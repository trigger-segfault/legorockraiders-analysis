#include "source_unfiltered_updated.h"
#include "datatypes_unfiltered_updated.h"
#include "functypes.h"
#include "globals.h"



void __cdecl lego::front::Advisor_Init(char *keyRoot,CameraData *structbc,void *ptr_1c)
{
	globals::g_AdvisorTypes_TABLE[0] = "Advisor_Objective";
	globals::g_AdvisorTypes_TABLE[1] = "Advisor_ObjectiveAcheived";
	globals::g_AdvisorTypes_TABLE[2] = "Advisor_ObjectiveFailed";
	globals::g_AdvisorTypes_TABLE[3] = "Advisor_IconPoint_Normal";
	globals::g_AdvisorTypes_TABLE[4] = "Advisor_IconPoint_BackButton";
	globals::g_AdvisorTypes_TABLE[5] = "Advisor_IconPoint_TopButtons";
	globals::g_AdvisorTypes_TABLE[6] = "Advisor_PanelPoint_RadarToggle";
	globals::g_AdvisorTypes_TABLE[7] = "Advisor_PanelPoint_RadarTaggedObjectView";
	globals::g_AdvisorTypes_TABLE[8] = "Advisor_PanelPoint_RadarZoomIn";
	globals::g_AdvisorTypes_TABLE[9] = "Advisor_PanelPoint_RadarZoomOut";
	globals::g_AdvisorTypes_TABLE[10] = "Advisor_PanelPoint_RadarMapView";
	globals::g_AdvisorTypes_TABLE[11] = "Advisor_PanelPoint_InfoDockGoto";
	globals::g_AdvisorTypes_TABLE[12] = "Advisor_PanelPoint_InfoDockClose";
	globals::g_AdvisorTypes_TABLE[13] = "Advisor_PanelPoint_TopPanelInfo";
	globals::g_AdvisorTypes_TABLE[14] = "Advisor_PanelPoint_TopPanelOptions";
	globals::g_AdvisorTypes_TABLE[15] = "Advisor_PanelPoint_TopPanelPriorities";
	globals::g_AdvisorTypes_TABLE[16] = "Advisor_PanelPoint_TopPanelCallToArms";
	globals::g_AdvisorTypes_TABLE[17] = "Advisor_PanelPoint_TopPanelGoBack";
	globals::g_AdvisorTypes_TABLE[18] = "Advisor_PanelPoint_ControlZoomIn";
	globals::g_AdvisorTypes_TABLE[19] = "Advisor_PanelPoint_ControlZoomOut";
	globals::g_AdvisorTypes_TABLE[20] = "Advisor_TalkInGame";
	globals::g_AdvisorAnimTypes_TABLE[0] = "Advisor_Anim_PointToMap";
	globals::g_AdvisorAnimTypes_TABLE[1] = "Advisor_Anim_Point_N";
	globals::g_AdvisorAnimTypes_TABLE[2] = "Advisor_Anim_Point_NE";
	globals::g_AdvisorAnimTypes_TABLE[3] = "Advisor_Anim_Point_E";
	globals::g_AdvisorAnimTypes_TABLE[4] = "Advisor_Anim_Point_SE";
	globals::g_AdvisorAnimTypes_TABLE[5] = "Advisor_Anim_Point_S";
	globals::g_AdvisorAnimTypes_TABLE[6] = "Advisor_Anim_Point_SW";
	globals::g_AdvisorAnimTypes_TABLE[7] = "Advisor_Anim_Point_W";
	globals::g_AdvisorAnimTypes_TABLE[8] = "Advisor_Anim_Point_NW";
	globals::g_AdvisorAnimTypes_TABLE[9] = "Advisor_Anim_Point_Up";
	globals::g_AdvisorAnimTypes_TABLE[10] = "Advisor_Anim_Talk_Top";
	globals::g_Advisor_ResRoot = structbc->resData1;
	globals::g_Advisor_ptr1c = ptr_1c;
	globals::g_Advisor_ResLight =
			 res::Container_MakeLight(structbc->resData1,D3DRMLIGHT_DIRECTIONAL,1.0,1.0,1.0);
	res::Container_SetOrientation
						(globals::g_Advisor_ResLight,structbc->resData1,0.0,0.0,-1.0,0.0,1.0,0.0);
	res::Container_Hide(globals::g_Advisor_ResLight,1);
	globals::g_Advisor_CurrentFlags = ADVISORSTATE_NONE;
	return;
}



void __cdecl lego::front::Advisor_Cleanup(void)
{
	if (globals::g_AdvisorAnimsData_TABLE
			[globals::g_AdvisorPositions_TABLE[globals::g_Advisor_CurrentType].animType].resData !=
			(Container *)0x0) {
		res::Container_Hide(globals::g_AdvisorAnimsData_TABLE
												[globals::g_AdvisorPositions_TABLE[globals::g_Advisor_CurrentType].animType]
												.resData,1);
	}
	globals::g_Advisor_CurrentFlags = globals::g_Advisor_CurrentFlags & ~ADVISORSTATE_UNK_1;
	res::Container_Hide(globals::g_Advisor_ResLight,1);
	return;
}



void __cdecl lego::front::Advisor_InitViewport(float param_unused)
{
	lego::view::Viewport_GetBackClip((Viewport *)globals::g_Advisor_ptr1c);
	lego::view::Viewport_GetFrontClip((Viewport *)globals::g_Advisor_ptr1c);
	globals::g_AdvisorPosition_Z = 0.96;
	return;
}



// sqrt(((a.x - b.x)*(a.x - b.x)) + ((a.y - b.y)*(a.y - b.y)))

float10 __cdecl lego::math::Vector2_Distance(Point2F *a,Point2F *b)
{
	float10 fVar1;
	float10 fVar2;
	
	fVar1 = (float10)a->y - (float10)b->y;
	fVar2 = (float10)a->x - (float10)b->x;
	return SQRT(fVar2 * fVar2 + fVar1 * (float10)(float)fVar1);
}



// <advisorType><animFileName>,<loopStart(seconds)>,<loopEnd(seconds)>
// NOTE last two parameters can be set to any value if the anim is not made to loop e.g. 0,0
// 
// Advisor_Anim_Point_Up  Mini-Figures\Captain\NEW_Captain_Point_CALL_T_ARMS,1.04,4.0
// Advisor_Anim_Talk_Top  Mini-Figures\Captain\NEW_Captain_Point_QTalk,1.04,2.4

void __cdecl lego::front::Advisor_LoadAdvisorAnims(CFGProperty *root,char *keyRoot)
{
	char *pcVar1;
	Container *cont;
	char **ppcVar2;
	AdvisorAnimData *pAVar3;
	float10 fVar4;
	char *stringParts [3];
	char buffer [64];
	
	pAVar3 = globals::g_AdvisorAnimsData_TABLE;
	ppcVar2 = globals::g_AdvisorAnimTypes_TABLE;
	do {
		pcVar1 = cfg::CFG_JoinPath(keyRoot,"Advisor",*ppcVar2,0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		if (pcVar1 == (char *)0x0) {
			if ((globs::mainGlobs.flags & CMD_REDUCEANIMATION) == CMD_NONE) {
				std::sprintf(buffer,"!%s",*ppcVar2);
				pcVar1 = cfg::CFG_JoinPath(keyRoot,"Advisor",*ppcVar2,0);
				pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			}
			if (pcVar1 != (char *)0x0) goto LAB_004012f0;
		}
		else {
LAB_004012f0:
			util::Util_Tokenise(pcVar1,stringParts,",");
			cont = res::Container_Load(globals::g_Advisor_ResRoot,stringParts[0],"LWS",1);
			pAVar3->resData = cont;
			if (cont != (Container *)0x0) {
				res::Container_SetOrientation(cont,globals::g_Advisor_ResRoot,0.0,0.0,1.0,0.0,1.0,0.0);
				res::Container_Hide(pAVar3->resData,1);
			}
			fVar4 = std::atof(stringParts[1]);
			pAVar3->loopStartTime = (float)(fVar4 * (float10)25.0);
			fVar4 = std::atof(stringParts[2]);
			pAVar3->loopEndTime = (float)(fVar4 * (float10)25.0);
		}
		ppcVar2 = ppcVar2 + 1;
		pAVar3 = pAVar3 + 1;
		if ((char **)((int)globals::g_AdvisorAnimTypes_TABLE + 0x2b) < ppcVar2) {
			return;
		}
	} while( true );
}



BOOL __cdecl lego::front::Advisor_GetAdvisorType(char *advisorName,AdvisorType *out_advisorType)
{
	int iVar1;
	char **ppcVar2;
	int index;
	
	index = 0;
	ppcVar2 = globals::g_AdvisorTypes_TABLE;
	do {
		iVar1 = std::_stricmp(*ppcVar2,advisorName);
		if (iVar1 == 0) {
			*out_advisorType = index;
			return 1;
		}
		ppcVar2 = (char **)((int)ppcVar2 + 4);
										// index++
		index = index + ADVISOR_OBJECTIVEACHIEVED;
										// index < ADVISOR__COUNT (21)
	} while (ppcVar2 < globals::g_AdvisorPositions_TABLE);
	return 0;
}



// out_vector = { (a.y * b.z) - (a.z * b.y),
//                (a.z * b.x) - (a.x * b.z),
//                (a.x * b.y) - (a.y * b.x) }

Vector3F * __cdecl lego::math::Vector3_CrossProduct(Vector3F *out_vector,Vector3F *a,Vector3F *b)
{
	out_vector->x = b->z * a->y - a->z * b->y;
	out_vector->y = a->z * b->x - b->z * a->x;
	out_vector->z = b->y * a->x - a->y * b->x;
	return out_vector;
}



BOOL __cdecl lego::front::Advisor_GetAnimType(char *animName,AdvisorAnimType *out_animType)
{
	int iVar1;
	char **ppcVar2;
	int index;
	
	index = 0;
	ppcVar2 = globals::g_AdvisorAnimTypes_TABLE;
	do {
		iVar1 = std::_stricmp((char *)*(Container **)ppcVar2,animName);
		if (iVar1 == 0) {
			*out_animType = index;
			return 1;
		}
		ppcVar2 = (char **)((int)ppcVar2 + 4);
										// index++
		index = index + ADVISORANIM_POINT_N;
										// index < ADVISORANIM__COUNT (11)
	} while (ppcVar2 < globals::g_AdvisorAnimsData_TABLE);
	return 0;
}



// out_vector = a + b

Vector3F * __cdecl lego::math::Vector3_Add(Vector3F *out_vector,Vector3F *a,Vector3F *b)
{
	out_vector->x = b->x + a->x;
	out_vector->y = a->y + b->y;
	out_vector->z = a->z + b->z;
	return out_vector;
}



// <positionType><animName>,<textName|NULL>,<sfxName|SFX_NULL>,<x(float)>,<y(float)>,<panelName|NULL>
// 
// Advisor_IconPoint_TopButtons    Advisor_Anim_Point_NE,NULL,SFX_NULL,-25,25,NULL
// Advisor_PanelPoint_RadarToggle  Advisor_Anim_Point_N,NULL,SFX_NULL,220,65,Panel_Radar

void __cdecl
lego::front::Advisor_LoadAdvisorPositions
					(CFGProperty *root,char *keyRoot,int screenWidth,int screenHeight)
{
	char *keyPath;
	CFGProperty *prop;
	BOOL BVar1;
	int iVar2;
	float10 fVar3;
	PanelType panelType;
	TextType textType;
	AdvisorAnimType animType;
	float x;
	float y;
	int sfxIndex;
	AdvisorType advisorIndex;
	char *stringParts [6];
	char advisorKeyPath [128];
	
	std::sprintf(advisorKeyPath,"AdvisorPositions%ix%i",screenWidth,screenHeight);
	keyPath = cfg::CFG_JoinPath(keyRoot,advisorKeyPath,0);
	for (prop = cfg::CFG_GetChildren(root,keyPath); prop != (CFGProperty *)0x0;
			prop = cfg::CFG_NextFlat(prop)) {
										// TEXT__COUNT (26)  treated as NULL
		textType = TEXT__COUNT;
										// PANEL__COUNT (12)  treated as NULL
		panelType = PANEL__COUNT;
		BVar1 = Advisor_GetAdvisorType(prop->key,&advisorIndex);
		if (BVar1 != 0) {
			util::Util_Tokenise(prop->value,stringParts,",");
			BVar1 = Advisor_GetAnimType(stringParts[0],&animType);
			if ((BVar1 != 0) &&
				 (((iVar2 = std::_stricmp("NULL",stringParts[1]), iVar2 == 0 ||
					 (BVar1 = Text_GetTextType(stringParts[1],&textType), BVar1 != 0)) &&
					(BVar1 = snd::SFX_GetType(stringParts[2],(SFXType *)&sfxIndex), BVar1 != 0)))) {
				fVar3 = std::atof(stringParts[3]);
				x = (float)fVar3;
				fVar3 = std::atof(stringParts[4]);
				y = (float)fVar3;
				iVar2 = std::_stricmp("NULL",stringParts[5]);
				if ((iVar2 == 0) || (BVar1 = Panel_GetPanelType(stringParts[5],&panelType), BVar1 != 0)) {
					Advisor_AddAdvisorPosition(advisorIndex,animType,textType,sfxIndex,panelType,x,y);
				}
			}
		}
	}
	return;
}



// out_vector = a - b

Vector3F * __cdecl lego::math::Vector3_Subtract(Vector3F *out_vector,Vector3F *a,Vector3F *b)
{
	out_vector->x = a->x - b->x;
	out_vector->y = a->y - b->y;
	out_vector->z = a->z - b->z;
	return out_vector;
}



// out_vector = a * scalar

Vector3F * __cdecl lego::math::Vector3_Scale(Vector3F *out_vector,Vector3F *a,float scalar)
{
	out_vector->x = scalar * a->x;
	out_vector->y = a->y * scalar;
	out_vector->z = a->z * scalar;
	return out_vector;
}



// ref_vector = ref_vector * (1.0 / modulus(ref_vector))
// REFERENCE: modulus(ref_vector) -> sqrt(dot_product(ref_vector, ref_vector))

Vector3F * __cdecl lego::math::Vector3_Normalize(Vector3F *ref_vector)
{
	float fVar1;
	
										// Vector3_Modulus (without 1.0 / _)
	fVar1 = 1.0 / SQRT(ref_vector->x * ref_vector->x +
										 ref_vector->z * ref_vector->z + ref_vector->y * ref_vector->y);
	ref_vector->x = fVar1 * ref_vector->x;
	ref_vector->y = fVar1 * ref_vector->y;
	ref_vector->z = fVar1 * ref_vector->z;
	return ref_vector;
}



void __cdecl
lego::front::Advisor_AddAdvisorPosition
					(AdvisorType advisorType,AdvisorAnimType animType,TextType textType,int sfxIndex,
					PanelType panelType,float x,float y)
{
	globals::g_AdvisorPositions_TABLE[advisorType].flags = ADVISORPOS_DEFAULT;
	globals::g_AdvisorPositions_TABLE[advisorType].animType = animType;
	globals::g_AdvisorPositions_TABLE[advisorType].textType = textType;
	globals::g_AdvisorPositions_TABLE[advisorType].sfxIndex = sfxIndex;
	globals::g_AdvisorPositions_TABLE[advisorType].point1.x = x;
	globals::g_AdvisorPositions_TABLE[advisorType].point1.y = y;
	globals::g_AdvisorPositions_TABLE[advisorType].point2.x = x;
	globals::g_AdvisorPositions_TABLE[advisorType].point2.y = y;
	globals::g_AdvisorPositions_TABLE[advisorType].panelType = panelType;
										// NULL panel
	if (panelType == PANEL__COUNT) {
		globals::g_AdvisorPositions_TABLE[advisorType].flags =
				 globals::g_AdvisorPositions_TABLE[advisorType].flags | ADVISORPOS_NOPANEL;
	}
										// non-NULL text
	if (textType != TEXT__COUNT) {
		globals::g_AdvisorPositions_TABLE[advisorType].flags =
				 globals::g_AdvisorPositions_TABLE[advisorType].flags | ADVISORPOS_HASTEXT;
	}
	return;
}



void __cdecl
lego::front::Advisor_SetParameters(AdvisorType advisorType,PanelType panelType,float x1,float y1)
{
	globals::g_AdvisorPositions_TABLE[advisorType].point1.x = x1;
	globals::g_AdvisorPositions_TABLE[advisorType].point1.y = y1;
	globals::g_AdvisorPositions_TABLE[advisorType].panelType = panelType;
										// NULL panel
	if (panelType == PANEL__COUNT) {
		globals::g_AdvisorPositions_TABLE[advisorType].flags =
				 globals::g_AdvisorPositions_TABLE[advisorType].flags | ADVISORPOS_NOPANEL;
		return;
	}
	globals::g_AdvisorPositions_TABLE[advisorType].flags =
			 globals::g_AdvisorPositions_TABLE[advisorType].flags & ~ADVISORPOS_NOPANEL;
	return;
}



void __cdecl lego::front::Advisor_GetPoint2(AdvisorType advisorType,float *out_x2,float *out_y2)
{
	*out_x2 = globals::g_AdvisorPositions_TABLE[advisorType].point2.x;
	*out_y2 = globals::g_AdvisorPositions_TABLE[advisorType].point2.y;
	return;
}



BOOL __cdecl lego::front::Advisor_SetCurrentAdvisor(AdvisorType advisorType,BOOL setFlag2)
{
	if ((((globals::g_AdvisorPositions_TABLE[advisorType].flags & ADVISORPOS_DEFAULT) !=
				ADVISORPOS_NONE) && (globals::g_Game.viewMode != VIEW_FIRSTPERSON)) &&
		 ((globals::g_Advisor_CurrentFlags & ADVISORSTATE_UNK_1) == ADVISORSTATE_NONE)) {
		globals::g_Advisor_CurrentType = advisorType;
		Advisor_SetCurrentSound(advisorType);
		if (setFlag2 != 0) {
			globals::g_Advisor_CurrentFlags =
					 globals::g_Advisor_CurrentFlags | (ADVISORSTATE_UNK_1|ADVISORSTATE_UNK_2);
			return 1;
		}
		globals::g_Advisor_CurrentFlags =
				 globals::g_Advisor_CurrentFlags & ~ADVISORSTATE_UNK_2 | ADVISORSTATE_UNK_1;
		return 1;
	}
	return 0;
}



void __cdecl lego::front::Advisor_SetCurrentSound(AdvisorType advisorType)
{
	Container *cont;
	
	cont = globals::g_AdvisorAnimsData_TABLE[globals::g_AdvisorPositions_TABLE[advisorType].animType].
				 resData;
	if (cont != (Container *)0x0) {
		res::Container_Hide(cont,0);
		res::Container_SetAnimationTime(cont,0.0);
		snd::Audio_Play_FUN_00465260(globals::g_AdvisorPositions_TABLE[advisorType].sfxIndex,0);
		snd::Audio_AddToSoundQueue1(SFX_CAPTAINSLIDE,0);
	}
	return;
}



void __cdecl lego::front::Advisor_Update(float elapsed)
{
	Container *cont;
	BOOL BVar1;
	AdvisorType advisorType;
	
	advisorType = globals::g_Advisor_CurrentType;
	cont = globals::g_AdvisorAnimsData_TABLE
				 [globals::g_AdvisorPositions_TABLE[globals::g_Advisor_CurrentType].animType].resData;
	if (cont != (Container *)0x0) {
		if (((globals::g_Advisor_CurrentFlags & ADVISORSTATE_UNK_1) != ADVISORSTATE_NONE) &&
			 (globals::g_Game.viewMode != VIEW_FIRSTPERSON)) {
			if ((globals::g_AdvisorPositions_TABLE[globals::g_Advisor_CurrentType].flags &
					ADVISORPOS_HASTEXT) != ADVISORPOS_NONE) {
				Text_DisplayMessage(globals::g_AdvisorPositions_TABLE[globals::g_Advisor_CurrentType].
														textType,1,0);
			}
			res::Container_Hide(cont,0);
			res::Container_Hide(globals::g_Advisor_ResLight,0);
			res::Container_Light_SetEnableContainer(globals::g_Advisor_ResLight,cont);
			Advisor_FUN_00401a70(advisorType);
			BVar1 = Advisor_FUN_004019b0(globals::g_AdvisorPositions_TABLE[advisorType].animType,elapsed);
			if (BVar1 != 0) {
				return;
			}
			globals::g_Advisor_CurrentFlags = globals::g_Advisor_CurrentFlags & ~ADVISORSTATE_UNK_1;
		}
		res::Container_Hide(cont,1);
	}
	res::Container_Hide(globals::g_Advisor_ResLight,1);
	return;
}



BOOL __cdecl lego::front::Advisor_FUN_004019b0(AdvisorAnimType animType,float elapsed)
{
	Container *cont;
	float10 fVar1;
	
	cont = globals::g_AdvisorAnimsData_TABLE[animType].resData;
	fVar1 = res::Container_MoveAnimation(cont,elapsed);
	if (((byte)globals::g_Advisor_CurrentFlags & ADVISORSTATE_UNK_2) == 0) {
		if ((ushort)((ushort)(fVar1 < (float10)0.0) << 8 | (ushort)(fVar1 == (float10)0.0) << 0xe) == 0)
		{
			return 0;
		}
	}
	else {
		if ((ushort)((ushort)(fVar1 < (float10)0.0) << 8 | (ushort)(fVar1 == (float10)0.0) << 0xe) == 0)
		{
			res::Container_SetAnimationTime
								(cont,(float)((float10)globals::g_AdvisorAnimsData_TABLE[animType].loopStartTime +
														 fVar1));
			return 1;
		}
		fVar1 = res::Container_GetAnimationTime(cont);
		if ((float10)globals::g_AdvisorAnimsData_TABLE[animType].loopEndTime <= fVar1) {
			res::Container_SetAnimationTime
								(cont,(float)((fVar1 - (float10)globals::g_AdvisorAnimsData_TABLE[animType].
																								loopEndTime) +
														 (float10)globals::g_AdvisorAnimsData_TABLE[animType].loopStartTime));
			return 1;
		}
	}
	return 1;
}



void __cdecl lego::front::Advisor_ClearFlag2(void)
{
	globals::g_Advisor_CurrentFlags = globals::g_Advisor_CurrentFlags & ~ADVISORSTATE_UNK_2;
	return;
}



void __cdecl lego::front::Advisor_FUN_00401a70(AdvisorType advisorType)
{
	Container *cont;
	AdvisorType AVar1;
	float y;
	Vector3F vector;
	Vector4F transform4d;
	
	AVar1 = advisorType;
	cont = globals::g_AdvisorAnimsData_TABLE[globals::g_AdvisorPositions_TABLE[advisorType].animType].
				 resData;
	if ((globals::g_AdvisorPositions_TABLE[advisorType].flags & ADVISORPOS_NOPANEL) == ADVISORPOS_NONE
		 ) {
										// output -> x, y (get panel position?)
		Panel_GetXYField3(globals::g_AdvisorPositions_TABLE[advisorType].panelType,(float *)&advisorType
											,&y);
	}
	else {
		advisorType = ADVISOR_OBJECTIVE;
		y = 0.0;
	}
	transform4d.x = globals::g_AdvisorPositions_TABLE[AVar1].point1.x + (float)advisorType;
	transform4d.z = globals::g_AdvisorPosition_Z;
	transform4d.y = globals::g_AdvisorPositions_TABLE[AVar1].point1.y + y;
	transform4d.w = 1.0;
	lego::view::Viewport_InverseTransform((Viewport *)globals::g_Advisor_ptr1c,&vector,&transform4d);
	res::Container_SetPosition(cont,(Container *)0x0,vector.x,vector.y,vector.z);
	return;
}



ProgrammerMode __cdecl lego::main::GetProgrammerMode(void)
{
	return globs::mainGlobs.programmerLevel;
}



char * __cdecl lego::main::GetStartLevel(void)
{
	return (char *)(-(uint)((globs::mainGlobs.flags & CMD_STARTLEVEL) != CMD_NONE) & 0x506f8c);
}



BOOL __cdecl lego::front::Advisor_GetFlag1(void)
{
	return globals::g_Advisor_CurrentFlags & ADVISORSTATE_UNK_1;
}



int __cdecl lego::main::GetResolutionWidth(void)
{
	return globs::mainGlobs.appWidth;
}



int __cdecl lego::main::GetResolutionHeight(void)
{
	return globs::mainGlobs.appHeight;
}



uint __cdecl lego::image::FontX_GetStringWidth(ImageFont *font,char *msg,...)
{
	Font_VGetStringInfo(font,(uint *)&font,(uint *)0x0,msg,&stack0x0000000c);
	return (uint)font;
}



void __cdecl
lego::unk::UnkFont_FUN_00401bc0(ImageFont *font,uint *out_width,uint *out_lineCount,char *msg,...)
{
	image::Font_VGetStringInfo(font,out_width,out_lineCount,msg,&stack0x00000014);
	return;
}



BOOL __cdecl lego::ai::AIPriority_GetType(char *aiPriorityName,AIPriorityType *out_priorityType)
{
	int iVar1;
	char **ppcVar2;
	AIPriorityType AVar3;
	
	AVar3 = AIPRIORITY_CRYSTAL;
	ppcVar2 = globals::g_AIPriorities_TABLE;
	do {
		iVar1 = std::_stricmp(aiPriorityName,*ppcVar2);
		if (iVar1 == 0) {
			*out_priorityType = AVar3;
			return 1;
		}
		ppcVar2 = ppcVar2 + 1;
		AVar3 = AVar3 + AIPRIORITY_ORE;
	} while (ppcVar2 < globals::g_AIPriorityValues_TABLE);
	return 0;
}



void __cdecl lego::pool::ReservedPool_AITask___Init(void)
{
	int iVar1;
	AITaskData **ppAVar2;
	uint *puVar3;
	
	ppAVar2 = globals::ReservedPool_AITask___g_TABLE;
	for (iVar1 = 0xc; iVar1 != 0; iVar1 = iVar1 + -1) {
		*ppAVar2 = (AITaskData *)0x0;
		ppAVar2 = ppAVar2 + 1;
	}
	lego::globals::g_AITaskTypes_TABLE[0] = "AITask_Type_Goto";
	lego::globals::g_AITaskTypes_TABLE[1] = "AITask_Type_Follow";
	lego::globals::g_AITaskTypes_TABLE[2] = "AITask_Type_FollowAttack";
	lego::globals::g_AITaskTypes_TABLE[3] = "AITask_Type_Collect";
	lego::globals::g_AITaskTypes_TABLE[4] = "AITask_Type_Gather";
	lego::globals::g_AITaskTypes_TABLE[12] = "AITask_Type_Clear";
	lego::globals::g_AITaskTypes_TABLE[5] = "AITask_Type_Deposit";
	lego::globals::g_AITaskTypes_TABLE[6] = "AITask_Type_Dump";
	lego::globals::g_AITaskTypes_TABLE[7] = "AITask_Type_Request";
	lego::globals::g_AITaskTypes_TABLE[10] = "AITask_Type_Repair";
	lego::globals::g_AITaskTypes_TABLE[8] = "AITask_Type_Dig";
	lego::globals::g_AITaskTypes_TABLE[9] = "AITask_Type_Dynamite";
	lego::globals::g_AITaskTypes_TABLE[11] = "AITask_Type_Reinforce";
	lego::globals::g_AITaskTypes_TABLE[13] = "AITask_Type_Wait";
	lego::globals::g_AITaskTypes_TABLE[14] = "AITask_Type_AnimationWait";
	lego::globals::g_AITaskTypes_TABLE[15] = "AITask_Type_ElecFence";
	lego::globals::g_AITaskTypes_TABLE[16] = "AITask_Type_Eat";
	lego::globals::g_AITaskTypes_TABLE[17] = "AITask_Type_GotoEat";
	lego::globals::g_AITaskTypes_TABLE[18] = "AITask_Type_FindDriver";
	lego::globals::g_AITaskTypes_TABLE[19] = "AITask_Type_GetTool";
	lego::globals::g_AITaskTypes_TABLE[20] = "AITask_Type_BirdScarer";
	lego::globals::g_AITaskTypes_TABLE[21] = "AITask_Type_Upgrade";
	lego::globals::g_AITaskTypes_TABLE[22] = "AITask_Type_BuildPath";
	lego::globals::g_AITaskTypes_TABLE[23] = "AITask_Type_Train";
	lego::globals::g_AITaskTypes_TABLE[24] = "AITask_Type_Depart";
	lego::globals::g_AITaskTypes_TABLE[25] = "AITask_Type_AttackPath";
	lego::globals::g_AITaskTypes_TABLE[26] = "AITask_Type_AttackRockMonster";
	lego::globals::g_AITaskTypes_TABLE[27] = "AITask_Type_Recharge";
	lego::globals::g_AITaskTypes_TABLE[28] = "AITask_Type_Dock";
	lego::globals::g_AITaskTypes_TABLE[29] = "AITask_Type_AttackObject";
	lego::globals::g_AITaskTypes_TABLE[30] = "AITask_Type_FindLoad";
	lego::globals::g_AIPriorities_TABLE[0] = "AI_Priority_Crystal";
	lego::globals::g_AIPriorities_TABLE[1] = "AI_Priority_Ore";
	lego::globals::g_AIPriorities_TABLE[2] = "AI_Priority_DefaultCollect";
	lego::globals::g_AIPriorities_TABLE[3] = "AI_Priority_Destruction";
	lego::globals::g_AIPriorities_TABLE[4] = "AI_Priority_Construction";
	lego::globals::g_AIPriorities_TABLE[5] = "AI_Priority_Request";
	lego::globals::g_AIPriorities_TABLE[6] = "AI_Priority_Reinforce";
	lego::globals::g_AIPriorities_TABLE[7] = "AI_Priority_Repair";
	lego::globals::g_AIPriorities_TABLE[8] = "AI_Priority_Clearing";
	lego::globals::g_AIPriorities_TABLE[9] = "AI_Priority_Storage";
	lego::globals::g_AIPriorities_TABLE[10] = "AI_Priority_Refining";
	lego::globals::g_AIPriorities_TABLE[11] = "AI_Priority_HealthLow";
	lego::globals::g_AIPriorities_TABLE[12] = "AI_Priority_GetIn";
	lego::globals::g_AIPriorities_TABLE[13] = "AI_Priority_Upgrade";
	lego::globals::g_AIPriorities_TABLE[14] = "AI_Priority_BuildPath";
	lego::globals::g_AIPriorities_TABLE[15] = "AI_Priority_AttackRockMonster";
	lego::globals::g_AIPriorities_TABLE[16] = "AI_Priority_Barrier";
	lego::globals::g_AIPriorities_TABLE[17] = "AI_Priority_FindLoad";
	lego::globals::g_AIPriorities_TABLE[18] = "AI_Priority_Recharge";
	lego::globals::g_AIPriorities_TABLE[19] = "AI_Priority_UpgradeBuilding";
	lego::globals::g_AIPriorities_TABLE[20] = "AI_Priority_Gather";
	lego::globals::g_AIPriorities_TABLE[21] = "AI_Priority_Steal";
	lego::globals::g_AIPriorities_TABLE[22] = "AI_Priority_Punch";
	lego::globals::g_AIPriorities_TABLE[23] = "AI_Priority_Depart";
	lego::globals::g_AIPriorities_TABLE[24] = "AI_Priority_AttackPath";
	lego::globals::g_AIPriorities_TABLE[26] = "AI_Priority_Congregate";
	lego::globals::g_AIPriorities_TABLE[25] = "AI_Priority_AttackObject";
	puVar3 = lego::globals::g_AIPriorityValues_TABLE;
	for (iVar1 = 0x1b; iVar1 != 0; iVar1 = iVar1 + -1) {
		*puVar3 = 0x31;
		puVar3 = puVar3 + 1;
	}
	globals::ReservedPool_AITask___g_NEXT = (AITaskData *)0x0;
	globals::ReservedPool_AITask___g_COUNT = 0;
	lego::globals::g_AIPriorityValues_TABLE[0] = 0x37;
	lego::globals::g_AIPriorityValues_TABLE[3] = 0x28;
	lego::globals::g_AIPriorityValues_TABLE[4] = 0x3c;
	lego::globals::g_AIPriorityValues_TABLE[5] = 0x14;
	lego::globals::g_AIPriorityValues_TABLE[6] = 0x46;
	lego::globals::g_AIPriorityValues_TABLE[8] = 0x14;
	lego::globals::g_AIPriorityValues_TABLE[9] = 5;
	lego::globals::g_AIPriorityValues_TABLE[10] = 0xf;
	lego::globals::g_AIPriorityValues_TABLE[15] = 0x38;
	lego::globals::g_AIPriorityValues_TABLE[19] = 99;
	lego::globals::g_AIPriorityValues_TABLE[20] = 0x31;
	lego::globals::g_AIPriorityValues_TABLE[21] = 0x5a;
	lego::globals::g_AIPriorityValues_TABLE[22] = 0x31;
	lego::globals::g_AIPriorityValues_TABLE[23] = 0;
	lego::globals::g_AIPriorityValues_TABLE[24] = 0x14;
	lego::globals::g_AIPriorityValues_TABLE[25] = 0x1e;
	lego::globals::g_AIPriorityValues_TABLE[26] = 99;
	globals::ReservedPool_AITask___g_INITFLAGS = 1;
	return;
}



void __cdecl
lego::ai::AITask_FUN_00401f40(AITaskType taskType,LiveObject *liveObj,Point2I *opt_position)
{
	AITaskData **ppAVar1;
	AITaskData *pAVar2;
	
	pAVar2 = globals::g_AITaskUnkPtr;
	if (globals::g_AITaskUnkPtr != (AITaskData *)0x0) {
		do {
			if (pAVar2->taskType == taskType) {
				if ((liveObj != (LiveObject *)0x0) && (liveObj == pAVar2->object_10)) {
					pAVar2->flags_5c = pAVar2->flags_5c | 0x10000;
				}
				if (((opt_position != (Point2I *)0x0) && (opt_position->x == (pAVar2->position).x)) &&
					 (opt_position->y == (pAVar2->position).y)) {
					pAVar2->flags_5c = pAVar2->flags_5c | 0x10000;
				}
			}
			ppAVar1 = &pAVar2->next;
			pAVar2 = *ppAVar1;
		} while (*ppAVar1 != (AITaskData *)0x0);
	}
	return;
}



void __cdecl lego::ai::AITask_SetPriorityType(AITaskData *aiTask,AIPriorityType priorityType)
{
	uint uVar1;
	
	if ((aiTask->flags_5c & 0x30000) == 0) {
		uVar1 = globals::g_AIPriorityValues_TABLE[priorityType];
		aiTask->priorityType = priorityType;
		aiTask->priorityValue = uVar1;
		return;
	}
	aiTask->priorityValue = 99;
	aiTask->priorityType = priorityType;
	return;
}



void __cdecl lego::game::Game_SetAITaskValue2(int index,uint aiTaskValue)
{
	globals::g_AIPriorityValues_TABLE[index] = aiTaskValue;
	return;
}



void __cdecl lego::game::Game_SetIsPriorityDisabled(int priorityIndex,BOOL isDisabled)
{
	globals::g_Priorities_bool2_TABLE[priorityIndex] = isDisabled;
	return;
}



BOOL __cdecl lego::game::Game_IsPriorityDisabled(int priorityIndex)
{
	return globals::g_Priorities_bool2_TABLE[priorityIndex];
}



void __cdecl lego::pool::ReservedPool_AITask___Cleanup(void)
{
	AITaskData **ppAVar1;
	
	ppAVar1 = globals::ReservedPool_AITask___g_TABLE;
	do {
		if (*ppAVar1 != (AITaskData *)0x0) {
			std::free(*ppAVar1);
		}
		ppAVar1 = ppAVar1 + 1;
	} while (ppAVar1 < &globals::ReservedPool_AITask___g_NEXT);
	globals::ReservedPool_AITask___g_NEXT = (AITaskData *)0x0;
	globals::ReservedPool_AITask___g_INITFLAGS = 0;
	return;
}



void __cdecl lego::ai::AITask_FUN_00402040(BOOL param_1)
{
	int iVar1;
	undefined4 *puVar2;
	BOOL *pBVar3;
	
	if (param_1 != 0) {
		pool::globals::ReservedPool_AITask___g_INITFLAGS =
				 pool::globals::ReservedPool_AITask___g_INITFLAGS & 0xfffffffd;
		return;
	}
	AITask_DoUnkCallbacks(AITask_Release_0,(LiveObject *)0x0);
	pool::globals::ReservedPool_AITask___g_INITFLAGS =
			 pool::globals::ReservedPool_AITask___g_INITFLAGS | 2;
	globals::g_AITaskUnkPtr = (AITaskData *)0x0;
	globals::g_AITaskDataNext = (AITaskData *)0x0;
	puVar2 = &DAT_004b44f4;
	for (iVar1 = 0x12c0; iVar1 != 0; iVar1 = iVar1 + -1) {
		*puVar2 = 0;
		puVar2 = puVar2 + 1;
	}
	pBVar3 = globals::g_Priorities_bool2_TABLE;
	for (iVar1 = 0x1b; iVar1 != 0; iVar1 = iVar1 + -1) {
		*pBVar3 = 0;
		pBVar3 = pBVar3 + 1;
	}
	return;
}



void __cdecl lego::game::Level_SetNoGather(BOOL noGather)
{
	AITaskData *pAVar1;
	
	if (noGather == 0) {
		ai::AITask_DoGather_Count(0);
	}
	pAVar1 = pool::ReservedPool_AITask___Next(AITASK_DEPART);
	ai::AITask_SetPriorityType(pAVar1,AIPRIORITY_DEPART);
	pAVar1->flags_5c = pAVar1->flags_5c | 0x40;
	pAVar1->next = globals::g_AITaskDataNext;
	globals::g_AITaskDataNext = pAVar1;
	pAVar1 = pool::ReservedPool_AITask___Next(AITASK_RECHARGE);
	ai::AITask_InitTask_1(pAVar1,AIPRIORITY_CRYSTAL);
	pAVar1->flags_5c = pAVar1->flags_5c & 0xffffffef | 0x440;
	return;
}



BOOL __cdecl lego::ai::AITask_Release_0(AITaskData *aiTask)
{
	pool::ReservedPool_AITask___Release(aiTask,1);
	return 0;
}



void __cdecl lego::util::free2(undefined *param_1)
{
	std::free(param_1);
	return;
}



void __cdecl lego::ai::AITask_FUN_00402150(float elapsedGame)
{
	float fVar1;
	AITaskData *pAVar2;
	uint uVar3;
	uint uVar4;
	
	uVar4 = globals::g_AIPriorityValues_TABLE[1];
	if ((int)globals::g_AIPriorityValues_TABLE[1] <= (int)globals::g_AIPriorityValues_TABLE[0]) {
		uVar4 = globals::g_AIPriorityValues_TABLE[0];
	}
	uVar3 = globals::g_AIPriorityValues_TABLE[4];
	if (((int)globals::g_AIPriorityValues_TABLE[4] < (int)uVar4) &&
		 (uVar3 = globals::g_AIPriorityValues_TABLE[0],
		 (int)globals::g_AIPriorityValues_TABLE[0] < (int)globals::g_AIPriorityValues_TABLE[1])) {
		uVar3 = globals::g_AIPriorityValues_TABLE[1];
	}
	globals::g_AIPriorityValues_TABLE[16] = uVar3 + 1;
	if ((pool::globals::ReservedPool_AITask___g_INITFLAGS & 0x80000000) == 0) {
		AITask_DoUnkCallbacks(AITask_FUN_00404180,(LiveObject *)&elapsedGame);
		for (pAVar2 = globals::g_AITaskUnkPtr; pAVar2 != (AITaskData *)0x0; pAVar2 = pAVar2->next) {
			if (((pAVar2->taskType == AITASK_REPAIR) && ((pAVar2->flags_5c & 0x200000) == 0)) &&
				 ((fVar1 = pAVar2->object_10->health,
					(ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) != 0 ||
					(100.0 <= pAVar2->object_10->health)))) {
				pAVar2->flags_5c = pAVar2->flags_5c | 0x20;
			}
		}
		AITask_FUN_00402240(&globals::g_AITaskUnkPtr);
		AITask_FUN_00402240(&globals::g_AITaskDataNext);
		INT_004b4424 = 0;
		UINT_004b44f0 = 0;
		unk::DoLiveObjCallbacks_True_FUN_00437a70(game::LiveObject_DoAITask,(LiveObject *)&elapsedGame);
		FUN_00405b40();
		FUN_00405880();
	}
	return;
}



void __cdecl lego::ai::AITask_FUN_00402240(AITaskData **ref_aiTask)
{
	AITaskData **ppAVar1;
	AITaskData *pAVar2;
	AITaskData *pAVar3;
	uint uVar4;
	bool bVar5;
	AITaskData **ppAVar6;
	BOOL BVar7;
	int iVar8;
	int iVar9;
	int iVar10;
	AITaskData *pAVar11;
	uint number;
	int *piVar12;
	AITaskData *local_4dc;
	int local_4d0 [5];
	undefined4 local_4bc;
	undefined4 local_4b8;
	undefined4 local_4b4;
	AITaskData *local_4b0 [300];
	
	local_4dc = (AITaskData *)0x0;
	pAVar2 = *ref_aiTask;
	pAVar11 = (AITaskData *)0x0;
	while (pAVar3 = pAVar11, pAVar11 = pAVar2, pAVar11 != (AITaskData *)0x0) {
		pAVar2 = pAVar11->next;
		if ((*(byte *)&pAVar11->flags_5c & 0x20) != 0) {
			if (pAVar3 == (AITaskData *)0x0) {
				*ref_aiTask = pAVar2;
				pool::ReservedPool_AITask___Release(pAVar11,0);
				pAVar11 = pAVar3;
			}
			else {
				pAVar3->next = pAVar2;
				pool::ReservedPool_AITask___Release(pAVar11,0);
				pAVar11 = pAVar3;
			}
		}
	}
	number = 0;
	pAVar2 = local_4dc;
	if (*ref_aiTask != (AITaskData *)0x0) {
		ppAVar6 = local_4b0;
		pAVar11 = *ref_aiTask;
		do {
			pAVar3 = pAVar11->next;
			pAVar2 = pAVar11;
			if (number == 300) break;
			*ppAVar6 = pAVar11;
			ppAVar6 = ppAVar6 + 1;
			number = number + 1;
			if ((globals::g_Priorities_bool2_TABLE[pAVar11->priorityType] == 0) ||
				 ((pAVar11->flags_5c & 0x10000) != 0)) {
				uVar4 = pAVar11->flags_5c;
				pAVar11->flags_5c = uVar4 & 0xfff7ffff;
				if ((uVar4 & 0x30000) == 0) {
					pAVar11->priorityValue = globals::g_AIPriorityValues_TABLE[pAVar11->priorityType];
				}
				else {
					pAVar11->priorityValue = 99;
				}
			}
			else {
				pAVar11->flags_5c = pAVar11->flags_5c | 0x80000;
			}
			if (pAVar11->taskType == AITASK_DIG) {
				if ((*(byte *)&pAVar11->flags_5c & 8) == 0) {
					BVar7 = FUN_00432e70((pAVar11->position).x,(pAVar11->position).y);
					if (BVar7 != 0) {
						pAVar11->priorityValue = 0;
					}
				}
				else {
					local_4d0[0] = 0;
					local_4d0[1] = 0;
					local_4d0[2] = 0;
					local_4b4 = 0;
					local_4d0[3] = 0xffffffff;
					local_4d0[4] = 0xffffffff;
					local_4bc = 0xffffffff;
					local_4b8 = 0xffffffff;
					bVar5 = false;
					piVar12 = local_4d0;
					iVar10 = 4;
					do {
						BVar7 = game::Level_GetBlockFlags1_10Not8
															(*piVar12 + (pAVar11->position).x,piVar12[1] + (pAVar11->position).y);
						if (BVar7 != 0) {
							bVar5 = true;
						}
						piVar12 = piVar12 + 2;
						iVar10 = iVar10 + -1;
					} while (iVar10 != 0);
					if (bVar5) {
						if (pAVar11->priorityValue == 0) {
							pAVar11->float_18 = (float)&DAT_42c80000;
						}
					}
					else {
						pAVar11->priorityValue = 0;
					}
				}
			}
			pAVar11 = pAVar3;
			pAVar2 = local_4dc;
		} while (pAVar3 != (AITaskData *)0x0);
	}
	local_4dc = pAVar2;
	if (number != 0) {
		std::qsort(local_4b0,number,4,AITask_QSortCompare);
		iVar10 = number - 1;
		iVar9 = 0;
		if (iVar10 != 0) {
			ppAVar6 = local_4b0;
			iVar8 = iVar10;
			do {
				pAVar2 = *ppAVar6;
				ppAVar1 = ppAVar6 + 1;
				ppAVar6 = ppAVar6 + 1;
				iVar8 = iVar8 + -1;
				pAVar2->next = *ppAVar1;
				iVar9 = iVar10;
			} while (iVar8 != 0);
		}
		local_4b0[iVar9]->next = local_4dc;
		*ref_aiTask = local_4b0[0];
	}
	return;
}



void __cdecl lego::ai::AITask_DoDig_AtPosition(Point2I *position,BOOL param_2,BOOL param_3)
{
	LevelData *pLVar1;
	uint uVar2;
	BOOL BVar3;
	AITaskData *aiTask;
	int iVar4;
	
	pLVar1 = game::GetLevel();
	uVar2 = game::Level_IsBlockSolid(position);
	if (uVar2 == 0) {
		uVar2 = game::Level_IsBlockLava(position);
		if (uVar2 == 0) {
			BVar3 = FUN_00432ec0(position->x,position->y);
			if (BVar3 != 0) {
				aiTask = pool::ReservedPool_AITask___Next(AITASK_DIG);
				(aiTask->position).x = position->x;
				(aiTask->position).y = position->y;
				if (param_2 != 0) {
					aiTask->flags_5c = aiTask->flags_5c | 8;
				}
				AITask_UnkInitRouting_FUN_00402530(aiTask,1);
				AITask_InitTask_1(aiTask,AIPRIORITY_DESTRUCTION);
				uVar2 = aiTask->flags_5c;
				aiTask->flags_5c = uVar2 | 0x80;
				if (param_3 != 0) {
					aiTask->flags_5c = uVar2 | 0x20080;
				}
				if (param_2 == 0) {
					game::SurfaceMap_FUN_0044f7a0(pLVar1->surfaceMap,position->x,position->y,1);
					iVar4 = (pLVar1->dimensions).width * position->y + position->x;
					pLVar1->blocks[iVar4].flags1 = pLVar1->blocks[iVar4].flags1 | 0x800000;
				}
			}
		}
	}
	return;
}



void __cdecl lego::ai::AITask_UnkInitRouting_FUN_00402530(AITaskData *aiTask,BOOL param_2)
{
	uint *out_unitsCount;
	LiveObject **out_unitsTable;
	BOOL BVar1;
	uint uVar2;
	
	BVar1 = game::Game_IsAnyUnitsSelected();
	if (BVar1 != 0) {
		out_unitsCount = &aiTask->field_44;
		out_unitsTable = (LiveObject **)&aiTask->ptr_40;
		aiTask->flags_5c = aiTask->flags_5c | 0x140;
		game::Game_CopySelectedUnits(out_unitsTable,out_unitsCount);
		uVar2 = 0;
		if (*out_unitsCount != 0) {
			do {
				game::LiveObject_UnkDoRouting_FUN_00441c00
									((LiveObject *)(*out_unitsTable)->floats_34[uVar2 - 0xd],0);
				if (param_2 != 0) {
					game::LiveObject_FUN_0043a130((LiveObject *)(*out_unitsTable)->floats_34[uVar2 - 0xd],0);
				}
				uVar2 = uVar2 + 1;
			} while (uVar2 < *out_unitsCount);
		}
	}
	return;
}



void __cdecl lego::ai::AITask_DoAttackRockMonster_Target(LiveObject *targetObj)
{
	BOOL BVar1;
	AITaskData *aiTask;
	
	game::GetLevel();
	if (targetObj != (LiveObject *)0x0) {
		BVar1 = game::LiveObject_CanShootObject(targetObj);
		if (BVar1 != 0) {
			aiTask = pool::ReservedPool_AITask___Next(AITASK_ATTACKROCKMONSTER);
			AITask_InitTask_1(aiTask,AIPRIORITY_ATTACKROCKMONSTER);
			aiTask->object_10 = targetObj;
			aiTask->flags_5c = aiTask->flags_5c & 0xffffffef | 0x40040;
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_004025f0(LiveObject *liveObj)
{
	BOOL BVar1;
	
	if ((liveObj->carryingThisObject == (LiveObject *)0x0) &&
		 ((liveObj->flags4 & 0x100) == LIVEOBJ4_NONE)) {
		BVar1 = ai::AITask_DoUnkCallbacks(ai::AITask_IsCollectAndSameTarget,liveObj);
		if (BVar1 == 0) {
			ai::AITask_DoCollect(liveObj,0.0);
		}
	}
	return;
}



BOOL __cdecl lego::ai::AITask_IsCollectAndSameTarget(AITaskData *aiTask,LiveObject *liveObj)
{
	if ((aiTask->taskType == AITASK_COLLECT) && (aiTask->object_10 == liveObj)) {
		return 1;
	}
	return 0;
}



void __cdecl lego::ai::AITask_DoCollect(LiveObject *liveObj,float param_2)
{
	ObjectType OVar1;
	AITaskData *aiTask;
	AIPriorityType priorityType;
	
	priorityType = AIPRIORITY_DEFAULTCOLLECT;
	aiTask = pool::ReservedPool_AITask___Next(AITASK_COLLECT);
	aiTask->object_10 = liveObj;
	aiTask->float_18 = param_2;
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_POWERCRYSTAL) {
		priorityType = -(uint)((liveObj->flags3 & LIVEOBJ3_UNK_80000000) != LIVEOBJ3_NONE) & 0x12;
	}
	else {
		if (OVar1 == OBJECT_ORE) {
			priorityType = AIPRIORITY_ORE;
		}
		else {
			if (OVar1 == OBJECT_BARRIER) {
				priorityType = AIPRIORITY_BARRIER;
			}
			else {
				if (OVar1 == OBJECT_DYNAMITE) {
					aiTask->mode_3c = 8;
					priorityType = AIPRIORITY_DESTRUCTION;
				}
			}
		}
	}
	AITask_InitTask_1(aiTask,priorityType);
	AITask_DoCollect_Target(liveObj);
	return;
}



void __cdecl lego::ai::AITask_DoBuildPath_AtPosition(Point2I *position)
{
	BOOL BVar1;
	int iVar2;
	AITaskData *aiTask;
	
	BVar1 = game::Level_IsBlockPowerPath(position);
	if (BVar1 == 0) {
		iVar2 = game::Level_GetBlockRubbleLevel_OrFlag200000(position);
		if (iVar2 == 0) {
			BVar1 = game::Object_Dependencies_FUN_0040add0(OBJECT_PATH,0,0);
			if (BVar1 != 0) {
				aiTask = pool::ReservedPool_AITask___Next(AITASK_BUILDPATH);
				(aiTask->position).x = position->x;
				(aiTask->position).y = position->y;
				AITask_InitTask_1(aiTask,AIPRIORITY_BUILDPATH);
			}
		}
	}
	return;
}



void __cdecl lego::ai::AITask_DoGather_Count(int count)
{
	AITaskData *aiTask;
	bool bVar1;
	
	bVar1 = count == 0;
	if (bVar1) {
		count = 1;
	}
	do {
		aiTask = pool::ReservedPool_AITask___Next(AITASK_GATHER);
		AITask_SetPriorityType(aiTask,AIPRIORITY_GATHER);
		if (bVar1) {
			aiTask->flags_5c = aiTask->flags_5c | 0x40;
		}
		AITask_Init_2_NoPriority(aiTask);
		count = count + -1;
	} while (count != 0);
	return;
}



void __cdecl lego::ai::AITask_DoCollect_Target(LiveObject *targetObj)
{
	AITaskData *aiTask;
	
	if (targetObj->objType == OBJECT_POWERCRYSTAL) {
		aiTask = pool::ReservedPool_AITask___Next(AITASK_COLLECT);
		aiTask->object_10 = targetObj;
		AITask_SetPriorityType(aiTask,AIPRIORITY_STEAL);
		AITask_Init_2_NoPriority(aiTask);
		aiTask->flags_5c = aiTask->flags_5c | 0x2000;
	}
	return;
}



void __cdecl
lego::ai::AITask_DoTrain_Target(LiveObject *targetObj,TrainedFlags training,BOOL param_3)
{
	BOOL BVar1;
	AITaskData *aiTask;
	AIPriorityType priorityType;
	
	BVar1 = game::LiveObject_HasTraining(targetObj,training);
	if (BVar1 != 0) {
		aiTask = pool::ReservedPool_AITask___Next(AITASK_TRAIN);
		aiTask->object_10 = targetObj;
		aiTask->mode_3c = training;
		switch(training) {
		case TRAINED_PILOT:
		case TRAINED_SAILOR:
		case TRAINED_DRIVER:
			priorityType = AIPRIORITY_GETIN;
			break;
		default:
			priorityType = AIPRIORITY_UPGRADE;
			break;
		case TRAINED_DYNAMITE:
			priorityType = AIPRIORITY_DESTRUCTION;
			break;
		case TRAINED_REPAIR:
			priorityType = AIPRIORITY_REPAIR;
			break;
		case TRAINED_SCANNER:
			priorityType = AIPRIORITY_CONSTRUCTION;
		}
		if (param_3 != 0) {
			AITask_UnkInitRouting_FUN_00402530(aiTask,1);
		}
		AITask_InitTask_1(aiTask,priorityType);
		aiTask->flags_5c = aiTask->flags_5c & 0xffffffbf;
	}
	return;
}



void __cdecl lego::ai::AITask_DoFindDriver_Target(LiveObject *targetObj)
{
	AITaskData *aiTask;
	ObjectStatsFlags3 OVar1;
	ObjectStatsFlags1 OVar2;
	
	if ((*(byte *)&targetObj->flags2 & LIVEOBJ2_UNK_10) == 0) {
		aiTask = pool::ReservedPool_AITask___Next(AITASK_FINDDRIVER);
		aiTask->object_10 = targetObj;
		targetObj->flags2 = targetObj->flags2 | LIVEOBJ2_UNK_10;
		OVar1 = game::LiveObject_GetStatsFlags3(targetObj);
		if ((OVar1 & STATS3_NEEDSPILOT) == STATS3_NONE) {
			OVar2 = game::LiveObject_GetStatsFlags1(targetObj);
			if ((OVar2 & STATS1_CROSSLAND) == STATS1_NONE) {
				OVar2 = game::LiveObject_GetStatsFlags1(targetObj);
				if ((OVar2 & STATS1_CROSSWATER) != STATS1_NONE) {
					aiTask->mode_3c = 2;
				}
			}
			else {
				OVar2 = game::LiveObject_GetStatsFlags1(targetObj);
				if ((OVar2 & STATS1_CROSSWATER) == STATS1_NONE) {
					aiTask->mode_3c = 4;
				}
				else {
					aiTask->mode_3c = 1;
				}
			}
		}
		else {
			aiTask->mode_3c = 1;
		}
		OVar1 = game::LiveObject_GetStatsFlags3(targetObj);
		if (((OVar1 & STATS3_TAKECARRYINGDRIVERS) != STATS3_NONE) &&
			 ((targetObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE)) {
			aiTask->flags_5c = aiTask->flags_5c | 0x100000;
		}
		AITask_UnkInitRouting_FUN_00402530(aiTask,~aiTask->flags_5c >> 0x14 & 1);
		aiTask->flags_5c = aiTask->flags_5c & 0xffffffbf;
		AITask_InitTask_1(aiTask,AIPRIORITY_GETIN);
	}
	return;
}



void __cdecl FUN_00402970(Point2I *position)
{
	Point2I *local_8;
	int local_4;
	
	local_8 = position;
	local_4 = 0;
	lego::ai::AITask_DoUnkCallbacks(lego::ai::AITask_FUN_004029a0,(LiveObject *)&local_8);
	return;
}



BOOL __cdecl lego::ai::AITask_FUN_004029a0(AITaskData *aiTask,Point2I **param_2)
{
	if (((aiTask->taskType == AITASK_ATTACKPATH) && ((*param_2)->x == (aiTask->position).x)) &&
		 ((*param_2)->y == (aiTask->position).y)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_004029d0(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = ai::AITask_DoUnkCallbacks(ai::AITask_FUN_004029f0,liveObj);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_FUN_004029f0(AITaskData *aiTask,LiveObject *liveObj)
{
	if ((aiTask->taskType == AITASK_ATTACKROCKMONSTER) && (aiTask->object_10 == liveObj)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



void __cdecl FUN_00402a10(Point2I *position,int param_2)
{
	LevelData *level;
	Point2I *local_8;
	int local_4;
	
	level = lego::game::GetLevel();
	local_8 = position;
	local_4 = param_2;
	lego::ai::AITask_DoUnkCallbacks(lego::ai::AITask_FUN_00402ae0,(LiveObject *)&local_8);
	lego::game::SurfaceMap_FUN_0044f830(level->surfaceMap,position->x,position->y);
	return;
}



void __cdecl FUN_00402a60(ObjectType param_1)
{
	ObjectType local_8;
	int local_4;
	
	local_8 = param_1;
	local_4 = 0;
	lego::ai::AITask_DoUnkCallbacks(lego::ai::AITask_FUN_00402b50,(LiveObject *)&local_8);
	return;
}



void __cdecl FUN_00402a90(ObjectType param_1,BOOL param_2)
{
	ObjectType local_8;
	int local_4;
	
	local_4 = 0;
	local_8 = param_1;
	if (param_2 != 0) {
		lego::ai::AITask_DoUnkCallbacks(lego::ai::AITask_FUN_00402bd0,(LiveObject *)&local_8);
		return;
	}
	lego::ai::AITask_DoUnkCallbacks(lego::ai::AITask_FUN_00402ba0,(LiveObject *)&local_8);
	return;
}



BOOL __cdecl lego::ai::AITask_FUN_00402ae0(AITaskData *aiTask,Point2I **param_2)
{
	AITaskType AVar1;
	bool bVar2;
	
	bVar2 = false;
	AVar1 = aiTask->taskType;
	if (AVar1 == AITASK_DIG) {
		if (param_2[1] != (Point2I *)0x0) {
			if ((*(byte *)&aiTask->flags_5c & 8) != 0) goto LAB_00402b16;
			if (param_2[1] != (Point2I *)0x0) goto LAB_00402b1b;
		}
		if ((*(byte *)&aiTask->flags_5c & 8) != 0) goto LAB_00402b1b;
	}
	else {
		if ((AVar1 != AITASK_DYNAMITE) && (AVar1 != AITASK_REINFORCE)) goto LAB_00402b1b;
	}
LAB_00402b16:
	bVar2 = true;
LAB_00402b1b:
	if (((bVar2) && ((*param_2)->x == (aiTask->position).x)) &&
		 ((*param_2)->y == (aiTask->position).y)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
		game::Level_SetBlockFlags1_8000000(*param_2,0);
	}
	return 0;
}



BOOL __cdecl lego::ai::AITask_FUN_00402b50(AITaskData *aiTask,Point2I **param_2)
{
	SurfaceMap *surfMap;
	int iVar1;
	int iVar2;
	
	if (((aiTask->taskType == AITASK_REINFORCE) && ((*param_2)->x == (aiTask->position).x)) &&
		 ((*param_2)->y == (aiTask->position).y)) {
		iVar2 = (aiTask->position).y;
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
		iVar1 = (aiTask->position).x;
		surfMap = game::GetSurfaceMap();
		game::SurfaceMap_FUN_0044f830(surfMap,iVar1,iVar2);
	}
	return 0;
}



BOOL __cdecl lego::ai::AITask_FUN_00402ba0(AITaskData *aiTask,Point2I **param_2)
{
	if (((aiTask->taskType == AITASK_CLEAR) && ((*param_2)->x == (aiTask->position).x)) &&
		 ((*param_2)->y == (aiTask->position).y)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



BOOL __cdecl lego::ai::AITask_FUN_00402bd0(AITaskData *aiTask,Point2I **param_2)
{
	if (((aiTask->taskType == AITASK_CLEAR) && ((*param_2)->x == (aiTask->position).x)) &&
		 ((*param_2)->y == (aiTask->position).y)) {
		aiTask->float_18 = 500.0;
	}
	return 0;
}



void __cdecl lego::ai::AITask_Release_2(AITaskData *aiTask)
{
	AITaskData **ppAVar1;
	AITaskData *pAVar2;
	
	if (aiTask->taskType == AITASK_GETTOOL) {
		if (aiTask->aiTask_58 != (AITaskData *)0x0) {
			AITask_DoUnkCallbacks(AITask_IsSameTaskAsField58,(LiveObject *)&aiTask);
			return;
		}
	}
	else {
		if ((aiTask->aiTask_58 != (AITaskData *)0x0) &&
			 (pAVar2 = globals::g_AITaskUnkPtr, globals::g_AITaskUnkPtr != (AITaskData *)0x0)) {
			do {
				if ((pAVar2->taskType == AITASK_GETTOOL) && (aiTask->aiTask_58 == pAVar2)) {
					pAVar2->flags_5c = pAVar2->flags_5c | 0x20;
				}
				ppAVar1 = &pAVar2->next;
				pAVar2 = *ppAVar1;
			} while (*ppAVar1 != (AITaskData *)0x0);
		}
	}
	return;
}



BOOL __cdecl lego::ai::AITask_IsSameTaskAsField58(AITaskData *aiTask,AITaskData *otherTask)
{
	return (uint)(aiTask->aiTask_58 == otherTask);
}



BOOL __cdecl lego::ai::AITask_DoDynamite_AtPosition(Point2I *position,BOOL param_2)
{
	BOOL BVar1;
	uint uVar2;
	AITaskData *aiTask;
	SurfaceMap *surfMap;
	int x;
	int y;
	int index;
	
	if ((globals::g_Game.level)->blocks
			[((globals::g_Game.level)->dimensions).width * position->y + position->x].terrain !=
			TERRAIN_IMMOVABLE) {
		BVar1 = game::Level_GetBlockFlags1_10Not8(position->x,position->y);
		if (BVar1 != 0) {
			uVar2 = game::Level_GetBlockFlags1_8000000(position);
			if (uVar2 == 0) {
				aiTask = pool::ReservedPool_AITask___Next(AITASK_DYNAMITE);
				(aiTask->position).x = position->x;
				uVar2 = aiTask->flags_5c;
				(aiTask->position).y = position->y;
				aiTask->objType = OBJECT_DYNAMITE;
				aiTask->objIndex = -1;
				aiTask->objLevel = 0;
				aiTask->flags_5c = uVar2 | 0x400;
				if (param_2 == 0) {
					AITask_UnkInitRouting_FUN_00402530(aiTask,1);
				}
				AITask_InitTask_1(aiTask,AIPRIORITY_DESTRUCTION);
				AI_PlaceRequestObject(position,OBJECT_DYNAMITE,0,0);
				game::Level_SetBlockFlags1_8000000(position,1);
				y = position->y;
				x = position->x;
				index = 2;
				surfMap = game::GetSurfaceMap();
				game::SurfaceMap_FUN_0044f7a0(surfMap,x,y,index);
				return 1;
			}
		}
	}
	return 0;
}



void __cdecl lego::ai::AITask_DoBirdScarer_AtPosition(Point2I *position)
{
	uint uVar1;
	BOOL BVar2;
	AITaskData *aiTask;
	
	BVar2 = game::Level_GetBlockFlags1_8(position->x,position->y);
	if (BVar2 != 0) {
		aiTask = pool::ReservedPool_AITask___Next(AITASK_BIRDSCARER);
		uVar1 = aiTask->flags_5c;
		(aiTask->position).x = position->x;
		(aiTask->position).y = position->y;
		aiTask->objType = OBJECT_OOHSCARY;
		aiTask->objIndex = -1;
		aiTask->objLevel = 0;
		aiTask->flags_5c = uVar1 | 0x400;
		AITask_UnkInitRouting_FUN_00402530(aiTask,1);
		AITask_InitTask_1(aiTask,AIPRIORITY_DESTRUCTION);
		AI_PlaceRequestObject(position,OBJECT_OOHSCARY,0,0);
	}
	return;
}



void __cdecl lego::ai::AITask_DoFindLoad(LiveObject *targetObj)
{
	ObjectStatsFlags3 OVar1;
	AITaskData *aiTask;
	
	OVar1 = game::LiveObject_GetStatsFlags3(targetObj);
	if ((((OVar1 & STATS3_CARRYVEHICLES) != STATS3_NONE) &&
			((targetObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE)) &&
		 ((targetObj->flags4 & LIVEOBJ4_UNK_10000) == LIVEOBJ4_NONE)) {
		aiTask = pool::ReservedPool_AITask___Next(AITASK_FINDLOAD);
		aiTask->object_10 = targetObj;
		targetObj->flags4 = targetObj->flags4 | LIVEOBJ4_UNK_10000;
		AITask_InitTask_1(aiTask,AIPRIORITY_FINDLOAD);
		aiTask->flags_5c = aiTask->flags_5c & 0xffffffbf | 0x100010;
	}
	return;
}



void __cdecl lego::ai::AITask_DoRepair_Target(LiveObject *targetObj,BOOL condition)
{
	AITaskData *aiTask;
	
	aiTask = pool::ReservedPool_AITask___Next(AITASK_REPAIR);
	aiTask->object_10 = targetObj;
	aiTask->mode_3c = 0x10;
	if (condition != 0) {
		aiTask->flags_5c = aiTask->flags_5c | 0x200000;
	}
	AITask_InitTask_1(aiTask,(-(uint)(condition != 0) & 0xc) + AIPRIORITY_REPAIR);
	return;
}



void __cdecl lego::ai::AITask_DoGotoEat_Target(LiveObject *liveObj,LiveObject *targetObj)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	pAVar1 = pool::ReservedPool_AITask___Next(AITASK_GOTOEAT);
	pAVar1->object_10 = targetObj;
	pAVar2 = game::LiveObject_AITask2F0_GetLast(liveObj);
	if (pAVar2 != (AITaskData *)0x0) {
		pAVar2->next = pAVar1;
		return;
	}
	liveObj->aitask_2f0 = pAVar1;
	return;
}



void __cdecl lego::ai::AITask_DoElecFence(Point2I *position)
{
	uint uVar1;
	AITaskData *aiTask;
	
	aiTask = pool::ReservedPool_AITask___Next(AITASK_ELECFENCE);
	uVar1 = aiTask->flags_5c;
	(aiTask->position).x = position->x;
	(aiTask->position).y = position->y;
	aiTask->objType = OBJECT_ELECTRICFENCE;
	aiTask->objIndex = -1;
	aiTask->objLevel = 0;
	aiTask->flags_5c = uVar1 | 0x400;
	AITask_UnkInitRouting_FUN_00402530(aiTask,1);
	AITask_InitTask_1(aiTask,AIPRIORITY_CONSTRUCTION);
	AI_PlaceRequestObject(position,OBJECT_ELECTRICFENCE,0,0);
	game::Level_SetBlockFlag8(position->x,position->y,1);
	return;
}



void __cdecl lego::ai::AITask_DoReinforce_AtPosition(Point2I *position)
{
	BOOL BVar1;
	AITaskData *aiTask;
	SurfaceMap *surfMap;
	int x;
	int y;
	int index;
	
	BVar1 = game::Level_GetBlockFlags1_10Not8(position->x,position->y);
	if (BVar1 != 0) {
		BVar1 = game::Level_GetBlockFlags1_20(position->x,position->y);
		if (BVar1 == 0) {
			aiTask = pool::ReservedPool_AITask___Next(AITASK_REINFORCE);
			(aiTask->position).x = position->x;
			(aiTask->position).y = position->y;
			AITask_UnkInitRouting_FUN_00402530(aiTask,1);
			AITask_InitTask_1(aiTask,AIPRIORITY_REINFORCE);
			y = position->y;
			x = position->x;
			index = 3;
			surfMap = game::GetSurfaceMap();
			game::SurfaceMap_FUN_0044f7a0(surfMap,x,y,index);
		}
	}
	return;
}



void __cdecl lego::ai::AITask_DoClear_AtPosition(Point2I *position,MessageType completeAction)
{
	AITaskData *aiTask;
	
	aiTask = pool::ReservedPool_AITask___Next(AITASK_CLEAR);
	(aiTask->position).x = position->x;
	(aiTask->position).y = position->y;
	aiTask->completeAction = completeAction;
	AITask_InitTask_1(aiTask,AIPRIORITY_CLEARING);
	return;
}



void __cdecl lego::ai::AITask_DoGetTool_FromTask(AITaskData *in_aiTask)
{
	AITaskData *pAVar1;
	BOOL BVar2;
	AITaskData *aiTask;
	undefined4 *puVar3;
	uint uVar4;
	int iVar5;
	undefined4 *puVar6;
	
	pAVar1 = in_aiTask;
	BVar2 = AI_GetToolFromTaskType(in_aiTask->taskType,(ToolType *)&in_aiTask);
	if (BVar2 != 0) {
		pAVar1->flags_5c = pAVar1->flags_5c | 0x1000;
		aiTask = pool::ReservedPool_AITask___Next(AITASK_GETTOOL);
		if ((pAVar1->flags_5c & 0x100) != 0) {
			puVar3 = (undefined4 *)std::malloc(pAVar1->field_44 << 2);
			aiTask->ptr_40 = puVar3;
			puVar6 = (undefined4 *)pAVar1->ptr_40;
			for (uVar4 = pAVar1->field_44 & 0x3fffffff; uVar4 != 0; uVar4 = uVar4 - 1) {
				*puVar3 = *puVar6;
				puVar6 = puVar6 + 1;
				puVar3 = puVar3 + 1;
			}
			for (iVar5 = 0; iVar5 != 0; iVar5 = iVar5 + -1) {
				*(undefined *)puVar3 = *(undefined *)puVar6;
				puVar6 = (undefined4 *)((int)puVar6 + 1);
				puVar3 = (undefined4 *)((int)puVar3 + 1);
			}
			aiTask->field_44 = pAVar1->field_44;
			aiTask->flags_5c = aiTask->flags_5c | 0x100;
		}
		aiTask->flags_5c = aiTask->flags_5c | 0x10;
		aiTask->toolType = (ToolType)in_aiTask;
		aiTask->aiTask_58 = pAVar1;
		pAVar1->aiTask_58 = aiTask;
		AITask_InitTask_1(aiTask,pAVar1->priorityType);
	}
	return;
}



BOOL __cdecl lego::ai::AITask_DoGetTool(ToolType toolType)
{
	AITaskData *aiTask;
	
	aiTask = pool::ReservedPool_AITask___Next(AITASK_GETTOOL);
	aiTask->toolType = toolType;
	aiTask->aiTask_58 = (AITaskData *)0x0;
	AITask_UnkInitRouting_FUN_00402530(aiTask,1);
	aiTask->flags_5c = aiTask->flags_5c & 0xffffffbf | 0x10;
	AITask_InitTask_1(aiTask,AIPRIORITY_DEFAULTCOLLECT);
	return 1;
}



BOOL __cdecl lego::game::Game_SelectedUnits_UnkEquippedTool_FUN_00403110(ToolType toolType)
{
	BOOL BVar1;
	uint uVar2;
	LiveObject **ppLVar3;
	uint uVar4;
	
	BVar1 = Game_IsAnyUnitsSelected();
	if (BVar1 == 0) {
		uVar2 = 0;
		if (INT_004b4424 != 0) {
			ppLVar3 = (LiveObject **)&DAT_004b435c;
			while ((*ppLVar3 == (LiveObject *)0x0 ||
						 (BVar1 = LiveObject_HasToolEquipped(*ppLVar3,toolType), BVar1 == 0))) {
				uVar2 = uVar2 + 1;
				ppLVar3 = ppLVar3 + 1;
				if ((uint)INT_004b4424 <= uVar2) {
					return 0;
				}
			}
			return 1;
		}
	}
	else {
		uVar2 = Game_GetNumSelectedUnits();
		ppLVar3 = Game_GetSelectedUnits();
		uVar4 = 0;
		if (uVar2 != 0) {
			do {
				BVar1 = LiveObject_HasToolEquipped(*ppLVar3,toolType);
				if (BVar1 != 0) {
					return 1;
				}
				uVar4 = uVar4 + 1;
				ppLVar3 = ppLVar3 + 1;
			} while (uVar4 < uVar2);
			return 0;
		}
	}
	return 0;
}



void __cdecl
lego::ai::AITask_DoGoto_Group(LiveObject **liveObjsTable,int count,Point2I *position,BOOL param_4)
{
	LiveObject *liveObj;
	AITaskData *pAVar1;
	ObjectStatsFlags1 OVar2;
	AITaskData *pAVar3;
	
	if ((count != 0) && (count != 0)) {
		do {
			pAVar1 = pool::ReservedPool_AITask___Next(AITASK_GOTO);
			(pAVar1->position).x = position->x;
			(pAVar1->position).y = position->y;
			pAVar1->flags_5c = 4;
			liveObj = *liveObjsTable;
			OVar2 = game::LiveObject_GetStatsFlags1(liveObj);
			if ((((OVar2 & STATS1_CANBEDRIVEN) == STATS1_NONE) ||
					(liveObj->drivenObject != (LiveObject *)0x0)) &&
				 ((liveObj->carryingThisObject == (LiveObject *)0x0 &&
					((*(byte *)&liveObj->flags3 & LIVEOBJ3_UNK_80) != 0)))) {
				if (param_4 != 0) {
					FUN_00404030(liveObj);
				}
				pAVar3 = game::LiveObject_AITask2F0_GetLast(liveObj);
				if (pAVar3 == (AITaskData *)0x0) {
					liveObj->aitask_2f0 = pAVar1;
				}
				else {
					pAVar3->next = pAVar1;
				}
			}
			liveObjsTable = liveObjsTable + 1;
			count = count + -1;
		} while (count != 0);
	}
	return;
}



void __cdecl lego::ai::AITask_DoUpgrade(LiveObject *liveObj,int newObjLevel)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	LiveObject *pLVar3;
	Point2F local_8;
	
	pLVar3 = (LiveObject *)0x0;
	if ((liveObj->objType == OBJECT_MINIFIGURE) &&
		 ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE)) {
		game::LiveObject_GetPosition(liveObj,(float *)&local_8,&local_8.y);
		pLVar3 = game::Level_GetBuildingAtPosition(&local_8);
	}
	else {
		if (liveObj->objType == OBJECT_VEHICLE) {
			pLVar3 = (LiveObject *)FUN_00438eb0(liveObj);
		}
	}
	if (pLVar3 != (LiveObject *)0x0) {
		pAVar1 = pool::ReservedPool_AITask___Next(AITASK_UPGRADE);
		pAVar1->object_10 = pLVar3;
		pAVar1->objLevel = newObjLevel;
		FUN_00404030(liveObj);
		pAVar2 = game::LiveObject_AITask2F0_GetLast(liveObj);
		if (pAVar2 != (AITaskData *)0x0) {
			pAVar2->next = pAVar1;
			return;
		}
		liveObj->aitask_2f0 = pAVar1;
	}
	return;
}



void __cdecl lego::ai::AITask_DoDock(LiveObject *liveObj)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	pAVar1 = pool::ReservedPool_AITask___Next(AITASK_DOCK);
	pAVar2 = game::LiveObject_AITask2F0_GetLast(liveObj);
	if (pAVar2 != (AITaskData *)0x0) {
		pAVar2->next = pAVar1;
		return;
	}
	liveObj->aitask_2f0 = pAVar1;
	return;
}



void __cdecl lego::ai::AITask_DoGoto_Congregate(Point2I *position)
{
	uint uVar1;
	AITaskData *aiTask;
	
	aiTask = pool::ReservedPool_AITask___Next(AITASK_GOTO);
	(aiTask->position).x = position->x;
	uVar1 = aiTask->flags_5c;
	(aiTask->position).y = position->y;
	aiTask->flags_5c = uVar1 & 0xffffffef | 0x40;
	AITask_SetPriorityType(aiTask,AIPRIORITY_CONGREGATE);
	AITask_Init_2_NoPriority(aiTask);
	return;
}



void __cdecl lego::ai::AITask_FUN_00403360(Point2I *position)
{
	AITaskData *pAVar1;
	AITaskData *aiTask;
	AITaskData *pAVar2;
	
	pAVar1 = globals::g_AITaskDataNext;
	pAVar2 = (AITaskData *)0x0;
	if (globals::g_AITaskDataNext != (AITaskData *)0x0) {
		do {
			aiTask = pAVar1;
			pAVar1 = aiTask->next;
			if (((aiTask->taskType == AITASK_GOTO) && ((aiTask->position).x == position->x)) &&
				 ((aiTask->position).y == position->y)) {
				if (pAVar2 == (AITaskData *)0x0) {
					globals::g_AITaskDataNext = pAVar1;
					pool::ReservedPool_AITask___Release(aiTask,0);
					return;
				}
				pAVar2->next = pAVar1;
				pool::ReservedPool_AITask___Release(aiTask,0);
				return;
			}
			pAVar2 = aiTask;
		} while (pAVar1 != (AITaskData *)0x0);
	}
	return;
}



void __cdecl lego::ai::AITask_DoAttackObject(LiveObject *liveObj)
{
	AITaskData *aiTask;
	
	aiTask = pool::ReservedPool_AITask___Next(AITASK_ATTACKOBJECT);
	aiTask->object_10 = liveObj;
	AITask_SetPriorityType(aiTask,AIPRIORITY_ATTACKOBJECT);
	AITask_Init_2_NoPriority(aiTask);
	aiTask->flags_5c = aiTask->flags_5c | 0x40;
	return;
}



void __cdecl lego::ai::AITask_DoAttackPath(Point2I *position)
{
	AITaskData *aiTask;
	
	aiTask = pool::ReservedPool_AITask___Next(AITASK_ATTACKPATH);
	(aiTask->position).x = position->x;
	(aiTask->position).y = position->y;
	AITask_SetPriorityType(aiTask,AIPRIORITY_ATTACKPATH);
	AITask_Init_2_NoPriority(aiTask);
	return;
}



void __cdecl lego::ai::AITask_DoRepair(LiveObject *liveObj)
{
	AITaskData *aiTask;
	
	aiTask = pool::ReservedPool_AITask___Next(AITASK_REPAIR);
	aiTask->object_10 = liveObj;
	AITask_SetPriorityType(aiTask,AIPRIORITY_PUNCH);
	AITask_Init_2_NoPriority(aiTask);
	aiTask->flags_5c = aiTask->flags_5c | 0x40;
	return;
}



void __cdecl FUN_00403490(LiveObject *liveObj)
{
	AITaskData *pAVar1;
	AITaskData *aiTask;
	AITaskData *pAVar2;
	AITaskData *pAVar3;
	
	pAVar2 = (AITaskData *)0x0;
	aiTask = lego::globals::g_AITaskDataNext;
	if (lego::globals::g_AITaskDataNext != (AITaskData *)0x0) {
		do {
			pAVar1 = aiTask->next;
			pAVar3 = aiTask;
			if ((aiTask->taskType == AITASK_REPAIR) && (liveObj == aiTask->object_10)) {
				pAVar3 = pAVar2;
				if (pAVar2 == (AITaskData *)0x0) {
					lego::globals::g_AITaskDataNext = pAVar1;
					lego::pool::ReservedPool_AITask___Release(aiTask,0);
				}
				else {
					pAVar2->next = pAVar1;
					lego::pool::ReservedPool_AITask___Release(aiTask,0);
				}
			}
			aiTask = pAVar1;
			pAVar2 = pAVar3;
		} while (pAVar1 != (AITaskData *)0x0);
	}
	return;
}



void __cdecl
lego::ai::AITask_DoGoto_AtPosition(LiveObject *liveObj,Point2I *position,undefined4 param_3)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	pAVar1 = pool::ReservedPool_AITask___Next(AITASK_GOTO);
	(pAVar1->position).x = position->x;
	(pAVar1->position).y = position->y;
	pAVar1->field_4 = param_3;
	pAVar2 = game::LiveObject_AITask2F0_GetLast(liveObj);
	if (pAVar2 != (AITaskData *)0x0) {
		pAVar2->next = pAVar1;
		return;
	}
	liveObj->aitask_2f0 = pAVar1;
	game::LiveObject_MiniFigure_FUN_00407380(liveObj);
	return;
}



void __cdecl lego::ai::AITask_DoDeposit_Target(LiveObject *liveObj,LiveObject *targetObj)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		pAVar1 = pool::ReservedPool_AITask___Next(AITASK_DEPOSITE);
		pAVar1->object_10 = targetObj;
		pAVar2 = game::LiveObject_AITask2F0_GetLast(liveObj);
		if (pAVar2 != (AITaskData *)0x0) {
			pAVar2->next = pAVar1;
			return;
		}
		liveObj->aitask_2f0 = pAVar1;
	}
	return;
}



void __cdecl
lego::ai::AITask_DoFollow_Group(LiveObject **liveObjsTable,int count,LiveObject *targetObj)
{
	LiveObject *liveObj;
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	if ((count != 0) && (count != 0)) {
		do {
			pAVar1 = pool::ReservedPool_AITask___Next(AITASK_FOLLOW);
			pAVar1->object_10 = targetObj;
			pAVar1->unkExpiryTime = 0.0;
			liveObj = *liveObjsTable;
			FUN_00404030(liveObj);
			pAVar2 = game::LiveObject_AITask2F0_GetLast(liveObj);
			if (pAVar2 == (AITaskData *)0x0) {
				liveObj->aitask_2f0 = pAVar1;
			}
			else {
				pAVar2->next = pAVar1;
			}
			liveObjsTable = liveObjsTable + 1;
			count = count + -1;
		} while (count != 0);
	}
	return;
}



void __cdecl lego::ai::AITask_DoFollowAttack(LiveObject *liveObj,LiveObject *targetObj)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	pAVar1 = pool::ReservedPool_AITask___Next(AITASK_FOLLOWATTACK);
	pAVar1->object_10 = targetObj;
	pAVar1->unkExpiryTime = 0.0;
	pAVar2 = game::LiveObject_AITask2F0_GetLast(liveObj);
	if (pAVar2 != (AITaskData *)0x0) {
		pAVar2->next = pAVar1;
		return;
	}
	liveObj->aitask_2f0 = pAVar1;
	return;
}



void __cdecl lego::ai::AI_FUN_00403630(int param_1,int param_2,int param_3,int param_4)
{
	AITaskData **ppAVar1;
	AITaskData *pAVar2;
	
	pAVar2 = globals::g_AITaskUnkPtr;
	if (globals::g_AITaskUnkPtr != (AITaskData *)0x0) {
		do {
			if (((pAVar2->taskType == AITASK_REQUEST) && (pAVar2->field_2c == param_1)) &&
				 ((param_2 == 0 || ((param_3 == pAVar2->objType && (param_4 == pAVar2->objIndex)))))) {
				pAVar2->flags_5c = pAVar2->flags_5c | 0x20;
			}
			ppAVar1 = &pAVar2->next;
			pAVar2 = *ppAVar1;
		} while (*ppAVar1 != (AITaskData *)0x0);
	}
	return;
}



void __cdecl
lego::ai::AITask_DoRequest_ObjectType
					(ObjectType objType,int objLevel,int objIndex,Point2I *position,undefined4 param_5,
					Point2F *pointFloat,BOOL param_7)
{
	int iVar1;
	AITaskData *aiTask;
	float10 fVar2;
	
	aiTask = pool::ReservedPool_AITask___Next(AITASK_REQUEST);
	aiTask->objType = objType;
	aiTask->objIndex = objLevel;
	aiTask->objLevel = objIndex;
	(aiTask->position).x = position->x;
	iVar1 = position->y;
	aiTask->field_2c = param_5;
	(aiTask->position).y = iVar1;
	if (pointFloat == (Point2F *)0x0) {
		fVar2 = math::Maths_RandRange(0.4,0.6);
		(aiTask->pointf_30).x = (float)fVar2;
		fVar2 = math::Maths_RandRange(0.4,0.6);
		(aiTask->pointf_30).y = (float)fVar2;
	}
	else {
		(aiTask->pointf_30).x = pointFloat->x;
		(aiTask->pointf_30).y = pointFloat->y;
	}
	if (param_7 != 0) {
		aiTask->flags_5c = aiTask->flags_5c | 0x800;
	}
	aiTask->object_10 = (LiveObject *)0x0;
	aiTask->unkExpiryTime = 0.0;
	AITask_InitTask_1(aiTask,AIPRIORITY_REQUEST);
	aiTask->flags_5c = aiTask->flags_5c | 0x400;
	AI_PlaceRequestObject(position,objType,objLevel,objIndex);
	return;
}



void __cdecl
lego::ai::AI_PlaceRequestObject(Point2I *position,ObjectType objType,int objIndex,int objLevel)
{
	LiveObject *pLVar1;
	int iVar2;
	LiveObject *liveObj;
	
	pLVar1 = FUN_00438d20(position,objType,objIndex,objLevel);
	if (pLVar1 == (LiveObject *)0x0) {
		if (((objIndex != 0) && (objType == OBJECT_ORE)) &&
			 (pLVar1 = FUN_00438d20(position,OBJECT_ORE,0,objLevel), pLVar1 != (LiveObject *)0x0)) {
			liveObj = game::LiveObject_FUN_00438da0((LiveObject *)0x0,position,OBJECT_ORE,0);
			iVar2 = game::LiveObject_GetMaxCarry(liveObj);
			if (iVar2 == 0) {
				return;
			}
			do {
				FUN_0043a910(pLVar1,OBJECT_ORE,0,objLevel);
				iVar2 = iVar2 + -1;
			} while (iVar2 != 0);
			return;
		}
	}
	else {
		iVar2 = FUN_0043a910(pLVar1,objType,objIndex,objLevel);
		if (iVar2 != 0) {
			return;
		}
	}
	iVar2 = objIndex * 0x10 + objType * 0xf0 + objLevel;
	(&DAT_004b44f4)[iVar2] = (&DAT_004b44f4)[iVar2] + 1;
	return;
}



AITaskData * __cdecl
lego::ai::AITask_DoDeposit_ObjectType
					(LiveObject *liveObj,ObjectType objType,int objIndex,int objLevel)
{
	AITaskData *aiTask;
	
	aiTask = pool::ReservedPool_AITask___Next(AITASK_DEPOSITE);
	aiTask->object_10 = liveObj;
	aiTask->unkExpiryTime = 0.0;
	aiTask->objType = objType;
	aiTask->objIndex = objIndex;
	aiTask->objLevel = objLevel;
	AITask_InitTask_1(aiTask,AIPRIORITY_REFINING);
	aiTask->flags_5c = aiTask->flags_5c & 0xffffffef | 0x4c0;
	return aiTask;
}



void __cdecl lego::game::LiveObject_FUN_00403840(LiveObject *liveObj)
{
	int iVar1;
	uint objIndex;
	ObjectType objType;
	uint objLevel;
	uint *puVar2;
	int local_8;
	uint local_4;
	
	objType = OBJECT_NONE;
	puVar2 = &DAT_004b44f4;
	do {
		objIndex = 0;
		do {
			objLevel = 0;
			do {
				local_8 = 0;
				local_4 = 0;
				if (*puVar2 != 0) {
					do {
						iVar1 = FUN_00404e40(objType,objIndex,objLevel);
						if ((iVar1 == 0) ||
							 (iVar1 = FUN_0043a910(liveObj,objType,objIndex,objLevel), iVar1 != 0)) {
							local_8 = local_8 + 1;
						}
						local_4 = local_4 + 1;
					} while (local_4 < *puVar2);
				}
				objLevel = objLevel + 1;
				*puVar2 = *puVar2 - local_8;
				puVar2 = puVar2 + 1;
			} while (objLevel < 0x10);
			objIndex = objIndex + 1;
		} while (objIndex < 0xf);
		objType = objType + OBJECT_VEHICLE;
	} while (puVar2 < globals::g_Priorities_bool2_TABLE);
	return;
}



void __cdecl lego::game::LiveObject_FUN_004038d0(LiveObject *liveObj)
{
	AITaskData *aiTask;
	
	aiTask = ai::AITask_DoDeposit_ObjectType(liveObj,OBJECT_NONE,-1,0);
	ai::AITask_SetPriorityType(aiTask,AIPRIORITY_STORAGE);
	LiveObject_FUN_00403840(liveObj);
	return;
}



void __cdecl lego::ai::AITask_DoGotoEat(LiveObject *liveObj)
{
	AITaskData *aiTask;
	
	aiTask = pool::ReservedPool_AITask___Next(AITASK_GOTOEAT);
	aiTask->object_10 = liveObj;
	aiTask->unkExpiryTime = 0.0;
	AITask_InitTask_1(aiTask,AIPRIORITY_CRYSTAL);
	aiTask->flags_5c = aiTask->flags_5c & 0xffffffef | 0xc0;
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_00403940(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = ai::AITask_DoUnkCallbacks(ai::AITask_FUN_00403960,liveObj);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_FUN_00403960(AITaskData *aiTask,LiveObject *liveObj)
{
	if ((aiTask->taskType == AITASK_DEPOSITE) && (liveObj == aiTask->object_10)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_00403980(LiveObject *liveObj)
{
	uint uVar1;
	AITaskData *pAVar2;
	AITaskData *aiTask;
	
	if (((byte)pool::globals::ReservedPool_AITask___g_INITFLAGS & 2) == 0) {
		aiTask = liveObj->aitask_2f0;
		while (aiTask != (AITaskData *)0x0) {
			uVar1 = aiTask->flags_5c;
			pAVar2 = aiTask->next;
			if (((uVar1 & 0x10) == 0) || ((uVar1 & 0x20) != 0)) {
				if (((uVar1 & 0x2000) == 0) || ((uVar1 & 0x20) != 0)) {
					pool::ReservedPool_AITask___Release(aiTask,0);
					aiTask = pAVar2;
				}
				else {
					ai::AITask_Init_2_NoPriority(aiTask);
					aiTask = pAVar2;
				}
			}
			else {
				ai::AITask_InitTask_1(aiTask,aiTask->priorityType);
				aiTask = pAVar2;
			}
		}
		liveObj->aitask_2f0 = (AITaskData *)0x0;
		ai::AITask_DoUnkCallbacks(ai::AITask_FUN_00403a00,liveObj);
	}
	return;
}



BOOL __cdecl lego::ai::AITask_FUN_00403a00(AITaskData *aiTask,LiveObject *liveObj)
{
	if (liveObj == aiTask->object_10) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



void __cdecl FUN_00403a20(LiveObject *liveObj,BOOL param_2)
{
	AITaskData *pAVar1;
	
	pAVar1 = liveObj->aitask_2f0;
	if (pAVar1 != (AITaskData *)0x0) {
		if (param_2 == 0) {
			pAVar1->flags_5c = pAVar1->flags_5c & 0xfffffffe;
		}
		else {
			if (pAVar1->taskType == AITASK_GOTO) {
				lego::game::LiveObject_FUN_00404110(liveObj);
				if (liveObj->objType == OBJECT_ROCKMONSTER) {
					lego::game::Level_AddMessageAction
										(MESSAGE_ROCKMONSTERGOTO_COMPLETE,liveObj,0,(Point2I *)0x0);
					return;
				}
			}
		}
	}
	return;
}



void __cdecl FUN_00403a70(LiveObject *liveObj)
{
	uint *puVar1;
	
	if (liveObj->aitask_2f0 != (AITaskData *)0x0) {
		puVar1 = &liveObj->aitask_2f0->flags_5c;
		*puVar1 = *puVar1 & 0xfffffffe;
	}
	return;
}



void __cdecl lego::ai::AITask_VariousGatherTasks_FUN_00403a90(LiveObject *liveObj)
{
	LiveObject *carriedObj;
	uint uVar1;
	LiveObject **ppLVar2;
	
	if ((((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
			((liveObj->flags1 & LIVEOBJ1_UNK_2000) == LIVEOBJ1_NONE)) &&
		 (uVar1 = 0, liveObj->numCarriedObjects != 0)) {
		ppLVar2 = liveObj->carriedObjects;
		do {
			carriedObj = *ppLVar2;
			game::LiveObject_FUN_00403b30(liveObj,AITASK_DEPOSITE,carriedObj);
			game::LiveObject_FUN_00403b30(liveObj,AITASK_DUMP,carriedObj);
			game::LiveObject_FUN_00403b30(liveObj,AITASK_DYNAMITE,carriedObj);
			game::LiveObject_FUN_00403b30(liveObj,AITASK_ELECFENCE,carriedObj);
			game::LiveObject_FUN_00403b30(liveObj,AITASK_REQUEST,carriedObj);
			game::LiveObject_FUN_00403b30(liveObj,AITASK_GATHER,(LiveObject *)0x0);
			game::LiveObject_FUN_00403b30(liveObj,AITASK_BIRDSCARER,carriedObj);
			uVar1 = uVar1 + 1;
			ppLVar2 = ppLVar2 + 1;
		} while (uVar1 < liveObj->numCarriedObjects);
	}
	return;
}



void __cdecl
lego::game::LiveObject_FUN_00403b30
					(LiveObject *holderObj,AITaskType taskType,LiveObject *carriedObj)
{
	AITaskData **ppAVar1;
	AITaskType AVar2;
	SurfaceMap *surfMap;
	AITaskData *pAVar3;
	AITaskData *aiTask;
	int iVar4;
	int iVar5;
	
	if (((byte)pool::globals::ReservedPool_AITask___g_INITFLAGS & 2) != 0) {
		return;
	}
	pAVar3 = (AITaskData *)0x0;
	aiTask = holderObj->aitask_2f0;
	if (aiTask == (AITaskData *)0x0) {
		return;
	}
	while (taskType != aiTask->taskType) {
		ppAVar1 = &aiTask->next;
		pAVar3 = aiTask;
		aiTask = *ppAVar1;
		if (*ppAVar1 == (AITaskData *)0x0) {
			return;
		}
	}
	AVar2 = aiTask->taskType;
	if (AVar2 == AITASK_DEPOSITE) {
LAB_00403b90:
		if (AVar2 == AITASK_REQUEST) goto LAB_00403b95;
	}
	else {
		if (AVar2 != AITASK_REQUEST) {
			if ((((AVar2 != AITASK_DUMP) && (AVar2 != AITASK_COLLECT)) && (AVar2 != AITASK_DYNAMITE)) &&
				 ((AVar2 != AITASK_ELECFENCE && (AVar2 != AITASK_BIRDSCARER)))) goto LAB_00403c01;
			goto LAB_00403b90;
		}
LAB_00403b95:
		ai::AITask_DoRequest_ObjectType
							(aiTask->objType,aiTask->objIndex,aiTask->objLevel,&aiTask->position,aiTask->field_2c,
							 &aiTask->pointf_30,aiTask->flags_5c & 0x800);
	}
	if (aiTask->taskType == AITASK_DYNAMITE) {
		Level_SetBlockFlags1_8000000(&aiTask->position,0);
		iVar5 = (aiTask->position).y;
		iVar4 = (aiTask->position).x;
		surfMap = GetSurfaceMap();
		SurfaceMap_FUN_0044f830(surfMap,iVar4,iVar5);
	}
	ai::AITask_DoCollect(carriedObj,150.0);
	ai::AITask_DoCollect_Target(carriedObj);
LAB_00403c01:
	if (pAVar3 == (AITaskData *)0x0) {
		holderObj->aitask_2f0 = aiTask->next;
		pool::ReservedPool_AITask___Release(aiTask,0);
		return;
	}
	pAVar3->next = aiTask->next;
	pool::ReservedPool_AITask___Release(aiTask,0);
	return;
}



void __cdecl
lego::game::LiveObject_SetAITaskUnk
					(LiveObject *liveObj1,AITaskType taskType,LiveObject *liveObj2,BOOL param_4)
{
	Point2I *position;
	bool bVar1;
	LiveObject *liveObj;
	AITaskData *pAVar2;
	LiveObject *pLVar3;
	int iVar4;
	LevelBlockFlags1 LVar5;
	AITaskData *aiTask;
	AITaskData *pAVar6;
	AITaskType AVar7;
	
	liveObj = liveObj1;
	if (((byte)pool::globals::ReservedPool_AITask___g_INITFLAGS & 2) == 0) {
		if ((taskType == AITASK_COLLECT) &&
			 (pLVar3 = LiveObject_FUN_00438da0
													 (liveObj1,(Point2I *)0x0,liveObj2->objType,liveObj2->objLevel),
			 pLVar3 != (LiveObject *)0x0)) {
			Level_AddMessageAction(MESSAGE_COLLECTCRYSTAL_COMPLETE,liveObj1,(BOOL)pLVar3,(Point2I *)0x0);
		}
		pAVar2 = liveObj1->aitask_2f0;
		pAVar6 = (AITaskData *)0x0;
		if (liveObj1->aitask_2f0 != (AITaskData *)0x0) {
LAB_00403c9a:
			aiTask = pAVar2;
			if (taskType != aiTask->taskType) goto code_r0x00403ca4;
			liveObj1 = (LiveObject *)0x0;
			bVar1 = false;
			if (param_4 != 0) {
				if (pAVar6 == (AITaskData *)0x0) {
					liveObj->aitask_2f0 = aiTask->next;
				}
				else {
					pAVar6->next = aiTask->next;
				}
			}
			if (aiTask->taskType == AITASK_REQUEST) {
				AVar7 = aiTask->field_2c;
				bVar1 = true;
				liveObj1 = liveObj2;
				iVar4 = FUN_00408ca0(AVar7,liveObj2->objType,liveObj2->objIndex);
				if (iVar4 == 0) {
					ai::AI_FUN_00403630(AVar7,1,liveObj2->objType,liveObj2->objIndex);
					bVar1 = false;
				}
			}
			else {
				AVar7 = taskType;
				if (aiTask->taskType == AITASK_CLEAR) {
					if (liveObj->objType == OBJECT_VEHICLE) {
						for (LVar5 = (globals::g_Game.level)->blocks
												 [(aiTask->position).y * ((globals::g_Game.level)->dimensions).width +
													(aiTask->position).x].flags1 & BLOCK1_RUBBLE_FULL; LVar5 != BLOCK1_NONE;
								LVar5 = LVar5 + ~BLOCK1_NONE) {
							FUN_00432bc0(&aiTask->position);
							Level_AddMessageAction(aiTask->completeAction,0,0,&aiTask->position);
						}
					}
					position = &aiTask->position;
					FUN_00432bc0(position);
					Level_AddMessageAction(aiTask->completeAction,0,0,position);
					FUN_00432640(position,0);
					FUN_00433050((int *)position,0);
				}
				else {
					if (taskType == AITASK_TRAIN) {
						LiveObject_TrainMiniFigure_instantunk(liveObj,aiTask->mode_3c);
						front::Text_DisplayMessage(TEXT_MANTRAINED,1,0);
					}
				}
			}
			if (param_4 != 0) {
				pool::ReservedPool_AITask___Release(aiTask,0);
			}
			if (bVar1) {
				FUN_00408c10(AVar7,liveObj1);
			}
		}
LAB_00403dfc:
		if (taskType == AITASK_COLLECT) {
			FUN_00403e20(liveObj2);
		}
	}
	return;
code_r0x00403ca4:
	pAVar2 = aiTask->next;
	pAVar6 = aiTask;
	if (aiTask->next == (AITaskData *)0x0) goto LAB_00403dfc;
	goto LAB_00403c9a;
}



BOOL __cdecl FUN_00403e20(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = lego::ai::AITask_DoUnkCallbacks(lego::ai::AITask_FUN_00403e40,liveObj);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_FUN_00403e40(AITaskData *aiTask,LiveObject *liveObj)
{
	if ((aiTask->taskType == AITASK_COLLECT) && (aiTask->object_10 == liveObj)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



void __cdecl lego::ai::AITask_DoAnimationWait(LiveObject *liveObj)
{
	AITaskData *pAVar1;
	
	if ((liveObj->aitask_2f0 == (AITaskData *)0x0) ||
		 (liveObj->aitask_2f0->taskType != AITASK_ANIMATIONWAIT)) {
		pAVar1 = pool::ReservedPool_AITask___Next(AITASK_ANIMATIONWAIT);
		pAVar1->next = liveObj->aitask_2f0;
		liveObj->aitask_2f0 = pAVar1;
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_00403e90(LiveObject *liveObj)
{
	if ((liveObj->aitask_2f0 != (AITaskData *)0x0) &&
		 (liveObj->aitask_2f0->taskType == AITASK_ANIMATIONWAIT)) {
		LiveObject_FUN_00404110(liveObj);
	}
	return;
}



int __cdecl lego::ai::AITask_QSortCompare(AITaskData **task_a,AITaskData **task_b)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	uint uVar3;
	uint uVar4;
	
	pAVar1 = *task_a;
	pAVar2 = *task_b;
	uVar3 = pAVar1->flags_5c & 0x100;
	if ((uVar3 != 0) && ((pAVar2->flags_5c & 0x100) == 0)) {
		return 0xffffffff;
	}
	uVar4 = pAVar2->flags_5c & 0x100;
	if (uVar4 == 0) {
		if (uVar3 == 0) goto LAB_00403f0c;
	}
	else {
		if (uVar3 == 0) {
			return 1;
		}
	}
	if (uVar4 != 0) {
		if (pAVar2->taskStartTime < pAVar1->taskStartTime) {
			return 0xffffffff;
		}
		if (pAVar1->taskStartTime < pAVar2->taskStartTime) {
			return 1;
		}
	}
LAB_00403f0c:
	if ((int)pAVar1->priorityValue < 0) {
		pAVar1->priorityValue = 0;
	}
	if ((int)pAVar2->priorityValue < 0) {
		pAVar2->priorityValue = 0;
	}
	if (99 < (int)pAVar1->priorityValue) {
		pAVar1->priorityValue = 99;
	}
	if (99 < (int)pAVar2->priorityValue) {
		pAVar2->priorityValue = 99;
	}
	if ((int)pAVar2->priorityValue < (int)pAVar1->priorityValue) {
		return 0xffffffff;
	}
	return (uint)((int)pAVar1->priorityValue < (int)pAVar2->priorityValue);
}



AITaskData * __cdecl lego::ai::AITask_InitTask_1(AITaskData *aiTask,AIPriorityType priorityType)
{
	aiTask->next = globals::g_AITaskUnkPtr;
	globals::g_AITaskUnkPtr = aiTask;
	aiTask->unkExpiryTime = 1500.0;
	aiTask->flags_5c = aiTask->flags_5c & 0xfffffffe | 0x10;
	aiTask->priorityValue = globals::g_AIPriorityValues_TABLE[priorityType];
	aiTask->priorityType = priorityType;
	return aiTask;
}



void __cdecl lego::ai::AITask_Init_2_NoPriority(AITaskData *aiTask)
{
	aiTask->next = globals::g_AITaskDataNext;
	globals::g_AITaskDataNext = aiTask;
	aiTask->unkExpiryTime = 1500.0;
	aiTask->flags_5c = aiTask->flags_5c & 0xffffffee;
	return;
}



void __cdecl lego::game::Game_UnkLiveObjectHandleDynamite(LiveObject *liveObj)
{
	if (((byte)pool::globals::ReservedPool_AITask___g_INITFLAGS & 6) == 0) {
		LiveObject_FUN_00403b30(liveObj,AITASK_GOTO,(LiveObject *)0x0);
		if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
			 (liveObj->carriedObjects[0]->objType == OBJECT_DYNAMITE)) {
			LiveObject_FUN_00403b30(liveObj,AITASK_DYNAMITE,liveObj->carriedObjects[0]);
		}
		FUN_00404030(liveObj);
		LiveObject__ReleaseTaskReferences(liveObj);
	}
	return;
}



void __cdecl FUN_00404030(LiveObject *liveObj)
{
	uint uVar1;
	AITaskData *pAVar2;
	AITaskData *pAVar3;
	AITaskData *aiTask;
	
	pAVar3 = (AITaskData *)0x0;
	pAVar2 = liveObj->aitask_2f0;
	while (aiTask = pAVar2, aiTask != (AITaskData *)0x0) {
		uVar1 = aiTask->flags_5c;
		pAVar2 = aiTask->next;
		if ((uVar1 & 4) == 0) {
			if (((uVar1 & 0x10) == 0) || ((uVar1 & 0x20) != 0)) {
				if (((uVar1 & 0x2000) == 0) || ((uVar1 & 0x20) != 0)) {
					if (pAVar3 == (AITaskData *)0x0) {
						aiTask->next = (AITaskData *)0x0;
						pAVar3 = aiTask;
					}
					else {
						pAVar3->next = aiTask;
						aiTask->next = (AITaskData *)0x0;
					}
				}
				else {
					aiTask->next = lego::globals::g_AITaskDataNext;
					lego::globals::g_AITaskDataNext = aiTask;
				}
			}
			else {
				aiTask->next = lego::globals::g_AITaskUnkPtr;
				lego::globals::g_AITaskUnkPtr = aiTask;
			}
		}
		else {
			lego::pool::ReservedPool_AITask___Release(aiTask,0);
		}
	}
	liveObj->aitask_2f0 = pAVar3;
	return;
}



AITaskData * __cdecl lego::game::LiveObject_AITask2F0_GetLast(LiveObject *liveObj)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	pAVar2 = liveObj->aitask_2f0;
	if (pAVar2 != (AITaskData *)0x0) {
		for (pAVar1 = pAVar2->next; pAVar1 != (AITaskData *)0x0; pAVar1 = pAVar1->next) {
			pAVar2 = pAVar1;
		}
	}
	return pAVar2;
}



BOOL __cdecl lego::game::LiveObject_IsCurrentTaskType(LiveObject *liveObj,AITaskType taskType)
{
	AITaskData *pAVar1;
	
	pAVar1 = liveObj->aitask_2f0;
	if (pAVar1 == (AITaskData *)0x0) {
		return (BOOL)(AITaskData *)0x0;
	}
	do {
		if (taskType == pAVar1->taskType) {
			return (BOOL)(AITaskData *)0x1;
		}
		pAVar1 = pAVar1->next;
	} while (pAVar1 != (AITaskData *)0x0);
	return (BOOL)pAVar1;
}



AITaskData * __cdecl lego::game::LiveObject_FUN_00404110(LiveObject *liveObj)
{
	AITaskData *aiTask;
	uint uVar1;
	
	aiTask = liveObj->aitask_2f0;
	if (aiTask != (AITaskData *)0x0) {
		liveObj->aitask_2f0 = aiTask->next;
		uVar1 = aiTask->flags_5c;
		if (((uVar1 & 0x10) != 0) && ((uVar1 & 0x20) == 0)) {
			aiTask->next = globals::g_AITaskUnkPtr;
			globals::g_AITaskUnkPtr = aiTask;
			return liveObj->aitask_2f0;
		}
		if (((uVar1 & 0x2000) != 0) && ((uVar1 & 0x20) == 0)) {
			aiTask->next = globals::g_AITaskDataNext;
			globals::g_AITaskDataNext = aiTask;
			return liveObj->aitask_2f0;
		}
		pool::ReservedPool_AITask___Release(aiTask,0);
	}
	return liveObj->aitask_2f0;
}



BOOL __cdecl lego::ai::AITask_FUN_00404180(AITaskData *param_1,float *param_2)
{
	if ((*(byte *)&param_1->flags_5c & 0x80) == 0) {
		param_1->unkExpiryTime = param_1->unkExpiryTime - *param_2;
	}
	param_1->float_18 = param_1->float_18 - *param_2;
	return 0;
}



undefined4 __cdecl lego::game::LiveObject_DoAITask(LiveObject *liveObj,float *param_2)
{
	float fVar1;
	AITaskType AVar2;
	LiveObject *pLVar3;
	ObjectType OVar4;
	LiveObject *pLVar5;
	bool bVar6;
	bool bVar7;
	BOOL BVar8;
	int iVar9;
	TutorialFlags TVar10;
	ObjectStatsFlags1 OVar11;
	SurfaceMap *surfMap;
	AITaskData *pAVar12;
	float fVar13;
	uint uVar14;
	LiveObject *aiTask;
	float10 fVar15;
	uint x;
	float *pfVar16;
	void *local_6c;
	void *local_68;
	undefined local_64 [4];
	float local_60;
	VehicleData *local_5c;
	float local_58;
	VehicleData *local_54;
	float local_50;
	VehicleData *local_4c;
	float local_48;
	VehicleData *local_44;
	float local_40;
	float local_3c;
	uint local_38;
	int local_34;
	float local_30;
	float local_2c;
	float local_18;
	float local_14;
	
	pLVar3 = liveObj;
	pool::globals::ReservedPool_AITask___g_INITFLAGS =
			 pool::globals::ReservedPool_AITask___g_INITFLAGS | 4;
	if (((((((liveObj->flags3 & 0x400000) == LIVEOBJ3_NONE) ||
				 ((ushort)((ushort)(liveObj->health < 0.0) << 8 | (ushort)(liveObj->health == 0.0) << 0xe)
					!= 0)) || (BVar8 = LiveObject_Check_FUN_004294f0(liveObj), pfVar16 = param_2, BVar8 != 0))
			 || ((liveObj->drivenObject != (LiveObject *)0x0 && (liveObj->objType == OBJECT_MINIFIGURE))))
			|| (liveObj->carryingThisObject != (LiveObject *)0x0)) ||
		 (((liveObj->flags2 & (LIVEOBJ2_UNK_4000|LIVEOBJ2_UNK_8000000)) != LIVEOBJ2_NONE ||
			((liveObj->flags1 & LIVEOBJ1_UNK_800000) != LIVEOBJ1_NONE)))) goto LAB_00404c90;
	pAVar12 = liveObj->aitask_2f0;
	local_6c = (void *)0x0;
	if (pAVar12 == (AITaskData *)0x0) {
		local_60 = 0.0;
		local_5c = (VehicleData *)0x0;
		liveObj->float_338 = *param_2 + liveObj->float_338;
		LiveObject_GetBlockCoordinates(liveObj,(int *)&local_38,&local_34);
		if (((liveObj->float_338 == *pfVar16) || ((*(byte *)&liveObj->flags4 & 0xc0) != 0)) ||
			 (BVar8 = FUN_004439d0(liveObj,&local_38,&local_60,0), BVar8 == 0)) {
			if ((ushort)((ushort)(liveObj->float_338 < 250.0) << 8 |
									(ushort)(liveObj->float_338 == 250.0) << 0xe) == 0) {
				if ((liveObj->objType == OBJECT_MINIFIGURE) &&
					 (BVar8 = LiveObject_Check_FUN_004294f0(liveObj), BVar8 == 0)) {
					LiveObject_FUN_00443930(liveObj);
				}
				liveObj->float_338 = 0.0;
			}
			else {
				liveObj = (LiveObject *)0x0;
				aiTask = (LiveObject *)globals::g_AITaskUnkPtr;
				pLVar5 = (LiveObject *)globals::g_AITaskUnkPtr;
				if (globals::g_AITaskUnkPtr == (AITaskData *)0x0) {
LAB_00404c21:
					if (aiTask != (LiveObject *)0x0) {
						FUN_00406290((undefined4 *)aiTask,(int)liveObj,pLVar3);
						goto LAB_00404c90;
					}
				}
				else {
					do {
						aiTask = pLVar5;
						fVar13 = aiTask->floats_34[10];
						if ((((((uint)fVar13 & 0x80000) == 0) &&
								 ((((uint)fVar13 & 0x100000) != 0 ||
									((BVar8 = FUN_00439c80(pLVar3), BVar8 == 0 &&
									 (fVar13 = aiTask->floats_34[10], ((uint)fVar13 & 0x400) == 0)))))) &&
								((((uint)fVar13 & 0x100) != 0 ||
								 (BVar8 = LiveObject_Check_FUN_004528d0(pLVar3,(uint *)0x0), BVar8 == 0)))) &&
							 ((((uint)aiTask->floats_34[10] & 0x100) == 0 ||
								(BVar8 = LiveObject_FindIndexOfInTable
																	 ((LiveObject **)aiTask->floats_34[3],(uint)aiTask->floats_34[4],
																		pLVar3,(uint *)0x0), BVar8 != 0)))) {
							local_58 = (float)((Point2I *)&aiTask->customName)->x;
							local_54 = aiTask->vehicle;
							BVar8 = ai::AITask_FUN_00404ef0
																((AITaskData *)aiTask,pLVar3,(float *)0x0,&local_58,&param_2,1,1);
							if ((BVar8 != 0) && (param_2 == (float *)0x0)) {
								if (((uint)aiTask->floats_34[10] & 0x100000) != 0) goto LAB_00404c21;
								LiveObject_GetBlockCoordinates(pLVar3,(int *)&local_50,(int *)&local_4c);
								OVar4 = aiTask->objType;
								if ((((OVar4 == OBJECT_UPGRADEPART) || (OVar4 == OBJECT_ELECTRICFENCE)) ||
										(OVar4 == 0x17)) ||
									 ((OVar4 == 0x15 ||
										((OVar4 == OBJECT_DYNAMITE && ((*(byte *)(aiTask->floats_34 + 10) & 8) == 0)))))
									 ) {
									if (((local_58 == local_50) &&
											(uVar14 = (int)(VehicleData *)((int)local_54 - (int)local_4c) >> 0x1f,
											((uint)(VehicleData *)((int)local_54 - (int)local_4c) ^ uVar14) - uVar14 == 1)
											) || ((local_54 == local_4c &&
														(uVar14 = (int)local_58 - (int)local_50 >> 0x1f,
														((int)local_58 - (int)local_50 ^ uVar14) - uVar14 == 1))))
									goto LAB_00404c21;
								}
								else {
									if ((local_58 == local_50) && (local_54 == local_4c)) goto LAB_00404c21;
								}
							}
						}
						if ((((((uint)aiTask->floats_34[10] & 0x400) != 0) &&
								 (BVar8 = FUN_00439c80(pLVar3), BVar8 != 0)) &&
								((pLVar3->flags3 & 0x200000) == LIVEOBJ3_NONE)) &&
							 (pLVar3->objType != OBJECT_ROCKMONSTER)) {
							pLVar5 = pLVar3->carriedObjects[0];
							if ((pLVar5->flags3 & LIVEOBJ3_UNK_80000000) == LIVEOBJ3_NONE) {
								if ((aiTask->upgrade == (UpgradeData *)0x0) ||
									 (((pLVar5->objLevel == aiTask->routingBlocksTotal &&
										 ((aiTask->routeptr_24 == (void *)0xffffffff ||
											((void *)pLVar5->objIndex == aiTask->routeptr_24)))) &&
										((UpgradeData *)pLVar5->objType == aiTask->upgrade)))) {
									OVar4 = aiTask->objType;
									bVar6 = false;
									bVar7 = false;
									if (((OVar4 == OBJECT_ORE) || (OVar4 == OBJECT_BARRIER)) ||
										 ((OVar4 == OBJECT_PATH || (OVar4 == 0x14)))) {
LAB_00404b3f:
										bVar6 = true;
									}
									else {
										if (OVar4 == OBJECT_BOULDER) {
											if ((LiveObject *)aiTask->miniFigure == (LiveObject *)0x0) goto LAB_00404b3f;
											BVar8 = LiveObject_CheckCondition_FUN_00438870
																				((LiveObject *)aiTask->miniFigure,0);
											if (BVar8 != 0) {
												BVar8 = LiveObject_FUN_0043a5c0(pLVar3,(LiveObject *)aiTask->miniFigure);
												if (BVar8 != 0) goto LAB_00404c21;
												bVar7 = true;
											}
										}
									}
									if (bVar6) {
										if (aiTask->objType == OBJECT_BARRIER) {
											iVar9 = FUN_00431ba0((int *)pLVar3,(int *)&aiTask->customName,(int *)&local_48
																					 ,1);
											if (iVar9 == 0) {
												bVar7 = true;
											}
										}
										else {
											local_48 = (float)((Point2I *)&aiTask->customName)->x;
											local_44 = aiTask->vehicle;
										}
										if (!bVar7) {
											LiveObject_GetBlockCoordinates(pLVar3,(int *)&local_40,(int *)&local_3c);
											iVar9 = FUN_00440ef0(pLVar3,local_40,local_3c,local_48,local_44,&local_6c,
																					 &local_68,local_64);
											if (iVar9 == 0) {
												bVar7 = true;
												goto LAB_00404bc6;
											}
											std::free(local_6c);
											std::free(local_68);
											goto LAB_00404c21;
										}
									}
									else {
LAB_00404bc6:
										if (!bVar7) goto LAB_00404bd1;
									}
									aiTask->building = (BuildingData *)0x42960000;
								}
							}
							else {
								if (aiTask->objType == 0x1b) goto LAB_00404c21;
							}
						}
LAB_00404bd1:
						if ((((uint)aiTask->floats_34[10] & 0x100) != 0) &&
							 (BVar8 = LiveObject_FindIndexOfInTable
																	((LiveObject **)aiTask->floats_34[3],(uint)aiTask->floats_34[4],
																	 pLVar3,(uint *)0x0), BVar8 != 0)) {
							aiTask = (LiveObject *)0x0;
							goto LAB_00404c21;
						}
						pLVar5 = (LiveObject *)aiTask->floats_34[0xb];
						liveObj = aiTask;
					} while ((LiveObject *)aiTask->floats_34[0xb] != (LiveObject *)0x0);
				}
				BVar8 = FUN_00439c80(pLVar3);
				if (BVar8 == 0) {
					if ((uint)INT_004b4424 < 0x32) {
						(&DAT_004b435c)[INT_004b4424] = pLVar3;
						INT_004b4424 = INT_004b4424 + 1;
					}
					if (((UINT_004b44f0 < 0x32) && (pLVar3->objType == OBJECT_ROCKMONSTER)) &&
						 ((pLVar3->flags3 & LIVEOBJ3_UNK_80000000) == LIVEOBJ3_NONE)) {
						(&DAT_004b4428)[UINT_004b44f0] = pLVar3;
						UINT_004b44f0 = UINT_004b44f0 + 1;
					}
				}
			}
		}
		else {
			if ((local_60 != 0.0) && (local_5c != (VehicleData *)0x0)) {
				pAVar12 = pool::ReservedPool_AITask___Next(AITASK_GOTO);
				liveObj->aitask_2f0 = pAVar12;
				(pAVar12->position).x = (int)local_60;
				(pAVar12->position).y = (int)local_5c;
			}
		}
		goto LAB_00404c90;
	}
	liveObj->float_338 = 0.0;
	uVar14 = pAVar12->flags_5c;
	if ((uVar14 & 0x20) != 0) {
		LiveObject_FUN_00404110(liveObj);
		LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
		goto LAB_00404c90;
	}
	AVar2 = pAVar12->taskType;
	if ((AVar2 == AITASK_WAIT) &&
		 ((ushort)((ushort)(pAVar12->unkExpiryTime < 0.0) << 8 |
							(ushort)(pAVar12->unkExpiryTime == 0.0) << 0xe) != 0)) {
		LiveObject_FUN_00404110(liveObj);
	}
	else {
		if (AVar2 == AITASK_FOLLOW) {
			if ((ushort)((ushort)(pAVar12->unkExpiryTime < 0.0) << 8 |
									(ushort)(pAVar12->unkExpiryTime == 0.0) << 0xe) != 0) {
				LiveObject_GetBlockCoordinates(liveObj,(int *)&local_48,(int *)&local_44);
				LiveObject_GetBlockCoordinates(pAVar12->object_10,(int *)&local_50,(int *)&local_4c);
				if ((local_48 == local_50) && (local_44 == local_4c)) goto LAB_0040441c;
LAB_004043f4:
				FUN_00404d30((float *)liveObj,&local_50,(float *)0x0);
				pAVar12->unkExpiryTime = 50.0;
			}
		}
		else {
			if (AVar2 == AITASK_FOLLOWATTACK) {
				if ((ushort)((ushort)(pAVar12->unkExpiryTime < 0.0) << 8 |
										(ushort)(pAVar12->unkExpiryTime == 0.0) << 0xe) != 0) {
					fVar13 = pAVar12->object_10->health;
					fVar1 = pAVar12->object_10->stats->PainThreshold;
					if ((ushort)((ushort)(fVar13 < fVar1) << 8 | (ushort)(fVar13 == fVar1) << 0xe) == 0) {
						LiveObject_GetPosition(liveObj,&local_48,(float *)&local_44);
						LiveObject_GetPosition(pAVar12->object_10,&local_58,(float *)&local_54);
						fVar13 = SQRT(((float)local_44 - (float)local_54) * ((float)local_44 - (float)local_54)
													+ (local_48 - local_58) * (local_48 - local_58));
						if ((ushort)((ushort)(fVar13 < 130.0) << 8 | (ushort)(fVar13 == 130.0) << 0xe) == 0) {
							LiveObject_GetBlockCoordinates(liveObj,(int *)&local_60,(int *)&local_5c);
							LiveObject_GetBlockCoordinates(pAVar12->object_10,(int *)&local_50,(int *)&local_4c);
							if ((local_60 != local_50) || (local_5c != local_4c)) goto LAB_004043f4;
						}
						else {
							iVar9 = FUN_00442190(liveObj,(int *)pAVar12->object_10,2);
							if (iVar9 == 0) {
								pAVar12->unkExpiryTime = 25.0;
								goto LAB_004047ed;
							}
						}
LAB_0040441c:
						pAVar12->unkExpiryTime = 50.0;
					}
					else {
						pAVar12->flags_5c = uVar14 | 0x20;
					}
				}
			}
			else {
				if (((uVar14 & 1) == 0) && ((liveObj->flags3 & 0x200000) == LIVEOBJ3_NONE)) {
					iVar9 = 1;
					switch(AVar2) {
					case AITASK_GOTO:
						LiveObject_GetBlockCoordinates(liveObj,(int *)&local_48,(int *)&local_44);
						if ((local_48 == (float)(pAVar12->position).x) &&
							 (local_44 == (VehicleData *)(pAVar12->position).y)) {
							iVar9 = 1;
							LiveObject_FUN_00404110(liveObj);
						}
						else {
							uVar14 = (pAVar12->position).y;
							x = (pAVar12->position).x;
							pfVar16 = &local_30;
							surfMap = GetSurfaceMap();
							SurfaceMap_FillStruct30_FUN_00450390(surfMap,x,uVar14,pfVar16);
							fVar15 = math::Maths_RandRange(local_30 - -6.0,local_18 - 6.0);
							local_40 = (float)fVar15;
							fVar15 = math::Maths_RandRange(local_14 - -6.0,local_2c - 6.0);
							local_3c = (float)fVar15;
							OVar11 = LiveObject_GetStatsFlags1(liveObj);
							iVar9 = FUN_00404d30((float *)liveObj,(float *)&pAVar12->position,
																	 (float *)(-(uint)((OVar11 & STATS1_ROUTEAVOIDANCE) != STATS1_NONE
																										) & (uint)&local_40));
						}
						break;
					case AITASK_COLLECT:
						iVar9 = FUN_00439ce0(liveObj,pAVar12->object_10);
						break;
					case AITASK_GATHER:
						iVar9 = LiveObject_TryCarryBoulder_FUN_00447390(liveObj);
						break;
					case AITASK_DEPOSITE:
						iVar9 = LiveObject_FUN_0043a5c0(liveObj,pAVar12->object_10);
						break;
					case AITASK_DUMP:
						iVar9 = FUN_0043a3e0((int *)liveObj,(float *)&pAVar12->position,
																 (float *)&pAVar12->pointf_30,1,uVar14 & 0x800);
						break;
					case AITASK_REQUEST:
						iVar9 = FUN_0043a3e0((int *)liveObj,(float *)&pAVar12->position,
																 (float *)&pAVar12->pointf_30,1,uVar14 & 0x800);
						break;
					case AITASK_DIG:
						if ((((uVar14 & 8) != 0) &&
								(OVar11 = LiveObject_GetStatsFlags1(liveObj),
								(OVar11 & STATS1_SINGLEWIDTHDIG) != STATS1_NONE)) ||
							 ((*(byte *)&pAVar12->flags_5c & 8) == 0)) {
							iVar9 = LiveObject_FUN_00447100
																(liveObj,(pAVar12->position).x,(pAVar12->position).y,
																 pAVar12->flags_5c & 8);
						}
						break;
					case AITASK_DYNAMITE:
						iVar9 = FUN_00448ac0((int *)liveObj,(uint *)&pAVar12->position);
						break;
					case AITASK_REPAIR:
						iVar9 = LiveObject_TryRepair_FUN_00449360
															(liveObj,pAVar12->object_10,1,uVar14 & 0x200000);
						break;
					case AITASK_REINFORCE:
						iVar9 = FUN_00449500((int *)liveObj,(uint *)&pAVar12->position);
						break;
					case AITASK_CLEAR:
						iVar9 = FUN_00449570((int *)liveObj,(float *)&pAVar12->position);
						break;
					case AITASK_ELECFENCE:
						iVar9 = FUN_00448d20((int *)liveObj,(float *)&pAVar12->position);
						break;
					case AITASK_EAT:
						iVar9 = FUN_00449d80(liveObj,pAVar12->object_10);
						break;
					case AITASK_GOTOEAT:
						iVar9 = FUN_00449d80(liveObj,pAVar12->object_10);
						break;
					case AITASK_FINDDRIVER:
						iVar9 = FUN_00440690((int *)liveObj,(float *)pAVar12->object_10);
						break;
					case AITASK_GETTOOL:
						iVar9 = LiveObject_DoGetTool(liveObj,pAVar12->toolType);
						LiveObject_UpdateBubbleImage(liveObj);
						break;
					case AITASK_BIRDSCARER:
						iVar9 = LiveObject_DoBirdScarer(liveObj,&pAVar12->position);
						break;
					case AITASK_UPGRADE:
						iVar9 = FUN_00448f50((int *)liveObj,(float *)pAVar12->object_10,pAVar12->objLevel);
						break;
					case AITASK_BUILDPATH:
						iVar9 = FUN_00448f10((uint *)liveObj);
						break;
					case AITASK_TRAIN:
						iVar9 = FUN_00449170((int *)liveObj,(int *)pAVar12->object_10,0);
						break;
					case AITASK_DEPART:
						iVar9 = LiveObject_FUN_004499c0(liveObj);
						break;
					case AITASK_ATTACKPATH:
						iVar9 = FUN_004498d0(liveObj,(float *)&pAVar12->position);
						break;
					case AITASK_ATTACKROCKMONSTER:
						pLVar3 = pAVar12->object_10;
						if ((pLVar3 == (LiveObject *)0x0) || (pLVar3->object_364 == (LiveObject *)0x0)) {
LAB_0040469f:
							iVar9 = FUN_004496f0((int *)liveObj,(float *)pAVar12->object_10);
						}
						else {
							if ((pLVar3->flags2 & LIVEOBJ2_UNK_8000000) == LIVEOBJ2_NONE) {
								TVar10 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
								if ((TVar10 == TUTORIAL_NONE) ||
									 (pAVar12->object_10->stats->PainThreshold <= pAVar12->object_10->health))
								goto LAB_0040469f;
								iVar9 = 0;
							}
							else {
								iVar9 = 0;
							}
						}
						break;
					case AITASK_RECHARGE:
						iVar9 = LiveObject_FUN_004492d0(liveObj);
						break;
					case AITASK_DOCK:
						iVar9 = FUN_004402b0((int *)liveObj);
						break;
					case AITASK_ATTACKOBJECT:
						iVar9 = FUN_004497e0((int *)liveObj,(undefined4 *)pAVar12->object_10);
						break;
					case AITASK_FINDLOAD:
						iVar9 = FUN_00440130((int *)liveObj,(float *)pAVar12->object_10);
					}
					if (iVar9 == 0) {
						local_6c = (void *)0x1;
					}
					else {
						pAVar12->flags_5c = pAVar12->flags_5c | 1;
					}
				}
			}
		}
	}
LAB_004047ed:
	if (local_6c != (void *)0x0) {
		if ((pAVar12->taskType == AITASK_DIG) && ((*(byte *)&pAVar12->flags_5c & 8) != 0)) {
			pAVar12->float_18 = (float)&DAT_42c80000;
		}
		if (((*(byte *)&pAVar12->flags_5c & 0x10) != 0) && (pAVar12->unkExpiryTime < 0.0)) {
			pAVar12->unkExpiryTime = 1500.0;
		}
		LiveObject_FUN_00404110(liveObj);
	}
LAB_00404c90:
	pool::globals::ReservedPool_AITask___g_INITFLAGS =
			 pool::globals::ReservedPool_AITask___g_INITFLAGS & 0xfffffffb;
	return 0;
}



undefined4 __cdecl FUN_00404d30(float *param_1,float *param_2,float *param_3)
{
	float *liveObj;
	int iVar1;
	float *local_10;
	uint local_c;
	float local_8;
	float local_4;
	
	liveObj = param_1;
	lego::game::LiveObject_GetBlockCoordinates((LiveObject *)param_1,(int *)&local_8,(int *)&local_4);
	if ((local_8 == *param_2) && (local_4 == param_2[1])) {
		param_1 = &local_8;
		local_10 = &local_4;
		local_c = 1;
	}
	else {
		iVar1 = FUN_00440ef0(liveObj,local_8,local_4,*param_2,param_2[1],&param_1,&local_10,&local_c);
		if (iVar1 == 0) {
			return 0;
		}
	}
	lego::game::LiveObject_FUN_004419c0((LiveObject *)liveObj,local_c,param_1,local_10,param_3);
	if (param_1 != &local_8) {
		std::free(param_1);
		std::free(local_10);
	}
	return 1;
}



void __cdecl FUN_00404e00(int *param_1)
{
	if ((*param_1 == OBJECT_POWERCRYSTAL) && ((param_1[0xfa] & 0x80000000U) != 0)) {
		lego::game::LiveObject_FindRechargeSeam_FUN_0044a690((LiveObject *)param_1,(Point2I *)0x0);
		return;
	}
	FUN_00404e40(*param_1,param_1[1],param_1[0xcc]);
	return;
}



void __cdecl FUN_00404e40(ObjectType objType,int objIndex,int objLevel)
{
	ObjectType local_c;
	int local_8;
	char *local_4;
	
	local_c = objType;
	local_8 = objIndex;
	local_4 = (char *)objLevel;
	lego::ai::AITask_DoUnkCallbacks(FUN_00404e80,(LiveObject *)&local_c);
	return;
}



undefined4 __cdecl FUN_00404e80(int *param_1,int *param_2)
{
	int iVar1;
	BOOL BVar2;
	
	iVar1 = *param_1;
	if (iVar1 != 5) {
		if (((iVar1 != 7) && (iVar1 != 9)) && (iVar1 != 0xf)) {
			return 0;
		}
		if (((iVar1 != 5) && ((LiveObject *)param_1[4] != (LiveObject *)0x0)) &&
			 (BVar2 = lego::game::LiveObject_CheckCondition_FUN_00438870((LiveObject *)param_1[4],0),
			 BVar2 == 0)) {
			return 0;
		}
	}
	if ((param_1[8] != 0) &&
		 (((*param_2 != param_1[8] || ((param_1[9] != -1 && (param_2[1] != param_1[9])))) ||
			(param_2[2] != param_1[10])))) {
		return 0;
	}
	return 1;
}



BOOL __cdecl
lego::ai::AITask_FUN_00404ef0
					(AITaskData *aiTask,LiveObject *liveObj_2,float *param_3,float *param_4,
					undefined4 *param_5,int param_6,int param_7)
{
	Point2I *pPVar1;
	AITaskType AVar2;
	ObjectType OVar3;
	LiveFlags5 LVar4;
	ObjectStatsFlags1 OVar5;
	BOOL BVar6;
	Container *pCVar7;
	ObjectStatsFlags3 OVar8;
	SurfaceMap *pSVar9;
	int iVar10;
	LiveObject *pLVar11;
	BOOL BVar12;
	float10 fVar13;
	float fVar14;
	uint uVar15;
	float y;
	uint uVar16;
	float *pfVar17;
	Vector3F local_18;
	Vector3F local_c;
	
	if (param_5 != (undefined4 *)0x0) {
		*param_5 = 0;
	}
	if (((aiTask->taskType != AITASK_COLLECT) || (aiTask->object_10->objType != OBJECT_DYNAMITE)) &&
		 ((ushort)((ushort)(aiTask->float_18 < 0.0) << 8 | (ushort)(aiTask->float_18 == 0.0) << 0xe) ==
			0)) {
		return 0;
	}
	OVar5 = game::LiveObject_GetStatsFlags1(liveObj_2);
	if (((OVar5 & STATS1_CANBEDRIVEN) != STATS1_NONE) &&
		 (liveObj_2->drivenObject == (LiveObject *)0x0)) {
		return 0;
	}
	if ((liveObj_2->flags1 & LIVEOBJ1_UNK_800000) != LIVEOBJ1_NONE) {
		return 0;
	}
	if ((liveObj_2->flags4 & 0x400) != LIVEOBJ4_NONE) {
		return 0;
	}
	if (((((byte)globals::g_Game.flags2 & 1) != 0) &&
			(BVar6 = game::LiveObject_MiniFigureHasBeamEquipped(liveObj_2), BVar6 != 0)) &&
		 (aiTask->taskType != AITASK_ATTACKROCKMONSTER)) {
		return 0;
	}
	AVar2 = aiTask->taskType;
	if (AVar2 == AITASK_ATTACKROCKMONSTER) {
		BVar6 = game::LiveObject_MiniFigureHasBeamEquipped(liveObj_2);
		if (BVar6 == 0) {
			return 0;
		}
		BVar6 = game::LiveObject_FUN_004723f0(liveObj_2,(undefined4 *)aiTask->object_10);
		if (BVar6 == 0) {
			return 0;
		}
		BVar6 = game::LiveObject_SeeThroughWalls_FUN_00471c20(liveObj_2,aiTask->object_10);
		if (BVar6 != 0) {
			return 0;
		}
		BVar6 = game::LiveObject_CheckCondition_FUN_00438870(aiTask->object_10,1);
		if (BVar6 == 0) {
			return 0;
		}
		if (((byte)globals::g_Game.flags2 & GAME2_CALLTOARMS) == 0) {
			return 0;
		}
		if (param_3 != (float *)0x0) {
			game::LiveObject_GetPosition(aiTask->object_10,param_3,param_3 + 1);
		}
		if (param_4 != (float *)0x0) {
			game::LiveObject_GetBlockCoordinates(aiTask->object_10,(int *)param_4,(int *)(param_4 + 1));
			return 1;
		}
	}
	else {
		if (AVar2 == AITASK_FINDLOAD) {
			pCVar7 = game::LiveObject_GetDepositNull(aiTask->object_10);
			if ((pCVar7 == (Container *)0x0) ||
				 (OVar8 = game::LiveObject_GetStatsFlags3(liveObj_2),
				 (OVar8 & STATS3_VEHICLECANBECARRIED) == STATS3_NONE)) {
				return 0;
			}
			res::Container_GetPosition(pCVar7,(Container *)0x0,&local_18);
			if (param_3 != (float *)0x0) {
				*param_3 = local_18.x;
				param_3[1] = local_18.y;
			}
			if (param_4 != (float *)0x0) {
				pfVar17 = param_4 + 1;
				pSVar9 = game::GetSurfaceMap();
				game::SurfaceMap_ToBlockCoordinatesNoZ
									(pSVar9,local_18.x,local_18.y,(int *)param_4,(int *)pfVar17);
				return 1;
			}
		}
		else {
			if (AVar2 == AITASK_COLLECT) {
				if ((*(byte *)&liveObj_2->flags3 & 0x40) == 0) {
					return 0;
				}
				BVar6 = FUN_00439e90(liveObj_2,aiTask->object_10,1);
				if (BVar6 == 0) {
					return 0;
				}
				if ((liveObj_2->objType == OBJECT_VEHICLE) &&
					 (iVar10 = game::LiveObject_GetMaxCarry(liveObj_2), iVar10 == 0)) {
					return 0;
				}
				pLVar11 = aiTask->object_10;
				OVar3 = pLVar11->objType;
				if (((OVar3 == OBJECT_DYNAMITE) && ((*(byte *)&liveObj_2->flags5_3f0 & 8) == 0)) &&
					 (param_7 != 0)) {
					return 0;
				}
				if ((liveObj_2->objType == OBJECT_ROCKMONSTER) && (OVar3 != OBJECT_POWERCRYSTAL)) {
					return 0;
				}
				if (liveObj_2->objType == OBJECT_VEHICLE) {
					if (OVar3 == OBJECT_BARRIER) {
						return 0;
					}
					if ((OVar3 == OBJECT_POWERCRYSTAL) &&
						 ((pLVar11->flags3 & LIVEOBJ3_UNK_80000000) != LIVEOBJ3_NONE)) {
						return 0;
					}
					if (((liveObj_2->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
						 (liveObj_2->carriedObjects[0]->objType == OBJECT_ELECTRICFENCE)) {
						return 0;
					}
				}
				iVar10 = FUN_00404e00((int *)pLVar11);
				if (iVar10 == 0) {
					return 0;
				}
				BVar6 = FUN_00439e40(liveObj_2,(undefined4 *)aiTask->object_10);
				if (BVar6 == 0) {
					return 0;
				}
				if (param_3 != (float *)0x0) {
					game::LiveObject_GetPosition(aiTask->object_10,param_3,param_3 + 1);
				}
				if (param_4 != (float *)0x0) {
					game::LiveObject_GetBlockCoordinates
										(aiTask->object_10,(int *)param_4,(int *)(param_4 + 1));
					return 1;
				}
			}
			else {
				if ((((AVar2 == AITASK_DIG) || (AVar2 == AITASK_GOTO)) || (AVar2 == AITASK_REINFORCE)) ||
					 (AVar2 == AITASK_CLEAR)) {
					BVar6 = 1;
					if (AVar2 == AITASK_DIG) {
						BVar6 = game::LiveObject_FUN_004326a0
															(liveObj_2,(aiTask->position).x,(aiTask->position).y,
															 aiTask->flags_5c & 8,1);
					}
					if (((param_6 != 0) && (AVar2 = aiTask->taskType, AVar2 != AITASK_GOTO)) &&
						 ((AVar2 != AITASK_DYNAMITE &&
							(BVar12 = game::LiveObject_TaskHasTool_FUN_0044b780(liveObj_2,AVar2), BVar12 == 0))))
					{
						return 0;
					}
					if ((aiTask->taskType == AITASK_REINFORCE) && (liveObj_2->objType != OBJECT_MINIFIGURE)) {
						return 0;
					}
					if ((aiTask->taskType == AITASK_CLEAR) &&
						 (OVar5 = game::LiveObject_GetStatsFlags1(liveObj_2),
						 (OVar5 & STATS1_CANCLEARRUBBLE) == STATS1_NONE)) {
						return 0;
					}
					if (aiTask->taskType == AITASK_DIG) {
						if ((*(byte *)&liveObj_2->flags3 & 2) == 0) {
							return 0;
						}
						if (BVar6 == 0) {
							return 0;
						}
						if (((*(byte *)&aiTask->flags_5c & 8) != 0) &&
							 (OVar5 = game::LiveObject_GetStatsFlags1(liveObj_2),
							 (OVar5 & STATS1_SINGLEWIDTHDIG) == STATS1_NONE)) {
							return 0;
						}
					}
					if (param_3 != (float *)0x0) {
						uVar16 = (aiTask->position).y;
						pfVar17 = param_3 + 1;
						uVar15 = (aiTask->position).x;
						pSVar9 = game::GetSurfaceMap();
						game::SurfaceMap_FUN_0044f900(pSVar9,uVar15,uVar16,param_3,pfVar17);
					}
					if (param_4 != (float *)0x0) {
						*param_4 = (float)(aiTask->position).x;
						param_4[1] = (float)(aiTask->position).y;
					}
				}
				else {
					if (AVar2 == AITASK_REPAIR) {
						if ((param_6 != 0) &&
							 (BVar6 = game::LiveObject_TaskHasTool_FUN_0044b780(liveObj_2,AITASK_REPAIR),
							 BVar6 == 0)) {
							return 0;
						}
						if (((param_7 != 0) && ((*(byte *)&liveObj_2->flags5_3f0 & 0x10) == 0)) &&
							 ((aiTask->flags_5c & 0x200000) == 0)) {
							return 0;
						}
						if (liveObj_2->objType != OBJECT_MINIFIGURE) {
							return 0;
						}
						if (param_3 != (float *)0x0) {
							game::LiveObject_GetPosition(aiTask->object_10,param_3,param_3 + 1);
							if (param_4 == (float *)0x0) {
								return 1;
							}
							game::LiveObject_GetBlockCoordinates
												(aiTask->object_10,(int *)param_4,(int *)(param_4 + 1));
							return 1;
						}
					}
					else {
						if (AVar2 == AITASK_GOTOEAT) {
							BVar6 = game::LiveObject_CheckCondition_FUN_00438870(aiTask->object_10,0);
							if (BVar6 == 0) {
								return 0;
							}
							if (((liveObj_2->objType == OBJECT_MINIFIGURE) &&
									((liveObj_2->flags2 & LIVEOBJ2_UNK_800) == LIVEOBJ2_NONE)) &&
								 (fVar14 = liveObj_2->health * 0.01 * globals::g_Game.MinEnergyForEat,
								 (ushort)((ushort)(liveObj_2->energy < fVar14) << 8 |
												 (ushort)(liveObj_2->energy == fVar14) << 0xe) != 0)) {
								if ((liveObj_2->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
									return 1;
								}
								return 0;
							}
							return 0;
						}
						if (AVar2 == AITASK_FINDDRIVER) {
							if ((((liveObj_2->objType != OBJECT_MINIFIGURE) ||
									 (liveObj_2->aitask_2f0 != (AITaskData *)0x0)) ||
									(liveObj_2->drivenObject != (LiveObject *)0x0)) ||
								 (((aiTask->mode_3c & liveObj_2->flags5_3f0) == LIVEOBJ5_NONE && (param_7 != 0)))) {
								return 0;
							}
							OVar5 = game::LiveObject_GetStatsFlags1(aiTask->object_10);
							if ((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) {
								if ((((*(byte *)&aiTask->object_10->flags4 & 0x40) != 0) &&
										(pLVar11 = aiTask->object_10->object_2fc, pLVar11 != (LiveObject *)0x0)) &&
									 ((pLVar11->objType == OBJECT_BUILDING &&
										(pCVar7 = res::Building_GetEntranceNull(pLVar11->building),
										pCVar7 != (Container *)0x0)))) {
									res::Container_GetPosition(pCVar7,(Container *)0x0,&local_c);
									if (param_3 != (float *)0x0) {
										*param_3 = local_c.x;
										param_3[1] = local_c.y;
									}
									if (param_4 == (float *)0x0) {
										return 1;
									}
									pfVar17 = param_4 + 1;
									pSVar9 = game::GetSurfaceMap();
									game::SurfaceMap_ToBlockCoordinatesNoZ
														(pSVar9,local_c.x,local_c.y,(int *)param_4,(int *)pfVar17);
									return 1;
								}
								iVar10 = FUN_0043a100((undefined4 *)aiTask->object_10,(uint *)&local_18);
								if (iVar10 == 0) {
									return 0;
								}
								if (param_3 != (float *)0x0) {
									pfVar17 = param_3 + 1;
									fVar14 = local_18.x;
									y = local_18.y;
									pSVar9 = game::GetSurfaceMap();
									game::SurfaceMap_FUN_0044f900(pSVar9,(uint)fVar14,(uint)y,param_3,pfVar17);
								}
								if (param_4 == (float *)0x0) {
									return 1;
								}
								*param_4 = local_18.x;
								param_4[1] = local_18.y;
								return 1;
							}
							if (param_3 != (float *)0x0) {
								game::LiveObject_GetPosition(aiTask->object_10,param_3,param_3 + 1);
								if (param_4 == (float *)0x0) {
									return 1;
								}
								game::LiveObject_GetBlockCoordinates
													(aiTask->object_10,(int *)param_4,(int *)(param_4 + 1));
								return 1;
							}
						}
						else {
							if (AVar2 == AITASK_UPGRADE) {
								if (liveObj_2->objType != OBJECT_VEHICLE) {
									return 0;
								}
								if (liveObj_2->drivenObject != (LiveObject *)0x0) {
									pCVar7 = game::LiveObject_GetDepositNull(aiTask->object_10);
									res::Container_GetPosition(pCVar7,(Container *)0x0,&local_c);
									if (param_3 != (float *)0x0) {
										*param_3 = local_c.x;
										param_3[1] = local_c.y;
									}
									if (param_4 == (float *)0x0) {
										return 1;
									}
									pfVar17 = param_4 + 1;
									pSVar9 = game::GetSurfaceMap();
									game::SurfaceMap_ToBlockCoordinatesNoZ
														(pSVar9,local_c.x,local_c.y,(int *)param_4,(int *)pfVar17);
									return 1;
								}
								return 0;
							}
							if (AVar2 != AITASK_TRAIN) {
								if (AVar2 == AITASK_BUILDPATH) {
									if (liveObj_2->objType != OBJECT_MINIFIGURE) {
										return 0;
									}
									pPVar1 = &aiTask->position;
									iVar10 = util::return_1(pPVar1);
									if (iVar10 != 0) {
										if (param_3 != (float *)0x0) {
											uVar16 = (aiTask->position).y;
											pfVar17 = param_3 + 1;
											uVar15 = pPVar1->x;
											pSVar9 = game::GetSurfaceMap();
											game::SurfaceMap_FUN_0044f900(pSVar9,uVar15,uVar16,param_3,pfVar17);
										}
										if (param_4 == (float *)0x0) {
											return 1;
										}
										*param_4 = (float)pPVar1->x;
										param_4[1] = (float)(aiTask->position).y;
										return 1;
									}
									return 0;
								}
								if (AVar2 == AITASK_GETTOOL) {
									if (((liveObj_2->objType == OBJECT_MINIFIGURE) &&
											(iVar10 = game::LiveObject_GetNumOfToolsCanCarry(liveObj_2), iVar10 != 0)) &&
										 (BVar6 = game::LiveObject_HasToolEquipped(liveObj_2,aiTask->toolType),
										 BVar6 == 0)) {
										game::LiveObject_GetPosition(liveObj_2,(float *)&local_18,&local_18.y);
										pLVar11 = game::Level_GetBuildingAtPosition((Point2F *)&local_18);
										if (pLVar11 != (LiveObject *)0x0) {
											if (param_3 == (float *)0x0) {
												return 1;
											}
											game::LiveObject_GetPosition(pLVar11,param_3,param_3 + 1);
											return 1;
										}
									}
									return 0;
								}
								if (param_5 == (undefined4 *)0x0) {
									return 1;
								}
								*param_5 = 1;
								return 1;
							}
							if (liveObj_2->objType != OBJECT_MINIFIGURE) {
								return 0;
							}
							LVar4 = liveObj_2->flags5_3f0;
							if (((LVar4 & 1) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 1)) {
								return 0;
							}
							if (((LVar4 & 2) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 2)) {
								return 0;
							}
							if (((LVar4 & 4) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 4)) {
								return 0;
							}
							if (((LVar4 & LIVEOBJ5_UNK_8) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 8)) {
								return 0;
							}
							if (((LVar4 & 0x10) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 0x10)) {
								return 0;
							}
							if (((LVar4 & 0x20) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 0x20)) {
								return 0;
							}
							fVar13 = game::Level_GetTrainTime();
							if ((ushort)((ushort)(fVar13 < (float10)liveObj_2->elapsedTime1) << 8 |
													(ushort)(fVar13 == (float10)liveObj_2->elapsedTime1) << 0xe) == 0) {
								return 0;
							}
							if (param_3 != (float *)0x0) {
								game::LiveObject_GetPosition(aiTask->object_10,param_3,param_3 + 1);
							}
						}
					}
					if (param_4 != (float *)0x0) {
						game::LiveObject_GetBlockCoordinates
											(aiTask->object_10,(int *)param_4,(int *)(param_4 + 1));
						return 1;
					}
				}
			}
		}
	}
	return 1;
}



void __cdecl FUN_00405880(void)
{
	LiveObject *liveObj;
	AITaskType AVar1;
	float fVar2;
	float fVar3;
	bool bVar4;
	BOOL BVar5;
	int iVar6;
	ObjectStatsFlags2 OVar7;
	AITaskData *pAVar8;
	uint uVar9;
	AITaskData *pAVar10;
	float10 fVar11;
	LiveObject **local_24;
	AITaskData *local_1c;
	float local_18;
	float local_14;
	float local_10;
	float local_c;
	int local_8;
	int local_4;
	
	local_1c = (AITaskData *)0x0;
	pAVar8 = lego::globals::g_AITaskDataNext;
	if (lego::globals::g_AITaskDataNext != (AITaskData *)0x0) {
		do {
			pAVar10 = pAVar8;
			if ((ushort)((ushort)(pAVar10->float_18 < 0.0) << 8 |
									(ushort)(pAVar10->float_18 == 0.0) << 0xe) != 0) {
				bVar4 = false;
				uVar9 = 0;
				if (UINT_004b44f0 != 0) {
					local_24 = (LiveObject **)&DAT_004b4428;
					do {
						liveObj = *local_24;
						lego::game::LiveObject_GetPosition(liveObj,&local_18,&local_14);
						lego::game::LiveObject_GetBlockCoordinates(liveObj,&local_8,&local_4);
						fVar11 = lego::game::LiveObject_GetPainThreshold(liveObj);
						if (fVar11 < (float10)liveObj->health) {
							AVar1 = pAVar10->taskType;
							if (AVar1 == AITASK_GATHER) {
								BVar5 = lego::game::LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj);
								if ((BVar5 != 0) && (iVar6 = FUN_004373c0(4,0), iVar6 != 0)) {
									bVar4 = true;
								}
							}
							else {
								if (AVar1 == AITASK_REPAIR) {
									OVar7 = lego::game::LiveObject_GetStatsFlags2(liveObj);
									if (((OVar7 & STATS2_DRAINPOWER) == STATS2_NONE) ||
										 ((BVar5 = lego::game::LiveObject_CheckCondition_FUN_00438870
																				 (pAVar10->object_10,0), BVar5 != 0 &&
											(OVar7 = lego::game::LiveObject_GetStatsFlags2(pAVar10->object_10),
											(OVar7 & STATS2_SELFPOWERED) == STATS2_NONE)))) {
										lego::game::LiveObject_GetPosition(pAVar10->object_10,&local_10,&local_c);
										fVar3 = local_18 - local_10;
										fVar2 = local_14 - local_c;
										fVar11 = lego::game::LiveObject_GetAttackRadius(liveObj);
										if ((float10)SQRT(fVar2 * fVar2 + fVar3 * fVar3) < fVar11) {
											bVar4 = true;
											OVar7 = lego::game::LiveObject_GetStatsFlags2(liveObj);
											if ((OVar7 & STATS2_DRAINPOWER) == STATS2_NONE) {
												pAVar10->float_18 = 750.0;
											}
										}
									}
								}
								else {
									if (AVar1 == AITASK_COLLECT) {
										iVar6 = FUN_0043c910(liveObj);
joined_r0x00405a76:
										if (iVar6 != 0) {
											bVar4 = true;
											pAVar10->float_18 = 250.0;
										}
									}
									else {
										if (AVar1 == AITASK_ATTACKPATH) {
											OVar7 = lego::game::LiveObject_GetStatsFlags2(liveObj);
											if ((OVar7 & STATS2_ATTACKPATHS) != STATS2_NONE) {
												bVar4 = true;
											}
										}
										else {
											if (AVar1 == AITASK_GOTO) {
												BVar5 = lego::game::LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj);
												if ((BVar5 != 0) &&
													 (((pAVar10->position).x != local_8 || ((pAVar10->position).y != local_4))
													 )) {
													bVar4 = true;
												}
											}
											else {
												if (AVar1 == AITASK_ATTACKOBJECT) {
													iVar6 = lego::game::LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj);
													goto joined_r0x00405a76;
												}
											}
										}
									}
								}
							}
						}
						if ((pAVar10->taskType == AITASK_DEPART) &&
							 ((BVar5 = lego::game::LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj),
								BVar5 != 0 ||
								(OVar7 = lego::game::LiveObject_GetStatsFlags2(liveObj),
								(OVar7 & STATS2_USEHOLES) != STATS2_NONE)))) {
							bVar4 = true;
						}
						if (bVar4) {
							UINT_004b44f0 = UINT_004b44f0 - 1;
							(&DAT_004b4428)[uVar9] = (&DAT_004b4428)[UINT_004b44f0];
							if ((*(byte *)&pAVar10->flags_5c & 0x40) == 0) {
								if (local_1c == (AITaskData *)0x0) {
									lego::globals::g_AITaskDataNext = pAVar10->next;
								}
								else {
									local_1c->next = pAVar10->next;
								}
								pAVar10->next = (AITaskData *)0x0;
								liveObj->aitask_2f0 = pAVar10;
							}
							else {
								pAVar8 = (AITaskData *)FUN_00406330((undefined4 *)pAVar10);
								liveObj->aitask_2f0 = pAVar8;
							}
							break;
						}
						uVar9 = uVar9 + 1;
						local_24 = local_24 + 1;
					} while (uVar9 < UINT_004b44f0);
				}
			}
			pAVar8 = pAVar10->next;
			local_1c = pAVar10;
		} while (pAVar10->next != (AITaskData *)0x0);
	}
	return;
}



void __cdecl FUN_00405b40(void)
{
	AITaskType AVar1;
	bool bVar2;
	AITaskData *pAVar3;
	BOOL BVar4;
	SurfaceMap *pSVar5;
	BOOL BVar6;
	int iVar7;
	uint uVar8;
	LiveObject *pLVar9;
	LiveObject *pLVar10;
	LiveObject **ppLVar11;
	AITaskData *aiTask;
	float fVar12;
	float fVar13;
	int *piVar14;
	Point2I *out_x;
	int *piVar15;
	LiveObject *local_94;
	LiveObject *local_90;
	LiveObject **local_8c;
	MessageType local_88;
	uint local_84;
	Point2I local_80;
	MessageType local_78;
	float local_74;
	float local_70;
	int local_6c;
	int local_68;
	int local_64;
	int local_60;
	uint local_5c;
	int local_58;
	int local_54;
	AITaskData *local_50;
	float local_4c;
	float local_48;
	float local_44;
	float local_40;
	float local_3c;
	void *local_38;
	int local_34;
	void *local_30;
	Point2F local_2c;
	int local_24;
	int local_20;
	float local_18;
	undefined local_14 [4];
	Point2I local_10;
	Point2F local_8;
	
	local_50 = (AITaskData *)0x0;
	local_44 = 99999.0;
	pAVar3 = lego::globals::g_AITaskUnkPtr;
	if (lego::globals::g_AITaskUnkPtr != (AITaskData *)0x0) {
		do {
			aiTask = pAVar3;
			if (((ushort)((ushort)(aiTask->float_18 < 0.0) << 8 | (ushort)(aiTask->float_18 == 0.0) << 0xe
									 ) != 0) && ((aiTask->flags_5c & 0x80400) == 0)) {
				pLVar9 = (LiveObject *)0x0;
				local_90 = (LiveObject *)0x0;
				local_84 = 0;
				if (INT_004b4424 != 0) {
					local_8c = (LiveObject **)&DAT_004b435c;
					pLVar10 = pLVar9;
					do {
						pLVar9 = *local_8c;
						if (pLVar9 != (LiveObject *)0x0) {
							if ((aiTask->flags_5c & 0x100) == 0) {
								BVar4 = lego::game::LiveObject_Check_FUN_004528d0(pLVar9,(uint *)0x0);
								pLVar10 = local_90;
								if (BVar4 == 0) {
									if ((aiTask->flags_5c & 0x100) != 0) goto LAB_00405bda;
									goto LAB_00405bf5;
								}
							}
							else {
LAB_00405bda:
								BVar4 = lego::game::LiveObject_FindIndexOfInTable
																	((LiveObject **)aiTask->ptr_40,aiTask->field_44,pLVar9,(uint *)0x0
																	);
								pLVar10 = local_90;
								if (BVar4 != 0) {
LAB_00405bf5:
									lego::game::LiveObject_GetPosition(pLVar9,&local_4c,&local_48);
									BVar4 = lego::ai::AITask_FUN_00404ef0
																		(aiTask,pLVar9,&local_74,(float *)0x0,&local_34,1,1);
									if (BVar4 != 0) {
										piVar15 = &local_68;
										piVar14 = &local_6c;
										fVar12 = local_74;
										fVar13 = local_70;
										pSVar5 = lego::game::GetSurfaceMap();
										BVar6 = lego::game::SurfaceMap_ToBlockCoordinatesNoZ
																			(pSVar5,fVar12,fVar13,piVar14,piVar15);
										if (BVar6 != 0) {
											piVar15 = &local_60;
											piVar14 = &local_64;
											fVar12 = local_4c;
											fVar13 = local_48;
											pSVar5 = lego::game::GetSurfaceMap();
											BVar6 = lego::game::SurfaceMap_ToBlockCoordinatesNoZ
																				(pSVar5,fVar12,fVar13,piVar14,piVar15);
											if (BVar6 != 0) {
												AVar1 = aiTask->taskType;
												local_94 = (LiveObject *)0x1;
												if ((((((AVar1 == AITASK_DIG) && ((*(byte *)&aiTask->flags_5c & 8) == 0)) ||
															(AVar1 == AITASK_REPAIR)) ||
														 ((AVar1 == AITASK_REINFORCE || (AVar1 == AITASK_TRAIN)))) ||
														(AVar1 == AITASK_GETTOOL)) &&
													 (((local_64 != local_6c ||
														 (uVar8 = local_60 - local_68 >> 0x1f,
														 (local_60 - local_68 ^ uVar8) - uVar8 != 1)) &&
														((local_60 != local_68 ||
														 (uVar8 = local_64 - local_6c >> 0x1f,
														 (local_64 - local_6c ^ uVar8) - uVar8 != 1)))))) {
													local_24 = local_6c;
													local_20 = local_68;
													iVar7 = FUN_00431ba0((int *)local_90,&local_24,&local_6c,1);
													if (iVar7 == 0) {
														local_94 = (LiveObject *)iVar7;
													}
												}
												if (local_94 != (LiveObject *)0x0) {
													BVar4 = FUN_00440ef0(pLVar9,local_64,local_60,local_6c,local_68,&local_30,
																							 &local_38,local_14);
													if (BVar4 == 0) {
														aiTask->float_18 = 75.0;
													}
													else {
														std::free(local_30);
														std::free(local_38);
													}
												}
											}
										}
									}
									if (local_34 != 0) {
										local_5c = local_84;
										local_40 = local_74;
										local_3c = local_70;
										break;
									}
									pLVar10 = local_90;
									if (BVar4 != 0) {
										local_18 = local_70 - local_48;
										fVar12 = SQRT(local_18 * local_18 +
																	(local_74 - local_4c) * (local_74 - local_4c));
										lego::game::LiveObject_GetFaceDirection(pLVar9,&local_8);
										if ((local_90 == (LiveObject *)0x0) || (fVar12 < local_44)) {
											local_5c = local_84;
											local_40 = local_74;
											local_3c = local_70;
											pLVar10 = pLVar9;
											local_90 = pLVar9;
											local_44 = fVar12;
										}
									}
								}
							}
						}
						pLVar9 = pLVar10;
						local_84 = local_84 + 1;
						local_8c = local_8c + 1;
						pLVar10 = pLVar9;
					} while (local_84 < (uint)INT_004b4424);
				}
				if (pLVar9 == (LiveObject *)0x0) {
					if (((aiTask->flags_5c & 0x1000) == 0) && (uVar8 = 0, INT_004b4424 != 0)) {
						ppLVar11 = (LiveObject **)&DAT_004b435c;
						do {
							pLVar9 = *ppLVar11;
							if (pLVar9 != (LiveObject *)0x0) {
								if ((aiTask->flags_5c & 0x100) == 0) {
									BVar4 = lego::game::LiveObject_Check_FUN_004528d0(pLVar9,(uint *)0x0);
									if (BVar4 == 0) {
										if ((aiTask->flags_5c & 0x100) != 0) goto LAB_004060b6;
										goto LAB_004060cd;
									}
								}
								else {
LAB_004060b6:
									BVar4 = lego::game::LiveObject_FindIndexOfInTable
																		((LiveObject **)aiTask->ptr_40,aiTask->field_44,pLVar9,
																		 (uint *)0x0);
									if (BVar4 != 0) {
LAB_004060cd:
										BVar4 = lego::ai::AITask_FUN_00404ef0
																			(aiTask,pLVar9,(float *)0x0,(float *)0x0,(undefined4 *)0x0,0,1
																			);
										if (BVar4 != 0) {
											lego::ai::AITask_DoGetTool_FromTask(aiTask);
											break;
										}
									}
								}
							}
							uVar8 = uVar8 + 1;
							ppLVar11 = ppLVar11 + 1;
						} while (uVar8 < (uint)INT_004b4424);
					}
					if (((aiTask->taskType != AITASK_TRAIN) && (aiTask->mode_3c != 0)) &&
						 ((aiTask->flags_5c & 0x8000) == 0)) {
						uVar8 = 0;
						local_94 = (LiveObject *)0x0;
						bVar2 = false;
						if (INT_004b4424 != 0) {
							ppLVar11 = (LiveObject **)&DAT_004b435c;
							do {
								pLVar9 = *ppLVar11;
								if (pLVar9 != (LiveObject *)0x0) {
									if ((aiTask->flags_5c & 0x100) == 0) {
										BVar4 = lego::game::LiveObject_Check_FUN_004528d0(pLVar9,(uint *)0x0);
										if (BVar4 == 0) {
											if ((aiTask->flags_5c & 0x100) != 0) goto LAB_0040615f;
											goto LAB_00406176;
										}
									}
									else {
LAB_0040615f:
										BVar4 = lego::game::LiveObject_FindIndexOfInTable
																			((LiveObject **)aiTask->ptr_40,aiTask->field_44,pLVar9,
																			 (uint *)0x0);
										if (BVar4 != 0) {
LAB_00406176:
											BVar4 = lego::ai::AITask_FUN_00404ef0
																				(aiTask,pLVar9,(float *)&local_2c,(float *)0x0,
																				 (undefined4 *)0x0,0,0);
											if ((BVar4 != 0) &&
												 (BVar4 = lego::ai::AITask_FUN_00404ef0
																						(aiTask,pLVar9,(float *)&local_2c,(float *)0x0,
																						 (undefined4 *)0x0,0,1), local_94 = pLVar9, BVar4 != 0))
											{
												bVar2 = true;
												break;
											}
										}
									}
								}
								uVar8 = uVar8 + 1;
								ppLVar11 = ppLVar11 + 1;
							} while (uVar8 < (uint)INT_004b4424);
						}
						if (((local_94 != (LiveObject *)0x0) && (!bVar2)) &&
							 (pLVar9 = (LiveObject *)FUN_00439110((LiveObject *)0x0,&local_2c,aiTask->mode_3c),
							 pLVar9 != (LiveObject *)0x0)) {
							lego::ai::AITask_DoTrain_Target
												(pLVar9,aiTask->mode_3c,(uint)(aiTask->mode_3c != TRAINED_REPAIR));
							aiTask->flags_5c = aiTask->flags_5c | 0x8000;
						}
					}
				}
				else {
					bVar2 = true;
					lego::game::LiveObject_GetBlockCoordinates(pLVar9,&local_58,&local_54);
					piVar15 = &local_80.y;
					out_x = &local_80;
					fVar12 = local_40;
					fVar13 = local_3c;
					pSVar5 = lego::game::GetSurfaceMap();
					lego::game::SurfaceMap_ToBlockCoordinatesNoZ(pSVar5,fVar12,fVar13,(int *)out_x,piVar15);
					AVar1 = aiTask->taskType;
					if (((((AVar1 == AITASK_CLEAR) || (AVar1 == AITASK_COLLECT)) ||
							 (AVar1 == AITASK_BUILDPATH)) || (AVar1 == AITASK_UPGRADE)) &&
						 ((local_58 != local_80.x || (local_54 != local_80.y)))) {
						if (aiTask->object_48 == (LiveObject *)0x0) {
							switch(AVar1) {
							case AITASK_COLLECT:
								local_78 = MESSAGE_COLLECTCRYSTAL;
								break;
							case AITASK_CLEAR:
								local_78 = MESSAGE_CLEAR;
								break;
							case AITASK_UPGRADE:
								local_78 = MESSAGE_UPGRADE;
								break;
							case AITASK_BUILDPATH:
								local_78 = MESSAGE_BUILDPATH;
							}
							lego::game::Level_AddMessageAction(local_78,pLVar9,(BOOL)aiTask,&local_80);
							if ((aiTask->flags_5c & 0x100) == 0) {
								aiTask->object_48 = pLVar9;
							}
							if ((aiTask->taskType == AITASK_CLEAR) && (pLVar9->objType == OBJECT_VEHICLE)) {
								FUN_00402a90(&aiTask->position,1);
								aiTask->float_18 = 0.0;
							}
						}
LAB_00406042:
						bVar2 = false;
					}
					else {
						if ((((AVar1 == AITASK_DIG) && ((*(byte *)&aiTask->flags_5c & 8) == 0)) ||
								(((AVar1 == AITASK_REPAIR || (AVar1 == AITASK_REINFORCE)) ||
								 ((AVar1 == AITASK_TRAIN || (AVar1 == AITASK_GETTOOL)))))) &&
							 (((local_58 != local_80.x ||
								 (uVar8 = local_54 - local_80.y >> 0x1f,
								 (local_54 - local_80.y ^ uVar8) - uVar8 != 1)) &&
								((local_54 != local_80.y ||
								 (uVar8 = local_58 - local_80.x >> 0x1f,
								 (local_58 - local_80.x ^ uVar8) - uVar8 != 1)))))) {
							if (aiTask->object_48 == (LiveObject *)0x0) {
								switch(AVar1) {
								case AITASK_DIG:
									local_88 = MESSAGE_DIG;
									break;
								case AITASK_REPAIR:
									local_88 = MESSAGE_REPAIR;
									break;
								case AITASK_REINFORCE:
									local_88 = MESSAGE_REINFORCE;
									break;
								case AITASK_GETTOOL:
									local_88 = MESSAGE_COLLECTTOOL;
									break;
								case AITASK_TRAIN:
									local_88 = MESSAGE_TRAIN;
								}
								iVar7 = FUN_00431ba0((int *)pLVar9,(int *)&local_80,(int *)&local_10,1);
								if (iVar7 == 0) {
									aiTask->priorityValue = aiTask->priorityValue - 1;
								}
								else {
									lego::game::Level_AddMessageAction(local_88,pLVar9,(BOOL)aiTask,&local_10);
									if ((aiTask->flags_5c & 0x100) == 0) {
										aiTask->object_48 = pLVar9;
									}
								}
							}
							goto LAB_00406042;
						}
					}
					if (bVar2) {
						FUN_00406290((undefined4 *)aiTask,(int)local_50,pLVar9);
					}
					INT_004b4424 = INT_004b4424 + -1;
					(&DAT_004b435c)[local_5c] = (&DAT_004b435c)[INT_004b4424];
				}
			}
			pAVar3 = aiTask->next;
			local_50 = aiTask;
		} while (aiTask->next != (AITaskData *)0x0);
	}
	return;
}



void __cdecl FUN_00406290(undefined4 *param_1,int param_2,LiveObject *liveObj)
{
	AITaskData *pAVar1;
	
	if ((*(byte *)(param_1 + 0x17) & 0x40) == 0) {
		if (param_2 == 0) {
			lego::globals::g_AITaskUnkPtr = (AITaskData *)param_1[0x18];
		}
		else {
			*(undefined4 *)(param_2 + 0x60) = param_1[0x18];
		}
		param_1[0x18] = 0;
		liveObj->aitask_2f0 = (AITaskData *)param_1;
	}
	else {
		pAVar1 = (AITaskData *)FUN_00406330(param_1);
		liveObj->aitask_2f0 = pAVar1;
		if ((param_1[0x17] & 0x40000) != 0) {
			param_1[6] = 0x41c80000;
		}
	}
	lego::game::LiveObject__ReleaseTaskReferences(liveObj);
	lego::game::LiveObject_MiniFigure_FUN_00407380(liveObj);
	return;
}



void __cdecl lego::game::LiveObject__ReleaseTaskReferences(LiveObject *liveObj)
{
	AITaskData **ppAVar1;
	AITaskData *pAVar2;
	
	pAVar2 = globals::g_AITaskUnkPtr;
	if (globals::g_AITaskUnkPtr != (AITaskData *)0x0) {
		do {
			if (pAVar2->object_48 == liveObj) {
				pAVar2->object_48 = (LiveObject *)0x0;
			}
			ppAVar1 = &pAVar2->next;
			pAVar2 = *ppAVar1;
		} while (*ppAVar1 != (AITaskData *)0x0);
	}
	return;
}



void __cdecl FUN_00406330(undefined4 *param_1)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	int iVar3;
	AITaskData *pAVar4;
	
	pAVar2 = lego::pool::ReservedPool_AITask___Next(*param_1);
	pAVar1 = pAVar2->pool_m_next;
	pAVar4 = pAVar2;
	for (iVar3 = 0x1a; iVar3 != 0; iVar3 = iVar3 + -1) {
		pAVar4->taskType = *param_1;
		param_1 = param_1 + 1;
		pAVar4 = (AITaskData *)&pAVar4->field_4;
	}
	pAVar2->pool_m_next = pAVar1;
	pAVar2->flags_5c = pAVar2->flags_5c | 0x200;
	pAVar2->next = (AITaskData *)0x0;
	return;
}



AITaskData * __cdecl lego::pool::ReservedPool_AITask___Next(AITaskType taskType)
{
	AITaskData *pAVar1;
	uint uVar2;
	int iVar3;
	AITaskData *pAVar4;
	
	if (globals::ReservedPool_AITask___g_NEXT == (AITaskData *)0x0) {
		ReservedPool_AITask___Alloc();
	}
	pAVar1 = globals::ReservedPool_AITask___g_NEXT;
	pAVar4 = globals::ReservedPool_AITask___g_NEXT;
	globals::ReservedPool_AITask___g_NEXT = globals::ReservedPool_AITask___g_NEXT->pool_m_next;
	for (iVar3 = 0x1a; iVar3 != 0; iVar3 = iVar3 + -1) {
		pAVar4->taskType = AITASK_GOTO;
		pAVar4 = (AITaskData *)&pAVar4->field_4;
	}
	pAVar1->pool_m_next = pAVar1;
	uVar2 = main::Main_GetTime();
	pAVar1->taskStartTime = uVar2;
	pAVar1->taskType = taskType;
	return pAVar1;
}



void __cdecl lego::pool::ReservedPool_AITask___Release(AITaskData *aiTask,BOOL noRelease2)
{
	if (noRelease2 == 0) {
		ai::AITask_Release_2(aiTask);
	}
	if ((aiTask->ptr_40 != (void *)0x0) && ((aiTask->flags_5c & 0x200) == 0)) {
		std::free(aiTask->ptr_40);
	}
	aiTask->pool_m_next = globals::ReservedPool_AITask___g_NEXT;
	globals::ReservedPool_AITask___g_NEXT = aiTask;
	return;
}



void __cdecl lego::pool::ReservedPool_AITask___Alloc(void)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globals::ReservedPool_AITask___g_COUNT & 0x1f);
	pAVar2 = (AITaskData *)std::malloc(uVar4 * 0x68);
	globals::ReservedPool_AITask___g_TABLE[globals::ReservedPool_AITask___g_COUNT] = pAVar2;
	pAVar2 = globals::ReservedPool_AITask___g_TABLE[globals::ReservedPool_AITask___g_COUNT];
	if (pAVar2 != (AITaskData *)0x0) {
		globals::ReservedPool_AITask___g_COUNT = globals::ReservedPool_AITask___g_COUNT + 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pAVar1 = pAVar2;
			do {
				pAVar1->pool_m_next = pAVar1 + 1;
				iVar3 = iVar3 + -1;
				pAVar1 = pAVar1 + 1;
			} while (iVar3 != 0);
		}
		pAVar2[uVar4 - 1].pool_m_next = globals::ReservedPool_AITask___g_NEXT;
		globals::ReservedPool_AITask___g_NEXT = pAVar2;
	}
	return;
}



BOOL __cdecl lego::ai::AITask_DoUnkCallbacks(undefined *taskFunction,LiveObject *liveObj)
{
	int iVar1;
	int iVar2;
	AITaskData **ppAVar3;
	uint uVar4;
	uint uVar5;
	uint local_4;
	
	local_4 = 0;
	if (pool::globals::ReservedPool_AITask___g_COUNT == 0) {
		return 0;
	}
	ppAVar3 = pool::globals::ReservedPool_AITask___g_TABLE;
	do {
		if (*ppAVar3 != (AITaskData *)0x0) {
			uVar5 = 0;
			uVar4 = 1 << ((byte)local_4 & 0x1f);
			if (uVar4 != 0) {
				iVar2 = 0;
				do {
					iVar1 = (int)&(*ppAVar3)->taskType + iVar2;
					if (((iVar1 != 0) && (*(int *)(iVar1 + 100) == iVar1)) &&
						 (iVar1 = (*(code *)taskFunction)(iVar1,liveObj), iVar1 != 0)) {
						return 1;
					}
					uVar5 = uVar5 + 1;
					iVar2 = iVar2 + 0x68;
				} while (uVar5 < uVar4);
			}
		}
		local_4 = local_4 + 1;
		ppAVar3 = ppAVar3 + 1;
		if (pool::globals::ReservedPool_AITask___g_COUNT <= local_4) {
			return 0;
		}
	} while( true );
}



IDirectDraw4 * __cdecl lego::draw::Draw_GetDirectDraw(void)
{
	return globs::directDrawGlobs.lpDirectDraw;
}



IDirectDrawSurface4 * __cdecl lego::draw::Draw_GetDrawingSurface(void)
{
	return globs::directDrawGlobs.bSurf;
}



void __cdecl
FUN_00406520(float *param_1,float *param_2,float *param_3,float *param_4,float *param_5,
						float param_6)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	
	fVar1 = *param_3 * 3.0 + *param_2;
	fVar5 = param_6 * param_6;
	fVar4 = (fVar1 - *param_2) * 3.0;
	fVar3 = ((*param_4 - *param_5 * 3.0) - fVar1) * 3.0 - fVar4;
	fVar1 = param_5[1];
	fVar6 = param_3[1] * 3.0 + param_2[1];
	fVar2 = param_4[1];
	*param_1 = fVar4 * param_6 +
						 fVar3 * fVar5 + (((*param_4 - *param_2) - fVar4) - fVar3) * fVar5 * param_6 + *param_2;
	fVar3 = (fVar6 - param_2[1]) * 3.0;
	fVar1 = ((fVar2 - fVar1 * 3.0) - fVar6) * 3.0 - fVar3;
	param_1[1] = fVar1 * fVar5 +
							 fVar3 * param_6 + (((param_4[1] - param_2[1]) - fVar3) - fVar1) * fVar5 * param_6 +
							 param_2[1];
	return;
}



float10 __cdecl FUN_00406660(float *param_1,float *param_2)
{
	return SQRT(((float10)param_1[1] - (float10)param_2[1]) *
							((float10)param_1[1] - (float10)param_2[1]) +
							((float10)*param_1 - (float10)*param_2) *
							(float10)(float)((float10)*param_1 - (float10)*param_2));
}



void __cdecl FUN_00406690(float *param_1,float param_2)
{
	float fVar1;
	
	fVar1 = SQRT(*param_1 * *param_1 + param_1[1] * param_1[1]) / param_2;
	*param_1 = *param_1 / fVar1;
	param_1[1] = param_1[1] / fVar1;
	return;
}



float10 __cdecl FUN_004066e0(uint *param_1)
{
	uint *puVar1;
	uint uVar2;
	float *pfVar3;
	float10 fVar4;
	float local_4;
	
	uVar2 = 1;
	local_4 = 0.0;
	param_1[0x65] = 0;
	if (1 < *param_1) {
		pfVar3 = (float *)(param_1 + 0x66);
		puVar1 = param_1;
		do {
			fVar4 = FUN_00406660((float *)(puVar1 + 1),(float *)(puVar1 + 3));
			*pfVar3 = (float)fVar4;
			uVar2 = uVar2 + 1;
			pfVar3 = pfVar3 + 1;
			local_4 = (float)(fVar4 + (float10)local_4);
			puVar1 = puVar1 + 2;
		} while (uVar2 < *param_1);
	}
	return (float10)local_4;
}



void __cdecl
FUN_00406750(uint *param_1,float *param_2,float *param_3,float *param_4,float *param_5,uint param_6)
{
	uint uVar1;
	float *pfVar2;
	
	if (0x31 < param_6) {
		param_6 = 0x32;
	}
	uVar1 = 1;
	*param_1 = param_6;
	param_1[1] = (uint)*param_2;
	param_1[2] = (uint)param_2[1];
	if (1 < param_6) {
		pfVar2 = (float *)(param_1 + 3);
		do {
			FUN_00406520(pfVar2,param_2,param_3,param_4,param_5,
									 (float)(ulonglong)uVar1 * (1.0 / (float)(ulonglong)(param_6 - 1)));
			uVar1 = uVar1 + 1;
			pfVar2 = pfVar2 + 2;
		} while (uVar1 < param_6);
	}
	return;
}



uint __cdecl FUN_004067f0(uint *param_1,float param_2,float *param_3)
{
	float fVar1;
	float fVar2;
	uint uVar3;
	float fVar4;
	uint uVar5;
	float *pfVar6;
	
	fVar4 = 0.0;
	uVar3 = *param_1;
	uVar5 = 1;
	if (1 < uVar3) {
		pfVar6 = (float *)(param_1 + 0x66);
		do {
			fVar4 = fVar4 + *pfVar6;
			if (param_2 < fVar4) break;
			uVar5 = uVar5 + 1;
			pfVar6 = pfVar6 + 1;
		} while (uVar5 < uVar3);
	}
	if (uVar5 < uVar3) {
		*param_3 = (float)param_1[uVar5 * 2 + -1];
		param_3[1] = (float)param_1[uVar5 * 2];
		fVar1 = (float)param_1[uVar5 * 2 + 2];
		fVar2 = (float)param_1[uVar5 * 2];
		fVar4 = (param_2 - (fVar4 - (float)param_1[uVar5 + 0x65])) / (float)param_1[uVar5 + 0x65];
		*param_3 = ((float)param_1[uVar5 * 2 + 1] - (float)param_1[uVar5 * 2 + -1]) * fVar4 +
							 (float)param_1[uVar5 * 2 + -1];
		param_3[1] = (fVar1 - fVar2) * fVar4 + (float)param_1[uVar5 * 2];
		return uVar5;
	}
	*param_3 = (float)param_1[uVar5 * 2 + -1];
	param_3[1] = (float)param_1[uVar5 * 2];
	return uVar5;
}



BOOL __cdecl lego::res::Creature_IsCameraFlipDir(CreatureData *creature)
{
	return (uint)(creature->CameraFlipDir == BOOL3_TRUE);
}



BOOL __cdecl
lego::res::Res_LoadAEFileCreature
					(CreatureData *creature,int index,Container *resRoot,char *aeFilename,char *rootName)
{
	char cVar1;
	int iVar2;
	CFGProperty *prop;
	Container *pCVar3;
	char *pcVar4;
	BOOL3 BVar5;
	PolyMeshData *pPVar6;
	uint uVar7;
	uint uVar8;
	int *piVar9;
	int iVar10;
	undefined4 *puVar11;
	char *pcVar12;
	undefined4 *puVar13;
	BOOL local_994;
	char *local_990;
	int local_98c [99];
	undefined4 local_800 [256];
	char local_400 [1024];
	
	uVar7 = 0xffffffff;
	pcVar4 = aeFilename;
	do {
		pcVar12 = pcVar4;
		if (uVar7 == 0) break;
		uVar7 = uVar7 - 1;
		pcVar12 = pcVar4 + 1;
		cVar1 = *pcVar4;
		pcVar4 = pcVar12;
	} while (cVar1 != '\0');
	uVar7 = ~uVar7;
	puVar11 = (undefined4 *)(pcVar12 + -uVar7);
	puVar13 = local_800;
	for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {
		*puVar13 = *puVar11;
		puVar11 = puVar11 + 1;
		puVar13 = puVar13 + 1;
	}
	local_994 = 0;
	for (uVar7 = uVar7 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {
		*(undefined *)puVar13 = *(undefined *)puVar11;
		puVar11 = (undefined4 *)((int)puVar11 + 1);
		puVar13 = (undefined4 *)((int)puVar13 + 1);
	}
	uVar7 = util::Util_Tokenise((char *)local_800,&local_990,"\\");
	if (1 < uVar7) {
		piVar9 = local_98c;
		iVar10 = uVar7 - 1;
		do {
			iVar2 = *piVar9;
			piVar9 = piVar9 + 1;
			iVar10 = iVar10 + -1;
			*(undefined *)(iVar2 + -1) = 0x5c;
		} while (iVar10 != 0);
	}
	std::sprintf(local_400,"%s\\%s.%s",local_800,(&local_990)[uVar7 - 1],"ae");
	prop = cfg::CFG_Open(local_400);
	if (prop != (CFGProperty *)0x0) {
		pCVar3 = Container_Load(resRoot,aeFilename,"ACT",1);
		creature->aeResData = pCVar3;
		if (pCVar3 != (Container *)0x0) {
			pcVar4 = cfg::CFG_JoinPath(rootName,"CameraNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			creature->CameraNullName = pcVar4;
			if (pcVar4 == (char *)0x0) {
				creature->CameraNullFrames = 0;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 == (char *)0x0) {
					pcVar4 = ____EMPTYSTR__;
				}
				else {
					pcVar4 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
					pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				}
				uVar7 = std::atoi(pcVar4);
				creature->CameraNullFrames = uVar7;
				pcVar4 = cfg::CFG_JoinPath(rootName,"CameraFlipDir",0);
				BVar5 = cfg::CFG_ReadBool(prop,pcVar4);
				creature->CameraFlipDir = BVar5;
			}
			pcVar4 = cfg::CFG_JoinPath(rootName,"DrillNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			creature->DrillNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"FootStepNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			creature->FootStepNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"CarryNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			creature->CarryNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"ThrowNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			creature->ThrowNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"DepositNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			creature->DepositNullName = pcVar4;
			creature->objIndex = index;
			pPVar6 = Res_LoadPolyMesh(prop,rootName,aeFilename,POLY_MEDIUM,1);
			creature->subdata_64 = pPVar6;
			pPVar6 = Res_LoadPolyMesh(prop,rootName,aeFilename,POLY_HIGH,1);
			creature->subdata_68 = pPVar6;
			pPVar6 = Res_LoadPolyMesh(prop,rootName,aeFilename,POLY_FP,creature->CameraNullFrames);
			creature->subdata_6c = pPVar6;
			creature->flags = 1;
			local_994 = 1;
		}
		cfg::CFG_Close(prop);
	}
	return local_994;
}



void __cdecl lego::res::Creature_FUN_00406b30(CreatureData *creature,BOOL notCondition)
{
	PolyMesh_FUN_00451e80(creature->subdata_64,creature->aeResData,(uint)(notCondition == 0),FALSE);
	return;
}



void __cdecl lego::res::Creature_FUN_00406b60(CreatureData *creature,BOOL notCondition)
{
	PolyMesh_FUN_00451e80(creature->subdata_68,creature->aeResData,(uint)(notCondition == 0),FALSE);
	return;
}



void __cdecl
lego::res::Creature_FUN_00406b90(CreatureData *creature,BOOL notCondition,int in_polyIndexUnk)
{
	PolyMesh_FUN_00451e80
						(creature->subdata_6c,creature->aeResData,(uint)(notCondition == 0),in_polyIndexUnk);
	return;
}



void __cdecl FUN_00406bc0(BasicObjectData *basicObjData,BOOL use3rdFrame)
{
	lego::res::Container_Hide(basicObjData->aeResData,use3rdFrame);
	return;
}



void __cdecl lego::res::Creature_Duplicate(CreatureData *in_creature,CreatureData *out_creature)
{
	PolyMeshData *pPVar1;
	Container *pCVar2;
	int iVar3;
	CreatureData *pCVar4;
	CreatureData *pCVar5;
	
	pCVar4 = in_creature;
	pCVar5 = out_creature;
	for (iVar3 = 0x1d; iVar3 != 0; iVar3 = iVar3 + -1) {
		pCVar5->objIndex = pCVar4->objIndex;
		pCVar4 = (CreatureData *)&pCVar4->aeResData;
		pCVar5 = (CreatureData *)&pCVar5->aeResData;
	}
	out_creature->flags = out_creature->flags & 0xfffffffe;
	pPVar1 = PolyMesh_Duplicate(in_creature->subdata_64);
	out_creature->subdata_64 = pPVar1;
	pPVar1 = PolyMesh_Duplicate(in_creature->subdata_68);
	out_creature->subdata_68 = pPVar1;
	pPVar1 = PolyMesh_Duplicate(in_creature->subdata_6c);
	out_creature->subdata_6c = pPVar1;
	pCVar2 = Container_Clone(in_creature->aeResData);
	out_creature->aeResData = pCVar2;
	return;
}



void __cdecl lego::res::Creature_DoCallbacks(CreatureData *creature,float elapsed)
{
	Container_SetAnimationTime(creature->aeResData,elapsed);
	return;
}



float10 __cdecl lego::res::Creature_FUN_00406c60(CreatureData *creature,float elapsed,uint param_3)
{
	float fVar1;
	uint uVar2;
	float10 fVar3;
	
	fVar3 = Container_MoveAnimation(creature->aeResData,elapsed);
	fVar1 = (float)fVar3;
	if ((1 < param_3) && (fVar1 != 0.0)) {
		uVar2 = Container_GetAnimationFrames(creature->aeResData);
		return (float10)fVar1 - (float10)(ulonglong)(uVar2 * (param_3 - 1));
	}
	return (float10)fVar1;
}



float10 __cdecl lego::res::Creature_GetAnimFloat10(CreatureData *creature)
{
	float10 fVar1;
	
	fVar1 = Container_GetAnimationTime(creature->aeResData);
	return fVar1;
}



void __cdecl lego::res::Creature_SetOrientation(CreatureData *creature,float x,float y)
{
	Container_SetOrientation(creature->aeResData,(Container *)0x0,x,y,0.0,0.0,0.0,-1.0);
	return;
}



void __cdecl
lego::res::Creature_SetPosition
					(CreatureData *creature,float x,float y,GetSurfaceZCallback *getZcallback,
					SurfaceMap *surfMap)
{
	float10 fVar1;
	
	fVar1 = (*getZcallback)(x,y,surfMap);
	Container_SetPosition(creature->aeResData,(Container *)0x0,x,y,(float)fVar1);
	return;
}



Container * __cdecl lego::res::Object_GetAEResource(BasicObjectData *basicObjData)
{
	return basicObjData->aeResData;
}



BOOL __cdecl
lego::res::Creature_FUN_00406d70(CreatureData *creature,char *activityName,float elapsed)
{
	uint uVar1;
	BOOL BVar2;
	undefined4 *puVar3;
	
	PolyMesh_FUN_00451ef0(creature->subdata_64);
	PolyMesh_FUN_00451ef0(creature->subdata_68);
	PolyMesh_FUN_00451ef0(creature->subdata_6c);
	uVar1 = 0;
	creature->field_40 = 0;
	creature->field_44 = 0;
	creature->resData_48 = (Container *)0x0;
	creature->field_4c = 0;
	creature->field_50 = 0;
	if (creature->CameraNullFrames != 0) {
		puVar3 = creature->cameraFramesTable_54;
		do {
			*puVar3 = 0;
			uVar1 = uVar1 + 1;
			puVar3 = puVar3 + 1;
		} while (uVar1 < creature->CameraNullFrames);
	}
	BVar2 = Container_SetActivity(creature->aeResData,activityName);
	Container_SetAnimationTime(creature->aeResData,elapsed);
	return BVar2;
}



void __cdecl lego::res::Creature_Destroy(CreatureData *creature)
{
	PolyMesh_Destroy(creature->subdata_64);
	PolyMesh_Destroy(creature->subdata_68);
	PolyMesh_Destroy(creature->subdata_6c);
	if ((*(byte *)&creature->flags & 1) != 0) {
		if (creature->DrillNullName != (char *)0x0) {
			std::free(creature->DrillNullName);
		}
		if (creature->FootStepNullName != (char *)0x0) {
			std::free(creature->FootStepNullName);
		}
		if (creature->CameraNullName != (char *)0x0) {
			std::free(creature->CameraNullName);
		}
		if (creature->CarryNullName != (char *)0x0) {
			std::free(creature->CarryNullName);
		}
		if (creature->ThrowNullName != (char *)0x0) {
			std::free(creature->ThrowNullName);
		}
	}
	Container_Remove(creature->aeResData);
	return;
}



Container * __cdecl FUN_00406e80(BasicObjectData *basicObjData,char *name,int param_3)
{
	char *name_00;
	Container *pCVar1;
	
	name_00 = lego::res::Container_FormatPartName(basicObjData->aeResData,name,&param_3);
	pCVar1 = lego::res::Container_SearchTree
										 (basicObjData->aeResData,name_00,CONTAINER_SEARCHMODE_FIRSTMATCH,
											(undefined4 *)0x0);
	return pCVar1;
}



Container * __cdecl lego::res::Creature_GetCameraNull(CreatureData *creature,int cameraIndex)
{
	Container *pCVar1;
	
	pCVar1 = (Container *)creature->CameraNullName;
	if (pCVar1 != (Container *)0x0) {
		if (creature->cameraFramesTable_54[cameraIndex] == 0) {
			pCVar1 = FUN_00406e80((BasicObjectData *)creature,pCVar1,cameraIndex);
			creature->cameraFramesTable_54[cameraIndex] = pCVar1;
		}
		pCVar1 = (Container *)creature->cameraFramesTable_54[cameraIndex];
	}
	return pCVar1;
}



Container * __cdecl lego::res::Creature_GetDrillNull(CreatureData *creature)
{
	Container *pCVar1;
	
	pCVar1 = (Container *)creature->field_40;
	if (pCVar1 == (Container *)0x0) {
		if (creature->DrillNullName != (char *)0x0) {
			pCVar1 = FUN_00406e80((BasicObjectData *)creature,creature->DrillNullName,0);
			creature->field_40 = pCVar1;
			return pCVar1;
		}
		pCVar1 = (Container *)0x0;
	}
	return pCVar1;
}



Container * __cdecl lego::res::Creature_GetCarryNull(CreatureData *creature)
{
	Container *pCVar1;
	
	if (creature->CarryNullName == (char *)0x0) {
		pCVar1 = (Container *)0x0;
	}
	else {
		pCVar1 = creature->resData_48;
		if (pCVar1 == (Container *)0x0) {
			pCVar1 = FUN_00406e80((BasicObjectData *)creature,creature->CarryNullName,0);
			creature->resData_48 = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Creature_GetDepositNull(CreatureData *creature)
{
	Container *pCVar1;
	
	if (creature->DepositNullName == (char *)0x0) {
		pCVar1 = (Container *)0x0;
	}
	else {
		pCVar1 = (Container *)creature->field_50;
		if (pCVar1 == (Container *)0x0) {
			pCVar1 = FUN_00406e80((BasicObjectData *)creature,creature->DepositNullName,0);
			creature->field_50 = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



BOOL __cdecl FUN_00406f70(CreatureData *creature)
{
	Container *pCVar1;
	float10 fVar2;
	
	if ((creature->field_4c == 0) && (creature->ThrowNullName != (char *)0x0)) {
		pCVar1 = FUN_00406e80((BasicObjectData *)creature,creature->ThrowNullName,0);
		creature->field_4c = pCVar1;
	}
	if ((Container *)creature->field_4c != (Container *)0x0) {
		fVar2 = lego::res::Container_GetZXRatio((Container *)creature->field_4c);
		if (fVar2 != (float10)1.0) {
			return 1;
		}
	}
	return 0;
}



float10 __cdecl lego::game::LiveObject_GetCreatureResFloat(CreatureData *creature)
{
	float10 fVar1;
	
	fVar1 = res::Container_GetTransCoef(creature->aeResData);
	return fVar1;
}



void __cdecl lego::main::Main_Init_Bubble(void)
{
	globals::g_Bubbles_TABLE[0] = "Bubble_CantDo";
	globals::g_Bubbles_TABLE[1] = "Bubble_Idle";
	globals::g_Bubbles_TABLE[2] = "Bubble_CollectCrystal";
	globals::g_Bubbles_TABLE[3] = "Bubble_CollectOre";
	globals::g_Bubbles_TABLE[4] = "Bubble_CollectStud";
	globals::g_Bubbles_TABLE[5] = "Bubble_CollectDynamite";
	globals::g_Bubbles_TABLE[6] = "Bubble_CollectBarrier";
	globals::g_Bubbles_TABLE[7] = "Bubble_CollectElecFence";
	globals::g_Bubbles_TABLE[8] = "Bubble_CollectDrill";
	globals::g_Bubbles_TABLE[9] = "Bubble_CollectSpade";
	globals::g_Bubbles_TABLE[10] = "Bubble_CollectHammer";
	globals::g_Bubbles_TABLE[11] = "Bubble_CollectSpanner";
	globals::g_Bubbles_TABLE[12] = "Bubble_CollectLaser";
	globals::g_Bubbles_TABLE[13] = "Bubble_CollectPusher";
	globals::g_Bubbles_TABLE[14] = "Bubble_CollectFreezer";
	globals::g_Bubbles_TABLE[15] = "Bubble_CollectBirdScarer";
	globals::g_Bubbles_TABLE[16] = "Bubble_CarryCrystal";
	globals::g_Bubbles_TABLE[17] = "Bubble_CarryOre";
	globals::g_Bubbles_TABLE[18] = "Bubble_CarryStud";
	globals::g_Bubbles_TABLE[19] = "Bubble_CarryDynamite";
	globals::g_Bubbles_TABLE[20] = "Bubble_CarryBarrier";
	globals::g_Bubbles_TABLE[21] = "Bubble_CarryElecFence";
	globals::g_Bubbles_TABLE[22] = "Bubble_Goto";
	globals::g_Bubbles_TABLE[23] = "Bubble_Dynamite";
	globals::g_Bubbles_TABLE[24] = "Bubble_Reinforce";
	globals::g_Bubbles_TABLE[25] = "Bubble_Drill";
	globals::g_Bubbles_TABLE[26] = "Bubble_Repair";
	globals::g_Bubbles_TABLE[27] = "Bubble_Dig";
	globals::g_Bubbles_TABLE[28] = "Bubble_Flee";
	globals::g_Bubbles_TABLE[29] = "Bubble_PowerOff";
	globals::g_Bubbles_TABLE[30] = "Bubble_CallToArms";
	globals::g_Bubbles_TABLE[31] = "Bubble_ElecFence";
	globals::g_Bubbles_TABLE[32] = "Bubble_Eat";
	globals::g_Bubbles_TABLE[33] = "Bubble_Drive";
	globals::g_Bubbles_TABLE[34] = "Bubble_Upgrade";
	globals::g_Bubbles_TABLE[35] = "Bubble_BuildPath";
	globals::g_Bubbles_TABLE[36] = "Bubble_Train";
	globals::g_Bubbles_TABLE[37] = "Bubble_Recharge";
	globals::g_Bubbles_TABLE[38] = "Bubble_Request";
	return;
}



void __cdecl lego::main::Main_Load_Bubbles(CFGProperty *root)
{
	char cVar1;
	bool bVar2;
	char *pcVar3;
	CFGProperty *prop;
	ImageBMP *image;
	int iVar4;
	char *pcVar5;
	
	pcVar3 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Bubbles",0);
	prop = cfg::CFG_GetChildren(root,pcVar3);
	do {
		if (prop == (CFGProperty *)0x0) {
			return;
		}
		pcVar3 = prop->key;
		bVar2 = true;
		if (pcVar3 != (char *)0x0) {
			iVar4 = -1;
			pcVar5 = pcVar3;
			do {
				if (iVar4 == 0) break;
				iVar4 = iVar4 + -1;
				cVar1 = *pcVar5;
				pcVar5 = pcVar5 + 1;
			} while (cVar1 != '\0');
			if ((iVar4 != -2) && (*pcVar3 == '!')) {
				if ((globs::mainGlobs.flags & CMD_REDUCEIMAGES) == CMD_NONE) {
					pcVar3 = pcVar3 + 1;
				}
				else {
					bVar2 = false;
				}
			}
		}
		if (bVar2) {
			iVar4 = Main_GetBubbleIndex(pcVar3);
			image = lego::image::Image_LoadBMPScaled(prop->value,0,0);
			globals::g_Bubbles_bmp_TABLE[iVar4] = image;
			if (image != (ImageBMP *)0x0) {
				lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
			}
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



int __cdecl lego::main::Main_GetBubbleIndex(char *bubbleName)
{
	int iVar1;
	char **ppcVar2;
	int iVar3;
	
	iVar3 = 0;
	ppcVar2 = globals::g_Bubbles_TABLE;
	do {
		iVar1 = std::_stricmp(*ppcVar2,bubbleName);
		if (iVar1 == 0) {
			return iVar3;
		}
		ppcVar2 = ppcVar2 + 1;
		iVar3 = iVar3 + 1;
	} while ((int)ppcVar2 < 0x55899c);
	return iVar1;
}



void __cdecl lego::game::Game_ToggleObjectUIsAlwaysVisible(void)
{
	globals::g_ObjectUIsAlwaysVisible = (uint)(globals::g_ObjectUIsAlwaysVisible == 0);
	return;
}



BOOL __cdecl FUN_00407290(void)
{
	return lego::globals::g_ObjectUIsAlwaysVisible;
}



void __cdecl lego::game::LiveObject_UpdateBubbleImage(LiveObject *liveObj)
{
	if (globals::g_ObjectUIsAlwaysVisible != 0) {
		liveObj->field_388 = 0;
		LiveObject_GetCurrentBubbleImage(liveObj,&liveObj->bubbleImage_38c);
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_004072d0(LiveObject *liveObj)
{
	Struct_8__00558bc4 *pSVar1;
	
	pSVar1 = TABLE_50__Struct_8__00558bc4__005589e4;
	do {
		if (liveObj == pSVar1->object_0) {
			pSVar1->object_0 = (LiveObject *)0x0;
		}
		pSVar1 = pSVar1 + 1;
	} while (pSVar1 < TABLE_50__Struct_8__00558bc4__00558a84);
	pSVar1 = TABLE_50__Struct_8__00558bc4__00558a84;
	do {
		if (liveObj == pSVar1->object_0) {
			pSVar1->object_0 = (LiveObject *)0x0;
		}
		pSVar1 = pSVar1 + 1;
	} while (pSVar1 < TABLE_50__Struct_8__00558bc4__00558b24);
	pSVar1 = TABLE_50__Struct_8__00558bc4__00558b24;
	do {
		if (liveObj == pSVar1->object_0) {
			pSVar1->object_0 = (LiveObject *)0x0;
		}
		pSVar1 = pSVar1 + 1;
	} while (pSVar1 < TABLE_50__Struct_8__00558bc4__00558bc4);
	pSVar1 = TABLE_50__Struct_8__00558bc4__00558bc4;
	do {
		if (liveObj == pSVar1->object_0) {
			pSVar1->object_0 = (LiveObject *)0x0;
		}
		pSVar1 = pSVar1 + 1;
	} while (pSVar1 < (Struct_8__00558bc4 *)&DAT_00558d54);
	return;
}



void __cdecl FUN_00407340(LiveObject *liveObj)
{
	Struct_8__00558bc4 *pSVar1;
	int iVar2;
	
	if (liveObj->objType == OBJECT_BUILDING) {
		iVar2 = 0;
		pSVar1 = TABLE_50__Struct_8__00558bc4__00558b24;
		do {
			if (liveObj == pSVar1->object_0) break;
			pSVar1 = pSVar1 + 1;
			iVar2 = iVar2 + 1;
		} while (pSVar1 < TABLE_50__Struct_8__00558bc4__00558bc4);
		if (iVar2 == 0x14) {
			pSVar1 = TABLE_50__Struct_8__00558bc4__00558b24;
			while (pSVar1->object_0 != (LiveObject *)0x0) {
				pSVar1 = pSVar1 + 1;
				if ((Struct_8__00558bc4 *)((int)&TABLE_50__Struct_8__00558bc4__00558b24[0x13].float_4 + 3U)
						< pSVar1) {
					return;
				}
			}
			pSVar1->object_0 = liveObj;
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_MiniFigure_FUN_00407380(LiveObject *liveObj)
{
	Struct_8__00558bc4 *pSVar1;
	int iVar2;
	Struct_8__00558bc4 *pSVar3;
	
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		iVar2 = 0;
		pSVar1 = TABLE_50__Struct_8__00558bc4__00558a84;
		do {
			pSVar3 = pSVar1;
			if (liveObj == pSVar3->object_0) break;
			iVar2 = iVar2 + 1;
			pSVar1 = pSVar3 + 1;
		} while (pSVar3 + 1 < TABLE_50__Struct_8__00558bc4__00558b24);
		if (iVar2 == 0x14) {
			iVar2 = 0;
			pSVar1 = TABLE_50__Struct_8__00558bc4__00558a84;
			do {
				pSVar3 = pSVar1;
				if (pSVar3->object_0 == (LiveObject *)0x0) {
					pSVar3->object_0 = liveObj;
					break;
				}
				iVar2 = iVar2 + 1;
				pSVar1 = pSVar3 + 1;
			} while (pSVar3 + 1 < TABLE_50__Struct_8__00558bc4__00558b24);
			if (iVar2 == 0x14) {
				return;
			}
		}
		pSVar3->float_4 = 12.5;
	}
	return;
}



void __cdecl lego::game::LiveObject_MiniFIgure_FUN_004073e0(LiveObject *liveObj)
{
	Struct_8__00558bc4 *pSVar1;
	int iVar2;
	Struct_8__00558bc4 *pSVar3;
	
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		iVar2 = 0;
		pSVar1 = TABLE_50__Struct_8__00558bc4__00558bc4;
		do {
			pSVar3 = pSVar1;
			if (liveObj == pSVar3->object_0) break;
			iVar2 = iVar2 + 1;
			pSVar1 = pSVar3 + 1;
		} while (pSVar3 + 1 < (Struct_8__00558bc4 *)&DAT_00558d54);
		if (iVar2 == 50) {
			iVar2 = 0;
			pSVar1 = TABLE_50__Struct_8__00558bc4__00558bc4;
			do {
				pSVar3 = pSVar1;
				if (pSVar3->object_0 == (LiveObject *)0x0) {
					pSVar3->object_0 = liveObj;
					break;
				}
				iVar2 = iVar2 + 1;
				pSVar1 = pSVar3 + 1;
			} while (pSVar3 + 1 < (Struct_8__00558bc4 *)&DAT_00558d54);
			if (iVar2 == 50) {
				return;
			}
		}
		pSVar3->float_4 = 2250000.0;
	}
	return;
}



void __cdecl lego::game::LiveObject_MiniFigure_FUN_00407440(LiveObject *liveObj,float param_2)
{
	float *pfVar1;
	
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		pfVar1 = &TABLE_50__Struct_8__00558bc4__00558bc4[0].float_4;
		do {
			if (pfVar1[-1] != 0.0) {
				*pfVar1 = param_2;
			}
			pfVar1 = pfVar1 + 2;
		} while (pfVar1 < &DAT_00558d58);
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_00407470(LiveObject *liveObj)
{
	Struct_8__00558bc4 *pSVar1;
	ObjectStatsFlags3 OVar2;
	int iVar3;
	Struct_8__00558bc4 *pSVar4;
	
	OVar2 = LiveObject_GetStatsFlags3(liveObj);
	if ((OVar2 & STATS3_SHOWHEALTHBAR) != STATS3_NONE) {
		iVar3 = 0;
		pSVar1 = TABLE_50__Struct_8__00558bc4__005589e4;
		do {
			pSVar4 = pSVar1;
			if (liveObj == pSVar4->object_0) break;
			iVar3 = iVar3 + 1;
			pSVar1 = pSVar4 + 1;
		} while (pSVar4 + 1 < TABLE_50__Struct_8__00558bc4__00558a84);
		if (iVar3 == 0x14) {
			iVar3 = 0;
			pSVar1 = TABLE_50__Struct_8__00558bc4__005589e4;
			do {
				pSVar4 = pSVar1;
				if (pSVar4->object_0 == (LiveObject *)0x0) {
					pSVar4->object_0 = liveObj;
					break;
				}
				iVar3 = iVar3 + 1;
				pSVar1 = pSVar4 + 1;
			} while (pSVar4 + 1 < TABLE_50__Struct_8__00558bc4__00558a84);
			if (iVar3 == 0x14) {
				return;
			}
		}
		pSVar4->float_4 = 37.5;
	}
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_004074d0(float param_1)
{
	LiveObject *pLVar1;
	float fVar2;
	ImageBMP *pIVar3;
	BOOL BVar4;
	Container *pCVar5;
	int iVar6;
	Struct_8__00558bc4 *pSVar7;
	float10 fVar8;
	longlong lVar9;
	Container *pCVar10;
	Vector3F *pVVar11;
	Point2F local_14;
	Vector3F local_c;
	
	if ((lego::globals::g_ObjectUIsAlwaysVisible != 0) &&
		 (BVar4 = lego::unk::Game_IsNotBool308__00425cb0(), BVar4 == 0)) {
		lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
							(lego::game::LiveObject_FUN_00407890,(LiveObject *)&param_1);
	}
	pSVar7 = TABLE_50__Struct_8__00558bc4__005589e4;
	do {
		pLVar1 = pSVar7->object_0;
		if (pLVar1 != (LiveObject *)0x0) {
			if ((((pLVar1->objType != OBJECT_MINIFIGURE) || (lego::globals::g_ObjectUIsAlwaysVisible == 0)
					 ) && (BVar4 = lego::unk::Game_IsNotBool308__00425cb0(), BVar4 == 0)) &&
				 ((pLVar1->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE)) {
				pVVar11 = &local_c;
				pCVar10 = (Container *)0x0;
				pCVar5 = lego::game::LiveObject_GetResource(pLVar1);
				lego::res::Container_GetPosition(pCVar5,pCVar10,pVVar11);
				fVar8 = lego::game::LiveObject_GetCollHeight(pLVar1);
				local_c.z = (float)((float10)local_c.z - fVar8);
				lego::view::Viewport_WorldToScreen(lego::globals::g_Game.viewMain,&local_14,&local_c);
				lVar9 = __ftol((float10)local_14.y);
				iVar6 = (int)lVar9;
				lVar9 = __ftol((float10)local_14.x);
				lego::game::LiveObject_FUN_00459dc0(pLVar1,(int)lVar9,iVar6);
			}
			fVar2 = pSVar7->float_4 - param_1;
			pSVar7->float_4 = fVar2;
			if (fVar2 < 0.0) {
				pSVar7->object_0 = (LiveObject *)0x0;
			}
		}
		pSVar7 = pSVar7 + 1;
	} while (pSVar7 < TABLE_50__Struct_8__00558bc4__00558a84);
	BVar4 = lego::unk::Game_IsNotBool308__00425cb0();
	if (BVar4 == 0) {
		if (12.5 <= _DAT_004b9a18) {
			if (25.0 <= _DAT_004b9a18) {
				_DAT_004b9a18 = _DAT_004b9a18 - 25.0;
			}
		}
		else {
			pSVar7 = TABLE_50__Struct_8__00558bc4__00558b24;
			do {
				pIVar3 = lego::globals::g_Bubbles_bmp_TABLE[29];
				pLVar1 = pSVar7->object_0;
				if (pLVar1 != (LiveObject *)0x0) {
					if ((pLVar1->flags3 & LIVEOBJ3_UNK_20000000) == LIVEOBJ3_NONE) {
						pVVar11 = &local_c;
						pCVar10 = (Container *)0x0;
						pCVar5 = lego::game::LiveObject_GetResource(pLVar1);
						lego::res::Container_GetPosition(pCVar5,pCVar10,pVVar11);
						fVar8 = lego::game::LiveObject_GetCollHeight(pLVar1);
						local_c.z = (float)((float10)local_c.z - fVar8);
						lego::view::Viewport_WorldToScreen(lego::globals::g_Game.viewMain,&local_14,&local_c);
						local_14.y = local_14.y - (float)pIVar3->height;
						local_14.x = local_14.x - (float)pIVar3->width * 0.5;
						lego::image::Image_DisplayScaled(pIVar3,(Rect2F *)0x0,&local_14,(Size2F *)0x0);
					}
					else {
						pSVar7->object_0 = (LiveObject *)0x0;
					}
				}
				pSVar7 = pSVar7 + 1;
			} while (pSVar7 < TABLE_50__Struct_8__00558bc4__00558bc4);
		}
		_DAT_004b9a18 = _DAT_004b9a18 + param_1;
	}
	pSVar7 = TABLE_50__Struct_8__00558bc4__00558a84;
	do {
		pLVar1 = pSVar7->object_0;
		if (pLVar1 != (LiveObject *)0x0) {
			if (((pLVar1->objType != OBJECT_MINIFIGURE) || (lego::globals::g_ObjectUIsAlwaysVisible == 0))
				 && (((pLVar1->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE &&
						 (BVar4 = lego::unk::Game_IsNotBool308__00425cb0(), BVar4 == 0)))) {
				local_14.x = 0.0;
				lego::game::LiveObject_FUN_004077f0(pLVar1,param_1,(ImageBMP **)&local_14,&local_c);
				pIVar3 = (ImageBMP *)local_14.x;
				if (((ImageBMP *)local_14.x != (ImageBMP *)0x0) &&
					 ((ImageBMP *)local_14.x != lego::globals::g_Bubbles_bmp_TABLE[1])) {
					lVar9 = __ftol((float10)local_c.y);
					iVar6 = (int)lVar9;
					lVar9 = __ftol((float10)local_c.x);
					FUN_0045a290(pIVar3,(int)lVar9,iVar6);
				}
			}
			fVar2 = pSVar7->float_4 - param_1;
			pSVar7->float_4 = fVar2;
			if (fVar2 < 0.0) {
				pSVar7->object_0 = (LiveObject *)0x0;
			}
		}
		pSVar7 = pSVar7 + 1;
	} while (pSVar7 < TABLE_50__Struct_8__00558bc4__00558b24);
	pSVar7 = TABLE_50__Struct_8__00558bc4__00558bc4;
	do {
		pLVar1 = pSVar7->object_0;
		if (pLVar1 != (LiveObject *)0x0) {
			if (((lego::globals::g_ObjectUIsAlwaysVisible == 0) &&
					((pLVar1->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE)) &&
				 (BVar4 = lego::unk::Game_IsNotBool308__00425cb0(), BVar4 == 0)) {
				local_14.x = 0.0;
				lego::game::LiveObject_FUN_004077f0(pLVar1,param_1,(ImageBMP **)&local_14,&local_c);
				pIVar3 = (ImageBMP *)local_14.x;
				if ((ImageBMP *)local_14.x != (ImageBMP *)0x0) {
					lVar9 = __ftol((float10)local_c.y);
					iVar6 = (int)lVar9;
					lVar9 = __ftol((float10)local_c.x);
					FUN_0045a290(pIVar3,(int)lVar9,iVar6);
				}
			}
			if ((ushort)((ushort)(pSVar7->float_4 < 0.0) << 8 | (ushort)(pSVar7->float_4 == 0.0) << 0xe)
					!= 0) {
				pSVar7->object_0 = (LiveObject *)0x0;
			}
		}
		pSVar7 = pSVar7 + 1;
	} while (pSVar7 < (Struct_8__00558bc4 *)&DAT_00558d54);
	return;
}



void __cdecl
lego::game::LiveObject_FUN_004077f0
					(LiveObject *liveObj,float param_2,ImageBMP **out_bubbleImage,Point2F *param_4)
{
	float fVar1;
	Container *cont;
	float10 fVar2;
	Container *opt_ref;
	Vector3F *out_pos;
	Vector3F local_c;
	
	out_pos = &local_c;
	opt_ref = (Container *)0x0;
	cont = LiveObject_GetResource(liveObj);
	res::Container_GetPosition(cont,opt_ref,out_pos);
	fVar2 = LiveObject_GetCollHeight(liveObj);
	local_c.z = (float)((float10)local_c.z - fVar2);
	lego::view::Viewport_WorldToScreen(globals::g_Game.viewMain,param_4,&local_c);
	fVar1 = (float)liveObj->field_388 - param_2;
	liveObj->field_388 = fVar1;
	if ((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) == 0) {
		*out_bubbleImage = liveObj->bubbleImage_38c;
	}
	else {
		LiveObject_GetCurrentBubbleImage(liveObj,out_bubbleImage);
	}
	if (*out_bubbleImage == (ImageBMP *)0x0) {
		*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[1];
	}
	return;
}



undefined4 __cdecl lego::game::LiveObject_FUN_00407890(LiveObject *liveObj,float *param_2)
{
	float *image;
	int iVar1;
	longlong lVar2;
	float local_8;
	float local_4;
	
	local_8 = *param_2;
	if ((liveObj->objType == OBJECT_MINIFIGURE) &&
		 ((liveObj->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE)) {
		param_2 = (float *)0x0;
		LiveObject_FUN_004077f0(liveObj,local_8,(ImageBMP **)&param_2,&local_8);
		lVar2 = __ftol((float10)local_4);
		iVar1 = (int)lVar2;
		lVar2 = __ftol((float10)local_8);
		LiveObject_FUN_00459dc0(liveObj,(int)lVar2,iVar1);
		lVar2 = __ftol((float10)local_4);
		iVar1 = (int)lVar2;
		lVar2 = __ftol((float10)local_8);
		FUN_0045a210(liveObj,(int)lVar2,iVar1);
		image = param_2;
		if ((ImageBMP *)param_2 != (ImageBMP *)0x0) {
			lVar2 = __ftol((float10)local_4);
			iVar1 = (int)lVar2;
			lVar2 = __ftol((float10)local_8);
			FUN_0045a290((ImageBMP *)image,(int)lVar2,iVar1);
		}
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_GetCurrentBubbleImage(LiveObject *liveObj,ImageBMP **out_bubbleImage)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	LiveObject *pLVar3;
	ObjectType OVar4;
	ToolType TVar5;
	AITaskType AVar6;
	
	pAVar1 = liveObj->aitask_2f0;
	if ((*(byte *)&liveObj->flags4 & 0x20) != 0) {
		*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[30];
		return;
	}
	if ((liveObj->flags1 & LIVEOBJ1_UNK_800000) != LIVEOBJ1_NONE) {
		*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[28];
		return;
	}
	if ((liveObj->flags1 & LIVEOBJ1_UNK_80000000) != LIVEOBJ1_NONE) {
		*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[0];
		return;
	}
	if (pAVar1 != (AITaskData *)0x0) {
		AVar6 = pAVar1->taskType;
		while ((AVar6 == AITASK_ANIMATIONWAIT && (pAVar2 = pAVar1->next, pAVar2 != (AITaskData *)0x0)))
		{
			AVar6 = pAVar2->taskType;
			pAVar1 = pAVar2;
		}
		switch(pAVar1->taskType) {
		case AITASK_GOTO:
			*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[22];
			return;
		case AITASK_COLLECT:
			OVar4 = pAVar1->object_10->objType;
			if (OVar4 == OBJECT_POWERCRYSTAL) {
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[2];
				return;
			}
			if (OVar4 == OBJECT_ORE) {
				if (pAVar1->object_10->objIndex != 0) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[4];
					return;
				}
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[3];
				return;
			}
			if (OVar4 == OBJECT_DYNAMITE) {
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[5];
				return;
			}
			if (OVar4 == OBJECT_BARRIER) {
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[6];
				return;
			}
			if (OVar4 == OBJECT_ELECTRICFENCE) {
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[7];
				return;
			}
			break;
		case AITASK_DEPOSITE:
			pLVar3 = liveObj->carriedObjects[0];
			if (pLVar3 != (LiveObject *)0x0) {
				OVar4 = pLVar3->objType;
				if (OVar4 == OBJECT_POWERCRYSTAL) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[16];
					return;
				}
				if (OVar4 == OBJECT_ORE) {
					if (pLVar3->objIndex != 0) {
						*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[18];
						return;
					}
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[17];
					return;
				}
				if (OVar4 == OBJECT_DYNAMITE) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[19];
					return;
				}
				if (OVar4 == OBJECT_BARRIER) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[20];
					return;
				}
				if (OVar4 == OBJECT_ELECTRICFENCE) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[21];
					return;
				}
			}
			break;
		case AITASK_REQUEST:
			*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[38];
			break;
		case AITASK_DIG:
			*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[25];
			return;
		case AITASK_DYNAMITE:
			*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[23];
			return;
		case AITASK_REPAIR:
			*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[26];
			return;
		case AITASK_REINFORCE:
			*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[24];
			return;
		case AITASK_CLEAR:
			*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[27];
			return;
		case AITASK_ELECFENCE:
			*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[31];
			return;
		case AITASK_EAT:
		case AITASK_GOTOEAT:
			*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[32];
			return;
		case AITASK_FINDDRIVER:
			*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[33];
			return;
		case AITASK_GETTOOL:
			TVar5 = pAVar1->toolType;
			if (TVar5 == TOOL_DRILL) {
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[8];
				return;
			}
			if (TVar5 == TOOL_SPADE) {
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[9];
				return;
			}
			if (TVar5 == TOOL_HAMMER) {
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[10];
				return;
			}
			if (TVar5 == TOOL_SPANNER) {
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[11];
				return;
			}
			if (TVar5 == TOOL_LASER) {
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[12];
				return;
			}
			if (TVar5 == TOOL_PUSHERGUN) {
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[13];
				return;
			}
			if (TVar5 == TOOL_FREEZERGUN) {
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[14];
				return;
			}
			if (TVar5 == TOOL_BIRDSCARER) {
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[15];
				return;
			}
			break;
		case AITASK_UPGRADE:
			*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[34];
			return;
		case AITASK_BUILDPATH:
			*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[35];
			return;
		case AITASK_TRAIN:
			*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[36];
			return;
		case AITASK_RECHARGE:
			*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[37];
			return;
		}
	}
	return;
}



BOOL __cdecl
lego::res::Res_LoadAEFileBuilding
					(BuildingData *building,int index,Container *resData,char *filename,char *rootName)
{
	char cVar1;
	int iVar2;
	Container *pCVar3;
	CFGProperty *prop;
	char *pcVar4;
	Point2I *pPVar5;
	int iVar6;
	uint uVar7;
	uint uVar8;
	int *piVar9;
	undefined4 *puVar10;
	BuildingData *pBVar11;
	undefined4 *puVar12;
	float10 fVar13;
	char **local_99c;
	int local_998;
	char *local_994 [2];
	int local_98c [99];
	char local_800 [1024];
	char filepath [1024];
	
	pBVar11 = building;
	for (iVar6 = 0x53; iVar6 != 0; iVar6 = iVar6 + -1) {
		pBVar11->objIndex = 0;
		pBVar11 = (BuildingData *)&pBVar11->aeResData;
	}
	pCVar3 = Container_Load(resData,filename,"ACT",1);
	building->aeResData = pCVar3;
	if (pCVar3 == (Container *)0x0) {
		return 0;
	}
	uVar7 = 0xffffffff;
	do {
		pcVar4 = filename;
		if (uVar7 == 0) break;
		uVar7 = uVar7 - 1;
		pcVar4 = filename + 1;
		cVar1 = *filename;
		filename = pcVar4;
	} while (cVar1 != '\0');
	uVar7 = ~uVar7;
	puVar10 = (undefined4 *)(pcVar4 + -uVar7);
	puVar12 = (undefined4 *)local_800;
	for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {
		*puVar12 = *puVar10;
		puVar10 = puVar10 + 1;
		puVar12 = puVar12 + 1;
	}
	for (uVar7 = uVar7 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {
		*(undefined *)puVar12 = *(undefined *)puVar10;
		puVar10 = (undefined4 *)((int)puVar10 + 1);
		puVar12 = (undefined4 *)((int)puVar12 + 1);
	}
	uVar7 = util::Util_Tokenise(local_800,local_994 + 1,"\\");
	if (1 < uVar7) {
		piVar9 = local_98c;
		iVar6 = uVar7 - 1;
		do {
			iVar2 = *piVar9;
			piVar9 = piVar9 + 1;
			iVar6 = iVar6 + -1;
			*(undefined *)(iVar2 + -1) = '\\';
		} while (iVar6 != 0);
	}
	std::sprintf(filepath,"%s\\%s.%s",local_800,local_994[uVar7],"ae");
	prop = cfg::CFG_Open(filepath);
	if (prop != (CFGProperty *)0x0) {
		pcVar4 = cfg::CFG_JoinPath(rootName,"CarryNullName",0);
		pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
		building->CarryNullName = pcVar4;
		if (pcVar4 == (char *)0x0) {
			building->CarryNullFrames = 0;
		}
		else {
			pcVar4 = cfg::CFG_JoinPath(rootName,"CarryNullFrames",0);
			pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
			if (pcVar4 == (char *)0x0) {
				uVar7 = std::atoi(____EMPTYSTR__);
				building->CarryNullFrames = uVar7;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"CarryNullFrames",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				uVar7 = std::atoi(pcVar4);
				building->CarryNullFrames = uVar7;
			}
		}
		pcVar4 = cfg::CFG_JoinPath(rootName,"CameraNullName",0);
		pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
		building->CameraNullName = pcVar4;
		if (pcVar4 == (char *)0x0) {
			building->CameraNullFrames = 0;
		}
		else {
			pcVar4 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
			pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
			if (pcVar4 == (char *)0x0) {
				uVar7 = std::atoi(____EMPTYSTR__);
				building->CameraNullFrames = uVar7;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				uVar7 = std::atoi(pcVar4);
				building->CameraNullFrames = uVar7;
			}
		}
		pcVar4 = cfg::CFG_JoinPath(rootName,"ToolNullName",0);
		pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
		building->ToolNullName = pcVar4;
		if (pcVar4 == (char *)0x0) {
			building->ToolNullFrames = 0;
		}
		else {
			pcVar4 = cfg::CFG_JoinPath(rootName,"ToolNullFrames",0);
			pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
			if (pcVar4 == (char *)0x0) {
				uVar7 = std::atoi(____EMPTYSTR__);
				building->ToolNullFrames = uVar7;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"ToolNullFrames",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				uVar7 = std::atoi(pcVar4);
				building->ToolNullFrames = uVar7;
			}
		}
		pcVar4 = cfg::CFG_JoinPath(rootName,"DepositNullName",0);
		pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
		building->DepositNullName = pcVar4;
		pcVar4 = cfg::CFG_JoinPath(rootName,"FireNullName",0);
		pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
		building->FireNullName = pcVar4;
		pcVar4 = cfg::CFG_JoinPath(rootName,"EntranceNullName",0);
		pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
		building->EntranceNullName = pcVar4;
		pcVar4 = cfg::CFG_JoinPath(rootName,"yPivot",0);
		pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
		building->yPivot = pcVar4;
		pcVar4 = cfg::CFG_JoinPath(rootName,"xPivot",0);
		pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
		building->xPivot = pcVar4;
		pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
		pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
		if (pcVar4 == (char *)0x0) {
			building->PivotMaxZ = 1.0;
		}
		else {
			pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
			pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
			if (pcVar4 == (char *)0x0) {
				fVar13 = std::atof(____EMPTYSTR__);
				building->PivotMaxZ = (float)fVar13;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				fVar13 = std::atof(pcVar4);
				building->PivotMaxZ = (float)fVar13;
			}
		}
		pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
		pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
		if (pcVar4 == (char *)0x0) {
			building->PivotMinZ = -1.0;
		}
		else {
			pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
			pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
			if (pcVar4 == (char *)0x0) {
				fVar13 = std::atof(____EMPTYSTR__);
				building->PivotMinZ = (float)fVar13;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				fVar13 = std::atof(pcVar4);
				building->PivotMinZ = (float)fVar13;
			}
		}
		Res_LoadUpgradeLevels(&building->upgrades,prop,rootName);
		pPVar5 = (Point2I *)std::malloc(0x50);
		building->shapePoints = pPVar5;
		building->shapeCount = 1;
		pPVar5->y = 0;
		building->shapePoints->x = 0;
		pcVar4 = cfg::CFG_JoinPath(rootName,"Shape",0);
		pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
		local_994[0] = pcVar4;
		if (pcVar4 != (char *)0x0) {
			local_998 = util::Util_Tokenise(pcVar4,local_994 + 1,":");
			if (local_998 != 0) {
				local_99c = local_994;
				do {
					local_99c = local_99c + 1;
					uVar7 = building->shapeCount;
					pPVar5 = building->shapePoints;
					pcVar4 = *local_99c;
					building->shapeCount = uVar7 + 1;
					iVar6 = std::atoi(pcVar4);
					pPVar5[uVar7].x = iVar6;
					pcVar4 = std::strstr(pcVar4,",");
					iVar6 = std::atoi(pcVar4 + 1);
					pPVar5[uVar7].y = iVar6;
					local_998 = local_998 + -1;
					pcVar4 = local_994[0];
				} while (local_998 != 0);
			}
			std::free(pcVar4);
		}
		pcVar4 = cfg::CFG_JoinPath(rootName,"PowerLevelScene",0);
		pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
		if (pcVar4 != (char *)0x0) {
			std::sprintf(filepath,"%s\\%s",local_800,pcVar4);
			pCVar3 = Container_Load(resData,filepath,"LWS",1);
			building->PowerLevelScene = pCVar3;
		}
		cfg::CFG_Close(prop);
	}
	Container_Hide(building->aeResData,1);
	building->objIndex = index;
	building->flags = 0;
	return 1;
}



void __cdecl lego::res::Building_FUN_00408210(BuildingData *building,BOOL param_2)
{
	float fVar1;
	
	if (param_2 == 0) {
		fVar1 = ((float)building->field_80 - 0.1) * 10.0 * 0.1111111;
	}
	else {
		fVar1 = (float)building->field_80 - (1.0 - (float)building->field_80) * -0.1;
	}
	building->field_80 = fVar1;
	if ((float)building->field_80 < 0.0) {
		building->field_80 = 0;
	}
	building->flags = building->flags | 2;
	return;
}



Point2I * __cdecl lego::res::Building_GetShapePoints(BuildingData *building,uint *out_shapeCount)
{
	if (out_shapeCount != (uint *)0x0) {
		*out_shapeCount = building->shapeCount;
	}
	return building->shapePoints;
}



void __cdecl lego::res::Object_SetOwnerObject(BasicObjectData *basicObjData,LiveObject *liveObj)
{
	Container_SetUserData(basicObjData->aeResData,liveObj);
	return;
}



void __cdecl lego::res::Building_UnkUpgrades(BuildingData *building,char *frameName)
{
	int *opt_instance;
	LiveObject *pLVar1;
	uint uVar2;
	BuildingData *basicObjData;
	undefined4 *puVar3;
	Container *pCVar4;
	Container *in_child;
	char *pcVar5;
	undefined4 *puVar6;
	int iVar7;
	UpgradeData *upgrade;
	uint local_14;
	int local_10;
	uint local_c;
	int local_8;
	UpgradeData *local_4;
	
	basicObjData = building;
	iVar7 = 3;
	pLVar1 = (LiveObject *)(building->upgrades).upgradeObjs;
	puVar3 = (undefined4 *)&building->field_0xc4;
	puVar6 = (undefined4 *)&building->field_0xa0;
	do {
		puVar3[0x1a] = 0;
		*puVar3 = 0;
		puVar3[-3] = 0;
		*puVar6 = 0;
		puVar3 = puVar3 + 1;
		iVar7 = iVar7 + -1;
		puVar6[1] = 0;
		puVar6 = puVar6 + 2;
	} while (iVar7 != 0);
	building->count_144 = 0;
	do {
		if (pLVar1 == (LiveObject *)0x0) {
			return;
		}
		upgrade = pLVar1->upgrade;
		iVar7 = upgrade->field_c;
		local_8 = iVar7;
		local_4 = upgrade;
		pCVar4 = FUN_00406e80((BasicObjectData *)basicObjData,*(undefined4 *)(iVar7 + 8),
													*(undefined4 *)(iVar7 + 4));
		in_child = Object_GetAEResource((BasicObjectData *)upgrade);
		Container_SetParent(in_child,pCVar4);
		Container_ClearTransform(in_child);
		if (frameName == (char *)0x0) {
			Container_SetActivity(upgrade->aeResData,globals::g_Activities_TABLE[0]);
		}
		else {
			Upgrade_FUN_0046c3f0(upgrade,frameName);
		}
		if (*(int *)(iVar7 + 0xc) != 0) {
			uVar2 = basicObjData->count_144;
			local_10 = 0;
			*(undefined4 *)(&basicObjData->field_0xd8 + uVar2 * 4) = 0;
			local_14 = 0;
			opt_instance = (int *)(&basicObjData->field_0xd8 + uVar2 * 4);
			building = (BuildingData *)(basicObjData->cameraFramesTable_40 + uVar2 * 2 + 0x18);
			local_c = uVar2;
			do {
				building->objIndex = 0;
				pcVar5 = Container_FormatPartName
													 (basicObjData->aeResData,basicObjData->FireNullName,opt_instance);
				pCVar4 = Container_SearchTree
													 (in_child,pcVar5,CONTAINER_SEARCHMODE_FIRSTMATCH,(undefined4 *)0x0);
				basicObjData->cameraFramesTable_40[*opt_instance + uVar2 * 2 + 0x18] = pCVar4;
				iVar7 = basicObjData->cameraFramesTable_40[uVar2 * 2 + *opt_instance + 0x18];
				*opt_instance = *opt_instance + 1;
				if (iVar7 == 0) break;
				local_14 = local_14 + 1;
				building = (BuildingData *)&building->aeResData;
			} while (local_14 < 2);
			pcVar5 = Container_FormatPartName(basicObjData->aeResData,basicObjData->xPivot,&local_10);
			pCVar4 = Container_SearchTree
												 (in_child,pcVar5,CONTAINER_SEARCHMODE_FIRSTMATCH,(undefined4 *)0x0);
			uVar2 = local_c;
			basicObjData->cameraFramesTable_40[local_c + 0x1e] = pCVar4;
			pcVar5 = Container_FormatPartName(basicObjData->aeResData,basicObjData->yPivot,&local_10);
			pCVar4 = Container_SearchTree
												 (in_child,pcVar5,CONTAINER_SEARCHMODE_FIRSTMATCH,(undefined4 *)0x0);
			*(Container **)(&basicObjData->field_0xc4 + uVar2 * 4) = pCVar4;
			*(int *)(&basicObjData->field_0x12c + uVar2 * 4) = local_8;
			basicObjData->count_144 = basicObjData->count_144 + 1;
			upgrade = local_4;
		}
		pLVar1 = upgrade->object_8;
	} while( true );
}



BOOL __cdecl
lego::res::Building_FUN_004084a0(BuildingData *building,char *activityName,float elapsed)
{
	uint uVar1;
	BOOL BVar2;
	undefined4 *puVar3;
	
	uVar1 = 0;
	if (building->CarryNullFrames != 0) {
		puVar3 = building->carryFramesTable_28;
		do {
			*puVar3 = 0;
			uVar1 = uVar1 + 1;
			puVar3 = puVar3 + 1;
		} while (uVar1 < building->CarryNullFrames);
	}
	uVar1 = 0;
	if (building->CameraNullFrames != 0) {
		puVar3 = building->cameraFramesTable_40;
		do {
			*puVar3 = 0;
			uVar1 = uVar1 + 1;
			puVar3 = puVar3 + 1;
		} while (uVar1 < building->CameraNullFrames);
	}
	building->field_68 = 0;
	building->field_6c = 0;
	BVar2 = Container_SetActivity(building->aeResData,activityName);
	Container_SetAnimationTime(building->aeResData,elapsed);
	Building_UnkUpgrades(building,activityName);
	return BVar2;
}



int __cdecl lego::res::Building_FUN_00408520(BuildingData *building,int cameraIndex)
{
	Container *pCVar1;
	char *name;
	
	name = building->CameraNullName;
	if (name != (char *)0x0) {
		if (building->cameraFramesTable_40[cameraIndex] == 0) {
			pCVar1 = FUN_00406e80((BasicObjectData *)building,name,cameraIndex);
			building->cameraFramesTable_40[cameraIndex] = pCVar1;
		}
		name = (char *)building->cameraFramesTable_40[cameraIndex];
	}
	return (int)name;
}



void __cdecl lego::res::Building_Duplicate(BuildingData *in_building,BuildingData *out_building)
{
	Container *pCVar1;
	int iVar2;
	BuildingData *pBVar3;
	BuildingData *pBVar4;
	
	pBVar3 = in_building;
	pBVar4 = out_building;
	for (iVar2 = 0x53; iVar2 != 0; iVar2 = iVar2 + -1) {
		pBVar4->objIndex = pBVar3->objIndex;
		pBVar3 = (BuildingData *)&pBVar3->aeResData;
		pBVar4 = (BuildingData *)&pBVar4->aeResData;
	}
	out_building->flags = out_building->flags & 0xfffffffe;
	pCVar1 = Container_Clone(in_building->aeResData);
	out_building->aeResData = pCVar1;
	if (in_building->PowerLevelScene != (Container *)0x0) {
		pCVar1 = Container_Clone(in_building->PowerLevelScene);
		out_building->PowerLevelScene = pCVar1;
	}
	return;
}



void __cdecl FUN_004085a0(BuildingData *param_1,BOOL param_2)
{
	lego::res::Container_Hide(param_1->aeResData,param_2);
	if (param_1->PowerLevelScene != (Container *)0x0) {
		lego::res::Container_Hide(param_1->PowerLevelScene,param_2);
	}
	return;
}



BOOL __cdecl lego::res::Object_GetFlag8(BasicObjectData *basicObjData)
{
	BOOL BVar1;
	
	BVar1 = Container_IsHidden(basicObjData->aeResData);
	return BVar1;
}



void __cdecl lego::res::Building_SetOrientation(BuildingData *building,float x,float y)
{
	Container_SetOrientation(building->aeResData,(Container *)0x0,x,y,0.0,0.0,0.0,-1.0);
	if (building->PowerLevelScene != (Container *)0x0) {
		Container_SetOrientation(building->PowerLevelScene,(Container *)0x0,x,y,0.0,0.0,0.0,-1.0);
	}
	return;
}



void __cdecl
lego::res::Building_SetPosition
					(BuildingData *building,float x,float y,undefined *getZcallback,SurfaceMap *surfMap)
{
	float10 fVar1;
	
	fVar1 = (float10)(*(code *)getZcallback)(x,y,surfMap);
	Container_SetPosition(building->aeResData,(Container *)0x0,x,y,(float)fVar1);
	if (building->PowerLevelScene != (Container *)0x0) {
		Container_SetPosition(building->PowerLevelScene,(Container *)0x0,x,y,(float)fVar1);
	}
	return;
}



Container * __cdecl lego::res::Building_GetCarryNull(BuildingData *building,int carryIndex)
{
	Container *pCVar1;
	
	if (building->CarryNullName == (char *)0x0) {
		return (Container *)0x0;
	}
	if ((Container *)building->carryFramesTable_28[carryIndex] != (Container *)0x0) {
		return (Container *)building->carryFramesTable_28[carryIndex];
	}
	pCVar1 = FUN_00406e80((BasicObjectData *)building,building->CarryNullName,carryIndex);
	building->carryFramesTable_28[carryIndex] = pCVar1;
	return pCVar1;
}



Container * __cdecl lego::res::Building_GetDepositNull(BuildingData *building)
{
	Container *pCVar1;
	
	if (building->DepositNullName == (char *)0x0) {
		pCVar1 = (Container *)0x0;
	}
	else {
		pCVar1 = (Container *)building->field_68;
		if (pCVar1 == (Container *)0x0) {
			pCVar1 = FUN_00406e80((BasicObjectData *)building,building->DepositNullName,0);
			building->field_68 = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Building_GetEntranceNull(BuildingData *building)
{
	Container *pCVar1;
	
	if (building->EntranceNullName == (char *)0x0) {
		pCVar1 = (Container *)0x0;
	}
	else {
		pCVar1 = (Container *)building->field_6c;
		if (pCVar1 == (Container *)0x0) {
			pCVar1 = FUN_00406e80((BasicObjectData *)building,building->EntranceNullName,0);
			building->field_6c = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Building_GetToolNull(BuildingData *building,int toolIndex)
{
	Container *pCVar1;
	
	if (building->ToolNullName == (char *)0x0) {
		return (Container *)0x0;
	}
	if ((Container *)building->cameraFramesTable_40[toolIndex + 4] != (Container *)0x0) {
		return (Container *)building->cameraFramesTable_40[toolIndex + 4];
	}
	pCVar1 = FUN_00406e80((BasicObjectData *)building,building->ToolNullName,toolIndex);
	building->cameraFramesTable_40[toolIndex + 4] = pCVar1;
	return pCVar1;
}



int __cdecl lego::res::Res_GetBuildingCarryNullFrames(BuildingData *building)
{
	return building->CarryNullFrames;
}



float10 __cdecl lego::res::Building_FUN_00408790(BuildingData *building,float elapsed,uint param_3)
{
	BuildingData *pBVar1;
	BuildingData *pBVar2;
	uint uVar3;
	float10 fVar4;
	
	pBVar2 = building;
	fVar4 = Container_MoveAnimation(building->aeResData,elapsed);
	pBVar1 = (BuildingData *)(float)fVar4;
	if ((1 < param_3) && ((float)pBVar1 != 0.0)) {
		uVar3 = Container_GetAnimationFrames(building->aeResData);
		pBVar1 = (BuildingData *)((float)pBVar1 - (float)(ulonglong)(uVar3 * (param_3 - 1)));
	}
	building = pBVar1;
	if ((*(byte *)&pBVar2->flags & 2) != 0) {
		if (pBVar2->PowerLevelScene != (Container *)0x0) {
			uVar3 = Container_GetAnimationFrames(pBVar2->PowerLevelScene);
			Container_SetAnimationTime
								(pBVar2->PowerLevelScene,(float)(ulonglong)uVar3 * (float)pBVar2->field_80);
		}
		pBVar2->flags = pBVar2->flags & 0xfffffffd;
	}
	return (float10)(float)building;
}



float10 __cdecl lego::res::Building_GetAnimFloat14_zero(BuildingData *building)
{
	return (float10)0.0;
}



void __cdecl lego::res::Building_Destroy(BuildingData *building)
{
	game::LiveObject_BuildingChangeUpgradeParts(building,-1);
	if (building->PowerLevelScene != (Container *)0x0) {
		Container_Remove(building->PowerLevelScene);
	}
	Container_Remove(building->aeResData);
	return;
}



BOOL __cdecl FUN_004088a0(BuildingData *building,int levelBit,BOOL condition)
{
	uint uVar1;
	
	uVar1 = 1 << ((byte)levelBit & 0x1f);
	if ((condition != 0) && (((building->upgrades).levelsMask & uVar1) != 0)) {
		return 0;
	}
	return (building->upgrades).levelsMask & uVar1;
}



void __cdecl lego::game::LiveObject_BuildingChangeUpgradeParts(BuildingData *building,int objLevel)
{
	res::ObjectUpgrade_ChangeUpgradeParts(&building->upgrades,objLevel);
	res::Building_UnkUpgrades(building,(char *)0x0);
	return;
}



float10 __cdecl lego::math::Math_FUN_00408900(Point2F *param_1,Point2F *param_2,Point2F *param_3)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float10 fVar6;
	float10 fVar7;
	
	fVar3 = param_3->x - param_2->x;
	fVar5 = param_3->y - param_2->y;
	fVar6 = (float10)param_1->x - (float10)param_3->x;
	fVar7 = (float10)param_1->y - (float10)param_3->y;
	fVar1 = (float)fVar6;
	fVar2 = (float)fVar7;
	fVar6 = SQRT(fVar7 * (float10)fVar2 + fVar6 * (float10)fVar1);
	fVar4 = 1.0 / SQRT(fVar5 * fVar5 + fVar3 * fVar3);
	fVar3 = fVar4 * fVar3;
	fVar4 = fVar4 * fVar5;
	if ((float10)(float)((float10)1.0 / fVar6) * (float10)fVar2 * (float10)fVar4 +
			((float10)1.0 / fVar6) * (float10)fVar1 * (float10)fVar3 < (float10)0.0) {
		fVar5 = param_1->x - param_2->x;
		fVar1 = param_1->y - param_2->y;
		fVar2 = SQRT(fVar1 * fVar1 + fVar5 * fVar5);
		fVar1 = (1.0 / fVar2) * fVar1 * fVar4 + (1.0 / fVar2) * fVar5 * fVar3;
		if ((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) != 0) {
			return (float10)fVar2;
		}
		fVar6 = std::acos((float10)fVar1);
		fVar6 = (float10)fsin(fVar6);
		fVar6 = fVar6 * (float10)fVar2;
	}
	return fVar6;
}



float10 __cdecl
lego::math::Math_FUN_00408a30(Point2F *param_1,Point2F *param_2,Point2F *param_3,uint param_4)
{
	Point2F *pPVar1;
	int iVar2;
	Point2F *pPVar3;
	float10 fVar4;
	
	fVar4 = Math_FUN_00408900(param_1,param_2,param_3);
	pPVar1 = (Point2F *)(float)fVar4;
	if (1 < param_4) {
		pPVar3 = (Point2F *)((int)param_3 - (int)param_2);
		iVar2 = param_4 - 1;
		param_3 = (Point2F *)(float)fVar4;
		do {
			param_2 = param_2 + 1;
			fVar4 = Math_FUN_00408900(param_1,param_2,(Point2F *)((int)&param_2->x + (int)&pPVar3->x));
			if (fVar4 < (float10)(float)param_3) {
				param_3 = (Point2F *)(float)fVar4;
			}
			iVar2 = iVar2 + -1;
			pPVar1 = param_3;
		} while (iVar2 != 0);
	}
	param_3 = pPVar1;
	return (float10)(float)param_3;
}



void __cdecl FUN_00408a90(float *param_1,float *param_2,float *param_3,float *param_4)
{
	float fVar1;
	float fVar2;
	float fVar3;
	
	fVar3 = *param_2 - *param_1;
	fVar1 = param_2[1] - param_1[1];
	fVar2 = 1.0 / SQRT(fVar1 * fVar1 + fVar3 * fVar3);
	fVar3 = fVar2 * fVar3;
	fVar2 = fVar2 * fVar1;
	fVar1 = (param_3[1] - param_1[1]) * fVar2 + (*param_3 - *param_1) * fVar3;
	*param_4 = fVar1 * fVar3 + *param_1;
	param_4[1] = fVar1 * fVar2 + param_1[1];
	return;
}



void __cdecl FUN_00408b20(float *param_1,float *param_2,float *param_3,float *param_4)
{
	float fVar1;
	float fVar2;
	float fVar3;
	
	fVar1 = param_2[1];
	fVar2 = *param_2;
	fVar3 = 1.0 / SQRT(fVar1 * fVar1 + fVar2 * fVar2);
	fVar2 = fVar3 * fVar2;
	fVar3 = fVar3 * fVar1;
	fVar1 = (param_3[1] - param_1[1]) * fVar3 + (*param_3 - *param_1) * fVar2;
	*param_4 = fVar1 * fVar2 + *param_1;
	param_4[1] = fVar1 * fVar3 + param_1[1];
	return;
}



uint __cdecl lego::game::Game_GetBuildingBase(char *name)
{
	byte bVar1;
	byte *pbVar2;
	int iVar3;
	uint uVar4;
	byte *pbVar5;
	char **ppcVar6;
	bool bVar7;
	
	uVar4 = 0;
	if (globals::g_BuildingBase_COUNT == 0) {
		return 0;
	}
	ppcVar6 = globals::g_BuildingBase_TABLE;
	do {
		pbVar2 = (byte *)*ppcVar6;
		pbVar5 = (byte *)name;
		do {
			bVar1 = *pbVar2;
			bVar7 = bVar1 < *pbVar5;
			if (bVar1 != *pbVar5) {
LAB_00408bee:
				iVar3 = (1 - (uint)bVar7) - (uint)(bVar7 != 0);
				goto LAB_00408bf3;
			}
			if (bVar1 == 0) break;
			bVar1 = pbVar2[1];
			bVar7 = bVar1 < pbVar5[1];
			if (bVar1 != pbVar5[1]) goto LAB_00408bee;
			pbVar2 = pbVar2 + 2;
			pbVar5 = pbVar5 + 2;
		} while (bVar1 != 0);
		iVar3 = 0;
LAB_00408bf3:
		if (iVar3 == 0) {
			return uVar4;
		}
		uVar4 = uVar4 + 1;
		ppcVar6 = (char **)((byte **)ppcVar6 + 1);
		if (globals::g_BuildingBase_COUNT <= uVar4) {
			return globals::g_BuildingBase_COUNT;
		}
	} while( true );
}



void __cdecl FUN_00408c10(int param_1,LiveObject *liveObj)
{
	int iVar1;
	
	iVar1 = FUN_00408ff0((Point2I *)0x0,&param_1);
	if (iVar1 == 0) {
		if (liveObj->objType == OBJECT_POWERCRYSTAL) {
			lego::game::Level_AddMessageAction(MESSAGE_GENERATECRYSTAL_COMPLETE,liveObj,0,(Point2I *)0x0);
			return;
		}
		lego::game::Level_AddMessageAction(MESSAGE_GENERATEORE_COMPLETE,liveObj,0,(Point2I *)0x0);
	}
	else {
		if (liveObj != (LiveObject *)0x0) {
			liveObj->flags4 = liveObj->flags4 | 0x100;
			*(LiveObject **)(iVar1 + 0x2c + *(int *)(iVar1 + 0xcc) * 4) = liveObj;
			*(int *)(iVar1 + 0xcc) = *(int *)(iVar1 + 0xcc) + 1;
			*(int *)(iVar1 + 0x20) = *(int *)(iVar1 + 0x20) + 1;
		}
		if (*(int *)(iVar1 + 0x1c) == *(int *)(iVar1 + 0x20)) {
			*(undefined4 *)(iVar1 + 0x28) = 0x42fa0000;
			*(uint *)(iVar1 + 0xd0) = *(uint *)(iVar1 + 0xd0) | 1;
			return;
		}
	}
	return;
}



undefined4 __cdecl FUN_00408ca0(int param_1,int param_2,int param_3)
{
	int iVar1;
	int iVar2;
	int *liveObjField10;
	uint uVar3;
	ObjectType objType;
	uint uVar4;
	
	liveObjField10 = (int *)FUN_00408ff0((Point2I *)0x0,&param_1);
	iVar2 = param_3;
	iVar1 = param_2;
	if (liveObjField10 != (int *)0x0) {
		uVar3 = FUN_00408d40((int)liveObjField10,param_2,param_3);
		objType = (-(uint)((liveObjField10[0x34] & 2U) != 0) & 0xb) + OBJECT_BUILDING;
		if (iVar1 == 6) {
			uVar4 = lego::game::Object_GetCostCrystal(objType,*liveObjField10,0);
		}
		else {
			if (iVar1 != 7) {
				return 1;
			}
			if (iVar2 == 0) {
				uVar4 = lego::game::Object_GetCostOre(objType,*liveObjField10,0);
			}
			else {
				uVar4 = lego::game::Object_GetCostRefinedOre(objType,*liveObjField10,0);
			}
		}
		if (uVar3 < uVar4) {
			return 1;
		}
	}
	return 0;
}



int __cdecl FUN_00408d40(int liveObjField10,int param_2,int param_3)
{
	int iVar1;
	int **ppiVar2;
	int iVar3;
	
	iVar1 = 0;
	iVar3 = *(int *)(liveObjField10 + 0x20);
	if (iVar3 != 0) {
		ppiVar2 = (int **)(liveObjField10 + 0x2c);
		do {
			if ((param_2 == **ppiVar2) && (param_3 == (*ppiVar2)[1])) {
				iVar1 = iVar1 + 1;
			}
			ppiVar2 = ppiVar2 + 1;
			iVar3 = iVar3 + -1;
		} while (iVar3 != 0);
	}
	return iVar1;
}



void __cdecl
lego::game::Level_SpawnCarryableObject
					(Point2I *position,ObjectType objType,int objIndex,int objLevel,int count)
{
	int iVar1;
	
	iVar1 = FUN_00408ff0(position,(int *)0x0);
	if ((objType == OBJECT_ORE) && (objIndex == 1)) {
		*(uint *)(iVar1 + 0xd0) = *(uint *)(iVar1 + 0xd0) | 8;
	}
	if (count != 0) {
		do {
			*(int *)(iVar1 + 0x1c) = *(int *)(iVar1 + 0x1c) + 1;
			ai::AITask_DoRequest_ObjectType
								(objType,objIndex,objLevel,position,*(undefined4 *)(iVar1 + 8),(Point2F *)0x0,0);
			count = count + -1;
		} while (count != 0);
	}
	return;
}



void __cdecl FUN_00408df0(int *param_1,uint *param_2,uint param_3)
{
	uint *puVar1;
	bool bVar2;
	int iVar3;
	SurfaceMap *surfMap;
	uint *puVar4;
	uint uVar5;
	uint *puVar6;
	uint *puVar7;
	Point2I *position;
	uint *puVar8;
	float10 fVar9;
	uint local_4c;
	int local_40 [5];
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	Point2F local_20;
	float local_18;
	undefined4 local_14;
	undefined4 local_10;
	float local_c;
	float local_8;
	undefined4 local_4;
	
	iVar3 = FUN_00408ff0((Point2I *)param_1,(int *)0x0);
	surfMap = lego::game::GetSurfaceMap();
	fVar9 = lego::game::SurfaceMap_GetBlockSize(surfMap);
	local_40[2] = 1;
	local_2c = 1;
	local_40[1] = 0xffffffff;
	local_28 = 0xffffffff;
	local_40[0] = 0;
	local_40[3] = 0;
	local_40[4] = 0;
	local_24 = 0;
	local_4c = 0;
	local_20.x = 0.5;
	local_14 = 0x3f000000;
	local_10 = 0x3f000000;
	local_4 = 0x3f000000;
	local_c = (float)((float10)8.8 / fVar9);
	local_20.y = 1.0 - local_c;
	if (param_3 != 0) {
		puVar6 = param_2 + 1;
		puVar8 = param_2 + 2;
		position = (Point2I *)param_2;
		local_18 = local_20.y;
		local_8 = local_c;
		do {
			if (((local_4c == param_3 - 1) || (position->x != *puVar8)) || (*puVar6 != puVar8[1])) {
				param_1 = (int *)0x0;
				do {
					bVar2 = false;
					uVar5 = 0;
					puVar4 = param_2;
					puVar1 = param_2;
					do {
						puVar7 = puVar1 + 2;
						if (((uVar5 == param_3 - 1) || (*puVar4 != *puVar7)) || (puVar4[1] != puVar1[3])) {
							if ((*puVar4 ==
									 *(int *)((int)((int)register0x00000010 + -0x40) + (int)param_1) + position->x) &&
								 (puVar4[1] == *puVar6 + *(int *)((int)register0x00000010 + -0x3c + (int)param_1)))
							{
								bVar2 = true;
							}
						}
						else {
							uVar5 = uVar5 + 1;
							puVar7 = puVar1 + 4;
							puVar4 = puVar4 + 2;
						}
						uVar5 = uVar5 + 1;
						puVar4 = puVar4 + 2;
						puVar1 = puVar7;
					} while (uVar5 < param_3);
					if (!bVar2) {
						lego::ai::AITask_DoRequest_ObjectType
											(OBJECT_BARRIER,0,0,position,*(undefined4 *)(iVar3 + 8),
											 (Point2F *)((int)&local_20.x + (int)param_1),1);
						*(int *)(iVar3 + 0x1c) = *(int *)(iVar3 + 0x1c) + 1;
					}
					param_1 = param_1 + 2;
				} while (param_1 < &DAT_00000020);
			}
			else {
				local_4c = local_4c + 1;
				puVar8 = puVar8 + 2;
				position = position + 1;
				puVar6 = puVar6 + 2;
			}
			local_4c = local_4c + 1;
			puVar8 = puVar8 + 2;
			position = position + 1;
			puVar6 = puVar6 + 2;
		} while (local_4c < param_3);
	}
	return;
}



BOOL __cdecl FUN_00408fd0(Point2I *position)
{
	int iVar1;
	
	iVar1 = FUN_00408ff0(position,(int *)0x0);
	return (uint)(iVar1 != 0);
}



int __cdecl FUN_00408ff0(Point2I *position,int *param_2)
{
	void **ppvVar1;
	void *pvVar2;
	
	pvVar2 = STRUCTD4_004b9a24;
	if (STRUCTD4_004b9a24 != (void *)0x0) {
		do {
			if (position == (Point2I *)0x0) {
				if ((param_2 != (int *)0x0) && (*param_2 == *(int *)((int)pvVar2 + 8))) {
					return (int)pvVar2;
				}
			}
			else {
				if ((position->x == *(int *)((int)pvVar2 + 0xc)) &&
					 (position->y == *(int *)((int)pvVar2 + 0x10))) {
					return (int)pvVar2;
				}
			}
			ppvVar1 = (void **)((int)pvVar2 + 0x24);
			pvVar2 = *ppvVar1;
		} while (*ppvVar1 != (void *)0x0);
	}
	return (int)(void *)0x0;
}



void __cdecl FUN_00409040(int *param_1)
{
	undefined *puVar1;
	
	puVar1 = (undefined *)FUN_00408ff0((Point2I *)param_1,(int *)0x0);
	if (puVar1 != (undefined *)0x0) {
		FUN_0041cee0((Point2I *)param_1);
		FUN_00409970((int)puVar1);
		FUN_00409920(puVar1);
	}
	return;
}



void __cdecl FUN_00409080(Point2I *position)
{
	LiveFlags4 *pLVar1;
	LiveObject *liveObj;
	undefined *puVar2;
	uint uVar3;
	LiveObject **ppLVar4;
	
	puVar2 = (undefined *)FUN_00408ff0(position,(int *)0x0);
	FUN_00432490(position,0);
	uVar3 = 0;
	if (*(int *)(puVar2 + 0xcc) != 0) {
		ppLVar4 = (LiveObject **)(puVar2 + 0x2c);
		do {
			liveObj = *ppLVar4;
			pLVar1 = &liveObj->flags4;
			*pLVar1 = *pLVar1 & 0xfffffeff;
			lego::ai::AITask_DoCollect(liveObj,0.0);
			uVar3 = uVar3 + 1;
			ppLVar4 = ppLVar4 + 1;
		} while (uVar3 < *(uint *)(puVar2 + 0xcc));
	}
	FUN_0041cee0(position);
	lego::ai::AI_FUN_00403630(*(int *)(puVar2 + 8),0,0,0);
	FUN_00409920(puVar2);
	return;
}



void __cdecl FUN_00409110(float elapsedGame)
{
	uint *puVar1;
	uint uVar2;
	uint *puVar3;
	
	puVar3 = (uint *)STRUCTD4_004b9a24;
	if (STRUCTD4_004b9a24 != (void *)0x0) {
		do {
			uVar2 = puVar3[0x34];
			puVar1 = (uint *)puVar3[9];
			if (((uVar2 & 2) == 0) || ((uVar2 & 4) != 0)) {
				if ((uVar2 & 1) != 0) {
					if ((uVar2 & 2) == 0) {
						uVar2 = FUN_004091a0(puVar3);
						if (uVar2 != 0) {
							FUN_00409970((int)puVar3);
							FUN_00409a60(puVar3,1);
							FUN_00409920((undefined *)puVar3);
						}
					}
					else {
						lego::ai::AITask_DoBuildPath_AtPosition((Point2I *)(puVar3 + 3));
						puVar3[0x34] = puVar3[0x34] & 0xfffffffe;
					}
				}
			}
			else {
				FUN_00409480((int)puVar3);
			}
			puVar3 = puVar1;
		} while (puVar1 != (uint *)0x0);
	}
	return;
}



uint __cdecl FUN_004091a0(LiveObject *param_1)
{
	BOOL BVar1;
	
	BVar1 = lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
										((LiveObjectPredicate *)&LAB_004091c0,param_1);
	return (uint)(BVar1 == 0);
}



BOOL __cdecl FUN_00409230(Point2I *position)
{
	BOOL BVar1;
	undefined4 *puVar2;
	
	BVar1 = lego::game::Level_IsBlockPowerPath(position);
	if (BVar1 == 0) {
		puVar2 = lego::unk::Lego_AllocStruct_d4(position);
		FUN_00432490(position,1);
		puVar2[0x34] = puVar2[0x34] | 2;
		FUN_0041cee0(position);
		return 1;
	}
	return 0;
}



undefined4 * __cdecl lego::unk::Lego_AllocStruct_d4(Point2I *position)
{
	undefined4 *puVar1;
	int iVar2;
	undefined4 *puVar3;
	
	puVar1 = (undefined4 *)std::malloc(0xd4);
	puVar3 = puVar1;
	for (iVar2 = 0x35; iVar2 != 0; iVar2 = iVar2 + -1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	puVar1[8] = 0;
	puVar1[7] = 0;
	puVar1[2] = UINT_004b9a20;
	UINT_004b9a20 = UINT_004b9a20 + 1;
	puVar1[3] = position->x;
	puVar1[4] = position->y;
	puVar1[9] = STRUCTD4_004b9a24;
	STRUCTD4_004b9a24 = puVar1;
	return puVar1;
}



void __cdecl FUN_004092e0(int *param_1)
{
	Point2I *pPVar1;
	BOOL BVar2;
	Point2I *position;
	int iVar3;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_20[0] = 0;
	local_20[1] = 0xffffffff;
	local_20[2] = 1;
	local_20[3] = 0;
	local_20[4] = 0;
	local_c = 1;
	local_8 = 0xffffffff;
	local_4 = 0;
	iVar3 = 4;
	pPVar1 = (Point2I *)&stack0xffffffd8;
	do {
		position = pPVar1 + 1;
		position->x = position->x + *param_1;
		pPVar1[1].y = pPVar1[1].y + param_1[1];
		BVar2 = lego::game::Level_IsBlockPowerPath(position);
		if (BVar2 == 0) {
			BVar2 = lego::game::Level_BlockCheck_FUN_004329d0(position->x,pPVar1[1].y,1);
			if (BVar2 != 0) goto LAB_00409350;
		}
		else {
LAB_00409350:
			BVar2 = lego::game::Level_BlockHasFlag2_100(position);
			if (BVar2 == 0) {
				FUN_00432030((int *)position);
				FUN_004092e0((int *)position);
			}
		}
		iVar3 = iVar3 + -1;
		pPVar1 = position;
		if (iVar3 == 0) {
			return;
		}
	} while( true );
}



undefined4 __cdecl FUN_00409380(int *param_1,int param_2)
{
	undefined4 uVar1;
	
	uVar1 = FUN_004093a0(param_1,param_2);
	FUN_00432230();
	return uVar1;
}



undefined4 __cdecl FUN_004093a0(int *param_1,int param_2)
{
	uint uVar1;
	int iVar2;
	BOOL BVar3;
	Point2I *position;
	uint uVar4;
	Point2I local_20;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar4 = 0;
	local_20.x = 0;
	local_20.y = -1;
	local_18 = 1;
	local_14 = 0;
	local_10 = 0;
	local_c = 1;
	local_8 = 0xffffffff;
	local_4 = 0;
	position = &local_20;
	do {
		position->x = position->x + *param_1;
		position->y = position->y + param_1[1];
		uVar1 = FUN_00432f90((int *)position);
		if (((uVar1 != 0) && (iVar2 = FUN_00438930((undefined4 *)position), iVar2 != 0)) &&
			 (BVar3 = FUN_004389e0(iVar2,param_2), BVar3 != 0)) {
			return 1;
		}
		BVar3 = lego::game::Level_IsBlockPowerPath(position);
		if (((BVar3 != 0) ||
				(BVar3 = lego::game::Level_BlockCheck_FUN_004329d0(position->x,position->y,1), BVar3 != 0))
			 && (uVar1 = FUN_00432200((int *)position), uVar1 == 0)) {
			FUN_004321a0((int *)position);
			iVar2 = FUN_004093a0((int *)position,param_2);
			if (iVar2 != 0) {
				return 1;
			}
		}
		uVar4 = uVar4 + 1;
		position = position + 1;
	} while (uVar4 < 4);
	return 0;
}



void __cdecl FUN_00409480(int param_1)
{
	Point2I *position;
	int iVar1;
	LiveObject *pLVar2;
	int iVar3;
	int iVar4;
	
	position = (Point2I *)(param_1 + 0xc);
	iVar1 = lego::util::return_1(position);
	if (iVar1 != 0) {
		pLVar2 = lego::game::LiveObject_FUN_00438da0((LiveObject *)0x0,position,OBJECT_ORE,0);
		iVar3 = lego::game::Object_GetCostCrystal(OBJECT_PATH,0,0);
		iVar1 = lego::game::Object_GetCostOre(OBJECT_PATH,0,0);
		iVar4 = lego::game::Object_GetCostRefinedOre(OBJECT_PATH,0,0);
		lego::game::Level_SpawnCarryableObject(position,OBJECT_POWERCRYSTAL,0,0,iVar3);
		if ((pLVar2 == (LiveObject *)0x0) || (iVar4 == 0)) {
			iVar3 = 0;
		}
		else {
			iVar3 = 1;
			iVar1 = iVar4;
		}
		lego::game::Level_SpawnCarryableObject(position,OBJECT_ORE,iVar3,0,iVar1);
		*(uint *)(param_1 + 0xd0) = *(uint *)(param_1 + 0xd0) | 4;
	}
	return;
}



void __cdecl FUN_00409530(Point2I *position)
{
	LiveObject *pLVar1;
	LevelData *level;
	undefined *puVar2;
	int iVar3;
	int iVar4;
	uint uVar5;
	LiveObject **ppLVar6;
	uint uVar7;
	
	level = lego::globals::g_Game.level;
	puVar2 = (undefined *)FUN_00408ff0(position,(int *)0x0);
	if ((puVar2 != (undefined *)0x0) && (*(int *)(puVar2 + 0x1c) != *(int *)(puVar2 + 0x20))) {
		uVar7 = *(uint *)(puVar2 + 0x18);
		uVar5 = 0;
		if (uVar7 != 0) {
			do {
				if (((uVar5 != uVar7 - 1) &&
						(iVar3 = *(int *)(puVar2 + 0x14),
						*(int *)(iVar3 + uVar5 * 8) == *(int *)(iVar3 + 8 + uVar5 * 8))) &&
					 (iVar4 = *(int *)(iVar3 + 4 + uVar5 * 8), iVar4 == *(int *)(iVar3 + 0xc + uVar5 * 8))) {
					iVar3 = iVar4 * (level->dimensions).width + *(int *)(iVar3 + uVar5 * 8);
					level->blocks[iVar3].flags1 = level->blocks[iVar3].flags1 & ~BLOCK1_UNK_8000;
				}
				iVar3 = uVar5 * 8;
				iVar4 = *(int *)(iVar3 + 4 + *(int *)(puVar2 + 0x14)) * (level->dimensions).width +
								*(int *)(iVar3 + *(int *)(puVar2 + 0x14));
				level->blocks[iVar4].flags1 = level->blocks[iVar4].flags1 & ~BLOCK1_UNK_100000;
				level->blocks
				[*(int *)(iVar3 + 4 + *(int *)(puVar2 + 0x14)) * (level->dimensions).width +
				 *(int *)(iVar3 + *(int *)(puVar2 + 0x14))].field_10 = 0;
				lego::game::Level_UpdateBlockSurfaceUnk
									(level,*(int *)(*(int *)(puVar2 + 0x14) + iVar3),
									 ((int *)(*(int *)(puVar2 + 0x14) + iVar3))[1]);
				FUN_0041cee0((Point2I *)(iVar3 + *(int *)(puVar2 + 0x14)));
				uVar7 = *(uint *)(puVar2 + 0x18);
				uVar5 = uVar5 + 1;
			} while (uVar5 < uVar7);
		}
		uVar7 = 0;
		if (*(int *)(puVar2 + 0xcc) != 0) {
			ppLVar6 = (LiveObject **)(puVar2 + 0x2c);
			do {
				pLVar1 = *ppLVar6;
				if (pLVar1->objType == OBJECT_BARRIER) {
					pLVar1->flags3 = pLVar1->flags3 | LIVEOBJ3_UNK_800000;
					(*ppLVar6)->health = -1.0;
				}
				else {
					pLVar1->flags4 = pLVar1->flags4 & 0xfffffeff;
					lego::ai::AITask_DoCollect(*ppLVar6,0.0);
				}
				uVar7 = uVar7 + 1;
				ppLVar6 = ppLVar6 + 1;
			} while (uVar7 < *(uint *)(puVar2 + 0xcc));
		}
		lego::ai::AI_FUN_00403630(*(int *)(puVar2 + 8),0,0,0);
		FUN_00409920(puVar2);
	}
	return;
}



int __cdecl
FUN_004096c0(int objIndex,Point2I *param_2,Direction direction,Point2I *param_4,uint count)
{
	LevelBlockFlags1 *pLVar1;
	bool bVar2;
	LevelData *level;
	int *piVar3;
	int *piVar4;
	SurfaceMap *surfMap;
	uint uVar5;
	int iVar6;
	Point2I *pPVar7;
	Point2I *pPVar8;
	uint *puVar9;
	float fVar10;
	
	level = lego::globals::g_Game.level;
	piVar3 = lego::unk::Lego_AllocStruct_d4(param_2);
	*piVar3 = objIndex;
	piVar3[1] = direction;
	piVar4 = (int *)std::malloc(count * 8);
	piVar3[5] = (int)piVar4;
	pPVar7 = param_4;
	for (uVar5 = count * 8 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
		*piVar4 = pPVar7->x;
		pPVar7 = (Point2I *)&pPVar7->y;
		piVar4 = piVar4 + 1;
	}
	fVar10 = 4.0;
	for (iVar6 = 0; iVar6 != 0; iVar6 = iVar6 + -1) {
		*(undefined *)piVar4 = *(undefined *)&pPVar7->x;
		pPVar7 = (Point2I *)((int)&pPVar7->x + 1);
		piVar4 = (int *)((int)piVar4 + 1);
	}
	puVar9 = (uint *)piVar3[5];
	piVar3[6] = count;
	uVar5 = count;
	surfMap = lego::game::GetSurfaceMap();
	lego::game::SurfaceMap_FUN_0044ed90(surfMap,puVar9,uVar5,fVar10);
	param_2 = (Point2I *)0x0;
	if (count != 0) {
		pPVar7 = param_4 + 1;
		do {
			if (((param_2 == (Point2I *)(count - 1)) || (param_4->x != pPVar7->x)) ||
				 (param_4->y != pPVar7->y)) {
				bVar2 = false;
			}
			else {
				bVar2 = true;
				pLVar1 = &level->blocks[param_4->y * (level->dimensions).width + param_4->x].flags1;
				*pLVar1 = *pLVar1 | BLOCK1_UNK_8000;
				level->blocks[param_4->y * (level->dimensions).width + param_4->x].field_10 = piVar3;
			}
			iVar6 = param_4->y * (level->dimensions).width + param_4->x;
			level->blocks[iVar6].flags1 = level->blocks[iVar6].flags1 | BLOCK1_UNK_100000;
			level->blocks[param_4->y * (level->dimensions).width + param_4->x].field_10 = piVar3;
			lego::game::Level_UpdateBlockSurfaceUnk(level,param_4->x,param_4->y);
			FUN_00409870(param_4);
			FUN_0041cee0(param_4);
			pPVar8 = param_4;
			if (bVar2) {
				param_2 = (Point2I *)((int)&param_2->x + 1);
				pPVar8 = param_4 + 1;
				pPVar7 = pPVar7 + 1;
			}
			param_4 = pPVar7;
			param_2 = (Point2I *)((int)&param_2->x + 1);
			pPVar7 = param_4 + 1;
			param_4 = pPVar8 + 1;
		} while (param_2 < count);
	}
	return piVar3[2];
}



void __cdecl FUN_00409870(Point2I *position)
{
	int *piVar1;
	int iVar2;
	Point2I ANGLES [8];
	
	ANGLES[0].x = -1;
	ANGLES[0].y = -1;
	ANGLES[1].x = 0;
	ANGLES[1].y = -1;
	ANGLES[2].x = 1;
	ANGLES[2].y = -1;
	ANGLES[3].x = 1;
	ANGLES[3].y = 0;
	ANGLES[4].x = 1;
	ANGLES[4].y = 1;
	ANGLES[5].x = 0;
	ANGLES[5].y = 1;
	ANGLES[6].x = -1;
	ANGLES[6].y = 1;
	ANGLES[7].x = -1;
	ANGLES[7].y = 0;
	iVar2 = 8;
	piVar1 = (int *)&stack0xffffffb8;
	do {
		lego::game::Level_FUN_004332b0
							(lego::globals::g_Game.level,position->x + piVar1[2],piVar1[3] + position->y);
		iVar2 = iVar2 + -1;
		piVar1 = piVar1 + 2;
	} while (iVar2 != 0);
	return;
}



void __cdecl FUN_00409900(void)
{
	undefined *puVar1;
	undefined *puVar2;
	
	puVar2 = (undefined *)STRUCTD4_004b9a24;
	if (STRUCTD4_004b9a24 != (void *)0x0) {
		do {
			puVar1 = *(undefined **)(puVar2 + 0x24);
			FUN_00409920(puVar2);
			puVar2 = puVar1;
		} while (puVar1 != (undefined *)0x0);
	}
	return;
}



void __cdecl FUN_00409920(undefined *param_1)
{
	undefined *puVar1;
	undefined *puVar2;
	undefined *puVar3;
	
	puVar1 = (undefined *)STRUCTD4_004b9a24;
	puVar3 = (undefined *)0x0;
	if (STRUCTD4_004b9a24 != (void *)0x0) {
		do {
			puVar2 = puVar1;
			if (puVar2 == param_1) {
				if (puVar3 == (undefined *)0x0) {
					STRUCTD4_004b9a24 = *(void **)(puVar2 + 0x24);
				}
				else {
					*(undefined4 *)(puVar3 + 0x24) = *(undefined4 *)(puVar2 + 0x24);
				}
				break;
			}
			puVar1 = *(undefined **)(puVar2 + 0x24);
			puVar3 = puVar2;
		} while (*(undefined **)(puVar2 + 0x24) != (undefined *)0x0);
	}
	std::free(*(void **)(param_1 + 0x14));
	std::free(param_1);
	return;
}



void __cdecl FUN_00409970(int param_1)
{
	int iVar1;
	uint uVar2;
	int *piVar3;
	
	uVar2 = 0;
	if (*(int *)(param_1 + 0xcc) != 0) {
		piVar3 = (int *)(param_1 + 0x2c);
		do {
			iVar1 = *piVar3;
			piVar3 = piVar3 + 1;
			*(undefined4 *)(iVar1 + 0x340) = 0xbf800000;
			uVar2 = uVar2 + 1;
			*(uint *)(iVar1 + 1000) = *(uint *)(iVar1 + 1000) | 0x800000;
		} while (uVar2 < *(uint *)(param_1 + 0xcc));
	}
	return;
}



void __cdecl
FUN_004099c0(uint param_1,int *param_2,undefined4 param_3,uint *param_4,uint param_5,int param_6)
{
	SurfaceMap *surfMap;
	int iVar1;
	uint *puVar2;
	float fVar3;
	uint local_d4 [4];
	int local_c4;
	uint *local_c0;
	uint local_bc;
	
	puVar2 = local_d4;
	for (iVar1 = 0x35; iVar1 != 0; iVar1 = iVar1 + -1) {
		*puVar2 = 0;
		puVar2 = puVar2 + 1;
	}
	local_d4[3] = *param_2;
	local_c4 = param_2[1];
	local_d4[0] = param_1;
	local_d4[1] = param_3;
	fVar3 = 4.0;
	local_c0 = param_4;
	local_bc = param_5;
	surfMap = lego::game::GetSurfaceMap();
	lego::game::SurfaceMap_FUN_0044ed90(surfMap,param_4,param_5,fVar3);
	FUN_00409870((Point2I *)param_2);
	FUN_00409a60(local_d4,param_6);
	return;
}



uint * __cdecl FUN_00409a60(uint *param_1,int param_2)
{
	int iVar1;
	int *piVar2;
	ulonglong uVar3;
	SurfaceMap *surfMap;
	LiveObject *liveObj;
	uint uVar4;
	ObjectStatsFlags1 OVar5;
	ObjectStatsFlags2 OVar6;
	uint uVar7;
	uint x;
	float *out_x;
	float *out_y;
	float local_c;
	float local_8;
	undefined4 uStack4;
	
	uVar7 = 0;
	uStack4 = 0;
	out_y = &local_c;
	local_8 = (float)param_1[1];
	out_x = &local_8;
	uVar4 = param_1[4];
	uVar3 = (ulonglong)(uint)local_8;
	x = param_1[3];
	surfMap = lego::game::GetSurfaceMap();
	lego::game::SurfaceMap_FUN_0044f900(surfMap,x,uVar4,out_x,out_y);
	liveObj = lego::game::Game_CreateLiveResourceObject
											((Container *)(lego::globals::g_Game.BuildingData_TABLE + *param_1),
											 OBJECT_BUILDING,*param_1,0,local_8,local_c,(float)uVar3 * 1.570796);
	if (param_2 != 0) {
		FUN_00447dc0((uint *)liveObj);
		lego::front::Info_FUN_00419ab0(INFO_CONSTRUCTED,(char *)0x0,liveObj,(Point2I *)0x0);
	}
	uVar4 = param_1[6];
	if (uVar4 != 0) {
		do {
			if (uVar7 == uVar4 - 1) {
LAB_00409b4b:
				OVar5 = lego::game::LiveObject_GetStatsFlags1(liveObj);
				iVar1 = uVar7 * 8;
				if ((OVar5 & STATS1_TOOLSTORE) == STATS1_NONE) {
					FUN_0041cee0((Point2I *)(iVar1 + param_1[5]));
					FUN_00432380(*(int **)(iVar1 + param_1[5]),*(int **)(iVar1 + 4 + param_1[5]));
					OVar6 = lego::game::LiveObject_GetStatsFlags2(liveObj);
					if ((OVar6 & STATS2_GENERATEPOWER) != STATS2_NONE) {
						FUN_00432500((int *)(iVar1 + param_1[5]));
					}
					FUN_00409c00((int *)(iVar1 + param_1[5]));
				}
				else {
					FUN_00432320((int **)(iVar1 + param_1[5]));
				}
				FUN_0040cdd0(*(int *)(iVar1 + param_1[5]),*(int *)(iVar1 + 4 + param_1[5]));
			}
			else {
				uVar4 = param_1[5];
				iVar1 = uVar7 * 8;
				if ((*(int *)(iVar1 + uVar4) != *(int *)(iVar1 + 8 + uVar4)) ||
					 (piVar2 = *(int **)(iVar1 + 4 + uVar4), piVar2 != *(int **)(iVar1 + 0xc + uVar4)))
				goto LAB_00409b4b;
				FUN_004323c0(*(int **)(iVar1 + uVar4),piVar2);
				FUN_004403f0((int)liveObj,(int *)(iVar1 + param_1[5]));
				uVar7 = uVar7 + 1;
			}
			uVar4 = param_1[6];
			uVar7 = uVar7 + 1;
		} while (uVar7 < uVar4);
	}
	return (uint *)liveObj;
}



void __cdecl FUN_00409c00(int *param_1)
{
	int iVar1;
	Point2I *position;
	Point2I local_20;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_20.x = 0;
	local_20.y = -1;
	local_18 = 1;
	local_14 = 0;
	local_10 = 0;
	local_c = 1;
	local_8 = 0xffffffff;
	local_4 = 0;
	position = &local_20;
	iVar1 = 4;
	do {
		position->x = position->x + *param_1;
		position->y = position->y + param_1[1];
		FUN_00402a10(position,0);
		position = position + 1;
		iVar1 = iVar1 + -1;
	} while (iVar1 != 0);
	return;
}



void __cdecl lego::unk::Lego_SetBool_004b9a54(BOOL param_1)
{
	BOOL_004b9a54 = param_1;
	return;
}



void __cdecl FUN_00409c80(LiveObject *liveObj)
{
	bool bVar1;
	Point2I *pPVar2;
	Point2I *position;
	SurfaceMap *pSVar3;
	Point2I *pPVar4;
	Direction rotation;
	uint uVar5;
	float10 fVar6;
	uint x;
	uint y;
	float *out_x;
	float x_00;
	float *out_y;
	float y_00;
	uint local_34;
	Point2F local_30;
	Point2I local_28;
	float local_20;
	float local_1c;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	lego::game::LiveObject_GetFaceDirection(liveObj,&local_30);
	lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_28,&local_28.y);
	lego::game::LiveObject_GetPosition(liveObj,&local_20,&local_1c);
	if (ABS(local_30.x) <= ABS(local_30.y)) {
		if ((ushort)((ushort)(local_30.y < 0.0) << 8 | (ushort)(local_30.y == 0.0) << 0xe) == 0) {
			rotation = DIRECTION_UP;
		}
		else {
			rotation = DIRECTION_DOWN;
		}
	}
	else {
		if ((ushort)((ushort)(local_30.x < 0.0) << 8 | (ushort)(local_30.x == 0.0) << 0xe) == 0) {
			rotation = DIRECTION_RIGHT;
		}
		else {
			rotation = DIRECTION_LEFT;
		}
	}
	pPVar2 = lego::res::Building_GetShapePoints
										 (lego::globals::g_Game.BuildingData_TABLE + liveObj->objIndex,&local_34);
	position = lego::game::Game_TransformShapePoints(&local_28,pPVar2,local_34,rotation);
	uVar5 = 0;
	pPVar2 = position;
	if (local_34 != 0) {
		do {
			pPVar4 = pPVar2 + 1;
			if (((uVar5 == local_34 - 1) || (position->x != pPVar4->x)) || (position->y != pPVar2[1].y)) {
				bVar1 = false;
			}
			else {
				bVar1 = true;
			}
			FUN_00432290((int **)position);
			FUN_004322f0((int *)position);
			if ((*(byte *)&liveObj->flags4 & 8) == 0) {
				y = position->y;
				out_y = &local_14;
				out_x = &local_18;
				x = position->x;
				pSVar3 = lego::game::GetSurfaceMap();
				lego::game::SurfaceMap_FUN_0044f900(pSVar3,x,y,out_x,out_y);
				x_00 = local_18;
				y_00 = local_14;
				pSVar3 = lego::game::GetSurfaceMap();
				fVar6 = lego::game::SurfaceMap_GetSurfaceZ(pSVar3,x_00,y_00);
				local_10 = (float)fVar6;
				lego::math::Maths_Vector3DRandom(&local_c);
				local_c.z = 0.0;
				FUN_0040cc10(3,&local_18,(undefined4 *)&local_c);
				lego::ai::AITask_DoClearTypeAction(position,MESSAGE_CLEARBUILDING_COMPLETE);
			}
			FUN_0040cdd0(position->x,position->y);
			if (bVar1) {
				uVar5 = uVar5 + 1;
				pPVar4 = pPVar2 + 2;
				position = position + 1;
			}
			uVar5 = uVar5 + 1;
			position = position + 1;
			pPVar2 = pPVar4;
		} while (uVar5 < local_34);
	}
	FUN_00409e50(liveObj);
	return;
}



void __cdecl FUN_00409e50(LiveObject *liveObj)
{
	int iVar1;
	int iVar2;
	Point2I local_8;
	
	if ((liveObj->flags4 & LIVEOBJ4_UNK_800) == LIVEOBJ4_NONE) {
		lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_8,&local_8.y);
		iVar1 = lego::game::Object_GetCostOre(OBJECT_BUILDING,liveObj->objIndex,liveObj->objLevel);
		iVar2 = lego::game::Object_GetCostCrystal(OBJECT_BUILDING,liveObj->objIndex,liveObj->objLevel);
		lego::game::Object_GetCostRefinedOre(OBJECT_BUILDING,liveObj->objIndex,liveObj->objLevel);
		if (BOOL_004b9a54 == 0) {
			for (; iVar2 != 0; iVar2 = iVar2 + -1) {
				lego::game::Level_GenerateCrystal(&local_8,0,(Point2F *)0x0,0);
			}
			for (; iVar1 != 0; iVar1 = iVar1 + -1) {
				lego::game::Level_GenerateOre(&local_8,0,(Point2F *)0x0,0);
			}
		}
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_800;
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_00409f20(LiveObject *liveObj)
{
	bool bVar1;
	bool bVar2;
	bool bVar3;
	ObjectStatsFlags1 OVar4;
	Point2F local_8;
	
	bVar3 = false;
	bVar1 = false;
	bVar2 = false;
	LiveObject_GetPosition(liveObj,(float *)&local_8,&local_8.y);
	OVar4 = LiveObject_GetStatsFlags1(liveObj);
	if (((OVar4 & STATS1_SMALLTELEPORTER) != STATS1_NONE) &&
		 (globals::g_Game.placeDestSmallTeleporter == liveObj)) {
		bVar1 = true;
	}
	OVar4 = LiveObject_GetStatsFlags1(liveObj);
	if (((OVar4 & STATS1_BIGTELEPORTER) != STATS1_NONE) &&
		 (globals::g_Game.placeDestBigTeleporter == liveObj)) {
		bVar2 = true;
	}
	OVar4 = LiveObject_GetStatsFlags1(liveObj);
	if (((OVar4 & STATS1_WATERTELEPORTER) != STATS1_NONE) &&
		 (globals::g_Game.placeDestWaterTeleporter == liveObj)) {
		bVar3 = true;
	}
	if (bVar1) {
		globals::g_Game.placeDestSmallTeleporter = (LiveObject *)FUN_00438ff0(&local_8);
	}
	if (bVar2) {
		globals::g_Game.placeDestBigTeleporter = (LiveObject *)FUN_00438f90(&local_8);
	}
	if (bVar3) {
		globals::g_Game.placeDestWaterTeleporter = (LiveObject *)FUN_00439050(&local_8);
	}
	pool::ReservedPool_LiveObject___Release(liveObj);
	Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
	return;
}



void __cdecl lego::main::Main_ShowCreditsFiles(char *textFile,ImageFont *font,char *aviFile)
{
	char *pcVar1;
	byte *memblock;
	AVIPlayer_t *aviPlayer;
	uint uVar2;
	uint uVar3;
	DWORD DVar4;
	int iVar5;
	int iVar6;
	int iVar7;
	char **ppcVar8;
	int iVar9;
	int iVar10;
	int local_444;
	uint local_440;
	uint local_43c;
	DWORD local_438;
	int local_434;
	uint local_430;
	char *local_42c;
	int local_428;
	int local_424;
	char **local_420;
	int local_41c;
	AVIPlayer_t *local_418;
	BOOL local_414;
	RECT local_410;
	char buffer [1024];
	
	local_434 = 0;
	local_43c = 0;
	local_424 = 0;
	local_438 = timeGetTime();
	local_410.left = 0;
	local_410.top = 0;
	local_410.right = globs::mainGlobs.appWidth;
	local_410.bottom = globs::mainGlobs.appHeight;
	local_430 = image::Font_GetHeight(font);
	iVar9 = globs::mainGlobs.appHeight / local_430 + 1;
	local_41c = (int)globs::mainGlobs.appWidth / 2;
	local_428 = iVar9;
	std::sprintf(buffer,"%s.cconv",textFile);
	memblock = lego::file::File_LoadBinary(buffer,&local_440);
	if ((memblock != (byte *)0x0) ||
		 (memblock = lego::file::File_LoadBinary(textFile,&local_440), memblock != (byte *)0x0)) {
		local_42c = (char *)std::realloc(memblock,local_440 + 4);
		local_42c[local_440] = '\0';
		aviPlayer = video::Animation_Load(aviFile);
		if (1 < (int)local_440) {
			iVar5 = local_440 - 1;
			pcVar1 = local_42c;
			do {
				if ((*pcVar1 == '\r') && (pcVar1[1] == '\n')) {
					local_434 = local_434 + 1;
				}
				iVar5 = iVar5 + -1;
				pcVar1 = pcVar1 + 1;
			} while (iVar5 != 0);
		}
		local_434 = local_434 + 1;
		local_418 = aviPlayer;
		local_420 = (char **)std::malloc(local_434 * 4);
		util::Util_Tokenise(local_42c,local_420,"\r\n");
		iVar5 = -iVar9;
		iVar6 = 0;
		local_444 = iVar5;
		do {
			uVar2 = input::Input_AnyKeyPressed();
			if ((uVar2 != 0) || ((globs::INPUT.mslb == 0 && (iVar6 != 0)))) {
				local_424 = 1;
			}
			local_414 = globs::INPUT.mslb;
			video::Animation_Update(aviPlayer);
			uVar2 = video::Animation_GetLength(aviPlayer);
			uVar3 = video::Animation_GetTime(aviPlayer);
			if (uVar2 <= uVar3) {
				video::Animation_SetTime(aviPlayer,0);
			}
			video::Animation_BlitToBackBuffer(aviPlayer,&local_410);
			DVar4 = timeGetTime();
			iVar6 = iVar5;
			if (0x21 < DVar4 - local_438) {
				local_43c = local_43c + 1;
				if (local_43c == local_430) {
					iVar6 = iVar5 + 1;
					local_43c = 0;
					local_444 = iVar6;
					if (iVar5 == local_434) {
						iVar6 = -iVar9;
						local_444 = iVar6;
					}
				}
				uVar2 = local_438 + 0x21;
				local_438 = uVar2;
				DVar4 = timeGetTime();
				if (uVar2 < DVar4) {
					local_438 = timeGetTime();
				}
			}
			iVar5 = iVar6;
			if (iVar6 < local_434) {
				iVar7 = iVar6 * local_430;
				ppcVar8 = local_420 + iVar6;
				iVar10 = iVar7;
				do {
					iVar5 = local_444;
					aviPlayer = local_418;
					iVar9 = local_428;
					if (local_428 < iVar6 - local_444) break;
					if (-1 < iVar6) {
						uVar2 = image::FontX_GetStringWidth(font,"%s",*ppcVar8);
						image::Font_PrintF(font,local_41c - (int)uVar2 / 2,(iVar10 - iVar7) - local_43c,"%s",
															 *ppcVar8);
					}
					iVar6 = iVar6 + 1;
					iVar10 = iVar10 + local_430;
					ppcVar8 = ppcVar8 + 1;
					aviPlayer = local_418;
					iVar9 = local_428;
				} while (iVar6 < local_434);
			}
			snd::Audio_UnkUpdate_FUN_00465460(1.0);
			iVar6 = video::Animation_IsOk(aviPlayer);
			if (iVar6 == 0) {
				Main_LoopUpdate(TRUE);
				Sleep(10);
			}
			else {
				Main_LoopUpdate(FALSE);
			}
			iVar6 = local_414;
		} while (local_424 == 0);
		if (aviPlayer != (AVIPlayer_t *)0x0) {
			video::Animation_Free(aviPlayer);
		}
		std::free(local_420);
		std::free(local_42c);
	}
	return;
}



void __cdecl FUN_0040a300(void)
{
	uint *puVar1;
	
	puVar1 = (uint *)&DAT_004b9aa0;
	do {
		if ((*puVar1 & 1) != 0) {
			*puVar1 = *puVar1 & 0xfffffffe;
			lego::res::Container_Hide((Container *)puVar1[-7],1);
		}
		puVar1 = puVar1 + 8;
	} while (puVar1 < &DAT_004b9be0);
	return;
}



void __cdecl lego::main::Main_LoadHealthFont(char *dirname,char *fileBaseName)
{
	Container_Texture *pCVar1;
	uint uVar2;
	char local_208 [260];
	char local_104 [260];
	
	uVar2 = 0;
	do {
		std::sprintf(local_104,"%s\\",dirname);
		if (fileBaseName == (char *)0x0) {
			std::sprintf(local_208,"%i.bmp",uVar2);
		}
		else {
			std::sprintf(local_208,"%s%i.bmp",fileBaseName);
		}
		if (uVar2 == 10) {
			DAT_004b9a80 = res::Mesh_LoadTexture(local_104,local_208,0,0);
		}
		else {
			pCVar1 = res::Mesh_LoadTexture(local_104,local_208,0,0);
			(&globals::g_HealthFontFrames)[uVar2] = pCVar1;
		}
		uVar2 = uVar2 + 1;
	} while (uVar2 < 0xb);
	return;
}



void __cdecl FUN_0040a3e0(LiveObject *liveObj,uint param_2)
{
	BOOL BVar1;
	Container **data;
	Container *pCVar2;
	Mesh *pMVar3;
	int iVar4;
	float10 fVar5;
	uint local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_18 = 0;
	local_14 = 2;
	local_10 = 1;
	local_c = 0;
	local_8 = 3;
	local_4 = 2;
	BVar1 = lego::game::LiveObject_FUN_0040aa10(liveObj);
	if ((((BVar1 != 0) && (param_2 != 0)) && (param_2 < 999)) &&
		 (data = (Container **)FUN_0040a4f0(), data != (Container **)0x0)) {
		data[6] = (Container *)0x0;
		data[4] = (Container *)0x0;
		data[3] = (Container *)0x0;
		fVar5 = lego::game::LiveObject_GetCollHeight(liveObj);
		data[5] = (Container *)(float)-fVar5;
		if (*data == (Container *)0x0) {
			pCVar2 = lego::game::LiveObject_GetResource(liveObj);
			pCVar2 = lego::res::Container_Create(pCVar2);
			*data = pCVar2;
			pMVar3 = lego::res::Mesh_CreateOnFrame(pCVar2->activityFrame,FUN_0040a670,0x3000,data,0);
			data[1] = (Container *)pMVar3;
			iVar4 = 4;
			do {
				lego::res::Mesh_AddGroup((Mesh *)data[1],4,2,3,&local_18);
				iVar4 = iVar4 + -1;
			} while (iVar4 != 0);
		}
		else {
			pCVar2 = lego::game::LiveObject_GetResource(liveObj);
			lego::res::Container_SetParent(*data,pCVar2);
			lego::res::Container_Hide(*data,0);
		}
		FUN_0040a510((int)data,param_2);
	}
	return;
}



undefined4 * __cdecl FUN_0040a4f0(void)
{
	undefined4 *puVar1;
	
	puVar1 = &DAT_004b9a84;
	do {
		if ((*(byte *)(puVar1 + 7) & 1) == 0) {
			puVar1[7] = puVar1[7] | 1;
			return puVar1;
		}
		puVar1 = puVar1 + 8;
	} while (puVar1 < &DAT_004b9bc4);
	return (undefined4 *)0x0;
}



void __cdecl FUN_0040a510(int param_1,uint param_2)
{
	uint uVar1;
	D3DRMGroupIndex DVar2;
	D3DRMGroupIndex groupID;
	Mesh *mesh;
	float r;
	float g;
	D3DRMGroupIndex local_4;
	
	DVar2 = D3DRMGROUP_0;
	local_4 = D3DRMGROUP_0;
	groupID = D3DRMGROUP_0;
	do {
		if (param_2 < 5) {
			lego::res::Mesh_SetGroupColour(*(Mesh **)(param_1 + 4),groupID,0.0,1.0,0.0,MATERIAL_DIFFUSE);
			mesh = *(Mesh **)(param_1 + 4);
			g = 1.0;
			r = 0.0;
		}
		else {
			if (param_2 < 10) {
				lego::res::Mesh_SetGroupColour(*(Mesh **)(param_1 + 4),groupID,1.0,1.0,0.0,MATERIAL_DIFFUSE)
				;
				mesh = *(Mesh **)(param_1 + 4);
				g = 1.0;
				r = 1.0;
			}
			else {
				lego::res::Mesh_SetGroupColour
									(*(Mesh **)(param_1 + 4),groupID,1.0,0.25,0.0,MATERIAL_DIFFUSE);
				mesh = *(Mesh **)(param_1 + 4);
				g = 0.25;
				r = 1.0;
			}
		}
		lego::res::Mesh_SetGroupColour(mesh,groupID,r,g,0.0,MATERIAL_EMISSIVE);
		groupID = groupID + 1;
	} while (groupID < 4);
	uVar1 = 1;
	if (param_2 != 0) {
		do {
			DVar2 = DVar2 + 1;
			uVar1 = uVar1 * 10;
			local_4 = DVar2;
		} while (uVar1 <= param_2);
	}
	DVar2 = D3DRMGROUP_0;
	if (local_4 != D3DRMGROUP_0) {
		do {
			lego::res::Mesh_SetGroupTexture
								(*(Mesh **)(param_1 + 4),DVar2,
								 (Container_Texture *)(&lego::globals::g_HealthFontFrames)[param_2 % 10]);
			lego::res::Mesh_HideGroup(*(Mesh **)(param_1 + 4),DVar2,0);
			param_2 = (param_2 - param_2 % 10) / 10;
			DVar2 = DVar2 + 1;
		} while (DVar2 < local_4);
	}
	lego::res::Mesh_SetGroupTexture(*(Mesh **)(param_1 + 4),DVar2,DAT_004b9a80);
	for (DVar2 = local_4 + 1; DVar2 < 4; DVar2 = DVar2 + 1) {
		lego::res::Mesh_HideGroup(*(Mesh **)(param_1 + 4),DVar2,1);
	}
	*(D3DRMGroupIndex *)(param_1 + 8) = local_4 + 1;
	return;
}



void __cdecl FUN_0040a670(undefined4 param_1,Container **param_2,int param_3)
{
	float fVar1;
	float fVar2;
	float fVar3;
	Container *cont;
	Container *cont_00;
	Container *pCVar4;
	float local_88;
	Vector3F local_80;
	float local_74;
	float local_70;
	float local_6c;
	Vector3F local_68;
	Vector3F local_5c;
	float local_50;
	float local_4c;
	float local_48;
	float local_44;
	float local_40;
	float local_3c;
	float local_38;
	float local_34;
	float local_30;
	Point2F local_2c;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	Vector3F local_c;
	
	local_2c.x = 0.0;
	local_2c.y = 0.0;
	local_24 = 0x3f800000;
	local_20 = 0;
	local_1c = 0x3f800000;
	local_18 = 0x3f800000;
	local_14 = 0;
	local_10 = 0x3f800000;
	cont = lego::game::Game_GetCurrentViewLight();
	pCVar4 = param_2[6];
	lego::res::Container_SetOrientation(*param_2,(Container *)0x0,0.0,0.0,1.0,0.0,1.0,0.0);
	cont_00 = lego::view::Viewport_GetCamera((Viewport *)param_3);
	lego::res::Container_GetOrientation(cont_00,(Container *)0x0,&local_68,&local_80);
	lego::res::Container_GetPosition(cont,(Container *)0x0,&local_c);
	fVar1 = local_80.y * local_68.z;
	fVar2 = local_80.z * local_68.y;
	fVar3 = local_80.z * local_68.x;
	local_68.z = local_80.x * local_68.z;
	local_68.y = local_80.x * local_68.y;
	local_68.x = local_80.y * local_68.x;
	local_6c = (((float)pCVar4 * 0.06666667 + (float)pCVar4 * 0.06666667) - -1.0) * 3.0;
	local_80.x = local_6c * local_80.x;
	local_80.y = local_6c * local_80.y;
	local_88 = 1.0 - (float)ZEXT48(param_2[2]) * 0.5;
	local_80.z = local_6c * local_80.z;
	local_74 = local_6c * (fVar1 - fVar2);
	pCVar4 = (Container *)0x0;
	local_70 = local_6c * (fVar3 - local_68.z);
	local_6c = local_6c * (local_68.y - local_68.x);
	if (param_2[2] != (Container *)0x0) {
		do {
			local_5c.x = (float)param_2[3] - local_88 * local_74;
			local_5c.y = (float)param_2[4] - local_88 * local_70;
			local_5c.z = (float)param_2[5] - local_88 * local_6c;
			local_50 = local_74 + local_5c.x;
			local_4c = local_70 + local_5c.y;
			local_48 = local_6c + local_5c.z;
			local_38 = local_80.x + local_5c.x;
			local_34 = local_80.y + local_5c.y;
			local_44 = local_80.x + local_50;
			local_30 = local_80.z + local_5c.z;
			local_40 = local_80.y + local_4c;
			local_3c = local_80.z + local_48;
			lego::res::Mesh_SetVertices_PointNormalAt
								((Mesh *)param_2[1],(D3DRMGroupIndex)pCVar4,0,4,&local_5c,&local_c,&local_2c);
			local_88 = local_88 - -1.0;
			pCVar4 = (Container *)((int)&pCVar4->masterFrame + 1);
		} while (pCVar4 < param_2[2]);
	}
	return;
}



void __cdecl FUN_0040a940(float elapsedAbs)
{
	undefined4 *puVar1;
	
	puVar1 = &DAT_004b9a84;
	do {
		if ((*(byte *)(puVar1 + 7) & 1) != 0) {
			FUN_0040a970(puVar1,elapsedAbs);
		}
		puVar1 = puVar1 + 8;
	} while (puVar1 < &DAT_004b9bc4);
	return;
}



void __cdecl FUN_0040a970(undefined4 *param_1,float elapsed)
{
	float fVar1;
	D3DRMGroupIndex groupID;
	
	if ((float)param_1[6] < 15.0) {
		param_1[3] = (float)param_1[3] + 0.0;
		groupID = D3DRMGROUP_0;
		param_1[4] = (float)param_1[4] + 0.0;
		param_1[5] = elapsed * -1.0 + (float)param_1[5];
		fVar1 = (float)param_1[6];
		if (param_1[2] != 0) {
			do {
				lego::res::Mesh_SetGroupMaterialValues
									((Mesh *)param_1[1],groupID,1.0 - fVar1 * 0.06666667,MATERIAL_ALPHA);
				groupID = groupID + 1;
			} while (groupID < (uint)param_1[2]);
		}
		param_1[6] = elapsed + (float)param_1[6];
		return;
	}
	param_1[7] = param_1[7] & 0xfffffffe;
	lego::res::Container_Hide((Container *)*param_1,1);
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_0040aa10(LiveObject *liveObj)
{
	ObjectStatsFlags2 OVar1;
	
	OVar1 = LiveObject_GetStatsFlags2(liveObj);
	if ((((OVar1 & STATS2_DONTSHOWDAMAGE) == STATS2_NONE) && (liveObj->objType != OBJECT_DYNAMITE)) &&
		 (liveObj->objType != OBJECT_OOHSCARY)) {
		return 1;
	}
	return 0;
}



void __cdecl FUN_0040aa40(int param_1)
{
	lego::globals::g_MiscObjectDependencies_TABLE[19][14].levels_field_44[0] = (uint)(param_1 == 0);
	return;
}



void __cdecl FUN_0040aa60(void)
{
	uint *puVar1;
	int iVar2;
	uint *puVar3;
	int iVar4;
	
	puVar3 = lego::globals::g_MiscObjectDependencies_TABLE[0].levels_flags;
	do {
		iVar4 = 0xf;
		do {
			iVar2 = 0x10;
			puVar1 = puVar3;
			do {
				iVar2 = iVar2 + -1;
				*puVar1 = *puVar1 & 0xfffffef3;
				puVar1 = puVar1 + 1;
			} while (iVar2 != 0);
			puVar3 = puVar3 + 0x31;
			iVar4 = iVar4 + -1;
		} while (iVar4 != 0);
	} while (puVar3 < &DAT_004c81fc);
	return;
}



void __cdecl lego::main::Main_Load_Dependencies(CFGProperty *root,char *keyBasePath)
{
	char *keyPath;
	CFGProperty *prop;
	int iVar1;
	BOOL BVar2;
	int iVar3;
	uint *puVar4;
	int iVar5;
	void *pvVar6;
	char **ppcVar7;
	uint length;
	int local_50;
	int local_4c;
	ObjectType local_48;
	int local_44;
	char *local_40;
	char *local_3c;
	char *local_38;
	char *local_34;
	char *local_30;
	char *local_28 [10];
	
	keyPath = cfg::CFG_JoinPath(keyBasePath,"Dependencies",0);
	for (prop = cfg::CFG_GetChildren(root,keyPath); prop != (CFGProperty *)0x0;
			prop = cfg::CFG_NextFlat(prop)) {
		iVar1 = util::Util_Tokenise(prop->key,&local_40,":");
		BVar2 = game::Object_GetObjectByName
											(local_3c,(ObjectType *)&keyBasePath,&local_50,(Container **)0x0);
		if (BVar2 != 0) {
			iVar3 = std::_stricmp(local_40,"HitOnceStay");
			if (iVar1 == 3) {
				iVar1 = std::atoi(local_38);
				game::Object_GetLevels((ObjectType)keyBasePath,local_50);
				if (iVar3 == 0) {
					globals::g_MiscObjectDependencies_TABLE[(int)keyBasePath][local_50].levels_flags[iVar1] =
							 globals::g_MiscObjectDependencies_TABLE[(int)keyBasePath][local_50].levels_flags
							 [iVar1] | 1;
				}
				globals::g_MiscObjectDependencies_TABLE[(int)keyBasePath][local_50].field_0 = 1;
			}
			else {
				iVar1 = 0;
				if (iVar3 == 0) {
					iVar3 = 0x10;
					puVar4 = globals::g_MiscObjectDependencies_TABLE[(int)keyBasePath][local_50].levels_flags;
					do {
						iVar3 = iVar3 + -1;
						*puVar4 = *puVar4 | 1;
						puVar4 = puVar4 + 1;
					} while (iVar3 != 0);
				}
				globals::g_MiscObjectDependencies_TABLE[(int)keyBasePath][local_50].field_0 = 0;
			}
			iVar3 = util::Util_Tokenise(prop->value,local_28,",");
			length = iVar3 << 4;
			iVar5 = (iVar1 + (local_50 + (int)keyBasePath * 0xf) * 0x31) * 4;
			pvVar6 = std::malloc(length);
			*(void **)(&DAT_004b9c08 + iVar5) = pvVar6;
			*(int *)(&DAT_004b9bc8 + iVar5) = iVar3;
			if (iVar3 != 0) {
				ppcVar7 = local_28;
				local_44 = iVar3;
				do {
					iVar3 = util::Util_Tokenise(*ppcVar7,&local_34,":");
					BVar2 = game::Object_GetObjectByName(local_34,&local_48,&local_4c,(Container **)0x0);
					if (BVar2 != 0) {
						*(ObjectType *)
						 (*(int *)(&DAT_004b9c08 + (iVar1 + (local_50 + (int)keyBasePath * 0xf) * 0x31) * 4) +
							-0x10 + length) = local_48;
						*(int *)(*(int *)(&DAT_004b9c08 +
														 (iVar1 + (local_50 + (int)keyBasePath * 0xf) * 0x31) * 4) + -0xc +
										length) = local_4c;
						if (iVar3 == 2) {
							iVar3 = std::atoi(local_30);
							game::Object_GetLevels(local_48,local_4c);
							*(int *)(*(int *)(&DAT_004b9c08 +
															 (iVar1 + (local_50 + (int)keyBasePath * 0xf) * 0x31) * 4) + -8 +
											length) = iVar3;
							*(undefined4 *)
							 (*(int *)(&DAT_004b9c08 + (iVar1 + (local_50 + (int)keyBasePath * 0xf) * 0x31) * 4) +
								-4 + length) = 1;
						}
						else {
							*(undefined4 *)
							 (*(int *)(&DAT_004b9c08 + (iVar1 + (local_50 + (int)keyBasePath * 0xf) * 0x31) * 4) +
								-4 + length) = 0;
						}
					}
					ppcVar7 = ppcVar7 + 1;
					length = length - 0x10;
					local_44 = local_44 + -1;
				} while (local_44 != 0);
			}
		}
	}
	Main_Init_MiscObjectDependencies();
	return;
}



BOOL __cdecl
lego::game::Object_Dependencies_FUN_0040add0(ObjectType objType,int objIndex,int objLevel)
{
	uint *puVar1;
	uint uVar2;
	BOOL BVar3;
	int iVar4;
	ObjectType OVar5;
	
	if (globals::g_MiscObjectDependencies_TABLE[19][14].levels_field_44[0] == 0) {
		puVar1 = globals::g_MiscObjectDependencies_TABLE[objType][objIndex].levels_flags + objLevel;
		if ((*(byte *)(globals::g_MiscObjectDependencies_TABLE[objType][objIndex].levels_flags +
									objLevel) & 2) == 0) {
			Object_Dependencies_Getter_FUN_0040aec0(objType,objIndex,objLevel,&objIndex,&objType);
			OVar5 = OBJECT_NONE;
			if (objType != OBJECT_NONE) {
				iVar4 = 0;
				do {
					BVar3 = unk::DoLiveObjCallbacks_True_FUN_00437a70
														(FUN_0040ae70,(LiveObject *)(objIndex + iVar4));
					if (BVar3 == 0) {
						return 0;
					}
					OVar5 = OVar5 + OBJECT_VEHICLE;
					iVar4 = iVar4 + 0x10;
				} while (OVar5 < objType);
			}
			uVar2 = *puVar1;
			if ((uVar2 & 1) != 0) {
				*puVar1 = uVar2 | 2;
			}
		}
	}
	return TRUE;
}



undefined4 __cdecl FUN_0040ae70(int *param_1,int *param_2)
{
	BOOL BVar1;
	
	BVar1 = FUN_004394c0(*param_2);
	if (BVar1 == 0) {
		if (*param_2 != *param_1) {
			return 0;
		}
		if (param_2[1] != param_1[1]) {
			return 0;
		}
		if ((param_2[3] != 0) && ((uint)param_1[0xcc] < (uint)param_2[2])) {
			return 0;
		}
	}
	return 1;
}



void __cdecl
lego::game::Object_Dependencies_Getter_FUN_0040aec0
					(ObjectType objType,int objIndex,int objLevel,undefined4 *out_param_4,
					undefined4 *out_param_5)
{
	int iVar1;
	
	iVar1 = objIndex * 0xc4 + objType * 0xb7c;
	if (globals::g_MiscObjectDependencies_TABLE[objType][objIndex].field_0 != 0) {
		iVar1 = (objLevel + (objIndex + objType * 0xf) * 0x31) * 4;
		*out_param_4 = *(undefined4 *)(&DAT_004b9c08 + iVar1);
		*out_param_5 = *(undefined4 *)(&DAT_004b9bc8 + iVar1);
		return;
	}
	*out_param_4 = *(undefined4 *)(&DAT_004b9c08 + iVar1);
	*out_param_5 = *(undefined4 *)(&DAT_004b9bc8 + iVar1);
	return;
}



void __cdecl
lego::game::Object_Dependencies_FUN_0040af30
					(ObjectType objType,int objIndex,int objLevel,int param_4)
{
	int iVar1;
	int iVar2;
	uint objIndex_00;
	ObjectType objType_00;
	uint uVar3;
	uint local_c;
	MiscObjectDependencies (*local_8) [15];
	uint local_4;
	
	iVar1 = param_4;
	local_8 = globals::g_MiscObjectDependencies_TABLE;
	objType_00 = OBJECT_NONE;
	*(undefined4 *)(param_4 + 0x200) = 0;
	do {
		objIndex_00 = 0;
		do {
			if ((*local_8)[0].field_0 == 0) {
				Object_Dependencies_Getter_FUN_0040aec0(objType_00,objIndex_00,0,&param_4,&local_c);
				uVar3 = 0;
				if (local_c != 0) {
					iVar2 = 0;
					do {
						if (((*(ObjectType *)(param_4 + iVar2) == objType) &&
								(*(int *)(param_4 + 4 + iVar2) == objIndex)) &&
							 ((*(int *)(param_4 + 0xc + iVar2) == 0 || (*(int *)(param_4 + 8 + iVar2) == objLevel)
								))) {
							*(ObjectType *)(iVar1 + *(int *)(iVar1 + 0x200) * 4) = objType_00;
							*(uint *)(iVar1 + 0x80 + *(int *)(iVar1 + 0x200) * 4) = objIndex_00;
							*(undefined4 *)(iVar1 + 0x180 + *(int *)(iVar1 + 0x200) * 4) = 0;
							*(int *)(iVar1 + 0x200) = *(int *)(iVar1 + 0x200) + 1;
						}
						uVar3 = uVar3 + 1;
						iVar2 = iVar2 + 0x10;
					} while (uVar3 < local_c);
				}
			}
			else {
				uVar3 = 0;
				do {
					Object_Dependencies_Getter_FUN_0040aec0(objType_00,objIndex_00,uVar3,&param_4,&local_c);
					iVar2 = 0;
					local_4 = 0;
					if (local_c != 0) {
						do {
							if (((*(ObjectType *)(param_4 + iVar2) == objType) &&
									(*(int *)(param_4 + 4 + iVar2) == objIndex)) &&
								 ((*(int *)(param_4 + 0xc + iVar2) == 0 ||
									(*(int *)(param_4 + 8 + iVar2) == objLevel)))) {
								*(ObjectType *)(iVar1 + *(int *)(iVar1 + 0x200) * 4) = objType_00;
								*(uint *)(iVar1 + 0x80 + *(int *)(iVar1 + 0x200) * 4) = objIndex_00;
								*(uint *)(iVar1 + 0x100 + *(int *)(iVar1 + 0x200) * 4) = uVar3;
								*(undefined4 *)(iVar1 + 0x180 + *(int *)(iVar1 + 0x200) * 4) = 1;
								*(int *)(iVar1 + 0x200) = *(int *)(iVar1 + 0x200) + 1;
							}
							iVar2 = iVar2 + 0x10;
							local_4 = local_4 + 1;
						} while (local_4 < local_c);
					}
					uVar3 = uVar3 + 1;
				} while (uVar3 < 0x10);
			}
			objIndex_00 = objIndex_00 + 1;
			local_8 = (MiscObjectDependencies (*) [15])(*local_8 + 1);
		} while (objIndex_00 < 0xf);
		objType_00 = objType_00 + OBJECT_VEHICLE;
	} while (local_8 < (MiscObjectDependencies (*) [15])&DAT_004c81f8);
	return;
}



void __cdecl lego::main::Main_Init_MiscObjectDependencies(void)
{
	uint *puVar1;
	BOOL BVar2;
	uint uVar3;
	uint objIndex;
	uint objNumber;
	uint objLevel;
	ObjectType local_4;
	
	objNumber = 0;
	local_4 = OBJECT_NONE;
	do {
		objIndex = 0;
		do {
			objLevel = 0;
			do {
				if ((objLevel == 1) &&
					 (globals::g_MiscObjectDependencies_TABLE[objIndex + objNumber].field_0 != 0)) break;
				puVar1 = globals::g_MiscObjectDependencies_TABLE[objIndex + objNumber].levels_flags +
								 objLevel;
				if ((*(byte *)(globals::g_MiscObjectDependencies_TABLE[objIndex + objNumber].levels_flags +
											objLevel) & 8) == 0) {
					BVar2 = game::Object_Dependencies_FUN_0040add0(local_4,objIndex,objLevel);
					uVar3 = *puVar1;
					if (BVar2 == 0) {
						if ((uVar3 & 4) != 0) goto LAB_0040b14c;
					}
					else {
						if ((uVar3 & 4) == 0) {
							uVar3 = uVar3 | 4;
						}
						else {
LAB_0040b14c:
							uVar3 = uVar3 & 0xfffffffb | 8;
						}
						*puVar1 = uVar3;
					}
				}
				objLevel = objLevel + 1;
			} while (objLevel < 0x10);
			objIndex = objIndex + 1;
		} while (objIndex < 0xf);
		objNumber = objNumber + 0xf;
		local_4 = local_4 + OBJECT_VEHICLE;
		if (299 < objNumber) {
			return;
		}
	} while( true );
}



BOOL __cdecl
lego::game::Object_Dependencies_IsLevelFlag4(ObjectType objType,int objIndex,int objLevel)
{
	if (globals::g_MiscObjectDependencies_TABLE[objType][objIndex].field_0 != 0) {
		return globals::g_MiscObjectDependencies_TABLE[objType][objIndex].levels_flags[objLevel] & 4;
	}
	return globals::g_MiscObjectDependencies_TABLE[objType][objIndex].levels_flags[0] & 4;
}



void __cdecl
lego::game::Object_SetDependencyLevelFlag_100(ObjectType objType,int objIndex,int objLevel)
{
	globals::g_MiscObjectDependencies_TABLE[objType][objIndex].levels_flags[objLevel] =
			 globals::g_MiscObjectDependencies_TABLE[objType][objIndex].levels_flags[objLevel] | 0x100;
	return;
}



uint __cdecl
lego::game::Object_GetDependencyLevelFlag_100(ObjectType objType,int objIndex,int objLevel)
{
	return globals::g_MiscObjectDependencies_TABLE[objType][objIndex].levels_flags[objLevel] & 0x100;
}



SurfaceTextureGrid * __cdecl
lego::game::Level_LoadTextureBaseName(char *textureBaseName,uint width,uint height)
{
	SurfaceTextureGrid *buffer;
	Container_Texture **ppCVar1;
	Container_Texture *pCVar2;
	uint uVar3;
	uint uVar4;
	int iVar5;
	int local_404;
	char local_400 [1024];
	
	buffer = (SurfaceTextureGrid *)std::malloc(0xc);
	uVar3 = 0;
	if (buffer != (SurfaceTextureGrid *)0x0) {
		ppCVar1 = (Container_Texture **)std::malloc(height * width * 4);
		buffer->gridSurfaces = ppCVar1;
		if (ppCVar1 == (Container_Texture **)0x0) {
			std::free(buffer);
			buffer = (SurfaceTextureGrid *)0x0;
		}
		else {
			(buffer->gridSize).width = width;
			(buffer->gridSize).height = height;
			if (height != 0) {
				local_404 = 0;
				do {
					uVar4 = 0;
					iVar5 = local_404;
					if (width != 0) {
						do {
							std::sprintf(local_400,"%s%0.1x%0.1x.bmp",textureBaseName,uVar4,uVar3);
							pCVar2 = res::Container_LoadTexture2(local_400,1,(uint *)0x0,(uint *)0x0);
							uVar4 = uVar4 + 1;
							*(Container_Texture **)((int)buffer->gridSurfaces + iVar5) = pCVar2;
							iVar5 = iVar5 + 4;
						} while (uVar4 < width);
					}
					uVar3 = uVar3 + 1;
					local_404 = local_404 + width * 4;
				} while (uVar3 < height);
				return buffer;
			}
		}
	}
	return buffer;
}



void __cdecl FUN_0040b340(uint *param_1)
{
	uint uVar1;
	uint uVar2;
	uint uVar3;
	
	uVar2 = 0;
	if (param_1[1] != 0) {
		do {
			uVar1 = *param_1;
			uVar3 = 0;
			if (uVar1 != 0) {
				do {
					lego::res::Container_FreeTexture
										(*(Container_Texture **)(param_1[2] + (uVar2 * uVar1 + uVar3) * 4));
					uVar1 = *param_1;
					uVar3 = uVar3 + 1;
				} while (uVar3 < uVar1);
			}
			uVar2 = uVar2 + 1;
		} while (uVar2 < param_1[1]);
	}
	std::free((void *)param_1[2]);
	std::free(param_1);
	return;
}



float10 __cdecl FUN_0040b3a0(int param_1,int param_2,float *param_3,int param_4)
{
	float *pfVar1;
	float *pfVar2;
	int iVar3;
	Vector4F *out_transform4d;
	Vector3F *pVVar4;
	float10 fVar5;
	float10 fVar6;
	float local_78;
	Vector3F local_70;
	Vector3F local_64;
	Vector3F local_58;
	Vector3F local_4c;
	Vector4F local_40 [4];
	
	local_78 = 1.0;
	iVar3 = 4;
	out_transform4d = local_40;
	pVVar4 = &local_70;
	do {
		lego::view::Viewport_Transform
							((Viewport *)param_2,out_transform4d,
							 (Vector3F *)((param_1 - (int)&local_70) + (int)pVVar4));
		iVar3 = iVar3 + -1;
		pVVar4->x = out_transform4d->x / out_transform4d->w;
		pVVar4->y = out_transform4d->y / out_transform4d->w;
		out_transform4d = out_transform4d + 1;
		pVVar4 = pVVar4 + 1;
	} while (iVar3 != 0);
	if (param_4 == 0) {
		pfVar2 = &local_40[0].z;
		pfVar1 = &local_70.y;
		iVar3 = 4;
		do {
			if (0.0 <= pfVar1[-1]) {
				if (0.0 <= *pfVar1) {
					if ((ushort)((ushort)(pfVar1[-1] < *param_3) << 8 |
											(ushort)(pfVar1[-1] == *param_3) << 0xe) == 0) {
						local_78 = local_78 - 0.25;
					}
					else {
						if ((ushort)((ushort)(*pfVar1 < param_3[1]) << 8 |
												(ushort)(*pfVar1 == param_3[1]) << 0xe) == 0) {
							local_78 = local_78 - 0.25;
						}
						else {
							if (((ushort)((ushort)(*pfVar2 < pfVar2[1]) << 8 |
													 (ushort)(*pfVar2 == pfVar2[1]) << 0xe) == 0) || (*pfVar2 < 0.0)) {
								local_78 = local_78 - 0.25;
							}
						}
					}
				}
				else {
					local_78 = local_78 - 0.25;
				}
			}
			else {
				local_78 = local_78 - 0.25;
			}
			pfVar1 = pfVar1 + 3;
			pfVar2 = pfVar2 + 4;
			iVar3 = iVar3 + -1;
		} while (iVar3 != 0);
	}
	if ((ushort)((ushort)(local_78 < 0.0) << 8 | (ushort)(local_78 == 0.0) << 0xe) != 0) {
		return (float10)0.0;
	}
	fVar5 = lego::math::Maths_TriangleAreaZ(&local_58,&local_64,&local_70,0);
	fVar6 = lego::math::Maths_TriangleAreaZ(&local_70,&local_4c,&local_58,0);
	return (fVar6 + (float10)(float)fVar5) * (float10)local_78;
}



ProMeshData * __cdecl
FUN_0040b520(Container *resData,char *meshName_a,char *meshName_b,float blockSize,
						SurfaceTextureGrid *surfTextGrid)
{
	ProMeshData *buffer;
	Container *pCVar1;
	D3DRMVertex *out_retArray;
	float *pfVar2;
	int iVar3;
	float fVar4;
	undefined4 *puVar5;
	ProMeshData *pPVar6;
	uint uVar7;
	undefined4 *puVar8;
	
	if (meshName_b == (char *)0x0) {
		meshName_b = meshName_a;
	}
	buffer = (ProMeshData *)std::malloc(0x340);
	if (buffer != (ProMeshData *)0x0) {
		pCVar1 = lego::res::Container_Load(resData,meshName_a,"LWO:NOTEXTURE",1);
		buffer->promesh_a = pCVar1;
		if (pCVar1 != (Container *)0x0) {
			pCVar1 = lego::res::Container_Load(resData,meshName_b,"LWO:NOTEXTURE",1);
			buffer->promesh_b = pCVar1;
			if (pCVar1 == (Container *)0x0) {
				pCVar1 = lego::res::Container_Load(resData,meshName_a,"LWO:NOTEXTURE",1);
				buffer->promesh_b = pCVar1;
			}
			fVar4 = blockSize * 0.01;
			buffer->field_32c = 0;
			buffer->BlockSize = blockSize;
			buffer->surfTextGrid = surfTextGrid;
			puVar5 = buffer->table_a;
			blockSize = 2.802597e-45;
			pPVar6 = buffer;
			do {
				lego::res::Container_Mesh_Scale(pPVar6->promesh_a,fVar4,fVar4,fVar4);
				lego::res::Container_Mesh_SetPerspectiveCorrection(pPVar6->promesh_a,D3DRMGROUP_0,1);
				lego::res::Container_Hide(pPVar6->promesh_a,1);
				puVar8 = puVar5;
				for (iVar3 = 100; iVar3 != 0; iVar3 = iVar3 + -1) {
					*puVar8 = 0;
					puVar8 = puVar8 + 1;
				}
				pPVar6 = (ProMeshData *)&pPVar6->promesh_b;
				puVar5 = puVar5 + 100;
				blockSize = (float)((int)blockSize + -1);
			} while (blockSize != 0.0);
			uVar7 = 0;
			do {
				lego::res::Container_Mesh_GetGroup
									((Container *)buffer->table_a[uVar7 - 2],D3DRMGROUP_0,(uint *)&blockSize,
									 (uint *)0x0,(uint *)0x0,(uint *)0x0,(uint *)0x0);
				out_retArray = (D3DRMVertex *)std::malloc((int)blockSize * 0x24);
				lego::res::Container_Mesh_GetVertices
									((Container *)buffer->table_a[uVar7 - 2],D3DRMGROUP_0,0,(uint)blockSize,
									 out_retArray);
				fVar4 = 0.0;
				if (blockSize != 0.0) {
					pfVar2 = &out_retArray->tv;
					do {
						if (uVar7 != 0) {
							pfVar2[-1] = 1.0 - pfVar2[-1];
							*pfVar2 = 1.0 - *pfVar2;
						}
						fVar4 = (float)((int)fVar4 + 1);
						pfVar2 = pfVar2 + 9;
					} while ((uint)fVar4 < (uint)blockSize);
				}
				lego::res::Container_Mesh_SetVertices
									((Container *)buffer->table_a[uVar7 - 2],D3DRMGROUP_0,0,(uint)blockSize,
									 out_retArray);
				std::free(out_retArray);
				uVar7 = uVar7 + 1;
			} while (uVar7 < 2);
			return buffer;
		}
		std::free(buffer);
	}
	return (ProMeshData *)0x0;
}



void __thiscall FUN_0040b700(void *this,int **param_1)
{
	Container **ppCVar1;
	int iVar2;
	
	if (param_1 != (int **)0x0) {
		lego::game::Level_SurfText_FUN_0040b740(this,(int)param_1);
		iVar2 = 2;
		ppCVar1 = (Container **)param_1;
		do {
			lego::res::Container_Remove(*ppCVar1);
			ppCVar1 = ppCVar1 + 1;
			iVar2 = iVar2 + -1;
		} while (iVar2 != 0);
		std::free(param_1);
	}
	return;
}



void __thiscall lego::game::Level_SurfText_FUN_0040b740(void *this,int param_1)
{
	int iVar1;
	Container **ppCVar2;
	int iVar3;
	
	*(undefined4 *)(param_1 + 0x32c) = 0;
	ppCVar2 = (Container **)(param_1 + 8);
	iVar1 = 2;
	do {
		iVar3 = 100;
		do {
			if (*ppCVar2 != (Container *)0x0) {
				res::Container_Remove(*ppCVar2);
				*ppCVar2 = (Container *)0x0;
			}
			ppCVar2 = ppCVar2 + 1;
			iVar3 = iVar3 + -1;
		} while (iVar3 != 0);
		iVar1 = iVar1 + -1;
	} while (iVar1 != 0);
	return;
}



undefined4 __cdecl FUN_0040b780(int *param_1,uint param_2)
{
	if (param_1 != (int *)0x0) {
		return *(undefined4 *)(param_1[2] + ((param_2 & 0xf) * *param_1 + ((param_2 & 0xff) >> 4)) * 4);
	}
	return 0;
}



void __cdecl
FUN_0040b7b0(int param_1,int param_2,uint param_3,uint param_4,undefined4 param_5,undefined4 param_6
						)
{
	float fVar1;
	undefined **ppuVar2;
	Container *pCVar3;
	Container **ppCVar4;
	uint uVar5;
	uint uVar6;
	Container *local_38 [2];
	int local_30 [4];
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if (param_1 != 0) {
		fVar1 = *(float *)(param_1 + 0x328);
		local_30[2] = 2;
		local_14 = 2;
		local_c = 2;
		local_30[0] = 3;
		local_1c = 3;
		local_8 = 3;
		local_30[1] = 0;
		local_30[3] = 0;
		local_20 = 1;
		local_18 = 1;
		local_10 = 0;
		local_4 = 1;
		ppuVar2 = (undefined **)FUN_0040b780(*(int **)(param_1 + 0x33c),param_3);
		ppCVar4 = local_38;
		uVar5 = 0;
		do {
			pCVar3 = lego::res::Container_Clone(*(Container **)((param_1 - (int)local_38) + (int)ppCVar4))
			;
			*(Container **)(param_1 + 8 + (uVar5 + *(int *)(param_1 + 0x32c)) * 4) = pCVar3;
			uVar6 = uVar5 + 100;
			*ppCVar4 = *(Container **)(param_1 + 8 + (uVar5 + *(int *)(param_1 + 0x32c)) * 4);
			ppCVar4 = ppCVar4 + 1;
			uVar5 = uVar6;
		} while (uVar6 < 200);
		uVar5 = param_4 & 0xff;
		FUN_0040b930(local_38[0],fVar1,(float *)(param_2 + local_30[uVar5 * 3] * 0xc),
								 (float *)(param_2 + local_30[uVar5 * 3 + 1] * 0xc),
								 (float *)(param_2 + local_30[uVar5 * 3 + 2] * 0xc),param_5,param_6,ppuVar2,0);
		uVar5 = uVar5 + 2 & 3;
		FUN_0040b930(local_38[1],fVar1,(float *)(param_2 + local_30[uVar5 * 3] * 0xc),
								 (float *)(param_2 + local_30[uVar5 * 3 + 1] * 0xc),
								 (float *)(param_2 + local_30[uVar5 * 3 + 2] * 0xc),param_5,param_6,ppuVar2,0);
		*(int *)(param_1 + 0x32c) = *(int *)(param_1 + 0x32c) + 1;
	}
	return;
}



void __cdecl
FUN_0040b930(Container *resData,float param_2,float *param_3,float *param_4,float *param_5,
						float param_6,float param_7,undefined **param_8,byte param_9)
{
	uint uVar1;
	D3DRMGroupIndex DVar2;
	D3DRMGroupIndex groupID;
	
	FUN_0040bac0(resData,param_2,param_3,param_4,param_5);
	lego::res::Container_Hide(resData,0);
	groupID = D3DRMGROUP_0;
	uVar1 = lego::res::Container_Mesh_GetGroupCount(resData);
	if (uVar1 != 0) {
		do {
			lego::res::Container_Mesh_SetTexture(resData,groupID,(Container_Texture *)param_8);
			groupID = groupID + 1;
			DVar2 = lego::res::Container_Mesh_GetGroupCount(resData);
		} while (groupID < DVar2);
	}
	lego::res::Container_AddTranslation(resData,D3DRMCOMBINE_BEFORE,-0.02,-0.02,0.0);
	lego::res::Container_AddScale(resData,D3DRMCOMBINE_BEFORE,1.015,1.015,param_6);
	lego::res::Container_SetColourAlpha(resData,param_7,param_7,param_7,1.0);
	if ((param_9 & 1) != 0) {
		lego::res::Container_AddRotation(resData,D3DRMCOMBINE_BEFORE,1.0,0.0,0.0,1.570796);
	}
	if ((param_9 & 2) != 0) {
		lego::res::Container_AddRotation(resData,D3DRMCOMBINE_BEFORE,1.0,0.0,0.0,-1.570796);
	}
	if ((param_9 & 4) != 0) {
		lego::res::Container_AddRotation(resData,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,1.570796);
	}
	if ((param_9 & 8) != 0) {
		lego::res::Container_AddRotation(resData,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,-1.570796);
	}
	if ((param_9 & 0x10) != 0) {
		lego::res::Container_AddRotation(resData,D3DRMCOMBINE_BEFORE,0.0,0.0,1.0,1.570796);
	}
	if ((param_9 & 0x20) != 0) {
		lego::res::Container_AddRotation(resData,D3DRMCOMBINE_BEFORE,0.0,0.0,1.0,-1.570796);
	}
	if ((param_9 & 0x80) != 0) {
		lego::res::Container_AddTranslation(resData,D3DRMCOMBINE_AFTER,0.0,-10.0,0.0);
	}
	if ((param_9 & 0x40) != 0) {
		lego::res::Container_AddTranslation(resData,D3DRMCOMBINE_AFTER,0.0,10.0,0.0);
	}
	return;
}



void __cdecl
FUN_0040bac0(Container *resData,float param_2,float *param_3,float *param_4,float *param_5)
{
	float fVar1;
	float fVar2;
	float fVar3;
	Vector3F local_58;
	Vector3F local_4c;
	Matrix4F local_40;
	
	fVar1 = *param_4 - *param_3;
	local_58.y = param_4[1] - param_3[1];
	local_58.z = param_4[2] - param_3[2];
	local_4c.x = (param_5[2] - param_4[2]) * local_58.y - (param_5[1] - param_4[1]) * local_58.z;
	local_4c.y = (*param_5 - *param_4) * local_58.z - (param_5[2] - param_4[2]) * fVar1;
	local_4c.z = (param_5[1] - param_4[1]) * fVar1 - (*param_5 - *param_4) * local_58.y;
	fVar3 = 1.0 / SQRT(local_58.z * local_58.z + local_58.y * local_58.y + fVar1 * fVar1);
	fVar2 = 1.0 / SQRT(local_4c.z * local_4c.z + local_4c.y * local_4c.y + local_4c.x * local_4c.x);
	lego::res::Container_SetOrientation
						(resData,(Container *)0x0,-(fVar2 * local_4c.x),-(fVar2 * local_4c.y),
						 -(fVar2 * local_4c.z),fVar3 * fVar1,fVar3 * local_58.y,fVar3 * local_58.z);
	lego::res::Container_SetPosition(resData,(Container *)0x0,*param_3,param_3[1],param_3[2]);
	lego::res::Container_InverseTransform(resData,&local_58,(Vector3F *)param_4);
	lego::res::Container_InverseTransform(resData,&local_4c,(Vector3F *)param_5);
	FUN_0040bc90((float *)&local_40,param_2,param_2,local_58.y,local_4c.x,local_4c.y);
	lego::res::Container_AddTransform(resData,D3DRMCOMBINE_BEFORE,&local_40);
	return;
}



void __cdecl
FUN_0040bc90(float *param_1,float param_2,float param_3,float param_4,float param_5,float param_6)
{
	param_1[3] = 0.0;
	param_1[2] = 0.0;
	param_1[7] = 0.0;
	param_1[6] = 0.0;
	param_1[4] = 0.0;
	param_1[0xb] = 0.0;
	param_1[9] = 0.0;
	param_1[8] = 0.0;
	param_1[0xe] = 0.0;
	param_1[0xd] = 0.0;
	param_1[0xc] = 0.0;
	param_1[0xf] = 1.0;
	param_1[10] = 1.0;
	*param_1 = param_5 / param_2;
	param_1[5] = param_4 / param_3;
	param_1[1] = (param_6 / param_5) * (param_5 / param_2);
	return;
}



void __cdecl FUN_0040bcf0(void)
{
	undefined4 local_4;
	
	FUN_0040c2d0(10000.0,&local_4,&local_4);
	return;
}



void __cdecl FUN_0040bd10(LiveObject *liveObj)
{
	Vector3F local_c;
	
	lego::res::Container_GetPosition(liveObj->other,(Container *)0x0,&local_c);
	FUN_0040bd40(&local_c);
	return;
}



void __cdecl FUN_0040bd40(Vector3F *position)
{
	Container **ppCVar1;
	LevelData *pLVar2;
	Container *pCVar3;
	int iVar4;
	
	iVar4 = 0;
	ppCVar1 = PTR_ARRAY_004c8bd8;
	do {
		if (*ppCVar1 == (Container *)0x0) {
			pLVar2 = lego::game::GetLevel();
			pCVar3 = lego::globals::g_Game.RES_BoulderExplode;
			if (pLVar2->BoulderAnimation == TEXTURES_ICE) {
				pCVar3 = lego::globals::g_Game.RES_BoulderExplodeIce;
			}
			pCVar3 = lego::res::Container_Clone(pCVar3);
			PTR_ARRAY_004c8bd8[iVar4] = pCVar3;
			lego::res::Container_SetAnimationTime(pCVar3,0.0);
			lego::res::Container_SetPosition
								(PTR_ARRAY_004c8bd8[iVar4],(Container *)0x0,position->x,position->y,position->z);
			lego::res::Container_SetOrientation
								(PTR_ARRAY_004c8bd8[iVar4],(Container *)0x0,0.0,1.0,0.0,0.0,0.0,-1.0);
			return;
		}
		ppCVar1 = ppCVar1 + 1;
		iVar4 = iVar4 + 1;
	} while (ppCVar1 < &DAT_004c8be8);
	return;
}



void __cdecl FUN_0040bde0(LiveObject *liveObj,Vector3F *param_2)
{
	Container *pCVar1;
	Container **ppCVar2;
	Vector3F local_c;
	
	if (liveObj == (LiveObject *)0x0) {
		local_c.x = param_2->x;
		local_c.y = param_2->y;
		local_c.z = param_2->z;
	}
	else {
		pCVar1 = lego::game::LiveObject_GetResource(liveObj);
		lego::res::Container_GetPosition(pCVar1,(Container *)0x0,&local_c);
	}
	ppCVar2 = (Container **)&DAT_004c8be8;
	do {
		if (*ppCVar2 == (Container *)0x0) {
			pCVar1 = lego::res::Container_Clone(lego::globals::g_Game.RES_SmashPath);
			*ppCVar2 = pCVar1;
			lego::res::Container_SetAnimationTime(pCVar1,0.0);
			lego::res::Container_SetPosition(*ppCVar2,(Container *)0x0,local_c.x,local_c.y,local_c.z);
			lego::res::Container_SetOrientation(*ppCVar2,(Container *)0x0,0.0,1.0,0.0,0.0,0.0,-1.0);
		}
		ppCVar2 = ppCVar2 + 1;
	} while (ppCVar2 < &lego::globals::g_MiscObjectResource_ShortElectricFenceBeam);
	return;
}



BOOL __cdecl lego::game::Game_GetRockFallStyle(char *param_1,uint *out_index)
{
	int iVar1;
	uint uVar2;
	char **ppcVar3;
	
	uVar2 = 0;
	if (globals::g_RockFallStyles_COUNT == 0) {
		return 0;
	}
	ppcVar3 = globals::g_RockFallStyles_TABLE;
	do {
		iVar1 = std::_stricmp(*ppcVar3,param_1);
		if (iVar1 == 0) {
			*out_index = uVar2;
			return 1;
		}
		uVar2 = uVar2 + 1;
		ppcVar3 = ppcVar3 + 1;
	} while (uVar2 < globals::g_RockFallStyles_COUNT);
	return 0;
}



void __cdecl lego::game::Game_SetRockFallStyleIndex(int rockFallStyleIndex)
{
	globals::g_RockFallStyleIndex = rockFallStyleIndex;
	return;
}



void __cdecl
lego::main::Boot_Load_RockFallStyles(CFGProperty *root,char *keyBasePath,Container *resData)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *prop;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	undefined4 *puVar8;
	char *local_428 [10];
	char local_400 [1024];
	
	pcVar2 = cfg::CFG_JoinPath(keyBasePath,"RockFallStyles",0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (prop == (CFGProperty *)0x0) {
			return;
		}
		pcVar2 = std::_strdup(prop->key);
		globals::g_RockFallStyles_TABLE[globals::g_RockFallStyles_COUNT] = pcVar2;
		uVar4 = 0xffffffff;
		pcVar2 = prop->value;
		do {
			pcVar7 = pcVar2;
			if (uVar4 == 0) break;
			uVar4 = uVar4 - 1;
			pcVar7 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar7;
		} while (cVar1 != '\0');
		uVar4 = ~uVar4;
		puVar6 = (undefined4 *)(pcVar7 + -uVar4);
		puVar8 = (undefined4 *)local_400;
		for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
			*puVar8 = *puVar6;
			puVar6 = puVar6 + 1;
			puVar8 = puVar8 + 1;
		}
		for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
			*(undefined *)puVar8 = *(undefined *)puVar6;
			puVar6 = (undefined4 *)((int)puVar6 + 1);
			puVar8 = (undefined4 *)((int)puVar8 + 1);
		}
		uVar4 = util::Util_Tokenise(local_400,local_428,",");
		uVar5 = 1;
		if (1 < uVar4) {
			uVar3 = 1;
			do {
				FUN_0040c000(resData,local_428[uVar3],globals::g_RockFallStyles_COUNT,uVar3 - 1,local_428[0]
										);
				uVar5 = uVar5 + 1;
				uVar3 = uVar5 & 0xffff;
			} while (uVar3 < uVar4);
		}
		globals::g_RockFallStyles_COUNT = globals::g_RockFallStyles_COUNT + 1;
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



BOOL __cdecl FUN_0040c000(Container *resData,char *param_2,int param_3,int param_4,char *param_5)
{
	int iVar1;
	Container **ppCVar2;
	char *pcVar3;
	Container *pCVar4;
	char *name;
	int iVar5;
	Container **ppCVar6;
	
	iVar1 = (param_4 + param_3 * 3) * 0xa4;
	ppCVar2 = (Container **)((int)lego::globals::g_MiscObjectDependencies_TABLE[0x13] + iVar1 + 0xb64)
	;
	pCVar4 = lego::res::Container_Load(resData,param_2,"LWS",1);
	*ppCVar2 = pCVar4;
	if (pCVar4 == (Container *)0x0) {
		pCVar4 = lego::res::Container_Load(resData,param_2,"ANIM",1);
		*ppCVar2 = pCVar4;
	}
	if (*ppCVar2 != (Container *)0x0) {
		lego::res::Container_Hide(*ppCVar2,1);
		ppCVar6 = (Container **)
							((int)lego::globals::g_MiscObjectDependencies_TABLE[0x13] + iVar1 + 0xb68);
		iVar5 = 4;
		do {
			pCVar4 = lego::res::Container_Clone(*ppCVar2);
			*ppCVar6 = pCVar4;
			ppCVar6[0xc] = (Container *)0x1;
			ppCVar6[0x24] = (Container *)0x0;
			lego::res::Container_Hide(*ppCVar6,1);
			pcVar3 = param_5;
			ppCVar6 = ppCVar6 + 1;
			iVar5 = iVar5 + -1;
		} while (iVar5 != 0);
		name = lego::res::Container_FormatPartName(*ppCVar2,param_5,(int *)0x0);
		lego::res::Container_SearchTree(*ppCVar2,name,CONTAINER_SEARCHMODE_MATCHCOUNT,&param_3);
		*(int *)(&DAT_004c8228 + iVar1) = param_3;
		*(char **)(&DAT_004c8224 + iVar1) = pcVar3;
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::main::Main_LoadMiscObjectResource_ElectricFenceBeam
					(Container *resRoot,char *filename,BOOL isLongBeam)
{
	Container *pCVar1;
	int iVar2;
	Container **ppCVar3;
	
	pCVar1 = res::Container_Load(resRoot,filename,"LWS",1);
	(&globals::g_MiscObjectResource_ShortElectricFenceBeam)[isLongBeam * 0x3d] = pCVar1;
	if (pCVar1 != (Container *)0x0) {
		res::Container_Hide(pCVar1,1);
		ppCVar3 = (Container **)(&DAT_004c8bfc + isLongBeam * 0x3d);
		iVar2 = 0x1e;
		do {
			pCVar1 = res::Container_Clone
												 ((&globals::g_MiscObjectResource_ShortElectricFenceBeam)[isLongBeam * 0x3d]
												 );
			*ppCVar3 = pCVar1;
			ppCVar3[0x1e] = (Container *)0x1;
			res::Container_Hide(*ppCVar3,1);
			ppCVar3 = ppCVar3 + 1;
			iVar2 = iVar2 + -1;
		} while (iVar2 != 0);
		return 1;
	}
	return 0;
}



BOOL __cdecl
FUN_0040c160(int param_1,undefined4 param_2,undefined4 param_3,float param_4,float param_5,
						float param_6,float param_7,float param_8)
{
	int iVar1;
	int *piVar2;
	uint uVar3;
	
	uVar3 = 0;
	iVar1 = (param_1 + lego::globals::g_RockFallStyleIndex * 3) * 0xa4;
	piVar2 = (int *)(&DAT_004c8214 + iVar1);
	do {
		if (*piVar2 != 0) break;
		uVar3 = uVar3 + 1;
		piVar2 = piVar2 + 1;
	} while (uVar3 < 4);
	if (uVar3 < 4) {
		lego::res::Container_Hide(*(Container **)(iVar1 + 0x4c81e4 + uVar3 * 4),0);
		lego::res::Container_SetAnimationTime(*(Container **)(iVar1 + 0x4c81e4 + uVar3 * 4),0.0);
		lego::res::Container_SetPosition
							(*(Container **)(iVar1 + 0x4c81e4 + uVar3 * 4),(Container *)0x0,param_4,param_5,
							 param_6);
		lego::res::Container_SetOrientation
							(*(Container **)(iVar1 + 0x4c81e4 + uVar3 * 4),(Container *)0x0,param_7,param_8,0.0,
							 0.0,0.0,-1.0);
		*(undefined4 *)(iVar1 + 0x4c81f4 + uVar3 * 4) = param_2;
		*(undefined4 *)(&DAT_004c8204 + uVar3 * 4 + iVar1) = param_3;
		*(undefined4 *)(&DAT_004c8214 + uVar3 * 4 + iVar1) = 0;
		return 1;
	}
	return 0;
}



undefined4 __cdecl
FUN_0040c220(int param_1,float param_2,float param_3,float param_4,float param_5,float param_6,
						float param_7)
{
	int *piVar1;
	uint uVar2;
	
	uVar2 = 0;
	piVar1 = &DAT_004c8c74 + param_1 * 0x3d;
	do {
		if (*piVar1 != 0) break;
		uVar2 = uVar2 + 1;
		piVar1 = piVar1 + 1;
	} while (uVar2 < 0x1e);
	if (uVar2 < 0x1e) {
		lego::res::Container_Hide((Container *)(&DAT_004c8bfc)[param_1 * 0x3d + uVar2],0);
		lego::res::Container_SetAnimationTime((Container *)(&DAT_004c8bfc)[param_1 * 0x3d + uVar2],0.0);
		lego::res::Container_SetPosition
							((Container *)(&DAT_004c8bfc)[param_1 * 0x3d + uVar2],(Container *)0x0,param_2,param_3
							 ,param_4);
		lego::res::Container_SetOrientation
							((Container *)(&DAT_004c8bfc)[param_1 * 0x3d + uVar2],(Container *)0x0,param_5,param_6
							 ,param_7,0.0,0.0,-1.0);
		(&DAT_004c8c74)[param_1 * 0x3d + uVar2] = 0;
		return 1;
	}
	return 0;
}



int __cdecl FUN_0040c2d0(float param_1,undefined4 *param_2,undefined4 *param_3)
{
	int iVar1;
	uint uVar2;
	int iVar3;
	int *piVar4;
	BlockObject **ppBVar5;
	uint uVar6;
	BlockObject **ppBVar7;
	float10 fVar8;
	
	iVar1 = 0;
	FUN_0040c760(param_1);
	FUN_0040c400(param_1);
	FUN_0040c450(param_1);
	FUN_0040cb70(param_1);
	uVar2 = 0;
	do {
		iVar3 = uVar2 + lego::globals::g_RockFallStyleIndex * 3;
		if (*(int *)((int)lego::globals::g_MiscObjectDependencies_TABLE[0x13] + iVar3 * 0xa4 + 0xb64) !=
				0) {
			uVar6 = 0;
			piVar4 = (int *)(&DAT_004c8214 + iVar3 * 0xa4);
			do {
				if (*piVar4 == 0) {
					fVar8 = lego::res::Container_MoveAnimation((Container *)piVar4[-0xc],param_1);
					if ((ushort)((ushort)(fVar8 < (float10)0.0) << 8 | (ushort)(fVar8 == (float10)0.0) << 0xe)
							== 0) {
						lego::res::Container_Hide((Container *)piVar4[-0xc],1);
						*piVar4 = 1;
						piVar4[0x18] = 0;
						lego::globals::g_MiscObjectDependencies_TABLE[0x13][0xe].levels_field_44[iVar1 + 2] =
								 uVar2;
						lego::globals::g_MiscObjectDependencies_TABLE[0x13][0xe].levels_field_44[iVar1 + 0xe] =
								 uVar6;
						iVar1 = iVar1 + 1;
					}
				}
				uVar6 = uVar6 + 1;
				piVar4 = piVar4 + 1;
			} while (uVar6 < 4);
		}
		uVar2 = uVar2 + 1;
	} while (uVar2 < 3);
	ppBVar7 = (BlockObject **)&DAT_004c8c74;
	*param_2 = 0x4c8180;
	*param_3 = 0x4c81b0;
	do {
		iVar3 = 0x1e;
		ppBVar5 = ppBVar7;
		do {
			if (*ppBVar5 == (BlockObject *)0x0) {
				fVar8 = lego::res::Container_MoveAnimation((Container *)ppBVar5[-0x1e],param_1);
				if ((ushort)((ushort)(fVar8 < (float10)0.0) << 8 | (ushort)(fVar8 == (float10)0.0) << 0xe)
						== 0) {
					lego::res::Container_Hide((Container *)ppBVar5[-0x1e],1);
					*ppBVar5 = (BlockObject *)0x1;
				}
			}
			ppBVar5 = ppBVar5 + 1;
			iVar3 = iVar3 + -1;
		} while (iVar3 != 0);
		ppBVar7 = ppBVar7 + 0x3d;
	} while (ppBVar7 < lego::pool::globals::ReservedPool_BlockObject___g_TABLE + 0x17);
	return iVar1;
}



void __cdecl FUN_0040c400(float param_1)
{
	Container **ppCVar1;
	float10 fVar2;
	
	ppCVar1 = PTR_ARRAY_004c8bd8;
	do {
		if (*ppCVar1 != (Container *)0x0) {
			fVar2 = lego::res::Container_MoveAnimation(*ppCVar1,param_1);
			if ((ushort)((ushort)(fVar2 < (float10)0.0) << 8 | (ushort)(fVar2 == (float10)0.0) << 0xe) ==
					0) {
				lego::res::Container_Remove(*ppCVar1);
				*ppCVar1 = (Container *)0x0;
			}
		}
		ppCVar1 = ppCVar1 + 1;
	} while (ppCVar1 < &DAT_004c8be8);
	return;
}



void __cdecl FUN_0040c450(float param_1)
{
	Container **ppCVar1;
	float10 fVar2;
	
	ppCVar1 = (Container **)&DAT_004c8be8;
	do {
		if (*ppCVar1 != (Container *)0x0) {
			fVar2 = lego::res::Container_MoveAnimation(*ppCVar1,param_1);
			if ((ushort)((ushort)(fVar2 < (float10)0.0) << 8 | (ushort)(fVar2 == (float10)0.0) << 0xe) ==
					0) {
				lego::res::Container_Remove(*ppCVar1);
				*ppCVar1 = (Container *)0x0;
			}
		}
		ppCVar1 = ppCVar1 + 1;
	} while (ppCVar1 < &lego::globals::g_MiscObjectResource_ShortElectricFenceBeam);
	return;
}



void __cdecl FUN_0040c4a0(int param_1,int param_2,int *out_x,int *out_y)
{
	int iVar1;
	
	iVar1 = (param_1 + lego::globals::g_RockFallStyleIndex * 3) * 0xa4;
	*out_x = *(int *)(iVar1 + 0x4c81f4 + param_2 * 4);
	*out_y = *(int *)(&DAT_004c8204 + param_2 * 4 + iVar1);
	return;
}



int ** __cdecl FUN_0040c4e0(int param_1,uint param_2)
{
	int *piVar1;
	char *name;
	Container *pCVar2;
	uint uVar3;
	uint uVar4;
	int *piVar5;
	
	uVar3 = 0;
	piVar5 = (int *)((int)lego::globals::g_MiscObjectDependencies_TABLE[0x13] +
									lego::globals::g_RockFallStyleIndex * 0x1ec + 0xb64);
	do {
		if (*piVar5 != 0) {
			uVar4 = 0;
			piVar1 = piVar5 + 5;
			do {
				if (((piVar1[8] == 0) && (param_1 == *piVar1)) && (param_2 == piVar1[4])) {
					param_2 = 0;
					if (piVar5[0x12] != 0) goto LAB_0040c546;
					goto LAB_0040c564;
				}
				uVar4 = uVar4 + 1;
				piVar1 = piVar1 + 1;
			} while (uVar4 < 4);
		}
		uVar3 = uVar3 + 1;
		piVar5 = piVar5 + 0x29;
		if (2 < uVar3) {
			return (int **)(Container *)0x0;
		}
	} while( true );
	while( true ) {
		param_2 = param_2 + 1;
		if ((uint)piVar5[0x12] <= param_2) break;
LAB_0040c546:
		if ((piVar5[uVar4 + 0x25] & 1 << ((byte)param_2 & 0x1f)) == 0) break;
	}
LAB_0040c564:
	if (param_2 != piVar5[0x12]) {
		piVar5[uVar4 + 0x25] = piVar5[uVar4 + 0x25] | 1 << ((byte)param_2 & 0x1f);
		name = lego::res::Container_FormatPartName
										 ((Container *)piVar5[uVar4 + 1],(char *)piVar5[0x11],(int *)&param_2);
		pCVar2 = lego::res::Container_SearchTree
											 ((Container *)piVar5[uVar4 + 1],name,CONTAINER_SEARCHMODE_FIRSTMATCH,
												(undefined4 *)0x0);
		return (int **)pCVar2;
	}
	return (int **)(Container *)0x0;
}



void __fastcall FUN_0040c5c0(void *param_1)
{
	Container **ppCVar1;
	
	ppCVar1 = PTR_ARRAY_004c8bd8;
	do {
		if (*ppCVar1 != (Container *)0x0) {
			lego::res::Container_Remove(*ppCVar1);
			*ppCVar1 = (Container *)0x0;
		}
		ppCVar1 = ppCVar1 + 1;
	} while (ppCVar1 < &DAT_004c8be8);
	return;
}



void __cdecl lego::main::Main_CleanupRockFallStyles(void)
{
	int iVar1;
	uint uVar2;
	Container **ppCVar3;
	int iVar4;
	
	uVar2 = 0;
	iVar1 = globals::g_RockFallStyleIndex;
	do {
		iVar4 = uVar2 + iVar1 * 3;
		if (*(int *)((int)globals::g_MiscObjectDependencies_TABLE[0x13] + iVar4 * 0xa4 + 0xb64) != 0) {
			ppCVar3 = (Container **)
								((int)globals::g_MiscObjectDependencies_TABLE[0x13] + iVar4 * 0xa4 + 0xb68);
			iVar4 = 4;
			do {
				res::Container_Remove(*ppCVar3);
				*ppCVar3 = (Container *)0x0;
				ppCVar3 = ppCVar3 + 1;
				iVar4 = iVar4 + -1;
				iVar1 = globals::g_RockFallStyleIndex;
			} while (iVar4 != 0);
		}
		uVar2 = uVar2 + 1;
	} while (uVar2 < 3);
	return;
}



void __cdecl lego::main::Main_LoadMiscObjectResource_Explosion(Container *resRoot,char *filename)
{
	globals::g_MiscObjectResource_Explosion = res::Container_Load(resRoot,filename,"LWS",1);
	res::Container_Hide(globals::g_MiscObjectResource_Explosion,1);
	return;
}



void __cdecl FUN_0040c680(LiveObject *liveObj,Point2F *param_2)
{
	SurfaceMap *surfMap;
	Container *pCVar1;
	float10 fVar2;
	float x;
	float y;
	float local_c;
	float local_8;
	float local_4;
	
	if (liveObj == (LiveObject *)0x0) {
		local_c = param_2->x;
		local_8 = param_2->y;
	}
	else {
		lego::game::LiveObject_GetPosition(liveObj,&local_c,&local_8);
	}
	x = local_c;
	y = local_8;
	surfMap = lego::game::GetSurfaceMap();
	fVar2 = lego::game::SurfaceMap_GetSurfaceZ(surfMap,x,y);
	local_4 = (float)(fVar2 - (float10)1.0);
	if ((uint)INT_004c8df4 < 4) {
		pCVar1 = lego::res::Container_Clone(lego::globals::g_MiscObjectResource_Explosion);
		(&DAT_004c8de4)[INT_004c8df4] = pCVar1;
		pCVar1 = (Container *)(&DAT_004c8de4)[INT_004c8df4];
		INT_004c8df4 = INT_004c8df4 + 1;
		lego::res::Container_Hide(pCVar1,0);
		lego::res::Container_SetPosition(pCVar1,(Container *)0x0,local_c,local_8,local_4);
		lego::res::Container_SetOrientation(pCVar1,(Container *)0x0,0.0,1.0,0.0,0.0,0.0,-1.0);
		lego::res::Container_SetAnimationTime(pCVar1,0.0);
	}
	return;
}



void __cdecl FUN_0040c760(float param_1)
{
	Container *cont;
	int iVar1;
	Container **ppCVar2;
	Container **ppCVar3;
	float10 fVar4;
	
	iVar1 = 0;
	if (0 < INT_004c8df4) {
		ppCVar2 = (Container **)&DAT_004c8de4;
		do {
			cont = *ppCVar2;
			fVar4 = lego::res::Container_MoveAnimation(cont,param_1);
			ppCVar3 = ppCVar2;
			if (fVar4 != (float10)0.0) {
				lego::res::Container_Remove(cont);
				INT_004c8df4 = INT_004c8df4 + -1;
				iVar1 = iVar1 + -1;
				ppCVar3 = ppCVar2 + -1;
				*ppCVar2 = (Container *)(&DAT_004c8de4)[INT_004c8df4];
			}
			iVar1 = iVar1 + 1;
			ppCVar2 = ppCVar3 + 1;
		} while (iVar1 < INT_004c8df4);
	}
	return;
}



undefined * __cdecl FUN_0040c7d0(undefined4 param_1)
{
	switch(param_1) {
	case 0:
		return (undefined *)&lego::globals::g_MiscObject_LazerHit;
	case 1:
		return (undefined *)&lego::globals::g_MiscObject_PusherHit;
	case 2:
		return (undefined *)&lego::globals::g_MiscObject_FreezerHit;
	case 3:
		return (undefined *)&lego::globals::g_MiscObject_PathDust;
	case 4:
		return (undefined *)&lego::globals::g_MiscObject_LavaErosionSmoke1;
	case 5:
		return (undefined *)&lego::globals::g_MiscObject_LavaErosionSmoke2;
	case 6:
		return (undefined *)&lego::globals::g_MiscObject_LavaErosionSmoke3;
	case 7:
		return (undefined *)&lego::globals::g_MiscObject_LavaErosionSmoke4;
	case 8:
		return (undefined *)&lego::globals::g_MiscObject_BirdScarer;
	case 9:
		return (undefined *)&lego::globals::g_MiscObject_UpgradeEffect;
	default:
		return (undefined *)(MiscObjectData *)0x0;
	}
}



BOOL __cdecl
lego::res::Res_LoadMiscObject(MiscObjectData *miscObjData,Container *resRoot,char *filename)
{
	Container *pCVar1;
	
	if (filename == (char *)0x0) {
		return 0;
	}
	pCVar1 = Container_Load(resRoot,filename,"LWS",1);
	miscObjData->resData = pCVar1;
	if (pCVar1 == (Container *)0x0) {
		pCVar1 = Container_Load(resRoot,filename,"LWO",1);
		miscObjData->resData = pCVar1;
		if (pCVar1 == (Container *)0x0) {
			return 0;
		}
	}
	Container_Hide(miscObjData->resData,1);
	return 1;
}



void __cdecl lego::res::Res_LoadMiscObjects(CFGProperty *root,char *keyRoot,Container *resRoot)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(keyRoot,"MiscObjects","LazerHit",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Res_LoadMiscObject(&globals::g_MiscObject_LazerHit,resRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(keyRoot,"MiscObjects","PusherHit",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Res_LoadMiscObject(&globals::g_MiscObject_PusherHit,resRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(keyRoot,"MiscObjects","FreezerHit",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Res_LoadMiscObject(&globals::g_MiscObject_FreezerHit,resRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(keyRoot,"MiscObjects","PathDust",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Res_LoadMiscObject(&globals::g_MiscObject_PathDust,resRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(keyRoot,"MiscObjects","LavaErosionSmoke1",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Res_LoadMiscObject(&globals::g_MiscObject_LavaErosionSmoke1,resRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(keyRoot,"MiscObjects","LavaErosionSmoke2",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Res_LoadMiscObject(&globals::g_MiscObject_LavaErosionSmoke2,resRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(keyRoot,"MiscObjects","LavaErosionSmoke3",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Res_LoadMiscObject(&globals::g_MiscObject_LavaErosionSmoke3,resRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(keyRoot,"MiscObjects","LavaErosionSmoke4",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Res_LoadMiscObject(&globals::g_MiscObject_LavaErosionSmoke4,resRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(keyRoot,"MiscObjects","BirdScarer",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Res_LoadMiscObject(&globals::g_MiscObject_BirdScarer,resRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(keyRoot,"MiscObjects","UpgradeEffect",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Res_LoadMiscObject(&globals::g_MiscObject_UpgradeEffect,resRoot,pcVar1);
	return;
}



void __cdecl FUN_0040caa0(int **param_1,float param_2)
{
	Container *cont;
	int *piVar1;
	Container **ppCVar2;
	int *piVar3;
	float10 fVar4;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	piVar3 = (int *)0x0;
	ppCVar2 = (Container **)param_1;
	if (param_1[10] != (int *)0x0) {
		do {
			cont = *ppCVar2;
			if (((MiscObjectData *)param_1 == &lego::globals::g_MiscObject_BirdScarer) &&
				 (lego::globals::g_MiscObject_BirdScarer._44_4_ =
							 param_2 + lego::globals::g_MiscObject_BirdScarer._44_4_,
				 (ushort)((ushort)(lego::globals::g_MiscObject_BirdScarer._44_4_ < 12.5) << 8 |
								 (ushort)(lego::globals::g_MiscObject_BirdScarer._44_4_ == 12.5) << 0xe) == 0)) {
				lego::res::Container_GetPosition(cont,(Container *)0x0,&local_c);
				local_14 = local_c.x;
				local_10 = local_c.y;
				FUN_00440b80((undefined4 *)0x0,&local_14,lego::globals::g_Game.BirdScarerRadius);
				lego::globals::g_MiscObject_BirdScarer._44_4_ = 0.0;
			}
			fVar4 = lego::res::Container_MoveAnimation(cont,param_2);
			if (fVar4 != (float10)0.0) {
				lego::res::Container_Remove(cont);
				piVar1 = (int *)((int)param_1[10] - 1);
				param_1[10] = piVar1;
				if (piVar3 == piVar1) {
					*ppCVar2 = (Container *)0x0;
				}
				else {
					*ppCVar2 = (Container *)param_1[(int)piVar1];
				}
				piVar3 = (int *)((int)piVar3 - 1);
				ppCVar2 = ppCVar2 + -1;
			}
			piVar3 = (int *)((int)piVar3 + 1);
			ppCVar2 = ppCVar2 + 1;
		} while (piVar3 < param_1[10]);
	}
	return;
}



void __cdecl FUN_0040cb70(float param_1)
{
	FUN_0040caa0((int **)&lego::globals::g_MiscObject_LazerHit,param_1);
	FUN_0040caa0((int **)&lego::globals::g_MiscObject_PusherHit,param_1);
	FUN_0040caa0((int **)&lego::globals::g_MiscObject_FreezerHit,param_1);
	FUN_0040caa0((int **)&lego::globals::g_MiscObject_PathDust,param_1);
	FUN_0040caa0((int **)&lego::globals::g_MiscObject_LavaErosionSmoke1,param_1);
	FUN_0040caa0((int **)&lego::globals::g_MiscObject_LavaErosionSmoke2,param_1);
	FUN_0040caa0((int **)&lego::globals::g_MiscObject_LavaErosionSmoke3,param_1);
	FUN_0040caa0((int **)&lego::globals::g_MiscObject_LavaErosionSmoke4,param_1);
	FUN_0040caa0((int **)&lego::globals::g_MiscObject_BirdScarer,param_1);
	FUN_0040caa0((int **)&lego::globals::g_MiscObject_UpgradeEffect,param_1);
	return;
}



undefined4 __cdecl FUN_0040cc10(undefined4 param_1,undefined4 *param_2,undefined4 *param_3)
{
	undefined *puVar1;
	Container *pCVar2;
	float dirx;
	float diry;
	float dirz;
	
	puVar1 = FUN_0040c7d0(param_1);
	if (((*(uint *)(puVar1 + 0x28) < 10) && (puVar1 != (undefined *)0x0)) &&
		 (*(Container **)(puVar1 + 0x30) != (Container *)0x0)) {
		*(undefined4 *)(puVar1 + 0x2c) = 0;
		pCVar2 = lego::res::Container_Clone(*(Container **)(puVar1 + 0x30));
		*(Container **)(puVar1 + *(int *)(puVar1 + 0x28) * 4) = pCVar2;
		lego::res::Container_SetAnimationTime(*(Container **)(puVar1 + *(int *)(puVar1 + 0x28) * 4),0.0)
		;
		lego::res::Container_SetPosition
							(*(Container **)(puVar1 + *(int *)(puVar1 + 0x28) * 4),(Container *)0x0,
							 (float)*param_2,(float)param_2[1],(float)param_2[2]);
		if (param_3 == (undefined4 *)0x0) {
			dirz = 0.0;
			diry = 1.0;
			dirx = 0.0;
			pCVar2 = *(Container **)(puVar1 + *(int *)(puVar1 + 0x28) * 4);
		}
		else {
			dirz = (float)param_3[2];
			diry = (float)param_3[1];
			dirx = (float)*param_3;
			pCVar2 = *(Container **)(puVar1 + *(int *)(puVar1 + 0x28) * 4);
		}
		lego::res::Container_SetOrientation(pCVar2,(Container *)0x0,dirx,diry,dirz,0.0,0.0,-1.0);
		*(int *)(puVar1 + 0x28) = *(int *)(puVar1 + 0x28) + 1;
		return 1;
	}
	return 0;
}



void __cdecl lego::pool::ReservedPool_BlockObject___Init(LevelData *level)
{
	uint uVar1;
	int iVar2;
	BlockObject *pBVar3;
	BlockObject **ppBVar4;
	
	PTR_004c8df8 = (BlockObject *)
								 std::malloc((level->dimensions).width * (level->dimensions).height * 0x14);
	if (PTR_004c8df8 != (BlockObject *)0x0) {
		pBVar3 = PTR_004c8df8;
		for (uVar1 = (level->dimensions).width * (level->dimensions).height * 5 & 0x3fffffff; uVar1 != 0
				; uVar1 = uVar1 - 1) {
			pBVar3->attachedObject = (LiveObject *)0x0;
			pBVar3 = (BlockObject *)&pBVar3->position;
		}
		for (iVar2 = 0; iVar2 != 0; iVar2 = iVar2 + -1) {
			*(undefined *)&pBVar3->attachedObject = 0;
			pBVar3 = (BlockObject *)((int)&pBVar3->attachedObject + 1);
		}
	}
	lego::globals::g_Level = level;
	ppBVar4 = globals::ReservedPool_BlockObject___g_TABLE;
	for (iVar2 = 0x20; iVar2 != 0; iVar2 = iVar2 + -1) {
		*ppBVar4 = (BlockObject *)0x0;
		ppBVar4 = ppBVar4 + 1;
	}
	globals::ReservedPool_BlockObject___g_NEXT = (BlockObject *)0x0;
	globals::ReservedPool_BlockObject___g_COUNT = 0;
	return;
}



void __cdecl lego::pool::ReservedPool_BlockObject___Cleanup(void)
{
	BlockObject **ppBVar1;
	
	ppBVar1 = globals::ReservedPool_BlockObject___g_TABLE;
	do {
		if (*ppBVar1 != (BlockObject *)0x0) {
			std::free(*ppBVar1);
		}
		ppBVar1 = ppBVar1 + 1;
	} while (ppBVar1 < &globals::ReservedPool_BlockObject___g_NEXT);
	globals::ReservedPool_BlockObject___g_NEXT = (BlockObject *)0x0;
	if (PTR_004c8df8 != (BlockObject *)0x0) {
		std::free(PTR_004c8df8);
		PTR_004c8df8 = (BlockObject *)0x0;
	}
	return;
}



void __cdecl lego::pool::ReservedPool_BlockObject___Reset(LevelData *level)
{
	ReservedPool_BlockObject___Cleanup();
	ReservedPool_BlockObject___Init(level);
	return;
}



void __cdecl FUN_0040cdd0(int x,int y)
{
	int iVar1;
	int iVar2;
	int iVar3;
	BOOL BVar4;
	int *piVar5;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	iVar3 = y;
	local_20[1] = 1;
	local_20[2] = 1;
	local_20[3] = 0;
	local_20[4] = 0;
	local_4 = 0;
	local_c = 0xffffffff;
	local_8 = 0xffffffff;
	lego::game::Level_UpdateBlockSurfaceUnk(lego::globals::g_Level,x,y);
	piVar5 = local_20 + 1;
	y = 4;
	do {
		iVar1 = piVar5[-1];
		iVar2 = *piVar5;
		BVar4 = lego::game::SurfaceMap_IsInsideDimensions
											(lego::globals::g_Level->surfaceMap,iVar1 + x,iVar3 + iVar2);
		if (BVar4 != 0) {
			lego::game::Level_UpdateBlockSurfaceUnk(lego::globals::g_Level,iVar1 + x,iVar3 + iVar2);
		}
		piVar5 = piVar5 + 2;
		y = y + -1;
	} while (y != 0);
	return;
}



void __cdecl lego::game::LiveObject_AssignBlockObject(LiveObject *liveObj)
{
	LiveObject *liveObj_00;
	int local_4;
	
	liveObj_00 = liveObj;
	LiveObject_GetBlockCoordinates(liveObj,&local_4,(int *)&liveObj);
	pool::ReservedPool_BlockObject___Next(liveObj_00,local_4,(int)liveObj);
	return;
}



BlockObject * __cdecl lego::pool::ReservedPool_BlockObject___Next(LiveObject *liveObj,int x,int y)
{
	LiveObject **ppLVar1;
	BlockObject *pBVar2;
	
	if (globals::ReservedPool_BlockObject___g_NEXT == (BlockObject *)0x0) {
		ReservedPool_BlockObject___Alloc();
	}
	pBVar2 = globals::ReservedPool_BlockObject___g_NEXT;
	ppLVar1 = &globals::ReservedPool_BlockObject___g_NEXT->attachedObject;
	globals::ReservedPool_BlockObject___g_NEXT =
			 globals::ReservedPool_BlockObject___g_NEXT->pool_m_next;
	*ppLVar1 = (LiveObject *)0x0;
	(pBVar2->position).x = 0;
	(pBVar2->position).y = 0;
	pBVar2->field_c = 0;
	pBVar2->pool_m_next = (BlockObject *)0x0;
	pBVar2->pool_m_next = pBVar2;
	pBVar2->attachedObject = liveObj;
	(pBVar2->position).x = x;
	(pBVar2->position).y = y;
	*(undefined4 *)
	 ((int)&PTR_004c8df8->position + ((lego::globals::g_Level->dimensions).width * y + x) * 0xc + 4) =
			 0;
	(&PTR_004c8df8->attachedObject)[((lego::globals::g_Level->dimensions).width * y + x) * 3] =
			 (LiveObject *)pBVar2;
	liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_2000000;
	FUN_0040cdd0(x,y);
	return pBVar2;
}



void __cdecl lego::pool::ReservedPool_BlockObject___Alloc(void)
{
	BlockObject *pBVar1;
	BlockObject *pBVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globals::ReservedPool_BlockObject___g_COUNT & 0x1f);
	pBVar2 = (BlockObject *)std::malloc(uVar4 * 0x14);
	globals::ReservedPool_BlockObject___g_TABLE[globals::ReservedPool_BlockObject___g_COUNT] = pBVar2;
	pBVar2 = globals::ReservedPool_BlockObject___g_TABLE[globals::ReservedPool_BlockObject___g_COUNT];
	if (pBVar2 != (BlockObject *)0x0) {
		globals::ReservedPool_BlockObject___g_COUNT = globals::ReservedPool_BlockObject___g_COUNT + 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pBVar1 = pBVar2;
			do {
				pBVar1->pool_m_next = pBVar1 + 1;
				iVar3 = iVar3 + -1;
				pBVar1 = pBVar1 + 1;
			} while (iVar3 != 0);
		}
		pBVar2[uVar4 - 1].pool_m_next = globals::ReservedPool_BlockObject___g_NEXT;
		globals::ReservedPool_BlockObject___g_NEXT = pBVar2;
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_0040cfd0(LiveObject *liveObj)
{
	int local_4;
	
	if ((liveObj->flags2 & LIVEOBJ2_UNK_2000000) != LIVEOBJ2_NONE) {
		LiveObject_GetBlockCoordinates(liveObj,&local_4,(int *)&liveObj);
		if ((&PTR_004c8df8->attachedObject)
				[((globals::g_Level->dimensions).width * (int)liveObj + local_4) * 3] != (LiveObject *)0x0)
		{
			pool::ReservedPool_BlockObject___Release
								((BlockObject *)
								 (&PTR_004c8df8->attachedObject)
								 [((globals::g_Level->dimensions).width * (int)liveObj + local_4) * 3],local_4,
								 (int)liveObj);
		}
	}
	return;
}



void __cdecl lego::pool::ReservedPool_BlockObject___Release(BlockObject *block,int x,int y)
{
	block->pool_m_next = globals::ReservedPool_BlockObject___g_NEXT;
	globals::ReservedPool_BlockObject___g_NEXT = block;
	*(undefined4 *)
	 ((int)&PTR_004c8df8->position + ((lego::globals::g_Level->dimensions).width * y + x) * 0xc + 4) =
			 0;
	(&PTR_004c8df8->attachedObject)[((lego::globals::g_Level->dimensions).width * y + x) * 3] =
			 (LiveObject *)0x0;
	FUN_0040cdd0(x,y);
	return;
}



BOOL __cdecl FUN_0040d0a0(int x,int y)
{
	int iVar1;
	LiveObject *liveObj;
	Point2F local_8;
	
	iVar1 = FUN_0040d170(x,y);
	if (iVar1 != 0) {
		lego::game::SurfaceMap_FUN_0044f900
							(lego::globals::g_Level->surfaceMap,x,y,(float *)&local_8,&local_8.y);
		liveObj = lego::game::Game_CreateLiveResourceObject
												(lego::globals::g_Game.RES_ElectricFence,OBJECT_ELECTRICFENCE,0,0,local_8.x,
												 local_8.y,0.0);
		lego::pool::ReservedPool_BlockObject___Next(liveObj,x,y);
		return 1;
	}
	return 0;
}



undefined4 __cdecl FUN_0040d120(int param_1,int param_2)
{
	LiveObject *liveObj;
	
	if ((&PTR_004c8df8->attachedObject)
			[((lego::globals::g_Level->dimensions).width * param_2 + param_1) * 3] != (LiveObject *)0x0) {
		liveObj = (LiveObject *)
							(&PTR_004c8df8->attachedObject)
							[((lego::globals::g_Level->dimensions).width * param_2 + param_1) * 3]->objType;
		lego::game::LiveObject_FUN_0040cfd0(liveObj);
		lego::pool::ReservedPool_LiveObject___Release(liveObj);
		return 1;
	}
	return 0;
}



undefined4 __cdecl FUN_0040d170(int param_1,int param_2)
{
	TerrainType TVar1;
	int iVar2;
	BOOL BVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	int local_40 [16];
	
	local_40[9] = 2;
	local_40[10] = 2;
	local_40[13] = 0xfffffffe;
	local_40[14] = 0xfffffffe;
	local_40[1] = 1;
	local_40[2] = 1;
	local_40[5] = 0xffffffff;
	local_40[6] = 0xffffffff;
	iVar2 = (lego::globals::g_Level->dimensions).width * param_2 + param_1;
	local_40[8] = 0;
	local_40[11] = 0;
	local_40[12] = 0;
	local_40[15] = 0;
	local_40[0] = 0;
	local_40[3] = 0;
	local_40[4] = 0;
	local_40[7] = 0;
	if (((((*(byte *)&lego::globals::g_Level->blocks[iVar2].flags1 & 8) == 0) ||
			 (TVar1 = lego::globals::g_Level->blocks[iVar2].terrain, TVar1 == TERRAIN_LAVA)) ||
			(TVar1 == TERRAIN_WATER_unused)) ||
		 (((&PTR_004c8df8->attachedObject)[iVar2 * 3] != (LiveObject *)0x0 ||
			(BVar3 = lego::game::Level_FUN_0040d320(lego::globals::g_Level,param_1,param_2,0), BVar3 != 0)
			))) {
		return 0;
	}
	uVar4 = 0;
	do {
		uVar5 = *(int *)((int)local_40 + uVar4) + param_1;
		uVar6 = param_2 + *(int *)((int)local_40 + uVar4 + 4);
		BVar3 = lego::game::SurfaceMap_IsInsideDimensions
											(lego::globals::g_Level->surfaceMap,uVar5,uVar6);
		if ((BVar3 != 0) &&
			 (((&PTR_004c8df8->attachedObject)
				 [((lego::globals::g_Level->dimensions).width * uVar6 + uVar5) * 3] != (LiveObject *)0x0 ||
				(BVar3 = lego::game::Level_FUN_0040d320(lego::globals::g_Level,uVar5,uVar6,0), BVar3 != 0)))
			 ) {
			return 1;
		}
		uVar5 = *(int *)((int)local_40 + uVar4 + 0x20) + param_1;
		uVar6 = *(int *)((int)local_40 + uVar4 + 0x24) + param_2;
		BVar3 = lego::game::SurfaceMap_IsInsideDimensions
											(lego::globals::g_Level->surfaceMap,uVar5,uVar6);
		if (BVar3 != 0) {
			if ((&PTR_004c8df8->attachedObject)
					[((lego::globals::g_Level->dimensions).width * uVar6 + uVar5) * 3] != (LiveObject *)0x0) {
				return 1;
			}
			BVar3 = lego::game::Level_FUN_0040d320(lego::globals::g_Level,uVar5,uVar6,0);
			if (BVar3 != 0) {
				return 1;
			}
		}
		uVar4 = uVar4 + 8;
		if (0x1f < uVar4) {
			return 0;
		}
	} while( true );
}



BOOL __cdecl lego::game::Level_FUN_0040d320(LevelData *level,int bx,int by,BOOL param_4)
{
	BOOL BVar1;
	Point2I blockPos;
	
	blockPos.x = bx;
	blockPos.y = by;
	BVar1 = Level_BlockCheck_FUN_004329d0(bx,by,TRUE);
	if (BVar1 != 0) {
		if (param_4 == 0) {
			return 1;
		}
		BVar1 = Level_BlockHasFlag2_100(&blockPos);
		if (BVar1 != 0) {
			return 1;
		}
	}
	return 0;
}



void __cdecl FUN_0040d380(float elapsed)
{
	FUN_0040d3c0(&LAB_0040d6a0,&elapsed);
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
						((LiveObjectPredicate *)&LAB_0040d650,(LiveObject *)0x0);
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_0040d510,(LiveObject *)&elapsed);
	return;
}



void __cdecl FUN_0040d3c0(undefined *param_1,undefined4 param_2)
{
	int iVar1;
	int iVar2;
	BlockObject **ppBVar3;
	uint uVar4;
	int iVar5;
	
	uVar4 = 0;
	if (lego::pool::globals::ReservedPool_BlockObject___g_COUNT != 0) {
		ppBVar3 = lego::pool::globals::ReservedPool_BlockObject___g_TABLE;
		do {
			if ((*ppBVar3 != (BlockObject *)0x0) && (iVar1 = 1 << ((byte)uVar4 & 0x1f), iVar1 != 0)) {
				iVar5 = 0;
				do {
					iVar2 = (int)&(*ppBVar3)->attachedObject + iVar5;
					if ((iVar2 != 0) && (*(int *)(iVar2 + 0x10) == iVar2)) {
						(*(code *)param_1)(iVar2,param_2);
					}
					iVar5 = iVar5 + 0x14;
					iVar1 = iVar1 + -1;
				} while (iVar1 != 0);
			}
			uVar4 = uVar4 + 1;
			ppBVar3 = ppBVar3 + 1;
		} while (uVar4 < lego::pool::globals::ReservedPool_BlockObject___g_COUNT);
	}
	return;
}



undefined4 __cdecl FUN_0040d420(undefined4 *param_1,uint param_2,uint param_3)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	float local_8;
	float local_4;
	
	FUN_0040d3c0(&LAB_0040d6a0,0);
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
						((LiveObjectPredicate *)&LAB_0040d650,(LiveObject *)0x0);
	if (param_1 == (undefined4 *)0x0) {
		if (((&PTR_004c8df8->attachedObject)
				 [((lego::globals::g_Level->dimensions).width * param_3 + param_2) * 3] == (LiveObject *)0x0
				) && (BVar2 = lego::game::Level_FUN_0040d320(lego::globals::g_Level,param_2,param_3,0),
						 BVar2 == 0)) {
			return 0;
		}
	}
	else {
		lego::game::LiveObject_GetPosition((LiveObject *)param_1,&local_8,&local_4);
		lego::game::SurfaceMap_ToBlockCoordinatesNoZ
							(lego::globals::g_Level->surfaceMap,local_8,local_4,(int *)&param_2,(int *)&param_3);
		OVar1 = lego::game::LiveObject_GetStatsFlags2((LiveObject *)param_1);
		if (((OVar1 & STATS2_SELFPOWERED) == STATS2_NONE) && ((param_1[0xfa] & 0x20000000) == 0)) {
			return 0;
		}
	}
	FUN_0040d780(param_2,param_3,1,0.0);
	return 1;
}



undefined4 __cdecl FUN_0040d510(LiveObject *param_1,float *param_2)
{
	float fVar1;
	BOOL BVar2;
	Point2I *pPVar3;
	Point2I *pPVar4;
	float *pfVar5;
	Point2I *pPVar6;
	Direction rotation;
	float *pfVar7;
	Point2F local_10;
	Point2I local_8;
	
	fVar1 = *param_2;
	if (param_1->objType == OBJECT_BUILDING) {
		lego::game::LiveObject_GetBlockCoordinates(param_1,(int *)&local_8,&local_8.y);
		BVar2 = lego::game::Level_FUN_0040d320(lego::globals::g_Level,local_8.x,local_8.y,1);
		if (BVar2 != 0) {
			lego::game::LiveObject_GetFaceDirection(param_1,&local_10);
			if (ABS(local_10.x) <= ABS(local_10.y)) {
				if ((ushort)((ushort)(local_10.y < 0.0) << 8 | (ushort)(local_10.y == 0.0) << 0xe) == 0) {
					rotation = DIRECTION_UP;
				}
				else {
					rotation = DIRECTION_DOWN;
				}
			}
			else {
				if ((ushort)((ushort)(local_10.x < 0.0) << 8 | (ushort)(local_10.x == 0.0) << 0xe) == 0) {
					rotation = DIRECTION_RIGHT;
				}
				else {
					rotation = DIRECTION_LEFT;
				}
			}
			pPVar3 = lego::res::Building_GetShapePoints(param_1->building,(uint *)&param_2);
			pPVar4 = lego::game::Game_TransformShapePoints(&local_8,pPVar3,(int)param_2,rotation);
			pfVar7 = (float *)0x0;
			pfVar5 = param_2;
			pPVar3 = pPVar4;
			if (param_2 != (float *)0x0) {
				do {
					pPVar6 = pPVar3 + 1;
					if (((pfVar7 == (float *)((int)pfVar5 - 1U)) || (pPVar4->x != pPVar6->x)) ||
						 (pPVar4->y != pPVar3[1].y)) {
						FUN_0040d780(pPVar4->x,pPVar4->y,0,fVar1);
						pfVar5 = param_2;
					}
					else {
						pfVar7 = (float *)((int)pfVar7 + 1);
						pPVar6 = pPVar3 + 2;
						pPVar4 = pPVar4 + 1;
					}
					pfVar7 = (float *)((int)pfVar7 + 1);
					pPVar4 = pPVar4 + 1;
					pPVar3 = pPVar6;
				} while (pfVar7 < pfVar5);
			}
		}
	}
	return 0;
}



void __cdecl FUN_0040d780(uint param_1,uint param_2,int param_3,float param_4)
{
	uint sx;
	uint sy;
	uint *puVar1;
	VehicleData *pVVar2;
	bool bVar3;
	short sVar4;
	BOOL BVar5;
	int iVar6;
	int iVar7;
	uint sx_00;
	uint sy_00;
	ulonglong uVar8;
	uint local_5c;
	float local_58;
	int *local_54;
	int local_50;
	uint local_48;
	uint local_44;
	int local_40;
	int local_3c [4];
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	int local_20 [4];
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_20[1] = 2;
	local_20[2] = 2;
	local_c = 0xfffffffe;
	local_8 = 0xfffffffe;
	local_3c[0] = 1;
	local_3c[1] = 1;
	local_2c = 0xffffffff;
	local_28 = 0xffffffff;
	local_20[0] = 0;
	local_20[3] = 0;
	local_10 = 0;
	local_4 = 0;
	local_40 = 0;
	local_3c[2] = 0;
	puVar1 = (uint *)((int)&PTR_004c8df8->position +
									 ((lego::globals::g_Level->dimensions).width * param_2 + param_1) * 0xc + 4);
	local_3c[3] = 0;
	local_24 = 0;
	local_5c = 0;
	*puVar1 = *puVar1 | 0x100;
	local_54 = &local_40;
	do {
		bVar3 = false;
		iVar6 = *local_54;
		sx = param_1 + iVar6;
		sy = local_3c[local_5c * 2] + param_2;
		BVar5 = lego::game::SurfaceMap_IsInsideDimensions(lego::globals::g_Level->surfaceMap,sx,sy);
		if ((BVar5 != 0) &&
			 (((&PTR_004c8df8->attachedObject)[((lego::globals::g_Level->dimensions).width * sy + sx) * 3]
				 != (LiveObject *)0x0 ||
				((BVar5 = lego::game::Level_FUN_0040d320(lego::globals::g_Level,sx,sy,1), BVar5 != 0 &&
				 (BVar5 = lego::game::Level_FUN_0040d320(lego::globals::g_Level,param_1,param_2,0),
				 BVar5 == 0)))))) {
			bVar3 = true;
			local_50 = 1;
			local_48 = sx;
			local_44 = sy;
		}
		if (bVar3) {
LAB_0040d9a4:
			if (local_50 == 0) {
				iVar6 = (lego::globals::g_Level->dimensions).width * sy + param_1 + iVar6;
				*(uint *)((int)&PTR_004c8df8->position + iVar6 * 0xc + 4) =
						 *(uint *)((int)&PTR_004c8df8->position + iVar6 * 0xc + 4) | 0x100;
			}
			iVar6 = (lego::globals::g_Level->dimensions).width;
			iVar7 = local_44 * iVar6 + local_48;
			if (((&PTR_004c8df8->attachedObject)[iVar7 * 3] == (LiveObject *)0x0) ||
				 (pVVar2 = (&PTR_004c8df8->attachedObject)[iVar7 * 3]->vehicle,
				 (ushort)((ushort)((float)pVVar2 < 0.0) << 8 | (ushort)((float)pVVar2 == 0.0) << 0xe) != 0))
			{
				if ((*(uint *)((int)&PTR_004c8df8->position + iVar7 * 0xc + 4) &
						1 << ((byte)local_5c & 0x1f)) == 0) {
					puVar1 = (uint *)((int)&PTR_004c8df8->position + (param_2 * iVar6 + param_1) * 0xc + 4);
					*puVar1 = *puVar1 | 1 << ((byte)local_5c - 2 & 3);
					local_58 = param_4;
					if ((ushort)((ushort)(param_4 < 200.0) << 8 | (ushort)(param_4 == 200.0) << 0xe) == 0) {
						local_58 = 200.0;
					}
					if (param_3 == 0) {
						if (local_58 != 0.0) {
							sVar4 = lego::math::Maths_Rand();
							uVar8 = __ftol((float10)200.0 / (float10)local_58);
							if ((int)((ulonglong)(uint)(int)sVar4 % (uVar8 & 0xffffffff)) == 0) goto LAB_0040dab9;
						}
					}
					else {
LAB_0040dab9:
						FUN_0040db50(param_1,param_2,local_48,local_44);
					}
				}
				BVar5 = lego::game::Level_FUN_0040d320(lego::globals::g_Level,local_48,local_44,0);
				if ((BVar5 == 0) &&
					 ((*(uint *)((int)&PTR_004c8df8->position +
											((lego::globals::g_Level->dimensions).width * local_44 + local_48) * 0xc + 4)
						& 0x100) == 0)) {
					FUN_0040d780(local_48,local_44,param_3,param_4);
				}
			}
		}
		else {
			sy_00 = param_2 + local_20[local_5c * 2 + 1];
			sx_00 = local_20[local_5c * 2] + param_1;
			BVar5 = lego::game::SurfaceMap_IsInsideDimensions
												(lego::globals::g_Level->surfaceMap,sx_00,sy_00);
			if (((BVar5 != 0) &&
					((BVar5 = lego::game::Level_FUN_0040d320(lego::globals::g_Level,sx,sy,0), BVar5 == 0 ||
					 (BVar5 = lego::game::Level_FUN_0040d320(lego::globals::g_Level,param_1,param_2,0),
					 BVar5 == 0)))) &&
				 (((&PTR_004c8df8->attachedObject)
					 [((lego::globals::g_Level->dimensions).width * sy_00 + sx_00) * 3] != (LiveObject *)0x0
					|| ((BVar5 = lego::game::Level_FUN_0040d320(lego::globals::g_Level,sx_00,sy_00,1),
							BVar5 != 0 &&
							(BVar5 = lego::game::Level_FUN_0040d320(lego::globals::g_Level,param_1,param_2,0),
							BVar5 == 0)))))) {
				bVar3 = true;
				local_50 = 0;
				local_48 = sx_00;
				local_44 = sy_00;
			}
			if (bVar3) goto LAB_0040d9a4;
		}
		local_5c = local_5c + 1;
		local_54 = local_54 + 2;
		if (3 < local_5c) {
			return;
		}
	} while( true );
}



undefined4 __cdecl FUN_0040db50(uint param_1,uint param_2,uint param_3,uint param_4)
{
	bool bVar1;
	uint uVar2;
	uint uVar3;
	float10 fVar4;
	float local_58;
	float local_54;
	float local_50;
	float local_4c;
	undefined4 local_48;
	undefined4 local_44;
	int local_40 [16];
	
	local_40[9] = 2;
	local_40[10] = 2;
	local_40[13] = 0xfffffffe;
	local_40[14] = 0xfffffffe;
	local_40[1] = 1;
	local_40[2] = 1;
	local_40[5] = 0xffffffff;
	local_40[6] = 0xffffffff;
	local_40[8] = 0;
	local_40[11] = 0;
	local_40[12] = 0;
	local_40[15] = 0;
	local_40[0] = 0;
	local_40[3] = 0;
	local_40[4] = 0;
	local_40[7] = 0;
	bVar1 = false;
	uVar2 = 0;
	do {
		if ((param_3 == *(int *)((int)local_40 + uVar2) + param_1) &&
			 (param_4 == param_2 + *(int *)((int)local_40 + uVar2 + 4))) {
			bVar1 = true;
			uVar3 = 1;
			break;
		}
		if ((param_3 == *(int *)((int)local_40 + uVar2 + 0x20) + param_1) &&
			 (param_4 == *(int *)((int)local_40 + uVar2 + 0x24) + param_2)) {
			bVar1 = true;
			uVar3 = 0;
			break;
		}
		uVar2 = uVar2 + 8;
		uVar3 = param_4;
	} while (uVar2 < 0x20);
	if (!bVar1) {
		return 0;
	}
	FUN_0040dcc0(param_1,param_2,param_3,param_4,&local_4c);
	lego::game::SurfaceMap_FUN_0044f900
						(lego::globals::g_Level->surfaceMap,param_1,param_2,&local_58,&local_54);
	fVar4 = lego::game::SurfaceMap_GetSurfaceZ(lego::globals::g_Level->surfaceMap,local_58,local_54);
	local_50 = (float)fVar4;
	if (uVar3 == 0) {
		FUN_0040c220(1,local_58,local_54,local_50,local_4c,local_48,local_44);
		return 1;
	}
	FUN_0040c220(0,local_58,local_54,local_50,local_4c,local_48,local_44);
	return 1;
}



void __cdecl FUN_0040dcc0(uint param_1,uint param_2,uint param_3,uint param_4,float *param_5)
{
	float10 fVar1;
	float local_18;
	float local_14;
	float local_10;
	float local_c;
	float local_8 [2];
	
	lego::game::SurfaceMap_FUN_0044f900
						(lego::globals::g_Level->surfaceMap,param_1,param_2,&local_18,&local_14);
	fVar1 = lego::game::SurfaceMap_GetSurfaceZ(lego::globals::g_Level->surfaceMap,local_18,local_14);
	local_10 = (float)fVar1;
	lego::game::SurfaceMap_FUN_0044f900
						(lego::globals::g_Level->surfaceMap,param_3,param_4,&local_c,local_8);
	fVar1 = lego::game::SurfaceMap_GetSurfaceZ(lego::globals::g_Level->surfaceMap,local_c,local_8[0]);
	*param_5 = local_c - local_18;
	param_5[1] = local_8[0] - local_14;
	param_5[2] = (float)(fVar1 - (float10)local_10);
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_0040dd70(LiveObject *liveObj)
{
	VehicleData *pVVar1;
	float fVar2;
	bool bVar3;
	BOOL BVar4;
	uint weaponType;
	int *piVar5;
	uint uVar6;
	uint uVar7;
	float10 fVar8;
	uint local_4c;
	uint local_48;
	float local_44;
	float local_40;
	uint local_3c;
	uint local_38;
	uint local_34;
	Point2F local_30;
	float local_28;
	float local_24;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_20[1] = 1;
	local_20[2] = 1;
	local_c = 0xffffffff;
	local_8 = 0xffffffff;
	local_20[0] = 0;
	local_20[3] = 0;
	local_20[4] = 0;
	local_4 = 0;
	local_44 = 0.0;
	bVar3 = false;
	LiveObject_GetPosition(liveObj,(float *)&local_30,&local_30.y);
	SurfaceMap_ToBlockCoordinatesNoZ
						(globals::g_Level->surfaceMap,local_30.x,local_30.y,(int *)&local_48,(int *)&local_4c);
	uVar7 = local_48;
	uVar6 = local_4c;
	local_3c = local_48;
	local_38 = local_4c;
	if (((*(byte *)((int)&PTR_004c8df8->position +
								 ((globals::g_Level->dimensions).width * local_4c + local_48) * 0xc + 5) & 1) != 0)
		 && (BVar4 = Level_FUN_0040d320(globals::g_Level,local_48,local_4c,0), BVar4 == 0)) {
		if ((&PTR_004c8df8->attachedObject)
				[((globals::g_Level->dimensions).width * local_4c + local_48) * 3] == (LiveObject *)0x0) {
			uVar6 = 0;
			piVar5 = local_20 + 1;
			do {
				if (((&PTR_004c8df8->attachedObject)
						 [((globals::g_Level->dimensions).width * (local_4c + *piVar5) + piVar5[-1] + local_48)
							* 3] != (LiveObject *)0x0) &&
					 (pVVar1 = (&PTR_004c8df8->attachedObject)
										 [((globals::g_Level->dimensions).width * (local_4c + *piVar5) +
											piVar5[-1] + local_48) * 3]->vehicle,
					 (ushort)((ushort)((float)pVVar1 < 0.0) << 8 | (ushort)((float)pVVar1 == 0.0) << 0xe) != 0
					 )) {
					SurfaceMap_FUN_0044f900
										(globals::g_Level->surfaceMap,piVar5[-1] + local_48,local_4c + *piVar5,&local_28
										 ,&local_24);
					local_40 = local_30.x - local_28;
					fVar2 = SQRT((local_30.y - local_24) * (local_30.y - local_24) + local_40 * local_40);
					if ((fVar2 < local_44) || (local_44 == 0.0)) {
						bVar3 = true;
						local_44 = fVar2;
						local_34 = uVar6;
					}
				}
				uVar6 = uVar6 + 1;
				piVar5 = piVar5 + 2;
			} while (uVar6 < 4);
			uVar6 = local_38;
			uVar7 = local_3c;
			if (bVar3) {
				uVar6 = local_38 + local_20[local_34 * 2 + 1];
				uVar7 = local_3c + local_20[local_34 * 2];
			}
		}
		else {
			pVVar1 = (&PTR_004c8df8->attachedObject)
							 [((globals::g_Level->dimensions).width * local_4c + local_48) * 3]->vehicle;
			if ((ushort)((ushort)((float)pVVar1 < 0.0) << 8 | (ushort)((float)pVVar1 == 0.0) << 0xe) != 0)
			{
				bVar3 = true;
			}
		}
		if (bVar3) {
			LiveObject_FUN_0040dff0(liveObj,&local_30,local_48,local_4c);
			FUN_0040d420((undefined4 *)0x0,uVar7,uVar6);
			weaponType = tools::Weapon_GetWeaponTypeByName("FenceSpark");
			fVar8 = tools::Weapon_GetRechargeTime(weaponType);
			(&PTR_004c8df8->attachedObject)[((globals::g_Level->dimensions).width * uVar6 + uVar7) * 3]->
			vehicle = (VehicleData *)(float)fVar8;
			return 1;
		}
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_FUN_0040dff0(LiveObject *liveObj,Point2F *param_2,uint param_3,uint param_4)
{
	uint weaponType;
	float10 fVar1;
	float10 fVar2;
	BOOL BVar3;
	float fVar4;
	float *pfVar5;
	float local_2c;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	float local_18;
	float local_14;
	float local_c;
	float local_8;
	
	SurfaceMap_FUN_0044f900(globals::g_Level->surfaceMap,param_3,param_4,&local_24,&local_20);
	fVar1 = SurfaceMap_GetSurfaceZ(globals::g_Level->surfaceMap,local_24,local_20);
	local_1c = (float)fVar1;
	local_c = param_2->x;
	local_8 = param_2->y;
	fVar1 = SurfaceMap_GetSurfaceZ(globals::g_Level->surfaceMap,local_c,local_8);
	fVar2 = LiveObject_GetCollHeight(liveObj);
	local_18 = local_c - local_24;
	local_14 = local_8 - local_20;
	FUN_0040c220(0,local_24,local_20,local_1c,local_18,local_14,
							 (float)(((float10)(float)fVar1 - fVar2 * (float10)0.5) - (float10)local_1c));
	pfVar5 = &local_2c;
	local_2c = local_18;
	local_28 = local_14;
	fVar4 = 0.0;
	BVar3 = 1;
	weaponType = tools::Weapon_GetWeaponTypeByName("FenceSpark");
	LiveObject_FUN_0046f530(liveObj,weaponType,BVar3,fVar4,pfVar5);
	LiveObject_UnkActivityCrumble_FUN_004424d0(liveObj);
	return;
}



BOOL __cdecl lego::game::Level_FUN_0040e110(LevelData *level,uint x,uint y)
{
	uint uVar1;
	BOOL BVar2;
	uint uVar3;
	int by;
	int *piVar4;
	int bx;
	int by_00;
	int local_20 [4];
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar1 = y;
	local_20[1] = 1;
	local_20[2] = 1;
	local_20[0] = 0;
	local_20[3] = 0;
	local_10 = 0;
	local_c = 0xffffffff;
	local_8 = 0xffffffff;
	local_4 = 0;
	if (((PTR_004c8df8 == (BlockObject *)0x0) ||
			((&PTR_004c8df8->attachedObject)[((globals::g_Level->dimensions).width * y + x) * 3] !=
			 (LiveObject *)0x0)) || (BVar2 = Level_FUN_0040d320(level,x,y,0), BVar2 != 0)) {
		return 0;
	}
	piVar4 = local_20 + 1;
	y = 0;
	do {
		bx = piVar4[-1] + x;
		by_00 = uVar1 + *piVar4;
		if (((&PTR_004c8df8->attachedObject)[((globals::g_Level->dimensions).width * by_00 + bx) * 3] !=
				 (LiveObject *)0x0) || (BVar2 = Level_FUN_0040d320(level,bx,by_00,0), BVar2 != 0)) {
			uVar3 = y - 2 & 3;
			by = local_20[uVar3 * 2 + 1] + uVar1;
			if (((&PTR_004c8df8->attachedObject)
					 [((globals::g_Level->dimensions).width * by + local_20[uVar3 * 2] + x) * 3] !=
					 (LiveObject *)0x0) ||
				 ((BVar2 = Level_FUN_0040d320(level,local_20[uVar3 * 2] + x,by,0), BVar2 != 0 &&
					(BVar2 = Level_FUN_0040d320(level,bx,by_00,0), BVar2 == 0)))) {
				return TRUE;
			}
		}
		piVar4 = piVar4 + 2;
		y = y + 1;
		if (3 < y) {
			return 0;
		}
	} while( true );
}



void __cdecl lego::game::Level_FUN_0040e280(LevelData *level,uint x,uint y,int param_4)
{
	LiveObject *pLVar1;
	float local_8;
	float local_4;
	
	if (PTR_004c8df8 != (BlockObject *)0x0) {
		if (param_4 == 0) {
			pLVar1 = (LiveObject *)
							 ((Point2I *)
							 ((int)&PTR_004c8df8->position + ((globals::g_Level->dimensions).width * y + x) * 0xc)
							 )->x;
			if (pLVar1 != (LiveObject *)0x0) {
				pool::ReservedPool_LiveObject___Release(pLVar1);
				((Point2I *)
				((int)&PTR_004c8df8->position + ((globals::g_Level->dimensions).width * y + x) * 0xc))->x =
						 0;
				*(undefined4 *)
				 ((int)&PTR_004c8df8->position + ((globals::g_Level->dimensions).width * y + x) * 0xc + 4) =
						 0;
			}
		}
		else {
			if (((Point2I *)
					((int)&PTR_004c8df8->position + ((globals::g_Level->dimensions).width * y + x) * 0xc))->x
					== 0) {
				SurfaceMap_FUN_0044f900(level->surfaceMap,x,y,&local_8,&local_4);
				pLVar1 = Game_CreateLiveResourceObject
													 (globals::g_Game.RES_ElectricFenceStud,OBJECT_ELECTRICFENCESTUD,0,0,
														local_8,local_4,0.0);
				((Point2I *)
				((int)&PTR_004c8df8->position + ((globals::g_Level->dimensions).width * y + x) * 0xc))->x =
						 (int)pLVar1;
				return;
			}
		}
	}
	return;
}



BOOL __cdecl FUN_0040e390(int x,int y)
{
	return (uint)((&PTR_004c8df8->attachedObject)
								[((lego::globals::g_Level->dimensions).width * y + x) * 3] != (LiveObject *)0x0);
}



void __cdecl lego::main::Main_Load_Encyclopedia(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	FileStream *pFVar2;
	uint uVar3;
	FileStream **ppFVar4;
	
	globals::g_Encyclopedia_VehicleTypes_TABLE =
			 (FileStream **)std::malloc(globals::g_Game.VehicleTypes_COUNT * 4);
	ppFVar4 = globals::g_Encyclopedia_VehicleTypes_TABLE;
	for (uVar3 = globals::g_Game.VehicleTypes_COUNT; uVar3 != 0; uVar3 = uVar3 - 1) {
		*ppFVar4 = (FileStream *)0x0;
		ppFVar4 = ppFVar4 + 1;
	}
	uVar3 = 0;
	if (globals::g_Game.VehicleTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia",
																 globals::g_Game.VehicleTypes_TABLE[uVar3],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != (char *)0x0) {
				pFVar2 = lego::file::File_Open(pcVar1,"r");
				globals::g_Encyclopedia_VehicleTypes_TABLE[uVar3] = pFVar2;
			}
			uVar3 = uVar3 + 1;
		} while (uVar3 < globals::g_Game.VehicleTypes_COUNT);
	}
	globals::g_Encyclopedia_MiniFigureTypes_TABLE =
			 (FileStream **)std::malloc(globals::g_Game.MiniFigureTypes_COUNT * 4);
	ppFVar4 = globals::g_Encyclopedia_MiniFigureTypes_TABLE;
	for (uVar3 = globals::g_Game.MiniFigureTypes_COUNT; uVar3 != 0; uVar3 = uVar3 - 1) {
		*ppFVar4 = (FileStream *)0x0;
		ppFVar4 = ppFVar4 + 1;
	}
	uVar3 = 0;
	if (globals::g_Game.MiniFigureTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia",
																 globals::g_Game.MiniFigureTypes_TABLE[uVar3],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != (char *)0x0) {
				pFVar2 = lego::file::File_Open(pcVar1,"r");
				globals::g_Encyclopedia_MiniFigureTypes_TABLE[uVar3] = pFVar2;
			}
			uVar3 = uVar3 + 1;
		} while (uVar3 < globals::g_Game.MiniFigureTypes_COUNT);
	}
	globals::g_Encyclopedia_RockMonsterTypes_TABLE =
			 (FileStream **)std::malloc(globals::g_Game.RockMonsterTypes_COUNT * 4);
	ppFVar4 = globals::g_Encyclopedia_RockMonsterTypes_TABLE;
	for (uVar3 = globals::g_Game.RockMonsterTypes_COUNT; uVar3 != 0; uVar3 = uVar3 - 1) {
		*ppFVar4 = (FileStream *)0x0;
		ppFVar4 = ppFVar4 + 1;
	}
	uVar3 = 0;
	if (globals::g_Game.RockMonsterTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia",
																 globals::g_Game.RockMonsterTypes_TABLE[uVar3],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != (char *)0x0) {
				pFVar2 = lego::file::File_Open(pcVar1,"r");
				globals::g_Encyclopedia_RockMonsterTypes_TABLE[uVar3] = pFVar2;
			}
			uVar3 = uVar3 + 1;
		} while (uVar3 < globals::g_Game.RockMonsterTypes_COUNT);
	}
	globals::g_Encyclopedia_BuildingTypes_TABLE =
			 (FileStream **)std::malloc(globals::g_Game.BuildingTypes_COUNT * 4);
	ppFVar4 = globals::g_Encyclopedia_BuildingTypes_TABLE;
	for (uVar3 = globals::g_Game.BuildingTypes_COUNT; uVar3 != 0; uVar3 = uVar3 - 1) {
		*ppFVar4 = (FileStream *)0x0;
		ppFVar4 = ppFVar4 + 1;
	}
	uVar3 = 0;
	if (globals::g_Game.BuildingTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia",
																 globals::g_Game.BuildingTypes_TABLE[uVar3],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != (char *)0x0) {
				pFVar2 = lego::file::File_Open(pcVar1,"r");
				globals::g_Encyclopedia_BuildingTypes_TABLE[uVar3] = pFVar2;
			}
			uVar3 = uVar3 + 1;
		} while (uVar3 < globals::g_Game.BuildingTypes_COUNT);
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia","PowerCrystal",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Encyclopedia_PowerCrystal = lego::file::File_Open(pcVar1,"r");
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia","Ore",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Encyclopedia_Ore = lego::file::File_Open(pcVar1,"r");
	}
	return;
}



void __cdecl FUN_0040e630(undefined4 *param_1)
{
	undefined4 *puVar1;
	int local_4;
	
	puVar1 = param_1;
	lego::game::LiveObject_GetTypeIndex((LiveObject *)param_1,&local_4,(int *)&param_1);
	switch(local_4) {
	case 1:
		DAT_004c8ea0 = lego::globals::g_Encyclopedia_VehicleTypes_TABLE[(int)param_1];
		break;
	case 2:
		DAT_004c8ea0 = lego::globals::g_Encyclopedia_MiniFigureTypes_TABLE[(int)param_1];
		break;
	case 3:
		DAT_004c8ea0 = lego::globals::g_Encyclopedia_RockMonsterTypes_TABLE[(int)param_1];
		break;
	case 4:
		DAT_004c8ea0 = lego::globals::g_Encyclopedia_BuildingTypes_TABLE[(int)param_1];
		break;
	default:
		DAT_004c8ea0 = (FileStream *)0x0;
		DAT_004c8ea8 = DAT_004c8ea8 & 0xfffffffe;
		return;
	case 6:
		DAT_004c8ea0 = lego::globals::g_Encyclopedia_PowerCrystal;
		break;
	case 7:
		DAT_004c8ea0 = lego::globals::g_Encyclopedia_Ore;
	}
	DAT_004c8ea8 = DAT_004c8ea8 | 3;
	PTR_004c8ea4 = (LiveObject *)puVar1;
	lego::image::Struct830_FUN_0045a8e0((TextWindow **)PTR_005017dc);
	return;
}



void FUN_0040e710(void)
{
	DAT_004c8ea8 = DAT_004c8ea8 & 0xfffffffe;
	return;
}



void __cdecl FUN_0040e720(float param_1)
{
	BOOL BVar1;
	char *pcVar2;
	char local_200 [512];
	
	if (((DAT_004c8ea8 & 1) != 0) && (BVar1 = FUN_0045adf0(0xb), BVar1 == 0)) {
		if ((DAT_004c8ea8 & 2) != 0) {
			if (DAT_004c8ea0 == (FileStream *)0x0) {
				FUN_0045a850(PTR_005017dc,"Object has no encyclopedia file.");
			}
			else {
				lego::file::File_Seek(DAT_004c8ea0,0,0);
				pcVar2 = lego::file::File_GetS(local_200,0x200,DAT_004c8ea0);
				while (pcVar2 != (char *)0x0) {
					FUN_0045a850(PTR_005017dc,"%s",local_200);
					pcVar2 = lego::file::File_GetS(local_200,0x200,DAT_004c8ea0);
				}
			}
			DAT_004c8ea8 = DAT_004c8ea8 & 0xfffffffd;
		}
		FUN_0045a870((int **)PTR_005017dc,0,param_1);
	}
	return;
}



void __cdecl FUN_0040e800(int param_1)
{
	if (((((byte)DAT_004c8ea8 & 1) != 0) && (((byte)PanelData_ARRAY_00501110[11].flags & 2) != 0)) &&
		 (PTR_004c8ea4 != (LiveObject *)0x0)) {
		lego::game::LiveObject_FUN_004247e0(PTR_004c8ea4,param_1,0.0,1.0,0.0);
	}
	return;
}



void __cdecl lego::game::LiveObject_ClearPtr_004c8ea4_IfEqual(LiveObject *liveObj)
{
	if (PTR_004c8ea4 == liveObj) {
		PTR_004c8ea4 = (LiveObject *)0x0;
	}
	return;
}



void __cdecl lego::game::Game_SetErodeTimes(float triggerTime,float erodeTime,float lockTime)
{
	int iVar1;
	BOOL *pBVar2;
	
	globals::g_ErodeTriggerTime = triggerTime * 25.0;
	globals::g_ErodeErodeTime = erodeTime * 25.0 * 0.2;
	globals::g_ErodeLockTime = lockTime * 25.0;
	globals::g_ErodeUnk_COUNT = 0;
	pBVar2 = globals::g_ErodeUnkBools_TABLE;
	for (iVar1 = 2000; iVar1 != 0; iVar1 = iVar1 + -1) {
		*pBVar2 = 0;
		pBVar2 = pBVar2 + 1;
	}
	pBVar2 = globals::g_ErodeUnkBools2_TABLE;
	for (iVar1 = 1000; iVar1 != 0; iVar1 = iVar1 + -1) {
		*pBVar2 = 0;
		pBVar2 = pBVar2 + 1;
	}
	return;
}



BOOL __cdecl lego::game::Game_GetAvailableErosion__0040e8c0(int *out_index)
{
	BOOL *pBVar1;
	int iVar2;
	
	iVar2 = 0;
	pBVar1 = globals::g_ErodeUnkBools_TABLE;
	do {
		if ((float)*pBVar1 == 0.0) {
			*out_index = iVar2;
			return 1;
		}
		pBVar1 = (BOOL *)((float *)pBVar1 + 1);
		iVar2 = iVar2 + 1;
	} while (pBVar1 < globals::g_ErodeUnkFloats_TABLE);
	return 0;
}



float10 __cdecl FUN_0040e8f0(Point2I *param_1)
{
	return (float10)(6 - (uint)(lego::globals::g_Game.level)->blocks
														 [((lego::globals::g_Game.level)->dimensions).width * param_1->y +
															param_1->x].erodeSpeed) * (float10)lego::globals::g_ErodeErodeTime *
				 (float10)25.0;
}



void __cdecl FUN_0040e940(Point2I *position,int param_2)
{
	LevelData *pLVar1;
	BOOL BVar2;
	float10 fVar3;
	int erodeIndex;
	int local_8;
	undefined4 local_4;
	
	pLVar1 = lego::globals::g_Game.level;
	BVar2 = lego::game::Game_GetAvailableErosion__0040e8c0(&erodeIndex);
	if (BVar2 != 0) {
		pLVar1->blocks[position->y * (pLVar1->dimensions).width + position->x].field_7 = (byte)param_2;
		lego::globals::g_ErodeBlocks_TABLE[erodeIndex].x = position->x;
		lego::globals::g_ErodeBlocks_TABLE[erodeIndex].y = position->y;
		fVar3 = FUN_0040e8f0(position);
		local_8 = param_2 + 1;
		local_4 = 0;
		lego::globals::g_ErodeUnkFloats_TABLE[erodeIndex] = (float)(fVar3 / (float10)local_8);
		lego::globals::g_ErodeUnkBools_TABLE[erodeIndex] = 1;
		FUN_0040ed80(position,1);
	}
	return;
}



void __cdecl lego::game::Game_DoErosionUnk__0040e9e0(float elapsedGame)
{
	float fVar1;
	LevelData *level;
	char cVar2;
	short sVar3;
	BOOL BVar4;
	int iVar5;
	BOOL *pBVar6;
	float *pfVar7;
	uint uVar8;
	Point2I *pPVar9;
	float10 fVar10;
	longlong lVar11;
	longlong lVar12;
	undefined4 uVar13;
	int local_24;
	ErodeState local_20;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	level = globals::g_Game.level;
	sVar3 = math::Maths_Rand();
	globals::g_ErosionTimer_Unk = elapsedGame + globals::g_ErosionTimer_Unk;
	if ((ushort)((ushort)(globals::g_ErosionTimer_Unk < globals::g_ErodeTriggerTime) << 8 |
							(ushort)(globals::g_ErosionTimer_Unk == globals::g_ErodeTriggerTime) << 0xe) == 0) {
		BVar4 = Game_GetAvailableErosion__0040e8c0(&local_24);
		if ((BVar4 != 0) && (uVar8 = 0, globals::g_ErodeUnk_COUNT != 0)) {
			do {
				iVar5 = FUN_0040ef30((int *)(globals::g_ErodeUnkStates2_TABLE +
																		((int)sVar3 + uVar8) % globals::g_ErodeUnk_COUNT),
														 (int *)&local_20);
				if (iVar5 != 0) {
					BVar4 = Level_IsBlockPowerPath((Point2I *)&local_20);
					if ((BVar4 == 0) ||
						 ((*(byte *)&level->blocks
												 [local_20.field_4 * (level->dimensions).width + local_20.field_0].flags2 &
							0x10) != 0)) {
						iVar5 = local_20.field_4 * (level->dimensions).width + local_20.field_0;
						level->blocks[iVar5].flags2 = level->blocks[iVar5].flags2 & 0xffffffef;
						globals::g_ErodeBlocks_TABLE[local_24].x = local_20.field_0;
						globals::g_ErodeBlocks_TABLE[local_24].y = local_20.field_4;
						fVar10 = FUN_0040e8f0(globals::g_ErodeBlocks_TABLE + local_24);
						globals::g_ErodeUnkFloats_TABLE[local_24] = (float)fVar10;
						globals::g_ErodeUnkBools_TABLE[local_24] = 1;
						level->blocks[local_20.field_4 * (level->dimensions).width + local_20.field_0].field_7 =
								 0;
						FUN_0040ed80((Point2I *)&local_20,1);
						front::Info_FUN_00419ab0
											(INFO_LAVAERODE,(char *)0x0,(LiveObject *)0x0,(Point2I *)&local_20);
						break;
					}
					Game_ErodeUnk__0040ed30(&local_20);
					iVar5 = local_20.field_4 * (level->dimensions).width + local_20.field_0;
					level->blocks[iVar5].flags2 = level->blocks[iVar5].flags2 | 0x10;
				}
				uVar8 = uVar8 + 1;
			} while (uVar8 < globals::g_ErodeUnk_COUNT);
		}
		globals::g_ErosionTimer_Unk = 0.0;
	}
	pfVar7 = globals::g_ErodeUnkFloats_TABLE;
	pPVar9 = globals::g_ErodeBlocks_TABLE;
	do {
		if (pfVar7[-2000] != 0.0) {
			fVar10 = FUN_0040e8f0(pPVar9);
			lVar11 = __ftol(((float10)*pfVar7 / fVar10) * (float10)4.0);
			*pfVar7 = *pfVar7 - elapsedGame;
			fVar10 = FUN_0040e8f0(pPVar9);
			lVar12 = __ftol(((float10)*pfVar7 / fVar10) * (float10)4.0);
			cVar2 = (char)lVar12;
			if (cVar2 == (char)lVar11) goto LAB_0040ecc3;
			level->blocks[pPVar9->y * (level->dimensions).width + pPVar9->x].field_7 = 4 - cVar2;
			SurfaceMap_FUN_0044f900(level->surfaceMap,pPVar9->x,pPVar9->y,&local_18,&local_14);
			fVar10 = SurfaceMap_GetSurfaceZ(level->surfaceMap,local_18,local_14);
			local_10 = (float)fVar10;
			math::Maths_Vector3DRandom(&local_c);
			local_c.z = 0.0;
			switch(cVar2) {
			case '\0':
				pfVar7[-2000] = 0.0;
				level->blocks[pPVar9->y * (level->dimensions).width + pPVar9->x].terrain = TERRAIN_LAVA;
				uVar13 = 4;
				break;
			case '\x01':
				uVar13 = 5;
				break;
			case '\x02':
				uVar13 = 6;
				break;
			case '\x03':
				uVar13 = 7;
				break;
			default:
				goto switchD_0040ec49_caseD_4;
			}
			FUN_0040cc10(uVar13,&local_18,(undefined4 *)&local_c);
switchD_0040ec49_caseD_4:
			Level_UpdateBlockSurfaceUnk(level,pPVar9->x,pPVar9->y);
		}
LAB_0040ecc3:
		pPVar9 = pPVar9 + 1;
		pfVar7 = pfVar7 + 1;
		if (globals::g_ErodeUnkBools_TABLE <= pPVar9) {
			pBVar6 = globals::g_ErodeUnkBools2_TABLE;
			do {
				if (((float)*pBVar6 != 0.0) &&
					 (fVar1 = ((float *)pBVar6)[-1000], ((float *)pBVar6)[-1000] = fVar1 - elapsedGame,
					 fVar1 - elapsedGame < 0.0)) {
					*pBVar6 = 0;
				}
				pBVar6 = (BOOL *)((float *)pBVar6 + 1);
			} while (pBVar6 < &globals::g_ErosionTimer_Unk);
			return;
		}
	} while( true );
}



void __cdecl lego::game::Game_ErodeUnk__0040ed30(ErodeState *param_1)
{
	BOOL *pBVar1;
	int iVar2;
	
	iVar2 = 0;
	pBVar1 = globals::g_ErodeUnkBools2_TABLE;
	do {
		if ((float)*pBVar1 == 0.0) {
			globals::g_ErodeUnkStates3_TABLE[iVar2].field_0 = param_1->field_0;
			globals::g_ErodeUnkStates3_TABLE[iVar2].field_4 = param_1->field_4;
			globals::g_ErodeLockTimes_TABLE[iVar2] = globals::g_ErodeLockTime;
			globals::g_ErodeUnkBools2_TABLE[iVar2] = 1;
			return;
		}
		pBVar1 = (BOOL *)((float *)pBVar1 + 1);
		iVar2 = iVar2 + 1;
	} while (pBVar1 < &globals::g_ErosionTimer_Unk);
	return;
}



void __cdecl FUN_0040ed80(Point2I *position,int param_2)
{
	LevelData *pLVar1;
	int iVar2;
	uint uVar3;
	Point2I *pPVar4;
	ErodeState *pEVar5;
	uint uVar6;
	
	pLVar1 = lego::globals::g_Game.level;
	if (param_2 == 0) {
		uVar3 = 0;
		if (lego::globals::g_ErodeUnk_COUNT != 0) {
			pEVar5 = lego::globals::g_ErodeUnkStates2_TABLE;
			do {
				if ((position->x == pEVar5->field_0) && (position->y == pEVar5->field_4)) {
					uVar6 = lego::globals::g_ErodeUnk_COUNT - 1;
					lego::globals::g_ErodeUnk_COUNT = uVar6;
					lego::globals::g_ErodeUnkStates2_TABLE[uVar3].field_0 =
							 lego::globals::g_ErodeUnkStates2_TABLE[uVar6].field_0;
					lego::globals::g_ErodeUnkStates2_TABLE[uVar3].field_4 =
							 lego::globals::g_ErodeUnkStates2_TABLE[uVar6].field_4;
					iVar2 = (pLVar1->dimensions).width * position->y + position->x;
					pLVar1->blocks[iVar2].flags1 = pLVar1->blocks[iVar2].flags1 & ~BLOCK1_UNK_80000000;
					break;
				}
				uVar3 = uVar3 + 1;
				pEVar5 = pEVar5 + 1;
			} while (uVar3 < lego::globals::g_ErodeUnk_COUNT);
		}
		iVar2 = 0;
		pPVar4 = lego::globals::g_ErodeBlocks_TABLE;
		do {
			if ((position->x == pPVar4->x) && (position->y == pPVar4->y)) {
				lego::globals::g_ErodeUnkBools_TABLE[iVar2] = 0;
				break;
			}
			pPVar4 = pPVar4 + 1;
			iVar2 = iVar2 + 1;
		} while (pPVar4 < lego::globals::g_ErodeUnkBools_TABLE);
		lego::game::Game_ErodeUnk__0040ed30((ErodeState *)position);
	}
	else {
		if ((((lego::globals::g_Game.level)->blocks
					[((lego::globals::g_Game.level)->dimensions).width * position->y + position->x].flags1 &
				 BLOCK1_UNK_80000000) == BLOCK1_NONE) && (lego::globals::g_ErodeUnk_COUNT < 2000)) {
			lego::globals::g_ErodeUnkStates2_TABLE[lego::globals::g_ErodeUnk_COUNT].field_0 = position->x;
			lego::globals::g_ErodeUnkStates2_TABLE[lego::globals::g_ErodeUnk_COUNT].field_4 = position->y;
			lego::globals::g_ErodeUnk_COUNT = lego::globals::g_ErodeUnk_COUNT + 1;
			FUN_004301e0(position);
			iVar2 = (pLVar1->dimensions).width * position->y + position->x;
			pLVar1->blocks[iVar2].flags1 = pLVar1->blocks[iVar2].flags1 | BLOCK1_UNK_80000000;
			return;
		}
	}
	return;
}



undefined4 __cdecl FUN_0040eee0(int *param_1)
{
	BOOL *pBVar1;
	ErodeState *pEVar2;
	
	pEVar2 = lego::globals::g_ErodeUnkStates3_TABLE;
	pBVar1 = lego::globals::g_ErodeUnkBools2_TABLE;
	while (((*pBVar1 == 0 || (*param_1 != pEVar2->field_0)) || (param_1[1] != pEVar2->field_4))) {
		pBVar1 = pBVar1 + 1;
		pEVar2 = pEVar2 + 1;
		if ((int *)((int)lego::globals::g_ErodeUnkBools2_TABLE + 3999) < pBVar1) {
			return 0;
		}
	}
	return 1;
}



undefined4 __cdecl FUN_0040ef30(int *param_1,int *param_2)
{
	LevelBlock *pLVar1;
	LevelBlockFlags1 LVar2;
	LevelData *pLVar3;
	int *piVar4;
	int iVar5;
	int *piVar6;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	piVar4 = param_1;
	pLVar3 = lego::globals::g_Game.level;
	local_20[2] = 1;
	local_c = 1;
	local_20[1] = 0xffffffff;
	local_8 = 0xffffffff;
	local_20[3] = 0;
	local_20[4] = 0;
	local_4 = 0;
	if ((lego::globals::g_Game.level)->blocks
			[param_1[1] * ((lego::globals::g_Game.level)->dimensions).width + *param_1].terrain !=
			TERRAIN_LAVA) {
		return 0;
	}
	param_1 = (int *)0x0;
	piVar6 = local_20 + 1;
	do {
		iVar5 = *piVar6;
		*param_2 = piVar6[-1] + *piVar4;
		iVar5 = piVar4[1] + iVar5;
		param_2[1] = iVar5;
		pLVar1 = pLVar3->blocks + (pLVar3->dimensions).width * iVar5 + *param_2;
		LVar2 = pLVar1->flags1;
		if ((((LVar2 & BLOCK1_UNK_80000000) == BLOCK1_NONE) && ((LVar2 & BLOCK1_UNK_8) != BLOCK1_NONE))
			 && (pLVar1->erodeSpeed != ERODE_NONE)) {
			iVar5 = FUN_0040eee0(param_2);
			if (iVar5 == 0) {
				return 1;
			}
		}
		piVar6 = piVar6 + 2;
		param_1 = (int *)((int)param_1 + 1);
	} while (param_1 < &DAT_00000004);
	return 0;
}



uint __cdecl FUN_0040f010(float time)
{
	short sVar1;
	SurfaceMap *pSVar2;
	BOOL BVar3;
	uint uVar4;
	uint uVar5;
	Point2I local_8;
	
	pSVar2 = lego::game::GetSurfaceMap();
	FLOAT_004d88c4 = FLOAT_004d88c4 - time;
	uVar5 = (uint)(ushort)((ushort)(FLOAT_004d88c4 < 0.0) << 8 |
												(ushort)(FLOAT_004d88c4 == 0.0) << 0xe);
	uVar4 = (uint)pSVar2 & 0xffff0000 | uVar5;
	if (uVar5 != 0) {
		uVar5 = 0;
		do {
			sVar1 = lego::math::Maths_Rand();
			local_8.x = (uint)(int)sVar1 % (uint)(pSVar2->smallDimensions).width;
			sVar1 = lego::math::Maths_Rand();
			local_8.y = (uint)(int)sVar1 % (uint)(pSVar2->smallDimensions).height;
			BVar3 = FUN_0040f0c0(&local_8,1);
			if (BVar3 != 0) {
				lego::front::Info_FUN_00419ab0(INFO_LANDSLIDE,(char *)0x0,(LiveObject *)0x0,&local_8);
				break;
			}
			uVar5 = uVar5 + 1;
		} while (uVar5 < 100);
		sVar1 = lego::math::Maths_Rand();
		uVar4 = (int)sVar1 / 0x32;
		FLOAT_004d88c4 = (float)((int)sVar1 % 0x32) - -750.0;
	}
	return uVar4;
}



BOOL __cdecl FUN_0040f0c0(Point2I *position,int param_2)
{
	bool bVar1;
	BOOL BVar2;
	uint uVar3;
	uint uVar4;
	int *piVar5;
	uint uVar6;
	int local_30;
	Point2I local_28;
	Point2I locations [4];
	
	uVar6 = 0;
	bVar1 = true;
	uVar4 = 0;
	local_30 = 0;
	lego::game::GetSurfaceMap();
	locations[0].x = 0;
	locations[0].y = -1;
	locations[1].x = 1;
	locations[1].y = 0;
	locations[2].x = 0;
	locations[2].y = 1;
	locations[3].x = -1;
	locations[3].y = 0;
	BVar2 = lego::game::Level_UpdateFallinsUnk1(position);
	if (BVar2 != 0) {
		piVar5 = &locations[0].y;
		do {
			local_28.x = piVar5[-1] + position->x;
			local_28.y = *piVar5 + position->y;
			BVar2 = lego::game::Level_GetBlockFlags1_10Not8(local_28.x,local_28.y);
			if (BVar2 != 0) {
				uVar3 = lego::game::Level_IsBlockSolid(&local_28);
				if (uVar3 == 0) {
					BVar2 = lego::game::Level_GetBlockFlags1_20(local_28.x,local_28.y);
					if (BVar2 != 0) goto LAB_0040f164;
				}
				else {
LAB_0040f164:
					bVar1 = false;
				}
				uVar4 = uVar4 | 1 << ((byte)uVar6 & 0x1f);
				BVar2 = lego::game::Level_GetBlockFlags1_c0(local_28.x,local_28.y);
				if (BVar2 == 0) {
					local_30 = local_30 + 1;
				}
			}
			uVar6 = uVar6 + 1;
			piVar5 = piVar5 + 2;
		} while (uVar6 < 4);
		if (((bVar1) && (uVar4 != 0)) && (local_30 != 0)) {
			FUN_0040f260(position,uVar4,param_2);
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Level_UpdateFallinsUnk1(Point2I *position)
{
	TerrainType TVar1;
	BOOL BVar2;
	uint uVar3;
	LevelData *level;
	
	level = globals::g_Game.level;
	BVar2 = Level_GetBlockFlags1_8(position->x,position->y);
	if ((((BVar2 != 0) && (uVar3 = Level_GetBlockFlags1_8000000(position), uVar3 == 0)) &&
			(TVar1 = level->blocks[(level->dimensions).width * position->y + position->x].terrain,
			TVar1 != TERRAIN_LAVA)) && ((TVar1 != TERRAIN_LAKE && (TVar1 != TERRAIN_WATER_unused)))) {
		if ((level->SafeCaverns != BOOL3_FALSE) && (BVar2 = Level_IsBlockExposed(position), BVar2 != 0))
		{
			return 0;
		}
		return 1;
	}
	return 0;
}



void __cdecl FUN_0040f260(Point2I *param_1,undefined4 param_2,int param_3)
{
	Point2I *position;
	undefined4 uVar1;
	int iVar2;
	Point2I *pPVar3;
	BOOL BVar4;
	Point2I *pPVar5;
	float10 fVar6;
	undefined4 uVar7;
	undefined4 uVar8;
	float local_30;
	Vector3F local_2c;
	undefined4 local_20 [4];
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	position = param_1;
	local_20[0] = 0;
	local_20[1] = 0x3f800000;
	local_20[2] = 0x3f800000;
	local_20[3] = 0;
	local_10 = 0;
	local_c = 0xbf800000;
	local_8 = 0xbf800000;
	local_4 = 0;
	iVar2 = FUN_00432bc0(param_1);
	while (iVar2 == 0) {
		iVar2 = FUN_00432bc0(position);
	}
	lego::ai::AITask_DoClearTypeAction(position,MESSAGE_CLEARFALLIN_COMPLETE);
	uVar1 = param_2;
	pPVar3 = param_1;
	pPVar5 = param_1;
	switch(param_2) {
	case 1:
	case 0xe:
		pPVar3 = (Point2I *)0x0;
		pPVar5 = (Point2I *)0x0;
		break;
	case 2:
	case 10:
	case 0xd:
		pPVar3 = (Point2I *)0x1;
		pPVar5 = (Point2I *)0x0;
		break;
	case 3:
		pPVar3 = (Point2I *)0x1;
		pPVar5 = (Point2I *)0x1;
		break;
	case 4:
	case 5:
	case 0xb:
		pPVar3 = (Point2I *)0x2;
		pPVar5 = (Point2I *)0x0;
		break;
	case 6:
		pPVar3 = (Point2I *)0x2;
		pPVar5 = (Point2I *)0x1;
		break;
	case 7:
	case 8:
		pPVar3 = (Point2I *)0x3;
		pPVar5 = (Point2I *)0x0;
		break;
	case 9:
		pPVar3 = (Point2I *)0x0;
		pPVar5 = (Point2I *)0x1;
		break;
	case 0xc:
		pPVar3 = (Point2I *)0x3;
		pPVar5 = (Point2I *)0x1;
	}
	lego::game::SurfaceMap_FUN_0044f900
						((lego::globals::g_Game.level)->surfaceMap,position->x,position->y,&local_30,
						 (float *)&param_1);
	uVar8 = local_20[(int)pPVar3 * 2 + 1];
	uVar7 = local_20[(int)pPVar3 * 2];
	fVar6 = lego::game::SurfaceMap_GetSurfaceZ
										((lego::globals::g_Game.level)->surfaceMap,local_30,(float)param_1);
	BVar4 = FUN_0040c160((int)pPVar5,position->x,position->y,local_30,param_1,(float)fVar6,uVar7,uVar8
											);
	if (BVar4 != 0) {
		local_2c.y = (float)param_1;
		local_2c.x = local_30;
		fVar6 = lego::game::SurfaceMap_GetSurfaceZ
											((lego::globals::g_Game.level)->surfaceMap,local_30,(float)param_1);
		local_2c.z = (float)fVar6;
		iVar2 = ((lego::globals::g_Game.level)->dimensions).width * position->y + position->x;
		(lego::globals::g_Game.level)->blocks[iVar2].flags1 =
				 (lego::globals::g_Game.level)->blocks[iVar2].flags1 | BLOCK1_UNK_800;
		iVar2 = ((lego::globals::g_Game.level)->dimensions).width * position->y + position->x;
		(lego::globals::g_Game.level)->blocks[iVar2].flags1 =
				 (lego::globals::g_Game.level)->blocks[iVar2].flags1 | BLOCK1_UNK_1000;
		lego::game::Level_SetBlockFlags1_8000000(position,1);
		lego::res::Res_PlayResourceSound((Container *)0x0,SFX_FALLIN,0,0,&local_2c);
	}
	if ((param_3 != 0) &&
		 (iVar2 = ((lego::globals::g_Game.level)->dimensions).width * position->y + position->x,
		 (lego::globals::g_Game.level)->blocks[iVar2].numLandSlides =
					(lego::globals::g_Game.level)->blocks[iVar2].numLandSlides + 1,
		 (uint)lego::globals::g_NumberOfLandSlidesTillCaveIn <=
		 (lego::globals::g_Game.level)->blocks
		 [((lego::globals::g_Game.level)->dimensions).width * position->y + position->x].numLandSlides))
	{
		lego::game::Game_LandSlideDoCavein(position,uVar1);
		lego::front::Info_FUN_00419ab0(INFO_LANDSLIDE,(char *)0x0,(LiveObject *)0x0,position);
	}
	lego::game::Level_UpdateBlockSurfaceUnk(lego::globals::g_Game.level,position->x,position->y);
	return;
}



void __cdecl lego::game::Game_SetNumberOfLandSlidesTillCaveIn(int numLandSlides)
{
	globals::g_NumberOfLandSlidesTillCaveIn = numLandSlides;
	return;
}



void __cdecl lego::game::Game_LandSlideDoCavein(Point2I *position,undefined4 param_2)
{
	BOOL BVar1;
	int iVar2;
	int *piVar3;
	Point2I current;
	Point2I locations [8];
	
	locations[0].x = 0;
	locations[0].y = 1;
	locations[1].x = 1;
	locations[1].y = 1;
	locations[2].x = 1;
	locations[2].y = 0;
	locations[3].x = 1;
	locations[3].y = -1;
	locations[4].x = 0;
	locations[4].y = -1;
	locations[5].x = -1;
	locations[5].y = -1;
	locations[6].x = -1;
	locations[6].y = 0;
	locations[7].x = -1;
	locations[7].y = 1;
	piVar3 = &locations[0].y;
	iVar2 = 8;
	do {
		current.x = piVar3[-1] + position->x;
		current.y = position->y + *piVar3;
		BVar1 = SurfaceMap_IsInsideDimensions((globals::g_Game.level)->surfaceMap,current.x,current.y);
		if (BVar1 != 0) {
			BVar1 = FUN_0040f0c0(&current,0);
			if (BVar1 == 0) {
				BVar1 = Level_UpdateFallinsUnk1(&current);
				if (BVar1 != 0) {
					FUN_0040f260(&current,param_2,0);
				}
			}
		}
		piVar3 = piVar3 + 2;
		iVar2 = iVar2 + -1;
	} while (iVar2 != 0);
	return;
}



FlockSubdata * __cdecl
lego::game::LiveObject_FlocksAllocSubdata
					(Vector3F *vector_1,Vector3F *vector_2,float turn,float speed,float tightness,
					float goalUpdate,Container *resData)
{
	FlockSubdata *pFVar1;
	
	pFVar1 = (FlockSubdata *)std::malloc(0xa0);
	if (pFVar1 == (FlockSubdata *)0x0) {
		return (FlockSubdata *)0x0;
	}
	pFVar1->float_30 = 0.0;
	pFVar1->float_2c = 0.0;
	pFVar1->float_28 = 0.0;
	pFVar1->float_24 = 0.0;
	(pFVar1->vector_18).y = 0.0;
	(pFVar1->vector_18).x = 0.0;
	(pFVar1->vector_18).z = 1.0;
	if (vector_2 == (Vector3F *)0x0) {
		(pFVar1->vector_0).x = 0.0;
		(pFVar1->vector_0).y = 0.0;
		(pFVar1->vector_0).z = 0.0;
	}
	else {
		(pFVar1->vector_0).x = vector_2->x;
		(pFVar1->vector_0).y = vector_2->y;
		(pFVar1->vector_0).z = vector_2->z;
	}
	if (vector_1 == (Vector3F *)0x0) {
		(pFVar1->vector_c).x = 0.0;
		(pFVar1->vector_c).y = 0.0;
		(pFVar1->vector_c).z = 0.0;
	}
	else {
		(pFVar1->vector_c).x = vector_1->x;
		(pFVar1->vector_c).y = vector_1->y;
		(pFVar1->vector_c).z = vector_1->z;
	}
	pFVar1->field_34 = 0;
	pFVar1->Turn2 = turn;
	pFVar1->Turn1 = turn;
	pFVar1->Speed2 = speed;
	pFVar1->Speed1 = speed;
	pFVar1->Tightness2 = tightness;
	pFVar1->Tightness1 = tightness;
	pFVar1->GoalUpdate2 = goalUpdate;
	pFVar1->GoalUpdate1 = goalUpdate;
	pFVar1->resData_98 = resData;
	return pFVar1;
}



void __cdecl lego::util::freeNonNull(void *ptr)
{
	if (ptr != (void *)0x0) {
		std::free(ptr);
	}
	return;
}



FlockData * __cdecl
lego::game::LiveObject_FlocksAllocData
					(Vector3F *vector_1,Vector3F *vector_2,float turn,float speed,float tightness,
					Container *resData)
{
	FlockData *pFVar1;
	FlockSubdata *pFVar2;
	
	pFVar1 = (FlockData *)std::malloc(0x28);
	if (pFVar1 == (FlockData *)0x0) {
		return (FlockData *)0x0;
	}
	pFVar2 = LiveObject_FlocksAllocSubdata(vector_1,vector_2,turn,speed,tightness,0.0,resData);
	pFVar1->flocksSubdata1 = pFVar2;
	if (vector_1 == (Vector3F *)0x0) {
		pFVar1->hasVector1 = 0;
	}
	else {
		pFVar1->hasVector1 = 1;
	}
	if (vector_2 != (Vector3F *)0x0) {
		pFVar1->hasVector2 = 1;
		pFVar1->flocksSubdata2 = (FlockSubdata *)0x0;
		pFVar1->numSubdata = 0;
		return pFVar1;
	}
	pFVar1->hasVector2 = 0;
	pFVar1->flocksSubdata2 = (FlockSubdata *)0x0;
	pFVar1->numSubdata = 0;
	return pFVar1;
}



void __cdecl lego::unk::Lego_UnkRecurseFree__0040f780(undefined4 *param_1)
{
	undefined4 *ptr;
	
	ptr = Lego_UnkRecurseFreeDoSomething__0040fd90(param_1);
	while (ptr != (undefined4 *)0x0) {
		util::freeNonNull(ptr);
		ptr = Lego_UnkRecurseFreeDoSomething__0040fd90(param_1);
	}
	util::freeNonNull((void *)*param_1);
	std::free(param_1);
	return;
}



void __cdecl lego::game::Flocks_FUN_0040f7c0(FlockSubdata *flockSubdata,Vector3F *vector)
{
	float fVar1;
	
	if ((ushort)((ushort)(vector->y < 1.0) << 8 | (ushort)(vector->y == 1.0) << 0xe) == 0) {
		fVar1 = flockSubdata->Turn1 + flockSubdata->float_28;
		flockSubdata->float_28 = fVar1;
		if ((ushort)((ushort)(fVar1 < 0.8) << 8 | (ushort)(fVar1 == 0.8) << 0xe) == 0) {
			flockSubdata->float_28 = 0.8;
			return;
		}
	}
	else {
		if (-1.0 <= vector->y) {
			flockSubdata->float_28 = flockSubdata->float_28 * 0.95;
			return;
		}
		fVar1 = flockSubdata->float_28 - flockSubdata->Turn1;
		flockSubdata->float_28 = fVar1;
		if (fVar1 < -0.8) {
			flockSubdata->float_28 = -0.8;
			return;
		}
	}
	return;
}



void __cdecl lego::game::Flocks_FUN_0040f850(FlockSubdata *flockSubdata,Vector3F *ref_vector)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	float fVar9;
	float fVar10;
	
	ref_vector->y = 0.0;
	(flockSubdata->vector_18).y = 0.0;
	fVar1 = (flockSubdata->vector_18).x;
	fVar7 = (flockSubdata->vector_18).z;
	fVar1 = 1.0 / SQRT(fVar1 * fVar1 + fVar7 * fVar7 + 0.0);
	(flockSubdata->vector_18).x = fVar1 * (flockSubdata->vector_18).x;
	(flockSubdata->vector_18).y = fVar1 * (flockSubdata->vector_18).y;
	(flockSubdata->vector_18).z = fVar1 * (flockSubdata->vector_18).z;
	fVar8 = 1.0 / SQRT(ref_vector->x * ref_vector->x +
										 ref_vector->z * ref_vector->z + ref_vector->y * ref_vector->y);
	fVar10 = fVar8 * ref_vector->x;
	fVar9 = fVar8 * ref_vector->y;
	fVar8 = fVar8 * ref_vector->z;
	ref_vector->x = fVar10;
	ref_vector->y = fVar9;
	ref_vector->z = fVar8;
	fVar1 = (flockSubdata->vector_18).z;
	fVar7 = (flockSubdata->vector_18).y;
	fVar2 = (flockSubdata->vector_18).x;
	fVar3 = (flockSubdata->vector_18).x;
	fVar4 = (flockSubdata->vector_18).x;
	fVar5 = (flockSubdata->vector_18).z;
	fVar6 = (flockSubdata->vector_18).y;
	ref_vector->x = fVar9 * (flockSubdata->vector_18).z - fVar8 * (flockSubdata->vector_18).y;
	ref_vector->y = fVar3 * fVar8 - fVar10 * fVar5;
	ref_vector->z = fVar10 * fVar6 - fVar4 * fVar9;
	fVar1 = (1.0 - (fVar2 * fVar10 + fVar1 * fVar8 + fVar7 * fVar9)) * flockSubdata->Turn1 * 10.0 *
					0.5;
	if ((ushort)((ushort)(ref_vector->y < 0.01) << 8 | (ushort)(ref_vector->y == 0.01) << 0xe) == 0) {
		fVar1 = flockSubdata->float_30 * 9.0 + fVar1;
	}
	else {
		if (0.01 <= ref_vector->y) goto LAB_0040fa04;
		fVar1 = flockSubdata->float_30 * 9.0 - fVar1;
	}
	flockSubdata->float_30 = fVar1 * 0.1;
LAB_0040fa04:
	flockSubdata->float_24 = flockSubdata->float_24 + flockSubdata->float_30;
	flockSubdata->float_2c = -(flockSubdata->float_30 * 9.0);
	return;
}



void __cdecl lego::game::Flocks_FUN_0040fa30(FlockSubdata *flockSubdata)
{
	Matrix4F local_100;
	Matrix4F local_c0;
	Matrix4F local_80;
	Matrix4F local_40;
	
	math::Matrix_RotX(&local_80,flockSubdata->float_28);
	math::Matrix_RotY(&local_100,flockSubdata->float_24);
	math::Matrix_RotZ(&local_c0,flockSubdata->float_2c);
	math::Matrix_Mult(&local_40,&local_100,&local_80);
	math::Matrix_Mult((Matrix4F *)flockSubdata->matrix,&local_40,&local_c0);
	return;
}



void __cdecl
lego::game::Flocks_FUN_0040fac0(undefined4 param_1,FlockSubdata *flockSubdata,float *param_3)
{
	Vector3F *trans;
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	Vector3F vector_b;
	Vector3F vector_a;
	float matrix_b [16];
	float matrix_a [16];
	
	vector_b.x = (flockSubdata->vector_0).x - (flockSubdata->vector_c).x;
	vector_b.y = (flockSubdata->vector_0).y - (flockSubdata->vector_c).y;
	trans = &flockSubdata->vector_c;
	fVar2 = *param_3;
	vector_b.z = (flockSubdata->vector_0).z - (flockSubdata->vector_c).z;
	if (SQRT(vector_b.z * vector_b.z + vector_b.y * vector_b.y + vector_b.x * vector_b.x) < 1e-05) {
		math::Maths_Vector3DRandom(&vector_b);
	}
	Flocks_FUN_0040f7c0(flockSubdata,&vector_b);
	Flocks_FUN_0040f850(flockSubdata,&vector_b);
	Flocks_FUN_0040fa30(flockSubdata);
	fVar1 = flockSubdata->Speed1;
	fVar3 = flockSubdata->matrix[9];
	fVar4 = flockSubdata->matrix[10];
	(flockSubdata->vector_18).x = flockSubdata->matrix[8];
	fVar1 = fVar1 * fVar2;
	(flockSubdata->vector_18).y = fVar3;
	(flockSubdata->vector_18).z = fVar4;
	fVar2 = (flockSubdata->vector_18).y;
	fVar3 = (flockSubdata->vector_18).z;
	trans->x = (flockSubdata->vector_18).x * fVar1 + trans->x;
	(flockSubdata->vector_c).y = (flockSubdata->vector_c).y + fVar2 * fVar1;
	(flockSubdata->vector_c).z = (flockSubdata->vector_c).z + fVar3 * fVar1;
	math::Matrix_Translate((Matrix4F *)matrix_a,trans);
	math::Matrix_Copy((Matrix4F *)matrix_b,(Matrix4F *)flockSubdata->matrix);
	math::Matrix_Mult((Matrix4F *)flockSubdata->matrix,(Matrix4F *)matrix_a,(Matrix4F *)matrix_b);
	return;
}



// out_vector = random_vector() * { x, y, z }

void __cdecl lego::math::Vector3_RandomMultiply(Vector3F *out_vector,float x,float y,float z)
{
	if (out_vector != (Vector3F *)0x0) {
		Maths_Vector3DRandom(out_vector);
		out_vector->x = x * out_vector->x;
		out_vector->y = y * out_vector->y;
		out_vector->z = z * out_vector->z;
	}
	return;
}



void __cdecl lego::game::Flocks_FUN_0040fc30(int *param_1,float *param_2,float *param_3)
{
	float fVar1;
	float x;
	int iVar2;
	float10 extraout_ST0;
	float10 fVar3;
	longlong lVar4;
	longlong lVar5;
	Vector3F local_c;
	
	fVar1 = param_2[0xd];
	lVar4 = __ftol((float10)param_2[0xd] / (float10)param_2[0xe]);
	fVar3 = extraout_ST0;
	if (extraout_ST0 == (float10)0.0) {
		fVar3 = (float10)0.001;
	}
	fVar1 = (float)((float10)1.0 / fVar3 + (float10)fVar1);
	lVar5 = __ftol((float10)fVar1 / (float10)param_2[0xe]);
	if ((int)lVar5 != (int)lVar4 && -1 < (int)lVar5 - (int)lVar4) {
		x = param_2[0x11];
		math::Vector3_RandomMultiply(&local_c,x,x,x);
		iVar2 = *param_1;
		*param_2 = *(float *)(iVar2 + 0xc) + local_c.x;
		param_2[1] = *(float *)(iVar2 + 0x10) + local_c.y;
		param_2[2] = *(float *)(iVar2 + 0x14) + local_c.z;
	}
	param_2[0xd] = fVar1;
	return;
}



void __cdecl FUN_0040fce0(int *param_1,undefined4 *param_2)
{
	undefined4 *puVar1;
	
	puVar1 = (undefined4 *)*param_1;
	*puVar1 = *param_2;
	puVar1[1] = param_2[1];
	puVar1[2] = param_2[2];
	param_1[4] = 1;
	return;
}



void __cdecl lego::game::Flocks_FUN_0040fd10(FlockSubdata *flockSubdata,float param_2)
{
	Flocks_FUN_0040fac0(0,flockSubdata,&param_2);
	return;
}



void __cdecl lego::game::Flocks_FUN_0040fd30(FlockData *flockData,undefined4 param_2)
{
	Flocks_FUN_0040fd10(flockData->flocksSubdata1,param_2);
	Flocks_CallbackForAllSubdata(flockData,Flocks_FUN_0040fac0,&param_2);
	Flocks_CallbackForAllSubdata(flockData,Flocks_FUN_0040fc30,&param_2);
	return;
}



void __cdecl
lego::game::LiveObject_FlocksAddSubdata(FlockData *flockData,FlockSubdata *flockSubdata)
{
	if ((flockData != (FlockData *)0x0) && (flockSubdata != (FlockSubdata *)0x0)) {
		flockSubdata->subdataNext_9c = flockData->flocksSubdata2;
		flockData->flocksSubdata2 = flockSubdata;
		flockData->numSubdata = flockData->numSubdata + 1;
	}
	return;
}



undefined4 * __cdecl lego::unk::Lego_UnkRecurseFreeDoSomething__0040fd90(undefined4 *param_1)
{
	undefined4 *puVar1;
	undefined4 uVar2;
	
	if ((param_1 != (undefined4 *)0x0) && (param_1[2] != 0)) {
		puVar1 = (undefined4 *)param_1[1];
		uVar2 = puVar1[0x27];
		param_1[2] = param_1[2] + -1;
		param_1[1] = uVar2;
		return puVar1;
	}
	return (undefined4 *)0x0;
}



void __cdecl
lego::game::Flocks_CallbackForAllSubdata
					(FlockData *flockData,FlocksCallback *callback,void *context)
{
	FlockSubdata *subdata;
	
	for (subdata = flockData->flocksSubdata2; subdata != (FlockSubdata *)0x0;
			subdata = subdata->subdataNext_9c) {
		(*callback)(flockData,subdata,context);
	}
	return;
}



float10 __cdecl lego::game::Game_RandomFloat_0_1(void)
{
	float10 fVar1;
	
	fVar1 = math::Maths_RandRange(0.0,1.0);
	return fVar1;
}



void __cdecl FUN_0040fe00(undefined4 param_1,int param_2,float *param_3)
{
	float fVar1;
	float fVar2;
	float10 fVar3;
	
	fVar2 = *param_3;
	fVar3 = lego::game::Game_RandomFloat_0_1();
	fVar2 = 1.0 / fVar2;
	fVar1 = (float)((fVar3 + fVar3) - (float10)1.0);
	*(float *)(param_2 + 0x3c) =
			 fVar2 * fVar1 * *(float *)(param_2 + 0x4c) + *(float *)(param_2 + 0x4c);
	*(float *)(param_2 + 0x44) =
			 fVar2 * fVar1 * *(float *)(param_2 + 0x54) + *(float *)(param_2 + 0x54);
	*(float *)(param_2 + 0x38) =
			 fVar2 * fVar1 * *(float *)(param_2 + 0x48) + *(float *)(param_2 + 0x48);
	return;
}



void __cdecl FUN_0040fe80(int param_1,undefined4 param_2)
{
	lego::game::Flocks_CallbackForAllSubdata((FlockData *)param_1,FUN_0040fe00,&param_2);
	return;
}



void __cdecl
lego::game::Flocks_SetParameters1(FlockData *param_1,float turn,float speed,float tightness)
{
	param_1->flocksSubdata1->Turn1 = turn;
	param_1->flocksSubdata1->Speed1 = speed;
	param_1->flocksSubdata1->Tightness1 = tightness;
	return;
}



void __cdecl lego::game::Flocks_SetParametersFromGlobals(undefined4 param_1,FlockSubdata *param_2)
{
	param_2->Turn2 = globals::g_Flocks_Turn;
	param_2->Turn1 = globals::g_Flocks_Turn;
	param_2->Speed2 = globals::g_Flocks_Speed;
	param_2->Speed1 = globals::g_Flocks_Speed;
	param_2->Tightness2 = globals::g_Flocks_Tightness;
	param_2->Tightness1 = globals::g_Flocks_Tightness;
	param_2->GoalUpdate2 = globals::g_Flocks_GoalUpdate;
	param_2->GoalUpdate1 = globals::g_Flocks_GoalUpdate;
	return;
}



void __cdecl
FUN_0040ff10(FlockData *flockData,float param_2,float param_3,float param_4,float param_5)
{
	lego::globals::g_Flocks_Speed = param_3;
	lego::globals::g_Flocks_Turn = param_2;
	lego::globals::g_Flocks_Tightness = param_4;
	lego::globals::g_Flocks_GoalUpdate = param_5;
	lego::game::Flocks_CallbackForAllSubdata
						(flockData,lego::game::Flocks_SetParametersFromGlobals,(void *)0x0);
	return;
}



void __cdecl lego::game::Flocks_FUN_0040ff50(FlockData *param_1,undefined4 *param_2)
{
	FlockSubdata *pFVar1;
	
	if ((param_1 != (FlockData *)0x0) && (param_2 != (undefined4 *)0x0)) {
		param_1->hasVector1 = 1;
		pFVar1 = param_1->flocksSubdata1;
		(pFVar1->vector_c).x = (float)*param_2;
		(pFVar1->vector_c).y = (float)param_2[1];
		(pFVar1->vector_c).z = (float)param_2[2];
	}
	return;
}



void __cdecl FUN_0040ff80(undefined4 param_1,int param_2,undefined4 *param_3)
{
	*(undefined4 *)(param_2 + 0xc) = *param_3;
	*(undefined4 *)(param_2 + 0x10) = param_3[1];
	*(undefined4 *)(param_2 + 0x14) = param_3[2];
	return;
}



void __cdecl FUN_0040ffa0(int param_1,void *param_2)
{
	lego::game::Flocks_CallbackForAllSubdata((FlockData *)param_1,FUN_0040ff80,param_2);
	return;
}



void __cdecl FUN_0040ffc0(undefined4 param_1,undefined4 *param_2,undefined4 *param_3)
{
	*param_2 = *param_3;
	param_2[1] = param_3[1];
	param_2[2] = param_3[2];
	return;
}



void __cdecl lego::game::Flocks_FUN_0040ffe0(FlockData *param_1,void *param_2)
{
	Flocks_CallbackForAllSubdata(param_1,FUN_0040ffc0,param_2);
	return;
}



void __cdecl FUN_00410000(undefined4 param_1,float *param_2,float *param_3)
{
	float *pfVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	float fVar9;
	float fVar10;
	float fVar11;
	float fVar12;
	
	fVar2 = *param_3;
	pfVar1 = param_2 + 3;
	fVar3 = *param_2;
	fVar4 = *pfVar1;
	fVar5 = param_2[1];
	fVar6 = param_2[4];
	fVar7 = param_2[5];
	fVar8 = param_2[2];
	lego::game::Flocks_FUN_0040fac0(param_1,(FlockSubdata *)param_2,param_3);
	fVar11 = fVar3 - fVar4;
	fVar9 = fVar5 - fVar6;
	fVar12 = fVar8 - fVar7;
	fVar2 = param_2[0x10] * fVar2;
	fVar10 = SQRT(fVar12 * fVar12 + fVar9 * fVar9 + fVar11 * fVar11);
	if (fVar2 <= fVar10) {
		fVar10 = 1.0 / fVar10;
		*pfVar1 = fVar10 * fVar11 * fVar2 + fVar4;
		param_2[4] = fVar10 * fVar9 * fVar2 + fVar6;
		param_2[5] = fVar10 * fVar12 * fVar2 + fVar7;
	}
	else {
		*pfVar1 = *param_2;
		param_2[4] = param_2[1];
		param_2[5] = param_2[2];
	}
	*param_2 = fVar3;
	param_2[0x22] = *pfVar1;
	param_2[0x24] = param_2[5];
	param_2[1] = fVar5;
	param_2[2] = fVar8;
	param_2[0x23] = param_2[4];
	return;
}



void __cdecl FUN_00410160(undefined4 param_1,float *param_2,undefined4 *param_3)
{
	if (((param_2[3] == *param_2) && (param_2[4] == param_2[1])) && (param_2[5] == param_2[2])) {
		lego::res::Container_Hide((Container *)param_2[0x26],1);
		return;
	}
	*param_3 = 0;
	return;
}



undefined4 __cdecl FUN_004101b0(int param_1)
{
	undefined4 local_4;
	
	local_4 = 1;
	lego::game::Flocks_CallbackForAllSubdata((FlockData *)param_1,FUN_00410160,&local_4);
	return local_4;
}



char * __cdecl lego::util::replaceTextSpaces(char *str)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	undefined4 *puVar4;
	char *pcVar5;
	undefined4 *puVar6;
	
	uVar2 = 0xffffffff;
	pcVar5 = str;
	do {
		if (uVar2 == 0) break;
		uVar2 = uVar2 - 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	if (0xff < ~uVar2 - 1) {
		return str;
	}
	uVar2 = 0xffffffff;
	do {
		pcVar5 = str;
		if (uVar2 == 0) break;
		uVar2 = uVar2 - 1;
		pcVar5 = str + 1;
		cVar1 = *str;
		str = pcVar5;
	} while (cVar1 != '\0');
	uVar2 = ~uVar2;
	puVar4 = (undefined4 *)(pcVar5 + -uVar2);
	puVar6 = (undefined4 *)CHAR_ARRAY_004dc748;
	for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
		*puVar6 = *puVar4;
		puVar4 = puVar4 + 1;
		puVar6 = puVar6 + 1;
	}
	uVar3 = 0;
	for (uVar2 = uVar2 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {
		*(undefined *)puVar6 = *(undefined *)puVar4;
		puVar4 = (undefined4 *)((int)puVar4 + 1);
		puVar6 = (undefined4 *)((int)puVar6 + 1);
	}
	do {
		if (CHAR_ARRAY_004dc748[uVar3] == '_') {
			CHAR_ARRAY_004dc748[uVar3] = ' ';
		}
		uVar3 = uVar3 + 1;
	} while (uVar3 < 0x100);
	return CHAR_ARRAY_004dc748;
}



void __cdecl lego::unk::Lego_UnkPrintf_FUN_00410250(ImageFont *font,int x,int y,char *format,...)
{
	ImageFont **ppIVar1;
	uint uVar2;
	char (*msg) [1024];
	
	if (format == (char *)0x0) {
		uVar2 = 0;
		if (UINT_004dc8d0 != 0) {
			ppIVar1 = PTRImageFont_ARRAY_004d8b08;
			msg = CHAR_ARRAY_ARRAY_004d8b48;
			do {
				image::Font_PrintF(*ppIVar1,INT_ARRAY_004d88c8[uVar2],INT_ARRAY_004dc850[uVar2],(char *)msg)
				;
				uVar2 = uVar2 + 1;
				msg = msg[1];
				ppIVar1 = ppIVar1 + 1;
			} while (uVar2 < UINT_004dc8d0);
		}
		UINT_004dc8d0 = 0;
		return;
	}
	if (UINT_004dc8d0 < 0xf) {
		std::vsprintf((char *)CHAR_ARRAY_ARRAY_004d8b48[UINT_004dc8d0],format,&stack0x00000014);
		INT_ARRAY_004d88c8[UINT_004dc8d0] = x;
		INT_ARRAY_004dc850[UINT_004dc8d0] = y;
		PTRImageFont_ARRAY_004d8b08[UINT_004dc8d0] = font;
		UINT_004dc8d0 = UINT_004dc8d0 + 1;
	}
	return;
}



void __cdecl lego::front::MainMenuFull_TriggerShowCredits(void)
{
	main::Main_ShowCreditsFiles
						(globals::g_Game.CreditsTextFile,globals::g_Game.bmpRSFont,
						 globals::g_Game.CreditsBackAVI);
	return;
}



void __cdecl FUN_00410320(void)
{
	uint uVar1;
	
	if (lego::globals::g_MenuWipeResource != (Container *)0x0) {
		FLOAT_005584f4 = 0.0;
		FLAGS_005584f0 = FLAGS_005584f0 & 0xffffff00 | FLAGS_005584f0 & 0xff | 1 | 2;
		uVar1 = lego::main::Main_GetTime();
		FLOAT_005584f8 = (float)(ulonglong)uVar1;
		lego::snd::Audio_AddToSoundQueue1(SFX_ROCKWIPE,0);
	}
	return;
}



void __cdecl lego::unk::Lego_UnsetFlag3_005584f0(void)
{
	FLAGS_005584f0 = FLAGS_005584f0 & 0xfffffffc;
	return;
}



ImageStruct_10 * __cdecl lego::unk::ImageStruct10_GetByName(char *struct10Name)
{
	ImageStruct_10 **ppIVar1;
	int iVar2;
	ImageStruct_10 *pIVar3;
	
	pIVar3 = globals::g_ImageStruct10_NEXT;
	if (globals::g_ImageStruct10_NEXT == (ImageStruct_10 *)0x0) {
		return (ImageStruct_10 *)0x0;
	}
	do {
		iVar2 = std::_stricmp(struct10Name,pIVar3->name);
		if (iVar2 == 0) {
			return pIVar3;
		}
		ppIVar1 = &pIVar3->next;
		pIVar3 = *ppIVar1;
	} while (*ppIVar1 != (ImageStruct_10 *)0x0);
	return (ImageStruct_10 *)0x0;
}



ImageStruct_10 * __cdecl lego::unk::ImageStruct10_Next(char *struct10Name)
{
	char cVar1;
	ImageStruct_10 *pIVar2;
	undefined4 *puVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	
	if ((struct10Name == (char *)0x0) || (*struct10Name == '\0')) {
		pIVar2 = (ImageStruct_10 *)0x0;
	}
	else {
		pIVar2 = ImageStruct10_GetByName(struct10Name);
		if (pIVar2 == (ImageStruct_10 *)0x0) {
			pIVar2 = (ImageStruct_10 *)std::malloc(0x10);
			uVar4 = 0xffffffff;
			pcVar7 = struct10Name;
			do {
				if (uVar4 == 0) break;
				uVar4 = uVar4 - 1;
				cVar1 = *pcVar7;
				pcVar7 = pcVar7 + 1;
			} while (cVar1 != '\0');
			puVar3 = (undefined4 *)std::malloc(~uVar4);
			uVar4 = 0xffffffff;
			pIVar2->name = (char *)puVar3;
			do {
				pcVar7 = struct10Name;
				if (uVar4 == 0) break;
				uVar4 = uVar4 - 1;
				pcVar7 = struct10Name + 1;
				cVar1 = *struct10Name;
				struct10Name = pcVar7;
			} while (cVar1 != '\0');
			uVar4 = ~uVar4;
			puVar6 = (undefined4 *)(pcVar7 + -uVar4);
			for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
				*puVar3 = *puVar6;
				puVar6 = puVar6 + 1;
				puVar3 = puVar3 + 1;
			}
			for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
				*(undefined *)puVar3 = *(undefined *)puVar6;
				puVar6 = (undefined4 *)((int)puVar6 + 1);
				puVar3 = (undefined4 *)((int)puVar3 + 1);
			}
			pIVar2->image = (ImageBMP *)0x0;
			pIVar2->next = globals::g_ImageStruct10_NEXT;
			pIVar2->font = (ImageFont *)0x0;
			globals::g_ImageStruct10_NEXT = pIVar2;
			return pIVar2;
		}
	}
	return pIVar2;
}



ImageBMP * __cdecl lego::unk::ImageStruct10_LoadImage(char *struct10Name)
{
	ImageStruct_10 *pIVar1;
	ImageBMP *pIVar2;
	
	if ((struct10Name != (char *)0x0) && (*struct10Name != '\0')) {
		pIVar1 = ImageStruct10_Next(struct10Name);
		if (pIVar1->image == (ImageBMP *)0x0) {
			pIVar2 = image::Image_LoadBMPScaled(struct10Name,0,0);
			pIVar1->image = pIVar2;
		}
		return pIVar1->image;
	}
	return (ImageBMP *)0x0;
}



ImageFont * __cdecl lego::unk::ImageStruct10_LoadFont(char *struct10Name)
{
	ImageStruct_10 *pIVar1;
	ImageFont *pIVar2;
	
	if ((struct10Name != (char *)0x0) && (*struct10Name != '\0')) {
		pIVar1 = ImageStruct10_Next(struct10Name);
		if (pIVar1->font == (ImageFont *)0x0) {
			pIVar2 = image::Font_Load(struct10Name);
			pIVar1->font = pIVar2;
		}
		return pIVar1->font;
	}
	return (ImageFont *)0x0;
}



char * __cdecl std::_strdup2(char *str)
{
	char cVar1;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	if (str == (char *)0x0) {
		return (char *)(undefined4 *)0x0;
	}
	uVar3 = 0xffffffff;
	pcVar6 = str;
	do {
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		cVar1 = *pcVar6;
		pcVar6 = pcVar6 + 1;
	} while (cVar1 != '\0');
	puVar2 = (undefined4 *)malloc(~uVar3);
	if (puVar2 == (undefined4 *)0x0) {
		return (char *)0x0;
	}
	uVar3 = 0xffffffff;
	do {
		pcVar6 = str;
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		pcVar6 = str + 1;
		cVar1 = *str;
		str = pcVar6;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	puVar5 = (undefined4 *)(pcVar6 + -uVar3);
	puVar7 = puVar2;
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
		*puVar7 = *puVar5;
		puVar5 = puVar5 + 1;
		puVar7 = puVar7 + 1;
	}
	for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
		*(undefined *)puVar7 = *(undefined *)puVar5;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
		puVar7 = (undefined4 *)((int)puVar7 + 1);
	}
	return (char *)puVar2;
}



undefined4 * __cdecl
FUN_00410520(undefined4 param_1,char *param_2,char *param_3,undefined4 param_4,undefined4 param_5,
						undefined4 param_6,undefined4 param_7,undefined4 param_8,undefined4 param_9,
						undefined4 param_10,undefined4 param_11,undefined4 param_12,undefined4 param_13,
						undefined4 param_14)
{
	undefined4 *puVar1;
	char *pcVar2;
	int iVar3;
	undefined4 *puVar4;
	
	puVar1 = (undefined4 *)std::malloc(0x5c);
	puVar4 = puVar1;
	for (iVar3 = 0x17; iVar3 != 0; iVar3 = iVar3 + -1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	pcVar2 = std::_strdup2(param_2);
	puVar1[8] = pcVar2;
	pcVar2 = std::_strdup2(param_3);
	puVar1[9] = pcVar2;
	puVar1[0xb] = param_4;
	puVar1[10] = param_1;
	puVar1[0xc] = param_5;
	puVar1[0xe] = param_7;
	puVar1[0xd] = param_6;
	puVar1[0xf] = param_8;
	puVar1[0x11] = param_10;
	puVar1[0x10] = param_9;
	puVar1[0x12] = param_11;
	puVar1[0x15] = param_13;
	puVar1[0x14] = param_12;
	puVar1[0x13] = 0;
	puVar1[0x16] = param_14;
	return puVar1;
}



void __cdecl lego::front::Menu_FreeSubMenuItem_Count(int *param_1)
{
	int *piVar1;
	uint uVar2;
	int *buffer;
	int iVar3;
	int iVar4;
	int iVar5;
	
	buffer = param_1;
	iVar4 = 0;
	if (param_1 != (int *)0x0) {
		if ((void *)param_1[8] != (void *)0x0) {
			std::free((void *)param_1[8]);
		}
		if ((void *)param_1[9] != (void *)0x0) {
			std::free((void *)param_1[9]);
		}
		if (*param_1 != 0) {
			piVar1 = param_1 + 7;
			param_1 = (int *)0x0;
			if (0 < *piVar1) {
				do {
					uVar2 = *(uint *)(*buffer + iVar4);
					if ((uVar2 & 1) == 0) {
						if ((uVar2 & 2) != 0) {
							iVar5 = iVar4 + 8;
							iVar3 = 3;
							do {
								image::Image_Remove(*(ImageBMP **)(*buffer + iVar5));
								iVar5 = iVar5 + 4;
								iVar3 = iVar3 + -1;
							} while (iVar3 != 0);
						}
					}
					else {
						std::free(*(void **)(*buffer + iVar4 + 4));
					}
					param_1 = (int *)((int)param_1 + 1);
					iVar4 = iVar4 + 0x20;
				} while ((int)param_1 < buffer[7]);
			}
			std::free((void *)*buffer);
		}
		std::free(buffer);
	}
	return;
}



void __cdecl
FUN_00410670(int **param_1,byte *param_2,int param_3,undefined4 *param_4,int param_5,int param_6,
						int param_7)
{
	int *piVar1;
	int *memblock;
	int **ppiVar2;
	int *piVar3;
	void *pvVar4;
	int iVar5;
	char *pcVar6;
	ImageBMP *pIVar7;
	uint uVar8;
	int **ppiVar9;
	int **ppiVar10;
	int iVar11;
	int *apiStack24 [6];
	
	ppiVar2 = param_1;
	if (*param_1 == (int *)0x0) {
		piVar3 = (int *)std::malloc(((int)param_1[7] + 1) * 0x20);
		iVar11 = 0;
		do {
			pvVar4 = std::malloc((int)param_1[7] * 4 + 4);
			piVar1 = param_1[7];
			*(void **)((int)apiStack24 + iVar11) = pvVar4;
			pvVar4 = std::malloc((int)piVar1 * 4 + 4);
			*(void **)((int)apiStack24 + iVar11 + 0xc) = pvVar4;
			iVar11 = iVar11 + 4;
		} while (iVar11 < 0xc);
	}
	else {
		piVar3 = (int *)std::realloc(*param_1,((int)param_1[7] + 1) * 0x20);
		ppiVar10 = param_1 + 4;
		iVar11 = 0;
		do {
			pvVar4 = std::realloc(ppiVar10[-3],(int)param_1[7] * 4 + 4);
			piVar1 = param_1[7];
			memblock = *ppiVar10;
			*(void **)((int)apiStack24 + iVar11) = pvVar4;
			pvVar4 = std::realloc(memblock,(int)piVar1 * 4 + 4);
			*(void **)((int)apiStack24 + iVar11 + 0xc) = pvVar4;
			iVar11 = iVar11 + 4;
			ppiVar10 = ppiVar10 + 1;
		} while (iVar11 < 0xc);
	}
	if (piVar3 != (int *)0x0) {
		*param_1 = piVar3;
		piVar3[(int)param_1[7] * 8 + 1] = 0;
		ppiVar10 = param_1 + 4;
		(*param_1)[(int)param_1[7] * 8] = -(uint)(param_3 != 0) & 4;
		iVar11 = 0;
		ppiVar9 = ppiVar10;
		do {
			iVar5 = iVar11 + 4;
			ppiVar9[-3] = *(int **)((int)apiStack24 + iVar11);
			*ppiVar9 = *(int **)((int)apiStack24 + iVar11 + 0xc);
			ppiVar9 = ppiVar9 + 1;
			iVar11 = iVar5;
		} while (iVar5 < 0xc);
		if ((param_2 != (byte *)0x0) &&
			 (pcVar6 = lego::util::Util_StrIStr((char *)param_2,".bmp"), pcVar6 != (char *)0x0)) {
			lego::util::Util_Tokenise((char *)param_2,(char **)(apiStack24 + 3),",");
			iVar11 = 0;
			(*param_1)[(int)param_1[7] * 8] = (*param_1)[(int)param_1[7] * 8] | 2;
			param_1 = apiStack24 + 3;
			do {
				pIVar7 = lego::unk::ImageStruct10_LoadImage((char *)*param_1);
				(*ppiVar2)[iVar11 + (int)ppiVar2[7] * 8 + 2] = (int)pIVar7;
				pIVar7 = (ImageBMP *)(*ppiVar2)[iVar11 + (int)ppiVar2[7] * 8 + 2];
				if (pIVar7 != (ImageBMP *)0x0) {
					lego::image::Image_SetPenZeroTrans(pIVar7);
				}
				iVar11 = iVar11 + 1;
				ppiVar10[-3][(int)ppiVar2[7]] = pIVar7->width;
				piVar3 = *ppiVar10;
				ppiVar10 = ppiVar10 + 1;
				piVar3[(int)ppiVar2[7]] = pIVar7->height;
				param_1 = param_1 + 1;
			} while (iVar11 < 3);
			(*ppiVar2)[(int)ppiVar2[7] * 8 + 5] = param_5;
			(*ppiVar2)[(int)ppiVar2[7] * 8 + 6] = param_6;
			(*ppiVar2)[(int)ppiVar2[7] * 8 + 7] = param_7;
			ppiVar2[7] = (int *)((int)ppiVar2[7] + 1);
			return;
		}
		(*param_1)[(int)param_1[7] * 8] = (*param_1)[(int)param_1[7] * 8] | 1;
		pcVar6 = std::_strdup2((char *)param_2);
		(*param_1)[(int)param_1[7] * 8 + 1] = (int)pcVar6;
		(*param_1)[(int)param_1[7] * 8 + 5] = param_5;
		(*param_1)[(int)param_1[7] * 8 + 6] = param_6;
		(*param_1)[(int)param_1[7] * 8 + 7] = param_7;
		uVar8 = lego::image::FontX_GetStringWidth((ImageFont *)param_4,(char *)param_2);
		param_1[3][(int)param_1[7]] = uVar8;
		param_1[2][(int)param_1[7]] = param_1[3][(int)param_1[7]];
		param_1[1][(int)param_1[7]] = param_1[2][(int)param_1[7]];
		uVar8 = lego::image::Font_GetHeight((ImageFont *)param_4);
		param_1[6][(int)param_1[7]] = uVar8;
		param_1[5][(int)param_1[7]] = param_1[6][(int)param_1[7]];
		(*ppiVar10)[(int)param_1[7]] = param_1[5][(int)param_1[7]];
		param_1[7] = (int *)((int)param_1[7] + 1);
	}
	return;
}



int * __cdecl
lego::front::Menu_SubMenuCycle_FUN_00410940
					(uint param_1,int param_2,int param_3,int param_4,int param_5)
{
	int *piVar1;
	undefined4 *puVar2;
	uint uVar3;
	int iVar4;
	
	piVar1 = (int *)std::malloc(0x1c);
	if (piVar1 == (int *)0x0) {
		return (int *)0x0;
	}
	puVar2 = (undefined4 *)std::malloc(param_1 * 4);
	*piVar1 = (int)puVar2;
	if (puVar2 == (undefined4 *)0x0) {
		Menu_FreeSubMenuItem_Cycle(piVar1);
		return (int *)0x0;
	}
	for (uVar3 = param_1 & 0x3fffffff; uVar3 != 0; uVar3 = uVar3 - 1) {
		*puVar2 = 0;
		puVar2 = puVar2 + 1;
	}
	for (iVar4 = 0; iVar4 != 0; iVar4 = iVar4 + -1) {
		*(undefined *)puVar2 = 0;
		puVar2 = (undefined4 *)((int)puVar2 + 1);
	}
	piVar1[3] = param_2;
	piVar1[6] = param_5;
	piVar1[1] = param_1;
	piVar1[2] = 0;
	piVar1[4] = param_3;
	piVar1[5] = param_4;
	return piVar1;
}



void __cdecl lego::front::Menu_SubMenu_FUN_004109d0(int *param_1,char *param_2)
{
	char *pcVar1;
	
	if (((param_1 != (int *)0x0) && (*param_1 != 0)) && (param_1[2] < param_1[1])) {
		pcVar1 = std::_strdup2(param_2);
		*(char **)(*param_1 + param_1[2] * 4) = pcVar1;
		if (*(int *)(*param_1 + param_1[2] * 4) != 0) {
			param_1[2] = param_1[2] + 1;
		}
	}
	return;
}



void __cdecl lego::front::Menu_FreeSubMenuItem_Cycle(int *param_1)
{
	void *buffer;
	int iVar1;
	
	if (param_1 != (int *)0x0) {
		if (*param_1 != 0) {
			iVar1 = 0;
			if (0 < param_1[2]) {
				do {
					buffer = *(void **)(*param_1 + iVar1 * 4);
					if (buffer != (void *)0x0) {
						std::free(buffer);
					}
					iVar1 = iVar1 + 1;
				} while (iVar1 < param_1[2]);
			}
			std::free((void *)*param_1);
		}
		std::free(param_1);
	}
	return;
}



int __cdecl lego::input::Input_GetMousePositionX(void)
{
	return globs::INPUT.msx;
}



int __cdecl lego::input::Input_GetMousePositionY(void)
{
	return globs::INPUT.msy;
}



BOOL __cdecl lego::input::Input_GetBool_0076bb3c(void)
{
	return globs::INPUT.mslb;
}



void __cdecl
lego::front::Menu_SubMenu_CreateItemC_FUN_00410a90
					(undefined4 param_1,BOOL param_2,undefined4 param_3)
{
	undefined4 *puVar1;
	
	puVar1 = (undefined4 *)std::malloc(0xc);
	if (puVar1 == (undefined4 *)0x0) {
		return;
	}
	*puVar1 = param_1;
	puVar1[1] = param_2;
	puVar1[2] = param_3;
	return;
}



undefined4 * __cdecl
lego::front::Menu_CreateRealSlider
					(undefined4 param_1,float lowLimit,float highLimit,float step,int x2,int y2,
					undefined4 param_7)
{
	undefined4 *puVar1;
	
	if ((ushort)((ushort)(highLimit < lowLimit) << 8 | (ushort)(highLimit == lowLimit) << 0xe) != 0) {
		return (undefined4 *)0x0;
	}
	puVar1 = (undefined4 *)std::malloc(0x1c);
	if (puVar1 == (undefined4 *)0x0) {
		return (undefined4 *)0x0;
	}
	*puVar1 = param_1;
	puVar1[1] = lowLimit;
	puVar1[2] = highLimit;
	puVar1[3] = step;
	puVar1[4] = x2;
	puVar1[5] = y2;
	puVar1[6] = param_7;
	return puVar1;
}



undefined4 * __cdecl
lego::front::Menu_SubMenuItem_FUN_00410b20
					(undefined4 param_1,int param_2,int param_3,undefined4 param_4,undefined4 param_5,
					undefined4 param_6,undefined4 param_7,undefined4 param_8,undefined4 param_9,
					undefined4 param_10,undefined4 param_11,undefined4 param_12,undefined4 param_13,
					undefined4 param_14)
{
	undefined4 *puVar1;
	
	if (param_3 <= param_2) {
		return (undefined4 *)0x0;
	}
	puVar1 = (undefined4 *)std::malloc(0x38);
	if (puVar1 == (undefined4 *)0x0) {
		return (undefined4 *)0x0;
	}
	*puVar1 = param_1;
	puVar1[3] = param_4;
	puVar1[4] = param_5;
	puVar1[5] = param_6;
	puVar1[6] = param_7;
	puVar1[7] = param_8;
	puVar1[8] = param_9;
	puVar1[9] = param_10;
	puVar1[10] = param_11;
	puVar1[0xb] = param_12;
	puVar1[1] = param_2;
	puVar1[2] = param_3;
	puVar1[0xc] = param_13;
	puVar1[0xd] = param_14;
	return puVar1;
}



void __cdecl lego::front::Menu_FreeSubMenuItem(SubMenuItem *menuItem)
{
	if (menuItem != (SubMenuItem *)0x0) {
		if (menuItem->banner != (char *)0x0) {
			std::free(menuItem->banner);
		}
		switch(menuItem->itemType) {
		case MENUITEM_CYCLE:
			Menu_FreeSubMenuItem_Cycle((int *)menuItem->itemData);
			std::free(menuItem);
			return;
		case MENUITEM_TRIGGER:
			util::freeNonNull(menuItem->itemData);
			std::free(menuItem);
			return;
		case MENUITEM_TEXTINPUT:
			util::freeNonNull(menuItem->itemData);
			std::free(menuItem);
			return;
		case MENUITEM_SLIDER:
			util::freeNonNull(menuItem->itemData);
			std::free(menuItem);
			return;
		case MENUITEM_REALSLIDER:
			util::freeNonNull(menuItem->itemData);
			std::free(menuItem);
			return;
		case MENUITEM__COUNT:
			Menu_FreeSubMenuItem_Count((int *)menuItem->itemData);
		}
		std::free(menuItem);
	}
	return;
}



SubMenuItem * __cdecl
lego::front::Menu_CreateItem3C
					(char *banner,ImageFont *loFont,ImageFont *hiFont,int x1,int y1,MenuItemType itemType,
					int param_7,void *param_8,undefined4 param_9)
{
	char cVar1;
	SubMenuItem *pSVar2;
	char *pcVar3;
	int iVar4;
	uint uVar5;
	SubMenuItem *pSVar6;
	
	if (banner == (char *)0x0) {
		return (SubMenuItem *)0x0;
	}
	pSVar2 = (SubMenuItem *)std::malloc(0x3c);
	if (pSVar2 == (SubMenuItem *)0x0) {
		return (SubMenuItem *)0x0;
	}
	pSVar6 = pSVar2;
	for (iVar4 = 0xf; iVar4 != 0; iVar4 = iVar4 + -1) {
		pSVar6->banner = (char *)0x0;
		pSVar6 = (SubMenuItem *)&pSVar6->length;
	}
	uVar5 = 0xffffffff;
	pcVar3 = banner;
	do {
		if (uVar5 == 0) break;
		uVar5 = uVar5 - 1;
		cVar1 = *pcVar3;
		pcVar3 = pcVar3 + 1;
	} while (cVar1 != '\0');
	pSVar2->length = ~uVar5 - 1;
	pcVar3 = std::_strdup2(banner);
	pSVar2->itemType = itemType;
	pSVar2->banner = pcVar3;
	(pSVar2->point1).x = x1;
	pSVar2->itemData = param_8;
	pSVar2->field_38 = param_9;
	pSVar2->LoFont = loFont;
	pSVar2->HiFont = hiFont;
	(pSVar2->point1).y = y1;
	if (((param_7 != 0) && (loFont != (ImageFont *)0x0)) && (hiFont != (ImageFont *)0x0)) {
		uVar5 = image::FontX_GetStringWidth(loFont,banner);
		pSVar2->field_20 = -(uVar5 >> 1);
		uVar5 = image::FontX_GetStringWidth(hiFont,banner);
		pSVar2->field_24 = -(uVar5 >> 1);
		return pSVar2;
	}
	pSVar2->field_20 = 0;
	pSVar2->field_24 = 0;
	return pSVar2;
}



undefined4 * __cdecl
lego::front::Menu_SubMenu_FUN_00410d50
					(char *param_1,char *param_2,char *param_3,int param_4,int param_5,char *param_6,
					char *param_7,char *param_8,int param_9,char *param_10,char *param_11)
{
	char cVar1;
	char **ppcVar2;
	char *pcVar3;
	ImageBMP *pIVar4;
	BOOL BVar5;
	int iVar6;
	uint uVar7;
	char **ppcVar8;
	
	if (param_1 != (char *)0x0) {
		ppcVar2 = (char **)std::malloc(0x3c);
		if (ppcVar2 != (char **)0x0) {
			ppcVar8 = ppcVar2;
			for (iVar6 = 0xf; iVar6 != 0; iVar6 = iVar6 + -1) {
				*ppcVar8 = (char *)0x0;
				ppcVar8 = ppcVar8 + 1;
			}
			uVar7 = 0xffffffff;
			pcVar3 = param_1;
			do {
				if (uVar7 == 0) break;
				uVar7 = uVar7 - 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar3 + 1;
			} while (cVar1 != '\0');
			ppcVar2[1] = (char *)(~uVar7 - 1);
			pcVar3 = std::_strdup2(param_1);
			*ppcVar2 = pcVar3;
			ppcVar2[2] = param_3;
			ppcVar2[3] = param_2;
			pIVar4 = image::Image_LoadBMPScaled((char *)param_4,0,0);
			ppcVar2[0xb] = (char *)pIVar4;
			if (pIVar4 != (ImageBMP *)0x0) {
				pIVar4 = image::Image_LoadBMPScaled((char *)param_5,0,0);
				ppcVar2[0xc] = (char *)pIVar4;
				if (pIVar4 != (ImageBMP *)0x0) {
					ppcVar2[10] = (char *)0x1;
				}
				ppcVar2[4] = param_11;
				ppcVar2[5] = param_8;
				ppcVar2[6] = param_6;
				ppcVar2[7] = param_7;
				BVar5 = ToolTip_GetType(param_10,(int *)(ppcVar2 + 0xd));
				if (BVar5 == 0) {
					ppcVar2[0xd] = (char *)0x0;
				}
				if (((param_9 != 0) && (ppcVar2[0xb] != (char *)0x0)) && (ppcVar2[0xc] != (char *)0x0)) {
					ppcVar2[8] = (char *)-(*(uint *)(ppcVar2[0xb] + 4) >> 1);
					ppcVar2[9] = (char *)-(*(uint *)(ppcVar2[0xc] + 4) >> 1);
					return ppcVar2;
				}
				ppcVar2[8] = (char *)0x0;
				ppcVar2[9] = (char *)0x0;
				return ppcVar2;
			}
		}
	}
	return (char **)0x0;
}



void __cdecl lego::front::Menu_FreeSubMenu(SubMenu *submenu)
{
	SubMenuItem *menuItem;
	int iVar1;
	
	if (submenu != (SubMenu *)0x0) {
		if (submenu->ptr_0 != (void *)0x0) {
			std::free(submenu->ptr_0);
		}
		if (submenu->ptr_4 != (void *)0x0) {
			std::free(submenu->ptr_4);
		}
		if (submenu->Items != (SubMenuItem *)0x0) {
			std::free(submenu->Items);
		}
		iVar1 = 0;
		if (0 < submenu->ItemCount) {
			do {
				menuItem = (SubMenuItem *)(&submenu->Items->banner)[iVar1];
				if (menuItem != (SubMenuItem *)0x0) {
					Menu_FreeSubMenuItem(menuItem);
				}
				iVar1 = iVar1 + 1;
			} while (iVar1 < submenu->ItemCount);
		}
		if (submenu->MenuImage != (ImageBMP *)0x0) {
			image::Image_Remove(submenu->MenuImage);
		}
		std::free(submenu);
	}
	return;
}



BOOL __cdecl lego::front::Menu_LoadMenuImage(SubMenu *param_1,char *param_2,BOOL isLightImage)
{
	char cVar1;
	ImageBMP *pIVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	undefined4 *puVar8;
	float10 fVar9;
	char *local_410;
	char *local_40c;
	char *local_408;
	char *local_404;
	undefined4 local_400 [256];
	
	local_410 = (char *)0x0;
	local_40c = (char *)0x0;
	local_408 = (char *)0x0;
	local_404 = (char *)0x0;
	if (param_2 == (char *)0x0) {
		return 0;
	}
	uVar4 = 0xffffffff;
	do {
		pcVar7 = param_2;
		if (uVar4 == 0) break;
		uVar4 = uVar4 - 1;
		pcVar7 = param_2 + 1;
		cVar1 = *param_2;
		param_2 = pcVar7;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar6 = (undefined4 *)(pcVar7 + -uVar4);
	puVar8 = local_400;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
		*puVar8 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar8 = puVar8 + 1;
	}
	for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
		*(undefined *)puVar8 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar8 = (undefined4 *)((int)puVar8 + 1);
	}
	uVar4 = util::Util_Tokenise((char *)local_400,&local_410,":");
	if (2 < uVar4) {
		param_1->uint_34 = param_1->uint_34 | 1;
		fVar9 = std::atof(local_40c);
		*(float *)&param_1->field_0x38 = (float)fVar9;
		fVar9 = std::atof(local_408);
		*(float *)&param_1->field_0x3c = (float)fVar9;
	}
	if (isLightImage != 0) {
		pIVar2 = unk::ImageStruct10_LoadImage(local_410);
		param_1->MenuImage = pIVar2;
		if ((pIVar2 != (ImageBMP *)0x0) && (uVar4 == 4)) {
			iVar3 = std::atoi(local_404);
			if (iVar3 == 1) {
				image::Image_SetPenZeroTrans(param_1->MenuImage);
			}
		}
		return (uint)(param_1->MenuImage != (ImageBMP *)0x0);
	}
	pIVar2 = unk::ImageStruct10_LoadImage(local_410);
	param_1->MenuImageDark = pIVar2;
	if ((pIVar2 != (ImageBMP *)0x0) && (uVar4 == 4)) {
		iVar3 = std::atoi(local_404);
		if (iVar3 == 1) {
			image::Image_SetupTrans(param_1->MenuImageDark,0.0,0.0,0.0,0.0,0.0,0.0);
		}
	}
	return (uint)(param_1->MenuImageDark != (ImageBMP *)0x0);
}



SubMenu * __cdecl
lego::front::Menu_CreateSubMenu
					(char *title,char *fullName,ImageFont *menuFont,int positionX,int positionY,
					BOOL autoCenter,BOOL displayTitle,int param_8,BOOL canScroll,char *anchored_str)
{
	char cVar1;
	SubMenu *submenu_00;
	char *pcVar2;
	SubMenuItem *pSVar3;
	int iVar4;
	uint uVar5;
	SubMenu *submenu;
	char *local_190;
	char *local_18c;
	
	submenu_00 = (SubMenu *)std::malloc(0xa0);
	if (submenu_00 == (SubMenu *)0x0) {
		return (SubMenu *)0x0;
	}
	submenu = submenu_00;
	for (iVar4 = 0x28; iVar4 != 0; iVar4 = iVar4 + -1) {
		submenu->ptr_0 = (void *)0x0;
		submenu = (SubMenu *)&submenu->ptr_4;
	}
	pcVar2 = std::_strdup2(title);
	submenu_00->ptr_0 = pcVar2;
	pcVar2 = std::_strdup2(fullName);
	submenu_00->ptr_4 = pcVar2;
	if (submenu_00->ptr_0 == (void *)0x0) {
		return (SubMenu *)0x0;
	}
	if (pcVar2 == (char *)0x0) {
		return (SubMenu *)0x0;
	}
	uVar5 = 0xffffffff;
	do {
		if (uVar5 == 0) break;
		uVar5 = uVar5 - 1;
		cVar1 = *title;
		title = title + 1;
	} while (cVar1 != '\0');
	submenu_00->length_8 = ~uVar5 - 1;
	pSVar3 = (SubMenuItem *)std::malloc(0x3c);
	submenu_00->Items = pSVar3;
	if (pSVar3 == (SubMenuItem *)0x0) {
		Menu_FreeSubMenu(submenu_00);
		return (SubMenu *)0x0;
	}
	submenu_00->MenuFont = menuFont;
	(submenu_00->Position).y = positionY;
	submenu_00->AutoCenter = autoCenter;
	submenu_00->DisplayTitle = displayTitle;
	(submenu_00->Position).x = positionX;
	submenu_00->int_20 = 0xf;
	submenu_00->ItemCount = 0;
	submenu_00->field_24 = 0;
	submenu_00->field_28 = 0;
	submenu_00->flags_58 = param_8;
	submenu_00->uint_34 = -(uint)(canScroll != 0) & 2;
	if (anchored_str != (char *)0x0) {
		submenu_00->isAnchored = 1;
		util::Util_Tokenise(anchored_str,&local_190,":");
		iVar4 = std::atoi(local_190);
		(submenu_00->AnchoredPosition).x = iVar4;
		iVar4 = std::atoi(local_18c);
		(submenu_00->AnchoredPosition).y = iVar4;
	}
	return submenu_00;
}



BOOL __cdecl lego::front::Menu_AddSubMenuItem(SubMenu *submenu,SubMenuItem *menuItem)
{
	int iVar1;
	SubMenuItem *pSVar2;
	
	if ((menuItem == (SubMenuItem *)0x0) || (submenu == (SubMenu *)0x0)) {
		return 0;
	}
	iVar1 = submenu->int_20;
	if (submenu->ItemCount == iVar1) {
		if (submenu->Items == (SubMenuItem *)0x0) {
			pSVar2 = (SubMenuItem *)std::malloc(iVar1 * 4 + 0x3c);
		}
		else {
			pSVar2 = (SubMenuItem *)std::realloc(submenu->Items,iVar1 * 4 + 0x3c);
		}
		if (pSVar2 == (SubMenuItem *)0x0) {
			return 0;
		}
		submenu->Items = pSVar2;
		submenu->int_20 = submenu->int_20 + 0xf;
	}
	(&submenu->Items->banner)[submenu->ItemCount] = (char *)menuItem;
	submenu->ItemCount = submenu->ItemCount + 1;
	return 1;
}



undefined4 __cdecl
FUN_00411210(int param_1,int param_2,int param_3,int param_4,int param_5,int param_6)
{
	if ((param_3 <= param_1) && (param_1 <= param_5 + param_3)) {
		if ((param_4 <= param_2) && (param_2 <= param_6 + param_4)) {
			return 1;
		}
	}
	return 0;
}



void __cdecl
FUN_00411250(int param_1,int param_2,int param_3,int param_4,int param_5,int param_6,int param_7)
{
	int iVar1;
	
	if (param_7 == 0) {
		iVar1 = 0;
	}
	else {
		iVar1 = -(param_5 / 2);
	}
	FUN_00411210(param_1,param_2,iVar1 + param_3,param_4,param_5,param_6);
	return;
}



int __cdecl FUN_00411290(int param_1,undefined4 *param_2,int *param_3)
{
	undefined4 *puVar1;
	undefined4 *puVar2;
	int iVar3;
	uint uVar4;
	byte *pbVar5;
	int iVar6;
	uint uVar7;
	
	puVar1 = param_2;
	uVar7 = 0;
	if ((ImageFont *)param_2[2] == (ImageFont *)0x0) {
		param_2 = (undefined4 *)0x0;
	}
	else {
		puVar2 = (undefined4 *)
						 lego::image::FontX_GetStringWidth((ImageFont *)param_2[2],(char *)param_3[8]);
		uVar7 = lego::image::Font_GetHeight((ImageFont *)param_2[2]);
		param_2 = puVar2;
	}
	iVar3 = FUN_00411250(lego::globs::INPUT.msx,lego::globs::INPUT.msy,
											 param_3[0xf] + *(int *)(param_1 + 0x2c),
											 param_3[0x10] + *(int *)(param_1 + 0x30),(int)param_2,uVar7,0);
	if (iVar3 != 0) {
		return -2;
	}
	if ((ImageFont *)puVar1[2] == (ImageFont *)0x0) {
		uVar4 = 0;
	}
	else {
		uVar4 = lego::image::FontX_GetStringWidth((ImageFont *)puVar1[2],(char *)param_3[9]);
	}
	iVar3 = FUN_00411250(lego::globs::INPUT.msx,lego::globs::INPUT.msy,
											 param_3[0x11] + *(int *)(param_1 + 0x2c),
											 param_3[0x12] + *(int *)(param_1 + 0x30),uVar4,uVar7,0);
	if (iVar3 != 0) {
		return -3;
	}
	iVar3 = 0;
	if (0 < param_3[0xe]) {
		while (iVar6 = param_3[0x13] + iVar3, iVar6 < param_3[7]) {
			pbVar5 = (byte *)(*param_3 + iVar6 * 0x20);
			if ((*pbVar5 & 4) != 0) {
				iVar6 = FUN_00411250(lego::globs::INPUT.msx,lego::globs::INPUT.msy,
														 puVar1[6] + param_3[0xb] + *(int *)(pbVar5 + 0x14) +
														 (int)Point2F_005584dc.x + *(int *)(param_1 + 0x2c),
														 param_3[0xd] * iVar3 + puVar1[7] + param_3[0xc] +
														 *(int *)(pbVar5 + 0x18) + (int)Point2F_005584dc.y +
														 *(int *)(param_1 + 0x30),*(int *)(param_3[1] + iVar6 * 4),
														 *(int *)(param_3[4] + iVar6 * 4),*(int *)(param_1 + 0x44));
				if (iVar6 != 0) {
					return iVar3 + param_3[0x13];
				}
			}
			iVar3 = iVar3 + 1;
			if (param_3[0xe] <= iVar3) {
				return -1;
			}
		}
	}
	return -1;
}



uint __cdecl FUN_00411420(int param_1,int param_2)
{
	undefined4 *puVar1;
	int iVar2;
	
	if ((param_2 < *(int *)(param_1 + 0x1c)) &&
		 (puVar1 = *(undefined4 **)(*(int *)(param_1 + 0x18) + param_2 * 4), puVar1[5] == 6)) {
		iVar2 = FUN_00411290(param_1,puVar1,(int *)puVar1[4]);
		return (uint)(iVar2 != -1);
	}
	return 0;
}



BOOL __cdecl
FUN_00411460(int param_1,int param_2,byte **param_3,byte **param_4,byte **param_5,byte **param_6)
{
	char **ppcVar1;
	ImageFont *pIVar2;
	byte *pbVar3;
	uint uVar4;
	uint uVar5;
	char *pcVar6;
	byte *pbVar7;
	byte *pbVar8;
	byte *pbVar9;
	byte *pbVar10;
	int iVar11;
	int iVar12;
	
	if (*(int *)(param_1 + 0x1c) <= param_2) {
		return 0;
	}
	iVar11 = param_2 * 4;
	ppcVar1 = *(char ***)(iVar11 + *(int *)(param_1 + 0x18));
	if (ppcVar1[5] == (char *)0x3) {
		pbVar10 = (byte *)(ppcVar1[6] + (int)(ppcVar1[9] + *(int *)(param_1 + 0x2c)));
		pcVar6 = ppcVar1[4];
		pbVar3 = (byte *)(ppcVar1[7] + *(int *)(param_1 + 0x30));
		if (*(int *)(param_1 + 0x24) == param_2) {
			pIVar2 = (ImageFont *)ppcVar1[2];
		}
		else {
			pIVar2 = (ImageFont *)ppcVar1[3];
		}
		uVar4 = lego::image::FontX_GetStringWidth(pIVar2,*ppcVar1);
		iVar11 = *(int *)(iVar11 + *(int *)(param_1 + 0x18));
		if (*(int *)(param_1 + 0x24) == param_2) {
			pIVar2 = *(ImageFont **)(iVar11 + 8);
		}
		else {
			pIVar2 = *(ImageFont **)(iVar11 + 0xc);
		}
		uVar5 = lego::image::Font_GetHeight(pIVar2);
		pbVar7 = (byte *)(ppcVar1[6] + *(int *)(param_1 + 0x2c) + *(int *)(pcVar6 + 0xc));
		pbVar9 = (byte *)(ppcVar1[7] + *(int *)(param_1 + 0x30) + *(int *)(pcVar6 + 0x10));
		if (*(int *)(pcVar6 + 0x24) == 0) {
			iVar11 = 0;
		}
		else {
			iVar11 = *(int *)(*(int *)(pcVar6 + 0x24) + 4);
		}
		if (*(int *)(pcVar6 + 0x28) == 0) {
			iVar12 = 0;
		}
		else {
			iVar12 = *(int *)(*(int *)(pcVar6 + 0x28) + 4);
		}
		pbVar8 = pbVar10;
		if ((int)pbVar7 <= (int)pbVar10) {
			pbVar8 = pbVar7;
		}
		*param_3 = pbVar8;
		pbVar8 = pbVar3;
		if ((int)pbVar9 <= (int)pbVar3) {
			pbVar8 = pbVar9;
		}
		*param_4 = pbVar8;
		pbVar8 = pbVar7 + iVar12 + 0x68 + iVar11;
		if ((int)(pbVar7 + iVar12 + 0x68 + iVar11) < (int)(pbVar10 + uVar4)) {
			pbVar8 = pbVar10 + uVar4;
		}
		*param_5 = pbVar8;
		pbVar10 = pbVar3 + uVar5;
		if ((int)(pbVar3 + uVar5) <= (int)(pbVar9 + 0x14)) {
			pbVar10 = pbVar9 + 0x14;
		}
		*param_6 = pbVar10;
		*param_5 = *param_5 + -(int)*param_3;
		*param_6 = *param_6 + -(int)*param_4;
		return 1;
	}
	if (ppcVar1[5] == (char *)0x6) {
		return 0;
	}
	*param_3 = (byte *)(ppcVar1[6] + (int)(ppcVar1[9] + *(int *)(param_1 + 0x2c)));
	*param_4 = (byte *)(*(int *)(*(int *)(iVar11 + *(int *)(param_1 + 0x18)) + 0x1c) +
										 *(int *)(param_1 + 0x30));
	ppcVar1 = *(char ***)(iVar11 + *(int *)(param_1 + 0x18));
	if (ppcVar1[10] != (char *)0x0) {
		if (*(int *)(param_1 + 0x24) == param_2) {
			pcVar6 = ppcVar1[0xc];
		}
		else {
			pcVar6 = ppcVar1[0xb];
		}
		*param_5 = *(byte **)(pcVar6 + 4);
		iVar11 = *(int *)(iVar11 + *(int *)(param_1 + 0x18));
		if (*(int *)(param_1 + 0x24) == param_2) {
			*param_6 = *(byte **)(*(int *)(iVar11 + 0x30) + 8);
			return 1;
		}
		*param_6 = *(byte **)(*(int *)(iVar11 + 0x2c) + 8);
		return 1;
	}
	if (*(int *)(param_1 + 0x24) == param_2) {
		pIVar2 = (ImageFont *)ppcVar1[2];
	}
	else {
		pIVar2 = (ImageFont *)ppcVar1[3];
	}
	pbVar3 = (byte *)lego::image::FontX_GetStringWidth(pIVar2,*ppcVar1);
	*param_5 = pbVar3;
	iVar11 = *(int *)(iVar11 + *(int *)(param_1 + 0x18));
	if (*(int *)(param_1 + 0x24) == param_2) {
		pbVar3 = (byte *)lego::image::Font_GetHeight(*(ImageFont **)(iVar11 + 8));
		*param_6 = pbVar3;
		return 1;
	}
	pbVar3 = (byte *)lego::image::Font_GetHeight(*(ImageFont **)(iVar11 + 0xc));
	*param_6 = pbVar3;
	return 1;
}



undefined4 __cdecl FUN_004116c0(int param_1,int *param_2)
{
	BOOL BVar1;
	int iVar2;
	uint uVar3;
	int iVar4;
	byte *local_10;
	byte *local_c;
	byte *local_8;
	byte *local_4;
	
	iVar4 = 0;
	local_4 = (byte *)0x0;
	local_8 = (byte *)0x0;
	local_c = (byte *)0x0;
	local_10 = (byte *)0x0;
	uVar3 = 0;
	while( true ) {
		BVar1 = FUN_00411460(param_1,iVar4,&local_4,&local_8,&local_c,&local_10);
		if (BVar1 == 0) {
			uVar3 = FUN_00411420(param_1,iVar4);
			if (uVar3 == 0) {
				return 0;
			}
		}
		if (uVar3 != 0) break;
		iVar2 = FUN_00411210(lego::globs::INPUT.msx,lego::globs::INPUT.msy,(int)local_4,(int)local_8,
												 (int)local_c,(int)local_10);
		if (iVar2 != 0) break;
		iVar4 = iVar4 + 1;
	}
	if (param_2 != (int *)0x0) {
		*param_2 = iVar4;
	}
	return 1;
}



undefined4 __cdecl FUN_00411770(void)
{
	undefined4 uVar1;
	
	if ((lego::globs::INPUT.mslb != 0) || (uVar1 = 1, DAT_004dc8d4 != 1)) {
		uVar1 = 0;
	}
	DAT_004dc8d4 = lego::globs::INPUT.mslb;
	return uVar1;
}



undefined4 __cdecl FUN_004117a0(int param_1,int param_2,int **param_3)
{
	int *piVar1;
	int iVar2;
	int iVar3;
	int iVar4;
	float10 fVar5;
	longlong lVar6;
	
	iVar4 = (int)param_3[3] + *(int *)(param_2 + 0x18) + *(int *)(param_1 + 0x2c);
	iVar3 = *(int *)(param_1 + 0x30) + *(int *)(param_2 + 0x1c) + (int)param_3[4];
	iVar2 = FUN_00411210(lego::globs::INPUT.msx,lego::globs::INPUT.msy,iVar4,iVar3,100,0x14);
	if (iVar2 != 0) {
		fVar5 = ((float10)lego::globs::INPUT.msx - (float10)iVar4) * (float10)0.01;
		if ((ushort)((ushort)(fVar5 < (float10)1.0) << 8 | (ushort)(fVar5 == (float10)1.0) << 0xe) == 0)
		{
			fVar5 = (float10)1.0;
		}
		if (fVar5 < (float10)0.0) {
			fVar5 = (float10)0.0;
		}
		lVar6 = __ftol((float10)(int)((int)param_3[2] - (int)param_3[1]) * fVar5);
		**param_3 = (int)lVar6;
		return 1;
	}
	piVar1 = param_3[0xb];
	if ((piVar1 != (int *)0x0) && (param_3[10] != (int *)0x0)) {
		iVar2 = FUN_00411210(lego::globs::INPUT.msx,lego::globs::INPUT.msy,(iVar4 - piVar1[1]) + -4,
												 iVar3,piVar1[1],piVar1[2]);
		if (iVar2 == 0) {
			iVar2 = FUN_00411210(lego::globs::INPUT.msx,lego::globs::INPUT.msy,
													 param_3[9][1] + 0x68 + iVar4,iVar3,param_3[10][1],param_3[10][2]);
			if (iVar2 == 0) {
				return 0;
			}
			iVar2 = **param_3;
			if (iVar2 < (int)param_3[2]) {
				**param_3 = iVar2 + 1;
			}
		}
		else {
			iVar2 = **param_3;
			if ((int)param_3[1] < iVar2) {
				**param_3 = iVar2 + -1;
				return 1;
			}
		}
		return 1;
	}
	return 0;
}



BOOL __cdecl FUN_00411900(int param_1)
{
	TutorialFlags TVar1;
	
	if ((param_1 != 0) && (*(int *)(param_1 + 0x38) != 0)) {
		TVar1 = lego::nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
		if (TVar1 != TUTORIAL_NONE) {
			return 1;
		}
	}
	return 0;
}



int __cdecl FUN_00411930(undefined4 param_1,int param_2)
{
	undefined *puVar1;
	float *pfVar2;
	int **ppiVar3;
	int **ppiVar4;
	float **ppfVar5;
	undefined4 *puVar6;
	int *piVar7;
	bool bVar8;
	bool bVar9;
	int iVar10;
	BOOL BVar11;
	int iVar12;
	int iVar13;
	undefined4 *puVar14;
	int local_4;
	
	local_4 = -1;
	iVar10 = *(int *)(param_2 + 0x24);
	bVar9 = false;
	if (iVar10 < 0) {
		puVar14 = (undefined4 *)0x0;
	}
	else {
		puVar14 = *(undefined4 **)(*(int *)(param_2 + 0x18) + iVar10 * 4);
	}
	if (((byte)FLAGS_005584f0 & 2) != 0) {
		return param_2;
	}
	bVar8 = true;
	if ((puVar14 == (undefined4 *)0x0) && (-1 < iVar10)) {
		*(undefined4 *)(param_2 + 0x28) = 1;
	}
	iVar10 = FUN_004116c0(param_2,&local_4);
	if (iVar10 != 0) {
		*(int *)(param_2 + 0x24) = local_4;
		puVar14 = *(undefined4 **)(*(int *)(param_2 + 0x18) + local_4 * 4);
	}
	BVar11 = FUN_00411900((int)puVar14);
	if (BVar11 != 0) {
		return param_2;
	}
	iVar10 = FUN_00411770();
	if ((iVar10 == 0) || (iVar10 = FUN_004116c0(param_2,&local_4), iVar10 == 0)) {
		bVar8 = false;
	}
	if ((puVar14 == (undefined4 *)0x0) && (*(int *)(param_2 + 0x24) < 0)) {
		return param_2;
	}
										// IsKeyPressed(KEY_CURSORRIGHT) (205)
	if (((lego::globs::INPUT.Key_Map[205] != false) &&
			(lego::globs::INPUT.prevKey_Map[205] != lego::globs::INPUT.Key_Map[205])) || (bVar8)) {
		lego::snd::Audio_Play_FUN_00465260(SFX_OKAY,0);
		switch(puVar14[5]) {
		case 0:
			iVar10 = puVar14[4];
			**(int **)(iVar10 + 0xc) = (**(int **)(iVar10 + 0xc) + 1) % *(int *)(iVar10 + 8);
			bVar9 = bVar8;
			if (*(code **)(iVar10 + 0x18) != (code *)0x0) {
				(**(code **)(iVar10 + 0x18))(**(undefined4 **)(iVar10 + 0xc));
			}
			break;
		case 2:
			iVar10 = puVar14[4];
			iVar13 = *(int *)(iVar10 + 8) + 1;
			iVar12 = *(int *)(iVar10 + 4) + -1;
			*(int *)(iVar10 + 8) = iVar13;
			bVar9 = bVar8;
			if (iVar12 < iVar13) {
				*(int *)(iVar10 + 8) = iVar12;
			}
			break;
		case 3:
			ppiVar4 = (int **)puVar14[4];
			if (bVar8) {
				FUN_004117a0(param_2,(int)puVar14,ppiVar4);
				if (ppiVar4[5] != (int *)0x0) {
					(*(code *)ppiVar4[5])(**ppiVar4);
				}
			}
			else {
				**ppiVar4 = **ppiVar4 + 1;
				ppiVar3 = (int **)*ppiVar4;
				piVar7 = ppiVar4[2];
				if (*ppiVar3 != piVar7 && (int)piVar7 <= (int)*ppiVar3) {
					*ppiVar3 = piVar7;
				}
				bVar9 = false;
				if (ppiVar4[5] != (int *)0x0) {
					(*(code *)ppiVar4[5])(**ppiVar4);
				}
			}
			break;
		case 4:
			ppfVar5 = (float **)puVar14[4];
			**ppfVar5 = (float)ppfVar5[3] + **ppfVar5;
			pfVar2 = (float *)**ppfVar5;
			if ((ushort)((ushort)((float)pfVar2 < (float)ppfVar5[2]) << 8 |
									(ushort)((float)pfVar2 == (float)ppfVar5[2]) << 0xe) == 0) {
				**ppfVar5 = (float)ppfVar5[2];
			}
			bVar9 = bVar8;
			if (ppfVar5[6] != (float *)0x0) {
				(*(code *)ppfVar5[6])(**ppfVar5);
			}
			break;
		case 6:
			piVar7 = (int *)puVar14[4];
			iVar10 = FUN_00411290(param_2,puVar14,piVar7);
			if (bVar8) {
				if (iVar10 == -3) {
					if (piVar7[0x13] < 1) break;
					iVar10 = piVar7[0x13] + -1;
				}
				else {
					if (iVar10 != -2) {
						if (iVar10 != -1) {
							if (piVar7[0x16] != 0) {
								*(int *)piVar7[10] = iVar10;
								if ((code *)piVar7[0x15] != (code *)0x0) {
									(*(code *)piVar7[0x15])(param_1,iVar10);
								}
								if (((SubMenu *)param_2 == lego::globals::menu::g_MainMenuFull->menus[3]) ||
									 ((SubMenu *)param_2 == *lego::globals::menu::g_SaveMenu->menus)) {
									INT_004a2f4c = iVar10;
									lego::globals::g_SaveMenu_OutNumber = iVar10;
								}
								return piVar7[0x16];
							}
							*(int *)piVar7[10] = iVar10;
							if ((code *)piVar7[0x15] != (code *)0x0) {
								(*(code *)piVar7[0x15])(param_1,iVar10);
							}
							*(undefined4 *)(param_2 + 0x28) = 1;
							if (((SubMenu *)param_2 == lego::globals::menu::g_MainMenuFull->menus[3]) ||
								 ((SubMenu *)param_2 == *lego::globals::menu::g_SaveMenu->menus)) {
								INT_004a2f4c = iVar10;
								lego::globals::g_SaveMenu_OutNumber = iVar10;
							}
						}
						break;
					}
					if (piVar7[7] - piVar7[0xe] <= piVar7[0x13]) break;
					iVar10 = piVar7[0x13] + 1;
				}
				piVar7[0x13] = iVar10;
			}
		}
	}
										// IsKeyPressed(KEY_CURSORLEFT) (203)
	if ((lego::globs::INPUT.Key_Map[203] != false) &&
		 (lego::globs::INPUT.prevKey_Map[203] != lego::globs::INPUT.Key_Map[203])) {
		switch(puVar14[5]) {
		case 0:
			iVar10 = puVar14[4];
			**(int **)(iVar10 + 0xc) = **(int **)(iVar10 + 0xc) + -1;
			if (**(int **)(iVar10 + 0xc) < 0) {
				**(int **)(iVar10 + 0xc) = *(int *)(iVar10 + 8) + -1;
			}
			break;
		case 2:
			iVar10 = puVar14[4];
			iVar12 = *(int *)(iVar10 + 8) + -1;
			*(int *)(iVar10 + 8) = iVar12;
			if (iVar12 < 0) {
				*(undefined4 *)(iVar10 + 8) = 0;
			}
			break;
		case 3:
			ppiVar4 = (int **)puVar14[4];
			**ppiVar4 = **ppiVar4 + -1;
			if ((int)**ppiVar4 < (int)ppiVar4[1]) {
				**ppiVar4 = (int)ppiVar4[1];
			}
			if (ppiVar4[5] != (int *)0x0) {
				(*(code *)ppiVar4[5])(**ppiVar4);
			}
			break;
		case 4:
			ppfVar5 = (float **)puVar14[4];
			**ppfVar5 = **ppfVar5 - (float)ppfVar5[3];
			if ((float)**ppfVar5 < (float)ppfVar5[1]) {
				**ppfVar5 = (float)ppfVar5[1];
			}
			if (ppfVar5[6] != (float *)0x0) {
				(*(code *)ppfVar5[6])(**ppfVar5);
			}
		}
	}
	if ((bVar8) && (!bVar9)) {
		iVar10 = puVar14[5];
		if (iVar10 == 0) {
			piVar7 = *(int **)(puVar14[4] + 0xc);
			*piVar7 = (*piVar7 + 1) % *(int *)(puVar14[4] + 8);
		}
		else {
			if (iVar10 == 1) {
				puVar6 = (undefined4 *)puVar14[4];
				if ((code *)puVar6[2] != (code *)0x0) {
					(*(code *)puVar6[2])();
				}
				if (puVar6[1] != 0) {
					*(undefined4 *)(param_2 + 0x28) = 1;
					*(undefined4 *)*puVar6 = 1;
				}
			}
			else {
				if (iVar10 == 5) {
					return puVar14[4];
				}
			}
		}
	}
	if (puVar14[5] == 2) {
		piVar7 = (int *)puVar14[4];
		iVar10 = 0;
		do {
			if ((lego::globs::INPUT.Key_Map[iVar10] != false) &&
				 (lego::globs::INPUT.prevKey_Map[iVar10] != lego::globs::INPUT.Key_Map[iVar10])) {
				if ((iVar10 == 0xe) && (iVar12 = piVar7[2], 0 < iVar12)) {
					if (iVar12 < piVar7[1]) {
						do {
							puVar1 = (undefined *)(*piVar7 + iVar12);
							iVar12 = iVar12 + 1;
							puVar1[-1] = *puVar1;
						} while (iVar12 < piVar7[1]);
					}
					piVar7[2] = piVar7[2] + -1;
					piVar7[1] = piVar7[1] + -1;
				}
				if (((piVar7[1] != piVar7[3]) && (piVar7[2] < piVar7[3] + -1)) &&
					 (lego::globals::g_DIKey_CharCodes_TABLE[iVar10] != 0)) {
					iVar12 = piVar7[1] + -1;
					if (piVar7[2] <= iVar12) {
						do {
							puVar1 = (undefined *)(*piVar7 + iVar12);
							iVar12 = iVar12 + -1;
							puVar1[1] = *puVar1;
						} while (piVar7[2] <= iVar12);
					}
					*(undefined *)(*piVar7 + piVar7[2]) =
							 *(undefined *)(lego::globals::g_DIKey_CharCodes_TABLE + iVar10);
					if ((lego::globs::INPUT.Key_Map[42] != false) || (lego::globs::INPUT.Key_Map[54] != false)
						 ) {
						*(char *)(*piVar7 + piVar7[2]) = *(char *)(*piVar7 + piVar7[2]) + -0x20;
					}
					piVar7[2] = piVar7[2] + 1;
					piVar7[1] = piVar7[1] + 1;
				}
			}
			iVar10 = iVar10 + 1;
		} while (iVar10 < 0x100);
	}
	return param_2;
}



int __cdecl lego::input::Input_GetKeyCharacter(int diKey)
{
	return globals::g_DIKey_CharCodes_TABLE[diKey];
}



void __cdecl FUN_00411e40(int param_1,uint param_2,uint param_3,int param_4,uint param_5)
{
	float fVar1;
	float fVar2;
	float fVar3;
	ulonglong uVar4;
	int iVar5;
	int iVar6;
	longlong lVar7;
	ImageBMP *image;
	int iVar8;
	Point2F local_20;
	uint local_18;
	undefined4 uStack20;
	Rect2F local_10;
	
	local_18 = param_3;
	uStack20 = 0;
	local_10.x = 0.0;
	local_10.y = 0.0;
	local_10.height = 20.0;
	fVar1 = (float)(ulonglong)((uint)(param_4 * 100) / param_5);
	fVar2 = (float)(ulonglong)param_2;
	uVar4 = (ulonglong)param_3;
	fVar3 = (float)uVar4;
	local_20.x = fVar2;
	local_20.y = fVar3;
	local_10.width = fVar1;
	lego::image::Image_DisplayScaled(*(ImageBMP **)(param_1 + 0x1c),&local_10,&local_20,(Size2F *)0x0)
	;
	local_10.width = 100.0 - fVar1;
	local_20.x = fVar2 + fVar1;
	local_10.y = 0.0;
	local_10.height = 20.0;
	local_20.y = fVar3;
	local_10.x = fVar1;
	lego::image::Image_DisplayScaled(*(ImageBMP **)(param_1 + 0x18),&local_10,&local_20,(Size2F *)0x0)
	;
	if (*(ImageBMP **)(param_1 + 0x20) != (ImageBMP *)0x0) {
		local_20.x = fVar2;
		local_20.y = fVar3;
		lego::image::Image_DisplayScaled
							(*(ImageBMP **)(param_1 + 0x20),(Rect2F *)0x0,&local_20,(Size2F *)0x0);
	}
	if (*(ImageBMP **)(param_1 + 0x24) != (ImageBMP *)0x0) {
		local_20.x = fVar2 - -100.0;
		local_20.y = fVar3;
		lego::image::Image_DisplayScaled
							(*(ImageBMP **)(param_1 + 0x24),(Rect2F *)0x0,&local_20,(Size2F *)0x0);
	}
	iVar6 = *(int *)(param_1 + 0x2c);
	if ((iVar6 != 0) && (*(int *)(param_1 + 0x34) != 0)) {
		local_20.x = fVar2 - (float)(*(int *)(iVar6 + 4) + 4);
		iVar8 = *(int *)(iVar6 + 8);
		iVar6 = *(int *)(iVar6 + 4);
		local_20.y = fVar3;
		lVar7 = __ftol((float10)uVar4);
		iVar5 = (int)lVar7;
		lVar7 = __ftol((float10)local_20.x);
		iVar6 = FUN_00411210(lego::globs::INPUT.msx,lego::globs::INPUT.msy,(int)lVar7,iVar5,iVar6,iVar8)
		;
		if (iVar6 == 0) {
			image = *(ImageBMP **)(param_1 + 0x2c);
		}
		else {
			image = *(ImageBMP **)(param_1 + 0x34);
		}
		lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,&local_20,(Size2F *)0x0);
	}
	iVar6 = *(int *)(param_1 + 0x28);
	if ((iVar6 != 0) && (*(int *)(param_1 + 0x30) != 0)) {
		local_20.x = ((float)*(int *)(*(int *)(param_1 + 0x24) + 4) + fVar2) - -104.0;
		iVar8 = *(int *)(iVar6 + 8);
		iVar6 = *(int *)(iVar6 + 4);
		local_20.y = fVar3;
		lVar7 = __ftol((float10)uVar4);
		iVar5 = (int)lVar7;
		lVar7 = __ftol((float10)local_20.x);
		iVar6 = FUN_00411210(lego::globs::INPUT.msx,lego::globs::INPUT.msy,(int)lVar7,iVar5,iVar6,iVar8)
		;
		if (iVar6 != 0) {
			lego::image::Image_DisplayScaled
								(*(ImageBMP **)(param_1 + 0x30),(Rect2F *)0x0,&local_20,(Size2F *)0x0);
			return;
		}
		lego::image::Image_DisplayScaled
							(*(ImageBMP **)(param_1 + 0x28),(Rect2F *)0x0,&local_20,(Size2F *)0x0);
	}
	return;
}



int __cdecl FUN_004120a0(int param_1)
{
	int iVar1;
	int iVar2;
	
	iVar2 = 0;
	for (iVar1 = *(int *)(param_1 + 0x40); iVar1 != 0; iVar1 = *(int *)(iVar1 + 0x18)) {
		iVar2 = iVar2 + 1;
	}
	return iVar2;
}



BOOL __cdecl lego::util::randomBool_1_In_400(void)
{
	short sVar1;
	short extraout_var;
	
	sVar1 = std::rand();
	return (uint)((int)(CONCAT44((int)extraout_var >> 0xf,CONCAT22(extraout_var,sVar1)) % 400) == 0);
}



void __cdecl FUN_004120e0(int param_1)
{
	char **ppcVar1;
	short sVar2;
	uint uVar3;
	uint uVar4;
	BOOL BVar5;
	undefined2 extraout_var;
	int iVar6;
	ulonglong uVar7;
	ulonglong uVar8;
	Rect2F local_10;
	
	if (DAT_0055806c == (ImageFlic *)0x0) {
		ppcVar1 = *(char ***)(param_1 + 0x40);
		if (ppcVar1 != (char **)0x0) {
			if (*(int *)(param_1 + 0x9c) == 1) {
				BVar5 = lego::util::randomBool_1_In_400();
				if (BVar5 == 0) {
					uVar3 = 0;
				}
				else {
					uVar3 = FUN_004120a0(param_1);
				}
				if (uVar3 != 0) {
					sVar2 = std::rand();
					for (uVar3 = CONCAT22(extraout_var,sVar2) % uVar3; uVar3 != 0; uVar3 = uVar3 - 1) {
						ppcVar1 = (char **)ppcVar1[6];
					}
					BVar5 = lego::image::Flic_Setup(*ppcVar1,&DAT_0055806c,FLICDISK);
					if (BVar5 != 0) {
						lego::snd::Audio_AddToSoundQueue1((SFXType)ppcVar1[5],0);
						DAT_00558068 = ppcVar1[3];
						DAT_00558064 = ppcVar1[4];
						TIMEUINT_00558070 = lego::main::Main_GetTime();
						TIMEUINT_00558074 = TIMEUINT_00558070;
						return;
					}
				}
			}
			else {
				if (-1 < INT_004a2f50) {
					for (iVar6 = 4 - INT_004a2f50; iVar6 != 0; iVar6 = iVar6 + -1) {
						ppcVar1 = (char **)ppcVar1[6];
					}
					BVar5 = lego::image::Flic_Setup(*ppcVar1,&DAT_0055806c,FLICDISK);
					if (BVar5 != 0) {
						lego::snd::Audio_AddToSoundQueue1((SFXType)ppcVar1[5],0);
						DAT_00558068 = ppcVar1[3];
						DAT_00558064 = ppcVar1[4];
						TIMEUINT_00558070 = lego::main::Main_GetTime();
						TIMEUINT_00558074 = TIMEUINT_00558070;
					}
					INT_004a2f4c = -1;
					INT_004a2f50 = -1;
					DAT_004dc8c0 = 1;
					return;
				}
				if (-1 < INT_004a2f4c) {
					INT_004a2f50 = INT_004a2f4c;
					DAT_004dc8c8 = 0;
				}
			}
		}
	}
	else {
		uVar3 = lego::res::AnimClone_IsLws((AnimClone *)DAT_0055806c);
		uVar4 = lego::image::Flic_GetHeight(DAT_0055806c);
		local_10.x = (float)(int)DAT_00558068;
		local_10.y = (float)(int)DAT_00558064;
		local_10.width = (float)(ulonglong)uVar3;
		local_10.height = (float)(ulonglong)uVar4;
		uVar4 = lego::main::Main_GetTime();
		uVar3 = TIMEUINT_00558070;
		uVar7 = __ftol((float10)(ulonglong)(TIMEUINT_00558074 - TIMEUINT_00558070) * (float10)0.025);
		uVar8 = __ftol((float10)(ulonglong)(uVar4 - uVar3) * (float10)0.025);
		if ((DAT_004dc8c0 != 0) &&
			 (uVar8 = uVar8 & 0xffffffff,
			 (int)(uint)(DAT_0055806c->fsHeader).frames <= DAT_0055806c->currentframe)) {
			uVar8 = uVar7 & 0xffffffff;
			INT_004a2f50 = -2;
		}
		TIMEUINT_00558074 = uVar4;
		BVar5 = lego::image::Flic_Animate(DAT_0055806c,&local_10,(uint)((int)uVar8 != (int)uVar7),0);
		if (BVar5 == 0) {
			lego::image::Flic_Close(DAT_0055806c);
			std::free(DAT_0055806c);
			DAT_0055806c = (ImageFlic *)0x0;
			TIMEUINT_00558070 = 0;
			TIMEUINT_00558074 = 0;
			lego::snd::Sound3D_Stream_Stop(0);
		}
		if ((DAT_004dc8c0 != 0) && (lego::globs::INPUT.mslb != 0)) {
			INT_004a2f50 = -2;
			DAT_004dc8c0 = 0;
			return;
		}
	}
	return;
}



void __cdecl
FUN_00412380(int param_1,int param_2,undefined4 *param_3,int *param_4,int param_5,int param_6)
{
	ImageBMP *image;
	byte *pbVar1;
	int iVar2;
	Point2F local_8;
	
	pbVar1 = (byte *)(param_5 * 0x20 + *param_4);
	if ((*pbVar1 & 1) != 0) {
		lego::image::Font_PrintF((ImageFont *)param_3,param_1,param_2,*(char **)(pbVar1 + 4));
		return;
	}
	local_8.y = (float)param_2;
	local_8.x = (float)param_1;
	image = *(ImageBMP **)(*param_4 + 8 + (param_6 + param_5 * 8) * 4);
	if ((((image != (ImageBMP *)0x0) && (param_1 < 0x280)) &&
			(iVar2 = -image->width,
			param_1 != iVar2 && SBORROW4(param_1,iVar2) == (int)(param_1 + image->width) < 0)) &&
		 ((iVar2 = -image->height,
			param_2 != iVar2 && SBORROW4(param_2,iVar2) == (int)(param_2 + image->height) < 0 &&
			(param_2 < 0x1e0)))) {
		lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,&local_8,(Size2F *)0x0);
	}
	return;
}



void __cdecl FUN_00412420(int param_1,int param_2,undefined4 param_3,int param_4)
{
	ImageBMP *image;
	char *pcVar1;
	int iVar2;
	char local_34 [8];
	Size2F local_2c;
	Point2F local_24;
	int local_1c;
	undefined4 uStack24;
	char *local_14;
	char *local_10;
	
	if (((SubMenu *)param_1 == lego::globals::menu::g_MainMenuFull->menus[3]) ||
		 ((SubMenu *)param_1 == *lego::globals::menu::g_SaveMenu->menus)) {
		image = lego::globals::g_SaveSlotImages_TABLE[param_2];
		if (image != (ImageBMP *)0x0) {
			std::sprintf(local_34,"pos%d",param_2 + 1);
			pcVar1 = lego::cfg::CFG_JoinPath
												 (lego::globals::g_Game.CfgRootName,"Menu::SaveImage",local_34,0);
			pcVar1 = lego::cfg::CFG_CopyString(lego::globals::g_Game.LegoCfgRoot,pcVar1);
			lego::util::Util_Tokenise(pcVar1,&local_14,"|");
			iVar2 = std::atoi(local_14);
			local_24.x = (float)iVar2;
			iVar2 = std::atoi(local_10);
			local_24.y = (float)iVar2;
			pcVar1 = lego::cfg::CFG_JoinPath
												 (lego::globals::g_Game.CfgRootName,"Menu::SaveImage","Width",0);
			pcVar1 = lego::cfg::CFG_ReadString(lego::globals::g_Game.LegoCfgRoot,pcVar1);
			if (pcVar1 == (char *)0x0) {
				pcVar1 = ____EMPTYSTR__;
			}
			else {
				pcVar1 = lego::cfg::CFG_JoinPath
													 (lego::globals::g_Game.CfgRootName,"Menu::SaveImage","Width",0);
				pcVar1 = lego::cfg::CFG_ReadString(lego::globals::g_Game.LegoCfgRoot,pcVar1);
			}
			iVar2 = std::atoi(pcVar1);
			local_2c.width = (float)iVar2;
			pcVar1 = lego::cfg::CFG_JoinPath
												 (lego::globals::g_Game.CfgRootName,"Menu::SaveImage","Height",0);
			pcVar1 = lego::cfg::CFG_ReadString(lego::globals::g_Game.LegoCfgRoot,pcVar1);
			if (pcVar1 == (char *)0x0) {
				pcVar1 = ____EMPTYSTR__;
			}
			else {
				pcVar1 = lego::cfg::CFG_JoinPath
													 (lego::globals::g_Game.CfgRootName,"Menu::SaveImage","Height",0);
				pcVar1 = lego::cfg::CFG_ReadString(lego::globals::g_Game.LegoCfgRoot,pcVar1);
			}
			iVar2 = std::atoi(pcVar1);
			local_2c.height = (float)iVar2;
			if (param_4 != 0) {
				local_1c = lego::globals::g_Menu_SaveImage_BigSize.height;
				uStack24 = 0;
				local_24.x = local_24.x -
										 ((float)(ulonglong)(uint)lego::globals::g_Menu_SaveImage_BigSize.width -
										 local_2c.width) * 0.25;
				local_24.y = local_24.y -
										 ((float)(ulonglong)(uint)lego::globals::g_Menu_SaveImage_BigSize.height -
										 local_2c.height) * 0.25;
				local_2c.width =
						 local_2c.width -
						 ((float)(ulonglong)(uint)lego::globals::g_Menu_SaveImage_BigSize.width - local_2c.width
						 ) * -0.5;
				local_2c.height =
						 local_2c.height -
						 ((float)(ulonglong)(uint)lego::globals::g_Menu_SaveImage_BigSize.height -
						 local_2c.height) * -0.5;
			}
			lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,&local_24,&local_2c);
		}
	}
	return;
}



// WARNING: Type propagation algorithm not settling

void __cdecl FUN_00412680(int *param_1,int *param_2,int *param_3)
{
	int *piVar1;
	SubMenu *pSVar2;
	int iVar3;
	char *pcVar4;
	int iVar5;
	int iVar6;
	longlong lVar7;
	
	pSVar2 = (SubMenu *)*param_1;
	if ((pSVar2 != lego::globals::menu::g_MainMenuFull->menus[3]) &&
		 (pSVar2 != *lego::globals::menu::g_SaveMenu->menus)) goto LAB_0041287c;
	if ((pSVar2 == *lego::globals::menu::g_SaveMenu->menus) && (-1 < INT_004a2f4c)) {
		if (lego::globals::g_SaveSlotPtrs_TABLE[INT_004a2f4c] == (void *)0x0) {
			DAT_00558508 = 0;
			*(undefined4 *)(*param_1 + 0x28) = 1;
		}
		else {
			DAT_004dc8bc = 1;
		}
	}
										// WARNING: Load size is inaccurate
	lego::front::TextWindow_Clear(*lego::globals::g_UnkStruct728_Menu_SaveText);
										// WARNING: Load size is inaccurate
	lego::front::TextWindow_PrintF(*lego::globals::g_UnkStruct728_Menu_SaveText,"\n");
	if (INT_004a2f50 == -2) {
		if (DAT_004dc8c8 != 0) {
			*param_2 = DAT_004dc8c8;
		}
		DAT_004dc8c8 = 0;
		INT_004a2f48 = -1;
		INT_004a2f54 = -1;
LAB_00412766:
		*param_3 = 0;
		INT_004a2f4c = -1;
		pcVar4 = (char *)((int)lego::globals::g_UnkStruct728_Menu_SaveText + 0x28);
		if ((SubMenu *)*param_1 != lego::globals::menu::g_MainMenuFull->menus[3]) {
			pcVar4 = (char *)((int)lego::globals::g_UnkStruct728_Menu_SaveText + 0x128);
		}
										// WARNING: Load size is inaccurate
		lego::front::TextWindow_PrintF(*lego::globals::g_UnkStruct728_Menu_SaveText,pcVar4);
	}
	else {
		if (INT_004a2f50 == -1) goto LAB_00412766;
		DAT_004dc8c8 = *param_2;
		*param_2 = *param_3;
		INT_004a2f54 = INT_004a2f50;
	}
	if (INT_004a2f54 < 0) {
		if (-1 < INT_004a2f48) {
			param_2 = (int *)(float)ZEXT48(lego::globals::g_SaveSlotPtrs_TABLE[INT_004a2f48]);
			if ((ushort)((ushort)((float)param_2 < 100.0) << 8 | (ushort)((float)param_2 == 100.0) << 0xe)
					== 0) {
				param_2 = (int *)&DAT_42c80000;
			}
										// WARNING: Load size is inaccurate
			lego::front::TextWindow_PrintF(*lego::globals::g_UnkStruct728_Menu_SaveText,"\n");
			lVar7 = __ftol((float10)(float)param_2);
										// WARNING: Load size is inaccurate
			lego::front::TextWindow_PrintF
								(*lego::globals::g_UnkStruct728_Menu_SaveText,
								 (char *)((int)lego::globals::g_UnkStruct728_Menu_SaveText + 0x228),(int)lVar7);
		}
	}
	else {
										// WARNING: Load size is inaccurate
		lego::front::TextWindow_Clear(*lego::globals::g_UnkStruct728_Menu_SaveText);
		if ((SubMenu *)*param_1 == lego::globals::menu::g_MainMenuFull->menus[3]) {
										// WARNING: Load size is inaccurate
			lego::front::TextWindow_PrintF
								(*lego::globals::g_UnkStruct728_Menu_SaveText,
								 (char *)((int)lego::globals::g_UnkStruct728_Menu_SaveText + 0x328),INT_004a2f54 + 1
								 ,0);
		}
	}
										// WARNING: Load size is inaccurate
	if (*lego::globals::g_UnkStruct728_Menu_SaveText != (TextWindow *)0x0) {
		lego::front::TextWindow_Update(*lego::globals::g_UnkStruct728_Menu_SaveText,0,1.0,(int *)0x0);
	}
LAB_0041287c:
	pSVar2 = (SubMenu *)*param_1;
	if ((pSVar2 == lego::globals::menu::g_MainMenuFull->menus[3]) &&
		 (iVar6 = 0, 0 < pSVar2->ItemCount)) {
		do {
			pcVar4 = (&pSVar2->Items->banner)[iVar6];
			if (*(int *)(pcVar4 + 0x14) == 6) {
				piVar1 = *(int **)(pcVar4 + 0x10);
				iVar3 = 0;
				if (0 < piVar1[7]) {
					iVar5 = 0;
					do {
						iVar3 = iVar3 + 1;
						std::sprintf(*(char **)(*piVar1 + 4 + iVar5),"%s %d",
												 lego::globals::menu::g_Menu_LoadGame_text,iVar3);
						iVar5 = iVar5 + 0x20;
					} while (iVar3 < piVar1[7]);
				}
			}
			pSVar2 = (SubMenu *)*param_1;
			iVar6 = iVar6 + 1;
		} while (iVar6 < pSVar2->ItemCount);
	}
	return;
}



void __cdecl FUN_00412900(int *param_1)
{
	void *pvVar1;
	Size2F local_10;
	Point2F local_8;
	
	pvVar1 = lego::globals::g_UnkStruct728_Menu_LevelText;
	if (((SubMenu *)*param_1 == lego::globals::menu::g_MainMenuFull->menus[1]) ||
		 ((SubMenu *)*param_1 == lego::globals::menu::g_MainMenuFull->menus[2])) {
		if (*(ImageBMP **)((int)lego::globals::g_UnkStruct728_Menu_LevelText + 4) != (ImageBMP *)0x0) {
			local_8.x = *(float *)((int)lego::globals::g_UnkStruct728_Menu_LevelText + 0x18);
			local_8.y = *(float *)((int)lego::globals::g_UnkStruct728_Menu_LevelText + 0x1c);
			local_10.width = *(float *)((int)lego::globals::g_UnkStruct728_Menu_LevelText + 0x20);
			local_10.height = *(float *)((int)lego::globals::g_UnkStruct728_Menu_LevelText + 0x24);
			lego::image::Image_DisplayScaled
								(*(ImageBMP **)((int)lego::globals::g_UnkStruct728_Menu_LevelText + 4),(Rect2F *)0x0
								 ,&local_8,&local_10);
		}
										// WARNING: Load size is inaccurate
		if (*pvVar1 != (TextWindow *)0x0) {
			lego::front::TextWindow_Update(*pvVar1,0,1.0,(int *)0x0);
										// WARNING: Load size is inaccurate
			lego::front::TextWindow_Clear(*pvVar1);
										// WARNING: Load size is inaccurate
			lego::front::TextWindow_PrintF(*pvVar1,"\n");
			if (((SubMenu *)*param_1 == lego::globals::menu::g_MainMenuFull->menus[1]) &&
				 ((char *)((int)pvVar1 + 0x528) != (char *)0x0)) {
										// WARNING: Load size is inaccurate
				lego::front::TextWindow_PrintF(*pvVar1,(char *)((int)pvVar1 + 0x528));
										// WARNING: Load size is inaccurate
				lego::front::TextWindow_PrintF(*pvVar1,"\n");
			}
			if (((SubMenu *)*param_1 == lego::globals::menu::g_MainMenuFull->menus[2]) &&
				 ((char *)((int)pvVar1 + 0x628) != (char *)0x0)) {
										// WARNING: Load size is inaccurate
				lego::front::TextWindow_PrintF(*pvVar1,(char *)((int)pvVar1 + 0x628));
										// WARNING: Load size is inaccurate
				lego::front::TextWindow_PrintF(*pvVar1,"\n");
			}
			BOOL_004dc8c4 = 1;
		}
	}
	return;
}



void __cdecl FUN_00412a20(int param_1,BOOL param_2)
{
	ImageBMP *pIVar1;
	Point2F local_18;
	Rect2F local_10;
	
	if (param_2 == 0) {
		pIVar1 = *(ImageBMP **)(param_1 + 0x14);
		if (pIVar1 != (ImageBMP *)0x0) {
			if ((*(byte *)(param_1 + 0x34) & 1) != 0) {
				lego::image::Image_DisplayScaled
									(pIVar1,(Rect2F *)0x0,(Point2F *)(param_1 + 0x38),(Size2F *)0x0);
				return;
			}
			local_10.x = -(float)(int)Point2F_005584dc.x;
			local_10.y = -(float)(int)Point2F_005584dc.y;
			local_10.width = 640.0;
			local_10.height = 480.0;
			local_18.x = 0.0;
			local_18.y = 0.0;
			lego::image::Image_DisplayScaled(pIVar1,&local_10,&local_18,(Size2F *)0x0);
		}
	}
	else {
		pIVar1 = *(ImageBMP **)(param_1 + 0x10);
		if (pIVar1 != (ImageBMP *)0x0) {
			if ((*(byte *)(param_1 + 0x34) & 1) != 0) {
				lego::image::Image_DisplayScaled
									(pIVar1,(Rect2F *)0x0,(Point2F *)(param_1 + 0x38),(Size2F *)0x0);
				return;
			}
			local_10.x = -(float)(int)Point2F_005584dc.x;
			local_10.y = -(float)(int)Point2F_005584dc.y;
			local_10.width = 640.0;
			local_10.height = 480.0;
			local_18.x = 0.0;
			local_18.y = 0.0;
			lego::image::Image_DisplayScaled(pIVar1,&local_10,&local_18,(Size2F *)0x0);
			return;
		}
	}
	return;
}



int __cdecl FUN_00412b30(undefined4 param_1,int param_2,BOOL *out_bool)
{
	ImageFont **ppIVar1;
	char **ppcVar2;
	char *pcVar3;
	char **ppcVar4;
	undefined4 *puVar5;
	int **ppiVar6;
	float **ppfVar7;
	int *piVar8;
	ulonglong uVar9;
	float fVar10;
	Viewport *view;
	Container *pCVar11;
	char *pcVar12;
	uint uVar13;
	BOOL BVar14;
	char *pcVar15;
	int iVar16;
	ImageFont *pIVar17;
	int iVar18;
	uint *puVar19;
	int iVar20;
	int iVar21;
	int iVar22;
	char *pcVar23;
	int local_864;
	Point2F local_850;
	char local_845;
	int local_844;
	Container *local_840;
	Viewport *local_83c;
	undefined4 uStack2104;
	Point2F local_834;
	int local_82c;
	PointerType local_828;
	Vector3F local_824;
	Vector3F local_818;
	Vector3F local_80c;
	byte local_800 [2048];
	
	FUN_00417da0();
	local_828 = lego::front::Pointer_GetCurrentType();
	view = lego::globals::g_Game.viewMain;
	local_83c = lego::globals::g_Game.viewMain;
	local_840 = lego::view::Viewport_GetCamera(lego::globals::g_Game.viewMain);
	INT_004a2f4c = -1;
	*(undefined4 *)(param_2 + 0x24) = 0xffffffff;
	if (out_bool != (BOOL *)0x0) {
		*out_bool = 0;
	}
	lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_STANDARD);
	local_844 = param_2;
	local_82c = param_2;
	if ((DAT_004dc8bc == 0) && (DAT_004dc8c8 == 0)) {
		local_844 = FUN_00411930(param_1,param_2);
	}
	if ((((SubMenu *)param_2 == *lego::globals::menu::g_SaveMenu->menus) && (-1 < INT_004a2f4c)) &&
		 (INT_004a2f58 < 0)) {
		*(undefined4 *)(param_2 + 0x28) = 0;
		*(undefined4 *)(local_844 + 0x28) = 0;
	}
	if (-1 < INT_004a2f50) {
		local_844 = local_82c;
	}
	iVar18 = *(int *)(param_2 + 0x2c);
	iVar22 = *(int *)(param_2 + 0x30);
	if ((lego::globals::g_MenuWipeResource != (Container *)0x0) && (((byte)FLAGS_005584f0 & 1) != 0))
	{
		lego::view::Viewport_Clear(view,1);
		lego::res::Container_SetParent(lego::globals::g_MenuWipeResource,lego::globals::g_Game.resRoot);
		pCVar11 = lego::view::Viewport_GetCamera(view);
		local_840 = pCVar11;
		lego::res::Container_GetPosition(pCVar11,(Container *)0x0,&local_80c);
		lego::res::Container_GetOrientation(pCVar11,(Container *)0x0,&local_818,&local_824);
		lego::res::Container_SetPosition(pCVar11,(Container *)0x0,0.0,0.0,5.0);
		lego::res::Container_SetOrientation(pCVar11,(Container *)0x0,0.0,0.0,1.0,0.0,1.0,0.0);
		lego::res::Container_SetAnimationTime(lego::globals::g_MenuWipeResource,FLOAT_005584f4);
	}
	FUN_00412a20(param_2,1);
	if ((SubMenu *)param_2 != *lego::globals::menu::g_SaveMenu->menus) {
		FUN_004120e0(param_2);
	}
	FUN_00412680(&param_2,&local_844,&local_82c);
	if (*(int *)(param_2 + 0x48) != 0) {
		pcVar12 = lego::util::replaceTextSpaces(*(char **)(param_2 + 4));
		uVar13 = lego::image::FontX_GetStringWidth(*(ImageFont **)(param_2 + 0xc),pcVar12);
		iVar21 = *(int *)(param_2 + 0x54);
		iVar20 = (int)lego::globs::mainGlobs.appWidth / 2;
		pcVar12 = lego::util::replaceTextSpaces(*(char **)(param_2 + 4));
		lego::image::Font_PrintF
							(*(ImageFont **)(param_2 + 0xc),iVar20 - (uVar13 >> 1),iVar21 + iVar22,pcVar12);
	}
	INT_004a2f48 = -1;
	local_834.x = 0.0;
	if (0 < *(int *)(param_2 + 0x1c)) {
		do {
			fVar10 = local_834.x;
			if ((*(float *)(param_2 + 0x24) != local_834.x) || (DAT_004dc8bc != 0)) {
LAB_004131e8:
				iVar21 = (int)fVar10 * 4;
				ppcVar2 = *(char ***)(*(int *)(param_2 + 0x18) + iVar21);
				pcVar12 = ppcVar2[6];
				pcVar23 = ppcVar2[7];
				pcVar3 = ppcVar2[8];
				ppIVar1 = (ImageFont **)(ppcVar2 + 3);
				if (ppcVar2[3] != (char *)0x0) {
					pcVar15 = lego::util::replaceTextSpaces(*ppcVar2);
					lego::image::Font_PrintF
										(*(ImageFont **)(*(int *)(*(int *)(param_2 + 0x18) + iVar21) + 0xc),
										 (int)pcVar3 + (int)pcVar12 + iVar18,(int)(pcVar23 + iVar22),"%s",pcVar15);
				}
				iVar21 = *(int *)(*(int *)(param_2 + 0x18) + iVar21);
				switch(*(undefined4 *)(iVar21 + 0x14)) {
				case 0:
					piVar8 = *(int **)(iVar21 + 0x10);
					if (*ppIVar1 != (ImageFont *)0x0) {
						pcVar15 = lego::util::replaceTextSpaces(*(char **)(*piVar8 + *(int *)piVar8[3] * 4));
						pcVar23 = pcVar23 + iVar22 + piVar8[5];
						pIVar17 = *ppIVar1;
						pcVar12 = pcVar12 + (int)(pcVar3 + piVar8[4] + iVar18);
						goto LAB_004134b2;
					}
					break;
				case 2:
					ppcVar2 = *(char ***)(iVar21 + 0x10);
					if (*ppIVar1 != (ImageFont *)0x0) {
						pcVar15 = lego::util::replaceTextSpaces(*ppcVar2);
						lego::image::Font_PrintF
											(*ppIVar1,(int)(pcVar12 + (int)(ppcVar2[4] + (int)pcVar3 + iVar18)),
											 (int)ppcVar2[5] + (int)pcVar23 + iVar22,"%s",pcVar15);
					}
					break;
				case 3:
					ppiVar6 = *(int ***)(iVar21 + 0x10);
					FUN_00411e40((int)ppiVar6,(int)ppiVar6[3] + (int)pcVar12 + iVar18,
											 (int)ppiVar6[4] + (int)pcVar23 + iVar22,**ppiVar6 - (int)ppiVar6[1],
											 (uint)((int)ppiVar6[2] - (int)ppiVar6[1]));
					break;
				case 4:
					ppfVar7 = *(float ***)(iVar21 + 0x10);
					if (*ppIVar1 != (ImageFont *)0x0) {
						lego::image::Font_PrintF
											(*ppIVar1,(int)(pcVar12 + iVar18 + (int)ppfVar7[4] + (int)pcVar3),
											 (int)ppfVar7[5] + (int)pcVar23 + iVar22,"%.2f",(double)**ppfVar7);
					}
					break;
				case 6:
					piVar8 = *(int **)(iVar21 + 0x10);
					iVar21 = 0;
					if (0 < piVar8[0xe]) {
						do {
							local_850.x = (float)(iVar21 + piVar8[0x13]);
							if (piVar8[7] <= (int)local_850.x) break;
							iVar20 = -(*(int *)(piVar8[1] + (int)local_850.x * 4) / 2);
							puVar19 = (uint *)((int)local_850.x * 0x20 + *piVar8);
							uVar13 = ~*puVar19 >> 1 & 2;
							if (*(int *)(param_2 + 0x44) == 0) {
								iVar20 = 0;
							}
							if (uVar13 == 0) {
								uVar13 = 1;
							}
							FUN_00412380((int)(pcVar12 +
																(int)Point2F_005584dc.x + iVar18 + piVar8[0xb] + puVar19[5] + iVar20
																),(int)(pcVar23 +
																			 (int)Point2F_005584dc.y +
																			 iVar22 + piVar8[0xd] * iVar21 + piVar8[0xc] + puVar19[6]),
													 (undefined4 *)*ppIVar1,piVar8,(int)local_850.x,uVar13);
							FUN_00412420(param_2,iVar21 + piVar8[0x13],piVar8,0);
							iVar21 = iVar21 + 1;
						} while (iVar21 < piVar8[0xe]);
					}
					if ((piVar8[0x13] < piVar8[7] - piVar8[0xe]) && (*ppIVar1 != (ImageFont *)0x0)) {
						lego::image::Font_PrintF
											(*ppIVar1,piVar8[0xf] + iVar18,piVar8[0x10] + iVar22,(char *)piVar8[8]);
					}
					if ((0 < piVar8[0x13]) && (pIVar17 = *ppIVar1, pIVar17 != (ImageFont *)0x0)) {
						pcVar15 = (char *)piVar8[9];
						pcVar23 = (char *)piVar8[0x12];
						pcVar12 = (char *)piVar8[0x11];
						goto LAB_004134b1;
					}
				}
				goto switchD_00413263_caseD_1;
			}
			iVar21 = (int)local_834.x * 4;
			BVar14 = FUN_00411900(*(int *)(*(int *)(param_2 + 0x18) + iVar21));
			if (BVar14 != 0) goto LAB_004131e8;
			ppcVar2 = *(char ***)(*(int *)(param_2 + 0x18) + iVar21);
			pcVar23 = ppcVar2[7];
			pcVar12 = ppcVar2[6];
			pcVar3 = ppcVar2[9];
			local_850.x = (float)pcVar12;
			if (ppcVar2[2] != (char *)0x0) {
				pcVar15 = lego::util::replaceTextSpaces(*ppcVar2);
				lego::image::Font_PrintF
									((ImageFont *)ppcVar2[2],(int)pcVar3 + (int)pcVar12 + iVar18,
									 (int)(pcVar23 + iVar22),"%s",pcVar15);
			}
			iVar20 = *(int *)(*(int *)(param_2 + 0x18) + *(int *)(param_2 + 0x24) * 4);
			switch(*(undefined4 *)(iVar20 + 0x14)) {
			case 0:
				piVar8 = *(int **)(iVar20 + 0x10);
				if (ppcVar2[2] == (char *)0x0) break;
				pcVar15 = lego::util::replaceTextSpaces(*(char **)(*piVar8 + *(int *)piVar8[3] * 4));
				pcVar23 = pcVar23 + piVar8[5];
				pIVar17 = (ImageFont *)ppcVar2[2];
				pcVar12 = (char *)((int)local_850.x + (int)(pcVar3 + piVar8[4]));
LAB_004134b1:
				pcVar23 = pcVar23 + iVar22;
				pcVar12 = pcVar12 + iVar18;
				goto LAB_004134b2;
			case 2:
				ppcVar4 = *(char ***)(iVar20 + 0x10);
				local_845 = (*ppcVar4)[(int)ppcVar4[2]];
				DAT_004dc8dc = DAT_004dc8dc + 1;
				if ((DAT_004dc8dc != 0) &&
					 (uVar13 = DAT_004dc8dc / 2 >> 0x1f,
					 ((DAT_004dc8dc / 2 ^ uVar13) - uVar13 & 1 ^ uVar13) != uVar13)) {
					(*ppcVar4)[(int)ppcVar4[2]] = '_';
				}
				if (ppcVar2[2] != (char *)0x0) {
					pcVar12 = lego::util::replaceTextSpaces(*ppcVar4);
					lego::image::Font_PrintF
										((ImageFont *)ppcVar2[2],
										 (int)((int)local_850.x + (int)(ppcVar4[4] + (int)pcVar3 + iVar18)),
										 (int)ppcVar4[5] + (int)pcVar23 + iVar22,"%s",pcVar12);
				}
				if ((DAT_004dc8dc != 0) &&
					 (uVar13 = DAT_004dc8dc / 2 >> 0x1f,
					 ((DAT_004dc8dc / 2 ^ uVar13) - uVar13 & 1 ^ uVar13) != uVar13)) {
					(*ppcVar4)[(int)ppcVar4[2]] = local_845;
				}
				break;
			case 3:
				ppiVar6 = *(int ***)(iVar20 + 0x10);
				FUN_00411e40((int)ppiVar6,(int)ppiVar6[3] + (int)pcVar12 + iVar18,
										 (int)ppiVar6[4] + (int)pcVar23 + iVar22,**ppiVar6 - (int)ppiVar6[1],
										 (uint)((int)ppiVar6[2] - (int)ppiVar6[1]));
				break;
			case 4:
				ppfVar7 = *(float ***)(iVar20 + 0x10);
				if ((ImageFont *)ppcVar2[2] != (ImageFont *)0x0) {
					lego::image::Font_PrintF
										((ImageFont *)ppcVar2[2],(int)(pcVar12 + iVar18 + (int)ppfVar7[4] + (int)pcVar3)
										 ,(int)ppfVar7[5] + (int)pcVar23 + iVar22,"%.2f",(double)**ppfVar7);
				}
				break;
			case 6:
				puVar5 = *(undefined4 **)(*(int *)(param_2 + 0x18) + iVar21);
				piVar8 = (int *)puVar5[4];
				iVar21 = FUN_00411290(param_2,puVar5,piVar8);
				local_864 = 0;
				INT_004a2f48 = iVar21;
				if (0 < piVar8[0xe]) {
					do {
						iVar20 = piVar8[0x13] + local_864;
						if (piVar8[7] <= iVar20) break;
						puVar19 = (uint *)(iVar20 * 0x20 + *piVar8);
						iVar16 = -(*(int *)(piVar8[1] + iVar20 * 4) / 2);
						uVar13 = ~*puVar19 >> 1 & 2;
						if (*(int *)(param_2 + 0x44) == 0) {
							iVar16 = 0;
						}
						if (iVar21 == iVar20) {
							FUN_00412380((int)((int)local_850.x +
																(int)Point2F_005584dc.x + iVar18 + piVar8[0xb] + puVar19[5] + iVar16
																),(int)(pcVar23 +
																			 (int)Point2F_005584dc.y +
																			 iVar22 + piVar8[0xd] * local_864 + piVar8[0xc] + puVar19[6]),
													 (undefined4 *)ppcVar2[2],piVar8,iVar20,uVar13);
							if ((code *)piVar8[0x15] != (code *)0x0) {
								(*(code *)piVar8[0x15])();
							}
							iVar20 = 1;
						}
						else {
							if (uVar13 == 0) {
								uVar13 = 1;
							}
							FUN_00412380((int)((int)local_850.x +
																(int)Point2F_005584dc.x + iVar18 + piVar8[0xb] + puVar19[5] + iVar16
																),(int)(pcVar23 +
																			 (int)Point2F_005584dc.y +
																			 iVar22 + piVar8[0xd] * local_864 + piVar8[0xc] + puVar19[6]),
													 (undefined4 *)ppcVar2[3],piVar8,iVar20,uVar13);
							iVar20 = 0;
						}
						FUN_00412420(param_2,local_864 + piVar8[0x13],piVar8,iVar20);
						local_864 = local_864 + 1;
					} while (local_864 < piVar8[0xe]);
				}
				if ((iVar21 == -2) && (piVar8[0x13] < piVar8[7] - piVar8[0xe])) {
					pIVar17 = (ImageFont *)ppcVar2[2];
joined_r0x00413184:
					if (pIVar17 != (ImageFont *)0x0) {
						lego::image::Font_PrintF
											(pIVar17,piVar8[0xf] + iVar18,piVar8[0x10] + iVar22,(char *)piVar8[8]);
					}
				}
				else {
					if (piVar8[0x13] < piVar8[7] - piVar8[0xe]) {
						pIVar17 = (ImageFont *)ppcVar2[3];
						goto joined_r0x00413184;
					}
				}
				if (iVar21 != -3) {
					if (0 < piVar8[0x13]) {
						pIVar17 = (ImageFont *)ppcVar2[3];
						goto LAB_004131c3;
					}
					break;
				}
				if (piVar8[0x13] < 1) break;
				pIVar17 = (ImageFont *)ppcVar2[2];
LAB_004131c3:
				if (pIVar17 == (ImageFont *)0x0) break;
				pcVar15 = (char *)piVar8[9];
				pcVar23 = (char *)(piVar8[0x12] + iVar22);
				pcVar12 = (char *)(piVar8[0x11] + iVar18);
LAB_004134b2:
				lego::image::Font_PrintF(pIVar17,(int)pcVar12,(int)pcVar23,pcVar15);
			}
switchD_00413263_caseD_1:
			local_834.x = (float)((int)local_834.x + 1);
		} while ((int)local_834.x < *(int *)(param_2 + 0x1c));
	}
	FUN_00412900(&param_2);
	iVar22 = 0;
	iVar18 = param_2;
	if (0 < *(int *)(param_2 + 0x1c)) {
		do {
			iVar21 = *(int *)(*(int *)(iVar18 + 0x18) + iVar22 * 4);
			if (*(int *)(iVar21 + 0x28) != 0) {
				if (*(int *)(iVar18 + 0x24) == iVar22) {
					if (*(ImageBMP **)(iVar21 + 0x30) != (ImageBMP *)0x0) {
						local_834.x = (float)(*(int *)(iVar21 + 0x18) + *(int *)(iVar18 + 0x2c));
						local_834.y = (float)(*(int *)(iVar21 + 0x1c) + *(int *)(iVar18 + 0x30));
						lego::image::Image_DisplayScaled
											(*(ImageBMP **)(iVar21 + 0x30),(Rect2F *)0x0,&local_834,(Size2F *)0x0);
					}
					lego::front::ToolTip_AddFlag4(*(int *)(iVar21 + 0x34));
					iVar18 = param_2;
				}
				else {
					if (*(ImageBMP **)(iVar21 + 0x2c) != (ImageBMP *)0x0) {
						local_850.x = (float)(*(int *)(iVar21 + 0x18) + *(int *)(iVar18 + 0x2c));
						local_850.y = (float)(*(int *)(iVar21 + 0x1c) + *(int *)(iVar18 + 0x30));
						lego::image::Image_DisplayScaled
											(*(ImageBMP **)(iVar21 + 0x2c),(Rect2F *)0x0,&local_850,(Size2F *)0x0);
						iVar18 = param_2;
					}
				}
			}
			iVar22 = iVar22 + 1;
		} while (iVar22 < *(int *)(iVar18 + 0x1c));
	}
	if (((((lego::globs::mainGlobs.flags & CMD_SHOWVERSION) != CMD_NONE) &&
			 (FONT_00558078 != (ImageFont *)0x0)) && (lego::globals::g_Main_Version != (char *)0x0)) &&
		 (lego::globs::mainGlobs.programmerLevel == PROGRAMMER_OFF)) {
		lego::image::Font_PrintF(FONT_00558078,0x221,0x1c2,lego::globals::g_Main_Version);
	}
	lego::unk::Lego_UnkPrintf_FUN_00410250((ImageFont *)0x0,0,0,(char *)0x0);
	if (((SubMenu *)param_2 == *lego::globals::menu::g_SaveMenu->menus) && (DAT_004dc8bc != 0)) {
		std::sprintf((char *)local_800,lego::globals::menu::g_MenuOverwrite_Text);
		INT_004a2f58 = FUN_004354f0((byte *)lego::globals::menu::g_MenuOverwrite_Title,local_800,
																(byte *)lego::globals::menu::g_MenuOverwrite_Ok,
																(byte *)lego::globals::menu::g_MenuOverwrite_Cancel);
		if (INT_004a2f58 == 0) {
			DAT_00558508 = 1;
			*(undefined4 *)(param_2 + 0x28) = 1;
			DAT_004dc8bc = 0;
			lego::globals::g_SaveMenu_OutNumber = -1;
		}
		else {
			if (INT_004a2f58 == 1) {
				DAT_00558508 = 0;
				*(undefined4 *)(param_2 + 0x28) = 1;
				DAT_004dc8bc = 0;
			}
		}
	}
	if ((lego::globals::g_MenuWipeResource != (Container *)0x0) && (((byte)FLAGS_005584f0 & 1) != 0))
	{
		lego::res::Container_Hide(PTR_005584fc,0);
		lego::view::Viewport_Render(local_83c,lego::globals::g_Game.resRoot,0.0);
		lego::res::Container_Hide(PTR_005584fc,1);
		pCVar11 = local_840;
		lego::res::Container_SetPosition(local_840,(Container *)0x0,local_80c.x,local_80c.y,local_80c.z)
		;
		lego::res::Container_SetOrientation
							(pCVar11,(Container *)0x0,local_818.x,local_818.y,local_818.z,local_824.x,local_824.y,
							 local_824.z);
		lego::res::Container_SetParent(lego::globals::g_MenuWipeResource,(Container *)0x0);
		local_83c = (Viewport *)
								lego::res::Container_GetAnimationFrames(lego::globals::g_MenuWipeResource);
		uStack2104 = 0;
		local_840 = (Container *)(float)ZEXT48(local_83c);
		local_83c = (Viewport *)lego::main::Main_GetTime();
		uStack2104 = 0;
		uVar9 = ZEXT48(local_83c);
		fVar10 = ((float)uVar9 - FLOAT_005584f8) * 0.001 * 25.0;
		local_850.x = fVar10 + fVar10;
		if ((ushort)((ushort)(local_850.x < 3.0) << 8 | (ushort)(local_850.x == 3.0) << 0xe) == 0) {
			local_850.x = 3.0;
		}
		fVar10 = (float)local_840 * 0.5;
		if (((ushort)((ushort)(FLOAT_005584f4 < fVar10) << 8 | (ushort)(FLOAT_005584f4 == fVar10) << 0xe
								 ) != 0) && (fVar10 <= local_850.x + FLOAT_005584f4)) {
			if (out_bool != (BOOL *)0x0) {
				*out_bool = 1;
			}
			INT_004a2f50 = -1;
			INT_004a2f4c = -1;
			DAT_004dc8c8 = 0;
			DAT_004dc8c0 = 0;
			if (DAT_0055806c != 0) {
				TIMEUINT_00558070 = 0;
				TIMEUINT_00558074 = 0;
			}
		}
		if ((ushort)((ushort)(FLOAT_005584f4 < (float)local_840) << 8 |
								(ushort)(FLOAT_005584f4 == (float)local_840) << 0xe) == 0) {
			lego::unk::Lego_UnsetFlag3_005584f0();
		}
		FLOAT_005584f4 = local_850.x + FLOAT_005584f4;
		FLOAT_005584f8 = (float)uVar9;
	}
	lego::front::Pointer_DrawPointer(lego::globs::INPUT.msx,lego::globs::INPUT.msy);
	lego::front::Pointer_SetType_IfUnkFloatLessThan0(local_828);
	return local_844;
}



void __cdecl FUN_004138a0(int param_1)
{
	int iVar1;
	float fVar2;
	float10 fVar3;
	longlong lVar4;
	
	if ((*(int *)(param_1 + 0x10) == 0) || ((*(byte *)(param_1 + 0x34) & 2) == 0)) {
		Point2F_005584dc.x = 0.0;
		Point2F_005584dc.y = 0.0;
	}
	else {
		fVar2 = (float)lego::globs::INPUT.msy;
		if (((ushort)((ushort)(fVar2 < 280.0) << 8 | (ushort)(fVar2 == 280.0) << 0xe) == 0) ||
			 (fVar2 < 200.0)) {
			iVar1 = *(int *)(*(int *)(param_1 + 0x10) + 8);
			if ((fVar2 < 480.0) && ((lego::globs::INPUT.mslb == 0 && (lego::globs::INPUT.msrb == 0)))) {
				fVar3 = (float10)lego::globs::INPUT.msy * (float10)0.2083333 - (float10)50.0;
				fVar3 = fVar3 * fVar3 * (float10)0.02;
				if (fVar2 < 240.0) {
					fVar3 = -fVar3;
				}
				lVar4 = __ftol(fVar3 * (float10)-0.25);
				Point2F_005584dc.y = (float)((int)Point2F_005584dc.y + (int)lVar4);
			}
			if (0 < (int)Point2F_005584dc.y) {
				Point2F_005584dc.y = 0.0;
			}
			if (SBORROW4((int)Point2F_005584dc.y + -0x1e0,-iVar1) !=
					(int)Point2F_005584dc.y + -0x1e0 + iVar1 < 0) {
				Point2F_005584dc.y = (float)(0x1e0 - iVar1);
				return;
			}
		}
	}
	return;
}



void __cdecl FUN_00413990(void)
{
	char *pcVar1;
	ImageBMP *pIVar2;
	int iVar3;
	float *pfVar4;
	uint saveIndex;
	ImageBMP **ppIVar5;
	void **ppvVar6;
	int iVar7;
	undefined4 *puVar8;
	undefined4 local_b8;
	undefined4 local_b4 [5];
	uint local_a0;
	void *local_84;
	
	iVar7 = 0;
	ppIVar5 = lego::globals::g_SaveSlotImages_TABLE;
	do {
		pcVar1 = lego::cfg::CFG_JoinPath
											 (lego::globals::g_Game.CfgRootName,"Menu::SaveImage","Path",0,iVar7);
		pcVar1 = lego::cfg::CFG_CopyString(lego::globals::g_Game.LegoCfgRoot,pcVar1);
		std::sprintf((char *)&local_b8,"%s\\%d.dat",pcVar1);
		pIVar2 = lego::image::Image_LoadBMPScaled((char *)&local_b8,0,0);
		*ppIVar5 = pIVar2;
		ppIVar5 = ppIVar5 + 1;
		iVar7 = iVar7 + 1;
	} while (ppIVar5 < &DAT_004dc8a4);
	saveIndex = 0;
	ppvVar6 = lego::globals::g_SaveSlotPtrs_TABLE;
	do {
		local_b8 = 0;
		puVar8 = local_b4;
		for (iVar7 = 0x2d; iVar7 != 0; iVar7 = iVar7 + -1) {
			*puVar8 = 0;
			puVar8 = puVar8 + 1;
		}
		lego::game::Game_UnkLoadSaveSlot__004179c0(saveIndex,&local_b8,1);
		*ppvVar6 = (void *)0x0;
		if (8 < local_a0) {
			pfVar4 = (float *)((int)local_84 + 0x1bc38);
			iVar7 = local_a0 - 8;
			do {
				if (*pfVar4 == 0.0) {
					iVar3 = 0;
				}
				else {
					iVar3 = 4;
				}
				*ppvVar6 = (void *)((int)*ppvVar6 + iVar3);
				pfVar4 = pfVar4 + 0xc64;
				iVar7 = iVar7 + -1;
			} while (iVar7 != 0);
		}
		std::free(local_84);
		ppvVar6 = ppvVar6 + 1;
		saveIndex = saveIndex + 1;
	} while (ppvVar6 < &DAT_004dc8bc);
	return;
}



void __cdecl FUN_00413a80(void)
{
	ImageBMP **ppIVar1;
	
	ppIVar1 = lego::globals::g_SaveSlotImages_TABLE;
	do {
		if (*ppIVar1 != (ImageBMP *)0x0) {
			lego::image::Image_Remove(*ppIVar1);
		}
		ppIVar1 = ppIVar1 + 1;
	} while (ppIVar1 < &DAT_004dc8a4);
	return;
}



// WARNING: Type propagation algorithm not settling

void __cdecl lego::front::MenuLoop_FUN_00413ab0(int param_1)
{
	int iVar1;
	bool bVar2;
	float milliseconds;
	SubMenu *pSVar3;
	DWORD DVar4;
	RewardFrontEnd *pRVar5;
	char *pcVar6;
	BOOL local_98;
	SubMenu *local_94;
	float local_90;
	DWORD local_8c;
	uint local_88;
	undefined4 uStack132;
	char local_80 [128];
	
	bVar2 = false;
	local_98 = 0;
	local_90 = 1.0;
	FUN_00413990();
	DAT_004dc8c8 = 0;
	INT_004a2f50 = -1;
	INT_004a2f4c = -1;
	INT_004a2f54 = -1;
	INT_004a2f58 = -1;
	globals::g_SaveMenu_OutNumber = -1;
	DAT_004dc8c0 = 0;
	DAT_004dc8bc = 0;
	BOOL_004dc8c4 = 0;
	globals::g_SaveMenu_IsLoadMode = 1;
	DAT_00558508 = 1;
	DAT_0055806c = (ImageFlic *)0x0;
	local_8c = timeGetTime();
	iVar1 = *(int *)(param_1 + 0x28);
	milliseconds = local_90;
	while (local_90 = milliseconds, iVar1 == 0) {
		if (bVar2) {
			FUN_00412b30(milliseconds,param_1,&local_98);
		}
		else {
			local_94 = (SubMenu *)FUN_00412b30(milliseconds,param_1,(BOOL *)0x0);
		}
		if (((SubMenu *)param_1 == *globals::menu::g_MainMenuFull->menus) &&
			 (local_94 != (SubMenu *)param_1)) {
			INT_00558028 = -1;
			FUN_00414fe0(milliseconds,-1);
		}
		FUN_004138a0(param_1);
		ToolTip_Update_FUN_0046ba80(globs::INPUT.msx,globs::INPUT.msy,milliseconds);
		snd::Audio_UnkUpdate_FUN_00465460(milliseconds);
		main::Main_LoopUpdate(0);
		DVar4 = timeGetTime();
		pSVar3 = local_94;
		local_88 = DVar4 - local_8c;
		uStack132 = 0;
		local_90 = (float)(ulonglong)local_88 * 0.025;
		local_8c = DVar4;
		if ((!bVar2) && (local_94 != (SubMenu *)param_1)) {
			FUN_00410320();
			bVar2 = true;
			if (globals::g_MenuWipeResource == (Container *)0x0) {
				local_98 = 1;
			}
		}
		if ((bVar2) && (local_98 != 0)) {
			if ((*(ImageBMP **)(param_1 + 0x10) != pSVar3->MenuImage) &&
				 (DAT_0055806c != (ImageFlic *)0x0)) {
				image::Flic_Close(DAT_0055806c);
				std::free(DAT_0055806c);
				snd::Sound3D_Stream_Stop(0);
				DAT_0055806c = (ImageFlic *)0x0;
				TIMEUINT_00558070 = 0;
				TIMEUINT_00558074 = 0;
			}
			Point2F_005584dc.y = 0.0;
			Point2F_005584dc.x = 0.0;
			bVar2 = false;
			local_98 = 0;
			param_1 = (int)pSVar3;
		}
		milliseconds = local_90;
		iVar1 = *(int *)(param_1 + 0x28);
	}
	FUN_00413a80();
	if ((((local_94 == *globals::menu::g_SaveMenu->menus) && (-1 < globals::g_SaveMenu_OutNumber)) &&
			(pRVar5 = reward::GetCurrentRewardFrontEnd(), pRVar5 != (RewardFrontEnd *)0x0)) &&
		 (pRVar5 = reward::GetCurrentRewardFrontEnd(), *(int *)&pRVar5->field_0x4 != 0)) {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu::SaveImage","Path",0);
		pcVar6 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar6);
		std::sprintf(local_80,"%s\\%d.dat",pcVar6,globals::g_SaveMenu_OutNumber);
		image::Image_SaveBMP((ImageBMP *)&pRVar5->field_0x8,local_80);
	}
	if (DAT_0055806c != (ImageFlic *)0x0) {
		image::Flic_Close(DAT_0055806c);
		std::free(DAT_0055806c);
		snd::Sound3D_Stream_Stop(0);
		DAT_0055806c = (ImageFlic *)0x0;
		TIMEUINT_00558070 = 0;
		TIMEUINT_00558074 = 0;
	}
	unk::Lego_UnsetFlag3_005584f0();
	return;
}



void __cdecl lego::front::Menu_FUN_00413d50(int *param_1,int param_2)
{
	int iVar1;
	
	iVar1 = 0;
	if (0 < param_1[1]) {
		do {
			iVar1 = iVar1 + 1;
			*(undefined4 *)(*(int *)(*param_1 + -4 + iVar1 * 4) + 0x28) = 0;
		} while (iVar1 < param_1[1]);
	}
	MenuLoop_FUN_00413ab0(*(int *)(*param_1 + param_2 * 4));
	return;
}



MenuItemType __cdecl lego::front::Menu_ParseMenuControlType(char *controlName)
{
	int iVar1;
	
	iVar1 = std::_stricmp(controlName,"cycle");
	if (iVar1 == 0) {
		return MENUITEM_CYCLE;
	}
	iVar1 = std::_stricmp(controlName,"trigger");
	if (iVar1 == 0) {
		return MENUITEM_TRIGGER;
	}
	iVar1 = std::_stricmp(controlName,"textinput");
	if (iVar1 == 0) {
		return MENUITEM_TEXTINPUT;
	}
	iVar1 = std::_stricmp(controlName,"slider");
	if (iVar1 == 0) {
		return MENUITEM_SLIDER;
	}
	iVar1 = std::_stricmp(controlName,"realslider");
	if (iVar1 == 0) {
		return MENUITEM_REALSLIDER;
	}
	iVar1 = std::_stricmp(controlName,"next");
	return (-(uint)(iVar1 != 0) & 0xfffffffa) + MENUITEM_NEXT;
}



char * __cdecl lego::util::stringReplaceChar(char *text,char origChar,char newChar)
{
	char *pcVar1;
	char *pcVar2;
	char c;
	
	c = *text;
	pcVar2 = text;
	while (c != '\0') {
		if (c == origChar) {
			*pcVar2 = newChar;
		}
		pcVar1 = pcVar2 + 1;
		pcVar2 = pcVar2 + 1;
		c = *pcVar1;
	}
	return text;
}



int __cdecl lego::front::Menu_GetOverlayType(char **param_1)
{
	char *pcVar1;
	char cVar2;
	int iVar3;
	char *_Str2;
	
	_Str2 = *param_1;
	cVar2 = *_Str2;
	while (cVar2 != '.') {
		pcVar1 = _Str2 + 1;
		_Str2 = _Str2 + 1;
		cVar2 = *pcVar1;
	}
	iVar3 = std::_stricmp(".avi",_Str2);
	if (iVar3 != 0) {
		iVar3 = std::_stricmp(".bmp",_Str2);
		if (iVar3 != 0) {
			iVar3 = std::_stricmp(".lws",_Str2);
			return (-(uint)(iVar3 != 0) & 0xfffffffd) + 3;
		}
		return 2;
	}
	return 1;
}



// ref_overlay functions as an input argument for the last overlay, and output argument for the new
// overlay (which is linked to the previous via linked list)

SubMenuOverlay * __cdecl
lego::front::Menu_CreateOverlay
					(char *filename,SubMenuOverlay **ref_overlay,int positionX,int positionY,SFXType sfxType)
{
	SubMenuOverlay *pSVar1;
	char *pcVar2;
	int iVar3;
	SubMenuOverlay *pSVar4;
	
	pSVar1 = (SubMenuOverlay *)std::malloc(0x20);
	pSVar4 = pSVar1;
	for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {
		pSVar4->filename = (char *)0x0;
		pSVar4 = (SubMenuOverlay *)&pSVar4->overlayType;
	}
	iVar3 = std::_strnicmp(filename,"Null",4);
	if (iVar3 != 0) {
		if (filename != (char *)0x0) {
			pcVar2 = std::_strdup2(filename);
			pSVar1->filename = pcVar2;
		}
		iVar3 = Menu_GetOverlayType((char **)pSVar1);
		pSVar1->overlayType = iVar3;
		pSVar1->field_1c = 0;
		pSVar4 = *ref_overlay;
		(pSVar1->position).x = positionX;
		pSVar1->previous = pSVar4;
		pSVar1->sfxType = sfxType;
		(pSVar1->position).y = positionY;
		*ref_overlay = pSVar1;
	}
	return pSVar1;
}



void __cdecl lego::front::Menu_SubMenuSlider_FUN_00413f40(int param_1,int param_2,int **param_3)
{
	ImageBMP *image;
	int iVar1;
	char **ppcVar2;
	
	if (param_1 == 0x10) {
		ppcVar2 = (char **)(param_2 + 0x20);
		iVar1 = 8;
		do {
			image = unk::ImageStruct10_LoadImage(*ppcVar2);
			*param_3 = (int *)image;
			if (image != (ImageBMP *)0x0) {
				lego::image::Image_SetPenZeroTrans(image);
			}
			ppcVar2 = ppcVar2 + 1;
			param_3 = (int **)((ImageBMP **)param_3 + 1);
			iVar1 = iVar1 + -1;
		} while (iVar1 != 0);
		return;
	}
	for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {
		*param_3 = (int *)0x0;
		param_3 = param_3 + 1;
	}
	return;
}



MenuCollection * __cdecl lego::front::Menu_CreateCollection(uint count)
{
	MenuCollection *menuCollection;
	SubMenu **ppSVar1;
	uint uVar2;
	int iVar3;
	
	menuCollection = (MenuCollection *)std::malloc(8);
	menuCollection->menus = (SubMenu **)0x0;
	menuCollection->count = 0;
	ppSVar1 = (SubMenu **)std::malloc(count * 4);
	uVar2 = count & 0x3fffffff;
	menuCollection->menus = ppSVar1;
	for (; uVar2 != 0; uVar2 = uVar2 - 1) {
		*ppSVar1 = (SubMenu *)0x0;
		ppSVar1 = ppSVar1 + 1;
	}
	for (iVar3 = 0; iVar3 != 0; iVar3 = iVar3 + -1) {
		*(undefined *)ppSVar1 = 0;
		ppSVar1 = (SubMenu **)((int)ppSVar1 + 1);
	}
	menuCollection->count = count;
	return menuCollection;
}



MenuCollection * __cdecl
lego::front::Menu_ParseMenu(undefined param_1,char *menuName,void *dst,void *callback,...)
{
	MenuItemType MVar1;
	char *pcVar2;
	uint uVar3;
	MenuCollection *menuCol;
	char *pcVar4;
	char *pcVar5;
	int iVar6;
	int iVar7;
	BOOL3 BVar8;
	uint uVar9;
	char *pcVar10;
	SubMenu *pSVar11;
	int iVar12;
	ImageFont *loFont;
	ImageFont *hiFont;
	SFXType SVar13;
	MenuItemType MVar14;
	int *piVar15;
	int iVar16;
	int iVar17;
	SubMenuItem *pSVar18;
	void **ppvVar19;
	void **ppvVar20;
	float10 fVar21;
	void *pvVar22;
	int *piVar23;
	undefined4 uVar24;
	ImageFont *pIVar25;
	undefined4 uVar26;
	ImageFont *pIVar27;
	undefined4 uVar28;
	float highLimit;
	undefined4 uVar29;
	float step;
	void *pvVar30;
	undefined4 uVar31;
	undefined4 uVar32;
	undefined4 uVar33;
	MenuItemType MVar34;
	undefined4 uVar35;
	undefined4 *puVar36;
	BOOL BVar37;
	char **local_dd0;
	char *local_dcc;
	int local_dc8;
	SFXType local_dc4;
	char *local_dc0;
	uint local_dbc;
	int local_db8;
	int local_db4;
	int *local_db0;
	undefined4 local_dac;
	undefined4 local_da8;
	undefined4 local_da4;
	undefined4 local_da0;
	undefined4 local_d9c;
	undefined4 local_d98;
	undefined4 local_d94;
	char *local_d90;
	char *local_d8c;
	char *local_d88;
	char *local_d84;
	char *local_d80;
	char *local_d7c;
	char *local_d78;
	char *local_d74;
	char *local_d70;
	char local_c00 [1024];
	char local_800 [1024];
	char local_400 [1024];
	
	ppvVar19 = &dst;
	std::sprintf(local_400,"Menu::%s",menuName);
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_400,"MenuCount",0);
	pcVar2 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 == (char *)0x0) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_400,"MenuCount",0);
		pcVar2 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar2);
	}
	uVar3 = std::atoi(pcVar2);
	local_dbc = uVar3;
	menuCol = Menu_CreateCollection(uVar3);
	iVar12 = 0;
	if (0 < (int)uVar3) {
		do {
			local_db8 = iVar12 + 1;
			local_dc8 = 0;
			std::sprintf(local_c00,"%s::Menu%i",local_400,local_db8);
			pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,"Title",0);
			pcVar2 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar2);
			pcVar4 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,"FullName",0);
			pcVar4 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar4);
			pcVar5 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,"Position",0);
			pcVar5 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar5);
			util::Util_Tokenise(pcVar5,&local_d90,":");
			iVar6 = std::atoi(local_d90);
			iVar7 = std::atoi(local_d8c);
			if (pcVar5 != (char *)0x0) {
				std::free(pcVar5);
			}
			pcVar5 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,"MenuFont",0);
			pcVar5 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar5);
			loFont = unk::ImageStruct10_LoadFont(pcVar5);
			pcVar5 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,"AutoCenter",0);
			BVar8 = cfg::CFG_ReadBool(globals::g_Game.LegoCfgRoot,pcVar5);
			uVar3 = (uint)(BVar8 == BOOL3_TRUE);
			pcVar5 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,"DisplayTitle",0);
			BVar8 = cfg::CFG_ReadBool(globals::g_Game.LegoCfgRoot,pcVar5);
			local_dc4 = (SFXType)(BVar8 != BOOL3_FALSE);
			pcVar5 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,"Anchored",0);
			local_dc0 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar5);
			if (((uVar3 != 0) && (pcVar2 != (char *)0x0)) && (*pcVar2 != '\0')) {
				uVar9 = image::FontX_GetStringWidth(loFont,pcVar2);
				local_dc8 = -((int)uVar9 / 2);
			}
			pcVar5 = local_dc0;
			pcVar10 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,"CanScroll",0);
			BVar8 = cfg::CFG_ReadBool(globals::g_Game.LegoCfgRoot,pcVar10);
			uVar9 = (uint)(BVar8 == BOOL3_TRUE);
			SVar13 = local_dc4;
			pcVar4 = util::stringReplaceChar(pcVar4,'_',' ');
			pcVar10 = util::stringReplaceChar(pcVar2,'_',' ');
			pSVar11 = Menu_CreateSubMenu(pcVar10,pcVar4,loFont,iVar6,iVar7,uVar3,SVar13,local_dc8,uVar9,
																	 pcVar5);
			BVar37 = 1;
			menuCol->menus[iVar12] = pSVar11;
			pcVar4 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,"MenuImage",0);
			pcVar4 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar4);
			Menu_LoadMenuImage(menuCol->menus[iVar12],pcVar4,BVar37);
			BVar37 = 0;
			pcVar4 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,"MenuImageDark",0);
			pcVar4 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar4);
			Menu_LoadMenuImage(menuCol->menus[iVar12],pcVar4,BVar37);
			std::sprintf(menuCol->menus[iVar12]->CfgName,"%s",local_c00);
			pcVar4 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,menuCol->menus[iVar12]->CfgName,
																 "PlayRandom",0);
			BVar8 = cfg::CFG_ReadBool(globals::g_Game.LegoCfgRoot,pcVar4);
			menuCol->menus[iVar12]->PlayRandom = BVar8;
			std::free(pcVar2);
			iVar12 = local_db8;
			uVar3 = local_dbc;
		} while (local_db8 < (int)local_dbc);
	}
	iVar12 = 0;
	if ((int)uVar3 < 1) {
		return menuCol;
	}
LAB_00414425:
	local_db8 = iVar12 + 1;
	MVar1 = menuCol->menus[iVar12]->AutoCenter;
	std::sprintf(local_c00,"%s::Menu%i",local_400,local_db8);
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,"LoFont",0);
	pcVar2 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar2);
	loFont = unk::ImageStruct10_LoadFont(pcVar2);
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,"HiFont",0);
	pcVar2 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar2);
	hiFont = unk::ImageStruct10_LoadFont(pcVar2);
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,"ItemCount",0);
	pcVar2 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 == (char *)0x0) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,"ItemCount",0);
		pcVar2 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar2);
	}
	local_dc0 = (char *)std::atoi(pcVar2);
	local_dd0 = (char **)0x1;
	do {
		std::sprintf(local_800,"Overlay%i",local_dd0);
		pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,local_800,0);
		local_dcc = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar2);
		if (local_dcc == (char *)0x0) {
			if ((globs::mainGlobs.flags & CMD_REDUCEFLICS) != CMD_NONE) break;
			std::sprintf(local_800,"!Overlay%i",local_dd0);
			pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,local_800,0);
			local_dcc = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar2);
			if (local_dcc == (char *)0x0) break;
		}
		util::Util_Tokenise(local_dcc,&local_d90,":");
		SVar13 = snd::SFX_GetType(local_d8c,&local_dc4);
		if (SVar13 == SFX_NULL) {
			local_dc4 = SVar13;
		}
		SVar13 = local_dc4;
		iVar6 = std::atoi(local_d84);
		iVar7 = std::atoi(local_d88);
		Menu_CreateOverlay(local_d90,&menuCol->menus[iVar12]->Overlays,iVar7,iVar6,SVar13);
		if (local_dcc != (char *)0x0) {
			std::free(local_dcc);
		}
		local_dd0 = (char **)((int)local_dd0 + 1);
	} while( true );
	iVar6 = 0;
	ppvVar20 = ppvVar19;
	if (0 < (int)local_dc0) {
		do {
			local_db4 = iVar6 + 1;
			std::sprintf(local_800,"Item%i",local_db4);
			if (local_dcc != (char *)0x0) {
				std::free(local_dcc);
			}
			pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,local_c00,local_800,0);
			local_dcc = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar2);
			iVar6 = util::Util_Tokenise(local_dcc,&local_d90,":");
			MVar14 = Menu_ParseMenuControlType(local_d90);
			ppvVar19 = ppvVar20;
			MVar34 = MVar1;
			switch(MVar14) {
			case MENUITEM_CYCLE:
				pvVar30 = *ppvVar20;
				ppvVar19 = ppvVar20 + 2;
				pvVar22 = ppvVar20[1];
				iVar6 = std::atoi(local_d80);
				iVar7 = std::atoi(local_d84);
				uVar3 = std::atoi(local_d78);
				piVar15 = Menu_SubMenuCycle_FUN_00410940(uVar3,(int)pvVar30,iVar7,iVar6,(int)pvVar22);
				uVar32 = 0;
				MVar14 = MENUITEM_CYCLE;
				piVar23 = piVar15;
				iVar6 = std::atoi(local_d88);
				iVar7 = std::atoi(local_d8c);
				pIVar25 = loFont;
				pIVar27 = hiFont;
				pcVar2 = util::stringReplaceChar(local_d7c,'_',' ');
				pSVar18 = Menu_CreateItem3C(pcVar2,pIVar25,pIVar27,iVar7,iVar6,MVar14,MVar34,piVar23,uVar32)
				;
				Menu_AddSubMenuItem(menuCol->menus[iVar12],pSVar18);
				local_dc8 = 0;
				iVar6 = std::atoi(local_d78);
				if (0 < iVar6) {
					local_dd0 = &local_d74;
					do {
						pcVar2 = util::stringReplaceChar(*local_dd0,'_',' ');
						Menu_SubMenu_FUN_004109d0(piVar15,pcVar2);
						local_dc8 = local_dc8 + 1;
						local_dd0 = local_dd0 + 1;
						iVar6 = std::atoi(local_d78);
					} while (local_dc8 < iVar6);
				}
				break;
			case MENUITEM_TRIGGER:
				if (iVar6 == 8) {
					pvVar30 = *ppvVar20;
					ppvVar19 = ppvVar20 + 2;
					pvVar22 = ppvVar20[1];
					iVar6 = std::atoi(local_d74);
					pSVar11 = (SubMenu *)
										Menu_SubMenu_CreateItemC_FUN_00410a90(pvVar30,(uint)(iVar6 == 1),pvVar22);
					uVar32 = 1;
LAB_00414992:
					pcVar2 = local_d78;
					iVar6 = std::atoi(local_d88);
					iVar7 = std::atoi(local_d8c);
					pSVar18 = (SubMenuItem *)
										Menu_SubMenu_FUN_00410d50
															(____EMPTYSTR__,loFont,hiFont,(int)local_d84,(int)local_d80,iVar7,
															 iVar6,uVar32,MVar34,pcVar2,pSVar11);
					pSVar11 = menuCol->menus[iVar12];
					ppvVar20 = ppvVar19;
					goto LAB_00414b5a;
				}
				if (iVar6 != 5) break;
				pvVar30 = *ppvVar20;
				ppvVar19 = ppvVar20 + 2;
				uVar32 = 0;
				pvVar22 = ppvVar20[1];
				iVar6 = std::atoi(local_d80);
				puVar36 = (undefined4 *)
									Menu_SubMenu_CreateItemC_FUN_00410a90(pvVar30,(uint)(iVar6 == 1),pvVar22);
				MVar14 = MENUITEM_TRIGGER;
LAB_00414a6e:
				iVar6 = std::atoi(local_d88);
				iVar7 = std::atoi(local_d8c);
				pcVar2 = local_d84;
				ppvVar20 = ppvVar19;
				goto LAB_00414b41;
			case MENUITEM_SLIDER:
				pvVar30 = *ppvVar20;
				Menu_SubMenuSlider_FUN_00413f40(iVar6,(int)&local_d90,&local_db0);
				uVar32 = 0;
				pvVar22 = ppvVar20[1];
				piVar23 = local_db0;
				uVar24 = local_dac;
				uVar26 = local_da8;
				uVar28 = local_da4;
				uVar29 = local_da0;
				uVar31 = local_d9c;
				uVar33 = local_d98;
				uVar35 = local_d94;
				iVar6 = std::atoi(local_d80);
				iVar7 = std::atoi(local_d84);
				iVar16 = std::atoi(local_d74);
				iVar17 = std::atoi(local_d78);
				puVar36 = Menu_SubMenuItem_FUN_00410b20
														(pvVar30,iVar17,iVar16,iVar7,iVar6,pvVar22,piVar23,uVar24,uVar26,uVar28,
														 uVar29,uVar31,uVar33,uVar35);
				MVar14 = MENUITEM_SLIDER;
				goto LAB_00414b10;
			case MENUITEM_REALSLIDER:
				pvVar30 = *ppvVar20;
				uVar32 = 0;
				pvVar22 = ppvVar20[1];
				iVar6 = std::atoi(local_d80);
				iVar7 = std::atoi(local_d84);
				fVar21 = std::atof(local_d70);
				step = (float)fVar21;
				fVar21 = std::atof(local_d74);
				highLimit = (float)fVar21;
				fVar21 = std::atof(local_d78);
				puVar36 = Menu_CreateRealSlider(pvVar30,(float)fVar21,highLimit,step,iVar7,iVar6,pvVar22);
				MVar14 = MENUITEM_REALSLIDER;
LAB_00414b10:
				ppvVar20 = ppvVar20 + 2;
				iVar6 = std::atoi(local_d88);
				iVar7 = std::atoi(local_d8c);
				pcVar2 = local_d7c;
LAB_00414b41:
				pIVar25 = loFont;
				pIVar27 = hiFont;
				pcVar2 = util::stringReplaceChar(pcVar2,'_',' ');
				pSVar18 = Menu_CreateItem3C(pcVar2,pIVar25,pIVar27,iVar7,iVar6,MVar14,MVar34,puVar36,uVar32)
				;
				pSVar11 = menuCol->menus[iVar12];
LAB_00414b5a:
				Menu_AddSubMenuItem(pSVar11,pSVar18);
				ppvVar19 = ppvVar20;
				break;
			case MENUITEM_NEXT:
				if (iVar6 == 8) {
					iVar6 = std::atoi(local_d74 + 4);
					pSVar11 = menuCol->menus[iVar6 + -1];
					uVar32 = 5;
					goto LAB_00414992;
				}
				if (iVar6 == 6) {
					iVar6 = std::atoi(local_d80 + 4);
					uVar32 = 1;
				}
				else {
					if (*local_d80 == '\0') {
						uVar32 = 0;
						puVar36 = (undefined4 *)0x0;
						MVar14 = MVar1;
						MVar34 = MENUITEM_NEXT;
						goto LAB_00414a6e;
					}
					iVar6 = std::atoi(local_d80 + 4);
					uVar32 = 0;
				}
				pSVar11 = menuCol->menus[iVar6 + -1];
				MVar14 = MENUITEM_NEXT;
				iVar6 = std::atoi(local_d88);
				iVar7 = std::atoi(local_d8c);
				pIVar25 = loFont;
				pIVar27 = hiFont;
				pcVar2 = util::stringReplaceChar(local_d84,'_',' ');
				pSVar18 = Menu_CreateItem3C(pcVar2,pIVar25,pIVar27,iVar7,iVar6,MVar14,MVar34,pSVar11,uVar32)
				;
				pSVar11 = menuCol->menus[iVar12];
				goto LAB_00414b5a;
			}
			iVar6 = local_db4;
			ppvVar20 = ppvVar19;
		} while (local_db4 < (int)local_dc0);
	}
	if (local_dcc != (char *)0x0) {
		std::free(local_dcc);
	}
	iVar12 = local_db8;
	if ((int)local_dbc <= local_db8) {
		return menuCol;
	}
	goto LAB_00414425;
}



int __cdecl lego::front::Menu_GetSubMenuIDByName(MenuCollection *menuCol,char *name)
{
	int iVar1;
	int iVar2;
	
	iVar2 = 0;
	if ((int)menuCol->count < 1) {
		return -1;
	}
	while ((menuCol->menus[iVar2] == (SubMenu *)0x0 ||
				 (iVar1 = std::_stricmp((char *)menuCol->menus[iVar2]->ptr_0,name), iVar1 != 0))) {
		iVar2 = iVar2 + 1;
		if ((int)menuCol->count <= iVar2) {
			return -1;
		}
	}
	return iVar2;
}



BOOL __cdecl lego::main::Config_IsIntrosEnabled(void)
{
	char *keyPath;
	BOOL3 BVar1;
	
	keyPath = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","DontPlayAvis",0);
	BVar1 = cfg::CFG_ReadBool(globals::g_Game.LegoCfgRoot,keyPath);
	if ((BVar1 != BOOL3_TRUE) && (globs::mainGlobs.programmerLevel < PROGRAMMER_MODE_3)) {
		return 1;
	}
	return 0;
}



void __cdecl lego::front::PausedMenu_SliderBrightness(int slider_0_10)
{
	float r;
	float r_00;
	
	r = (float)slider_0_10 * 0.1;
	r_00 = r * 0.8 - -0.2;
	res::Container_SetColourAlpha(globals::g_Game.resTopSpotlight,r,r,r,1.0);
	res::Container_SetColourAlpha(globals::g_Game.resFPLight,r_00,r_00,r_00,1.0);
	res::Container_Light_SetSpotPenumbra(globals::g_Game.resTopSpotlight,r * 1.5 - -0.5);
	res::Container_Light_SetSpotUmbra(globals::g_Game.resTopSpotlight,r * 0.8 - -0.2);
	return;
}



void __cdecl lego::front::PausedMenu_SliderSoundVolume(int slider_0_10)
{
	snd::Sound3D_SetGlobalVolumePrescaled(slider_0_10);
	return;
}



void __cdecl lego::front::PausedMenu_SliderMusicVolume(int slider_0_10)
{
	main::Main_SetCDVolume((float)slider_0_10 * 0.1111111,(float)slider_0_10 * 0.1111111);
	return;
}



undefined4 __cdecl FUN_00414d40(void)
{
	BOOL BVar1;
	undefined4 uVar2;
	longlong lVar3;
	float local_8;
	float local_4;
	
	uVar2 = 0;
	BVar1 = lego::snd::lego::main::Main_GetCDVolume(&local_4,&local_8);
	if (BVar1 != 0) {
		lVar3 = __ftol(((float10)local_8 + (float10)local_4) * (float10)0.5 * (float10)9.0);
		uVar2 = (undefined4)lVar3;
	}
	return uVar2;
}



void __cdecl lego::front::PausedMenu_CycleWallDetail(int cycle_High_Low)
{
	if (cycle_High_Low == 0) {
		globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_WALLPROMESHES;
	}
	else {
		if (cycle_High_Low == 1) {
			globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_WALLPROMESHES;
			return;
		}
	}
	return;
}



void __cdecl lego::front::PausedMenu_CycleAutoGameSpeed(int cycle_On_Off)
{
	Info_SetAutoGameSpeed((uint)(cycle_On_Off == 0));
	return;
}



void __cdecl lego::front::PausedMenu_CycleMusic(int cycle_On_Off)
{
	snd::Music_PlayNext((uint)(cycle_On_Off == 0));
	return;
}



void __cdecl lego::front::PausedMenu_CycleSound(int cycle_On_Off)
{
	main::Config_SetSoundEnabled((uint)(cycle_On_Off == 0));
	return;
}



void __cdecl lego::front::PausedMenu_CycleHelpWindow(int cycle_Off_On)
{
	if (cycle_Off_On == 0) {
		FUN_00419130(0,1);
	}
	else {
		if (cycle_Off_On == 1) {
			FUN_00419130(0,0);
			return;
		}
	}
	return;
}



void __cdecl lego::front::PausedMenu_TriggerReplayObjective(void)
{
	game::Level_SetCompleteStatus(LEVELSTATUS_NONE);
	return;
}



void __cdecl lego::front::PausedMenu_SliderGameSpeed(int slider_0_5)
{
	switch(slider_0_5) {
	case 0:
		globals::g_Game.gameSpeed = 0.3333333;
		return;
	case 1:
		globals::g_Game.gameSpeed = 0.6666667;
		return;
	default:
		globals::g_Game.gameSpeed = 1.0;
		return;
	case 3:
		globals::g_Game.gameSpeed = 1.333333;
		return;
	case 4:
		globals::g_Game.gameSpeed = 1.666667;
		return;
	case 5:
		globals::g_Game.gameSpeed = 2.0;
		return;
	}
}



void __cdecl lego::front::FrontEnd_UpdateSliderGameSpeed(void)
{
	if (globals::g_Game.gameSpeed < 0.6666666) {
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 0;
		return;
	}
	if (globals::g_Game.gameSpeed < 1.0) {
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 1;
		return;
	}
	if (globals::g_Game.gameSpeed < 1.333333) {
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 2;
		return;
	}
	if (globals::g_Game.gameSpeed < 1.666667) {
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 3;
		return;
	}
	globals::g_PausedMenu_SliderGameSpeed_0_5 = 4;
	if (2.0 <= globals::g_Game.gameSpeed) {
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 5;
	}
	return;
}



int __cdecl lego::front::FrontEnd_CalcSliderGameSpeed(void)
{
	int iVar1;
	
	if (globals::g_Game.gameSpeed < 0.6666666) {
		return 0;
	}
	if (globals::g_Game.gameSpeed < 1.0) {
		return 1;
	}
	if (globals::g_Game.gameSpeed < 1.333333) {
		return 2;
	}
	if (globals::g_Game.gameSpeed < 1.666667) {
		return 3;
	}
	iVar1 = 4;
	if (2.0 <= globals::g_Game.gameSpeed) {
		iVar1 = 5;
	}
	return iVar1;
}



void __cdecl FUN_00414fe0(undefined4 param_1,int param_2)
{
	undefined *puVar1;
	int iVar2;
	LevelIdentifier *pLVar3;
	undefined4 uVar4;
	undefined4 uVar5;
	
	lego::save::Save_SetSaveNumber(param_2);
	puVar1 = FUN_00417da0();
	if (puVar1 == (undefined *)0x0) {
		uVar5 = 1;
		uVar4 = *(undefined4 *)(lego::globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
		pLVar3 = &LevelIdentifier_00557fe4;
		iVar2 = 0;
	}
	else {
		uVar5 = 0;
		uVar4 = *(undefined4 *)(lego::globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
		pLVar3 = &LevelIdentifier_00557fe4;
		puVar1 = FUN_00417da0();
		iVar2 = *(int *)(puVar1 + 0x34);
	}
	FUN_00417310(DAT_00557ff8,iVar2,pLVar3,uVar4,uVar5);
	FUN_00417310(DAT_00557ffc,0,&LevelIdentifier_00557fd0,
							 *(undefined4 *)(lego::globals::menu::g_MainMenuFull->menus[2]->Items->length + 0x10),
							 0);
	return;
}



void __cdecl FUN_00415080(void)
{
	int saveIndex;
	undefined *puVar1;
	
	saveIndex = lego::save::Save_GetSaveNumber();
	puVar1 = FUN_00417d80(saveIndex);
	if (puVar1 != (undefined *)0x0) {
		lego::front::PausedMenu_SliderSoundVolume(*(int *)(puVar1 + 8));
		lego::front::PausedMenu_SliderBrightness(*(int *)(puVar1 + 0x10));
		lego::front::PausedMenu_SliderMusicVolume(*(int *)(puVar1 + 4));
	}
	return;
}



void __cdecl lego::front::SaveMenu_TriggerBack(void)
{
	undefined *puVar1;
	LevelIdentifier *pLVar2;
	undefined4 uVar3;
	undefined4 uVar4;
	
	globals::g_SaveMenu_IsLoadMode = 0;
	DAT_00558508 = 0;
	INT_004a2f4c = -1;
	puVar1 = FUN_00417da0();
	if (puVar1 != (undefined *)0x0) {
		uVar4 = 0;
		uVar3 = *(undefined4 *)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
		pLVar2 = &LevelIdentifier_00557fe4;
		puVar1 = FUN_00417da0();
		FUN_00417310(DAT_00557ff8,*(int *)(puVar1 + 0x34),pLVar2,uVar3,uVar4);
		return;
	}
	FUN_00417310(DAT_00557ff8,0,&LevelIdentifier_00557fe4,
							 *(undefined4 *)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10),1);
	return;
}



void __cdecl FUN_00415150(void)
{
	char *levelName;
	int iVar1;
	MenuCollection *pMVar2;
	char local_80 [128];
	
	std::sprintf(local_80,"%s",(lego::globals::g_Game.level)->levelName);
	FUN_00425b60(0,0);
	lego::game::Game_freeLevel__0042eff0();
	levelName = std::_strdup(local_80);
	lego::main::Main_loadLevelCFG(levelName);
	iVar1 = 0;
	pMVar2 = lego::globals::menu::g_PausedMenu;
	if (0 < (int)lego::globals::menu::g_PausedMenu->count) {
		do {
			if (pMVar2->menus[iVar1] != (SubMenu *)0x0) {
				pMVar2->menus[iVar1]->field_28 = 1;
				pMVar2 = lego::globals::menu::g_PausedMenu;
			}
			iVar1 = iVar1 + 1;
		} while (iVar1 < (int)pMVar2->count);
	}
	lego::globals::g_PausedMenu_TriggerRestart = 0;
	lego::globals::g_Game.flags1 = lego::globals::g_Game.flags1 | GAME1_PAUSED;
	FUN_00459620();
	return;
}



void __cdecl FUN_004151f0(int param_1,char *param_2)
{
	int iVar1;
	uint uVar2;
	int iVar3;
	int iVar4;
	uint uVar5;
	longlong lVar6;
	uint in_stack_0000000c;
	
	if (param_1 != 0) {
		iVar4 = 0;
		uVar5 = 0;
		uVar2 = 0;
		if (*(int *)(param_1 + 0x18) != 0) {
			iVar3 = 0;
			do {
				iVar1 = FUN_00417360(uVar5,param_1);
				iVar4 = iVar4 + iVar1;
				if ((*(byte *)(*(int *)(param_1 + 0x34) + iVar3) & 1) != 0) {
					in_stack_0000000c = in_stack_0000000c + 1;
				}
				uVar5 = uVar5 + 1;
				iVar3 = iVar3 + 0x3190;
				uVar2 = in_stack_0000000c;
			} while (uVar5 < *(uint *)(param_1 + 0x18));
		}
		if (uVar2 != 0) {
			lVar6 = __ftol(((float10)(ulonglong)uVar2 / (float10)*(int *)(param_1 + 0x18)) *
										 (float10)100.0);
			std::sprintf(param_2,"Game %i%% complete with %i points scored",(int)lVar6,iVar4);
		}
	}
	return;
}



void __cdecl lego::front::FrontEnd_UpdateGameSpeedSliderLevel(void)
{
	globals::g_PausedMenu_SliderGameSpeed_0_5 = FrontEnd_CalcSliderGameSpeed();
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOL __cdecl FUN_004152a0(float elapsed,int param_2)
{
	SubMenu *pSVar1;
	int iVar2;
	BOOL BVar3;
	MenuCollection *pMVar4;
	uint uVar5;
	
	uVar5 = 1;
	lego::front::FrontEnd_UpdateGameSpeedSliderLevel();
	pMVar4 = lego::globals::menu::g_PausedMenu;
	if ((param_2 != 0) && (pMVar4 = lego::globals::menu::g_OptionsMenu, param_2 != 1)) {
		return 1;
	}
	if (((((DAT_004dc8e0 != (SubMenu *)0x0) && (lego::globals::g_PausedMenu_TriggerRestart == 0)) &&
			 (lego::globals::g_PausedMenu_TriggerQuit == 0)) &&
			((lego::globals::g_PausedMenu_TriggerReplayObjective == 0 && (_DAT_004dc8e4 == pMVar4)))) &&
		 (BVar3 = lego::game::Level_IsObjectiveFinished(), BVar3 == 0)) {
LAB_0041535f:
		BVar3 = lego::game::Level_IsObjectiveFinished();
		if (BVar3 == 0) {
			DAT_004dc8e0 = (SubMenu *)FUN_00412b30(elapsed,(int)DAT_004dc8e0,(BOOL *)0x0);
		}
		if (param_2 != 0) {
			if (param_2 == 1) {
				iVar2 = (*pMVar4->menus)->field_28;
				(*pMVar4->menus)->field_28 = 0;
				uVar5 = (uint)(iVar2 == 1);
			}
			return uVar5;
		}
		uVar5 = 1;
		pSVar1 = *pMVar4->menus;
		if ((pSVar1->field_28 != 1) && (pMVar4->menus[2]->field_28 != 1)) {
			uVar5 = 0;
		}
		pSVar1->field_28 = 0;
		pMVar4->menus[2]->field_28 = 0;
		return uVar5;
	}
	lego::globals::g_PausedMenu_TriggerQuit = 0;
	DAT_004dc8e0 = *pMVar4->menus;
	_DAT_004dc8e4 = pMVar4;
	if (lego::globals::g_PausedMenu_TriggerReplayObjective == 0) {
		if (lego::globals::g_PausedMenu_TriggerRestart != 1) goto LAB_0041535f;
	}
	else {
		if (*pMVar4->menus != (SubMenu *)0x0) {
			(*pMVar4->menus)->field_28 = 1;
		}
		if (pMVar4->menus[2] != (SubMenu *)0x0) {
			pMVar4->menus[2]->field_28 = 1;
		}
		if (param_2 == 0) {
			lego::globals::g_PausedMenu_TriggerReplayObjective = 0;
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::Game_UnkParseLevelIdentifier_004153e0
					(CFGProperty *root,uint *param_2,char *propertyName)
{
	uint length;
	char *pcVar1;
	void *pvVar2;
	undefined4 *puVar3;
	uint uVar4;
	int iVar5;
	uint uVar6;
	undefined4 uVar7;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main",propertyName,0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar1);
	if (pcVar1 == (char *)0x0) {
		return 0;
	}
	uVar6 = 1;
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,pcVar1,"NextLevel",0);
	for (pcVar1 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar1); pcVar1 != (char *)0x0;
			pcVar1 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar1)) {
		uVar6 = uVar6 + 1;
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,pcVar1,"NextLevel",0);
	}
	length = uVar6 * 4;
	*param_2 = uVar6;
	pvVar2 = std::malloc(length);
	param_2[1] = (uint)pvVar2;
	pvVar2 = std::malloc(length);
	param_2[2] = (uint)pvVar2;
	puVar3 = (undefined4 *)std::malloc(length);
	param_2[3] = (uint)puVar3;
	for (uVar4 = uVar6 & 0x3fffffff; uVar4 != 0; uVar4 = uVar4 - 1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	for (iVar5 = 0; iVar5 != 0; iVar5 = iVar5 + -1) {
		*(undefined *)puVar3 = 0;
		puVar3 = (undefined4 *)((int)puVar3 + 1);
	}
	puVar3 = (undefined4 *)std::malloc(length);
	param_2[4] = (uint)puVar3;
	for (uVar6 = uVar6 & 0x3fffffff; uVar6 != 0; uVar6 = uVar6 - 1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	for (iVar5 = 0; iVar5 != 0; iVar5 = iVar5 + -1) {
		*(undefined *)puVar3 = 0;
		puVar3 = (undefined4 *)((int)puVar3 + 1);
	}
	if (param_2[1] != 0) {
		if (param_2[2] != 0) {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main",propertyName,0);
			pcVar1 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar1);
			*(char **)param_2[1] = pcVar1;
			uVar7 = *(undefined4 *)param_2[1];
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,uVar7,"FullName",0);
			pcVar1 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar1);
			*(char **)param_2[2] = pcVar1;
			if (*(char **)param_2[2] == (char *)0x0) {
				pcVar1 = std::_strdup2(*(char **)param_2[1]);
				*(char **)param_2[2] = pcVar1;
			}
			else {
				util::stringReplaceChar(*(char **)param_2[2],'_',' ');
			}
			iVar5 = 1;
			if (1 < (int)*param_2) {
				do {
					pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,uVar7,"NextLevel",0);
					pcVar1 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar1);
					*(char **)(param_2[1] + iVar5 * 4) = pcVar1;
					uVar7 = *(undefined4 *)(param_2[1] + iVar5 * 4);
					pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,uVar7,"FullName",0);
					pcVar1 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar1);
					*(char **)(param_2[2] + iVar5 * 4) = pcVar1;
					pcVar1 = *(char **)(param_2[2] + iVar5 * 4);
					if (pcVar1 == (char *)0x0) {
						pcVar1 = std::_strdup2(*(char **)(param_2[1] + iVar5 * 4));
						*(char **)(param_2[2] + iVar5 * 4) = pcVar1;
					}
					else {
						util::stringReplaceChar(pcVar1,'_',' ');
					}
					iVar5 = iVar5 + 1;
				} while (iVar5 < (int)*param_2);
			}
			return 1;
		}
		return 0;
	}
	return 0;
}



void __cdecl lego::video::VideoPlayer_Play(VideoPlayer_t *videoPlayer,BOOL isSkippable)
{
	BOOL BVar1;
	uint uVar2;
	ulonglong uVar3;
	float local_1c;
	RECT rect;
	
										// HARDCODED SCREEN RESOLUTION!!
	rect.left = 0;
	rect.top = 0;
	rect.right = 640;
	rect.bottom = 480;
	local_1c = 0.0;
	BVar1 = VideoPlayer_Update(videoPlayer,1.0,&rect);
	if (BVar1 != 0) {
		while( true ) {
			main::Main_LoopUpdate(0);
			local_1c = local_1c - -1.0;
			uVar3 = VideoPlayer_GetDuration(videoPlayer);
			if ((float)(uVar3 & 0xffffffff) < local_1c) break;
			if (isSkippable != 0) {
				uVar2 = input::Input_AnyKeyPressed();
				if (uVar2 != 0) {
					return;
				}
				if (globs::INPUT.msrb != 0) {
					return;
				}
				if (globs::INPUT.mslb != 0) {
					return;
				}
			}
			BVar1 = VideoPlayer_Update(videoPlayer,1.0,&rect);
			if (BVar1 == 0) {
				return;
			}
		}
	}
	return;
}



void __cdecl lego::main::Boot_PlayIntroImage(char *imageKeyName,BOOL isSkippable,char *timeKeyName)
{
	char *pcVar1;
	DWORD DVar2;
	ImageBMP *image;
	DWORD DVar3;
	uint uVar4;
	float10 fVar5;
	longlong lVar6;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main",timeKeyName,0);
	pcVar1 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar1);
	if (pcVar1 == (char *)0x0) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main",timeKeyName,0);
		pcVar1 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar1);
	}
	fVar5 = std::atof(pcVar1);
	timeKeyName = (char *)(float)fVar5;
	if ((float)timeKeyName == 0.0) {
		timeKeyName = (char *)0x40400000;
	}
	DVar2 = timeGetTime();
	lVar6 = __ftol((float10)(float)timeKeyName * (float10)-1000.0);
	if (imageKeyName != (char *)0x0) {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main",imageKeyName,0);
		pcVar1 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar1);
		if ((pcVar1 != (char *)0x0) &&
			 (image = lego::image::Image_LoadBMPScaled(pcVar1,0,0), image != (ImageBMP *)0x0)) {
			while( true ) {
				lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,(Point2F *)0x0,(Size2F *)0x0);
				Main_LoopUpdate(0);
				Sleep(100);
				DVar3 = timeGetTime();
				if (DVar2 - (int)lVar6 <= DVar3) break;
				if ((isSkippable != 0) &&
					 (((uVar4 = input::Input_AnyKeyPressed(), uVar4 != 0 || (globs::INPUT.msrb != 0)) ||
						(globs::INPUT.mslb != 0)))) break;
			}
			lego::image::Image_Remove(image);
		}
	}
	return;
}



void __cdecl lego::main::Boot_PlayIntroAVI(char *aviKeyName,BOOL isSkippable)
{
	char *pcVar1;
	BOOL BVar2;
	VideoPlayer_t *videoPlayer;
	
	if (aviKeyName != (char *)0x0) {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main",aviKeyName,0);
		pcVar1 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar1);
		if (pcVar1 != (char *)0x0) {
			BVar2 = lego::file::File_Exists(pcVar1);
			if (BVar2 != 0) {
				videoPlayer = video::VideoPlayer_Open(pcVar1);
				video::VideoPlayer_Play(videoPlayer,isSkippable);
				video::VideoPlayer_Close(videoPlayer);
				std::free(pcVar1);
			}
		}
	}
	return;
}



void __cdecl lego::game::Level_DoVideo__004158c0(char *levelName,int param_2)
{
	char *pcVar1;
	BOOL BVar2;
	VideoPlayer_t *videoPlayer;
	
	if (levelName != (char *)0x0) {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"Video",0);
		pcVar1 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar1);
		if (pcVar1 != (char *)0x0) {
			BVar2 = lego::file::File_Exists(pcVar1);
			if (BVar2 != 0) {
				videoPlayer = video::VideoPlayer_Open(pcVar1);
				video::VideoPlayer_Play(videoPlayer,param_2);
				video::VideoPlayer_Close(videoPlayer);
			}
			std::free(pcVar1);
		}
	}
	return;
}



// WARNING: Type propagation algorithm not settling

void __cdecl lego::front::Menu_Load_FUN_00415940(undefined4 param_1)
{
	int iVar1;
	int iVar2;
	int iVar3;
	int **ppiVar4;
	SubMenuItem *pSVar5;
	int **ppiVar6;
	char *pcVar7;
	undefined *puVar8;
	int iVar9;
	uint unaff_EDI;
	Struct_b8__00558080 *pSVar10;
	undefined4 uVar11;
	code *pcVar12;
	byte local_64 [100];
	
	DAT_00557ff8 = FUN_00416fc0(&LevelIdentifier_00557fe4,*LevelIdentifier_00557fe4.field_4);
	DAT_00557ffc = FUN_00416fc0(&LevelIdentifier_00557fd0,*LevelIdentifier_00557fd0.field_4);
	FUN_00416da0();
	iVar1 = Menu_GetSubMenuIDByName(globals::menu::g_MainMenuFull,"Levels");
	iVar2 = Menu_GetSubMenuIDByName(globals::menu::g_MainMenuFull,"Tutorials");
	iVar3 = Menu_GetSubMenuIDByName(globals::menu::g_MainMenuFull,"Load Level Save");
	ppiVar4 = (int **)FUN_00410520(&INT_00558028,____EMPTYSTR__,____EMPTYSTR__,0xffffff38,0xffffff9c,
																 0x3c,5,0xffffffec,200,0xffffffec,0xffffffd8,0,FUN_00414fe0,
																 globals::menu::g_MainMenuFull->menus[iVar1]);
	pcVar7 = globals::menu::g_MainMenuFull->menus[iVar3]->Items->banner;
	pSVar5 = Menu_CreateItem3C(____EMPTYSTR__,*(ImageFont **)(pcVar7 + 0xc),
														 *(ImageFont **)(pcVar7 + 8),0,0,MENUITEM__COUNT,1,ppiVar4,0);
	Menu_AddSubMenuItem(globals::menu::g_MainMenuFull->menus[iVar3],pSVar5);
	ppiVar6 = (int **)FUN_00410520(&INT_00558028,____EMPTYSTR__,____EMPTYSTR__,0xffffff38,0xffffff9c,
																 0x3c,5,0xffffffec,200,0xffffffec,0xffffffd8,0,FUN_00414fe0,0);
	pcVar7 = globals::menu::g_MainMenuFull->menus[iVar3]->Items->banner;
	pSVar5 = Menu_CreateItem3C(____EMPTYSTR__,*(ImageFont **)(pcVar7 + 0xc),
														 *(ImageFont **)(pcVar7 + 8),0,0,MENUITEM__COUNT,1,ppiVar6,0);
	Menu_AddSubMenuItem(*globals::menu::g_SaveMenu->menus,pSVar5);
	iVar9 = 0;
	pSVar10 = globals::g_Struct_b8_TABLE__00558080;
	do {
		iVar9 = iVar9 + 1;
		pcVar7 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu","Save_Game",0,iVar9);
		pcVar7 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar7);
		std::sprintf((char *)local_64,"%s %i",pcVar7);
		util::stringReplaceChar((char *)local_64,'_',' ');
		FUN_004151f0((int)pSVar10,(char *)local_64);
		FUN_00410670(ppiVar4,local_64,1,
								 *(undefined4 **)(globals::menu::g_MainMenuFull->menus[iVar3]->Items->banner + 8),0,
								 0,0);
		FUN_00410670(ppiVar6,local_64,1,
								 *(undefined4 **)(globals::menu::g_MainMenuFull->menus[iVar3]->Items->banner + 8),0,
								 0,0);
		pSVar10 = pSVar10 + 1;
	} while ((int)pSVar10 < 0x558418);
	FUN_00417d20(unaff_EDI);
	pcVar12 = unk::lego_uses_testercall_FUN_00417390;
	uVar11 = 0;
	puVar8 = FUN_00417da0();
	FUN_004178e0(4,(int)DAT_00557ff8,&LevelIdentifier_00557fe4,
							 (int)globals::menu::g_MainMenuFull->menus[iVar1],puVar8,uVar11,pcVar12);
	pcVar12 = FUN_00417630;
	uVar11 = 0;
	puVar8 = FUN_00417da0();
	FUN_004178e0(5,(int)DAT_00557ffc,&LevelIdentifier_00557fd0,
							 (int)globals::menu::g_MainMenuFull->menus[iVar2],puVar8,uVar11,pcVar12);
	return;
}



void __cdecl lego::save::Save_ClearSaveNumber(void)
{
	globals::g_SaveNumber = -1;
	return;
}



void __cdecl FUN_00415c30(undefined4 param_1,char *param_2,undefined4 *param_3)
{
	char cVar1;
	char *pcVar2;
	int iVar3;
	TextWindow *pTVar4;
	ImageBMP *pIVar5;
	uint uVar6;
	uint uVar7;
	undefined4 *puVar8;
	char *pcVar9;
	undefined4 *puVar10;
	Rect2F local_24;
	char *local_14;
	char *local_10;
	char *local_c;
	char *local_8;
	char *local_4;
	
	local_24.y = 0.0;
	local_24.width = 0.0;
	local_24.x = 0.0;
	local_24.height = 0.0;
	pcVar2 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,param_2,"Load",0);
	pcVar2 = lego::cfg::CFG_CopyString(lego::globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar2 = lego::util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 = uVar6 - 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = param_3 + 10;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,param_2,"Save",0);
	pcVar2 = lego::cfg::CFG_CopyString(lego::globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar2 = lego::util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 = uVar6 - 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = param_3 + 0x4a;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,param_2,"Slot",0);
	pcVar2 = lego::cfg::CFG_CopyString(lego::globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar2 = lego::util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 = uVar6 - 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = param_3 + 0x8a;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,param_2,"SaveSel",0);
	pcVar2 = lego::cfg::CFG_CopyString(lego::globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar2 = lego::util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 = uVar6 - 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = param_3 + 0x10a;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,param_2,"LoadSel",0);
	pcVar2 = lego::cfg::CFG_CopyString(lego::globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar2 = lego::util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 = uVar6 - 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = param_3 + 0xca;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,param_2,"Level",0);
	pcVar2 = lego::cfg::CFG_CopyString(lego::globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar2 = lego::util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 = uVar6 - 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = param_3 + 0x14a;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,param_2,"Tutorial",0);
	pcVar2 = lego::cfg::CFG_CopyString(lego::globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar2 = lego::util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 = uVar6 - 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = param_3 + 0x18a;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,param_2,"Window",0);
	pcVar2 = lego::cfg::CFG_CopyString(lego::globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		iVar3 = lego::util::Util_Tokenise(pcVar2,&local_14,"|");
		if (iVar3 == 4) {
			iVar3 = std::atoi(local_14);
			local_24.x = (float)iVar3;
			param_3[2] = local_24.x;
			iVar3 = std::atoi(local_10);
			local_24.y = (float)iVar3;
			param_3[3] = local_24.y;
			iVar3 = std::atoi(local_c);
			local_24.width = (float)iVar3;
			param_3[4] = local_24.width;
			iVar3 = std::atoi(local_8);
			local_24.height = (float)iVar3;
			param_3[5] = local_24.height;
			pTVar4 = lego::front::TextWindow_Create(lego::globals::g_Game.bmpFONT5_HI,&local_24,0x200);
			*param_3 = pTVar4;
		}
	}
	pcVar2 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,param_2,"Panel",0);
	pcVar2 = lego::cfg::CFG_CopyString(lego::globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		iVar3 = lego::util::Util_Tokenise(pcVar2,&local_14,"|");
		if ((iVar3 == 5) && (local_14 != (char *)0x0)) {
			pIVar5 = lego::image::Image_LoadBMPScaled(local_14,0,0);
			param_3[1] = pIVar5;
			if (pIVar5 != (ImageBMP *)0x0) {
				iVar3 = std::atoi(local_10);
				param_3[6] = (float)iVar3;
				iVar3 = std::atoi(local_c);
				param_3[7] = (float)iVar3;
				iVar3 = std::atoi(local_8);
				param_3[8] = (float)iVar3;
				iVar3 = std::atoi(local_4);
				param_3[9] = (float)iVar3;
				lego::image::Image_SetupTrans((ImageBMP *)param_3[1],0.0,0.0,0.0,0.0,0.0,0.0);
			}
		}
	}
	return;
}



BOOL __cdecl FUN_00416080(int levelNumber)
{
	BOOL BVar1;
	SFXType local_84;
	char local_80 [128];
	
	std::sprintf(local_80,"Stream_LevelName_Level%d",levelNumber);
	BVar1 = lego::snd::SFX_GetType(local_80,&local_84);
	if (BVar1 != 0) {
		BVar1 = lego::snd::Audio_FUN_004651b0(local_84,(int *)0x0);
	}
	return BVar1;
}



BOOL __cdecl FUN_004160d0(int levelNumber)
{
	BOOL BVar1;
	SFXType local_84;
	char local_80 [128];
	
	std::sprintf(local_80,"Stream_LevelName_TLevel%d",levelNumber);
	BVar1 = lego::snd::SFX_GetType(local_80,&local_84);
	if (BVar1 != 0) {
		BVar1 = lego::snd::Audio_FUN_004651b0(local_84,(int *)0x0);
	}
	return BVar1;
}



void __cdecl lego::front::Menu_LoadMenus(CFGProperty *root)
{
	char cVar1;
	char *pcVar2;
	int iVar3;
	char *pcVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	undefined4 *puVar9;
	undefined uVar10;
	
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu","MenuWipe",0);
	pcVar2 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 == (char *)0x0) {
		pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu","!MenuWipe",0);
		pcVar2 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar2);
		if (pcVar2 == (char *)0x0) goto LAB_004161da;
		if ((globs::mainGlobs.flags & CMD_REDUCEANIMATION) == CMD_NONE) {
			iVar3 = std::_strnicmp(pcVar2,"Null",4);
			goto joined_r0x004161b8;
		}
	}
	else {
		iVar3 = std::_strnicmp(pcVar2,"Null",4);
joined_r0x004161b8:
		if (iVar3 != 0) {
			globals::g_MenuWipeResource = res::Container_Load((Container *)0x0,pcVar2,"LWS",1);
		}
	}
	std::free(pcVar2);
LAB_004161da:
	globals::g_UnkStruct728_Menu_SaveText = std::malloc(0x728);
	puVar7 = (undefined4 *)globals::g_UnkStruct728_Menu_SaveText;
	for (iVar3 = 0x1ca; iVar3 != 0; iVar3 = iVar3 + -1) {
		*puVar7 = 0;
		puVar7 = puVar7 + 1;
	}
	FUN_00415c30(root,"Menu::SaveText",(undefined4 *)globals::g_UnkStruct728_Menu_SaveText);
	globals::g_UnkStruct728_Menu_LevelText = std::malloc(0x728);
	puVar7 = (undefined4 *)globals::g_UnkStruct728_Menu_LevelText;
	for (iVar3 = 0x1ca; iVar3 != 0; iVar3 = iVar3 + -1) {
		*puVar7 = 0;
		puVar7 = puVar7 + 1;
	}
	FUN_00415c30(root,"Menu::LevelText",(undefined4 *)globals::g_UnkStruct728_Menu_LevelText);
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu","Save_Game",0);
	pcVar2 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar4 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar8 = pcVar4;
			if (uVar5 == 0) break;
			uVar5 = uVar5 - 1;
			pcVar8 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar8;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar8 + -uVar5);
		puVar9 = (undefined4 *)globals::menu::g_Menu_SaveGame_text;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
			*puVar9 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar9 = puVar9 + 1;
		}
		for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
			*(undefined *)puVar9 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar9 = (undefined4 *)((int)puVar9 + 1);
		}
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu","Load_Game",0);
	pcVar2 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar4 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar8 = pcVar4;
			if (uVar5 == 0) break;
			uVar5 = uVar5 - 1;
			pcVar8 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar8;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar8 + -uVar5);
		puVar9 = (undefined4 *)globals::menu::g_Menu_LoadGame_text;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
			*puVar9 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar9 = puVar9 + 1;
		}
		for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
			*(undefined *)puVar9 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar9 = (undefined4 *)((int)puVar9 + 1);
		}
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu::Overwrite","Title",0);
	pcVar2 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar4 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar8 = pcVar4;
			if (uVar5 == 0) break;
			uVar5 = uVar5 - 1;
			pcVar8 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar8;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar8 + -uVar5);
		puVar9 = (undefined4 *)globals::menu::g_MenuOverwrite_Title;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
			*puVar9 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar9 = puVar9 + 1;
		}
		for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
			*(undefined *)puVar9 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar9 = (undefined4 *)((int)puVar9 + 1);
		}
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu::Overwrite","Text",0);
	pcVar2 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar4 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar8 = pcVar4;
			if (uVar5 == 0) break;
			uVar5 = uVar5 - 1;
			pcVar8 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar8;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar8 + -uVar5);
		puVar9 = (undefined4 *)globals::menu::g_MenuOverwrite_Text;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
			*puVar9 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar9 = puVar9 + 1;
		}
		for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
			*(undefined *)puVar9 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar9 = (undefined4 *)((int)puVar9 + 1);
		}
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu::Overwrite","Ok",0);
	pcVar2 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar4 = pcVar2;
			if (uVar5 == 0) break;
			uVar5 = uVar5 - 1;
			pcVar4 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar4;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar4 + -uVar5);
		puVar9 = (undefined4 *)globals::menu::g_MenuOverwrite_Ok;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
			*puVar9 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar9 = puVar9 + 1;
		}
		for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
			*(undefined *)puVar9 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar9 = (undefined4 *)((int)puVar9 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu::Overwrite","Cancel",0);
	pcVar2 = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar4 = pcVar2;
			if (uVar5 == 0) break;
			uVar5 = uVar5 - 1;
			pcVar4 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar4;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar4 + -uVar5);
		puVar9 = (undefined4 *)globals::menu::g_MenuOverwrite_Cancel;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
			*puVar9 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar9 = puVar9 + 1;
		}
		for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
			*(undefined *)puVar9 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar9 = (undefined4 *)((int)puVar9 + 1);
		}
	}
	FONT_00558078 = globals::g_Game.bmpMbriefFONT2;
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","Version",0);
	globals::g_Main_Version = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar2);
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu","DefaultLevelBMPS",0);
	globals::g_Menu_DefaultLevelBMPS = cfg::CFG_CopyString(globals::g_Game.LegoCfgRoot,pcVar2);
	PTR_005584fc = res::Container_MakeLight
													 (globals::g_Game.resRoot,D3DRMLIGHT_DIRECTIONAL,0.8,0.8,0.8);
	res::Container_Hide(PTR_005584fc,1);
	uVar10 = SUB41(root,0);
	globals::menu::g_MainMenuFull =
			 Menu_ParseMenu(uVar10,"MainMenuFull",&globals::g_MainMenuFull_TriggerCredits,
											MainMenuFull_TriggerShowCredits,&globals::g_MainMenuFull_TriggerYesQuit,0,
											0xffffffff);
	globals::menu::g_SaveMenu =
			 Menu_ParseMenu(uVar10,"SaveMenu",&globals::g_SaveMenu_TriggerBack,SaveMenu_TriggerBack,
											0xffffffff);
	game::Game_UnkParseLevelIdentifier_004153e0
						(globals::g_Game.LegoCfgRoot,(uint *)&LevelIdentifier_00557fe4,"StartLevel");
	game::Game_UnkParseLevelIdentifier_004153e0
						(globals::g_Game.LegoCfgRoot,(uint *)&LevelIdentifier_00557fd0,"TutorialStartLevel");
	Menu_Load_FUN_00415940(globals::menu::g_MainMenuFull);
	globals::menu::g_PausedMenu =
			 Menu_ParseMenu(uVar10,"PausedMenu",&globals::g_PausedMenu_TriggerContinue,(void *)0x0,
											&globals::g_PausedMenu_SliderGameSpeed_0_5,PausedMenu_SliderGameSpeed,
											&globals::g_PausedMenu_SliderSoundVolume_0_10,PausedMenu_SliderSoundVolume,
											&globals::g_PausedMenu_SliderMusicVolume_0_10,PausedMenu_SliderMusicVolume,
											&globals::g_PausedMenu_SliderBrightness_0_10,PausedMenu_SliderBrightness,
											&globals::g_PausedMenu_CycleHelpWindow_Off_On,PausedMenu_CycleHelpWindow,
											&globals::g_PausedMenu_TriggerReplayObjective,
											PausedMenu_TriggerReplayObjective,&globals::g_PausedMenu_TriggerQuit,0,
											&globals::g_PausedMenu_TriggerRestart,0,
											&globals::g_PausedMenu_CycleWallDetail_High_Low,PausedMenu_CycleWallDetail,
											&globals::g_PausedMenu_CycleMusic_On_Off,PausedMenu_CycleMusic,
											&globals::g_PausedMenu_CycleSound_On_Off,PausedMenu_CycleSound,
											&globals::g_PausedMenu_CycleAutoGameSpeed_On_Off,PausedMenu_CycleAutoGameSpeed
											,0xffffffff);
	globals::menu::g_OptionsMenu =
			 Menu_ParseMenu(uVar10,"OptionsMenu",&globals::g_PausedMenu_SliderGameSpeed_0_5,
											PausedMenu_SliderGameSpeed,&globals::g_PausedMenu_SliderSoundVolume_0_10,
											PausedMenu_SliderSoundVolume,&globals::g_PausedMenu_SliderMusicVolume_0_10,
											PausedMenu_SliderMusicVolume,&globals::g_PausedMenu_SliderBrightness_0_10,
											PausedMenu_SliderBrightness,&globals::g_PausedMenu_CycleHelpWindow_Off_On,
											PausedMenu_CycleHelpWindow,&globals::g_PausedMenu_TriggerReplayObjective,
											PausedMenu_TriggerReplayObjective,&globals::g_PausedMenu_TriggerContinue,0,
											0xffffffff);
	globals::g_PausedMenu_SliderSoundVolume_0_10 = 8;
	globals::g_PausedMenu_TriggerContinue = 0;
	globals::g_PausedMenu_SliderBrightness_0_10 = 5;
	globals::g_PausedMenu_CycleHelpWindow_Off_On = 1;
	globals::g_PausedMenu_TriggerReplayObjective = 0;
	globals::g_PausedMenu_SliderGameSpeed_0_5 = FrontEnd_CalcSliderGameSpeed();
	globals::g_PausedMenu_SliderMusicVolume_0_10 = FUN_00414d40();
	DAT_00558500 = 0;
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu","MaxLevelScreens",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 == (char *)0x0) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu","MaxLevelScreens",0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	}
	globals::g_Menu_MaxLevelScreens = std::atoi(pcVar2);
	if (globals::g_Menu_MaxLevelScreens == 0) {
		globals::g_Menu_MaxLevelScreens = 1;
	}
	DAT_00558824 = 0;
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu","SaveImage","BigWidth",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 == (char *)0x0) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu","SaveImage","BigWidth",0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	}
	globals::g_Menu_SaveImage_BigSize.width = std::atoi(pcVar2);
	if (globals::g_Menu_SaveImage_BigSize.width == 0) {
		globals::g_Menu_SaveImage_BigSize.width = 0x50;
	}
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu","SaveImage","BigHeight",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 == (char *)0x0) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu","SaveImage","BigHeight",0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	}
	globals::g_Menu_SaveImage_BigSize.height = std::atoi(pcVar2);
	if (globals::g_Menu_SaveImage_BigSize.height == 0) {
		globals::g_Menu_SaveImage_BigSize.height = 0x3c;
	}
	unk::Lego_SetDat_0055881c(1);
	return;
}



void __cdecl FUN_00416840(void)
{
	undefined *puVar1;
	
	puVar1 = FUN_00417da0();
	if (puVar1 != (undefined *)0x0) {
		*(int *)(puVar1 + 0xc) = lego::globals::g_PausedMenu_SliderGameSpeed_0_5;
		*(int *)(puVar1 + 8) = lego::globals::g_PausedMenu_SliderSoundVolume_0_10;
		*(int *)(puVar1 + 0x10) = lego::globals::g_PausedMenu_SliderBrightness_0_10;
	}
	return;
}



void __cdecl FUN_00416870(BOOL param_1,BOOL param_2)
{
	undefined *puVar1;
	
	if (param_2 != 0) {
		lego::globals::g_MainMenuFull_TriggerYesQuit = 0;
		INT_00558020 = -1;
		INT_00558024 = -1;
		lego::globals::g_PausedMenu_TriggerContinue = 0;
	}
	if (param_1 != 0) {
		if (INT_00558028 != -1) {
			puVar1 = FUN_00417da0();
			if (puVar1 != (undefined *)0x0) {
				puVar1 = FUN_00417da0();
				lego::globals::g_PausedMenu_SliderGameSpeed_0_5 = *(int *)(puVar1 + 0xc);
				lego::globals::g_PausedMenu_SliderSoundVolume_0_10 = *(int *)(puVar1 + 8);
				lego::globals::g_PausedMenu_SliderBrightness_0_10 = *(int *)(puVar1 + 0x10);
				return;
			}
		}
		lego::globals::g_PausedMenu_SliderGameSpeed_0_5 = 1;
		lego::globals::g_PausedMenu_SliderSoundVolume_0_10 = 8;
		lego::globals::g_PausedMenu_SliderBrightness_0_10 = 5;
	}
	return;
}



void __cdecl lego::front::Menu_FUN_004168f0(int menuId)
{
	undefined *puVar1;
	int iVar2;
	LevelIdentifier *pLVar3;
	undefined4 uVar4;
	undefined4 uVar5;
	
	switch(menuId) {
	case 0:
		INT_00558028 = -1;
		FUN_00416870(1,1);
		puVar1 = FUN_00417da0();
		if (puVar1 == (undefined *)0x0) {
			if (DAT_0055881c != 0) {
				FUN_00417310(DAT_00557ff8,0,&LevelIdentifier_00557fe4,
										 *(undefined4 *)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10),
										 1);
			}
		}
		else {
LAB_00416af1:
			uVar5 = 0;
			uVar4 = *(undefined4 *)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
			pLVar3 = &LevelIdentifier_00557fe4;
			puVar1 = FUN_00417da0();
			FUN_00417310(DAT_00557ff8,*(int *)(puVar1 + 0x34),pLVar3,uVar4,uVar5);
		}
		break;
	case 1:
		FUN_00416870(1,1);
		puVar1 = FUN_00417da0();
		if (puVar1 == (undefined *)0x0) {
			if (DAT_0055881c == 0) goto LAB_004169dd;
			uVar5 = 1;
			uVar4 = *(undefined4 *)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
			pLVar3 = &LevelIdentifier_00557fe4;
			iVar2 = 0;
		}
		else {
			uVar5 = 0;
			uVar4 = *(undefined4 *)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
			pLVar3 = &LevelIdentifier_00557fe4;
			puVar1 = FUN_00417da0();
			iVar2 = *(int *)(puVar1 + 0x34);
		}
		FUN_00417310(DAT_00557ff8,iVar2,pLVar3,uVar4,uVar5);
LAB_004169dd:
		FUN_00417310(DAT_00557ffc,0,&LevelIdentifier_00557fd0,
								 *(undefined4 *)(globals::menu::g_MainMenuFull->menus[2]->Items->length + 0x10),0);
		unk::Lego_SetDat_0055881c(1);
		return;
	case 2:
		FUN_00416870(1,1);
		puVar1 = FUN_00417da0();
		if (puVar1 == (undefined *)0x0) {
			if (DAT_0055881c == 0) goto LAB_00416a8d;
			uVar5 = 1;
			uVar4 = *(undefined4 *)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
			pLVar3 = &LevelIdentifier_00557fe4;
			iVar2 = 0;
		}
		else {
			uVar5 = 0;
			uVar4 = *(undefined4 *)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
			pLVar3 = &LevelIdentifier_00557fe4;
			puVar1 = FUN_00417da0();
			iVar2 = *(int *)(puVar1 + 0x34);
		}
		FUN_00417310(DAT_00557ff8,iVar2,pLVar3,uVar4,uVar5);
LAB_00416a8d:
		FUN_00417310(DAT_00557ffc,0,&LevelIdentifier_00557fd0,
								 *(undefined4 *)(globals::menu::g_MainMenuFull->menus[2]->Items->length + 0x10),0);
		unk::Lego_SetDat_0055881c(1);
		return;
	case 3:
		FUN_00416870(0,1);
		unk::Lego_SetDat_0055881c(1);
		return;
	case 4:
		FUN_00416870(0,1);
		puVar1 = FUN_00417da0();
		if (puVar1 != (undefined *)0x0) goto LAB_00416af1;
		if (DAT_0055881c != 0) {
			FUN_00417310(DAT_00557ff8,0,&LevelIdentifier_00557fe4,
									 *(undefined4 *)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10),1)
			;
			DAT_00558500 = 1;
		}
		break;
	default:
		goto switchD_004168fd_caseD_5;
	}
	FUN_00417310(DAT_00557ffc,0,&LevelIdentifier_00557fd0,
							 *(undefined4 *)(globals::menu::g_MainMenuFull->menus[2]->Items->length + 0x10),0);
switchD_004168fd_caseD_5:
	unk::Lego_SetDat_0055881c(1);
	return;
}



undefined4 __cdecl lego::front::Menu_Open_FUN_00416bb0(int menuId)
{
	MenuCollection *pMVar1;
	int iVar2;
	
	pMVar1 = globals::menu::g_MainMenuFull;
	Menu_FUN_004168f0(menuId);
	snd::Audio_AddToSoundQueue1(SFX_AMBIENTMUSICLOOP,1);
	switch(menuId) {
	case 0:
		iVar2 = 0;
		break;
	case 1:
		iVar2 = 1;
		break;
	case 2:
		iVar2 = 2;
		break;
	default:
		goto switchD_00416bd6_caseD_3;
	case 4:
		iVar2 = 0;
		pMVar1 = globals::menu::g_SaveMenu;
	}
	Menu_FUN_00413d50((int *)pMVar1,iVar2);
switchD_00416bd6_caseD_3:
	snd::Sound3D_Stream_Stop(1);
	snd::Sound3D_Stream_Stop(0);
	return 0;
}



BOOL __cdecl lego::main::Config_IsFrontEndEnabled(void)
{
	char *keyPath;
	BOOL3 BVar1;
	
	keyPath = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","FrontEnd",0);
	BVar1 = cfg::CFG_ReadBool(globals::g_Game.LegoCfgRoot,keyPath);
	if ((BVar1 == BOOL3_TRUE) && (globs::mainGlobs.programmerLevel < PROGRAMMER_MODE_3)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::unk::Lego_GetIntNotM1__00558020(void)
{
	return (uint)(INT_00558020 != -1);
}



BOOL __cdecl lego::unk::Lego_GetIntNotM1__00558024(void)
{
	return (uint)(INT_00558024 != -1);
}



char * __cdecl FUN_00416ca0(void)
{
	BOOL BVar1;
	int iVar2;
	
	BVar1 = lego::unk::Lego_GetIntNotM1__00558020();
	if (BVar1 == 0) {
		BVar1 = lego::unk::Lego_GetIntNotM1__00558024();
		if (BVar1 == 0) {
			return (char *)0x0;
		}
		iVar2 = FUN_00417200(DAT_00557ffc,INT_00558024);
		if (iVar2 != -1) {
			return LevelIdentifier_00557fd0.field_4[iVar2];
		}
	}
	else {
		iVar2 = FUN_00417200(DAT_00557ff8,INT_00558020);
		if (iVar2 != -1) {
			return LevelIdentifier_00557fe4.field_4[iVar2];
		}
	}
	return (char *)0x0;
}



int __cdecl lego::front::Front_IsTriggerAppQuit(void)
{
	return globals::g_MainMenuFull_TriggerYesQuit;
}



BOOL __cdecl lego::front::Front_IsTriggerMissionQuit(void)
{
	return (uint)(globals::g_PausedMenu_TriggerQuit != 0);
}



BOOL __cdecl lego::front::Front_IsTriggerMissionRestart(void)
{
	return (uint)(globals::g_PausedMenu_TriggerRestart != 0);
}



undefined4 * __cdecl FUN_00416d30(void)
{
	BOOL BVar1;
	LevelIdentifier *pLVar2;
	
	BVar1 = lego::unk::Lego_GetIntNotM1__00558024();
	pLVar2 = &LevelIdentifier_00557fd0;
	if (BVar1 == 0) {
		pLVar2 = &LevelIdentifier_00557fe4;
	}
	return (undefined4 *)pLVar2;
}



int __cdecl lego::unk::Lego_FindNameInTableStruct(LevelIdentifier *param_1,char *param_2)
{
	int iVar1;
	int iVar2;
	
	iVar2 = 0;
	if (param_1->field_0 < 1) {
		return -1;
	}
	do {
		iVar1 = std::_stricmp(param_2,param_1->field_4[iVar2]);
		if (iVar1 == 0) {
			return iVar2;
		}
		iVar2 = iVar2 + 1;
	} while (iVar2 < param_1->field_0);
	return -1;
}



void __cdecl FUN_00416da0(void)
{
	int iVar1;
	
	iVar1 = 0;
	if (0 < LevelIdentifier_00557fe4.field_0) {
		do {
			if (LevelIdentifier_00557fe4.field_c[iVar1] != (void *)0x0) {
				*(undefined4 *)((int)LevelIdentifier_00557fe4.field_c[iVar1] + 0x10) = 0;
				*(undefined4 *)(LevelIdentifier_00557fe4.field_10 + iVar1 * 4) = 0;
			}
			iVar1 = iVar1 + 1;
		} while (iVar1 < LevelIdentifier_00557fe4.field_0);
	}
	iVar1 = 0;
	if (0 < LevelIdentifier_00557fd0.field_0) {
		do {
			if (LevelIdentifier_00557fd0.field_c[iVar1] != (void *)0x0) {
				*(undefined4 *)((int)LevelIdentifier_00557fd0.field_c[iVar1] + 0x10) = 0;
				*(undefined4 *)(LevelIdentifier_00557fd0.field_10 + iVar1 * 4) = 0;
			}
			iVar1 = iVar1 + 1;
		} while (iVar1 < LevelIdentifier_00557fd0.field_0);
	}
	return;
}



void __cdecl FUN_00416e00(LevelIdentifier *param_1,char *param_2,undefined4 param_3)
{
	byte bVar1;
	byte *pbVar2;
	int iVar3;
	int iVar4;
	byte *pbVar5;
	byte **ppbVar6;
	bool bVar7;
	
	iVar4 = 0;
	if (param_1->field_0 < 1) {
		return;
	}
	ppbVar6 = (byte **)param_1->field_4;
	do {
		pbVar2 = *ppbVar6;
		pbVar5 = (byte *)param_2;
		do {
			bVar1 = *pbVar2;
			bVar7 = bVar1 < *pbVar5;
			if (bVar1 != *pbVar5) {
LAB_00416e3d:
				iVar3 = (1 - (uint)bVar7) - (uint)(bVar7 != 0);
				goto LAB_00416e42;
			}
			if (bVar1 == 0) break;
			bVar1 = pbVar2[1];
			bVar7 = bVar1 < pbVar5[1];
			if (bVar1 != pbVar5[1]) goto LAB_00416e3d;
			pbVar2 = pbVar2 + 2;
			pbVar5 = pbVar5 + 2;
		} while (bVar1 != 0);
		iVar3 = 0;
LAB_00416e42:
		if (iVar3 == 0) {
			*(undefined4 *)(param_1->field_10 + iVar4 * 4) = param_3;
			return;
		}
		iVar4 = iVar4 + 1;
		ppbVar6 = ppbVar6 + 1;
		if (param_1->field_0 <= iVar4) {
			return;
		}
	} while( true );
}



undefined4 __cdecl FUN_00416e70(LevelIdentifier *param_1,char *param_2)
{
	byte bVar1;
	byte *pbVar2;
	int iVar3;
	int iVar4;
	byte *pbVar5;
	byte **ppbVar6;
	bool bVar7;
	
	iVar4 = 0;
	if (param_1->field_0 < 1) {
		return 0;
	}
	ppbVar6 = (byte **)param_1->field_4;
	do {
		pbVar2 = *ppbVar6;
		pbVar5 = (byte *)param_2;
		do {
			bVar1 = *pbVar2;
			bVar7 = bVar1 < *pbVar5;
			if (bVar1 != *pbVar5) {
LAB_00416ead:
				iVar3 = (1 - (uint)bVar7) - (uint)(bVar7 != 0);
				goto LAB_00416eb2;
			}
			if (bVar1 == 0) break;
			bVar1 = pbVar2[1];
			bVar7 = bVar1 < pbVar5[1];
			if (bVar1 != pbVar5[1]) goto LAB_00416ead;
			pbVar2 = pbVar2 + 2;
			pbVar5 = pbVar5 + 2;
		} while (bVar1 != 0);
		iVar3 = 0;
LAB_00416eb2:
		if (iVar3 == 0) {
			return *(undefined4 *)(param_1->field_10 + iVar4 * 4);
		}
		iVar4 = iVar4 + 1;
		ppbVar6 = ppbVar6 + 1;
		if (param_1->field_0 <= iVar4) {
			return 0;
		}
	} while( true );
}



void __cdecl FUN_00416ee0(LevelIdentifier *param_1,char *param_2,void *param_3)
{
	byte bVar1;
	byte *pbVar2;
	int iVar3;
	int iVar4;
	byte *pbVar5;
	byte **ppbVar6;
	bool bVar7;
	
	iVar4 = 0;
	if (param_1->field_0 < 1) {
		return;
	}
	ppbVar6 = (byte **)param_1->field_4;
	do {
		pbVar2 = *ppbVar6;
		pbVar5 = (byte *)param_2;
		do {
			bVar1 = *pbVar2;
			bVar7 = bVar1 < *pbVar5;
			if (bVar1 != *pbVar5) {
LAB_00416f1d:
				iVar3 = (1 - (uint)bVar7) - (uint)(bVar7 != 0);
				goto LAB_00416f22;
			}
			if (bVar1 == 0) break;
			bVar1 = pbVar2[1];
			bVar7 = bVar1 < pbVar5[1];
			if (bVar1 != pbVar5[1]) goto LAB_00416f1d;
			pbVar2 = pbVar2 + 2;
			pbVar5 = pbVar5 + 2;
		} while (bVar1 != 0);
		iVar3 = 0;
LAB_00416f22:
		if (iVar3 == 0) {
			param_1->field_c[iVar4] = param_3;
			return;
		}
		iVar4 = iVar4 + 1;
		ppbVar6 = ppbVar6 + 1;
		if (param_1->field_0 <= iVar4) {
			return;
		}
	} while( true );
}



void * __cdecl FUN_00416f50(LevelIdentifier *param_1,char *param_2)
{
	byte bVar1;
	byte *pbVar2;
	int iVar3;
	int iVar4;
	byte *pbVar5;
	byte **ppbVar6;
	bool bVar7;
	
	iVar4 = 0;
	if (param_1->field_0 < 1) {
		return (void *)0x0;
	}
	ppbVar6 = (byte **)param_1->field_4;
	do {
		pbVar2 = *ppbVar6;
		pbVar5 = (byte *)param_2;
		do {
			bVar1 = *pbVar2;
			bVar7 = bVar1 < *pbVar5;
			if (bVar1 != *pbVar5) {
LAB_00416f8d:
				iVar3 = (1 - (uint)bVar7) - (uint)(bVar7 != 0);
				goto LAB_00416f92;
			}
			if (bVar1 == 0) break;
			bVar1 = pbVar2[1];
			bVar7 = bVar1 < pbVar5[1];
			if (bVar1 != pbVar5[1]) goto LAB_00416f8d;
			pbVar2 = pbVar2 + 2;
			pbVar5 = pbVar5 + 2;
		} while (bVar1 != 0);
		iVar3 = 0;
LAB_00416f92:
		if (iVar3 == 0) {
			return param_1->field_c[iVar4];
		}
		iVar4 = iVar4 + 1;
		ppbVar6 = ppbVar6 + 1;
		if (param_1->field_0 <= iVar4) {
			return (void *)0x0;
		}
	} while( true );
}



int * __cdecl FUN_00416fc0(LevelIdentifier *param_1,char *levelPath)
{
	int iVar1;
	int *piVar2;
	char *pcVar3;
	uint uVar4;
	void *pvVar5;
	int *piVar6;
	uint uVar7;
	char *local_3c [15];
	
	if (levelPath != (char *)0x0) {
		iVar1 = FUN_00416e70(param_1,levelPath);
		if (iVar1 != 0) {
			piVar2 = (int *)FUN_00416f50(param_1,levelPath);
			return piVar2;
		}
		piVar2 = (int *)std::malloc(0x14);
		FUN_00416e00(param_1,levelPath,1);
		FUN_00416ee0(param_1,levelPath,piVar2);
		if (piVar2 != (int *)0x0) {
			iVar1 = lego::unk::Lego_FindNameInTableStruct(param_1,levelPath);
			if (iVar1 != -1) {
				pcVar3 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,levelPath,"LevelLinks",0)
				;
				pcVar3 = lego::cfg::CFG_CopyString(lego::globals::g_Game.LegoCfgRoot,pcVar3);
				*piVar2 = iVar1;
				uVar7 = 0;
				if (pcVar3 == (char *)0x0) {
					piVar2[1] = 0;
				}
				else {
					uVar4 = lego::util::Util_Tokenise(pcVar3,local_3c,",");
					if (uVar4 == 0) goto LAB_004170bd;
					pvVar5 = std::malloc(uVar4 * 4);
					piVar2[1] = (int)pvVar5;
					if (uVar4 != 0) {
						do {
							piVar6 = FUN_00416fc0(param_1,local_3c[uVar7]);
							*(int **)(piVar2[1] + uVar7 * 4) = piVar6;
							uVar7 = uVar7 + 1;
						} while (uVar7 < uVar4);
						piVar2[2] = uVar7;
						return piVar2;
					}
				}
				piVar2[2] = 0;
				return piVar2;
			}
LAB_004170bd:
			std::free(piVar2);
			return (int *)0x0;
		}
	}
	return (int *)0x0;
}



BOOL __cdecl FUN_004170f0(int param_1,undefined *callback,undefined4 param_3)
{
	int iVar1;
	BOOL BVar2;
	uint uVar3;
	
	if ((param_1 != 0) && (*(int *)(param_1 + 0x10) == 0)) {
		*(undefined4 *)(param_1 + 0x10) = 1;
		iVar1 = (*(code *)callback)(param_1,param_3);
		if (iVar1 != 0) {
			return 1;
		}
		if ((*(int *)(param_1 + 4) != 0) && (uVar3 = 0, *(int *)(param_1 + 8) != 0)) {
			do {
				BVar2 = FUN_004170f0(*(int *)(*(int *)(param_1 + 4) + uVar3 * 4),callback,param_3);
				if (BVar2 != 0) {
					return 1;
				}
				uVar3 = uVar3 + 1;
			} while (uVar3 < *(uint *)(param_1 + 8));
			return 0;
		}
	}
	return 0;
}



undefined4 __cdecl FUN_00417170(undefined4 param_1,int *param_2)
{
	*param_2 = *param_2 + 1;
	return 0;
}



BOOL __cdecl FUN_00417180(undefined4 param_1,undefined4 *param_2)
{
	int iVar1;
	
	iVar1 = param_2[2];
	if (param_2[1] == iVar1) {
		param_2[3] = iVar1;
		*param_2 = param_1;
		return 1;
	}
	param_2[2] = iVar1 + 1;
	return 0;
}



undefined4 __cdecl FUN_004171b0(int param_1,undefined4 param_2)
{
	BOOL BVar1;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_10 = 0;
	local_8 = 0;
	local_4 = 0;
	local_c = param_2;
	BVar1 = FUN_004170f0(param_1,FUN_00417180,&local_10);
	if (BVar1 != 0) {
		FUN_00416da0();
		return local_10;
	}
	FUN_00416da0();
	return 0;
}



undefined4 __cdecl FUN_00417200(int param_1,undefined4 param_2)
{
	undefined4 *puVar1;
	
	puVar1 = (undefined4 *)FUN_004171b0(param_1,param_2);
	if (puVar1 != (undefined4 *)0x0) {
		return *puVar1;
	}
	return 0xffffffff;
}



void __cdecl FUN_00417220(int *struct14_1,int *struct14_2,BOOL param_3)
{
	uint *puVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	
	uVar4 = 0;
	if ((struct14_1 != (int *)0x0) && (struct14_1[4] == 0)) {
		if ((PROGRAMMER_MODE_1 < lego::globs::mainGlobs.programmerLevel) ||
			 ((lego::globs::mainGlobs.flags & CMD_TESTLEVELS) != CMD_NONE)) {
			struct14_2[4] = 0;
		}
		struct14_1[4] = 1;
		if (((*struct14_2 == 0) || (PROGRAMMER_MODE_1 < lego::globs::mainGlobs.programmerLevel)) ||
			 ((lego::globs::mainGlobs.flags & CMD_TESTLEVELS) != CMD_NONE)) {
			uVar3 = (uint)(struct14_2[4] == 0);
		}
		else {
			uVar3 = *(uint *)(*struct14_1 * 0x3190 + *struct14_2) & 1;
		}
		if (((uVar3 == 0) && (param_3 == 0)) &&
			 (puVar1 = (uint *)(*(int *)struct14_2[2] + struct14_2[3] * 0x20),
			 *(int *)(*(int *)struct14_2[2] + 0x1c + struct14_2[3] * 0x20) == 0)) {
			uVar2 = *puVar1 & 0xfffffffb;
		}
		else {
			puVar1 = (uint *)(*(int *)struct14_2[2] + struct14_2[3] * 0x20);
			uVar2 = *(uint *)(*(int *)struct14_2[2] + struct14_2[3] * 0x20) | 4;
		}
		*puVar1 = uVar2;
		struct14_2[3] = struct14_2[3] + 1;
		if (struct14_1[2] != 0) {
			do {
				FUN_00417220(*(int **)(struct14_1[1] + uVar4 * 4),struct14_2,uVar3);
				uVar4 = uVar4 + 1;
			} while (uVar4 < (uint)struct14_1[2]);
		}
	}
	return;
}



void __cdecl
FUN_00417310(int *param_1,int param_2,char **param_3,undefined4 param_4,undefined4 param_5)
{
	LevelIdentifier local_14;
	
	local_14.field_4 = param_3;
	local_14.field_8 = param_4;
	local_14.field_0 = param_2;
	local_14.field_c = (void **)0x0;
	local_14.field_10 = param_5;
	FUN_00417220(param_1,(int *)&local_14,1);
	FUN_00416da0();
	return;
}



longlong FUN_00417360(int param_1,int param_2)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)*(float *)(param_1 * 0x3190 + 0x2fb8 + *(int *)(param_2 + 0x34)));
	return lVar1;
}



void __cdecl
lego::unk::lego_uses_testercall_FUN_00417390(undefined4 param_1,undefined4 param_2,float param_3)
{
	ImageFont *font;
	TextWindow *textWnd;
	void *pvVar1;
	int *piVar2;
	undefined *puVar3;
	uint uVar4;
	undefined4 uVar5;
	char *pcVar6;
	int iVar7;
	undefined4 *puVar8;
	char local_16c;
	undefined local_16b [63];
	char local_12c [8];
	char acStack292 [292];
	
	pvVar1 = globals::g_UnkStruct728_Menu_LevelText;
	font = globals::menu::g_MainMenuFull->menus[1]->MenuFont;
	piVar2 = (int *)FUN_004171b0(DAT_00557ff8,param_2);
	pcVar6 = *(char **)(LevelIdentifier_00557fe4.field_8 + *piVar2 * 4);
	local_16c = '\0';
	puVar8 = (undefined4 *)local_16b;
	for (iVar7 = 0xf; iVar7 != 0; iVar7 = iVar7 + -1) {
		*puVar8 = 0;
		puVar8 = puVar8 + 1;
	}
	*(undefined2 *)puVar8 = 0;
	*(undefined *)((int)puVar8 + 2) = 0;
	puVar3 = FUN_00417da0();
	DAT_00558838 = DAT_00558834;
	DAT_00558834 = *piVar2 + 1;
	if ((globs::mainGlobs.flags & CMD_TESTERCALL) != CMD_NONE) {
		std::sprintf(&local_16c," (Level %d)",*piVar2 + 1);
	}
	if ((pcVar6 == (char *)0x0) || (*pcVar6 == '\0')) {
		pcVar6 = LevelIdentifier_00557fe4.field_4[*piVar2];
	}
										// WARNING: Load size is inaccurate
	textWnd = *pvVar1;
	if (textWnd == (TextWindow *)0x0) {
		uVar4 = image::FontX_GetStringWidth(font,pcVar6);
		Lego_UnkPrintf_FUN_00410250(font,(int)globs::mainGlobs.appWidth / 2 - (int)uVar4 / 2,390,pcVar6)
		;
	}
	else {
		if ((BOOL_004dc8c4 != 0) &&
			 (front::TextWindow_PrintF(textWnd,pcVar6),
			 (globs::mainGlobs.flags & CMD_TESTERCALL) != CMD_NONE)) {
										// WARNING: Load size is inaccurate
			front::TextWindow_PrintF(*pvVar1,&local_16c);
		}
	}
	if (puVar3 != (undefined *)0x0) {
		uVar4 = *(uint *)(*(int *)(puVar3 + 0x34) + *piVar2 * 0x3190);
		if (((uVar4 & 1) != 0) && ((uVar4 & 2) == 0)) {
			uVar5 = FUN_00417360(*piVar2,puVar3);
			pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu","Level_Completed",0,uVar5);
			pcVar6 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar6);
			std::sprintf(acStack292," %s (%i)",pcVar6);
			util::stringReplaceChar(acStack292,'_',' ');
			goto LAB_0041757a;
		}
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Menu","Level_Incomplete",0);
	pcVar6 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar6);
	std::sprintf(local_12c," %s",pcVar6);
	util::stringReplaceChar(local_12c,'_',' ');
LAB_0041757a:
	if ((*local_16b._3_4_ != (TextWindow *)0x0) && (BOOL_004dc8c4 != 0)) {
		front::TextWindow_PrintF(*local_16b._3_4_,acStack292);
		if (DAT_00558834 != DAT_00558838) {
			BOOL_0055883c = 1;
			FLOAT_00558840 = 0.0;
		}
		if ((BOOL_0055883c != 0) &&
			 (FLOAT_00558840 = param_3 + FLOAT_00558840,
			 (ushort)((ushort)(FLOAT_00558840 * 25.0 < 500.0) << 8 |
							 (ushort)(FLOAT_00558840 * 25.0 == 500.0) << 0xe) == 0)) {
			if (DAT_00558834 < 9) {
				iVar7 = FUN_004160d0(DAT_00558834);
			}
			else {
				iVar7 = FUN_00416080(DAT_00558834 + -8);
			}
			if (iVar7 != 0) {
				BOOL_0055883c = 0;
			}
		}
	}
	BOOL_004dc8c4 = 0;
	return;
}



void __cdecl FUN_00417630(float param_1,undefined4 param_2)
{
	void *pvVar1;
	int *piVar2;
	BOOL BVar3;
	char *format;
	
	pvVar1 = lego::globals::g_UnkStruct728_Menu_LevelText;
	piVar2 = (int *)FUN_004171b0(DAT_00557ffc,param_2);
	format = *(char **)(LevelIdentifier_00557fd0.field_8 + *piVar2 * 4);
	DAT_00558838 = DAT_00558834;
	DAT_00558834 = *piVar2 + 1;
	if ((format == (char *)0x0) || (*format == '\0')) {
		format = LevelIdentifier_00557fd0.field_4[*piVar2];
	}
										// WARNING: Load size is inaccurate
	if ((*pvVar1 != (TextWindow *)0x0) && (BOOL_004dc8c4 != 0)) {
		lego::front::TextWindow_PrintF(*pvVar1,format);
		if (DAT_00558834 != DAT_00558838) {
			BOOL_0055883c = 1;
			FLOAT_00558840 = 0.0;
		}
		if ((BOOL_0055883c != 0) &&
			 (FLOAT_00558840 = param_1 + FLOAT_00558840,
			 (ushort)((ushort)(FLOAT_00558840 * 25.0 < 500.0) << 8 |
							 (ushort)(FLOAT_00558840 * 25.0 == 500.0) << 0xe) == 0)) {
			BVar3 = FUN_004160d0(DAT_00558834);
			if (BVar3 != 0) {
				BOOL_0055883c = 0;
			}
		}
	}
	BOOL_004dc8c4 = 0;
	return;
}



undefined4 __cdecl FUN_00417710(int *param_1,int *param_2)
{
	char cVar1;
	undefined4 uVar2;
	char *pcVar3;
	int iVar4;
	int iVar5;
	BOOL3 BVar6;
	byte *buffer;
	uint uVar7;
	uint uVar8;
	undefined4 *puVar9;
	char *pcVar10;
	undefined4 *puVar11;
	undefined4 local_400 [256];
	
	uVar2 = *(undefined4 *)(*(int *)(*param_2 + 4) + *param_1 * 4);
	pcVar3 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,uVar2,"FrontEndX",0);
	pcVar3 = lego::cfg::CFG_ReadString(lego::globals::g_Game.LegoCfgRoot,pcVar3);
	if (pcVar3 == (char *)0x0) {
		pcVar3 = ____EMPTYSTR__;
	}
	else {
		pcVar3 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,uVar2,"FrontEndX",0);
		pcVar3 = lego::cfg::CFG_ReadString(lego::globals::g_Game.LegoCfgRoot,pcVar3);
	}
	iVar4 = std::atoi(pcVar3);
	pcVar3 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,uVar2,"FrontEndY",0);
	pcVar3 = lego::cfg::CFG_ReadString(lego::globals::g_Game.LegoCfgRoot,pcVar3);
	if (pcVar3 == (char *)0x0) {
		pcVar3 = ____EMPTYSTR__;
	}
	else {
		pcVar3 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,uVar2,"FrontEndY",0);
		pcVar3 = lego::cfg::CFG_ReadString(lego::globals::g_Game.LegoCfgRoot,pcVar3);
	}
	iVar5 = std::atoi(pcVar3);
	pcVar3 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,uVar2,"FrontEndOpen",0);
	BVar6 = lego::cfg::CFG_ReadBool(lego::globals::g_Game.LegoCfgRoot,pcVar3);
	if (BVar6 == BOOL3_ERROR) {
		BVar6 = BOOL3_FALSE;
	}
	pcVar3 = lego::cfg::CFG_JoinPath(lego::globals::g_Game.CfgRootName,uVar2,"MenuBMP",0);
	buffer = (byte *)lego::cfg::CFG_CopyString(lego::globals::g_Game.LegoCfgRoot,pcVar3);
	if (buffer != (byte *)0x0) {
		FUN_00410670((int **)param_2[2],buffer,0,(undefined4 *)0x0,iVar4,iVar5,BVar6);
		std::free(buffer);
		return 0;
	}
	uVar7 = 0xffffffff;
	pcVar3 = lego::globals::g_Menu_DefaultLevelBMPS;
	do {
		pcVar10 = pcVar3;
		if (uVar7 == 0) break;
		uVar7 = uVar7 - 1;
		pcVar10 = pcVar3 + 1;
		cVar1 = *pcVar3;
		pcVar3 = pcVar10;
	} while (cVar1 != '\0');
	uVar7 = ~uVar7;
	puVar9 = (undefined4 *)(pcVar10 + -uVar7);
	puVar11 = local_400;
	for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {
		*puVar11 = *puVar9;
		puVar9 = puVar9 + 1;
		puVar11 = puVar11 + 1;
	}
	for (uVar7 = uVar7 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {
		*(undefined *)puVar11 = *(undefined *)puVar9;
		puVar9 = (undefined4 *)((int)puVar9 + 1);
		puVar11 = (undefined4 *)((int)puVar11 + 1);
	}
	FUN_00410670((int **)param_2[2],(byte *)local_400,0,(undefined4 *)0x0,iVar4,iVar5,BVar6);
	return 0;
}



void __cdecl
FUN_004178e0(int param_1,int param_2,undefined4 param_3,int param_4,undefined4 param_5,
						undefined4 param_6,undefined4 param_7)
{
	int submenu;
	undefined4 *puVar1;
	SubMenuItem *menuItem;
	undefined4 local_10;
	int local_c;
	undefined4 *local_8;
	undefined4 local_4;
	
	submenu = param_4;
	local_10 = param_3;
	local_c = param_4;
	local_8 = (undefined4 *)0x0;
	local_4 = param_5;
	param_3 = 0;
	FUN_004170f0(param_2,FUN_00417170,&param_3);
	FUN_00416da0();
	puVar1 = FUN_00410520(&lego::globals::g_MainMenuFull_TriggerCredits + param_1 * 4,____EMPTYSTR__,
												____EMPTYSTR__,0,0,0,param_3,0,0,0,0,0,param_7,param_6);
	menuItem = lego::front::Menu_CreateItem3C
											 ("Levels!!!",(ImageFont *)0x0,(ImageFont *)0x0,0,0,MENUITEM__COUNT,1,puVar1,0
											 );
	lego::front::Menu_AddSubMenuItem((SubMenu *)submenu,menuItem);
	local_8 = puVar1;
	FUN_004170f0(param_2,FUN_00417710,&local_10);
	FUN_00416da0();
	return;
}



BOOL __cdecl
lego::game::Game_UnkLoadSaveSlot__004179c0(uint saveIndex,undefined4 *param_2,BOOL param_3)
{
	uint saveNumber;
	FileStream *f;
	void *out_buffer;
	int iVar1;
	undefined4 *puVar2;
	undefined4 local_68;
	char local_64 [100];
	
	saveNumber = saveIndex;
	if (saveIndex < 6) {
		std::sprintf(local_64,"%s\\%i.sav","Saves",saveIndex);
		f = lego::file::File_Open(local_64,"rb");
		puVar2 = param_2;
		if (f != (FileStream *)0x0) {
			saveIndex = 0;
			local_68 = 0;
			lego::file::File_Read(param_2,0xb0,1,f);
			FUN_004170f0(DAT_00557ff8,FUN_00417170,&saveIndex);
			FUN_00416da0();
			FUN_004170f0(DAT_00557ffc,FUN_00417170,&local_68);
			FUN_00416da0();
			if ((puVar2[6] != saveIndex) && (param_3 == 0)) {
				save::Save_SPrintfFileUnkWrite__00417b00(saveNumber,0);
				for (iVar1 = 0x2e; iVar1 != 0; iVar1 = iVar1 + -1) {
					*puVar2 = 0;
					puVar2 = puVar2 + 1;
				}
				return 0;
			}
			out_buffer = std::malloc(puVar2[6] * 0x3190);
			puVar2[0xd] = out_buffer;
			lego::file::File_Read(out_buffer,0x3190,puVar2[6],f);
			lego::file::File_Close(f);
			return 1;
		}
		if (param_3 == 0) {
			save::Save_SPrintfFileUnkWrite__00417b00(saveNumber,0);
		}
	}
	return 0;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

BOOL __cdecl lego::save::Save_SPrintfFileUnkWrite__00417b00(uint saveNumber,void *param_2)
{
	FileStream *pFVar1;
	int iVar2;
	uint uVar3;
	undefined4 *puVar4;
	int iStack12976;
	undefined4 uStack12972;
	undefined4 auStack12968 [5];
	uint auStack12948 [40];
	char acStack12788 [100];
	undefined4 uStack12688;
	undefined4 auStack12684 [3170];
	undefined4 uStack4;
	
	uStack4 = 0x417b0a;
	if (saveNumber < 6) {
		std::sprintf(acStack12788,"%s\\%i.sav","Saves",saveNumber);
		uVar3 = 0;
		if (param_2 == (void *)0x0) {
			lego::file::File_MakeDir("Saves");
			pFVar1 = lego::file::File_Open(acStack12788,"wb");
			if (pFVar1 != (FileStream *)0x0) {
				uStack12972 = 0;
				puVar4 = auStack12968;
				for (iVar2 = 0x2d; iVar2 != 0; iVar2 = iVar2 + -1) {
					*puVar4 = 0;
					puVar4 = puVar4 + 1;
				}
				uStack12688 = 0;
				auStack12968[1] = 7;
				puVar4 = auStack12684;
				for (iVar2 = 0xc63; iVar2 != 0; iVar2 = iVar2 + -1) {
					*puVar4 = 0;
					puVar4 = puVar4 + 1;
				}
				auStack12968[0] = 5;
				auStack12968[3] = 5;
				auStack12968[2] = 1;
				auStack12948[0] = 0;
				FUN_004170f0(DAT_00557ff8,FUN_00417170,auStack12948);
				FUN_00416da0();
				lego::file::File_Write(&uStack12972,0xb4,1,pFVar1);
				if (auStack12948[0] != 0) {
					do {
						lego::file::File_Write(&uStack12688,0x3190,1,pFVar1);
						uVar3 = uVar3 + 1;
					} while (uVar3 < auStack12948[0]);
				}
				lego::file::File_Close(pFVar1);
				return 1;
			}
		}
		else {
			iStack12976 = 0;
			FUN_004170f0(DAT_00557ff8,FUN_00417170,&iStack12976);
			FUN_00416da0();
			if (iStack12976 != *(int *)((int)param_2 + 0x18)) {
				Save_SPrintfFileUnkWrite__00417b00(saveNumber,(void *)0x0);
				return 1;
			}
			pFVar1 = lego::file::File_Open(acStack12788,"wb");
			if (pFVar1 != (FileStream *)0x0) {
				lego::file::File_Write(param_2,0xb0,1,pFVar1);
				if (*(int *)((int)param_2 + 0x18) != 0) {
					lego::file::File_Write
										(*(void **)((int)param_2 + 0x34),0x3190,*(int *)((int)param_2 + 0x18),pFVar1);
				}
				lego::file::File_Close(pFVar1);
				std::sprintf(acStack12788,"%s\\%i.osf","Saves",saveNumber);
				unk::Lego_Write_SORRFile__004596a0(acStack12788);
				return 1;
			}
		}
	}
	return 0;
}



void __cdecl FUN_00417d20(uint param_1)
{
	BOOL BVar1;
	Struct_b8__00558080 *pSVar2;
	uint saveIndex;
	
	saveIndex = 0;
	pSVar2 = lego::globals::g_Struct_b8_TABLE__00558080;
	do {
		if ((lego::globs::mainGlobs.flags & CMD_CLEANSAVES) == CMD_NONE) {
			BVar1 = lego::game::Game_UnkLoadSaveSlot__004179c0(saveIndex,(undefined4 *)pSVar2,0);
			if (BVar1 == 0) goto LAB_00417d53;
		}
		else {
			lego::save::Save_SPrintfFileUnkWrite__00417b00(saveIndex,0);
LAB_00417d53:
			lego::game::Game_UnkLoadSaveSlot__004179c0(saveIndex,(undefined4 *)pSVar2,0);
		}
		pSVar2 = pSVar2 + 1;
		saveIndex = saveIndex + 1;
		if ((Struct_b8__00558080 *)((int)&lego::globals::g_Struct_b8_TABLE__00558080[5].field_0xb4 + 3U)
				< pSVar2) {
			return;
		}
	} while( true );
}



undefined * __cdecl FUN_00417d80(int saveIndex)
{
	if ((saveIndex < 6) && (-1 < saveIndex)) {
		return (undefined *)(lego::globals::g_Struct_b8_TABLE__00558080 + saveIndex);
	}
	return (undefined *)(Struct_b8__00558080 *)0x0;
}



undefined * __cdecl FUN_00417da0(void)
{
	undefined *puVar1;
	
	if (lego::globals::g_SaveNumber != -1) {
		puVar1 = FUN_00417d80(lego::globals::g_SaveNumber);
		return puVar1;
	}
	return (undefined *)0x0;
}



int __cdecl lego::save::Save_GetSaveNumber(void)
{
	return globals::g_SaveNumber;
}



void __cdecl lego::save::Save_SetSaveNumber(int saveIndex)
{
	globals::g_SaveNumber = saveIndex;
	return;
}



void __cdecl FUN_00417de0(uint param_1)
{
	undefined *puVar1;
	BOOL BVar2;
	uint *puVar3;
	
	puVar1 = FUN_00417da0();
	if (puVar1 != (undefined *)0x0) {
		BVar2 = lego::unk::Lego_GetIntNotM1__00558024();
		if (BVar2 == 0) {
			if (7 < param_1) {
				if (*(uint *)(puVar1 + 0x18) <= param_1 && param_1 != *(uint *)(puVar1 + 0x18)) {
					return;
				}
				*(uint *)(param_1 * 0x3190 + *(int *)(puVar1 + 0x34)) =
						 *(uint *)(param_1 * 0x3190 + *(int *)(puVar1 + 0x34)) | 1;
				return;
			}
		}
		else {
			if (7 < param_1) {
				return;
			}
		}
		puVar3 = (uint *)(*(int *)(puVar1 + 0x34) + param_1 * 0x3190);
		*puVar3 = *puVar3 | 1;
		puVar3 = (uint *)(param_1 * 0x3190 + *(int *)(puVar1 + 0x34));
		*puVar3 = *puVar3 | 2;
	}
	return;
}



void __cdecl FUN_00417e50(undefined4 *param_1)
{
	undefined *puVar1;
	int iVar2;
	undefined4 *puVar3;
	
	puVar1 = FUN_00417da0();
	if (puVar1 != (undefined *)0x0) {
		puVar3 = (undefined4 *)(puVar1 + 0x1c);
		for (iVar2 = 6; iVar2 != 0; iVar2 = iVar2 + -1) {
			*puVar3 = *param_1;
			param_1 = param_1 + 1;
			puVar3 = puVar3 + 1;
		}
	}
	return;
}



BOOL __cdecl FUN_00417e70(int param_1,undefined4 *param_2)
{
	undefined *puVar1;
	int iVar2;
	undefined4 *puVar3;
	
	puVar1 = FUN_00417da0();
	if ((puVar1 != (undefined *)0x0) && (param_1 < *(int *)(puVar1 + 0x18))) {
		puVar3 = (undefined4 *)(param_1 * 0x3190 + 4 + *(int *)(puVar1 + 0x34));
		for (iVar2 = 0xc63; iVar2 != 0; iVar2 = iVar2 + -1) {
			*puVar3 = *param_2;
			param_2 = param_2 + 1;
			puVar3 = puVar3 + 1;
		}
		return 1;
	}
	return 0;
}



int __cdecl FUN_00417ec0(int param_1)
{
	undefined *puVar1;
	
	puVar1 = FUN_00417da0();
	if ((puVar1 != (undefined *)0x0) && (param_1 < *(int *)(puVar1 + 0x18))) {
		return param_1 * 0x3190 + 4 + *(int *)(puVar1 + 0x34);
	}
	return 0;
}



BOOL __cdecl FUN_00417ef0(void)
{
	undefined *puVar1;
	BOOL BVar2;
	
	puVar1 = FUN_00417da0();
	BVar2 = lego::save::Save_SPrintfFileUnkWrite__00417b00(lego::globals::g_SaveNumber,puVar1);
	return BVar2;
}



undefined4 __cdecl lego::unk::Lego_GetDat_00558500(void)
{
	return DAT_00558500;
}



void __cdecl lego::unk::Lego_SetDat_00558500(undefined4 param_1)
{
	DAT_00558500 = param_1;
	return;
}



void __cdecl FUN_00417f30(undefined4 param_1,undefined4 param_2,undefined4 param_3,uint param_4)
{
	int saveNumber;
	undefined4 uVar1;
	
	uVar1 = 0;
	saveNumber = lego::save::Save_GetSaveNumber();
	lego::save::Save_SPrintfFileUnkWrite__00417b00(saveNumber,uVar1);
	FUN_00417310(DAT_00557ff8,0,&LevelIdentifier_00557fe4,
							 *(undefined4 *)(lego::globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10),
							 1);
	return;
}



void __cdecl FUN_00417f70(undefined4 *param_1)
{
	undefined *puVar1;
	undefined4 *puVar2;
	void *pvVar3;
	int iVar4;
	uint uVar5;
	undefined4 *puVar6;
	
	puVar1 = FUN_00417da0();
	if (puVar1 != (undefined *)0x0) {
		puVar2 = (undefined4 *)FUN_00417da0();
		puVar6 = param_1;
		for (iVar4 = 0x2e; iVar4 != 0; iVar4 = iVar4 + -1) {
			*puVar6 = *puVar2;
			puVar2 = puVar2 + 1;
			puVar6 = puVar6 + 1;
		}
		pvVar3 = std::malloc(param_1[6] * 0x3190);
		param_1[0xd] = pvVar3;
		if (pvVar3 != (void *)0x0) {
			iVar4 = param_1[6];
			puVar1 = FUN_00417da0();
			puVar2 = *(undefined4 **)(puVar1 + 0x34);
			puVar6 = (undefined4 *)param_1[0xd];
			for (uVar5 = (uint)(iVar4 * 0x3190) >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
				*puVar6 = *puVar2;
				puVar2 = puVar2 + 1;
				puVar6 = puVar6 + 1;
			}
			for (iVar4 = 0; iVar4 != 0; iVar4 = iVar4 + -1) {
				*(undefined *)puVar6 = *(undefined *)puVar2;
				puVar2 = (undefined4 *)((int)puVar2 + 1);
				puVar6 = (undefined4 *)((int)puVar6 + 1);
			}
		}
	}
	return;
}



void __cdecl FUN_00417ff0(undefined4 *param_1)
{
	undefined *puVar1;
	undefined4 *puVar2;
	int iVar3;
	undefined4 *puVar4;
	
	puVar1 = FUN_00417da0();
	if (puVar1 != (undefined *)0x0) {
		puVar1 = FUN_00417da0();
		if (*(int *)(puVar1 + 0x34) != 0) {
			puVar1 = FUN_00417da0();
			std::free(*(void **)(puVar1 + 0x34));
		}
		puVar2 = (undefined4 *)FUN_00417da0();
		puVar4 = param_1;
		for (iVar3 = 0x2e; iVar3 != 0; iVar3 = iVar3 + -1) {
			*puVar2 = *puVar4;
			puVar4 = puVar4 + 1;
			puVar2 = puVar2 + 1;
		}
		puVar1 = FUN_00417da0();
		*(undefined4 *)(puVar1 + 0x34) = param_1[0xd];
	}
	return;
}



void __cdecl lego::unk::Lego_SetDat_0055881c(undefined4 param_1)
{
	DAT_0055881c = param_1;
	return;
}



BOOL __cdecl FUN_00418050(void)
{
	undefined *puVar1;
	uint uVar2;
	uint uVar3;
	int iVar4;
	longlong lVar5;
	
	puVar1 = FUN_00417da0();
	if (puVar1 != (undefined *)0x0) {
		uVar2 = 0;
		uVar3 = 8;
		puVar1 = FUN_00417da0();
		if (8 < *(uint *)(puVar1 + 0x18)) {
			iVar4 = 0x18c80;
			do {
				puVar1 = FUN_00417da0();
				lVar5 = __ftol((float10)*(float *)(*(int *)(puVar1 + 0x34) + 0x2fb8 + iVar4));
				uVar2 = uVar2 + (int)lVar5;
				uVar3 = uVar3 + 1;
				iVar4 = iVar4 + 0x3190;
				puVar1 = FUN_00417da0();
			} while (uVar3 < *(uint *)(puVar1 + 0x18));
		}
		puVar1 = FUN_00417da0();
		if (99 < uVar2 / (*(int *)(puVar1 + 0x18) - 8U)) {
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::main::Main_Font_SetDefault(ImageFont *font)
{
	globals::g_DefaultFont = font;
	return;
}



void __cdecl lego::unk::Lego_UnsetFlag1_004dd650(void)
{
	FLAGS_004dd650 = FLAGS_004dd650 & 0xfffffffe;
	return;
}



void __cdecl lego::main::Main_Load_HelpWindow(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	int iVar4;
	Rect2F local_50;
	char *local_40;
	char *local_3c;
	char *local_38;
	char *local_34;
	
	Main_Load_HelpWindowInfo_Levels(root,rootPath);
	pcVar3 = cfg::CFG_JoinPath(rootPath,"HelpWindow","BackGroundImage",0);
	pcVar3 = cfg::CFG_CopyString(root,pcVar3);
	if (pcVar3 != (char *)0x0) {
		util::Util_Tokenise(pcVar3,&local_40,",");
		globals::g_HelpWindow_BackgroundImage_bitmap = image::Image_LoadBMPScaled(local_40,0,0);
		if (globals::g_HelpWindow_BackgroundImage_bitmap != (ImageBMP *)0x0) {
			image::Image_SetupTrans(globals::g_HelpWindow_BackgroundImage_bitmap,0.0,0.0,0.0,0.0,0.0,0.0);
		}
		iVar4 = std::atoi(local_3c);
		globals::g_HelpWindow_BackgroundImage_x = (float)iVar4;
		iVar4 = std::atoi(local_38);
		globals::g_HelpWindow_BackgroundImage_y = (float)iVar4;
		std::free(pcVar3);
	}
	Main_Load_HelpWindow_Buttons(root,rootPath);
	pcVar3 = cfg::CFG_JoinPath(rootPath,"HelpWindow","TextWindowArea",0);
	pcVar3 = cfg::CFG_CopyString(root,pcVar3);
	if (pcVar3 != (char *)0x0) {
		util::Util_Tokenise(pcVar3,&local_40,",");
		iVar4 = std::atoi(local_40);
		local_50.x = (float)iVar4;
		iVar4 = std::atoi(local_3c);
		local_50.y = (float)iVar4;
		iVar4 = std::atoi(local_38);
		local_50.width = (float)iVar4;
		iVar4 = std::atoi(local_34);
		local_50.height = (float)iVar4;
		globals::g_HelpWindow_TextWindowArea_unkDrawRegion =
				 front::TextWindow_Create(globals::g_DefaultFont,&local_50,0x400);
		globals::g_HelpWindow_TextWindowArea_y2 = local_50.y + local_50.height;
		globals::g_HelpWindow_TextWindowArea_x = local_50.x;
		globals::g_HelpWindow_TextWindowArea_y = local_50.y;
		std::free(pcVar3);
	}
	pcVar3 = cfg::CFG_JoinPath(rootPath,"HelpWindow","CanBuildMessage",0);
	globals::g_HelpWindow_CanBuildMessage = cfg::CFG_CopyString(root,pcVar3);
	if (globals::g_HelpWindow_CanBuildMessage != (char *)0x0) {
		cVar2 = *globals::g_HelpWindow_CanBuildMessage;
		pcVar3 = globals::g_HelpWindow_CanBuildMessage;
		while (cVar2 != '\0') {
			if (cVar2 == '_') {
				*pcVar3 = ' ';
			}
			pcVar1 = pcVar3 + 1;
			pcVar3 = pcVar3 + 1;
			cVar2 = *pcVar1;
		}
	}
	pcVar3 = cfg::CFG_JoinPath(rootPath,"HelpWindow","CanTransportMessage",0);
	globals::g_HelpWindow_CanTransportMessage = cfg::CFG_CopyString(root,pcVar3);
	if (globals::g_HelpWindow_CanTransportMessage != (char *)0x0) {
		cVar2 = *globals::g_HelpWindow_CanTransportMessage;
		pcVar3 = globals::g_HelpWindow_CanTransportMessage;
		while (cVar2 != '\0') {
			if (cVar2 == '_') {
				*pcVar3 = ' ';
			}
			pcVar1 = pcVar3 + 1;
			pcVar3 = pcVar3 + 1;
			cVar2 = *pcVar1;
		}
	}
	pcVar3 = cfg::CFG_JoinPath(rootPath,"HelpWindow","CanBuildAndTransportMessage",0);
	globals::g_HelpWindow_CanBuildAndTransportMessage = cfg::CFG_CopyString(root,pcVar3);
	if (globals::g_HelpWindow_CanBuildAndTransportMessage != (char *)0x0) {
		cVar2 = *globals::g_HelpWindow_CanBuildAndTransportMessage;
		pcVar3 = globals::g_HelpWindow_CanBuildAndTransportMessage;
		while (cVar2 != '\0') {
			if (cVar2 == '_') {
				*pcVar3 = ' ';
			}
			pcVar1 = pcVar3 + 1;
			pcVar3 = pcVar3 + 1;
			cVar2 = *pcVar1;
		}
	}
	FLAGS_004dd650 = FLAGS_004dd650 & 0xffffff00 | FLAGS_004dd650 & 0xff | 4 | 2;
	FUN_00419130(0,0);
	return;
}



void __cdecl lego::main::Main_Load_HelpWindowInfo_Levels(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	uint uVar5;
	HelpWindowInfoLevels *pHVar6;
	char local_400 [1024];
	
	uVar4 = 0;
	if (globals::g_Game.VehicleTypes_COUNT != 0) {
		pHVar6 = globals::g_HelpWindowInfo_VehicleTypes_Levels_TABLE;
		do {
			uVar5 = 0;
			do {
				std::sprintf(local_400,"HelpWindow::HelpWindowInfo::%sL%i",
										 globals::g_Game.VehicleTypes_TABLE[uVar4],uVar5);
				pcVar3 = cfg::CFG_JoinPath(rootPath,local_400,0);
				pcVar3 = cfg::CFG_CopyString(root,pcVar3);
				pHVar6->levels[0] = pcVar3;
				if (pcVar3 != (char *)0x0) {
					cVar2 = *pcVar3;
					while (cVar2 != '\0') {
						if (cVar2 == '_') {
							*pcVar3 = ' ';
						}
						pcVar1 = pcVar3 + 1;
						pcVar3 = pcVar3 + 1;
						cVar2 = *pcVar1;
					}
				}
				uVar5 = uVar5 + 1;
				pHVar6 = (HelpWindowInfoLevels *)(pHVar6->levels + 1);
			} while (uVar5 < 0x10);
			uVar4 = uVar4 + 1;
		} while (uVar4 < globals::g_Game.VehicleTypes_COUNT);
	}
	uVar4 = 0;
	if (globals::g_Game.MiniFigureTypes_COUNT != 0) {
		pHVar6 = globals::g_HelpWindowInfo_MiniFigureTypes_Levels_TABLE;
		do {
			uVar5 = 0;
			do {
				std::sprintf(local_400,"HelpWindow::HelpWindowInfo::%sL%i",
										 globals::g_Game.MiniFigureTypes_TABLE[uVar4],uVar5);
				pcVar3 = cfg::CFG_JoinPath(rootPath,local_400,0);
				pcVar3 = cfg::CFG_CopyString(root,pcVar3);
				pHVar6->levels[0] = pcVar3;
				if (pcVar3 != (char *)0x0) {
					cVar2 = *pcVar3;
					while (cVar2 != '\0') {
						if (cVar2 == '_') {
							*pcVar3 = ' ';
						}
						pcVar1 = pcVar3 + 1;
						pcVar3 = pcVar3 + 1;
						cVar2 = *pcVar1;
					}
				}
				uVar5 = uVar5 + 1;
				pHVar6 = (HelpWindowInfoLevels *)(pHVar6->levels + 1);
			} while (uVar5 < 0x10);
			uVar4 = uVar4 + 1;
		} while (uVar4 < globals::g_Game.MiniFigureTypes_COUNT);
	}
	uVar4 = 0;
	if (globals::g_Game.BuildingTypes_COUNT != 0) {
		pHVar6 = globals::g_HelpWindowInfo_BuildingTypes_Levels_TABLE;
		do {
			uVar5 = 0;
			do {
				std::sprintf(local_400,"HelpWindow::HelpWindowInfo::%sL%i",
										 globals::g_Game.BuildingTypes_TABLE[uVar4],uVar5);
				pcVar3 = cfg::CFG_JoinPath(rootPath,local_400,0);
				pcVar3 = cfg::CFG_CopyString(root,pcVar3);
				pHVar6->levels[0] = pcVar3;
				if (pcVar3 != (char *)0x0) {
					cVar2 = *pcVar3;
					while (cVar2 != '\0') {
						if (cVar2 == '_') {
							*pcVar3 = ' ';
						}
						pcVar1 = pcVar3 + 1;
						pcVar3 = pcVar3 + 1;
						cVar2 = *pcVar1;
					}
				}
				uVar5 = uVar5 + 1;
				pHVar6 = (HelpWindowInfoLevels *)(pHVar6->levels + 1);
			} while (uVar5 < 0x10);
			uVar4 = uVar4 + 1;
		} while (uVar4 < globals::g_Game.BuildingTypes_COUNT);
	}
	return;
}



void __cdecl lego::main::Main_Load_HelpWindow_Buttons(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	int iVar2;
	char *local_40;
	char *local_3c;
	char *local_38;
	char *local_34;
	char *local_30;
	char *local_2c;
	char *local_28;
	
	pcVar1 = cfg::CFG_JoinPath(rootPath,"HelpWindow","ContinueButton",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		util::Util_Tokenise(pcVar1,&local_40,",");
		iVar2 = std::atoi(local_40);
		globals::g_HelpWindow_ContinueButton_x = (float)iVar2 + globals::g_HelpWindow_BackgroundImage_x;
		iVar2 = std::atoi(local_3c);
		globals::g_HelpWindow_ContinueButton_y = (float)iVar2 + globals::g_HelpWindow_BackgroundImage_y;
		iVar2 = std::atoi(local_38);
		globals::g_HelpWindow_ContinueButton_width = (float)iVar2;
		iVar2 = std::atoi(local_34);
		globals::g_HelpWindow_ContinueButton_height = (float)iVar2;
		globals::g_HelpWindow_ContinueButton_bmp = image::Image_LoadBMPScaled(local_30,0,0);
		globals::g_HelpWindow_ContinueButton_bmp_push = image::Image_LoadBMPScaled(local_2c,0,0);
		globals::g_HelpWindow_ContinueButton_text = util::Util_RemoveUnderscores(local_28);
		front::ToolTip_Load_HasNLEscape(8,globals::g_HelpWindow_ContinueButton_text);
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"HelpWindow","CancelFutureButton",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		util::Util_Tokenise(pcVar1,&local_40,",");
		iVar2 = std::atoi(local_40);
		globals::g_HelpWindow_CancelFutureButton_x =
				 (float)iVar2 + globals::g_HelpWindow_BackgroundImage_x;
		iVar2 = std::atoi(local_3c);
		globals::g_HelpWindow_CancelFutureButton_y =
				 (float)iVar2 + globals::g_HelpWindow_BackgroundImage_y;
		iVar2 = std::atoi(local_38);
		globals::g_HelpWindow_CancelFutureButton_width = (float)iVar2;
		iVar2 = std::atoi(local_34);
		globals::g_HelpWindow_CancelFutureButton_height = (float)iVar2;
		globals::g_HelpWindow_CancelFutureButton_bmp = image::Image_LoadBMPScaled(local_30,0,0);
		globals::g_HelpWindow_CancelFutureButton_bmp_push = image::Image_LoadBMPScaled(local_2c,0,0);
		globals::g_HelpWindow_CancelFutureButton_text = util::Util_RemoveUnderscores(local_28);
		front::ToolTip_Load_HasNLEscape(9,globals::g_HelpWindow_CancelFutureButton_text);
	}
	return;
}



void __cdecl lego::game::Game_SetPlaceFlagsState_004dd650(BOOL param_1)
{
	if ((FLAGS_004dd650 & 4) != 0) {
		if (param_1 != 0) {
			FLAGS_004dd650 = FLAGS_004dd650 & 0xffffff00 | FLAGS_004dd650 & 0xfe | 2;
			return;
		}
		FLAGS_004dd650 = FLAGS_004dd650 & 0xfffffffc;
	}
	return;
}



void __cdecl
lego::game::Game_UpdateObjectDependencies
					(ObjectType objType,int objIndex,int objLevel,BOOL noHelpWindow)
{
	uint uVar1;
	
	main::Main_Init_MiscObjectDependencies();
	uVar1 = Object_GetDependencyLevelFlag_100(objType,objIndex,objLevel);
	if (uVar1 == 0) {
		Object_SetDependencyLevelFlag_100(objType,objIndex,objLevel);
		if (noHelpWindow == 0) {
			globals::g_HelpWindow_ObjectType = objType;
			globals::g_HelpWindow_ObjectIndex = objIndex;
			globals::g_HelpWindow_ObjectLevel = objLevel;
			if (objType == OBJECT_VEHICLE) {
				globals::g_HelpWindow_ObjectName =
						 globals::g_HelpWindowInfo_VehicleTypes_Levels_TABLE[objIndex].levels[objLevel];
			}
			else {
				if (objType == OBJECT_MINIFIGURE) {
					globals::g_HelpWindow_ObjectName =
							 globals::g_HelpWindowInfo_MiniFigureTypes_Levels_TABLE[objIndex].levels[objLevel];
				}
				else {
					if (objType == OBJECT_BUILDING) {
						globals::g_HelpWindow_ObjectName =
								 globals::g_HelpWindowInfo_BuildingTypes_Levels_TABLE[objIndex].levels[objLevel];
					}
				}
			}
			front::TextWindow_Clear(globals::g_HelpWindow_TextWindowArea_unkDrawRegion);
			FLAGS_004dd650 = FLAGS_004dd650 | 8;
			Object_Dependencies_FUN_00418850(objType,objIndex,objLevel);
			FLAGS_004dd650 = FLAGS_004dd650 | 1;
			FLOAT_004dd640 = 0.0;
			FLOAT_004dd644 = 0.0;
		}
	}
	return;
}



void __cdecl
lego::game::Object_Dependencies_FUN_00418850(ObjectType objType,int objIndex,int objLevel)
{
	int iVar1;
	int iVar2;
	BOOL BVar3;
	int *piVar4;
	uint uVar5;
	ObjectType local_204 [32];
	int local_184 [32];
	int local_104 [64];
	uint local_4;
	
	uVar5 = 0;
	UINT_004dd63c = 0;
	Object_Dependencies_FUN_0040af30(objType,objIndex,objLevel,(int)local_204);
	if (local_4 != 0) {
		piVar4 = local_184;
		do {
			BVar3 = Object_Dependencies_IsLevelFlag4(piVar4[-0x20],*piVar4,piVar4[0x20]);
			if (BVar3 != 0) {
				iVar1 = *piVar4;
				(&DAT_004dd4d4)[UINT_004dd63c] = piVar4[-0x20];
				iVar2 = piVar4[0x20];
				(&DAT_004dd54c)[UINT_004dd63c] = iVar1;
				(&DAT_004dd5c4)[UINT_004dd63c] = iVar2;
				UINT_004dd63c = UINT_004dd63c + 1;
			}
			uVar5 = uVar5 + 1;
			piVar4 = piVar4 + 1;
		} while (uVar5 < local_4);
	}
	return;
}



void __cdecl FUN_00418900(void)
{
	if (((FLAGS_004dd650 & 2) != 0) && ((FLAGS_004dd650 & 1) != 0)) {
		FUN_00425b60(0,0);
		lego::game::Game_SetMenuNextPosition((Point2F *)0x0);
		FLAGS_004dd650 = FLAGS_004dd650 & 0xfffffffe;
	}
	return;
}



void __cdecl FUN_00418930(void)
{
	uint uVar1;
	TutorialFlags TVar2;
	ImageBMP *image;
	char *pcVar3;
	int *piVar4;
	int iVar5;
	ObjectType *pOVar6;
	int iVar7;
	float10 fVar8;
	longlong lVar9;
	char *format;
	undefined8 uVar10;
	float local_14;
	Point2F local_10;
	Point2F local_8;
	
	uVar1 = FUN_00419120();
	if (uVar1 == 0) {
		FUN_00418900();
	}
	uVar1 = FUN_00419120();
	if (uVar1 == 0) {
		return;
	}
	if ((FLAGS_004dd650 & 2) == 0) {
		return;
	}
	if ((FLAGS_004dd650 & 1) == 0) {
		return;
	}
	TVar2 = lego::nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
	if ((TVar2 & 0x800) != TUTORIAL_NONE) {
		return;
	}
	FUN_00425b60(0,1);
	if ((lego::globals::g_HelpWindow_ObjectName == (char *)0x0) && (UINT_004dd63c == 0)) {
		FUN_00418900();
		return;
	}
	if (lego::globals::g_HelpWindow_BackgroundImage_bitmap != (ImageBMP *)0x0) {
		lego::image::Image_DisplayScaled
							(lego::globals::g_HelpWindow_BackgroundImage_bitmap,(Rect2F *)0x0,
							 (Point2F *)&lego::globals::g_HelpWindow_BackgroundImage_x,(Size2F *)0x0);
	}
	if ((FLAGS_004dd650 & 8) != 0) {
		if (lego::globals::g_HelpWindow_ObjectName != (char *)0x0) {
			lego::front::TextWindow_PrintF(lego::globals::g_HelpWindow_TextWindowArea_unkDrawRegion,"%s");
		}
		FLAGS_004dd650 = FLAGS_004dd650 & 0xfffffff7;
	}
	if (lego::globals::g_HelpWindow_ObjectName == (char *)0x0) {
		lVar9 = __ftol((float10)lego::globals::g_HelpWindow_TextWindowArea_y);
		local_14 = (float)lVar9;
	}
	else {
		lego::front::TextWindow_Update
							(lego::globals::g_HelpWindow_TextWindowArea_unkDrawRegion,0,0.0,(int *)&local_14);
	}
	if (UINT_004dd63c == 0) goto LAB_00418cb8;
	local_8.x = local_14;
	local_8.y = 0.0;
	iVar7 = 0;
	iVar5 = 0;
	local_10.y = (float)(ulonglong)(uint)local_14 - -10.0;
	local_10.x = lego::globals::g_HelpWindow_TextWindowArea_x;
	if (UINT_004dd63c != 0) {
		piVar4 = &DAT_004dd4d4;
		uVar1 = UINT_004dd63c;
		do {
			if (*piVar4 == 1) {
				iVar5 = iVar5 + 1;
			}
			else {
				if (*piVar4 == 4) {
					iVar7 = iVar7 + 1;
				}
			}
			piVar4 = piVar4 + 1;
			uVar1 = uVar1 - 1;
		} while (uVar1 != 0);
	}
	if (iVar5 == 0) {
		if (lego::globals::g_HelpWindow_CanBuildMessage != (char *)0x0) {
			uVar10 = CONCAT44(lego::globals::g_HelpWindow_CanBuildMessage,0x4a2d60);
			lVar9 = __ftol((float10)local_10.y);
			iVar5 = (int)lVar9;
			lVar9 = __ftol((float10)local_10.x);
			iVar7 = (int)lVar9;
			goto override_prt_418b00_2c9bc250;
		}
	}
	else {
		if (iVar7 == 0) {
			if (lego::globals::g_HelpWindow_CanTransportMessage != (char *)0x0) {
				uVar10 = CONCAT44(lego::globals::g_HelpWindow_CanTransportMessage,0x4a2d60);
				lVar9 = __ftol((float10)local_10.y);
				iVar5 = (int)lVar9;
				lVar9 = __ftol((float10)local_10.x);
				iVar7 = (int)lVar9;
override_prt_418b00_2c9bc250:
				lego::image::Font_PrintF
									(lego::globals::g_DefaultFont,iVar7,iVar5,(char *)uVar10,
									 (char *)((ulonglong)uVar10 >> 0x20));
			}
		}
		else {
			if (lego::globals::g_HelpWindow_CanBuildAndTransportMessage != (char *)0x0) {
				uVar10 = CONCAT44(lego::globals::g_HelpWindow_CanBuildAndTransportMessage,0x4a2d60);
				lVar9 = __ftol((float10)local_10.y);
				iVar5 = (int)lVar9;
				lVar9 = __ftol((float10)local_10.x);
				iVar7 = (int)lVar9;
				goto override_prt_418b00_2c9bc250;
			}
		}
	}
	uVar1 = lego::image::Font_GetHeight(lego::globals::g_DefaultFont);
	local_8.x = (float)(uVar1 + 10);
	local_8.y = 0.0;
	local_10.y = (float)(ulonglong)(uint)local_8.x + local_10.y;
	fVar8 = __floor((double)FLOAT_004dd640);
	local_10.y = (float)((float10)local_10.y - ((float10)FLOAT_004dd640 - fVar8) * (float10)45.0);
	fVar8 = __floor((double)FLOAT_004dd640);
	lVar9 = __ftol(fVar8);
	uVar1 = (uint)lVar9;
	if (uVar1 < UINT_004dd63c) {
		pOVar6 = &DAT_004dd4d4 + uVar1;
		do {
			local_10.x = lego::globals::g_HelpWindow_TextWindowArea_x;
			image = lego::front::Interface_GetObjectBuildImage(*pOVar6,pOVar6[0x1e],1);
			if (image != (ImageBMP *)0x0) {
				if (lego::globals::g_HelpWindow_TextWindowArea_y2 <= (float)image->height + local_10.y) {
					if (FLOAT_004dd644 == 0.0) {
						local_8.y = 0.0;
						local_8.x = (float)((UINT_004dd63c - uVar1) - 1);
						FLOAT_004dd644 = (float)(ulonglong)(uint)local_8.x;
					}
					if (FLOAT_004dd640 < FLOAT_004dd644) {
						local_8.x = 345.0;
						local_8.y = 350.0;
						lego::game::Game_SetMenuNextPosition(&local_8);
					}
					break;
				}
				lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,&local_10,(Size2F *)0x0);
			}
			local_10.x = local_10.x - -50.0;
			local_10.y = local_10.y - -10.0;
			pcVar3 = lego::game::Object_GetTheName(*pOVar6,pOVar6[0x1e]);
			format = "%s";
			lVar9 = __ftol((float10)local_10.y);
			iVar5 = (int)lVar9;
			lVar9 = __ftol((float10)local_10.x);
			lego::image::Font_PrintF(lego::globals::g_DefaultFont,(int)lVar9,iVar5,format,pcVar3);
			local_10.y = local_10.y - -35.0;
			uVar1 = uVar1 + 1;
			pOVar6 = pOVar6 + 1;
			if (UINT_004dd63c <= uVar1) {
				FUN_00419030();
				return;
			}
		} while( true );
	}
LAB_00418cb8:
	FUN_00419030();
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOL __cdecl
FUN_00418cd0(uint param_1,uint param_2,BOOL param_3,BOOL param_4,BOOL param_5,float elapsed)
{
	float fVar1;
	float fVar2;
	float fVar3;
	BOOL BVar4;
	float *pfVar5;
	int iVar6;
	
	if (((FLAGS_004dd650 & 2) != 0) && ((FLAGS_004dd650 & 1) != 0)) {
		FLAGS_004dd650 = FLAGS_004dd650 & 0xffffffcf;
		fVar1 = (float)(ulonglong)param_1;
		if ((345.0 <= fVar1) &&
			 ((((fVar2 = (float)(lego::globals::g_Game.NextButton)->width - -345.0,
					(ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) != 0 &&
					(fVar2 = (float)(ulonglong)param_2, 350.0 <= fVar2)) &&
				 (fVar3 = (float)(lego::globals::g_Game.NextButton)->height - -350.0,
				 (ushort)((ushort)(fVar2 < fVar3) << 8 | (ushort)(fVar2 == fVar3) << 0xe) != 0)) &&
				(lego::front::ToolTip_AddFlag4(0x21), param_5 != 0)))) {
			FUN_00418f60(3,5.0);
			lego::snd::Audio_FUN_00428730(0);
		}
		iVar6 = 0;
		pfVar5 = &lego::globals::g_HelpWindow_ContinueButton_x;
		do {
			if (((*pfVar5 <= fVar1) &&
					(fVar2 = *pfVar5 + pfVar5[2],
					(ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) != 0)) &&
				 ((fVar2 = (float)(ulonglong)param_2, pfVar5[1] <= fVar2 &&
					(fVar3 = pfVar5[1] + pfVar5[3],
					(ushort)((ushort)(fVar2 < fVar3) << 8 | (ushort)(fVar2 == fVar3) << 0xe) != 0)))) {
				FLAGS_004dd650 = FLAGS_004dd650 | 0x10;
				_DAT_004dd648 = iVar6;
				BVar4 = FUN_00418ef0(iVar6,param_3,param_4);
				if ((BVar4 != 0) && (param_5 != 0)) {
					FUN_00418f60(iVar6,elapsed);
					lego::snd::Audio_FUN_00428730(0);
				}
				if ((param_3 == 0) && (param_5 == 0)) {
					FUN_00418eb0(iVar6);
				}
				return 1;
			}
			pfVar5 = pfVar5 + 7;
			iVar6 = iVar6 + 1;
		} while (pfVar5 < &DAT_004dc93c);
		FUN_00418ef0(4,param_3,param_4);
	}
	return 0;
}



void __cdecl FUN_00418eb0(int param_1)
{
	switch(param_1) {
	case 0:
		lego::front::ToolTip_AddFlag4(8);
		return;
	case 1:
		lego::front::ToolTip_AddFlag4(9);
	}
	return;
}



BOOL __cdecl FUN_00418ef0(int param_1,int param_2,int param_3)
{
	int iVar1;
	
	iVar1 = DAT_004dd64c;
	if (param_2 == 0) {
		DAT_004dd64c = 4;
	}
	else {
		if (DAT_004dd64c == 4) {
			if (param_3 == 0) {
				DAT_004dd64c = param_1;
				FLAGS_004dd650 = FLAGS_004dd650 | 0x20;
				return (uint)(param_1 == 4);
			}
		}
		else {
			if (DAT_004dd64c == param_1) {
				FLAGS_004dd650 = FLAGS_004dd650 | 0x20;
				return (uint)(DAT_004dd64c == param_1);
			}
		}
	}
	return (uint)(iVar1 == param_1);
}



void __cdecl FUN_00418f60(undefined4 param_1,float elapsed)
{
	switch(param_1) {
	case 0:
		FUN_00418900();
		return;
	case 1:
		FUN_00419130(1,0);
		FUN_00418900();
		return;
	case 2:
		if (((ushort)((ushort)(FLOAT_004dd640 < 0.0) << 8 | (ushort)(FLOAT_004dd640 == 0.0) << 0xe) == 0
				) && (FLOAT_004dd640 = FLOAT_004dd640 - elapsed * 0.2, FLOAT_004dd640 < 0.0)) {
			FLOAT_004dd640 = 0.0;
			return;
		}
		break;
	case 3:
		if ((FLOAT_004dd640 < FLOAT_004dd644) &&
			 (FLOAT_004dd640 = FLOAT_004dd640 - elapsed * -0.2, FLOAT_004dd644 <= FLOAT_004dd640)) {
			FLOAT_004dd640 = FLOAT_004dd644;
			lego::game::Game_SetMenuNextPosition((Point2F *)0x0);
		}
	}
	return;
}



void __cdecl FUN_00419030(void)
{
	ImageBMP *image;
	float *pfVar1;
	int iVar2;
	Point2F local_8;
	
	iVar2 = 0;
	pfVar1 = &lego::globals::g_HelpWindow_ContinueButton_y;
	do {
		local_8.x = pfVar1[-1];
		local_8.y = *pfVar1;
		image = (ImageBMP *)FUN_00419080(iVar2);
		if (image != (ImageBMP *)0x0) {
			lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,&local_8,(Size2F *)0x0);
		}
		pfVar1 = pfVar1 + 7;
		iVar2 = iVar2 + 1;
	} while (pfVar1 < &DAT_004dc940);
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ImageBMP * __cdecl FUN_00419080(int param_1)
{
	if ((param_1 == 1) && (((byte)FLAGS_004dd650 & 4) == 0)) {
		return lego::globals::g_HelpWindow_CancelFutureButton_bmp_push;
	}
	if ((((byte)FLAGS_004dd650 & 0x10) != 0) && (_DAT_004dd648 == param_1)) {
		if (((byte)FLAGS_004dd650 & 0x20) != 0) {
			return (&lego::globals::g_HelpWindow_ContinueButton_bmp_push)[param_1 * 7];
		}
		return (&lego::globals::g_HelpWindow_ContinueButton_bmp)[param_1 * 7];
	}
	return (ImageBMP *)0x0;
}



BOOL __cdecl FUN_004190d0(void)
{
	uint uVar1;
	uint uVar2;
	TutorialFlags TVar3;
	uint uVar4;
	
	uVar1 = FUN_00419120();
	uVar2 = FLAGS_004dd650 & 1;
	uVar4 = FLAGS_004dd650 & 2;
	TVar3 = lego::nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
	if ((((uVar1 != 0) && (uVar4 != 0)) && (uVar2 != 0)) && (TVar3 == TUTORIAL_NONE)) {
		return 1;
	}
	return 0;
}



uint __cdecl FUN_00419120(void)
{
	return FLAGS_004dd650 & 0x40;
}



void __cdecl FUN_00419130(BOOL param_1,BOOL param_2)
{
	if (param_1 != 0) {
		param_2 = FLAGS_004dd650 & 0x40;
	}
	if (param_2 == 0) {
		FLAGS_004dd650 = FLAGS_004dd650 | 0x40;
		return;
	}
	FLAGS_004dd650 = FLAGS_004dd650 & 0xffffffbf;
	return;
}



void __cdecl lego::front::Info_InitInfo(ImageFont *font)
{
	globals::g_Infos_TABLE[0] = "Info_CrystalFound";
	globals::g_Infos_TABLE[1] = "Info_OreSeamFound";
	globals::g_Infos_TABLE[2] = "Info_RockMonster";
	globals::g_Infos_TABLE[3] = "Info_LavaRockMonster";
	globals::g_Infos_TABLE[4] = "Info_IceRockMonster";
	globals::g_Infos_TABLE[5] = "Info_UnderAttack";
	globals::g_Infos_TABLE[6] = "Info_Landslide";
	globals::g_Infos_TABLE[7] = "Info_CaveIn";
	globals::g_Infos_TABLE[8] = "Info_Constructed";
	globals::g_Infos_TABLE[9] = "Info_CavernLocated";
	globals::g_Infos_TABLE[10] = "Info_LegoManDeath";
	globals::g_Infos_TABLE[11] = "Info_VehicleDeath";
	globals::g_Infos_TABLE[12] = "Info_BuildingDeath";
	globals::g_Infos_TABLE[13] = "Info_DynamitePlaced";
	globals::g_Infos_TABLE[14] = "Info_NoPower";
	globals::g_Infos_TABLE[15] = "Info_PowerDrain";
	globals::g_Infos_TABLE[16] = "Info_AirDepleting";
	globals::g_Infos_TABLE[17] = "Info_AirLow";
	globals::g_Infos_TABLE[18] = "Info_AirOut";
	globals::g_Infos_TABLE[19] = "Info_AirRestored";
	globals::g_Infos_TABLE[20] = "Info_TrainDriver";
	globals::g_Infos_TABLE[21] = "Info_TrainDynamite";
	globals::g_Infos_TABLE[22] = "Info_TrainRepair";
	globals::g_Infos_TABLE[23] = "Info_TrainPilot";
	globals::g_Infos_TABLE[24] = "Info_TrainSailor";
	globals::g_Infos_TABLE[25] = "Info_TrainScanner";
	globals::g_Infos_TABLE[26] = "Info_OreCollected";
	globals::g_Infos_TABLE[27] = "Info_WallDug";
	globals::g_Infos_TABLE[28] = "Info_WallReinforced";
	globals::g_Infos_TABLE[29] = "Info_CrystalPower";
	globals::g_Infos_TABLE[30] = "Info_LavaErode";
	globals::g_Infos_TABLE[31] = "Info_SlugEmerge";
	globals::g_Infos_TABLE[32] = "Info_PathCompleted";
	globals::g_Infos_TABLE[33] = "Info_FoundMinifigure";
	globals::g_Infos_TABLE[34] = "Info_CanUpgradeMinifigure";
	globals::g_Infos_TABLE[35] = "Info_CanTrainMinifigure";
	globals::g_Infos_TABLE[36] = "Info_CrystalSeamFound";
	globals::g_Infos_TABLE[37] = "Info_GenericSeamFound";
	globals::g_Infos_TABLE[38] = "Info_GenericDeath";
	globals::g_Infos_TABLE[39] = "Info_GenericMonster";
	globals::g_Info_Font = font;
	globals::g_InfoMessageFlags = globals::g_InfoMessageFlags | (INFOMSG_UNK_8|INFOMSG_AUTOGAMESPEED);
	return;
}



BOOL __cdecl lego::front::Info_GetInfoType(char *infoName,InfoType *out_infoType)
{
	int iVar1;
	char **ppcVar2;
	InfoType IVar3;
	
	IVar3 = INFO_CRYSTALFOUND;
	ppcVar2 = globals::g_Infos_TABLE;
	do {
		iVar1 = std::_stricmp(*ppcVar2,infoName);
		if (iVar1 == 0) {
			*out_infoType = IVar3;
			return 1;
		}
		ppcVar2 = (char **)((int)ppcVar2 + 4);
		IVar3 = IVar3 + INFO_ORESEAMFOUND;
	} while (ppcVar2 < globals::g_InfoDatas_TABLE);
	return 0;
}



undefined4 __cdecl FUN_00419350(int param_1)
{
	return lego::globals::g_InfoDatas_TABLE[param_1].field_4;
}



void __cdecl lego::main::Main_LoadMessageTabs_InfoOverFlow(char *filename)
{
	globals::g_MessageTabs_InfoOverFlow_bmp = image::Image_LoadBMPScaled(filename,0,0);
	image::Image_SetPenZeroTrans(globals::g_MessageTabs_InfoOverFlow_bmp);
	return;
}



void __cdecl lego::front::Info_SetAutoGameSpeed(BOOL state)
{
	if (state != 0) {
		globals::g_InfoMessageFlags = globals::g_InfoMessageFlags | INFOMSG_AUTOGAMESPEED;
		return;
	}
	globals::g_InfoMessageFlags = globals::g_InfoMessageFlags & ~INFOMSG_AUTOGAMESPEED;
	return;
}



void __cdecl FUN_004193a0(int param_1,int param_2)
{
	if (param_2 != 0) {
		lego::globals::g_InfoDatas_TABLE[param_1].flags =
				 lego::globals::g_InfoDatas_TABLE[param_1].flags | 0x10000;
		return;
	}
	lego::globals::g_InfoDatas_TABLE[param_1].flags =
			 lego::globals::g_InfoDatas_TABLE[param_1].flags & 0xfffeffff;
	return;
}



void __cdecl lego::front::Info_SetText(InfoType infoType,char *text)
{
	if (globals::g_InfoDatas_TABLE[infoType].text != (char *)0x0) {
		std::free(globals::g_InfoDatas_TABLE[infoType].text);
	}
	Info_SetText_internal(text,globals::g_InfoDatas_TABLE + infoType);
	return;
}



void __cdecl FUN_00419420(int param_1,int param_2)
{
	if (param_2 != 0) {
		lego::globals::g_InfoDatas_TABLE[param_1].flags =
				 lego::globals::g_InfoDatas_TABLE[param_1].flags | 0x20000;
		return;
	}
	lego::globals::g_InfoDatas_TABLE[param_1].flags =
			 lego::globals::g_InfoDatas_TABLE[param_1].flags & 0xfffdffff;
	return;
}



void __cdecl lego::front::Info_SetText_internal(char *text,InfoMessageData *infoData)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	BOOL BVar4;
	uint uVar5;
	int iVar6;
	int iVar7;
	char *pcVar8;
	char *pcVar9;
	uint local_30;
	InfoType local_2c;
	char acStack40 [8];
	char local_20 [32];
	
	pcVar9 = text;
	uVar5 = 0xffffffff;
	local_30 = 0;
	pcVar3 = text;
	do {
		if (uVar5 == 0) break;
		uVar5 = uVar5 - 1;
		cVar2 = *pcVar3;
		pcVar3 = pcVar3 + 1;
	} while (cVar2 != '\0');
	pcVar3 = (char *)std::malloc(~uVar5 + 0xb);
	infoData->text = pcVar3;
	cVar2 = *pcVar9;
	while (cVar2 != '\0') {
		cVar2 = *pcVar9;
		if (cVar2 == '_') {
			*pcVar3 = ' ';
		}
		else {
			if (cVar2 == '$') {
				pcVar8 = pcVar9 + 1;
				iVar6 = 0;
				iVar7 = 0;
				cVar2 = pcVar9[1];
				pcVar9 = pcVar8;
				while (cVar2 != '$') {
					local_20[iVar6] = cVar2;
					pcVar1 = pcVar8 + 1;
					iVar6 = iVar6 + 1;
					pcVar8 = pcVar8 + 1;
					pcVar9 = pcVar9 + 1;
					cVar2 = *pcVar1;
				}
				local_20[iVar6] = '\0';
				BVar4 = Pointer_GetType(local_20,(PointerType *)&text);
				if (BVar4 == 0) {
					BVar4 = Info_GetInfoType(local_20,&local_2c);
					if (BVar4 != 0) {
						iVar7 = FUN_00419350(local_2c);
					}
				}
				else {
					iVar7 = Pointers_GetImage((PointerType)text);
				}
				if (iVar7 != 0) {
					*pcVar3 = '%';
					pcVar3 = pcVar3 + 1;
					acStack40[local_30] = (char)iVar7;
					local_30 = local_30 + 1;
					*pcVar3 = 'b';
				}
			}
			else {
				if ((cVar2 == '\\') && (pcVar9[1] == 'n')) {
					*pcVar3 = '\n';
					pcVar9 = pcVar9 + 1;
				}
				else {
					*pcVar3 = cVar2;
				}
			}
		}
		pcVar8 = pcVar9 + 1;
		pcVar3 = pcVar3 + 1;
		pcVar9 = pcVar9 + 1;
		cVar2 = *pcVar8;
	}
	*pcVar3 = '\0';
	pcVar3 = pcVar3 + 1;
	uVar5 = 0;
	*pcVar3 = (char)local_30;
	do {
		pcVar3 = pcVar3 + 1;
		if (uVar5 < local_30) {
			*pcVar3 = acStack40[uVar5];
		}
		else {
			*pcVar3 = '\0';
		}
		uVar5 = uVar5 + 1;
	} while (uVar5 < 5);
	return;
}



void __cdecl lego::front::Info_FUN_00419580(int param_1,char *filename)
{
	ImageBMP *image;
	
	image = lego::image::Image_LoadBMPScaled(filename,0,0);
	globals::g_InfoDatas_TABLE[param_1].field_4 = image;
	lego::image::Image_SetPenZeroTrans(image);
	return;
}



void __cdecl lego::front::Info_SetSFXType(InfoType infoType,SFXType sfxType)
{
	globals::g_InfoDatas_TABLE[infoType].sfxType = sfxType;
	return;
}



BOOL __cdecl
lego::front::Info_DoCallbacks_FUN_004195d0(int param_1,undefined *callback,undefined4 param_3)
{
	int iVar1;
	InfoType IVar2;
	
	IVar2 = globals::g_InfoInstances_TABLE[param_1].infoType;
	if (IVar2 == INFO_CRYSTALFOUND) {
		return 0;
	}
	do {
		iVar1 = (*(code *)callback)(IVar2,param_3);
		if (iVar1 != 0) {
			return 1;
		}
		IVar2 = *(InfoType *)(IVar2 + INFO_AIRDEPLETING);
	} while (IVar2 != INFO_CRYSTALFOUND);
	return 0;
}



void __cdecl FUN_00419620(int param_1,int param_2)
{
	InfoType IVar1;
	int iVar2;
	int iVar3;
	
	IVar1 = lego::globals::g_InfoInstances_TABLE[param_1].infoType;
	if (IVar1 == INFO_CRYSTALFOUND) {
		lego::globals::g_InfoInstances_TABLE[param_1].infoType = param_2;
		*(undefined4 *)(param_2 + 0x10) = 0;
		*(int *)&lego::globals::g_InfoInstances_TABLE[param_1].field_0x4 =
				 *(int *)&lego::globals::g_InfoInstances_TABLE[param_1].field_0x4 + 1;
		return;
	}
	iVar3 = 1;
	iVar2 = *(int *)(IVar1 + INFO_AIRDEPLETING);
	while (iVar2 != 0) {
		iVar3 = iVar3 + 1;
		if (iVar3 == 9) {
			FUN_004196e0(param_1,0);
		}
		IVar1 = *(InfoType *)(IVar1 + INFO_AIRDEPLETING);
		iVar2 = *(int *)(IVar1 + INFO_AIRDEPLETING);
	}
	*(int *)(IVar1 + INFO_AIRDEPLETING) = param_2;
	*(undefined4 *)(param_2 + 0x10) = 0;
	*(int *)&lego::globals::g_InfoInstances_TABLE[param_1].field_0x4 =
			 *(int *)&lego::globals::g_InfoInstances_TABLE[param_1].field_0x4 + 1;
	return;
}



int __cdecl FUN_004196b0(int param_1,int param_2)
{
	InfoType IVar1;
	
	IVar1 = lego::globals::g_InfoInstances_TABLE[param_1].infoType;
	if ((param_2 < 0) || (*(int *)&lego::globals::g_InfoInstances_TABLE[param_1].field_0x4 <= param_2)
		 ) {
		IVar1 = INFO_CRYSTALFOUND;
	}
	else {
		if (0 < param_2) {
			do {
				IVar1 = *(InfoType *)(IVar1 + INFO_AIRDEPLETING);
				param_2 = param_2 + -1;
			} while (param_2 != 0);
			return IVar1;
		}
	}
	return IVar1;
}



int __cdecl FUN_004196e0(int param_1,int param_2)
{
	int iVar1;
	int iVar2;
	
	iVar1 = FUN_004196b0(param_1,param_2);
	if (iVar1 == 0) {
		return 0;
	}
	iVar2 = FUN_004196b0(param_1,param_2 + -1);
	if (param_2 == 0) {
		lego::globals::g_InfoInstances_TABLE[param_1].infoType = *(InfoType *)(iVar1 + 0x10);
	}
	else {
		*(undefined4 *)(iVar2 + 0x10) = *(undefined4 *)(iVar1 + 0x10);
	}
	*(int *)&lego::globals::g_InfoInstances_TABLE[param_1].field_0x4 =
			 *(int *)&lego::globals::g_InfoInstances_TABLE[param_1].field_0x4 + -1;
	return iVar1;
}



BOOL __cdecl FUN_00419740(int param_1,int *param_2)
{
	if (*(int *)(param_1 + 8) == *param_2) {
		return 1;
	}
	param_2[1] = param_2[1] + 1;
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_00419760(LiveObject *liveObj)
{
	int iVar1;
	uint uVar2;
	uint uVar3;
	int *piVar4;
	LiveObject *local_8;
	int local_4;
	
	local_8 = liveObj;
	uVar2 = 0;
	if (globals::g_InfoInstances_COUNT != 0) {
		piVar4 = (int *)&globals::g_InfoInstances_TABLE[0].field_0x4;
		do {
			local_4 = 0;
			iVar1 = front::Info_DoCallbacks_FUN_004195d0(uVar2,FUN_00419740,&local_8);
			while (iVar1 != 0) {
				FUN_004196e0(uVar2,local_4);
				local_4 = 0;
				iVar1 = front::Info_DoCallbacks_FUN_004195d0(uVar2,FUN_00419740,&local_8);
			}
			uVar3 = uVar2;
			if (*piVar4 == 0) {
				uVar3 = uVar2 - 1;
				piVar4 = piVar4 + -5;
				FUN_00419db0(uVar2);
			}
			uVar2 = uVar3 + 1;
			piVar4 = piVar4 + 5;
		} while (uVar2 < (uint)globals::g_InfoInstances_COUNT);
	}
	return;
}



BOOL __cdecl FUN_004197f0(int *param_1,int **param_2)
{
	if ((*param_1 == **param_2) && (param_1[1] == (*param_2)[1])) {
		return 1;
	}
	param_2[1] = (int *)((int)param_2[1] + 1);
	return 0;
}



void __cdecl FUN_00419820(undefined4 param_1)
{
	int iVar1;
	int *piVar2;
	uint uVar3;
	uint uVar4;
	int *piVar5;
	undefined4 local_8;
	int local_4;
	
	local_8 = param_1;
	uVar3 = 0;
	if (lego::globals::g_InfoInstances_COUNT != 0) {
		piVar2 = (int *)&lego::globals::g_InfoInstances_TABLE[0].field_0x4;
		piVar5 = (int *)&lego::globals::g_InfoInstances_TABLE[0].field_0x8;
		do {
			uVar4 = uVar3;
			if ((*piVar5 == 6) || (*piVar5 == 7)) {
				local_4 = 0;
				iVar1 = lego::front::Info_DoCallbacks_FUN_004195d0(uVar3,FUN_004197f0,&local_8);
				while (iVar1 != 0) {
					FUN_004196e0(uVar3,local_4);
					local_4 = 0;
					iVar1 = lego::front::Info_DoCallbacks_FUN_004195d0(uVar3,FUN_004197f0,&local_8);
				}
				if (*piVar2 == 0) {
					uVar4 = uVar3 - 1;
					piVar5 = piVar5 + -5;
					piVar2 = piVar2 + -5;
					FUN_00419db0(uVar3);
				}
			}
			uVar3 = uVar4 + 1;
			piVar5 = piVar5 + 5;
			piVar2 = piVar2 + 5;
		} while (uVar3 < (uint)lego::globals::g_InfoInstances_COUNT);
	}
	return;
}



BOOL __cdecl lego::front::Info_Callback_FUN_004198d0(int *param_1,int *param_2)
{
	int iVar1;
	int *piVar2;
	
	iVar1 = *param_2;
	if ((((iVar1 != 0) || (param_2[1] != 0)) && ((iVar1 == 0 || (param_1[2] != iVar1)))) &&
		 (((piVar2 = (int *)param_2[1], piVar2 == (int *)0x0 || (*param_1 != *piVar2)) ||
			(param_1[1] != piVar2[1])))) {
		return 0;
	}
	return 1;
}



BOOL __cdecl lego::front::Info_FUN_00419920(InfoType infoType,undefined4 param_2,undefined4 param_3)
{
	BOOL BVar1;
	uint uVar2;
	InfoType *pIVar3;
	undefined4 local_8;
	undefined4 local_4;
	
	if ((((infoType != INFO_LEGOMANDEATH) && (infoType != INFO_BUILDINGDEATH)) &&
			(infoType != INFO_VEHICLEDEATH)) && (infoType != INFO_GENERICDEATH)) {
		local_4 = param_3;
		uVar2 = 0;
		local_8 = param_2;
		if (globals::g_InfoInstances_COUNT != 0) {
			pIVar3 = (InfoType *)&globals::g_InfoInstances_TABLE[0].field_0x8;
			do {
				if (infoType == *pIVar3) {
					BVar1 = Info_DoCallbacks_FUN_004195d0(uVar2,Info_Callback_FUN_004198d0,&local_8);
					if (BVar1 != 0) {
						return 1;
					}
				}
				uVar2 = uVar2 + 1;
				pIVar3 = pIVar3 + 5;
			} while (uVar2 < (uint)globals::g_InfoInstances_COUNT);
			return 0;
		}
	}
	return 0;
}



undefined4 __cdecl
lego::front::Info_CreateInstance(undefined4 *param_1,undefined4 param_2,char *param_3)
{
	undefined4 *puVar1;
	
	puVar1 = (undefined4 *)std::malloc(0x14);
	if (puVar1 == (undefined4 *)0x0) {
		return (undefined4 *)0x0;
	}
	if (param_1 == (undefined4 *)0x0) {
		puVar1[1] = 0xffffffff;
		*puVar1 = 0xffffffff;
	}
	else {
		*puVar1 = *param_1;
		puVar1[1] = param_1[1];
	}
	puVar1[2] = param_2;
	if (param_3 != (char *)0x0) {
		Info_SetText_internal(param_3,(InfoMessageData *)(puVar1 + 3));
		return puVar1;
	}
	puVar1[3] = 0;
	return puVar1;
}



void __cdecl lego::front::Info_SetFlag4(BOOL state)
{
	if (state != 0) {
		globals::g_InfoMessageFlags = globals::g_InfoMessageFlags | INFOMSG_UNK_4;
		return;
	}
	globals::g_InfoMessageFlags = globals::g_InfoMessageFlags & ~INFOMSG_UNK_4;
	return;
}



BOOL __cdecl lego::front::Info_HasText(InfoType infoType)
{
	return (uint)(globals::g_InfoDatas_TABLE[infoType].text != (char *)0x0);
}



int __cdecl lego::front::Info_FUN_00419a50(int param_1)
{
	int iVar1;
	int *piVar2;
	
	iVar1 = 0;
	if (0 < globals::g_InfoInstances_COUNT) {
		piVar2 = (int *)&globals::g_InfoInstances_TABLE[0].field_0x8;
		do {
			if (*piVar2 == param_1) {
				return iVar1;
			}
			iVar1 = iVar1 + 1;
			piVar2 = piVar2 + 5;
		} while (iVar1 < globals::g_InfoInstances_COUNT);
	}
	return -1;
}



float10 __cdecl FUN_00419a80(void)
{
	int iVar1;
	int *piVar2;
	int iVar3;
	float10 fVar4;
	
	fVar4 = (float10)333.0;
	if (lego::globals::g_InfoInstances_COUNT != 0) {
		piVar2 = (int *)&lego::globals::g_InfoInstances_TABLE[0].field_0x8;
		iVar3 = lego::globals::g_InfoInstances_COUNT;
		do {
			iVar1 = *piVar2;
			piVar2 = piVar2 + 5;
			iVar3 = iVar3 + -1;
			fVar4 = fVar4 - (float10)*(int *)(lego::globals::g_InfoDatas_TABLE[iVar1].field_4 + 8);
		} while (iVar3 != 0);
	}
	return fVar4;
}



void __cdecl
lego::front::Info_FUN_00419ab0(InfoType infoType,char *param_2,LiveObject *param_3,Point2I *param_4)
{
	InfoMessageInstance *pIVar1;
	int iVar2;
	TutorialFlags TVar3;
	BOOL BVar4;
	int iVar5;
	int iVar6;
	ProgrammerMode PVar7;
	float10 fVar8;
	
	if (((byte)globals::g_InfoMessageFlags & INFOMSG_UNK_4) != 0) {
		TVar3 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
		if ((TVar3 & TUTORIAL_UNK_100) == TUTORIAL_NONE) {
			if (((((byte)globals::g_InfoMessageFlags & INFOMSG_UNK_8) != 0) &&
					((globals::g_InfoDatas_TABLE[infoType].flags & 0x20000) != 0)) &&
				 ((ushort)((ushort)(globals::g_InfoDatas_TABLE[infoType].float_c < 0.0) << 8 |
									(ushort)(globals::g_InfoDatas_TABLE[infoType].float_c == 0.0) << 0xe) != 0)) {
				globals::g_InfoDatas_TABLE[infoType].float_c = 25.0;
				if (((infoType == INFO_LEGOMANDEATH) || (infoType == INFO_VEHICLEDEATH)) ||
					 (infoType == INFO_BUILDINGDEATH)) {
					globals::g_InfoDatas_TABLE[10].float_c = 25.0;
					globals::g_InfoDatas_TABLE[11].float_c = 25.0;
					globals::g_InfoDatas_TABLE[12].float_c = 25.0;
					globals::g_InfoDatas_TABLE[38].float_c = 25.0;
				}
				snd::Audio_FUN_004651b0(globals::g_InfoDatas_TABLE[infoType].sfxType,(int *)0x0);
			}
			BVar4 = Info_FUN_00419920(infoType,param_3,param_4);
			if (BVar4 == 0) {
				BVar4 = Info_HasText(infoType);
				if (BVar4 != 0) {
					iVar6 = globals::g_InfoDatas_TABLE[infoType].field_4;
					if (((((byte)globals::g_InfoMessageFlags & INFOMSG_UNK_8) != 0) &&
							((globals::g_InfoDatas_TABLE[infoType].flags & 0x20000) == 0)) &&
						 ((ushort)((ushort)(globals::g_InfoDatas_TABLE[infoType].float_c < 0.0) << 8 |
											(ushort)(globals::g_InfoDatas_TABLE[infoType].float_c == 0.0) << 0xe) != 0)) {
						globals::g_InfoDatas_TABLE[infoType].float_c = 25.0;
						if ((((infoType == INFO_LEGOMANDEATH) || (infoType == INFO_VEHICLEDEATH)) ||
								(infoType == INFO_BUILDINGDEATH)) || (infoType == INFO_GENERICDEATH)) {
							globals::g_InfoDatas_TABLE[10].float_c = 25.0;
							globals::g_InfoDatas_TABLE[11].float_c = 25.0;
							globals::g_InfoDatas_TABLE[12].float_c = 25.0;
							globals::g_InfoDatas_TABLE[38].float_c = 25.0;
						}
						snd::Audio_FUN_004651b0(globals::g_InfoDatas_TABLE[infoType].sfxType,(int *)0x0);
					}
					if (globals::g_InfoInstances_COUNT != 0x28) {
						iVar5 = Info_FUN_00419a50(infoType);
						iVar2 = globals::g_InfoInstances_COUNT;
						if (iVar5 == -1) {
							pIVar1 = globals::g_InfoInstances_TABLE + globals::g_InfoInstances_COUNT;
							globals::g_InfoInstances_COUNT = globals::g_InfoInstances_COUNT + 1;
							pIVar1->float_c = -(float)*(int *)(iVar6 + 4);
							fVar8 = FUN_00419a80();
							*(float *)&globals::g_InfoInstances_TABLE[iVar2].field_0x10 = (float)fVar8;
							iVar5 = iVar2;
						}
						*(InfoType *)&globals::g_InfoInstances_TABLE[iVar5].field_0x8 = infoType;
						iVar6 = Info_CreateInstance((undefined4 *)param_4,param_3,param_2);
						FUN_00419620(iVar5,iVar6);
						PVar7 = main::GetProgrammerMode();
						if (((PVar7 < 5) && (((byte)globals::g_InfoMessageFlags & INFOMSG_AUTOGAMESPEED) != 0))
							 && ((globals::g_InfoDatas_TABLE[infoType].flags & 0x10000) != 0)) {
							fVar8 = game::Game_GetGameSpeed();
							if ((ushort)((ushort)(fVar8 < (float10)1.0) << 8 |
													(ushort)(fVar8 == (float10)1.0) << 0xe) == 0) {
								game::Game_SetGameSpeed(1.0);
							}
						}
					}
				}
			}
		}
	}
	return;
}



void __cdecl FUN_00419cd0(void)
{
	if ((lego::globals::g_InfoInstances_COUNT != 0) &&
		 (lego::globals::g_InfoInstances_TABLE[0]._4_4_ != 0)) {
		if ((*(LiveObject **)(lego::globals::g_InfoInstances_TABLE[0].infoType + INFO_CONSTRUCTED) !=
				 (LiveObject *)0x0) ||
			 ((0 < *(int *)lego::globals::g_InfoInstances_TABLE[0].infoType &&
				(0 < *(int *)(lego::globals::g_InfoInstances_TABLE[0].infoType + INFO_ICEROCKMONSTER))))) {
			lego::game::LiveObject_FUN_0042dd70
								(*(LiveObject **)
									(lego::globals::g_InfoInstances_TABLE[0].infoType + INFO_CONSTRUCTED),
								 (uint *)lego::globals::g_InfoInstances_TABLE[0].infoType,0);
		}
	}
	return;
}



void __cdecl FUN_00419d10(uint param_1)
{
	InfoMessageInstance *pIVar1;
	int iVar2;
	InfoMessageInstance *pIVar3;
	InfoType *pIVar4;
	InfoMessageInstance *pIVar5;
	InfoType local_14 [5];
	
	if (param_1 < (uint)lego::globals::g_InfoInstances_COUNT) {
		if (param_1 != 0) {
			pIVar3 = lego::globals::g_InfoInstances_TABLE + param_1;
			pIVar4 = local_14;
			for (iVar2 = 5; pIVar1 = lego::globals::g_InfoInstances_TABLE + param_1, iVar2 != 0;
					iVar2 = iVar2 + -1) {
				*pIVar4 = pIVar3->infoType;
				pIVar3 = (InfoMessageInstance *)&pIVar3->field_0x4;
				pIVar4 = pIVar4 + 1;
			}
			do {
				param_1 = param_1 - 1;
				pIVar3 = pIVar1 + -1;
				pIVar5 = pIVar1;
				for (iVar2 = 5; iVar2 != 0; iVar2 = iVar2 + -1) {
					pIVar5->infoType = pIVar3->infoType;
					pIVar3 = (InfoMessageInstance *)&pIVar3->field_0x4;
					pIVar5 = (InfoMessageInstance *)&pIVar5->field_0x4;
				}
				pIVar1 = pIVar1 + -1;
			} while (param_1 != 0);
			pIVar4 = local_14;
			pIVar3 = lego::globals::g_InfoInstances_TABLE;
			for (iVar2 = 5; iVar2 != 0; iVar2 = iVar2 + -1) {
				pIVar3->infoType = *pIVar4;
				pIVar4 = pIVar4 + 1;
				pIVar3 = (InfoMessageInstance *)&pIVar3->field_0x4;
			}
		}
		lego::globals::g_InfoMessageFlags =
				 lego::globals::g_InfoMessageFlags | (INFOMSG_UNK_1|INFOMSG_UNK_2);
	}
	return;
}



void __cdecl FUN_00419d90(void)
{
	if (lego::globals::g_InfoInstances_COUNT != 0) {
		FUN_00419db0(0);
	}
	return;
}



void __cdecl FUN_00419db0(uint param_1)
{
	int iVar1;
	InfoMessageInstance *pIVar2;
	uint uVar3;
	InfoMessageInstance *pIVar4;
	InfoMessageInstance *pIVar5;
	
	if (param_1 < (uint)lego::globals::g_InfoInstances_COUNT) {
		iVar1 = FUN_004196e0(param_1,0);
		if ((iVar1 != 0) && (*(void **)(iVar1 + 0xc) != (void *)0x0)) {
			std::free(*(void **)(iVar1 + 0xc));
		}
		if (*(int *)&lego::globals::g_InfoInstances_TABLE[param_1].field_0x4 == 0) {
			if (param_1 < (uint)lego::globals::g_InfoInstances_COUNT) {
				pIVar2 = lego::globals::g_InfoInstances_TABLE + param_1;
				uVar3 = param_1;
				do {
					uVar3 = uVar3 + 1;
					pIVar4 = pIVar2 + 1;
					pIVar5 = pIVar2;
					for (iVar1 = 5; iVar1 != 0; iVar1 = iVar1 + -1) {
						pIVar5->infoType = pIVar4->infoType;
						pIVar4 = (InfoMessageInstance *)&pIVar4->field_0x4;
						pIVar5 = (InfoMessageInstance *)&pIVar5->field_0x4;
					}
					pIVar2 = pIVar2 + 1;
				} while (uVar3 < (uint)lego::globals::g_InfoInstances_COUNT);
			}
			lego::globals::g_InfoInstances_COUNT = lego::globals::g_InfoInstances_COUNT + -1;
		}
		if (param_1 == 0) {
			lego::globals::g_InfoMessageFlags = lego::globals::g_InfoMessageFlags & ~INFOMSG_UNK_1;
		}
	}
	return;
}



void __cdecl FUN_00419e40(void)
{
	if (lego::globals::g_InfoInstances_COUNT != 0) {
		do {
			FUN_00419db0(0);
		} while (lego::globals::g_InfoInstances_COUNT != 0);
	}
	return;
}



void __cdecl FUN_00419e60(float param_1)
{
	ImageBMP *image;
	int y;
	int x;
	ImageFont *font;
	uint uVar1;
	float *pfVar2;
	longlong lVar3;
	char *msg;
	float fVar4;
	Point2F local_8;
	
	local_8.y = 333.0;
	uVar1 = 0;
	if (lego::globals::g_InfoInstances_COUNT == 0) {
		return;
	}
	pfVar2 = (float *)&lego::globals::g_InfoInstances_TABLE[0].field_0x10;
	while( true ) {
		image = (ImageBMP *)lego::globals::g_InfoDatas_TABLE[(int)pfVar2[-2]].field_4;
		if ((ushort)((ushort)(local_8.y < *pfVar2) << 8 | (ushort)(local_8.y == *pfVar2) << 0xe) == 0) {
			*pfVar2 = *pfVar2 - param_1 * -8.0;
		}
		if (local_8.y < *pfVar2) {
			*pfVar2 = local_8.y;
		}
		if (pfVar2[-1] < 0.0) {
			pfVar2[-1] = pfVar2[-1] - param_1 * -3.0;
		}
		if ((ushort)((ushort)(pfVar2[-1] < 0.0) << 8 | (ushort)(pfVar2[-1] == 0.0) << 0xe) == 0) {
			pfVar2[-1] = 0.0;
		}
		local_8.y = *pfVar2;
		local_8.x = pfVar2[-1];
		lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,&local_8,(Size2F *)0x0);
		if (local_8.y < 0.0) break;
		fVar4 = pfVar2[-3];
		msg = "%i";
		lVar3 = __ftol((float10)local_8.y);
		y = (int)lVar3 + 10;
		lVar3 = __ftol((float10)local_8.x);
		x = (int)lVar3 + 2;
		font = (ImageFont *)lego::unk::Lego_GetDat_004ddd58();
		lego::image::Font_PrintF(font,x,y,msg,fVar4);
		uVar1 = uVar1 + 1;
		pfVar2 = pfVar2 + 5;
		local_8.y = local_8.y - (float)image->height;
		if ((uint)lego::globals::g_InfoInstances_COUNT <= uVar1) {
			return;
		}
	}
	local_8.y = 0.0;
	lego::image::Image_DisplayScaled
						(lego::globals::g_MessageTabs_InfoOverFlow_bmp,(Rect2F *)0x0,&local_8,(Size2F *)0x0);
	return;
}



void __cdecl FUN_00419fb0(float param_1)
{
	char cVar1;
	uint uVar2;
	char *format;
	char *pcVar3;
	
	if (((lego::globals::g_InfoMessageFlags & INFOMSG_UNK_1) == INFOMSG_NONE) ||
		 (lego::globals::g_InfoInstances_COUNT == 0)) {
		if (((byte)PanelData_ARRAY_00501110[7].flags & 4) == 0) {
			FUN_0045adc0(7);
		}
	}
	else {
		if (((byte)PanelData_ARRAY_00501110[7].flags & 2) == 0) {
			FUN_0045adc0(7);
		}
		if ((lego::globals::g_InfoMessageFlags & INFOMSG_UNK_2) != INFOMSG_NONE) {
			lego::image::Struct830_FUN_0045a8e0(PTR_005017d8);
			format = *(char **)(lego::globals::g_InfoInstances_TABLE[0].infoType + INFO_BUILDINGDEATH);
			if (format == (char *)0x0) {
				format = lego::globals::g_InfoDatas_TABLE[lego::globals::g_InfoInstances_TABLE[0]._8_4_].
								 text;
			}
			uVar2 = 0xffffffff;
			pcVar3 = format;
			do {
				if (uVar2 == 0) break;
				uVar2 = uVar2 - 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar3 + 1;
			} while (cVar1 != '\0');
			uVar2 = ~uVar2;
			if (format[uVar2] == '\0') {
				FUN_0045a850((TextWindow *)PTR_005017d8,format);
			}
			else {
				FUN_0045a850((TextWindow *)PTR_005017d8,format,(uint)(byte)format[uVar2 + 1],
										 (uint)(byte)format[uVar2 + 2],(uint)(byte)format[uVar2 + 3],
										 (uint)(byte)format[uVar2 + 4],(uint)(byte)format[uVar2 + 5]);
			}
			FUN_0045a870((int **)PTR_005017d8,INT_004ddd44,param_1);
			FUN_0041a180();
			lego::globals::g_InfoMessageFlags = lego::globals::g_InfoMessageFlags & ~INFOMSG_UNK_2;
		}
	}
	FUN_0045a870((int **)PTR_005017d8,INT_004ddd44,param_1);
	return;
}



undefined4 __cdecl FUN_0041a0d0(int param_1,int param_2,int param_3)
{
	int iVar1;
	uint uVar2;
	float *pfVar3;
	longlong lVar4;
	
	uVar2 = 0;
	if (lego::globals::g_InfoInstances_COUNT == 0) {
		return 0;
	}
	pfVar3 = (float *)&lego::globals::g_InfoInstances_TABLE[0].field_0x10;
	do {
		iVar1 = *(int *)(lego::globals::g_InfoDatas_TABLE[(int)pfVar3[-2]].field_4 + 8);
		if ((-1 < param_1) &&
			 (param_1 <= *(int *)(lego::globals::g_InfoDatas_TABLE[(int)pfVar3[-2]].field_4 + 4))) {
			lVar4 = __ftol((float10)*pfVar3);
			if (((int)lVar4 <= param_2) && (param_2 <= iVar1 + (int)lVar4)) {
				if (param_3 != 0) {
					if (((lego::globals::g_InfoMessageFlags & INFOMSG_UNK_1) != INFOMSG_NONE) && (uVar2 == 0))
					{
						FUN_0045adc0(7);
						lego::globals::g_InfoMessageFlags = lego::globals::g_InfoMessageFlags & ~INFOMSG_UNK_1;
						return 1;
					}
					FUN_00419d10(uVar2);
				}
				return 1;
			}
		}
		uVar2 = uVar2 + 1;
		pfVar3 = pfVar3 + 5;
		if ((uint)lego::globals::g_InfoInstances_COUNT <= uVar2) {
			return 0;
		}
	} while( true );
}



void __cdecl FUN_0041a180(void)
{
	int local_8;
	int local_4;
	
	lego::image::Struct830_FUN_0045a8f0(PTR_005017d8,&local_8,&local_4);
	local_8 = local_8 - local_4;
	if (local_8 < 0) {
		local_8 = 0;
	}
	FUN_00464190(0,local_8,0);
	FUN_0041a1c0();
	return;
}



void __cdecl FUN_0041a1c0(void)
{
	int local_8;
	int local_4;
	
	lego::draw::Draw_UnkFuncOfInterestTable__00464160(0,&local_8,&local_4);
	INT_004ddd44 = local_8 - local_4;
	return;
}



void __cdecl FUN_0041a1f0(float param_1)
{
	float *pfVar1;
	
	pfVar1 = &lego::globals::g_InfoDatas_TABLE[0].float_c;
	do {
		if ((ushort)((ushort)(*pfVar1 < 0.0) << 8 | (ushort)(*pfVar1 == 0.0) << 0xe) == 0) {
			*pfVar1 = *pfVar1 - param_1;
		}
		pfVar1 = pfVar1 + 5;
	} while (pfVar1 < &lego::globals::g_InfoInstances_TABLE[0].float_c);
	return;
}



undefined4 __cdecl lego::unk::Lego_GetDat_004ddd58(void)
{
	return DAT_004ddd58;
}



void __cdecl lego::main::Main_InitInterfaceMenuItems(uint param_1,uint param_2,ImageFont *font)
{
	front::ToolTip_SetFlag10(4,1);
	FLOAT_004decd0 = (float)(ulonglong)param_1;
	globals::g_InterfaceMenuItemNames_TABLE[0] = "Interface_MenuItem_BackToDefault";
	FLOAT_004decd4 = (float)(ulonglong)param_2;
	DAT_004ddd58 = font;
	globals::g_InterfaceMenuItemNames_TABLE[1] = "Interface_MenuItem_TeleportMan";
	globals::g_InterfaceMenuItemNames_TABLE[2] = "Interface_MenuItem_BuildBuilding";
	globals::g_InterfaceMenuItemNames_TABLE[3] = "Interface_MenuItem_BuildSmallVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[4] = "Interface_MenuItem_BuildLargeVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[5] = "Interface_MenuItem_LayPath";
	globals::g_InterfaceMenuItemNames_TABLE[7] = "Interface_MenuItem_RepairLava";
	globals::g_InterfaceMenuItemNames_TABLE[8] = "Interface_MenuItem_GeologistTest";
	globals::g_InterfaceMenuItemNames_TABLE[9] = "Interface_MenuItem_ClearRubble";
	globals::g_InterfaceMenuItemNames_TABLE[10] = "Interface_MenuItem_Dam";
	globals::g_InterfaceMenuItemNames_TABLE[17] = "Interface_MenuItem_SelectMan";
	globals::g_InterfaceMenuItemNames_TABLE[32] = "Interface_MenuItem_DeleteMan";
	globals::g_InterfaceMenuItemNames_TABLE[41] = "Interface_MenuItem_DeleteVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[40] = "Interface_MenuItem_DeleteBuilding";
	globals::g_InterfaceMenuItemNames_TABLE[43] = "Interface_MenuItem_Attack";
	globals::g_InterfaceMenuItemNames_TABLE[18] = "Interface_MenuItem_SelectVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[22] = "Interface_MenuItem_UnLoadVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[23] = "Interface_MenuItem_UnLoadMinifigure";
	globals::g_InterfaceMenuItemNames_TABLE[20] = "Interface_MenuItem_VehiclePickUp";
	globals::g_InterfaceMenuItemNames_TABLE[21] = "Interface_MenuItem_MinifigurePickUp";
	globals::g_InterfaceMenuItemNames_TABLE[25] = "Interface_MenuItem_GetOut";
	globals::g_InterfaceMenuItemNames_TABLE[24] = "Interface_MenuItem_GetIn";
	globals::g_InterfaceMenuItemNames_TABLE[26] = "Interface_MenuItem_GotoDock";
	globals::g_InterfaceMenuItemNames_TABLE[11] = "Interface_MenuItem_Dig";
	globals::g_InterfaceMenuItemNames_TABLE[12] = "Interface_MenuItem_Reinforce";
	globals::g_InterfaceMenuItemNames_TABLE[13] = "Interface_MenuItem_Dynamite";
	globals::g_InterfaceMenuItemNames_TABLE[64] = "Interface_MenuItem_UpgradeMan";
	globals::g_InterfaceMenuItemNames_TABLE[31] = "Interface_MenuItem_GoFeed";
	globals::g_InterfaceMenuItemNames_TABLE[45] = "Interface_MenuItem_GotoFirstPerson";
	globals::g_InterfaceMenuItemNames_TABLE[46] = "Interface_MenuItem_GotoSecondPerson";
	globals::g_InterfaceMenuItemNames_TABLE[57] = "Interface_MenuItem_TrainSkill";
	globals::g_InterfaceMenuItemNames_TABLE[34] = "Interface_MenuItem_PowerOn";
	globals::g_InterfaceMenuItemNames_TABLE[35] = "Interface_MenuItem_PowerOff";
	globals::g_InterfaceMenuItemNames_TABLE[65] = "Interface_MenuItem_UpgradeBuilding";
	globals::g_InterfaceMenuItemNames_TABLE[36] = "Interface_MenuItem_Repair";
	globals::g_InterfaceMenuItemNames_TABLE[19] = "Interface_MenuItem_SelectBuilding";
	globals::g_InterfaceMenuItemNames_TABLE[44] = "Interface_MenuItem_GotoTopView";
	globals::g_InterfaceMenuItemNames_TABLE[48] = "Interface_MenuItem_GetTool";
	globals::g_InterfaceMenuItemNames_TABLE[49] = "Interface_MenuItem_GetDrill";
	globals::g_InterfaceMenuItemNames_TABLE[50] = "Interface_MenuItem_GetSpade";
	globals::g_InterfaceMenuItemNames_TABLE[51] = "Interface_MenuItem_GetHammer";
	globals::g_InterfaceMenuItemNames_TABLE[52] = "Interface_MenuItem_GetSpanner";
	globals::g_InterfaceMenuItemNames_TABLE[58] = "Interface_MenuItem_TrainDriver";
	globals::g_InterfaceMenuItemNames_TABLE[59] = "Interface_MenuItem_TrainEngineer";
	globals::g_InterfaceMenuItemNames_TABLE[60] = "Interface_MenuItem_TrainGeologist";
	globals::g_InterfaceMenuItemNames_TABLE[61] = "Interface_MenuItem_TrainPilot";
	globals::g_InterfaceMenuItemNames_TABLE[62] = "Interface_MenuItem_TrainSailor";
	globals::g_InterfaceMenuItemNames_TABLE[63] = "Interface_MenuItem_TrainDynamite";
	globals::g_InterfaceMenuItemNames_TABLE[73] = "Interface_MenuItem_Build";
	globals::g_InterfaceMenuItemNames_TABLE[14] = "Interface_MenuItem_PlaceFence";
	globals::g_InterfaceMenuItemNames_TABLE[37] = "Interface_MenuItem_MakeTeleporterPrimary";
	globals::g_InterfaceMenuItemNames_TABLE[15] = "Interface_MenuItem_DeselectDig";
	globals::g_InterfaceMenuItemNames_TABLE[72] = "Interface_MenuItem_ClearSelection";
	globals::g_InterfaceMenuItemNames_TABLE[71] = "Interface_MenuItem_Encyclopedia";
	globals::g_InterfaceMenuItemNames_TABLE[38] = "Interface_MenuItem_EjectCrystal";
	globals::g_InterfaceMenuItemNames_TABLE[39] = "Interface_MenuItem_EjectOre";
	globals::g_InterfaceMenuItemNames_TABLE[47] = "Interface_MenuItem_TrackObject";
	globals::g_InterfaceMenuItemNames_TABLE[27] = "Interface_MenuItem_LegoManGoto";
	globals::g_InterfaceMenuItemNames_TABLE[30] = "Interface_MenuItem_LegoManDig";
	globals::g_InterfaceMenuItemNames_TABLE[28] = "Interface_MenuItem_VehicleGoto";
	globals::g_InterfaceMenuItemNames_TABLE[29] = "Interface_MenuItem_VehicleDig";
	globals::g_InterfaceMenuItemNames_TABLE[6] = "Interface_MenuItem_RemovePath";
	globals::g_InterfaceMenuItemNames_TABLE[66] = "Interface_MenuItem_UpgradeVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[67] = "Interface_MenuItem_UpgradeEngine";
	globals::g_InterfaceMenuItemNames_TABLE[68] = "Interface_MenuItem_UpgardeDrill";
	globals::g_InterfaceMenuItemNames_TABLE[69] = "Interface_MenuItem_UpgardeScan";
	globals::g_InterfaceMenuItemNames_TABLE[70] = "Interface_MenuItem_UpgardeCarry";
	globals::g_InterfaceMenuItemNames_TABLE[42] = "Interface_MenuItem_DeleteElectricFence";
	globals::g_InterfaceMenuItemNames_TABLE[53] = "Interface_MenuItem_GetLaser";
	globals::g_InterfaceMenuItemNames_TABLE[54] = "Interface_MenuItem_GetPusherGun";
	globals::g_InterfaceMenuItemNames_TABLE[55] = "Interface_MenuItem_GetFreezerGun";
	globals::g_InterfaceMenuItemNames_TABLE[56] = "Interface_MenuItem_GetBirdScarer";
	globals::g_InterfaceMenuItemNames_TABLE[33] = "Interface_MenuItem_DropBirdScarer";
	globals::g_InterfaceMenuItemNames_TABLE[16] = "Interface_MenuItem_CancelConstruction";
	Main_InterfaceAddItems();
	FUN_0041e900(param_1,param_2,globs::mainGlobs.appWidth + 10,param_2,750.0);
	FUN_0041a8c0();
	return;
}



void __cdecl lego::main::Main_InterfaceAddItems(void)
{
	Main_InterfaceAddItem(0,4,1,2,3,4);
	Main_InterfaceAddItem(1,3,5,6,0xe);
	Main_InterfaceAddItem(2,1,7);
	Main_InterfaceAddItem(3,1,0xe);
	Main_InterfaceAddItem(4,1,0x10);
	Main_InterfaceAddItem(5,2,9,0xe);
	Main_InterfaceAddItem(7,4,0xb,0xc,0xd,0xf);
	Main_InterfaceAddItem(8,2,0x2b,0x2f);
	Main_InterfaceAddItem(10,7,0x16,0x14,0x42,0x19,0x2d,0x2e,0x29);
	Main_InterfaceAddItem(0xb,6,0x16,0x14,0x19,0x2d,0x2e,0x1a);
	Main_InterfaceAddItem(0xc,2,0x18,0x29);
	Main_InterfaceAddItem(9,10,0x1f,0x17,0x15,0x30,0x21,0x40,0x39,0x2d,0x2e,0x20);
	Main_InterfaceAddItem(0xd,4,0x24,0x22,0x41,0x28);
	Main_InterfaceAddItem(0xe,1,0x2a);
	Main_InterfaceAddItem(0xf,3,0x2c,0x2e,0x2d);
	Main_InterfaceAddItem(0x10,8,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38);
	Main_InterfaceAddItem(0x11,6,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f);
	Main_InterfaceAddItem(0x12,4,0x43,0x44,0x45,0x46);
	return;
}



void __cdecl lego::main::Main_InterfaceAddItem(int itemIndex,int numParams,...)
{
	int *piVar1;
	int *piVar2;
	uint uVar3;
	int iVar4;
	int *piVar5;
	int local_78 [30];
	
	globals::g_InterfaceMenuItemDefines_TABLE[itemIndex].numParams = numParams;
	piVar1 = (int *)std::malloc(numParams * 4);
	globals::g_InterfaceMenuItemDefines_TABLE[itemIndex].parameters = piVar1;
	piVar2 = (int *)&stack0x0000000c;
	if (numParams != 0) {
		piVar5 = local_78;
		do {
			iVar4 = *piVar2;
			piVar2 = piVar2 + 1;
			*piVar5 = iVar4;
			piVar5 = piVar5 + 1;
			numParams = numParams + -1;
		} while (numParams != 0);
	}
	piVar2 = local_78;
	for (uVar3 = globals::g_InterfaceMenuItemDefines_TABLE[itemIndex].numParams & 0x3fffffff;
			uVar3 != 0; uVar3 = uVar3 - 1) {
		*piVar1 = *piVar2;
		piVar2 = piVar2 + 1;
		piVar1 = piVar1 + 1;
	}
	for (iVar4 = 0; iVar4 != 0; iVar4 = iVar4 + -1) {
		*(undefined *)piVar1 = *(undefined *)piVar2;
		piVar2 = (int *)((int)piVar2 + 1);
		piVar1 = (int *)((int)piVar1 + 1);
	}
	return;
}



void __cdecl lego::main::Main_CleanupUnkInteraces(void)
{
	InterfaceMenuItem *pIVar1;
	
	pIVar1 = globals::g_InterfaceMenuItemDefines_TABLE;
	do {
		if (pIVar1->parameters != (int *)0x0) {
			std::free(pIVar1->parameters);
		}
		pIVar1 = pIVar1 + 1;
	} while (pIVar1 < &Point2I_004decc4);
	std::free(globals::g_InterfaceBuildImages_Vehicles_normal_TABLE);
	std::free(globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE);
	std::free(globals::g_InterfaceBuildImages_Vehicles_disabled_TABLE);
	std::free(globals::g_SubmenuIcons_VehicleTypes_TABLE);
	std::free(globals::g_InterfaceBuildKeys_Vehicles_TABLE);
	std::free(globals::g_SubmenuIcons_VehicleTypes2_TABLE);
	std::free(globals::g_InterfaceBuildImages_Buildings_normal_TABLE);
	std::free(globals::g_InterfaceBuildImages_Buildings_pressed_TABLE);
	std::free(globals::g_InterfaceBuildImages_Buildings_disabled_TABLE);
	std::free(globals::g_SubmenuIcons_BuildingTypes_TABLE);
	std::free(globals::g_InterfaceBuildKeys_Buildings_TABLE);
	std::free(globals::g_SubmenuIcons_BuildingTypes2_TABLE);
	return;
}



void __cdecl FUN_0041a850(void)
{
	int iVar1;
	uint uVar2;
	uint uVar3;
	uint *puVar4;
	undefined4 *puVar5;
	undefined4 *puVar6;
	
	FLAGS_004df1f8 = 0;
	puVar4 = UINT_ARRAY_004de9ac;
	for (iVar1 = 0x4a; iVar1 != 0; iVar1 = iVar1 + -1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	puVar4 = UINT_ARRAY_004de60c;
	for (iVar1 = 0x4a; uVar2 = lego::globals::g_Game.VehicleTypes_COUNT,
			puVar6 = (undefined4 *)lego::globals::g_SubmenuIcons_VehicleTypes_TABLE, iVar1 != 0;
			iVar1 = iVar1 + -1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	for (; uVar3 = lego::globals::g_Game.VehicleTypes_COUNT,
			puVar5 = (undefined4 *)lego::globals::g_SubmenuIcons_VehicleTypes2_TABLE, uVar2 != 0;
			uVar2 = uVar2 - 1) {
		*puVar6 = 0;
		puVar6 = puVar6 + 1;
	}
	for (; uVar2 = lego::globals::g_Game.BuildingTypes_COUNT,
			puVar6 = (undefined4 *)lego::globals::g_SubmenuIcons_BuildingTypes_TABLE, uVar3 != 0;
			uVar3 = uVar3 - 1) {
		*puVar5 = 0;
		puVar5 = puVar5 + 1;
	}
	for (; uVar3 = lego::globals::g_Game.BuildingTypes_COUNT,
			puVar5 = (undefined4 *)lego::globals::g_SubmenuIcons_BuildingTypes2_TABLE, uVar2 != 0;
			uVar2 = uVar2 - 1) {
		*puVar6 = 0;
		puVar6 = puVar6 + 1;
	}
	for (; uVar3 != 0; uVar3 = uVar3 - 1) {
		*puVar5 = 0;
		puVar5 = puVar5 + 1;
	}
	puVar6 = &DAT_004ded34;
	for (iVar1 = 300; iVar1 != 0; iVar1 = iVar1 + -1) {
		*puVar6 = 0;
		puVar6 = puVar6 + 1;
	}
	FUN_0041a8c0();
	return;
}



void __cdecl FUN_0041a8c0(void)
{
	INT_004deccc = 0;
	FLOAT_004decd0 = FLOAT_004dece8;
	FLAGS_004df1f8 = FLAGS_004df1f8 | 0x84;
	return;
}



BOOL __cdecl lego::front::Interface_GetMenuItemType(char *menuItemName,int *out_menuItemType)
{
	int iVar1;
	char **ppcVar2;
	int iVar3;
	
	iVar3 = 0;
	ppcVar2 = globals::g_InterfaceMenuItemNames_TABLE;
	do {
		iVar1 = std::_stricmp(*ppcVar2,menuItemName);
		if (iVar1 == 0) {
			*out_menuItemType = iVar3;
			return 1;
		}
		ppcVar2 = ppcVar2 + 1;
		iVar3 = iVar3 + 1;
	} while (ppcVar2 < &DAT_004ddff8);
	return 0;
}



void __cdecl lego::main::Main_InitSubmenuIconTables(void)
{
	uint uVar1;
	uint uVar2;
	undefined4 *puVar3;
	
	globals::g_SubmenuIcons_VehicleTypes_TABLE = std::malloc(globals::g_Game.VehicleTypes_COUNT * 4);
	puVar3 = (undefined4 *)globals::g_SubmenuIcons_VehicleTypes_TABLE;
	for (uVar1 = globals::g_Game.VehicleTypes_COUNT; uVar1 != 0; uVar1 = uVar1 - 1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	globals::g_InterfaceBuildKeys_Vehicles_TABLE =
			 (byte *)std::malloc(globals::g_Game.VehicleTypes_COUNT);
	uVar1 = globals::g_Game.VehicleTypes_COUNT;
	puVar3 = (undefined4 *)globals::g_InterfaceBuildKeys_Vehicles_TABLE;
	for (uVar2 = globals::g_Game.VehicleTypes_COUNT >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	for (uVar1 = uVar1 & 3; uVar1 != 0; uVar1 = uVar1 - 1) {
		*(undefined *)puVar3 = 0;
		puVar3 = (undefined4 *)((int)puVar3 + 1);
	}
	globals::g_SubmenuIcons_VehicleTypes2_TABLE = std::malloc(globals::g_Game.VehicleTypes_COUNT * 4);
	puVar3 = (undefined4 *)globals::g_SubmenuIcons_VehicleTypes2_TABLE;
	for (uVar1 = globals::g_Game.VehicleTypes_COUNT; uVar1 != 0; uVar1 = uVar1 - 1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	globals::g_SubmenuIcons_BuildingTypes_TABLE = std::malloc(globals::g_Game.BuildingTypes_COUNT * 4)
	;
	puVar3 = (undefined4 *)globals::g_SubmenuIcons_BuildingTypes_TABLE;
	for (uVar1 = globals::g_Game.BuildingTypes_COUNT; uVar1 != 0; uVar1 = uVar1 - 1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	globals::g_InterfaceBuildKeys_Buildings_TABLE =
			 (byte *)std::malloc(globals::g_Game.BuildingTypes_COUNT);
	uVar1 = globals::g_Game.BuildingTypes_COUNT;
	puVar3 = (undefined4 *)globals::g_InterfaceBuildKeys_Buildings_TABLE;
	for (uVar2 = globals::g_Game.BuildingTypes_COUNT >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	for (uVar1 = uVar1 & 3; uVar1 != 0; uVar1 = uVar1 - 1) {
		*(undefined *)puVar3 = 0;
		puVar3 = (undefined4 *)((int)puVar3 + 1);
	}
	globals::g_SubmenuIcons_BuildingTypes2_TABLE =
			 std::malloc(globals::g_Game.BuildingTypes_COUNT * 4);
	puVar3 = (undefined4 *)globals::g_SubmenuIcons_BuildingTypes2_TABLE;
	for (uVar1 = globals::g_Game.BuildingTypes_COUNT; uVar1 != 0; uVar1 = uVar1 - 1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	return;
}



void __cdecl lego::main::Main_LoadInterfaceBuildImages(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	ImageBMP *pIVar2;
	BOOL BVar3;
	uint uVar4;
	KeysByte local_51;
	char *local_50;
	char *local_4c;
	char *local_48;
	char *local_44;
	
	globals::g_InterfaceBuildImages_Vehicles_normal_TABLE =
			 (ImageBMP **)std::malloc(globals::g_Game.VehicleTypes_COUNT * 4);
	globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE =
			 (ImageBMP **)std::malloc(globals::g_Game.VehicleTypes_COUNT * 4);
	globals::g_InterfaceBuildImages_Vehicles_disabled_TABLE =
			 (ImageBMP **)std::malloc(globals::g_Game.VehicleTypes_COUNT * 4);
	uVar4 = 0;
	if (globals::g_Game.VehicleTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"InterfaceBuildImages",
																 globals::g_Game.VehicleTypes_TABLE[uVar4],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 == (char *)0x0) {
				globals::g_InterfaceBuildImages_Vehicles_normal_TABLE[uVar4] = (ImageBMP *)0x0;
				globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE[uVar4] = (ImageBMP *)0x0;
				globals::g_InterfaceBuildImages_Vehicles_disabled_TABLE[uVar4] = (ImageBMP *)0x0;
			}
			else {
				util::Util_Tokenise(pcVar1,&local_50,":");
				pIVar2 = image::Image_LoadBMPScaled(local_50,0,0);
				globals::g_InterfaceBuildImages_Vehicles_normal_TABLE[uVar4] = pIVar2;
				pIVar2 = image::Image_LoadBMPScaled(local_4c,0,0);
				globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE[uVar4] = pIVar2;
				pIVar2 = image::Image_LoadBMPScaled(local_48,0,0);
				globals::g_InterfaceBuildImages_Vehicles_disabled_TABLE[uVar4] = pIVar2;
				BVar3 = input::Key_Find(local_44,&local_51);
				if (BVar3 != 0) {
					globals::g_InterfaceBuildKeys_Vehicles_TABLE[uVar4] = local_51;
				}
			}
			uVar4 = uVar4 + 1;
		} while (uVar4 < globals::g_Game.VehicleTypes_COUNT);
	}
	globals::g_InterfaceBuildImages_Buildings_normal_TABLE =
			 (ImageBMP **)std::malloc(globals::g_Game.BuildingTypes_COUNT * 4);
	globals::g_InterfaceBuildImages_Buildings_pressed_TABLE =
			 (ImageBMP **)std::malloc(globals::g_Game.BuildingTypes_COUNT * 4);
	globals::g_InterfaceBuildImages_Buildings_disabled_TABLE =
			 (ImageBMP **)std::malloc(globals::g_Game.BuildingTypes_COUNT * 4);
	uVar4 = 0;
	if (globals::g_Game.BuildingTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"InterfaceBuildImages",
																 globals::g_Game.BuildingTypes_TABLE[uVar4],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 == (char *)0x0) {
				globals::g_InterfaceBuildImages_Buildings_normal_TABLE[uVar4] = (ImageBMP *)0x0;
				globals::g_InterfaceBuildImages_Buildings_pressed_TABLE[uVar4] = (ImageBMP *)0x0;
				globals::g_InterfaceBuildImages_Buildings_disabled_TABLE[uVar4] = (ImageBMP *)0x0;
			}
			else {
				util::Util_Tokenise(pcVar1,&local_50,":");
				pIVar2 = image::Image_LoadBMPScaled(local_50,0,0);
				globals::g_InterfaceBuildImages_Buildings_normal_TABLE[uVar4] = pIVar2;
				pIVar2 = image::Image_LoadBMPScaled(local_4c,0,0);
				globals::g_InterfaceBuildImages_Buildings_pressed_TABLE[uVar4] = pIVar2;
				pIVar2 = image::Image_LoadBMPScaled(local_48,0,0);
				globals::g_InterfaceBuildImages_Buildings_disabled_TABLE[uVar4] = pIVar2;
				BVar3 = input::Key_Find(local_44,&local_51);
				if (BVar3 != 0) {
					globals::g_InterfaceBuildKeys_Buildings_TABLE[uVar4] = local_51;
				}
			}
			uVar4 = uVar4 + 1;
		} while (uVar4 < globals::g_Game.BuildingTypes_COUNT);
	}
	return;
}



void __cdecl lego::main::Main_LoadInterfaceImages(CFGProperty *root,char *keyBasePath)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *prop;
	BOOL BVar3;
	int iVar4;
	BOOL3 BVar5;
	ImageBMP *pIVar6;
	int iVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	undefined4 *puVar11;
	char *pcVar12;
	undefined4 *puVar13;
	KeysByte local_47d;
	int local_47c;
	char *local_478;
	char *local_474;
	char *local_450;
	char *local_44c;
	char *local_448;
	char *local_444;
	char *local_440;
	char *local_43c;
	char *local_438;
	undefined4 local_400 [256];
	
	pcVar2 = cfg::CFG_JoinPath(keyBasePath,"InterfaceImages",0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (prop == (CFGProperty *)0x0) {
			Main_LoadInterfaceBuildImages(root,keyBasePath);
			Main_LoadInterfaceBackButton(root,keyBasePath);
			return;
		}
		BVar3 = front::Interface_GetMenuItemType(prop->key,&local_47c);
		if (BVar3 != 0) {
			uVar8 = 0xffffffff;
			uVar10 = 0;
			pcVar2 = prop->value;
			do {
				pcVar12 = pcVar2;
				if (uVar8 == 0) break;
				uVar8 = uVar8 - 1;
				pcVar12 = pcVar2 + 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar12;
			} while (cVar1 != '\0');
			uVar8 = ~uVar8;
			puVar11 = (undefined4 *)(pcVar12 + -uVar8);
			puVar13 = local_400;
			for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
				*puVar13 = *puVar11;
				puVar11 = puVar11 + 1;
				puVar13 = puVar13 + 1;
			}
			for (uVar8 = uVar8 & 3; uVar8 != 0; uVar8 = uVar8 - 1) {
				*(undefined *)puVar13 = *(undefined *)puVar11;
				puVar11 = (undefined4 *)((int)puVar11 + 1);
				puVar13 = (undefined4 *)((int)puVar13 + 1);
			}
			iVar4 = util::Util_Tokenise((char *)local_400,&local_450,":");
			if ((iVar4 == 7) && (BVar5 = util::Util_GetBoolFromString(local_438), BVar5 != BOOL3_ERROR)) {
				BVar5 = util::Util_GetBoolFromString(local_438);
				uVar10 = (uint)(BVar5 == BOOL3_TRUE);
			}
			*(uint *)(&DAT_004deadc + local_47c * 4) = uVar10;
			pIVar6 = image::Image_LoadBMPScaled(local_450,0,0);
			*(ImageBMP **)(&DAT_004ddff8 + local_47c * 4) = pIVar6;
			pIVar6 = image::Image_LoadBMPScaled(local_44c,0,0);
			*(ImageBMP **)(&DAT_004de120 + local_47c * 4) = pIVar6;
			pIVar6 = image::Image_LoadBMPScaled(local_448,0,0);
			*(ImageBMP **)(&DAT_004de248 + local_47c * 4) = pIVar6;
			iVar7 = util::Util_Tokenise(local_444,&local_478,"|");
			iVar4 = local_47c * 4;
			pcVar2 = std::_strdup(local_478);
			*(char **)(&DAT_004de370 + iVar4) = pcVar2;
			if (iVar7 == 2) {
				snd::SFX_GetType(local_474,(SFXType *)(&DAT_004de498 + iVar4));
			}
			iVar7 = util::Util_Tokenise(local_440,&local_478,"|");
			iVar4 = local_47c * 4;
			pcVar2 = std::_strdup(local_478);
			*(char **)(&DAT_004de74c + iVar4) = pcVar2;
			if (iVar7 == 2) {
				snd::SFX_GetType(local_474,(SFXType *)(&DAT_004de874 + iVar4));
			}
			BVar3 = input::Key_Find(local_43c,&local_47d);
			if (BVar3 != 0) {
				globals::g_InterfaceIcon_Keys_TABLE[local_47c] = local_47d;
			}
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



void __cdecl lego::main::Main_LoadInterfaceSurroundImages(CFGProperty *root,char *keyBasePath)
{
	int value;
	char *pcVar1;
	int iVar2;
	ImageBMP *pIVar3;
	ImageBMP **ppIVar4;
	float *pfVar5;
	char local_64 [20];
	char *local_50;
	char *local_4c;
	char *local_48;
	char *local_44;
	char *local_40;
	char *local_3c;
	char *local_38;
	char *local_34;
	
	value = 0;
	ppIVar4 = (ImageBMP **)&DAT_004ddd5c;
	pfVar5 = (float *)&DAT_004ddd8c;
	do {
		value = value + 1;
		std::itoa(value,local_64,10);
		pcVar1 = cfg::CFG_JoinPath(keyBasePath,"InterfaceSurroundImages",local_64,0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		if (pcVar1 == (char *)0x0) {
			*ppIVar4 = (ImageBMP *)0x0;
		}
		else {
			util::Util_Tokenise(pcVar1,&local_50,":");
			iVar2 = std::_stricmp(local_50,"NULL");
			if (iVar2 != 0) {
				pIVar3 = image::Image_LoadBMPScaled(local_50,0,0);
				*ppIVar4 = pIVar3;
				if (pIVar3 != (ImageBMP *)0x0) {
					image::Image_SetupTrans(pIVar3,0.0,0.0,0.0,0.0,0.0,0.0);
				}
				iVar2 = std::atoi(local_4c);
				pfVar5[-1] = (float)iVar2;
				iVar2 = std::atoi(local_48);
				*pfVar5 = (float)iVar2;
				iVar2 = std::atoi(local_44);
				pfVar5[0x38] = (float)iVar2;
				iVar2 = std::atoi(local_40);
				pfVar5[0x39] = (float)iVar2;
			}
			iVar2 = std::_stricmp(local_3c,"NULL");
			if (iVar2 != 0) {
				pIVar3 = image::Image_LoadBMPScaled(local_3c,0,0);
				ppIVar4[0x21] = pIVar3;
				if (pIVar3 != (ImageBMP *)0x0) {
					image::Image_SetupTrans(pIVar3,0.0,0.0,0.0,0.0,0.0,0.0);
				}
				iVar2 = std::atoi(local_38);
				pfVar5[0x20] = (float)iVar2;
				iVar2 = std::atoi(local_34);
				pfVar5[0x21] = (float)iVar2;
			}
		}
		pfVar5 = pfVar5 + 2;
		ppIVar4 = ppIVar4 + 1;
	} while (pfVar5 < &DAT_004ddde4);
	return;
}



void __cdecl lego::main::Main_LoadInterfaceBackButton(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	char *local_50;
	char *local_4c;
	char *local_48;
	char *local_44;
	char *local_40;
	
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"InterfaceBackButton",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		util::Util_Tokenise(pcVar1,&local_50,":");
		globals::g_InterfaceBackButton_size.width = std::atoi(local_50);
		globals::g_InterfaceBackButton_size.height = std::atoi(local_4c);
		globals::g_InterfaceBackButton_bmp = image::Image_LoadBMPScaled(local_48,0,0);
		globals::g_InterfaceBackButton_bmp_pressed = image::Image_LoadBMPScaled(local_44,0,0);
		globals::g_InterfaceBackButton_text = util::Util_RemoveUnderscores(local_40);
		front::ToolTip_Load_HasNLEscape(5,globals::g_InterfaceBackButton_text);
	}
	return;
}



void __cdecl lego::main::Main_LoadInterfaceDependencies_PlusMinus(char *plus,char *minus)
{
	globals::g_InterfaceDependencies_Plus_bmp = image::Image_LoadBMPScaled(plus,0,0);
	if (globals::g_InterfaceDependencies_Plus_bmp != (ImageBMP *)0x0) {
		image::Image_SetupTrans(globals::g_InterfaceDependencies_Plus_bmp,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	globals::g_InterfaceDependencies_Minus_bmp = image::Image_LoadBMPScaled(minus,0,0);
	if (globals::g_InterfaceDependencies_Minus_bmp != (ImageBMP *)0x0) {
		image::Image_SetupTrans(globals::g_InterfaceDependencies_Minus_bmp,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	return;
}



void __cdecl FUN_0041b200(int param_1,Point2I *position)
{
	FUN_00435950();
	FUN_0041b230(param_1,position);
	FUN_0041e980_internal(param_1,position);
	return;
}



void __cdecl FUN_0041b230(int param_1,Point2I *position)
{
	SurfaceMap *pSVar1;
	uint uVar2;
	int iVar3;
	int iVar4;
	int iVar5;
	
	if ((((DAT_004decfc == 1) || (DAT_004decfc == 2)) || (DAT_004decfc == 7)) ||
		 (((DAT_004decfc == 5 || (DAT_004decfc == 3)) || (DAT_004decfc == 4)))) {
		iVar3 = Point2I_004decf4.x;
		iVar4 = Point2I_004decf4.y;
		pSVar1 = lego::game::GetSurfaceMap();
		uVar2 = lego::game::SurfaceMap_FUN_0044f800(pSVar1,iVar3,iVar4);
		if (uVar2 == 0) {
			INT_004df1f0 = 0;
		}
		else {
			iVar3 = Point2I_004decf4.x;
			iVar4 = Point2I_004decf4.y;
			iVar5 = INT_004df1f0;
			pSVar1 = lego::game::GetSurfaceMap();
			lego::game::SurfaceMap_FUN_0044f7a0(pSVar1,iVar3,iVar4,iVar5);
		}
	}
	if (((param_1 == 1) || (param_1 == 2)) ||
		 ((param_1 == 7 || (((param_1 == 5 || (param_1 == 3)) || (param_1 == 4)))))) {
		iVar5 = 4;
		iVar3 = position->y;
		iVar4 = position->x;
		pSVar1 = lego::game::GetSurfaceMap();
		uVar2 = lego::game::SurfaceMap_FUN_0044f7a0(pSVar1,iVar4,iVar3,iVar5);
		if (uVar2 != 4) {
			INT_004df1f0 = uVar2;
		}
	}
	return;
}



int __cdecl FUN_0041b2f0(int param_1)
{
	ObjectStatsFlags2 OVar1;
	ObjectStatsFlags3 OVar2;
	uint uVar3;
	uint uVar4;
	
	if (param_1 == 0x13) {
		return lego::globals::g_Game.BuildingTypes_COUNT;
	}
	if (param_1 == 0x14) {
		uVar4 = 0;
		uVar3 = 0;
		if (lego::globals::g_Game.VehicleTypes_COUNT != 0) {
			do {
				OVar1 = lego::game::Object_GetStatsFlags2(OBJECT_VEHICLE,uVar3);
				if ((OVar1 & STATS2_USESMALLTELEPORTER) == STATS2_NONE) {
					OVar1 = lego::game::Object_GetStatsFlags2(OBJECT_VEHICLE,uVar3);
					if ((OVar1 & STATS2_USEWATERTELEPORTER) != STATS2_NONE) goto LAB_0041b335;
				}
				else {
LAB_0041b335:
					OVar2 = lego::game::Object_GetStatsFlags3(OBJECT_VEHICLE,uVar3);
					if ((OVar2 & STATS3_CLASSASLARGE) == STATS3_NONE) {
						uVar4 = uVar4 + 1;
					}
				}
				uVar3 = uVar3 + 1;
				if (lego::globals::g_Game.VehicleTypes_COUNT <= uVar3) {
					return uVar4;
				}
			} while( true );
		}
	}
	else {
		if (param_1 != 0x15) {
			return lego::globals::g_InterfaceMenuItemDefines_TABLE[param_1].numParams;
		}
		uVar4 = 0;
		uVar3 = 0;
		if (lego::globals::g_Game.VehicleTypes_COUNT != 0) {
			do {
				OVar1 = lego::game::Object_GetStatsFlags2(OBJECT_VEHICLE,uVar3);
				if ((OVar1 & STATS2_USEBIGTELEPORTER) == STATS2_NONE) {
					OVar2 = lego::game::Object_GetStatsFlags3(OBJECT_VEHICLE,uVar3);
					if ((OVar2 & STATS3_CLASSASLARGE) != STATS3_NONE) goto LAB_0041b385;
				}
				else {
LAB_0041b385:
					uVar4 = uVar4 + 1;
				}
				uVar3 = uVar3 + 1;
			} while (uVar3 < lego::globals::g_Game.VehicleTypes_COUNT);
		}
	}
	return uVar4;
}



BOOL __cdecl lego::unk::Lego_ParamNotEquals0_NotEquals15(int param_1)
{
	if ((param_1 != 0) && (param_1 != 0xf)) {
		return 1;
	}
	return 0;
}



void __cdecl FUN_0041b3c0(void)
{
	int iVar1;
	BOOL BVar2;
	ImageBMP *pIVar3;
	uint uVar4;
	Point2F local_8;
	
	if ((FLAGS_004df1f8 & 4) == 0) {
		return;
	}
	iVar1 = FUN_0041b2f0(INT_004deccc);
	BVar2 = lego::unk::Lego_ParamNotEquals0_NotEquals15(INT_004deccc);
	if (BVar2 == 0) {
		if (*(ImageBMP **)(&DAT_004ddddc + iVar1 * 4) != (ImageBMP *)0x0) {
			local_8.x = *(float *)(&DAT_004dde04 + iVar1 * 8) + FLOAT_004decd0;
			local_8.y = *(float *)(&DAT_004dde08 + iVar1 * 8) + FLOAT_004decd4;
			lego::image::Image_DisplayScaled
								(*(ImageBMP **)(&DAT_004ddddc + iVar1 * 4),(Rect2F *)0x0,&local_8,(Size2F *)0x0);
		}
		goto LAB_0041b52f;
	}
	if ((ImageBMP *)(&DAT_004ddd58)[iVar1] != (ImageBMP *)0x0) {
		local_8.x = *(float *)(&DAT_004ddd80 + iVar1 * 8) + FLOAT_004decd0;
		local_8.y = *(float *)(&DAT_004ddd84 + iVar1 * 8) + FLOAT_004decd4;
		lego::image::Image_DisplayScaled
							((ImageBMP *)(&DAT_004ddd58)[iVar1],(Rect2F *)0x0,&local_8,(Size2F *)0x0);
	}
	uVar4 = UINT_ARRAY_004de60c[0] & 4;
	BVar2 = FUN_0041c990(0);
	pIVar3 = lego::globals::g_InterfaceBackButton_bmp;
	if (BVar2 == 0) {
		if ((FLAGS_004df1f8 & 0x4000) == 0) {
			if (uVar4 != 0) goto LAB_0041b47e;
LAB_0041b48e:
			pIVar3 = (ImageBMP *)0x0;
		}
		else {
			if (uVar4 != 0) {
LAB_0041b47e:
				if (DAT_004ded1c == 0) goto LAB_0041b48e;
			}
		}
	}
	else {
		pIVar3 = lego::globals::g_InterfaceBackButton_bmp_pressed;
		if ((uVar4 != 0) && (DAT_004ded1c != 0)) {
			pIVar3 = lego::globals::g_InterfaceBackButton_bmp;
		}
	}
	if (pIVar3 != (ImageBMP *)0x0) {
		local_8.x = (float)(&lego::globals::g_InterfaceBackButton_bmp)[iVar1 * 2] + FLOAT_004decd0;
		local_8.y = (float)(&lego::globals::g_InterfaceBackButton_bmp_pressed)[iVar1 * 2] +
								FLOAT_004decd4;
		lego::image::Image_DisplayScaled(pIVar3,(Rect2F *)0x0,&local_8,(Size2F *)0x0);
	}
	FUN_0041c420(0,OBJECT_NONE,0,(float *)0x0);
	FUN_0041c920(0,0);
	FUN_0041c6e0(0);
LAB_0041b52f:
	local_8.x = FLOAT_004decd0;
	local_8.y = FLOAT_004decd4;
	FUN_0041b5b0(INT_004deccc,FUN_0041b730,&local_8);
	if ((FLAGS_004df1f8 & 0x1200) != 0) {
		FUN_0041cc60(&Rect2F_004ded0c);
	}
	if ((FLAGS_004df1f8 & 0x3000) != 0) {
		FUN_0041ebd0(Rect2F_004ded0c.x,Rect2F_004ded0c.y);
		return;
	}
	FUN_0041ed90();
	return;
}



BOOL __cdecl FUN_0041b5b0(int menuIcon,undefined *callback,void *context)
{
	int iVar1;
	ObjectStatsFlags2 OVar2;
	ObjectStatsFlags3 OVar3;
	uint uVar4;
	
	uVar4 = 0;
	if (menuIcon == 0x13) {
		if (lego::globals::g_Game.BuildingTypes_COUNT != 0) {
			do {
				iVar1 = (*(code *)callback)(0x49,4,uVar4,context);
				if (iVar1 != 0) {
					return 1;
				}
				uVar4 = uVar4 + 1;
			} while (uVar4 < lego::globals::g_Game.BuildingTypes_COUNT);
			return 0;
		}
	}
	else {
		if (menuIcon == 0x14) {
			uVar4 = 0;
			if (lego::globals::g_Game.VehicleTypes_COUNT != 0) {
				while (((OVar2 = lego::game::Object_GetStatsFlags2(OBJECT_VEHICLE,uVar4),
								(OVar2 & STATS2_USESMALLTELEPORTER) == STATS2_NONE &&
								(OVar2 = lego::game::Object_GetStatsFlags2(OBJECT_VEHICLE,uVar4),
								(OVar2 & STATS2_USEWATERTELEPORTER) == STATS2_NONE)) ||
							 ((OVar3 = lego::game::Object_GetStatsFlags3(OBJECT_VEHICLE,uVar4),
								(OVar3 & STATS3_CLASSASLARGE) != STATS3_NONE ||
								(iVar1 = (*(code *)callback)(0x49,1,uVar4,context), iVar1 == 0))))) {
					uVar4 = uVar4 + 1;
					if (lego::globals::g_Game.VehicleTypes_COUNT <= uVar4) {
						return 0;
					}
				}
				return 1;
			}
		}
		else {
			if (menuIcon == 0x15) {
				uVar4 = 0;
				if (lego::globals::g_Game.VehicleTypes_COUNT != 0) {
					while (((OVar2 = lego::game::Object_GetStatsFlags2(OBJECT_VEHICLE,uVar4),
									(OVar2 & STATS2_USEBIGTELEPORTER) == STATS2_NONE &&
									(OVar3 = lego::game::Object_GetStatsFlags3(OBJECT_VEHICLE,uVar4),
									(OVar3 & STATS3_CLASSASLARGE) == STATS3_NONE)) ||
								 (iVar1 = (*(code *)callback)(0x49,1,uVar4,context), iVar1 == 0))) {
						uVar4 = uVar4 + 1;
						if (lego::globals::g_Game.VehicleTypes_COUNT <= uVar4) {
							return 0;
						}
					}
					return 1;
				}
			}
			else {
				if (lego::globals::g_InterfaceMenuItemDefines_TABLE[menuIcon].numParams != 0) {
					while( true ) {
						iVar1 = lego::globals::g_InterfaceMenuItemDefines_TABLE[menuIcon].parameters[uVar4];
						if ((iVar1 == 0x22) || (iVar1 == 0x23)) {
							iVar1 = FUN_0041b8f0(lego::globals::g_InterfaceMenuItemDefines_TABLE[menuIcon].
																	 parameters + uVar4);
						}
						iVar1 = (*(code *)callback)(iVar1,0,0,context);
						if (iVar1 != 0) break;
						uVar4 = uVar4 + 1;
						if (lego::globals::g_InterfaceMenuItemDefines_TABLE[menuIcon].numParams <= uVar4) {
							return 0;
						}
					}
					return 1;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl FUN_0041b730(uint param_1,uint param_2,int param_3,float *param_4)
{
	uint uVar1;
	ImageBMP *image;
	uint uVar2;
	
	uVar1 = param_1;
	if (param_1 == 0x49) {
		FUN_0041c730(param_2,param_3);
		image = lego::front::Interface_GetBuildImageByObjectType(param_2,param_3);
		if (param_2 == 1) {
			uVar2 = *(uint *)((int)lego::globals::g_SubmenuIcons_VehicleTypes2_TABLE + param_3 * 4) & 4;
		}
		else {
			uVar2 = param_2;
			if (param_2 == 4) {
				uVar2 = *(uint *)((int)lego::globals::g_SubmenuIcons_BuildingTypes2_TABLE + param_3 * 4) & 4
				;
			}
		}
		FUN_0041c950(param_2,param_3,0);
	}
	else {
		FUN_0041c6e0(param_1);
		image = FUN_0041c9e0(param_1);
		uVar2 = UINT_ARRAY_004de60c[param_1] & 4;
		FUN_0041c920(param_1,0);
	}
	FUN_0041c420(param_1,param_2,param_3,param_4);
	if (image == (ImageBMP *)0x0) {
		param_1 = 0x28;
	}
	else {
		param_1 = image->height;
		if ((uVar2 == 0) || (DAT_004ded1c != 0)) {
			lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,(Point2F *)param_4,(Size2F *)0x0);
		}
	}
	if (uVar1 == 1) {
		param_3 = 0;
		param_2 = 2;
	}
	else {
		if (uVar1 != 0x49) goto LAB_0041b82e;
	}
	FUN_0041eb60(param_2,param_3);
LAB_0041b82e:
	param_4[1] = (float)(ulonglong)param_1 + param_4[1];
	return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_0041b860(float param_1)
{
	_DAT_004ded20 = _DAT_004ded20 - param_1;
	if (_DAT_004ded20 < 0.0) {
		DAT_004ded1c = (uint)(DAT_004ded1c == 0);
		_DAT_004ded20 = 15.0;
	}
	FUN_0041e9f0(param_1);
	if ((ushort)((ushort)(FLOAT_004df1ec < 0.0) << 8 | (ushort)(FLOAT_004df1ec == 0.0) << 0xe) == 0) {
		FLOAT_004df1ec = FLOAT_004df1ec - param_1;
		return;
	}
	FLAGS_004df1f8 = FLAGS_004df1f8 | 0x800;
	return;
}



undefined4 __cdecl lego::unk::Lego_GetDat_004ded1c(void)
{
	return DAT_004ded1c;
}



// Result is same as final value of *ref_param_1 (param_1 may not be changed)

undefined4 __cdecl FUN_0041b8f0(undefined4 *ref_param_1)
{
	LiveObject *pLVar1;
	
	pLVar1 = lego::game::Game_GetPrimarySelectedObject();
	if (((FLAGS_004df1f8 & 0x80) == 0) && ((FLAGS_004df1f8 & 0x100) != 0)) {
		return *ref_param_1;
	}
	if ((pLVar1->flags3 & LIVEOBJ3_UNK_80000000) != LIVEOBJ3_NONE) {
		*ref_param_1 = 0x22;
		return 0x22;
	}
	*ref_param_1 = 0x23;
	return 0x23;
}



void __cdecl FUN_0041b940(float param_1)
{
	SFXType SVar1;
	
	SVar1 = DAT_004df1f4;
	if (DAT_004df1f4 != DAT_004df1fc) {
		FLOAT_004a3b58 = 25.0;
		DAT_004df1f4 = 0;
		DAT_004df1fc = SVar1;
		DAT_004df200 = 0;
		return;
	}
	FLOAT_004a3b58 = FLOAT_004a3b58 - param_1;
	if (((ushort)((ushort)(FLOAT_004a3b58 < 0.0) << 8 | (ushort)(FLOAT_004a3b58 == 0.0) << 0xe) != 0)
		 && (DAT_004df200 == 0)) {
		DAT_004df200 = lego::snd::Audio_FUN_004651b0(DAT_004df1f4,(int *)0x0);
	}
	DAT_004df1f4 = 0;
	return;
}



void __cdecl lego::unk::Lego_SetDat_004df1f4(undefined4 param_1)
{
	DAT_004df1f4 = param_1;
	return;
}



BOOL __cdecl
lego::game::GameUnk_DoSomethingWithRenameReplace
					(uint param_1,uint param_2,int param_3,int param_4,int param_5)
{
	float fVar1;
	char cVar2;
	BOOL BVar3;
	char *pcVar4;
	LiveObject *pLVar5;
	uint uVar6;
	undefined4 *puVar7;
	int iVar8;
	uint uVar9;
	uint uVar10;
	char *pcVar11;
	char **ppcVar12;
	ImageBMP *image;
	undefined4 *puVar13;
	int iVar14;
	char *pcVar15;
	undefined4 *puVar16;
	longlong lVar17;
	undefined4 uVar18;
	int local_a78;
	int local_a74;
	uint local_a70;
	ObjectType local_a6c;
	int local_a68;
	ObjectType local_a64;
	int local_a60;
	int local_a5c;
	uint local_a58;
	uint local_a54;
	char *local_a50 [20];
	char local_a00 [512];
	undefined4 local_800;
	undefined4 local_600 [128];
	char local_400 [1024];
	
	pcVar11 = (char *)0x0;
	local_a70 = 0;
	local_a60 = 0;
	if (((FLAGS_004df1f8 & 4) == 0) || ((FLAGS_004df1f8 & 0x80) == 0)) {
		FLAGS_004df1f8 = FLAGS_004df1f8 & 0xffff89ff;
		return 0;
	}
	FLAGS_004df1f8 = FLAGS_004df1f8 & 0xffff89ff;
	BVar3 = FUN_0041edb0(param_1,param_2,Rect2F_004ded0c.x,Rect2F_004ded0c.y,&local_a64,&local_a68,
											 &local_a5c);
	if (BVar3 != 0) {
		FLAGS_004df1f8 = FLAGS_004df1f8 | 0x1000;
		if (((param_3 == 0) && (param_5 == 0)) && (local_a64 != 0x14)) {
			pcVar11 = globals::g_Game.UpgradeNames_TABLE[local_a5c];
			if (pcVar11 == (char *)0x0) {
				pcVar11 = Object_GetName(local_a64,local_a68);
				std::sprintf((char *)&local_800,"%s",pcVar11);
			}
			else {
				pcVar4 = Object_GetName(local_a64,local_a68);
				std::sprintf((char *)&local_800,"%s (%s)",pcVar4,pcVar11);
			}
			front::ToolTip_Load_HasNLEscape(4,(char *)&local_800);
			front::ToolTip_AddFlag4(4);
			front::ToolTip_FUN_0046ba60(4);
			if ((globals::g_Game.flags2 & GAME2_DISABLETOOLTIPSOUND) == GAME2_NONE) {
				unk::Lego_SetDat_004df1f4(globals::g_ObjTtSFX_TABLE[local_a64][local_a68]);
			}
		}
		FUN_0041c610(0,0,0,param_3,param_4);
		return 1;
	}
	BVar3 = FUN_0041c0f0(param_1,param_2,&local_a78,&local_a6c,&local_a74);
	if (BVar3 == 0) {
		iVar14 = FUN_0041b2f0(INT_004deccc);
		BVar3 = unk::Lego_ParamNotEquals0_NotEquals15(INT_004deccc);
		if (BVar3 == 0) {
			image = *(ImageBMP **)(&DAT_004ddddc + iVar14 * 4);
			lVar17 = __ftol((float10)*(float *)(&DAT_004dde04 + iVar14 * 8) + (float10)FLOAT_004decd0);
			iVar8 = (int)lVar17;
			fVar1 = *(float *)(&DAT_004dde08 + iVar14 * 8);
		}
		else {
			image = (ImageBMP *)(&DAT_004ddd58)[iVar14];
			lVar17 = __ftol((float10)*(float *)(&DAT_004ddd80 + iVar14 * 8) + (float10)FLOAT_004decd0);
			iVar8 = (int)lVar17;
			fVar1 = *(float *)(&DAT_004ddd84 + iVar14 * 8);
		}
		lVar17 = __ftol((float10)fVar1 + (float10)FLOAT_004decd4);
		if (image == (ImageBMP *)0x0) {
			return local_a70;
		}
		BVar3 = lego::image::Image_GetPixel(image,param_1 - iVar8,param_2 - (int)lVar17,&local_a58);
		if (BVar3 == 0) {
			return local_a70;
		}
		if (local_a58 == 0) {
			return local_a70;
		}
		if (param_5 != 0) {
			snd::Audio_FUN_00428730(1);
		}
		return 1;
	}
	if (local_a78 == 0) {
		FLAGS_004df1f8 = FLAGS_004df1f8 | 0x4000;
		front::ToolTip_AddFlag4(5);
		goto LAB_0041bf5c;
	}
	if (local_a78 == 0x49) {
		FLAGS_004df1f8 =
				 FLAGS_004df1f8 & 0xffff0000 |
				 (uint)(ushort)(CONCAT11((char)((FLAGS_004df1f8 | 0x200) >> 8),(char)FLAGS_004df1f8) | 0x400
											 ) | 0x2000;
		pcVar11 = Object_GetName(local_a6c,local_a74);
		std::sprintf(local_a00,"%s",pcVar11);
		if ((globals::g_Game.flags2 & GAME2_DISABLETOOLTIPSOUND) == GAME2_NONE) {
			unk::Lego_SetDat_004df1f4(globals::g_ObjTtSFX_TABLE[local_a6c][local_a74]);
			pcVar4 = local_a00;
		}
		else {
LAB_0041bec2:
			pcVar4 = local_a00;
		}
	}
	else {
		if ((local_a78 == 5) || (uVar6 = FLAGS_004df1f8 | 0x200, local_a78 == 0xe)) {
			uVar6 = FLAGS_004df1f8 | 0x2200;
		}
		FLAGS_004df1f8 = uVar6;
		BVar3 = FUN_0041c820(local_a78,0);
		if (BVar3 == 0) {
			pcVar4 = *(char **)(&DAT_004de370 + local_a78 * 4);
			if ((pcVar4 != (char *)0x0) &&
				 (pcVar11 = pcVar4, (globals::g_Game.flags2 & GAME2_DISABLETOOLTIPSOUND) == GAME2_NONE)) {
				uVar18 = *(undefined4 *)(&DAT_004de498 + local_a78 * 4);
LAB_0041bd3e:
				unk::Lego_SetDat_004df1f4(uVar18);
				pcVar11 = pcVar4;
			}
		}
		else {
			if (*(int *)(&DAT_004de74c + local_a78 * 4) != 0) {
				pLVar5 = Game_GetPrimarySelectedObject();
				if (((((pLVar5 == (LiveObject *)0x0) || (local_a78 != 0x41)) ||
						 (uVar6 = Object_GetLevels(pLVar5->objType,pLVar5->objIndex),
						 uVar6 <= pLVar5->objLevel + 1)) ||
						((uVar6 = Level_GetOreCount(0), (uint)globals::g_Game.BuildingUpgradeCostOre <= uVar6 ||
						 (uVar6 = Level_GetOreCount(1), (uint)globals::g_Game.BuildingUpgradeCostStuds <= uVar6)
						 ))) || (globals::g_ToolTipIcon_Ore == (ImageBMP *)0x0)) {
					pcVar11 = *(char **)(&DAT_004de74c + local_a78 * 4);
				}
				else {
					if (globals::g_Game.OreRequiredText != (char *)0x0) {
						std::sprintf(local_400,"%s",globals::g_Game.OreRequiredText);
						pcVar11 = local_400;
					}
					local_a60 = Level_GetOreCount(0);
					local_a60 = globals::g_Game.BuildingUpgradeCostOre - local_a60;
				}
				if ((globals::g_Game.flags2 & GAME2_DISABLETOOLTIPSOUND) == GAME2_NONE) {
					uVar18 = *(undefined4 *)(&DAT_004de874 + local_a78 * 4);
					pcVar4 = pcVar11;
					goto LAB_0041bd3e;
				}
			}
		}
		pcVar4 = (char *)0x0;
		if (((pcVar11 != (char *)0x0) &&
				(pcVar4 = pcVar11, *(int *)(&DAT_004deadc + local_a78 * 4) != 0)) &&
			 ((uVar6 = Game_GetNumSelectedUnits(), uVar6 == 1 &&
				(((pLVar5 = Game_GetPrimarySelectedObject(), pLVar5 != (LiveObject *)0x0 &&
					(pLVar5 = Game_GetPrimarySelectedObject(), pLVar5->customName != (char *)0x0)) &&
				 (pLVar5 = Game_GetPrimarySelectedObject(), *pLVar5->customName != '\0')))))) {
			uVar6 = 0xffffffff;
			pcVar4 = globals::g_Game.RenameReplace;
			do {
				pcVar15 = pcVar4;
				if (uVar6 == 0) break;
				uVar6 = uVar6 - 1;
				pcVar15 = pcVar4 + 1;
				cVar2 = *pcVar4;
				pcVar4 = pcVar15;
			} while (cVar2 != '\0');
			uVar6 = ~uVar6;
			puVar13 = (undefined4 *)(pcVar15 + -uVar6);
			puVar16 = &local_800;
			for (uVar9 = uVar6 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
				*puVar16 = *puVar13;
				puVar13 = puVar13 + 1;
				puVar16 = puVar16 + 1;
			}
			for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
				*(undefined *)puVar16 = *(undefined *)puVar13;
				puVar13 = (undefined4 *)((int)puVar13 + 1);
				puVar16 = (undefined4 *)((int)puVar16 + 1);
			}
			uVar6 = 0xffffffff;
			do {
				pcVar4 = pcVar11;
				if (uVar6 == 0) break;
				uVar6 = uVar6 - 1;
				pcVar4 = pcVar11 + 1;
				cVar2 = *pcVar11;
				pcVar11 = pcVar4;
			} while (cVar2 != '\0');
			uVar6 = ~uVar6;
			puVar13 = (undefined4 *)(pcVar4 + -uVar6);
			puVar16 = local_600;
			for (uVar9 = uVar6 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
				*puVar16 = *puVar13;
				puVar13 = puVar13 + 1;
				puVar16 = puVar16 + 1;
			}
			puVar7 = &local_800;
			for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
				*(undefined *)puVar16 = *(undefined *)puVar13;
				puVar13 = (undefined4 *)((int)puVar13 + 1);
				puVar16 = (undefined4 *)((int)puVar16 + 1);
			}
			while ((char)local_800 != '\0') {
				if (*(char *)puVar7 == ' ') {
					*(char *)puVar7 = '_';
				}
				pcVar11 = (char *)((int)puVar7 + 1);
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				local_800._0_1_ = *pcVar11;
			}
			local_a54 = util::Util_Tokenise((char *)local_600,local_a50,(char *)&local_800);
			uVar6 = 0;
			local_a00[0] = '\0';
			if (local_a54 != 0) {
				local_a70 = local_a54 - 1;
				ppcVar12 = local_a50;
				do {
					uVar9 = 0xffffffff;
					pcVar11 = *ppcVar12;
					do {
						pcVar4 = pcVar11;
						if (uVar9 == 0) break;
						uVar9 = uVar9 - 1;
						pcVar4 = pcVar11 + 1;
						cVar2 = *pcVar11;
						pcVar11 = pcVar4;
					} while (cVar2 != '\0');
					uVar9 = ~uVar9;
					iVar14 = -1;
					pcVar11 = local_a00;
					do {
						pcVar15 = pcVar11;
						if (iVar14 == 0) break;
						iVar14 = iVar14 + -1;
						pcVar15 = pcVar11 + 1;
						cVar2 = *pcVar11;
						pcVar11 = pcVar15;
					} while (cVar2 != '\0');
					puVar13 = (undefined4 *)(pcVar4 + -uVar9);
					puVar16 = (undefined4 *)(pcVar15 + -1);
					for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {
						*puVar16 = *puVar13;
						puVar13 = puVar13 + 1;
						puVar16 = puVar16 + 1;
					}
					for (uVar9 = uVar9 & 3; uVar9 != 0; uVar9 = uVar9 - 1) {
						*(undefined *)puVar16 = *(undefined *)puVar13;
						puVar13 = (undefined4 *)((int)puVar13 + 1);
						puVar16 = (undefined4 *)((int)puVar16 + 1);
					}
					if (uVar6 < local_a70) {
						pLVar5 = Game_GetPrimarySelectedObject();
						uVar9 = 0xffffffff;
						pcVar11 = pLVar5->customName;
						do {
							pcVar4 = pcVar11;
							if (uVar9 == 0) break;
							uVar9 = uVar9 - 1;
							pcVar4 = pcVar11 + 1;
							cVar2 = *pcVar11;
							pcVar11 = pcVar4;
						} while (cVar2 != '\0');
						uVar9 = ~uVar9;
						iVar14 = -1;
						pcVar11 = local_a00;
						do {
							pcVar15 = pcVar11;
							if (iVar14 == 0) break;
							iVar14 = iVar14 + -1;
							pcVar15 = pcVar11 + 1;
							cVar2 = *pcVar11;
							pcVar11 = pcVar15;
						} while (cVar2 != '\0');
						puVar13 = (undefined4 *)(pcVar4 + -uVar9);
						puVar16 = (undefined4 *)(pcVar15 + -1);
						for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {
							*puVar16 = *puVar13;
							puVar13 = puVar13 + 1;
							puVar16 = puVar16 + 1;
						}
						for (uVar9 = uVar9 & 3; uVar9 != 0; uVar9 = uVar9 - 1) {
							*(undefined *)puVar16 = *(undefined *)puVar13;
							puVar13 = (undefined4 *)((int)puVar13 + 1);
							puVar16 = (undefined4 *)((int)puVar16 + 1);
						}
					}
					uVar6 = uVar6 + 1;
					ppcVar12 = ppcVar12 + 1;
				} while (uVar6 < local_a54);
			}
			goto LAB_0041bec2;
		}
	}
	if ((param_3 == 0) && (param_5 == 0)) {
		if (pcVar4 == (char *)0x0) {
			std::sprintf(local_a00,"Missing config for\n\'%s\'",
									 globals::g_InterfaceMenuItemNames_TABLE[local_a78]);
			front::ToolTip_Load_HasNLEscape(4,local_a00);
		}
		else {
			front::ToolTip_Load_HasNLEscape(4,pcVar4);
			for (iVar14 = local_a60; iVar14 != 0; iVar14 = iVar14 + -1) {
				front::ToolTip_FUN_0046b920(4,(undefined4 *)globals::g_ToolTipIcon_Ore);
			}
		}
		front::ToolTip_AddFlag4(4);
		front::ToolTip_FUN_0046ba60(4);
	}
	else {
		unk::Lego_SetDat_004df1f4(0);
	}
LAB_0041bf5c:
	BVar3 = FUN_0041c610(local_a78,local_a6c,local_a74,param_3,param_4);
	if ((BVar3 != 0) && (param_5 != 0)) {
		if (local_a78 == 0x49) {
			if ((INT_004deccc == 0x14) || (INT_004deccc == 0x15)) {
				*(int *)((int)globals::g_SubmenuIcons_VehicleTypes_TABLE + local_a74 * 4) =
						 *(int *)((int)globals::g_SubmenuIcons_VehicleTypes_TABLE + local_a74 * 4) + 1;
			}
			else {
				if (INT_004deccc == 0x13) {
					*(int *)((int)globals::g_SubmenuIcons_BuildingTypes_TABLE + local_a74 * 4) =
							 *(int *)((int)globals::g_SubmenuIcons_BuildingTypes_TABLE + local_a74 * 4) + 1;
				}
			}
		}
		else {
			UINT_ARRAY_004de9ac[local_a78] = UINT_ARRAY_004de9ac[local_a78] + 1;
		}
		BVar3 = Game_DoAction__0041dbd0(local_a78);
		snd::Audio_FUN_00428730((uint)(BVar3 == 0));
	}
	return 1;
}



BOOL __cdecl
FUN_0041c0f0(uint param_1,uint param_2,undefined4 *param_3,undefined4 *param_4,undefined4 *param_5)
{
	float fVar1;
	float fVar2;
	int iVar3;
	BOOL BVar4;
	uint local_1c;
	uint local_18;
	float local_14;
	float local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	iVar3 = FUN_0041b2f0(INT_004deccc);
	BVar4 = lego::unk::Lego_ParamNotEquals0_NotEquals15(INT_004deccc);
	if (BVar4 != 0) {
		fVar1 = (float)(ulonglong)param_1;
		if (((((float)(&lego::globals::g_InterfaceBackButton_bmp)[iVar3 * 2] + FLOAT_004decd0 <= fVar1)
				 && (fVar2 = (float)(ulonglong)(uint)lego::globals::g_InterfaceBackButton_size.width +
										 (float)(&lego::globals::g_InterfaceBackButton_bmp)[iVar3 * 2] + FLOAT_004decd0,
						(ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) != 0)) &&
				(fVar1 = (float)(ulonglong)param_2,
				(float)(&lego::globals::g_InterfaceBackButton_bmp_pressed)[iVar3 * 2] + FLOAT_004decd4 <=
				fVar1)) &&
			 (fVar2 = (float)(ulonglong)(uint)lego::globals::g_InterfaceBackButton_size.height +
								(float)(&lego::globals::g_InterfaceBackButton_bmp_pressed)[iVar3 * 2] +
								FLOAT_004decd4,
			 (ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) != 0)) {
			*param_3 = 0;
			return 1;
		}
	}
	local_14 = FLOAT_004decd0;
	local_1c = param_1;
	local_18 = param_2;
	local_10 = FLOAT_004decd4;
	BVar4 = FUN_0041b5b0(INT_004deccc,FUN_0041c240,&local_1c);
	if (BVar4 == 0) {
		return 0;
	}
	*param_3 = local_c;
	*param_4 = local_8;
	*param_5 = local_4;
	return 1;
}



BOOL __cdecl FUN_0041c240(uint in_menuIcon,ObjectType objType,int objIndex,uint *param_4)
{
	Point2F *point;
	float fVar1;
	float fVar2;
	uint menuIcon;
	ImageBMP *pIVar3;
	uint uVar4;
	
	menuIcon = in_menuIcon;
	if (in_menuIcon == 0x49) {
		pIVar3 = lego::front::Interface_GetBuildImageByObjectType(objType,objIndex);
	}
	else {
		pIVar3 = FUN_0041c9e0(in_menuIcon);
	}
	if (pIVar3 == (ImageBMP *)0x0) {
		uVar4 = 0x28;
		in_menuIcon = 0x28;
	}
	else {
		in_menuIcon = pIVar3->width;
		uVar4 = pIVar3->height;
	}
	point = (Point2F *)(param_4 + 2);
	fVar1 = (float)(ulonglong)*param_4;
	if ((((point->x <= fVar1) &&
			 (fVar2 = (float)(ulonglong)in_menuIcon + point->x,
			 (ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) != 0)) &&
			(fVar1 = (float)(ulonglong)param_4[1], (float)param_4[3] <= fVar1)) &&
		 ((ushort)((ushort)(fVar1 < (float)(ulonglong)uVar4 + (float)param_4[3]) << 8 |
							(ushort)(fVar1 == (float)(ulonglong)uVar4 + (float)param_4[3]) << 0xe) != 0)) {
		param_4[4] = menuIcon;
		lego::front::MenuIcon_SetDat_004decd8_004decdc(menuIcon,objType,objIndex);
		if (menuIcon == 0x49) {
			param_4[5] = objType;
			param_4[6] = objIndex;
		}
		FUN_0041cc10(point,in_menuIcon - 1,uVar4 - 1);
		return 1;
	}
	param_4[3] = (uint)((float)(ulonglong)uVar4 + (float)param_4[3]);
	return 0;
}



void __cdecl lego::front::Front_DoF2InterfaceKeyAction(void)
{
	if (((((byte)FLAGS_004df1f8 & 4) != 0) && (((byte)FLAGS_004df1f8 & 0x80) != 0)) &&
		 (globs::INPUT.Key_Map[60] != false)) {
		FUN_0041b5b0(INT_004deccc,Front_DoMenuIconKey_Action,(void *)0x0);
	}
	return;
}



BOOL __cdecl lego::front::Front_DoMenuIconKey_Action(uint menuIcon,ObjectType objType,int objIndex)
{
	uint menuIcon_00;
	
	menuIcon_00 = menuIcon;
	if (menuIcon == 0x49) {
		if (objType == OBJECT_VEHICLE) {
			menuIcon = (uint)globals::g_InterfaceBuildKeys_Vehicles_TABLE[objIndex];
		}
		else {
			if (objType == OBJECT_BUILDING) {
				menuIcon = (uint)globals::g_InterfaceBuildKeys_Buildings_TABLE[objIndex];
			}
		}
	}
	else {
		menuIcon = (uint)globals::g_InterfaceIcon_Keys_TABLE[menuIcon];
	}
	if ((globs::INPUT.Key_Map[menuIcon & 0xff] != false) &&
		 (globs::INPUT.prevKey_Map[menuIcon & 0xff] != globs::INPUT.Key_Map[menuIcon & 0xff])) {
		MenuIcon_SetDat_004decd8_004decdc(menuIcon_00,objType,objIndex);
		game::Game_DoAction__0041dbd0(menuIcon_00);
	}
	return 0;
}



void __cdecl FUN_0041c420(int param_1,ObjectType objType,int objIndex,float *param_4)
{
	bool bVar1;
	bool bVar2;
	BOOL BVar3;
	int iVar4;
	float local_18;
	float fStack20;
	float local_10;
	float local_c;
	uint local_8;
	undefined4 uStack4;
	
	bVar2 = false;
	if (((FLAGS_004df1f8 & 0x20) != 0) && (BVar3 = lego::front::Advisor_GetFlag1(), BVar3 == 0)) {
		bVar1 = false;
		if (INT_004ded28 == 0x49) {
			if ((ObjectType_004ded2c == objType) && (INT_004ded30 == objIndex)) {
				objType = (ObjectType)lego::front::Interface_GetBuildImageByObjectType(objType,objIndex);
				bVar1 = true;
			}
		}
		else {
			if (param_1 == INT_004ded28) {
				if (param_1 == 0) {
					bVar2 = true;
					bVar1 = true;
				}
				else {
					objType = (ObjectType)FUN_0041c9e0(param_1);
					bVar1 = true;
				}
			}
		}
		if (bVar1) {
			if (bVar2) {
				iVar4 = FUN_0041b2f0(INT_004deccc);
				if ((FLAGS_004df1f8 & 0x80) == 0) {
					local_18 = (float)(&lego::globals::g_InterfaceBackButton_bmp)[iVar4 * 2] + FLOAT_004dece8;
				}
				else {
					local_18 = (float)(&lego::globals::g_InterfaceBackButton_bmp)[iVar4 * 2] + FLOAT_004decd0;
				}
				local_18 = local_18 -
									 (float)(ulonglong)(uint)lego::globals::g_InterfaceBackButton_size.width * -0.5;
				fStack20 = ((float)(&lego::globals::g_InterfaceBackButton_bmp_pressed)[iVar4 * 2] +
									 FLOAT_004decd4) -
									 (float)(ulonglong)(uint)lego::globals::g_InterfaceBackButton_size.height * -0.5;
			}
			else {
				if ((ImageBMP *)objType == (ImageBMP *)0x0) {
					local_8 = 0x28;
				}
				else {
					local_8 = *(uint *)(objType + 8);
				}
				local_18 = *param_4;
				if ((FLAGS_004df1f8 & 0x80) == 0) {
					local_18 = FLOAT_004dece8;
				}
				uStack4 = 0;
				fStack20 = (float)(ulonglong)local_8 * 0.5 + param_4[1];
			}
			lego::front::Advisor_GetPoint2(DAT_004ded24,&local_10,&local_c);
			lego::front::Advisor_SetParameters
								(DAT_004ded24,PANEL__COUNT,local_10 + local_18,local_c + fStack20);
			lego::front::Advisor_SetCurrentAdvisor(DAT_004ded24,FLAGS_004df1f8 & 0x40);
			FLAGS_004df1f8 = FLAGS_004df1f8 & 0xffffffdf;
		}
	}
	return;
}



BOOL __cdecl FUN_0041c610(int menuIcon,int param_2,int param_3,int param_4,int param_5)
{
	int iVar1;
	
	iVar1 = INTMenuIcon_004ded00;
	if (param_4 == 0) {
		INTMenuIcon_004ded00 = 0x4a;
	}
	else {
		if ((FLAGS_004df1f8 & 0x1000) == 0) {
			if (INTMenuIcon_004ded00 == 0x4a) {
				if (param_5 != 0) goto LAB_0041c6aa;
				INTMenuIcon_004ded00 = menuIcon;
				DAT_004ded04 = param_2;
				DAT_004ded08 = param_3;
				if (menuIcon == 0x49) {
					FUN_0041c950(param_2,param_3,1);
					goto LAB_0041c6aa;
				}
			}
			else {
				if (INTMenuIcon_004ded00 != menuIcon) goto LAB_0041c6aa;
				if (menuIcon == 0x49) {
					if ((DAT_004ded04 == param_2) && (DAT_004ded08 == param_3)) {
						FUN_0041c950(param_2,param_3,1);
					}
					goto LAB_0041c6aa;
				}
			}
			FUN_0041c920(menuIcon,1);
		}
	}
LAB_0041c6aa:
	if (iVar1 == menuIcon) {
		if (menuIcon != 0x49) {
			return 1;
		}
		if ((DAT_004ded04 == param_2) && (DAT_004ded08 == param_3)) {
			return 1;
		}
	}
	return 0;
}



void __cdecl FUN_0041c6e0(uint menuIcon)
{
	BOOL BVar1;
	uint uVar2;
	
	uVar2 = UINT_ARRAY_004de60c[menuIcon];
	if (((uVar2 & 2) == 0) && (((byte)FLAGS_004df1f8 & 0x80) != 0)) {
		BVar1 = FUN_0041cf70(menuIcon);
		uVar2 = UINT_ARRAY_004de60c[menuIcon];
		if (BVar1 != 0) {
			UINT_ARRAY_004de60c[menuIcon] = uVar2 & 0xfffffffe;
			return;
		}
	}
	UINT_ARRAY_004de60c[menuIcon] = uVar2 | 1;
	return;
}



void __cdecl FUN_0041c730(int param_1,int param_2)
{
	uint *puVar1;
	BOOL BVar2;
	int iVar3;
	int iVar4;
	uint uVar5;
	void *pvVar6;
	
	if (param_1 == 1) {
		uVar5 = *(uint *)((int)lego::globals::g_SubmenuIcons_VehicleTypes2_TABLE + param_2 * 4);
		pvVar6 = lego::globals::g_SubmenuIcons_VehicleTypes2_TABLE;
		if (((uVar5 & 2) == 0) && (((byte)FLAGS_004df1f8 & 0x80) != 0)) {
			BVar2 = lego::game::Object_FindTeleporter_FUN_0041f030(OBJECT_VEHICLE,param_2);
			if ((BVar2 != 0) &&
				 (BVar2 = lego::game::Object_Dependencies_FUN_0040add0(OBJECT_VEHICLE,param_2,0), BVar2 != 0
				 )) {
				iVar3 = lego::game::Object_GetCostCrystal(OBJECT_VEHICLE,param_2,0);
				iVar4 = lego::game::Level_GetCrystalCount(1);
				if (iVar3 <= iVar4) {
					puVar1 = (uint *)((int)lego::globals::g_SubmenuIcons_VehicleTypes2_TABLE + param_2 * 4);
					*puVar1 = *puVar1 & 0xfffffffe;
					return;
				}
			}
			puVar1 = (uint *)((int)lego::globals::g_SubmenuIcons_VehicleTypes2_TABLE + param_2 * 4);
			*puVar1 = *puVar1 | 1;
			return;
		}
	}
	else {
		if (param_1 != 4) {
			return;
		}
		uVar5 = *(uint *)((int)lego::globals::g_SubmenuIcons_BuildingTypes2_TABLE + param_2 * 4);
		pvVar6 = lego::globals::g_SubmenuIcons_BuildingTypes2_TABLE;
		if (((uVar5 & 2) == 0) && (((byte)FLAGS_004df1f8 & 0x80) != 0)) {
			BVar2 = lego::game::Object_FindTeleporter_FUN_0041f030(OBJECT_BUILDING,param_2);
			if ((BVar2 != 0) &&
				 (BVar2 = lego::game::Object_Dependencies_FUN_0040add0(OBJECT_BUILDING,param_2,0),
				 BVar2 != 0)) {
				puVar1 = (uint *)((int)lego::globals::g_SubmenuIcons_BuildingTypes2_TABLE + param_2 * 4);
				*puVar1 = *puVar1 & 0xfffffffe;
				return;
			}
			puVar1 = (uint *)((int)lego::globals::g_SubmenuIcons_BuildingTypes2_TABLE + param_2 * 4);
			*puVar1 = *puVar1 | 1;
			return;
		}
	}
	*(uint *)((int)pvVar6 + param_2 * 4) = uVar5 | 1;
	return;
}



BOOL __cdecl FUN_0041c820(int param_1,BOOL param_2)
{
	TutorialFlags TVar1;
	
	if (param_1 == 0x49) {
		return 0;
	}
	if ((lego::globals::g_Game.flags1 & GAME1_LASERTRACKER) != GAME1_NONE) {
		return 1;
	}
	if (param_2 != 0) {
		TVar1 = lego::nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
		if ((TVar1 & 1) != TUTORIAL_NONE) {
			return ~UINT_ARRAY_004de60c[param_1] >> 2 & 1;
		}
	}
	return UINT_ARRAY_004de60c[param_1] & 1;
}



BOOL __cdecl FUN_0041c880(int param_1,int param_2,int param_3)
{
	TutorialFlags TVar1;
	
	if ((lego::globals::g_Game.flags1 & GAME1_LASERTRACKER) != GAME1_NONE) {
		return 1;
	}
	if (param_3 != 0) {
		TVar1 = lego::nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
		if ((TVar1 & 1) != TUTORIAL_NONE) {
			if (param_1 == 1) {
				return ~*(uint *)((int)lego::globals::g_SubmenuIcons_VehicleTypes2_TABLE + param_2 * 4) >> 2
							 & 1;
			}
			if (param_1 == 4) {
				return ~*(uint *)((int)lego::globals::g_SubmenuIcons_BuildingTypes2_TABLE + param_2 * 4) >>
							 2 & 1;
			}
		}
	}
	if (param_1 == 1) {
		return *(uint *)((int)lego::globals::g_SubmenuIcons_VehicleTypes2_TABLE + param_2 * 4) & 1;
	}
	if (param_1 == 4) {
		return *(uint *)((int)lego::globals::g_SubmenuIcons_BuildingTypes2_TABLE + param_2 * 4) & 1;
	}
	return 0;
}



void __cdecl FUN_0041c920(int param_1,int param_2)
{
	if (param_2 != 0) {
		UINT_ARRAY_004de60c[param_1] = UINT_ARRAY_004de60c[param_1] | 8;
		return;
	}
	UINT_ARRAY_004de60c[param_1] = UINT_ARRAY_004de60c[param_1] & 0xfffffff7;
	return;
}



void __cdecl FUN_0041c950(int param_1,int param_2,int param_3)
{
	uint uVar1;
	void *pvVar2;
	
	pvVar2 = lego::globals::g_SubmenuIcons_VehicleTypes2_TABLE;
	if ((param_1 == 1) || (pvVar2 = lego::globals::g_SubmenuIcons_BuildingTypes2_TABLE, param_1 == 4))
	{
		uVar1 = *(uint *)((int)pvVar2 + param_2 * 4);
		if (param_3 != 0) {
			*(uint *)((int)pvVar2 + param_2 * 4) = uVar1 | 8;
			return;
		}
		*(uint *)((int)pvVar2 + param_2 * 4) = uVar1 & 0xfffffff7;
	}
	return;
}



BOOL __cdecl FUN_0041c990(int param_1)
{
	return UINT_ARRAY_004de60c[param_1] & 8;
}



BOOL __cdecl FUN_0041c9a0(int param_1,int param_2)
{
	if (param_1 == 1) {
		return *(uint *)((int)lego::globals::g_SubmenuIcons_VehicleTypes2_TABLE + param_2 * 4) & 8;
	}
	if (param_1 == 4) {
		return *(uint *)((int)lego::globals::g_SubmenuIcons_BuildingTypes2_TABLE + param_2 * 4) & 8;
	}
	return 0;
}



ImageBMP * __cdecl FUN_0041c9e0(int param_1)
{
	BOOL BVar1;
	
	BVar1 = FUN_0041c820(param_1,0);
	if (BVar1 != 0) {
		return *(ImageBMP **)(&DAT_004de120 + param_1 * 4);
	}
	BVar1 = FUN_0041c990(param_1);
	if (BVar1 != 0) {
		return *(ImageBMP **)(&DAT_004de248 + param_1 * 4);
	}
	return *(ImageBMP **)(&DAT_004ddff8 + param_1 * 4);
}



ImageBMP * __cdecl lego::front::Interface_GetBuildImageByObjectType(ObjectType objType,int objIndex)
{
	BOOL BVar1;
	
	BVar1 = FUN_0041c880(objType,objIndex,0);
	if (BVar1 == 0) {
		BVar1 = FUN_0041c9a0(objType,objIndex);
		if (BVar1 == 0) {
			if (objType == OBJECT_VEHICLE) {
				return globals::g_InterfaceBuildImages_Vehicles_normal_TABLE[objIndex];
			}
			if (objType == OBJECT_BUILDING) {
				return globals::g_InterfaceBuildImages_Buildings_normal_TABLE[objIndex];
			}
		}
		else {
			if (objType == OBJECT_VEHICLE) {
				return globals::g_InterfaceBuildImages_Vehicles_disabled_TABLE[objIndex];
			}
			if (objType == OBJECT_BUILDING) {
				return globals::g_InterfaceBuildImages_Buildings_disabled_TABLE[objIndex];
			}
		}
	}
	else {
		if (objType == OBJECT_VEHICLE) {
			return globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE[objIndex];
		}
		if (objType == OBJECT_BUILDING) {
			return globals::g_InterfaceBuildImages_Buildings_pressed_TABLE[objIndex];
		}
	}
	return (ImageBMP *)0x0;
}



ImageBMP * __cdecl
lego::front::Interface_GetObjectBuildImage(ObjectType objType,int objIndex,BOOL param_3)
{
	if (param_3 == 0) {
		switch(objType) {
		case OBJECT_VEHICLE:
			return globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE[objIndex];
		case OBJECT_MINIFIGURE:
			return PTRImageBMP_004de124;
		case OBJECT_BUILDING:
			return globals::g_InterfaceBuildImages_Buildings_pressed_TABLE[objIndex];
		case OBJECT_ELECTRICFENCE:
			return PTRImageBMP_004de158;
		case OBJECT_PATH:
			return PTRImageBMP_004de134;
		}
	}
	else {
		switch(objType) {
		case OBJECT_VEHICLE:
			return globals::g_InterfaceBuildImages_Vehicles_normal_TABLE[objIndex];
		case OBJECT_MINIFIGURE:
			return PTRImageBMP_004ddffc;
		case OBJECT_BUILDING:
			return globals::g_InterfaceBuildImages_Buildings_normal_TABLE[objIndex];
		case OBJECT_ELECTRICFENCE:
			return PTRImageBMP_004de030;
		case OBJECT_PATH:
			return PTRImageBMP_004de00c;
		}
	}
	return (ImageBMP *)0x0;
}



void __cdecl
lego::front::MenuIcon_SetDat_004decd8_004decdc(int menuIcon,ObjectType objType,int objIndex)
{
	if (menuIcon == 0x49) {
		ObjectType_004decd8 = objType;
		INTObjectIndex_004decdc = objIndex;
		return;
	}
	if (menuIcon == 5) {
		ObjectType_004decd8 = OBJECT_PATH;
		INTObjectIndex_004decdc = 0;
		return;
	}
	if (menuIcon == 0xe) {
		ObjectType_004decd8 = OBJECT_ELECTRICFENCE;
		INTObjectIndex_004decdc = 0;
	}
	return;
}



void __cdecl FUN_0041cc10(Point2F *point,uint unkWidth,uint unkHeight)
{
	Rect2F_004ded0c.x = point->x;
	Rect2F_004ded0c.y = point->y;
	Rect2F_004ded0c.width = (float)(ulonglong)unkWidth;
	Rect2F_004ded0c.height = (float)(ulonglong)unkHeight;
	return;
}



void __cdecl FUN_0041cc60(Rect2F *rect)
{
	Point2F local_28;
	Point2F local_20 [4];
	
	if ((lego::globals::g_Game.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) {
		local_28.x = rect->x - 1.0;
		local_28.y = rect->y - 1.0;
		local_20[1].y = (rect->height + rect->y) - -1.0;
		local_20[0].x = (rect->x + rect->width) - -1.0;
		local_20[0].y = local_28.y;
		local_20[1].x = local_20[0].x;
		local_20[2].x = local_28.x;
		local_20[2].y = local_20[1].y;
		local_20[3].x = local_28.x;
		local_20[3].y = local_28.y;
		lego::draw::Draw_LineListEx(&local_28,local_20,4,0.0,1.0,0.0,DrawEffect_None);
		local_28.x = rect->x - 2.0;
		local_28.y = rect->y - 2.0;
		local_20[0].x = (rect->x + rect->width) - -2.0;
		local_20[1].y = (rect->height + rect->y) - -2.0;
		local_20[0].y = local_28.y;
		local_20[1].x = local_20[0].x;
		local_20[2].x = local_28.x;
		local_20[2].y = local_20[1].y;
		local_20[3].x = local_28.x;
		local_20[3].y = local_28.y;
		lego::draw::Draw_LineListEx(&local_28,local_20,4,0.0,1.0,0.0,DrawEffect_None);
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_0041cdd0(LiveObject *liveObj)
{
	uint uVar1;
	LiveObject **ppLVar2;
	ObjectStatsFlags1 OVar3;
	uint uVar4;
	
	if (INT_004deccc == 0xc) {
		uVar1 = Game_GetNumSelectedUnits();
		ppLVar2 = Game_GetSelectedUnits();
		for (uVar4 = uVar1; uVar4 != 0; uVar4 = uVar4 - 1) {
			if (liveObj == *ppLVar2) {
				if (uVar1 == 1) {
					OVar3 = LiveObject_GetStatsFlags1(liveObj);
					if (((OVar3 & STATS1_CROSSLAND) == STATS1_NONE) &&
						 ((*(byte *)&liveObj->flags4 & 0x40) == 0)) {
						FUN_0041b200(0xb,(Point2I *)0x0);
					}
					else {
						FUN_0041b200(10,(Point2I *)0x0);
					}
				}
				else {
					FUN_0041e680();
				}
			}
			ppLVar2 = ppLVar2 + 1;
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_0041ce50(LiveObject *liveObj)
{
	uint uVar1;
	LiveObject **ppLVar2;
	uint uVar3;
	
	if (((INT_004deccc == 10) || (INT_004deccc == 0x12)) || (INT_004deccc == 0xb)) {
		uVar1 = Game_GetNumSelectedUnits();
		ppLVar2 = Game_GetSelectedUnits();
		for (uVar3 = uVar1; uVar3 != 0; uVar3 = uVar3 - 1) {
			if (liveObj->drivenObject == *ppLVar2) {
				if (uVar1 == 1) {
					FUN_0041b200(0xc,(Point2I *)0x0);
				}
				else {
					FUN_0041e680();
				}
			}
			ppLVar2 = ppLVar2 + 1;
		}
	}
	return;
}



void __cdecl FUN_0041ceb0(Point2I *position)
{
	if (((INT_004deccc == 7) && (Point2I_004decc4.x == position->x)) &&
		 (Point2I_004decc4.y == position->y)) {
		FUN_0041e680();
		return;
	}
	return;
}



void __cdecl FUN_0041cee0(Point2I *position)
{
	if ((((INT_004deccc == 1) || (INT_004deccc == 4)) && (Point2I_004decc4.x == position->x)) &&
		 (Point2I_004decc4.y == position->y)) {
		FUN_0041e680();
		return;
	}
	return;
}



void __cdecl FUN_0041cf10(Point2I *position)
{
	if (((INT_004deccc == 5) && (Point2I_004decc4.x == position->x)) &&
		 (Point2I_004decc4.y == position->y)) {
		FUN_0041e680();
		return;
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_0041cf40(LiveObject *liveObj)
{
	BOOL BVar1;
	
	if (globals::g_Game.viewMode != VIEW_FIRSTPERSON) {
		BVar1 = LiveObject_Check_FUN_004528d0(liveObj,(uint *)0x0);
		if (BVar1 != 0) {
			FUN_0041e680();
			return;
		}
	}
	return;
}



BOOL __cdecl FUN_0041cf70(uint menuIcon)
{
	TerrainType TVar1;
	LiveFlags5 LVar2;
	uint uVar3;
	LiveObject *liveObj;
	ObjectStatsFlags3 OVar4;
	ObjectStatsFlags1 OVar5;
	int iVar6;
	uint uVar7;
	BOOL BVar8;
	ObjectStatsFlags2 OVar9;
	float10 fVar10;
	ObjectType objType;
	code *callback;
	ToolType toolType;
	undefined4 uVar11;
	int iVar12;
	ObjectType local_8;
	int local_4;
	
	liveObj = lego::game::Game_GetPrimarySelectedObject();
	uVar3 = menuIcon;
	switch(menuIcon) {
	case 0:
		if (DAT_004decfc == 0xf) {
			return 0;
		}
		break;
	case 1:
		lego::game::Object_GetObjectByName("Barracks",&local_8,(int *)&menuIcon,(Container **)0x0);
		BVar8 = lego::game::Object_FindTeleporter_FUN_0041f030(OBJECT_MINIFIGURE,0);
		if (BVar8 == 0) {
			return 0;
		}
		BVar8 = lego::game::Object_Dependencies_FUN_0040add0(OBJECT_MINIFIGURE,0,0);
		if (BVar8 == 0) {
			return 0;
		}
		BVar8 = lego::game::Object_DoOxygenCheck_FUN_0043c4c0(OBJECT_MINIFIGURE,0,local_8,menuIcon);
		if (BVar8 == 0) {
			return 0;
		}
		break;
	case 5:
		BVar8 = FUN_00408fd0(&Point2I_004decc4);
		if (BVar8 != 0) {
			return 0;
		}
		BVar8 = lego::game::Level_IsBlockPowerPath(&Point2I_004decc4);
		if (BVar8 != 0) {
			return 0;
		}
		objType = OBJECT_PATH;
		goto LAB_0041d8d5;
	case 6:
		BVar8 = lego::game::Level_IsBlockPowerPath(&Point2I_004decc4);
		if (BVar8 == 0) {
			return 0;
		}
		break;
	case 7:
		BVar8 = FUN_00408fd0(&Point2I_004decc4);
		if (BVar8 != 0) {
			return 0;
		}
		if ((lego::globals::g_Game.level)->blocks
				[((lego::globals::g_Game.level)->dimensions).width * Point2I_004decc4.y + Point2I_004decc4.x
				].terrain == TERRAIN_LAVA) {
			return 0;
		}
		break;
	case 9:
		BVar8 = lego::game::Game_IsAnyUnitsSelected();
		if (BVar8 == 0) break;
		toolType = TOOL_SPADE;
		goto LAB_0041d17f;
	case 0xb:
		BVar8 = FUN_0041f670(&Point2I_004decc4);
		if (BVar8 == 0) {
			return 0;
		}
		BVar8 = lego::game::Game_IsAnyUnitsSelected();
		if (BVar8 == 0) {
			BVar8 = FUN_0041f2f0(&Point2I_004decc4);
			if (BVar8 == 0) {
				return 0;
			}
		}
		else {
			BVar8 = lego::game::Game_SelectedUnits_UnkEquippedTool_FUN_00403110(TOOL_DRILL);
			if ((BVar8 == 0) && (BVar8 = FUN_0041f1e0(), BVar8 == 0)) {
				return 0;
			}
			BVar8 = FUN_00431960(Point2I_004decc4.x,Point2I_004decc4.y,0);
			if (BVar8 == 0) {
				return 0;
			}
		}
		break;
	case 0xc:
		BVar8 = FUN_0041f670(&Point2I_004decc4);
		if (BVar8 == 0) {
			return 0;
		}
		BVar8 = lego::game::Level_GetBlockFlags1_20(Point2I_004decc4.x,Point2I_004decc4.y);
		if (BVar8 != 0) {
			return 0;
		}
		BVar8 = lego::game::Level_GetBlockFlags1_c0(Point2I_004decc4.x,Point2I_004decc4.y);
		if (BVar8 != 0) {
			return 0;
		}
		BVar8 = lego::game::LiveObject_FUN_00432950
											((LiveObject *)0x0,Point2I_004decc4.x,Point2I_004decc4.y);
		if (BVar8 == 0) {
			return 0;
		}
		BVar8 = lego::game::Game_IsAnyUnitsSelected();
		if (BVar8 == 0) {
			BVar8 = FUN_0041f330(&Point2I_004decc4);
			if (BVar8 == 0) {
				return 0;
			}
		}
		else {
			BVar8 = lego::game::Game_SelectedUnits_UnkEquippedTool_FUN_00403110(TOOL_HAMMER);
			if ((BVar8 == 0) && (BVar8 = FUN_0041f1e0(), BVar8 == 0)) {
				return 0;
			}
			iVar12 = FUN_004319e0(Point2I_004decc4.x,Point2I_004decc4.y);
			if (iVar12 == 0) {
				return 0;
			}
		}
		break;
	case 0xd:
		BVar8 = FUN_0041f670(&Point2I_004decc4);
		if (BVar8 == 0) {
			return 0;
		}
		TVar1 = (lego::globals::g_Game.level)->blocks
						[((lego::globals::g_Game.level)->dimensions).width * Point2I_004decc4.y +
						 Point2I_004decc4.x].terrain;
		if (TVar1 == TERRAIN_IMMOVABLE) {
			return 0;
		}
		if (TVar1 == TERRAIN_RECHARGESEAM) {
			return 0;
		}
		BVar8 = lego::game::Level_GetBlockFlags1_10Not8(Point2I_004decc4.x,Point2I_004decc4.y);
		if (BVar8 == 0) {
			return 0;
		}
		uVar7 = lego::game::Level_GetBlockFlags1_8000000(&Point2I_004decc4);
		if (uVar7 != 0) {
			return 0;
		}
		BVar8 = FUN_0041f1e0();
		if (BVar8 == 0) {
			return 0;
		}
		BVar8 = FUN_0041f270(8);
		if (BVar8 != 0) break;
		BVar8 = FUN_0041f220(2,0);
		if (BVar8 == 0) {
			return 0;
		}
		uVar11 = 0x20;
		goto LAB_0041d599;
	case 0xe:
		uVar7 = FUN_00432450(Point2I_004decc4.x,Point2I_004decc4.y);
		if (uVar7 != 0) {
			return 0;
		}
		iVar12 = FUN_0040d170(Point2I_004decc4.x,Point2I_004decc4.y);
		if (iVar12 == 0) {
			return 0;
		}
		BVar8 = 0;
		objType = OBJECT_ELECTRICFENCE;
LAB_0041d8d5:
		BVar8 = lego::game::Object_Dependencies_FUN_0040add0(objType,BVar8,BVar8);
		if (BVar8 == 0) {
			return 0;
		}
		break;
	case 0x10:
		if (((lego::globals::g_Game.level)->blocks
				 [((lego::globals::g_Game.level)->dimensions).width * Point2I_004decc4.y +
					Point2I_004decc4.x].flags1 & (BLOCK1_UNK_100000|BLOCK1_UNK_40000000)) == BLOCK1_NONE) {
			return 0;
		}
		uVar7 = FUN_00432f60((int *)&Point2I_004decc4);
		if (uVar7 != 0) {
			return 0;
		}
		BVar8 = lego::game::Level_IsBlockPowerPath(&Point2I_004decc4);
		if (BVar8 != 0) {
			return 0;
		}
		BVar8 = lego::game::Level_BlockCheck_FUN_004329d0(Point2I_004decc4.x,Point2I_004decc4.y,1);
		if (BVar8 != 0) {
			return 0;
		}
		break;
	case 0x14:
	case 0x15:
		iVar12 = 0;
		callback = FUN_0041f400;
		goto LAB_0041d969;
	case 0x16:
	case 0x17:
		if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
			 (liveObj->carriedObjects[0]->objType == OBJECT_BARRIER)) {
			return 0;
		}
		OVar4 = lego::game::LiveObject_GetStatsFlags3(liveObj);
		if (((OVar4 & STATS3_CARRYVEHICLES) != STATS3_NONE) &&
			 (iVar12 = FUN_00440080((int *)liveObj), iVar12 == 0)) {
			return 0;
		}
		iVar12 = 0;
		callback = lego::game::LiveObject_FUN_0041f3a0;
		goto LAB_0041d969;
	case 0x18:
		iVar12 = 2;
		uVar11 = 8;
		OVar4 = lego::game::LiveObject_GetStatsFlags3(liveObj);
		if ((OVar4 & STATS3_NEEDSPILOT) == STATS3_NONE) {
			OVar5 = lego::game::LiveObject_GetStatsFlags1(liveObj);
			if ((OVar5 & STATS1_CROSSLAND) != STATS1_NONE) {
				OVar5 = lego::game::LiveObject_GetStatsFlags1(liveObj);
				if ((OVar5 & STATS1_CROSSWATER) == STATS1_NONE) {
					iVar12 = 4;
					uVar11 = 0x10;
				}
				else {
					iVar12 = 1;
					uVar11 = 4;
				}
			}
		}
		else {
			iVar12 = 1;
			uVar11 = 4;
		}
		OVar4 = lego::game::LiveObject_GetStatsFlags3(liveObj);
		if (((OVar4 & STATS3_GETINATLAND) == STATS3_NONE) || ((*(byte *)&liveObj->flags4 & 0x40) != 0))
		{
			if ((iVar12 == 2) && ((*(byte *)&liveObj->flags4 & 0x40) == 0)) {
				return 0;
			}
		}
		else {
			iVar6 = FUN_0043a100((undefined4 *)liveObj,(uint *)0x0);
			if (iVar6 == 0) {
				return 0;
			}
		}
		if ((*(byte *)&liveObj->flags2 & 0x10) != 0) {
			return 0;
		}
		BVar8 = FUN_0041f270(iVar12);
		if (BVar8 != 0) break;
		BVar8 = FUN_0041f220(2,0);
		if (BVar8 == 0) {
			return 0;
		}
		goto LAB_0041d599;
	case 0x19:
		if ((*(byte *)&liveObj->flags1 & 1) != 0) {
			return 0;
		}
		OVar5 = lego::game::LiveObject_GetStatsFlags1(liveObj);
		if ((OVar5 & STATS1_CANBEDRIVEN) == STATS1_NONE) {
			return 0;
		}
		OVar5 = lego::game::LiveObject_GetStatsFlags1(liveObj);
		if ((((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) &&
				(iVar12 = FUN_0043a0d0(liveObj,(uint *)0x0), iVar12 == 0)) &&
			 ((*(byte *)&liveObj->flags4 & 0x40) == 0)) {
			return 0;
		}
		break;
	case 0x1a:
		if ((*(byte *)&liveObj->flags1 & 1) != 0) {
			return 0;
		}
		OVar5 = lego::game::LiveObject_GetStatsFlags1(liveObj);
		if ((OVar5 & STATS1_CANBEDRIVEN) == STATS1_NONE) {
			return 0;
		}
		if ((*(byte *)&liveObj->flags4 & 0x40) != 0) {
			return 0;
		}
		iVar12 = FUN_00438ca0(liveObj,1);
		if (iVar12 == 0) {
			return 0;
		}
		break;
	case 0x1d:
		if ((*(byte *)&liveObj->flags3 & 2) == 0) {
			return 0;
		}
		if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
			return 0;
		}
		break;
	case 0x1e:
		toolType = TOOL_DRILL;
LAB_0041d17f:
		BVar8 = lego::game::Game_SelectedUnits_UnkEquippedTool_FUN_00403110(toolType);
		if ((BVar8 == 0) && (BVar8 = FUN_0041f1e0(), BVar8 == 0)) {
			return 0;
		}
		break;
	case 0x1f:
		iVar12 = 0;
		callback = lego::game::LiveObject_IsEnergyLessThan100;
		goto LAB_0041d969;
	case 0x21:
		iVar12 = 6;
		callback = lego::game::LiveObject_HasToolEquipped_2;
LAB_0041d969:
		BVar8 = lego::game::DoSelectedUnits_Callback(callback,iVar12);
		if (BVar8 == 0) {
			return 0;
		}
		break;
	case 0x22:
	case 0x23:
		OVar9 = lego::game::LiveObject_GetStatsFlags2(liveObj);
		if ((OVar9 & STATS2_SELFPOWERED) != STATS2_NONE) {
			return 0;
		}
		if ((liveObj->flags3 & LIVEOBJ3_UNK_20000000) == LIVEOBJ3_NONE) {
			return 0;
		}
		break;
	case 0x24:
		BVar8 = lego::game::DoSelectedUnits_Callback(lego::game::LiveObject_IsHealthLessThan100,0);
		if (BVar8 == 0) {
			return 0;
		}
		BVar8 = FUN_0041f270(0x10);
		if (BVar8 != 0) break;
		BVar8 = FUN_0041f220(2,0);
		if (BVar8 == 0) {
			return 0;
		}
		uVar11 = 0x40;
LAB_0041d599:
		BVar8 = FUN_0041f1a0(uVar11);
		if (BVar8 == 0) {
			return 0;
		}
		break;
	case 0x25:
		BVar8 = lego::game::LiveObject_IsSmallTeleporter(liveObj);
		if (((BVar8 == 0) && (BVar8 = lego::game::LiveObject_IsBigTeleporter(liveObj), BVar8 == 0)) &&
			 (BVar8 = lego::game::LiveObject_IsWaterTeleporter(liveObj), BVar8 == 0)) {
			return 0;
		}
		break;
	case 0x26:
		BVar8 = lego::game::LiveObject_CanSpawnCarryableObject(liveObj,OBJECT_POWERCRYSTAL,0);
		if (BVar8 == 0) {
			return 0;
		}
	case 0x27:
		BVar8 = lego::game::LiveObject_CanSpawnCarryableObject(liveObj,OBJECT_ORE,0);
		if (BVar8 == 0) {
			return 0;
		}
		break;
	case 0x29:
		lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_8,&local_4);
		if ((liveObj->drivenObject != (LiveObject *)0x0) &&
			 (iVar12 = lego::game::LiveObject_FUN_00431cd0
													 (liveObj->drivenObject,local_8,local_4,local_8,local_4,1), iVar12 == 0))
		{
			return 0;
		}
		OVar4 = lego::game::LiveObject_GetStatsFlags3(liveObj);
		if (((((OVar4 & STATS3_CARRYVEHICLES) != STATS3_NONE) &&
				 ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
				(liveObj->carriedObjects[0] != (LiveObject *)0x0)) &&
			 (iVar12 = lego::game::LiveObject_FUN_00431cd0
													 (liveObj->carriedObjects[0],local_8,local_4,local_8,local_4,1),
			 iVar12 == 0)) {
			return 0;
		}
		OVar5 = lego::game::LiveObject_GetStatsFlags1(liveObj);
		if (((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) && ((*(byte *)&liveObj->flags4 & 0x40) == 0)) {
			return 0;
		}
		break;
	case 0x2d:
		if ((liveObj == lego::globals::g_Game.objectFP) &&
			 ((lego::globals::g_Game.cameraFP)->field_14 == 0)) {
			return 0;
		}
		break;
	case 0x2e:
		if ((liveObj == lego::globals::g_Game.objectFP) &&
			 ((lego::globals::g_Game.cameraFP)->field_14 == 1)) {
			return 0;
		}
		break;
	case 0x30:
		goto switchD_0041cf8b_caseD_30;
	case 0x31:
		iVar12 = TOOL_DRILL;
		goto LAB_0041d741;
	case 0x32:
		iVar12 = TOOL_SPADE;
		goto LAB_0041d741;
	case 0x33:
		iVar12 = TOOL_HAMMER;
		goto LAB_0041d741;
	case 0x34:
		iVar12 = TOOL_SPANNER;
		goto LAB_0041d741;
	case 0x35:
		iVar12 = TOOL_LASER;
		goto LAB_0041d741;
	case 0x36:
		iVar12 = TOOL_PUSHERGUN;
		goto LAB_0041d741;
	case 0x37:
		iVar12 = TOOL_FREEZERGUN;
		goto LAB_0041d741;
	case 0x38:
		iVar12 = TOOL_BIRDSCARER;
LAB_0041d741:
		BVar8 = lego::game::DoSelectedUnits_Callback
											(lego::game::LiveObject_DoesNotHaveToolEquipped,iVar12);
		if (BVar8 == 0) {
			return 0;
		}
switchD_0041cf8b_caseD_30:
		BVar8 = FUN_0041f1e0();
		if (BVar8 == 0) {
			return 0;
		}
		break;
	case 0x39:
		BVar8 = FUN_0041f1a0(0xfc);
		if (BVar8 == 0) {
			return 0;
		}
		LVar2 = liveObj->flags5_3f0;
		if (((((LVar2 & 1) != LIVEOBJ5_NONE) && ((LVar2 & 2) != LIVEOBJ5_NONE)) &&
				(((LVar2 & 4) != LIVEOBJ5_NONE &&
				 (((LVar2 & LIVEOBJ5_UNK_8) != LIVEOBJ5_NONE && ((LVar2 & 0x10) != LIVEOBJ5_NONE)))))) &&
			 ((LVar2 & 0x20) != LIVEOBJ5_NONE)) {
			return 0;
		}
		break;
	case 0x3a:
		BVar8 = FUN_0041f650(4);
		if (BVar8 != 0) {
			return 0;
		}
		uVar11 = 0x10;
		goto LAB_0041d829;
	case 0x3b:
		BVar8 = FUN_0041f650(0x10);
		if (BVar8 != 0) {
			return 0;
		}
		uVar11 = 0x40;
		goto LAB_0041d829;
	case 0x3c:
		BVar8 = FUN_0041f650(0x20);
		if (BVar8 != 0) {
			return 0;
		}
		uVar11 = 0x80;
		goto LAB_0041d829;
	case 0x3d:
		BVar8 = FUN_0041f650(1);
		if (BVar8 != 0) {
			return 0;
		}
		uVar11 = 4;
LAB_0041d829:
		iVar12 = FUN_0041f1a0(uVar11);
joined_r0x0041d86f:
		if (iVar12 == 0) {
			return 0;
		}
		fVar10 = lego::game::Level_GetTrainTime();
		if ((ushort)((ushort)(fVar10 < (float10)liveObj->elapsedTime1) << 8 |
								(ushort)(fVar10 == (float10)liveObj->elapsedTime1) << 0xe) == 0) {
			return 0;
		}
		break;
	case 0x3e:
		BVar8 = FUN_0041f650(2);
		if (BVar8 != 0) {
			return 0;
		}
		uVar11 = 8;
		goto LAB_0041d865;
	case 0x3f:
		BVar8 = FUN_0041f650(8);
		if (BVar8 != 0) {
			return 0;
		}
		uVar11 = 0x20;
LAB_0041d865:
		iVar12 = FUN_0041f1a0(uVar11);
		goto joined_r0x0041d86f;
	case 0x40:
		uVar7 = lego::game::Object_GetLevels(liveObj->objType,liveObj->objIndex);
		if (uVar7 <= liveObj->objLevel + 1) {
			return 0;
		}
		if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
			return 0;
		}
		goto switchD_0041cf8b_caseD_30;
	case 0x41:
		BVar8 = lego::game::LiveObject_GetBuildingUpgradeCost(liveObj,(uint *)0x0);
		if (BVar8 == 0) {
			return 0;
		}
		break;
	case 0x42:
		BVar8 = FUN_0041f160();
		if (BVar8 == 0) {
			return 0;
		}
		BVar8 = FUN_00438b70(liveObj,1);
		if (((BVar8 != 0) || (BVar8 = FUN_00438b70(liveObj,0), BVar8 != 0)) ||
			 (BVar8 = FUN_00438b70(liveObj,2), BVar8 != 0)) break;
		goto LAB_0041da08;
	case 0x43:
		BVar8 = FUN_0041f160();
		if (BVar8 == 0) {
			return 0;
		}
		iVar12 = 1;
		goto LAB_0041da0a;
	case 0x44:
		BVar8 = FUN_0041f160();
		if (BVar8 == 0) {
			return 0;
		}
		iVar12 = 0;
		goto LAB_0041da0a;
	case 0x45:
		BVar8 = FUN_0041f160();
		if (BVar8 == 0) {
			return 0;
		}
		iVar12 = 2;
		goto LAB_0041da0a;
	case 0x46:
		BVar8 = FUN_0041f160();
		if (BVar8 == 0) {
			return 0;
		}
LAB_0041da08:
		iVar12 = 3;
LAB_0041da0a:
		BVar8 = FUN_00438b70(liveObj,iVar12);
		if (BVar8 == 0) {
			return 0;
		}
	}
	if (((byte)lego::globals::g_Game.flags3 & 6) == 0) {
		if (((byte)lego::globals::g_Game.flags3 & 0x18) == 0) {
			if ((((byte)lego::globals::g_Game.flags3 & 0x60) != 0) && (uVar3 != 0)) {
				if ((int)uVar3 < 0x1d) {
					return 0;
				}
				if (0x1e < (int)uVar3) {
					return 0;
				}
			}
		}
		else {
			if (uVar3 != 0) {
				if ((int)uVar3 < 0x14) {
					return 0;
				}
				if (0x15 < (int)uVar3) {
					return 0;
				}
			}
		}
	}
	else {
		if ((uVar3 != 0) && (((int)uVar3 < 0x1b || (0x1c < (int)uVar3)))) {
			return 0;
		}
	}
	return 1;
}



BOOL __cdecl lego::game::Game_DoAction__0041dbd0(int menuIcon)
{
	ObjectType OVar1;
	LiveObject *pLVar2;
	BOOL BVar3;
	SurfaceMap *pSVar4;
	ObjectStatsFlags1 OVar5;
	LevelData *pLVar6;
	int iVar7;
	ObjectStatsFlags3 OVar8;
	GameFlags3 GVar9;
	int iVar10;
	int index;
	undefined4 newObjLevel;
	
	pLVar2 = Game_GetPrimarySelectedObject();
	BVar3 = FUN_0041c820(menuIcon,1);
	if (BVar3 != 0) {
		return 0;
	}
	switch(menuIcon) {
	case 0:
		if (0xf < INT_004deccc) {
			if (INT_004deccc < 0x12) {
				FUN_0041b200(9,(Point2I *)0x0);
				return 1;
			}
			if (INT_004deccc == 0x12) {
				OVar5 = LiveObject_GetStatsFlags1(pLVar2);
				if (((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) && ((*(byte *)&pLVar2->flags4 & 0x40) == 0))
				{
					FUN_0041b200(0xb,(Point2I *)0x0);
					return 1;
				}
				FUN_0041b200(10,(Point2I *)0x0);
				return 1;
			}
		}
		break;
	case 1:
		Game_TryPlaceObject(OBJECT_MINIFIGURE,0);
		FUN_0041e680();
		return 1;
	case 2:
		FUN_0041b200(0x13,(Point2I *)0x0);
		return 1;
	case 3:
		FUN_0041b200(0x14,(Point2I *)0x0);
		return 1;
	case 4:
		FUN_0041b200(0x15,(Point2I *)0x0);
		return 1;
	case 5:
	case 7:
		FUN_00409230(&Point2I_004decc4);
		FUN_0041e680();
		return 1;
	case 6:
		ai::AITask_DoClearTypeAction(&Point2I_004decc4,MESSAGE_CLEARREMOVEPATH_COMPLETE);
		pLVar6 = GetLevel();
		iVar7 = (pLVar6->dimensions).width * Point2I_004decc4.y + Point2I_004decc4.x;
		pLVar6 = GetLevel();
		pLVar6->blocks[iVar7].flags1 = pLVar6->blocks[iVar7].flags1 & ~BLOCK1_POWERPATH;
		Level_UpdateBlockSurfaceUnk(globals::g_Game.level,Point2I_004decc4.x,Point2I_004decc4.y);
		FUN_0041e680();
		return 1;
	case 9:
		ai::AITask_FUN_00401f40(AITASK_CLEAR,(LiveObject *)0x0,&Point2I_004decc4);
		FUN_0041e680();
		return 1;
	case 0xb:
		ai::AITask_DoDig_AtPosition(&Point2I_004decc4,0,1);
		goto LAB_0041de87;
	case 0xc:
		ai::AITask_DoReinforce_AtPosition(&Point2I_004decc4);
		goto LAB_0041de87;
	case 0xd:
		ai::AITask_DoDynamite_AtPosition(&Point2I_004decc4,0);
LAB_0041de87:
		iVar7 = Point2I_004decc4.x;
		iVar10 = Point2I_004decc4.y;
		pSVar4 = GetSurfaceMap();
		INT_004df1f0 = SurfaceMap_FUN_0044f800(pSVar4,iVar7,iVar10);
		FUN_0041e680();
		return 1;
	case 0xe:
		ai::AITask_DoElecFence(&Point2I_004decc4);
		FUN_0041e680();
		return 1;
	case 0xf:
		FUN_00402a10(&Point2I_004decc4,0);
		INT_004df1f0 = 0;
		index = 4;
		iVar7 = Point2I_004decc4.x;
		iVar10 = Point2I_004decc4.y;
		pSVar4 = GetSurfaceMap();
		SurfaceMap_FUN_0044f7a0(pSVar4,iVar7,iVar10,index);
		FUN_0041e680();
		return 1;
	case 0x10:
		if (((globals::g_Game.level)->blocks
				 [((globals::g_Game.level)->dimensions).width * Point2I_004decc4.y + Point2I_004decc4.x].
				 flags1 & BLOCK1_UNK_40000000) != BLOCK1_NONE) {
			FUN_00409080(&Point2I_004decc4);
			FUN_0041e680();
			return 1;
		}
		FUN_00409530(&Point2I_004decc4);
		FUN_0041e680();
		return 1;
	case 0x11:
		Level_AddMessageAction(MESSAGE_CLEARSELECT,0,0,(Point2I *)0x0);
		Level_AddMessageAction(MESSAGE_SELECT,pLVar2,0,(Point2I *)0x0);
		FUN_0041b200(9,(Point2I *)0x0);
		return 1;
	case 0x12:
		Level_AddMessageAction(MESSAGE_CLEARSELECT,0,0,(Point2I *)0x0);
		Level_AddMessageAction(MESSAGE_SELECT,pLVar2,0,(Point2I *)0x0);
		OVar5 = LiveObject_GetStatsFlags1(pLVar2);
		if (((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) && ((*(byte *)&pLVar2->flags4 & 0x40) == 0)) {
			FUN_0041b200(0xb,(Point2I *)0x0);
			return 1;
		}
LAB_0041df4c:
		FUN_0041b200(10,(Point2I *)0x0);
		return 1;
	case 0x13:
		Level_AddMessageAction(MESSAGE_CLEARSELECT,0,0,(Point2I *)0x0);
		Level_AddMessageAction(MESSAGE_SELECT,pLVar2,0,(Point2I *)0x0);
		FUN_0041b200(0xd,(Point2I *)0x0);
		return 1;
	case 0x14:
		OVar8 = LiveObject_GetStatsFlags3(pLVar2);
		if ((OVar8 & STATS3_CARRYVEHICLES) != STATS3_NONE) {
			ai::AITask_DoFindLoad(pLVar2);
			return 1;
		}
		GVar9 = GAME3_LOADVEHICLE;
		if ((globals::g_Game.flags3 & GAME3_LOADVEHICLE) != GAME3_NONE) {
			FUN_00435950();
			return 1;
		}
		goto LAB_0041e4b7;
	case 0x15:
		GVar9 = GAME3_PICKUPOBJECT;
		if ((globals::g_Game.flags3 & GAME3_PICKUPOBJECT) != GAME3_NONE) {
			FUN_00435950();
			return 1;
		}
		goto LAB_0041e4b7;
	case 0x16:
	case 0x17:
		DoSelectedUnits_Callback(LiveObject_FUN_0041f5f0,0);
		return 1;
	case 0x18:
		Game_UnselectAllUnits();
		ai::AITask_DoFindDriver_Target(pLVar2);
		FUN_0041e680();
		return 1;
	case 0x19:
		FUN_00440470(pLVar2,0);
		FUN_0041e680();
		return 1;
	case 0x1a:
		FUN_00440470(pLVar2,1);
		FUN_0041e680();
		return 1;
	case 0x1b:
		GVar9 = GAME3_UNK_2;
		if ((globals::g_Game.flags3 & GAME3_UNK_2) != GAME3_NONE) {
			FUN_00435950();
			return 1;
		}
		goto LAB_0041e4b7;
	case 0x1c:
		GVar9 = GAME3_UNK_4;
		if ((globals::g_Game.flags3 & GAME3_UNK_4) != GAME3_NONE) {
			FUN_00435950();
			return 1;
		}
		goto LAB_0041e4b7;
	case 0x1d:
		GVar9 = GAME3_UNK_40;
		goto LAB_0041e4a1;
	case 0x1e:
		GVar9 = GAME3_UNK_20;
LAB_0041e4a1:
		if (((byte)globals::g_Game.flags3 & (byte)GVar9) != 0) {
			FUN_00435950();
			return 1;
		}
LAB_0041e4b7:
		FUN_00435950();
		globals::g_Game.flags3 = globals::g_Game.flags3 | GVar9;
		return 1;
	case 0x1f:
		DoSelectedUnits_Callback(LiveObject_GoEatIfEnergyIsLessThan100,0);
		FUN_0041e680();
		return 1;
	case 0x20:
	case 0x28:
	case 0x29:
	case 0x2a:
		DoSelectedUnits_Callback(LiveObject_FUN_0041f520,0);
		FUN_0041e680();
		return 1;
	case 0x21:
		DoSelectedUnits_Callback(LiveObject_FUN_0041f770,0);
		FUN_0041e680();
		return 1;
	case 0x22:
		BVar3 = 1;
		goto LAB_0041e51b;
	case 0x23:
		BVar3 = 0;
LAB_0041e51b:
		LiveObject_SetFlag3_80000000(pLVar2,BVar3);
		break;
	case 0x24:
		DoSelectedUnits_Callback(LiveObject_GoRepairIfHealthLessThan100,0);
		FUN_0041e680();
		return 1;
	case 0x25:
		BVar3 = LiveObject_IsSmallTeleporter(pLVar2);
		if (BVar3 != 0) {
			globals::g_Game.placeDestSmallTeleporter = pLVar2;
			FUN_0041e680();
			return 1;
		}
		BVar3 = LiveObject_IsBigTeleporter(pLVar2);
		if (BVar3 != 0) {
			globals::g_Game.placeDestBigTeleporter = pLVar2;
			FUN_0041e680();
			return 1;
		}
		BVar3 = LiveObject_IsWaterTeleporter(pLVar2);
		if (BVar3 != 0) {
			globals::g_Game.placeDestWaterTeleporter = pLVar2;
			FUN_0041e680();
			return 1;
		}
		break;
	case 0x26:
		FUN_0043a910(pLVar2,OBJECT_POWERCRYSTAL,0,0);
		FUN_0041e680();
		return 1;
	case 0x27:
		FUN_0043a910(pLVar2,OBJECT_ORE,0,0);
		FUN_0041e680();
		return 1;
	case 0x2c:
		Level_AddMessageAction(MESSAGE_TOPVIEW,0,0,(Point2I *)0x0);
		OVar1 = pLVar2->objType;
		if (OVar1 == OBJECT_VEHICLE) {
			OVar5 = LiveObject_GetStatsFlags1(pLVar2);
			if (((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) && ((*(byte *)&pLVar2->flags4 & 0x40) == 0)) {
				FUN_0041b200(0xb,(Point2I *)0x0);
				return 1;
			}
			goto LAB_0041df4c;
		}
		if (OVar1 == OBJECT_MINIFIGURE) {
			FUN_0041b200(9,(Point2I *)0x0);
			return 1;
		}
		if (OVar1 == OBJECT_BUILDING) {
			FUN_0041b200(0xd,(Point2I *)0x0);
			return 1;
		}
		break;
	case 0x2d:
		BVar3 = 0;
		goto LAB_0041deb2;
	case 0x2e:
		BVar3 = 1;
LAB_0041deb2:
		Level_AddMessageAction(MESSAGE_FIRSTPERSON,0,BVar3,(Point2I *)0x0);
		FUN_0041b200(0xf,(Point2I *)0x0);
		return 1;
	case 0x2f:
		LiveObject_FUN_00425c80(pLVar2);
		FUN_0041e680();
		return 1;
	case 0x30:
		FUN_0041b200(0x10,(Point2I *)0x0);
		return 1;
	case 0x31:
		DoSelectedUnits_Callback(LiveObject_GoGetToolIfNotEquipped,TOOL_DRILL);
		FUN_0041e680();
		return 1;
	case 0x32:
		DoSelectedUnits_Callback(LiveObject_GoGetToolIfNotEquipped,TOOL_SPADE);
		FUN_0041e680();
		return 1;
	case 0x33:
		DoSelectedUnits_Callback(LiveObject_GoGetToolIfNotEquipped,TOOL_HAMMER);
		FUN_0041e680();
		return 1;
	case 0x34:
		DoSelectedUnits_Callback(LiveObject_GoGetToolIfNotEquipped,TOOL_SPANNER);
		FUN_0041e680();
		return 1;
	case 0x35:
		DoSelectedUnits_Callback(LiveObject_GoGetToolIfNotEquipped,TOOL_LASER);
		FUN_0041e680();
		return 1;
	case 0x36:
		DoSelectedUnits_Callback(LiveObject_GoGetToolIfNotEquipped,TOOL_PUSHERGUN);
		FUN_0041e680();
		return 1;
	case 0x37:
		DoSelectedUnits_Callback(LiveObject_GoGetToolIfNotEquipped,TOOL_FREEZERGUN);
		FUN_0041e680();
		return 1;
	case 0x38:
		DoSelectedUnits_Callback(LiveObject_GoGetToolIfNotEquipped,TOOL_BIRDSCARER);
		FUN_0041e680();
		return 1;
	case 0x39:
		FUN_0041b200(0x11,(Point2I *)0x0);
		return 1;
	case 0x3a:
	case 0x3b:
	case 0x3c:
	case 0x3d:
	case 0x3e:
	case 0x3f:
		switch(menuIcon) {
		case 0x3a:
			menuIcon = TRAINED_DRIVER;
			break;
		case 0x3b:
			menuIcon = TRAINED_REPAIR;
			break;
		case 0x3c:
			menuIcon = TRAINED_SCANNER;
			break;
		case 0x3d:
			menuIcon = TRAINED_PILOT;
			break;
		case 0x3e:
			menuIcon = TRAINED_SAILOR;
			break;
		case 0x3f:
			menuIcon = TRAINED_DYNAMITE;
		}
		pLVar2 = (LiveObject *)FUN_00439110(pLVar2,(Point2F *)0x0,menuIcon);
		if (pLVar2 == (LiveObject *)0x0) {
			return 0;
		}
		ai::AITask_DoTrain_Target(pLVar2,menuIcon,1);
		FUN_0041e680();
		return 1;
	case 0x40:
		ai::AITask_DoUpgrade(pLVar2,0);
		FUN_0041e680();
		return 1;
	case 0x41:
		LiveObject_FUN_00438ab0(pLVar2);
		FUN_0041e680();
		return 1;
	case 0x42:
		FUN_0041b200(0x12,(Point2I *)0x0);
		return 1;
	case 0x43:
		newObjLevel = 1;
		goto LAB_0041e4f4;
	case 0x44:
		newObjLevel = 0;
		goto LAB_0041e4f4;
	case 0x45:
		newObjLevel = 2;
		goto LAB_0041e4f4;
	case 0x46:
		newObjLevel = 3;
LAB_0041e4f4:
		ai::AITask_DoUpgrade(pLVar2,newObjLevel);
		pLVar2->elapsedTime2 = 0.0;
		FUN_0041e680();
		return 1;
	case 0x47:
		if ((globals::g_Game.flags3 & GAME3_UNK_1) != GAME3_NONE) {
			FUN_00435950();
			FUN_0041e680();
			return 1;
		}
		FUN_00435950();
		globals::g_Game.flags3 = globals::g_Game.flags3 | GAME3_UNK_1;
		FUN_0040e710();
		FUN_0041e680();
		return 1;
	case 0x48:
		Level_AddMessageAction(MESSAGE_CLEARSELECT,0,0,(Point2I *)0x0);
		FUN_0041e680();
		return 1;
	case 0x49:
		BVar3 = FUN_0041c880(ObjectType_004decd8,INTObjectIndex_004decdc,1);
		if (BVar3 != 0) {
			return 0;
		}
		Game_TryPlaceObject(ObjectType_004decd8,INTObjectIndex_004decdc);
		if (ObjectType_004decd8 == OBJECT_BUILDING) {
			return 1;
		}
	}
	FUN_0041e680();
	return 1;
}



void __cdecl FUN_0041e680(void)
{
	lego::game::Level_AddMessageAction(MESSAGE_CLEARSELECT,0,0,(Point2I *)0x0);
	FUN_0041b200(0,(Point2I *)0x0);
	return;
}



void __cdecl lego::nerps::NERPs_SetIconFlag4__0041e6a0(int menuIcon,BOOL state)
{
	if (state != 0) {
		UINT_ARRAY_004de60c[menuIcon] = UINT_ARRAY_004de60c[menuIcon] | 4;
		return;
	}
	UINT_ARRAY_004de60c[menuIcon] = UINT_ARRAY_004de60c[menuIcon] & 0xfffffffb;
	return;
}



void __cdecl
lego::nerps::NERPs_FlashSubmenuIcon_internal___0041e6d0(ObjectType objType,int objIndex,BOOL state)
{
	uint uVar1;
	void *pvVar2;
	
	pvVar2 = globals::g_SubmenuIcons_VehicleTypes2_TABLE;
	if ((objType == OBJECT_VEHICLE) ||
		 (pvVar2 = globals::g_SubmenuIcons_BuildingTypes2_TABLE, objType == OBJECT_BUILDING)) {
		uVar1 = *(uint *)((int)pvVar2 + objIndex * 4);
		if (state != 0) {
			*(uint *)((int)pvVar2 + objIndex * 4) = uVar1 | 4;
			return;
		}
		*(uint *)((int)pvVar2 + objIndex * 4) = uVar1 & 0xfffffffb;
	}
	return;
}



LiveObject * __cdecl lego::game::Game_GetFirstSelectedObject(void)
{
	return (LiveObject *)
				 (-(uint)(globals::g_SelectedUnits_COUNT != 0) & (uint)globals::g_SelectedUnits_TABLE[0]);
}



uint __cdecl FUN_0041e720(int param_1,uint param_2)
{
	uint uVar1;
	
	uVar1 = UINT_ARRAY_004de9ac[param_1];
	UINT_ARRAY_004de9ac[param_1] = param_2;
	return uVar1;
}



uint __cdecl FUN_0041e740(int param_1)
{
	return UINT_ARRAY_004de9ac[param_1];
}



undefined4 __cdecl
lego::nerps::NERPs_SetSubmenuIconClicked_internal___0041e750
					(ObjectType objType,int objIndex,BOOL state)
{
	undefined4 uVar1;
	
	uVar1 = 0;
	if (objType == OBJECT_VEHICLE) {
		uVar1 = *(undefined4 *)((int)globals::g_SubmenuIcons_VehicleTypes_TABLE + objIndex * 4);
		*(BOOL *)((int)globals::g_SubmenuIcons_VehicleTypes_TABLE + objIndex * 4) = state;
		return uVar1;
	}
	if (objType == OBJECT_BUILDING) {
		uVar1 = *(undefined4 *)((int)globals::g_SubmenuIcons_BuildingTypes_TABLE + objIndex * 4);
		*(BOOL *)((int)globals::g_SubmenuIcons_BuildingTypes_TABLE + objIndex * 4) = state;
	}
	return uVar1;
}



undefined4 __cdecl lego::front::SubMenu_GetBuildingVehicleIcon(ObjectType objType,int objIndex)
{
	if (objType == OBJECT_VEHICLE) {
		return *(undefined4 *)((int)globals::g_SubmenuIcons_VehicleTypes_TABLE + objIndex * 4);
	}
	if (objType == OBJECT_BUILDING) {
		return *(undefined4 *)((int)globals::g_SubmenuIcons_BuildingTypes_TABLE + objIndex * 4);
	}
	return 0;
}



BOOL __cdecl FUN_0041e7c0(int menuIcon,BOOL setFlag60)
{
	uint uVar1;
	
	uVar1 = FLAGS_004df1f8 | 0x20;
	if (setFlag60 != 0) {
		uVar1 = FLAGS_004df1f8 | 0x60;
	}
	FLAGS_004df1f8 = uVar1;
	DAT_004ded24 = FUN_0041e800(menuIcon);
	INT_004ded28 = menuIcon;
	return 1;
}



undefined4 __cdecl FUN_0041e800(undefined4 menuIcon)
{
	switch(menuIcon) {
	case 0:
		return 4;
	case 1:
	case 2:
	case 5:
	case 6:
	case 9:
	case 0xb:
	case 0xc:
	case 0xe:
	case 0x14:
	case 0x16:
	case 0x17:
	case 0x18:
	case 0x1f:
	case 0x22:
	case 0x24:
	case 0x29:
	case 0x2a:
	case 0x2b:
	case 0x2c:
	case 0x2e:
	case 0x2f:
	case 0x31:
	case 0x32:
	case 0x3a:
	case 0x3b:
	case 0x43:
	case 0x44:
		return 5;
	default:
		return 3;
	}
}



undefined4 __cdecl FUN_0041e8c0(ObjectType objType,int objIndex)
{
	TutorialFlags TVar1;
	
	TVar1 = lego::nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
	if ((TVar1 & TUTORIAL_UNK_4) != TUTORIAL_NONE) {
		return (&DAT_004ded34)[objIndex + objType * 0xf];
	}
	return 1;
}



void __cdecl FUN_0041e900(uint param_1,uint param_2,uint param_3,uint param_4,float param_5)
{
	FLOAT_004dece0 = (float)(ulonglong)param_3;
	FLOAT_004dece4 = (float)(ulonglong)param_4;
	FLOAT_004dece8 = (float)(ulonglong)param_1;
	FLOAT_004decec = (float)(ulonglong)param_2;
	FLOAT_004decf0 = param_5 * 0.04;
	return;
}



void __cdecl FUN_0041e980_internal(int param_1,Point2I *position)
{
	if (((FLAGS_004df1f8 & 0x80) == 0) || (INT_004deccc != param_1)) {
		FLAGS_004df1f8 = FLAGS_004df1f8 & 0xffffff7f | 0x100;
		lego::snd::Audio_Play_FUN_00465260(SFX_INTERFACESLIDEOFFSCREEN,0);
	}
	else {
		INT_004deccc = param_1;
		if (position == (Point2I *)0x0) {
			DAT_004decfc = param_1;
			return;
		}
		Point2I_004decc4.x = position->x;
		Point2I_004decc4.y = position->y;
	}
	if (position != (Point2I *)0x0) {
		Point2I_004decf4.x = position->x;
		Point2I_004decf4.y = position->y;
	}
	DAT_004decfc = param_1;
	return;
}



void __cdecl FUN_0041e9f0(float param_1)
{
	if ((FLAGS_004df1f8 & 0x80) == 0) {
		if ((FLAGS_004df1f8 & 0x100) == 0) {
			if ((FLAGS_004df1f8 & 4) != 0) {
				FLOAT_004decd0 = FLOAT_004decd0 - param_1 * FLOAT_004decf0;
				if ((ushort)((ushort)(FLOAT_004decd0 < FLOAT_004dece8) << 8 |
										(ushort)(FLOAT_004decd0 == FLOAT_004dece8) << 0xe) != 0) {
					FLAGS_004df1f8 = FLAGS_004df1f8 | 0x80;
					FLOAT_004decd0 = FLOAT_004dece8;
				}
			}
		}
		else {
			FLOAT_004decd0 = param_1 * FLOAT_004decf0 + FLOAT_004decd0;
			if ((INT_004deccc == 0x16) && (((byte)PanelData_ARRAY_00501110[8].flags & 2) != 0)) {
				FUN_0045adc0(8);
				FUN_0045aeb0(6,1,0);
				FLOAT_004decd0 = FLOAT_004dece0;
			}
			if (FLOAT_004dece0 <= FLOAT_004decd0) {
				FLAGS_004df1f8 = FLAGS_004df1f8 & 0xfffffeff;
				FLOAT_004decd0 = FLOAT_004dece0;
				lego::snd::Audio_Play_FUN_00465260(SFX_INTERFACESLIDEONSCREEN,0);
				if (DAT_004decfc == 0x16) {
					FLAGS_004df1f8 = FLAGS_004df1f8 & 0xfffffffb | 0x80;
					FUN_0045adc0(8);
					lego::unk::Lego_UnsetFlag6_00501860();
					FLAGS_00501860 = FLAGS_00501860 | 2;
				}
				else {
					if (DAT_004decfc == 0x17) {
						FLAGS_004df1f8 = FLAGS_004df1f8 & 0xfffffffb | 0x80;
						FUN_0045adc0(0xb);
						lego::globals::g_Game.flags3 = lego::globals::g_Game.flags3 | GAME3_UNK_1;
						FUN_0040e710();
					}
					else {
						FLAGS_004df1f8 = FLAGS_004df1f8 | 4;
					}
				}
				Point2I_004decc4.x = Point2I_004decf4.x;
				Point2I_004decc4.y = Point2I_004decf4.y;
				INT_004deccc = DAT_004decfc;
				return;
			}
		}
	}
	return;
}



void __cdecl FUN_0041eb60(int param_1,int param_2)
{
	ObjectType *pOVar1;
	int y;
	uint uVar2;
	int iVar3;
	longlong lVar4;
	float *in_stack_0000000c;
	char *msg;
	
	iVar3 = 0;
	if (lego::globals::g_Game.objTeleportQueue_COUNT != 0) {
		pOVar1 = lego::globals::g_Game.objTeleportQueueTypes_TABLE;
		uVar2 = lego::globals::g_Game.objTeleportQueue_COUNT;
		do {
			if ((*pOVar1 == param_1) && (pOVar1[0x14] == param_2)) {
				iVar3 = iVar3 + 1;
			}
			pOVar1 = pOVar1 + 1;
			uVar2 = uVar2 - 1;
		} while (uVar2 != 0);
	}
	if (iVar3 != 0) {
		msg = "%i";
		lVar4 = __ftol((float10)in_stack_0000000c[1]);
		y = (int)lVar4 + 3;
		lVar4 = __ftol((float10)*in_stack_0000000c);
		lego::image::Font_PrintF(DAT_004ddd58,(int)lVar4 + 3,y,msg,iVar3);
	}
	return;
}



void __cdecl FUN_0041ebd0(float param_1,float param_2)
{
	BOOL BVar1;
	ImageBMP *image;
	int iVar2;
	uint uVar3;
	longlong lVar4;
	char *msg;
	char *pcVar5;
	int local_10;
	uint local_c;
	Point2F local_8;
	
	if ((UINT_004a3b5c != ObjectType_004decd8) || (DAT_004ddd50 != INTObjectIndex_004decdc)) {
		FUN_0041ed90();
		UINT_004a3b5c = ObjectType_004decd8;
		DAT_004ddd50 = INTObjectIndex_004decdc;
	}
	if (((FLAGS_004df1f8 & 0x800) != 0) &&
		 (lego::game::Object_Dependencies_Getter_FUN_0040aec0
								(ObjectType_004decd8,INTObjectIndex_004decdc,0,&local_10,&local_c), local_c != 0)) {
		local_8.x = param_1 - 15.0;
		uVar3 = 0;
		local_8.y = param_2;
		if (local_c != 0) {
			do {
				if (uVar3 == 0) {
					if (lego::globals::g_InterfaceDependencies_Minus_bmp == (ImageBMP *)0x0) {
LAB_0041ecb4:
						local_8.x = local_8.x - 20.0;
					}
					else {
						local_8.x = local_8.x - (float)lego::globals::g_InterfaceDependencies_Minus_bmp->width;
						lego::image::Image_DisplayScaled
											(lego::globals::g_InterfaceDependencies_Minus_bmp,(Rect2F *)0x0,&local_8,
											 (Size2F *)0x0);
					}
				}
				else {
					if (lego::globals::g_InterfaceDependencies_Plus_bmp == (ImageBMP *)0x0) goto LAB_0041ecb4;
					local_8.x = local_8.x - (float)lego::globals::g_InterfaceDependencies_Plus_bmp->width;
					lego::image::Image_DisplayScaled
										(lego::globals::g_InterfaceDependencies_Plus_bmp,(Rect2F *)0x0,&local_8,
										 (Size2F *)0x0);
				}
				iVar2 = uVar3 * 0x10;
				BVar1 = lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
													(FUN_0040ae70,(LiveObject *)(local_10 + iVar2));
				image = lego::front::Interface_GetObjectBuildImage
													(*(ObjectType *)(local_10 + iVar2),*(int *)(local_10 + 4 + iVar2),
													 (uint)(BVar1 != 0));
				if (image == (ImageBMP *)0x0) {
					local_8.x = local_8.x - 40.0;
				}
				else {
					local_8.x = local_8.x - (float)image->width;
					lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,&local_8,(Size2F *)0x0);
					if ((*(int *)(local_10 + 0xc + iVar2) != 0) &&
						 (iVar2 = *(int *)(local_10 + 8 + iVar2), iVar2 != 0)) {
						pcVar5 = lego::globals::g_Game.UpgradeNames_TABLE[iVar2];
						msg = "%s";
						lVar4 = __ftol((float10)local_8.y);
						iVar2 = (int)lVar4 + 3;
						lVar4 = __ftol((float10)local_8.x);
						lego::image::Font_PrintF(DAT_004ddd58,(int)lVar4 + 3,iVar2,msg,pcVar5);
					}
				}
				uVar3 = uVar3 + 1;
			} while (uVar3 < local_c);
		}
	}
	return;
}



void __cdecl FUN_0041ed90(void)
{
	FLOAT_004df1ec = 25.0;
	FLAGS_004df1f8 = FLAGS_004df1f8 & 0xfffff7ff;
	return;
}



BOOL __cdecl
FUN_0041edb0(uint param_1,uint param_2,float param_3,float param_4,undefined4 *param_5,
						undefined4 *param_6,undefined4 *param_7)
{
	int iVar1;
	float fVar2;
	float fVar3;
	ImageBMP *pIVar4;
	uint uVar5;
	uint uVar6;
	uint local_40;
	int local_3c;
	float local_38;
	undefined4 uStack52;
	uint local_30;
	undefined4 uStack44;
	uint local_28;
	undefined4 uStack36;
	uint local_20;
	undefined4 uStack28;
	uint local_18;
	undefined4 uStack20;
	uint local_10;
	undefined4 uStack12;
	uint local_8;
	undefined4 uStack4;
	
	if (((FLAGS_004df1f8 & 0x800) != 0) &&
		 (lego::game::Object_Dependencies_Getter_FUN_0040aec0
								(ObjectType_004decd8,INTObjectIndex_004decdc,0,&local_3c,&local_40), local_40 != 0))
	{
		local_38 = param_3 - 15.0;
		fVar3 = (float)(ulonglong)param_1;
		if ((local_38 <= fVar3) &&
			 ((((ushort)((ushort)(fVar3 < local_38 - -15.0) << 8 |
									(ushort)(fVar3 == local_38 - -15.0) << 0xe) != 0 &&
				 (fVar2 = (float)(ulonglong)param_2, param_4 <= fVar2)) &&
				((ushort)((ushort)(fVar2 < param_4 - -40.0) << 8 | (ushort)(fVar2 == param_4 - -40.0) << 0xe
								 ) != 0)))) {
			*param_5 = 0x14;
			return 1;
		}
		uStack52 = 0;
		uVar6 = 0;
		if (local_40 != 0) {
			do {
				pIVar4 = lego::globals::g_InterfaceDependencies_Minus_bmp;
				if (uVar6 != 0) {
					pIVar4 = lego::globals::g_InterfaceDependencies_Plus_bmp;
				}
				if (pIVar4 == (ImageBMP *)0x0) {
					local_30 = 0x14;
					uVar5 = 0x28;
				}
				else {
					local_30 = pIVar4->width;
					uVar5 = pIVar4->height;
				}
				uStack44 = 0;
				local_38 = local_38 - (float)(ulonglong)local_30;
				if ((local_38 <= fVar3) &&
					 (fVar2 = local_38 + (float)(ulonglong)local_30,
					 (ushort)((ushort)(fVar3 < fVar2) << 8 | (ushort)(fVar3 == fVar2) << 0xe) != 0)) {
					local_28 = param_2;
					uStack36 = 0;
					fVar2 = (float)(ulonglong)param_2;
					if ((param_4 <= fVar2) &&
						 (uStack28 = 0, local_20 = uVar5,
						 (ushort)((ushort)(fVar2 < (float)(ulonglong)uVar5 + param_4) << 8 |
										 (ushort)(fVar2 == (float)(ulonglong)uVar5 + param_4) << 0xe) != 0)) {
						*param_5 = 0x14;
						return 1;
					}
				}
				pIVar4 = lego::front::Interface_GetObjectBuildImage
													 (*(ObjectType *)(uVar6 * 0x10 + local_3c),
														*(int *)(uVar6 * 0x10 + 4 + local_3c),0);
				if (pIVar4 == (ImageBMP *)0x0) {
					local_18 = 0x28;
					uVar5 = 0x28;
				}
				else {
					local_18 = pIVar4->width;
					uVar5 = pIVar4->height;
				}
				uStack20 = 0;
				local_38 = local_38 - (float)(ulonglong)local_18;
				if ((local_38 <= fVar3) &&
					 (fVar2 = local_38 + (float)(ulonglong)local_18,
					 (ushort)((ushort)(fVar3 < fVar2) << 8 | (ushort)(fVar3 == fVar2) << 0xe) != 0)) {
					local_10 = param_2;
					uStack12 = 0;
					fVar2 = (float)(ulonglong)param_2;
					if ((param_4 <= fVar2) &&
						 (uStack4 = 0, local_8 = uVar5,
						 (ushort)((ushort)(fVar2 < (float)(ulonglong)uVar5 + param_4) << 8 |
										 (ushort)(fVar2 == (float)(ulonglong)uVar5 + param_4) << 0xe) != 0)) {
						iVar1 = uVar6 * 0x10 + local_3c;
						*param_5 = *(undefined4 *)(uVar6 * 0x10 + local_3c);
						*param_6 = *(undefined4 *)(iVar1 + 4);
						*param_7 = *(undefined4 *)(iVar1 + 8);
						return 1;
					}
				}
				uVar6 = uVar6 + 1;
				if (local_40 <= uVar6) {
					return 0;
				}
			} while( true );
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Object_FindTeleporter_FUN_0041f030(ObjectType objType,int objIndex)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	ObjectType local_18;
	int local_14;
	char *local_10;
	VehicleData *local_c;
	CreatureData *local_8;
	CreatureData *local_4;
	
	local_14 = 0;
	local_10 = (char *)0x0;
	local_18 = OBJECT_NONE;
	local_c = (VehicleData *)0x0;
	local_8 = (CreatureData *)0x0;
	local_4 = (CreatureData *)0x0;
	OVar1 = Object_GetStatsFlags2(objType,objIndex);
	if ((OVar1 & STATS2_USESMALLTELEPORTER) == STATS2_NONE) {
		if ((OVar1 & STATS2_USEBIGTELEPORTER) == STATS2_NONE) {
			if ((OVar1 & STATS2_USEWATERTELEPORTER) == STATS2_NONE) {
				if ((OVar1 & STATS2_USELEGOMANTELEPORTER) == STATS2_NONE) {
					return 1;
				}
				local_10 = (char *)0x80000000;
			}
			else {
				local_10 = (char *)0x40;
			}
		}
		else {
			local_10 = &DAT_00000020;
		}
	}
	else {
		local_10 = &DAT_00000010;
	}
	BVar2 = unk::DoLiveObjCallbacks_True_FUN_00437a70(LiveObject_FUN_0041f0c0,(LiveObject *)&local_18)
	;
	return BVar2;
}



BOOL __cdecl lego::game::LiveObject_FUN_0041f0c0(LiveObject *liveObj,ObjectType *param_2)
{
	BOOL BVar1;
	ObjectStatsFlags1 OVar2;
	ObjectStatsFlags2 OVar3;
	
	if ((liveObj->objType == OBJECT_BUILDING) &&
		 (BVar1 = LiveObject_CheckCondition_FUN_00438870(liveObj,0), BVar1 == 0)) {
		return 0;
	}
	if ((param_2[5] & 1) != 0) {
		if (liveObj->objType != *param_2) {
			return 0;
		}
		if (liveObj->objIndex != param_2[1]) {
			return 0;
		}
	}
	if (((param_2[5] & 2) != 0) && ((param_2[4] & liveObj->flags5_3f0) == LIVEOBJ5_NONE)) {
		return 0;
	}
	if ((param_2[2] != OBJECT_NONE) &&
		 (OVar2 = LiveObject_GetStatsFlags1(liveObj), (param_2[2] & OVar2) == STATS1_NONE)) {
		return 0;
	}
	if ((param_2[3] != OBJECT_NONE) &&
		 (OVar3 = LiveObject_GetStatsFlags2(liveObj), (param_2[3] & OVar3) == STATS2_NONE)) {
		return 0;
	}
	return 1;
}



BOOL __cdecl FUN_0041f160(void)
{
	BOOL BVar1;
	ObjectType local_18;
	int local_14;
	char *local_10;
	VehicleData *local_c;
	CreatureData *local_8;
	CreatureData *local_4;
	
	local_14 = 0;
	local_10 = (char *)0x0;
	local_18 = OBJECT_NONE;
	local_8 = (CreatureData *)0x0;
	local_c = (VehicleData *)0x2;
	local_4 = (CreatureData *)0x0;
	BVar1 = lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
										(lego::game::LiveObject_FUN_0041f0c0,(LiveObject *)&local_18);
	return BVar1;
}



BOOL __cdecl FUN_0041f1a0(VehicleData *param_1)
{
	BOOL BVar1;
	ObjectType local_18;
	int local_14;
	char *local_10;
	VehicleData *local_c;
	CreatureData *local_8;
	CreatureData *local_4;
	
	local_14 = 0;
	local_10 = (char *)0x0;
	local_8 = (CreatureData *)0x0;
	local_18 = OBJECT_NONE;
	local_4 = (CreatureData *)0x0;
	local_c = param_1;
	BVar1 = lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
										(lego::game::LiveObject_FUN_0041f0c0,(LiveObject *)&local_18);
	return BVar1;
}



BOOL __cdecl FUN_0041f1e0(void)
{
	BOOL BVar1;
	ObjectType local_18;
	int local_14;
	char *local_10;
	VehicleData *local_c;
	CreatureData *local_8;
	CreatureData *local_4;
	
	local_14 = 0;
	local_c = (VehicleData *)0x0;
	local_18 = OBJECT_NONE;
	local_8 = (CreatureData *)0x0;
	local_10 = (char *)0x100000;
	local_4 = (CreatureData *)0x0;
	BVar1 = lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
										(lego::game::LiveObject_FUN_0041f0c0,(LiveObject *)&local_18);
	return BVar1;
}



BOOL __cdecl FUN_0041f220(ObjectType param_1,int param_2)
{
	BOOL BVar1;
	ObjectType local_18;
	int local_14;
	char *local_10;
	VehicleData *local_c;
	CreatureData *local_8;
	CreatureData *local_4;
	
	local_10 = (char *)0x0;
	local_c = (VehicleData *)0x0;
	local_8 = (CreatureData *)0x0;
	local_4 = (CreatureData *)0x1;
	local_18 = param_1;
	local_14 = param_2;
	BVar1 = lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
										(lego::game::LiveObject_FUN_0041f0c0,(LiveObject *)&local_18);
	return BVar1;
}



BOOL __cdecl FUN_0041f270(CreatureData *param_1)
{
	BOOL BVar1;
	ObjectType local_18;
	int local_14;
	char *local_10;
	VehicleData *local_c;
	CreatureData *local_8;
	CreatureData *local_4;
	
	local_14 = 0;
	local_10 = (char *)0x0;
	local_c = (VehicleData *)0x0;
	local_4 = (CreatureData *)0x2;
	local_18 = OBJECT_NONE;
	local_8 = param_1;
	BVar1 = lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
										(lego::game::LiveObject_FUN_0041f0c0,(LiveObject *)&local_18);
	return BVar1;
}



BOOL __cdecl lego::game::LiveObject_FUN_0041f2c0(LiveObject *liveObj,uint *param_2)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_FUN_004326a0(liveObj,*param_2,param_2[1],0,0);
	return (uint)(BVar1 != 0);
}



BOOL __cdecl FUN_0041f2f0(LiveObject *param_1)
{
	BOOL BVar1;
	
	BVar1 = lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
										(lego::game::LiveObject_FUN_0041f2c0,param_1);
	return BVar1;
}



BOOL __cdecl lego::game::LiveObject_FUN_0041f310(LiveObject *liveObj,Point2I *position)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_FUN_00432950(liveObj,position->x,position->y);
	return (uint)(BVar1 != 0);
}



BOOL __cdecl FUN_0041f330(LiveObject *param_1)
{
	BOOL BVar1;
	
	BVar1 = lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
										(lego::game::LiveObject_FUN_0041f310,param_1);
	return BVar1;
}



BOOL __cdecl lego::game::DoSelectedUnits_Callback(undefined *callback,int lpContext)
{
	uint uVar1;
	LiveObject **ppLVar2;
	int iVar3;
	uint uVar4;
	
	uVar1 = Game_GetNumSelectedUnits();
	ppLVar2 = Game_GetSelectedUnits();
	uVar4 = 0;
	if (uVar1 == 0) {
		return 0;
	}
	do {
		iVar3 = (*(code *)callback)(*ppLVar2,lpContext);
		if (iVar3 != 0) {
			return 1;
		}
		uVar4 = uVar4 + 1;
		ppLVar2 = ppLVar2 + 1;
	} while (uVar4 < uVar1);
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_0041f3a0(LiveObject *liveObj)
{
	if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
		 ((liveObj->flags1 & LIVEOBJ1_UNK_2000) == LIVEOBJ1_NONE)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_IsEnergyLessThan100(LiveObject *liveObj)
{
	if (liveObj->energy < 100.0) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_IsHealthLessThan100(LiveObject *liveObj)
{
	if (liveObj->health < 100.0) {
		return 1;
	}
	return 0;
}



BOOL __cdecl FUN_0041f400(LiveObject *liveObj)
{
	ObjectStatsFlags3 OVar1;
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	int *out_x;
	int *out_y;
	int local_14;
	int local_10;
	Vector3F local_c;
	
	OVar1 = lego::game::LiveObject_GetStatsFlags3(liveObj);
	if ((OVar1 & STATS3_CARRYVEHICLES) == STATS3_NONE) {
		if (liveObj->objType == OBJECT_MINIFIGURE) {
			if ((((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) &&
					((liveObj->flags3 & 0x20) != LIVEOBJ3_NONE)) &&
				 ((liveObj->flags3 & 0x40) != LIVEOBJ3_NONE)) {
				return 1;
			}
		}
		else {
			if (((liveObj->flags3 & 0x20) != LIVEOBJ3_NONE) && ((liveObj->flags3 & 0x40) != LIVEOBJ3_NONE)
				 ) {
				uVar5 = liveObj->field_328;
				uVar4 = lego::game::LiveObject_GetMaxCarry(liveObj);
				if (uVar4 <= uVar5) {
					uVar5 = lego::game::LiveObject_GetMaxCarry(liveObj);
				}
				if (liveObj->numCarriedObjects < uVar5) {
					return 1;
				}
			}
		}
	}
	else {
		if ((((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) &&
				((liveObj->flags4 & LIVEOBJ4_UNK_10000) == LIVEOBJ4_NONE)) &&
			 (cont = lego::game::LiveObject_GetDepositNull(liveObj), cont != (Container *)0x0)) {
			lego::res::Container_GetPosition(cont,(Container *)0x0,&local_c);
			out_y = &local_10;
			out_x = &local_14;
			surfMap = lego::game::GetSurfaceMap();
			BVar2 = lego::game::SurfaceMap_ToBlockCoordinatesNoZ(surfMap,local_c.x,local_c.y,out_x,out_y);
			if ((BVar2 != 0) &&
				 (iVar3 = lego::game::LiveObject_FUN_00431cd0
														((LiveObject *)0x0,local_14,local_10,local_14,local_10,1), iVar3 != 0))
			{
				return 1;
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_0041f520(LiveObject *liveObj)
{
	liveObj->health = -1.0;
	liveObj->flags4 = liveObj->flags4 | 8;
	return 0;
}



BOOL __cdecl lego::game::LiveObject_GoEatIfEnergyIsLessThan100(LiveObject *liveObj)
{
	if (liveObj->energy < 100.0) {
		LiveObject_GoEat_unk(liveObj);
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_GoRepairIfHealthLessThan100(LiveObject *liveObj)
{
	if (liveObj->health < 100.0) {
		ai::AITask_DoRepair_Target(liveObj,0);
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_DoesNotHaveToolEquipped(LiveObject *liveObj,ToolType toolType)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_HasToolEquipped(liveObj,toolType);
	return (uint)(BVar1 == 0);
}



BOOL __cdecl lego::game::LiveObject_GoGetToolIfNotEquipped(LiveObject *liveObj,ToolType toolType)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_HasToolEquipped(liveObj,toolType);
	if (BVar1 == 0) {
		ai::AITask_DoGetTool(toolType);
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_0041f5f0(LiveObject *liveObj)
{
	ObjectStatsFlags3 OVar1;
	
	OVar1 = LiveObject_GetStatsFlags3(liveObj);
	if ((OVar1 & STATS3_CARRYVEHICLES) == STATS3_NONE) {
		if (((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) ||
			 (liveObj->carriedObjects[0]->objType != OBJECT_BARRIER)) {
			LiveObject_FUN_0043a130(liveObj,0);
		}
	}
	else {
		if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
			 (liveObj->carriedObjects[0] != (LiveObject *)0x0)) {
			LiveObject_FUN_0043fee0(liveObj->carriedObjects[0]);
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl FUN_0041f650(uint param_1)
{
	LiveObject *pLVar1;
	
	pLVar1 = lego::game::Game_GetPrimarySelectedObject();
	return (uint)((pLVar1->flags5_3f0 & param_1) != LIVEOBJ5_NONE);
}



BOOL __cdecl FUN_0041f670(Point2I *blockPosition)
{
	BOOL BVar1;
	uint uVar2;
	int iVar3;
	int *piVar4;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_20[4] = 0xffffffff;
	local_4 = 0xffffffff;
	uVar2 = 0;
	local_20[0] = 1;
	local_20[1] = 0;
	local_20[2] = 0;
	local_20[3] = 1;
	local_c = 0;
	local_8 = 0;
	BVar1 = lego::game::Level_GetBlockFlags1_c0(blockPosition->x,blockPosition->y);
	if (BVar1 == 0) {
		piVar4 = local_20;
		do {
			BVar1 = lego::game::Level_BlockCheck_FUN_004329d0
												(blockPosition->x + *piVar4,piVar4[1] + blockPosition->y,1);
			if (BVar1 != 0) {
				return 0;
			}
			uVar2 = uVar2 + 1;
			piVar4 = piVar4 + 2;
		} while (uVar2 < 4);
		return 1;
	}
	uVar2 = 0;
	piVar4 = local_20;
	iVar3 = 4;
	do {
		BVar1 = lego::game::Level_BlockCheck_FUN_004329d0
											(blockPosition->x + *piVar4,piVar4[1] + blockPosition->y,1);
		if (BVar1 != 0) {
			uVar2 = uVar2 + 1;
		}
		piVar4 = piVar4 + 2;
		iVar3 = iVar3 + -1;
	} while (iVar3 != 0);
	if (1 < uVar2) {
		return 0;
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_HasToolEquipped_2(LiveObject *liveObj,ToolType toolType)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_HasToolEquipped(liveObj,toolType);
	return (uint)(BVar1 != 0);
}



BOOL __cdecl lego::game::LiveObject_FUN_0041f770(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_BIRDSCARER);
	if (BVar1 != 0) {
		LiveObject_00448c60(liveObj);
	}
	return 0;
}



void __cdecl lego::game::Level_IncrementCrystals(void)
{
	if (globals::g_Game.level != (LevelData *)0x0) {
		(globals::g_Game.level)->numCrystals = (globals::g_Game.level)->numCrystals + 1;
	}
	return;
}



void __cdecl lego::game::Level_SubtractCrystals(int crystalCount)
{
	if (globals::g_Game.level != (LevelData *)0x0) {
		(globals::g_Game.level)->numCrystals = (globals::g_Game.level)->numCrystals - crystalCount;
	}
	return;
}



void __cdecl lego::game::Level_AddDrainedCrystals(int drainedCrystalCount)
{
	if (globals::g_Game.level != (LevelData *)0x0) {
		(globals::g_Game.level)->numDrainedCrystals =
				 (globals::g_Game.level)->numDrainedCrystals + drainedCrystalCount;
	}
	return;
}



int __cdecl lego::game::Level_GetCrystalCount(BOOL includeDrained)
{
	int in_EAX;
	
	if ((globals::g_Game.level != (LevelData *)0x0) &&
		 (in_EAX = (globals::g_Game.level)->numCrystals, includeDrained == 0)) {
		in_EAX = in_EAX - (globals::g_Game.level)->numDrainedCrystals;
	}
	return in_EAX;
}



int __cdecl lego::game::Level_GetOreCount(BOOL isProcessed)
{
	LevelData *pLVar1;
	
	pLVar1 = globals::g_Game.level;
	if (globals::g_Game.level != (LevelData *)0x0) {
		if (isProcessed != 0) {
			return (int)(LevelData *)(globals::g_Game.level)->numProcessedOre;
		}
		pLVar1 = (LevelData *)(globals::g_Game.level)->numOre;
	}
	return (int)pLVar1;
}



void __cdecl lego::game::Level_AddToField9c(int value)
{
	if (globals::g_Game.level != (LevelData *)0x0) {
		(globals::g_Game.level)->field_9c = (globals::g_Game.level)->field_9c + value;
	}
	return;
}



void __cdecl lego::game::Game_SetFlag1_20000_unkCamera(BOOL state)
{
	if (state != 0) {
		globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_UNK_20000;
		return;
	}
	globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_UNK_20000;
	return;
}



BOOL __cdecl lego::game::Game_IsNoclipOn(void)
{
	return globals::g_Game.flags1 & GAME1_DEBUG_NOCLIP_FPS;
}



void __cdecl lego::game::Level_IncField94(void)
{
	if (globals::g_Game.level != (LevelData *)0x0) {
		(globals::g_Game.level)->field_94 = (globals::g_Game.level)->field_94 + 1;
	}
	return;
}



void __cdecl lego::game::Level_IncFieldA8(void)
{
	if (globals::g_Game.level != (LevelData *)0x0) {
		(globals::g_Game.level)->field_a8 = (globals::g_Game.level)->field_a8 + 1;
	}
	return;
}



void __cdecl lego::game::Level_IncOre(BOOL isProcessed)
{
	if (globals::g_Game.level != (LevelData *)0x0) {
		if (isProcessed == 0) {
			(globals::g_Game.level)->numOre = (globals::g_Game.level)->numOre + 1;
		}
		else {
			(globals::g_Game.level)->numProcessedOre = (globals::g_Game.level)->numProcessedOre + 1;
		}
	}
	if (isProcessed != 0) {
		FUN_0045c840(1,5);
		return;
	}
	FUN_0045c840(1,1);
	return;
}



void __cdecl lego::game::Level_SubtractOre(BOOL isProcessed,int oreCount)
{
	if (globals::g_Game.level != (LevelData *)0x0) {
		if (isProcessed == 0) {
			(globals::g_Game.level)->numOre = (globals::g_Game.level)->numOre - oreCount;
		}
		else {
			(globals::g_Game.level)->numProcessedOre = (globals::g_Game.level)->numProcessedOre - oreCount
			;
		}
	}
	if (isProcessed != 0) {
		FUN_0045c840(0,5);
		return;
	}
	FUN_0045c840(0,oreCount);
	return;
}



BOOL __cdecl lego::main::LRR_Go(LPCSTR gameName)
{
	BOOL BVar1;
	int iVar2;
	GameManager *pGVar3;
	GameFunctions gameFuncs;
	
	pGVar3 = &globals::g_Game;
	for (iVar2 = 0x3be; iVar2 != 0; iVar2 = iVar2 + -1) {
		pGVar3->LegoCfgRoot = (CFGProperty *)0x0;
		pGVar3 = (GameManager *)&pGVar3->CfgRootName;
	}
	globals::g_Game.CfgRootName = gameName;
	Main_SetTitle(gameName);
	gameFuncs.Initialise = Game_Init_LoadLegoCFG;
	gameFuncs.MainLoop = Game_Update;
	gameFuncs.Shutdown = Game_Cleanup;
	if (globs::mainGlobs.programmerLevel != PROGRAMMER_MODE_10) {
		gameFuncs.Shutdown = Game_Exit;
	}
	BVar1 = Main_SetState(&gameFuncs);
	return BVar1;
}



void __cdecl FUN_0041f9b0(void)
{
	lego::game::GetLevel();
	if ((lego::globals::g_Game.flags1 & GAME1_UNK_8000000) == GAME1_NONE) {
		UINT_00556118 = lego::game::Game_GetPilotPreviousLevel("Pilot",0);
		lego::globals::g_Game.flags1 = lego::globals::g_Game.flags1 | GAME1_UNK_8000000;
		lego::unk::Lego_SetBool_004b9a54(1);
		lego::game::LiveManager_SetFlag20(1);
		FUN_0046a7d0(1,1,1);
		FUN_0046a7d0(2,1,1);
		FUN_0046a7d0(8,1,1);
		FUN_0046a7d0(0x400,1,1);
		FUN_00425b60(0,0);
		FUN_0041e680();
		if (((byte)PanelData_ARRAY_00501110[0].flags & 2) != 0) {
			FUN_0045adc0(0);
			FUN_0045adc0(1);
		}
	}
	return;
}



float10 __cdecl lego::game::Game_GetGameSpeed(void)
{
	return (float10)globals::g_Game.gameSpeed;
}


/*
Unable to decompile 'Game_Init_LoadLegoCFG'
Cause: Exception while decompiling 0041fa80: process: timeout

*/


BOOL __cdecl lego::main::Game_Init_LoadLegoCFG(void)
{
	char *pcVar1;
	BOOL BVar2;
	int iVar3;
	int iVar4;
	char *pcVar5;
	ProgrammerMode PVar6;
	char *pcVar7;
	byte *input;
	BOOL3 BVar8;
	CFGProperty *prop;
	uint uVar9;
	uint screenWidth;
	float10 fVar10;
	float10 fVar11;
	float10 fVar12;
	int iVar13;
	float *out_r;
	float fVar14;
	ColourRGBF *pCVar15;
	float *pfVar16;
	float fVar17;
	float *pfVar18;
	float fVar19;
	char *MinEnergyForEat_str;
	char *HighPolyRange_str;
	char *MedPolyRange_str;
	char *ReinforceHits_str;
	char *DrainTime_str;
	char *MiniFigureRunAway_str;
	char *HPBlocks_str;
	char *CDTracks_str;
	char *CDStartTrack_str;
	char *BirdScarerRadius_str;
	char *DynamiteWakeRadius_str;
	char *DynamiteMaxDamage_str;
	char *DynamiteDamageRadius_str;
	char *tvclipdist_str;
	char *maxdist_str;
	char *mindist_str;
	char *MouseScrollBorder_str;
	char *MaxReturnedCrystals_str;
	char *RollOffFor3DSounds_str;
	char *MaxDistFor3DSounds_str;
	char *MinDistFor3DSoundsOnTopView_str;
	char *MouseScrollIndent_str;
	char *CameraAcceleration_str;
	char *CameraDropOff_str;
	char *CameraSpeed_str;
	char *LoaderProfile_filename;
	char *TextPauseTime_str;
	char *TextureUsage_str;
	char *BuildingUpgradeCostStuds_str;
	char *BuildingUpgradeCostOre_str;
	char *startLevelName;
	Point2F Dialog_center;
	char *Window_stringParts [4];
	int Window_numParts;
	Rect2F Window_rect;
	CFGProperty *Pointers_cfgProp;
	float CameraDropOff;
	float CameraSpeed;
	float MaxDistFor3DSounds;
	float RollOffFor3DSounds;
	int MouseScrollIndent;
	float CameraAcceleration;
	float MinDistFor3DSoundsOnTopView;
	char *Button_lpstr;
	char *Button_stringParts [10];
	char Button_buffer [128];
	char *Button_filename;
	char *SharedSizes_str;
	char *LoadScreen;
	char *ProgressBar;
	char *ProgressWindow;
	char *LoadingText;
	char *ShutdownScreen;
	Direction ProgressBar_direction;
	Rect2F ProgressWindow_rect;
	char *ProgressWindow_stringParts [10];
	char *StartMessage;
	char *Version;
	Rect2F MsgPanel_rect1;
	Rect2F MsgPanel_rect2;
	float local_5c;
	Rect2F fontRender84_rect;
	Rect2F fontRender80_rect;
	uint TextureUsage;
	uint videoMemFree;
	uint videoMemTotal;
	char *RenameReplace_ptr;
	float ToolTipRGB_g;
	float ToolTipRGB_r;
	float ToolTipRGB_b;
	float maxdist;
	float mindist;
	CFGProperty *legoCfgRoot;
	uint surfaceIdx_unused;
	float maxtilt;
	float mintilt;
	
	globals::g_Game.DragBoxRGB.red = 0.2;
	globals::g_Game.DragBoxRGB.green = 0.7;
	globals::g_Game.DragBoxRGB.blue = 1.0;
	globals::g_Game.SurfaceTypes_TABLE[0] = "Lego_SurfaceType_Tunnel";
	globals::g_Game.SurfaceTypes_TABLE[1] = "Lego_SurfaceType_Immovable";
	globals::g_Game.SurfaceTypes_TABLE[2] = "Lego_SurfaceType_Hard";
	globals::g_Game.SurfaceTypes_TABLE[3] = "Lego_SurfaceType_Medium";
	globals::g_Game.SurfaceTypes_TABLE[4] = "Lego_SurfaceType_Loose";
	globals::g_Game.SurfaceTypes_TABLE[5] = "Lego_SurfaceType_Soil";
	globals::g_Game.SurfaceTypes_TABLE[6] = "Lego_SurfaceType_Lava";
	globals::g_Game.SurfaceTypes_TABLE[7] = "Lego_SurfaceType_Water";
	globals::g_Game.SurfaceTypes_TABLE[8] = "Lego_SurfaceType_OreSeam";
	globals::g_Game.SurfaceTypes_TABLE[9] = "Lego_SurfaceType_Lake";
	globals::g_Game.SurfaceTypes_TABLE[10] = "Lego_SurfaceType_CrystalSeam";
	globals::g_Game.SurfaceTypes_TABLE[11] = "Lego_SurfaceType_RechargeSeam";
	globals::g_Game.SurfaceTypes_TABLE[12] = "Lego_SurfaceType_Rubble";
	globals::g_Game.SurfaceTypes_TABLE[13] = "Lego_SurfaceType_Reinforcement";
	globals::g_Game.SurfaceTypes_TABLE[14] = "Lego_SurfaceType_Path";
	globals::g_Game.SurfaceTypes_TABLE[15] = "Lego_SurfaceType_SlugHole";
	globals::g_Game.SurfaceTypes_TABLE[16] = "Lego_SurfaceType_Undiscovered";
	globals::g_Game.SurfaceTypes_TABLE[17] = "Lego_SurfaceType_Cavern";
	for (surfaceIdx_unused = 0; surfaceIdx_unused < 0x12; surfaceIdx_unused += 1) {
	}
	game::Game_SetGameSpeed(1.0);
	lego::input::Keys_Initialise();
	lego::view::Viewport_Initialise();
	pool::ReservedPool<LiveObject>__Init();
	image::Image_Initialise();
										/* No argument actually passed, just problem with variadic functions not
											 allowing zero args */
	util::logf_removed();
	Main_InitUnkVectorTables();
	Main_InitPanelButtons();
	pool::ReservedPool<AITask>__Init();
	Boot_InitTable_Message();
	Main_InitSmokeAnim_empty();
	Main_InitPointers();
	Main_Init_Bubble();
	globals::g_Game.bmpFONT5_HI = image::Font_Load("Interface\\Fonts\\FONT5_HI.bmp");
	globals::g_Game.bmpToolTipFont = image::Font_Load("Interface\\Fonts\\ToolTipFont.bmp");
	globals::g_Game.bmpDeskTopFont = image::Font_Load("Interface\\Fonts\\DeskTopFont.bmp");
	globals::g_Game.bmpfont5_HI = image::Font_Load("Interface\\Fonts\\font5_HI.bmp");
	globals::g_Game.bmpMbriefFONT = image::Font_Load("Interface\\Fonts\\MBriefFONT.bmp");
	globals::g_Game.bmpMbriefFONT2 = image::Font_Load("Interface\\Fonts\\MBriefFONT2.bmp");
	globals::g_Game.bmpRSFont = image::Font_Load("Interface\\Fonts\\RSFont.bmp");
	front::Info_InitInfo(globals::g_Game.bmpFONT5_HI);
	Main_InitInterfaceMenuItems(565,18,globals::g_Game.bmpToolTipFont);
	globals::g_Game.resRoot = res::Container_Initialise(globals::g_Game.CfgRootName);
	if (globals::g_Game.resRoot == NULL) {
		return 0;
	}
	res::Container_SetTriggerFrameCallback(res::Res_ResourceDrawCallback,NULL);
	globals::g_Game.LegoCfgRoot = cfg::CFG_Open("Lego.cfg");
	legoCfgRoot = globals::g_Game.LegoCfgRoot;
	if (globals::g_Game.LegoCfgRoot == NULL) goto LAB_0042274b;
	pfVar18 = &ToolTipRGB_b;
	pfVar16 = &ToolTipRGB_g;
	out_r = &ToolTipRGB_r;
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","ToolTipRGB",0);
	BVar2 = cfg::CFG_ReadRGBF(legoCfgRoot,pcVar1,out_r,pfVar16,pfVar18);
	if (BVar2 == 0) {
		ToolTipRGB_b = 0.3254902;
		ToolTipRGB_g = 0.3254902;
		ToolTipRGB_r = 0.3254902;
	}
	iVar13 = 0x20;
	fVar14 = ToolTipRGB_r;
	fVar17 = ToolTipRGB_g;
	fVar19 = ToolTipRGB_b;
	iVar3 = GetResolutionHeight();
	iVar4 = GetResolutionWidth();
	Main_InitToolTips_AndBigStruct
						(globals::g_Game.bmpToolTipFont,2,1,1.0,iVar4,iVar3,iVar13,fVar14,fVar17,fVar19);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","CreditsTextFile",0);
	globals::g_Game.CreditsTextFile = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","CreditsBackAVI",0);
	globals::g_Game.CreditsBackAVI = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","BuildingUpgradeCostOre",0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	if (pcVar1 == NULL) {
		BuildingUpgradeCostOre_str = ""/*EMPTYSTR*/;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","BuildingUpgradeCostOre",0);
		BuildingUpgradeCostOre_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	}
	globals::g_Game.BuildingUpgradeCostOre = std::atoi(BuildingUpgradeCostOre_str);
	if (globals::g_Game.BuildingUpgradeCostOre == 0) {
		globals::g_Game.BuildingUpgradeCostOre = 5;
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","BuildingUpgradeCostStuds",0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	if (pcVar1 == NULL) {
		BuildingUpgradeCostStuds_str = ""/*EMPTYSTR*/;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","BuildingUpgradeCostStuds",0);
		BuildingUpgradeCostStuds_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	}
	globals::g_Game.BuildingUpgradeCostStuds = std::atoi(BuildingUpgradeCostStuds_str);
	if (globals::g_Game.BuildingUpgradeCostStuds == 0) {
		globals::g_Game.BuildingUpgradeCostStuds = 1;
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","RenameReplace",0);
	globals::g_Game.RenameReplace = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
	pcVar1 = globals::g_Game.RenameReplace;
	if (globals::g_Game.RenameReplace != NULL) {
		while (RenameReplace_ptr = pcVar1, *RenameReplace_ptr != '\0') {
			if (*RenameReplace_ptr == '_') {
				*RenameReplace_ptr = ' ';
			}
			pcVar1 = RenameReplace_ptr + 1;
		}
	}
	BVar2 = ddraw::DirectDraw_GetAvailTextureMem(&videoMemTotal,&videoMemFree);
	if (BVar2 != 0) {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","TextureUsage",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			TextureUsage_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","TextureUsage",0);
			TextureUsage_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		TextureUsage = std::atoi(TextureUsage_str);
		if ((TextureUsage != 0) &&
			 (ddraw::DirectDraw_AdjustTextureUsage(&TextureUsage), TextureUsage <= videoMemFree)) {
			Main_DisableTextureManagement();
		}
	}
	fontRender80_rect.x = 55.0;
	fontRender80_rect.y = 435.0;
	fontRender80_rect.width = 325.0;
	fontRender80_rect.height = 42.0;
	globals::g_Game.textWnd_80 =
			 front::TextWindow_Create(globals::g_Game.bmpfont5_HI,&fontRender80_rect,0x400);
	fontRender84_rect.x = 55.0;
	fontRender84_rect.y = 435.0;
	fontRender84_rect.width = 260.0;
	fontRender84_rect.height = 42.0;
	globals::g_Game.textWnd_84 =
			 front::TextWindow_Create(globals::g_Game.bmpfont5_HI,&fontRender84_rect,0x400);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","TextPauseTime",0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	if (pcVar1 == NULL) {
		TextPauseTime_str = ""/*EMPTYSTR*/;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","TextPauseTime",0);
		TextPauseTime_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	}
	fVar10 = std::atof(TextPauseTime_str);
	front::Text_Load(globals::g_Game.textWnd_80,globals::g_Game.textWnd_84,316,425,
									 (float)(fVar10 * (float10)25.0));
	MsgPanel_rect1.x = 55.0;
	MsgPanel_rect1.y = 435.0;
	MsgPanel_rect1.width = 325.0;
	MsgPanel_rect1.height = 42.0;
	MsgPanel_rect2.x = 55.0;
	MsgPanel_rect2.y = 363.0;
	MsgPanel_rect2.width = 325.0;
	MsgPanel_rect2.height = 140.0;
	Main_LoadMsgPanel("Interface\\MessagePanel\\MsgPanel.bmp",0x2a,409,338,&MsgPanel_rect1,
										&MsgPanel_rect2,20.0);
	if ((globs::mainGlobs.flags & CMD_SHOWVERSION) != CMD_NONE) {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","StartMessage",0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		pcVar5 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","Version",0);
		pcVar5 = cfg::CFG_ReadString(legoCfgRoot,pcVar5);
		if (pcVar1 != NULL) {
			pcVar1 = util::stringReplaceChar(pcVar1,'_',' ');
			if (pcVar5 == NULL) {
				front::TextWindow_PrintF(globals::g_Game.textWnd_80,"\n%s",pcVar1);
			}
			else {
				front::TextWindow_PrintF(globals::g_Game.textWnd_80,"\n%s (%s)",pcVar1,pcVar5);
			}
			util::free2(pcVar1);
		}
	}
	BVar2 = Config_IsFrontEndEnabled();
	if ((BVar2 != 0) && (BVar2 = Config_IsIntrosEnabled(), BVar2 != 0)) {
		PVar6 = GetProgrammerMode();
		Boot_PlayIntroAVI("LegoAvi",(uint)(PVar6 != PROGRAMMER_OFF));
		Boot_PlayIntroImage("DDILogo",TRUE,"DDILogoTime");
		Boot_PlayIntroAVI("DDIAvi",TRUE);
		Boot_PlayIntroAVI("RRAvi",TRUE);
		pcVar1 = "LMILogoTime";
		PVar6 = GetProgrammerMode();
		Boot_PlayIntroImage("LMILogo",(uint)(PVar6 != PROGRAMMER_OFF),pcVar1);
	}
	snd::SFX_InitHashNames();
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","ProgressBar",0);
	ProgressBar = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","LoadScreen",0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	pcVar5 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","ShutdownScreen",0);
	pcVar5 = cfg::CFG_ReadString(legoCfgRoot,pcVar5);
	pcVar7 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","ProgressWindow",0);
	input = (byte *)cfg::CFG_CopyString(legoCfgRoot,pcVar7);
	pcVar7 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","LoadingText",0);
	pcVar7 = cfg::CFG_ReadString(legoCfgRoot,pcVar7);
	if (input == NULL) {
		ProgressBar = NULL;
	}
	else {
		iVar3 = std::toupper((uint)*input);
		*input = (byte)iVar3;
		if (false) {
LAB_004203f0:
			ProgressBar_direction = DIRECTION__COUNT;
		}
		else {
			switch(*input) {
			case 0x44:
				ProgressBar_direction = DIRECTION_DOWN;
				break;
			default:
				goto LAB_004203f0;
			case 0x4c:
				ProgressBar_direction = DIRECTION_LEFT;
				break;
			case 0x52:
				ProgressBar_direction = DIRECTION_RIGHT;
				break;
			case 0x55:
				ProgressBar_direction = DIRECTION_UP;
			}
		}
		iVar3 = util::Util_Tokenise((char *)input,ProgressWindow_stringParts,",");
		if (((iVar3 == 4) && (input[1] == 0x3a)) && (ProgressBar_direction != DIRECTION__COUNT)) {
			iVar3 = std::atoi(ProgressWindow_stringParts[0] + 2);
			ProgressWindow_rect.x = (float)iVar3;
			iVar3 = std::atoi(ProgressWindow_stringParts[1]);
			ProgressWindow_rect.y = (float)iVar3;
			iVar3 = std::atoi(ProgressWindow_stringParts[2]);
			ProgressWindow_rect.width = (float)iVar3;
			iVar3 = std::atoi(ProgressWindow_stringParts[3]);
			ProgressWindow_rect.height = (float)iVar3;
		}
	}
	util::free2(input);
	BVar2 = snd::Sound_IsInitialised();
	if (BVar2 == 0) {
		LoaderProfile_filename = "LoaderProfileNoSound.txt";
	}
	else {
		LoaderProfile_filename = "LoaderProfile.txt";
	}
	Main_LoadLoadScreen(pcVar1,pcVar5,globals::g_Game.bmpFONT5_HI,LoaderProfile_filename,
											ProgressBar_direction,ProgressBar,&ProgressWindow_rect,pcVar7);
	LoaderProfile_Lookup("Game Data");
	globals::g_Game.cameraMain = lego::view::Camera_Create(globals::g_Game.resRoot,CAMERATYPE_TOPDOWN)
	;
	if (((globals::g_Game.cameraMain == NULL) ||
			(globals::g_Game.cameraFP =
						lego::view::Camera_Create(globals::g_Game.resRoot,CAMERATYPE_FIRSTPERSON),
			globals::g_Game.cameraFP == NULL)) ||
		 ((globals::g_Game.cameraRadar =
						lego::view::Camera_Create(globals::g_Game.resRoot,CAMERATYPE_RADAR),
			globals::g_Game.cameraRadar == NULL ||
			((globals::g_Game.viewMain =
						 lego::view::Viewport_Create(0.0,0.0,1.0,1.0,(globals::g_Game.cameraMain)->resData1),
			 globals::g_Game.viewMain == NULL ||
			 (globals::g_Game.viewRadar =
						 lego::view::Viewport_CreatePixel
											 (0x10,0xd,0x97,0x97,(globals::g_Game.cameraRadar)->resData1),
			 globals::g_Game.viewRadar == NULL)))))) goto LAB_0042274b;
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","StreamNERPSSpeach",0);
	BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
	if (BVar8 == BOOL3_TRUE) {
		globals::g_Game.flags1 |= GAME1_STREAMNERPSSPEACH;
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","ShowDebugToolTips",0);
	BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
	if ((BVar8 == BOOL3_TRUE) || (PVar6 = GetProgrammerMode(), PVar6 != PROGRAMMER_OFF)) {
		globals::g_Game.flags2 |= GAME2_SHOWDEBUGTOOLTIPS;
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","AllowDebugKeys",0);
	BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
	if ((BVar8 == BOOL3_TRUE) || (PVar6 = GetProgrammerMode(), PVar6 != PROGRAMMER_OFF)) {
		globals::g_Game.flags2 |= GAME2_ALLOWDEBUGKEYS;
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","AllowEditMode",0);
	BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
	if ((BVar8 == BOOL3_TRUE) || (PVar6 = GetProgrammerMode(), PVar6 != PROGRAMMER_OFF)) {
		globals::g_Game.flags2 |= GAME2_ALLOWEDITMODE;
	}
	pfVar16 = &globals::g_Game.PowerCrystalRGB.blue;
	pfVar18 = &globals::g_Game.PowerCrystalRGB.green;
	pCVar15 = &globals::g_Game.PowerCrystalRGB;
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","PowerCrystalRGB",0);
	cfg::CFG_ReadRGBF(legoCfgRoot,pcVar1,(float *)pCVar15,pfVar18,pfVar16);
	pfVar16 = &globals::g_Game.UnpoweredCrystalRGB.blue;
	pfVar18 = &globals::g_Game.UnpoweredCrystalRGB.green;
	pCVar15 = &globals::g_Game.UnpoweredCrystalRGB;
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","UnpoweredCrystalRGB",0);
	cfg::CFG_ReadRGBF(legoCfgRoot,pcVar1,(float *)pCVar15,pfVar18,pfVar16);
	Boot_Load_Samples(legoCfgRoot,(uint)((globs::mainGlobs.flags & CMD_REDUCESAMPLES) == CMD_NONE));
	Main_LoadSurfaceTypeDescriptions_sound(legoCfgRoot,globals::g_Game.CfgRootName);
	Main_LoadPrioritiesImagePositions(legoCfgRoot,globals::g_Game.CfgRootName);
	Main_LoadPriorityImages(legoCfgRoot,globals::g_Game.CfgRootName);
	Main_Load_ToolTipInfo(legoCfgRoot,globals::g_Game.CfgRootName);
	Main_LoadToolNames(legoCfgRoot,globals::g_Game.CfgRootName);
	Main_LoadPanelRotationControl(legoCfgRoot,globals::g_Game.CfgRootName);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","SharedObjects",0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	res::Lws_Initialise(pcVar1,snd::SFX_GetType,snd::Audio_PlayOrInitSoundUnk,snd::Audio_IsSoundOn);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","SharedTextures",0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	if (pcVar1 != NULL) {
		res::Container_SetSharedTextureDirectory(pcVar1);
	}
	res::Mesh_Initialise(pcVar1);
	iVar3 = GetResolutionHeight();
	iVar4 = GetResolutionWidth();
	std::sprintf(Button_buffer,"NextButton%ix%i",iVar4,iVar3);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main",Button_buffer,0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	if ((pcVar1 != NULL) &&
		 (globals::g_Game.NextButton = image::Image_LoadBMPScaled(pcVar1,0,0),
		 globals::g_Game.NextButton != NULL)) {
		image::Image_SetupTrans(globals::g_Game.NextButton,0.0,0.0,0.0,0.0,0.0,0.0);
		iVar3 = GetResolutionHeight();
		iVar4 = GetResolutionWidth();
		std::sprintf(Button_buffer,"NextButtonPos%ix%i",iVar4,iVar3);
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main",Button_buffer,0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if (pcVar1 != NULL) {
			iVar3 = util::Util_Tokenise(pcVar1,Button_stringParts,",");
			if (iVar3 == 2) {
				fVar10 = std::atof(Button_stringParts[0]);
				globals::g_Game.NextButtonPos.x = (float)fVar10;
				fVar10 = std::atof(Button_stringParts[1]);
				globals::g_Game.NextButtonPos.y = (float)fVar10;
			}
			util::free2(pcVar1);
		}
	}
	iVar3 = GetResolutionHeight();
	iVar4 = GetResolutionWidth();
	std::sprintf(Button_buffer,"BackButton%ix%i",iVar4,iVar3);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main",Button_buffer,0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	if ((pcVar1 != NULL) &&
		 (globals::g_Game.BackButton = image::Image_LoadBMPScaled(pcVar1,0,0),
		 globals::g_Game.BackButton != NULL)) {
		image::Image_SetupTrans(globals::g_Game.BackButton,0.0,0.0,0.0,0.0,0.0,0.0);
		iVar3 = GetResolutionHeight();
		iVar4 = GetResolutionWidth();
		std::sprintf(Button_buffer,"BackButtonPos%ix%i",iVar4,iVar3);
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main",Button_buffer,0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if (pcVar1 != NULL) {
			iVar3 = util::Util_Tokenise(pcVar1,Button_stringParts,",");
			if (iVar3 == 2) {
				fVar10 = std::atof(Button_stringParts[0]);
				globals::g_Game.BackButtonPos.x = (float)fVar10;
				fVar10 = std::atof(Button_stringParts[1]);
				globals::g_Game.BackButtonPos.y = (float)fVar10;
			}
			util::free2(pcVar1);
		}
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","BackArrow",0);
	pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
	if ((pcVar1 != NULL) &&
		 (globals::g_Game.BackArrow = image::Image_LoadBMPScaled(pcVar1,0,0),
		 globals::g_Game.BackArrow != NULL)) {
		image::Image_SetupTrans(globals::g_Game.BackArrow,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	unk::Lego_SetDatTo_004a773c___00453bc0((uint)(globals::g_Game.NextButton != NULL));
	BVar2 = Main_LoadLighting();
	if (((((BVar2 != 0) && (BVar2 = Main_Load_GraphicsSettings(), BVar2 != 0)) &&
			 (BVar2 = Boot_Load_UpgradeTypes(), BVar2 != 0)) &&
			((BVar2 = Boot_Load_VehicleTypes(), BVar2 != 0 &&
			 (BVar2 = Boot_Load_MiniFigureTypes(), BVar2 != 0)))) &&
		 ((BVar2 = Boot_Load_RockMonsterTypes(), BVar2 != 0 &&
			(BVar2 = Boot_Load_BuildingTypes(), BVar2 != 0)))) {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","CameraSpeed",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			CameraSpeed_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","CameraSpeed",0);
			CameraSpeed_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(CameraSpeed_str);
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","CameraDropOff",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			CameraDropOff_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","CameraDropOff",0);
			CameraDropOff_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar11 = std::atof(CameraDropOff_str);
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","CameraAcceleration",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			CameraAcceleration_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","CameraAcceleration",0);
			CameraAcceleration_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar12 = std::atof(CameraAcceleration_str);
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MouseScrollIndent",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MouseScrollIndent_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MouseScrollIndent",0);
			MouseScrollIndent_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		iVar3 = std::atoi(MouseScrollIndent_str);
		lego::view::Camera_SetCameraMovements((float)fVar10,(float)fVar11,(float)fVar12,iVar3);
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MinDistFor3DSoundsOnTopView",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MinDistFor3DSoundsOnTopView_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MinDistFor3DSoundsOnTopView",0)
			;
			MinDistFor3DSoundsOnTopView_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(MinDistFor3DSoundsOnTopView_str);
		globals::g_Game.MinDistFor3DSoundsOnTopView = (float)fVar10;
		if (fVar10 == (float10)0.0) {
			globals::g_Game.MinDistFor3DSoundsOnTopView = 150.0;
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MaxDistFor3DSounds",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MaxDistFor3DSounds_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MaxDistFor3DSounds",0);
			MaxDistFor3DSounds_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(MaxDistFor3DSounds_str);
		if (fVar10 != (float10)0.0) {
			snd::Sound3D_SetMaxDist((float)fVar10);
		}
		snd::Sound3D_SetRollOffFactor(1.0);
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","RollOffFor3DSounds",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			RollOffFor3DSounds_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","RollOffFor3DSounds",0);
			RollOffFor3DSounds_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(RollOffFor3DSounds_str);
		if (fVar10 != (float10)0.0) {
			snd::Sound3D_SetRollOffFactor((float)fVar10);
		}
		globals::g_Game.RES_2f4_TABLEUNK =
				 (Container **)res::Res_FUN_004641c0(globals::g_Game.resRoot,5.0);
		res::ResLp_UnkSetup3DFrameTransform(globals::g_Game.RES_2f4_TABLEUNK,1);
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MaxReturnedCrystals",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MaxReturnedCrystals_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MaxReturnedCrystals",0);
			MaxReturnedCrystals_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		globals::g_Game.MaxReturnedCrystals = std::atoi(MaxReturnedCrystals_str);
		if (globals::g_Game.MaxReturnedCrystals == 0) {
			globals::g_Game.MaxReturnedCrystals = 10;
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MouseScrollBorder",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MouseScrollBorder_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MouseScrollBorder",0);
			MouseScrollBorder_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		globals::g_Game.MouseScrollBorder = std::atoi(MouseScrollBorder_str);
		if (globals::g_Game.MouseScrollBorder == 0) {
			globals::g_Game.MouseScrollBorder = 5;
		}
		Main_Load_ObjectNames(legoCfgRoot);
		Main_Load_ObjectTheNames(legoCfgRoot);
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","HelpWindowOn",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			Main_Font_SetDefault(globals::g_Game.bmpMbriefFONT2);
			Main_Load_HelpWindow(legoCfgRoot,globals::g_Game.CfgRootName);
		}
		Main_Load_ObjInfo(legoCfgRoot,globals::g_Game.CfgRootName);
		light::LightEffects_Load(legoCfgRoot,globals::g_Game.CfgRootName);
		game::Game_ParseStats(legoCfgRoot,globals::g_Game.CfgRootName);
		Main_Load_Dependencies(legoCfgRoot,globals::g_Game.CfgRootName);
		Main_Load_Bubbles(legoCfgRoot);
		Main_Load_Encyclopedia(legoCfgRoot,globals::g_Game.CfgRootName);
		Main_LoadObjTtSFXs(legoCfgRoot,globals::g_Game.CfgRootName);
		tools::Weapon_LoadWeaponTypes(legoCfgRoot,globals::g_Game.CfgRootName);
		globals::g_Game.viewMode = VIEW_TOPDOWN;
		snd::Sound3D_MakeListener((globals::g_Game.cameraMain)->resTableunk_34->masterFrame);
		snd::Sound3D_SetMinDistForAtten(globals::g_Game.MinDistFor3DSoundsOnTopView);
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","mindist",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			mindist_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","mindist",0);
			mindist_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(mindist_str);
		mindist = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","maxdist",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			maxdist_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","maxdist",0);
			maxdist_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(maxdist_str);
		maxdist = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","mintilt",0);
		fVar10 = cfg::CFG_ReadRadians(legoCfgRoot,pcVar1);
		mintilt = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","maxtilt",0);
		fVar10 = cfg::CFG_ReadRadians(legoCfgRoot,pcVar1);
		maxtilt = (float)fVar10;
		lego::view::Camera_SetDistRange(globals::g_Game.cameraMain,mindist,maxdist);
		lego::view::Camera_SetTiltRange(globals::g_Game.cameraMain,mintilt,maxtilt);
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","tvclipdist",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			tvclipdist_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","tvclipdist",0);
			tvclipdist_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(tvclipdist_str);
		globals::g_Game.TVClipDist = (float)fVar10;
		lego::view::Viewport_SetBackClip(globals::g_Game.viewMain,globals::g_Game.TVClipDist);
		lego::view::Viewport_SetBackClip(globals::g_Game.viewRadar,globals::g_Game.TVClipDist);
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","DynamiteDamageRadius",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			DynamiteDamageRadius_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","DynamiteDamageRadius",0);
			DynamiteDamageRadius_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(DynamiteDamageRadius_str);
		globals::g_Game.DynamiteDamageRadius = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","DynamiteMaxDamage",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			DynamiteMaxDamage_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","DynamiteMaxDamage",0);
			DynamiteMaxDamage_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(DynamiteMaxDamage_str);
		globals::g_Game.DynamiteMaxDamage = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","DynamiteWakeRadius",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			DynamiteWakeRadius_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","DynamiteWakeRadius",0);
			DynamiteWakeRadius_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(DynamiteWakeRadius_str);
		globals::g_Game.DynamiteWakeRadius = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","BirdScarerRadius",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			BirdScarerRadius_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","BirdScarerRadius",0);
			BirdScarerRadius_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(BirdScarerRadius_str);
		globals::g_Game.BirdScarerRadius = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MusicOn",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			globals::g_Game.flags2 |= GAME2_MUSICON;
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","CDStartTrack",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			CDStartTrack_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","CDStartTrack",0);
			CDStartTrack_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		globals::g_Game.CDStartTrack = std::atoi(CDStartTrack_str);
		if (globals::g_Game.CDStartTrack == 0) {
			globals::g_Game.CDStartTrack = 2;
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","CDTracks",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			CDTracks_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","CDTracks",0);
			CDTracks_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		globals::g_Game.CDTracks = std::atoi(CDTracks_str);
		if (globals::g_Game.CDTracks == 0) {
			globals::g_Game.flags2 &= ~GAME2_MUSICON;
			globals::g_Game.CDTracks = 1;
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","SoundOn",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			globals::g_Game.flags1 |= GAME1_SOUNDON;
		}
		globals::g_Game.flags1 |= GAME1_WALLPROMESHES|GAME1_CLEAR|GAME1_PANELS|GAME1_DYNAMICPM;
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","Clear",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_FALSE) {
			globals::g_Game.flags1 &= ~GAME1_CLEAR;
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","Panels",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_FALSE) {
			globals::g_Game.flags1 &= ~GAME1_PANELS;
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","WallProMeshes",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_FALSE) {
			globals::g_Game.flags1 &= ~GAME1_WALLPROMESHES;
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","DynamicPM",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_FALSE) {
			globals::g_Game.flags1 &= ~GAME1_DYNAMICPM;
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","HPBlocks",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			HPBlocks_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","HPBlocks",0);
			HPBlocks_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		globals::g_Game.HPBlocks = std::atoi(HPBlocks_str);
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","OnlyBuildOnPaths",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			globals::g_Game.flags1 |= GAME1_ONLYBUILDONPATHS;
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","AlwaysRockFall",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			globals::g_Game.flags1 |= GAME1_ALWAYSROCKFALL;
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MiniFigureRunAway",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MiniFigureRunAway_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MiniFigureRunAway",0);
			MiniFigureRunAway_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(MiniFigureRunAway_str);
		globals::g_Game.MiniFigureRunAway = (float)fVar10;
		if (fVar10 == (float10)0.0) {
			globals::g_Game.MiniFigureRunAway = 10.0;
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","DrainTime",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			DrainTime_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","DrainTime",0);
			DrainTime_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(DrainTime_str);
		globals::g_Game.DrainTime = (float)fVar10;
		if (fVar10 == (float10)0.0) {
			globals::g_Game.DrainTime = 10.0;
		}
		globals::g_Game.DrainTime = globals::g_Game.DrainTime * 25.0;
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","ReinforceHits",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			ReinforceHits_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","ReinforceHits",0);
			ReinforceHits_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		globals::g_Game.ReinforceHits = std::atoi(ReinforceHits_str);
		if (globals::g_Game.ReinforceHits == 0) {
			globals::g_Game.ReinforceHits = 4;
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MedPolyRange",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MedPolyRange_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MedPolyRange",0);
			MedPolyRange_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(MedPolyRange_str);
		globals::g_Game.MedPolyRange = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","HighPolyRange",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			HighPolyRange_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","HighPolyRange",0);
			HighPolyRange_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(HighPolyRange_str);
		globals::g_Game.HighPolyRange = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MinEnergyForEat",0);
		pcVar1 = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		if (pcVar1 == NULL) {
			MinEnergyForEat_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MinEnergyForEat",0);
			MinEnergyForEat_str = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
		}
		fVar10 = std::atof(MinEnergyForEat_str);
		globals::g_Game.MinEnergyForEat = (float)fVar10;
		Main_LoadMiscObjects(legoCfgRoot);
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Pointers",0);
		prop = cfg::CFG_GetChildren(legoCfgRoot,pcVar1);
		front::Pointer_LoadPointers(prop);
		front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_STANDARD);
		if ((globals::g_Game.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
			game::Debug_RegisterSelectedUnitHotkey(KEY_ONE,MESSAGE_FIRSTPERSON,NULL,FALSE,NULL);
			game::Debug_RegisterSelectedUnitHotkey(KEY_TWO,MESSAGE_FIRSTPERSON,NULL,TRUE,NULL);
			game::Debug_RegisterSelectedUnitHotkey(KEY_FOUR,MESSAGE_TRACKOBJECT,NULL,FALSE,NULL);
			game::Debug_RegisterSelectedUnitHotkey(KEY_THREE,MESSAGE_TOPVIEW,NULL,FALSE,NULL);
		}
		Main_LoadSmokeAnim("MiscAnims\\Smoke","Smoke",3);
		Main_LoadHealthFont("Interface\\FONTS\\HealthFont","a000_");
		Dialog_center.x = 0.0;
		Dialog_center.y = 0.0;
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Dialog","Image",0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if ((pcVar1 != NULL) &&
			 (globals::g_Game.DialogImage = image::Image_LoadBMPScaled(pcVar1,0,0),
			 globals::g_Game.DialogImage != NULL)) {
			image::Image_SetupTrans(globals::g_Game.DialogImage,0.0,0.0,0.0,0.0,0.0,0.0);
			iVar3 = GetResolutionWidth();
			Dialog_center.x = (float)(iVar3 / 2) - (float)((globals::g_Game.DialogImage)->width >> 1);
			iVar3 = GetResolutionHeight();
			Dialog_center.y = (float)(iVar3 / 2) - (float)((globals::g_Game.DialogImage)->height >> 1);
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Dialog","TitleWindow",0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if ((pcVar1 != NULL) && (iVar3 = util::Util_Tokenise(pcVar1,Window_stringParts,"|"), iVar3 == 4)
			 ) {
			iVar3 = std::atoi(Window_stringParts[0]);
			Window_rect.x = (float)iVar3 + Dialog_center.x;
			iVar3 = std::atoi(Window_stringParts[1]);
			Window_rect.y = (float)iVar3 + Dialog_center.y;
			iVar3 = std::atoi(Window_stringParts[2]);
			Window_rect.width = (float)iVar3;
			iVar3 = std::atoi(Window_stringParts[3]);
			Window_rect.height = (float)iVar3;
			globals::g_Game.drawregion_e80 =
					 front::TextWindow_Create(globals::g_Game.bmpMbriefFONT2,&Window_rect,0x400);
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Dialog","TextWindow",0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if ((pcVar1 != NULL) && (iVar3 = util::Util_Tokenise(pcVar1,Window_stringParts,"|"), iVar3 == 4)
			 ) {
			iVar3 = std::atoi(Window_stringParts[0]);
			Window_rect.x = (float)iVar3 + Dialog_center.x;
			iVar3 = std::atoi(Window_stringParts[1]);
			Window_rect.y = (float)iVar3 + Dialog_center.y;
			iVar3 = std::atoi(Window_stringParts[2]);
			Window_rect.width = (float)iVar3;
			iVar3 = std::atoi(Window_stringParts[3]);
			Window_rect.height = (float)iVar3;
			globals::g_Game.drawregion_e84 =
					 front::TextWindow_Create(globals::g_Game.bmpMbriefFONT,&Window_rect,0x400);
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Dialog","OkWindow",0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if ((pcVar1 != NULL) && (iVar3 = util::Util_Tokenise(pcVar1,Window_stringParts,"|"), iVar3 == 4)
			 ) {
			iVar3 = std::atoi(Window_stringParts[0]);
			Window_rect.x = (float)iVar3 + Dialog_center.x;
			iVar3 = std::atoi(Window_stringParts[1]);
			Window_rect.y = (float)iVar3 + Dialog_center.y;
			iVar3 = std::atoi(Window_stringParts[2]);
			Window_rect.width = (float)iVar3;
			iVar3 = std::atoi(Window_stringParts[3]);
			Window_rect.height = (float)iVar3;
			globals::g_Game.drawregion_e88 =
					 front::TextWindow_Create(globals::g_Game.bmpMbriefFONT,&Window_rect,0x400);
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Dialog","CancelWindow",0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if ((pcVar1 != NULL) && (iVar3 = util::Util_Tokenise(pcVar1,Window_stringParts,"|"), iVar3 == 4)
			 ) {
			iVar3 = std::atoi(Window_stringParts[0]);
			Window_rect.x = (float)iVar3 + Dialog_center.x;
			iVar3 = std::atoi(Window_stringParts[1]);
			Window_rect.y = (float)iVar3 + Dialog_center.y;
			iVar3 = std::atoi(Window_stringParts[2]);
			Window_rect.width = (float)iVar3;
			iVar3 = std::atoi(Window_stringParts[3]);
			Window_rect.height = (float)iVar3;
			globals::g_Game.drawregion_e8c =
					 front::TextWindow_Create(globals::g_Game.bmpMbriefFONT,&Window_rect,0x400);
		}
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Dialog","ContrastOverlay",0);
		pcVar1 = cfg::CFG_CopyString(legoCfgRoot,pcVar1);
		if ((pcVar1 != NULL) &&
			 (globals::g_Game.DialogContrastOverlay = image::Image_LoadBMPScaled(pcVar1,0,0),
			 globals::g_Game.DialogContrastOverlay != NULL)) {
			image::Image_SetupTrans(globals::g_Game.DialogContrastOverlay,0.0,0.0,0.0,0.0,0.0,0.0);
		}
		globals::g_Game.flags1 |= GAME1_RADARON|GAME1_RADAR_TRACKOBJECTVIEW;
		util::logf_removed((char *)globals::g_Game.resRoot,"animtex\\dirt");
		globals::g_Game.tvTiltOrZoom_334 = 15.0;
		globals::g_Game.float_324 = 16.0;
		globals::g_Game.float_328 = 13.0;
		globals::g_Game.float_32c = 151.0;
		globals::g_Game.float_330 = 151.0;
		Boot_Load_RockFallStyles(legoCfgRoot,globals::g_Game.CfgRootName,globals::g_Game.resRoot);
		Main_LoadToolTips(legoCfgRoot);
		Main_LoadToolTipIcons(legoCfgRoot);
		Main_LoadUpgradeNames(legoCfgRoot);
		front::Info_LoadInfoMessages(legoCfgRoot);
		Main_LoadMessageTabs_InfoOverFlow("Interface\\MessageTabs\\infoOverFlow.bmp");
		Main_LoadTextMessages(legoCfgRoot);
		uVar9 = GetResolutionHeight();
		screenWidth = GetResolutionWidth();
		front::Panel_LoadPanels(legoCfgRoot,screenWidth,uVar9);
		Main_LoadRightPanelCrystals
							("Interface\\RightPanel\\SmallCrystal.bmp","Interface\\RightPanel\\UsedCrystal.bmp",
							 "Interface\\RightPanel\\NoSmallCrystal.bmp");
		front::AirMeter_Load
							("Interface\\AirMeter\\msgpanel_air_juice.bmp",85,6,236,
							 "Interface\\AirMeter\\msgpanel_noair.bmp",21,0);
		Main_LoadRightPanel_CryOreSidebar
							("Interface\\RightPanel\\crystalsidebar_ore.bmp",0x267,0x1b2,0x1a7);
		uVar9 = GetResolutionHeight();
		iVar3 = GetResolutionWidth();
		Main_LoadButtons(legoCfgRoot,iVar3,uVar9);
		Main_LoadTutorialIcon(legoCfgRoot);
		Main_InitSubmenuIconTables();
		Main_LoadInterfaceImages(legoCfgRoot,globals::g_Game.CfgRootName);
		Main_LoadInterfaceSurroundImages(legoCfgRoot,globals::g_Game.CfgRootName);
		Main_LoadInterfaceDependencies_PlusMinus
							("Interface\\Dependencies\\+.bmp","Interface\\Dependencies\\=.bmp");
		front::Reward_LoadBaseGraphics(legoCfgRoot,globals::g_Game.CfgRootName);
		reward::Reward_LoadBaseFrontEnd();
		Main_LoadInterfaceButtons_ScrollInfo();
		front::Panel_FUN_0045ad80(PANEL_RADAR,2,1);
		front::Panel_FUN_0045ad80(PANEL_RADAR,3,1);
		save::Save_ClearSaveNumber();
		BVar2 = Config_IsFrontEndEnabled();
		if (BVar2 != 0) {
			front::Menu_LoadMenus(globals::g_Game.LegoCfgRoot);
		}
		front::Advisor_Init(globals::g_Game.CfgRootName,globals::g_Game.cameraMain,
												globals::g_Game.viewMain);
		front::Advisor_InitViewport(200.0);
		front::Advisor_LoadAdvisorAnims(legoCfgRoot,globals::g_Game.CfgRootName);
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","DisplayAdvisor",0);
		BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			iVar3 = GetResolutionHeight();
			iVar4 = GetResolutionWidth();
			front::Advisor_LoadAdvisorPositions(legoCfgRoot,globals::g_Game.CfgRootName,iVar4,iVar3);
		}
		if ((globals::g_Game.flags1 & GAME1_SOUNDON) != GAME1_NONE) {
			Config_SetSoundEnabled(1);
		}
		PVar6 = GetProgrammerMode();
		if (PVar6 < PROGRAMMER_MODE_3) {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","FrontEnd",0);
			BVar8 = cfg::CFG_ReadBool(legoCfgRoot,pcVar1);
			if (BVar8 != BOOL3_TRUE) goto LAB_004226cc;
			LoaderProfile_Lookup(NULL);
			front::Menu_Open_FUN_00416bb0(0);
			iVar3 = front::Front_IsTriggerAppQuit();
			if (iVar3 != 0) {
				return 0;
			}
			startLevelName = (char *)FUN_00416ca0();
		}
		else {
LAB_004226cc:
			startLevelName = GetStartLevel();
			if (startLevelName == NULL) {
				pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","startlevel",0);
				startLevelName = cfg::CFG_ReadString(legoCfgRoot,pcVar1);
			}
		}
		FUN_00416870(1,0);
		BVar2 = Main_loadLevelCFG(startLevelName);
		if (BVar2 != 0) {
			snd::Audio_Play_FUN_00465260(SFX_AMBIENTLOOP,1);
			return 1;
		}
	}
	cfg::CFG_Close(legoCfgRoot);
LAB_0042274b:
	res::Container_Shutdown();
	return 0;
}




void __cdecl lego::main::Main_LoadMiscObjects(CFGProperty *root)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","Boulder",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_Boulder = res::Container_Load(globals::g_Game.resRoot,pcVar1,"LWO",1);
	if (globals::g_Game.RES_Boulder == (Container *)0x0) {
		globals::g_Game.RES_Boulder = res::Container_Load(globals::g_Game.resRoot,pcVar1,"MESH",1);
	}
	res::Container_Hide(globals::g_Game.RES_Boulder,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","BoulderExplodeIce",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_BoulderExplodeIce =
			 res::Container_Load(globals::g_Game.resRoot,pcVar1,"LWS",1);
	res::Container_Hide(globals::g_Game.RES_BoulderExplodeIce,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","BoulderExplode",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_BoulderExplode = res::Container_Load(globals::g_Game.resRoot,pcVar1,"LWS",1);
	res::Container_Hide(globals::g_Game.RES_BoulderExplode,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","SmashPath",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_SmashPath = res::Container_Load(globals::g_Game.resRoot,pcVar1,"LWS",1);
	res::Container_Hide(globals::g_Game.RES_SmashPath,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","Explosion",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Main_LoadMiscObjectResource_Explosion(globals::g_Game.resRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","Crystal",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_Crystal = res::Container_Load(globals::g_Game.resRoot,pcVar1,"LWO",1);
	if (globals::g_Game.RES_Crystal == (Container *)0x0) {
		globals::g_Game.RES_Crystal = res::Container_Load(globals::g_Game.resRoot,pcVar1,"MESH",1);
	}
	res::Container_Hide(globals::g_Game.RES_Crystal,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","Dynamite",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_Dynamite = res::Container_Load(globals::g_Game.resRoot,pcVar1,"ACT",1);
	res::Container_Hide(globals::g_Game.RES_Dynamite,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","OohScary",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_OohScary = res::Container_Load(globals::g_Game.resRoot,pcVar1,"ACT",1);
	res::Container_Hide(globals::g_Game.RES_OohScary,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","Barrier",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_Barrier = res::Container_Load(globals::g_Game.resRoot,pcVar1,"ACT",1);
	res::Container_Hide(globals::g_Game.RES_Barrier,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","Ore",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_Ores_TABLE[0] = res::Container_Load(globals::g_Game.resRoot,pcVar1,"LWO",1);
	if (globals::g_Game.RES_Ores_TABLE[0] == (Container *)0x0) {
		globals::g_Game.RES_Ores_TABLE[0] = res::Container_Load(globals::g_Game.resRoot,pcVar1,"MESH",1)
		;
	}
	res::Container_Hide(globals::g_Game.RES_Ores_TABLE[0],1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","ProcessedOre",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_Ores_TABLE[1] = res::Container_Load(globals::g_Game.resRoot,pcVar1,"LWO",1);
	if (globals::g_Game.RES_Ores_TABLE[1] == (Container *)0x0) {
		globals::g_Game.RES_Ores_TABLE[1] = res::Container_Load(globals::g_Game.resRoot,pcVar1,"MESH",1)
		;
	}
	res::Container_Hide(globals::g_Game.RES_Ores_TABLE[1],1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","ElectricFence",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_ElectricFence = res::Container_Load(globals::g_Game.resRoot,pcVar1,"LWO",1);
	res::Container_Hide(globals::g_Game.RES_ElectricFence,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","ElectricFenceStud",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_ElectricFenceStud =
			 res::Container_Load(globals::g_Game.resRoot,pcVar1,"LWS",1);
	res::Container_Hide(globals::g_Game.RES_ElectricFenceStud,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","ShortElectricFenceBeam",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Main_LoadMiscObjectResource_ElectricFenceBeam(globals::g_Game.resRoot,pcVar1,0);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","LongElectricFenceBeam",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Main_LoadMiscObjectResource_ElectricFenceBeam(globals::g_Game.resRoot,pcVar1,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","SpiderWeb",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_SpiderWeb = res::Container_Load(globals::g_Game.resRoot,pcVar1,"ACT",1);
	res::Container_Hide(globals::g_Game.RES_SpiderWeb,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","RechargeSparkle",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_RechargeSparkle = res::Container_Load(globals::g_Game.resRoot,pcVar1,"LWS",1);
	res::Container_Hide(globals::g_Game.RES_RechargeSparkle,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","MiniTeleportUp",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_MiniTeleportUp = res::Container_Load(globals::g_Game.resRoot,pcVar1,"LWS",0);
	res::Container_Hide(globals::g_Game.RES_MiniTeleportUp,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","IceCube",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_IceCube = res::Container_Load(globals::g_Game.resRoot,pcVar1,"ACT",1);
	res::Container_Hide(globals::g_Game.RES_IceCube,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","Pusher",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_Pusher = res::Container_Load(globals::g_Game.resRoot,pcVar1,"LWS",1);
	res::Container_Hide(globals::g_Game.RES_Pusher,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","Freezer",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_Freezer = res::Container_Load(globals::g_Game.resRoot,pcVar1,"LWS",1);
	res::Container_Hide(globals::g_Game.RES_Freezer,1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiscObjects","LaserShot",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Game.RES_LaserShot = res::Container_Load(globals::g_Game.resRoot,pcVar1,"LWS",1);
	res::Container_Hide(globals::g_Game.RES_LaserShot,1);
	res::Res_LoadMiscObjects(root,globals::g_Game.CfgRootName,globals::g_Game.resRoot);
	return;
}



Container * __cdecl lego::game::Game_GetCamera24_IfBool308_ElseCamera2C(void)
{
	Container *pCVar1;
	
	if (globals::g_Game.viewMode == VIEW_TOPDOWN) {
		return (globals::g_Game.cameraMain)->resData1;
	}
	pCVar1 = (Container *)globals::g_Game.viewMode;
	if (globals::g_Game.viewMode == VIEW_FIRSTPERSON) {
		pCVar1 = (globals::g_Game.cameraFP)->resData1;
	}
	return pCVar1;
}



float10 __cdecl lego::game::Game_GetFloatFPS_e40(void)
{
	return (float10)globals::g_Game.elapsedAbs;
}



void __cdecl lego::game::Game_RenameInputUnk(float elapsed)
{
	uint uVar1;
	uint uVar2;
	LiveObject *pLVar3;
	char *pcVar4;
	uint uVar5;
	char *pcVar6;
	char *pcVar7;
	int iVar8;
	longlong lVar9;
	
	globals::g_RenameInputTimer = globals::g_RenameInputTimer - elapsed;
	if ((ushort)((ushort)(globals::g_RenameInputTimer < 0.0) << 8 |
							(ushort)(globals::g_RenameInputTimer == 0.0) << 0xe) != 0) {
		globals::g_RenameInputTimer = globals::g_RenameInputTimer - -12.5;
		globals::g_UseQuotes_Unk = ZEXT14(globals::g_UseQuotes_Unk == 0);
	}
	if (globals::g_Game.renameInput != (char *)0x0) {
		lVar9 = __ftol((float10)globals::g_Game.renamePosition.x);
		iVar8 = (int)lVar9;
		uVar1 = image::Font_GetHeight(globals::g_Game.bmpToolTipFont);
		lVar9 = __ftol((float10)globals::g_Game.renamePosition.y);
		uVar2 = image::Font_GetCharWidth(globals::g_Game.bmpToolTipFont,'\"');
		pcVar4 = globals::g_Game.renameInput;
		if ((*globals::g_Game.renameInput == '\0') &&
			 (pLVar3 = Game_GetPrimarySelectedObject(), pcVar4 = globals::g_Game.renameInput,
			 pLVar3 != (LiveObject *)0x0)) {
			pLVar3 = Game_GetPrimarySelectedObject();
			pcVar4 = LiveObject_GetName(pLVar3);
		}
		uVar5 = image::FontX_GetStringWidth(globals::g_Game.bmpToolTipFont,"\"%s\"",pcVar4);
		if (globs::mainGlobs.appWidth - 40 < iVar8 + uVar5) {
			iVar8 = iVar8 - uVar5;
		}
		pcVar7 = "\"";
		if (globals::g_UseQuotes_Unk == 0) {
			pcVar7 = ____EMPTYSTR__;
		}
		pcVar6 = "\"";
		if (globals::g_UseQuotes_Unk == 0) {
			pcVar6 = ____EMPTYSTR__;
		}
		image::Font_PrintF(globals::g_Game.bmpToolTipFont,
											 (~-(uint)(globals::g_UseQuotes_Unk != 0) & uVar2) + iVar8,
											 (int)lVar9 - (uVar1 >> 1),"%s%s%s",pcVar6,pcVar4,pcVar7);
	}
	return;
}



void __cdecl lego::input::Input_UpdateTyping(void)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	int iVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	if (globals::g_Game.renameInput != (char *)0x0) {
		uVar2 = 0xffffffff;
		pcVar6 = globals::g_Game.renameInput;
		do {
			if (uVar2 == 0) break;
			uVar2 = uVar2 - 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
		uVar3 = ~uVar2 - 1;
										// 1 = DIK_ESCAPE, 14 = DIK_BACK (backspace), 28 = DIK_RETURN (enter)
		if ((globs::INPUT.Key_Map[14] == false) ||
			 ((bool)globals::g_KeyboardState_Typing_TABLE[14] == globs::INPUT.Key_Map[14])) {
			if (((globs::INPUT.Key_Map[28] == false) && (globals::g_KeyboardState_Typing_TABLE[28] != 0))
				 || ((globs::INPUT.Key_Map[1] == false && (globals::g_KeyboardState_Typing_TABLE[1] != 0))))
			{
				globals::g_Game.renameInput = (char *)0x0;
				FUN_00425b60(0,0);
			}
			else {
				uVar2 = 0;
				do {
					if ((((uVar3 < 0xb) && (globs::INPUT.Key_Map[uVar2] != false)) &&
							((bool)globals::g_KeyboardState_Typing_TABLE[uVar2] != globs::INPUT.Key_Map[uVar2]))
						 && (iVar4 = Input_GetKeyCharacter(uVar2), iVar4 != 0)) {
						iVar4 = std::toupper(iVar4);
						globals::g_Game.renameInput[uVar3] = (char)iVar4;
						uVar3 = uVar3 + 1;
						globals::g_Game.renameInput[uVar3] = '\0';
					}
					uVar2 = uVar2 + 1;
				} while (uVar2 < 0x100);
			}
		}
		else {
			if (uVar3 != 0) {
				globals::g_Game.renameInput[~uVar2 - 2] = '\0';
			}
		}
		puVar5 = (undefined4 *)globs::INPUT.Key_Map;
		puVar7 = (undefined4 *)globals::g_KeyboardState_Typing_TABLE;
		for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {
			*puVar7 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar7 = puVar7 + 1;
		}
		puVar5 = (undefined4 *)globs::INPUT.Key_Map;
		for (iVar4 = 0x40; iVar4 != 0; iVar4 = iVar4 + -1) {
			*puVar5 = 0;
			puVar5 = puVar5 + 1;
		}
	}
	return;
}



BOOL __cdecl lego::main::Game_Update(float elapsed)
{
	float fVar1;
	LiveObject *pLVar2;
	BOOL BVar3;
	LevelData *pLVar4;
	int iVar5;
	uint uVar6;
	char *pcVar7;
	LiveObject **ppLVar8;
	ObjectUpgradesData *pOVar9;
	SFXType sfxType;
	float fVar10;
	float elapsedGame_00;
	uint uVar11;
	int iVar12;
	float10 fVar13;
	longlong lVar14;
	TextType textType;
	float fVar16;
	ulonglong uVar15;
	float local_34;
	SFXType local_30;
	float elapsedGame;
	Vector4F local_28;
	int local_18;
	BOOL local_14;
	BOOL local_10;
	Vector3F local_c;
	
	fVar1 = elapsed;
	local_30 = SFX_NULL;
	if ((globs::mainGlobs.programmerLevel == PROGRAMMER_MODE_10) &&
		 (BVar3 = FUN_00435870(), BVar3 == 0)) {
		return 0;
	}
	if ((globals::g_Game.flags1 & GAME1_CAMERADISABLED) != GAME1_NONE) {
		elapsed = 0.0;
	}
	input::Input_UpdateTyping();
	globals::g_Game.elapsedAbs = elapsed;
	if ((globals::g_Game.viewMode == VIEW_FIRSTPERSON) &&
		 (globs::mainGlobs.programmerLevel < PROGRAMMER_MODE_2)) {
										// In first person view, game speed is locked at 100%
		elapsedGame = elapsed;
	}
	else {
		fVar13 = game::Game_GetGameSpeed();
		elapsedGame = (float)(fVar13 * (float10)elapsed);
	}
	elapsedGame_00 = elapsedGame;
	FUN_0046a9f0(elapsedGame);
	FUN_00435980();
	fVar16 = elapsed;
	pLVar4 = game::GetLevel();
	game::Level_FUN_0042c370(pLVar4,fVar16);
	game::Game_UpdateFallins(elapsedGame_00);
	unk::Lego_unkSlug__004260f0(elapsedGame_00);
	if ((globals::g_Game.flags2 & GAME2_CALLTOARMS) == GAME2_NONE) {
		if (((globals::g_Game.cameraFP != (CameraData *)0x0) &&
				((globals::g_Game.cameraFP)->resData1 != (Container *)0x0)) &&
			 (globals::g_Game.resFPRotLightDefault != (Container *)0x0)) {
			res::Container_Hide(globals::g_Game.resFPRotLightDefault,1);
		}
	}
	else {
		if (((globals::g_Game.cameraFP != (CameraData *)0x0) &&
				((globals::g_Game.cameraFP)->resData1 != (Container *)0x0)) &&
			 ((globals::g_Game.resFPRotLightDefault != (Container *)0x0 &&
				((globals::g_Game.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE)))) {
			res::Container_Hide(globals::g_Game.resFPRotLightDefault,0);
			res::Container_AddRotation
								(globals::g_Game.resFPRotLightDefault,D3DRMCOMBINE_AFTER,0.0,1.0,0.0,elapsed * 0.1);
		}
	}
	if (((globals::g_Game.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) &&
		 (((globals::g_Game.flags1 & GAME1_UNK_200000) != GAME1_NONE || (globals::g_Game.bool_98 != 0)))
		 ) {
		if (globals::g_Game.bool_98 != 0) {
			local_28.x = (1.0 / elapsed) * 5.0;
			res::Container_GetPosition((globals::g_Game.cameraMain)->resData3,(Container *)0x0,&local_c);
			globals::g_Game.pointf_88.x =
					 (local_28.x * local_c.x + globals::g_Game.pointf_90.x) / (local_28.x - -1.0);
			globals::g_Game.pointf_88.y =
					 (local_28.x * local_c.y + globals::g_Game.pointf_90.y) / (local_28.x - -1.0);
			local_28.x = globals::g_Game.pointf_88.x - local_c.x;
			local_28.y = globals::g_Game.pointf_88.y - local_c.y;
			if (SQRT(local_28.y * local_28.y + local_28.x * local_28.x) < 2.0) {
				globals::g_Game.bool_98 = 0;
			}
		}
		lego::view::Camera_SetFramePosition_IfTopdown
							(globals::g_Game.cameraMain,globals::g_Game.pointf_88.x,globals::g_Game.pointf_88.y);
		globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_UNK_200000;
	}
	if ((globals::g_Game.flags1 & GAME1_LEVELSTART) != GAME1_NONE) {
		elapsedGame = 1.0;
		globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_LEVELSTART;
		elapsedGame_00 = 1.0;
	}
	BVar3 = game::Game_DoHotkeyChecks(elapsedGame_00,elapsed,&local_10,&local_14,&local_18);
	if (BVar3 == 0) {
		return 0;
	}
	if ((globals::g_Game.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) {
		FUN_00425cc0();
	}
	ai::AITask_FUN_00402150(elapsedGame_00);
	game::Level_FUN_00424530(globals::g_Game.level,elapsedGame_00);
	FUN_0040a940(elapsed);
	game::Game_UpdateLevelBlockPointsTable(elapsedGame_00);
	res::Struct2B0_Table_FUN_0046f810(elapsedGame_00);
	game::Game_DoErosionUnk__0040e9e0(elapsedGame_00);
	game::Level_FUN_004312e0(globals::g_Game.level,elapsedGame_00);
	game::Game_PTL_UNKInit__00452390();
	lego::view::Camera_Update(globals::g_Game.cameraMain,globals::g_Game.level,elapsed,elapsedGame_00)
	;
	lego::view::Camera_Update
						(globals::g_Game.cameraRadar,globals::g_Game.level,elapsed,elapsedGame_00);
	lego::view::Camera_Update(globals::g_Game.cameraFP,globals::g_Game.level,elapsed,elapsedGame_00);
	FUN_00409110(elapsedGame_00);
	FUN_0041b940(fVar1);
	FUN_004290d0(elapsed,0);
	FUN_00449ec0();
	FUN_0040d380(elapsedGame_00);
	game::Game_unkGameLoop_FUN_00426450(fVar1,elapsed,local_10,local_14,local_18);
	game::SurfaceMap_FUN_0044f2b0((globals::g_Game.level)->surfaceMap,elapsedGame_00);
	game::Level_FUN_0046e650(globals::g_Game.level,elapsedGame_00);
	snd::Sound3D_UpdateListener();
	FUN_00465dc0(elapsedGame_00);
	FUN_00466880(SUB41(elapsedGame_00,0));
	light::LightEffects_Update(elapsedGame_00);
	FUN_0041a1f0(fVar1);
	if (globals::g_Game.IsFallinsEnabled != 0) {
		FUN_0040f010(elapsedGame_00);
	}
	if ((((globals::g_Game.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) &&
			(globs::INPUT.Key_Map[64] != false)) &&
		 (globs::INPUT.prevKey_Map[64] != globs::INPUT.Key_Map[64])) {
		globals::g_Game.IsFallinsEnabled = ZEXT14(globals::g_Game.IsFallinsEnabled == 0);
		front::TextWindow_PrintF(globals::g_Game.textWnd_80,"\nFallin Mode %s");
	}
	res::Container_Hide(globals::g_Game.resAmbientLight,0);
	if (globals::g_Game.viewMode == VIEW_TOPDOWN) {
		if ((globals::g_Game.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) {
			res::Container_Hide(globals::g_Game.resRootSpotlight,0);
		}
		res::Container_Hide(globals::g_Game.resTopSpotlight,0);
		lego::view::Viewport_Clear(globals::g_Game.viewMain,1);
		lego::view::Viewport_Render(globals::g_Game.viewMain,globals::g_Game.resRoot,elapsed);
		res::Container_Hide(globals::g_Game.resTopSpotlight,1);
		res::Container_Hide(globals::g_Game.resRootSpotlight,1);
	}
	else {
		if (globals::g_Game.viewMode == VIEW_FIRSTPERSON) {
			FUN_00463770(0);
			FUN_004634f0();
			FUN_0043bb10(globals::g_Game.objectFP,(globals::g_Game.cameraFP)->resData1,
									 globals::g_Game.MedPolyRange,globals::g_Game.HighPolyRange,1);
			BVar3 = 1;
			iVar5 = lego::view::Camera_GetField14(globals::g_Game.cameraFP);
			game::LiveObject_FUN_0043bae0(globals::g_Game.objectFP,iVar5,BVar3);
			game::Game_UpdateSceneFog(1,elapsedGame_00);
			if (((globals::g_Game.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) &&
				 (res::Container_Hide(globals::g_Game.resFPLight,0),
				 globals::g_Game.resFPRotLight != (Container *)0x0)) {
				res::Container_AddRotation
									(globals::g_Game.resFPRotLight,D3DRMCOMBINE_AFTER,0.0,1.0,0.0,elapsed * 0.01);
				res::Container_Hide(globals::g_Game.resFPRotLight,0);
			}
			lego::view::Viewport_Clear(globals::g_Game.viewMain,1);
			lego::view::Viewport_Render(globals::g_Game.viewMain,globals::g_Game.resRoot,elapsed);
			res::Container_Hide(globals::g_Game.resFPLight,1);
			if (globals::g_Game.resFPRotLight != (Container *)0x0) {
				res::Container_Hide(globals::g_Game.resFPRotLight,1);
			}
			game::Game_UpdateSceneFog(0,elapsedGame_00);
			BVar3 = 0;
			iVar5 = lego::view::Camera_GetField14(globals::g_Game.cameraFP);
			game::LiveObject_FUN_0043bae0(globals::g_Game.objectFP,iVar5,BVar3);
			FUN_0043bb10(globals::g_Game.objectFP,(Container *)0x0,0,0,0);
			FUN_00463800();
			FUN_00463770(1);
			game::Level_ForEachSurfText_FUN_00434460();
		}
	}
	res::Container_Hide(globals::g_Game.resAmbientLight,1);
	iVar5 = FUN_0045ae20(0);
	if (iVar5 == 0) {
		globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_RADARON;
	}
	else {
		globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_RADARON;
	}
	if (globals::g_Game.viewMode == VIEW_TOPDOWN) {
		FUN_00424760((int)globals::g_Game.viewMain);
		FUN_00424740(globals::g_Game.viewMain);
		FUN_0040e800((int)globals::g_Game.viewMain);
	}
	FUN_004292e0(globals::g_Game.level);
	if ((globals::g_Game.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) {
		FUN_004074d0(elapsed);
	}
	if ((((globals::g_Game.flags1 & GAME1_RADARON) != GAME1_NONE) &&
			((globals::g_Game.flags1 & GAME1_RADAR_TRACKOBJECTVIEW) != GAME1_NONE)) &&
		 (lego::view::Viewport_Clear(globals::g_Game.viewRadar,1),
		 (globals::g_Game.flags1 & GAME1_UNK_20000) == GAME1_NONE)) {
		FUN_004290d0(elapsedGame_00,1);
		FUN_00449ec0();
		res::Container_Hide(globals::g_Game.resTrackSpotlight,0);
		if (((globals::g_Game.cameraFP != (CameraData *)0x0) &&
				((globals::g_Game.cameraFP)->resData1 != (Container *)0x0)) &&
			 (globals::g_Game.resFPRotLightDefault != (Container *)0x0)) {
			res::Container_Hide(globals::g_Game.resFPRotLightDefault,1);
		}
		lego::view::Viewport_Render(globals::g_Game.viewRadar,globals::g_Game.resRoot,elapsed);
		res::Container_Hide(globals::g_Game.resTrackSpotlight,1);
		game::SurfaceMap_DoForCoordsAndClear_Mesh_FUN_00474df0((globals::g_Game.level)->surfaceMap);
	}
	Main_Finalise3D();
	FUN_00465d50(1);
	snd::Audio_UnkUpdate_FUN_00465460(fVar1);
	if ((globals::g_Game.viewMode == VIEW_TOPDOWN) &&
		 ((globals::g_Game.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE)) {
		game::Level_FUN_00435230
							(globals::g_Game.level,(int)globals::g_Game.viewMain,elapsedGame_00,elapsed);
		FUN_004548c0(globals::g_Game.level,(int)globals::g_Game.viewMain,elapsedGame_00,elapsed);
	}
	game::SurfaceMap_DoForCoordsAndClear_Mesh_FUN_00474df0((globals::g_Game.level)->surfaceMap);
	if (((globals::g_Game.flags1 & GAME1_RADARON) == GAME1_NONE) ||
		 ((globals::g_Game.flags1 & GAME1_RADAR_MAPVIEW) == GAME1_NONE)) {
		iVar5 = 0;
	}
	else {
		iVar5 = 1;
	}
	if (iVar5 != 0) {
		FUN_00426180();
	}
	FUN_0043c570(elapsedGame_00,iVar5);
	if ((globals::g_Game.flags1 & GAME1_PANELS) != GAME1_NONE) {
		if ((globals::g_Game.flags1 & GAME1_RADARON) == GAME1_NONE) {
			front::Panel_FUN_0045a9f0(PANEL_RADARFILL,elapsed);
		}
		front::Panel_FUN_0045a9f0(PANEL_RADAR,elapsed);
		if ((((globals::g_Game.flags1 & GAME1_RADARON) != GAME1_NONE) &&
				((globals::g_Game.flags1 & GAME1_RADAR_TRACKOBJECTVIEW) != GAME1_NONE)) &&
			 ((globals::g_Game.flags1 & GAME1_UNK_20000) == GAME1_NONE)) {
			front::Panel_FUN_0045a9f0(PANEL_RADAROVERLAY,elapsed);
		}
		front::Panel_FUN_0045a9f0(PANEL_MESSAGESIDE,elapsed);
		front::Panel_FUN_0045a9f0(PANEL_CAMERACONTROL,elapsed);
		front::Panel_FUN_0045a9f0(PANEL_TOPPANEL,elapsed);
		front::Panel_FUN_0045a9f0(PANEL_PRIORITYLIST,elapsed);
		FUN_0045d990();
		front::Panel_FUN_0045a9f0(PANEL_ENCYCLOPEDIA,elapsed);
		FUN_0040e720(elapsed);
		if ((globals::g_Game.flags2 & GAME2_INMENU) == GAME2_NONE) {
			FUN_0041b3c0();
		}
		FUN_0041b860(elapsed);
		front::Panel_FUN_0045a9f0(PANEL_CRYSTALSIDEBAR,elapsed);
		fVar10 = elapsed;
		fVar16 = elapsed;
		if (globals::g_Game.level != (LevelData *)0x0) {
			fVar10 = (float)(globals::g_Game.level)->numCrystals;
			fVar16 = (float)((globals::g_Game.level)->numCrystals -
											(globals::g_Game.level)->numDrainedCrystals);
		}
		FUN_0045c390((uint)fVar10,(uint)fVar16,elapsedGame_00);
		front::Panel_CryOreSidebar_Draw();
		FUN_0045a720(5,globals::g_Game.bmpToolTipFont,0x10,0x1d5,1,"%i");
		front::Panel_FUN_0045a9f0(PANEL_INFORMATION,elapsed);
		FUN_00463fe0(0);
		FUN_00419fb0(elapsed);
		front::Panel_FUN_0045a9f0(PANEL_INFODOCK,elapsed);
		FUN_00419e60(elapsed);
	}
	FUN_00418930();
	BVar3 = game::Level_IsObjectiveFinished();
	fVar16 = elapsed;
	if (BVar3 != 0) {
		fVar16 = fVar1;
	}
	front::Advisor_Update(fVar16);
	snd::Sound_Update(globals::g_Game.flags1 & GAME1_MUSICON);
	if ((globals::g_Game.flags1 & GAME1_DEBUG_NONERPS) == GAME1_NONE) {
		nerps::NERPs_Exec__004535e0(elapsed);
	}
	FUN_00458ea0(globals::g_Game.textWnd_80,globals::g_Game.level,elapsedGame_00,fVar1);
	if (globs::mainGlobs.programmerLevel < PROGRAMMER_MODE_2) {
		if (((globals::g_Game.level)->MaxStolen != 0.0) &&
			 ((uint)(globals::g_Game.level)->MaxStolen <= (uint)(globals::g_Game.level)->field_9c)) {
			game::Level_SetCompleteStatus(LEVELSTATUS_FAILED_CRYSTALS);
		}
		iVar5 = game::LiveObject_GetOrSubLevelsTable(OBJECT_PATH,0,0,1);
		if (iVar5 == 0) {
			uVar11 = 0;
			iVar12 = 0;
			iVar5 = game::Object_GetLevels(OBJECT_MINIFIGURE,0);
			if (iVar5 != 0) {
				do {
					iVar5 = game::LiveObject_GetOrSubLevelsTable(OBJECT_MINIFIGURE,0,uVar11,1);
					iVar12 = iVar12 + iVar5;
					uVar11 = uVar11 + 1;
					uVar6 = game::Object_GetLevels(OBJECT_MINIFIGURE,0);
				} while (uVar11 < uVar6);
			}
			if ((iVar12 == 0) && (pLVar4 = game::GetLevel(), pLVar4->status == LEVELSTATUS_NONE)) {
				game::Level_SetCompleteStatus(LEVELSTATUS_FAILED);
			}
		}
	}
	FUN_0046afc0(elapsed);
	if (((globals::g_Game.flags2 & GAME2_MENU_HASNEXT) != GAME2_NONE) &&
		 (globals::g_Game.NextButton != (ImageBMP *)0x0)) {
		image::Image_DisplayScaled
							(globals::g_Game.NextButton,(Rect2F *)0x0,&globals::g_Game.menuNextPoint,(Size2F *)0x0
							);
	}
	if (((globals::g_Game.flags2 & GAME2_MENU_HASPREVIOUS) != GAME2_NONE) &&
		 (globals::g_Game.BackArrow != (ImageBMP *)0x0)) {
		image::Image_DisplayScaled
							(globals::g_Game.BackArrow,(Rect2F *)0x0,&globals::g_Game.menuPrevPoint,(Size2F *)0x0)
		;
	}
	if ((((globals::g_Game.flags2 & GAME2_UNK_40) != GAME2_NONE) &&
			(globals::g_Game.NextButton != (ImageBMP *)0x0)) &&
		 (((globals::g_Game.flags2 & GAME2_CAMERAMOVING) == GAME2_NONE ||
			(iVar5 = unk::Lego_GetDat_004ded1c(), iVar5 != 0)))) {
		image::Image_DisplayScaled
							(globals::g_Game.NextButton,(Rect2F *)0x0,&globals::g_Game.NextButtonPos,(Size2F *)0x0
							);
	}
	if (((globals::g_Game.flags2 & GAME2_UNK_80) != GAME2_NONE) &&
		 (globals::g_Game.BackButton != (ImageBMP *)0x0)) {
		image::Image_DisplayScaled
							(globals::g_Game.BackButton,(Rect2F *)0x0,&globals::g_Game.BackButtonPos,(Size2F *)0x0
							);
	}
	if ((((globals::g_Game.flags2 & GAME2_INOPTIONSMENU) != GAME2_NONE) &&
			(BVar3 = Config_IsFrontEndEnabled(), BVar3 != 0)) &&
		 (BVar3 = FUN_004152a0(elapsed,1), BVar3 != 0)) {
		globals::g_Game.flags2 = globals::g_Game.flags2 & ~GAME2_INOPTIONSMENU;
		BVar3 = game::Level_IsObjectiveFinished();
		if (BVar3 == 0) {
			FUN_00425b60(0,0);
		}
		else {
			globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_PAUSED;
		}
	}
	game::Game_RenameInputUnk(fVar1);
	if ((globals::g_Game.flags1 & GAME1_PAUSED) == GAME1_NONE) {
		front::Pointer_SubUnkFloat_IfGreaterThan0(fVar1);
		if (globals::g_Game.renameInput == (char *)0x0) goto LAB_00423e04;
	}
	else {
		BVar3 = Config_IsFrontEndEnabled();
		if ((BVar3 == 0) || (BVar3 = FUN_004152a0(elapsed,0), BVar3 == 0)) {
			front::Pointer_SubUnkFloat_IfGreaterThan0(fVar1);
LAB_00423e04:
			front::Pointer_DrawPointer(globs::INPUT.msx,globs::INPUT.msy);
		}
		else {
			globals::g_Game.flags1 = globals::g_Game.flags1 ^ GAME1_PAUSED;
			BVar3 = front::Front_IsTriggerMissionQuit();
			if (BVar3 == 0) {
				BVar3 = game::Level_IsObjectiveFinished();
				if (BVar3 == 0) {
					FUN_00425b60(0,0);
				}
			}
			else {
				FUN_0041f9b0();
				pLVar4 = game::GetLevel();
				pLVar4->status = LEVELSTATUS_FAILED_CRYSTALS;
				unk::Lego_UnkLevelImportantPilot___004604e0();
				if ((globals::g_Game.flags1 & GAME1_MUSICON) != GAME1_NONE) {
					globals::g_Game.flags2 = globals::g_Game.flags2 | GAME2_MUSICON;
					snd::Music_PlayNext(0);
				}
			}
		}
	}
	BVar3 = front::Front_IsTriggerMissionRestart();
	if ((BVar3 == 1) || (globs::mainGlobs.programmerLevel == PROGRAMMER_MODE_11)) {
		FUN_00415150();
	}
	if ((globals::g_Game.flags1 & GAME1_UNK_20000000) != GAME1_NONE) {
		pcVar7 = "Vertex";
		if ((globals::g_Game.flags1 & GAME1_UNK_40000) == GAME1_NONE) {
			pcVar7 = "Block";
		}
		image::Font_PrintF(globals::g_Game.bmpDeskTopFont,10,10,"%s mode",pcVar7);
	}
	if (((globals::g_Game.flags1 & GAME1_UNK_40000) != GAME1_NONE) && (globals::g_Game.bool_c8 != 0))
	{
		game::SurfaceMap_FUN_00450320
							((globals::g_Game.level)->surfaceMap,globals::g_Game.pointi_c0.x,
							 globals::g_Game.pointi_c0.y,&local_c);
		lego::view::Viewport_Transform(globals::g_Game.viewMain,&local_28,&local_c);
		local_28.x = local_28.x / local_28.w;
		local_28.y = local_28.y / local_28.w;
		front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_DRILL);
		lVar14 = __ftol((float10)local_28.y);
		uVar11 = (uint)lVar14;
		lVar14 = __ftol((float10)local_28.x);
		front::Pointer_DrawPointer((uint)lVar14,uVar11);
		globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_UNK_80000000;
	}
	front::ToolTip_Update_FUN_0046ba80(globs::INPUT.msx,globs::INPUT.msy,fVar1);
	if ((globals::g_Game.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
		if (((((globs::INPUT.Key_Map[6] != false) &&
					(globs::INPUT.prevKey_Map[6] != globs::INPUT.Key_Map[6])) ||
				 ((globs::INPUT.Key_Map[7] != false &&
					(globs::INPUT.prevKey_Map[7] != globs::INPUT.Key_Map[7])))) ||
				((globs::INPUT.Key_Map[8] != false &&
				 (globs::INPUT.prevKey_Map[8] != globs::INPUT.Key_Map[8])))) ||
			 ((globs::INPUT.Key_Map[9] != false &&
				(globs::INPUT.prevKey_Map[9] != globs::INPUT.Key_Map[9])))) {
			FLOAT_004df530 = 1.0;
		}
		if ((ushort)((ushort)(FLOAT_004df530 < 0.0) << 8 | (ushort)(FLOAT_004df530 == 0.0) << 0xe) == 0)
		{
			ppLVar8 = game::Game_GetSelectedUnits((int *)&local_28);
			if (local_28.x != 0.0) {
				pLVar2 = *ppLVar8;
				if (pLVar2->objType == OBJECT_BUILDING) {
					pOVar9 = &pLVar2->building->upgrades;
				}
				else {
					if (pLVar2->objType == OBJECT_VEHICLE) {
						pOVar9 = &pLVar2->vehicle->upgrades;
					}
					else {
						pOVar9 = (ObjectUpgradesData *)0x0;
					}
				}
				if (pOVar9 != (ObjectUpgradesData *)0x0) {
					uVar11 = pOVar9->currentLevel;
					uVar15 = CONCAT44(uVar11,uVar11 >> 1) & 0x100000001;
					image::Font_PrintF(globals::g_Game.bmpFONT5_HI,0,0,"Upgrade - (%i%i%i%i)",uVar11 >> 3 & 1,
														 uVar11 >> 2 & 1,(uint)uVar15,(uint)(uVar15 >> 0x20));
				}
			}
			FLOAT_004df530 = FLOAT_004df530 - 0.1;
		}
	}
	if (globals::g_DripSFXTimer < 0.0) {
		snd::Audio_Play_FUN_00465260(SFX_DRIP,0);
		fVar13 = math::Maths_RandRange(75.0,125.0);
		globals::g_DripSFXTimer = (float)fVar13;
	}
	if (globals::g_AmbientSFXTimer < 0.0) {
		snd::Audio_Play_FUN_00465260(SFX_AMBIENT,0);
		fVar13 = math::Maths_RandRange(250.0,750.0);
		globals::g_AmbientSFXTimer = (float)fVar13;
	}
	globals::g_DripSFXTimer = globals::g_DripSFXTimer - elapsed;
	globals::g_AmbientSFXTimer = globals::g_AmbientSFXTimer - elapsed;
	if ((globals::g_Game.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
										// IsKeyUp(KEYPAD_9) (73)
		if (globs::INPUT.Key_Map[73] == false) {
			local_34 = -1.0;
										// IsKeyUp(KEYPAD_8) (72)
			if (globs::INPUT.Key_Map[72] == false) {
				local_34 = 0.0;
			}
		}
		else {
			local_34 = 1.0;
		}
		if (local_34 != 0.0) {
			globals::g_SpeedChangeTimer = 25.0;
			fVar13 = game::Game_GetGameSpeed();
			game::Game_SetGameSpeed
								((float)((float10)local_34 * (float10)elapsed * (float10)0.01 + fVar13));
			fVar13 = game::Game_GetGameSpeed();
			if ((ushort)((ushort)(fVar13 < (float10)3.0) << 8 | (ushort)(fVar13 == (float10)3.0) << 0xe)
					== 0) {
				game::Game_SetGameSpeed(3.0);
			}
			fVar13 = game::Game_GetGameSpeed();
			if (fVar13 < (float10)0.0) {
				game::Game_SetGameSpeed(0.0);
			}
		}
		if ((ushort)((ushort)(globals::g_SpeedChangeTimer < 0.0) << 8 |
								(ushort)(globals::g_SpeedChangeTimer == 0.0) << 0xe) == 0) {
			fVar13 = game::Game_GetGameSpeed();
			image::Font_PrintF(globals::g_Game.bmpFONT5_HI,10,0x50,"Game Speed %0.0f%%",
												 (double)(fVar13 * (float10)100.0));
		}
		globals::g_SpeedChangeTimer = globals::g_SpeedChangeTimer - elapsed;
	}
	if ((globals::g_Game.flags2 & GAME2_ALLOWDEBUGKEYS) == GAME2_NONE) goto LAB_0042427c;
	if (globals::g_DebugRollOffFactor_Value == -1.0) {
		fVar13 = snd::Sound3D_SetRollOffFactor(-1.0);
		globals::g_DebugRollOffFactor_Value = (float)fVar13;
	}
	if (globs::INPUT.Key_Map[10] == false) {
		if (globs::INPUT.Key_Map[11] != false) {
			globals::g_DebugRollOffFactor_Value = globals::g_DebugRollOffFactor_Value - -0.05;
			goto LAB_0042421e;
		}
	}
	else {
		globals::g_DebugRollOffFactor_Value = globals::g_DebugRollOffFactor_Value - 0.05;
LAB_0042421e:
		fVar13 = snd::Sound3D_SetRollOffFactor(globals::g_DebugRollOffFactor_Value);
		globals::g_DebugRollOffFactor_Value = (float)fVar13;
		globals::g_RollOffChangeTimer = 25.0;
	}
	if ((ushort)((ushort)(globals::g_RollOffChangeTimer < 0.0) << 8 |
							(ushort)(globals::g_RollOffChangeTimer == 0.0) << 0xe) == 0) {
		image::Font_PrintF(globals::g_Game.bmpFONT5_HI,10,0x50,"3D sound fall off: %f",
											 (double)globals::g_DebugRollOffFactor_Value);
	}
	globals::g_RollOffChangeTimer = globals::g_RollOffChangeTimer - elapsed;
LAB_0042427c:
	if ((globals::g_Game.flags1 & GAME1_DEBUG_NONERPS) == GAME1_NONE) {
		FUN_00453e70(elapsed);
	}
	else {
		image::Font_PrintF(globals::g_Game.bmpFONT5_HI,0,0,"NoNERPS");
	}
	if ((ushort)((ushort)((globals::g_Game.level)->oxygenLevel < 0.0) << 8 |
							(ushort)((globals::g_Game.level)->oxygenLevel == 0.0) << 0xe) == 0) {
		fVar1 = (globals::g_Game.level)->oxygenLevel;
		if ((globals::g_Game.level)->float_204 - 5.0 <= (globals::g_Game.level)->oxygenLevel) {
			if ((ushort)((ushort)(fVar1 < (globals::g_Game.level)->float_204) << 8 |
									(ushort)(fVar1 == (globals::g_Game.level)->float_204) << 0xe) == 0) {
				if ((undefined *)(globals::g_Game.level)->oxygenLevel == &DAT_42c80000) {
					front::Info_FUN_00419ab0(INFO_AIRRESTORED,(char *)0x0,(LiveObject *)0x0,(Point2I *)0x0);
				}
				(globals::g_Game.level)->float_204 = (globals::g_Game.level)->oxygenLevel;
			}
		}
		else {
			if ((ushort)((ushort)(fVar1 < 10.0) << 8 | (ushort)(fVar1 == 10.0) << 0xe) == 0) {
				front::Info_FUN_00419ab0(INFO_AIRDEPLETING,(char *)0x0,(LiveObject *)0x0,(Point2I *)0x0);
				textType = TEXT_AIRSUPPLYRUNNINGOUT;
			}
			else {
				front::Info_FUN_00419ab0(INFO_AIRLOW,(char *)0x0,(LiveObject *)0x0,(Point2I *)0x0);
				textType = TEXT_AIRSUPPLYLOW;
			}
			front::Text_DisplayMessage(textType,1,0);
			(globals::g_Game.level)->float_204 = (globals::g_Game.level)->oxygenLevel;
		}
	}
	else {
		front::Info_FUN_00419ab0(INFO_AIROUT,(char *)0x0,(LiveObject *)0x0,(Point2I *)0x0);
	}
	if ((ushort)((ushort)((globals::g_Game.level)->oxygenLevel < 10.0) << 8 |
							(ushort)((globals::g_Game.level)->oxygenLevel == 10.0) << 0xe) == 0) {
		if ((globals::g_AirMeter_BeatUnkBool != 0) &&
			 (BVar3 = snd::SFX_GetType("SND_AirBeat",&local_30), BVar3 != 0)) {
			sfxType = snd::Sample_ChooseRandomSound(local_30);
			snd::Sample_StopSoundBufferInstance(sfxType);
		}
		BVar3 = 0;
	}
	else {
		if ((globals::g_AirMeter_BeatUnkBool == 0) &&
			 (BVar3 = snd::SFX_GetType("SND_AirBeat",&local_30), BVar3 != 0)) {
			snd::Audio_Play_FUN_00465260(local_30,1);
		}
		BVar3 = snd::SFX_GetType("SND_AirBeat",&local_30);
		if (BVar3 != 0) {
			iVar5 = snd::Sound3D_MinVolume();
			lVar14 = __ftol((float10)(globals::g_Game.level)->oxygenLevel * (float10)0.1 *
											(float10)iVar5 * (float10)0.1);
			iVar5 = snd::Sample_GetRandomVolume(local_30);
			if ((int)lVar14 != iVar5) {
				snd::Sample_PlayRandomAtVolume(local_30,(int)lVar14);
			}
		}
		BVar3 = 1;
	}
	front::AirMeter_SetAirBeat_UnkBool(BVar3);
	globals::g_Game.timerGame_e3c = globals::g_Game.timerGame_e3c - elapsedGame;
	return TRUE;
}



void __cdecl lego::game::LiveObject_ConsumeOxygen(LiveObject *liveObj,float elapsed)
{
	LevelData *pLVar1;
	float10 fVar2;
	
	pLVar1 = globals::g_Game.level;
	fVar2 = LiveObject_GetOxygenCoef(liveObj);
	if ((liveObj->objType != OBJECT_BUILDING) ||
		 ((liveObj->flags3 & LIVEOBJ3_UNK_20000000) != LIVEOBJ3_NONE)) {
		fVar2 = (float10)elapsed * (float10)0.04 * (float10)pLVar1->OxygenRate * fVar2 +
						(float10)pLVar1->oxygenLevel;
		pLVar1->oxygenLevel = (float)fVar2;
		if ((ushort)((ushort)(fVar2 < (float10)100.0) << 8 | (ushort)(fVar2 == (float10)100.0) << 0xe)
				== 0) {
			pLVar1->oxygenLevel = (float)&DAT_42c80000;
		}
		if (((ushort)((ushort)(pLVar1->oxygenLevel < 0.0) << 8 |
								 (ushort)(pLVar1->oxygenLevel == 0.0) << 0xe) != 0) &&
			 (pLVar1->oxygenLevel = 0.0, (globals::g_Game.flags1 & GAME1_UNK_8000000) == GAME1_NONE)) {
			Level_SetCompleteStatus(LEVELSTATUS_FAILED);
			return;
		}
	}
	return;
}



void __cdecl lego::game::Level_FUN_00424530(LevelData *level,float elapsedGame)
{
	LevelBlockFlags1 *pLVar1;
	uint uVar2;
	int iVar3;
	uint uVar4;
	int local_14;
	int local_10;
	int local_c;
	Point2I local_8;
	
	uVar2 = FUN_0040c2d0(elapsedGame,&local_c,&local_10);
	uVar4 = 0;
	if (uVar2 != 0) {
		do {
			FUN_0040c4a0(*(int *)(local_c + uVar4 * 4),*(int *)(local_10 + uVar4 * 4),&local_14,
									 (int *)&elapsedGame);
			local_8.x = local_14;
			local_8.y = (int)elapsedGame;
			iVar3 = ((globals::g_Game.level)->dimensions).width * (int)elapsedGame + local_14;
			(globals::g_Game.level)->blocks[iVar3].flags1 =
					 (globals::g_Game.level)->blocks[iVar3].flags1 & ~BLOCK1_UNK_800;
			if (((globals::g_Game.level)->blocks
					 [((globals::g_Game.level)->dimensions).width * (int)elapsedGame + local_14].flags1 &
					BLOCK1_UNK_1000) == BLOCK1_NONE) {
				Level_AddMessageAction(MESSAGE_ROCKFALL_COMPLETE,0,0,&local_8);
			}
			iVar3 = ((globals::g_Game.level)->dimensions).width * (int)elapsedGame + local_14;
			(globals::g_Game.level)->blocks[iVar3].flags1 =
					 (globals::g_Game.level)->blocks[iVar3].flags1 & ~BLOCK1_UNK_1000;
			pLVar1 = &(globals::g_Game.level)->blocks
								[((globals::g_Game.level)->dimensions).width * local_8.y + local_8.x].flags1;
			uVar4 = uVar4 + 1;
			*pLVar1 = *pLVar1 & ~BLOCK1_UNK_8000000;
		} while (uVar4 < uVar2);
	}
	return;
}



void __cdecl lego::game::Game_UpdateSceneFog(BOOL isFogEnabled,float elapsed)
{
	uint uVar1;
	uint uVar2;
	float10 fVar3;
	float10 fVar4;
	ColourRGBF local_c;
	
	if ((globals::g_Game.flags1 & GAME1_FOGCOLOURRGB) != GAME1_NONE) {
		res::Container_EnableFog(isFogEnabled);
		if ((isFogEnabled != 0) && ((globals::g_Game.flags1 & GAME1_HIGHFOGCOLOURRGB) != GAME1_NONE)) {
			fVar3 = ((float10)6.283185 / (float10)globals::g_Game.FogRate) * (float10)elapsed +
							(float10)FLOAT_004df53c;
			FLOAT_004df53c = (float)fVar3;
			fVar3 = (float10)fsin(fVar3);
			uVar1 = 0;
			do {
				uVar2 = uVar1 + 4;
				fVar4 = ((float10)*(float *)((int)globals::g_Game.objTeleportQueueTypes_TABLE +
																		(uVar1 - 0x5c)) -
								(float10)*(float *)((int)globals::g_Game.table10_2f8 + uVar1 + 0x54)) * (float10)0.5
				;
				*(float *)((int)&local_c.red + uVar1) =
						 (float)(fVar4 + (float10)*(float *)((int)globals::g_Game.table10_2f8 + uVar1 + 0x54) +
										fVar4 * fVar3);
				uVar1 = uVar2;
			} while (uVar2 < 0xc);
			res::Container_SetFogColour(local_c.red,local_c.green,local_c.blue);
		}
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_00424700(LiveObject *liveObj,int param_2)
{
	if ((liveObj->flags4 & 1) != LIVEOBJ4_NONE) {
		LiveObject_FUN_004247e0(liveObj,param_2,1.0,0.0,0.0);
	}
	return 0;
}



void __cdecl FUN_00424740(LiveObject *liveObj)
{
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(lego::game::LiveObject_FUN_00424700,liveObj);
	return;
}



void __cdecl FUN_00424760(int param_1)
{
	uint uVar1;
	LiveObject **ppLVar2;
	uint local_c;
	
	uVar1 = lego::game::Game_GetNumSelectedUnits();
	ppLVar2 = lego::game::Game_GetSelectedUnits();
	for (local_c = 0; local_c < uVar1; local_c = local_c + 1) {
		if (local_c == 0) {
			lego::game::LiveObject_FUN_004247e0(*ppLVar2,param_1,0.0,1.0,0.0);
		}
		else {
			lego::game::LiveObject_FUN_004247e0(ppLVar2[local_c],param_1,1.0,1.0,0.0);
		}
	}
	return;
}



void __cdecl
lego::game::LiveObject_FUN_004247e0(LiveObject *liveObj,int param_2,float r,float g,float b)
{
	BOOL BVar1;
	SurfaceMap *surfMap;
	int iVar2;
	uint uVar3;
	float10 fVar4;
	longlong lVar5;
	char *msg;
	Point2F local_e8;
	float local_e0;
	float local_dc;
	float local_d8;
	float local_d4;
	float local_d0;
	float local_cc;
	float local_c8;
	float local_c4;
	float local_c0;
	float local_bc;
	float local_b8;
	float local_b4;
	float local_b0;
	float local_ac;
	Vector3F local_a8;
	Vector3F local_9c;
	Point2F local_90;
	float local_88;
	float local_84;
	float local_80;
	float local_7c;
	float local_78;
	float local_74;
	float local_70;
	float local_6c;
	float local_68;
	float local_64;
	float local_60;
	float local_5c;
	float local_58;
	float local_54;
	float local_50;
	Vector3F local_4c;
	Point2F local_40 [2];
	Vector4F local_30;
	Vector3F local_20;
	Vector3F local_14;
	float local_8;
	
	local_4c.x = 0.0;
	local_4c.y = 1.0;
	local_4c.z = 0.0;
	BVar1 = LiveObject_FUN_0044a2b0(liveObj);
	if (BVar1 == 0) {
		if ((globals::g_Game.flags1 & GAME1_CAMERADISABLED) != GAME1_NONE) {
			r = r * 0.3;
			g = g * 0.3;
			b = b * 0.3;
		}
		LiveObject_GetPosition(liveObj,(float *)&local_a8,&local_a8.y);
		surfMap = GetSurfaceMap();
		fVar4 = SurfaceMap_GetSurfaceZ(surfMap,local_a8.x,local_a8.y);
		local_a8.z = (float)fVar4;
		fVar4 = LiveObject_GetCollHeight(liveObj);
		local_a8.z = (float)((float10)local_a8.z - fVar4 / (float10)2.0);
		lego::view::Viewport_WorldToScreen((Viewport *)param_2,(Point2F *)&local_30,&local_a8);
		if ((0.0 <= local_30.x) && (0.0 <= local_30.y)) {
			iVar2 = main::GetResolutionWidth();
			if (local_30.x <= (float)iVar2) {
				iVar2 = main::GetResolutionHeight();
				if (local_30.y <= (float)iVar2) {
					local_30.z = 0.0;
					local_30.w = 1.0;
					lego::view::Viewport_InverseTransform((Viewport *)param_2,&local_9c,&local_30);
					math::Vector3_Subtract(&local_14,&local_a8,&local_9c);
					math::Vector3_Normalize(&local_14);
					math::Vector3_CrossProduct(&local_20,&local_14,&local_4c);
					math::Vector3_Normalize(&local_20);
					fVar4 = LiveObject_GetPickSphere(liveObj);
					math::Vector3_Scale(&local_20,&local_20,(float)fVar4);
					math::Vector3_Add(&local_a8,&local_a8,&local_20);
					lego::view::Viewport_WorldToScreen((Viewport *)param_2,local_40,&local_a8);
					fVar4 = math::Vector2_Distance((Point2F *)&local_30,local_40);
					local_50 = (float)(fVar4 / (float10)2.5);
					local_8 = (float)((fVar4 / (float10)2.5) / (float10)5.0 + (float10)3.0);
					local_e8.x = local_30.x - local_50;
					local_e8.y = (local_30.y - local_50) + local_8;
					local_90.x = local_30.x - local_50;
					local_90.y = local_30.y - local_50;
					local_e0 = (local_30.x - local_50) + 1.0;
					local_dc = local_30.y - local_50;
					local_88 = (local_30.x - local_50) + local_8;
					local_84 = local_30.y - local_50;
					local_d8 = (local_30.x + local_50) - local_8;
					local_d4 = local_30.y - local_50;
					local_80 = local_30.x + local_50;
					local_7c = local_30.y - local_50;
					local_d0 = local_30.x + local_50;
					local_cc = (local_30.y - local_50) + 1.0;
					local_78 = local_30.x + local_50;
					local_74 = (local_30.y - local_50) + local_8;
					local_c8 = local_30.x + local_50;
					local_c4 = (local_30.y + local_50) - local_8;
					local_70 = local_30.x + local_50;
					local_6c = local_30.y + local_50;
					local_c0 = (local_30.x + local_50) - 1.0;
					local_bc = local_30.y + local_50;
					local_68 = (local_30.x + local_50) - local_8;
					local_64 = local_30.y + local_50;
					local_b8 = (local_30.x - local_50) + local_8;
					local_b4 = local_30.y + local_50;
					local_60 = local_30.x - local_50;
					local_5c = local_30.y + local_50;
					local_b0 = local_30.x - local_50;
					local_ac = (local_30.y + local_50) - 1.0;
					local_58 = local_30.x - local_50;
					local_54 = (local_30.y + local_50) - local_8;
					draw::Draw_LineListEx(&local_e8,&local_90,8,r,g,b,DrawEffect_None);
					if ((((globals::g_Game.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) &&
							(liveObj->customName != (char *)0x0)) && (*liveObj->customName != '\0')) {
						msg = liveObj->customName;
						lVar5 = __ftol((float10)local_30.y - (float10)local_50);
						uVar3 = image::Font_GetHeight(globals::g_Game.bmpToolTipFont);
						iVar2 = (int)lVar5 - uVar3;
						lVar5 = __ftol((float10)local_30.x - (float10)local_50);
						image::Font_PrintF(globals::g_Game.bmpToolTipFont,(int)lVar5,iVar2,msg);
					}
				}
			}
		}
	}
	return;
}



void __cdecl lego::main::Game_Exit(void)
{
	Game_Exit();
	return;
}



void __cdecl lego::main::Game_Cleanup(void)
{
	BOOL BVar1;
	char *filename;
	uint uVar2;
	char *unaff_EDI;
	int iVar3;
	
	Main_ShowShutdownScreen();
	reward::Reward_CleanupBase();
	snd::Music_PlayNext(0);
	Config_SetSoundEnabled(0);
	game::Game_freeLevel__0042eff0();
	Main_CleanupUnkInteraces();
	cfg::CFG_Close(globals::g_Game.LegoCfgRoot);
	lego::view::Viewport_Remove(globals::g_Game.viewMain);
	res::Container_Remove(globals::g_Game.resRoot);
	lego::view::Camera_Cleanup(globals::g_Game.cameraMain);
	lego::view::Camera_Cleanup(globals::g_Game.cameraRadar);
	lego::view::Camera_Cleanup(globals::g_Game.cameraFP);
	uVar2 = 0;
	if (globals::g_Game.VehicleTypes_COUNT != 0) {
		iVar3 = 0;
		do {
			res::Vehicle_Destroy
								((VehicleData *)
								 ((int)(globals::g_Game.VehicleData_TABLE)->WheelMeshes + iVar3 + -0x10));
			std::free(globals::g_Game.VehicleTypes_TABLE[uVar2]);
			uVar2 = uVar2 + 1;
			iVar3 = iVar3 + 0x1ec;
		} while (uVar2 < globals::g_Game.VehicleTypes_COUNT);
	}
	std::free(globals::g_Game.VehicleTypes_TABLE);
	std::free(globals::g_Game.ObjectNames_VehicleTypes_TABLE);
	std::free(globals::g_Game.VehicleData_TABLE);
	uVar2 = 0;
	if (globals::g_Game.MiniFigureTypes_COUNT != 0) {
		iVar3 = 0;
		do {
			res::Creature_Destroy
								((CreatureData *)
								 ((int)(globals::g_Game.MiniFigureData_TABLE)->cameraFramesTable_54 + iVar3 + -0x54)
								);
			std::free(globals::g_Game.MiniFigureTypes_TABLE[uVar2]);
			uVar2 = uVar2 + 1;
			iVar3 = iVar3 + 0x74;
		} while (uVar2 < globals::g_Game.MiniFigureTypes_COUNT);
	}
	std::free(globals::g_Game.MiniFigureTypes_TABLE);
	std::free(globals::g_Game.ObjectNames_MiniFigureTypes_TABLE);
	std::free(globals::g_Game.MiniFigureData_TABLE);
	uVar2 = 0;
	if (globals::g_Game.RockMonsterTypes_COUNT != 0) {
		iVar3 = 0;
		do {
			res::Creature_Destroy
								((CreatureData *)
								 ((int)(globals::g_Game.RockMonsterData_TABLE)->cameraFramesTable_54 + iVar3 + -0x54
								 ));
			std::free(globals::g_Game.RockMonsterTypes_TABLE[uVar2]);
			uVar2 = uVar2 + 1;
			iVar3 = iVar3 + 0x74;
		} while (uVar2 < globals::g_Game.RockMonsterTypes_COUNT);
	}
	std::free(globals::g_Game.RockMonsterTypes_TABLE);
	std::free(globals::g_Game.ObjectNames_RockMonsterTypes_TABLE);
	std::free(globals::g_Game.RockMonsterData_TABLE);
	uVar2 = 0;
	if (globals::g_Game.UpgradeTypes_COUNT != 0) {
		iVar3 = 0;
		do {
			res::Upgrade_Destroy
								((UpgradeData *)((int)&(globals::g_Game.UpgradeData_TABLE)->objectIndex + iVar3));
			std::free(globals::g_Game.UpgradeTypes_TABLE[uVar2]);
			uVar2 = uVar2 + 1;
			iVar3 = iVar3 + 0x10;
		} while (uVar2 < globals::g_Game.UpgradeTypes_COUNT);
	}
	std::free(globals::g_Game.UpgradeTypes_TABLE);
	std::free(globals::g_Game.ObjectNames_UpgradeTypes_TABLE);
	std::free(globals::g_Game.UpgradeData_TABLE);
	uVar2 = 0;
	if (globals::g_Game.BuildingTypes_COUNT != 0) {
		iVar3 = 0;
		do {
			res::Building_Destroy
								((BuildingData *)
								 ((int)(globals::g_Game.BuildingData_TABLE)->carryFramesTable_28 + iVar3 + -0x28));
			std::free(globals::g_Game.BuildingTypes_TABLE[uVar2]);
			uVar2 = uVar2 + 1;
			iVar3 = iVar3 + 0x14c;
		} while (uVar2 < globals::g_Game.BuildingTypes_COUNT);
	}
	std::free(globals::g_Game.BuildingTypes_TABLE);
	std::free(globals::g_Game.ObjectNames_BuildingTypes_TABLE);
	std::free(globals::g_Game.BuildingData_TABLE);
	std::free(globals::g_Game.ObjectNames_PowerCrystal);
	std::free(globals::g_Game.ObjectNames_Ore);
	std::free(globals::g_Game.ObjectNames_ProcessedOre);
	std::free(globals::g_Game.ObjectNames_Dynamite);
	std::free(globals::g_Game.ObjectNames_Barrier);
	std::free(globals::g_Game.ObjectNames_ElectricFence);
	std::free(globals::g_Game.ObjectNames_SpiderWeb);
	std::free(globals::g_Game.ObjectNames_OohScary);
	std::free(globals::g_Game.ObjectNames_Path);
	front::TextWindow_Remove(globals::g_Game.textWnd_80);
	image::Font_Remove(globals::g_Game.bmpFONT5_HI);
	image::Font_Remove(globals::g_Game.bmpToolTipFont);
	Main_CleanupRockFallStyles();
	pool::ReservedPool_AITask___Cleanup();
	pool::ReservedPool_LiveObject___Cleanup();
	res::Container_Shutdown();
	lego::view::Viewport_Shutdown();
	if (globs::mainGlobs.programmerLevel == PROGRAMMER_MODE_10) {
		BVar1 = snd::Sound_IsInitialised();
		filename = "LoaderProfile.txt";
		if (BVar1 == 0) {
			filename = "LoaderProfileNoSound.txt";
		}
	}
	else {
		filename = (char *)0x0;
	}
	lego::file::Log_LoaderProfile(filename);
	util::logf_removed(unaff_EDI);
	image::Image_Shutdown();
	res::Lws_Shutdown();
	snd::Sound3D_ShutDown();
	ddraw::DirectDraw_Clear((Rect2F *)0x0,0);
	return;
}



void __cdecl lego::main::Game_Exit(void)
{
	snd::Music_PlayNext(0);
	std::exit(0);
	return;
}



BOOL __cdecl
lego::game::Game_DoHotkeyChecks
					(float elapsedGame,float param_2,BOOL *out_t,BOOL *put_r,BOOL *out_shift)
{
	BOOL *pBVar1;
	BOOL *pBVar2;
	BOOL *pBVar3;
	LiveObject *pLVar4;
	Container *cont;
	BOOL BVar5;
	TutorialFlags TVar6;
	char *pcVar7;
	int iVar8;
	BOOL3 BVar9;
	int iVar10;
	bool bVar11;
	float10 fVar12;
	ActivityType actType;
	undefined4 actData;
	Point2F local_14;
	Vector3F local_c;
	
										// IsKeyReleased(KEY_RETURN) (28)
										//  "Submit unit rename input."
	if ((((((globals::g_Game.flags2 & GAME2_ALLOWRENAME) != GAME2_NONE) &&
				(globs::INPUT.Key_Map[28] == false)) && (globs::INPUT.prevKey_Map[28] != false)) &&
			(((globals::g_Game.viewMode == VIEW_TOPDOWN &&
				((globals::g_Game.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE)) &&
			 ((pLVar4 = Game_GetPrimarySelectedObject(), pLVar4 != (LiveObject *)0x0 &&
				(pLVar4->objType == OBJECT_MINIFIGURE)))))) &&
		 ((pLVar4->flags5_3f0 != LIVEOBJ5_NONE || (pLVar4->objLevel != 0)))) {
		cont = LiveObject_GetResource(pLVar4);
		res::Container_GetPosition(cont,(Container *)0x0,&local_c);
		fVar12 = LiveObject_GetCollHeight(pLVar4);
		local_c.z = (float)((float10)local_c.z - fVar12 * (float10)0.5);
		lego::view::Viewport_WorldToScreen(globals::g_Game.viewMain,&local_14,&local_c);
		if ((40.0 <= local_14.x) &&
			 (((40.0 <= local_14.y &&
				 ((ushort)((ushort)(local_14.x < (float)globs::mainGlobs.appWidth - 40.0) << 8 |
									(ushort)(local_14.x == (float)globs::mainGlobs.appWidth - 40.0) << 0xe) != 0)) &&
				((ushort)((ushort)(local_14.y < (float)globs::mainGlobs.appHeight - 80.0) << 8 |
								 (ushort)(local_14.y == (float)globs::mainGlobs.appHeight - 80.0) << 0xe) != 0)))) {
			FUN_00425b60(0,1);
			if (pLVar4->customName == (char *)0x0) {
				LiveObject_SetCustomName(pLVar4,"Object");
				*pLVar4->customName = '\0';
			}
			globals::g_Game.renameInput = pLVar4->customName;
			globals::g_Game.renamePosition.x = local_14.x;
			globals::g_Game.renamePosition.y = local_14.y;
		}
	}
										// IsKeyDown(KEY_ESCAPE) (1)
	if (globs::INPUT.Key_Map[1] != false) {
		if ((((globals::g_Game.flags2 & GAME2_INOPTIONSMENU) == GAME2_NONE) &&
				(BVar5 = FUN_004190d0(), BVar5 == 0)) &&
			 ((BVar5 = Level_IsObjectiveFinished(), BVar5 == 0 &&
				((globals::g_Game.flags1 & GAME1_UNK_8000000) == GAME1_NONE)))) {
			if ((globals::g_Game.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
										// IsKeyUp(KEY_SPACE) (57)
				if (globs::INPUT.Key_Map[57] == false) {
										// IsKeyDown(KEY_RETURN) (28)
					if (globs::INPUT.Key_Map[28] != false) {
						return 0;
					}
				}
				else {
					snd::Sound3D_ShutDown();
					main::Game_Exit();
				}
			}
			FUN_00425b60(0,1);
			globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_PAUSED;
		}
		else {
										// IsKeyDown(KEY_ESCAPE) (1)
			if (((globs::INPUT.Key_Map[1] != false) &&
					((globals::g_Game.flags2 & GAME2_INOPTIONSMENU) == GAME2_NONE)) &&
				 ((BVar5 = FUN_004190d0(), BVar5 == 0 &&
					((BVar5 = Level_IsObjectiveFinished(), BVar5 == 0 &&
					 ((globals::g_Game.flags1 & GAME1_UNK_8000000) == GAME1_NONE)))))) {
				snd::Sound3D_ShutDown();
				main::Game_Exit();
			}
		}
	}
	if ((globals::g_Game.flags2 & GAME2_UNK_2) != GAME2_NONE) {
		BVar5 = main::Config_IsFrontEndEnabled();
										// IsKeyDown(KEY_SPACE) (57)
		if ((BVar5 == 0) || (globs::INPUT.Key_Map[57] != false)) {
			snd::Sound3D_ShutDown();
			main::Game_Exit();
		}
		else {
										// IsKeyDown(KEY_RETURN) (28)
			if (globs::INPUT.Key_Map[28] != false) {
				return 0;
			}
			BVar5 = FUN_00435870();
			if (BVar5 == 0) {
				return 0;
			}
		}
	}
	pBVar3 = out_shift;
	pBVar2 = put_r;
	pBVar1 = out_t;
	*out_t = 0;
	*put_r = 0;
	*out_shift = 0;
	if ((globals::g_Game.flags1 & (GAME1_CAMERADISABLED|GAME1_UNK_8000000)) == GAME1_NONE) {
		front::Front_DoF2InterfaceKeyAction();
										// IsKeyPressed(KEY_SPACE) (57)
										//  "Toggle unit info bubbles/HUDs visibility."
		if ((globs::INPUT.Key_Map[57] != false) &&
			 (globs::INPUT.prevKey_Map[57] != globs::INPUT.Key_Map[57])) {
			Game_ToggleObjectUIsAlwaysVisible();
		}
										// IsKeyDown(KEY_LEFTSHIFT) (42) || IsKeyDown(KEY_RIGHTSHIFT) (54)
		if ((globs::INPUT.Key_Map[42] != false) || (globs::INPUT.Key_Map[54] != false)) {
			*pBVar3 = 1;
		}
		if ((globals::g_Game.viewMode == VIEW_TOPDOWN) &&
			 (TVar6 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0),
			 (TVar6 & TUTORIAL_UNK_1000) == TUTORIAL_NONE)) {
										// IsKeyDown(KEY_CURSORDOWN) (208)
										//  "Topdown view: Pitch lower (around center)."
			if (globs::INPUT.Key_Map[208] != false) {
				lego::view::Camera_AddTilt(globals::g_Game.cameraMain,param_2 * 0.02);
			}
										// IsKeyDown(KEY_CURSORUP) (200)
										//  "Topdown view: Pitch raise (around center)."
			if (globs::INPUT.Key_Map[200] != false) {
				lego::view::Camera_AddTilt(globals::g_Game.cameraMain,param_2 * -0.02);
			}
										// IsKeyDown(KEY_CURSORLEFT) (203)
										//  "Topdown view: Rotate clockwise (around center)."
			if (globs::INPUT.Key_Map[203] != false) {
				lego::view::Camera_AddYaw(globals::g_Game.cameraMain,param_2 * 0.02);
			}
										// IsKeyDown(KEY_CURSORRIGHT) (205)
										//  "Topdown view: Rotate counter-clockwise (around center)."
			if (globs::INPUT.Key_Map[205] != false) {
				lego::view::Camera_AddYaw(globals::g_Game.cameraMain,param_2 * -0.02);
			}
										// IsKeyDown(KEY_MINUS) (12)
										//  "Topdown view: Zoom out."
			if (globs::INPUT.Key_Map[12] != false) {
				lego::view::AddDist(globals::g_Game.cameraMain,param_2 * 3.0);
			}
										// IsKeyDown(KEY_EQUALS) (13)  "+""Topdown view: Zoom in."
			if (globs::INPUT.Key_Map[13] != false) {
				lego::view::AddDist(globals::g_Game.cameraMain,param_2 * -3.0);
			}
		}
		if ((globals::g_Game.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
										// IsKeyDown(KEYPAD_7) (71)
										//  "Set game speed to 300%."
			if (globs::INPUT.Key_Map[71] != false) {
				Game_SetGameSpeed(3.0);
			}
										// IsKeyDown(KEY_T) (20)
			if (globs::INPUT.Key_Map[20] != false) {
				*pBVar1 = 1;
			}
										// IsKeyDown(KEY_R) (19)
			if (globs::INPUT.Key_Map[19] != false) {
				*pBVar2 = 1;
			}
										// IsKeyPressed(KEY_L) (38)
			if (((globs::INPUT.Key_Map[38] != false) &&
					(globs::INPUT.prevKey_Map[38] != globs::INPUT.Key_Map[38])) &&
				 (BVar5 = FUN_00435870(), BVar5 == 0)) {
				return 0;
			}
										// IsKeyDown(KEY_LEFTCTRL) (29) && IsKeyPressed(KEY_F) (33)
										//  "Toggle framerate monitor."
			if (((globs::INPUT.Key_Map[29] != false) && (globs::INPUT.Key_Map[33] != false)) &&
				 (globs::INPUT.prevKey_Map[33] != globs::INPUT.Key_Map[33])) {
				if ((globals::g_Game.flags1 & GAME1_FRAMERATEMONITOR) == GAME1_NONE) {
					globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_FRAMERATEMONITOR;
				}
				else {
					globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_FRAMERATEMONITOR;
				}
				pcVar7 = "ON";
				if ((globals::g_Game.flags1 & GAME1_FRAMERATEMONITOR) == GAME1_NONE) {
					pcVar7 = "OFF";
				}
				front::TextWindow_PrintF(globals::g_Game.textWnd_80,"\nFrame Rate Monitor: %s",pcVar7);
			}
										// IsKeyPressed(KEY_TAB) (15)
										//  "Toggle between Radar Map/Track Object View."
			if ((((globals::g_Game.flags1 & GAME1_RADARON) != GAME1_NONE) &&
					(globs::INPUT.Key_Map[15] != false)) &&
				 (globs::INPUT.prevKey_Map[15] != globs::INPUT.Key_Map[15])) {
				bVar11 = (globals::g_Game.flags1 & GAME1_RADAR_TRACKOBJECTVIEW) == GAME1_NONE;
				if (bVar11) {
					globals::g_Game.flags1 =
							 globals::g_Game.flags1 &
							 (GAME1_HIGHFOGCOLOURRGB|GAME1_UNK_20000|GAME1_UNK_40000|GAME1_DYNAMICPM|
								GAME1_CAMERADISABLED|GAME1_UNK_200000|GAME1_ONLYBUILDONPATHS|GAME1_ALWAYSROCKFALL|
								GAME1_DEBUG_NONERPS|GAME1_PAUSED|GAME1_STREAMNERPSSPEACH|GAME1_UNK_8000000|
								GAME1_LASERTRACKER|GAME1_UNK_20000000|GAME1_DEBUG_NOCLIP_FPS|GAME1_UNK_80000000) |
							 (ushort)((ushort)globals::g_Game.flags1 | 0x2000) & ~GAME1_RADAR_MAPVIEW;
					front::Panel_FUN_0045ad80(PANEL_RADAR,2,1);
				}
				else {
					globals::g_Game.flags1 =
							 globals::g_Game.flags1 & ~GAME1_RADAR_TRACKOBJECTVIEW | GAME1_RADAR_MAPVIEW;
					front::Panel_FUN_0045ad80(PANEL_RADAR,2,0);
				}
				front::Panel_FUN_0045ad80(PANEL_RADAR,3,(uint)bVar11);
			}
										// IsKeyDown(KEY_LEFTCTRL) (29)
			if (globs::INPUT.Key_Map[29] != false) {
										// IsKeyPressed(KEY_G) (34)
										//  "Toggle memory monitor."
				if ((globs::INPUT.Key_Map[34] != false) &&
					 (globs::INPUT.prevKey_Map[34] != globs::INPUT.Key_Map[34])) {
					if ((globals::g_Game.flags1 & GAME1_MEMORYMONITOR) == GAME1_NONE) {
						globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_MEMORYMONITOR;
					}
					else {
						globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_MEMORYMONITOR;
					}
					pcVar7 = "ON";
					if ((globals::g_Game.flags1 & GAME1_MEMORYMONITOR) == GAME1_NONE) {
						pcVar7 = "OFF";
					}
					front::TextWindow_PrintF(globals::g_Game.textWnd_80,"\nMemory Monitor: %s",pcVar7);
				}
										// IsKeyDown(KEY_LEFTCTRL) (29) && IsKeyPressed(KEY_RETURN) (28)
										//  "Toggle Noclip in first/second person view."
				if (((globs::INPUT.Key_Map[29] != false) && (globs::INPUT.Key_Map[28] != false)) &&
					 (globs::INPUT.prevKey_Map[28] != globs::INPUT.Key_Map[28])) {
					if ((globals::g_Game.flags1 & GAME1_DEBUG_NOCLIP_FPS) == GAME1_NONE) {
						globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_DEBUG_NOCLIP_FPS;
					}
					else {
						globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_DEBUG_NOCLIP_FPS;
					}
				}
			}
		}
		if ((globals::g_Game.viewMode == VIEW_FIRSTPERSON) &&
			 ((*(byte *)&(globals::g_Game.objectFP)->flags2 & LIVEOBJ2_UNK_1) == 0)) {
										// First person view controls
										// IsKeyDown(KEY_CURSORUP) (200)
										//  "First person view: Move forward."
			if (globs::INPUT.Key_Map[200] != false) {
				LiveObject_FPMove(globals::g_Game.objectFP,1,0,0.0);
			}
										// IsKeyDown(KEY_CURSORDOWN) (208)
										//  "First person view: Move back."
			if (globs::INPUT.Key_Map[208] != false) {
				LiveObject_FPMove(globals::g_Game.objectFP,-1,0,0.0);
			}
										// IsKeyDown(KEY_CURSORLEFT) (203)
										//  "First person view: Turn left."
			if (globs::INPUT.Key_Map[203] != false) {
				LiveObject_FPMove(globals::g_Game.objectFP,0,0,-0.05);
			}
										// IsKeyDown(KEY_CURSORRIGHT) (205)
										//  "First person view: Turn right."
			if (globs::INPUT.Key_Map[205] != false) {
				LiveObject_FPMove(globals::g_Game.objectFP,0,0,0.05);
			}
										// IsKeyDown(KEY_Z) (44)
										//  "First person view: Strafe left."
			if (globs::INPUT.Key_Map[44] != false) {
				LiveObject_FPMove(globals::g_Game.objectFP,0,-1,0.0);
			}
										// IsKeyDown(KEY_X) (45)
										//  "First person view: Strafe right."
			if (globs::INPUT.Key_Map[45] != false) {
				LiveObject_FPMove(globals::g_Game.objectFP,0,1,0.0);
			}
		}
		if ((globals::g_Game.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
										// IsKeyPressed(KEY_S) (31)
										//  "Toggle sound On/Off."
			if ((globs::INPUT.Key_Map[31] != false) &&
				 (globs::INPUT.prevKey_Map[31] != globs::INPUT.Key_Map[31])) {
				if ((globals::g_Game.flags1 & GAME1_SOUNDON) == GAME1_NONE) {
					main::Config_SetSoundEnabled(1);
					snd::Audio_Play_FUN_00465260(SFX_AMBIENTLOOP,1);
				}
				else {
					main::Config_SetSoundEnabled(0);
				}
				pcVar7 = "ON";
				if ((globals::g_Game.flags1 & GAME1_SOUNDON) == GAME1_NONE) {
					pcVar7 = "OFF";
				}
				front::TextWindow_PrintF(globals::g_Game.textWnd_80,"\nSound Effects: %s",pcVar7);
			}
										// IsKeyPressed(KEY_M) (55)
										//  "Toggle music On/Off."
			if ((globs::INPUT.Key_Map[50] != false) &&
				 (globs::INPUT.prevKey_Map[50] != globs::INPUT.Key_Map[50])) {
				snd::Music_PlayNext((uint)((globals::g_Game.flags1 & GAME1_MUSICON) == GAME1_NONE));
				pcVar7 = "ON";
				if ((globals::g_Game.flags1 & GAME1_MUSICON) == GAME1_NONE) {
					pcVar7 = "OFF";
				}
				front::TextWindow_PrintF(globals::g_Game.textWnd_80,"\nMusic: %s",pcVar7);
			}
		}
										// IsKeyPressed(KEYPAD_0) (82)
		if ((((globals::g_Game.flags2 & GAME2_ALLOWEDITMODE) != GAME2_NONE) &&
				(globs::INPUT.Key_Map[82] != false)) &&
			 (globs::INPUT.prevKey_Map[82] != globs::INPUT.Key_Map[82])) {
			lego::view::Camera_Debug_AllowEditModeFunc1(globals::g_Game.cameraMain,0);
			res::ResLp_UnkSetup3DFrameTransform(globals::g_Game.RES_2f4_TABLEUNK,1);
		}
										// IsKeyPressed(KEY_Z) (44)
										//  "Make primary selected unit eat."
		if ((((globals::g_Game.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) &&
				(globs::INPUT.Key_Map[44] != false)) &&
			 (globs::INPUT.prevKey_Map[44] != globs::INPUT.Key_Map[44])) {
			lego::view::Camera_SetFloata0_a4_Zeroa8(globals::g_Game.cameraMain,5.0,25.0);
			pLVar4 = Game_GetPrimarySelectedObject();
			if (pLVar4 != (LiveObject *)0x0) {
				pLVar4 = Game_GetPrimarySelectedObject();
				actData = 0;
				actType = ACTIVITY_EAT;
				pLVar4->flags1 = pLVar4->flags1 | LIVEOBJ1_EATING;
				pLVar4 = Game_GetPrimarySelectedObject();
				LiveObject_SetActivityUnk(pLVar4,actType,actData);
				pLVar4 = Game_GetPrimarySelectedObject();
				Game_UpdateSomeAITasks(pLVar4);
				pLVar4 = Game_GetPrimarySelectedObject();
				ai::AITask_DoAnimationWait(pLVar4);
			}
		}
	}
	iVar10 = 0;
	param_2 = 0.0;
	if ((DAT_004df540 != 0) && (globs::INPUT.mslb == 0)) {
		iVar10 = 1;
	}
										// IsKeyUp(KEY_SPACE) && !IsKeyReleased(KEY_SPACE) (57)
	if ((globs::INPUT.Key_Map[57] == false) ||
		 (globs::INPUT.prevKey_Map[57] == globs::INPUT.Key_Map[57])) {
		iVar8 = 0;
	}
	else {
		iVar8 = 1;
	}
	iVar10 = FUN_00458c80(iVar8,iVar10,(uint *)&param_2);
	if ((((iVar10 == 0) && (BVar5 = FUN_004190d0(), BVar5 == 0)) &&
			(BVar5 = Level_IsObjectiveFinished(), BVar5 == 0)) &&
		 (((globals::g_Game.flags1 & GAME1_UNK_8000000) == GAME1_NONE &&
			((globals::g_Game.flags2 & GAME2_INOPTIONSMENU) == GAME2_NONE)))) {
										// IsKeyPressed(KEY_P) (25)
										//  "Pause/unpause the game."
		if ((globs::INPUT.Key_Map[25] != false) &&
			 (globs::INPUT.prevKey_Map[25] != globs::INPUT.Key_Map[25])) {
			FUN_00425b60(1,0);
			globals::g_Game.flags1 = globals::g_Game.flags1 ^ GAME1_PAUSED;
		}
		if (globs::mainGlobs.active == 0) {
			pcVar7 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","LoseFocusAndPause",0);
			BVar9 = cfg::CFG_ReadBool(globals::g_Game.LegoCfgRoot,pcVar7);
			if (((BVar9 == BOOL3_TRUE) && ((globals::g_Game.flags1 & GAME1_UNK_8000000) == GAME1_NONE)) &&
				 (FUN_00425b60(0,1), (globals::g_Game.flags1 & GAME1_PAUSED) == GAME1_NONE)) {
				globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_PAUSED;
			}
		}
	}
	DAT_004df540 = globs::INPUT.mslb;
	if (param_2 != 0.0) {
		return 0;
	}
	if ((globals::g_Game.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
										// IsKeyUp(KEY_LEFTSHIFT) (42)
		if (globs::INPUT.Key_Map[42] == false) {
										// IsKeyDown(KEY_FIVE) (6)
			if (globs::INPUT.Key_Map[6] != false) {
				globals::g_CursorLightLevel_Base = globals::g_CursorLightLevel_Base - 0.02;
				res::Container_Light_SetSpotPenumbra
									(globals::g_Game.resRootSpotlight,globals::g_CursorLightLevel_Base);
			}
										// IsKeyDown(KEY_SIX) (7)
			if (globs::INPUT.Key_Map[7] != false) {
				globals::g_CursorLightLevel_Current = globals::g_CursorLightLevel_Current - 0.02;
				goto LAB_004259b9;
			}
		}
		else {
										// IsKeyDown(KEY_FIVE) (6)
			if (globs::INPUT.Key_Map[6] != false) {
				globals::g_CursorLightLevel_Base = globals::g_CursorLightLevel_Base - -0.02;
				res::Container_Light_SetSpotPenumbra
									(globals::g_Game.resRootSpotlight,globals::g_CursorLightLevel_Base);
			}
										// IsKeyDown(KEY_SIX) (7)
			if (globs::INPUT.Key_Map[7] != false) {
				globals::g_CursorLightLevel_Current = globals::g_CursorLightLevel_Current - -0.02;
LAB_004259b9:
				res::Container_Light_SetSpotUmbra
									(globals::g_Game.resRootSpotlight,globals::g_CursorLightLevel_Current);
			}
		}
		if ((globals::g_Game.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) goto LAB_004259d8;
	}
	if ((globs::mainGlobs.flags & CMD_DEBUGCOMPLETE) == CMD_NONE) {
		return 1;
	}
LAB_004259d8:
										// IsKeyDown(KEY_LEFTCTRL) (29)
	if (globs::INPUT.Key_Map[29] != false) {
										// IsKeyPressed(KEY_D) (32)
										//  "Instantly fails the current level."
		if ((globs::INPUT.Key_Map[32] != false) &&
			 (globs::INPUT.prevKey_Map[32] != globs::INPUT.Key_Map[32])) {
			nerps::funcs::NERPFunc__SetLevelFail((int *)0x0);
		}
										// IsKeyPressed(KEY_S) (31)
										//  "Instantly completes the current level."
		if ((globs::INPUT.Key_Map[31] != false) &&
			 (globs::INPUT.prevKey_Map[31] != globs::INPUT.Key_Map[31])) {
			nerps::funcs::NERPFunc__SetLevelCompleted((int *)0x0);
		}
	}
										// IsKeyDown(KEY_RIGHTCTRL) (157)  && IsKeyPressed(KEY_S) (31)
										//  "Instantly fails the current level with reason, too many crystals stolen."
	if (((globs::INPUT.Key_Map[157] != false) && (globs::INPUT.Key_Map[31] != false)) &&
		 (globs::INPUT.prevKey_Map[31] != globs::INPUT.Key_Map[31])) {
		Level_SetCompleteStatus(LEVELSTATUS_FAILED_CRYSTALS);
	}
										// IsKeyDown(KEY_O) (24)
										//  "Decreases oxygen level."
	if (globs::INPUT.Key_Map[24] != false) {
		(globals::g_Game.level)->oxygenLevel = (globals::g_Game.level)->oxygenLevel - 1.0;
	}
	return 1;
}



BOOL __cdecl FUN_00425a70(undefined param_1)
{
	BOOL BVar1;
	
	BVar1 = lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
										(lego::game::LiveObject_FUN_00425a90,(LiveObject *)&param_1);
	return BVar1;
}



BOOL __cdecl lego::game::LiveObject_FUN_00425a90(LiveObject *liveObj,int *param_2)
{
	Container *cont;
	SFXType SVar1;
	BOOL flag2;
	BOOL flag4;
	Vector3F *opt_position;
	
	cont = LiveObject_GetResource(liveObj);
	if (cont != (Container *)0x0) {
		if ((liveObj->flags4 & LIVEOBJ4_UNK_20000) == LIVEOBJ4_NONE) {
			if (*param_2 != 0) {
				snd::Sample_StopSoundBufferInstance(liveObj->field_350);
			}
			if ((*(byte *)&liveObj->flags1 & 8) != 0) {
				opt_position = (Vector3F *)0x0;
				flag4 = 1;
				flag2 = 1;
				SVar1 = LiveObject_GetDrillSoundType(liveObj,0);
				res::Res_PlayResourceSound(cont,SVar1,flag2,flag4,opt_position);
				liveObj->field_350 = SVar1;
				liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_100000;
			}
		}
		if (*param_2 != 0) {
			snd::Sample_StopSoundBufferInstance(liveObj->field_354);
		}
		SVar1 = LiveObject_GetEngineSound(liveObj);
		if (SVar1 != SFX_NULL) {
			res::Res_PlayResourceSound(cont,SVar1,1,1,(Vector3F *)0x0);
			liveObj->field_354 = SVar1;
			liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_80000;
		}
	}
	return 0;
}



void __cdecl FUN_00425b60(BOOL param_1,BOOL param_2)
{
	if ((lego::globals::g_Game.flags2 & GAME2_UNK_2) == GAME2_NONE) {
		if (param_1 != 0) {
			param_2 = ~lego::globals::g_Game.flags1 >> 0x14 & 1;
		}
		if (param_2 != 0) {
			if ((lego::globals::g_Game.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) {
				lego::snd::Sound3D_StopAllSounds();
			}
			lego::globals::g_Game.flags1 = lego::globals::g_Game.flags1 | GAME1_CAMERADISABLED;
			lego::globals::g_Game.flags2 = lego::globals::g_Game.flags2 | GAME2_INMENU;
			return;
		}
		FUN_00425a70(0);
		lego::snd::Audio_Play_FUN_00465260(SFX_AMBIENTLOOP,1);
		lego::globals::g_Game.flags1 = lego::globals::g_Game.flags1 & ~GAME1_CAMERADISABLED;
		lego::globals::g_Game.flags2 = lego::globals::g_Game.flags2 & ~GAME2_INMENU;
	}
	return;
}



void __cdecl lego::game::Game_UnkSetGameSpeed_UnkBool(BOOL param_1)
{
	globals::g_GameSpeed_UnkBool = param_1;
	return;
}



void __cdecl lego::game::Game_SetGameSpeed(float newGameSpeed)
{
	if ((globals::g_Game.gameSpeed <= newGameSpeed) || (globals::g_GameSpeed_UnkBool == 0)) {
		front::FrontEnd_UpdateSliderGameSpeed();
		globals::g_Game.gameSpeed = newGameSpeed;
		if (newGameSpeed < 0.0) {
			globals::g_Game.gameSpeed = 0.0;
		}
										// Debug mode allows game speeds up to 300%
		if ((ushort)((ushort)(globals::g_Game.gameSpeed < 3.0) << 8 |
								(ushort)(globals::g_Game.gameSpeed == 3.0) << 0xe) == 0) {
			globals::g_Game.gameSpeed = 3.0;
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_00425c80(LiveObject *liveObj)
{
	float10 fVar1;
	float fVar2;
	float fVar3;
	
	fVar3 = 0.01;
	fVar2 = 0.7;
	fVar1 = LiveObject_GetTrackDist(liveObj);
	lego::view::Camera_FUN_00435deb(globals::g_Game.cameraRadar,liveObj,2.0,(float)fVar1,fVar2,fVar3);
	return;
}



BOOL __cdecl lego::unk::Game_IsNotBool308__00425cb0(void)
{
	return (uint)(globals::g_Game.viewMode == VIEW_FIRSTPERSON);
}



void __cdecl FUN_00425cc0(void)
{
	LevelData *pLVar1;
	TutorialFlags TVar2;
	BOOL BVar3;
	float fVar4;
	int iVar5;
	char *pcVar6;
	LevelBlockFlags1 LVar7;
	float10 fVar8;
	float fVar9;
	LiveObject *local_30;
	Point2F local_2c;
	int local_24;
	int local_20;
	Point2F local_1c;
	Point2F local_10;
	float local_8;
	float local_4;
	
	pLVar1 = lego::globals::g_Game.level;
	if ((lego::globals::g_Game.flags1 & GAME1_RADARON) == GAME1_NONE) {
		return;
	}
	if ((lego::globals::g_Game.flags1 & GAME1_RADAR_MAPVIEW) == GAME1_NONE) {
		return;
	}
	if ((lego::globals::g_Game.flags1 & GAME1_UNK_100) != GAME1_NONE) {
		return;
	}
	local_1c.x = (float)lego::globs::INPUT.msx - (float)INT_004df414;
	local_10.x = (float)INT_004df410;
	local_10.y = 0.0;
	local_1c.y = (float)lego::globs::INPUT.msy - (float)INT_004df410;
	lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_STANDARD);
	TVar2 = lego::nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
	if ((TVar2 & TUTORIAL_UNK_1000) == TUTORIAL_NONE) {
		BOOL_004df54c =
				 (BOOL)(SQRT(local_1c.y * local_1c.y + local_1c.x * local_1c.x) + (float)BOOL_004df54c);
	}
	if ((((BOOL_004df55c != 0) && (lego::globs::INPUT.mslb != 0)) && (4.0 <= (float)BOOL_004df54c)) &&
		 (BVar3 = lego::game::LevelStruct3C_FUN_0045e990
												(pLVar1->struct3c_84,lego::globs::INPUT.msx,lego::globs::INPUT.msy,&local_10
												 ,(int *)&local_2c,(int *)&local_2c.y), BVar3 != 0)) {
		lego::view::Camera_GetFramePosition_IfTopdown(lego::globals::g_Game.cameraMain,&local_1c);
		fVar4 = (float)lego::view::Camera_GetMouseScrollIndent();
		if (((uint)local_2c.x < (uint)fVar4) ||
			 (iVar5 = lego::view::Camera_GetMouseScrollIndent(),
			 (uint)((pLVar1->surfaceMap->smallDimensions).width - iVar5) <= (uint)local_2c.x)) {
			local_10.x = local_1c.x;
		}
		fVar4 = (float)lego::view::Camera_GetMouseScrollIndent();
		if (((uint)local_2c.y < (uint)fVar4) ||
			 (iVar5 = lego::view::Camera_GetMouseScrollIndent(),
			 (uint)((pLVar1->surfaceMap->smallDimensions).height - iVar5) <= (uint)local_2c.y)) {
			local_10.y = local_1c.y;
		}
		if (lego::globals::g_Game.viewMode == VIEW_TOPDOWN) {
			lego::view::Camera_SetFramePosition_IfTopdown
								(lego::globals::g_Game.cameraMain,local_10.x,local_10.y);
		}
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_RADARPAN);
		lego::globals::g_Game.flags1 = lego::globals::g_Game.flags1 | GAME1_UNK_200;
	}
	BVar3 = lego::game::LevelStruct3C_FUN_0045e920
										(pLVar1->struct3c_84,lego::globs::INPUT.msx,lego::globs::INPUT.msy);
	if (((BVar3 != 0) && (lego::globs::INPUT.mslb != 0)) && (BOOL_004df550 == 0)) {
		BOOL_004df55c = 1;
	}
	if (4.0 <= (float)BOOL_004df54c) goto LAB_004260b6;
	BVar3 = lego::game::LevelStruct3C_FUN_0045eae0
										(pLVar1->struct3c_84,lego::globs::INPUT.msx,lego::globs::INPUT.msy,&local_30,
										 &local_8);
	if (BVar3 == 0) {
		if (lego::globs::INPUT.mslb != 0) goto LAB_004260b6;
		if (BOOL_004df550 != 0) {
			BVar3 = lego::game::LevelStruct3C_FUN_0045e990
												(pLVar1->struct3c_84,lego::globs::INPUT.msx,lego::globs::INPUT.msy,
												 &lego::globals::g_Game.tvFaceDirection_338,&local_20,&local_24);
			if (BVar3 != 0) {
				lego::globals::g_Game.flags1 = lego::globals::g_Game.flags1 | GAME1_UNK_4000;
			}
			goto LAB_004260b6;
		}
		BVar3 = lego::game::LevelStruct3C_FUN_0045e990
											(pLVar1->struct3c_84,lego::globs::INPUT.msx,lego::globs::INPUT.msy,
											 (Point2F *)0x0,(int *)&local_2c,(int *)&local_2c.y);
		if (BVar3 == 0) goto LAB_004260b6;
		if ((Point2F_004df554.x == local_2c.x) && (Point2F_004df554.y == local_2c.y)) {
			iVar5 = ((lego::globals::g_Game.level)->dimensions).width;
			if (((uint)local_2c.x < iVar5 - 1U) &&
				 ((uint)local_2c.y < ((lego::globals::g_Game.level)->dimensions).height - 1U)) {
				LVar7 = (lego::globals::g_Game.level)->blocks[(int)local_2c.y * iVar5 + (int)local_2c.x].
								flags1 & 4;
			}
			else {
				LVar7 = BLOCK1_NONE;
			}
			if (LVar7 != BLOCK1_NONE) {
				local_1c.x = local_2c.x;
				local_1c.y = local_2c.y;
				FUN_00428260(&local_1c,0,1,1);
			}
			goto LAB_004260b6;
		}
		Point2F_004df554.x = local_2c.x;
		Point2F_004df554.y = local_2c.y;
		iVar5 = 0;
	}
	else {
		if (lego::globs::INPUT.mslb != 0) goto LAB_004260b6;
		if (BOOL_004df550 != 0) {
			if (lego::globals::g_Game.viewMode == VIEW_TOPDOWN) {
				lego::view::Camera_SetFramePosition_IfTopdown
									(lego::globals::g_Game.cameraMain,local_8,local_4);
			}
			fVar9 = 0.01;
			fVar4 = 0.7;
			fVar8 = lego::game::LiveObject_GetTrackDist(local_30);
			lego::view::Camera_FUN_00435deb
								(lego::globals::g_Game.cameraRadar,local_30,2.0,(float)fVar8,fVar4,fVar9);
			lego::globals::g_Game.flags1 = lego::globals::g_Game.flags1 & ~GAME1_UNK_4000;
			goto LAB_004260b6;
		}
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_TRACKOBJECT);
		pcVar6 = lego::game::LiveObject_GetName(local_30);
		lego::front::ToolTip_Load_HasNLEscape(2,"%s",pcVar6);
		iVar5 = lego::game::LiveObject_GetObjTtSFX(local_30);
		lego::front::ToolTip_FUN_0046b9c0(2,iVar5);
		iVar5 = 2;
	}
	lego::front::ToolTip_AddFlag4(iVar5);
LAB_004260b6:
	if (lego::globs::INPUT.mslb == 0) {
		BOOL_004df54c = lego::globs::INPUT.mslb;
		BOOL_004df55c = lego::globs::INPUT.mslb;
	}
	INT_004df410 = lego::globs::INPUT.msy;
	INT_004df414 = lego::globs::INPUT.msx;
	BOOL_004df550 = lego::globs::INPUT.mslb;
	return;
}



void __cdecl lego::unk::Lego_unkSlug__004260f0(float elapsedGame)
{
	int iVar1;
	
	if (((globals::g_Game.level)->Slug != 0x14) &&
		 (globals::g_Game.InitialSlugTime = globals::g_Game.InitialSlugTime - elapsedGame,
		 globals::g_Game.InitialSlugTime < 0.0)) {
		iVar1 = FUN_00438c20((LiveObject *)0x0,0);
		if (iVar1 != 0) {
			FUN_0043b010((undefined4 *)0x0,(globals::g_Game.level)->Slug);
		}
		globals::g_Game.InitialSlugTime = (globals::g_Game.level)->SlugTime;
	}
	return;
}



void __cdecl lego::game::Game_GetVector_45c(Vector3F *out_vector)
{
	out_vector->x = globals::g_Game.vector_45c.x;
	out_vector->y = globals::g_Game.vector_45c.y;
	out_vector->z = globals::g_Game.vector_45c.z;
	return;
}



void __cdecl FUN_00426180(void)
{
	Point2F local_8;
	
	if ((lego::globals::g_Game.cameraRadar)->object_4 == (LiveObject *)0x0) {
		lego::globals::g_Game.flags1 = lego::globals::g_Game.flags1 | GAME1_UNK_4000;
	}
	if ((lego::globals::g_Game.flags1 & GAME1_UNK_4000) == GAME1_NONE) {
		lego::game::LiveObject_GetPosition
							((lego::globals::g_Game.cameraRadar)->object_4,(float *)&local_8,&local_8.y);
	}
	else {
		local_8.x = lego::globals::g_Game.tvFaceDirection_338.x;
		local_8.y = lego::globals::g_Game.tvFaceDirection_338.y;
	}
	lego::game::LevelStruct3C_SetFloat14
						((lego::globals::g_Game.level)->struct3c_84,lego::globals::g_Game.tvTiltOrZoom_334);
	lego::game::LevelStruct3C_FUN_0045de80((lego::globals::g_Game.level)->struct3c_84,&local_8);
	return;
}



void __cdecl lego::game::Game_SetMenuNextPosition(Point2F *position)
{
	if (position != (Point2F *)0x0) {
		globals::g_Game.flags2 = globals::g_Game.flags2 | GAME2_MENU_HASNEXT;
		globals::g_Game.menuNextPoint.x = position->x;
		globals::g_Game.menuNextPoint.y = position->y;
		return;
	}
	globals::g_Game.flags2 = globals::g_Game.flags2 & ~GAME2_MENU_HASNEXT;
	return;
}



void __cdecl lego::game::Game_SetMenuPreviousPosition(Point2F *position)
{
	if (position != (Point2F *)0x0) {
		globals::g_Game.flags2 = globals::g_Game.flags2 | GAME2_MENU_HASPREVIOUS;
		globals::g_Game.menuPrevPoint.x = position->x;
		globals::g_Game.menuPrevPoint.y = position->y;
		return;
	}
	globals::g_Game.flags2 = globals::g_Game.flags2 & ~GAME2_MENU_HASPREVIOUS;
	return;
}



void __cdecl lego::game::Game_SetFlags2_40_And_2_unkCamera(BOOL onFlag40,BOOL onFlag2)
{
	GameFlags2 GVar1;
	
	if (onFlag40 == 0) {
		GVar1 = globals::g_Game.flags2 & ~GAME2_UNK_40;
	}
	else {
		GVar1 = globals::g_Game.flags2 | GAME2_UNK_40;
	}
	if (onFlag2 != 0) {
		globals::g_Game.flags2 = GVar1 | GAME2_CAMERAMOVING;
		return;
	}
	globals::g_Game.flags2 = GVar1 & ~GAME2_CAMERAMOVING;
	return;
}



void __cdecl lego::game::Game_SetFlags2_80(BOOL state)
{
	if (state != 0) {
		globals::g_Game.flags2 = globals::g_Game.flags2 | GAME2_UNK_80;
		return;
	}
	globals::g_Game.flags2 = globals::g_Game.flags2 & ~GAME2_UNK_80;
	return;
}



void __cdecl FUN_004262f0(void)
{
	int local_4;
	
	local_4 = 1;
	FLAGS_00504610 = 0;
	lego::nerps::funcs::NERPFunc__SetMessagePermit(&local_4);
	FLOAT_00504618 = 0.0;
	lego::front::TextWindow_Clear(lego::globals::g_Game.textWnd_80);
	lego::game::Game_SetFlags2_40_And_2_unkCamera(0,0);
	lego::game::Game_SetFlags2_80(0);
	return;
}



void __cdecl lego::game::Game_UpdateIfBool308_UnkCameraFP(float elapsed)
{
	TutorialFlags TVar1;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	if (globals::g_Game.viewMode == VIEW_TOPDOWN) {
		TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
		if ((TVar1 & TUTORIAL_UNK_1000) == TUTORIAL_NONE) {
			if (((((int)globals::g_Game.MouseScrollBorder <= globs::INPUT.msx) &&
					 ((int)globals::g_Game.MouseScrollBorder <= globs::INPUT.msy)) &&
					(globs::INPUT.msx <= (int)(globs::mainGlobs.appWidth - globals::g_Game.MouseScrollBorder))
					) && (globs::INPUT.msy <=
								(int)(globs::mainGlobs.appHeight - globals::g_Game.MouseScrollBorder))) {
				lego::view::Camera_ZeroField9c_UnkSpeedAccel(globals::g_Game.cameraMain);
				return;
			}
			lego::view::Camera_GetSurfacePosition_IfTopdown
								(globals::g_Game.cameraMain,(globals::g_Game.level)->surfaceMap,&local_18);
			Game_MainView_MouseTransform(globs::INPUT.msx,globs::INPUT.msy,(float *)&local_24,&local_24.y)
			;
			local_c.x = local_24.x - local_18.x;
			local_c.y = local_24.y - local_18.y;
			local_18.z = 0.0;
			local_24.z = 0.0;
			local_c.z = 0.0;
			lego::view::Camera_FUN_00436da9(globals::g_Game.cameraMain,&local_c,elapsed);
		}
	}
	return;
}



void __cdecl
lego::game::Game_unkGameLoop_FUN_00426450
					(float elapsed,float param_2,undefined4 param_3,undefined4 param_4,int param_5)
{
	char cVar1;
	ObjectType OVar2;
	LevelData *pLVar3;
	PointerType PVar4;
	int iVar5;
	LiveObject *pLVar6;
	ObjectStatsFlags3 OVar7;
	ObjectStatsFlags1 OVar8;
	LiveObject *pLVar9;
	LevelBlockFlags1 LVar10;
	TutorialFlags TVar11;
	float fVar12;
	LiveFlags5 LVar13;
	BOOL BVar14;
	bool bVar15;
	uint uVar16;
	float fVar17;
	uint uVar18;
	float fVar19;
	PointerType pointerType;
	Point2I *opt_position;
	float fVar20;
	int local_40;
	LiveObject *local_3c;
	float local_38;
	uint local_34;
	BOOL local_30;
	int local_2c;
	int local_28;
	Point2F local_24;
	Point2F local_1c;
	Point2F local_14;
	float local_c;
	float local_8;
	float local_4;
	
	pLVar3 = globals::g_Game.level;
	globals::g_Game.flags2 = globals::g_Game.flags2 & ~GAME2_MOUSE_INSIDEGAMEVIEW;
	BVar14 = 0;
	local_3c = (LiveObject *)0x0;
	local_28 = 0;
	local_2c = 0;
	local_40 = 0;
	local_30 = 0;
	res::ResLp_UnkSetup3DFrameTransform(globals::g_Game.RES_2f4_TABLEUNK,1);
	if ((globs::INPUT.mslb == 0) && (globs::INPUT.msrb == 0)) {
		FLOAT_004df56c = FLOAT_004df56c + elapsed;
	}
	else {
		FLOAT_004df56c = 0.0;
	}
	if (BOOL_004df564 != 0) {
		if (globs::INPUT.mslb == 0) {
			if ((globals::g_Game.flags1 & GAME1_UNK_100) == GAME1_NONE) {
				BVar14 = 1;
				local_40 = 1;
			}
		}
		else {
			BOOL_004df560 = 1;
		}
	}
	if (globs::INPUT.mslb == 0) {
		BOOL_004df560 = 0;
	}
	if ((BOOL_004df568 != 0) && (globs::INPUT.msrb == 0)) {
		local_30 = 1;
	}
	if (BOOL_004df560 == 0) {
		FLOAT_004df41c = 0.0;
		FLOAT_004df418 = 0.0;
	}
	else {
		FLOAT_004df418 =
				 (float)((globs::INPUT.diffx ^ globs::INPUT.diffx >> 0x1f) - (globs::INPUT.diffx >> 0x1f)) +
				 FLOAT_004df418;
		local_24.x = (float)((globs::INPUT.diffy ^ globs::INPUT.diffy >> 0x1f) -
												(globs::INPUT.diffy >> 0x1f));
		FLOAT_004df41c = (float)(int)local_24.x + FLOAT_004df41c;
	}
	FUN_00418cd0(globs::INPUT.msx,globs::INPUT.msy,globs::INPUT.mslb,BOOL_004df564,BVar14,elapsed);
	if ((globals::g_Game.flags1 & GAME1_CAMERADISABLED) != GAME1_NONE) {
		front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_STANDARD);
		BOOL_004df564 = globs::INPUT.mslb;
		BOOL_004df568 = globs::INPUT.msrb;
		BOOL_004df570 = 1;
		globals::g_Game.flags1 = globals::g_Game.flags1 & ~(GAME1_UNK_100|GAME1_UNK_200);
		return;
	}
	if (BOOL_004df570 != 0) {
		BOOL_004df564 = 0;
		BOOL_004df568 = 0;
		BOOL_004df560 = 0;
		local_40 = 0;
		local_30 = 0;
		BOOL_004df570 = 0;
	}
	BVar14 = SurfaceMap_FUN_004505a0
										 ((globals::g_Game.level)->surfaceMap,globals::g_Game.viewMain,globs::INPUT.msx,
											globs::INPUT.msy,&local_34,(uint *)&local_38,&local_c);
	bVar15 = BVar14 == 0;
	if (!bVar15) {
		elapsed = (float)(pLVar3->blocks + (pLVar3->dimensions).width * (int)local_38 + local_34);
		res::Container_SetPosition
							(globals::g_Game.resRootLight,(Container *)0x0,local_c,local_8,local_4 - 250.0);
	}
	light::LightEffects_SetDimmerMode((uint)bVar15);
	if ((globals::g_Game.flags1 & GAME1_UNK_8000000) != GAME1_NONE) {
		Game_UpdateIfBool308_UnkCameraFP(param_2);
		front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_STANDARD);
		globals::g_Game.flags1 = globals::g_Game.flags1 & ~(GAME1_UNK_100|GAME1_UNK_200);
		return;
	}
	PVar4 = front::Pointer_GetCurrentType();
	if (((globals::g_Game.flags1 & GAME1_UNK_100) == GAME1_NONE) &&
		 (BVar14 = Game_IsAnyUnitsSelected(), BVar14 != 0)) {
		pointerType = POINTER_SELECTED;
	}
	else {
		pointerType = POINTER_STANDARD;
	}
	front::Pointer_SetType_IfUnkFloatLessThan0(pointerType);
	if (((globals::g_Game.flags1 & GAME1_UNK_100) == GAME1_NONE) &&
		 (BVar14 = FUN_0045b070(param_2,globs::INPUT.msx,globs::INPUT.msy,globs::INPUT.mslb,
														BOOL_004df564,&local_2c), BVar14 != 0)) {
		Game_UpdateIfBool308_UnkCameraFP(param_2);
		globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_UNK_200;
		goto LAB_00427c9c;
	}
	Game_UpdateIfBool308_UnkCameraFP(param_2);
	if ((globals::g_Game.flags1 & GAME1_UNK_100) == GAME1_NONE) {
		BVar14 = FUN_0045d3d0(globs::INPUT.msx,globs::INPUT.msy,globs::INPUT.mslb,BOOL_004df564,local_40
												 );
		if (BVar14 != 0) {
			globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_UNK_200;
			goto LAB_00427c9c;
		}
		if ((((globals::g_Game.flags1 & GAME1_UNK_100) == GAME1_NONE) &&
				((globals::g_Game.flags2 & GAME2_INMENU) == GAME2_NONE)) &&
			 (BVar14 = GameUnk_DoSomethingWithRenameReplace
													 (globs::INPUT.msx,globs::INPUT.msy,globs::INPUT.mslb,BOOL_004df564,
														local_40), BVar14 != 0)) {
			globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_UNK_200;
			goto LAB_00427c9c;
		}
		if (((globals::g_Game.flags1 & GAME1_UNK_100) != GAME1_NONE) ||
			 (iVar5 = FUN_0041a0d0(globs::INPUT.msx,globs::INPUT.msy,local_40), iVar5 == 0))
		goto LAB_0042682b;
		globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_UNK_200;
		if (local_40 == 0) goto LAB_00427c9c;
		iVar5 = 0;
LAB_00427c94:
		snd::Audio_FUN_00428730(iVar5);
		goto LAB_00427c9c;
	}
LAB_0042682b:
	if (globals::g_Game.viewMode == VIEW_FIRSTPERSON) {
		globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_UNK_200;
		goto LAB_00427c9c;
	}
	if ((((globals::g_Game.flags1 & GAME1_UNK_100) == GAME1_NONE) &&
			((globals::g_Game.flags1 & GAME1_RADARON) != GAME1_NONE)) &&
		 (BVar14 = LevelStruct3C_FUN_0045e920(pLVar3->struct3c_84,globs::INPUT.msx,globs::INPUT.msy),
		 BVar14 != 0)) {
		if (local_40 != 0) {
			snd::Audio_FUN_00428730(0);
		}
		if ((globals::g_Game.flags1 & GAME1_RADAR_TRACKOBJECTVIEW) == GAME1_NONE) {
			front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
		}
		goto LAB_00427c9c;
	}
	if (local_2c != 0) {
		bVar15 = false;
		if ((globals::g_Game.NextButton != (ImageBMP *)0x0) &&
			 ((globals::g_Game.flags2 & GAME2_UNK_40) != GAME2_NONE)) {
			fVar17 = (float)globs::INPUT.msx;
			fVar12 = (float)(globals::g_Game.NextButton)->height;
			if ((((ushort)((ushort)(fVar17 < globals::g_Game.NextButtonPos.x) << 8 |
										(ushort)(fVar17 == globals::g_Game.NextButtonPos.x) << 0xe) == 0) &&
					(((fVar19 = (float)globs::INPUT.msy,
						(ushort)((ushort)(fVar19 < globals::g_Game.NextButtonPos.y) << 8 |
										(ushort)(fVar19 == globals::g_Game.NextButtonPos.y) << 0xe) == 0 &&
						(local_24.y = 0.0, local_24.x = (float)(globals::g_Game.NextButton)->width,
						fVar17 < (float)(ulonglong)(globals::g_Game.NextButton)->width +
										 globals::g_Game.NextButtonPos.x)) &&
					 (local_24.y = 0.0, local_24.x = fVar12,
					 fVar19 < (float)(ulonglong)(uint)fVar12 + globals::g_Game.NextButtonPos.y)))) &&
				 (front::ToolTip_AddFlag4(0x20), local_40 != 0)) {
				FUN_00453be0();
				bVar15 = true;
			}
		}
		if ((globals::g_Game.BackButton != (ImageBMP *)0x0) &&
			 ((globals::g_Game.flags2 & GAME2_UNK_80) != GAME2_NONE)) {
			fVar17 = (float)globs::INPUT.msx;
			fVar12 = (float)(globals::g_Game.BackButton)->height;
			if ((((ushort)((ushort)(fVar17 < globals::g_Game.BackButtonPos.x) << 8 |
										(ushort)(fVar17 == globals::g_Game.BackButtonPos.x) << 0xe) == 0) &&
					((fVar19 = (float)globs::INPUT.msy,
					 (ushort)((ushort)(fVar19 < globals::g_Game.BackButtonPos.y) << 8 |
									 (ushort)(fVar19 == globals::g_Game.BackButtonPos.y) << 0xe) == 0 &&
					 (local_24.y = 0.0, local_24.x = (float)(globals::g_Game.BackButton)->width,
					 fVar17 < (float)(ulonglong)(globals::g_Game.BackButton)->width +
										globals::g_Game.BackButtonPos.x)))) &&
				 (local_24.y = 0.0, local_24.x = fVar12,
				 fVar19 < (float)(ulonglong)(uint)fVar12 + globals::g_Game.BackButtonPos.y)) {
				front::ToolTip_AddFlag4(0x1f);
				if (local_40 == 0) goto LAB_00427c9c;
				FUN_00453bd0();
				bVar15 = true;
			}
		}
		if ((local_40 == 0) || (bVar15)) goto LAB_00427c9c;
		iVar5 = 1;
		goto LAB_00427c94;
	}
	if (bVar15) goto LAB_00427c9c;
	globals::g_Game.vector_45c.y = local_8;
	globals::g_Game.vector_45c.x = local_c;
	globals::g_Game.vector_45c.z = local_4;
	globals::g_Game.flags2 = globals::g_Game.flags2 | GAME2_MOUSE_INSIDEGAMEVIEW;
	Point2I_00557fb8.x = local_34;
	Point2I_00557fb8.y = (int)local_38;
	if (((globals::g_Game.flags1 & GAME1_UNK_100) == GAME1_NONE) ||
		 ((globals::g_Game.flags3 & (GAME3_UNK_1|GAME3_PLACEBUILDING)) != GAME3_NONE)) {
		if ((globals::g_Game.flags3 & GAME3_PLACEBUILDING) == GAME3_NONE) {
			iVar5 = FUN_0043b620(globs::INPUT.msx,globs::INPUT.msy,&local_3c);
			if (iVar5 == 0) {
				if ((globals::g_Game.flags1 & GAME1_LASERTRACKER) != GAME1_NONE) {
					iVar5 = ((globals::g_Game.level)->dimensions).width;
					if (((local_34 < iVar5 - 1U) &&
							((uint)local_38 < ((globals::g_Game.level)->dimensions).height - 1U)) &&
						 ((LVar10 = (globals::g_Game.level)->blocks[(int)local_38 * iVar5 + local_34].flags1,
							(LVar10 & BLOCK1_UNK_10) != BLOCK1_NONE && ((LVar10 & BLOCK1_UNK_8) == BLOCK1_NONE))))
					{
						bVar15 = true;
					}
					else {
						bVar15 = false;
					}
					if (bVar15) {
						FUN_004350d0((uint)*(byte *)((int)elapsed + 2));
					}
					goto LAB_0042797a;
				}
				if (local_40 != 0) {
					*(int *)((int)elapsed + 0x28) = *(int *)((int)elapsed + 0x28) + 1;
				}
				if (((globals::g_Game.flags3 & GAME3_PICKUPOBJECT) != GAME3_NONE) ||
					 ((globals::g_Game.flags3 & GAME3_LOADVEHICLE) != GAME3_NONE)) {
					if ((globals::g_Game.flags3 & GAME3_PICKUPOBJECT) == GAME3_NONE) {
						PVar4 = POINTER_VEHICLECANTPICKUP;
					}
					else {
						PVar4 = POINTER_LEGOMANCANTPICKUP;
					}
					goto LAB_00427972;
				}
				if (((globals::g_Game.flags3 & GAME3_UNK_20) == GAME3_NONE) &&
					 ((globals::g_Game.flags3 & GAME3_UNK_40) == GAME3_NONE)) {
					if (((globals::g_Game.flags3 & GAME3_UNK_2) == GAME3_NONE) &&
						 ((globals::g_Game.flags3 & GAME3_UNK_4) == GAME3_NONE)) {
						if ((globals::g_Game.flags3 & GAME3_UNK_1) == GAME3_NONE) {
							iVar5 = ((globals::g_Game.level)->dimensions).width;
							if ((local_34 < iVar5 - 1U) &&
								 ((uint)local_38 < ((globals::g_Game.level)->dimensions).height - 1U)) {
								LVar10 = (globals::g_Game.level)->blocks[(int)local_38 * iVar5 + local_34].flags1 &
												 4;
							}
							else {
								LVar10 = BLOCK1_NONE;
							}
							if (LVar10 != BLOCK1_NONE) {
								iVar5 = ((globals::g_Game.level)->dimensions).width;
								if ((((local_34 < iVar5 - 1U) &&
										 ((uint)local_38 < ((globals::g_Game.level)->dimensions).height - 1U)) &&
										(LVar10 = (globals::g_Game.level)->blocks[(int)local_38 * iVar5 + local_34].
															flags1, (LVar10 & BLOCK1_UNK_10) != BLOCK1_NONE)) &&
									 ((LVar10 & BLOCK1_UNK_8) == BLOCK1_NONE)) {
									bVar15 = true;
								}
								else {
									bVar15 = false;
								}
								if ((bVar15) &&
									 (((globals::g_Game.level)->blocks
										 [((globals::g_Game.level)->dimensions).width * Point2I_00557fb8.y +
											Point2I_00557fb8.x].terrain == TERRAIN_IMMOVABLE ||
										((globals::g_Game.level)->blocks
										 [((globals::g_Game.level)->dimensions).width * Point2I_00557fb8.y +
											Point2I_00557fb8.x].terrain == TERRAIN_RECHARGESEAM)))) {
									if ((*(byte *)((int)elapsed + 8) & 8) == 0) {
										FUN_004350d0((uint)*(byte *)((int)elapsed + 2));
									}
									if (BOOL_004df560 == 0) {
										FUN_00428260((Point2F *)&Point2I_00557fb8,1,1,0);
									}
									if (local_40 != 0) {
										snd::Audio_FUN_00428730(2);
									}
								}
								else {
									fVar12 = 0.0;
									param_2 = 0.0;
									if ((*(byte *)((int)elapsed + 8) & 8) == 0) {
										FUN_004350d0((uint)*(byte *)((int)elapsed + 2));
									}
									if (BOOL_004df560 == 0) {
										FUN_00428260((Point2F *)&Point2I_00557fb8,1,1,0);
									}
									BVar14 = Game_IsAnyUnitsSelected();
									if (BVar14 != 0) {
										if ((globals::g_Game.flags1 & GAME1_UNK_40000) == GAME1_NONE) {
											if (((*(byte *)((int)elapsed + 8) & 8) == 0) &&
												 (BVar14 = FUN_00431960(local_34,(uint)local_38,0), BVar14 != 0)) {
												pLVar9 = Game_GetPrimarySelectedObject();
												if (pLVar9->objType == OBJECT_MINIFIGURE) {
													PVar4 = POINTER_LEGOMANCANTDIG;
												}
												else {
													PVar4 = POINTER_VEHICLECANTDIG;
												}
												front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
												front::Text_DisplayMessage(TEXT_NODRILL,0,0);
												cVar1 = *(char *)((int)elapsed + 2);
												if ((((cVar1 != '\x01') && (cVar1 != '\t')) && (cVar1 != '\v')) &&
													 ((*(byte *)((int)elapsed + 8) & 0x40) == 0)) {
													fVar12 = 1.401298e-45;
													param_2 = 1.401298e-45;
													pLVar9 = Game_GetPrimarySelectedObject();
													if (pLVar9->objType == OBJECT_MINIFIGURE) {
														PVar4 = POINTER_LEGOMANDIG;
													}
													else {
														PVar4 = POINTER_VEHICLEDIG;
													}
													front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
													front::Text_DisplayMessage(TEXT_DRILL,0,0);
													if ((local_40 != 0) &&
														 (BVar14 = Level_BlockPointerCheck(&Point2I_00557fb8), BVar14 == 0)) {
														ai::AITask_DoDig_AtPosition(&Point2I_00557fb8,0,1);
														ai::AITask_FUN_00401f40(AITASK_DIG,(LiveObject *)0x0,&Point2I_00557fb8);
														goto LAB_004271d4;
													}
												}
											}
										}
										else {
											if ((*(char *)elapsed == '\x01') ||
												 (BVar14 = FUN_00431960(local_34,(uint)local_38,1), BVar14 == 0)) {
												globals::g_Game.bool_c8 = 0;
											}
											else {
												globals::g_Game.pointi_c0.y = (int)local_38;
												fVar12 = 1.401298e-45;
												globals::g_Game.pointi_c0.x = local_34;
												param_2 = 1.401298e-45;
												globals::g_Game.bool_c8 = 1;
												if ((local_40 != 0) &&
													 (BVar14 = Level_BlockPointerCheck(&Point2I_00557fb8), BVar14 == 0)) {
													ai::AITask_DoDig_AtPosition(&Point2I_00557fb8,1,1);
LAB_004271d4:
													param_2 = 1.401298e-45;
													fVar12 = 1.401298e-45;
													snd::Audio_FUN_00428730(0);
													FUN_0041e680();
												}
											}
										}
										if ((fVar12 == 0.0) && ((*(uint *)((int)elapsed + 8) & 8) != 0)) {
											if ((((globals::g_Game.level)->blocks
														[((globals::g_Game.level)->dimensions).width * (int)local_38 + local_34]
														.flags1 & BLOCK1_UNK_400) == BLOCK1_NONE) &&
												 ((*(byte *)&(globals::g_Game.level)->blocks
																		 [((globals::g_Game.level)->dimensions).width * (int)local_38 +
																			local_34].flags2 & 4) == 0)) {
												bVar15 = false;
											}
											else {
												bVar15 = true;
											}
											if ((!bVar15) && ((*(byte *)((int)elapsed + 0xc) & 0x20) == 0)) {
												if ((*(uint *)((int)elapsed + 8) & 0x200000) == 0) {
													pLVar9 = Game_GetPrimarySelectedObject();
													OVar8 = LiveObject_GetStatsFlags1(pLVar9);
													if ((OVar8 & STATS1_CANCLEARRUBBLE) != STATS1_NONE) {
														BVar14 = 0;
														uVar16 = local_34;
														fVar17 = local_38;
														uVar18 = local_34;
														fVar19 = local_38;
														pLVar9 = Game_GetPrimarySelectedObject();
														iVar5 = LiveObject_FUN_00431cd0
																							(pLVar9,uVar16,(int)fVar17,uVar18,(int)fVar19,BVar14);
														if (iVar5 != 0) {
															fVar12 = 1.401298e-45;
															param_2 = 1.401298e-45;
															pLVar9 = Game_GetPrimarySelectedObject();
															if (pLVar9->objType == OBJECT_MINIFIGURE) {
																PVar4 = POINTER_LEGOMANCLEAR;
															}
															else {
																PVar4 = POINTER_VEHICLECLEAR;
															}
															front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
															if ((local_40 != 0) &&
																 (BVar14 = Level_BlockPointerCheck(&Point2I_00557fb8), BVar14 == 0))
															{
																Level_AddMessageAction(MESSAGE_USERGOTO,0,0,&Point2I_00557fb8);
																ai::AITask_FUN_00401f40
																					(AITASK_CLEAR,(LiveObject *)0x0,&Point2I_00557fb8);
																snd::Audio_FUN_00428730(0);
																FUN_0041e680();
															}
														}
													}
												}
												if (fVar12 != 0.0) goto LAB_0042797a;
												uVar16 = local_34;
												fVar17 = local_38;
												uVar18 = local_34;
												fVar19 = local_38;
												fVar20 = fVar12;
												pLVar9 = Game_GetPrimarySelectedObject();
												iVar5 = LiveObject_FUN_00431cd0
																					(pLVar9,uVar16,(int)fVar17,uVar18,(int)fVar19,(BOOL)fVar20
																					);
												if (iVar5 != 0) {
													fVar12 = 1.401298e-45;
													param_2 = 1.401298e-45;
													pLVar9 = Game_GetPrimarySelectedObject();
													if (pLVar9->objType == OBJECT_MINIFIGURE) {
														PVar4 = POINTER_LEGOMANGO;
													}
													else {
														PVar4 = POINTER_VEHICLEGO;
													}
													front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
													front::Text_DisplayMessage(TEXT_WALK,0,0);
													if ((local_40 != 0) &&
														 (BVar14 = Level_BlockPointerCheck(&Point2I_00557fb8), BVar14 == 0)) {
														Level_AddMessageAction(MESSAGE_USERGOTO,0,0,&Point2I_00557fb8);
														snd::Audio_FUN_00428730(0);
														FUN_0041e680();
													}
												}
											}
										}
									}
									if (fVar12 == 0.0) {
										if ((((globals::g_Game.level)->blocks
													[((globals::g_Game.level)->dimensions).width * (int)local_38 + local_34].
													flags1 & BLOCK1_UNK_400) == BLOCK1_NONE) &&
											 ((*(byte *)&(globals::g_Game.level)->blocks
																	 [((globals::g_Game.level)->dimensions).width * (int)local_38 +
																		local_34].flags2 & 4) == 0)) {
											bVar15 = false;
										}
										else {
											bVar15 = true;
										}
										if ((((!bVar15) && (cVar1 = *(char *)((int)elapsed + 2), cVar1 != '\x06')) &&
												(cVar1 != '\t')) && ((*(byte *)((int)elapsed + 0xc) & 0x20) == 0)) {
											if ((*(uint *)((int)elapsed + 8) & 8) != 0) {
												if (((globals::g_Game.level)->blocks
														 [((globals::g_Game.level)->dimensions).width * Point2I_00557fb8.y +
															Point2I_00557fb8.x].flags1 & BLOCK1_UNK_80000000) != BLOCK1_NONE) {
													fVar12 = 1.401298e-45;
													param_2 = 1.401298e-45;
													if ((local_40 != 0) &&
														 (BVar14 = Level_BlockPointerCheck(&Point2I_00557fb8), BVar14 == 0)) {
														Level_AddMessageAction(MESSAGE_CLEARSELECT,0,0,(Point2I *)0x0);
														snd::Audio_FUN_00428730(5);
														FUN_0041b200(2,&Point2I_00557fb8);
													}
												}
												if (((fVar12 == 0.0) && ((*(uint *)((int)elapsed + 8) & 0x8000) != 0)) &&
													 (param_2 = 1.401298e-45, local_40 != 0)) {
													snd::Audio_FUN_00428730(1);
												}
												if ((((*(uint *)((int)elapsed + 8) & 0x100000) != 0) ||
														(((globals::g_Game.level)->blocks
															[((globals::g_Game.level)->dimensions).width * Point2I_00557fb8.y +
															 Point2I_00557fb8.x].flags1 & BLOCK1_UNK_40000000) != BLOCK1_NONE)) &&
													 (((globals::g_Game.level)->blocks
														 [((globals::g_Game.level)->dimensions).width * Point2I_00557fb8.y +
															Point2I_00557fb8.x].flags1 & BLOCK1_UNK_8000) == BLOCK1_NONE)) {
													if (((Point2I_00557fb8.x < 0) || (Point2I_00557fb8.y < 0)) ||
														 ((iVar5 = ((globals::g_Game.level)->dimensions).width,
															iVar5 <= Point2I_00557fb8.x ||
															(((globals::g_Game.level)->dimensions).height <= Point2I_00557fb8.y)))
														 ) {
														LVar10 = BLOCK1_NONE;
													}
													else {
														LVar10 = (globals::g_Game.level)->blocks
																		 [Point2I_00557fb8.y * iVar5 + Point2I_00557fb8.x].flags1 &
																		 BLOCK1_POWERPATH;
													}
													if (((LVar10 == BLOCK1_NONE) && (param_2 = 1.401298e-45, local_40 != 0))
														 && (BVar14 = Level_BlockPointerCheck(&Point2I_00557fb8), BVar14 == 0))
													{
														snd::Audio_FUN_00428730(5);
														FUN_0041b200(4,&Point2I_00557fb8);
													}
												}
												if (param_2 != 0.0) goto LAB_0042797a;
												if (((globals::g_Game.level)->blocks
														 [((globals::g_Game.level)->dimensions).width * Point2I_00557fb8.y +
															Point2I_00557fb8.x].flags1 & BLOCK1_UNK_40000000) == BLOCK1_NONE) {
													if ((((Point2I_00557fb8.x < 0) || (Point2I_00557fb8.y < 0)) ||
															(iVar5 = ((globals::g_Game.level)->dimensions).width,
															iVar5 <= Point2I_00557fb8.x)) ||
														 (((globals::g_Game.level)->dimensions).height <= Point2I_00557fb8.y)) {
														LVar10 = BLOCK1_NONE;
													}
													else {
														LVar10 = (globals::g_Game.level)->blocks
																		 [Point2I_00557fb8.y * iVar5 + Point2I_00557fb8.x].flags1 &
																		 BLOCK1_POWERPATH;
													}
													fVar12 = param_2;
													if (LVar10 != BLOCK1_NONE) goto LAB_004275d9;
												}
												else {
LAB_004275d9:
													fVar12 = 1.401298e-45;
													if ((local_40 != 0) &&
														 (BVar14 = Level_BlockPointerCheck(&Point2I_00557fb8), BVar14 == 0)) {
														Level_AddMessageAction(MESSAGE_CLEARSELECT,0,0,(Point2I *)0x0);
														snd::Audio_FUN_00428730(5);
														FUN_0041b200(1,&Point2I_00557fb8);
													}
												}
												if (fVar12 == 0.0) {
													if ((((*(uint *)((int)elapsed + 8) & 0x200000) != 0) &&
															(fVar12 = 1.401298e-45, local_40 != 0)) &&
														 (BVar14 = Level_BlockPointerCheck(&Point2I_00557fb8), BVar14 == 0)) {
														Level_AddMessageAction(MESSAGE_CLEARSELECT,0,0,(Point2I *)0x0);
														snd::Audio_FUN_00428730(5);
														FUN_0041b200(1,&Point2I_00557fb8);
													}
													if (fVar12 == 0.0) {
														if ((((*(uint *)((int)elapsed + 8) & 0x200000) != 0) ||
																(fVar12 = 1.401298e-45, local_40 == 0)) ||
															 (BVar14 = Level_BlockPointerCheck(&Point2I_00557fb8), BVar14 != 0))
														goto LAB_00427713;
														Level_AddMessageAction(MESSAGE_CLEARSELECT,0,0,(Point2I *)0x0);
														snd::Audio_FUN_00428730(5);
														iVar5 = 5;
														goto LAB_0042770b;
													}
												}
												goto LAB_0042797a;
											}
											if (((cVar1 == '\x01') || ((*(uint *)((int)elapsed + 8) & 0x40) != 0)) ||
												 ((fVar12 = 1.401298e-45, local_40 == 0 ||
													(BVar14 = Level_BlockPointerCheck(&Point2I_00557fb8), BVar14 != 0))))
											goto LAB_00427713;
											Level_AddMessageAction(MESSAGE_CLEARSELECT,0,0,(Point2I *)0x0);
											snd::Audio_FUN_00428730(4);
											iVar5 = 7;
LAB_0042770b:
											fVar12 = 1.401298e-45;
											FUN_0041b200(iVar5,&Point2I_00557fb8);
										}
LAB_00427713:
										if (fVar12 == 0.0) goto LAB_0042771b;
									}
								}
								goto LAB_0042797a;
							}
						}
						else {
							globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_UNK_200;
							front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_CANTHELP);
							front::Text_DisplayMessage(TEXT_ENCYCLOPEDIA,0,0);
						}
LAB_0042771b:
						if (local_40 != 0) {
LAB_00427727:
							snd::Audio_FUN_00428730(1);
						}
					}
					else {
						if ((globals::g_Game.flags3 & GAME3_UNK_2) == GAME3_NONE) {
							PVar4 = POINTER_VEHICLECANTGO;
						}
						else {
							PVar4 = POINTER_LEGOMANCANTGO;
						}
						front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
						if (((*(byte *)((int)elapsed + 8) & 8) != 0) &&
							 (BVar14 = Game_IsAnyUnitsSelected(), BVar14 != 0)) {
							BVar14 = 0;
							uVar16 = local_34;
							fVar12 = local_38;
							uVar18 = local_34;
							fVar17 = local_38;
							pLVar9 = Game_GetPrimarySelectedObject();
							iVar5 = LiveObject_FUN_00431cd0(pLVar9,uVar16,(int)fVar12,uVar18,(int)fVar17,BVar14);
							if (iVar5 != 0) {
								if ((globals::g_Game.flags3 & GAME3_UNK_2) == GAME3_NONE) {
									PVar4 = POINTER_VEHICLEGO;
								}
								else {
									PVar4 = POINTER_LEGOMANGO;
								}
								front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
								front::Text_DisplayMessage(TEXT_WALK,0,0);
								if ((local_40 != 0) &&
									 (BVar14 = Level_BlockPointerCheck(&Point2I_00557fb8), BVar14 == 0)) {
									Level_AddMessageAction(MESSAGE_USERGOTO,0,0,&Point2I_00557fb8);
									snd::Audio_FUN_00428730(0);
									FUN_0041e680();
								}
							}
						}
					}
				}
				else {
					if ((globals::g_Game.flags3 & GAME3_UNK_20) == GAME3_NONE) {
						PVar4 = POINTER_VEHICLECANTDIG;
					}
					else {
						PVar4 = POINTER_LEGOMANCANTDIG;
					}
					front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
					front::Text_DisplayMessage(TEXT_NODRILL,0,0);
					if ((globals::g_Game.flags1 & GAME1_UNK_40000) == GAME1_NONE) {
						if ((((((*(uint *)((int)elapsed + 8) & 8) == 0) &&
									(cVar1 = *(char *)((int)elapsed + 2), cVar1 != '\x01')) && (cVar1 != '\t')) &&
								((cVar1 != '\v' && ((*(uint *)((int)elapsed + 8) & 0x40) == 0)))) &&
							 ((BVar14 = Game_IsAnyUnitsSelected(), BVar14 == 0 ||
								(BVar14 = FUN_00431960(local_34,(uint)local_38,0), BVar14 != 0)))) {
							if ((globals::g_Game.flags3 & GAME3_UNK_20) == GAME3_NONE) {
								PVar4 = POINTER_VEHICLEDIG;
							}
							else {
								PVar4 = POINTER_LEGOMANDIG;
							}
							front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
							front::Text_DisplayMessage(TEXT_DRILL,0,0);
							if ((local_40 != 0) &&
								 (BVar14 = Level_BlockPointerCheck(&Point2I_00557fb8), BVar14 == 0)) {
								ai::AITask_DoDig_AtPosition(&Point2I_00557fb8,0,1);
								goto LAB_00427954;
							}
						}
					}
					else {
						if ((*(char *)elapsed == '\x01') ||
							 ((BVar14 = Game_IsAnyUnitsSelected(), BVar14 != 0 &&
								(BVar14 = FUN_00431960(local_34,(uint)local_38,1), BVar14 == 0)))) {
							globals::g_Game.bool_c8 = 0;
						}
						else {
							globals::g_Game.pointi_c0.y = (int)local_38;
							globals::g_Game.pointi_c0.x = local_34;
							globals::g_Game.bool_c8 = 1;
							if ((local_40 != 0) &&
								 (BVar14 = Level_BlockPointerCheck(&Point2I_00557fb8), BVar14 == 0)) {
								ai::AITask_DoDig_AtPosition(&Point2I_00557fb8,1,1);
								snd::Audio_FUN_00428730(0);
								FUN_0041e680();
							}
						}
					}
				}
			}
			else {
				if ((local_3c->objType == OBJECT_MINIFIGURE) &&
					 (local_3c->drivenObject != (LiveObject *)0x0)) {
					local_3c = local_3c->drivenObject;
				}
				if (local_3c->carryingThisObject != (LiveObject *)0x0) {
					local_3c = local_3c->carryingThisObject;
				}
				if (((local_3c->objType == OBJECT_VEHICLE) &&
						(BVar14 = Game_IsAnyUnitsSelected(), BVar14 != 0)) &&
					 (pLVar6 = Game_GetPrimarySelectedObject(), pLVar9 = local_3c,
					 pLVar6->objType == OBJECT_MINIFIGURE)) {
					pLVar6 = Game_GetPrimarySelectedObject();
					LVar13 = 2;
					OVar7 = LiveObject_GetStatsFlags3(pLVar9);
					if ((OVar7 & STATS3_NEEDSPILOT) == STATS3_NONE) {
						OVar8 = LiveObject_GetStatsFlags1(pLVar9);
						if ((OVar8 & STATS1_CROSSLAND) != STATS1_NONE) {
							OVar8 = LiveObject_GetStatsFlags1(pLVar9);
							LVar13 = (-(uint)((OVar8 & STATS1_CROSSWATER) != STATS1_NONE) & 0xfffffffd) + 4;
						}
					}
					else {
						LVar13 = 1;
					}
					if ((pLVar6->flags5_3f0 & LVar13) != LIVEOBJ5_NONE) {
						if (local_40 == 0) {
							PVar4 = POINTER_GETIN;
							goto LAB_00427972;
						}
						ai::AITask_DoFindDriver_Target(pLVar9);
						snd::Audio_FUN_00428730(0);
						FUN_0041e680();
					}
				}
				else {
					if (((globals::g_Game.flags3 & GAME3_UNK_20) == GAME3_NONE) &&
						 ((globals::g_Game.flags3 & GAME3_UNK_40) == GAME3_NONE)) {
						if (((globals::g_Game.flags3 & GAME3_PICKUPOBJECT) == GAME3_NONE) &&
							 ((globals::g_Game.flags3 & GAME3_LOADVEHICLE) == GAME3_NONE)) {
							if (((globals::g_Game.flags3 & GAME3_UNK_2) != GAME3_NONE) ||
								 ((globals::g_Game.flags3 & GAME3_UNK_4) != GAME3_NONE)) {
								if ((globals::g_Game.flags3 & GAME3_UNK_2) == GAME3_NONE) {
									PVar4 = POINTER_VEHICLECANTGO;
								}
								else {
									PVar4 = POINTER_LEGOMANCANTGO;
								}
								goto LAB_00427972;
							}
							if ((globals::g_Game.flags3 & GAME3_UNK_1) == GAME3_NONE) {
								BVar14 = LiveObject_CheckCondition_FUN_00438870(local_3c,1);
								if (BVar14 != 0) {
									front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SELECTED);
									if (BOOL_004df560 == 0) {
										LiveObject_ShowToolTip(local_3c);
									}
									if (local_40 == 0) {
										pLVar9 = Game_GetPrimarySelectedObject();
										if ((pLVar9 != (LiveObject *)0x0) &&
											 ((local_3c->objType == OBJECT_POWERCRYSTAL ||
												(local_3c->objType == OBJECT_ORE)))) {
											LiveObject_GetBlockCoordinates(local_3c,(int *)&local_24,(int *)&local_24.y);
											iVar5 = LiveObject_FUN_00431cd0
																				(pLVar9,(int)local_24.x,(int)local_24.y,(int)local_24.x,
																				 (int)local_24.y,0);
											if (iVar5 != 0) {
												if (local_3c->objType == OBJECT_ORE) {
													PVar4 = POINTER_PICKUPORE;
												}
												else {
													if (pLVar9->objType == OBJECT_MINIFIGURE) {
														PVar4 = POINTER_LEGOMANPICKUP;
													}
													else {
														if (pLVar9->objType != OBJECT_VEHICLE) goto LAB_0042797a;
														PVar4 = POINTER_VEHICLEPICKUP;
													}
												}
LAB_00427972:
												front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
											}
										}
									}
									else {
										TVar11 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
										if (((TVar11 & TUTORIAL_UNK_8) != TUTORIAL_NONE) ||
											 ((TVar11 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0),
												TVar11 != TUTORIAL_NONE && (local_3c->field_3f8 == 0)))) goto LAB_00427727;
										iVar5 = FUN_0041e8c0(local_3c->objType,local_3c->objIndex);
										if ((((iVar5 != 0) && ((local_3c->flags2 & LIVEOBJ2_UNK_2) == LIVEOBJ2_NONE)) &&
												((OVar2 = local_3c->objType, OVar2 != OBJECT_VEHICLE ||
												 ((local_3c->flags1 & LIVEOBJ1_CLEARING) == LIVEOBJ1_NONE)))) &&
											 (((globals::g_Game.flags1 & GAME1_LASERTRACKER) == GAME1_NONE ||
												((*(byte *)&local_3c->flags4 & 1) != 0)))) {
											if ((OVar2 == OBJECT_VEHICLE) ||
												 (((OVar2 == OBJECT_BUILDING || (OVar2 == OBJECT_MINIFIGURE)) ||
													((OVar2 == OBJECT_ELECTRICFENCE &&
													 ((local_3c->flags2 & LIVEOBJ2_UNK_2000000) != LIVEOBJ2_NONE)))))) {
												snd::Audio_FUN_00428730(0);
												if (param_5 == 0) {
													Level_AddMessageAction(MESSAGE_CLEARSELECT,0,0,(Point2I *)0x0);
												}
												else {
													BVar14 = LiveObject_Check_FUN_004528d0(local_3c,(uint *)0x0);
													if (BVar14 != 0) goto LAB_0042797a;
												}
												Level_AddMessageAction(MESSAGE_SELECT,local_3c,0,(Point2I *)0x0);
												Level_AddMessageAction(MESSAGE_REDUCESELECTION,0,0,(Point2I *)0x0);
											}
											else {
												if ((OVar2 == OBJECT_POWERCRYSTAL) || (OVar2 == OBJECT_ORE)) {
													pLVar9 = Game_GetPrimarySelectedObject();
													if (pLVar9 != (LiveObject *)0x0) {
														LiveObject_GetBlockCoordinates
																			(local_3c,(int *)&local_24,(int *)&local_24.y);
														iVar5 = LiveObject_FUN_00431cd0
																							(pLVar9,(int)local_24.x,(int)local_24.y,
																							 (int)local_24.x,(int)local_24.y,0);
														if (iVar5 != 0) {
															opt_position = (Point2I *)&local_24;
															goto LAB_00426def;
														}
													}
												}
												else {
													snd::Audio_FUN_00428730(1);
												}
											}
										}
									}
								}
							}
							else {
								globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_UNK_200;
								front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_HELP);
								front::Text_DisplayMessage(TEXT_ENCYCLOPEDIA,0,0);
								if (local_40 != 0) {
									snd::Audio_FUN_00428730(0);
									FUN_0040e630((undefined4 *)local_3c);
								}
							}
						}
						else {
							if ((globals::g_Game.flags3 & GAME3_PICKUPOBJECT) == GAME3_NONE) {
								PVar4 = POINTER_VEHICLECANTPICKUP;
							}
							else {
								PVar4 = POINTER_LEGOMANCANTPICKUP;
							}
							front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
							OVar2 = local_3c->objType;
							if ((((OVar2 == OBJECT_ORE) || (OVar2 == OBJECT_POWERCRYSTAL)) ||
									((OVar2 == OBJECT_ELECTRICFENCE &&
									 ((local_3c->flags2 & LIVEOBJ2_UNK_2000000) == LIVEOBJ2_NONE)))) ||
								 ((OVar2 == OBJECT_DYNAMITE && ((local_3c->flags3 & 0x10000) == LIVEOBJ3_NONE)))) {
								BVar14 = 0;
								uVar16 = local_34;
								fVar12 = local_38;
								uVar18 = local_34;
								fVar17 = local_38;
								pLVar9 = Game_GetPrimarySelectedObject();
								iVar5 = LiveObject_FUN_00431cd0(pLVar9,uVar16,(int)fVar12,uVar18,(int)fVar17,BVar14)
								;
								if (iVar5 != 0) {
									if (local_3c->objType == OBJECT_ORE) {
										PVar4 = POINTER_PICKUPORE;
									}
									else {
										if ((globals::g_Game.flags3 & GAME3_PICKUPOBJECT) == GAME3_NONE) {
											PVar4 = POINTER_VEHICLEPICKUP;
										}
										else {
											PVar4 = POINTER_LEGOMANPICKUP;
										}
									}
									front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
									if (local_40 != 0) {
										opt_position = &Point2I_00557fb8;
LAB_00426def:
										Level_AddMessageAction(MESSAGE_USERGOTO,0,0,opt_position);
										LiveObject_FUN_004025f0(local_3c);
										ai::AITask_FUN_00401f40(AITASK_COLLECT,local_3c,(Point2I *)0x0);
LAB_00427954:
										snd::Audio_FUN_00428730(0);
										FUN_0041e680();
									}
								}
							}
						}
					}
					else {
						if ((globals::g_Game.flags3 & GAME3_UNK_20) == GAME3_NONE) {
							PVar4 = POINTER_VEHICLECANTDIG;
						}
						else {
							PVar4 = POINTER_LEGOMANCANTDIG;
						}
						front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
						front::Text_DisplayMessage(TEXT_NODRILL,0,0);
					}
				}
			}
		}
		else {
			local_1c.x = local_c;
			local_1c.y = local_8;
			local_28 = 1;
			BVar14 = Game_UnkBuildingPlaceDirection
												 (globals::g_Game.placeObjType,globals::g_Game.placeObjIndex,local_40,0,
													&local_1c,local_34,(uint)local_38,1,globals::g_Game.RES_2f4_TABLEUNK);
			if (BVar14 == 0) {
				globals::g_Game.flags3 = globals::g_Game.flags3 & ~GAME3_PLACEBUILDING;
			}
			if (local_40 != 0) {
				*(int *)((int)elapsed + 0x28) = *(int *)((int)elapsed + 0x28) + 1;
			}
		}
	}
LAB_0042797a:
	if ((((globals::g_Game.flags3 & GAME3_PLACEBUILDING) == GAME3_NONE) &&
			((globals::g_Game.flags1 & GAME1_LASERTRACKER) == GAME1_NONE)) &&
		 (TVar11 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0),
		 (TVar11 & TUTORIAL_UNK_200) == TUTORIAL_NONE)) {
		if (globs::INPUT.mslb == 0) {
			if ((globals::g_Game.flags1 & GAME1_UNK_100) == GAME1_NONE) {
				globals::g_Game.float_a4 = local_c;
				globals::g_Game.float_a8 = local_8;
				globals::g_Game.float_ac = local_4;
			}
			else {
				local_24.x = (float)globs::INPUT.msx;
				local_24.y = (float)globs::INPUT.msy;
				TVar11 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
				if ((TVar11 & TUTORIAL_UNK_8) == TUTORIAL_NONE) {
					if (param_5 == 0) {
						Level_AddMessageAction(MESSAGE_CLEARSELECT,0,0,(Point2I *)0x0);
					}
					lego::view::Viewport_WorldToScreen
										(globals::g_Game.viewMain,&local_14,(Vector3F *)&globals::g_Game.float_a4);
					lego::view::Viewport_DoSelection(globals::g_Game.viewMain,&local_14,&local_24);
					snd::Audio_FUN_00428730(0);
				}
			}
			globals::g_Game.float_b0 = (float)(ulonglong)local_34;
			local_24.x = local_38;
			local_24.y = 0.0;
			globals::g_Game.float_b4 = (float)(ulonglong)(uint)local_38;
		}
		if (((BOOL_004df560 != 0) && ((globals::g_Game.flags2 & GAME2_NOMULTISELECT) == GAME2_NONE)) &&
			 ((globals::g_Game.flags1 & GAME1_UNK_200) == GAME1_NONE)) {
			if (((globals::g_Game.flags1 & GAME1_UNK_100) == GAME1_NONE) &&
				 (fVar12 = SQRT(FLOAT_004df41c * FLOAT_004df41c + FLOAT_004df418 * FLOAT_004df418),
				 (ushort)((ushort)(fVar12 < 10.0) << 8 | (ushort)(fVar12 == 10.0) << 0xe) == 0)) {
				globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_UNK_100;
			}
			globals::g_Game.float_b8 = (float)(ulonglong)local_34;
			local_24.x = local_38;
			local_24.y = 0.0;
			globals::g_Game.float_bc = (float)(ulonglong)(uint)local_38;
		}
	}
	if ((globals::g_Game.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
		Game_HandleDebugKeys(local_34,(int)local_38,local_3c);
	}
LAB_00427c9c:
	if (((local_28 == 0) && ((globals::g_Game.flags3 & GAME3_PLACEBUILDING) != GAME3_NONE)) &&
		 (BVar14 = Game_UnkBuildingPlaceDirection
												 (globals::g_Game.placeObjType,globals::g_Game.placeObjIndex,local_40,
													local_30,(Point2F *)0x0,local_34,(uint)local_38,0,
													globals::g_Game.RES_2f4_TABLEUNK), BVar14 == 0)) {
		globals::g_Game.flags3 = globals::g_Game.flags3 & ~GAME3_PLACEBUILDING;
	}
	if (BOOL_004df560 == 0) {
		globals::g_Game.flags1 = globals::g_Game.flags1 & ~(GAME1_UNK_100|GAME1_UNK_200);
	}
	BOOL_004df564 = globs::INPUT.mslb;
	BOOL_004df568 = globs::INPUT.msrb;
	return;
}



void __cdecl lego::main::Main_Load_ToolTipInfo(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ToolTipInfo","HealthText",0);
	globals::g_Game.HealthText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ToolTipInfo","EnergyText",0);
	globals::g_Game.EnergyText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ToolTipInfo","CrystalsText",0);
	globals::g_Game.CrystalsText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ToolTipInfo","OreText",0);
	globals::g_Game.OreText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ToolTipInfo","StudsText",0);
	globals::g_Game.StudsText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ToolTipInfo","ToolsText",0);
	globals::g_Game.ToolsText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ToolTipInfo","CarryObjectText",0);
	globals::g_Game.CarryObjectText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ToolTipInfo","DrivenByText",0);
	globals::g_Game.DrivenByText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ToolTipInfo","OreRequiredText",0);
	globals::g_Game.OreRequiredText = cfg::CFG_CopyString(root,pcVar1);
	return;
}



void __cdecl lego::main::Main_LoadUpgradeNames(CFGProperty *root)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *prop;
	int iVar3;
	uint uVar4;
	
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"UpgradeNames",0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (prop == (CFGProperty *)0x0) {
			return;
		}
		uVar4 = 0xffffffff;
		pcVar2 = "Level";
		do {
			if (uVar4 == 0) break;
			uVar4 = uVar4 - 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar2 + 1;
		} while (cVar1 != '\0');
		iVar3 = std::_strnicmp("Level",prop->key,~uVar4 - 1);
		if (iVar3 == 0) {
			uVar4 = 0xffffffff;
			pcVar2 = "Level";
			do {
				if (uVar4 == 0) break;
				uVar4 = uVar4 - 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar2 + 1;
			} while (cVar1 != '\0');
			uVar4 = std::atoi(prop->key + (~uVar4 - 1));
			if (uVar4 < 0x10) {
				pcVar2 = std::_strdup(prop->value);
				globals::g_Game.UpgradeNames_TABLE[uVar4] = pcVar2;
			}
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl lego::game::LiveObject_ShowToolTip(LiveObject *liveObj)
{
	char cVar1;
	ObjectType OVar2;
	ImageBMP *pIVar3;
	char *pcVar4;
	BOOL BVar5;
	undefined4 uVar6;
	int iVar7;
	uint uVar8;
	uint uVar9;
	undefined4 *puVar10;
	ImageBMP **ppIVar11;
	byte bVar12;
	char *pcVar13;
	char *pcVar14;
	undefined4 *puVar15;
	ToolType *pTVar16;
	longlong lVar17;
	char local_180 [128];
	char local_100 [256];
	
	pcVar4 = LiveObject_GetName(liveObj);
	if (pcVar4 != (char *)0x0) {
		pcVar4 = LiveObject_GetName(liveObj);
		iVar7 = -1;
		do {
			if (iVar7 == 0) break;
			iVar7 = iVar7 + -1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar4 + 1;
		} while (cVar1 != '\0');
		if (iVar7 != -2) {
			if (_DAT_004df574 != liveObj) {
				_DAT_004df574 = liveObj;
				return;
			}
			if ((liveObj->customName != (char *)0x0) && (*liveObj->customName == '\0')) {
				LiveObject_SetCustomName(liveObj,(char *)0x0);
			}
			pcVar4 = liveObj->customName;
			if (pcVar4 == (char *)0x0) {
				pcVar4 = LiveObject_GetName(liveObj);
			}
			uVar8 = 0xffffffff;
			do {
				pcVar13 = pcVar4;
				if (uVar8 == 0) break;
				uVar8 = uVar8 - 1;
				pcVar13 = pcVar4 + 1;
				cVar1 = *pcVar4;
				pcVar4 = pcVar13;
			} while (cVar1 != '\0');
			uVar8 = ~uVar8;
			puVar10 = (undefined4 *)(pcVar13 + -uVar8);
			puVar15 = (undefined4 *)local_100;
			for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
				*puVar15 = *puVar10;
				puVar10 = puVar10 + 1;
				puVar15 = puVar15 + 1;
			}
			OVar2 = liveObj->objType;
			for (uVar8 = uVar8 & 3; uVar8 != 0; uVar8 = uVar8 - 1) {
				*(undefined *)puVar15 = *(undefined *)puVar10;
				puVar10 = (undefined4 *)((int)puVar10 + 1);
				puVar15 = (undefined4 *)((int)puVar15 + 1);
			}
			if ((OVar2 == OBJECT_BUILDING) &&
				 (globals::g_Game.UpgradeNames_TABLE[liveObj->objLevel] != (char *)0x0)) {
				std::sprintf(local_180," (%s)",globals::g_Game.UpgradeNames_TABLE[liveObj->objLevel]);
				uVar8 = 0xffffffff;
				pcVar4 = local_180;
				do {
					pcVar13 = pcVar4;
					if (uVar8 == 0) break;
					uVar8 = uVar8 - 1;
					pcVar13 = pcVar4 + 1;
					cVar1 = *pcVar4;
					pcVar4 = pcVar13;
				} while (cVar1 != '\0');
				uVar8 = ~uVar8;
				iVar7 = -1;
				pcVar4 = local_100;
				do {
					pcVar14 = pcVar4;
					if (iVar7 == 0) break;
					iVar7 = iVar7 + -1;
					pcVar14 = pcVar4 + 1;
					cVar1 = *pcVar4;
					pcVar4 = pcVar14;
				} while (cVar1 != '\0');
				puVar10 = (undefined4 *)(pcVar13 + -uVar8);
				puVar15 = (undefined4 *)(pcVar14 + -1);
				for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
					*puVar15 = *puVar10;
					puVar10 = puVar10 + 1;
					puVar15 = puVar15 + 1;
				}
				for (uVar8 = uVar8 & 3; uVar8 != 0; uVar8 = uVar8 - 1) {
					*(undefined *)puVar15 = *(undefined *)puVar10;
					puVar10 = (undefined4 *)((int)puVar10 + 1);
					puVar15 = (undefined4 *)((int)puVar15 + 1);
				}
			}
			if (((((liveObj->flags3 & 0x40000) != LIVEOBJ3_NONE) &&
					 (BVar5 = LiveObject_FUN_0040aa10(liveObj), BVar5 != 0)) &&
					(liveObj->objType != OBJECT_MINIFIGURE)) && (liveObj->objType != OBJECT_ROCKMONSTER)) {
				if (0.0 <= liveObj->health) {
					lVar17 = __ftol((float10)liveObj->health);
					uVar6 = (undefined4)lVar17;
				}
				else {
					uVar6 = 0;
				}
				std::sprintf(local_180,"\n%s: %i",globals::g_Game.EnergyText,uVar6);
				uVar8 = 0xffffffff;
				pcVar4 = local_180;
				do {
					pcVar13 = pcVar4;
					if (uVar8 == 0) break;
					uVar8 = uVar8 - 1;
					pcVar13 = pcVar4 + 1;
					cVar1 = *pcVar4;
					pcVar4 = pcVar13;
				} while (cVar1 != '\0');
				uVar8 = ~uVar8;
				iVar7 = -1;
				pcVar4 = local_100;
				do {
					pcVar14 = pcVar4;
					if (iVar7 == 0) break;
					iVar7 = iVar7 + -1;
					pcVar14 = pcVar4 + 1;
					cVar1 = *pcVar4;
					pcVar4 = pcVar14;
				} while (cVar1 != '\0');
				puVar10 = (undefined4 *)(pcVar13 + -uVar8);
				puVar15 = (undefined4 *)(pcVar14 + -1);
				for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
					*puVar15 = *puVar10;
					puVar10 = puVar10 + 1;
					puVar15 = puVar15 + 1;
				}
				for (uVar8 = uVar8 & 3; uVar8 != 0; uVar8 = uVar8 - 1) {
					*(undefined *)puVar15 = *(undefined *)puVar10;
					puVar10 = (undefined4 *)((int)puVar10 + 1);
					puVar15 = (undefined4 *)((int)puVar15 + 1);
				}
			}
			if (((liveObj->objType == OBJECT_VEHICLE) && (liveObj->drivenObject != (LiveObject *)0x0)) &&
				 ((pcVar4 = liveObj->drivenObject->customName, pcVar4 != (char *)0x0 &&
					((*pcVar4 != '\0' && (globals::g_Game.DrivenByText != (char *)0x0)))))) {
				std::sprintf(local_180,"\n%s: %s",globals::g_Game.DrivenByText,pcVar4);
				uVar8 = 0xffffffff;
				pcVar4 = local_180;
				do {
					pcVar13 = pcVar4;
					if (uVar8 == 0) break;
					uVar8 = uVar8 - 1;
					pcVar13 = pcVar4 + 1;
					cVar1 = *pcVar4;
					pcVar4 = pcVar13;
				} while (cVar1 != '\0');
				uVar8 = ~uVar8;
				iVar7 = -1;
				pcVar4 = local_100;
				do {
					pcVar14 = pcVar4;
					if (iVar7 == 0) break;
					iVar7 = iVar7 + -1;
					pcVar14 = pcVar4 + 1;
					cVar1 = *pcVar4;
					pcVar4 = pcVar14;
				} while (cVar1 != '\0');
				puVar10 = (undefined4 *)(pcVar13 + -uVar8);
				puVar15 = (undefined4 *)(pcVar14 + -1);
				for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
					*puVar15 = *puVar10;
					puVar10 = puVar10 + 1;
					puVar15 = puVar15 + 1;
				}
				for (uVar8 = uVar8 & 3; uVar8 != 0; uVar8 = uVar8 - 1) {
					*(undefined *)puVar15 = *(undefined *)puVar10;
					puVar10 = (undefined4 *)((int)puVar10 + 1);
					puVar15 = (undefined4 *)((int)puVar15 + 1);
				}
			}
			front::ToolTip_Load_HasNLEscape(2,local_100);
			iVar7 = LiveObject_GetObjTtSFX(liveObj);
			front::ToolTip_FUN_0046b9c0(2,iVar7);
			if (liveObj->objType == OBJECT_MINIFIGURE) {
				uVar8 = 0;
				if (liveObj->numCarriedTools != 0) {
					pTVar16 = liveObj->carriedTools;
					do {
						if (globals::g_ToolTipIcons_Tools_TABLE[*pTVar16] != (ImageBMP *)0x0) {
							front::ToolTip_FUN_0046b920
												(2,(undefined4 *)globals::g_ToolTipIcons_Tools_TABLE[*pTVar16]);
						}
						uVar8 = uVar8 + 1;
						pTVar16 = pTVar16 + 1;
					} while (uVar8 < liveObj->numCarriedTools);
				}
				uVar9 = LiveObject_GetNumOfToolsCanCarry(liveObj);
				if (uVar8 < uVar9) {
					do {
						if (globals::g_ToolTipIcon_Blank != (ImageBMP *)0x0) {
							front::ToolTip_FUN_0046b920(2,(undefined4 *)globals::g_ToolTipIcon_Blank);
						}
						uVar8 = uVar8 + 1;
						uVar9 = LiveObject_GetNumOfToolsCanCarry(liveObj);
					} while (uVar8 < uVar9);
				}
				if (liveObj->flags5_3f0 != LIVEOBJ5_NONE) {
					front::ToolTip_FUN_0046b920(2,(undefined4 *)0x0);
					bVar12 = 0;
					ppIVar11 = globals::g_ToolTipIcons_Abilities_TABLE;
					do {
						pIVar3 = globals::g_ToolTipIcon_Blank;
						if ((liveObj->flags5_3f0 & 1 << (bVar12 & 0x1f)) != LIVEOBJ5_NONE) {
							pIVar3 = *ppIVar11;
						}
						if (pIVar3 != (ImageBMP *)0x0) {
							front::ToolTip_FUN_0046b920(2,(undefined4 *)pIVar3);
						}
						ppIVar11 = ppIVar11 + 1;
						bVar12 = bVar12 + 1;
					} while (ppIVar11 < globals::g_ToolTipIcons_Tools_TABLE);
				}
			}
			front::ToolTip_AddFlag4(2);
		}
	}
	return;
}



void __cdecl FUN_00428260(Point2F *param_1,BOOL param_2,BOOL param_3,BOOL param_4)
{
	LevelBlock *pLVar1;
	char cVar2;
	float fVar3;
	float fVar4;
	LevelBlockFlags1 LVar5;
	int *liveObjField10;
	bool bVar6;
	char *pcVar7;
	int iVar8;
	int iVar9;
	int iVar10;
	int iVar11;
	int iVar12;
	int iVar13;
	char *pcVar14;
	LevelBlockFlags1 LVar15;
	uint uVar16;
	uint uVar17;
	uint uVar18;
	undefined4 *puVar19;
	undefined4 *puVar20;
	char local_100 [128];
	undefined4 local_80 [32];
	
	fVar3 = param_1->y;
	fVar4 = param_1->x;
	pLVar1 = (lego::globals::g_Game.level)->blocks +
					 ((lego::globals::g_Game.level)->dimensions).width * (int)fVar3 + (int)fVar4;
	if ((Point2F_004df208.x != fVar4) || (Point2F_004df208.y != fVar3)) {
		Point2F_004df208.x = param_1->x;
		Point2F_004df208.y = param_1->y;
		return;
	}
	LVar5 = pLVar1->flags1;
	pcVar7 = (char *)(LVar5 & BLOCK1_UNK_100000);
	if ((((pcVar7 != (char *)0x0) &&
			 (((lego::globals::g_Game.level)->blocks
				 [((lego::globals::g_Game.level)->dimensions).width * (int)fVar3 + (int)fVar4].flags1 &
				BLOCK1_UNK_400) == BLOCK1_NONE)) &&
			((*(byte *)&(lego::globals::g_Game.level)->blocks
									[((lego::globals::g_Game.level)->dimensions).width * (int)fVar3 + (int)fVar4].
									flags2 & 4) == 0)) && ((LVar5 & BLOCK1_UNK_8000) == BLOCK1_NONE)) {
		liveObjField10 = (int *)pLVar1->field_10;
		uVar18 = liveObjField10[0x34];
		pcVar7 = lego::game::Object_GetName(OBJECT_BUILDING,*liveObjField10);
		uVar16 = 0xffffffff;
		do {
			pcVar14 = pcVar7;
			if (uVar16 == 0) break;
			uVar16 = uVar16 - 1;
			pcVar14 = pcVar7 + 1;
			cVar2 = *pcVar7;
			pcVar7 = pcVar14;
		} while (cVar2 != '\0');
		uVar16 = ~uVar16;
		puVar19 = (undefined4 *)(pcVar14 + -uVar16);
		puVar20 = local_80;
		for (uVar17 = uVar16 >> 2; uVar17 != 0; uVar17 = uVar17 - 1) {
			*puVar20 = *puVar19;
			puVar19 = puVar19 + 1;
			puVar20 = puVar20 + 1;
		}
		for (uVar16 = uVar16 & 3; uVar16 != 0; uVar16 = uVar16 - 1) {
			*(undefined *)puVar20 = *(undefined *)puVar19;
			puVar19 = (undefined4 *)((int)puVar19 + 1);
			puVar20 = (undefined4 *)((int)puVar20 + 1);
		}
		if (param_2 != 0) {
			iVar8 = FUN_00408d40((int)liveObjField10,6,0);
			iVar9 = lego::game::Object_GetCostCrystal(OBJECT_BUILDING,*liveObjField10,0);
			iVar10 = FUN_00408d40((int)liveObjField10,7,0);
			iVar11 = lego::game::Object_GetCostOre(OBJECT_BUILDING,*liveObjField10,0);
			iVar12 = FUN_00408d40((int)liveObjField10,7,1);
			iVar13 = lego::game::Object_GetCostRefinedOre(OBJECT_BUILDING,*liveObjField10,0);
			if (iVar9 != 0) {
				std::sprintf(local_100,"\n%s: %i/%i",lego::globals::g_Game.CrystalsText,iVar8,iVar9);
				uVar16 = 0xffffffff;
				pcVar7 = local_100;
				do {
					pcVar14 = pcVar7;
					if (uVar16 == 0) break;
					uVar16 = uVar16 - 1;
					pcVar14 = pcVar7 + 1;
					cVar2 = *pcVar7;
					pcVar7 = pcVar14;
				} while (cVar2 != '\0');
				uVar16 = ~uVar16;
				iVar8 = -1;
				puVar19 = local_80;
				do {
					puVar20 = puVar19;
					if (iVar8 == 0) break;
					iVar8 = iVar8 + -1;
					puVar20 = (undefined4 *)((int)puVar19 + 1);
					cVar2 = *(char *)puVar19;
					puVar19 = puVar20;
				} while (cVar2 != '\0');
				puVar19 = (undefined4 *)(pcVar14 + -uVar16);
				puVar20 = (undefined4 *)((int)puVar20 + -1);
				for (uVar17 = uVar16 >> 2; uVar17 != 0; uVar17 = uVar17 - 1) {
					*puVar20 = *puVar19;
					puVar19 = puVar19 + 1;
					puVar20 = puVar20 + 1;
				}
				for (uVar16 = uVar16 & 3; uVar16 != 0; uVar16 = uVar16 - 1) {
					*(undefined *)puVar20 = *(undefined *)puVar19;
					puVar19 = (undefined4 *)((int)puVar19 + 1);
					puVar20 = (undefined4 *)((int)puVar20 + 1);
				}
			}
			pcVar7 = lego::globals::g_Game.OreText;
			if ((uVar18 & 8) != 0) {
				iVar10 = iVar12;
				iVar11 = iVar13;
				pcVar7 = lego::globals::g_Game.StudsText;
			}
			if (iVar11 != 0) {
				std::sprintf(local_100,"\n%s: %i/%i",pcVar7,iVar10,iVar11);
				uVar18 = 0xffffffff;
				pcVar7 = local_100;
				do {
					pcVar14 = pcVar7;
					if (uVar18 == 0) break;
					uVar18 = uVar18 - 1;
					pcVar14 = pcVar7 + 1;
					cVar2 = *pcVar7;
					pcVar7 = pcVar14;
				} while (cVar2 != '\0');
				uVar18 = ~uVar18;
				iVar10 = -1;
				puVar19 = local_80;
				do {
					puVar20 = puVar19;
					if (iVar10 == 0) break;
					iVar10 = iVar10 + -1;
					puVar20 = (undefined4 *)((int)puVar19 + 1);
					cVar2 = *(char *)puVar19;
					puVar19 = puVar20;
				} while (cVar2 != '\0');
				puVar19 = (undefined4 *)(pcVar14 + -uVar18);
				puVar20 = (undefined4 *)((int)puVar20 + -1);
				for (uVar16 = uVar18 >> 2; uVar16 != 0; uVar16 = uVar16 - 1) {
					*puVar20 = *puVar19;
					puVar19 = puVar19 + 1;
					puVar20 = puVar20 + 1;
				}
				for (uVar18 = uVar18 & 3; uVar18 != 0; uVar18 = uVar18 - 1) {
					*(undefined *)puVar20 = *(undefined *)puVar19;
					puVar19 = (undefined4 *)((int)puVar19 + 1);
					puVar20 = (undefined4 *)((int)puVar20 + 1);
				}
			}
		}
		lego::front::ToolTip_Load_HasNLEscape(3,(char *)local_80);
		lego::front::ToolTip_FUN_0046b9c0(3,0);
		lego::front::ToolTip_AddFlag4(3);
		return;
	}
	bVar6 = false;
	if ((LVar5 & BLOCK1_UNK_8) == BLOCK1_NONE) {
		if (((LVar5 & BLOCK1_UNK_10) == BLOCK1_NONE) && ((LVar5 & BLOCK1_HIDDEN) != BLOCK1_NONE)) {
			pcVar7 = FUN_004350a0(0x10);
			uVar18 = 0x10;
		}
		else {
			if ((LVar5 & BLOCK1_REINFORCED) == BLOCK1_NONE) {
				uVar18 = (uint)pLVar1->terrain;
				goto LAB_00428649;
			}
			pcVar7 = FUN_004350a0(0xd);
			uVar18 = 0xd;
		}
	}
	else {
		if ((LVar5 & BLOCK1_UNK_80000000) == BLOCK1_NONE) {
			if ((LVar5 & BLOCK1_UNK_200000) == BLOCK1_NONE) {
				pcVar7 = FUN_004350a0(0xc);
				pcVar14 = (char *)FUN_004350c0(0xc);
				bVar6 = true;
			}
			else {
				if ((*(byte *)&pLVar1->flags2 & 0x20) == 0) {
					if ((((int)fVar4 < 0) || ((int)fVar3 < 0)) ||
						 ((iVar10 = ((lego::globals::g_Game.level)->dimensions).width, iVar10 <= (int)fVar4 ||
							(((lego::globals::g_Game.level)->dimensions).height <= (int)fVar3)))) {
						LVar15 = BLOCK1_NONE;
					}
					else {
						LVar15 = (lego::globals::g_Game.level)->blocks[iVar10 * (int)fVar3 + (int)fVar4].flags1
										 & BLOCK1_POWERPATH;
					}
					if ((LVar15 == BLOCK1_NONE) && ((LVar5 & BLOCK1_UNK_8000) == BLOCK1_NONE)) {
						pcVar14 = pcVar7;
						if (((((lego::globals::g_Game.level)->blocks
									 [((lego::globals::g_Game.level)->dimensions).width * (int)fVar3 + (int)fVar4].
									 flags1 & BLOCK1_UNK_400) == BLOCK1_NONE) &&
								((*(byte *)&(lego::globals::g_Game.level)->blocks
														[((lego::globals::g_Game.level)->dimensions).width * (int)fVar3 +
														 (int)fVar4].flags2 & 4) == 0)) && (pcVar7 == (char *)0x0)) {
							if (param_4 == 0) goto LAB_004285a8;
							pcVar7 = FUN_004350a0(0x11);
							pcVar14 = (char *)FUN_004350c0(0x11);
							bVar6 = true;
						}
					}
					else {
						pcVar7 = FUN_004350a0(0xe);
						pcVar14 = (char *)FUN_004350c0(0xe);
						bVar6 = true;
					}
				}
				else {
					pcVar7 = FUN_004350a0(0xf);
					pcVar14 = (char *)FUN_004350c0(0xf);
					bVar6 = true;
				}
			}
		}
		else {
LAB_004285a8:
			pcVar7 = FUN_004350a0(0);
			pcVar14 = (char *)FUN_004350c0(0);
			bVar6 = true;
		}
		if (pLVar1->terrain == TERRAIN_LAKE) {
			uVar18 = 9;
LAB_00428649:
			pcVar7 = FUN_004350a0(uVar18);
			uVar18 = (uint)pLVar1->terrain;
		}
		else {
			if (pLVar1->terrain != TERRAIN_LAVA) goto LAB_00428668;
			pcVar7 = FUN_004350a0(6);
			uVar18 = (uint)pLVar1->terrain;
		}
	}
	pcVar14 = (char *)FUN_004350c0(uVar18);
	bVar6 = true;
LAB_00428668:
	if (bVar6) {
		lego::front::ToolTip_Load_HasNLEscape(6,"%s",pcVar7);
		if (param_3 == 0) {
			pcVar14 = (char *)0x0;
		}
		lego::front::ToolTip_FUN_0046b9c0(6,pcVar14);
		lego::front::ToolTip_AddFlag4(6);
	}
	return;
}



BOOL __cdecl lego::game::Level_BlockPointerCheck(Point2I *blockPos)
{
	int iVar1;
	int iVar2;
	int iVar3;
	TutorialFlags TVar4;
	LevelData *level;
	
	TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
	if (TVar4 != TUTORIAL_NONE) {
		TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
		if ((TVar4 & TUTORIAL_UNK_8) == TUTORIAL_NONE) {
			TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
			if ((TVar4 & TUTORIAL_UNK_4) == TUTORIAL_NONE) {
				return 1;
			}
		}
	}
	TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
	if ((TVar4 & TUTORIAL_UNK_2) != TUTORIAL_NONE) {
		level = GetLevel();
		iVar1 = (level->dimensions).width;
		iVar2 = blockPos->y;
		iVar3 = blockPos->x;
		level = GetLevel();
		if (level->blocks[iVar1 * iVar2 + iVar3].blockpointer == 0) {
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::snd::Audio_FUN_00428730(int param_1)
{
	BOOL setFlag8;
	SFXType sfxType;
	
	setFlag8 = Audio_GetFlag8();
	Audio_FUN_00465590(0,0);
	switch(param_1) {
	case 0:
		front::Pointer_SetTypeAndUnkFloat(POINTER_OKAY,12.5);
		sfxType = SFX_OKAY;
		break;
	case 1:
		front::Pointer_SetTypeAndUnkFloat(POINTER_NOTOKAY,12.5);
		sfxType = SFX_NOTOKAY;
		break;
	case 2:
		front::Pointer_SetTypeAndUnkFloat(POINTER_NOTOKAY,12.5);
		sfxType = SFX_IMMOVABLEROCK;
		break;
	case 3:
		front::Pointer_SetTypeAndUnkFloat(POINTER_OKAY,12.5);
		sfxType = SFX_TOPPRIORITY;
		break;
	case 4:
		front::Pointer_SetTypeAndUnkFloat(POINTER_OKAY,12.5);
		sfxType = SFX_WALL;
		break;
	case 5:
		front::Pointer_SetTypeAndUnkFloat(POINTER_OKAY,12.5);
		sfxType = SFX_FLOOR;
		break;
	default:
		goto switchD_00428751_caseD_6;
	}
	Audio_Play_FUN_00465260(sfxType,0);
switchD_00428751_caseD_6:
	Audio_FUN_00465590(setFlag8,0);
	return;
}



void __cdecl lego::game::Game_HandleDebugKeys(int bx,int by,LiveObject *liveObj)
{
	LevelData *pLVar1;
	BOOL BVar2;
	LiveObject *pLVar3;
	BOOL BVar4;
	BOOL BVar5;
	BOOL BVar6;
	LiveObject *liveObj_00;
	undefined **ppuVar7;
	LiveObject **ppLVar8;
	ObjectUpgradesData *pOVar9;
	uint uVar10;
	float in_stack_00000010;
	float dirz;
	int iVar11;
	float *pfVar12;
	uint local_18;
	LiveObject **local_14;
	Point2F local_10;
	Point2I mousePos;
	
	mousePos.x = bx;
	mousePos.y = by;
										// IsKeyPressed(KEY_A) (30)
										// "Creates a landslide at mousepoint."
	if (((globs::INPUT.Key_Map[30] != false) &&
			(globs::INPUT.prevKey_Map[30] != globs::INPUT.Key_Map[30])) &&
		 (FUN_0040f260(&mousePos,1,1), liveObj != (LiveObject *)0x0)) {
		ai::AI_LiveObject_DoSlip(liveObj);
	}
										// IsKeyPressed(KEY_END) (207)
										// "Toggles power Off/On for currently selected building"
	if (((globs::INPUT.Key_Map[207] != false) &&
			(globs::INPUT.prevKey_Map[207] != globs::INPUT.Key_Map[207])) &&
		 (BVar2 = Game_IsAnyUnitsSelected(), BVar2 != 0)) {
		pLVar3 = Game_GetPrimarySelectedObject();
		LiveObject_SetUnkFlags2(pLVar3);
	}
										// IsKeyPressed(KEY_E) (18)
	if ((globs::INPUT.Key_Map[18] != false) &&
		 (globs::INPUT.prevKey_Map[18] != globs::INPUT.Key_Map[18])) {
		FUN_0043b1f0((int **)(globals::g_Game.RockMonsterData_TABLE +
												 (globals::g_Game.level)->EmergeCreature),4.203895e-45,
								 (globals::g_Game.level)->EmergeCreature,bx,by);
	}
										// IsKeyDown(KEY_W) (17)
	if (globs::INPUT.Key_Map[17] != false) {
		Level_FUN_004303a0(globals::g_Game.level,0,(int *)bx,(int *)by);
	}
										// IsKeyPressed(KEY_C) (46)
	if (globs::INPUT.Key_Map[46] != false) {
		if ((globs::INPUT.prevKey_Map[46] != globs::INPUT.Key_Map[46]) &&
			 (BVar2 = Game_IsAnyUnitsSelected(), BVar2 != 0)) {
			pLVar3 = Game_GetPrimarySelectedObject();
			FUN_00448a80((int *)pLVar3);
		}
										// IsKeyPressed(KEY_C) (46)
		if (((globs::INPUT.Key_Map[46] != false) &&
				(globs::INPUT.prevKey_Map[46] != globs::INPUT.Key_Map[46])) &&
			 (BVar2 = Game_IsAnyUnitsSelected(), BVar2 != 0)) {
			pLVar3 = Game_GetPrimarySelectedObject();
			FUN_00448a80((int *)pLVar3);
		}
	}
										// IsKeyPressed(KEY_F12) (88)
										// "Disables all NERPs functions."
	if ((globs::INPUT.Key_Map[88] != false) &&
		 (globs::INPUT.prevKey_Map[88] != globs::INPUT.Key_Map[88])) {
		if ((globals::g_Game.flags1 & GAME1_DEBUG_NONERPS) == GAME1_NONE) {
			local_14 = (LiveObject **)0x0;
			globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_DEBUG_NONERPS;
			nerps::funcs::NERPFunc__SetTutorialFlags((int *)&local_14);
		}
		else {
			globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_DEBUG_NONERPS;
		}
	}
										// IsKeyPressed(KEY_F11) (87)
										// "Disables all building and vehicle prerequisites."
	if ((globs::INPUT.Key_Map[87] != false) &&
		 (globs::INPUT.prevKey_Map[87] != globs::INPUT.Key_Map[87])) {
		FUN_0040aa40(0);
	}
										// IsKeyPressed(KEY_F10) (68)
										// "Inverts the direction of lighting."
	if ((globs::INPUT.Key_Map[68] != false) &&
		 (globs::INPUT.prevKey_Map[68] != globs::INPUT.Key_Map[68])) {
		globals::g_GameLighting_Invert_DebugF10 = ZEXT14(globals::g_GameLighting_Invert_DebugF10 == 0);
		if (globals::g_GameLighting_Invert_DebugF10 == 0) {
			res::Container_SetPosition
								(globals::g_Game.resTopSpotlight,(globals::g_Game.cameraMain)->resData3,200.0,140.0,
								 -130.0);
			dirz = 0.75;
		}
		else {
			res::Container_SetPosition
								(globals::g_Game.resTopSpotlight,(globals::g_Game.cameraMain)->resData3,250.0,190.0,
								 20.0);
			dirz = 0.0;
		}
		res::Container_SetOrientation
							(globals::g_Game.resTopSpotlight,(globals::g_Game.cameraMain)->resData3,-1.0,-0.8,dirz
							 ,0.0,1.0,0.0);
		light::LightEffects_InvalidatePosition();
	}
										// IsKeyPressed(KEY_F9) (67)
	if ((globs::INPUT.Key_Map[67] != false) &&
		 (globs::INPUT.prevKey_Map[67] != globs::INPUT.Key_Map[67])) {
		globals::g_GameLighting_Unk_DebugF9 = ZEXT14(globals::g_GameLighting_Unk_DebugF9 == 0);
		light::LightEffects_SetDisabled(globals::g_GameLighting_Unk_DebugF9);
	}
	BVar2 = Game_IsAnyUnitsSelected();
										// IsKeyPressed(KEY_FIVE) (6) || IsKeyPressed(KEY_SIX) (7) ||
										// IsKeyPressed(KEY_SEVEN) (8) || IsKeyPressed(KEY_EIGHT) (9)
										// "Change selected unit visual upgrade parts"
	if ((BVar2 != 0) &&
		 ((((((globs::INPUT.Key_Map[6] != false &&
					(globs::INPUT.prevKey_Map[6] != globs::INPUT.Key_Map[6])) ||
				 ((globs::INPUT.Key_Map[7] != false &&
					(globs::INPUT.prevKey_Map[7] != globs::INPUT.Key_Map[7])))) ||
				((globs::INPUT.Key_Map[8] != false &&
				 (globs::INPUT.prevKey_Map[8] != globs::INPUT.Key_Map[8])))) ||
			 ((globs::INPUT.Key_Map[9] != false &&
				(globs::INPUT.prevKey_Map[9] != globs::INPUT.Key_Map[9])))) &&
			(local_14 = Game_GetSelectedUnits((int *)&local_10), local_10.x != 0.0)))) {
		pLVar3 = *local_14;
		if (pLVar3->objType == OBJECT_BUILDING) {
			BVar2 = 0;
			iVar11 = 0;
			pOVar9 = &pLVar3->building->upgrades;
			pLVar3 = Game_GetPrimarySelectedObject();
			BVar4 = FUN_004088a0(pLVar3->building,iVar11,BVar2);
			BVar2 = 0;
			iVar11 = 1;
			pLVar3 = Game_GetPrimarySelectedObject();
			BVar5 = FUN_004088a0(pLVar3->building,iVar11,BVar2);
			BVar2 = 0;
			iVar11 = 2;
			pLVar3 = Game_GetPrimarySelectedObject();
			BVar6 = FUN_004088a0(pLVar3->building,iVar11,BVar2);
			BVar2 = 0;
			iVar11 = 3;
			pLVar3 = Game_GetPrimarySelectedObject();
			BVar2 = FUN_004088a0(pLVar3->building,iVar11,BVar2);
		}
		else {
			if (pLVar3->objType == OBJECT_VEHICLE) {
				BVar2 = 0;
				iVar11 = 0;
				pOVar9 = &pLVar3->vehicle->upgrades;
				pLVar3 = Game_GetPrimarySelectedObject();
				BVar4 = res::Vehicle_FUN_0046d200(pLVar3->vehicle,iVar11,BVar2);
				BVar2 = 0;
				iVar11 = 1;
				pLVar3 = Game_GetPrimarySelectedObject();
				BVar5 = res::Vehicle_FUN_0046d200(pLVar3->vehicle,iVar11,BVar2);
				BVar2 = 0;
				iVar11 = 2;
				pLVar3 = Game_GetPrimarySelectedObject();
				BVar6 = res::Vehicle_FUN_0046d200(pLVar3->vehicle,iVar11,BVar2);
				BVar2 = 0;
				iVar11 = 3;
				pLVar3 = Game_GetPrimarySelectedObject();
				BVar2 = res::Vehicle_FUN_0046d200(pLVar3->vehicle,iVar11,BVar2);
			}
			else {
				pOVar9 = (ObjectUpgradesData *)0x0;
				BVar2 = bx;
				BVar5 = bx;
				BVar6 = bx;
				BVar4 = bx;
			}
		}
		if (pOVar9 != (ObjectUpgradesData *)0x0) {
			local_18 = pOVar9->currentLevel;
			uVar10 = local_18;
										// IsKeyPressed(KEY_FIVE) (6)
										// "Change selected unit visual upgrade parts (level bit 3)"
			if (((globs::INPUT.Key_Map[6] != false) &&
					(globs::INPUT.prevKey_Map[6] != globs::INPUT.Key_Map[6])) && (BVar4 != 0)) {
				uVar10 = local_18 ^ 8;
			}
										// IsKeyPressed(KEY_SIX) (7)
										// "Change selected unit visual upgrade parts (level bit 2)"
			if (((globs::INPUT.Key_Map[7] != false) &&
					(globs::INPUT.prevKey_Map[7] != globs::INPUT.Key_Map[7])) && (BVar5 != 0)) {
				uVar10 = uVar10 ^ 4;
			}
										// IsKeyPressed(KEY_SEVEN) (8)
										// "Change selected unit visual upgrade parts (level bit 1)"
			if (((globs::INPUT.Key_Map[8] != false) &&
					(globs::INPUT.prevKey_Map[8] != globs::INPUT.Key_Map[8])) && (BVar6 != 0)) {
				uVar10 = uVar10 ^ 2;
			}
										// IsKeyPressed(KEY_EIGHT) (9)
										// "Change selected unit visual upgrade parts (level bit 0)"
			if (((globs::INPUT.Key_Map[9] != false) &&
					(globs::INPUT.prevKey_Map[9] != globs::INPUT.Key_Map[9])) && (BVar2 != 0)) {
				uVar10 = uVar10 ^ 1;
			}
			if (uVar10 != local_18) {
				if ((*local_14)->objType == OBJECT_BUILDING) {
					pLVar3 = Game_GetPrimarySelectedObject();
					LiveObject_BuildingChangeUpgradeParts(pLVar3->building,uVar10);
				}
				else {
					if ((*local_14)->objType == OBJECT_VEHICLE) {
						pLVar3 = Game_GetPrimarySelectedObject();
						res::Vehicle_ChangeUpgradeParts(pLVar3->vehicle,uVar10);
					}
				}
			}
		}
	}
										// IsKeyPressed(KEY_BACKSPACE) (14)
	if ((globs::INPUT.Key_Map[14] != false) &&
		 (globs::INPUT.prevKey_Map[14] != globs::INPUT.Key_Map[14])) {
		ai::AITask_DoGather_Count(5);
	}
										// IsKeyPressed(KEYPAD_DELETE) (83)
										// "Destroys any walls at mousepoint, except border rock"
	if ((globs::INPUT.Key_Map[83] != false) &&
		 (globs::INPUT.prevKey_Map[83] != globs::INPUT.Key_Map[83])) {
		Level_DestroyWall(globals::g_Game.level,bx,by,0);
	}
										// IsKeyDown(KEYPAD_3) (81)
										// "Destroys connections between any walls at mousepoint, except border rock."
	if (globs::INPUT.Key_Map[81] != false) {
		Level_DestroyWallConnection(globals::g_Game.level,bx,by);
	}
										// IsKeyPressed(KEY_W) (17)
	if ((((globs::INPUT.Key_Map[17] != false) &&
			 (globs::INPUT.prevKey_Map[17] != globs::INPUT.Key_Map[17])) &&
			(BVar2 = Game_IsAnyUnitsSelected(), BVar2 != 0)) &&
		 (pLVar3 = Game_GetPrimarySelectedObject(), pLVar1 = globals::g_Game.level,
		 pLVar3->objType == OBJECT_ROCKMONSTER)) {
		LiveObject_FUN_0044a890(pLVar3,(int *)&local_18,(int *)&local_14,1,0,0);
		liveObj_00 = LiveObject__Create((int **)globals::g_Game.RES_Boulder,OBJECT_BOULDER,0);
		LiveObject_FUN_0044a210(liveObj_00,1);
		LiveObject_RoutingNoCarry_FUN_00447470(pLVar3,local_18,(uint)local_14,liveObj_00);
		uVar10 = (pLVar1->dimensions).width * (int)local_14 + local_18;
		ppuVar7 = (undefined **)
							FUN_0040b780((int *)pLVar1->surfTextGrid,
													 uVar10 & 0xffffff00 | (uint)pLVar1->blocks[uVar10].texture);
		LiveObject_InitBoulderMesh_FUN_00440eb0(liveObj_00,ppuVar7);
	}
										// IsKeyPressed(KEY_N) (49)
	if (((globs::INPUT.Key_Map[49] != false) &&
			(globs::INPUT.prevKey_Map[49] != globs::INPUT.Key_Map[49])) &&
		 (BVar2 = Game_IsAnyUnitsSelected(), BVar2 != 0)) {
		BVar2 = 0;
		pLVar3 = Game_GetPrimarySelectedObject();
		LiveObject_UnkDoRouting_FUN_00441c00(pLVar3,BVar2);
	}
										// IsKeyUp(KEY_LEFTSHIFT) (42) && IsKeyPressed(KEY_A) (30)
										// "Tells a Rock Raider to get a Sonic Blaster from Tool Store and place at
										// mousepoint."
	if (((globs::INPUT.Key_Map[42] != false) && (globs::INPUT.Key_Map[30] != false)) &&
		 (globs::INPUT.prevKey_Map[30] != globs::INPUT.Key_Map[30])) {
		ai::AITask_DoBirdScarer_AtPosition(&mousePos);
	}
										// IsKeyPressed(KEY_B) (48)
										// "Pushes any Rock Raider or Monster at mousepoint east-northeast."
	if ((globs::INPUT.Key_Map[48] != false) &&
		 (globs::INPUT.prevKey_Map[48] != globs::INPUT.Key_Map[48])) {
		local_10.x = 2.0;
		local_10.y = 1.0;
		if (liveObj != (LiveObject *)0x0) {
			LiveObject_Unk_AndSetVector3B4(liveObj,&local_10,40.0);
		}
	}
										// IsKeyPressed(KEY_H) (35)
										// "Creates a spider web at mousepoint."
	if ((globs::INPUT.Key_Map[35] != false) &&
		 (globs::INPUT.prevKey_Map[35] != globs::INPUT.Key_Map[35])) {
		Level_DoSomethingBlockStruct_c__00466510(bx,by);
	}
										// IsKeyPressed(KEY_F) (33)
	if ((((globs::INPUT.Key_Map[33] != false) &&
			 (globs::INPUT.prevKey_Map[33] != globs::INPUT.Key_Map[33])) &&
			(BVar2 = Game_IsAnyUnitsSelected(), BVar2 != 0)) &&
		 (uVar10 = Game_GetNumSelectedUnits(), uVar10 != 0)) {
		ppLVar8 = Game_GetSelectedUnits();
		for (; uVar10 != 0; uVar10 = uVar10 - 1) {
			LiveObject_FUN_0043f960(*ppLVar8,40.0,1,in_stack_00000010);
			ppLVar8 = ppLVar8 + 1;
		}
	}
										// IsKeyPressed(KEY_H) (35)
	if (((globs::INPUT.Key_Map[35] != false) &&
			(globs::INPUT.prevKey_Map[35] != globs::INPUT.Key_Map[35])) &&
		 ((BVar2 = Game_IsAnyUnitsSelected(), BVar2 != 0 &&
			(pLVar3 = Game_GetPrimarySelectedObject(), pLVar3->objType == OBJECT_BUILDING)))) {
		FUN_0040d420((undefined4 *)pLVar3,0,0);
	}
										// IsKeyPressed(KEY_J) (36)
	if ((globs::INPUT.Key_Map[36] != false) &&
		 (globs::INPUT.prevKey_Map[36] != globs::INPUT.Key_Map[36])) {
		BVar2 = FUN_0040e390(bx,by);
		if (BVar2 == 0) {
			FUN_0040d0a0(bx,by);
		}
		else {
			FUN_0040d120(bx,by);
		}
	}
										// IsKeyPressed(KEY_Y) (21)
										// "Triggers the CrystalFound InfoMessage."
	if ((globs::INPUT.Key_Map[21] != false) &&
		 (globs::INPUT.prevKey_Map[21] != globs::INPUT.Key_Map[21])) {
		local_10.x = 1.401298e-45;
		local_10.y = 1.401298e-45;
		front::Info_FUN_00419ab0(INFO_CRYSTALFOUND,(char *)0x0,(LiveObject *)0x0,(Point2I *)&local_10);
	}
										// IsKeyUp(KEY_LEFTSHIFT) (42)
	if (globs::INPUT.Key_Map[42] == false) {
										// IsKeyPressed(KEY_U) (22)
										// "Ends Advisor_Anim_Point_N."
		if ((globs::INPUT.Key_Map[22] != false) &&
			 (globs::INPUT.prevKey_Map[22] != globs::INPUT.Key_Map[22])) {
			front::Advisor_ClearFlag2();
		}
	}
	else {
										// IsKeyPressed(KEY_U) (22)
										// "Begins Advisor_Anim_Point_N."
		if ((globs::INPUT.Key_Map[22] != false) &&
			 (globs::INPUT.prevKey_Map[22] != globs::INPUT.Key_Map[22])) {
			front::Panel_SetCurrentAdvisorFromButton(0,0,1);
		}
	}
										// IsKeyPressed(KEY_K) (37)
	if (((globs::INPUT.Key_Map[37] != false) &&
			(globs::INPUT.prevKey_Map[37] != globs::INPUT.Key_Map[37])) &&
		 (BVar2 = Game_IsAnyUnitsSelected(), BVar2 != 0)) {
		pLVar3 = Game_GetPrimarySelectedObject();
		if (pLVar3->objType == OBJECT_VEHICLE) {
			DAT_004df584 = Game_GetPrimarySelectedObject();
			return;
		}
		pLVar3 = Game_GetPrimarySelectedObject();
		if ((pLVar3->objType == OBJECT_MINIFIGURE) && (DAT_004df584 != (LiveObject *)0x0)) {
			pfVar12 = (float *)DAT_004df584;
			pLVar3 = Game_GetPrimarySelectedObject();
			FUN_00440690((int *)pLVar3,pfVar12);
		}
	}
	return;
}



void __cdecl lego::game::SurfaceMap_LevelXYCallback_FUN_00429040(int x,int y)
{
	if (((globals::g_Game.level)->blocks[((globals::g_Game.level)->dimensions).width * y + x].flags1 &
			BLOCK1_UNK_4000) != BLOCK1_NONE) {
		FUN_00465d80((globals::g_Game.level)->blocks
								 [((globals::g_Game.level)->dimensions).width * y + x].field_1c,0);
	}
	return;
}



void __cdecl FUN_00429090(Point2I *position)
{
	int iVar1;
	
	iVar1 = ((lego::globals::g_Game.level)->dimensions).width * position->y + position->x;
	FUN_0040b780((int *)(lego::globals::g_Game.level)->surfTextGrid,
							 iVar1 * 9 & 0xffffff00U | (uint)(lego::globals::g_Game.level)->blocks[iVar1].texture)
	;
	return;
}



void __cdecl FUN_004290d0(float elapsed,float param_2)
{
	SurfaceMap *surfMap;
	float fVar1;
	float10 fVar2;
	longlong lVar3;
	float unaff_retaddr;
	float in_stack_0000000c;
	float in_stack_00000010;
	float in_stack_00000014;
	float in_stack_00000018;
	int in_stack_0000001c;
	float in_stack_00000020;
	float in_stack_00000024;
	float in_stack_00000028;
	int in_stack_0000002c;
	uint in_stack_00000030;
	undefined4 in_stack_00000034;
	float in_stack_00000038;
	undefined4 in_stack_0000003c;
	float in_stack_00000040;
	float in_stack_00000044;
	float in_stack_00000048;
	float in_stack_0000004c;
	float in_stack_00000050;
	float in_stack_ffffffe8;
	float in_stack_ffffffec;
	float in_stack_fffffff0;
	float in_stack_fffffff4;
	float in_stack_fffffff8;
	float in_stack_fffffffc;
	
	if (param_2 == 0.0) {
		if (lego::globals::g_Game.viewMode == VIEW_TOPDOWN) {
			lego::res::Container_GetPosition
								((lego::globals::g_Game.cameraMain)->resData2,(Container *)0x0,
								 (Vector3F *)&stack0xffffffe8);
			lego::game::SurfaceMap_ToBlockCoordinatesNoZ
								((lego::globals::g_Game.level)->surfaceMap,in_stack_ffffffe8,in_stack_ffffffec,
								 (int *)&param_2,(int *)&elapsed);
			lego::res::Container_GetOrientation
								((lego::globals::g_Game.cameraMain)->resData1,(Container *)0x0,
								 (Vector3F *)&stack0xfffffff4,(Vector3F *)0x0);
			surfMap = lego::game::GetSurfaceMap();
			fVar2 = lego::game::SurfaceMap_GetBlockSize(surfMap);
			lego::game::SurfaceMap_ToBlockCoordinatesNoZ
								((lego::globals::g_Game.level)->surfaceMap,
								 (float)(fVar2 * (float10)3.0 * (float10)in_stack_fffffff4) + in_stack_ffffffe8,
								 (float)(fVar2 * (float10)3.0 * (float10)in_stack_fffffff8) + in_stack_ffffffec,
								 (int *)&param_2,(int *)&elapsed);
			lego::game::SurfaceMap_AddCoordsInRadius_AndDoCallbacks
								((lego::globals::g_Game.level)->surfaceMap,(int)param_2,(int)elapsed,8,
								 lego::game::SurfaceMap_LevelXYCallback_FUN_00429040);
			return;
		}
		if (lego::globals::g_Game.viewMode == VIEW_FIRSTPERSON) {
			param_2 = (lego::globals::g_Game.level)->surfaceMap->BlockSize *
								lego::globals::g_Game.FPClipBlocks;
			fVar1 = (float)lego::globals::g_Game.HPBlocks;
			if (((lego::globals::g_Game.flags1 & GAME1_DYNAMICPM) != GAME1_NONE) && (elapsed != 0.0)) {
				in_stack_ffffffec = 0.0;
				in_stack_ffffffe8 = (float)lego::globals::g_Game.HPBlocks;
				lVar3 = __ftol((float10)(ulonglong)(uint)lego::globals::g_Game.HPBlocks / (float10)elapsed);
				fVar1 = (float)lVar3;
			}
			FUN_00433db0((lego::globals::g_Game.cameraFP)->resData1,(uint *)lego::globals::g_Game.viewMain
									 ,(uint)param_2,fVar1,in_stack_ffffffe8,in_stack_ffffffec,in_stack_fffffff0,
									 in_stack_fffffff4,(int)in_stack_fffffff8,in_stack_fffffffc,unaff_retaddr,elapsed,
									 param_2,in_stack_0000000c,in_stack_00000010,in_stack_00000014,in_stack_00000018,
									 in_stack_0000001c,in_stack_00000020,in_stack_00000024,in_stack_00000028,
									 in_stack_0000002c,in_stack_00000030,in_stack_00000034,in_stack_00000038,
									 in_stack_0000003c,in_stack_00000040,in_stack_00000044,in_stack_00000048,
									 in_stack_0000004c,in_stack_00000050);
			return;
		}
	}
	else {
		if (((lego::globals::g_Game.flags1 & GAME1_RADARON) != GAME1_NONE) &&
			 ((lego::globals::g_Game.flags1 & GAME1_RADAR_TRACKOBJECTVIEW) != GAME1_NONE)) {
			lego::res::Container_GetPosition
								((lego::globals::g_Game.cameraRadar)->resData2,(Container *)0x0,
								 (Vector3F *)&stack0xfffffff4);
			lego::game::SurfaceMap_ToBlockCoordinatesNoZ
								((lego::globals::g_Game.level)->surfaceMap,in_stack_fffffff4,in_stack_fffffff8,
								 (int *)&param_2,(int *)&elapsed);
			lego::game::SurfaceMap_AddCoordsInRadius_AndDoCallbacks
								((lego::globals::g_Game.level)->surfaceMap,(int)param_2,(int)elapsed,2,
								 (XYCallback *)0x0);
		}
	}
	return;
}



void __cdecl FUN_004292e0(undefined4 param_1)
{
	Point2F local_38;
	float local_30;
	float local_2c;
	Point2F local_28;
	Point2F local_20;
	float local_18;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	if ((lego::globals::g_Game.flags1 & GAME1_UNK_100) != GAME1_NONE) {
		local_2c = (float)lego::globs::INPUT.msy;
		local_30 = (float)lego::globs::INPUT.msx;
		lego::view::Viewport_WorldToScreen
							(lego::globals::g_Game.viewMain,&local_38,(Vector3F *)&lego::globals::g_Game.float_a4)
		;
		local_28.x = local_38.x;
		local_28.y = local_38.y;
		local_20.x = local_30;
		local_20.y = local_38.y;
		local_18 = local_30;
		local_14 = local_2c;
		local_10 = local_38.x;
		local_c = local_2c;
		local_8 = local_38.x;
		local_4 = local_38.y;
		lego::draw::Draw_LineListEx
							(&local_28,&local_20,4,lego::globals::g_Game.DragBoxRGB.red,
							 lego::globals::g_Game.DragBoxRGB.green,lego::globals::g_Game.DragBoxRGB.blue,
							 DrawEffect_HalfTrans);
	}
	return;
}



void __cdecl
lego::game::Game_MainView_MouseTransform(uint mouseX,uint mouseY,float *out_x,float *out_y)
{
	BOOL BVar1;
	Vector3F local_4c;
	Vector3F local_40;
	Vector3F local_34;
	Vector3F local_28;
	Vector3F local_1c;
	Vector4F local_10;
	
	local_28.x = 0.0;
	local_4c.x = (float)mouseY;
	local_4c.y = 0.0;
	local_28.y = 0.0;
	local_28.z = 0.0;
	local_34.x = 0.0;
	local_34.y = 0.0;
	local_34.z = -1.0;
	local_10.z = 0.0;
	local_10.w = 1.0;
	local_10.x = (float)(ulonglong)mouseX;
	local_10.y = (float)(ulonglong)mouseY;
	lego::view::Viewport_InverseTransform(globals::g_Game.viewMain,&local_40,&local_10);
	local_10.z = 1.0;
	local_10.w = 1.0;
	local_10.x = (float)(ulonglong)mouseX;
	local_10.y = (float)(ulonglong)mouseY;
	lego::view::Viewport_InverseTransform(globals::g_Game.viewMain,&local_4c,&local_10);
	local_4c.x = local_4c.x - local_40.x;
	local_4c.y = local_4c.y - local_40.y;
	local_4c.z = local_4c.z - local_40.z;
	BVar1 = math::Maths_RayPlaneIntersection(&local_1c,&local_40,&local_4c,&local_28,&local_34);
	if (BVar1 != 0) {
		*out_x = local_1c.x;
		*out_y = local_1c.y;
	}
	return;
}



Container * __cdecl lego::game::Game_GetCurrentViewLight(void)
{
	Container *light;
	
	light = globals::g_Game.resFPLight;
	if (globals::g_Game.viewMode != VIEW_FIRSTPERSON) {
		light = globals::g_Game.resRootSpotlight;
	}
	return light;
}



BOOL __cdecl lego::game::LiveObject_Check_FUN_004294f0(LiveObject *liveObj)
{
	if (((globals::g_Game.viewMode != VIEW_FIRSTPERSON) || (liveObj != globals::g_Game.objectFP)) &&
		 ((liveObj->drivenObject == (LiveObject *)0x0 ||
			(liveObj->drivenObject != globals::g_Game.objectFP)))) {
		return 0;
	}
	return 1;
}



void __cdecl FUN_00429520(BOOL param_1,LiveObject *liveObj,int field14)
{
	BOOL BVar1;
	
	BVar1 = param_1;
	if (param_1 == 0) {
		param_1 = 1063675494;
		if (field14 != 0) {
			param_1 = 1058642330;
		}
		lego::view::Camera_SetObject4_Field14(lego::globals::g_Game.cameraFP,liveObj,field14);
		FUN_0046e480(1);
		lego::game::SurfaceMap_FUN_00450d40((lego::globals::g_Game.level)->surfaceMap,1);
		lego::globals::g_Game.objectFP = liveObj;
		if (liveObj->objType == OBJECT_MINIFIGURE) {
			lego::game::LiveObject_FUN_0043a130(liveObj,0);
		}
		lego::view::Viewport_SetCamera
							(lego::globals::g_Game.viewMain,(lego::globals::g_Game.cameraFP)->resData1);
		lego::snd::Sound3D_MakeListener((lego::globals::g_Game.cameraFP)->resData1->masterFrame);
		lego::snd::Sound3D_SetMinDistForAtten(50.0);
		lego::view::Viewport_SmoothSetField(lego::globals::g_Game.viewMain,(float)param_1);
		lego::view::Viewport_SetBackClip
							(lego::globals::g_Game.viewMain,
							 (lego::globals::g_Game.level)->BlockSize * lego::globals::g_Game.FPClipBlocks);
		lego::globals::g_Game.viewMode = BVar1;
		return;
	}
	if (param_1 == 1) {
		if (lego::globals::g_Game.objectFP != (LiveObject *)0x0) {
			lego::game::LiveObject_FUN_0042dd70(lego::globals::g_Game.objectFP,(uint *)0x0,0);
		}
		(lego::globals::g_Game.cameraFP)->object_4 = (LiveObject *)0x0;
		lego::globals::g_Game.objectFP = (LiveObject *)0x0;
		FUN_0046e480(0);
		lego::game::SurfaceMap_FUN_00450d40((lego::globals::g_Game.level)->surfaceMap,0);
		lego::view::Viewport_SetCamera
							(lego::globals::g_Game.viewMain,(lego::globals::g_Game.cameraMain)->resData1);
		lego::snd::Sound3D_MakeListener((lego::globals::g_Game.cameraMain)->resTableunk_34->masterFrame)
		;
		lego::snd::Sound3D_SetMinDistForAtten(lego::globals::g_Game.MinDistFor3DSoundsOnTopView);
		lego::view::Viewport_SetField(lego::globals::g_Game.viewMain,0.5);
		lego::view::Viewport_SetBackClip
							(lego::globals::g_Game.viewMain,lego::globals::g_Game.TVClipDist);
	}
	lego::globals::g_Game.viewMode = param_1;
	return;
}



void __cdecl lego::snd::Music_CDAudio_PlayNextCallback(void)
{
	Sound_StopCD();
	Music_PlayNext(1);
	return;
}



void __cdecl lego::snd::Music_PlayNext(BOOL isMusicOn)
{
	short sVar1;
	
	if (isMusicOn != 0) {
		sVar1 = math::Maths_Rand();
		globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_MUSICON;
		Sound_PlayCDTrack(((uint)(int)sVar1 % globals::g_Game.CDTracks - 1) +
											globals::g_Game.CDStartTrack,0,Music_CDAudio_PlayNextCallback);
		return;
	}
	globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_MUSICON;
	Sound_StopCD();
	Sound_Update(0);
	return;
}



void __cdecl lego::main::Config_SetSoundEnabled(BOOL isSoundOn)
{
	if (isSoundOn != 0) {
		globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_SOUNDON;
		snd::Audio_SetFlag1_AndOtherFunc_true(isSoundOn);
		return;
	}
	globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_SOUNDON;
	snd::Audio_SetFlag1_AndOtherFunc_true(0);
	return;
}



int __cdecl lego::game::Level_GetEmergeCreature(void)
{
	return (globals::g_Game.level)->EmergeCreature;
}



float10 __cdecl lego::game::Level_GetObjectUpgradeTime(ObjectType objType)
{
	return (float10)(globals::g_Game.level)->UpgradeTimes[objType];
}



float10 __cdecl lego::game::Level_GetTrainTime(void)
{
	return (float10)(globals::g_Game.level)->TrainTime;
}



// WARNING: Could not reconcile some variable overlaps

BOOL __cdecl lego::main::Main_loadLevelCFG(char *levelName)
{
	float fVar1;
	CFGProperty *root;
	char cVar2;
	undefined *puVar3;
	undefined4 *puVar4;
	int iVar5;
	LevelData *level;
	char *pcVar6;
	uint uVar7;
	BOOL3 BVar8;
	float fVar9;
	BOOL BVar10;
	LiveObject *pLVar11;
	LiveObject **ppLVar12;
	LevelData *pLVar13;
	float *pfVar14;
	uint uVar15;
	float10 fVar16;
	ColourRGBF *pCVar17;
	float *pfVar18;
	float local_1c0;
	float local_1bc;
	float local_1b8;
	char *nameEmergeCreature;
	ObjectType local_1b0;
	char *local_1ac;
	char *local_1a8;
	char *local_1a4;
	char *local_1a0;
	char *local_19c;
	char *local_198;
	char *local_194;
	char *local_190;
	char *local_18c;
	char *local_188;
	char *local_184;
	Point2F filenameObjectList;
	char *local_178;
	char *filenameIntroAVI;
	char *filenameNERPMessage;
	char *filenameNERP;
	char *filenamePTL;
	uint local_164;
	char *local_160;
	char *local_15c;
	int local_134;
	char *local_130;
	LiveObject *local_12c [10];
	char local_104 [260];
	
	root = globals::g_Game.LegoCfgRoot;
	game::Level_DoVideo__004158c0(levelName,1);
	unk::Lego_CleanupLinkedStruct20();
	FUN_00415080();
	game::Game_SetPlaceFlagsState_004dd650(0);
	unk::Lego_SetBool_004b9a54(0);
	game::LiveManager_SetFlag20(0);
	puVar3 = FUN_00417da0();
	if (puVar3 == (undefined *)0x0) {
		puVar4 = (undefined4 *)0x0;
	}
	else {
		puVar4 = (undefined4 *)(puVar3 + 0x1c);
	}
	FUN_00437390(puVar4);
	iVar5 = unk::Lego_GetDat_00500e64();
	if ((iVar5 == 0) && (iVar5 = save::Save_GetSaveNumber(), iVar5 != -1)) {
		std::sprintf(local_104,"%s\\%i.osf","Saves",iVar5);
		unk::Lego_Read_SORRFile__00459730(local_104);
	}
	level = (LevelData *)std::malloc(0x284);
	if (level == (LevelData *)0x0) goto LAB_0042b198;
	pLVar13 = level;
	for (iVar5 = 0xa1; iVar5 != 0; iVar5 = iVar5 + -1) {
		pLVar13->levelName = (char *)0x0;
		pLVar13 = (LevelData *)&pLVar13->surfaceMap;
	}
	globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_LEVELSTART;
	globals::g_Game.level = level;
	LoaderProfile_Lookup(levelName);
	game::Level_LoadPriorities(root,globals::g_Game.CfgRootName,levelName);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"Seed",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"Seed",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	uVar7 = std::atoi(pcVar6);
	if (uVar7 != 0) {
		std::srand(uVar7);
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"BoulderAnimation",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if ((pcVar6 == (char *)0x0) || (iVar5 = std::_stricmp(pcVar6,"Rock"), iVar5 == 0)) {
LAB_00429989:
		level->BoulderAnimation = TEXTURES_ROCK;
	}
	else {
		iVar5 = std::_stricmp(pcVar6,"Lava");
		if (iVar5 == 0) {
			level->BoulderAnimation = TEXTURES_LAVA;
		}
		else {
			iVar5 = std::_stricmp(pcVar6,"Ice");
			if (iVar5 != 0) goto LAB_00429989;
			level->BoulderAnimation = TEXTURES_ICE;
		}
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"FallinMultiplier",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"FallinMultiplier",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	globals::g_Game.FallinMultiplier = std::atoi(pcVar6);
	if (globals::g_Game.FallinMultiplier == 0) {
		globals::g_Game.FallinMultiplier = 1;
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"blocksize",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"blocksize",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	level->BlockSize = (float)fVar16;
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"digdepth",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"digdepth",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	level->DigDepth = (float)fVar16;
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"useroof",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	level->UseRoof = BVar8;
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"roofheight",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"roofheight",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	level->RoofHeight = (float)fVar16;
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"roughlevel",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"roughlevel",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	level->RoughLevel = (float)fVar16;
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"surfacemap",0);
	local_1a0 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"predugmap",0);
	local_1a8 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"terrainmap",0);
	local_194 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"blockPointersMap",0);
	local_198 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"CryOreMap",0);
	local_1ac = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"ErodeMap",0);
	local_18c = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"EmergeMap",0);
	local_184 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"AIMap",0);
	local_188 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"PathMap",0);
	local_1a4 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"FallinMap",0);
	local_190 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"textureset",0);
	local_178 = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"EmergeTimeOut",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"EmergeTimeOut",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	level->EmergeTimeOut = (float)fVar16;
	if (fVar16 == (float10)0.0) {
		level->EmergeTimeOut = 1500.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"olistfile",0);
	filenameObjectList.x = (float)cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"elistfile",0);
	cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"selboxheight",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"selboxheight",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	level->SelBoxHeight = (float)fVar16;
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"PTLFile",0);
	filenamePTL = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"NERPFile",0);
	filenameNERP = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"NERPMessageFile",0);
	filenameNERPMessage = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"EmergeCreature",0);
	nameEmergeCreature = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"SafeCaverns",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	level->SafeCaverns = BVar8;
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"IntroAVI",0);
	filenameIntroAVI = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"StartFP",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	level->StartFP = (uint)(BVar8 == BOOL3_TRUE);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"NoDrain",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	level->NoDrain = (uint)(BVar8 == BOOL3_TRUE);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"OxygenRate",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"OxygenRate",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	level->OxygenRate = (float)(fVar16 * (float10)0.001);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"UpgradeTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"UpgradeTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	fVar9 = (float)(fVar16 * (float10)25.0);
	pfVar14 = level->UpgradeTimes;
	for (iVar5 = 0x14; iVar5 != 0; iVar5 = iVar5 + -1) {
		*pfVar14 = fVar9;
		pfVar14 = pfVar14 + 1;
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"MinifigureUpgradeTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"MinifigureUpgradeTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	fVar1 = (float)fVar16;
	level->UpgradeTimes[2] = fVar1;
	if (fVar1 == 0.0) {
		level->UpgradeTimes[2] = fVar9;
	}
	else {
		level->UpgradeTimes[2] = fVar1 * 25.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"VehicleUpgradeTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"VehicleUpgradeTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	fVar1 = (float)fVar16;
	level->UpgradeTimes[1] = fVar1;
	if (fVar1 == 0.0) {
		level->UpgradeTimes[1] = fVar9;
	}
	else {
		level->UpgradeTimes[1] = fVar1 * 25.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"BuildingUpgradeTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"BuildingUpgradeTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	fVar1 = (float)fVar16;
	level->UpgradeTimes[4] = fVar1;
	if (fVar1 == 0.0) {
		level->UpgradeTimes[4] = fVar9;
	}
	else {
		level->UpgradeTimes[4] = fVar1 * 25.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"TrainTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"TrainTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	level->TrainTime = (float)(fVar16 * (float10)25.0);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"NoMultiSelect",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	if (BVar8 == BOOL3_TRUE) {
		globals::g_Game.flags2 = globals::g_Game.flags2 | GAME2_NOMULTISELECT;
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"NoAutoEat",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	if (BVar8 == BOOL3_TRUE) {
		globals::g_Game.flags2 = globals::g_Game.flags2 | GAME2_NOAUTOEAT;
	}
	else {
		globals::g_Game.flags2 = globals::g_Game.flags2 & ~GAME2_NOAUTOEAT;
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"EndGameAVI1",0);
	globals::g_Game.EndGameAVI1 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"EndGameAVI2",0);
	globals::g_Game.EndGameAVI2 = cfg::CFG_CopyString(root,pcVar6);
	if (globals::g_Game.RenameReplace != (char *)0x0) {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"AllowRename",0);
		BVar8 = cfg::CFG_ReadBool(root,pcVar6);
		if (BVar8 == BOOL3_TRUE) {
			globals::g_Game.flags2 = globals::g_Game.flags2 | GAME2_ALLOWRENAME;
		}
		else {
			globals::g_Game.flags2 = globals::g_Game.flags2 & ~GAME2_ALLOWRENAME;
		}
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"RecallOLObjects",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	if (BVar8 == BOOL3_TRUE) {
		globals::g_Game.flags2 = globals::g_Game.flags2 | GAME2_RECALLOLOBJECTS;
	}
	else {
		globals::g_Game.flags2 = globals::g_Game.flags2 & ~GAME2_RECALLOLOBJECTS;
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"GenerateSpiders",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	if (BVar8 == BOOL3_TRUE) {
		globals::g_Game.flags2 = globals::g_Game.flags2 | GAME2_GENERATESPIDERS;
	}
	else {
		globals::g_Game.flags2 = globals::g_Game.flags2 & ~GAME2_GENERATESPIDERS;
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"DisableToolTipSound",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	if (BVar8 == BOOL3_TRUE) {
		globals::g_Game.flags2 = globals::g_Game.flags2 | GAME2_DISABLETOOLTIPSOUND;
	}
	else {
		globals::g_Game.flags2 = globals::g_Game.flags2 & ~GAME2_DISABLETOOLTIPSOUND;
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"DisableEndTeleport",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	game::Game_SetEndTeleportEnabled((uint)(BVar8 != BOOL3_TRUE));
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"DragBoxRGB",0);
	pcVar6 = cfg::CFG_CopyString(root,pcVar6);
	local_19c = pcVar6;
	if (pcVar6 != (char *)0x0) {
		iVar5 = util::Util_Tokenise(pcVar6,(char **)local_12c,":");
		if (iVar5 == 3) {
			uVar7 = 0;
			do {
				local_1b0 = std::atoi(*(char **)((int)local_12c + uVar7));
				uVar15 = uVar7 + 4;
				*(float *)((int)globals::g_Game.UpgradeNames_TABLE + (uVar7 - 0x2c)) =
						 (float)local_1b0 * 0.003921569;
				pcVar6 = local_19c;
				uVar7 = uVar15;
			} while (uVar15 < 0xc);
		}
		std::free(pcVar6);
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"BuildingTolerance",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"BuildingTolerance",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	level->BuildingTolerance = (float)fVar16;
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"BuildingMaxVariation",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"BuildingMaxVariation",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	level->BuildingMaxVariation = (float)fVar16;
	if (level->BuildingTolerance == 0.0) {
		level->BuildingTolerance = 4.0;
	}
	if ((float10)0.0 == fVar16) {
		level->BuildingMaxVariation = 6.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"MaxStolen",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"MaxStolen",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar9 = (float)std::atoi(pcVar6);
	level->MaxStolen = fVar9;
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"Slug",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		level->Slug = 0x14;
	}
	else {
		BVar10 = game::Object_GetObjectByName(pcVar6,&local_1b0,&level->Slug,(Container **)0x0);
		if (BVar10 != 0) {
			pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"SlugTime",0);
			pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			if (pcVar6 == (char *)0x0) {
				pcVar6 = ____EMPTYSTR__;
			}
			else {
				pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"SlugTime",0);
				pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			}
			fVar16 = std::atof(pcVar6);
			level->SlugTime = (float)fVar16;
			if ((float)fVar16 == 0.0) {
				level->SlugTime = 60.0;
			}
			level->SlugTime = level->SlugTime * 25.0;
			pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"InitialSlugTime",0);
			pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			if (pcVar6 == (char *)0x0) {
				pcVar6 = ____EMPTYSTR__;
			}
			else {
				pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"InitialSlugTime",0);
				pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			}
			fVar16 = std::atof(pcVar6);
			if ((float10)0.0 == fVar16) {
				fVar16 = (float10)60.0;
			}
			globals::g_Game.InitialSlugTime = (float)(fVar16 * (float10)25.0);
		}
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"RockFallStyle",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	game::Game_GetRockFallStyle(pcVar6,&local_164);
	game::Game_SetRockFallStyleIndex(local_164);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"noFallins",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	globals::g_Game.IsFallinsEnabled = ZEXT14(BVar8 != BOOL3_TRUE);
	game::Level_LoadRewardQuotaCrystals(root,globals::g_Game.CfgRootName,levelName);
	game::Object_GetObjectByName
						(nameEmergeCreature,(ObjectType *)&nameEmergeCreature,&level->EmergeCreature,
						 (Container **)0x0);
	pfVar18 = &globals::g_Game.FogColourRGB.blue;
	pfVar14 = &globals::g_Game.FogColourRGB.green;
	pCVar17 = &globals::g_Game.FogColourRGB;
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"FogColourRGB",0);
	BVar10 = cfg::CFG_ReadRGBF(globals::g_Game.LegoCfgRoot,pcVar6,(float *)pCVar17,pfVar14,pfVar18);
	if (BVar10 == 0) {
		globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_FOGCOLOURRGB;
	}
	else {
		pfVar18 = &globals::g_Game.HighFogColourRGB.blue;
		pfVar14 = &globals::g_Game.HighFogColourRGB.green;
		pCVar17 = &globals::g_Game.HighFogColourRGB;
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"HighFogColourRGB",0);
		BVar10 = cfg::CFG_ReadRGBF(globals::g_Game.LegoCfgRoot,pcVar6,(float *)pCVar17,pfVar14,pfVar18);
		if (BVar10 == 0) {
			globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_HIGHFOGCOLOURRGB;
		}
		else {
			globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_HIGHFOGCOLOURRGB;
			globals::g_Game.float_364 = 1.0;
			pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"FogRate",0);
			pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			if (pcVar6 == (char *)0x0) {
				pcVar6 = ____EMPTYSTR__;
			}
			else {
				pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"FogRate",0);
				pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			}
			fVar16 = std::atof(pcVar6);
			if ((float10)0.0 == fVar16) {
				globals::g_Game.FogRate = 1500.0;
			}
			else {
				globals::g_Game.FogRate = (float)fVar16 * 25.0;
			}
		}
		res::Container_SetFogColour
							(globals::g_Game.FogColourRGB.red,globals::g_Game.FogColourRGB.green,
							 globals::g_Game.FogColourRGB.blue);
		res::Container_SetFogMode(D3DRMFOGMETHOD_TABLE);
		res::Container_SetFogParams
							(0.0,(globals::g_Game.level)->BlockSize * globals::g_Game.FPClipBlocks,0.0032);
		globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_FOGCOLOURRGB;
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"nextlevel",0);
	pcVar6 = cfg::CFG_CopyString(root,pcVar6);
	level->NextLevel = pcVar6;
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"FullName",0);
	nameEmergeCreature = cfg::CFG_CopyString(root,pcVar6);
	level->FullName = nameEmergeCreature;
	if (nameEmergeCreature == (char *)0x0) {
		level->FullName = (char *)0x0;
	}
	else {
		iVar5 = -1;
		uVar7 = 0;
		pcVar6 = nameEmergeCreature;
		do {
			if (iVar5 == 0) break;
			iVar5 = iVar5 + -1;
			cVar2 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar2 != '\0');
		if (iVar5 != -2) {
			do {
				cVar2 = nameEmergeCreature[uVar7];
				if (cVar2 == '_') {
					cVar2 = ' ';
				}
				nameEmergeCreature[uVar7] = cVar2;
				nameEmergeCreature = level->FullName;
				uVar15 = 0xffffffff;
				uVar7 = uVar7 + 1;
				pcVar6 = nameEmergeCreature;
				do {
					if (uVar15 == 0) break;
					uVar15 = uVar15 - 1;
					cVar2 = *pcVar6;
					pcVar6 = pcVar6 + 1;
				} while (cVar2 != '\0');
			} while (uVar7 < ~uVar15 - 1);
		}
	}
	game::Level_LoadObjectiveInfo
						(root,globals::g_Game.CfgRootName,levelName,level,globs::mainGlobs.appWidth,
						 globs::mainGlobs.appHeight);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"ErodeTriggerTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"ErodeTriggerTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	local_1bc = (float)fVar16;
	if ((float10)0.0 == fVar16) {
		local_1bc = 10.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"ErodeErodeTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"ErodeErodeTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	local_1b8 = (float)fVar16;
	if ((float10)0.0 == fVar16) {
		local_1b8 = 5.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"ErodeLockTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"ErodeLockTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar16 = std::atof(pcVar6);
	local_1c0 = (float)fVar16;
	if ((float10)0.0 == fVar16) {
		local_1c0 = 60.0;
	}
	game::Game_SetErodeTimes(local_1bc,local_1b8,local_1c0);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"NumberOfLandSlidesTillCaveIn",0)
	;
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == (char *)0x0) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"NumberOfLandSlidesTillCaveIn",
															 0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	iVar5 = std::atoi(pcVar6);
	if (iVar5 == 0) {
		iVar5 = 3;
	}
	game::Game_SetNumberOfLandSlidesTillCaveIn(iVar5);
	pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"DisableStartTeleport",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	level->levelName = levelName;
	level->IsStartTeleportEnabled = (uint)(BVar8 != BOOL3_TRUE);
	level->float_204 = (float)&DAT_42c80000;
	level->oxygenLevel = (float)&DAT_42c80000;
	level->numCrystals = 0;
	level->numOre = 0;
	level->field_90 = 0;
	level->field_a4 = 0;
	level->field_94 = 0;
	level->field_a8 = 0;
	level->status = LEVELSTATUS_NONE;
	globals::g_Game.placeDestSmallTeleporter = (LiveObject *)0x0;
	globals::g_Game.placeDestBigTeleporter = (LiveObject *)0x0;
	game::Level_LoadNERPsFile(filenameNERP);
	game::Level_LoadNERPMessageFile(filenameNERPMessage);
	BVar10 = Main_loadPTLCFG__0045daa0(filenamePTL,globals::g_Game.CfgRootName);
	if (BVar10 != 0) {
		local_1bc = 0.0;
		local_1c0._0_1_ = '\0';
		local_1b8 = 0.0;
		local_19c = (char *)0x0;
		local_1b0 = OBJECT_NONE;
		if ((local_1a0 != (char *)0x0) &&
			 (iVar5 = util::Util_Tokenise(local_1a0,&local_160,":"), iVar5 == 2)) {
			std::atoi(local_15c);
		}
		if ((local_1a8 != (char *)0x0) &&
			 (iVar5 = util::Util_Tokenise(local_1a8,&local_160,":"), iVar5 == 2)) {
			local_1b0 = std::atoi(local_15c);
		}
		if ((local_194 != (char *)0x0) &&
			 (iVar5 = util::Util_Tokenise(local_194,&local_160,":"), iVar5 == 2)) {
			local_19c = (char *)std::atoi(local_15c);
		}
		if ((local_198 != (char *)0x0) &&
			 (iVar5 = util::Util_Tokenise(local_198,&local_160,":"), iVar5 == 2)) {
			local_1b8 = (float)std::atoi(local_15c);
		}
		if ((local_1ac != (char *)0x0) &&
			 (iVar5 = util::Util_Tokenise(local_1ac,&local_160,":"), iVar5 == 2)) {
			iVar5 = std::atoi(local_15c);
			local_1c0._0_1_ = (char)iVar5;
		}
		if ((local_1a4 != (char *)0x0) &&
			 (iVar5 = util::Util_Tokenise(local_1a4,&local_160,":"), iVar5 == 2)) {
			local_1bc = (float)std::atoi(local_15c);
		}
		if ((local_190 != (char *)0x0) &&
			 (iVar5 = util::Util_Tokenise(local_190,&local_160,":"), iVar5 == 2)) {
			std::atoi(local_15c);
		}
		pcVar6 = local_184;
		if ((local_184 != (char *)0x0) &&
			 (iVar5 = util::Util_Tokenise(local_184,&local_160,":"), iVar5 == 2)) {
			local_1bc = (float)std::atoi(local_15c);
		}
		BVar10 = game::Level_LoadMapFiles
											 (level,local_1a0,local_1a8,local_1b0,local_194,(int)local_19c,local_198,
												local_1b8,local_1ac,local_1c0._0_1_,local_18c,local_1a4,(int)local_1bc,
												local_178,pcVar6,local_188,local_190);
		if (BVar10 != 0) {
			std::free(local_1a0);
			std::free(local_1a8);
			std::free(local_194);
			std::free(local_198);
			std::free(local_1ac);
			std::free(local_18c);
			std::free(pcVar6);
			std::free(local_188);
			std::free(local_190);
			if (local_1a4 != (char *)0x0) {
				std::free(local_1a4);
			}
			pool::ReservedPool_BlockObject___Reset(level);
			game::Level_Start(level);
			game::Level_SetCompleteStatus(LEVELSTATUS_NONE);
			FUN_00458ea0(globals::g_Game.textWnd_80,globals::g_Game.level,1.0,1.0);
			BVar10 = Main_loadObjectListCFG(level,(char *)filenameObjectList.x);
			if (BVar10 != 0) {
				pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"InitialCrystals",0);
				pcVar6 = cfg::CFG_ReadString(root,pcVar6);
				if (pcVar6 == (char *)0x0) {
					pcVar6 = ____EMPTYSTR__;
				}
				else {
					pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"InitialCrystals",0);
					pcVar6 = cfg::CFG_ReadString(root,pcVar6);
				}
				local_134 = std::atoi(pcVar6);
				pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"InitialOre",0);
				pcVar6 = cfg::CFG_ReadString(root,pcVar6);
				if (pcVar6 == (char *)0x0) {
					pcVar6 = ____EMPTYSTR__;
				}
				else {
					pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"InitialOre",0);
					pcVar6 = cfg::CFG_ReadString(root,pcVar6);
				}
				local_130 = (char *)std::atoi(pcVar6);
				unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_0042b220,(LiveObject *)&stack0xfffffec8);
				LoaderProfile_Lookup((char *)0x0);
				filenameObjectList.x = 350.0;
				filenameObjectList.y = 70.0;
				video::VideoPlayer_OpenAndPlay(filenameIntroAVI,&filenameObjectList);
				pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"NoGather",0);
				BVar8 = cfg::CFG_ReadBool(root,pcVar6);
				game::Level_SetNoGather((uint)(BVar8 == BOOL3_TRUE));
				front::Info_SetFlag4(1);
				if ((level->StartFP == 0) || (MINIFIGOBJ_004e9448 == (LiveObject *)0x0)) {
					FUN_00429520(1,(LiveObject *)0x0,0);
				}
				else {
					FUN_00429520(0,MINIFIGOBJ_004e9448,1);
					game::Level_AddMessageAction(MESSAGE_SELECT,MINIFIGOBJ_004e9448,0,(Point2I *)0x0);
					FUN_0041b200(0xf,(Point2I *)0x0);
				}
				game::Level_InitBlockPointersTable(level);
				pcVar6 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,levelName,"Precreate",0);
				BVar8 = cfg::CFG_ReadBool(root,pcVar6);
				if (BVar8 == BOOL3_TRUE) {
					ppLVar12 = local_12c;
					iVar5 = 10;
					do {
						pLVar11 = game::LiveObject__Create
																((int **)globals::g_Game.MiniFigureData_TABLE,OBJECT_MINIFIGURE,0);
						*ppLVar12 = pLVar11;
						ppLVar12 = ppLVar12 + 1;
						iVar5 = iVar5 + -1;
					} while (iVar5 != 0);
					ppLVar12 = local_12c;
					iVar5 = 10;
					do {
						pool::ReservedPool_LiveObject___Release(*ppLVar12);
						ppLVar12 = ppLVar12 + 1;
						iVar5 = iVar5 + -1;
					} while (iVar5 != 0);
				}
				return 1;
			}
		}
	}
	std::free(level);
LAB_0042b198:
	std::free(local_1a0);
	std::free(local_1a8);
	std::free(local_194);
	std::free(local_198);
	std::free(local_1ac);
	std::free(local_18c);
	std::free(local_184);
	LoaderProfile_Lookup((char *)0x0);
	globals::g_Game.level = (LevelData *)0x0;
	return 0;
}



undefined4 __cdecl FUN_0042b220(int param_1,int param_2)
{
	ObjectStatsFlags1 OVar1;
	
	OVar1 = lego::game::LiveObject_GetStatsFlags1((LiveObject *)param_1);
	if ((OVar1 & STATS1_STOREOBJECTS) != STATS1_NONE) {
		FUN_0043abb0(param_1,*(int *)(param_2 + 4));
		FUN_0043abd0(param_1,*(int *)(param_2 + 8));
	}
	return 0;
}



BOOL __cdecl lego::game::Level_Load_FUN_0042b260(LevelData *level,char *meshBaseName)
{
	uint uVar1;
	undefined4 *puVar2;
	ProMeshData *pPVar3;
	uint uVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	int local_20c;
	char meshName_a [256];
	char meshName_b [256];
	
	uVar4 = (level->surfTextSize).height;
	uVar1 = (level->surfTextSize).width;
	puVar2 = (undefined4 *)std::malloc(uVar4 * uVar1 * 4);
	level->field_0x80 = puVar2;
	if (puVar2 == (undefined4 *)0x0) {
		return 0;
	}
	if ((globs::mainGlobs.flags & CMD_REDUCEPROMESHES) == CMD_NONE) {
		uVar7 = 0;
		if (uVar4 != 0) {
			local_20c = 0;
			do {
				uVar6 = 0;
				iVar5 = local_20c;
				if (uVar1 != 0) {
					do {
						std::sprintf(meshName_a,"%s%0.1x%0.1xa",meshBaseName,uVar6,uVar7);
						std::sprintf(meshName_b,"%s%0.1x%0.1xb",meshBaseName,uVar6,uVar7);
						pPVar3 = FUN_0040b520(globals::g_Game.resRoot,meshName_a,meshName_b,level->BlockSize,
																	level->surfTextGrid);
						uVar6 = uVar6 + 1;
						*(ProMeshData **)(level->field_0x80 + iVar5) = pPVar3;
						iVar5 = iVar5 + 4;
					} while (uVar6 < uVar1);
				}
				uVar7 = uVar7 + 1;
				local_20c = local_20c + uVar1 * 4;
			} while (uVar7 < uVar4);
			return 1;
		}
	}
	else {
		for (uVar4 = uVar4 * uVar1 & 0x3fffffff; uVar4 != 0; uVar4 = uVar4 - 1) {
			*puVar2 = 0;
			puVar2 = puVar2 + 1;
		}
		for (iVar5 = 0; iVar5 != 0; iVar5 = iVar5 + -1) {
			*(undefined *)puVar2 = 0;
			puVar2 = (undefined4 *)((int)puVar2 + 1);
		}
	}
	return 1;
}



void __cdecl FUN_0042b3b0(int param_1)
{
	void *pvVar1;
	int iVar2;
	int iVar3;
	void *this;
	int iVar4;
	void *extraout_ECX;
	int iVar5;
	int iVar6;
	
	iVar4 = param_1;
	iVar2 = *(int *)(param_1 + 0x74);
	if (*(int *)(param_1 + 0x78) != 0) {
		pvVar1 = (void *)(iVar2 * 4);
		iVar5 = 0;
		iVar3 = iVar2;
		this = pvVar1;
		param_1 = *(int *)(param_1 + 0x78);
		iVar6 = iVar5;
		do {
			for (; iVar3 != 0; iVar3 = iVar3 + -1) {
				FUN_0040b700(this,*(int ***)(*(int *)(iVar4 + 0x80) + iVar5));
				iVar5 = iVar5 + 4;
				this = extraout_ECX;
			}
			iVar5 = iVar6 + (int)pvVar1;
			param_1 = param_1 + -1;
			iVar3 = iVar2;
			this = pvVar1;
			iVar6 = iVar5;
		} while (param_1 != 0);
	}
	std::free(*(void **)(iVar4 + 0x80));
	*(undefined4 *)(iVar4 + 0x80) = 0;
	return;
}



LevelStruct_3c * __cdecl FUN_0042b430(void)
{
	return (lego::globals::g_Game.level)->struct3c_84;
}



BOOL __cdecl
lego::game::Level_LoadMapFiles
					(LevelData *level,char *surfaceMap,char *predugMap,int predugParam,char *terrainMap,
					int terrainParam,char *blockPointersMap,int blockPointersParam,char *cryOreMap,
					char cryOreParam,char *erodeMap,char *pathMap,int pathParam,char *textureSet,
					char *emergeMap,char *aiMap,char *fallinMap)
{
	short sVar1;
	SurfaceMap *pSVar2;
	LevelStruct_3c *pLVar3;
	BOOL BVar4;
	uint uVar5;
	int iVar6;
	uint uVar7;
	uint uVar8;
	
	pSVar2 = SurfaceMap_Load(globals::g_Game.resRoot,surfaceMap,level->BlockSize,level->RoughLevel);
	level->surfaceMap = pSVar2;
	if (pSVar2 != (SurfaceMap *)0x0) {
		pLVar3 = SurfaceMap_AllocLevelStruct3C__0045dd50
											 (pSVar2,(Rect2F *)&globals::g_Game.float_324,globals::g_Game.tvTiltOrZoom_334
											 );
		level->struct3c_84 = pLVar3;
		SurfaceMap_FUN_0044f750(level->surfaceMap,1);
										// It seems this entire chain of calls is redundant, as they all cause the exact
										// same effect.
		SurfaceMap_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		SurfaceMap_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		SurfaceMap_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		SurfaceMap_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		SurfaceMap_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		SurfaceMap_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		pSVar2 = level->surfaceMap;
		(level->dimensions).width = (pSVar2->dimensions).width;
		(level->dimensions).height = (pSVar2->dimensions).height;
		pool::ReservedPool_BlockObject___Reset(level);
		Level_Start(level);
		if (level->UseRoof != BOOL3_FALSE) {
			FUN_00463060(globals::g_Game.resRoot,(level->dimensions).width,(level->dimensions).height);
			FUN_00463770(1);
		}
		pSVar2 = (SurfaceMap *)main::Main_LoadTextureType(level,textureSet);
		if (pSVar2 != (SurfaceMap *)0x0) {
			pSVar2 = (SurfaceMap *)
							 std::malloc((level->dimensions).height * (level->dimensions).width * 0x48);
			level->blocks = (LevelBlock *)pSVar2;
			if (pSVar2 != (SurfaceMap *)0x0) {
				uVar7 = 0;
				for (uVar5 = (uint)((level->dimensions).height * (level->dimensions).width * 0x48) >> 2;
						uVar5 != 0; uVar5 = uVar5 - 1) {
					(pSVar2->smallDimensions).width = 0;
					pSVar2 = (SurfaceMap *)&(pSVar2->smallDimensions).height;
				}
				for (iVar6 = 0; iVar6 != 0; iVar6 = iVar6 + -1) {
					*(undefined *)&(pSVar2->smallDimensions).width = 0;
					pSVar2 = (SurfaceMap *)((int)&(pSVar2->smallDimensions).width + 1);
				}
				if ((level->dimensions).height != 0) {
					do {
						uVar5 = (level->dimensions).width;
						uVar8 = 0;
						if (uVar5 != 0) {
							do {
								level->blocks[uVar7 * uVar5 + uVar8].predug = PREDUG_WALL;
								level->blocks[uVar7 * (level->dimensions).width + uVar8].texture = TEXTURE_GROUND;
								level->blocks[uVar7 * (level->dimensions).width + uVar8].terrain = TERRAIN_TUNNEL;
								level->blocks[uVar7 * (level->dimensions).width + uVar8].flags1 = BLOCK1_NONE;
								level->blocks[uVar7 * (level->dimensions).width + uVar8].field_3 = 0;
								level->blocks[uVar7 * (level->dimensions).width + uVar8].struct1c_18 =
										 (LevelStruct_1c *)0x0;
								level->blocks[uVar7 * (level->dimensions).width + uVar8].float_14 = 0.0;
								sVar1 = math::Maths_Rand();
								iVar6 = uVar7 * (level->dimensions).width + uVar8;
								uVar8 = uVar8 + 1;
								level->blocks[iVar6].randomness = sVar1;
								uVar5 = (level->dimensions).width;
							} while (uVar8 < uVar5);
						}
						uVar7 = uVar7 + 1;
					} while (uVar7 < (uint)(level->dimensions).height);
				}
				pSVar2 = (SurfaceMap *)Level_LoadPredugMap(level,predugMap,predugParam);
				if (pSVar2 != (SurfaceMap *)0x0) {
					pSVar2 = (SurfaceMap *)Level_LoadTerrainMap(level,terrainMap,terrainParam);
					if (pSVar2 != (SurfaceMap *)0x0) {
						Level_LoadCryOreMap(level,cryOreMap,cryOreParam);
						Level_LoadErodeMap(level,erodeMap);
						Level_LoadPathMap(level,pathMap,pathParam);
						Level_LoadEmergeMap(level,emergeMap);
						Level_LoadAIMap(level,aiMap);
						Level_LoadFallinMap(level,fallinMap);
						BVar4 = Level_LoadBlockPointersMap(level,blockPointersMap,blockPointersParam);
						if (BVar4 != 0) {
							level->hasBlockPointers = 1;
						}
						uVar5 = 0;
						if ((level->dimensions).height != 0) {
							do {
								uVar7 = 0;
								if ((level->dimensions).width != 0) {
									do {
										Level_UpdateBlockSurfaceUnk(level,uVar7,uVar5);
										uVar7 = uVar7 + 1;
									} while (uVar7 < (uint)(level->dimensions).width);
								}
								uVar5 = uVar5 + 1;
							} while (uVar5 < (uint)(level->dimensions).height);
						}
						SurfaceMap_FUN_0044eb40(level->surfaceMap);
						Level_Load_FUN_0046de50(globals::g_Game.resRoot,level);
						pSVar2 = (SurfaceMap *)0x1;
					}
				}
			}
		}
	}
	return (BOOL)pSVar2;
}



void __cdecl lego::game::SurfaceMap_InitTextureCoords(SurfaceMap *surfMap)
{
	SurfaceTexture SVar1;
	uint uVar2;
	uint uVar3;
	SurfaceTexture local_68 [8];
	SurfaceTexture local_60 [8];
	SurfaceTexture local_58 [8];
	SurfaceTexture local_50 [8];
	SurfaceTexture local_48 [8];
	SurfaceTexture local_40 [8];
	SurfaceTexture local_38 [8];
	SurfaceTexture local_30 [16];
	SurfaceTexture local_20 [32];
	
	local_38[0] = TEXTURE_TUNNEL;
	local_38[1] = TEXTURE_TUNNEL;
	local_38[2] = TEXTURE_TUNNEL;
	local_38[3] = TEXTURE_TUNNEL;
	local_38[4] = TEXTURE_TUNNEL;
	local_38[5] = TEXTURE_TUNNEL;
	local_30[4] = TEXTURE_WALL_F_SOIL;
	local_30[5] = TEXTURE_WALL_F_ORESEAM;
	local_30[6] = TEXTURE_WALL_F_CRYSTALSEAM;
	local_30[7] = TEXTURE_WALL_F_RECHARGESEAM;
	local_30[12] = TEXTURE_WALL_F_SOIL;
	local_30[13] = TEXTURE_WALL_F_ORESEAM;
	local_30[14] = TEXTURE_WALL_F_CRYSTALSEAM;
	local_30[15] = TEXTURE_WALL_F_RECHARGESEAM;
	local_20[0] = TEXTURE_GROUND;
	local_20[1] = TEXTURE_GROUND;
	local_20[2] = TEXTURE_GROUND;
	local_20[3] = TEXTURE_GROUND;
	local_20[4] = TEXTURE_LAVA;
	local_20[5] = TEXTURE_LAVA_NOTHOT;
	local_20[6] = TEXTURE_WATER;
	local_20[7] = TEXTURE_GROUND;
	local_20[8] = TEXTURE_PLATE;
	local_20[9] = TEXTURE_PLATE_POWERED;
	local_20[10] = TEXTURE_RUBBLE_FULL;
	local_20[11] = TEXTURE_RUBBLE_HIGH;
	local_20[12] = TEXTURE_RUBBLE_MEDIUM;
	local_20[13] = TEXTURE_RUBBLE_LOW;
	local_20[14] = TEXTURE_ERODE_LOW;
	local_20[15] = TEXTURE_ERODE_MEDIUM;
	local_20[16] = TEXTURE_ERODE_HIGH;
	local_20[17] = TEXTURE_ERODE_FULL;
	local_20[18] = TEXTURE_07;
	local_20[19] = TEXTURE_PATH_BUILD;
	local_20[20] = TEXTURE_PATH_4;
	local_20[21] = TEXTURE_PATH_2;
	local_20[22] = TEXTURE_PATH_C;
	local_20[23] = TEXTURE_PATH_3;
	local_20[24] = TEXTURE_PATH_1;
	local_20[25] = TEXTURE_PATH_4_POWERED;
	local_20[26] = TEXTURE_PATH_2_POWERED;
	local_20[27] = TEXTURE_PATH_C_POWERED;
	local_20[28] = TEXTURE_PATH_3_POWERED;
	local_20[29] = TEXTURE_PATH_1_POWERED;
	local_20[30] = TEXTURE_SLUGHOLE;
	local_30[0] = TEXTURE_WALL_F_IMMOVABLE;
	local_30[1] = TEXTURE_WALL_F_HARD;
	local_30[2] = TEXTURE_WALL_F_MEDIUM;
	local_30[3] = TEXTURE_WALL_F_LOOSE;
	local_30[8] = TEXTURE_WALL_F_IMMOVABLE;
	local_30[9] = TEXTURE_WALL_F_HARD;
	local_30[10] = TEXTURE_WALL_F_MEDIUM;
	local_30[11] = TEXTURE_WALL_F_LOOSE;
	local_68[0] = TEXTURE_WALL_R_IMMOVABLE;
	local_68[1] = TEXTURE_WALL_R_HARD;
	local_68[2] = TEXTURE_WALL_R_MEDIUM;
	local_68[3] = TEXTURE_WALL_R_LOOSE;
	local_68[4] = TEXTURE_WALL_R_SOIL;
	local_60[0] = TEXTURE_WALL_C_IMMOVABLE;
	local_60[1] = TEXTURE_WALL_C_HARD;
	local_60[2] = TEXTURE_WALL_C_MEDIUM;
	local_60[3] = TEXTURE_WALL_C_LOOSE;
	local_60[4] = TEXTURE_WALL_C_SOIL;
	local_58[0] = TEXTURE_WALL_C_IMMOVABLE;
	local_58[1] = TEXTURE_WALL_C_HARD;
	local_58[2] = TEXTURE_WALL_C_MEDIUM;
	local_58[3] = TEXTURE_WALL_C_LOOSE;
	local_58[4] = TEXTURE_WALL_C_SOIL;
	local_50[4] = TEXTURE_WALL_O_SOIL;
	local_48[4] = TEXTURE_WALL_O_SOIL;
	local_50[0] = TEXTURE_WALL_O_IMMOVABLE;
	local_50[1] = TEXTURE_WALL_O_HARD;
	local_50[2] = TEXTURE_WALL_O_MEDIUM;
	local_50[3] = TEXTURE_WALL_O_LOOSE;
	local_48[0] = TEXTURE_WALL_O_IMMOVABLE;
	local_48[1] = TEXTURE_WALL_O_HARD;
	local_48[2] = TEXTURE_WALL_O_MEDIUM;
	local_48[3] = TEXTURE_WALL_O_LOOSE;
	local_40[0] = TEXTURE_WALL_GAP;
	local_40[1] = TEXTURE_WALL_GAP;
	local_40[2] = TEXTURE_WALL_GAP;
	local_40[3] = TEXTURE_WALL_GAP;
	local_40[4] = TEXTURE_WALL_GAP;
	uVar2 = 0;
	do {
		SVar1 = local_20[uVar2];
		uVar3 = 0;
		do {
			SurfaceMap_AddTextureCoordMapping(surfMap,SVar1,local_30[uVar3]);
			uVar3 = uVar3 + 1;
		} while (uVar3 < 0x10);
		uVar3 = 0;
		do {
			SurfaceMap_AddTextureCoordMapping(surfMap,SVar1,local_68[uVar3]);
			uVar3 = uVar3 + 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			SurfaceMap_AddTextureCoordMapping(surfMap,SVar1,local_60[uVar3]);
			uVar3 = uVar3 + 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			SurfaceMap_AddTextureCoordMapping(surfMap,SVar1,local_58[uVar3]);
			uVar3 = uVar3 + 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			SurfaceMap_AddTextureCoordMapping(surfMap,SVar1,local_50[uVar3]);
			uVar3 = uVar3 + 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			SurfaceMap_AddTextureCoordMapping(surfMap,SVar1,local_48[uVar3]);
			uVar3 = uVar3 + 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			SurfaceMap_AddTextureCoordMapping(surfMap,SVar1,local_40[uVar3]);
			uVar3 = uVar3 + 1;
		} while (uVar3 < 5);
		uVar2 = uVar2 + 1;
	} while (uVar2 < 0x1f);
	uVar2 = 0;
	do {
		SVar1 = local_38[uVar2];
		uVar3 = 0;
		do {
			SurfaceMap_AddTextureCoordMapping(surfMap,SVar1,local_30[uVar3]);
			uVar3 = uVar3 + 1;
		} while (uVar3 < 0x10);
		uVar3 = 0;
		do {
			SurfaceMap_AddTextureCoordMapping(surfMap,SVar1,local_68[uVar3]);
			uVar3 = uVar3 + 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			SurfaceMap_AddTextureCoordMapping(surfMap,SVar1,local_60[uVar3]);
			uVar3 = uVar3 + 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			SurfaceMap_AddTextureCoordMapping(surfMap,SVar1,local_58[uVar3]);
			uVar3 = uVar3 + 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			SurfaceMap_AddTextureCoordMapping(surfMap,SVar1,local_50[uVar3]);
			uVar3 = uVar3 + 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			SurfaceMap_AddTextureCoordMapping(surfMap,SVar1,local_48[uVar3]);
			uVar3 = uVar3 + 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			SurfaceMap_AddTextureCoordMapping(surfMap,SVar1,local_40[uVar3]);
			uVar3 = uVar3 + 1;
		} while (uVar3 < 5);
		uVar2 = uVar2 + 1;
	} while (uVar2 < 6);
	return;
}



BOOL __cdecl lego::main::Main_LoadTextureType(LevelData *level,char *keyTexturePath)
{
	SurfaceMap *surfMap;
	CFGProperty *prop;
	char *pcVar1;
	int iVar2;
	int iVar3;
	char *pcVar4;
	SurfaceTextureGrid *field2c;
	BOOL BVar5;
	BOOL result;
	
	prop = globals::g_Game.LegoCfgRoot;
	result = 0;
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,keyTexturePath,"surftextwidth",0);
	pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
	if (pcVar1 == (char *)0x0) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,keyTexturePath,"surftextwidth",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
	}
	iVar2 = std::atoi(pcVar1);
	if (iVar2 != 0) {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,keyTexturePath,"surftextheight",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == (char *)0x0) {
			pcVar1 = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,keyTexturePath,"surftextheight",0);
			pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		}
		iVar3 = std::atoi(pcVar1);
		if (iVar3 != 0) {
			surfMap = level->surfaceMap;
			(level->surfTextSize).width = iVar2;
			(level->surfTextSize).height = iVar3;
			game::SurfaceMap_InitTextureCoords(surfMap);
			game::SurfaceMap_FUN_0044eb40(level->surfaceMap);
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,keyTexturePath,"meshbasename",0);
			pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
			if (pcVar1 != (char *)0x0) {
				pcVar4 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,keyTexturePath,"texturebasename",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 != (char *)0x0) {
					field2c = game::Level_LoadTextureBaseName
															(pcVar4,(level->surfTextSize).width,(level->surfTextSize).height);
					level->surfTextGrid = field2c;
					if (field2c != (SurfaceTextureGrid *)0x0) {
						game::SurfaceMap_SetField_2c(level->surfaceMap,field2c);
						BVar5 = game::Level_Load_FUN_0042b260(level,pcVar1);
						if (BVar5 != 0) {
							pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,keyTexturePath,"rooftexture",0)
							;
							pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
							if (pcVar1 != (char *)0x0) {
								BVar5 = Main_LoadRoofTexture(pcVar1);
								if (BVar5 != 0) {
									result = 1;
								}
							}
						}
					}
				}
			}
		}
	}
	return result;
}



BOOL __cdecl lego::game::Level_LoadPredugMap(LevelData *level,char *filename,int modifier)
{
	int *piVar1;
	LevelBlockFlags1 *pLVar2;
	int iVar3;
	uint uVar4;
	char *pcVar5;
	int *piVar6;
	int iVar7;
	uint y;
	int iVar8;
	char *x;
	int local_58;
	uint local_54;
	Point2I local_50;
	int local_48 [5];
	undefined4 local_34;
	undefined4 local_30;
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if ((filename != (char *)0x0) &&
		 (uVar4 = lego::file::File_LoadBinaryHandle(filename,(uint *)0x0), uVar4 != 0xffffffff)) {
		local_54 = uVar4;
		MapShared_GetDimensions(uVar4,(int *)&filename,&local_58);
		if ((filename == (char *)(level->dimensions).width) && (local_58 == (level->dimensions).height))
		{
			y = 1;
			pcVar5 = filename;
			iVar8 = local_58;
			if (local_58 != 1 && local_58 != 2) {
				do {
					x = (char *)0x1;
					if (pcVar5 != (char *)0x1 && pcVar5 != (char *)0x2) {
						do {
							uVar4 = MapShared_GetBlock(local_54,(int)x,y);
							iVar8 = uVar4 - modifier;
							if ((iVar8 == 1) || (iVar8 == 3)) {
								Level_DestroyWall(level,(int)x,y,1);
								local_48[0] = -1;
								local_48[1] = 0xffffffff;
								local_48[3] = 0xffffffff;
								local_34 = 0xffffffff;
								local_18 = 0xffffffff;
								local_10 = 0xffffffff;
								local_8 = 0;
								local_48[2] = 0;
								local_48[4] = 1;
								local_30 = 1;
								local_2c = 0;
								local_28 = 1;
								local_24 = 1;
								local_20 = 0;
								local_1c = 1;
								local_14 = 1;
								local_c = 0;
								local_4 = 0;
								piVar6 = local_48;
								iVar7 = 9;
								do {
									piVar1 = piVar6 + 1;
									iVar3 = *piVar6;
									piVar6 = piVar6 + 2;
									pLVar2 = &level->blocks
														[(int)(x + iVar3 + (*piVar1 + y) * (level->dimensions).width)].flags1;
									iVar7 = iVar7 + -1;
									*pLVar2 = *pLVar2 | BLOCK1_EXPOSED;
								} while (iVar7 != 0);
							}
							else {
								if ((iVar8 == 2) || (iVar8 == 4)) {
									level->blocks[(int)(x + y * (level->dimensions).width)].flags1 =
											 level->blocks[(int)(x + y * (level->dimensions).width)].flags1 |
											 BLOCK1_HIDDEN;
								}
							}
							if (iVar8 == 3) {
								level->blocks[(int)(x + y * (level->dimensions).width)].flags2 =
										 level->blocks[(int)(x + y * (level->dimensions).width)].flags2 |
										 BLOCK2_SLUGHOLE_EXPOSED;
								local_50.x = (int)x;
								local_50.y = y;
								Level_RegisterSlimySlugHole(&local_50);
							}
							if (iVar8 == 4) {
								level->blocks[(int)(x + y * (level->dimensions).width)].flags2 =
										 level->blocks[(int)(x + y * (level->dimensions).width)].flags2 |
										 BLOCK2_SLUGHOLE_HIDDEN;
							}
							x = x + 1;
							pcVar5 = filename;
							iVar8 = local_58;
						} while (x < filename + -1);
					}
					y = y + 1;
					uVar4 = local_54;
				} while (y < iVar8 - 1U);
			}
			lego::file::Mem_FreeHandle(uVar4);
			return 1;
		}
		lego::file::Mem_FreeHandle(uVar4);
	}
	return 0;
}



BOOL __cdecl lego::game::Level_LoadErodeMap(LevelData *level,char *filename)
{
	bool bVar1;
	short sVar2;
	uint uVar3;
	char *pcVar4;
	uint uVar5;
	char *x;
	uint y;
	uint local_10;
	uint local_c;
	Point2I local_8;
	
	if ((filename != (char *)0x0) &&
		 (uVar3 = lego::file::File_LoadBinaryHandle(filename,(uint *)0x0), uVar3 != 0xffffffff)) {
		local_c = uVar3;
		MapShared_GetDimensions(uVar3,(int *)&filename,(int *)&local_10);
		if ((filename == (char *)(level->dimensions).width) && (local_10 == (level->dimensions).height))
		{
			y = 0;
			pcVar4 = filename;
			uVar5 = local_10;
			if (local_10 != 0) {
				do {
					x = (char *)0x0;
					if (pcVar4 != (char *)0x0) {
						do {
							local_8.x = (int)x;
							local_8.y = y;
							uVar3 = MapShared_GetBlock(local_c,(int)x,y);
							bVar1 = false;
							if ((uVar3 == 0) || ((uVar3 & 1) != 0)) {
								uVar3 = uVar3 + 1;
							}
							else {
								bVar1 = true;
							}
							level->blocks[(int)(x + y * (level->dimensions).width)].erodeSpeed =
									 (ErodeType)(uVar3 >> 1);
							if (bVar1) {
								sVar2 = math::Maths_Rand();
								uVar3 = (int)sVar2 >> 0x1f;
								FUN_0040e940(&local_8,(((int)sVar2 ^ uVar3) - uVar3 & 3 ^ uVar3) - uVar3);
							}
							x = x + 1;
							pcVar4 = filename;
							uVar5 = local_10;
						} while (x < filename);
					}
					y = y + 1;
					uVar3 = local_c;
				} while (y < uVar5);
			}
			lego::file::Mem_FreeHandle(uVar3);
			return 1;
		}
		lego::file::Mem_FreeHandle(uVar3);
	}
	return 0;
}



BOOL __cdecl lego::game::Level_LoadAIMap(LevelData *level,char *filename)
{
	uint sharedIndex;
	uint uVar1;
	char *pcVar2;
	char *x;
	uint y;
	uint local_4;
	
	if ((filename != (char *)0x0) &&
		 (sharedIndex = lego::file::File_LoadBinaryHandle(filename,(uint *)0x0),
		 sharedIndex != 0xffffffff)) {
		MapShared_GetDimensions(sharedIndex,(int *)&filename,(int *)&local_4);
		if ((filename == (char *)(level->dimensions).width) && (local_4 == (level->dimensions).height))
		{
			y = 0;
			pcVar2 = filename;
			uVar1 = local_4;
			if (local_4 != 0) {
				do {
					x = (char *)0x0;
					if (pcVar2 != (char *)0x0) {
						do {
							uVar1 = MapShared_GetBlock(sharedIndex,(int)x,y);
							pcVar2 = x + y * (level->dimensions).width;
							x = x + 1;
							level->blocks[(int)pcVar2].aiNode = (byte)uVar1;
							pcVar2 = filename;
							uVar1 = local_4;
						} while (x < filename);
					}
					y = y + 1;
				} while (y < uVar1);
			}
			lego::file::Mem_FreeHandle(sharedIndex);
			return 1;
		}
		lego::file::Mem_FreeHandle(sharedIndex);
	}
	return 0;
}



BOOL __cdecl lego::game::Level_LoadEmergeMap(LevelData *level,char *filename)
{
	LevelBlockFlags2 *pLVar1;
	uint uVar2;
	uint uVar3;
	void *pvVar4;
	int iVar5;
	char *pcVar6;
	uint uVar7;
	uint uVar8;
	undefined4 *puVar9;
	uint local_c;
	char *local_8;
	uint local_4;
	
	if (filename != (char *)0x0) {
		uVar2 = lego::file::File_LoadBinaryHandle(filename,(uint *)0x0);
		local_4 = uVar2;
		if (((uVar2 != 0xffffffff) &&
				(MapShared_GetDimensions(uVar2,(int *)&local_c,(int *)&local_8),
				local_c == (level->dimensions).width)) && (local_8 == (char *)(level->dimensions).height)) {
			filename = (char *)0x0;
			uVar3 = local_c;
			pcVar6 = local_8;
			if (local_8 != (char *)0x0) {
				do {
					uVar2 = 0;
					if (uVar3 != 0) {
						do {
							uVar3 = MapShared_GetBlock(local_4,uVar2,(int)filename);
							if (uVar3 != 0) {
								uVar7 = (uVar3 - 1) % 6;
								uVar8 = (uVar3 - 1) / 6;
								uVar3 = uVar8 + 1;
								if (level->count_c < uVar3) {
									if (level->ptrtable_8 == (void *)0x0) {
										pvVar4 = std::malloc(uVar3 * 0x4c);
									}
									else {
										pvVar4 = std::realloc(level->ptrtable_8,uVar3 * 0x4c);
									}
									level->ptrtable_8 = pvVar4;
									puVar9 = (undefined4 *)((int)level->ptrtable_8 + level->count_c * 0x4c);
									for (uVar3 = ((uVar8 - level->count_c) + 1) * 0x13 & 0x3fffffff; uVar3 != 0;
											uVar3 = uVar3 - 1) {
										*puVar9 = 0;
										puVar9 = puVar9 + 1;
									}
									for (iVar5 = 0; iVar5 != 0; iVar5 = iVar5 + -1) {
										*(undefined *)puVar9 = 0;
										puVar9 = (undefined4 *)((int)puVar9 + 1);
									}
									level->count_c = uVar8 + 1;
								}
								if (uVar7 == 0) {
									iVar5 = (int)filename * (level->dimensions).width + uVar2;
									level->blocks[iVar5].flags2 = level->blocks[iVar5].flags2 | BLOCK2_EMERGE_TRIGGER;
									*(uint *)(uVar8 * 0x4c + 4 + (int)level->ptrtable_8) = uVar2;
									*(char **)(uVar8 * 0x4c + 8 + (int)level->ptrtable_8) = filename;
								}
								else {
									pLVar1 = &level->blocks[(int)filename * (level->dimensions).width + uVar2].flags2;
									*pLVar1 = *pLVar1 | BLOCK2_EMERGE_POINT;
									iVar5 = uVar8 * 0x4c;
									*(uint *)(iVar5 + uVar7 * 0xc + 4 + (int)level->ptrtable_8) = uVar2;
									*(char **)(uVar7 * 0xc + iVar5 + 8 + (int)level->ptrtable_8) = filename;
									*(undefined4 *)(iVar5 + (uVar7 + 1) * 0xc + (int)level->ptrtable_8) = 1;
								}
							}
							uVar2 = uVar2 + 1;
							uVar3 = local_c;
							pcVar6 = local_8;
						} while (uVar2 < local_c);
					}
					filename = filename + 1;
					uVar2 = local_4;
				} while (filename < pcVar6);
			}
			lego::file::Mem_FreeHandle(uVar2);
			return 1;
		}
		lego::file::Mem_FreeHandle(uVar2);
	}
	return 0;
}



BOOL __cdecl
lego::game::Level_UnkEmerge_FUN_0042c260
					(LevelData *level,Point2I *in_position,undefined4 *out_unkPosition)
{
	int iVar1;
	uint *puVar2;
	int iVar3;
	int iVar4;
	uint uVar5;
	uint local_4;
	
	iVar4 = 0;
	local_4 = 0;
	if (level->count_c == 0) {
		return 0;
	}
	do {
		iVar1 = (int)level->ptrtable_8 + iVar4;
		if (((in_position->x == *(int *)(iVar1 + 4)) && (in_position->y == *(int *)(iVar1 + 8))) &&
			 ((ushort)((ushort)(*(float *)(iVar1 + 0xc) < 0.0) << 8 |
								(ushort)(*(float *)(iVar1 + 0xc) == 0.0) << 0xe) != 0)) {
			iVar1 = 0;
			uVar5 = 0;
			do {
				if (*(int *)(iVar4 + uVar5 + 0x18 + (int)level->ptrtable_8) != 0) {
					iVar3 = iVar4 + uVar5 + (int)level->ptrtable_8;
					puVar2 = FUN_0043b1f0((int **)(globals::g_Game.RockMonsterData_TABLE +
																				level->EmergeCreature),4.203895e-45,level->EmergeCreature,
																*(uint *)(iVar3 + 0x10),*(uint *)(iVar3 + 0x14));
					if (puVar2 != (uint *)0x0) {
						iVar4 = local_4 * 0x4c;
						*(float *)(iVar4 + 0xc + (int)level->ptrtable_8) = level->EmergeTimeOut;
						if (out_unkPosition != (undefined4 *)0x0) {
							*out_unkPosition =
									 *(undefined4 *)(iVar1 * 0xc + iVar4 + 0x10 + (int)level->ptrtable_8);
							out_unkPosition[1] =
									 *(undefined4 *)(iVar1 * 0xc + iVar4 + 0x14 + (int)level->ptrtable_8);
						}
						return 1;
					}
				}
				uVar5 = uVar5 + 0xc;
				iVar1 = iVar1 + 1;
			} while (uVar5 < 0x3c);
		}
		local_4 = local_4 + 1;
		iVar4 = iVar4 + 0x4c;
	} while (local_4 < level->count_c);
	return 0;
}



void __cdecl lego::game::Level_FUN_0042c370(LevelData *level,float elapsedAbs)
{
	float *pfVar1;
	float fVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 0;
	if (level->count_c != 0) {
		iVar3 = 0;
		do {
			fVar2 = *(float *)((int)level->ptrtable_8 + iVar3 + 0xc);
			pfVar1 = (float *)((int)level->ptrtable_8 + iVar3 + 0xc);
			if ((ushort)((ushort)(fVar2 < 0.0) << 8 | (ushort)(fVar2 == 0.0) << 0xe) == 0) {
				*pfVar1 = *pfVar1 - elapsedAbs;
			}
			uVar4 = uVar4 + 1;
			iVar3 = iVar3 + 0x4c;
		} while (uVar4 < level->count_c);
	}
	return;
}



BOOL __cdecl lego::game::Level_LoadTerrainMap(LevelData *level,char *filename,int modifier)
{
	TerrainType TVar1;
	uint sharedIndex;
	uint uVar2;
	int iVar3;
	char *pcVar4;
	uint y;
	char *x;
	uint local_c;
	Point2I local_8;
	
	sharedIndex = lego::file::File_LoadBinaryHandle(filename,(uint *)0x0);
	if (sharedIndex != 0xffffffff) {
		MapShared_GetDimensions(sharedIndex,(int *)&filename,(int *)&local_c);
		if ((filename == (char *)(level->dimensions).width) && (local_c == (level->dimensions).height))
		{
			y = 0;
			pcVar4 = filename;
			uVar2 = local_c;
			if (local_c != 0) {
				do {
					x = (char *)0x0;
					if (pcVar4 != (char *)0x0) {
						do {
							uVar2 = MapShared_GetBlock(sharedIndex,(int)x,y);
							iVar3 = uVar2 - modifier;
										// Soil SurfaceType was removed, change to Dirt
							if (iVar3 == 5) {
								iVar3 = 4;
							}
							level->blocks[(int)(x + y * (level->dimensions).width)].terrain = (TerrainType)iVar3;
							TVar1 = level->blocks[(int)(x + y * (level->dimensions).width)].terrain;
							if (TVar1 == TERRAIN_LAVA) {
								level->blocks[(int)(x + y * (level->dimensions).width)].field_7 = 4;
							}
							else {
								if (TVar1 == TERRAIN_RECHARGESEAM) {
									local_8.x = (int)x;
									local_8.y = y;
									Level_RegisterRechargeSeam(&local_8);
									res::Res_Unk_RechargeSparkle(level,&local_8,1);
								}
							}
							x = x + 1;
							pcVar4 = filename;
							uVar2 = local_c;
						} while (x < filename);
					}
					y = y + 1;
				} while (y < uVar2);
			}
			lego::file::Mem_FreeHandle(sharedIndex);
			return 1;
		}
		lego::file::Mem_FreeHandle(sharedIndex);
	}
	return 0;
}



BOOL __cdecl
lego::game::Level_GetBlockCryOre
					(Point2I *position,int *out_crystal,int *out_ore,int *out_crystalAlt,int *out_oreAlt)
{
	int iVar1;
	uint uVar2;
	uint uVar3;
	int CRYORE_COUNTS [5];
	
	uVar3 = (uint)(globals::g_Game.level)->blocks
								[position->y * ((globals::g_Game.level)->dimensions).width + position->x].cryOre;
	CRYORE_COUNTS[0] = 1;
	uVar2 = uVar3 - 1;
	*out_oreAlt = 0;
	*out_crystalAlt = 0;
	*out_ore = 0;
	CRYORE_COUNTS[1] = 3;
	CRYORE_COUNTS[2] = 5;
	CRYORE_COUNTS[3] = 10;
	CRYORE_COUNTS[4] = 0x19;
	*out_crystal = 0;
	if (uVar3 != 0) {
		iVar1 = *(int *)((int)CRYORE_COUNTS + (uVar2 & 0xfffffffc));
		switch(uVar2 & 3) {
		case 0:
			*out_crystal = iVar1;
			return 1;
		case 1:
			*out_crystalAlt = iVar1;
			return 1;
		case 2:
			*out_ore = iVar1;
			return 1;
		case 3:
			*out_oreAlt = iVar1;
		}
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::game::Level_LoadCryOreMap(LevelData *level,char *filename,char modifier)
{
	uint sharedIndex;
	uint uVar1;
	char *pcVar2;
	char *x;
	uint y;
	uint local_4;
	
	sharedIndex = lego::file::File_LoadBinaryHandle(filename,(uint *)0x0);
	if (sharedIndex != 0xffffffff) {
		MapShared_GetDimensions(sharedIndex,(int *)&filename,(int *)&local_4);
		if ((filename == (char *)(level->dimensions).width) && (local_4 == (level->dimensions).height))
		{
			y = 0;
			pcVar2 = filename;
			uVar1 = local_4;
			if (local_4 != 0) {
				do {
					x = (char *)0x0;
					if (pcVar2 != (char *)0x0) {
						do {
							uVar1 = MapShared_GetBlock(sharedIndex,(int)x,y);
							pcVar2 = x + y * (level->dimensions).width;
							x = x + 1;
							level->blocks[(int)pcVar2].cryOre = (char)uVar1 - modifier;
							pcVar2 = filename;
							uVar1 = local_4;
						} while (x < filename);
					}
					y = y + 1;
				} while (y < uVar1);
			}
			lego::file::Mem_FreeHandle(sharedIndex);
			return 1;
		}
		lego::file::Mem_FreeHandle(sharedIndex);
	}
	return 0;
}



BOOL __cdecl lego::game::Level_LoadPathMap(LevelData *level,char *filename,int modifier)
{
	LevelBlockFlags1 *pLVar1;
	LevelBlockFlags1 LVar2;
	uint uVar3;
	BOOL BVar4;
	char *pcVar5;
	uint uVar6;
	uint y;
	int iVar7;
	char *x;
	uint local_10;
	uint local_c;
	Point2I local_8;
	
	if ((filename != (char *)0x0) &&
		 (uVar3 = lego::file::File_LoadBinaryHandle(filename,(uint *)0x0), uVar3 != 0xffffffff)) {
		local_c = uVar3;
		MapShared_GetDimensions(uVar3,(int *)&filename,(int *)&local_10);
		if ((filename == (char *)(level->dimensions).width) && (local_10 == (level->dimensions).height))
		{
			y = 0;
			pcVar5 = filename;
			uVar6 = local_10;
			if (local_10 != 0) {
				do {
					x = (char *)0x0;
					if (pcVar5 != (char *)0x0) {
						do {
							local_8.x = (int)x;
							local_8.y = y;
							uVar3 = MapShared_GetBlock(local_c,(int)x,y);
							pLVar1 = &level->blocks[(int)(x + y * (level->dimensions).width)].flags1;
							LVar2 = *pLVar1;
							if ((LVar2 & BLOCK1_UNK_8) != BLOCK1_NONE) {
								if (uVar3 - modifier == 2) {
									*pLVar1 = LVar2 | BLOCK1_POWERPATH;
								}
								else {
									if ((((uVar3 - modifier == 1) &&
											 (((globals::g_Game.level)->blocks
												 [(int)(local_8.x + ((globals::g_Game.level)->dimensions).width * local_8.y)
												 ].flags1 & BLOCK1_UNK_400) == BLOCK1_NONE)) &&
											((*(byte *)&(globals::g_Game.level)->blocks
																	[(int)(local_8.x +
																				((globals::g_Game.level)->dimensions).width * local_8.y)].
																	flags2 & 4) == 0)) &&
										 ((((globals::g_Game.level)->blocks
												[(int)(local_8.x + ((globals::g_Game.level)->dimensions).width * local_8.y)]
												.flags1 & BLOCK1_UNK_8000) == BLOCK1_NONE &&
											(BVar4 = FUN_00408fd0(&local_8), BVar4 == 0)))) {
										(globals::g_Game.level)->blocks
										[(int)(char *)(local_8.x +
																	((globals::g_Game.level)->dimensions).width * local_8.y)].flags1 =
												 (globals::g_Game.level)->blocks
												 [(int)(char *)(local_8.x +
																			 ((globals::g_Game.level)->dimensions).width * local_8.y)].
												 flags1 & ~BLOCK1_UNK_200000;
										(globals::g_Game.level)->blocks
										[(int)(char *)(local_8.x +
																	((globals::g_Game.level)->dimensions).width * local_8.y)].flags1 =
												 (globals::g_Game.level)->blocks
												 [(int)(char *)(local_8.x +
																			 ((globals::g_Game.level)->dimensions).width * local_8.y)].
												 flags1 & ~BLOCK1_POWERPATH;
										(globals::g_Game.level)->blocks
										[(int)(char *)(local_8.x +
																	((globals::g_Game.level)->dimensions).width * local_8.y)].flags1 =
												 (globals::g_Game.level)->blocks
												 [(int)(char *)(local_8.x +
																			 ((globals::g_Game.level)->dimensions).width * local_8.y)].
												 flags1 & ~BLOCK1_UNK_40000000;
										Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
										FUN_00402970(&local_8);
										util::logf_removed((char *)&local_8);
										iVar7 = 4;
										do {
											ai::AITask_DoClear_AtPosition(&local_8,MESSAGE_CLEARINITIAL_COMPLETE);
											iVar7 = iVar7 + -1;
										} while (iVar7 != 0);
										(globals::g_Game.level)->blocks
										[(int)(char *)(local_8.x +
																	((globals::g_Game.level)->dimensions).width * local_8.y)].flags1 =
												 (globals::g_Game.level)->blocks
												 [(int)(char *)(local_8.x +
																			 ((globals::g_Game.level)->dimensions).width * local_8.y)].
												 flags1 | BLOCK1_RUBBLE_FULL;
									}
								}
							}
							x = x + 1;
							pcVar5 = filename;
							uVar6 = local_10;
						} while (x < filename);
					}
					y = y + 1;
					uVar3 = local_c;
				} while (y < uVar6);
			}
			lego::file::Mem_FreeHandle(uVar3);
			return 1;
		}
		lego::file::Mem_FreeHandle(uVar3);
	}
	return 0;
}



BOOL __cdecl lego::game::Level_LoadFallinMap(LevelData *level,char *filename)
{
	uint sharedIndex_00;
	float fVar1;
	char *pcVar2;
	uint uVar3;
	uint y;
	char *x;
	uint local_10;
	uint sharedIndex;
	uint local_8;
	undefined4 uStack4;
	
	globals::g_Game.hasFallins = 0;
	if ((filename != (char *)0x0) &&
		 (sharedIndex_00 = lego::file::File_LoadBinaryHandle(filename,(uint *)0x0),
		 sharedIndex_00 != 0xffffffff)) {
		sharedIndex = sharedIndex_00;
		MapShared_GetDimensions(sharedIndex_00,(int *)&filename,(int *)&local_10);
		if ((filename == (char *)(level->dimensions).width) && (local_10 == (level->dimensions).height))
		{
			y = 0;
			pcVar2 = filename;
			uVar3 = local_10;
			if (local_10 != 0) {
				do {
					x = (char *)0x0;
					if (pcVar2 != (char *)0x0) {
						do {
							fVar1 = (float)MapShared_GetBlock(sharedIndex,(int)x,y);
							level->blocks[(int)(x + y * (level->dimensions).width)].fallinIntensity = 0.0;
							if (fVar1 != 0.0) {
								level->blocks[(int)(x + y * (level->dimensions).width)].fallinIntensity = fVar1;
								local_8 = (uint)(int)level->blocks[(int)(x + y * (level->dimensions).width)].
																		 randomness %
													((int)fVar1 * globals::g_Game.FallinMultiplier * 0x19);
								uStack4 = 0;
								level->blocks[(int)(x + y * (level->dimensions).width)].fallinTimer =
										 (float)(ulonglong)local_8;
								level->blocks[(int)(x + y * (level->dimensions).width)].fallinUpper = 0;
								if (4 < (uint)fVar1) {
									level->blocks[(int)(x + y * (level->dimensions).width)].fallinIntensity =
											 (float)((int)fVar1 - 4);
									level->blocks[(int)(x + y * (level->dimensions).width)].fallinUpper = 1;
								}
							}
							x = x + 1;
							pcVar2 = filename;
							uVar3 = local_10;
						} while (x < filename);
					}
					y = y + 1;
					sharedIndex_00 = sharedIndex;
				} while (y < uVar3);
			}
			globals::g_Game.hasFallins = 1;
			lego::file::Mem_FreeHandle(sharedIndex_00);
			return 1;
		}
		lego::file::Mem_FreeHandle(sharedIndex_00);
	}
	return 0;
}



void __cdecl lego::game::Game_UpdateFallins(float elapsedGame)
{
	uint uVar1;
	uint uVar2;
	LevelData *level;
	int iVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	Point2I position;
	LevelBlock *block;
	
	level = GetLevel();
	if ((((globals::g_Game.hasFallins != 0) && (uVar1 = (level->dimensions).width, uVar1 != 0)) &&
			(uVar2 = (level->dimensions).height, uVar2 != 0)) && (uVar5 = 0, uVar2 != 0)) {
		do {
			uVar6 = 0;
			if (uVar1 != 0) {
				do {
					block = level->blocks + uVar5 * (level->dimensions).width + uVar6;
					if (block->fallinIntensity != 0.0) {
						block->fallinTimer = elapsedGame + block->fallinTimer;
						iVar3 = uVar5 * (level->dimensions).width + uVar6;
						block = level->blocks + iVar3;
						if ((float)(ulonglong)
											 ((int)level->blocks[iVar3].fallinIntensity * globals::g_Game.FallinMultiplier
											 * 0x19) < block->fallinTimer) {
							block->fallinTimer = 0.0;
							position.x = uVar6;
							position.y = uVar5;
							BVar4 = FUN_0040f0c0(&position,
																	 level->blocks[uVar5 * (level->dimensions).width + uVar6].
																	 fallinUpper);
							if (BVar4 != 0) {
								front::Info_FUN_00419ab0(INFO_LANDSLIDE,(char *)0x0,(LiveObject *)0x0,&position);
							}
						}
					}
					uVar6 = uVar6 + 1;
				} while (uVar6 < uVar1);
			}
			uVar5 = uVar5 + 1;
		} while (uVar5 < uVar2);
	}
	return;
}



BOOL __cdecl lego::game::Level_LoadBlockPointersMap(LevelData *level,char *filename,int modifier)
{
	uint sharedIndex;
	uint uVar1;
	char *pcVar2;
	char *x;
	uint y;
	uint local_4;
	
	if ((filename != (char *)0x0) &&
		 (sharedIndex = lego::file::File_LoadBinaryHandle(filename,(uint *)0x0),
		 sharedIndex != 0xffffffff)) {
		MapShared_GetDimensions(sharedIndex,(int *)&filename,(int *)&local_4);
		if ((filename == (char *)(level->dimensions).width) && (local_4 == (level->dimensions).height))
		{
			y = 0;
			pcVar2 = filename;
			uVar1 = local_4;
			if (local_4 != 0) {
				do {
					x = (char *)0x0;
					if (pcVar2 != (char *)0x0) {
						do {
							uVar1 = MapShared_GetBlock(sharedIndex,(int)x,y);
							pcVar2 = x + y * (level->dimensions).width;
							x = x + 1;
							level->blocks[(int)pcVar2].blockpointer = (char)uVar1 - (char)modifier;
							pcVar2 = filename;
							uVar1 = local_4;
						} while (x < filename);
					}
					y = y + 1;
				} while (y < uVar1);
			}
			lego::file::Mem_FreeHandle(sharedIndex);
			return 1;
		}
		lego::file::Mem_FreeHandle(sharedIndex);
	}
	return 0;
}



UpgradeData * __cdecl lego::game::Game_GetUpgradeData(char *upgradeName)
{
	int iVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (globals::g_Game.UpgradeTypes_COUNT == 0) {
		return (UpgradeData *)0x0;
	}
	do {
		iVar1 = std::_stricmp(upgradeName,globals::g_Game.UpgradeTypes_TABLE[uVar2]);
		if (iVar1 == 0) {
			return globals::g_Game.UpgradeData_TABLE + uVar2;
		}
		uVar2 = uVar2 + 1;
	} while (uVar2 < globals::g_Game.UpgradeTypes_COUNT);
	return (UpgradeData *)0x0;
}



BOOL __cdecl lego::main::Boot_Load_VehicleTypes(void)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	undefined4 *puVar8;
	undefined4 *puVar9;
	int local_4;
	
	iVar7 = 0;
	globals::g_Game.VehicleTypes_COUNT = 0;
	local_4 = 0;
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"VehicleTypes",0);
	for (pCVar3 = cfg::CFG_GetChildren(globals::g_Game.LegoCfgRoot,pcVar2);
			pCVar3 != (CFGProperty *)0x0; pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		globals::g_Game.VehicleTypes_COUNT = globals::g_Game.VehicleTypes_COUNT + 1;
	}
	if ((globals::g_Game.VehicleTypes_COUNT != 0) &&
		 (globals::g_Game.VehicleData_TABLE =
					 (VehicleData *)std::malloc(globals::g_Game.VehicleTypes_COUNT * 0x1ec),
		 globals::g_Game.VehicleData_TABLE != (VehicleData *)0x0)) {
		globals::g_Game.VehicleTypes_TABLE =
				 (char **)std::malloc(globals::g_Game.VehicleTypes_COUNT * 4);
		if (globals::g_Game.VehicleTypes_TABLE != (char **)0x0) {
			pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"VehicleTypes",0);
			pCVar3 = cfg::CFG_GetChildren(globals::g_Game.LegoCfgRoot,pcVar2);
			while ((pCVar3 != (CFGProperty *)0x0 &&
						 (BVar4 = res::Res_LoadAEFileVehicle
																((VehicleData *)
																 ((int)(globals::g_Game.VehicleData_TABLE)->WheelMeshes +
																 iVar7 + -0x10),local_4,globals::g_Game.resRoot,pCVar3->value,
																 globals::g_Game.CfgRootName), BVar4 != 0))) {
				res::Vehicle_FUN_0046d580
									((VehicleData *)
									 ((int)(globals::g_Game.VehicleData_TABLE)->WheelMeshes + iVar7 + -0x10),1);
				uVar5 = 0xffffffff;
				pcVar2 = pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 = uVar5 - 1;
					cVar1 = *pcVar2;
					pcVar2 = pcVar2 + 1;
				} while (cVar1 != '\0');
				pcVar2 = (char *)std::malloc(~uVar5);
				iVar7 = iVar7 + 0x1ec;
				globals::g_Game.VehicleTypes_TABLE[local_4] = pcVar2;
				uVar5 = 0xffffffff;
				puVar8 = (undefined4 *)pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 = uVar5 - 1;
					cVar1 = *(char *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				} while (cVar1 != '\0');
				puVar8 = (undefined4 *)pCVar3->key;
				puVar9 = (undefined4 *)globals::g_Game.VehicleTypes_TABLE[local_4];
				for (uVar6 = ~uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
					*puVar9 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar9 = puVar9 + 1;
				}
				local_4 = local_4 + 1;
				for (uVar5 = ~uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
					*(undefined *)puVar9 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				pCVar3 = cfg::CFG_NextFlat(pCVar3);
			}
			if (pCVar3 == (CFGProperty *)0x0) {
				return 1;
			}
			std::free(globals::g_Game.VehicleTypes_TABLE);
		}
		std::free(globals::g_Game.VehicleData_TABLE);
	}
	return 0;
}



BOOL __cdecl lego::main::Boot_Load_MiniFigureTypes(void)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	undefined4 *puVar8;
	undefined4 *puVar9;
	int local_4;
	
	iVar7 = 0;
	globals::g_Game.MiniFigureTypes_COUNT = 0;
	local_4 = 0;
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiniFigureTypes",0);
	for (pCVar3 = cfg::CFG_GetChildren(globals::g_Game.LegoCfgRoot,pcVar2);
			pCVar3 != (CFGProperty *)0x0; pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		globals::g_Game.MiniFigureTypes_COUNT = globals::g_Game.MiniFigureTypes_COUNT + 1;
	}
	if ((globals::g_Game.MiniFigureTypes_COUNT != 0) &&
		 (globals::g_Game.MiniFigureData_TABLE =
					 (CreatureData *)std::malloc(globals::g_Game.MiniFigureTypes_COUNT * 0x74),
		 globals::g_Game.MiniFigureData_TABLE != (CreatureData *)0x0)) {
		globals::g_Game.MiniFigureTypes_TABLE =
				 (char **)std::malloc(globals::g_Game.MiniFigureTypes_COUNT * 4);
		if (globals::g_Game.MiniFigureTypes_TABLE != (char **)0x0) {
			pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"MiniFigureTypes",0);
			pCVar3 = cfg::CFG_GetChildren(globals::g_Game.LegoCfgRoot,pcVar2);
			while ((pCVar3 != (CFGProperty *)0x0 &&
						 (BVar4 = res::Res_LoadAEFileCreature
																((CreatureData *)
																 ((int)(globals::g_Game.MiniFigureData_TABLE)->cameraFramesTable_54
																 + iVar7 + -0x54),local_4,globals::g_Game.resRoot,pCVar3->value,
																 globals::g_Game.CfgRootName), BVar4 != 0))) {
				FUN_00406bc0((BasicObjectData *)
										 ((int)(globals::g_Game.MiniFigureData_TABLE)->cameraFramesTable_54 +
										 iVar7 + -0x54),1);
				uVar5 = 0xffffffff;
				pcVar2 = pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 = uVar5 - 1;
					cVar1 = *pcVar2;
					pcVar2 = pcVar2 + 1;
				} while (cVar1 != '\0');
				pcVar2 = (char *)std::malloc(~uVar5);
				iVar7 = iVar7 + 0x74;
				globals::g_Game.MiniFigureTypes_TABLE[local_4] = pcVar2;
				uVar5 = 0xffffffff;
				puVar8 = (undefined4 *)pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 = uVar5 - 1;
					cVar1 = *(char *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				} while (cVar1 != '\0');
				puVar8 = (undefined4 *)pCVar3->key;
				puVar9 = (undefined4 *)globals::g_Game.MiniFigureTypes_TABLE[local_4];
				for (uVar6 = ~uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
					*puVar9 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar9 = puVar9 + 1;
				}
				local_4 = local_4 + 1;
				for (uVar5 = ~uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
					*(undefined *)puVar9 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				pCVar3 = cfg::CFG_NextFlat(pCVar3);
			}
			if (pCVar3 == (CFGProperty *)0x0) {
				return 1;
			}
			std::free(globals::g_Game.MiniFigureTypes_TABLE);
		}
		std::free(globals::g_Game.MiniFigureData_TABLE);
	}
	return 0;
}



BOOL __cdecl lego::main::Boot_Load_RockMonsterTypes(void)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	undefined4 *puVar8;
	undefined4 *puVar9;
	int local_4;
	
	iVar7 = 0;
	globals::g_Game.RockMonsterTypes_COUNT = 0;
	local_4 = 0;
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"RockMonsterTypes",0);
	for (pCVar3 = cfg::CFG_GetChildren(globals::g_Game.LegoCfgRoot,pcVar2);
			pCVar3 != (CFGProperty *)0x0; pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		globals::g_Game.RockMonsterTypes_COUNT = globals::g_Game.RockMonsterTypes_COUNT + 1;
	}
	if ((globals::g_Game.RockMonsterTypes_COUNT != 0) &&
		 (globals::g_Game.RockMonsterData_TABLE =
					 (CreatureData *)std::malloc(globals::g_Game.RockMonsterTypes_COUNT * 0x74),
		 globals::g_Game.RockMonsterData_TABLE != (CreatureData *)0x0)) {
		globals::g_Game.RockMonsterTypes_TABLE =
				 (char **)std::malloc(globals::g_Game.RockMonsterTypes_COUNT * 4);
		if (globals::g_Game.RockMonsterTypes_TABLE != (char **)0x0) {
			pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"RockMonsterTypes",0);
			pCVar3 = cfg::CFG_GetChildren(globals::g_Game.LegoCfgRoot,pcVar2);
			while ((pCVar3 != (CFGProperty *)0x0 &&
						 (BVar4 = res::Res_LoadAEFileCreature
																((CreatureData *)
																 ((int)(globals::g_Game.RockMonsterData_TABLE)->cameraFramesTable_54
																 + iVar7 + -0x54),local_4,globals::g_Game.resRoot,pCVar3->value,
																 globals::g_Game.CfgRootName), BVar4 != 0))) {
				FUN_00406bc0((BasicObjectData *)
										 ((int)(globals::g_Game.RockMonsterData_TABLE)->cameraFramesTable_54 +
										 iVar7 + -0x54),1);
				uVar5 = 0xffffffff;
				pcVar2 = pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 = uVar5 - 1;
					cVar1 = *pcVar2;
					pcVar2 = pcVar2 + 1;
				} while (cVar1 != '\0');
				pcVar2 = (char *)std::malloc(~uVar5);
				iVar7 = iVar7 + 0x74;
				globals::g_Game.RockMonsterTypes_TABLE[local_4] = pcVar2;
				uVar5 = 0xffffffff;
				puVar8 = (undefined4 *)pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 = uVar5 - 1;
					cVar1 = *(char *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				} while (cVar1 != '\0');
				puVar8 = (undefined4 *)pCVar3->key;
				puVar9 = (undefined4 *)globals::g_Game.RockMonsterTypes_TABLE[local_4];
				for (uVar6 = ~uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
					*puVar9 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar9 = puVar9 + 1;
				}
				local_4 = local_4 + 1;
				for (uVar5 = ~uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
					*(undefined *)puVar9 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				pCVar3 = cfg::CFG_NextFlat(pCVar3);
			}
			if (pCVar3 == (CFGProperty *)0x0) {
				return 1;
			}
			std::free(globals::g_Game.RockMonsterTypes_TABLE);
		}
		std::free(globals::g_Game.RockMonsterData_TABLE);
	}
	return 0;
}



BOOL __cdecl lego::main::Boot_Load_BuildingTypes(void)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	undefined4 *puVar8;
	undefined4 *puVar9;
	int local_4;
	
	iVar7 = 0;
	globals::g_Game.BuildingTypes_COUNT = 0;
	local_4 = 0;
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"BuildingTypes",0);
	for (pCVar3 = cfg::CFG_GetChildren(globals::g_Game.LegoCfgRoot,pcVar2);
			pCVar3 != (CFGProperty *)0x0; pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		globals::g_Game.BuildingTypes_COUNT = globals::g_Game.BuildingTypes_COUNT + 1;
	}
	if ((globals::g_Game.BuildingTypes_COUNT != 0) &&
		 (globals::g_Game.BuildingData_TABLE =
					 (BuildingData *)std::malloc(globals::g_Game.BuildingTypes_COUNT * 0x14c),
		 globals::g_Game.BuildingData_TABLE != (BuildingData *)0x0)) {
		globals::g_Game.BuildingTypes_TABLE =
				 (char **)std::malloc(globals::g_Game.BuildingTypes_COUNT * 4);
		if (globals::g_Game.BuildingTypes_TABLE != (char **)0x0) {
			pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"BuildingTypes",0);
			pCVar3 = cfg::CFG_GetChildren(globals::g_Game.LegoCfgRoot,pcVar2);
			while ((pCVar3 != (CFGProperty *)0x0 &&
						 (BVar4 = res::Res_LoadAEFileBuilding
																((BuildingData *)
																 ((int)(globals::g_Game.BuildingData_TABLE)->carryFramesTable_28 +
																 iVar7 + -0x28),local_4,globals::g_Game.resRoot,pCVar3->value,
																 globals::g_Game.CfgRootName), BVar4 != 0))) {
				FUN_004085a0((BuildingData *)
										 ((int)(globals::g_Game.BuildingData_TABLE)->carryFramesTable_28 + iVar7 + -0x28
										 ),1);
				uVar5 = 0xffffffff;
				pcVar2 = pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 = uVar5 - 1;
					cVar1 = *pcVar2;
					pcVar2 = pcVar2 + 1;
				} while (cVar1 != '\0');
				pcVar2 = (char *)std::malloc(~uVar5);
				iVar7 = iVar7 + 0x14c;
				globals::g_Game.BuildingTypes_TABLE[local_4] = pcVar2;
				uVar5 = 0xffffffff;
				puVar8 = (undefined4 *)pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 = uVar5 - 1;
					cVar1 = *(char *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				} while (cVar1 != '\0');
				puVar8 = (undefined4 *)pCVar3->key;
				puVar9 = (undefined4 *)globals::g_Game.BuildingTypes_TABLE[local_4];
				for (uVar6 = ~uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
					*puVar9 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar9 = puVar9 + 1;
				}
				local_4 = local_4 + 1;
				for (uVar5 = ~uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
					*(undefined *)puVar9 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				pCVar3 = cfg::CFG_NextFlat(pCVar3);
			}
			if (pCVar3 == (CFGProperty *)0x0) {
				return 1;
			}
			std::free(globals::g_Game.BuildingTypes_TABLE);
		}
		std::free(globals::g_Game.BuildingData_TABLE);
	}
	return 0;
}



// WARNING: Removing unreachable block (ram,0x0042d503)

BOOL __cdecl lego::main::Boot_Load_UpgradeTypes(void)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	undefined4 *puVar7;
	undefined4 *puVar8;
	int local_4;
	
	iVar6 = 0;
	globals::g_Game.UpgradeTypes_COUNT = 0;
	local_4 = 0;
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"UpgradeTypes",0);
	for (pCVar3 = cfg::CFG_GetChildren(globals::g_Game.LegoCfgRoot,pcVar2);
			pCVar3 != (CFGProperty *)0x0; pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		globals::g_Game.UpgradeTypes_COUNT = globals::g_Game.UpgradeTypes_COUNT + 1;
	}
	if ((globals::g_Game.UpgradeTypes_COUNT != 0) &&
		 (globals::g_Game.UpgradeData_TABLE =
					 (UpgradeData *)std::malloc(globals::g_Game.UpgradeTypes_COUNT << 4),
		 globals::g_Game.UpgradeData_TABLE != (UpgradeData *)0x0)) {
		globals::g_Game.UpgradeTypes_TABLE =
				 (char **)std::malloc(globals::g_Game.UpgradeTypes_COUNT * 4);
		if (globals::g_Game.UpgradeTypes_TABLE != (char **)0x0) {
			pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"UpgradeTypes",0);
			pCVar3 = cfg::CFG_GetChildren(globals::g_Game.LegoCfgRoot,pcVar2);
			do {
				if (pCVar3 == (CFGProperty *)0x0) {
					return 1;
				}
				res::UnkUpgrade_Init_FUN_0046c2f0
									((UpgradeData *)((int)&(globals::g_Game.UpgradeData_TABLE)->objectIndex + iVar6),
									 local_4,globals::g_Game.resRoot,pCVar3->value);
				FUN_00406bc0((BasicObjectData *)
										 ((int)&(globals::g_Game.UpgradeData_TABLE)->objectIndex + iVar6),1);
				uVar4 = 0xffffffff;
				pcVar2 = pCVar3->key;
				do {
					if (uVar4 == 0) break;
					uVar4 = uVar4 - 1;
					cVar1 = *pcVar2;
					pcVar2 = pcVar2 + 1;
				} while (cVar1 != '\0');
				pcVar2 = (char *)std::malloc(~uVar4);
				iVar6 = iVar6 + 0x10;
				globals::g_Game.UpgradeTypes_TABLE[local_4] = pcVar2;
				uVar4 = 0xffffffff;
				puVar7 = (undefined4 *)pCVar3->key;
				do {
					if (uVar4 == 0) break;
					uVar4 = uVar4 - 1;
					cVar1 = *(char *)puVar7;
					puVar7 = (undefined4 *)((int)puVar7 + 1);
				} while (cVar1 != '\0');
				puVar7 = (undefined4 *)pCVar3->key;
				puVar8 = (undefined4 *)globals::g_Game.UpgradeTypes_TABLE[local_4];
				for (uVar5 = ~uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
					*puVar8 = *puVar7;
					puVar7 = puVar7 + 1;
					puVar8 = puVar8 + 1;
				}
				local_4 = local_4 + 1;
				for (uVar4 = ~uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
					*(undefined *)puVar8 = *(undefined *)puVar7;
					puVar7 = (undefined4 *)((int)puVar7 + 1);
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				}
				pCVar3 = cfg::CFG_NextFlat(pCVar3);
			} while( true );
		}
		std::free(globals::g_Game.UpgradeData_TABLE);
	}
	return 0;
}



void __cdecl lego::main::Main_Load_ObjectNames(CFGProperty *root)
{
	char *pcVar1;
	uint uVar2;
	uint uVar3;
	
	globals::g_Game.ObjectNames_VehicleTypes_TABLE =
			 (char **)std::malloc(globals::g_Game.VehicleTypes_COUNT * 4);
	uVar2 = 0;
	if (globals::g_Game.VehicleTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectNames",
																 globals::g_Game.VehicleTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globals::g_Game.ObjectNames_VehicleTypes_TABLE[uVar2] = pcVar1;
			uVar2 = uVar2 + 1;
		} while (uVar2 < globals::g_Game.VehicleTypes_COUNT);
	}
	globals::g_Game.ObjectNames_MiniFigureTypes_TABLE =
			 (char **)std::malloc(globals::g_Game.MiniFigureTypes_COUNT * 4);
	uVar2 = 0;
	if (globals::g_Game.MiniFigureTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectNames",
																 globals::g_Game.MiniFigureTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globals::g_Game.ObjectNames_MiniFigureTypes_TABLE[uVar2] = pcVar1;
			uVar2 = uVar2 + 1;
		} while (uVar2 < globals::g_Game.MiniFigureTypes_COUNT);
	}
	globals::g_Game.ObjectNames_RockMonsterTypes_TABLE =
			 (char **)std::malloc(globals::g_Game.RockMonsterTypes_COUNT * 4);
	uVar2 = 0;
	if (globals::g_Game.RockMonsterTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectNames",
																 globals::g_Game.RockMonsterTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globals::g_Game.ObjectNames_RockMonsterTypes_TABLE[uVar2] = pcVar1;
			uVar2 = uVar2 + 1;
		} while (uVar2 < globals::g_Game.RockMonsterTypes_COUNT);
	}
	globals::g_Game.ObjectNames_BuildingTypes_TABLE =
			 (char **)std::malloc(globals::g_Game.BuildingTypes_COUNT * 4);
	uVar2 = 0;
	if (globals::g_Game.BuildingTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectNames",
																 globals::g_Game.BuildingTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globals::g_Game.ObjectNames_BuildingTypes_TABLE[uVar2] = pcVar1;
			uVar2 = uVar2 + 1;
		} while (uVar2 < globals::g_Game.BuildingTypes_COUNT);
	}
	globals::g_Game.ObjectNames_UpgradeTypes_TABLE =
			 (char **)std::malloc(globals::g_Game.UpgradeTypes_COUNT * 4);
	uVar2 = 0;
	if (globals::g_Game.UpgradeTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectNames",
																 globals::g_Game.UpgradeTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != (char *)0x0) {
				pcVar1 = util::Util_RemoveUnderscores(pcVar1);
				globals::g_Game.ObjectNames_UpgradeTypes_TABLE[uVar2] = pcVar1;
			}
			uVar3 = uVar2 + 1;
			globals::g_Game.ObjectNames_UpgradeTypes_TABLE[uVar2] = (char *)0x0;
			uVar2 = uVar3;
		} while (uVar3 < globals::g_Game.UpgradeTypes_COUNT);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectNames","PowerCrystal",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectNames_PowerCrystal = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectNames","Ore",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectNames_Ore = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectNames","ProcessedOre",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectNames_ProcessedOre = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectNames","Dynamite",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectNames_Dynamite = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectNames","Barrier",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectNames_Barrier = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectNames","ElectricFence",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectNames_ElectricFence = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectNames","SpiderWeb",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectNames_SpiderWeb = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectNames","OohScary",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectNames_OohScary = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectNames","Path",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectNames_Path = util::Util_RemoveUnderscores(pcVar1);
	}
	return;
}



void __cdecl lego::main::Main_Load_ObjectTheNames(CFGProperty *root)
{
	char *pcVar1;
	uint uVar2;
	uint uVar3;
	
	globals::g_Game.ObjectTheNames_VehicleTypes_TABLE =
			 (char **)std::malloc(globals::g_Game.VehicleTypes_COUNT * 4);
	uVar2 = 0;
	if (globals::g_Game.VehicleTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectTheNames",
																 globals::g_Game.VehicleTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globals::g_Game.ObjectTheNames_VehicleTypes_TABLE[uVar2] = pcVar1;
			uVar2 = uVar2 + 1;
		} while (uVar2 < globals::g_Game.VehicleTypes_COUNT);
	}
	globals::g_Game.ObjectTheNames_MiniFigureTypes_TABLE =
			 (char **)std::malloc(globals::g_Game.MiniFigureTypes_COUNT * 4);
	uVar2 = 0;
	if (globals::g_Game.MiniFigureTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectTheNames",
																 globals::g_Game.MiniFigureTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globals::g_Game.ObjectTheNames_MiniFigureTypes_TABLE[uVar2] = pcVar1;
			uVar2 = uVar2 + 1;
		} while (uVar2 < globals::g_Game.MiniFigureTypes_COUNT);
	}
	globals::g_Game.ObjectTheNames_RockMonsterTypes_TABLE =
			 (char **)std::malloc(globals::g_Game.RockMonsterTypes_COUNT * 4);
	uVar2 = 0;
	if (globals::g_Game.RockMonsterTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectTheNames",
																 globals::g_Game.RockMonsterTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globals::g_Game.ObjectTheNames_RockMonsterTypes_TABLE[uVar2] = pcVar1;
			uVar2 = uVar2 + 1;
		} while (uVar2 < globals::g_Game.RockMonsterTypes_COUNT);
	}
	globals::g_Game.ObjectTheNames_BuildingTypes_TABLE =
			 (char **)std::malloc(globals::g_Game.BuildingTypes_COUNT * 4);
	uVar2 = 0;
	if (globals::g_Game.BuildingTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectTheNames",
																 globals::g_Game.BuildingTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globals::g_Game.ObjectTheNames_BuildingTypes_TABLE[uVar2] = pcVar1;
			uVar2 = uVar2 + 1;
		} while (uVar2 < globals::g_Game.BuildingTypes_COUNT);
	}
	globals::g_Game.ObjectTheNames_UpgradeTypes_TABLE =
			 (char **)std::malloc(globals::g_Game.UpgradeTypes_COUNT * 4);
	uVar2 = 0;
	if (globals::g_Game.UpgradeTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectTheNames",
																 globals::g_Game.UpgradeTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != (char *)0x0) {
				pcVar1 = util::Util_RemoveUnderscores(pcVar1);
				globals::g_Game.ObjectTheNames_UpgradeTypes_TABLE[uVar2] = pcVar1;
			}
			uVar3 = uVar2 + 1;
			globals::g_Game.ObjectTheNames_UpgradeTypes_TABLE[uVar2] = (char *)0x0;
			uVar2 = uVar3;
		} while (uVar3 < globals::g_Game.UpgradeTypes_COUNT);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectTheNames","PowerCrystal",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectTheNames_PowerCrystal = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectTheNames","Ore",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectTheNames_Ore = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectTheNames","ProcessedOre",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectTheNames_ProcessedOre = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectTheNames","Dynamite",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectTheNames_Dynamite = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectTheNames","Barrier",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectTheNames_Barrier = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectTheNames","ElectricFence",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectTheNames_ElectricFence = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectTheNames","SpiderWeb",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectTheNames_SpiderWeb = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectTheNames","OohScary",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectTheNames_OohScary = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ObjectTheNames","Path",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.ObjectTheNames_Path = util::Util_RemoveUnderscores(pcVar1);
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_0042dd70(LiveObject *liveObj,uint *param_2,BOOL param_3)
{
	Point2F *pPVar1;
	LevelData *pLVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	SurfaceMap *pSVar6;
	Point2F *pPVar7;
	uint local_8;
	uint local_4;
	
	pLVar2 = globals::g_Game.level;
	globals::g_Game.bool_98 = param_3;
	if (liveObj == (LiveObject *)0x0) {
		if (param_3 == 0) {
			pSVar6 = (globals::g_Game.level)->surfaceMap;
			pPVar1 = &globals::g_Game.pointf_88;
			pPVar7 = &globals::g_Game.pointf_88;
			uVar4 = param_2[1];
			uVar5 = *param_2;
		}
		else {
			pPVar1 = &globals::g_Game.pointf_90;
			pPVar7 = &globals::g_Game.pointf_90;
			uVar4 = param_2[1];
			uVar5 = *param_2;
			pSVar6 = (globals::g_Game.level)->surfaceMap;
		}
		SurfaceMap_FUN_0044f900(pSVar6,uVar5,uVar4,(float *)pPVar7,&pPVar1->y);
		local_8 = *param_2;
		local_4 = param_2[1];
	}
	else {
		if (param_3 == 0) {
			pPVar1 = &globals::g_Game.pointf_88;
			pPVar7 = &globals::g_Game.pointf_88;
		}
		else {
			pPVar1 = &globals::g_Game.pointf_90;
			pPVar7 = &globals::g_Game.pointf_90;
		}
		LiveObject_GetPosition(liveObj,(float *)pPVar7,&pPVar1->y);
		LiveObject_GetBlockCoordinates(liveObj,(int *)&local_8,(int *)&local_4);
	}
	uVar5 = local_4;
	uVar4 = local_8;
	iVar3 = lego::view::Camera_GetMouseScrollIndent();
	if ((int)local_8 < iVar3) {
		uVar4 = lego::view::Camera_GetMouseScrollIndent();
	}
	iVar3 = lego::view::Camera_GetMouseScrollIndent();
	if ((pLVar2->surfaceMap->smallDimensions).width - iVar3 <= (int)local_8) {
		iVar3 = lego::view::Camera_GetMouseScrollIndent();
		uVar4 = ((pLVar2->surfaceMap->smallDimensions).width - iVar3) - 1;
	}
	iVar3 = lego::view::Camera_GetMouseScrollIndent();
	if ((int)local_4 < iVar3) {
		uVar5 = lego::view::Camera_GetMouseScrollIndent();
	}
	iVar3 = lego::view::Camera_GetMouseScrollIndent();
	if ((pLVar2->surfaceMap->smallDimensions).height - iVar3 <= (int)local_4) {
		iVar3 = lego::view::Camera_GetMouseScrollIndent();
		uVar5 = ((pLVar2->surfaceMap->smallDimensions).height - iVar3) - 1;
	}
	if ((local_8 != uVar4) || (local_4 != uVar5)) {
		if (param_3 == 0) {
			pPVar1 = &globals::g_Game.pointf_88;
			pPVar7 = &globals::g_Game.pointf_88;
			pSVar6 = (globals::g_Game.level)->surfaceMap;
		}
		else {
			pPVar1 = &globals::g_Game.pointf_90;
			pPVar7 = &globals::g_Game.pointf_90;
			pSVar6 = (globals::g_Game.level)->surfaceMap;
		}
		SurfaceMap_FUN_0044f900(pSVar6,uVar4,uVar5,(float *)pPVar7,&pPVar1->y);
	}
	globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_UNK_200000;
	return;
}



void __cdecl lego::game::LiveObject_FUN_0042def0(LiveObject *liveObj)
{
	LiveObject **ppLVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (globals::g_Game.count10_320 != 0) {
		ppLVar1 = (LiveObject **)globals::g_Game.table10_2f8;
		do {
			if (liveObj == *ppLVar1) {
				*ppLVar1 = (LiveObject *)0x0;
			}
			uVar2 = uVar2 + 1;
			ppLVar1 = ppLVar1 + 1;
		} while (uVar2 < globals::g_Game.count10_320);
	}
	return;
}



BOOL __cdecl FUN_0042df20(uint param_1,int *param_2)
{
	int iVar1;
	
	if ((param_1 < lego::globals::g_Game.count10_320) &&
		 (iVar1 = lego::globals::g_Game.table10_2f8[param_1], *param_2 = iVar1, iVar1 != 0)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::main::Main_loadObjectListCFG(LevelData *level,char *filename)
{
	LiveObject *liveObj;
	CFGProperty *prop;
	char *pcVar1;
	CFGProperty *prop_00;
	CFGProperty *pCVar2;
	uint y;
	BOOL BVar3;
	LevelBlockFlags1 LVar4;
	Point2I *pPVar5;
	ObjectStatsFlags3 OVar6;
	ObjectStatsFlags1 OVar7;
	int iVar8;
	char **ppcVar9;
	LiveObject *pLVar10;
	Direction rotation;
	uint uVar11;
	undefined4 *puVar12;
	float10 fVar13;
	ulonglong uVar14;
	ulonglong uVar15;
	longlong lVar16;
	float fVar17;
	float fVar18;
	TrainedFlags trainFlags;
	uint local_9c8;
	ObjectType local_9c4;
	float local_9c0;
	float local_9bc;
	float objYpos;
	float objHeading;
	uint local_9b0;
	float objXpos;
	uint local_9a8;
	float objHealth;
	LiveObject **local_9a0;
	char *objDrivenByName;
	int local_998;
	CFGProperty *local_994;
	Container *local_990;
	char *objTypeName;
	uint local_988;
	Point2I local_984;
	char *objDrivingName;
	float local_978;
	float local_974;
	uint local_970;
	undefined4 uStack2412;
	uint local_968;
	undefined4 uStack2404;
	LiveObject *local_960 [200];
	char *local_640 [200];
	char *apcStack800 [200];
	
	local_9b0 = 0;
	local_998 = 1;
	local_9c8 = 0;
	prop = cfg::CFG_Open(filename);
	local_994 = prop;
	if (prop != (CFGProperty *)0x0) {
		puVar12 = globals::g_Game.table10_2f8;
		for (iVar8 = 10; iVar8 != 0; iVar8 = iVar8 + -1) {
			*puVar12 = 0;
			puVar12 = puVar12 + 1;
		}
		globals::g_Game.count10_320 = 0;
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,0);
		prop_00 = cfg::CFG_GetChildren(prop,pcVar1);
		if (prop_00 != (CFGProperty *)0x0) {
			local_9a0 = local_960;
			do {
				pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,prop_00->key,"type",0);
				objTypeName = cfg::CFG_CopyString(prop,pcVar1);
				if (objTypeName == (char *)0x0) break;
				pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,prop_00->key,"xpos",0);
				pCVar2 = cfg::CFG_GetProperty(prop,pcVar1);
				if (pCVar2 == (CFGProperty *)0x0) break;
				pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,prop_00->key,"ypos",0);
				pCVar2 = cfg::CFG_GetProperty(prop,pcVar1);
				if (pCVar2 == (CFGProperty *)0x0) break;
				pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,prop_00->key,"heading",0);
				pCVar2 = cfg::CFG_GetProperty(prop,pcVar1);
				if (pCVar2 == (CFGProperty *)0x0) break;
				pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,prop_00->key,"xpos",0);
				pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				if (pcVar1 == (char *)0x0) {
					pcVar1 = ____EMPTYSTR__;
				}
				else {
					pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,prop_00->key,"xpos",0);
					pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				}
				fVar13 = std::atof(pcVar1);
				objXpos = (float)fVar13;
				pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,prop_00->key,"ypos",0);
				pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				if (pcVar1 == (char *)0x0) {
					pcVar1 = ____EMPTYSTR__;
				}
				else {
					pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,prop_00->key,"ypos",0);
					pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				}
				fVar13 = std::atof(pcVar1);
				objYpos = (float)fVar13;
				pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,prop_00->key,"heading",0);
				pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				if (pcVar1 == (char *)0x0) {
					pcVar1 = ____EMPTYSTR__;
				}
				else {
					pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,prop_00->key,"heading",0);
					pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				}
				fVar13 = std::atof(pcVar1);
				objHeading = (float)fVar13;
				pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,prop_00->key,"health",0);
				pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				if (pcVar1 == (char *)0x0) {
					pcVar1 = ____EMPTYSTR__;
				}
				else {
					pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,prop_00->key,"health",0);
					pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
				}
				fVar13 = std::atof(pcVar1);
				objHealth = (float)fVar13;
				if ((float10)0.0 == fVar13) {
					objHealth = (float)&DAT_42c80000;
				}
				pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,prop_00->key,"driving",0);
				objDrivingName = cfg::CFG_CopyString(prop,pcVar1);
				apcStack800[local_9c8] = objDrivingName;
				objDrivenByName = std::_strdup(prop_00->key);
				objXpos = objXpos - 1.0;
				local_640[local_9c8] = objDrivenByName;
				objYpos = objYpos - 1.0;
				uVar14 = __ftol((float10)objXpos);
				uVar11 = (uint)uVar14;
				uVar15 = __ftol((float10)objYpos);
				y = (uint)uVar15;
				game::SurfaceMap_FUN_0044f900(level->surfaceMap,uVar11,y,&local_9c0,&local_9bc);
				uStack2404 = 0;
				uStack2412 = 0;
				objYpos = (objYpos - ((float)(uVar15 & 0xffffffff) - -0.5)) * level->BlockSize;
				local_9c0 = local_9c0 + (objXpos - ((float)(uVar14 & 0xffffffff) - -0.5)) * level->BlockSize
				;
				local_9bc = local_9bc - objYpos;
				objHeading = objHeading * 0.005555556 * 3.141593;
				local_970 = y;
				local_968 = uVar11;
				BVar3 = game::Object_GetObjectByName(objTypeName,&local_9c4,(int *)&local_9a8,&local_990);
				if (BVar3 == 0) break;
				pLVar10 = (LiveObject *)0x0;
				if (local_9c4 == OBJECT_TVCAMERA) {
					lego::view::Camera_SetFramePosition_IfTopdown
										(globals::g_Game.cameraMain,local_9c0,local_9bc);
					lego::view::Camera_SetYaw(globals::g_Game.cameraMain,objHeading);
					lego::view::Camera_SetTilt(globals::g_Game.cameraMain,0.8);
					globals::g_Game.tvFaceDirection_338.x = local_9c0;
					globals::g_Game.tvFaceDirection_338.y = local_9bc;
					globals::g_Game.tvTiltOrZoom_334 = 15.0;
				}
				else {
					iVar8 = ((globals::g_Game.level)->dimensions).width;
					if ((uVar11 < iVar8 - 1U) && (y < ((globals::g_Game.level)->dimensions).height - 1U)) {
						LVar4 = (globals::g_Game.level)->blocks[y * iVar8 + uVar11].flags1 & BLOCK1_UNK_8;
					}
					else {
						LVar4 = BLOCK1_NONE;
					}
					if (LVar4 == BLOCK1_NONE) {
						local_978 = local_9c0;
						local_974 = local_9bc;
						FUN_00437ee0(local_990,local_9c4,local_9a8,&local_978,objHeading,objHealth,
												 objDrivenByName,objDrivingName);
					}
					else {
						if (local_9c4 == OBJECT_BUILDING) {
							local_984.x = uVar11;
							local_984.y = y;
							objDrivenByName =
									 (char *)res::Building_GetShapePoints
																		 (globals::g_Game.BuildingData_TABLE + local_9a8,&local_988);
							lVar16 = __ftol((float10)objHeading * (float10)0.1591549 * (float10)8.0);
							rotation = ((uint)lVar16 & 1) + (uint)lVar16 >> 1;
							pPVar5 = game::Game_TransformShapePoints
																 (&local_984,(Point2I *)objDrivenByName,local_988,rotation);
							pLVar10 = (LiveObject *)
												FUN_004099c0(local_9a8,(int *)&local_984,rotation,(uint *)pPVar5,local_988,
																		 level->IsStartTeleportEnabled);
							if (pLVar10 != (LiveObject *)0x0) {
								game::LiveObject_FUN_00438720(pLVar10);
							}
						}
						else {
							pLVar10 = game::LiveObject__Create((int **)local_990,local_9c4,local_9a8);
						}
					}
				}
				*local_9a0 = pLVar10;
				if (pLVar10 != (LiveObject *)0x0) {
					if (local_998 != 0) {
						fVar18 = 0.01;
						fVar17 = 0.7;
						fVar13 = game::LiveObject_GetTrackDist(pLVar10);
						lego::view::Camera_FUN_00435deb
											(globals::g_Game.cameraRadar,pLVar10,2.0,(float)fVar13,fVar17,fVar18);
					}
					local_998 = 0;
					if (local_9c4 != OBJECT_BUILDING) {
						game::LiveObject_UnkUpdatePositioning(pLVar10,local_9c0,local_9bc,objHeading,1);
					}
					if ((((local_9c4 == OBJECT_POWERCRYSTAL) || (local_9c4 == OBJECT_ORE)) ||
							(local_9c4 == OBJECT_DYNAMITE)) || (local_9c4 == OBJECT_BARRIER)) {
						ai::AITask_DoCollect(pLVar10,0.0);
					}
					if ((MINIFIGOBJ_004e9448 == (LiveObject *)0x0) && (pLVar10->objType == OBJECT_MINIFIGURE))
					{
						MINIFIGOBJ_004e9448 = pLVar10;
					}
					if (globals::g_Game.count10_320 < 10) {
						globals::g_Game.table10_2f8[globals::g_Game.count10_320] = pLVar10;
						globals::g_Game.count10_320 = globals::g_Game.count10_320 + 1;
					}
					pLVar10->flags4 = pLVar10->flags4 | 0x200;
					pLVar10->health = objHealth;
					game::Game_UpdateObjectDependencies(pLVar10->objType,pLVar10->objIndex,0,1);
					if ((globals::g_Game.flags2 & GAME2_RECALLOLOBJECTS) != GAME2_NONE) {
						game::LiveObject_RecallMiniFigure(pLVar10);
					}
					game::LiveObject_Vehicle_FUN_0043aca0(pLVar10);
					if (local_9c4 == OBJECT_SPIDERWEB) {
						pLVar10->flags3 = pLVar10->flags3 | 0x10000;
						res::Container_SetActivity(pLVar10->other,"FlapInWind");
						res::Container_SetAnimationTime(pLVar10->other,0.0);
						game::Level_SetBlockStruct_c_Value(uVar11,y,pLVar10);
					}
					else {
						if (local_9c4 == OBJECT_ELECTRICFENCE) {
							game::LiveObject_AssignBlockObject(pLVar10);
						}
					}
				}
				std::free(objTypeName);
				local_9c8 = local_9c8 + 1;
				local_9a0 = local_9a0 + 1;
				prop_00 = cfg::CFG_NextFlat(prop_00);
				prop = local_994;
			} while (prop_00 != (CFGProperty *)0x0);
			if (prop_00 == (CFGProperty *)0x0) {
				local_9b0 = 1;
			}
		}
		cfg::CFG_Close(prop);
	}
	if (local_9b0 == 0) {
		return 0;
	}
	local_9b0 = 0;
	if (local_9c8 != 0) {
		do {
			pLVar10 = local_960[local_9b0];
			if ((pLVar10 != (LiveObject *)0x0) && (pcVar1 = apcStack800[local_9b0], pcVar1 != (char *)0x0)
				 ) {
				uVar11 = 0;
				ppcVar9 = local_640;
				do {
					iVar8 = std::_stricmp(pcVar1,*ppcVar9);
					if (iVar8 == 0) {
						liveObj = local_960[uVar11];
						if (liveObj != (LiveObject *)0x0) {
							pLVar10->object_2fc = liveObj;
							pLVar10->flags2 = pLVar10->flags2 | LIVEOBJ2_UNK_4;
							OVar6 = game::LiveObject_GetStatsFlags3(liveObj);
							if ((OVar6 & STATS3_NEEDSPILOT) == STATS3_NONE) {
								OVar7 = game::LiveObject_GetStatsFlags1(liveObj);
								if ((OVar7 & STATS1_CROSSWATER) == STATS1_NONE) {
									trainFlags = TRAINED_DRIVER;
								}
								else {
									OVar7 = game::LiveObject_GetStatsFlags1(liveObj);
									if ((OVar7 & STATS1_CROSSLAND) == STATS1_NONE) {
										trainFlags = TRAINED_SAILOR;
									}
									else {
										trainFlags = TRAINED_PILOT;
									}
								}
							}
							else {
								trainFlags = TRAINED_PILOT;
							}
							game::LiveObject_TrainMiniFigure_instantunk(pLVar10,trainFlags);
							FUN_0043f3c0(pLVar10,(int)liveObj);
						}
						break;
					}
					uVar11 = uVar11 + 1;
					ppcVar9 = ppcVar9 + 1;
				} while (uVar11 < local_9c8);
			}
			local_9b0 = local_9b0 + 1;
		} while (local_9b0 < local_9c8);
	}
	uVar11 = 0;
	if (local_9c8 != 0) {
		do {
			if (local_640[uVar11] != (char *)0x0) {
				std::free(local_640[uVar11]);
			}
			if (apcStack800[uVar11] != (char *)0x0) {
				std::free(apcStack800[uVar11]);
			}
			uVar11 = uVar11 + 1;
		} while (uVar11 < local_9c8);
	}
	return 1;
}



BOOL __cdecl
lego::game::Object_GetObjectByName
					(char *objName,ObjectType *out_objType,int *out_objIndex,Container **opt_resData)
{
	int iVar1;
	uint index;
	
	index = 0;
	*out_objIndex = 0;
	if (globals::g_Game.RockMonsterTypes_COUNT != 0) {
		do {
			iVar1 = std::_stricmp(globals::g_Game.RockMonsterTypes_TABLE[index],objName);
			if (iVar1 == 0) {
				*out_objType = OBJECT_ROCKMONSTER;
				*out_objIndex = index;
				if (opt_resData == (Container **)0x0) {
					return 1;
				}
				*opt_resData = (Container *)(globals::g_Game.RockMonsterData_TABLE + index);
				return 1;
			}
			index = index + 1;
		} while (index < globals::g_Game.RockMonsterTypes_COUNT);
	}
	iVar1 = std::_stricmp("tvcamera",objName);
	if (iVar1 == 0) {
		*out_objType = OBJECT_TVCAMERA;
		if (opt_resData != (Container **)0x0) {
			*opt_resData = (Container *)0x0;
			return 1;
		}
	}
	else {
		iVar1 = std::_stricmp("PowerCrystal",objName);
		if (iVar1 == 0) {
			*out_objType = OBJECT_POWERCRYSTAL;
			if (opt_resData != (Container **)0x0) {
				*opt_resData = globals::g_Game.RES_Crystal;
				return 1;
			}
		}
		else {
			iVar1 = std::_stricmp("Ore",objName);
			if (iVar1 == 0) {
				*out_objType = OBJECT_ORE;
				*out_objIndex = 0;
				if (opt_resData != (Container **)0x0) {
					*opt_resData = globals::g_Game.RES_Ores_TABLE[0];
					return 1;
				}
			}
			else {
				iVar1 = std::_stricmp("ProcessedOre",objName);
				if (iVar1 == 0) {
					*out_objType = OBJECT_ORE;
					*out_objIndex = 1;
					if (opt_resData != (Container **)0x0) {
						*opt_resData = globals::g_Game.RES_Ores_TABLE[1];
						return 1;
					}
				}
				else {
					iVar1 = std::_stricmp("Boulder",objName);
					if (iVar1 == 0) {
						*out_objType = OBJECT_BOULDER;
						if (opt_resData != (Container **)0x0) {
							*opt_resData = globals::g_Game.RES_Boulder;
							return 1;
						}
					}
					else {
						iVar1 = std::_stricmp("Pusher",objName);
						if (iVar1 == 0) {
							*out_objType = OBJECT_PUSHER;
							if (opt_resData != (Container **)0x0) {
								*opt_resData = globals::g_Game.RES_Pusher;
								return 1;
							}
						}
						else {
							iVar1 = std::_stricmp("LaserShot",objName);
							if (iVar1 == 0) {
								*out_objType = OBJECT_LASERSHOT;
								if (opt_resData != (Container **)0x0) {
									*opt_resData = globals::g_Game.RES_LaserShot;
									return 1;
								}
							}
							else {
								iVar1 = std::_stricmp("Freezer",objName);
								if (iVar1 == 0) {
									*out_objType = OBJECT_FREEZER;
									if (opt_resData != (Container **)0x0) {
										*opt_resData = globals::g_Game.RES_Freezer;
										return 1;
									}
								}
								else {
									iVar1 = std::_stricmp("Dynamite",objName);
									if (iVar1 == 0) {
										*out_objType = OBJECT_DYNAMITE;
										if (opt_resData != (Container **)0x0) {
											*opt_resData = globals::g_Game.RES_Dynamite;
											return 1;
										}
									}
									else {
										iVar1 = std::_stricmp("ElectricFence",objName);
										if (iVar1 == 0) {
											*out_objType = OBJECT_ELECTRICFENCE;
											if (opt_resData != (Container **)0x0) {
												*opt_resData = globals::g_Game.RES_ElectricFence;
												return 1;
											}
										}
										else {
											iVar1 = std::_stricmp("SpiderWeb",objName);
											if (iVar1 == 0) {
												*out_objType = OBJECT_SPIDERWEB;
												if (opt_resData != (Container **)0x0) {
													*opt_resData = globals::g_Game.RES_SpiderWeb;
													return 1;
												}
											}
											else {
												iVar1 = std::_stricmp("Barrier",objName);
												if (iVar1 == 0) {
													*out_objType = OBJECT_BARRIER;
													if (opt_resData != (Container **)0x0) {
														*opt_resData = globals::g_Game.RES_Barrier;
														return 1;
													}
												}
												else {
													iVar1 = std::_stricmp("OohScary",objName);
													if (iVar1 == 0) {
														*out_objType = OBJECT_OOHSCARY;
														if (opt_resData != (Container **)0x0) {
															*opt_resData = globals::g_Game.RES_OohScary;
															return 1;
														}
													}
													else {
														iVar1 = std::_stricmp("Path",objName);
														if (iVar1 == 0) {
															*out_objType = OBJECT_PATH;
															if (opt_resData != (Container **)0x0) {
																*opt_resData = (Container *)0x0;
																return 1;
															}
														}
														else {
															index = 0;
															if (globals::g_Game.VehicleTypes_COUNT != 0) {
																do {
																	iVar1 = std::_stricmp(globals::g_Game.VehicleTypes_TABLE[index],
																												objName);
																	if (iVar1 == 0) {
																		*out_objType = OBJECT_VEHICLE;
																		*out_objIndex = index;
																		if (opt_resData == (Container **)0x0) {
																			return 1;
																		}
																		*opt_resData = (Container *)
																									 (globals::g_Game.VehicleData_TABLE + index);
																		return 1;
																	}
																	index = index + 1;
																} while (index < globals::g_Game.VehicleTypes_COUNT);
															}
															index = 0;
															if (globals::g_Game.MiniFigureTypes_COUNT != 0) {
																do {
																	iVar1 = std::_stricmp(globals::g_Game.MiniFigureTypes_TABLE[index]
																												,objName);
																	if (iVar1 == 0) {
																		*out_objType = OBJECT_MINIFIGURE;
																		*out_objIndex = index;
																		if (opt_resData == (Container **)0x0) {
																			return 1;
																		}
																		*opt_resData = (Container *)
																									 (globals::g_Game.MiniFigureData_TABLE + index);
																		return 1;
																	}
																	index = index + 1;
																} while (index < globals::g_Game.MiniFigureTypes_COUNT);
															}
															index = 0;
															if (globals::g_Game.BuildingTypes_COUNT == 0) {
																return 0;
															}
															while (iVar1 = std::_stricmp(globals::g_Game.BuildingTypes_TABLE
																													 [index],objName), iVar1 != 0) {
																index = index + 1;
																if (globals::g_Game.BuildingTypes_COUNT <= index) {
																	return 0;
																}
															}
															*out_objType = OBJECT_BUILDING;
															*out_objIndex = index;
															if (opt_resData != (Container **)0x0) {
																*opt_resData = (Container *)
																							 (globals::g_Game.BuildingData_TABLE + index);
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return 1;
}



BOOL __cdecl
lego::game::Object_GetTypeResource(ObjectType objType,int objIndex,Container **out_resData)
{
	if (objType == OBJECT_TVCAMERA) {
		*out_resData = (Container *)0x0;
		return 1;
	}
	if (objType == OBJECT_POWERCRYSTAL) {
		*out_resData = globals::g_Game.RES_Crystal;
		return 1;
	}
	if (objType == OBJECT_ORE) {
		*out_resData = globals::g_Game.RES_Ores_TABLE[objIndex];
		return 1;
	}
	if (objType == OBJECT_DYNAMITE) {
		*out_resData = globals::g_Game.RES_Dynamite;
		return 1;
	}
	if (objType == OBJECT_BARRIER) {
		*out_resData = globals::g_Game.RES_Barrier;
		return 1;
	}
	if (objType == OBJECT_ELECTRICFENCE) {
		*out_resData = globals::g_Game.RES_ElectricFence;
		return 1;
	}
	if (objType == OBJECT_SPIDERWEB) {
		*out_resData = globals::g_Game.RES_SpiderWeb;
		return 1;
	}
	if (objType == OBJECT_OOHSCARY) {
		*out_resData = globals::g_Game.RES_OohScary;
		return 1;
	}
	if (objType == OBJECT_PATH) {
		*out_resData = (Container *)0x0;
		return 1;
	}
	if (objType == OBJECT_BOULDER) {
		*out_resData = globals::g_Game.RES_Boulder;
		return 1;
	}
	if (objType == OBJECT_VEHICLE) {
		*out_resData = (Container *)(globals::g_Game.VehicleData_TABLE + objIndex);
		return 1;
	}
	if (objType == OBJECT_MINIFIGURE) {
		*out_resData = (Container *)(globals::g_Game.MiniFigureData_TABLE + objIndex);
		return 1;
	}
	if (objType == OBJECT_ROCKMONSTER) {
		*out_resData = (Container *)(globals::g_Game.RockMonsterData_TABLE + objIndex);
		return 1;
	}
	if (objType == OBJECT_BUILDING) {
		*out_resData = (Container *)(globals::g_Game.BuildingData_TABLE + objIndex);
		return 1;
	}
	if (objType == OBJECT_PUSHER) {
		*out_resData = globals::g_Game.RES_Pusher;
		return 1;
	}
	if (objType == OBJECT_LASERSHOT) {
		*out_resData = globals::g_Game.RES_LaserShot;
		return 1;
	}
	if (objType == OBJECT_FREEZER) {
		*out_resData = globals::g_Game.RES_Freezer;
		return 1;
	}
	return 0;
}



int __cdecl lego::game::Object_GetTypeCount(ObjectType objType)
{
	uint uVar1;
	
	uVar1 = objType + OBJECT_TVCAMERA;
	switch(objType) {
	case OBJECT_VEHICLE:
		return globals::g_Game.VehicleTypes_COUNT;
	case OBJECT_MINIFIGURE:
		return globals::g_Game.MiniFigureTypes_COUNT;
	case OBJECT_ROCKMONSTER:
		return globals::g_Game.RockMonsterTypes_COUNT;
	case OBJECT_BUILDING:
		return globals::g_Game.BuildingTypes_COUNT;
	case OBJECT_BOULDER:
	case OBJECT_POWERCRYSTAL:
	case OBJECT_DYNAMITE:
	case OBJECT_BARRIER:
	case OBJECT_ELECTRICFENCE:
	case OBJECT_SPIDERWEB:
	case OBJECT_OOHSCARY:
	case OBJECT_ELECTRICFENCESTUD:
	case OBJECT_PATH:
	case OBJECT_PUSHER:
	case OBJECT_FREEZER:
	case OBJECT_ICECUBE:
	case OBJECT_LASERSHOT:
		uVar1 = 1;
		break;
	case OBJECT_ORE:
		return 2;
	case OBJECT_UPGRADEPART:
		return globals::g_Game.UpgradeTypes_COUNT;
	}
	return uVar1;
}



void __cdecl lego::video::VideoPlayer_OpenAndPlay(char *filename,Point2F *opt_point)
{
	Point2F *pPVar1;
	VideoPlayer_t *videoPlayer;
	int iVar2;
	BOOL doFillSurface;
	uint clear;
	RECT *lpRect;
	bool bVar3;
	longlong lVar4;
	RECT rect;
	
	if ((filename != (char *)0x0) &&
		 (videoPlayer = VideoPlayer_Open(filename), pPVar1 = opt_point,
		 videoPlayer != (VideoPlayer_t *)0x0)) {
		bVar3 = opt_point == (Point2F *)0x0;
		if (!bVar3) {
			VideoPlayer_GetSize(videoPlayer,(uint *)&filename,(uint *)&opt_point);
			lVar4 = __ftol((float10)pPVar1->x);
			rect.left = (LONG)lVar4;
			lVar4 = __ftol((float10)pPVar1->y);
			rect.top = (LONG)lVar4;
			lVar4 = __ftol((float10)ZEXT48(filename) + (float10)pPVar1->x);
			rect.right = (LONG)lVar4;
			lVar4 = __ftol((float10)ZEXT48(opt_point) + (float10)pPVar1->y);
			rect.bottom = (LONG)lVar4;
			ddraw::DirectDraw_ReturnFrontBuffer();
		}
		clear = (uint)bVar3;
		lpRect = (RECT *)(~-(uint)(clear != 0) & (uint)&rect);
		iVar2 = VideoPlayer_Update(videoPlayer,1.0,lpRect);
		while (iVar2 != 0) {
			main::Main_LoopUpdate(clear);
			iVar2 = VideoPlayer_Update(videoPlayer,1.0,lpRect);
		}
		VideoPlayer_Close(videoPlayer);
	}
	return;
}



char * lego::game::Game_freeLevel__0042eff0(void)
{
	LevelData *buffer;
	void *extraout_ECX;
	char *pcVar1;
	
	buffer = globals::g_Game.level;
	pcVar1 = (char *)0x0;
	if (globals::g_Game.level != (LevelData *)0x0) {
		std::free((globals::g_Game.level)->ptrtable_8);
		if (globals::g_Game.EndGameAVI1 != (char *)0x0) {
			std::free(globals::g_Game.EndGameAVI1);
		}
		if (globals::g_Game.EndGameAVI2 != (char *)0x0) {
			std::free(globals::g_Game.EndGameAVI2);
		}
		std::free(buffer->FullName);
		globals::g_Game.flags1 = globals::g_Game.flags1 & ~(GAME1_UNK_200000|GAME1_UNK_8000000);
		pool::globals::ReservedPool_LiveObject___g_INITFLAGS =
				 pool::globals::ReservedPool_LiveObject___g_INITFLAGS & 0xffffffbf;
		globals::g_Game.flags2 = globals::g_Game.flags2 & ~(GAME2_UNK_2|GAME2_NOMULTISELECT);
		globals::g_Game.bool_98 = 0;
		globals::g_Game.objTeleportQueue_COUNT = 0;
		MINIFIGOBJ_004e9448 = (LiveObject *)0x0;
		DAT_004ebbc4 = 0;
		DAT_004ebbc8 = 0;
		Game_SetCallToArmsOn(0);
		globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_LASERTRACKER;
		globals::g_Game.flags2 =
				 globals::g_Game.flags2 & ~(GAME2_UNK_4|GAME2_UNK_40|GAME2_UNK_80|GAME2_MENU_HASNEXT);
		globals::g_Game.pointsCount2_dcc[0] = 0;
		globals::g_Game.pointsCount2_dcc[1] = 0;
		lego::view::Camera_SetFloata0_a4_Zeroa8(globals::g_Game.cameraMain,0.0,0.0);
		lego::view::Camera_SetDist(globals::g_Game.cameraMain,200.0);
		FUN_00465c30();
		FUN_00435950();
		pcVar1 = buffer->NextLevel;
		FUN_0046ad50();
		unk::Lego_UnsetFlag1_004dd650();
		FUN_0040aa60();
		Level_BlockPointers_FUN_00456f20();
		ai::AITask_FUN_00402040(0);
		FUN_00437560();
		FUN_00409900();
		FUN_0040bcf0();
		ai::AITask_FUN_00402040(1);
		front::Info_SetFlag4(0);
		unk::Lego_UnkFreeGridPtr_FUN_00463190();
		lego::view::Camera_FUN_00435deb(globals::g_Game.cameraRadar,(LiveObject *)0x0,0.0,0.0,0.0,0.0);
		lego::view::Camera_SetObject4_Field14(globals::g_Game.cameraFP,(LiveObject *)0x0,0);
		Game_CleanupSelectedUnitsCount();
		nerps::NERPs_Cleanup();
		LevelStruct3C_Free_Unwind(buffer->struct3c_84);
		SurfaceMap_Free(buffer->surfaceMap);
		FUN_0042b3b0((int)buffer);
		FUN_0040b340((uint *)buffer->surfTextGrid);
		FUN_00431460((int)buffer);
		FUN_0040c5c0(extraout_ECX);
		std::free(buffer->blocks);
		std::free(buffer);
		FUN_00419e40();
		FUN_0041a850();
		Game_SetGameSpeed(1.0);
		FUN_0045a530();
		front::Advisor_Cleanup();
		snd::Sound3D_StopAllSounds();
		FUN_0040a300();
	}
	globals::g_Game.level = (LevelData *)0x0;
	return pcVar1;
}



void __cdecl FUN_0042f210(LevelData *level,int *param_2,int *param_3,int param_4)
{
	LevelBlockFlags1 *pLVar1;
	int iVar2;
	
	iVar2 = (level->dimensions).width;
	if (param_4 != 0) {
		pLVar1 = &level->blocks[(int)(iVar2 * (int)param_3 + (int)param_2)].flags1;
		*pLVar1 = *pLVar1 | BLOCK1_UNK_200;
		lego::game::Level_UpdateBlockSurfaceUnk(level,(int)param_2,(int)param_3);
		return;
	}
	pLVar1 = &level->blocks[(int)(iVar2 * (int)param_3 + (int)param_2)].flags1;
	*pLVar1 = *pLVar1 & ~BLOCK1_UNK_200;
	lego::game::Level_UpdateBlockSurfaceUnk(level,(int)param_2,(int)param_3);
	return;
}



uint __cdecl FUN_0042f280(int param_1,int param_2,undefined *param_3,int param_4)
{
	int iVar1;
	LevelBlockFlags1 LVar2;
	undefined3 uVar3;
	uint uVar5;
	int iVar6;
	int *piVar7;
	int iVar8;
	uint local_24;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	undefined3 uVar4;
	
	local_20[2] = 1;
	local_c = 1;
	local_20[1] = 0xffffffff;
	local_20[3] = 0;
	local_20[4] = 0;
	local_8 = 0xffffffff;
	local_4 = 0;
	local_24 = 0;
	uVar5 = 0;
	piVar7 = local_20 + 1;
	do {
		iVar6 = piVar7[-1] + param_1;
		iVar8 = param_2 + *piVar7;
		if ((((iVar6 < 0) || (iVar8 < 0)) ||
				(iVar1 = ((lego::globals::g_Game.level)->dimensions).width, iVar1 <= iVar6)) ||
			 (((lego::globals::g_Game.level)->dimensions).height <= iVar8)) {
			LVar2 = BLOCK1_NONE;
		}
		else {
			LVar2 = (lego::globals::g_Game.level)->blocks[iVar8 * iVar1 + iVar6].flags1 & BLOCK1_POWERPATH
			;
		}
		if ((LVar2 != BLOCK1_NONE) ||
			 (((lego::globals::g_Game.level)->blocks
				 [((lego::globals::g_Game.level)->dimensions).width * iVar8 + iVar6].flags1 & BLOCK1_UNK_400
				) != BLOCK1_NONE)) {
			local_24 = local_24 | 1 << ((byte)uVar5 & 0x1f);
		}
		uVar5 = uVar5 + 1;
		piVar7 = piVar7 + 2;
	} while (uVar5 < 4);
	uVar3 = (undefined3)(local_24 >> 8);
	uVar4 = (undefined3)((uint)param_3 >> 8);
	if (param_4 == 0) {
		switch(local_24) {
		case 0:
			*param_3 = 0;
			return CONCAT31(uVar3,0x65);
		case 1:
			*param_3 = 2;
			return CONCAT31(uVar4,0x65);
		case 2:
			*param_3 = 3;
			return CONCAT31(uVar3,0x65);
		case 3:
			*param_3 = 3;
			return CONCAT31(uVar3,99);
		case 4:
			*param_3 = 0;
			return CONCAT31(uVar3,0x65);
		case 5:
			*param_3 = 0;
			return CONCAT31(uVar3,0x62);
		case 6:
			*param_3 = 0;
			return CONCAT31(uVar3,99);
		case 7:
			*param_3 = 0;
			return CONCAT31(uVar3,100);
		case 8:
			*param_3 = 1;
			return CONCAT31(uVar4,0x65);
		case 9:
			*param_3 = 2;
			return CONCAT31(uVar4,99);
		case 10:
			*param_3 = 1;
			return CONCAT31(uVar4,0x62);
		case 0xb:
			*param_3 = 3;
			return CONCAT31(uVar3,100);
		case 0xc:
			*param_3 = 1;
			return CONCAT31(uVar3,99);
		case 0xd:
			*param_3 = 2;
			return CONCAT31(uVar3,100);
		case 0xe:
			*param_3 = 1;
			return CONCAT31(uVar4,100);
		case 0xf:
			*param_3 = 0;
			return CONCAT31(uVar3,0x60);
		}
	}
	else {
		switch(local_24) {
		case 0:
			*param_3 = 0;
			return CONCAT31(uVar4,0x75);
		case 1:
			*param_3 = 2;
			return CONCAT31(uVar3,0x75);
		case 2:
			*param_3 = 3;
			return CONCAT31(uVar4,0x75);
		case 3:
			*param_3 = 3;
			return CONCAT31(uVar4,0x73);
		case 4:
			*param_3 = 0;
			return CONCAT31(uVar3,0x75);
		case 5:
			*param_3 = 0;
			return CONCAT31(uVar3,0x72);
		case 6:
			*param_3 = 0;
			return CONCAT31(uVar4,0x73);
		case 7:
			*param_3 = 0;
			return CONCAT31(uVar3,0x74);
		case 8:
			*param_3 = 1;
			return CONCAT31(uVar3,0x75);
		case 9:
			*param_3 = 2;
			return CONCAT31(uVar3,0x73);
		case 10:
			*param_3 = 1;
			return CONCAT31(uVar3,0x72);
		case 0xb:
			*param_3 = 3;
			return CONCAT31(uVar3,0x74);
		case 0xc:
			*param_3 = 1;
			return CONCAT31(uVar3,0x73);
		case 0xd:
			*param_3 = 2;
			return CONCAT31(uVar4,0x74);
		case 0xe:
			*param_3 = 1;
			return CONCAT31(uVar3,0x74);
		case 0xf:
			*param_3 = 0;
			return CONCAT31(uVar4,0x71);
		}
	}
	return local_24 & 0xffffff00 | (uint)param_3 & 0xff;
}



// WARNING: Removing unreachable block (ram,0x0042fe08)
// WARNING: Removing unreachable block (ram,0x0042fe13)
// WARNING: Removing unreachable block (ram,0x0042fea2)
// WARNING: Removing unreachable block (ram,0x0042fead)
// WARNING: Recovered jumptable eliminated as dead code
// WARNING: Switch with 1 destination removed at 0x0042fd79 : 5 cases all go to same destination
// WARNING: Switch with 1 destination removed at 0x0042fdd8 : 5 cases all go to same destination

void __cdecl lego::game::Level_UpdateBlockSurfaceUnk(LevelData *level,int x,int y)
{
	LevelBlock *pLVar1;
	LevelBlock *pLVar2;
	SurfaceMap *surfMap;
	int iVar3;
	LevelBlockFlags1 LVar4;
	LevelBlockFlags2 LVar5;
	LevelBlockFlags1 LVar6;
	BOOL BVar7;
	int *piVar8;
	FeatureFlags FVar9;
	uint *puVar10;
	uint extraout_ECX;
	uint uVar11;
	uint extraout_EDX;
	uint uVar12;
	float local_60;
	int local_5c;
	float local_58;
	float local_54;
	Point2I *local_50;
	SurfaceMap *local_4c;
	Vector3F local_48;
	int local_3c;
	Point2I local_38;
	uint local_30 [5];
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	iVar3 = (level->dimensions).width;
	if (iVar3 - 1U <= (uint)x) {
		return;
	}
	if ((level->dimensions).height - 1U <= (uint)y) {
		return;
	}
	local_4c = level->surfaceMap;
	iVar3 = y * iVar3 + x;
	local_5c = 0;
	local_30[0] = 0;
	LVar4 = level->blocks[iVar3].flags1 & BLOCK1_POWERPATH;
	local_30[1] = 0;
	pLVar1 = level->blocks + iVar3;
	local_30[2] = 1;
	local_30[3] = 0;
	local_30[4] = 1;
	local_1c = 1;
	local_18 = 0;
	local_14 = 1;
	local_3c = 1;
	if ((LVar4 == BLOCK1_NONE) || ((pLVar1->flags2 & 0x400) != BLOCK2_NONE)) {
		if ((LVar4 == BLOCK1_NONE) && ((pLVar1->flags2 & 0x400) != BLOCK2_NONE)) {
			unk::Lego_PathLiveLevelsIncrementConditional(0);
			LVar5 = pLVar1->flags2 & 0xfffffbff;
			goto LAB_0042f6d5;
		}
	}
	else {
		unk::Lego_PathLiveLevelsIncrementConditional(1);
		LVar5 = pLVar1->flags2 | 0x400;
LAB_0042f6d5:
		pLVar1->flags2 = LVar5;
	}
	iVar3 = (level->dimensions).width;
	pLVar2 = level->blocks;
	local_50 = &local_38;
	uVar11 = 0;
										// Get surrounding blocks for orientation?
	puVar10 = local_30;
	do {
		if (pLVar2[(puVar10[1] + y) * iVar3 + x + *puVar10].predug == PREDUG_EXPOSED) {
			local_48.x = (float)((uint)local_48.x & 0xffffff00 | uVar11 & 0xff);
			local_5c = local_5c + 1;
		}
		else {
			*(char *)&local_50->x = (char)uVar11;
			local_50 = (Point2I *)((int)&local_50->x + 1);
		}
		uVar11 = uVar11 + 1;
		puVar10 = puVar10 + 2;
	} while (uVar11 < 4);
	LVar4 = pLVar1->flags1;
	LVar6 = LVar4 & 0xffffdf27;
	pLVar1->flags1 = LVar6;
	if (local_5c == 4) {
		local_38.x = x;
		local_38.y = y;
		pLVar1->flags1 = LVar4 & 0xffffdf07 | 0xc;
		pLVar1->field_3 = 0;
		if ((LVar4 & BLOCK1_UNK_8) == BLOCK1_NONE) {
			local_48.x = (float)x;
			local_48.y = (float)y;
			FUN_00402a10(&local_38,0);
			Level_FUN_00431380(level,(Point2I *)&local_48,1);
			if ((globals::g_Game.flags1 & GAME1_ALWAYSROCKFALL) != GAME1_NONE) {
				Level_AddMessageAction
									(MESSAGE_DIG_COMPLETE,0,
									 (uint)(globals::g_Game.level)->blocks
												 [((globals::g_Game.level)->dimensions).width * y + x].field_3,
									 (Point2I *)&local_48);
			}
		}
		if ((pLVar1->flags1 & BLOCK1_UNK_400000) == BLOCK1_NONE) {
			if ((((((globals::g_Game.level)->blocks
							[((globals::g_Game.level)->dimensions).width * local_38.y + local_38.x].flags1 &
						 BLOCK1_UNK_400) == BLOCK1_NONE) &&
					 ((*(byte *)&(globals::g_Game.level)->blocks
											 [((globals::g_Game.level)->dimensions).width * local_38.y + local_38.x].
											 flags2 & 4) == 0)) &&
					((*(byte *)((int)&(globals::g_Game.level)->blocks
														[((globals::g_Game.level)->dimensions).width * local_38.y + local_38.x].
														flags1 + 1) & 0x80) == 0)) &&
				 (BVar7 = FUN_00408fd0(&local_38), BVar7 == 0)) {
				iVar3 = ((globals::g_Game.level)->dimensions).width * local_38.y + local_38.x;
				(globals::g_Game.level)->blocks[iVar3].flags1 =
						 (globals::g_Game.level)->blocks[iVar3].flags1 & ~BLOCK1_UNK_200000;
				iVar3 = ((globals::g_Game.level)->dimensions).width * local_38.y + local_38.x;
				(globals::g_Game.level)->blocks[iVar3].flags1 =
						 (globals::g_Game.level)->blocks[iVar3].flags1 & ~BLOCK1_POWERPATH;
				iVar3 = ((globals::g_Game.level)->dimensions).width * local_38.y + local_38.x;
				(globals::g_Game.level)->blocks[iVar3].flags1 =
						 (globals::g_Game.level)->blocks[iVar3].flags1 & ~BLOCK1_UNK_40000000;
				Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
				FUN_00402970(&local_38);
				util::logf_removed((char *)&local_38);
				iVar3 = 4;
				do {
					ai::AITask_DoClear_AtPosition(&local_38,MESSAGE_CLEAR_COMPLETE);
					iVar3 = iVar3 + -1;
				} while (iVar3 != 0);
				iVar3 = ((globals::g_Game.level)->dimensions).width * local_38.y + local_38.x;
				(globals::g_Game.level)->blocks[iVar3].flags1 =
						 (globals::g_Game.level)->blocks[iVar3].flags1 | BLOCK1_RUBBLE_FULL;
			}
			iVar3 = ((globals::g_Game.level)->dimensions).width * local_38.y + local_38.x;
			(globals::g_Game.level)->blocks[iVar3].flags1 =
					 (globals::g_Game.level)->blocks[iVar3].flags1 | BLOCK1_UNK_400000;
			FUN_0041ceb0(&local_38);
		}
		BVar7 = Level_FUN_0040e110(level,x,y);
		Level_FUN_0040e280(level,x,y,(uint)(BVar7 != 0));
		if ((pLVar1->terrain == TERRAIN_LAVA) ||
			 (LVar4 = pLVar1->flags1, (LVar4 & BLOCK1_UNK_80000000) != BLOCK1_NONE)) {
			FUN_0040ed80(&local_38,1);
			if ((pLVar1->flags1 & BLOCK1_UNK_200) == BLOCK1_NONE) {
				if (pLVar1->field_7 == 4) {
					pLVar1->texture = TEXTURE_LAVA;
					SurfaceMap_FUN_00450c20(level->surfaceMap,x,y,1);
					if ((pLVar1->flags1 & BLOCK1_UNK_4000) == BLOCK1_NONE) {
						if ((int)pLVar1->randomness % 3 == 0) {
							local_48.x = 0.1;
							local_48.y = 0.1;
							local_48.z = -1.0;
							piVar8 = FUN_004656f0(0,x,y,&local_48,0.6,0.4,0.0,1.0,0.3,0,(int)pLVar1->randomness,
																		0x26);
							pLVar1->field_1c = piVar8;
							pLVar1->flags1 = pLVar1->flags1 | BLOCK1_UNK_4000;
						}
					}
					else {
						FUN_00465d80(pLVar1->field_1c,0);
					}
				}
				else {
					SurfaceMap_FUN_00450c20(level->surfaceMap,x,y,0);
					switch(pLVar1->field_7) {
					case 0:
						pLVar1->texture = TEXTURE_ERODE_LOW;
						break;
					case 1:
						pLVar1->texture = TEXTURE_ERODE_MEDIUM;
						break;
					case 2:
						pLVar1->texture = TEXTURE_ERODE_HIGH;
						break;
					case 3:
						pLVar1->texture = TEXTURE_ERODE_FULL;
					}
				}
			}
			else {
				SurfaceMap_FUN_00450c20(level->surfaceMap,x,y,0);
				pLVar1->texture = TEXTURE_LAVA_NOTHOT;
				if ((pLVar1->flags1 & BLOCK1_UNK_4000) != BLOCK1_NONE) {
					FUN_00465d80(pLVar1->field_1c,1);
				}
			}
		}
		else {
			if (pLVar1->terrain == TERRAIN_LAKE) {
				pLVar1->texture = TEXTURE_WATER;
				SurfaceMap_FUN_00450c20(level->surfaceMap,x,y,1);
			}
			else {
				if ((LVar4 & BLOCK1_UNK_100000) == BLOCK1_NONE) {
					if ((LVar4 & BLOCK1_POWERPATH) == BLOCK1_NONE) {
						if ((*(byte *)&pLVar1->flags2 & 0x20) == 0) {
							if ((LVar4 & BLOCK1_UNK_200000) == BLOCK1_NONE) {
								switch(LVar4 & BLOCK1_RUBBLE_FULL) {
								case BLOCK1_NONE:
									pLVar1->texture = TEXTURE_RUBBLE_LOW;
									break;
								case BLOCK1_RUBBLE_LOW:
									pLVar1->texture = TEXTURE_RUBBLE_MEDIUM;
									break;
								case BLOCK1_RUBBLE_MEDIUM:
									pLVar1->texture = TEXTURE_RUBBLE_HIGH;
									break;
								case BLOCK1_RUBBLE_FULL:
									pLVar1->texture = TEXTURE_RUBBLE_FULL;
								}
							}
							else {
								if ((LVar4 & BLOCK1_UNK_40000000) == BLOCK1_NONE) {
									pLVar1->texture = TEXTURE_GROUND;
								}
								else {
									pLVar1->texture = TEXTURE_PATH_BUILD;
								}
							}
						}
						else {
							pLVar1->texture = TEXTURE_SLUGHOLE;
						}
					}
					else {
						uVar11 = FUN_0042f280(x,y,&pLVar1->field_3,pLVar1->flags2 & 0x100);
						pLVar1->texture = (SurfaceTexture)uVar11;
					}
				}
				else {
					if ((pLVar1->flags2 & 0x100) == BLOCK2_NONE) {
						pLVar1->texture = TEXTURE_PLATE;
					}
					else {
						pLVar1->texture = TEXTURE_PLATE_POWERED;
					}
				}
			}
		}
		goto switchD_0042fb8d_caseD_4;
	}
	if (local_5c != 2) {
		if ((local_5c == 1) || (local_5c == 3)) {
			pLVar1->flags1 = LVar4 & 0xffffdf07 | 0x14;
			if (local_5c == 1) {
				switch(pLVar1->terrain) {
				case TERRAIN_IMMOVABLE:
				case TERRAIN_WATER_unused:
					pLVar1->texture = TEXTURE_WALL_C_IMMOVABLE;
					break;
				case TERRAIN_HARD:
					pLVar1->texture = TEXTURE_WALL_C_HARD;
					break;
				case TERRAIN_MEDIUM:
					pLVar1->texture = TEXTURE_WALL_C_MEDIUM;
					break;
				case TERRAIN_LOOSE:
					pLVar1->texture = TEXTURE_WALL_C_LOOSE;
					break;
				case TERRAIN_SOIL:
					pLVar1->texture = TEXTURE_WALL_C_SOIL;
				}
				pLVar1->flags1 = LVar4 & 0xffffdf07 | 0x54;
				local_38.y = y;
				pLVar1->field_3 = SUB41(local_48.x,0) + 2U & 3;
				local_38.x = x;
				Level_FUN_00431380(level,&local_38,1);
			}
			else {
				if (local_5c == 3) {
					switch(pLVar1->terrain) {
					case TERRAIN_IMMOVABLE:
					case TERRAIN_WATER_unused:
						pLVar1->texture = TEXTURE_WALL_O_IMMOVABLE;
						break;
					case TERRAIN_HARD:
						pLVar1->texture = TEXTURE_WALL_O_HARD;
						break;
					case TERRAIN_MEDIUM:
						pLVar1->texture = TEXTURE_WALL_O_MEDIUM;
						break;
					case TERRAIN_LOOSE:
						pLVar1->texture = TEXTURE_WALL_O_LOOSE;
						break;
					case TERRAIN_SOIL:
						pLVar1->texture = TEXTURE_WALL_O_SOIL;
					}
					local_48.x = (float)x;
					local_48.y = (float)y;
					Level_FUN_00431380(level,(Point2I *)&local_48,1);
					FUN_00402a60(&local_48);
					pLVar1->field_3 = (byte)local_38.x;
					pLVar1->flags1 = pLVar1->flags1 | BLOCK1_UNK_80;
				}
			}
			surfMap = local_4c;
			SurfaceMap_FUN_00450a90(local_4c,x,y,&local_60,&local_60,&local_58);
			SurfaceMap_FUN_00450a90(surfMap,x + 1U,y + 1U,&local_60,&local_60,&local_54);
			local_48.x = local_58 - local_54;
			SurfaceMap_FUN_00450a90(surfMap,x + 1U,y,&local_60,&local_60,&local_58);
			SurfaceMap_FUN_00450a90(surfMap,x,y + 1U,&local_60,&local_60,&local_54);
			SurfaceMap_FUN_0044f0b0
								(surfMap,x,y,
								 (uint)((ushort)((ushort)(ABS(local_48.x) < ABS(local_58 - local_54)) << 8 |
																(ushort)(ABS(local_48.x) == ABS(local_58 - local_54)) << 0xe) == 0))
			;
			local_38.x = x;
			local_38.y = y;
			Level_FUN_00431380(level,&local_38,1);
		}
		else {
			if (((LVar4 & 4) == BLOCK1_NONE) || (pLVar1->terrain - 1 < 5)) {
				pLVar1->texture = TEXTURE_TUNNEL;
			}
			pLVar1->field_3 = 0;
		}
		goto switchD_0042fb8d_caseD_4;
	}
	local_30[1] = 1;
	local_30[2] = 1;
	local_8 = 1;
	local_30[0] = 0;
	local_18 = 0;
	local_10 = 0;
	local_1c = 3;
	local_14 = 3;
	local_4 = 3;
	uVar11 = 0;
	local_30[3] = 2;
	local_30[4] = 2;
	local_c = 2;
	pLVar1->flags1 = LVar6 | 0x14;
	puVar10 = local_30 + 1;
	do {
		if ((puVar10[-1] == (local_38.x & 0xffU)) && (*puVar10 == ((uint)local_38.x >> 8 & 0xff))) {
			x._0_1_ = (byte)uVar11;
			goto LAB_0042fc43;
		}
		uVar11 = uVar11 + 1;
		puVar10 = puVar10 + 2;
	} while (uVar11 < 6);
LAB_0042fc43:
	if (3 < (byte)x) {
		if (pLVar1->terrain - 1 < 5) {
			pLVar1->texture = TEXTURE_WALL_GAP;
		}
		pLVar1->flags1 =
				 LVar4 & 0xffff0000 | (uint)CONCAT11((char)(LVar6 >> 8),(char)(LVar6 | 0x14)) | 0x2000;
		pLVar1->field_3 = (byte)x - 4;
		SurfaceMap_FUN_0044f0b0(local_4c,x,y,(byte)((byte)x - 4) & 1);
		goto switchD_0042fb8d_caseD_4;
	}
	if ((LVar4 & BLOCK1_REINFORCED) != BLOCK1_NONE) {
		switch(pLVar1->terrain) {
		case TERRAIN_IMMOVABLE:
		case TERRAIN_WATER_unused:
			pLVar1->texture = TEXTURE_WALL_R_IMMOVABLE;
			pLVar1->field_3 = (byte)x;
			break;
		case TERRAIN_HARD:
			pLVar1->texture = TEXTURE_WALL_R_HARD;
			pLVar1->field_3 = (byte)x;
			break;
		case TERRAIN_MEDIUM:
			pLVar1->texture = TEXTURE_WALL_R_MEDIUM;
			pLVar1->field_3 = (byte)x;
			break;
		case TERRAIN_LOOSE:
			pLVar1->texture = TEXTURE_WALL_R_LOOSE;
			pLVar1->field_3 = (byte)x;
			break;
		case TERRAIN_SOIL:
			pLVar1->texture = TEXTURE_WALL_R_SOIL;
			pLVar1->field_3 = (byte)x;
			break;
		default:
			goto switchD_0042fce8_caseD_6;
		}
		goto switchD_0042fb8d_caseD_4;
	}
	if ((int)pLVar1->randomness % 10 == 0) {
		switch(pLVar1->terrain) {
		case TERRAIN_IMMOVABLE:
		case TERRAIN_WATER_unused:
			goto switchD_0042fce8_caseD_1;
		case TERRAIN_HARD:
			goto switchD_0042fce8_caseD_2;
		case TERRAIN_MEDIUM:
			goto switchD_0042fce8_caseD_3;
		case TERRAIN_LOOSE:
			goto switchD_0042fce8_caseD_4;
		case TERRAIN_SOIL:
			goto switchD_0042fce8_caseD_5;
		case TERRAIN_ORESEAM:
			goto switchD_0042fce8_caseD_8;
		case TERRAIN_CRYSTALSEAM:
			goto switchD_0042fce8_caseD_a;
		case TERRAIN_RECHARGESEAM:
			goto switchD_0042fce8_caseD_b;
		}
	}
	else {
		switch(pLVar1->terrain) {
		case TERRAIN_IMMOVABLE:
		case TERRAIN_WATER_unused:
switchD_0042fce8_caseD_1:
			pLVar1->texture = TEXTURE_WALL_F_IMMOVABLE;
			pLVar1->field_3 = (byte)x;
			goto switchD_0042fb8d_caseD_4;
		case TERRAIN_HARD:
switchD_0042fce8_caseD_2:
			pLVar1->texture = TEXTURE_WALL_F_HARD;
			pLVar1->field_3 = (byte)x;
			goto switchD_0042fb8d_caseD_4;
		case TERRAIN_MEDIUM:
switchD_0042fce8_caseD_3:
			pLVar1->texture = TEXTURE_WALL_F_MEDIUM;
			pLVar1->field_3 = (byte)x;
			goto switchD_0042fb8d_caseD_4;
		case TERRAIN_LOOSE:
switchD_0042fce8_caseD_4:
			pLVar1->texture = TEXTURE_WALL_F_LOOSE;
			pLVar1->field_3 = (byte)x;
			goto switchD_0042fb8d_caseD_4;
		case TERRAIN_SOIL:
switchD_0042fce8_caseD_5:
			pLVar1->texture = TEXTURE_WALL_F_SOIL;
			pLVar1->field_3 = (byte)x;
			goto switchD_0042fb8d_caseD_4;
		case TERRAIN_ORESEAM:
switchD_0042fce8_caseD_8:
			pLVar1->texture = TEXTURE_WALL_F_ORESEAM;
			pLVar1->field_3 = (byte)x;
			goto switchD_0042fb8d_caseD_4;
		case TERRAIN_CRYSTALSEAM:
switchD_0042fce8_caseD_a:
			pLVar1->texture = TEXTURE_WALL_F_CRYSTALSEAM;
			pLVar1->field_3 = (byte)x;
			goto switchD_0042fb8d_caseD_4;
		case TERRAIN_RECHARGESEAM:
switchD_0042fce8_caseD_b:
			pLVar1->texture = TEXTURE_WALL_F_RECHARGESEAM;
		}
	}
switchD_0042fce8_caseD_6:
	pLVar1->field_3 = (byte)x;
switchD_0042fb8d_caseD_4:
	LVar4 = pLVar1->flags1;
	if ((((LVar4 & 4) != BLOCK1_NONE) && ((LVar4 & 0x800000) != BLOCK1_NONE)) &&
		 ((pLVar1->terrain == TERRAIN_IMMOVABLE ||
			((pLVar1->terrain == TERRAIN_WATER_unused || ((LVar4 & BLOCK1_UNK_8) != BLOCK1_NONE)))))) {
		pLVar1->flags1 = LVar4 & 0xff7fffff;
		SurfaceMap_FUN_0044f830(level->surfaceMap,x,y);
	}
	FVar9 = main::Main_GetCLFlags();
	iVar3 = local_3c;
	if ((FVar9 & FEATURE_BLOCKFADEIN) == FEATURE_NONE) {
		iVar3 = 0;
	}
	uVar11 = extraout_ECX & 0xffffff00 | (uint)pLVar1->field_3;
	uVar12 = extraout_EDX & 0xffffff00 | (uint)pLVar1->texture;
	if (iVar3 == 0) {
		SurfaceMap_UpdateBlockVisual(level->surfaceMap,x,y,uVar12,uVar11);
	}
	else {
		SurfaceMap_FadeInBlock(level->surfaceMap,x,y,uVar12,uVar11);
	}
	if (level->UseRoof != BOOL3_FALSE) {
		Level_FUN_004332b0(level,x,y);
	}
	return;
}



void __cdecl FUN_004301e0(Point2I *param_1)
{
	LevelBlockFlags1 *pLVar1;
	int iVar2;
	
	pLVar1 = &(lego::globals::g_Game.level)->blocks
						[((lego::globals::g_Game.level)->dimensions).width * param_1->y + param_1->x].flags1;
	*pLVar1 = *pLVar1 & ~BLOCK1_POWERPATH;
	iVar2 = ((lego::globals::g_Game.level)->dimensions).width * param_1->y + param_1->x;
	(lego::globals::g_Game.level)->blocks[iVar2].flags1 =
			 (lego::globals::g_Game.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_40000000;
	lego::game::Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
	FUN_00402970(param_1);
	lego::util::logf_removed((char *)param_1);
	return;
}



void __cdecl lego::ai::AITask_DoClearTypeAction(Point2I *position,MessageType completeAction)
{
	BOOL BVar1;
	int iVar2;
	
	if (((((globals::g_Game.level)->blocks
				 [((globals::g_Game.level)->dimensions).width * position->y + position->x].flags1 &
				BLOCK1_UNK_400) == BLOCK1_NONE) &&
			((*(byte *)&(globals::g_Game.level)->blocks
									[((globals::g_Game.level)->dimensions).width * position->y + position->x].flags2 &
			 4) == 0)) &&
		 (((globals::g_Game.level)->blocks
			 [((globals::g_Game.level)->dimensions).width * position->y + position->x].flags1 &
			BLOCK1_UNK_8000) == BLOCK1_NONE)) {
		BVar1 = FUN_00408fd0(position);
		if (BVar1 == 0) {
			iVar2 = ((globals::g_Game.level)->dimensions).width * position->y + position->x;
			(globals::g_Game.level)->blocks[iVar2].flags1 =
					 (globals::g_Game.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_200000;
			iVar2 = ((globals::g_Game.level)->dimensions).width * position->y + position->x;
			(globals::g_Game.level)->blocks[iVar2].flags1 =
					 (globals::g_Game.level)->blocks[iVar2].flags1 & ~BLOCK1_POWERPATH;
			iVar2 = ((globals::g_Game.level)->dimensions).width * position->y + position->x;
			(globals::g_Game.level)->blocks[iVar2].flags1 =
					 (globals::g_Game.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_40000000;
			game::Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
			FUN_00402970(position);
			util::logf_removed((char *)position);
			iVar2 = 4;
			do {
				AITask_DoClear_AtPosition(position,completeAction);
				iVar2 = iVar2 + -1;
			} while (iVar2 != 0);
			iVar2 = ((globals::g_Game.level)->dimensions).width * position->y + position->x;
			(globals::g_Game.level)->blocks[iVar2].flags1 =
					 (globals::g_Game.level)->blocks[iVar2].flags1 | BLOCK1_RUBBLE_FULL;
		}
	}
	return;
}



void __cdecl
lego::game::Level_FUN_004303a0(LevelData *level,undefined4 param_2,int *param_3,int *param_4)
{
	int iVar1;
	undefined4 *puVar2;
	int *piVar3;
	
	if ((param_3 != (int *)0x0) && (param_4 != (int *)0x0)) {
		iVar1 = (level->dimensions).width;
		if ((param_3 < (int *)(iVar1 - 2U)) &&
			 ((param_4 < (int *)((level->dimensions).height - 2U) &&
				((*(byte *)&level->blocks[(int)((int)param_4 * iVar1 + (int)param_3)].flags1 & 8) != 0)))) {
			puVar2 = FUN_0046eb60((int)param_3,(int)param_4,(uint *)0x0);
			if (puVar2 != (undefined4 *)0x0) {
				piVar3 = (int *)((int)param_4 * (level->dimensions).width + (int)param_3);
				level->blocks[(int)piVar3].flags1 = level->blocks[(int)piVar3].flags1 & ~BLOCK1_UNK_8;
				piVar3 = (int *)((int)param_4 * (level->dimensions).width + (int)param_3);
				level->blocks[(int)piVar3].flags1 = level->blocks[(int)piVar3].flags1 | BLOCK1_UNK_10;
				Level_UpdateBlockSurfaceUnk(level,(int)param_3,(int)param_4);
				FUN_0046e5f0((int)param_3,(uint)param_4);
			}
		}
	}
	return;
}



BOOL __cdecl lego::game::Level_DestroyWall(LevelData *level,int in_x,int in_y,BOOL isHiddenCavern)
{
	int *piVar1;
	LevelBlock *pLVar2;
	LevelBlockFlags1 *pLVar3;
	LevelBlockFlags2 *pLVar4;
	short *psVar5;
	TerrainType TVar6;
	PredugType PVar7;
	SurfaceMap *surfMap;
	LevelBlockFlags1 LVar8;
	LevelBlockFlags2 LVar9;
	int x;
	int *piVar10;
	int iVar11;
	TutorialFlags TVar12;
	BOOL BVar13;
	uint uVar14;
	int iVar15;
	uint *puVar16;
	uint uVar17;
	InfoType infoType;
	Point2I local_50;
	Point2I local_48;
	int local_40 [5];
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	x = in_x;
	surfMap = level->surfaceMap;
	local_40[0] = 0;
	local_40[1] = 0;
	local_40[2] = 1;
	local_40[3] = 0;
	local_40[4] = 1;
	local_2c = 1;
	local_28 = 0;
	local_24 = 1;
	if ((((in_x == 0) || (in_y == 0)) ||
			(iVar11 = (level->dimensions).width, iVar11 - 2U <= (uint)in_x)) ||
		 (((level->dimensions).height - 2U <= (uint)in_y ||
			(pLVar2 = level->blocks + in_y * iVar11 + in_x, (*(byte *)&pLVar2->flags1 & 8) != 0)))) {
		return 0;
	}
	if ((pLVar2->terrain == TERRAIN_ORESEAM) || (pLVar2->terrain == TERRAIN_CRYSTALSEAM)) {
		local_48.x = in_x;
		local_48.y = in_y;
		pLVar2->float_14 = 0.0;
		piVar10 = local_40;
		in_x = 4;
		do {
			uVar14 = piVar10[1] + in_y;
			iVar11 = *piVar10;
			iVar15 = uVar14 * (level->dimensions).width + x + iVar11;
			if (level->blocks[iVar15].predug == PREDUG_WALL) {
				local_50.x = x;
				local_50.y = in_y;
				level->blocks[iVar15].predug = PREDUG_EXPOSED|PREDUG_HIDDEN_SLUGHOLE;
				TVar6 = level->blocks[in_y * (level->dimensions).width + x].terrain;
				if ((TVar6 == TERRAIN_ORESEAM) || (TVar6 == TERRAIN_CRYSTALSEAM)) {
					front::Info_FUN_00419ab0(INFO_GENERICSEAMFOUND,(char *)0x0,(LiveObject *)0x0,&local_50);
				}
				TVar6 = level->blocks[in_y * (level->dimensions).width + x].terrain;
				if (TVar6 == TERRAIN_ORESEAM) {
					infoType = INFO_ORESEAMFOUND;
				}
				else {
					if (TVar6 != TERRAIN_CRYSTALSEAM) goto LAB_00430c0d;
					infoType = INFO_CRYSTALSEAMFOUND;
				}
				front::Info_FUN_00419ab0(infoType,(char *)0x0,(LiveObject *)0x0,&local_50);
			}
LAB_00430c0d:
			PVar7 = level->blocks[uVar14 * (level->dimensions).width + x + iVar11].predug;
			if (PVar7 != PREDUG_EXPOSED) {
				level->blocks[uVar14 * (level->dimensions).width + x + iVar11].predug = PVar7 + ~PREDUG_WALL
				;
				SurfaceMap_Unk_ChangeWallDepth(surfMap,iVar11 + x,uVar14,level->DigDepth * 0.25);
			}
			piVar10 = piVar10 + 2;
			in_x = in_x + -1;
		} while (in_x != 0);
		FUN_00430d20((int *)&local_48);
		psVar5 = (short *)&level->blocks[in_y * (level->dimensions).width + x].field_0x22;
		*psVar5 = *psVar5 + 1;
		iVar11 = 4;
		if (*(short *)&level->blocks[in_y * (level->dimensions).width + x].field_0x22 != 4) {
			Level_FUN_004332b0(globals::g_Game.level,x,in_y);
			FUN_00409870(&local_48);
			return 0;
		}
		level->blocks[in_y * (level->dimensions).width + x].terrain = TERRAIN_SOIL;
		piVar10 = local_40;
		do {
			piVar1 = piVar10 + 1;
			iVar15 = *piVar10;
			piVar10 = piVar10 + 2;
			iVar11 = iVar11 + -1;
			level->blocks[(*piVar1 + in_y) * (level->dimensions).width + x + iVar15].predug =
					 PREDUG_EXPOSED;
		} while (iVar11 != 0);
		Level_DestroyWall(level,x,in_y,isHiddenCavern);
	}
	else {
		if (pLVar2->predug == PREDUG_WALL) {
			SurfaceMap_Unk_ChangeWallDepth(surfMap,in_x,in_y,level->DigDepth);
			level->blocks[in_y * (level->dimensions).width + in_x].predug = PREDUG_EXPOSED;
		}
		if (level->blocks[in_y * (level->dimensions).width + 1 + in_x].predug == PREDUG_WALL) {
			SurfaceMap_Unk_ChangeWallDepth(surfMap,in_x + 1,in_y,level->DigDepth);
			level->blocks[in_y * (level->dimensions).width + 1 + in_x].predug = PREDUG_EXPOSED;
		}
		uVar14 = in_y + 1;
		if (level->blocks[uVar14 * (level->dimensions).width + 1 + in_x].predug == PREDUG_WALL) {
			SurfaceMap_Unk_ChangeWallDepth(surfMap,in_x + 1,uVar14,level->DigDepth);
			level->blocks[uVar14 * (level->dimensions).width + 1 + in_x].predug = PREDUG_EXPOSED;
		}
		if (level->blocks[uVar14 * (level->dimensions).width + in_x].predug == PREDUG_WALL) {
			SurfaceMap_Unk_ChangeWallDepth(surfMap,in_x,uVar14,level->DigDepth);
			level->blocks[uVar14 * (level->dimensions).width + in_x].predug = PREDUG_EXPOSED;
		}
		local_40[0] = -1;
		local_40[1] = 0xffffffff;
		local_40[3] = 0xffffffff;
		local_2c = 0xffffffff;
		local_28 = 0xffffffff;
		local_18 = 0xffffffff;
		piVar10 = local_40;
		local_40[2] = 0;
		local_40[4] = 1;
		local_24 = 0;
		local_20 = 1;
		local_1c = 0;
		local_14 = 1;
		local_10 = 0;
		local_c = 1;
		local_8 = 1;
		local_4 = 1;
		in_x = 8;
		do {
			iVar11 = piVar10[1];
			iVar15 = *piVar10;
			pLVar3 = &level->blocks[(iVar11 + in_y) * (level->dimensions).width + x + iVar15].flags1;
			LVar8 = *pLVar3;
			if ((LVar8 & BLOCK1_UNK_8) == BLOCK1_NONE) {
				*pLVar3 = LVar8 | BLOCK1_UNK_10;
				iVar15 = (iVar11 + in_y) * (level->dimensions).width + x + iVar15;
				level->blocks[iVar15].flags1 = level->blocks[iVar15].flags1 & 0xfffbffff;
			}
			piVar10 = piVar10 + 2;
			in_x = in_x + -1;
		} while (in_x != 0);
		local_48.x = x;
		local_48.y = in_y;
		pLVar3 = &level->blocks[in_y * (level->dimensions).width + x].flags1;
		*pLVar3 = *pLVar3 | BLOCK1_UNK_8;
		Level_FUN_00431380(level,&local_48,1);
		iVar11 = in_y * (level->dimensions).width + x;
		level->blocks[iVar11].flags1 = level->blocks[iVar11].flags1 & ~BLOCK1_REINFORCED;
		iVar11 = in_y * (level->dimensions).width + x;
		level->blocks[iVar11].flags1 = level->blocks[iVar11].flags1 | BLOCK1_UNK_400000;
		LVar8 = level->blocks[in_y * (level->dimensions).width + x].flags1;
		if ((((LVar8 & BLOCK1_EXPOSED) == BLOCK1_NONE) || ((LVar8 & BLOCK1_HIDDEN) != BLOCK1_NONE)) &&
			 ((LVar8 & 0x800000) != BLOCK1_NONE)) {
			unk::Lego_DecFloat_00555adc();
		}
		if (isHiddenCavern == 0) {
			uVar14 = in_y - 1;
			local_48.x = x;
			local_48.y = in_y;
			if (uVar14 <= in_y + 1U) {
				do {
					puVar16 = (uint *)(x - 1);
					if (puVar16 <= (uint *)(x + 1U)) {
						do {
							if ((*(byte *)((int)&level->blocks
																	 [(int)(uVar14 * (level->dimensions).width + (int)puVar16)].flags1
														+ 2) & 2) != 0) {
								FUN_004314b0(puVar16,uVar14);
								TVar12 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
								if (TVar12 == TUTORIAL_NONE) {
									front::Info_FUN_00419ab0
														(INFO_CAVERNLOCATED,(char *)0x0,(LiveObject *)0x0,&local_48);
									front::Text_DisplayMessage(TEXT_CAVERNDISCOVERED,1,0);
									unk::Lego_DecFloat_00555efc();
								}
							}
							puVar16 = (uint *)((int)puVar16 + 1);
						} while (puVar16 <= (uint *)(x + 1U));
					}
					uVar14 = uVar14 + 1;
				} while (uVar14 <= in_y + 1U);
			}
			iVar11 = ((globals::g_Game.level)->dimensions).width * in_y + x;
			(globals::g_Game.level)->blocks[iVar11].flags1 =
					 (globals::g_Game.level)->blocks[iVar11].flags1 | BLOCK1_UNK_800;
			Level_AddMessageAction
								(MESSAGE_DIG_COMPLETE,0,
								 (uint)(globals::g_Game.level)->blocks
											 [((globals::g_Game.level)->dimensions).width * in_y + x].field_3,&local_48);
			Level_FUN_0046e4e0(level,x,in_y);
			local_50.x = x;
			local_50.y = in_y;
			if (((((globals::g_Game.level)->blocks[((globals::g_Game.level)->dimensions).width * in_y + x]
						 .flags1 & BLOCK1_UNK_400) == BLOCK1_NONE) &&
					((*(byte *)&(globals::g_Game.level)->blocks
											[((globals::g_Game.level)->dimensions).width * in_y + x].flags2 & 4) == 0)) &&
				 ((((globals::g_Game.level)->blocks[((globals::g_Game.level)->dimensions).width * in_y + x].
						flags1 & BLOCK1_UNK_8000) == BLOCK1_NONE &&
					(BVar13 = FUN_00408fd0(&local_50), BVar13 == 0)))) {
				iVar11 = ((globals::g_Game.level)->dimensions).width * local_50.y + local_50.x;
				(globals::g_Game.level)->blocks[iVar11].flags1 =
						 (globals::g_Game.level)->blocks[iVar11].flags1 & ~BLOCK1_UNK_200000;
				iVar11 = ((globals::g_Game.level)->dimensions).width * local_50.y + local_50.x;
				(globals::g_Game.level)->blocks[iVar11].flags1 =
						 (globals::g_Game.level)->blocks[iVar11].flags1 & ~BLOCK1_POWERPATH;
				iVar11 = ((globals::g_Game.level)->dimensions).width * local_50.y + local_50.x;
				(globals::g_Game.level)->blocks[iVar11].flags1 =
						 (globals::g_Game.level)->blocks[iVar11].flags1 & ~BLOCK1_UNK_40000000;
				Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
				FUN_00402970(&local_50);
				util::logf_removed((char *)&local_50);
				iVar11 = 4;
				do {
					ai::AITask_DoClear_AtPosition(&local_50,MESSAGE_CLEAR_COMPLETE);
					iVar11 = iVar11 + -1;
				} while (iVar11 != 0);
				iVar11 = ((globals::g_Game.level)->dimensions).width * local_50.y + local_50.x;
				(globals::g_Game.level)->blocks[iVar11].flags1 =
						 (globals::g_Game.level)->blocks[iVar11].flags1 | BLOCK1_RUBBLE_FULL;
			}
			FUN_0041ceb0(&local_50);
		}
		else {
			pLVar3 = &level->blocks[in_y * (level->dimensions).width + x].flags1;
			*pLVar3 = *pLVar3 | BLOCK1_UNK_200000;
		}
		local_48.x = x;
		local_48.y = in_y;
		FUN_00402a10(&local_48,0);
		uVar14 = in_y - 1;
		if (uVar14 < in_y + 2U) {
			do {
				uVar17 = x - 1;
				if (uVar17 < x + 2U) {
					do {
						Level_UpdateBlockSurfaceUnk(level,uVar17,uVar14);
						uVar17 = uVar17 + 1;
					} while (uVar17 < x + 2U);
				}
				uVar14 = uVar14 + 1;
			} while (uVar14 < in_y + 2U);
		}
		iVar11 = in_y * (level->dimensions).width + x;
		level->blocks[iVar11].flags1 = level->blocks[iVar11].flags1 & 0xff7fffff;
		uVar14 = in_y - 1;
		if (uVar14 <= in_y + 2U) {
			do {
				uVar17 = x - 1;
				if (uVar17 <= x + 2U) {
					do {
						SurfaceMap_FUN_0044f270(surfMap,uVar17,uVar14);
						uVar17 = uVar17 + 1;
					} while (uVar17 <= x + 2U);
				}
				uVar14 = uVar14 + 1;
			} while (uVar14 <= in_y + 2U);
		}
		if ((isHiddenCavern == 0) && ((globals::g_Game.flags2 & GAME2_GENERATESPIDERS) != GAME2_NONE)) {
			uVar14 = SEXT24(level->blocks[in_y * (level->dimensions).width + x].randomness);
			uVar17 = (int)uVar14 >> 0x1f;
			if (((uVar14 ^ uVar17) - uVar17 & 3 ^ uVar17) == uVar17) {
				Level_GenerateSmallSpiders(x,in_y,(int)uVar14 % 0x549);
			}
		}
		local_50.x = x;
		local_50.y = in_y;
		FUN_00437c00(&local_50);
		pLVar4 = &level->blocks[in_y * (level->dimensions).width + x].flags2;
		LVar9 = *pLVar4;
		if ((LVar9 & BLOCK2_SLUGHOLE_HIDDEN) != BLOCK2_NONE) {
			*pLVar4 = LVar9 & ~BLOCK2_SLUGHOLE_HIDDEN;
			iVar11 = in_y * (level->dimensions).width + x;
			level->blocks[iVar11].flags2 = level->blocks[iVar11].flags2 | BLOCK2_SLUGHOLE_EXPOSED;
			Level_RegisterSlimySlugHole(&local_50);
			Level_UpdateBlockSurfaceUnk(level,x,in_y);
		}
		if (isHiddenCavern == 0) {
			front::Info_FUN_00419ab0(INFO_WALLDUG,(char *)0x0,(LiveObject *)0x0,&local_50);
			return 1;
		}
	}
	return 1;
}



void __cdecl FUN_00430d20(int *param_1)
{
	TerrainType TVar1;
	int iVar2;
	int iVar3;
	int iVar4;
	int *piVar5;
	uint uVar6;
	Point2I local_28;
	int local_20 [8];
	
	uVar6 = 0;
	local_20[1] = 0xffffffff;
	local_20[6] = 0xffffffff;
	local_20[2] = 1;
	local_20[5] = 1;
	iVar2 = param_1[1];
	iVar3 = *param_1;
	local_20[0] = 0;
	local_20[3] = 0;
	local_20[4] = 0;
	local_20[7] = 0;
	piVar5 = local_20;
	do {
		iVar4 = (piVar5[1] + iVar2) * ((lego::globals::g_Game.level)->dimensions).width + iVar3 +
						*piVar5;
		if ((((*(byte *)&(lego::globals::g_Game.level)->blocks[iVar4].flags1 & 8) != 0) &&
				(TVar1 = (lego::globals::g_Game.level)->blocks[iVar4].terrain, TVar1 != TERRAIN_LAKE)) &&
			 (TVar1 != TERRAIN_LAVA)) break;
		uVar6 = uVar6 + 1;
		piVar5 = piVar5 + 2;
	} while (uVar6 < 4);
	if (uVar6 != 4) {
		local_28.y = local_20[uVar6 * 2 + 1] + iVar2;
		local_28.x = local_20[uVar6 * 2] + iVar3;
		TVar1 = (lego::globals::g_Game.level)->blocks
						[iVar2 * ((lego::globals::g_Game.level)->dimensions).width + iVar3].terrain;
		if (TVar1 == TERRAIN_ORESEAM) {
			lego::game::Level_GenerateOre(&local_28,0,(Point2F *)0x0,1);
			return;
		}
		if (TVar1 == TERRAIN_CRYSTALSEAM) {
			lego::game::Level_GenerateCrystal(&local_28,0,(Point2F *)0x0,1);
		}
	}
	return;
}



BOOL __cdecl lego::game::Level_DestroyWallConnection(LevelData *level,uint x,uint y)
{
	int *piVar1;
	Size2I *pSVar2;
	LevelBlock **ppLVar3;
	LevelBlockFlags1 *pLVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	int *piVar8;
	int iVar9;
	uint uVar10;
	Point2I local_28;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar6 = x;
	local_28.x = (int)level->surfaceMap;
	local_20[0] = -1;
	local_20[1] = 0xffffffff;
	local_20[2] = 0;
	local_20[3] = 0xffffffff;
	local_20[4] = 0;
	local_c = 0;
	local_8 = 0xffffffff;
	local_4 = 0;
	if ((((x != 0) && (y != 0)) && (iVar9 = (level->dimensions).width, x < iVar9 - 2U)) &&
		 (y < (level->dimensions).height - 2U)) {
		if (level->blocks[y * iVar9 + x].predug == PREDUG_WALL) {
			SurfaceMap_Unk_ChangeWallDepth((SurfaceMap *)local_28.x,x,y,level->DigDepth);
			iVar9 = 4;
			level->blocks[y * (level->dimensions).width + x].predug = PREDUG_EXPOSED;
			piVar8 = local_20 + 1;
			do {
				piVar1 = piVar8 + -1;
				iVar5 = *piVar8;
				piVar8 = piVar8 + 2;
				pLVar4 = &level->blocks[(y + iVar5) * (level->dimensions).width + *piVar1 + x].flags1;
				iVar9 = iVar9 + -1;
				*pLVar4 = *pLVar4 | 0x40000;
			} while (iVar9 != 0);
			for (uVar7 = y - 1; uVar7 <= y; uVar7 = uVar7 + 1) {
				for (uVar10 = x - 1; uVar10 <= x; uVar10 = uVar10 + 1) {
					Level_UpdateBlockSurfaceUnk(level,uVar10,uVar7);
				}
			}
			uVar7 = y - 1;
			if (uVar7 <= y + 1) {
				do {
					uVar10 = x - 1;
					if (uVar10 <= x + 1) {
						do {
							SurfaceMap_FUN_0044f270((SurfaceMap *)local_28.x,uVar10,uVar7);
							uVar10 = uVar10 + 1;
						} while (uVar10 <= x + 1);
					}
					uVar7 = uVar7 + 1;
				} while (uVar7 <= y + 1);
			}
			pSVar2 = &level->dimensions;
			ppLVar3 = &level->blocks;
			uVar7 = 0;
			local_20[2] = 1;
			local_c = 1;
			local_28.x = x;
			local_28.y = y;
			level = (LevelData *)0x0;
			local_20[0] = 0;
			local_20[1] = 0xffffffff;
			local_20[3] = 0;
			local_20[4] = 0;
			local_8 = 0xffffffff;
			local_4 = 0;
			piVar8 = local_20;
			do {
				if ((*ppLVar3)[(piVar8[1] + y) * pSVar2->width + uVar6 + *piVar8].predug == PREDUG_EXPOSED)
				{
					level = (LevelData *)((int)&level->levelName + 1);
					x = uVar7;
				}
				uVar7 = uVar7 + 1;
				piVar8 = piVar8 + 2;
			} while (uVar7 < 4);
			if (level == (LevelData *)0x1) {
				Level_AddMessageAction(MESSAGE_DIG_COMPLETE,0,x - 2 & 3 | 0x10000,&local_28);
			}
			FUN_00402a10(&local_28,1);
		}
		return 1;
	}
	return 0;
}



void __cdecl lego::game::Block_RemoveReinforcement(Point2I *blockPos)
{
	LevelData *level;
	int iVar1;
	
	level = globals::g_Game.level;
	Level_FUN_00431380(globals::g_Game.level,blockPos,0);
	iVar1 = (level->dimensions).width * blockPos->y + blockPos->x;
	level->blocks[iVar1].flags1 = level->blocks[iVar1].flags1 & ~BLOCK1_REINFORCED;
	Level_UpdateBlockSurfaceUnk(level,blockPos->x,blockPos->y);
	return;
}



void __cdecl FUN_00431070(int x,int y)
{
	LevelBlockFlags1 *pLVar1;
	LevelBlockFlags1 LVar2;
	LevelData *level;
	Point2I point;
	
	level = lego::globals::g_Game.level;
	pLVar1 = &(lego::globals::g_Game.level)->blocks
						[((lego::globals::g_Game.level)->dimensions).width * y + x].flags1;
	LVar2 = *pLVar1;
	if (((LVar2 & BLOCK1_UNK_10) != BLOCK1_NONE) &&
		 ((LVar2 & (BLOCK1_REINFORCED|BLOCK1_UNK_40|BLOCK1_UNK_80)) == BLOCK1_NONE)) {
		*pLVar1 = LVar2 | BLOCK1_REINFORCED;
		lego::game::Level_UpdateBlockSurfaceUnk(level,x,y);
		point.x = x;
		point.y = y;
		lego::res::Res_Unk_RechargeSparkle(level,&point,0);
		FUN_00402a60(&point);
		lego::front::Info_FUN_00419ab0(INFO_WALLREINFORCED,(char *)0x0,(LiveObject *)0x0,&point);
	}
	return;
}



void __cdecl lego::res::Res_Unk_RechargeSparkle(LevelData *level,Point2I *position,BOOL param_3)
{
	int iVar1;
	LevelStruct_1c *pLVar2;
	Container *pCVar3;
	uint uVar4;
	LevelStruct_1c *pLVar5;
	float10 fVar6;
	float local_3c;
	float local_38;
	float local_34;
	float local_30 [4];
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	pCVar3 = globals::g_Game.RES_RechargeSparkle;
	iVar1 = position->y * (level->dimensions).width + position->x;
	local_30[0] = 0.0;
	local_30[1] = 1.0;
	local_30[2] = 0.0;
	uVar4 = (uint)level->blocks[iVar1].field_3;
	local_30[3] = 1.0;
	local_20 = 0;
	local_1c = 0;
	local_18 = 0;
	local_14 = 0xbf800000;
	local_10 = 0;
	local_c = 0xbf800000;
	local_8 = 0;
	local_4 = 0;
	if (param_3 != 0) {
		pLVar2 = level->blocks[iVar1].struct1c_18;
		if (pLVar2 == (LevelStruct_1c *)0x0) {
			pLVar2 = (LevelStruct_1c *)std::malloc(0x1c);
			pLVar5 = pLVar2;
			for (iVar1 = 7; iVar1 != 0; iVar1 = iVar1 + -1) {
				pLVar5->resData = (Container *)0x0;
				pLVar5 = (LevelStruct_1c *)&pLVar5->position;
			}
			pLVar2->bool_18 = param_3;
			pCVar3 = Container_Clone(pCVar3);
			pLVar2->resData = pCVar3;
			if (pLVar2->bool_18 == 0) {
				Container_SetActivity(pCVar3,"Activity_Build");
			}
			Container_SetAnimationTime(pLVar2->resData,0.0);
			(pLVar2->position).x = position->x;
			*(int *)&pLVar2->position = position->y;
			pLVar2->next = (LevelStruct_1c *)0x0;
			pLVar5 = level->terrain1c_88;
			pLVar2->previous = pLVar5;
			if (pLVar5 != (LevelStruct_1c *)0x0) {
				pLVar5->next = pLVar2;
			}
			level->terrain1c_88 = pLVar2;
			level->blocks[position->y * (level->dimensions).width + position->x].struct1c_18 = pLVar2;
		}
		game::SurfaceMap_FUN_0044f900(level->surfaceMap,position->x,position->y,&local_3c,&local_38);
		fVar6 = game::SurfaceMap_GetSurfaceZ(level->surfaceMap,local_3c,local_38);
		local_34 = (float)fVar6;
		Container_SetPosition(pLVar2->resData,(Container *)0x0,local_3c,local_38,local_34);
		Container_SetOrientation
							(pLVar2->resData,(Container *)0x0,local_30[uVar4 * 3],local_30[uVar4 * 3 + 1],
							 local_30[uVar4 * 3 + 2],0.0,0.0,-1.0);
	}
	return;
}



void __cdecl lego::game::Level_FUN_004312e0(LevelData *level,float elapsedGame)
{
	byte bVar1;
	LevelStruct_1c *pLVar2;
	LevelStruct_1c *pLVar3;
	float10 fVar4;
	
	pLVar2 = level->terrain1c_88;
	while (pLVar3 = pLVar2, pLVar3 != (LevelStruct_1c *)0x0) {
		pLVar2 = pLVar3->previous;
		fVar4 = res::Container_MoveAnimation(pLVar3->resData,elapsedGame);
		if (pLVar3->bool_18 == 0) {
			bVar1 = *(byte *)&pLVar3->field_c;
			if (((bVar1 & 1) == 0) && ((float)fVar4 != 0.0)) {
				*(byte *)&pLVar3->field_c = bVar1 | 1;
				res::Container_SetActivity(pLVar3->resData,"Activity_Stand");
			}
			else {
				if ((bVar1 & 2) == 0) {
					if (((bVar1 & 4) != 0) && ((float)fVar4 != 0.0)) {
						*(byte *)&pLVar3->field_c = bVar1 | 2;
					}
				}
				else {
					FUN_004313f0((int **)pLVar3);
				}
			}
		}
	}
	return;
}



void __cdecl lego::game::Level_FUN_00431380(LevelData *level,Point2I *blockPos,BOOL param_3)
{
	LevelStruct_1c *pLVar1;
	
	pLVar1 = level->blocks[(level->dimensions).width * blockPos->y + blockPos->x].struct1c_18;
	if (pLVar1 != (LevelStruct_1c *)0x0) {
		if ((param_3 == 0) && (pLVar1->bool_18 == 0)) {
			res::Container_SetActivity(pLVar1->resData,"Activity_Destroy");
			res::Container_SetAnimationTime(pLVar1->resData,0.0);
			*(byte *)&pLVar1->field_c = *(byte *)&pLVar1->field_c | 4;
			return;
		}
		*(byte *)&pLVar1->field_c = *(byte *)&pLVar1->field_c | 2;
	}
	return;
}



void __cdecl FUN_004313f0(int **param_1)
{
	LevelData *pLVar1;
	
	pLVar1 = lego::globals::g_Game.level;
	lego::res::Container_Remove((Container *)*param_1);
	pLVar1->blocks[(int)((int)param_1[2] * (pLVar1->dimensions).width + (int)param_1[1])].struct1c_18
			 = (LevelStruct_1c *)0x0;
	if (param_1[4] == (int *)0x0) {
		pLVar1->terrain1c_88 = (LevelStruct_1c *)param_1[5];
	}
	else {
		param_1[4][5] = (int)param_1[5];
	}
	if (param_1[5] != (int *)0x0) {
		param_1[5][4] = (int)param_1[4];
	}
	std::free(param_1);
	return;
}



void __cdecl FUN_00431460(int param_1)
{
	int **ppiVar1;
	int **ppiVar2;
	
	ppiVar2 = *(int ***)(param_1 + 0x88);
	while (ppiVar2 != (int **)0x0) {
		ppiVar1 = (int **)ppiVar2[5];
		FUN_004313f0(ppiVar2);
		ppiVar2 = ppiVar1;
	}
	return;
}



LevelData * __cdecl lego::game::GetLevel(void)
{
	return globals::g_Game.level;
}



SurfaceMap * __cdecl lego::game::GetSurfaceMap(void)
{
	LevelData *pLVar1;
	
	pLVar1 = GetLevel();
	return pLVar1->surfaceMap;
}



void __cdecl FUN_004314b0(uint *param_1,uint param_2)
{
	int iVar1;
	float fVar2;
	float fVar3;
	uint uVar4;
	int in_x;
	LevelData *level;
	float *pfVar5;
	int iVar6;
	int iVar7;
	uint uVar8;
	uint uVar9;
	int iVar10;
	float *pfVar11;
	longlong lVar12;
	uint local_2c;
	uint local_10 [2];
	float *local_8 [2];
	
	level = lego::globals::g_Game.level;
	iVar10 = ((lego::globals::g_Game.level)->dimensions).height +
					 ((lego::globals::g_Game.level)->dimensions).width;
	local_10[0] = 0;
	local_10[1] = 0;
	uVar9 = 0;
	pfVar5 = (float *)std::malloc(iVar10 * 0x20);
	local_8[0] = pfVar5;
	if (pfVar5 != (float *)0x0) {
		local_8[1] = pfVar5 + iVar10 * 4;
		*pfVar5 = (float)ZEXT48(param_1);
		param_1 = local_10;
		local_10[0] = 1;
		iVar10 = 0;
		pfVar5[1] = (float)(ulonglong)param_2;
		do {
			local_2c = 0;
			if (*param_1 != 0) {
				pfVar11 = *(float **)((int)local_8 + iVar10);
				do {
					fVar2 = pfVar11[1];
					fVar3 = *pfVar11;
					lVar12 = __ftol((float10)fVar2);
					iVar10 = (int)lVar12 + -1;
					iVar6 = (int)lVar12 + 1;
					if (iVar10 <= iVar6) {
						lVar12 = __ftol((float10)fVar3);
						iVar1 = (int)lVar12 + -1;
						in_x = iVar1;
						do {
							for (; in_x <= (int)lVar12 + 1; in_x = in_x + 1) {
								if ((level->blocks[iVar10 * (level->dimensions).width + in_x].flags1 & BLOCK1_HIDDEN
										) != BLOCK1_NONE) {
									lego::game::Level_DestroyWall(level,in_x,iVar10,1);
									iVar7 = iVar10 * (level->dimensions).width + in_x;
									level->blocks[iVar7].flags1 = level->blocks[iVar7].flags1 & ~BLOCK1_HIDDEN;
									if ((fVar3 != (float)in_x) || ((float)iVar10 != fVar2)) {
										uVar8 = (uint)(uVar9 == 0);
										uVar4 = local_10[uVar8];
										pfVar5 = local_8[uVar8];
										pfVar5[uVar4 * 2] = (float)in_x;
										local_10[uVar8] = uVar4 + 1;
										pfVar5[uVar4 * 2 + 1] = (float)iVar10;
									}
								}
							}
							iVar10 = iVar10 + 1;
							in_x = iVar1;
						} while (iVar10 <= iVar6);
					}
					local_2c = local_2c + 1;
					pfVar11 = pfVar11 + 2;
					pfVar5 = local_8[0];
				} while (local_2c < *param_1);
			}
			uVar9 = (uint)(uVar9 == 0);
			*param_1 = 0;
			iVar10 = uVar9 * 4;
			param_1 = local_10 + uVar9;
		} while (local_10[uVar9] != 0);
		std::free(pfVar5);
	}
	return;
}



void __cdecl FUN_004316b0(uint param_1,uint param_2,int param_3,float param_4)
{
	LevelBlockFlags1 *pLVar1;
	LevelBlock *pLVar2;
	int iVar3;
	BOOL BVar4;
	float *pfVar5;
	bool bVar6;
	float10 fVar7;
	float10 extraout_ST0;
	longlong lVar8;
	longlong lVar9;
	float fVar10;
	float fVar11;
	float local_40;
	undefined4 uStack60;
	uint local_38;
	float local_34;
	undefined4 uStack48;
	Vector3F local_2c;
	float local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uStack60 = 0;
	fVar7 = (float10)(ulonglong)param_2;
	uStack48 = 0;
	local_38 = 0;
	local_34 = (float)(ulonglong)param_1;
	pLVar2 = (lego::globals::g_Game.level)->blocks;
	iVar3 = ((lego::globals::g_Game.level)->dimensions).width;
	local_20[0] = 1.0;
	local_20[1] = 0.0;
	local_20[2] = 0.0;
	local_20[3] = 1.0;
	local_20[4] = -1.0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0xbf800000;
	pfVar5 = local_20;
	local_40 = 5.605194e-45;
	do {
		*pfVar5 = local_34 + *pfVar5;
		fVar11 = pfVar5[1];
		pfVar5[1] = (float)(fVar7 + (float10)fVar11);
		lVar8 = __ftol(fVar7 + (float10)fVar11);
		lVar9 = __ftol((float10)*pfVar5);
		if ((*(byte *)&pLVar2[iVar3 * (int)lVar8 + (int)lVar9].flags1 & 8) != 0) {
			local_38 = local_38 + 1;
		}
		pfVar5 = pfVar5 + 2;
		local_40 = (float)((int)local_40 + -1);
		fVar7 = extraout_ST0;
	} while (local_40 != 0.0);
	if (param_4 == 0.0) {
		lego::game::SurfaceMap_FUN_0044f900
							((lego::globals::g_Game.level)->surfaceMap,param_1,param_2,&local_40,&param_4);
	}
	else {
		lego::game::SurfaceMap_FUN_00450a90
							((lego::globals::g_Game.level)->surfaceMap,param_1,param_2,&local_40,&param_4,
							 &local_34);
	}
	local_2c.y = param_4;
	local_2c.x = local_40;
	fVar7 = lego::game::SurfaceMap_GetSurfaceZ
										((lego::globals::g_Game.level)->surfaceMap,local_40,param_4);
	local_2c.z = (float)fVar7;
	lego::res::Res_PlayResourceSound((Container *)0x0,SFX_ROCKBREAK,0,0,&local_2c);
	bVar6 = 1 < local_38;
	local_20[0] = 0.0;
	local_20[1] = 1.0;
	local_20[2] = 1.0;
	local_20[3] = 0.0;
	local_20[4] = 0.0;
	local_c = 0xbf800000;
	local_8 = 0xbf800000;
	local_4 = 0;
	fVar11 = local_20[param_3 * 2 + 1];
	fVar10 = local_20[param_3 * 2];
	fVar7 = lego::game::SurfaceMap_GetSurfaceZ
										((lego::globals::g_Game.level)->surfaceMap,local_40,param_4);
	BVar4 = FUN_0040c160((uint)bVar6,param_1,param_2,local_40,param_4,(float)fVar7,fVar10,fVar11);
	if (BVar4 != 0) {
		pLVar1 = &(lego::globals::g_Game.level)->blocks
							[((lego::globals::g_Game.level)->dimensions).width * param_2 + param_1].flags1;
		*pLVar1 = *pLVar1 | BLOCK1_UNK_800;
	}
	return;
}



SurfaceType __cdecl lego::game::Level_GetBlockTerrain(int bx,int by)
{
	return (uint)(globals::g_Game.level)->blocks
							 [((globals::g_Game.level)->dimensions).width * by + bx].terrain;
}



uint __cdecl lego::game::MapShared_GetBlock(uint sharedIndex,int x,int y)
{
	MapFileInfo *mapFile;
	int local_4;
	uint sharedIndex_00;
	
	sharedIndex_00 = sharedIndex;
	mapFile = (MapFileInfo *)lego::file::Mem_AddressHandle(sharedIndex);
	MapShared_GetDimensions(sharedIndex_00,(int *)&sharedIndex,&local_4);
	return (uint)mapFile->blocks[sharedIndex * y + x];
}



BOOL __cdecl FUN_00431960(uint x,uint y,BOOL param_3)
{
	LiveObject **ppLVar1;
	BOOL BVar2;
	uint local_8;
	uint numSelected;
	
	ppLVar1 = lego::game::Game_GetSelectedUnits((int *)&numSelected);
	if ((ppLVar1 != (LiveObject **)0x0) && (local_8 = 0, numSelected != 0)) {
		do {
			BVar2 = lego::game::LiveObject_FUN_004326a0(*ppLVar1,x,y,param_3,1);
			if (BVar2 != 0) {
				return 1;
			}
			local_8 = local_8 + 1;
			ppLVar1 = ppLVar1 + 1;
		} while (local_8 < numSelected);
		return 0;
	}
	return 0;
}



undefined4 __cdecl FUN_004319e0(uint param_1,uint param_2)
{
	LiveObject **ppLVar1;
	BOOL BVar2;
	uint uVar3;
	uint local_4;
	
	ppLVar1 = lego::game::Game_GetSelectedUnits((int *)&local_4);
	if ((ppLVar1 != (LiveObject **)0x0) && (uVar3 = 0, local_4 != 0)) {
		do {
			BVar2 = lego::game::LiveObject_FUN_00432950(*ppLVar1,param_1,param_2);
			if (BVar2 != 0) {
				return 1;
			}
			uVar3 = uVar3 + 1;
			ppLVar1 = ppLVar1 + 1;
		} while (uVar3 < local_4);
		return 0;
	}
	return 0;
}



undefined4 __cdecl FUN_00431a50(int param_1,int param_2,int param_3,int param_4)
{
	LevelBlock *pLVar1;
	LevelBlockFlags1 LVar2;
	int iVar3;
	BOOL BVar4;
	int *piVar5;
	uint uVar6;
	Point2I local_28;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_28.y = param_2;
	iVar3 = ((lego::globals::g_Game.level)->dimensions).width * param_2 + param_1;
	local_28.x = param_1;
	pLVar1 = (lego::globals::g_Game.level)->blocks + iVar3;
	if ((*(byte *)&(lego::globals::g_Game.level)->blocks[iVar3].flags2 & 0x20) == 0) {
		BVar4 = FUN_00408fd0(&local_28);
		if ((BVar4 == 0) && (LVar2 = pLVar1->flags1, (LVar2 & BLOCK1_POWERPATH) == BLOCK1_NONE)) {
			uVar6 = 0;
			if (((param_3 == 0) || ((param_4 == 0 || (pLVar1->terrain == TERRAIN_LAKE)))) &&
				 (((param_3 == 0 || ((LVar2 & BLOCK1_UNK_8000) == BLOCK1_NONE)) &&
					((((param_4 != 0 || (pLVar1->terrain != TERRAIN_LAKE)) &&
						(pLVar1->terrain != TERRAIN_LAVA)) &&
					 ((((LVar2 & BLOCK1_UNK_8) != BLOCK1_NONE && ((LVar2 & BLOCK1_UNK_200000) != BLOCK1_NONE))
						&& ((LVar2 & (BLOCK1_UNK_400|BLOCK1_UNK_8000|BLOCK1_UNK_100000)) == BLOCK1_NONE))))))))
			{
				BVar4 = FUN_0040e390(param_1,param_2);
				if (BVar4 == 0) {
					local_20[1] = 0xffffffff;
					local_8 = 0xffffffff;
					local_20[0] = 0;
					local_20[2] = 1;
					local_20[3] = 0;
					local_20[4] = 0;
					local_c = 1;
					local_4 = 0;
					piVar5 = local_20;
					while ((lego::globals::g_Game.level)->blocks
								 [(piVar5[1] + param_2) * ((lego::globals::g_Game.level)->dimensions).width +
									param_1 + *piVar5].terrain != TERRAIN_RECHARGESEAM) {
						uVar6 = uVar6 + 1;
						piVar5 = piVar5 + 2;
						if (3 < uVar6) {
							return 1;
						}
					}
				}
			}
		}
	}
	return 0;
}



undefined4 __cdecl FUN_00431ba0(int *param_1,int *param_2,int *param_3,int param_4)
{
	LevelBlockFlags1 LVar1;
	bool bVar2;
	int iVar3;
	LevelData *pLVar4;
	uint uVar5;
	uint local_24;
	int local_20 [4];
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_20[1] = 0xffffffff;
	local_8 = 0xffffffff;
	DAT_004df588 = DAT_004df588 + 1;
	local_20[0] = 0;
	local_20[2] = 1;
	local_20[3] = 0;
	local_10 = 0;
	local_c = 1;
	local_4 = 0;
	local_24 = 0;
	pLVar4 = lego::globals::g_Game.level;
	do {
		uVar5 = DAT_004df588 + local_24 & 3;
		if (param_4 == 0) {
LAB_00431c58:
			iVar3 = lego::game::LiveObject_FUN_00431cd0
												((LiveObject *)param_1,local_20[uVar5 * 2] + *param_2,
												 local_20[uVar5 * 2 + 1] + param_2[1],local_20[uVar5 * 2] + *param_2,
												 local_20[uVar5 * 2 + 1] + param_2[1],0);
			pLVar4 = lego::globals::g_Game.level;
			if (iVar3 != 0) {
				iVar3 = local_20[uVar5 * 2 + 1];
				*param_3 = local_20[uVar5 * 2] + *param_2;
				param_3[1] = iVar3 + param_2[1];
				return 1;
			}
		}
		else {
			iVar3 = (pLVar4->dimensions).width;
			if (((((uint)(local_20[uVar5 * 2] + *param_2) < iVar3 - 1U) &&
					 ((uint)(local_20[uVar5 * 2 + 1] + param_2[1]) < (pLVar4->dimensions).height - 1U)) &&
					(LVar1 = pLVar4->blocks
									 [(local_20[uVar5 * 2 + 1] + param_2[1]) * iVar3 + local_20[uVar5 * 2] + *param_2]
									 .flags1, (LVar1 & BLOCK1_UNK_10) != BLOCK1_NONE)) &&
				 ((LVar1 & BLOCK1_UNK_8) == BLOCK1_NONE)) {
				bVar2 = true;
			}
			else {
				bVar2 = false;
			}
			if (!bVar2) goto LAB_00431c58;
		}
		local_24 = local_24 + 1;
		if (3 < local_24) {
			return 0;
		}
	} while( true );
}



int __cdecl
lego::game::LiveObject_FUN_00431cd0
					(LiveObject *in_liveObj,int param_2,int param_3,int param_4,int param_5,BOOL param_6)
{
	int iVar1;
	LevelBlockFlags1 LVar2;
	LevelBlock *pLVar3;
	LevelData *pLVar4;
	LiveObject *liveObj;
	int iVar5;
	ObjectStatsFlags1 OVar6;
	int *piVar7;
	BOOL BVar8;
	int iVar9;
	ObjectStatsFlags1 OVar10;
	LevelBlockFlags1 LVar11;
	ObjectStatsFlags2 local_40;
	ObjectStatsFlags1 local_3c;
	ObjectStatsFlags3 local_38;
	ObjectStatsFlags1 local_34;
	int local_30;
	int local_2c;
	LevelBlock *local_28;
	LevelBlock *local_24;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	iVar5 = param_3;
	liveObj = in_liveObj;
	pLVar4 = globals::g_Game.level;
	iVar1 = ((globals::g_Game.level)->dimensions).width;
	OVar10 = STATS1_NONE;
	local_3c = STATS1_SINGLEWIDTHDIG;
	local_40 = STATS2_NONE;
	local_38 = STATS3_NONE;
	local_28 = (globals::g_Game.level)->blocks + param_3 * iVar1 + param_2;
	local_20[0] = 0;
	local_20[3] = 0;
	local_24 = (globals::g_Game.level)->blocks + param_5 * iVar1 + param_4;
	param_3 = 1;
	local_20[1] = 0xffffffff;
	local_20[2] = 1;
	local_20[4] = 0;
	local_c = 1;
	local_8 = 0xffffffff;
	local_4 = 0;
	if (((in_liveObj != (LiveObject *)0x0) &&
			(OVar6 = LiveObject_GetStatsFlags1(in_liveObj), (OVar6 & STATS1_CANBEDRIVEN) != STATS1_NONE))
		 && (in_liveObj->drivenObject == (LiveObject *)0x0)) {
		return 0;
	}
	in_liveObj = (LiveObject *)0x0;
	piVar7 = local_20 + 1;
	do {
		if ((piVar7[-1] + param_4 == param_2) && (param_5 + *piVar7 == iVar5)) break;
		piVar7 = piVar7 + 2;
		in_liveObj = (LiveObject *)((int)&in_liveObj->objType + 1);
	} while (in_liveObj < (LiveObject *)&DAT_00000004);
	if (liveObj == (LiveObject *)0x0) {
		local_34 = STATS1_NONE;
	}
	else {
		if (liveObj->objType == OBJECT_ELECTRICFENCE) {
			return 0;
		}
		local_38 = LiveObject_GetStatsFlags3(liveObj);
		local_38 = local_38 & STATS3_ENTERTOOLSTORE;
		local_34 = LiveObject_GetStatsFlags1(liveObj);
		local_34 = local_34 & STATS1_SINGLEWIDTHDIG;
		OVar10 = LiveObject_GetStatsFlags1(liveObj);
		OVar10 = OVar10 & STATS1_CROSSWATER;
		local_3c = LiveObject_GetStatsFlags1(liveObj);
		local_3c = local_3c & STATS1_CROSSLAND;
		local_40 = LiveObject_GetStatsFlags2(liveObj);
		local_40 = local_40 & STATS2_CROSSLAVA;
		if (((param_6 == 0) &&
				(BVar8 = LiveObject_GetBlockCoordinates(liveObj,&local_30,&local_2c), BVar8 != 0)) &&
			 ((param_2 == local_30 && (iVar5 == local_2c)))) {
			return 1;
		}
	}
	if (local_28->terrain == TERRAIN_LAKE) {
		if (OVar10 == STATS1_NONE) {
			return 0;
		}
	}
	else {
		if (local_3c == STATS1_NONE) {
			return 0;
		}
	}
	if (((local_28->terrain == TERRAIN_LAVA) && (local_40 == STATS2_NONE)) &&
		 ((local_28->flags1 & BLOCK1_UNK_200) == BLOCK1_NONE)) {
		return 0;
	}
	LVar2 = local_28->flags1;
	if ((LVar2 & BLOCK1_UNK_400) != BLOCK1_NONE) {
		return 0;
	}
	if ((param_6 != 0) && ((LVar2 & BLOCK1_UNK_40) != BLOCK1_NONE)) {
		return 0;
	}
	if ((local_38 == STATS3_NONE) && ((*(byte *)&local_28->flags2 & 4) != 0)) {
		return 0;
	}
	if (local_34 == STATS1_NONE) {
		if ((LVar2 & BLOCK1_UNK_8) == BLOCK1_NONE) {
			return 0;
		}
	}
	else {
		if ((LVar2 & BLOCK1_UNK_10) != BLOCK1_NONE) {
			param_3 = 3;
		}
		if (local_28->predug == PREDUG_WALL) {
			return 0;
		}
		iVar1 = (pLVar4->dimensions).width;
		pLVar3 = pLVar4->blocks;
		iVar9 = iVar5 * iVar1 + param_2;
		LVar11 = pLVar3[iVar9].flags1 & BLOCK1_UNK_10;
		if (LVar11 != BLOCK1_NONE) {
			if ((pLVar3 + iVar9)[-1].terrain == TERRAIN_LAVA) {
				return 0;
			}
			if (pLVar3[(iVar5 + -1) * iVar1 + param_2].terrain == TERRAIN_LAVA) {
				return 0;
			}
		}
		if (LVar11 != BLOCK1_NONE) {
			if ((pLVar3 + iVar9)[-1].terrain == TERRAIN_WATER_unused) {
				return 0;
			}
			if (pLVar3[(iVar5 + -1) * iVar1 + param_2].terrain == TERRAIN_WATER_unused) {
				return 0;
			}
		}
		if (in_liveObj == (LiveObject *)0x0) {
			if ((LVar2 & 0x2000) != BLOCK1_NONE) {
				param_3 = 2;
			}
			if ((local_24->flags1 & 0x2000) != BLOCK1_NONE) {
				param_3 = 2;
			}
		}
	}
	if ((param_4 != param_2) && (param_5 != iVar5)) {
		iVar1 = (pLVar4->dimensions).width;
		if (((*(byte *)&pLVar4->blocks[param_5 * iVar1 + param_2].flags1 & 8) != 0) &&
			 ((*(byte *)&pLVar4->blocks[iVar5 * iVar1 + param_4].flags1 & 8) != 0)) {
			return 2;
		}
	}
	return param_3;
}



void __cdecl FUN_00432030(int *param_1)
{
	LevelBlockFlags2 *pLVar1;
	LevelData *level;
	
	level = lego::globals::g_Game.level;
	pLVar1 = &(lego::globals::g_Game.level)->blocks
						[((lego::globals::g_Game.level)->dimensions).width * param_1[1] + *param_1].flags2;
	*pLVar1 = *pLVar1 | 0x100;
	lego::globals::g_Game.points2x100_78c[lego::globals::g_Game.pointsCount2_dcc[0]].x = *param_1;
	lego::globals::g_Game.points2x100_78c[lego::globals::g_Game.pointsCount2_dcc[0]].y = param_1[1];
	lego::globals::g_Game.pointsCount2_dcc[0] = lego::globals::g_Game.pointsCount2_dcc[0] + 1;
	lego::game::Level_UpdateBlockSurfaceUnk(level,*param_1,param_1[1]);
	return;
}



BOOL __cdecl lego::game::Level_BlockHasFlag2_100(Point2I *blockPos)
{
	return (globals::g_Game.level)->blocks
				 [blockPos->y * ((globals::g_Game.level)->dimensions).width + blockPos->x].flags2 & 0x100;
}



void __cdecl lego::game::Game_UpdateLevelBlocks_PointsAAC(void)
{
	int y;
	int x;
	LevelData *level;
	uint uVar1;
	Point2I (*paPVar2) [100];
	
	level = globals::g_Game.level;
	uVar1 = 0;
	if (globals::g_Game.pointsCount2_dcc[1] != 0) {
		paPVar2 = globals::g_Game.points2x100_78c[1];
		do {
			y = (*paPVar2)[0].y;
			x = (*paPVar2)[0].x;
			if ((*(byte *)((int)&level->blocks[(level->dimensions).width * y + x].flags2 + 1) & 1) == 0) {
				Level_UpdateBlockSurfaceUnk(level,x,y);
			}
			uVar1 = uVar1 + 1;
			paPVar2 = (Point2I (*) [100])(*paPVar2 + 1);
		} while (uVar1 < globals::g_Game.pointsCount2_dcc[1]);
	}
	globals::g_Game.pointsCount2_dcc[1] = 0;
	return;
}



void __cdecl lego::game::Game_LevelClearBlockFlag2_100_Points28C(void)
{
	LevelBlockFlags2 *pLVar1;
	Point2I *pPVar2;
	Point2I *pPVar3;
	Point2I (*paPVar4) [100];
	uint uVar5;
	LevelData *level;
	
	level = globals::g_Game.level;
	uVar5 = 0;
	globals::g_Game.pointsCount2_dcc[1] = globals::g_Game.pointsCount2_dcc[0];
	if (globals::g_Game.pointsCount2_dcc[0] != 0) {
		paPVar4 = globals::g_Game.points2x100_78c;
		do {
			paPVar4[1][0].x = (*paPVar4)[0].x;
			paPVar4[1][0].y = (*paPVar4)[0].y;
			pPVar2 = *paPVar4;
			pPVar3 = *paPVar4;
			paPVar4 = (Point2I (*) [100])(*paPVar4 + 1);
			pLVar1 = &level->blocks[pPVar2->y * (level->dimensions).width + pPVar3->x].flags2;
			uVar5 = uVar5 + 1;
			*pLVar1 = *pLVar1 & 0xfffffeff;
			globals::g_Game.pointsCount2_dcc[1] = globals::g_Game.pointsCount2_dcc[0];
		} while (uVar5 < globals::g_Game.pointsCount2_dcc[0]);
	}
	globals::g_Game.pointsCount2_dcc[0] = 0;
	return;
}



void __cdecl FUN_004321a0(int *param_1)
{
	LevelBlockFlags2 *pLVar1;
	
	pLVar1 = &(lego::globals::g_Game.level)->blocks
						[((lego::globals::g_Game.level)->dimensions).width * param_1[1] + *param_1].flags2;
	*pLVar1 = *pLVar1 | 2;
	lego::globals::g_Game.table200_468[lego::globals::g_Game.count_788 * 2] = *param_1;
	lego::globals::g_Game.table200_468[lego::globals::g_Game.count_788 * 2 + 1] = param_1[1];
	lego::globals::g_Game.count_788 = lego::globals::g_Game.count_788 + 1;
	return;
}



uint __cdecl FUN_00432200(int *param_1)
{
	return (lego::globals::g_Game.level)->blocks
				 [((lego::globals::g_Game.level)->dimensions).width * param_1[1] + *param_1].flags2 & 2;
}



void FUN_00432230(void)
{
	int *piVar1;
	LevelBlockFlags2 *pLVar2;
	int iVar3;
	LevelData *pLVar4;
	int *piVar5;
	uint uVar6;
	
	pLVar4 = lego::globals::g_Game.level;
	uVar6 = 0;
	if (lego::globals::g_Game.count_788 != 0) {
		piVar5 = lego::globals::g_Game.table200_468;
		do {
			piVar1 = piVar5 + 1;
			iVar3 = *piVar5;
			piVar5 = piVar5 + 2;
			pLVar2 = &pLVar4->blocks[*piVar1 * (pLVar4->dimensions).width + iVar3].flags2;
			uVar6 = uVar6 + 1;
			*pLVar2 = *pLVar2 & 0xfffffffd;
		} while (uVar6 < lego::globals::g_Game.count_788);
	}
	lego::globals::g_Game.count_788 = 0;
	return;
}



void __cdecl FUN_00432290(int **param_1)
{
	LevelBlockFlags1 *pLVar1;
	LevelBlockFlags2 *pLVar2;
	LevelData *level;
	
	level = lego::globals::g_Game.level;
	pLVar1 = &(lego::globals::g_Game.level)->blocks
						[(int)(((lego::globals::g_Game.level)->dimensions).width * (int)param_1[1] +
									(int)*param_1)].flags1;
	*pLVar1 = *pLVar1 & ~(BLOCK1_UNK_400|BLOCK1_UNK_8000|BLOCK1_UNK_100000|BLOCK1_POWERPATH);
	pLVar2 = &level->blocks[(int)((level->dimensions).width * (int)param_1[1] + (int)*param_1)].flags2
	;
	*pLVar2 = *pLVar2 & 0xfffffffb;
	lego::game::Level_UpdateBlockSurfaceUnk(level,(int)*param_1,(int)param_1[1]);
	return;
}



void __cdecl FUN_004322f0(int *param_1)
{
	LevelBlockFlags2 *pLVar1;
	
	pLVar1 = &(lego::globals::g_Game.level)->blocks
						[param_1[1] * ((lego::globals::g_Game.level)->dimensions).width + *param_1].flags2;
	*pLVar1 = *pLVar1 & 0xfffffffe;
	return;
}



void __cdecl FUN_00432320(int **param_1)
{
	LevelBlockFlags1 *pLVar1;
	LevelBlockFlags2 *pLVar2;
	LevelData *level;
	
	level = lego::globals::g_Game.level;
	pLVar1 = &(lego::globals::g_Game.level)->blocks
						[(int)(((lego::globals::g_Game.level)->dimensions).width * (int)param_1[1] +
									(int)*param_1)].flags1;
	*pLVar1 = *pLVar1 | (BLOCK1_UNK_8000|BLOCK1_UNK_100000);
	pLVar2 = &level->blocks[(int)((level->dimensions).width * (int)param_1[1] + (int)*param_1)].flags2
	;
	*pLVar2 = *pLVar2 | 4;
	lego::game::Level_UpdateBlockSurfaceUnk(level,(int)*param_1,(int)param_1[1]);
	return;
}



void __cdecl FUN_00432380(int *param_1,int *param_2)
{
	LevelBlockFlags1 *pLVar1;
	LevelData *level;
	
	level = lego::globals::g_Game.level;
	pLVar1 = &(lego::globals::g_Game.level)->blocks
						[(int)(((lego::globals::g_Game.level)->dimensions).width * (int)param_2 + (int)param_1)]
						.flags1;
	*pLVar1 = *pLVar1 | (BLOCK1_UNK_400|BLOCK1_UNK_100000);
	lego::game::Level_UpdateBlockSurfaceUnk(level,(int)param_1,(int)param_2);
	return;
}



void __cdecl FUN_004323c0(int *param_1,int *param_2)
{
	LevelBlockFlags1 *pLVar1;
	LevelData *level;
	
	level = lego::globals::g_Game.level;
	pLVar1 = &(lego::globals::g_Game.level)->blocks
						[(int)(((lego::globals::g_Game.level)->dimensions).width * (int)param_2 + (int)param_1)]
						.flags1;
	*pLVar1 = *pLVar1 | (BLOCK1_UNK_8000|BLOCK1_UNK_100000|BLOCK1_POWERPATH);
	lego::game::Level_UpdateBlockSurfaceUnk(level,(int)param_1,(int)param_2);
	return;
}



void __cdecl lego::game::Level_SetBlockFlag8(int x,int y,BOOL state)
{
	LevelBlockFlags2 *pLVar1;
	int iVar2;
	
	iVar2 = ((globals::g_Game.level)->dimensions).width;
	if (state != 0) {
		pLVar1 = &(globals::g_Game.level)->blocks[iVar2 * y + x].flags2;
		*pLVar1 = *pLVar1 | 8;
		return;
	}
	iVar2 = iVar2 * y + x;
	(globals::g_Game.level)->blocks[iVar2].flags2 =
			 (globals::g_Game.level)->blocks[iVar2].flags2 & 0xfffffff7;
	return;
}



uint __cdecl FUN_00432450(int param_1,int param_2)
{
	return (lego::globals::g_Game.level)->blocks
				 [((lego::globals::g_Game.level)->dimensions).width * param_2 + param_1].flags2 & 8;
}



undefined4 __cdecl lego::util::return_1(undefined4 param_1)
{
	return 1;
}



void __cdecl FUN_00432490(Point2I *position,int param_2)
{
	int iVar1;
	LevelData *level;
	LevelBlockFlags1 *pLVar2;
	LevelBlockFlags1 LVar3;
	
	level = lego::globals::g_Game.level;
	iVar1 = ((lego::globals::g_Game.level)->dimensions).width;
	if (param_2 == 0) {
		pLVar2 = &(lego::globals::g_Game.level)->blocks[iVar1 * position->y + position->x].flags1;
		LVar3 = *pLVar2 & ~BLOCK1_UNK_40000000;
	}
	else {
		pLVar2 = &(lego::globals::g_Game.level)->blocks[iVar1 * position->y + position->x].flags1;
		LVar3 = *pLVar2 | BLOCK1_UNK_40000000;
	}
	*pLVar2 = LVar3;
	lego::game::Level_UpdateBlockSurfaceUnk(level,position->x,position->y);
	return;
}



void __cdecl FUN_00432500(int *param_1)
{
	LevelBlockFlags2 *pLVar1;
	
	pLVar1 = &(lego::globals::g_Game.level)->blocks
						[param_1[1] * ((lego::globals::g_Game.level)->dimensions).width + *param_1].flags2;
	*pLVar1 = *pLVar1 | 1;
	return;
}



undefined4 __cdecl FUN_00432530(Point2I *param_1)
{
	LevelBlock *pLVar1;
	LevelBlockFlags1 LVar2;
	LevelData *level;
	int iVar3;
	int iVar4;
	int *piVar5;
	int local_28 [5];
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	level = lego::globals::g_Game.level;
	iVar3 = ((lego::globals::g_Game.level)->dimensions).width * param_1->y + param_1->x;
	pLVar1 = (lego::globals::g_Game.level)->blocks + iVar3;
	LVar2 = (lego::globals::g_Game.level)->blocks[iVar3].flags1;
	if (((LVar2 & BLOCK1_UNK_200000) != BLOCK1_NONE) && (pLVar1->terrain != TERRAIN_LAVA)) {
		local_28[0] = 0;
		local_28[1] = 0;
		local_28[2] = 0;
		local_28[3] = 0xffffffff;
		local_28[4] = 1;
		local_14 = 0;
		local_10 = 0;
		local_c = 1;
		local_8 = 0xffffffff;
		local_4 = 0;
		if ((LVar2 & BLOCK1_UNK_80000000) == BLOCK1_NONE) {
			pLVar1->flags1 = LVar2 | BLOCK1_POWERPATH;
		}
		else {
			FUN_0040ed80(param_1,0);
			level->blocks[(level->dimensions).width * param_1->y + param_1->x].field_7 = 0;
		}
		iVar3 = (level->dimensions).width * param_1->y + param_1->x;
		piVar5 = local_28;
		iVar4 = 5;
		level->blocks[iVar3].flags1 = level->blocks[iVar3].flags1 & ~BLOCK1_UNK_40000000;
		do {
			lego::game::Level_UpdateBlockSurfaceUnk(level,param_1->x + *piVar5,piVar5[1] + param_1->y);
			piVar5 = piVar5 + 2;
			iVar4 = iVar4 + -1;
		} while (iVar4 != 0);
		lego::game::Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
		return 1;
	}
	return 0;
}



void __cdecl FUN_00432640(Point2I *blockPosition,BOOL condition)
{
	LevelBlockFlags1 *pLVar1;
	int iVar2;
	
	iVar2 = ((lego::globals::g_Game.level)->dimensions).width;
	if (condition != 0) {
		pLVar1 = &(lego::globals::g_Game.level)->blocks[iVar2 * blockPosition->y + blockPosition->x].
							flags1;
		*pLVar1 = *pLVar1 | BLOCK1_UNK_80000;
		return;
	}
	iVar2 = iVar2 * blockPosition->y + blockPosition->x;
	(lego::globals::g_Game.level)->blocks[iVar2].flags1 =
			 (lego::globals::g_Game.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_80000;
	return;
}



BOOL __cdecl
lego::game::LiveObject_FUN_004326a0(LiveObject *liveObj,uint x,uint y,BOOL param_4,BOOL param_5)
{
	LevelBlock *pLVar1;
	TerrainType TVar2;
	int iVar3;
	LevelData *pLVar4;
	ObjectStatsFlags1 OVar5;
	int *piVar6;
	uint uVar7;
	float10 fVar8;
	int local_40 [5];
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	pLVar4 = globals::g_Game.level;
	pLVar1 = (globals::g_Game.level)->blocks + y * ((globals::g_Game.level)->dimensions).width + x;
	OVar5 = LiveObject_GetStatsFlags1(liveObj);
	if (((OVar5 & STATS1_CANBEDRIVEN) == STATS1_NONE) || (liveObj->drivenObject != (LiveObject *)0x0))
	{
		if ((param_4 != 0) &&
			 (OVar5 = LiveObject_GetStatsFlags1(liveObj), (OVar5 & STATS1_SINGLEWIDTHDIG) == STATS1_NONE))
		{
			return 0;
		}
		if (((((param_5 == 0) || ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE)) &&
				 ((*(byte *)&liveObj->flags3 & 2) != 0)) &&
				((fVar8 = LiveObject_GetDrillTimeType(liveObj,(uint)pLVar1->terrain), fVar8 != (float10)0.0
				 && (iVar3 = (pLVar4->dimensions).width, x < iVar3 - 2U)))) &&
			 (y < (pLVar4->dimensions).height - 2U)) {
			uVar7 = 0;
			if (param_4 == 0) {
				if ((((pLVar1->flags1 & BLOCK1_UNK_10) != BLOCK1_NONE) &&
						((pLVar1->flags1 & BLOCK1_UNK_40) == BLOCK1_NONE)) &&
					 ((TVar2 = pLVar1->terrain, TVar2 != TERRAIN_IMMOVABLE &&
						((TVar2 != TERRAIN_WATER_unused && (TVar2 != TERRAIN_RECHARGESEAM)))))) {
					return 1;
				}
			}
			else {
				if (pLVar1->predug == PREDUG_WALL) {
					local_40[2] = 1;
					local_2c = 1;
					local_20[0] = -1;
					local_20[1] = 0xffffffff;
					local_20[2] = 0;
					local_20[3] = 0xffffffff;
					local_20[4] = 0;
					local_c = 0;
					local_8 = 0xffffffff;
					local_4 = 0;
					local_40[0] = 0;
					local_40[1] = 0xffffffff;
					local_40[3] = 0;
					local_40[4] = 0;
					local_28 = 0xffffffff;
					local_24 = 0;
					piVar6 = local_40;
					do {
						if (pLVar4->blocks[(piVar6[1] + y) * iVar3 + x + *piVar6].predug != PREDUG_WALL) break;
						uVar7 = uVar7 + 1;
						piVar6 = piVar6 + 2;
					} while (uVar7 < 4);
					if (uVar7 < 4) {
						uVar7 = 0;
						piVar6 = local_20;
						do {
							TVar2 = pLVar4->blocks[(piVar6[1] + y) * iVar3 + x + *piVar6].terrain;
							if ((TVar2 != TERRAIN_IMMOVABLE) && (TVar2 != TERRAIN_WATER_unused)) break;
							uVar7 = uVar7 + 1;
							piVar6 = piVar6 + 2;
						} while (uVar7 < 4);
						if (uVar7 < 4) {
							return 1;
						}
					}
				}
			}
		}
	}
	return 0;
}



undefined4 __cdecl FUN_00432880(int param_1,uint param_2,uint param_3)
{
	TerrainType TVar1;
	LevelBlockFlags1 LVar2;
	int iVar3;
	
	if (((((*(uint *)(param_1 + 1000) & 0x8000) != 0) && (param_2 != 0)) && (param_3 != 0)) &&
		 ((iVar3 = ((lego::globals::g_Game.level)->dimensions).width, param_2 < iVar3 - 2U &&
			(param_3 < ((lego::globals::g_Game.level)->dimensions).height - 2U)))) {
		iVar3 = param_3 * iVar3 + param_2;
		LVar2 = (lego::globals::g_Game.level)->blocks[iVar3].flags1;
		if (((((LVar2 & BLOCK1_UNK_10) != BLOCK1_NONE) &&
				 (((LVar2 & BLOCK1_UNK_40) == BLOCK1_NONE &&
					(TVar1 = (lego::globals::g_Game.level)->blocks[iVar3].terrain, TVar1 != TERRAIN_IMMOVABLE)
					))) && (TVar1 != TERRAIN_RECHARGESEAM)) && (TVar1 != TERRAIN_WATER_unused)) {
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Level_BlockCheck_FUN_00432900(LiveObject *liveObj,uint bx,uint by)
{
	LevelData *pLVar1;
	BOOL BVar2;
	
	pLVar1 = globals::g_Game.level;
	BVar2 = SurfaceMap_IsInsideDimensions((globals::g_Game.level)->surfaceMap,bx,by);
	if ((BVar2 != 0) &&
		 ((*(byte *)&pLVar1->blocks[(pLVar1->dimensions).width * by + bx].flags1 & 8) != 0)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_00432950(LiveObject *liveObj,uint x,uint y)
{
	TerrainType TVar1;
	int iVar2;
	LevelBlockFlags1 LVar3;
	
	if (((((liveObj == (LiveObject *)0x0) || ((*(byte *)&liveObj->flags3 & 4) != 0)) && (x != 0)) &&
			((y != 0 && (iVar2 = ((globals::g_Game.level)->dimensions).width, x < iVar2 - 2U)))) &&
		 (y < ((globals::g_Game.level)->dimensions).height - 2U)) {
		LVar3 = (globals::g_Game.level)->blocks[y * iVar2 + x].flags1;
		if ((((LVar3 & BLOCK1_UNK_10) != BLOCK1_NONE) && ((LVar3 & BLOCK1_REINFORCED) == BLOCK1_NONE))
			 && ((TVar1 = (globals::g_Game.level)->blocks[y * iVar2 + x].terrain,
					 TVar1 != TERRAIN_RECHARGESEAM &&
					 ((TVar1 != TERRAIN_ORESEAM && (TVar1 != TERRAIN_CRYSTALSEAM)))))) {
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Level_BlockCheck_FUN_004329d0(int bx,int by,BOOL param_3)
{
	int iVar1;
	
	iVar1 = ((globals::g_Game.level)->dimensions).width;
	if (param_3 == 0) {
		return (globals::g_Game.level)->blocks[iVar1 * by + bx].flags1 & BLOCK1_UNK_400;
	}
	if ((((globals::g_Game.level)->blocks[iVar1 * by + bx].flags1 & BLOCK1_UNK_400) == BLOCK1_NONE) &&
		 ((*(byte *)&(globals::g_Game.level)->blocks[iVar1 * by + bx].flags2 & 4) == 0)) {
		return BLOCK1_NONE;
	}
	return BLOCK1_RUBBLE_LOW;
}



uint __cdecl FUN_00432a30(uint param_1,uint param_2)
{
	int iVar1;
	
	iVar1 = ((lego::globals::g_Game.level)->dimensions).width;
	if ((param_1 < iVar1 - 1U) && (param_2 < ((lego::globals::g_Game.level)->dimensions).height - 1U))
	{
		return (lego::globals::g_Game.level)->blocks[param_2 * iVar1 + param_1].flags1 & BLOCK1_UNK_800;
	}
	return BLOCK1_NONE;
}



BOOL __cdecl lego::game::Level_GetBlockFlags1_8(uint x,uint y)
{
	int iVar1;
	
	iVar1 = ((globals::g_Game.level)->dimensions).width;
	if ((x < iVar1 - 1U) && (y < ((globals::g_Game.level)->dimensions).height - 1U)) {
		return (globals::g_Game.level)->blocks[y * iVar1 + x].flags1 & BLOCK1_UNK_8;
	}
	return BLOCK1_NONE;
}



undefined4 __cdecl FUN_00432ac0(int param_1,int param_2)
{
	TerrainType TVar1;
	
	TVar1 = (lego::globals::g_Game.level)->blocks
					[((lego::globals::g_Game.level)->dimensions).width * param_2 + param_1].terrain;
	if (((TVar1 != TERRAIN_ORESEAM) && (TVar1 != TERRAIN_CRYSTALSEAM)) &&
		 (TVar1 != TERRAIN_RECHARGESEAM)) {
		return 0;
	}
	return 1;
}



BOOL __cdecl lego::game::Level_GetBlockFlags1_10Not8(uint x,uint y)
{
	int iVar1;
	LevelBlockFlags1 LVar2;
	
	iVar1 = ((globals::g_Game.level)->dimensions).width;
	if ((((x < iVar1 - 1U) && (y < ((globals::g_Game.level)->dimensions).height - 1U)) &&
			(LVar2 = (globals::g_Game.level)->blocks[y * iVar1 + x].flags1,
			(LVar2 & BLOCK1_UNK_10) != BLOCK1_NONE)) && ((LVar2 & BLOCK1_UNK_8) == BLOCK1_NONE)) {
		return 1;
	}
	return 0;
}



uint __cdecl FUN_00432b50(int param_1,int param_2)
{
	return (lego::globals::g_Game.level)->blocks
				 [((lego::globals::g_Game.level)->dimensions).width * param_2 + param_1].flags1 & 0x40000;
}



int __cdecl lego::game::Level_GetBlockRubbleLevel_OrFlag200000(Point2I *position)
{
	LevelBlockFlags1 LVar1;
	
	LVar1 = (globals::g_Game.level)->blocks
					[((globals::g_Game.level)->dimensions).width * position->y + position->x].flags1;
	if ((LVar1 & BLOCK1_UNK_200000) != BLOCK1_NONE) {
		return 0;
	}
	return (LVar1 & BLOCK1_RUBBLE_FULL) + BLOCK1_RUBBLE_LOW;
}



BOOL __cdecl FUN_00432bc0(Point2I *position)
{
	LevelBlock *pLVar1;
	LevelBlockFlags1 LVar2;
	LevelData *level;
	int iVar3;
	LevelBlockFlags1 LVar4;
	uint uVar5;
	float10 fVar6;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	level = lego::globals::g_Game.level;
	uVar5 = 1;
	iVar3 = ((lego::globals::g_Game.level)->dimensions).width * position->y + position->x;
	pLVar1 = (lego::globals::g_Game.level)->blocks + iVar3;
	LVar2 = (lego::globals::g_Game.level)->blocks[iVar3].flags1;
	LVar4 = LVar2 & BLOCK1_RUBBLE_FULL;
	if ((LVar2 & BLOCK1_UNK_200000) == BLOCK1_NONE) {
		if (LVar4 != BLOCK1_NONE) {
			pLVar1->flags1 = (LVar4 + ~BLOCK1_NONE ^ LVar2) & BLOCK1_RUBBLE_FULL ^ LVar2;
		}
		else {
			pLVar1->flags1 = LVar2 | BLOCK1_UNK_200000;
			FUN_00419820(position);
			FUN_0041cf10(position);
			FUN_00402a90(position,0);
			lego::game::SurfaceMap_FUN_0044f900
								(level->surfaceMap,position->x,position->y,&local_18,&local_14);
			fVar6 = lego::game::SurfaceMap_GetSurfaceZ(level->surfaceMap,local_18,local_14);
			local_10 = (float)fVar6;
			lego::math::Maths_Vector3DRandom(&local_c);
			local_c.z = 0.0;
			FUN_0040cc10(3,&local_18,(undefined4 *)&local_c);
		}
		uVar5 = (uint)(LVar4 == BLOCK1_NONE);
		lego::game::Level_UpdateBlockSurfaceUnk(level,position->x,position->y);
	}
	return uVar5;
}



BOOL __cdecl lego::game::Level_GetBlockFlags1_20(uint x,uint y)
{
	int iVar1;
	
	iVar1 = ((globals::g_Game.level)->dimensions).width;
	if ((x < iVar1 - 1U) && (y < ((globals::g_Game.level)->dimensions).height - 1U)) {
		return (globals::g_Game.level)->blocks[y * iVar1 + x].flags1 & BLOCK1_REINFORCED;
	}
	return BLOCK1_NONE;
}



uint __cdecl lego::game::Level_GetBlockFlags1_8000000(Point2I *position)
{
	return (globals::g_Game.level)->blocks
				 [position->y * ((globals::g_Game.level)->dimensions).width + position->x].flags1 &
				 BLOCK1_UNK_8000000;
}



void __cdecl lego::game::Level_SetBlockFlags1_8000000(Point2I *position,BOOL state)
{
	LevelBlockFlags1 *pLVar1;
	int iVar2;
	
	iVar2 = ((globals::g_Game.level)->dimensions).width;
	if (state != 0) {
		pLVar1 = &(globals::g_Game.level)->blocks[iVar2 * position->y + position->x].flags1;
		*pLVar1 = *pLVar1 | BLOCK1_UNK_8000000;
		return;
	}
	iVar2 = iVar2 * position->y + position->x;
	(globals::g_Game.level)->blocks[iVar2].flags1 =
			 (globals::g_Game.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_8000000;
	return;
}



BOOL __cdecl lego::game::Level_GetBlockFlags1_c0(int x,int y)
{
	if ((*(byte *)&(globals::g_Game.level)->blocks
								 [((globals::g_Game.level)->dimensions).width * y + x].flags1 & 0xc0) == 0) {
		return 0;
	}
	return 1;
}



BOOL __cdecl lego::game::Level_IsBlockExposed(Point2I *position)
{
	return (globals::g_Game.level)->blocks
				 [((globals::g_Game.level)->dimensions).width * position->y + position->x].flags1 &
				 BLOCK1_EXPOSED;
}



uint __cdecl lego::game::Level_IsBlockSolid(Point2I *position)
{
	return (uint)((globals::g_Game.level)->blocks
								[((globals::g_Game.level)->dimensions).width * position->y + position->x].terrain ==
							 TERRAIN_IMMOVABLE);
}



uint __cdecl lego::game::Level_IsBlockLava(Point2I *position)
{
	return (uint)((globals::g_Game.level)->blocks
								[position->y * ((globals::g_Game.level)->dimensions).width + position->x].terrain ==
							 TERRAIN_LAVA);
}



BOOL __cdecl FUN_00432e70(uint x,uint y)
{
	int iVar1;
	
	iVar1 = ((lego::globals::g_Game.level)->dimensions).width;
	if ((x < iVar1 - 1U) && (y < ((lego::globals::g_Game.level)->dimensions).height - 1U)) {
		return (uint)(((lego::globals::g_Game.level)->blocks[y * iVar1 + x].flags1 &
									(BLOCK1_UNK_8|BLOCK1_UNK_10)) == BLOCK1_NONE);
	}
	return 1;
}



BOOL __cdecl FUN_00432ec0(uint x,uint y)
{
	int iVar1;
	
	iVar1 = ((lego::globals::g_Game.level)->dimensions).width;
	if ((x < iVar1 - 1U) && (y < ((lego::globals::g_Game.level)->dimensions).height - 1U)) {
		return (lego::globals::g_Game.level)->blocks[y * iVar1 + x].flags1 & 4;
	}
	return BLOCK1_NONE;
}



uint __cdecl FUN_00432f00(int param_1,int param_2)
{
	return (lego::globals::g_Game.level)->blocks
				 [((lego::globals::g_Game.level)->dimensions).width * param_2 + param_1].flags1 & 0x2000;
}



uint __cdecl FUN_00432f30(int param_1,int param_2)
{
	return (lego::globals::g_Game.level)->blocks
				 [((lego::globals::g_Game.level)->dimensions).width * param_2 + param_1].flags1 &
				 BLOCK1_UNK_80;
}



uint __cdecl FUN_00432f60(int *param_1)
{
	return (lego::globals::g_Game.level)->blocks
				 [((lego::globals::g_Game.level)->dimensions).width * param_1[1] + *param_1].flags1 &
				 BLOCK1_UNK_8000;
}



uint __cdecl FUN_00432f90(int *param_1)
{
	return (lego::globals::g_Game.level)->blocks
				 [((lego::globals::g_Game.level)->dimensions).width * param_1[1] + *param_1].flags2 & 1;
}



BOOL __cdecl lego::game::Level_IsBlockPowerPath(Point2I *position)
{
	int iVar1;
	int iVar2;
	int iVar3;
	
	iVar1 = position->x;
	if ((((-1 < iVar1) && (iVar2 = position->y, -1 < iVar2)) &&
			(iVar3 = ((globals::g_Game.level)->dimensions).width, iVar1 < iVar3)) &&
		 (iVar2 < ((globals::g_Game.level)->dimensions).height)) {
		return (globals::g_Game.level)->blocks[iVar3 * iVar2 + iVar1].flags1 & BLOCK1_POWERPATH;
	}
	return BLOCK1_NONE;
}



BOOL __cdecl lego::game::Level_GetBlockFlags1_180000(Point2I *position)
{
	if (((globals::g_Game.level)->blocks
			 [position->y * ((globals::g_Game.level)->dimensions).width + position->x].flags1 &
			(BLOCK1_UNK_80000|BLOCK1_UNK_100000)) == BLOCK1_NONE) {
		return 0;
	}
	return 1;
}



void __cdecl FUN_00433050(int *param_1,int param_2)
{
	LevelBlockFlags1 *pLVar1;
	int iVar2;
	
	if (param_2 != 0) {
		pLVar1 = &(lego::globals::g_Game.level)->blocks
							[param_1[1] * ((lego::globals::g_Game.level)->dimensions).width + *param_1].flags1;
		*pLVar1 = *pLVar1 | 0x10000000;
		return;
	}
	iVar2 = param_1[1] * ((lego::globals::g_Game.level)->dimensions).width + *param_1;
	(lego::globals::g_Game.level)->blocks[iVar2].flags1 =
			 (lego::globals::g_Game.level)->blocks[iVar2].flags1 & 0xefffffff;
	return;
}



BOOL __cdecl
lego::game::LiveObject_UnkGetDamage
					(LiveObject *liveObj,int x,int y,float elapsed,float *optout_value)
{
	ObjectType OVar1;
	LevelData *pLVar2;
	ObjectStatsFlags1 OVar3;
	ObjectStatsFlags2 OVar4;
	uint weaponType;
	float10 fVar5;
	
	pLVar2 = globals::g_Game.level;
	OVar1 = liveObj->objType;
	if ((((((OVar1 != OBJECT_POWERCRYSTAL) && (OVar1 != OBJECT_ORE)) && (OVar1 != OBJECT_BOULDER)) &&
			 ((OVar1 != OBJECT_DYNAMITE && (OVar1 != OBJECT_ELECTRICFENCE)))) &&
			(((OVar1 != OBJECT_OOHSCARY && ((OVar1 != OBJECT_ELECTRICFENCESTUD && (OVar1 != OBJECT_PATH)))
				) && (OVar1 != OBJECT_PUSHER)))) &&
		 (((OVar1 != OBJECT_FREEZER && (OVar1 != OBJECT_ICECUBE)) && (OVar1 != OBJECT_LASERSHOT)))) {
		if ((liveObj->drivenObject != (LiveObject *)0x0) &&
			 (OVar3 = LiveObject_GetStatsFlags1(liveObj), (OVar3 & STATS1_CANBEDRIVEN) == STATS1_NONE)) {
			return 0;
		}
		if (((pLVar2->blocks[y * (pLVar2->dimensions).width + x].terrain == TERRAIN_LAVA) &&
				((pLVar2->blocks[y * (pLVar2->dimensions).width + x].flags1 & BLOCK1_UNK_200) == BLOCK1_NONE
				)) && (OVar4 = LiveObject_GetStatsFlags2(liveObj), (OVar4 & STATS2_CROSSLAVA) == STATS2_NONE
							)) {
			if (optout_value == (float *)0x0) {
				return 1;
			}
			*optout_value = elapsed;
			return 1;
		}
		if ((pLVar2->blocks[y * (pLVar2->dimensions).width + x].flags1 & BLOCK1_UNK_1000) != BLOCK1_NONE
			 ) {
			if (optout_value != (float *)0x0) {
				weaponType = tools::Weapon_GetWeaponTypeByName("RockFallIn");
				fVar5 = Weapon_GetDamageForLiveObject(weaponType,liveObj);
				*optout_value = (float)(fVar5 * (float10)elapsed);
			}
			return 1;
		}
	}
	return 0;
}



uint __cdecl FUN_004331f0(int param_1,int param_2)
{
	return (uint)(lego::globals::g_Game.level)->blocks
							 [((lego::globals::g_Game.level)->dimensions).width * param_2 + param_1].field_3;
}



void __cdecl FUN_00433220(uint param_1,uint param_2)
{
	int iVar1;
	
	iVar1 = ((lego::globals::g_Game.level)->dimensions).width;
	if ((param_1 < iVar1 - 1U) && (param_2 < ((lego::globals::g_Game.level)->dimensions).height - 1U))
	{
		iVar1 = param_2 * iVar1 + param_1;
		(lego::globals::g_Game.level)->blocks[iVar1].flags1 =
				 (lego::globals::g_Game.level)->blocks[iVar1].flags1 | 4;
	}
	return;
}



undefined4 __cdecl FUN_00433260(uint param_1,uint param_2,uint *param_3)
{
	int iVar1;
	
	iVar1 = ((lego::globals::g_Game.level)->dimensions).width;
	if ((param_1 < iVar1 - 1U) && (param_2 < ((lego::globals::g_Game.level)->dimensions).height - 1U))
	{
		*param_3 = (uint)(lego::globals::g_Game.level)->blocks[param_2 * iVar1 + param_1].terrain;
		return 1;
	}
	return 0;
}



void __cdecl lego::game::Level_FUN_004332b0(LevelData *level,uint x,uint y)
{
	int iVar1;
	float fVar2;
	int iVar3;
	Vector3F local_30;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	LevelBlockFlags1 block;
	LevelBlock *blocksGrid;
	
	if ((x < (level->dimensions).width - 1U) && (y < (level->dimensions).height - 1U)) {
		SurfaceMap_FillStruct30_FUN_00450390(level->surfaceMap,x,y,(undefined4 *)&local_30);
		iVar1 = (level->dimensions).width;
		blocksGrid = level->blocks;
		iVar3 = y * iVar1 + x;
		block = blocksGrid[iVar3].flags1;
		if ((block & BLOCK1_UNK_8) == BLOCK1_NONE) {
			if ((block & BLOCK1_UNK_10) == BLOCK1_NONE) {
				return;
			}
			if (blocksGrid[iVar3].predug == PREDUG_EXPOSED) {
				local_30.z = local_30.z - (level->DigDepth + level->RoofHeight);
			}
			if (blocksGrid[iVar3 + 1].predug == PREDUG_EXPOSED) {
				local_24.z = local_24.z - (level->DigDepth + level->RoofHeight);
			}
			iVar1 = (y + 1) * iVar1 + x;
			if (blocksGrid[iVar1 + 1].predug == PREDUG_EXPOSED) {
				local_18.z = local_18.z - (level->DigDepth + level->RoofHeight);
			}
			if (blocksGrid[iVar1].predug == PREDUG_EXPOSED) {
				local_c.z = local_c.z - (level->DigDepth + level->RoofHeight);
			}
		}
		else {
			fVar2 = level->DigDepth + level->RoofHeight;
			local_30.z = local_30.z - fVar2;
			local_24.z = local_24.z - fVar2;
			local_18.z = local_18.z - fVar2;
			local_c.z = local_c.z - fVar2;
		}
		FUN_004631e0(x,y,&local_30,&local_24,&local_18,&local_c);
	}
	return;
}



void __cdecl lego::game::MapShared_GetDimensions(uint sharedIndex,int *out_width,int *out_height)
{
	MapFileInfo *mapFile;
	
	mapFile = (MapFileInfo *)lego::file::Mem_AddressHandle(sharedIndex);
	*out_width = (mapFile->dimensions).width;
	*out_height = (mapFile->dimensions).height;
	return;
}



BOOL __cdecl lego::main::Main_Load_GraphicsSettings(void)
{
	char *pcVar1;
	int iVar2;
	BOOL3 BVar3;
	BOOL3 BVar4;
	BOOL3 BVar5;
	BOOL3 BVar6;
	BOOL3 BVar7;
	BOOL3 BVar8;
	GraphicsQuality renderQuality;
	float10 fVar9;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","fpclipblocks",0);
	pcVar1 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar1);
	if (pcVar1 == (char *)0x0) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","fpclipblocks",0);
		pcVar1 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar1);
	}
	fVar9 = std::atof(pcVar1);
	globals::g_Game.FPClipBlocks = (float)fVar9;
	if ((float10)0.0 != fVar9) {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","quality",0);
		pcVar1 = cfg::CFG_ReadString(globals::g_Game.LegoCfgRoot,pcVar1);
		if (pcVar1 != (char *)0x0) {
			iVar2 = std::_stricmp("gouraud",pcVar1);
			if (iVar2 == 0) {
				renderQuality = QUALITY_GOURAUD;
			}
			else {
				iVar2 = std::_stricmp("flat",pcVar1);
				if (iVar2 == 0) {
					renderQuality = QUALITY_FLAT;
				}
				else {
					iVar2 = std::_stricmp("wireframe",pcVar1);
					if (iVar2 != 0) {
						return 0;
					}
					renderQuality = QUALITY_WIREFRAME;
				}
			}
			globals::g_Game.Quality = renderQuality;
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","dither",0);
			BVar3 = cfg::CFG_ReadBool(globals::g_Game.LegoCfgRoot,pcVar1);
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","filter",0);
			BVar4 = cfg::CFG_ReadBool(globals::g_Game.LegoCfgRoot,pcVar1);
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","blend",0);
			BVar5 = cfg::CFG_ReadBool(globals::g_Game.LegoCfgRoot,pcVar1);
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","sort",0);
			BVar6 = cfg::CFG_ReadBool(globals::g_Game.LegoCfgRoot,pcVar1);
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","mipmap",0);
			BVar7 = cfg::CFG_ReadBool(globals::g_Game.LegoCfgRoot,pcVar1);
			pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","linearmipmap",0);
			BVar8 = cfg::CFG_ReadBool(globals::g_Game.LegoCfgRoot,pcVar1);
			Main_Setup3D(renderQuality,(uint)(BVar3 == BOOL3_TRUE),(uint)(BVar4 == BOOL3_TRUE),
									 (uint)(BVar7 == BOOL3_TRUE),(uint)(BVar8 == BOOL3_TRUE),
									 (uint)(BVar5 == BOOL3_TRUE),(uint)(BVar6 == BOOL3_TRUE));
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::main::Main_LoadLighting(void)
{
	char *pcVar1;
	BOOL BVar2;
	Container *opt_parent;
	float *pfVar3;
	float *pfVar4;
	float *pfVar5;
	float local_c;
	float local_8;
	float local_4;
	
	pfVar4 = &local_c;
	pfVar5 = &local_8;
	pfVar3 = &local_4;
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","topspotrgb",0);
	BVar2 = cfg::CFG_ReadRGBF(globals::g_Game.LegoCfgRoot,pcVar1,pfVar3,pfVar5,pfVar4);
	if (BVar2 == 0) {
		return 0;
	}
	globals::g_Game.resTopSpotlight =
			 res::Container_MakeLight
								 ((globals::g_Game.cameraMain)->resData3,D3DRMLIGHT_SPOT,local_4,local_8,local_c);
	if (globals::g_Game.resTopSpotlight == (Container *)0x0) {
		return 0;
	}
	res::Container_Light_SetSpotPenumbra(globals::g_Game.resTopSpotlight,0.85);
	res::Container_Light_SetSpotUmbra(globals::g_Game.resTopSpotlight,0.4);
	res::Container_SetPosition
						(globals::g_Game.resTopSpotlight,(globals::g_Game.cameraMain)->resData3,200.0,140.0,
						 -130.0);
	res::Container_SetOrientation
						(globals::g_Game.resTopSpotlight,(globals::g_Game.cameraMain)->resData3,-1.0,-0.8,0.75,
						 0.0,1.0,0.0);
	pfVar4 = &local_c;
	pfVar5 = &local_8;
	pfVar3 = &local_4;
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","trackspotrgb",0);
	BVar2 = cfg::CFG_ReadRGBF(globals::g_Game.LegoCfgRoot,pcVar1,pfVar3,pfVar5,pfVar4);
	if (BVar2 == 0) {
		return 0;
	}
	globals::g_Game.resTrackSpotlight =
			 res::Container_MakeLight
								 ((globals::g_Game.cameraRadar)->resData2,D3DRMLIGHT_SPOT,local_4,local_8,local_c);
	if (globals::g_Game.resTrackSpotlight == (Container *)0x0) {
		return 0;
	}
	res::Container_SetPosition(globals::g_Game.resTrackSpotlight,(Container *)0x0,0.0,0.0,-150.0);
	res::Container_SetOrientation
						(globals::g_Game.resTrackSpotlight,(Container *)0x0,0.0,0.0,1.0,0.0,1.0,0.0);
	pfVar4 = &local_c;
	pfVar5 = &local_8;
	pfVar3 = &local_4;
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","ambientrgb",0);
	BVar2 = cfg::CFG_ReadRGBF(globals::g_Game.LegoCfgRoot,pcVar1,pfVar3,pfVar5,pfVar4);
	if (BVar2 == 0) {
		return 0;
	}
	globals::g_Game.resAmbientLight =
			 res::Container_MakeLight(globals::g_Game.resRoot,D3DRMLIGHT_AMBIENT,local_4,local_8,local_c);
	pfVar5 = &local_c;
	if (globals::g_Game.resAmbientLight == (Container *)0x0) {
		return 0;
	}
	pfVar3 = &local_8;
	pfVar4 = &local_4;
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","fplightrgb",0);
	BVar2 = cfg::CFG_ReadRGBF(globals::g_Game.LegoCfgRoot,pcVar1,pfVar4,pfVar3,pfVar5);
	if (BVar2 == 0) {
		return 0;
	}
	globals::g_Game.resFPLight =
			 res::Container_MakeLight
								 ((globals::g_Game.cameraFP)->resData1,D3DRMLIGHT_POINT,local_4,local_8,local_c);
	pfVar5 = &local_c;
	if (globals::g_Game.resFPLight == (Container *)0x0) {
		return 0;
	}
	pfVar3 = &local_8;
	pfVar4 = &local_4;
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","fprotlightrgb",0);
	BVar2 = cfg::CFG_ReadRGBF(globals::g_Game.LegoCfgRoot,pcVar1,pfVar4,pfVar3,pfVar5);
	if (BVar2 == 0) {
		globals::g_Game.resFPRotLight = (Container *)0x0;
	}
	else {
		globals::g_Game.resFPRotLight =
				 res::Container_MakeLight
									 ((globals::g_Game.cameraFP)->resData1,D3DRMLIGHT_DIRECTIONAL,local_4,local_8,
										local_c);
	}
	globals::g_Game.resFPRotLightDefault =
			 res::Container_MakeLight
								 ((globals::g_Game.cameraFP)->resData1,D3DRMLIGHT_DIRECTIONAL,1.0,0.0,0.0);
	if (globals::g_Game.resFPRotLightDefault == (Container *)0x0) {
		return 0;
	}
	opt_parent = res::GetRoot();
	globals::g_Game.resRootLight = res::Container_Create(opt_parent);
	globals::g_Game.resRootSpotlight =
			 res::Container_MakeLight(globals::g_Game.resRootLight,D3DRMLIGHT_SPOT,1.0,1.0,1.0);
	if (globals::g_Game.resRootSpotlight == (Container *)0x0) {
		return 0;
	}
	light::InitLightEffects(globals::g_Game.resRootSpotlight,globals::g_Game.resRootLight,0.8,0.8,0.8)
	;
	res::Container_SetOrientation
						(globals::g_Game.resRootSpotlight,(Container *)0x0,0.0,0.0,1.0,0.0,1.0,0.0);
	res::Container_Light_SetSpotPenumbra(globals::g_Game.resRootSpotlight,0.85);
	res::Container_Light_SetSpotUmbra(globals::g_Game.resRootSpotlight,0.0);
	res::Container_Hide(globals::g_Game.resFPLight,1);
	if (globals::g_Game.resFPRotLight != (Container *)0x0) {
		res::Container_Hide(globals::g_Game.resFPRotLight,1);
	}
	res::Container_Hide(globals::g_Game.resTopSpotlight,1);
	res::Container_Hide(globals::g_Game.resTrackSpotlight,1);
	res::Container_Hide(globals::g_Game.resAmbientLight,1);
	res::Container_Hide(globals::g_Game.resRootSpotlight,1);
	res::Container_Hide(globals::g_Game.resFPRotLightDefault,1);
	res::Container_Light_SetSpotRange(globals::g_Game.resTopSpotlight,2000.0);
	res::Container_Light_SetSpotRange(globals::g_Game.resTrackSpotlight,2000.0);
	res::Container_Light_SetSpotRange(globals::g_Game.resRootSpotlight,2000.0);
	return 1;
}



BOOL __cdecl lego::game::Level_ToBlockCoordinatesNoZ(float in_x,float in_y,int *out_x,int *out_y)
{
	BOOL BVar1;
	
	BVar1 = SurfaceMap_ToBlockCoordinatesNoZ
										((globals::g_Game.level)->surfaceMap,in_x,in_y,out_x,out_y);
	return BVar1;
}



BOOL __cdecl lego::game::LiveObject_FUN_00433b40(LiveObject *liveObj,float param_2,int param_3)
{
	int iVar1;
	LevelBlockFlags1 LVar2;
	float fVar3;
	bool bVar4;
	short sVar5;
	ObjectStatsFlags1 OVar6;
	BOOL BVar7;
	int *piVar8;
	uint uVar9;
	ulonglong uVar10;
	float local_2c;
	int local_28;
	int local_24;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar9 = 0;
	local_20[0] = -1;
	local_20[1] = 0;
	local_20[2] = 1;
	local_20[3] = 0;
	local_20[4] = 0;
	local_c = 0xffffffff;
	local_8 = 0;
	local_4 = 1;
	OVar6 = LiveObject_GetStatsFlags1(liveObj);
	if (((((OVar6 & STATS1_RANDOMENTERWALL) != STATS1_NONE) && ((*(byte *)&liveObj->flags1 & 1) == 0))
			&& (BVar7 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj), BVar7 == 0)) &&
		 (param_2 != 0.0)) {
		local_2c = param_2;
		if ((ushort)((ushort)(param_2 < 300.0) << 8 | (ushort)(param_2 == 300.0) << 0xe) == 0) {
			local_2c = 300.0;
		}
		sVar5 = math::Maths_Rand();
		uVar10 = __ftol((float10)300.0 / (float10)local_2c);
		if ((int)((ulonglong)(uint)(int)sVar5 % (uVar10 & 0xffffffff)) == 0) {
			LiveObject_GetBlockCoordinates(liveObj,&local_24,&local_28);
			piVar8 = local_20;
			iVar1 = ((globals::g_Game.level)->dimensions).width;
			do {
				if ((((uint)(local_24 + *piVar8) < iVar1 - 1U) &&
						((uint)(piVar8[1] + local_28) < ((globals::g_Game.level)->dimensions).height - 1U)) &&
					 ((LVar2 = (globals::g_Game.level)->blocks
										 [(piVar8[1] + local_28) * iVar1 + local_24 + *piVar8].flags1,
						(LVar2 & BLOCK1_UNK_10) != BLOCK1_NONE && ((LVar2 & BLOCK1_UNK_8) == BLOCK1_NONE)))) {
					bVar4 = true;
				}
				else {
					bVar4 = false;
				}
				if (bVar4) {
					liveObj->health = -1.0;
					LiveObject_FUN_004499c0(liveObj);
					return 1;
				}
				uVar9 = uVar9 + 1;
				piVar8 = piVar8 + 2;
			} while (uVar9 < 4);
		}
	}
	if (((param_3 != 0) ||
			(OVar6 = LiveObject_GetStatsFlags1(liveObj), (OVar6 & STATS1_RANDOMMOVE) != STATS1_NONE)) &&
		 (((*(byte *)&liveObj->flags1 & 1) == 0 &&
			((BVar7 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj), BVar7 == 0 &&
			 (fVar3 = liveObj->stats->RandomMoveTime, param_2 != 0.0)))))) {
		local_2c = param_2;
		if ((ushort)((ushort)(param_2 < fVar3) << 8 | (ushort)(param_2 == fVar3) << 0xe) == 0) {
			local_2c = fVar3;
		}
		if (param_3 == 0) {
			sVar5 = math::Maths_Rand();
			uVar10 = __ftol((float10)fVar3 / (float10)local_2c);
			if ((int)((ulonglong)(uint)(int)sVar5 % (uVar10 & 0xffffffff)) != 0) {
				return 0;
			}
		}
		LiveObject_FUN_00444520(liveObj);
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::game::Level_Block_FUN_00433d60(int x,int y)
{
	SurfaceMap *surfMap;
	BOOL BVar1;
	
	if (((globals::g_Game.level)->blocks[((globals::g_Game.level)->dimensions).width * y + x].flags1 &
			0x100) == BLOCK1_NONE) {
		surfMap = GetSurfaceMap();
		BVar1 = SurfaceMap_FUN_0044eb20(surfMap,x,y);
		if (BVar1 != 0) {
			return 1;
		}
	}
	return 0;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

void __cdecl
FUN_00433db0(Container *resData,uint *param_2,uint param_3,float param_4,float param_5,float param_6
						,undefined4 param_7,float param_8,int param_9,float param_10,float param_11,
						float param_12,float param_13,float param_14,float param_15,float param_16,
						float param_17,int param_18,float param_19,float param_20,float param_21,int param_22,
						uint param_23,undefined4 param_24,float param_25,undefined4 param_26,float param_27,
						float param_28,float param_29,float param_30,float param_31)
{
	LevelBlockFlags1 *pLVar1;
	bool bVar2;
	LevelData *level;
	float fVar3;
	BOOL BVar4;
	uint uVar5;
	uint *puVar6;
	float *pfVar7;
	SurfaceMap *pSVar8;
	uint uVar9;
	int iVar10;
	float10 fVar11;
	longlong lVar12;
	float fStack7376;
	uint uStack7372;
	SurfaceMap *pSStack7368;
	uint uStack7364;
	float fStack7360;
	float fStack7356;
	float fStack7352;
	undefined4 uStack7348;
	float fStack7344;
	int iStack7340;
	float fStack7336;
	float fStack7332;
	float fStack7328;
	float fStack7324;
	float fStack7320;
	float fStack7316;
	float fStack7312;
	float fStack7308;
	int iStack7304;
	Vector3F VStack7300;
	int iStack7288;
	uint uStack7284;
	undefined4 uStack7280;
	float fStack7276;
	undefined4 uStack7272;
	float fStack7268;
	float fStack7264;
	Vector3F VStack7260;
	undefined4 auStack7248 [12];
	uint auStack7200 [600];
	float afStack4800 [1199];
	undefined4 uStack4;
	
	level = lego::globals::g_Game.level;
	uStack4 = 0x433dba;
	pSVar8 = (lego::globals::g_Game.level)->surfaceMap;
	fStack7332 = 0.0;
	pSStack7368 = pSVar8;
	fVar11 = lego::game::SurfaceMap_GetBlockSize(pSVar8);
	fStack7356 = (float)fVar11;
	lVar12 = __ftol((float10)(float)param_3 / (float10)fStack7356);
	iVar10 = (int)lVar12;
	iStack7340 = 0;
	lego::res::Container_GetPosition(resData,(Container *)0x0,&VStack7300);
	lego::game::SurfaceMap_ToBlockCoordinatesNoZ
						(pSVar8,VStack7300.x,VStack7300.y,&iStack7304,&iStack7288);
	lego::res::Container_GetOrientation(resData,(Container *)0x0,&VStack7260,(Vector3F *)0x0);
	fVar11 = lego::view::Viewport_GetField(lego::globals::g_Game.viewMain);
	fVar11 = (float10)fcos(fVar11 * (float10)1.4);
	fStack7344 = (float)fVar11;
	lego::view::Viewport_GetSize(lego::globals::g_Game.viewMain,(uint *)&fStack7376,&uStack7372);
	fStack7268 = (float)(ulonglong)(uint)fStack7376;
	uStack7348 = 0;
	fStack7264 = (float)(ulonglong)uStack7372;
	fStack7352 = (float)(iStack7304 - iVar10);
	uVar5 = iStack7288 - iVar10;
	fStack7360 = (float)(iStack7304 + iVar10);
	uStack7364 = iVar10 + iStack7288;
	if ((int)fStack7352 < 0) {
		fStack7352 = 0.0;
	}
	if ((int)uVar5 < 0) {
		uVar5 = 0;
	}
	if ((int)fStack7360 < 0) {
		fStack7360 = 0.0;
	}
	if ((int)uStack7364 < 0) {
		uStack7364 = 0;
	}
	iVar10 = (level->dimensions).width;
	if (iVar10 <= (int)fStack7360) {
		fStack7360 = (float)(iVar10 + -1);
	}
	iVar10 = (level->dimensions).height;
	if (iVar10 <= (int)uStack7364) {
		uStack7364 = iVar10 - 1;
	}
	fVar3 = fStack7352;
	uVar9 = uStack7364;
	uStack7372 = uVar5;
	if (uVar5 < uStack7364) {
		do {
			fStack7376 = fVar3;
			fVar3 = fStack7376;
			if ((uint)fStack7376 < (uint)fStack7360) {
				puVar6 = auStack7200 + iStack7340 * 2 + 1;
				pfVar7 = afStack4800 + (int)fStack7332 * 4 + 1;
				uStack7372 = uVar5;
				do {
					pSVar8 = pSStack7368;
					if ((*(byte *)&level->blocks[uVar5 * (level->dimensions).width + (int)fStack7376].flags1 &
							0x18) != 0) {
						lego::game::SurfaceMap_FUN_0044f900
											(pSStack7368,(uint)fStack7376,uVar5,&fStack7316,&fStack7312);
						fVar11 = lego::game::SurfaceMap_GetSurfaceZ(pSVar8,fStack7316,fStack7312);
						fStack7308 = (float)fVar11;
						fStack7328 = (float)((float10)fStack7316 - (float10)VStack7300.x);
						fStack7324 = (float)((float10)fStack7312 - (float10)VStack7300.y);
						fStack7320 = (float)(fVar11 - (float10)VStack7300.z);
						fVar11 = SQRT((fVar11 - (float10)VStack7300.z) * (float10)fStack7320 +
													((float10)fStack7312 - (float10)VStack7300.y) * (float10)fStack7324 +
													((float10)fStack7316 - (float10)VStack7300.x) * (float10)fStack7328);
						fStack7336 = (float)fVar11;
						uVar5 = uStack7372;
						if (fVar11 < (float10)(float)param_3) {
							fVar3 = 1.0 / fStack7336;
							fVar3 = fVar3 * fStack7320 * VStack7260.z +
											fVar3 * fStack7324 * VStack7260.y + fVar3 * fStack7328 * VStack7260.x;
							bVar2 = fStack7336 < (fVar3 - -2.0) * fStack7356;
							if (bVar2) {
								fVar3 = fStack7344 - -1.0;
							}
							if ((ushort)((ushort)(fVar3 < fStack7344) << 8 | (ushort)(fVar3 == fStack7344) << 0xe)
									== 0) {
								lego::game::SurfaceMap_FillStruct30_FUN_00450390
													(pSStack7368,(uint)fStack7376,uStack7372,auStack7248);
								fStack7276 = fStack7376;
								uStack7272 = 0;
								uStack7284 = uStack7372;
								uStack7280 = 0;
								pfVar7[-1] = (float)(ulonglong)(uint)fStack7376;
								*pfVar7 = (float)(ulonglong)uStack7372;
								pfVar7[1] = fStack7336;
								fVar11 = FUN_0040b3a0((int)auStack7248,(int)param_2,&fStack7268,(uint)bVar2);
								pfVar7[2] = (float)fVar11;
								uVar5 = uStack7372;
								if ((ushort)((ushort)(fVar11 < (float10)0.0) << 8 |
														(ushort)(fVar11 == (float10)0.0) << 0xe) == 0) {
									fStack7332 = (float)((int)fStack7332 + 1);
									pfVar7 = pfVar7 + 4;
								}
								else {
									puVar6[-1] = (uint)fStack7376;
									iStack7340 = iStack7340 + 1;
									*puVar6 = uStack7372;
									puVar6 = puVar6 + 2;
								}
							}
						}
					}
					fStack7376 = (float)((int)fStack7376 + 1);
					fVar3 = fStack7352;
					pSVar8 = pSStack7368;
					uVar9 = uStack7364;
				} while ((uint)fStack7376 < (uint)fStack7360);
			}
			uVar5 = uVar5 + 1;
			uStack7372 = uVar5;
		} while (uVar5 < uVar9);
	}
	fVar3 = fStack7332;
	std::qsort(afStack4800,(uint)fStack7332,0x10,lego::unk::Lego_CompareQsortUnk_FUN_00434380);
	pSStack7368 = (SurfaceMap *)0x0;
	if (fVar3 != 0.0) {
		pfVar7 = afStack4800 + 2;
		fStack7356 = fVar3;
		do {
			lVar12 = __ftol((float10)pfVar7[-2]);
			fVar3 = (float)lVar12;
			fStack7376 = fVar3;
			lVar12 = __ftol((float10)pfVar7[-1]);
			uStack7372 = (uint)lVar12;
			if (((uint)param_4 <= pSStack7368) || ((float)param_3 * 0.6666667 <= *pfVar7)) {
				pLVar1 = &level->blocks[uStack7372 * (level->dimensions).width + (int)fVar3].flags1;
				*pLVar1 = *pLVar1 & 0xfffffeff;
				lego::game::SurfaceMap_AddBlockCoord(pSVar8,(int)fStack7376,uStack7372);
				FUN_004637b0((int)fStack7376,uStack7372);
				if ((level->blocks[uStack7372 * (level->dimensions).width + (int)fStack7376].flags1 &
						BLOCK1_UNK_4000) != BLOCK1_NONE) {
					FUN_00465d80(level->blocks[uStack7372 * (level->dimensions).width + (int)fStack7376].
											 field_1c,0);
				}
			}
			else {
				fStack7344 = 1.0 - *pfVar7 / ((float)param_3 * 0.6666667);
				fStack7352 = fStack7344 * 0.7 - -0.3;
				if ((((byte)lego::globals::g_Game.flags1 & GAME1_WALLPROMESHES) == 0) ||
					 (BVar4 = lego::game::Level_FUN_004343b0
															(level,(uint)fVar3,uStack7372,fStack7344,(uint)fStack7352),
					 fVar3 = fStack7376, BVar4 == 0)) {
					lego::game::SurfaceMap_AddBlockCoord(pSVar8,(int)fVar3,uStack7372);
					FUN_004637b0((int)fStack7376,uStack7372);
					if ((level->blocks[uStack7372 * (level->dimensions).width + (int)fStack7376].flags1 &
							BLOCK1_UNK_4000) != BLOCK1_NONE) {
						FUN_00465d80(level->blocks[uStack7372 * (level->dimensions).width + (int)fStack7376].
												 field_1c,0);
					}
					iVar10 = uStack7372 * (level->dimensions).width + (int)fStack7376;
					level->blocks[iVar10].flags1 = level->blocks[iVar10].flags1 & 0xfffffeff;
				}
				else {
					pLVar1 = &level->blocks[uStack7372 * (level->dimensions).width + (int)fStack7376].flags1;
					*pLVar1 = *pLVar1 | 0x100;
					FUN_004637b0((int)fStack7376,uStack7372);
					pSStack7368 = (SurfaceMap *)((int)pSStack7368 + 1);
				}
			}
			pfVar7 = pfVar7 + 4;
			fStack7356 = (float)((int)fStack7356 + -1);
		} while (fStack7356 != 0.0);
	}
	if (iStack7340 != 0) {
		puVar6 = auStack7200;
		iVar10 = iStack7340;
		do {
			FUN_004637b0(*puVar6,puVar6[1]);
			puVar6 = puVar6 + 2;
			iVar10 = iVar10 + -1;
		} while (iVar10 != 0);
	}
	return;
}



int __cdecl lego::unk::Lego_CompareQsortUnk_FUN_00434380(int param_1,int param_2)
{
	if (*(float *)(param_1 + 0xc) < *(float *)(param_2 + 0xc)) {
		return 1;
	}
	if ((ushort)((ushort)(*(float *)(param_1 + 0xc) < *(float *)(param_2 + 0xc)) << 8 |
							(ushort)(*(float *)(param_1 + 0xc) == *(float *)(param_2 + 0xc)) << 0xe) == 0) {
		return -1;
	}
	return 0;
}



BOOL __cdecl
lego::game::Level_FUN_004343b0(LevelData *level,uint bx,uint by,undefined4 param_4,uint param_5)
{
	LevelBlock *pLVar1;
	SurfaceTexture SVar2;
	int iVar3;
	int iVar4;
	undefined4 local_30 [12];
	
	if (((*(byte *)&level->blocks[by * (level->dimensions).width + bx].flags1 & 0x18) != 0) &&
		 (SVar2 = level->blocks[by * (level->dimensions).width + bx].texture,
		 iVar3 = *(int *)(level->field_0x80 +
										 ((level->surfTextSize).width * (SVar2 & 0xf) + (uint)(SVar2 >> 4)) * 4),
		 iVar3 != 0)) {
		SurfaceMap_FillStruct30_FUN_00450390(level->surfaceMap,bx,by,local_30);
		iVar4 = by * (level->dimensions).width + bx;
		pLVar1 = level->blocks + iVar4;
		FUN_0040b7b0(iVar3,(int)local_30,(uint)pLVar1 & 0xffffff00 | (uint)pLVar1->texture,
								 param_5 & 0xffffff00 | (uint)level->blocks[iVar4].field_3,param_4,param_5);
		return 1;
	}
	return 0;
}



void __cdecl lego::game::Level_ForEachSurfText_FUN_00434460(void)
{
	int iVar1;
	LevelData *pLVar2;
	uint uVar3;
	
	pLVar2 = globals::g_Game.level;
	uVar3 = 0;
	if (((globals::g_Game.level)->surfTextSize).height * ((globals::g_Game.level)->surfTextSize).width
			!= 0) {
		do {
			iVar1 = *(int *)((int)(void *)pLVar2->field_0x80 + uVar3 * 4);
			if (iVar1 != 0) {
				Level_SurfText_FUN_0040b740((void *)pLVar2->field_0x80,iVar1);
			}
			uVar3 = uVar3 + 1;
		} while (uVar3 < (uint)((pLVar2->surfTextSize).height * (pLVar2->surfTextSize).width));
	}
	return;
}



BOOL __cdecl lego::game::Level_GetBlockUnkField14Test(int bx,int by,float param_3,float param_4)
{
	float fVar1;
	LevelData *pLVar2;
	int iVar3;
	
	pLVar2 = globals::g_Game.level;
	if ((param_3 != 0.0) &&
		 (iVar3 = by * ((globals::g_Game.level)->dimensions).width + bx,
		 (globals::g_Game.level)->blocks[iVar3].float_14 =
					param_4 / param_3 + (globals::g_Game.level)->blocks[iVar3].float_14,
		 fVar1 = pLVar2->blocks[by * (pLVar2->dimensions).width + bx].float_14,
		 (ushort)((ushort)(fVar1 < 1.0) << 8 | (ushort)(fVar1 == 1.0) << 0xe) == 0)) {
		return 1;
	}
	return 0;
}



void __cdecl lego::front::Panel_LoadPanels(CFGProperty *root,uint screenWidth,uint screenHeight)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *prop;
	BOOL BVar3;
	int yIn;
	int xIn;
	int yOut;
	int xOut;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	undefined4 *puVar8;
	PanelType panelType;
	char *stringParts [10];
	char buff [256];
	
	std::sprintf(buff,"Panels%ix%i",screenWidth,screenHeight);
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,buff,0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (prop == (CFGProperty *)0x0) {
			return;
		}
		BVar3 = Panel_GetPanelType(prop->key,&panelType);
		if (BVar3 != 0) {
			uVar4 = 0xffffffff;
			pcVar2 = prop->value;
			do {
				pcVar7 = pcVar2;
				if (uVar4 == 0) break;
				uVar4 = uVar4 - 1;
				pcVar7 = pcVar2 + 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar7;
			} while (cVar1 != '\0');
			uVar4 = ~uVar4;
			puVar6 = (undefined4 *)(pcVar7 + -uVar4);
			puVar8 = (undefined4 *)buff;
			for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
				*puVar8 = *puVar6;
				puVar6 = puVar6 + 1;
				puVar8 = puVar8 + 1;
			}
			for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
				*(undefined *)puVar8 = *(undefined *)puVar6;
				puVar6 = (undefined4 *)((int)puVar6 + 1);
				puVar8 = (undefined4 *)((int)puVar8 + 1);
			}
			util::Util_Tokenise(buff,stringParts,",");
			Panel_LoadImage(stringParts[0],panelType,4);
			yIn = std::atoi(stringParts[4]);
			xIn = std::atoi(stringParts[3]);
			yOut = std::atoi(stringParts[2]);
			xOut = std::atoi(stringParts[1]);
			Panel_SetArea(panelType,xOut,yOut,xIn,yIn);
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

void __cdecl lego::main::Main_LoadButtons(CFGProperty *root,int screenWidth,uint screenHeight)
{
	char *pcVar1;
	CFGProperty *prop;
	BOOL BVar2;
	int iVar3;
	int iVar4;
	char **ppcVar5;
	uint uVar6;
	int *piVar7;
	char **ppcVar8;
	CFGProperty *pCStack11756;
	int iStack11752;
	int iStack11748;
	uint uStack11744;
	int iStack11740;
	int aiStack11736 [12];
	char *pcStack11688;
	char *apcStack11684 [4];
	char *pcStack11668;
	char *pcStack11664;
	char *pcStack11660;
	char *pcStack11656;
	char acStack11648 [128];
	int aiStack11520 [288];
	uint auStack10368 [288];
	char *apcStack9216 [288];
	undefined auStack8064 [1152];
	undefined auStack6912 [1152];
	char *apcStack5760 [288];
	float afStack4608 [1151];
	undefined4 uStack4;
	
	uStack4 = 0x43464a;
	piVar7 = aiStack11736;
	aiStack11736[0] = 0;
	for (iVar4 = 0xb; piVar7 = piVar7 + 1, iVar4 != 0; iVar4 = iVar4 + -1) {
		*piVar7 = 0;
	}
	iStack11748 = 0;
	std::sprintf(acStack11648,"Buttons%ix%i",screenWidth,screenHeight);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,acStack11648,0);
	prop = cfg::CFG_GetChildren(root,pcVar1);
	if (prop != (CFGProperty *)0x0) {
		ppcVar5 = apcStack5760;
		do {
			BVar2 = front::Panel_GetPanelType(prop->key,(PanelType *)&pCStack11756);
			if (BVar2 != 0) {
				pcVar1 = std::_strdup(prop->value);
				*ppcVar5 = pcVar1;
				util::Util_Tokenise(pcVar1,&pcStack11688,",");
				BVar2 = front::Panel_GetButtonType((PanelType)pCStack11756,pcStack11688,&uStack11744);
				if (BVar2 != 0) {
					uVar6 = 0;
					ppcVar8 = apcStack11684;
					auStack10368[aiStack11736[(int)pCStack11756] + (int)pCStack11756 * 0x18] = uStack11744;
					do {
						iVar3 = std::_stricmp("NULL",*ppcVar8);
						iVar4 = aiStack11736[(int)pCStack11756] + ((int)&pCStack11756->fileData + uVar6) * 0x18;
						if (iVar3 == 0) {
							apcStack9216[iVar4] = (char *)0x0;
						}
						else {
							apcStack9216[iVar4] = *ppcVar8;
						}
						uVar6 = uVar6 + 0xc;
						ppcVar8 = ppcVar8 + 1;
					} while (uVar6 < 0x24);
					iStack11752 = std::atoi(apcStack11684[3]);
					afStack4608[(aiStack11736[(int)pCStack11756] + (int)pCStack11756 * 0x18) * 4] =
							 (float)iStack11752;
					iStack11752 = std::atoi(pcStack11668);
					afStack4608[(aiStack11736[(int)pCStack11756] + (int)pCStack11756 * 0x18) * 4 + 1] =
							 (float)iStack11752;
					iStack11752 = std::atoi(pcStack11664);
					afStack4608[(aiStack11736[(int)pCStack11756] + (int)pCStack11756 * 0x18) * 4 + 2] =
							 (float)iStack11752;
					iStack11752 = std::atoi(pcStack11660);
					afStack4608[(aiStack11736[(int)pCStack11756] + (int)pCStack11756 * 0x18) * 4 + 3] =
							 (float)iStack11752;
					BVar2 = front::ToolTip_GetType(pcStack11656,&iStack11740);
					iVar3 = aiStack11736[(int)pCStack11756];
					iVar4 = iVar3 + (int)pCStack11756 * 0x18;
					if (BVar2 == 0) {
						aiStack11520[iVar4] = 0;
					}
					else {
						aiStack11520[iVar4] = iStack11740;
					}
					aiStack11736[(int)pCStack11756] = iVar3 + 1;
					iStack11748 = iStack11748 + 1;
					ppcVar5 = ppcVar5 + 1;
				}
			}
			prop = cfg::CFG_NextFlat(prop);
		} while (prop != (CFGProperty *)0x0);
		do {
			pCStack11756 = prop;
			FUN_0045aef0((int)prop,aiStack11736[(int)prop],(int)(auStack10368 + (int)prop * 0x18),
									 (int)(afStack4608 + (int)prop * 0x60),(int *)(apcStack9216 + (int)prop * 0x18),
									 (int)(auStack8064 + (int)prop * 0x60),(int)(auStack6912 + (int)prop * 0x60),
									 (int)(aiStack11520 + (int)prop * 0x18));
			prop = (CFGProperty *)((int)&pCStack11756->fileData + 1);
		} while (prop < (CFGProperty *)&DAT_0000000c);
		if (iStack11748 != 0) {
			ppcVar5 = apcStack5760;
			iVar4 = iStack11748;
			pCStack11756 = prop;
			do {
				std::free(*ppcVar5);
				ppcVar5 = ppcVar5 + 1;
				iVar4 = iVar4 + -1;
			} while (iVar4 != 0);
		}
	}
	return;
}



void __cdecl lego::main::Main_LoadTutorialIcon(CFGProperty *root)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","TutorialIcon",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		globals::g_Game.TutorialIcon = image::Image_LoadBMPScaled(pcVar1,0,0);
		if (globals::g_Game.TutorialIcon != (ImageBMP *)0x0) {
			image::Image_SetPenZeroTrans(globals::g_Game.TutorialIcon);
		}
	}
	return;
}



void __cdecl lego::main::Boot_Load_Samples(CFGProperty *root,BOOL noReduceSamples)
{
	bool bVar1;
	char *pcVar2;
	CFGProperty *prop;
	BOOL BVar3;
	SFXType local_4;
	
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Samples",0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	if (prop != (CFGProperty *)0x0) {
		snd::Audio_SetAudioFlag2(1);
		do {
			pcVar2 = prop->key;
			bVar1 = false;
			if ((*pcVar2 == '!') && (pcVar2 = pcVar2 + 1, noReduceSamples == 0)) {
				bVar1 = true;
			}
			if (!bVar1) {
				BVar3 = snd::SFX_GetType(pcVar2,&local_4);
				if (BVar3 != 0) {
					snd::Sample_LoadProperty(prop->value,local_4);
				}
			}
			prop = cfg::CFG_NextFlat(prop);
		} while (prop != (CFGProperty *)0x0);
		snd::Audio_SetAudioFlag2(0);
	}
	return;
}



void __cdecl lego::main::Main_LoadTextMessages(CFGProperty *root)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	undefined4 *puVar9;
	TextType local_22c;
	char *stringParts [10];
	char buffer [512];
	
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"TextMessages",0);
	for (pCVar3 = cfg::CFG_GetChildren(root,pcVar2); pCVar3 != (CFGProperty *)0x0;
			pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		BVar4 = front::Text_GetTextType(pCVar3->key,&local_22c);
		if (BVar4 != 0) {
			front::Text_SetMessage(local_22c,pCVar3->value);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"TextMessagesWithImages",0);
	pCVar3 = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (pCVar3 == (CFGProperty *)0x0) {
			return;
		}
		BVar4 = front::Text_GetTextType(pCVar3->key,&local_22c);
		if (BVar4 != 0) {
			uVar5 = 0xffffffff;
			pcVar2 = pCVar3->value;
			do {
				pcVar8 = pcVar2;
				if (uVar5 == 0) break;
				uVar5 = uVar5 - 1;
				pcVar8 = pcVar2 + 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar8;
			} while (cVar1 != '\0');
			uVar5 = ~uVar5;
			puVar7 = (undefined4 *)(pcVar8 + -uVar5);
			puVar9 = (undefined4 *)buffer;
			for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
				*puVar9 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar9 = puVar9 + 1;
			}
			for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
				*(undefined *)puVar9 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar9 = (undefined4 *)((int)puVar9 + 1);
			}
			util::Util_Tokenise(buffer,stringParts,":");
			front::Text_SetMessageWithImage(local_22c,stringParts[0],stringParts[1],stringParts[2]);
		}
		pCVar3 = cfg::CFG_NextFlat(pCVar3);
	} while( true );
}



void __cdecl lego::front::Info_LoadInfoMessages(CFGProperty *root)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *prop;
	BOOL BVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	undefined4 *puVar9;
	InfoType infoType;
	SFXType sfxType;
	char *stringParts [10];
	char buffer [1024];
	
	pcVar2 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"InfoMessages",0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (prop == (CFGProperty *)0x0) {
			return;
		}
		BVar3 = Info_GetInfoType(prop->key,&infoType);
		if (BVar3 != 0) {
			uVar5 = 0xffffffff;
			pcVar2 = prop->value;
			do {
				pcVar8 = pcVar2;
				if (uVar5 == 0) break;
				uVar5 = uVar5 - 1;
				pcVar8 = pcVar2 + 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar8;
			} while (cVar1 != '\0');
			uVar5 = ~uVar5;
			puVar7 = (undefined4 *)(pcVar8 + -uVar5);
			puVar9 = (undefined4 *)buffer;
			for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
				*puVar9 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar9 = puVar9 + 1;
			}
			for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
				*(undefined *)puVar9 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar9 = (undefined4 *)((int)puVar9 + 1);
			}
			uVar5 = util::Util_Tokenise(buffer,stringParts,":");
			Info_SetText(infoType,stringParts[0]);
			Info_FUN_00419580(infoType,stringParts[1]);
			BVar3 = snd::SFX_GetType(stringParts[2],&sfxType);
			if (BVar3 != 0) {
				Info_SetSFXType(infoType,sfxType);
			}
			if (uVar5 < 4) {
				FUN_004193a0(infoType,1);
				iVar4 = 0;
			}
			else {
				iVar4 = std::_stricmp(stringParts[3],"SLOW");
				FUN_004193a0(infoType,(uint)(iVar4 == 0));
				iVar4 = std::_stricmp(stringParts[3],"ALWAYSPLAYSFX");
				if (iVar4 == 0) {
					iVar4 = 1;
				}
				else {
					if ((uVar5 < 5) || (iVar4 = std::_stricmp(stringParts[4],"ALWAYSPLAYSFX"), iVar4 != 0)) {
						iVar4 = 0;
					}
					else {
						iVar4 = 1;
					}
				}
			}
			FUN_00419420(infoType,iVar4);
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



void __cdecl lego::main::Main_LoadToolTips(CFGProperty *root)
{
	char *pcVar1;
	CFGProperty *pCVar2;
	BOOL BVar3;
	int local_8;
	SFXType local_4;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ToolTips",0);
	for (pCVar2 = cfg::CFG_GetChildren(root,pcVar1); pCVar2 != (CFGProperty *)0x0;
			pCVar2 = cfg::CFG_NextFlat(pCVar2)) {
		BVar3 = front::ToolTip_GetType(pCVar2->key,&local_8);
		if (BVar3 != 0) {
			front::ToolTip_Load_HasNLEscape(local_8,pCVar2->value);
		}
	}
	pcVar1 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ToolTipsSFXs",0);
	for (pCVar2 = cfg::CFG_GetChildren(root,pcVar1); pCVar2 != (CFGProperty *)0x0;
			pCVar2 = cfg::CFG_NextFlat(pCVar2)) {
		BVar3 = front::ToolTip_GetType(pCVar2->key,&local_8);
		if ((BVar3 != 0) && (BVar3 = snd::SFX_GetType(pCVar2->value,&local_4), BVar3 != 0)) {
			front::ToolTip_FUN_0046b9c0(local_8,local_4);
		}
	}
	return;
}



BOOL __cdecl lego::game::Game_TryPlaceObject(ObjectType objType,int objIndex)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	Vector3F local_c;
	
	globals::g_Game.flags3 = globals::g_Game.flags3 & ~GAME3_PLACEBUILDING;
	Game_SetPlaceFlagsState_004dd650(1);
	if ((objType == OBJECT_BUILDING) || (objType == OBJECT_ELECTRICFENCE)) {
		globals::g_Game.flags3 = globals::g_Game.flags3 | GAME3_PLACEBUILDING;
		globals::g_Game.placeObjType = objType;
		globals::g_Game.placeObjIndex = objIndex;
		res::Container_GetOrientation
							((globals::g_Game.cameraMain)->resData1,(Container *)0x0,&local_c,(Vector3F *)0x0);
		if (ABS(local_c.x) <= ABS(local_c.y)) {
			if ((ushort)((ushort)(local_c.y < 0.0) << 8 | (ushort)(local_c.y == 0.0) << 0xe) == 0) {
				globals::g_Game.placeObjDirection = DIRECTION_DOWN;
				return 1;
			}
			globals::g_Game.placeObjDirection = DIRECTION_UP;
			return 1;
		}
		if ((ushort)((ushort)(local_c.x < 0.0) << 8 | (ushort)(local_c.x == 0.0) << 0xe) == 0) {
			globals::g_Game.placeObjDirection = DIRECTION_LEFT;
			return 1;
		}
		globals::g_Game.placeObjDirection = DIRECTION_RIGHT;
		return 1;
	}
	OVar1 = Object_GetStatsFlags2(objType,objIndex);
	if ((OVar1 & STATS2_USESMALLTELEPORTER) != STATS2_NONE) {
		BVar2 = LiveObject_QueueTeleport(globals::g_Game.placeDestSmallTeleporter,objType,objIndex);
		return BVar2;
	}
	OVar1 = Object_GetStatsFlags2(objType,objIndex);
	if ((OVar1 & STATS2_USEBIGTELEPORTER) != STATS2_NONE) {
		BVar2 = LiveObject_QueueTeleport(globals::g_Game.placeDestBigTeleporter,objType,objIndex);
		return BVar2;
	}
	OVar1 = Object_GetStatsFlags2(objType,objIndex);
	if ((OVar1 & STATS2_USEWATERTELEPORTER) != STATS2_NONE) {
		BVar2 = LiveObject_QueueTeleport(globals::g_Game.placeDestWaterTeleporter,objType,objIndex);
		return BVar2;
	}
	OVar1 = Object_GetStatsFlags2(objType,objIndex);
	if ((OVar1 & STATS2_USELEGOMANTELEPORTER) != STATS2_NONE) {
		BVar2 = LiveObject_QueueTeleport((LiveObject *)0x0,objType,objIndex);
		return BVar2;
	}
	return 0;
}



void __cdecl FUN_00434f40(int *param_1,int param_2)
{
	uint uVar1;
	LevelData *pLVar2;
	uint uVar3;
	int iVar4;
	int iVar5;
	int iVar6;
	
	pLVar2 = lego::globals::g_Game.level;
	iVar4 = -param_2;
	iVar6 = iVar4;
	if (-param_2 == param_2 || SBORROW4(iVar4,param_2) != param_2 * -2 < 0) {
		do {
			for (iVar5 = iVar4; iVar5 <= param_2; iVar5 = iVar5 + 1) {
				if ((((iVar5 * iVar5 + iVar6 * iVar6 <= param_2 * param_2) &&
						 (uVar1 = iVar5 + *param_1, -1 < (int)uVar1)) &&
						((int)uVar1 < (pLVar2->dimensions).width)) &&
					 ((uVar3 = param_1[1] + iVar6, -1 < (int)uVar3 &&
						((int)uVar3 < (pLVar2->dimensions).height)))) {
					FUN_00433220(uVar1,uVar3);
				}
			}
			iVar6 = iVar6 + 1;
		} while (iVar6 <= param_2);
	}
	return;
}



void __cdecl lego::main::Main_LoadSurfaceTypeDescriptions_sound(CFGProperty *root,char *keyBasePath)
{
	char cVar1;
	char *pcVar2;
	BOOL BVar3;
	uint uVar4;
	uint uVar5;
	void **ppvVar6;
	undefined4 *puVar7;
	char *pcVar8;
	char *pcVar9;
	undefined4 *puVar10;
	SFXType local_430;
	undefined4 *local_42c;
	char *local_428;
	char *local_424;
	undefined4 local_400 [256];
	
	ppvVar6 = globals::g_Game.SurfaceTypeDescriptions_sound_TABLE;
	do {
		pcVar2 = cfg::CFG_JoinPath(keyBasePath,"SurfaceTypeDescriptions",ppvVar6[-0x24],0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
		if (pcVar2 != (char *)0x0) {
			uVar4 = 0xffffffff;
			local_42c = local_400;
			pcVar8 = pcVar2;
			do {
				pcVar9 = pcVar8;
				if (uVar4 == 0) break;
				uVar4 = uVar4 - 1;
				pcVar9 = pcVar8 + 1;
				cVar1 = *pcVar8;
				pcVar8 = pcVar9;
			} while (cVar1 != '\0');
			uVar4 = ~uVar4;
			puVar7 = (undefined4 *)(pcVar9 + -uVar4);
			puVar10 = local_42c;
			for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
				*puVar10 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar10 = puVar10 + 1;
			}
			for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
				*(undefined *)puVar10 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar10 = (undefined4 *)((int)puVar10 + 1);
			}
			util::Util_Tokenise(pcVar2,&local_428,",");
			pcVar2 = util::Util_RemoveUnderscores(local_428);
			ppvVar6[-0x12] = pcVar2;
			BVar3 = snd::SFX_GetType(local_424,&local_430);
			*ppvVar6 = (void *)(-(uint)(BVar3 != 0) & local_430);
		}
		ppvVar6 = ppvVar6 + 1;
		if ((void **)((int)globals::g_Game.SurfaceTypeDescriptions_sound_TABLE + 0x47) < ppvVar6) {
			return;
		}
	} while( true );
}



char * __cdecl FUN_004350a0(int param_1)
{
	char *pcVar1;
	
	pcVar1 = lego::globals::g_Game.SurfaceTypeDescriptions_name_TABLE[param_1];
	if (pcVar1 == (char *)0x0) {
		pcVar1 = "Need config for surface type.";
	}
	return pcVar1;
}



void * __cdecl FUN_004350c0(int param_1)
{
	return lego::globals::g_Game.SurfaceTypeDescriptions_sound_TABLE[param_1];
}



void __cdecl FUN_004350d0(int param_1)
{
	if (param_1 == 1) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_IMMOVABLE);
		return;
	}
	if (param_1 == 2) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_HARD);
		return;
	}
	if (param_1 == 3) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_MEDIUM);
		return;
	}
	if (param_1 == 4) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_LOOSE);
		return;
	}
	if (param_1 == 5) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_SOIL);
		return;
	}
	if (param_1 == 8) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_ORESEAM);
		return;
	}
	if (param_1 == 10) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_CRYSTALSEAM);
		return;
	}
	if (param_1 == 0xb) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_RECHARGESEAM);
	}
	return;
}



void __cdecl FUN_00435160(Point2I *param_1,int param_2,int param_3)
{
	uint uVar1;
	short sVar2;
	short sVar3;
	uint uVar4;
	BOOL BVar5;
	int iVar6;
	int *piVar7;
	uint local_19c;
	Point2I local_198;
	int local_190 [100];
	
	piVar7 = local_190;
	for (iVar6 = 100; iVar6 != 0; iVar6 = iVar6 + -1) {
		*piVar7 = 0;
		piVar7 = piVar7 + 1;
	}
	uVar1 = param_2 * 2;
	local_19c = 0;
	while( true ) {
		if (param_3 == 0) {
			uVar4 = uVar1 * uVar1 >> 2;
		}
		else {
			uVar4 = uVar1 * uVar1;
		}
		if (uVar4 <= local_19c) break;
		sVar2 = lego::math::Maths_Rand();
		sVar3 = lego::math::Maths_Rand();
		local_198.x = ((uint)(int)sVar2 % uVar1 + param_1->x) - param_2;
		local_198.y = (param_1->y + (uint)(int)sVar3 % uVar1) - param_2;
		iVar6 = (uint)(int)sVar3 % uVar1 + ((uint)(int)sVar2 % uVar1) * 10;
		if (local_190[iVar6] == 0) {
			BVar5 = FUN_0040f0c0(&local_198,1);
			if ((BVar5 != 0) && (param_3 != 0)) {
				return;
			}
			local_190[iVar6] = 1;
		}
		local_19c = local_19c + 1;
	}
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl
lego::game::Level_FUN_00435230(LevelData *level,int param_2,undefined4 param_3,float param_4)
{
	LevelBlock *pLVar1;
	TutorialFlags TVar2;
	SurfaceMap *pSVar3;
	BOOL BVar4;
	uint uVar5;
	uint y;
	uint x;
	float10 fVar6;
	float10 fVar7;
	Point2F local_14;
	Vector3F local_c;
	
	fVar6 = (float10)fsin((float10)_DAT_004df58c);
	_DAT_004df58c = _DAT_004df58c - param_4 * 25.0 * -0.01333333;
	TVar2 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
	if (TVar2 != TUTORIAL_NONE) {
		y = 0;
		pSVar3 = level->surfaceMap;
		if ((pSVar3->smallDimensions).height != 0) {
			do {
				x = 0;
				if ((pSVar3->smallDimensions).width != 0) {
					do {
						BVar4 = Level_Block_FUN_00433d60(x,y);
						if (BVar4 == 0) {
							pLVar1 = level->blocks + y * (level->dimensions).width + x;
							if (pLVar1->blockpointer == 0) {
								if (pLVar1->field_44 == 1) {
									pLVar1->field_44 = 0;
									TVar2 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
									if ((((TVar2 & TUTORIAL_UNK_2) == TUTORIAL_NONE) &&
											(level->blocks[y * (level->dimensions).width + x].clickCount != 0)) &&
										 (INT_004deccc == 0)) {
										SurfaceMap_FUN_0044f7a0((globals::g_Game.level)->surfaceMap,x,y,4);
									}
									else {
										pSVar3 = (globals::g_Game.level)->surfaceMap;
LAB_0043544b:
										SurfaceMap_FUN_0044f830(pSVar3,x,y);
									}
								}
								else {
									if ((pLVar1->field_44 == 0) &&
										 (uVar5 = SurfaceMap_FUN_0044f800((globals::g_Game.level)->surfaceMap,x,y),
										 uVar5 == 5)) {
										pSVar3 = (globals::g_Game.level)->surfaceMap;
										goto LAB_0043544b;
									}
								}
							}
							else {
								SurfaceMap_FUN_0044f900(level->surfaceMap,x,y,(float *)&local_c,&local_c.y);
								fVar7 = SurfaceMap_GetSurfaceZ(level->surfaceMap,local_c.x,local_c.y);
								local_c.z = (float)fVar7;
								lego::view::Viewport_WorldToScreen((Viewport *)param_2,&local_14,&local_c);
								local_14.x = local_14.x - (float)((int)(globals::g_Game.TutorialIcon)->width / 2);
								local_14.y = local_14.y -
														 ((float)fVar6 * 20.0 +
														 (float)((globals::g_Game.TutorialIcon)->height << 1));
								image::Image_DisplayScaled
													(globals::g_Game.TutorialIcon,(Rect2F *)0x0,&local_14,(Size2F *)0x0);
								if (DAT_004ded1c == 0) {
									SurfaceMap_FUN_0044f830((globals::g_Game.level)->surfaceMap,x,y);
									level->blocks[y * (level->dimensions).width + x].field_44 = 1;
								}
								else {
									SurfaceMap_FUN_0044f7a0((globals::g_Game.level)->surfaceMap,x,y,5);
									level->blocks[y * (level->dimensions).width + x].field_44 = 1;
								}
							}
						}
						x = x + 1;
					} while (x < (uint)(level->surfaceMap->smallDimensions).width);
				}
				pSVar3 = level->surfaceMap;
				y = y + 1;
			} while (y < (uint)(pSVar3->smallDimensions).height);
		}
	}
	return;
}



BOOL __cdecl lego::unk::Lego_LeftButtonInputUnk_FUN_00435480(void)
{
	if ((globs::INPUT.mslb == 0) && (BOOL_004df424 != 0)) {
		BOOL_004df424 = globs::INPUT.mslb;
		return 1;
	}
	BOOL_004df424 = globs::INPUT.mslb;
	return 0;
}



undefined4 FUN_004354b0(void)
{
	Point2F local_8;
	
	local_8.x = 0.0;
	local_8.y = 0.0;
	if (lego::globals::g_Game.DialogContrastOverlay == (ImageBMP *)0x0) {
		return 0;
	}
	lego::image::Image_DisplayScaled
						(lego::globals::g_Game.DialogContrastOverlay,(Rect2F *)0x0,&local_8,(Size2F *)0x0);
	return 1;
}



undefined4 __cdecl FUN_004354f0(byte *param_1,byte *param_2,byte *param_3,byte *param_4)
{
	float fVar1;
	float fVar2;
	uint uVar3;
	uint uVar4;
	BOOL BVar5;
	undefined4 uVar6;
	Point2F local_18;
	float local_c;
	undefined4 local_8;
	float local_4;
	
	uVar6 = 0xffffffff;
	if (((lego::globals::g_Game.DialogImage != (ImageBMP *)0x0) &&
			(lego::globals::g_Game.drawregion_e80 != (void *)0x0)) &&
		 (lego::globals::g_Game.drawregion_e84 != (void *)0x0)) {
		FUN_004354b0();
		local_18.x = (float)((int)lego::globs::mainGlobs.appWidth / 2) -
								 (float)((lego::globals::g_Game.DialogImage)->width >> 1);
		local_18.y = (float)((int)lego::globs::mainGlobs.appHeight / 2) -
								 (float)((lego::globals::g_Game.DialogImage)->height >> 1);
		lego::image::Image_DisplayScaled
							(lego::globals::g_Game.DialogImage,(Rect2F *)0x0,&local_18,(Size2F *)0x0);
		lego::front::TextWindow_Clear((TextWindow *)lego::globals::g_Game.drawregion_e80);
		lego::front::TextWindow_Clear((TextWindow *)lego::globals::g_Game.drawregion_e84);
		lego::front::TextWindow_Clear((TextWindow *)lego::globals::g_Game.drawregion_e88);
		lego::front::TextWindow_Clear((TextWindow *)lego::globals::g_Game.drawregion_e8c);
		if (param_3 != (byte *)0x0) {
			local_c = 0.0;
			local_8 = 0;
			local_4 = 0.0;
			uVar3 = lego::image::FontX_GetStringWidth(lego::globals::g_Game.bmpMbriefFONT,(char *)param_3)
			;
			uVar4 = lego::image::Font_GetHeight(lego::globals::g_Game.bmpMbriefFONT);
			fVar1 = (*(float *)((int)lego::globals::g_Game.drawregion_e88 + 4) -
							*(float *)((int)lego::globals::g_Game.drawregion_e88 + 0xc) * -0.5) -
							(float)(uVar3 >> 1);
			local_c = *(float *)((int)lego::globals::g_Game.drawregion_e88 + 8);
			local_4 = (float)(ulonglong)uVar4;
			fVar2 = (float)lego::globs::INPUT.msx;
			if ((((ushort)((ushort)(fVar2 < fVar1) << 8 | (ushort)(fVar2 == fVar1) << 0xe) != 0) ||
					(fVar1 + (float)(ulonglong)uVar3 <= fVar2)) ||
				 ((fVar1 = (float)lego::globs::INPUT.msy,
					(ushort)((ushort)(fVar1 < local_c) << 8 | (ushort)(fVar1 == local_c) << 0xe) != 0 ||
					(local_c + local_4 <= fVar1)))) {
				*(ImageFont **)lego::globals::g_Game.drawregion_e88 = lego::globals::g_Game.bmpMbriefFONT;
				lego::front::TextWindow_PrintF
									((TextWindow *)lego::globals::g_Game.drawregion_e88,(char *)param_3);
			}
			else {
				*(ImageFont **)lego::globals::g_Game.drawregion_e88 = lego::globals::g_Game.bmpMbriefFONT2;
				lego::front::TextWindow_PrintF
									((TextWindow *)lego::globals::g_Game.drawregion_e88,(char *)param_3);
				BVar5 = lego::unk::Lego_LeftButtonInputUnk_FUN_00435480();
				if (BVar5 != 0) {
					uVar6 = 1;
				}
			}
		}
		if (param_4 != (byte *)0x0) {
			local_c = 0.0;
			local_8 = 0;
			local_4 = 0.0;
			uVar3 = lego::image::FontX_GetStringWidth(lego::globals::g_Game.bmpMbriefFONT,(char *)param_4)
			;
			uVar4 = lego::image::Font_GetHeight(lego::globals::g_Game.bmpMbriefFONT);
			fVar1 = (*(float *)((int)lego::globals::g_Game.drawregion_e8c + 4) -
							*(float *)((int)lego::globals::g_Game.drawregion_e8c + 0xc) * -0.5) -
							(float)(uVar3 >> 1);
			local_c = *(float *)((int)lego::globals::g_Game.drawregion_e8c + 8);
			local_4 = (float)(ulonglong)uVar4;
			fVar2 = (float)lego::globs::INPUT.msx;
			if ((((ushort)((ushort)(fVar2 < fVar1) << 8 | (ushort)(fVar2 == fVar1) << 0xe) != 0) ||
					(fVar1 + (float)(ulonglong)uVar3 <= fVar2)) ||
				 ((fVar1 = (float)lego::globs::INPUT.msy,
					(ushort)((ushort)(fVar1 < local_c) << 8 | (ushort)(fVar1 == local_c) << 0xe) != 0 ||
					(local_c + local_4 <= fVar1)))) {
				*(ImageFont **)lego::globals::g_Game.drawregion_e8c = lego::globals::g_Game.bmpMbriefFONT;
				lego::front::TextWindow_PrintF
									((TextWindow *)lego::globals::g_Game.drawregion_e8c,(char *)param_4);
			}
			else {
				*(ImageFont **)lego::globals::g_Game.drawregion_e8c = lego::globals::g_Game.bmpMbriefFONT2;
				lego::front::TextWindow_PrintF
									((TextWindow *)lego::globals::g_Game.drawregion_e8c,(char *)param_4);
				BVar5 = lego::unk::Lego_LeftButtonInputUnk_FUN_00435480();
				if (BVar5 != 0) {
					uVar6 = 0;
				}
			}
		}
		lego::front::TextWindow_PrintF
							((TextWindow *)lego::globals::g_Game.drawregion_e80,(char *)param_1);
		lego::front::TextWindow_PrintF
							((TextWindow *)lego::globals::g_Game.drawregion_e84,(char *)param_2);
		lego::front::TextWindow_Update
							((TextWindow *)lego::globals::g_Game.drawregion_e80,0,1.0,(int *)0x0);
		lego::front::TextWindow_Update
							((TextWindow *)lego::globals::g_Game.drawregion_e84,0,1.0,(int *)0x0);
		lego::front::TextWindow_Update
							((TextWindow *)lego::globals::g_Game.drawregion_e88,0,1.0,(int *)0x0);
		lego::front::TextWindow_Update
							((TextWindow *)lego::globals::g_Game.drawregion_e8c,0,1.0,(int *)0x0);
		return uVar6;
	}
	return 0xffffffff;
}



BOOL __cdecl FUN_00435870(void)
{
	BOOL BVar1;
	BOOL BVar2;
	BOOL BVar3;
	char *levelName;
	int iVar4;
	
	lego::game::GetLevel();
	BVar1 = lego::unk::Lego_GetIntNotM1__00558020();
	BVar2 = lego::unk::Lego_GetIntNotM1__00558024();
	lego::snd::Sound3D_StopAllSounds();
	BVar3 = lego::main::Config_IsFrontEndEnabled();
	if (BVar3 != 0) {
		lego::reward::Reward_LoadLevelFrontEnd();
		FUN_00460620();
		lego::main::Main_waitFrontEndRewards__004616d0();
		lego::reward::RewardFrontEnd_Free();
	}
	FUN_00429520(1,(LiveObject *)0x0,0);
	lego::front::TextWindow_Clear(lego::globals::g_Game.textWnd_80);
	levelName = (char *)lego::game::Game_freeLevel__0042eff0();
	BVar3 = lego::main::Config_IsFrontEndEnabled();
	if (BVar3 != 0) {
		if (BVar1 == 0) {
			if (BVar2 == 0) goto LAB_00435915;
			lego::front::Menu_Open_FUN_00416bb0(2);
			iVar4 = lego::front::Front_IsTriggerAppQuit();
			if (iVar4 != 0) {
				return 0;
			}
		}
		else {
			lego::front::Menu_Open_FUN_00416bb0(1);
			iVar4 = lego::front::Front_IsTriggerAppQuit();
			if (iVar4 != 0) {
				return 0;
			}
		}
		levelName = (char *)FUN_00416ca0();
	}
LAB_00435915:
	FUN_00416870(1,0);
	if (levelName == (char *)0x0) {
		return 0;
	}
	BVar1 = lego::main::Main_loadLevelCFG(levelName);
	if (BVar1 == 0) {
		return 0;
	}
	std::free(levelName);
	return 1;
}



void __cdecl FUN_00435950(void)
{
	lego::globals::g_Game.flags3 =
			 lego::globals::g_Game.flags3 &
			 ~(GAME3_UNK_1|GAME3_UNK_2|GAME3_UNK_4|GAME3_PICKUPOBJECT|GAME3_LOADVEHICLE|GAME3_UNK_20|
				 GAME3_UNK_40|GAME3_PLACEBUILDING);
	lego::res::ResLp_UnkSetup3DFrameTransform(lego::globals::g_Game.RES_2f4_TABLEUNK,1);
	return;
}



void __cdecl FUN_00435980(void)
{
	BOOL BVar1;
	
	if ((lego::globals::g_Game.flags1 & GAME1_UNK_8000000) != GAME1_NONE) {
		BVar1 = FUN_0046a780(0x40b);
		if (BVar1 != 0) {
			lego::globals::g_Game.flags2 = lego::globals::g_Game.flags2 | GAME2_UNK_2;
		}
	}
	return;
}



void __cdecl FUN_004359b0(int param_1)
{
	if (param_1 != 0) {
		lego::globals::g_Game.flags2 = lego::globals::g_Game.flags2 | GAME2_UNK_4;
		return;
	}
	lego::globals::g_Game.flags2 = lego::globals::g_Game.flags2 & ~GAME2_UNK_4;
	return;
}



void __cdecl lego::game::Game_SetCallToArmsOn(BOOL enableCallToArms)
{
	if (enableCallToArms != 0) {
		globals::g_Game.flags2 = globals::g_Game.flags2 | GAME2_CALLTOARMS;
		if ((ushort)((ushort)(globals::g_Game.timerGame_e3c < 0.0) << 8 |
								(ushort)(globals::g_Game.timerGame_e3c == 0.0) << 0xe) != 0) {
			snd::Audio_Play_FUN_00465260(SFX_SIREN,0);
			globals::g_Game.timerGame_e3c = 250.0;
		}
		FUN_0045aeb0(6,2,1);
		return;
	}
	globals::g_Game.flags2 = globals::g_Game.flags2 & ~GAME2_CALLTOARMS;
	globals::g_Game.timerGame_e3c = 0.0;
	FUN_0045aeb0(6,2,0);
	return;
}



CameraData * __cdecl lego::view::Camera_Create(Container *resRoot,CameraType camType)
{
	CameraData *cam;
	Container *pCVar1;
	
	cam = (CameraData *)std::malloc(0xbc);
	if (cam != (CameraData *)0x0) {
		cam->camType = camType;
		cam->object_4 = (LiveObject *)0x0;
		cam->float_c = 0.0;
		cam->float_8 = 0.0;
		*(undefined *)&cam->flags = 0;
		cam->yaw = 0.0;
		cam->tilt = 0.0;
		cam->dist = 200.0;
		cam->field_14 = 0;
		(cam->vector_18).x = 0.0;
		(cam->vector_18).y = 0.0;
		(cam->vector_18).z = 0.0;
		cam->speedAccel_9c = 0.0;
		(cam->vector_a0).z = 0.0;
		(cam->vector_a0).y = 0.0;
		(cam->vector_a0).x = 0.0;
		(cam->vector_ac).z = 0.0;
		(cam->vector_ac).y = 0.0;
		(cam->vector_ac).x = 0.0;
		pCVar1 = res::Container_Create((Container *)0x0);
		cam->resData1 = pCVar1;
		if (cam->resData1 != (Container *)0x0) {
			res::Container_SetPosition(cam->resData1,(Container *)0x0,0.0,0.0,-cam->dist);
			res::Container_SetOrientation(cam->resData1,(Container *)0x0,0.0,0.0,1.0,0.0,1.0,0.0);
			if (camType == CAMERATYPE_FIRSTPERSON) {
				res::Container_SetParent(cam->resData1,resRoot);
				return cam;
			}
			pCVar1 = res::Container_Create(resRoot);
			cam->resData2 = pCVar1;
			if (cam->resData2 != (Container *)0x0) {
				pCVar1 = res::Container_Create(resRoot);
				cam->resData3 = pCVar1;
				if (cam->resData3 != (Container *)0x0) {
					pCVar1 = res::Container_Create(cam->resData2);
					cam->resData4 = pCVar1;
					if (cam->resData4 != (Container *)0x0) {
						if (camType == CAMERATYPE_TOPDOWN) {
							pCVar1 = res::Container_Create(cam->resData4);
							cam->resTableunk_34 = pCVar1;
							if (cam->resTableunk_34 != (Container *)0x0) {
								res::Container_SetPosition(cam->resTableunk_34,(Container *)0x0,0.0,0.0,-80.0);
							}
						}
						res::Container_SetParent(cam->resData1,cam->resData4);
						return cam;
					}
					res::Container_Remove(cam->resData3);
				}
				res::Container_Remove(cam->resData2);
			}
			res::Container_Remove(cam->resData1);
		}
		std::free(cam);
	}
	return (CameraData *)0x0;
}



void __cdecl lego::view::Camera_Debug_AllowEditModeFunc1(CameraData *cam,BOOL modeDisableUnk)
{
	if (modeDisableUnk == 0) {
		*(byte *)&cam->flags = *(byte *)&cam->flags & 0xf7;
	}
	else {
		*(byte *)&cam->flags = *(byte *)&cam->flags | 8;
	}
	return;
}



void __cdecl lego::view::Camera_Cleanup(CameraData *cam)
{
	res::Container_Remove(cam->resData1);
	if (cam->camType != CAMERATYPE_FIRSTPERSON) {
		res::Container_Remove(cam->resData2);
		res::Container_Remove(cam->resData4);
	}
	std::free(cam);
	return;
}



void __cdecl
lego::view::Camera_SetCameraMovements
					(float cameraSpeed,float cameraDropOff,float cameraAcceleration,int mouseScrollIndent)
{
	globals::g_CameraSpeed = cameraSpeed;
	globals::g_CameraDropOff = cameraDropOff;
	globals::g_CameraAcceleration = cameraAcceleration;
	globals::g_MouseScrollIndent = mouseScrollIndent;
	return;
}



void __cdecl lego::view::Camera_CopyPositionOrientation(CameraData *dstCamera,CameraData *srcCamera)
{
	Vector3F vectorPos;
	Vector3F vectorD;
	Vector3F vectorU;
	
	if (dstCamera->camType == CAMERATYPE_FIRSTPERSON) {
		res::Container_GetPosition(srcCamera->resData1,(Container *)0x0,&vectorPos);
		res::Container_GetOrientation(srcCamera->resData1,(Container *)0x0,&vectorD,&vectorU);
		res::Container_SetPosition
							(dstCamera->resData1,(Container *)0x0,vectorPos.x,vectorPos.y,vectorPos.z);
		res::Container_SetOrientation
							(dstCamera->resData1,(Container *)0x0,vectorD.x,vectorD.y,vectorD.z,vectorU.x,
							 vectorU.y,vectorU.z);
	}
	return;
}



void __cdecl
lego::view::Camera_FUN_00435deb
					(CameraData *cam,LiveObject *liveObj,float param_3,float param_4,float param_5,
					float param_6)
{
	cam->object_4 = liveObj;
	cam->float_8 = param_3;
	cam->float_c = param_4;
	Camera_SetTilt(cam,param_5);
	cam->float_10 = param_6;
	return;
}



void __cdecl
lego::view::Camera_SetObject4_Field14(CameraData *cam,LiveObject *liveObj,undefined4 param_3)
{
	cam->object_4 = liveObj;
	cam->field_14 = param_3;
	return;
}



undefined4 __cdecl lego::view::Camera_GetField14(CameraData *cam)
{
	return cam->field_14;
}



void __cdecl lego::view::Camera_ZeroField9c_UnkSpeedAccel(CameraData *cam)
{
	cam->speedAccel_9c = 0.0;
	return;
}



int __cdecl lego::view::Camera_GetMouseScrollIndent(void)
{
	return globals::g_MouseScrollIndent;
}



void __cdecl lego::view::Camera_SetFloata0_a4_Zeroa8(CameraData *cam,float param_2,float param_3)
{
	(cam->vector_a0).x = param_2;
	(cam->vector_a0).y = param_3;
	(cam->vector_a0).z = 0.0;
	return;
}



void __cdecl lego::view::Camera_Update(CameraData *cam,LevelData *level,float param_3,float param_4)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	BOOL BVar5;
	SurfaceMap *surfMap;
	float10 fVar6;
	Vector3F local_e0;
	float local_d4;
	float local_d0;
	float local_cc;
	float local_c8;
	float local_c4;
	float local_c0;
	float local_bc;
	Vector3F local_b8;
	Vector3F local_ac;
	Vector3F local_a0;
	float local_94;
	float local_90;
	float local_8c;
	float local_88;
	Vector3F local_84;
	Container *local_78;
	float local_74;
	float local_70;
	float local_6c;
	Vector3F local_68;
	float local_5c;
	Vector3F local_58;
	Vector3F local_4c;
	float local_40;
	float local_3c;
	float local_38;
	float local_34;
	Vector3F local_30;
	Vector3F local_24;
	Vector3F local_18;
	uint local_c;
	uint local_8;
	
	res::Container_AddTranslation
						(cam->resData1,D3DRMCOMBINE_BEFORE,-(cam->vector_ac).x,-(cam->vector_ac).y,
						 -(cam->vector_ac).z);
	fVar1 = globals::g_CameraDropOff;
	if (cam->camType == CAMERATYPE_TOPDOWN) {
		(cam->vector_18).x = (cam->vector_18).x * globals::g_CameraDropOff;
		(cam->vector_18).y = (cam->vector_18).y * fVar1;
		(cam->vector_18).z = (cam->vector_18).z * fVar1;
		res::Container_AddTranslation
							(cam->resData2,D3DRMCOMBINE_AFTER,(cam->vector_18).x,(cam->vector_18).y,
							 (cam->vector_18).z);
		res::Container_GetPosition(cam->resData2,(Container *)0x0,&local_30);
		res::Container_GetOrientation(cam->resData2,(Container *)0x0,&local_24,&local_18);
		BVar5 = game::SurfaceMap_ToBlockCoordinatesNoZ
											(level->surfaceMap,local_30.x,local_30.y,(int *)&local_8,(int *)&local_c);
		if (BVar5 == 0) {
			res::Container_AddTranslation
								(cam->resData2,D3DRMCOMBINE_AFTER,-(cam->vector_18).x,-(cam->vector_18).y,
								 -(cam->vector_18).z);
		}
		else {
			if ((local_8 < (uint)globals::g_MouseScrollIndent) ||
				 ((uint)((level->surfaceMap->smallDimensions).width - globals::g_MouseScrollIndent) <=
					local_8)) {
				res::Container_AddTranslation(cam->resData2,D3DRMCOMBINE_AFTER,-(cam->vector_18).x,0.0,0.0);
			}
			if ((local_c < (uint)globals::g_MouseScrollIndent) ||
				 ((uint)((level->surfaceMap->smallDimensions).height - globals::g_MouseScrollIndent) <=
					local_c)) {
				res::Container_AddTranslation(cam->resData2,D3DRMCOMBINE_AFTER,0.0,-(cam->vector_18).y,0.0);
			}
			fVar6 = game::SurfaceMap_GetSurfaceZ(level->surfaceMap,local_30.x,local_30.y);
			res::Container_SetPosition(cam->resData3,(Container *)0x0,local_30.x,local_30.y,(float)fVar6);
			res::Container_SetOrientation
								(cam->resData3,(Container *)0x0,local_18.x,local_18.y,0.0,0.0,0.0,-1.0);
			surfMap = game::GetSurfaceMap();
			fVar6 = game::SurfaceMap_UnkCameraXYFunc_RetZunk(surfMap,local_30.x,local_30.y);
			local_34 = (float)-fVar6;
			local_38 = cam->dist + local_34;
			res::Container_SetPosition(cam->resData1,cam->resData4,0.0,0.0,-local_38);
		}
		goto LAB_004368f0;
	}
	if (cam->camType != CAMERATYPE_FIRSTPERSON) {
		if (cam->camType == CAMERATYPE_RADAR) {
			if (cam->object_4 == (LiveObject *)0x0) {
				game::Game_SetFlag1_20000_unkCamera(1);
			}
			else {
				local_78 = game::LiveObject_GetResource(cam->object_4);
				if (local_78 != (Container *)0x0) {
					local_88 = cam->float_8 * param_4;
					game::Game_SetFlag1_20000_unkCamera(0);
					res::Container_GetPosition(cam->resData1,(Container *)0x0,&local_a0);
					res::Container_GetPosition(local_78,(Container *)0x0,&local_84);
					local_84.z = local_84.z - cam->float_c / 10.0;
					fVar1 = cam->dist;
					cam->dist = cam->float_c;
					res::Container_SetPosition(cam->resData1,cam->resData4,0.0,0.0,-cam->dist);
					res::Container_GetPosition(cam->resData2,(Container *)0x0,&local_b8);
					res::Container_SetPosition
										(cam->resData2,(Container *)0x0,local_84.x,local_84.y,local_84.z);
					res::Container_GetPosition(cam->resData1,(Container *)0x0,&local_e0);
					local_c8 = local_e0.x - local_a0.x;
					local_c4 = local_e0.y - local_a0.y;
					local_c0 = local_e0.z - local_a0.z;
					fVar6 = std::sqrt((double)(local_c0 * local_c0 + local_c4 * local_c4 + local_c8 * local_c8
																		));
					local_8c = (float)fVar6;
					if (((ushort)((ushort)(fVar6 < (float10)local_88) << 8 |
											 (ushort)(fVar6 == (float10)local_88) << 0xe) == 0) && (local_8c < 120.0)) {
						local_90 = local_8c / local_88;
						res::Container_GetOrientation(local_78,(Container *)0x0,&local_ac,(Vector3F *)0x0);
						local_d4 = local_ac.x * local_90;
						local_d0 = local_ac.y * local_90;
						local_cc = local_ac.z * local_90;
						local_84.x = local_84.x + local_d4;
						local_84.y = local_84.y + local_d0;
						local_84.z = local_84.z + local_cc;
						local_c8 = local_84.x - local_b8.x;
						local_c4 = local_84.y - local_b8.y;
						local_c0 = local_84.z - local_b8.z;
						fVar6 = std::sqrt((double)(local_c0 * local_c0 +
																			local_c4 * local_c4 + local_c8 * local_c8));
						local_94 = (float)fVar6;
						fVar6 = std::round((double)(cam->float_c - fVar1));
						local_bc = (float)fVar6;
						fVar2 = local_94 + local_bc;
						fVar6 = std::sqrt((double)(local_c0 * local_c0 +
																			local_c4 * local_c4 + local_c8 * local_c8));
						fVar3 = 1.0 / (float)fVar6;
						fVar4 = (local_94 / fVar2) * local_88;
						local_c8 = local_c8 * fVar3 * fVar4;
						local_c4 = local_c4 * fVar3 * fVar4;
						local_c0 = local_c0 * fVar3 * fVar4;
						local_b8.x = local_b8.x + local_c8;
						local_b8.y = local_b8.y + local_c4;
						local_b8.z = local_b8.z + local_c0;
						res::Container_SetPosition
											(cam->resData2,(Container *)0x0,local_b8.x,local_b8.y,local_b8.z);
						if ((ushort)((ushort)(fVar1 < cam->float_c) << 8 |
												(ushort)(fVar1 == cam->float_c) << 0xe) == 0) {
							cam->dist = fVar1 - (local_bc / fVar2) * local_88;
						}
						else {
							if (fVar1 != cam->float_c) {
								cam->dist = (local_bc / fVar2) * local_88 + fVar1;
							}
						}
						res::Container_SetPosition(cam->resData1,cam->resData4,0.0,0.0,-cam->dist);
					}
					Camera_AddYaw(cam,cam->float_10 * param_3);
				}
			}
		}
		goto LAB_004368f0;
	}
	if ((cam->object_4 == (LiveObject *)0x0) || (param_3 == 0.0)) goto LAB_004368f0;
	res::Container_GetPosition(cam->resData1,(Container *)0x0,&local_58);
	res::Container_GetOrientation(cam->resData1,(Container *)0x0,&local_4c,&local_68);
	game::LiveObject_UnkCameraFunc(cam->object_4,cam->field_14,&local_74,&local_68);
	if ((*(byte *)&cam->flags & 0x10) == 0) {
LAB_0043621d:
		local_58.x = local_74;
		local_58.y = local_70;
		local_58.z = local_6c;
		local_4c.x = local_68.x;
		local_4c.y = local_68.y;
		local_4c.z = local_68.z;
	}
	else {
		fVar6 = std::sqrt((double)((local_6c - local_58.z) * (local_6c - local_58.z) +
															(local_70 - local_58.y) * (local_70 - local_58.y) +
															(local_74 - local_58.x) * (local_74 - local_58.x)));
		local_40 = (float)fVar6;
		if (((ushort)((ushort)(fVar6 < (float10)100.0) << 8 | (ushort)(fVar6 == (float10)100.0) << 0xe)
				 == 0) ||
			 (local_5c = local_68.x * local_4c.x + local_68.y * local_4c.y + local_68.z * local_4c.z,
			 local_5c < 0.0)) goto LAB_0043621d;
	}
	local_3c = (1.0 / param_3) * 4.0;
	fVar6 = std::sqrt((double)(local_4c.z * local_4c.z +
														local_4c.y * local_4c.y + local_4c.x * local_4c.x));
	fVar1 = 1.0 / (float)fVar6;
	local_4c.x = local_4c.x * fVar1;
	local_4c.y = local_4c.y * fVar1;
	local_4c.z = local_4c.z * fVar1;
	fVar6 = std::sqrt((double)(local_68.z * local_68.z +
														local_68.y * local_68.y + local_68.x * local_68.x));
	fVar1 = 1.0 / (float)fVar6;
	local_4c.x = local_4c.x * local_3c;
	local_4c.y = local_4c.y * local_3c;
	local_4c.z = local_4c.z * local_3c;
	local_68.x = local_68.x * fVar1 + local_4c.x;
	local_68.y = local_68.y * fVar1 + local_4c.y;
	local_68.z = local_68.z * fVar1 + local_4c.z;
	local_58.x = local_58.x * local_3c;
	local_58.y = local_58.y * local_3c;
	local_58.z = local_58.z * local_3c;
	fVar1 = 1.0 / (local_3c + 1.0);
	local_74 = (local_74 + local_58.x) * fVar1;
	local_70 = (local_70 + local_58.y) * fVar1;
	local_6c = (local_6c + local_58.z) * fVar1;
	if ((ushort)((ushort)(local_40 < 0.01) << 8 | (ushort)(local_40 == 0.01) << 0xe) == 0) {
		res::Container_SetPosition(cam->resData1,(Container *)0x0,local_74,local_70,local_6c);
	}
	if (local_5c < 0.99999) {
		res::Container_SetOrientation
							(cam->resData1,(Container *)0x0,local_68.x,local_68.y,local_68.z,0.0,0.0,-1.0);
	}
	*(byte *)&cam->flags = *(byte *)&cam->flags | 0x10;
LAB_004368f0:
	if ((cam->vector_a0).y <= (cam->vector_a0).z) {
		(cam->vector_ac).z = 0.0;
		(cam->vector_ac).y = 0.0;
		(cam->vector_ac).x = 0.0;
	}
	else {
		fVar1 = (cam->vector_a0).y;
		fVar2 = (cam->vector_a0).z;
		fVar3 = (cam->vector_a0).y;
		fVar4 = (cam->vector_a0).x;
		fVar6 = math::Maths_RandRange(0.0,1.0);
		math::Maths_Vector3DRandom(&cam->vector_ac);
		fVar1 = ((fVar1 - fVar2) / fVar3) * fVar4 * (float)fVar6;
		(cam->vector_ac).x = (cam->vector_ac).x * fVar1;
		(cam->vector_ac).y = (cam->vector_ac).y * fVar1;
		(cam->vector_ac).z = (cam->vector_ac).z * fVar1;
		(cam->vector_a0).z = (cam->vector_a0).z + param_4;
		res::Container_AddTranslation
							(cam->resData1,D3DRMCOMBINE_BEFORE,-(cam->vector_ac).x,-(cam->vector_ac).y,
							 -(cam->vector_ac).z);
	}
	return;
}



void __cdecl lego::view::Camera_SetTiltRange(CameraData *cam,float minTilt,float maxTilt)
{
	*(byte *)&cam->flags = *(byte *)&cam->flags | 1;
	(cam->TiltRange).min = minTilt;
	(cam->TiltRange).max = maxTilt;
	return;
}



void __cdecl lego::view::Camera_SetTilt(CameraData *cam,float tilt)
{
	float fVar1;
	
	if ((((*(byte *)&cam->flags & CAMERA_TILTRANGE) == 0) ||
			((*(byte *)&cam->flags & CAMERA_UNK_8) != 0)) ||
		 (((cam->TiltRange).min <= tilt &&
			(fVar1 = (cam->TiltRange).max,
			(ushort)((ushort)(tilt < fVar1) << 8 | (ushort)(tilt == fVar1) << 0xe) != 0)))) {
		cam->tilt = tilt;
		res::Container_SetOrientation(cam->resData4,cam->resData2,0.0,0.0,1.0,0.0,1.0,0.0);
		res::Container_AddRotation(cam->resData4,D3DRMCOMBINE_BEFORE,1.0,0.0,0.0,-tilt);
	}
	return;
}



void __cdecl lego::view::Camera_AddTilt(CameraData *cam,float tiltAmount)
{
	Camera_SetTilt(cam,tiltAmount + cam->tilt);
	return;
}



void __cdecl lego::view::Camera_SetYawRange(CameraData *cam,float minYaw,float maxYaw)
{
	*(byte *)&cam->flags = *(byte *)&cam->flags | CAMERA_YAWRANGE;
	(cam->YawRange).min = minYaw;
	(cam->YawRange).max = maxYaw;
	return;
}



void __cdecl lego::view::Camera_SetYaw(CameraData *cam,float yaw)
{
	float fVar1;
	
	if ((((*(byte *)&cam->flags & CAMERA_YAWRANGE) == 0) ||
			((*(byte *)&cam->flags & CAMERA_UNK_8) != 0)) ||
		 (((cam->YawRange).min <= yaw &&
			(fVar1 = (cam->YawRange).max,
			(ushort)((ushort)(yaw < fVar1) << 8 | (ushort)(yaw == fVar1) << 0xe) != 0)))) {
		cam->yaw = yaw;
		res::Container_SetOrientation(cam->resData2,(Container *)0x0,0.0,0.0,1.0,0.0,1.0,0.0);
		res::Container_AddRotation(cam->resData2,D3DRMCOMBINE_BEFORE,0.0,0.0,1.0,-yaw);
	}
	return;
}



void __cdecl lego::view::Camera_AddYaw(CameraData *cam,float yawAmount)
{
	Camera_SetYaw(cam,yawAmount + cam->yaw);
	return;
}



void __cdecl lego::view::Camera_SetDistRange(CameraData *cam,float minDist,float maxDist)
{
	*(byte *)&cam->flags = *(byte *)&cam->flags | CAMERA_DISTRANGE;
	(cam->DistRange).min = minDist;
	(cam->DistRange).max = maxDist;
	return;
}



void __cdecl lego::view::Camera_SetDist(CameraData *cam,float dist)
{
	float fVar1;
	
	if ((((*(byte *)&cam->flags & CAMERA_DISTRANGE) == 0) ||
			((*(byte *)&cam->flags & CAMERA_UNK_8) != 0)) ||
		 (((cam->DistRange).min <= dist &&
			(fVar1 = (cam->DistRange).max,
			(ushort)((ushort)(dist < fVar1) << 8 | (ushort)(dist == fVar1) << 0xe) != 0)))) {
		cam->dist = dist;
	}
	return;
}



void __cdecl lego::view::AddDist(CameraData *cam,float distAmount)
{
	Camera_SetDist(cam,distAmount + cam->dist);
	return;
}



void __cdecl lego::view::Camera_AddTranslation2F(CameraData *cam,float translateX,float translateY)
{
	res::Container_AddTranslation(cam->resData2,D3DRMCOMBINE_BEFORE,translateX,translateY,0.0);
	return;
}



void __cdecl lego::view::Camera_GetFramePosition_IfTopdown(CameraData *cam,Vector3F *out_position)
{
	if (cam->camType == CAMERATYPE_TOPDOWN) {
		res::Container_GetPosition(cam->resData2,(Container *)0x0,out_position);
	}
	return;
}



void __cdecl lego::view::Camera_SetFramePosition_IfTopdown(CameraData *cam,float x,float y)
{
	if (cam->camType == CAMERATYPE_TOPDOWN) {
		res::Container_SetPosition(cam->resData2,(Container *)0x0,x,y,0.0);
	}
	return;
}



BOOL __cdecl
lego::view::Camera_GetSurfacePosition_IfTopdown
					(CameraData *cam,SurfaceMap *surfMap,Vector3F *out_surfPosition)
{
	float10 fVar1;
	
	if (cam->camType == CAMERATYPE_TOPDOWN) {
		res::Container_GetPosition(cam->resData2,(Container *)0x0,out_surfPosition);
		fVar1 = game::SurfaceMap_GetSurfaceZ(surfMap,out_surfPosition->x,out_surfPosition->y);
		out_surfPosition->z = (float)fVar1;
	}
	return 1;
}



float10 __cdecl lego::view::Camera_GetYaw(CameraData *cam)
{
	return (float10)cam->yaw;
}



void __cdecl lego::view::Camera_FUN_00436da9(CameraData *cam,Vector3F *ref_vector,float unkScalar)
{
	float fVar1;
	float10 fVar2;
	
	fVar2 = std::sqrt((double)(ref_vector->z * ref_vector->z +
														ref_vector->y * ref_vector->y + ref_vector->x * ref_vector->x));
	fVar1 = 1.0 / (float)fVar2;
	ref_vector->x = ref_vector->x * fVar1;
	ref_vector->y = ref_vector->y * fVar1;
	ref_vector->z = ref_vector->z * fVar1;
	cam->speedAccel_9c = unkScalar * globals::g_CameraAcceleration + cam->speedAccel_9c;
	if ((ushort)((ushort)(cam->speedAccel_9c < globals::g_CameraSpeed) << 8 |
							(ushort)(cam->speedAccel_9c == globals::g_CameraSpeed) << 0xe) == 0) {
		cam->speedAccel_9c = globals::g_CameraSpeed;
	}
	fVar1 = cam->speedAccel_9c * unkScalar;
	ref_vector->x = ref_vector->x * fVar1;
	ref_vector->y = ref_vector->y * fVar1;
	ref_vector->z = ref_vector->z * fVar1;
	(cam->vector_18).x = (cam->vector_18).x + ref_vector->x;
	(cam->vector_18).y = (cam->vector_18).y + ref_vector->y;
	(cam->vector_18).z = (cam->vector_18).z + ref_vector->z;
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl lego::pool::ReservedPool_LiveObject___Init(void)
{
	int iVar1;
	LiveObject **ppLVar2;
	
	ppLVar2 = globals::ReservedPool_LiveObject___g_TABLE;
	for (iVar1 = 0x318f; iVar1 != 0; iVar1 = iVar1 + -1) {
		*ppLVar2 = (LiveObject *)0x0;
		ppLVar2 = ppLVar2 + 1;
	}
	lego::globals::g_Activities_TABLE[0] = "Activity_Stand";
	lego::globals::g_Activities_TABLE[1] = "Activity_Route";
	lego::globals::g_Activities_TABLE[2] = "Activity_RouteRubble";
	lego::globals::g_Activities_TABLE[3] = "Activity_RunPanic";
	lego::globals::g_Activities_TABLE[4] = "Activity_Drill";
	lego::globals::g_Activities_TABLE[5] = "Activity_Teleport";
	lego::globals::g_Activities_TABLE[6] = "Activity_Walk";
	lego::globals::g_Activities_TABLE[7] = "Activity_Reinforce";
	lego::globals::g_Activities_TABLE[8] = "Activity_Reverse";
	lego::globals::g_Activities_TABLE[9] = "Activity_TurnLeft";
	lego::globals::g_Activities_TABLE[10] = "Activity_TurnRight";
	lego::globals::g_Activities_TABLE[11] = "Activity_CantDo";
	lego::globals::g_Activities_TABLE[12] = "Activity_Emerge";
	lego::globals::g_Activities_TABLE[13] = "Activity_Enter";
	lego::globals::g_Activities_TABLE[14] = "Activity_EnterRein";
	lego::globals::g_Activities_TABLE[15] = "Activity_Collect";
	lego::globals::g_Activities_TABLE[16] = "Activity_Gather";
	lego::globals::g_Activities_TABLE[17] = "Activity_Carry";
	lego::globals::g_Activities_TABLE[18] = "Activity_CarryRubble";
	lego::globals::g_Activities_TABLE[19] = "Activity_Throw";
	lego::globals::g_Activities_TABLE[20] = "Activity_CarryTurnLeft";
	lego::globals::g_Activities_TABLE[21] = "Activity_CarryTurnRight";
	lego::globals::g_Activities_TABLE[22] = "Activity_CarryStand";
	lego::globals::g_Activities_TABLE[23] = "Activity_HitLeft";
	lego::globals::g_Activities_TABLE[24] = "Activity_HitRight";
	lego::globals::g_Activities_TABLE[25] = "Activity_HitFront";
	lego::globals::g_Activities_TABLE[26] = "Activity_HitBack";
	lego::globals::g_Activities_TABLE[27] = "Activity_HitHard";
	lego::globals::g_Activities_TABLE[28] = "Activity_Dynamite";
	lego::globals::g_Activities_TABLE[29] = "Activity_Deposit";
	lego::globals::g_Activities_TABLE[30] = "Activity_Clear";
	lego::globals::g_Activities_TABLE[31] = "Activity_Place";
	lego::globals::g_Activities_TABLE[32] = "Activity_Repair";
	lego::globals::g_Activities_TABLE[33] = "Activity_Slip";
	lego::globals::g_Activities_TABLE[34] = "Activity_Rest";
	lego::globals::g_Activities_TABLE[35] = "Activity_Eat";
	lego::globals::g_Activities_TABLE[36] = "Activity_Stamp";
	lego::globals::g_Activities_TABLE[37] = "Activity_ThrowMan";
	lego::globals::g_Activities_TABLE[38] = "Activity_ThrownByRockMonster";
	lego::globals::g_Activities_TABLE[39] = "Activity_GetUp";
	lego::globals::g_Activities_TABLE[40] = "Activity_BuildPath";
	lego::globals::g_Activities_TABLE[41] = "Activity_Upgrade";
	lego::globals::g_Activities_TABLE[42] = "Activity_Explode";
	lego::globals::g_Activities_TABLE[43] = "Activity_Unpowered";
	lego::globals::g_Activities_TABLE[44] = "Activity_FireLaser";
	lego::globals::g_Activities_TABLE[45] = "Activity_Freezed";
	lego::globals::g_Activities_TABLE[46] = "Activity_FreezeStart";
	lego::globals::g_Activities_TABLE[47] = "Activity_FreezeMelt";
	lego::globals::g_Activities_TABLE[48] = "Activity_Recharge";
	lego::globals::g_Activities_TABLE[49] = "Activity_WakeUp";
	lego::globals::g_Activities_TABLE[50] = "Activity_Train";
	lego::globals::g_Activities_TABLE[51] = "Activity_FloatOn";
	lego::globals::g_Activities_TABLE[52] = "Activity_FloatOff";
	lego::globals::g_Activities_TABLE[53] = "Activity_Opening";
	lego::globals::g_Activities_TABLE[54] = "Activity_Closing";
	lego::globals::g_Activities_TABLE[55] = "Activity_Open";
	lego::globals::g_Activities_TABLE[56] = "Activity_Waiting1";
	lego::globals::g_Activities_TABLE[57] = "Activity_Waiting2";
	lego::globals::g_Activities_TABLE[58] = "Activity_Waiting3";
	lego::globals::g_Activities_TABLE[59] = "Activity_Waiting4";
	lego::globals::g_Activities_TABLE[60] = "Activity_Waiting5";
	lego::globals::g_Activities_TABLE[61] = "Activity_Waiting6";
	lego::globals::g_Activities_TABLE[62] = "Activity_Waiting7";
	lego::globals::g_Activities_TABLE[63] = "Activity_Waiting8";
	lego::globals::g_Activities_TABLE[64] = "Activity_Waiting9";
	lego::globals::g_Activities_TABLE[65] = "Activity_Waiting10";
	lego::globals::g_Activities_TABLE[66] = "Activity_Waiting11";
	lego::globals::g_Activities_TABLE[67] = "Activity_Waiting12";
	lego::globals::g_Activities_TABLE[68] = "Activity_Waiting13";
	lego::globals::g_Activities_TABLE[69] = "Activity_Waiting14";
	lego::globals::g_Activities_TABLE[70] = "Activity_Waiting15";
	lego::globals::g_Activities_TABLE[71] = "Activity_Waiting16";
	lego::globals::g_Activities_TABLE[72] = "Activity_Waiting17";
	lego::globals::g_Activities_TABLE[73] = "Activity_Waiting18";
	lego::globals::g_Activities_TABLE[74] = "Activity_Waiting19";
	lego::globals::g_Activities_TABLE[75] = "Activity_Waiting20";
	lego::globals::g_Activities_TABLE[76] = "Activity_Waiting21";
	lego::globals::g_Activities_TABLE[77] = "Activity_Crumble";
	lego::globals::g_Activities_TABLE[78] = "Activity_TeleportIn";
	lego::globals::g_AbilityTypes_TABLE[0] = "LegoObject_AbilityType_Pilot";
	lego::globals::g_AbilityTypes_TABLE[1] = "LegoObject_AbilityType_Sailor";
	lego::globals::g_AbilityTypes_TABLE[2] = "LegoObject_AbilityType_Driver";
	lego::globals::g_AbilityTypes_TABLE[3] = "LegoObject_AbilityType_Dynamite";
	lego::globals::g_AbilityTypes_TABLE[4] = "LegoObject_AbilityType_Repair";
	lego::globals::g_AbilityTypes_TABLE[5] = "LegoObject_AbilityType_Scanner";
	ppLVar2 = globals::ReservedPool_LiveObject___g_TABLE;
	for (iVar1 = 0x20; iVar1 != 0; iVar1 = iVar1 + -1) {
		*ppLVar2 = (LiveObject *)0x0;
		ppLVar2 = ppLVar2 + 1;
	}
	globals::ReservedPool_LiveObject___g_NEXT = (LiveObject *)0x0;
	globals::ReservedPool_LiveObject___g_COUNT = 0;
	globals::ReservedPool_LiveObject___g_INITFLAGS = LIVEMANAGER_ISUSED;
	DAT_004dfe18 = 0;
	_DAT_004dfe1c = 0;
	_DAT_004dfe20 = 1;
	_DAT_004dfe24 = 1;
	_DAT_004dfe28 = 4;
	_DAT_004dfe2c = 4;
	_DAT_004dfe30 = 4;
	_DAT_004dfe34 = 4;
	DAT_004dfe38 = 3;
	DAT_004dfe3c = 2;
	DAT_004dfe40 = 4;
	lego::globals::g_Game.ToolTypes_TABLE[0] = "LegoObject_ToolType_Drill";
	lego::globals::g_Game.ToolTypes_TABLE[1] = "LegoObject_ToolType_Spade";
	lego::globals::g_Game.ToolTypes_TABLE[2] = "LegoObject_ToolType_Hammer";
	lego::globals::g_Game.ToolTypes_TABLE[3] = "LegoObject_ToolType_Spanner";
	lego::globals::g_Game.ToolTypes_TABLE[4] = "LegoObject_ToolType_Laser";
	lego::globals::g_Game.ToolTypes_TABLE[5] = "LegoObject_ToolType_PusherGun";
	lego::globals::g_Game.ToolTypes_TABLE[6] = "LegoObject_ToolType_BirdScarer";
	lego::globals::g_Game.ToolTypes_TABLE[7] = "LegoObject_ToolType_FreezerGun";
	return;
}



void __cdecl lego::pool::ReservedPool_LiveObject___Cleanup(void)
{
	LiveObject **ppLVar1;
	
	FUN_0043b5e0();
	ppLVar1 = globals::ReservedPool_LiveObject___g_TABLE;
	do {
		if (*ppLVar1 != (LiveObject *)0x0) {
			std::free(*ppLVar1);
		}
		ppLVar1 = ppLVar1 + 1;
	} while (ppLVar1 < &globals::ReservedPool_LiveObject___g_NEXT);
	globals::ReservedPool_LiveObject___g_NEXT = (LiveObject *)0x0;
	globals::ReservedPool_LiveObject___g_INITFLAGS = LIVEMANAGER_NONE;
	if (lego::globals::g_UnkSurfaceGrid_1_TABLE != (void *)0x0) {
		std::free(lego::globals::g_UnkSurfaceGrid_1_TABLE);
	}
	globals::ReservedPool_LiveObject___g_INITFLAGS =
			 globals::ReservedPool_LiveObject___g_INITFLAGS & ~LIVEMANAGER_ISUSED;
	return;
}



void __cdecl FUN_00437370(undefined4 *param_1)
{
	int iVar1;
	undefined4 *puVar2;
	
	puVar2 = &DAT_004eb7ac;
	for (iVar1 = 6; iVar1 != 0; iVar1 = iVar1 + -1) {
		*param_1 = *puVar2;
		puVar2 = puVar2 + 1;
		param_1 = param_1 + 1;
	}
	return;
}



void __cdecl FUN_00437390(undefined4 *param_1)
{
	int iVar1;
	undefined4 *puVar2;
	
	iVar1 = 6;
	if (param_1 != (undefined4 *)0x0) {
		puVar2 = &DAT_004eb7ac;
		for (; iVar1 != 0; iVar1 = iVar1 + -1) {
			*puVar2 = *param_1;
			param_1 = param_1 + 1;
			puVar2 = puVar2 + 1;
		}
		return;
	}
	puVar2 = &DAT_004eb7ac;
	for (; iVar1 != 0; iVar1 = iVar1 + -1) {
		*puVar2 = 0;
		puVar2 = puVar2 + 1;
	}
	return;
}



int __cdecl FUN_004373c0(int param_1,int param_2)
{
	ObjectStatsFlags1 OVar1;
	int iVar2;
	int iVar3;
	uint objIndex;
	uint objLevel;
	
	iVar3 = 0;
	objIndex = 0;
	do {
		objLevel = 0;
		do {
			if (param_2 == 0) {
LAB_004373e4:
				iVar2 = lego::game::LiveObject_GetOrSubLevelsTable(param_1,objIndex,objLevel,1);
				iVar3 = iVar3 + iVar2;
			}
			else {
				OVar1 = lego::game::Object_GetStatsFlags1(param_1,objIndex);
				if ((OVar1 & STATS1_STOREOBJECTS) == STATS1_NONE) goto LAB_004373e4;
			}
			objLevel = objLevel + 1;
		} while (objLevel < 0x10);
		objIndex = objIndex + 1;
		if (0xe < objIndex) {
			return iVar3;
		}
	} while( true );
}



void __cdecl lego::main::Main_LoadToolTipIcons(CFGProperty *root)
{
	char *keyPath;
	CFGProperty *prop;
	int iVar1;
	ImageBMP *pIVar2;
	int iVar3;
	char **ppcVar4;
	
	keyPath = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"ToolTipIcons",0);
	prop = cfg::CFG_GetChildren(root,keyPath);
	do {
		if (prop == (CFGProperty *)0x0) {
			if (globals::g_ToolTipIcon_Ore != (ImageBMP *)0x0) {
				image::Image_SetupTrans(globals::g_ToolTipIcon_Ore,0.0,0.0,0.0,0.0,0.0,0.0);
			}
			return;
		}
		iVar3 = 0;
		ppcVar4 = globals::g_Game.ToolTypes_TABLE;
		do {
			if ((*ppcVar4 != (char *)0x0) && (iVar1 = std::_stricmp(prop->key,*ppcVar4), iVar1 == 0)) {
				pIVar2 = image::Image_LoadBMPScaled(prop->value,0,0);
				globals::g_ToolTipIcons_Tools_TABLE[iVar3] = pIVar2;
				break;
			}
			ppcVar4 = ppcVar4 + 1;
			iVar3 = iVar3 + 1;
		} while (ppcVar4 < globals::g_Game.ToolNames_TABLE);
		if (iVar3 == 0xb) {
			iVar3 = 0;
			ppcVar4 = globals::g_AbilityTypes_TABLE;
			do {
				if (((ImageBMP *)*ppcVar4 != (ImageBMP *)0x0) &&
					 (iVar1 = std::_stricmp(prop->key,(char *)(ImageBMP *)*ppcVar4), iVar1 == 0)) {
					pIVar2 = image::Image_LoadBMPScaled(prop->value,0,0);
					globals::g_ToolTipIcons_Abilities_TABLE[iVar3] = pIVar2;
					break;
				}
				ppcVar4 = (char **)((ImageBMP **)ppcVar4 + 1);
				iVar3 = iVar3 + 1;
			} while (ppcVar4 < globals::g_ToolTipIcons_Abilities_TABLE);
		}
		if (iVar3 == 6) {
			iVar3 = std::_stricmp(prop->key,"Blank");
			if (iVar3 == 0) {
				globals::g_ToolTipIcon_Blank = image::Image_LoadBMPScaled(prop->value,0,0);
			}
			else {
				iVar3 = std::_stricmp(prop->key,"Ore");
				if (iVar3 == 0) {
					globals::g_ToolTipIcon_Ore = image::Image_LoadBMPScaled(prop->value,0,0);
				}
			}
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



void __cdecl FUN_00437560(void)
{
	int iVar1;
	Point2I *pPVar2;
	LiveObject **ppLVar3;
	
	FUN_0043b5e0();
	FUN_00437700();
	FUN_00437ba0();
	pPVar2 = lego::globals::g_SlimySlugHoles_TABLE;
	for (iVar1 = 0x28; iVar1 != 0; iVar1 = iVar1 + -1) {
		pPVar2->x = 0;
		pPVar2 = (Point2I *)&pPVar2->y;
	}
	pPVar2 = lego::globals::g_RechargeSeams_TABLE;
	for (iVar1 = 0x14; iVar1 != 0; iVar1 = iVar1 + -1) {
		pPVar2->x = 0;
		pPVar2 = (Point2I *)&pPVar2->y;
	}
	lego::globals::g_SlimySlugHoles_COUNT = 0;
	lego::globals::g_RechargeSeams_COUNT = 0;
	FLOAT_004eb7a8 = 0.0;
	ppLVar3 = PTR_ARRAY_004ebbcc;
	for (iVar1 = 100; iVar1 != 0; iVar1 = iVar1 + -1) {
		*ppLVar3 = (LiveObject *)0x0;
		ppLVar3 = ppLVar3 + 1;
	}
	UINT_004ebd5c = 0;
	lego::game::Game_SetNumBuildingsTeleported(0);
	return;
}



void __cdecl
lego::game::LiveObject_Weapon_FUN_004375c0(LiveObject *in_liveObj,int weaponType,float param_3)
{
	LiveObject *pLVar1;
	float10 fVar2;
	Point2I local_8;
	
	if (weaponType == -1) {
		fVar2 = (float10)param_3;
	}
	else {
		fVar2 = tools::Weapon_GetDischargeRate(weaponType);
		fVar2 = fVar2 * (float10)param_3;
	}
	FLOAT_004eb7a8 = (float)(fVar2 + (float10)FLOAT_004eb7a8);
	LiveObject_GetBlockCoordinates(in_liveObj,(int *)&local_8,&local_8.y);
	while (((1.0 <= FLOAT_004eb7a8 &&
					(pLVar1 = FUN_00438d20(&local_8,OBJECT_POWERCRYSTAL,0,0), pLVar1 != (LiveObject *)0x0)) &&
				 (pLVar1 = (LiveObject *)FUN_0043a910(pLVar1,OBJECT_POWERCRYSTAL,0,0),
				 pLVar1 != (LiveObject *)0x0))) {
		pLVar1->flags3 = pLVar1->flags3 | LIVEOBJ3_UNK_80000000;
		LiveObject_SetCrystalPoweredColor(pLVar1,0);
		FLOAT_004eb7a8 = FLOAT_004eb7a8 - 1.0;
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_00437690(LiveObject *liveObj,BOOL condition)
{
	BOOL BVar1;
	
	if ((condition == 0) && ((liveObj->flags4 & LIVEOBJ4_UNK_2000) != LIVEOBJ4_NONE)) {
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_2000 | LIVEOBJ4_UNK_4000;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_CLOSING,0);
		BVar1 = Game_UpdateSomeAITasks(liveObj);
		return BVar1;
	}
	if ((condition != 0) && ((liveObj->flags4 & LIVEOBJ4_UNK_2000) == LIVEOBJ4_NONE)) {
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_1000;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_OPENING,0);
	}
	BVar1 = Game_UpdateSomeAITasks(liveObj);
	return BVar1;
}



void __cdecl FUN_00437700(void)
{
	int iVar1;
	uint (*paauVar2) [15] [16];
	
	paauVar2 = lego::globals::g_LiveObjectLevels_Previous_TABLE;
	for (iVar1 = 0x12c0; iVar1 != 0; iVar1 = iVar1 + -1) {
		(*paauVar2)[0] = 0;
		paauVar2 = (uint (*) [15] [16])(*paauVar2 + 1);
	}
	paauVar2 = lego::globals::g_LiveObjectLevels_Current_TABLE;
	for (iVar1 = 0x12c0; iVar1 != 0; iVar1 = iVar1 + -1) {
		(*paauVar2)[0] = 0;
		paauVar2 = (uint (*) [15] [16])(*paauVar2 + 1);
	}
	return;
}



int __cdecl
lego::game::LiveObject_GetOrSubLevelsTable
					(ObjectType objType,int objIndex,int objLevel,BOOL doSubtract)
{
	uint uVar1;
	
	uVar1 = globals::g_LiveObjectLevels_Current_TABLE[objType][objIndex][objLevel];
	if (doSubtract != 0) {
		uVar1 = uVar1 - globals::g_LiveObjectLevels_Previous_TABLE[objType][objIndex][objLevel];
	}
	return uVar1;
}



uint __cdecl lego::game::LiveObject_GetPreviousLevel(ObjectType objType,int objIndex,int objLevel)
{
	return globals::g_LiveObjectLevels_Previous_TABLE[objType][objIndex][objLevel];
}



void __cdecl lego::unk::Lego_PathLiveLevelsIncrementConditional(BOOL param_1)
{
	if (param_1 != 0) {
		globals::g_LiveObjectLevels_Current_TABLE[15][0][0] =
				 globals::g_LiveObjectLevels_Current_TABLE[15][0][0] + 1;
		return;
	}
	globals::g_LiveObjectLevels_Previous_TABLE[15][0][0] =
			 globals::g_LiveObjectLevels_Previous_TABLE[15][0][0] + 1;
	return;
}



void __cdecl lego::game::LiveObject_FUN_004377b0(LiveObject *liveObj)
{
	if (liveObj->objType != OBJECT_BOULDER) {
		unk::DoLiveObjCallbacks_True_FUN_00437a70(LiveObject_FUN_004377d0,liveObj);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_004377d0(LiveObject *liveObj1,LiveObject *liveObj2)
{
	if (liveObj1->object_2fc == liveObj2) {
		LiveObject_UnkDoRouting_FUN_00441c00(liveObj1,0);
		liveObj1->object_2fc = (LiveObject *)0x0;
	}
	return 0;
}



BOOL __cdecl lego::pool::ReservedPool_LiveObject___Release(LiveObject *liveObj)
{
	LiveFlags4 *pLVar1;
	LiveObject *pLVar2;
	ObjectType OVar3;
	ObjectStatsFlags1 OVar4;
	VehicleData *buffer;
	
	lego::globals::g_LiveObjectLevels_Previous_TABLE[liveObj->objType][liveObj->objIndex]
	[liveObj->objLevel] =
			 lego::globals::g_LiveObjectLevels_Previous_TABLE[liveObj->objType][liveObj->objIndex]
			 [liveObj->objLevel] + 1;
	if ((liveObj->flags4 & LIVEOBJ4_UNK_100000) != LIVEOBJ4_NONE) {
		snd::Sample_StopSoundBufferInstance(liveObj->field_350);
	}
	if ((liveObj->flags4 & LIVEOBJ4_UNK_80000) != LIVEOBJ4_NONE) {
		snd::Sample_StopSoundBufferInstance(liveObj->field_354);
	}
	unk::DoLiveObjCallbacks_True_FUN_00437a70(game::LiveObject_SetField_3c4,liveObj);
	if (liveObj->objType == OBJECT_ROCKMONSTER) {
		game::LiveObject_FUN_004029d0(liveObj);
	}
	if (liveObj->resData_2e4 != (Container *)0x0) {
		res::Container_Remove(liveObj->resData_2e4);
	}
	if (liveObj->carryingThisObject != (LiveObject *)0x0) {
		game::LiveObject_FUN_0043a130(liveObj->carryingThisObject,0);
	}
	if ((liveObj->flags4 & LIVEOBJ4_UNK_40) != LIVEOBJ4_NONE) {
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_40;
		if (liveObj->object_2fc != (LiveObject *)0x0) {
			pLVar1 = &liveObj->object_2fc->flags4;
			*pLVar1 = *pLVar1 & ~LIVEOBJ4_UNK_40;
		}
	}
	game::LiveObject_FUN_0043abf0(liveObj);
	if ((*(byte *)&liveObj->flags4 & 1) != 0) {
		lego::globals::g_Game.flags1 = lego::globals::g_Game.flags1 & ~GAME1_LASERTRACKER;
	}
	if ((*(byte *)&liveObj->flags4 & 0x80) != 0) {
		pLVar2 = liveObj->object_2fc;
		if (pLVar2 != (LiveObject *)0x0) {
			pLVar2->flags4 = pLVar2->flags4 & ~LIVEOBJ4_UNK_80;
		}
		liveObj->object_2fc = (LiveObject *)0x0;
	}
	game::LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
	game::LiveObject_FUN_00447bc0(liveObj);
	game::LiveObject_FUN_0043a130(liveObj,0);
	game::LiveObject_FUN_00403980(liveObj);
	game::LiveObject_FUN_0043f820(liveObj);
	game::LiveObject_ClearPtr_004c8ea4_IfEqual(liveObj);
	OVar4 = game::LiveObject_GetStatsFlags1(liveObj);
	if (((OVar4 & STATS1_PROCESSCRYSTAL) != STATS1_NONE) ||
		 (OVar4 = game::LiveObject_GetStatsFlags1(liveObj), (OVar4 & STATS1_PROCESSORE) != STATS1_NONE))
	{
		game::LiveObject_FUN_00403940(liveObj);
	}
	game::LiveObject_FUN_00452770(liveObj);
	game::LiveObject_FUN_00419760(liveObj);
	game::LiveObject_FUN_004072d0(liveObj);
	game::LiveObject_FUN_004377b0(liveObj);
	game::LiveObject_FUN_0042def0(liveObj);
	OVar3 = liveObj->objType;
	if (OVar3 == OBJECT_VEHICLE) {
		res::Vehicle_Destroy(liveObj->vehicle);
		buffer = liveObj->vehicle;
	}
	else {
		if (OVar3 == OBJECT_MINIFIGURE) {
			res::Creature_Destroy(liveObj->miniFigure);
			buffer = (VehicleData *)liveObj->miniFigure;
		}
		else {
			if (OVar3 == OBJECT_ROCKMONSTER) {
				OVar4 = game::LiveObject_GetStatsFlags1(liveObj);
				if ((OVar4 & STATS1_FLOCKS) != STATS1_NONE) {
					game::LiveObject_FlocksDestroy(liveObj);
				}
				res::Creature_Destroy(liveObj->rockMonster);
				buffer = (VehicleData *)liveObj->rockMonster;
			}
			else {
				if (OVar3 == OBJECT_BUILDING) {
					res::Building_Destroy(liveObj->building);
					buffer = (VehicleData *)liveObj->building;
				}
				else {
					if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
						res::Container_Remove(liveObj->other);
						goto LAB_00437a4d;
					}
					if (OVar3 != OBJECT_UPGRADEPART) goto LAB_00437a4d;
					res::Upgrade_Destroy(liveObj->upgrade);
					buffer = (VehicleData *)liveObj->upgrade;
				}
			}
		}
	}
	std::free(buffer);
LAB_00437a4d:
	liveObj->pool_m_next = globals::ReservedPool_LiveObject___g_NEXT;
	globals::ReservedPool_LiveObject___g_NEXT = liveObj;
	return 0;
}



BOOL __cdecl
lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
					(LiveObjectPredicate *predicateFunc,LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = DoLiveObjCallbacks_FUN_00437a90(predicateFunc,liveObj,1);
	return BVar1;
}



BOOL __cdecl
lego::unk::DoLiveObjCallbacks_FUN_00437a90
					(LiveObjectPredicate *predicateFunc,void *context,BOOL param_3)
{
	LiveObject *liveObj;
	BOOL BVar1;
	int iVar2;
	LiveObject **ppLVar3;
	uint uVar4;
	uint uVar5;
	uint tblIndex;
	
	tblIndex = 0;
	if (pool::globals::ReservedPool_LiveObject___g_COUNT == 0) {
		return 0;
	}
	ppLVar3 = pool::globals::ReservedPool_LiveObject___g_TABLE;
	do {
		if (*ppLVar3 != (LiveObject *)0x0) {
			uVar5 = 0;
			uVar4 = 1 << ((byte)tblIndex & 0x1f);
			if (uVar4 != 0) {
				iVar2 = 0;
				do {
					liveObj = (LiveObject *)((int)(*ppLVar3)->floats_34 + iVar2 + -0x34);
					if ((((liveObj != (LiveObject *)0x0) && (liveObj->pool_m_next == liveObj)) &&
							((param_3 == 0 || ((liveObj->flags3 & LIVEOBJ3_UNK_80000) == LIVEOBJ3_NONE)))) &&
						 (BVar1 = (*predicateFunc)(liveObj,context), BVar1 != 0)) {
						return 1;
					}
					uVar5 = uVar5 + 1;
					iVar2 = iVar2 + 0x40c;
				} while (uVar5 < uVar4);
			}
		}
		tblIndex = tblIndex + 1;
		ppLVar3 = ppLVar3 + 1;
		if (pool::globals::ReservedPool_LiveObject___g_COUNT <= tblIndex) {
			return 0;
		}
	} while( true );
}



void __cdecl lego::game::LiveObject_SetCustomName(LiveObject *liveObj,char *customName)
{
	char *pcVar1;
	
	if ((customName != (char *)0x0) && (*customName != '\0')) {
										// There is no regard for memory bounds here,
										// allocates 11 bytes, assigns bytes[11]...
										// why......
		if (liveObj->customName == (char *)0x0) {
			pcVar1 = (char *)std::malloc(0xb);
			liveObj->customName = pcVar1;
		}
		std::_strncpy(liveObj->customName,customName,0xb);
		liveObj->customName[0xb] = '\0';
		return;
	}
	if (liveObj->customName != (char *)0x0) {
		std::free(liveObj->customName);
	}
	liveObj->customName = (char *)0x0;
	return;
}



void __cdecl FUN_00437ba0(void)
{
	int iVar1;
	void **ppvVar2;
	uint uVar3;
	undefined4 *puVar4;
	
	uVar3 = 0;
	if (DAT_004eb7a4 != 0) {
		ppvVar2 = (void **)&DAT_004e9568;
		do {
			if (ppvVar2[1] != (void *)0x0) {
				std::free(ppvVar2[1]);
			}
			if (*ppvVar2 != (void *)0x0) {
				std::free(*ppvVar2);
			}
			uVar3 = uVar3 + 1;
			ppvVar2 = ppvVar2 + 0xb;
		} while (uVar3 < DAT_004eb7a4);
	}
	DAT_004eb7a4 = 0;
	puVar4 = &DAT_004e9544;
	for (iVar1 = 200; iVar1 != 0; iVar1 = iVar1 + -1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	lego::game::Game_ClearHiddenObjectsFound();
	return;
}



void __cdecl FUN_00437c00(Point2I *param_1)
{
	char *pcVar1;
	char *pcVar2;
	LiveObject *liveObj;
	Point2I *pPVar3;
	LiveObject *pLVar4;
	ObjectStatsFlags3 OVar5;
	ObjectStatsFlags1 OVar6;
	int iVar7;
	Point2I *translation;
	uint uVar8;
	Direction rotation;
	int *piVar9;
	uint uVar10;
	longlong lVar11;
	TrainedFlags trainFlags;
	char **local_96c;
	uint local_968;
	uint local_964;
	LiveObject *apLStack2400 [200];
	char *local_640 [200];
	char *apcStack800 [200];
	
	uVar10 = 0;
	uVar8 = 0;
	local_968 = 0;
	if (DAT_004eb7a4 != 0) {
		local_96c = local_640;
		translation = (Point2I *)&DAT_004e9544;
		do {
			pPVar3 = translation;
			if ((translation->x == param_1->x) && (translation->y == param_1->y)) {
				if (translation[3].x == OBJECT_BUILDING) {
					pPVar3 = lego::res::Building_GetShapePoints
														 (lego::globals::g_Game.BuildingData_TABLE + translation[3].y,&local_964
														 );
					lVar11 = __ftol((float10)(float)translation[2].x * (float10)0.1591549 * (float10)8.0);
					rotation = ((uint)lVar11 & 1) + (uint)lVar11 >> 1;
					pPVar3 = lego::game::Game_TransformShapePoints(translation,pPVar3,local_964,rotation);
					pLVar4 = (LiveObject *)
									 FUN_004099c0(translation[3].y,(int *)translation,rotation,(uint *)pPVar3,
																local_964,0);
					uVar10 = local_968;
				}
				else {
					pLVar4 = lego::game::LiveObject__Create
														 ((int **)translation[2].y,translation[3].x,translation[3].y);
				}
				if (pLVar4 != (LiveObject *)0x0) {
					if (translation[3].x != 4) {
						lego::game::LiveObject_UnkUpdatePositioning
											(pLVar4,(float)translation[1].x,(float)translation[1].y,translation[2].x,1);
					}
					iVar7 = translation[3].x;
					if ((((iVar7 == 6) || (iVar7 == 7)) || (iVar7 == 8)) || (iVar7 == 9)) {
						lego::ai::AITask_DoCollect(pLVar4,0.0);
					}
					pLVar4->health = (float)translation[4].x;
					if (pLVar4->objType == OBJECT_MINIFIGURE) {
						lego::game::Game_IncHiddenObjectsFound(OBJECT_MINIFIGURE);
						lego::front::Info_FUN_00419ab0(INFO_FOUNDMINIFIGURE,(char *)0x0,pLVar4,(Point2I *)0x0);
					}
					pLVar4->flags4 = pLVar4->flags4 | 0x200;
					lego::game::LiveObject_FUN_00438720(pLVar4);
					if (pLVar4->objType == OBJECT_ELECTRICFENCE) {
						lego::game::LiveObject_AssignBlockObject(pLVar4);
					}
					pcVar1 = (char *)translation[4].y;
					pcVar2 = (char *)translation[5].x;
					apLStack2400[uVar10] = pLVar4;
					apcStack800[uVar10] = pcVar1;
					*local_96c = pcVar2;
					local_968 = uVar10 + 1;
					local_96c = local_96c + 1;
					translation[4].y = 0;
				}
				DAT_004eb7a4 = DAT_004eb7a4 - 1;
				uVar8 = uVar8 - 1;
				pPVar3 = (Point2I *)&translation[-6].y;
				piVar9 = &DAT_004e9544 + DAT_004eb7a4 * 0xb;
				for (iVar7 = 0xb; uVar10 = local_968, iVar7 != 0; iVar7 = iVar7 + -1) {
					translation->x = *piVar9;
					piVar9 = piVar9 + 1;
					translation = (Point2I *)&translation->y;
				}
			}
			uVar8 = uVar8 + 1;
			translation = (Point2I *)&pPVar3[5].y;
		} while (uVar8 < DAT_004eb7a4);
	}
	local_96c = (char **)0x0;
	if (uVar10 != 0) {
		do {
			pcVar1 = local_640[(int)local_96c];
			if (pcVar1 != (char *)0x0) {
				uVar8 = 0;
				do {
					if ((local_96c != (char **)uVar8) &&
						 (iVar7 = std::_stricmp(apcStack800[uVar8],pcVar1), iVar7 == 0)) {
						pLVar4 = apLStack2400[(int)local_96c];
						liveObj = apLStack2400[uVar8];
						pLVar4->object_2fc = liveObj;
						pLVar4->flags2 = pLVar4->flags2 | LIVEOBJ2_UNK_4;
						OVar5 = lego::game::LiveObject_GetStatsFlags3(liveObj);
						if ((OVar5 & STATS3_NEEDSPILOT) == STATS3_NONE) {
							OVar6 = lego::game::LiveObject_GetStatsFlags1(liveObj);
							if ((OVar6 & STATS1_CROSSWATER) == STATS1_NONE) {
								trainFlags = TRAINED_DRIVER;
							}
							else {
								OVar6 = lego::game::LiveObject_GetStatsFlags1(liveObj);
								if ((OVar6 & STATS1_CROSSLAND) == STATS1_NONE) {
									trainFlags = TRAINED_SAILOR;
								}
								else {
									trainFlags = TRAINED_PILOT;
								}
							}
						}
						else {
							trainFlags = TRAINED_PILOT;
						}
						lego::game::LiveObject_TrainMiniFigure_instantunk(pLVar4,trainFlags);
						FUN_0043f3c0(pLVar4,(int)liveObj);
						uVar10 = local_968;
					}
					uVar8 = uVar8 + 1;
				} while (uVar8 < uVar10);
			}
			local_96c = (char **)((int)local_96c + 1);
		} while (local_96c < uVar10);
	}
	uVar8 = 0;
	if (uVar10 != 0) {
		do {
			if (local_640[uVar8] != (char *)0x0) {
				std::free(local_640[uVar8]);
			}
			if (apcStack800[uVar8] != (char *)0x0) {
				std::free(apcStack800[uVar8]);
			}
			uVar8 = uVar8 + 1;
		} while (uVar8 < uVar10);
	}
	return;
}



void __cdecl
FUN_00437ee0(undefined4 param_1,undefined4 param_2,undefined4 param_3,float *param_4,
						undefined4 param_5,undefined4 param_6,char *param_7,char *param_8)
{
	int iVar1;
	int iVar2;
	char *pcVar3;
	SurfaceMap *surfMap;
	float in_x;
	float fVar4;
	int *out_x;
	int *out_y;
	
	iVar2 = DAT_004eb7a4;
	out_x = &DAT_004e9544 + DAT_004eb7a4 * 0xb;
	iVar1 = DAT_004eb7a4 * 0xb;
	DAT_004eb7a4 = DAT_004eb7a4 + 1;
	(&DAT_004e954c)[iVar1] = *param_4;
	fVar4 = param_4[1];
	(&DAT_004e9558)[iVar2 * 0xb] = param_1;
	(&DAT_004e9550)[iVar2 * 0xb] = fVar4;
	(&DAT_004e9564)[iVar2 * 0xb] = param_6;
	(&DAT_004e9554)[iVar2 * 0xb] = param_5;
	(&DAT_004e955c)[iVar2 * 0xb] = param_2;
	(&DAT_004e9560)[iVar2 * 0xb] = param_3;
	if (param_7 != (char *)0x0) {
		pcVar3 = std::_strdup(param_7);
		(&DAT_004e9568)[iVar2 * 0xb] = pcVar3;
	}
	if (param_8 != (char *)0x0) {
		pcVar3 = std::_strdup(param_8);
		(&DAT_004e956c)[iVar2 * 0xb] = pcVar3;
	}
	fVar4 = param_4[1];
	in_x = *param_4;
	out_y = &DAT_004e9548 + iVar2 * 0xb;
	surfMap = lego::game::GetSurfaceMap();
	lego::game::SurfaceMap_ToBlockCoordinatesNoZ(surfMap,in_x,fVar4,out_x,out_y);
	return;
}



BOOL __cdecl lego::game::LiveObject_CanShootObject(LiveObject *liveObj)
{
	ObjectStatsFlags2 OVar1;
	float10 fVar2;
	
	OVar1 = LiveObject_GetStatsFlags2(liveObj);
	if ((OVar1 & STATS2_CANBESHOTAT) != STATS2_NONE) {
		fVar2 = LiveObject_GetPainThreshold(liveObj);
		if (fVar2 < (float10)liveObj->health) {
			return 1;
		}
	}
	return 0;
}



LiveObject * __cdecl lego::game::LiveObject__Create(int **srcData,ObjectType objType,int objIndex)
{
	ObjectType OVar1;
	LiveObject *liveObj;
	BOOL BVar2;
	VehicleData *out_vehicle;
	uint uVar3;
	ObjectStatsFlags1 OVar4;
	CreatureData *pCVar5;
	BuildingData *out_building;
	UpgradeData *out_upgrade;
	Container *cont;
	LiveFlags3 LVar6;
	BOOL BVar7;
	ObjectStatsFlags2 OVar8;
	
	liveObj = pool::ReservedPool_LiveObject___Next();
	if (liveObj == (LiveObject *)0x0) {
		return (LiveObject *)0x0;
	}
	liveObj->objType = objType;
	liveObj->objIndex = objIndex;
	liveObj->flags3 = LIVEOBJ3_NONE;
	liveObj->health = (float)&DAT_42c80000;
	liveObj->energy = (float)&DAT_42c80000;
	res::Container_EnableSoundTriggers(0);
	BVar2 = snd::Audio_IsSoundOn();
	snd::Audio_SetIsSoundOn_AndOtherFunc(0,0);
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		out_vehicle = (VehicleData *)std::malloc(0x1ec);
		liveObj->vehicle = out_vehicle;
		res::Vehicle_Duplicate((VehicleData *)srcData,out_vehicle);
		res::Vehicle_SetOwnerObject(liveObj->vehicle,liveObj);
		uVar3 = res::Vehicle_GetCarryNullFrames(liveObj->vehicle);
		liveObj->field_328 = uVar3;
		res::Vehicle_ChangeUpgradeParts(liveObj->vehicle,0);
		liveObj->flags5_3f0 = 0x20;
		liveObj->flags3 = liveObj->flags3 | 0x441190;
		LiveObject_SetLevel(liveObj,0);
		if (srcData[0x2d] != (int *)0x0) {
			liveObj->flags3 = liveObj->flags3 | 2;
		}
		if (srcData[0x37] != (int *)0x0) {
			liveObj->flags3 = liveObj->flags3 | 0x20;
			OVar4 = LiveObject_GetStatsFlags1(liveObj);
			if ((OVar4 & STATS1_CROSSLAND) != STATS1_NONE) {
				liveObj->flags3 = liveObj->flags3 | 0x40;
			}
		}
		goto LAB_00438452;
	}
	if (OVar1 == OBJECT_MINIFIGURE) {
		pCVar5 = (CreatureData *)std::malloc(0x74);
		liveObj->miniFigure = pCVar5;
		res::Creature_Duplicate((CreatureData *)srcData,pCVar5);
		res::Object_SetOwnerObject((BasicObjectData *)liveObj->miniFigure,liveObj);
		uVar3 = nerps::funcs::NERPFunc__True((int *)liveObj->miniFigure);
		LVar6 = liveObj->flags3;
		liveObj->field_328 = uVar3;
		liveObj->flags3 = LVar6 | 0x4401f5;
		if (srcData[0xb] != (int *)0x0) {
			liveObj->flags3 = LVar6 | 0x4401f7;
		}
		LiveObject_SetLevel(liveObj,0);
		liveObj->flags3 = liveObj->flags3 | 0x8000;
		MiniFigure_EquipTool(liveObj,TOOL_DRILL);
		goto LAB_00438452;
	}
	if (OVar1 == OBJECT_ROCKMONSTER) {
		pCVar5 = (CreatureData *)std::malloc(0x74);
		liveObj->rockMonster = pCVar5;
		res::Creature_Duplicate((CreatureData *)srcData,pCVar5);
		res::Object_SetOwnerObject((BasicObjectData *)liveObj->rockMonster,liveObj);
		uVar3 = nerps::funcs::NERPFunc__True((int *)liveObj->rockMonster);
		LVar6 = liveObj->flags3;
		liveObj->field_328 = uVar3;
		liveObj->flags3 = LVar6 | 0x8440200;
		if (srcData[0xb] != (int *)0x0) {
			liveObj->flags3 = LVar6 | 0x8440202;
		}
		LiveObject_SetLevel(liveObj,0);
		OVar4 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar4 & STATS1_FLOCKS) == STATS1_NONE) {
			liveObj->flocksData_32c = (FlockData *)0x0;
		}
		else {
			LiveObject_FlocksInit(liveObj);
			OVar4 = LiveObject_GetStatsFlags1(liveObj);
			if ((OVar4 & STATS1_FLOCKS_DEBUG) == STATS1_NONE) {
				LiveObject_FUN_0044a210(liveObj,1);
				liveObj->flags3 = liveObj->flags3 & 0xfffffeff;
			}
		}
		BVar7 = LiveObject_CanShootObject(liveObj);
		if (BVar7 != 0) {
			ai::AITask_DoAttackRockMonster_Target(liveObj);
		}
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_80000000;
		goto LAB_00438452;
	}
	if (OVar1 == OBJECT_BUILDING) {
		out_building = (BuildingData *)std::malloc(0x14c);
		liveObj->building = out_building;
		res::Building_Duplicate((BuildingData *)srcData,out_building);
		res::Object_SetOwnerObject((BasicObjectData *)liveObj->building,liveObj);
		uVar3 = res::Res_GetBuildingCarryNullFrames(liveObj->building);
		liveObj->field_328 = uVar3;
		liveObj->flags3 = liveObj->flags3 | 0x40100;
		LiveObject_BuildingChangeUpgradeParts(liveObj->building,0);
		LiveObject_SetLevel(liveObj,0);
		OVar4 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar4 & STATS1_SMALLTELEPORTER) != STATS1_NONE) {
			globals::g_Game.placeDestSmallTeleporter = liveObj;
		}
		OVar4 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar4 & STATS1_BIGTELEPORTER) != STATS1_NONE) {
			globals::g_Game.placeDestBigTeleporter = liveObj;
		}
		OVar4 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar4 & STATS1_WATERTELEPORTER) != STATS1_NONE) {
			globals::g_Game.placeDestWaterTeleporter = liveObj;
		}
		LiveObject_GetStatsFlags1(liveObj);
		OVar4 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar4 & STATS1_SNAXULIKE) != STATS1_NONE) {
			ai::AITask_DoGotoEat(liveObj);
		}
		ai::AITask_DoRepair(liveObj);
		liveObj->flags5_3f0 = 0x20;
		Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
		goto LAB_00438452;
	}
	if (OVar1 == OBJECT_UPGRADEPART) {
		out_upgrade = (UpgradeData *)std::malloc(0x10);
		liveObj->upgrade = out_upgrade;
		res::Upgrade_Duplicate((UpgradeData *)srcData,out_upgrade);
		liveObj->stats = &globals::const::c_ObjectStats_Upgrade;
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_80000;
		goto LAB_00438452;
	}
	cont = res::Container_Clone((Container *)srcData);
	liveObj->other = cont;
	res::Container_SetUserData(cont,liveObj);
	LVar6 = liveObj->flags3;
	OVar1 = liveObj->objType;
	liveObj->flags3 = LVar6 | LIVEOBJ3_SIMPLEOBJECT;
	if (OVar1 == OBJECT_ELECTRICFENCE) {
		liveObj->flags3 = LVar6 | 0x60100;
	}
	if ((OVar1 == OBJECT_ORE) || (OVar1 == OBJECT_POWERCRYSTAL)) {
		LVar6 = liveObj->flags3 | 0x100100;
LAB_004383f9:
		liveObj->flags3 = LVar6;
	}
	else {
		if ((OVar1 == OBJECT_DYNAMITE) || (OVar1 == OBJECT_OOHSCARY)) {
			LVar6 = liveObj->flags3 | 0x40000;
			goto LAB_004383f9;
		}
	}
	LiveObject_SetCrystalPoweredColor(liveObj,1);
	switch(liveObj->objType) {
	case OBJECT_DYNAMITE:
		liveObj->stats = &globals::const::c_ObjectStats_Dynamite;
		break;
	case OBJECT_BARRIER:
		liveObj->stats = &globals::const::c_ObjectStats_Barrier;
		break;
	default:
		LiveObject_SetLevel(liveObj,0);
		break;
	case OBJECT_SPIDERWEB:
	case OBJECT_OOHSCARY:
	case OBJECT_ELECTRICFENCESTUD:
	case OBJECT_PUSHER:
	case OBJECT_FREEZER:
	case OBJECT_ICECUBE:
	case OBJECT_LASERSHOT:
		liveObj->stats = &globals::const::c_ObjectStats_Enemy;
	}
LAB_00438452:
	liveObj->aitaskName2 = globals::g_Activities_TABLE[0];
	liveObj->aitaskName1 = globals::g_Activities_TABLE[9];
	BVar7 = Game_UpdateSomeAITasks(liveObj);
	if (BVar7 != 0) {
		liveObj->flags3 = liveObj->flags3 | 8;
	}
	liveObj->aitaskName1 = globals::g_Activities_TABLE[16];
	BVar7 = Game_UpdateSomeAITasks(liveObj);
	if (BVar7 != 0) {
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_4000000;
	}
	liveObj->aitaskName1 = globals::g_Activities_TABLE[2];
	BVar7 = Game_UpdateSomeAITasks(liveObj);
	if (BVar7 != 0) {
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_10000000;
	}
	liveObj->aitaskName1 = globals::g_Activities_TABLE[0];
	Game_UpdateSomeAITasks(liveObj);
	LiveObject_FUN_00403e90(liveObj);
	res::Container_EnableSoundTriggers(1);
	if (BVar2 != 0) {
		snd::Audio_SetIsSoundOn_AndOtherFunc(1,0);
	}
	FUN_0043c830(liveObj);
	globals::g_LiveObjectLevels_Current_TABLE[liveObj->objType][liveObj->objIndex][0] =
			 globals::g_LiveObjectLevels_Current_TABLE[liveObj->objType][liveObj->objIndex][0] + 1;
	OVar8 = LiveObject_GetStatsFlags2(liveObj);
	if ((OVar8 & STATS2_UNSELECTABLE) != STATS2_NONE) {
		liveObj->flags3 = liveObj->flags3 & 0xfffffeff;
	}
	return liveObj;
}



LiveObject * __cdecl lego::pool::ReservedPool_LiveObject___Next(void)
{
	int iVar1;
	LiveObject *pLVar2;
	LiveObject *liveObj;
	
	if (globals::ReservedPool_LiveObject___g_NEXT == (LiveObject *)0x0) {
		ReservedPool_LiveObject___Alloc();
	}
	liveObj = globals::ReservedPool_LiveObject___g_NEXT;
	pLVar2 = globals::ReservedPool_LiveObject___g_NEXT;
	globals::ReservedPool_LiveObject___g_NEXT = globals::ReservedPool_LiveObject___g_NEXT->pool_m_next
	;
	for (iVar1 = 0x103; iVar1 != 0; iVar1 = iVar1 + -1) {
		pLVar2->objType = OBJECT_NONE;
		pLVar2 = (LiveObject *)&pLVar2->objIndex;
	}
	liveObj->pool_m_next = liveObj;
	(liveObj->point_2f4).y = -1.0;
	(liveObj->point_2f4).x = -1.0;
	return liveObj;
}



void __cdecl lego::pool::ReservedPool_LiveObject___Alloc(void)
{
	LiveObject *pLVar1;
	LiveObject *pLVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globals::ReservedPool_LiveObject___g_COUNT & 0x1f);
	pLVar2 = (LiveObject *)std::malloc(uVar4 * 0x40c);
	globals::ReservedPool_LiveObject___g_TABLE[globals::ReservedPool_LiveObject___g_COUNT] = pLVar2;
	pLVar2 = globals::ReservedPool_LiveObject___g_TABLE[globals::ReservedPool_LiveObject___g_COUNT];
	if (pLVar2 != (LiveObject *)0x0) {
		globals::ReservedPool_LiveObject___g_COUNT = globals::ReservedPool_LiveObject___g_COUNT + 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pLVar1 = pLVar2;
			do {
				pLVar1->pool_m_next = pLVar1 + 1;
				iVar3 = iVar3 + -1;
				pLVar1 = pLVar1 + 1;
			} while (iVar3 != 0);
		}
		pLVar2[uVar4 - 1].pool_m_next = globals::ReservedPool_LiveObject___g_NEXT;
		globals::ReservedPool_LiveObject___g_NEXT = pLVar2;
	}
	return;
}



int __cdecl lego::game::Game_GetNumBuildingsTeleported(int *stack)
{
	return globals::g_BuildingsTeleported;
}



void __cdecl lego::game::Game_SetNumBuildingsTeleported(uint numTeleported)
{
	globals::g_BuildingsTeleported = numTeleported;
	return;
}



void __cdecl lego::game::LiveObject_SetCrystalPoweredColor(LiveObject *liveObj,BOOL isPowered)
{
	uint uVar1;
	D3DRMGroupIndex DVar2;
	float b;
	D3DRMGroupIndex groupID;
	float local_4;
	
	if (liveObj->objType == OBJECT_POWERCRYSTAL) {
		if (isPowered == 0) {
			isPowered = (BOOL)globals::g_Game.UnpoweredCrystalRGB.red;
			local_4 = globals::g_Game.UnpoweredCrystalRGB.green;
			b = globals::g_Game.UnpoweredCrystalRGB.blue;
		}
		else {
			isPowered = (BOOL)globals::g_Game.PowerCrystalRGB.red;
			local_4 = globals::g_Game.PowerCrystalRGB.green;
			b = globals::g_Game.PowerCrystalRGB.blue;
		}
		groupID = D3DRMGROUP_0;
		uVar1 = res::Container_Mesh_GetGroupCount(liveObj->other);
		if (uVar1 != 0) {
			do {
				res::Container_Mesh_SetColourAlpha(liveObj->other,groupID,(float)isPowered,local_4,b,1.0);
				res::Container_Mesh_SetEmissive(liveObj->other,groupID,(float)isPowered,local_4,b);
				groupID = groupID + 1;
				DVar2 = res::Container_Mesh_GetGroupCount(liveObj->other);
			} while (groupID < DVar2);
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_00438720(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	
	if (liveObj->objType == OBJECT_BUILDING) {
		Game_UpdateSomeAITasks(liveObj);
		liveObj->flags3 = liveObj->flags3 | 0x20;
		OVar1 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar1 & STATS1_STOREOBJECTS) == STATS1_NONE) {
			OVar1 = LiveObject_GetStatsFlags1(liveObj);
			if ((OVar1 & STATS1_PROCESSORE) == STATS1_NONE) {
				OVar1 = LiveObject_GetStatsFlags1(liveObj);
				if ((OVar1 & STATS1_PROCESSCRYSTAL) == STATS1_NONE) {
					liveObj->flags3 = liveObj->flags3 & 0xffffffdf;
				}
				else {
					ai::AITask_DoDeposit_ObjectType(liveObj,OBJECT_POWERCRYSTAL,0,0);
				}
			}
			else {
				ai::AITask_DoDeposit_ObjectType(liveObj,OBJECT_ORE,0,0);
			}
		}
		else {
			LiveObject_FUN_004038d0(liveObj);
		}
		Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_200000;
	}
	else {
		if (liveObj->objType == OBJECT_VEHICLE) {
			res::Vehicle_FUN_0046d280(liveObj->vehicle,0);
		}
	}
	if ((liveObj->objType == OBJECT_MINIFIGURE) || (liveObj->objType == OBJECT_VEHICLE)) {
		LiveObject_FUN_0043f820(liveObj);
	}
	Game_UpdateObjectDependencies(liveObj->objType,liveObj->objIndex,0,liveObj->flags4 & 0x200);
	if (liveObj->objType == OBJECT_BUILDING) {
		globals::g_BuildingsTeleported = globals::g_BuildingsTeleported + 1;
	}
	if ((liveObj->objType == OBJECT_MINIFIGURE) || (liveObj->objType == OBJECT_VEHICLE)) {
		ai::AITask_DoAttackObject(liveObj);
	}
	if ((liveObj->objType == OBJECT_VEHICLE) || (liveObj->objType == OBJECT_BUILDING)) {
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_40000;
	}
	return;
}



void __cdecl lego::game::LiveObject_SetFlag3_80000000(LiveObject *liveObj,BOOL state)
{
	LiveFlags3 LVar1;
	
	if (state == 0) {
		LVar1 = liveObj->flags3 | LIVEOBJ3_UNK_80000000;
	}
	else {
		LVar1 = liveObj->flags3 & ~LIVEOBJ3_UNK_80000000;
	}
	liveObj->flags3 = LVar1;
	Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
	return;
}



BOOL __cdecl lego::game::LiveObject_CheckCondition_FUN_00438870(LiveObject *liveObj,BOOL state)
{
	if ((((((liveObj->flags1 &
					(LIVEOBJ1_UNK_100|LIVEOBJ1_UNK_100000|LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) ==
					LIVEOBJ1_NONE) && ((liveObj->flags2 & LIVEOBJ2_UNK_100000) == LIVEOBJ2_NONE)) &&
			 (0.0 <= liveObj->health)) && ((liveObj->flags1 & LIVEOBJ1_UNK_20000) == LIVEOBJ1_NONE)) &&
		 ((state != 0 ||
			(((liveObj->flags3 & LIVEOBJ3_UNK_20000000) != LIVEOBJ3_NONE &&
			 ((liveObj->flags3 & LIVEOBJ3_UNK_80000000) == LIVEOBJ3_NONE)))))) {
		return 1;
	}
	return 0;
}



LiveObject * __cdecl
lego::game::Game_CreateLiveResourceObject
					(Container *resData,ObjectType objType,int objIndex,int objLevel,float x,float y,
					float theta)
{
	LiveObject *liveObj;
	
	liveObj = LiveObject__Create((int **)resData,objType,objIndex);
	if (liveObj != (LiveObject *)0x0) {
		LiveObject_UnkUpdatePositioning(liveObj,x,y,theta,1);
		if ((liveObj->objType == OBJECT_POWERCRYSTAL) || (liveObj->objType == OBJECT_ORE)) {
			LiveObject_SetLevel_thunk(liveObj,objLevel);
		}
		return liveObj;
	}
	return (LiveObject *)0x0;
}



ObjectType __cdecl FUN_00438930(undefined4 *param_1)
{
	ObjectType local_c;
	int local_8;
	char *local_4;
	
	local_c = OBJECT_NONE;
	local_8 = *param_1;
	local_4 = (char *)param_1[1];
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00438970,(LiveObject *)&local_c);
	return local_c;
}



BOOL __cdecl FUN_00438970(LiveObject *liveObj,LiveObject **param_2)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	LiveObject *local_8;
	LiveObject *local_4;
	
	if (liveObj->objType == OBJECT_BUILDING) {
		OVar1 = lego::game::LiveObject_GetStatsFlags2(liveObj);
		if ((OVar1 & STATS2_GENERATEPOWER) != STATS2_NONE) {
			BVar2 = lego::game::LiveObject_CheckCondition_FUN_00438870(liveObj,0);
			if (BVar2 != 0) {
				lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_8,(int *)&local_4);
				if ((local_8 == param_2[1]) && (local_4 == param_2[2])) {
					*param_2 = liveObj;
					return 1;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl FUN_004389e0(LiveObject *liveObj,int param_2)
{
	int iVar1;
	
	if ((lego::globals::g_Game.level)->NoDrain != 0) {
		param_2 = 0;
	}
	iVar1 = lego::game::Level_GetCrystalCount(0);
	if (iVar1 < param_2) {
		lego::front::Info_FUN_00419ab0(INFO_NOPOWER,(char *)0x0,liveObj,(Point2I *)0x0);
		return 0;
	}
	lego::game::Level_AddDrainedCrystals(param_2);
	return 1;
}



BOOL __cdecl lego::game::LiveObject_GetBuildingUpgradeCost(LiveObject *liveObj,uint *out_oreCost)
{
	uint uVar1;
	
	uVar1 = Object_GetLevels(liveObj->objType,liveObj->objIndex);
	if (uVar1 <= liveObj->objLevel + 1) {
		return 0;
	}
	uVar1 = Level_GetOreCount(0);
	if (uVar1 < (uint)globals::g_Game.BuildingUpgradeCostOre) {
		uVar1 = Level_GetOreCount(1);
		if (uVar1 < (uint)globals::g_Game.BuildingUpgradeCostStuds) {
			return 0;
		}
		if (out_oreCost != (uint *)0x0) {
			*out_oreCost = globals::g_Game.BuildingUpgradeCostStuds;
		}
	}
	else {
		if (out_oreCost != (uint *)0x0) {
			*out_oreCost = 0;
			return 1;
		}
	}
	return 1;
}



void __cdecl lego::game::LiveObject_FUN_00438ab0(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	BOOL BVar1;
	Container *cont;
	LiveObject *oreCount;
	Container *opt_ref;
	Vector3F *out_pos;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	if (in_liveObj->objType == OBJECT_BUILDING) {
		BVar1 = LiveObject_GetBuildingUpgradeCost(in_liveObj,(uint *)&in_liveObj);
		if (BVar1 != 0) {
			oreCount = in_liveObj;
			if (in_liveObj == (LiveObject *)0x0) {
				oreCount = (LiveObject *)globals::g_Game.BuildingUpgradeCostOre;
			}
			Level_SubtractOre((uint)(in_liveObj != (LiveObject *)0x0),(int)oreCount);
			liveObj->elapsedTime2 = 0.0;
			LiveObject_BuildingChangeUpgradeParts(liveObj->building,liveObj->objLevel + 1);
			LiveObject_SetLevel(liveObj,liveObj->objLevel + 1);
			out_pos = &local_c;
			opt_ref = (Container *)0x0;
			cont = LiveObject_GetResource(liveObj);
			res::Container_GetPosition(cont,opt_ref,out_pos);
			FUN_0040cc10(9,(undefined4 *)&local_c,(undefined4 *)0x0);
			Game_UpdateObjectDependencies(liveObj->objType,liveObj->objIndex,liveObj->objLevel,0);
		}
	}
	return;
}



BOOL __cdecl FUN_00438b70(LiveObject *liveObj,int objLevel)
{
	BOOL BVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	
	if ((liveObj->objType != OBJECT_VEHICLE) ||
		 (BVar1 = lego::res::Vehicle_FUN_0046d200(liveObj->vehicle,objLevel,1), BVar1 == 0)) {
		return 0;
	}
	uVar2 = lego::game::Object_GetUpgradeCostOre(liveObj->objType,liveObj->objIndex,objLevel);
	uVar3 = lego::game::Object_GetUpgradeCostOre(liveObj->objType,liveObj->objIndex,objLevel);
	uVar4 = lego::game::Object_GetUpgradeCostOre(liveObj->objType,liveObj->objIndex,objLevel);
	uVar5 = lego::game::Level_GetOreCount(0);
	if ((uVar5 < uVar4) &&
		 (uVar4 = lego::game::Level_GetOreCount(1), uVar4 < (uint)(uVar2 % 5 != 0) + uVar3 / 5)) {
		return 0;
	}
	return 1;
}



ObjectType __cdecl FUN_00438c20(LiveObject *opt_liveObj,BOOL param_2)
{
	ObjectType local_24;
	float local_20;
	char *local_1c;
	VehicleData *local_18;
	CreatureData *local_14;
	CreatureData *local_10;
	BuildingData *local_c;
	Container *local_8;
	UpgradeData *local_4;
	
	local_24 = OBJECT_NONE;
	local_20 = 0.0;
	local_1c = (char *)0x0;
	local_18 = (VehicleData *)0x461c4000;
	local_14 = (CreatureData *)0x2000;
	local_10 = (CreatureData *)0x0;
	local_c = (BuildingData *)0x0;
	local_8 = (Container *)0x0;
	local_4 = (UpgradeData *)0x0;
	if (param_2 != 0) {
		local_14 = (CreatureData *)0x6000;
	}
	if (opt_liveObj != (LiveObject *)0x0) {
		lego::game::LiveObject_GetPosition(opt_liveObj,&local_20,(float *)&local_1c);
	}
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00439270,(LiveObject *)&local_24);
	return local_24;
}



ObjectType __cdecl FUN_00438ca0(LiveObject *liveObj,BOOL param_2)
{
	ObjectType local_24;
	float local_20;
	char *local_1c;
	VehicleData *local_18;
	CreatureData *local_14;
	CreatureData *local_10;
	BuildingData *local_c;
	Container *local_8;
	UpgradeData *local_4;
	
	local_24 = OBJECT_NONE;
	local_20 = 0.0;
	local_1c = (char *)0x0;
	local_18 = (VehicleData *)0x461c4000;
	local_14 = (CreatureData *)0x1000;
	local_10 = (CreatureData *)0x0;
	local_c = (BuildingData *)0x0;
	local_8 = (Container *)0x0;
	local_4 = (UpgradeData *)0x0;
	lego::game::LiveObject_GetPosition(liveObj,&local_20,(float *)&local_1c);
	if (param_2 != 0) {
		local_14 = (CreatureData *)((uint)local_14 | 0x400);
	}
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00439270,(LiveObject *)&local_24);
	return local_24;
}



LiveObject * __cdecl FUN_00438d20(Point2I *position,ObjectType objType,int objIndex,int objLevel)
{
	SurfaceMap *surfMap;
	uint x;
	uint y;
	float *out_x;
	char **out_y;
	LiveObject *local_24;
	float local_20;
	char *local_1c;
	VehicleData *local_18;
	CreatureData *local_14;
	CreatureData *local_10;
	BuildingData *local_c;
	Container *local_8;
	UpgradeData *local_4;
	
	local_c = (BuildingData *)objIndex;
	local_24 = (LiveObject *)0x0;
	local_20 = 0.0;
	local_1c = (char *)0x0;
	local_4 = (UpgradeData *)0x0;
	out_y = &local_1c;
	out_x = &local_20;
	local_10 = (CreatureData *)objType;
	local_8 = (Container *)objLevel;
	local_18 = (VehicleData *)0x461c4000;
	local_14 = (CreatureData *)0x1;
	y = position->y;
	x = position->x;
	surfMap = lego::game::GetSurfaceMap();
	lego::game::SurfaceMap_FUN_0044f900(surfMap,x,y,out_x,(float *)out_y);
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00439270,(LiveObject *)&local_24);
	return local_24;
}



LiveObject * __cdecl
lego::game::LiveObject_FUN_00438da0
					(LiveObject *liveObj,Point2I *position,ObjectType objType,int objLevel)
{
	SurfaceMap *surfMap;
	uint x;
	uint y;
	float *out_x;
	char **out_y;
	LiveObject *local_24;
	float local_20;
	char *local_1c;
	VehicleData *local_18;
	CreatureData *local_14;
	CreatureData *local_10;
	BuildingData *local_c;
	Container *local_8;
	UpgradeData *local_4;
	
	local_10 = (CreatureData *)objType;
	local_18 = (VehicleData *)0x461c4000;
	local_24 = (LiveObject *)0x0;
	local_20 = 0.0;
	local_1c = (char *)0x0;
	local_14 = (CreatureData *)0x2;
	local_c = (BuildingData *)0x0;
	local_8 = (Container *)objLevel;
	local_4 = (UpgradeData *)0x0;
	if (liveObj == (LiveObject *)0x0) {
		out_y = &local_1c;
		out_x = &local_20;
		y = position->y;
		x = position->x;
		surfMap = GetSurfaceMap();
		SurfaceMap_FUN_0044f900(surfMap,x,y,out_x,(float *)out_y);
	}
	else {
		LiveObject_GetPosition(liveObj,&local_20,(float *)&local_1c);
	}
	unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00439270,(LiveObject *)&local_24);
	return local_24;
}



ObjectType __cdecl FUN_00438e40(LiveObject *liveObj,CreatureData *param_2)
{
	ObjectType local_24;
	float local_20;
	char *local_1c;
	VehicleData *local_18;
	CreatureData *local_14;
	CreatureData *local_10;
	BuildingData *local_c;
	Container *local_8;
	UpgradeData *local_4;
	
	local_24 = OBJECT_NONE;
	local_20 = 0.0;
	local_1c = (char *)0x0;
	local_10 = (CreatureData *)0x0;
	local_c = (BuildingData *)0x0;
	local_8 = (Container *)0x0;
	local_4 = (UpgradeData *)0x0;
	local_14 = param_2;
	local_18 = (VehicleData *)0x461c4000;
	lego::game::LiveObject_GetPosition(liveObj,&local_20,(float *)&local_1c);
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00439270,(LiveObject *)&local_24);
	return local_24;
}



ObjectType __cdecl FUN_00438eb0(LiveObject *liveObj)
{
	ObjectType local_24;
	float local_20;
	char *local_1c;
	VehicleData *local_18;
	CreatureData *local_14;
	CreatureData *local_10;
	BuildingData *local_c;
	Container *local_8;
	UpgradeData *local_4;
	
	local_24 = OBJECT_NONE;
	local_20 = 0.0;
	local_1c = (char *)0x0;
	local_10 = (CreatureData *)0x0;
	local_c = (BuildingData *)0x0;
	local_8 = (Container *)0x0;
	local_4 = (UpgradeData *)0x0;
	local_18 = (VehicleData *)0x461c4000;
	local_14 = (CreatureData *)0x80;
	lego::game::LiveObject_GetPosition(liveObj,&local_20,(float *)&local_1c);
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00439270,(LiveObject *)&local_24);
	return local_24;
}



ObjectType __cdecl FUN_00438f20(LiveObject *liveObj)
{
	ObjectType local_24;
	float local_20;
	char *local_1c;
	VehicleData *local_18;
	CreatureData *local_14;
	CreatureData *local_10;
	BuildingData *local_c;
	Container *local_8;
	UpgradeData *local_4;
	
	local_24 = OBJECT_NONE;
	local_20 = 0.0;
	local_1c = (char *)0x0;
	local_10 = (CreatureData *)0x0;
	local_c = (BuildingData *)0x0;
	local_8 = (Container *)0x0;
	local_4 = (UpgradeData *)0x0;
	local_18 = (VehicleData *)0x461c4000;
	local_14 = (CreatureData *)&DAT_00000004;
	lego::game::LiveObject_GetPosition(liveObj,&local_20,(float *)&local_1c);
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00439270,(LiveObject *)&local_24);
	return local_24;
}



ObjectType __cdecl FUN_00438f90(Point2F *point)
{
	ObjectType local_24;
	float local_20;
	char *local_1c;
	VehicleData *local_18;
	CreatureData *local_14;
	CreatureData *local_10;
	BuildingData *local_c;
	Container *local_8;
	UpgradeData *local_4;
	
	local_24 = OBJECT_NONE;
	local_18 = (VehicleData *)0x461c4000;
	local_20 = point->x;
	local_1c = (char *)point->y;
	local_14 = (CreatureData *)&DAT_00000020;
	local_10 = (CreatureData *)0x0;
	local_c = (BuildingData *)0x0;
	local_8 = (Container *)0x0;
	local_4 = (UpgradeData *)0x0;
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00439270,(LiveObject *)&local_24);
	return local_24;
}



ObjectType __cdecl FUN_00438ff0(Point2F *point)
{
	ObjectType local_24;
	float local_20;
	char *local_1c;
	VehicleData *local_18;
	CreatureData *local_14;
	CreatureData *local_10;
	BuildingData *local_c;
	Container *local_8;
	UpgradeData *local_4;
	
	local_24 = OBJECT_NONE;
	local_18 = (VehicleData *)0x461c4000;
	local_20 = point->x;
	local_1c = (char *)point->y;
	local_14 = (CreatureData *)&DAT_00000010;
	local_10 = (CreatureData *)0x0;
	local_c = (BuildingData *)0x0;
	local_8 = (Container *)0x0;
	local_4 = (UpgradeData *)0x0;
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00439270,(LiveObject *)&local_24);
	return local_24;
}



ObjectType __cdecl FUN_00439050(Point2F *point)
{
	ObjectType local_24;
	float local_20;
	char *local_1c;
	VehicleData *local_18;
	CreatureData *local_14;
	CreatureData *local_10;
	BuildingData *local_c;
	Container *local_8;
	UpgradeData *local_4;
	
	local_24 = OBJECT_NONE;
	local_18 = (VehicleData *)0x461c4000;
	local_20 = point->x;
	local_1c = (char *)point->y;
	local_14 = (CreatureData *)0x200;
	local_10 = (CreatureData *)0x0;
	local_c = (BuildingData *)0x0;
	local_8 = (Container *)0x0;
	local_4 = (UpgradeData *)0x0;
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00439270,(LiveObject *)&local_24);
	return local_24;
}



LiveObject * __cdecl lego::game::Level_GetBuildingAtPosition(Point2F *point)
{
	LiveObject *local_24;
	float local_20;
	char *local_1c;
	VehicleData *local_18;
	CreatureData *local_14;
	CreatureData *local_10;
	BuildingData *local_c;
	Container *local_8;
	UpgradeData *local_4;
	
	local_24 = (LiveObject *)0x0;
	local_18 = (VehicleData *)0x461c4000;
	local_20 = point->x;
	local_1c = (char *)point->y;
	local_14 = (CreatureData *)&DAT_00000008;
	local_10 = (CreatureData *)0x0;
	local_c = (BuildingData *)0x0;
	local_8 = (Container *)0x0;
	local_4 = (UpgradeData *)0x0;
	unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00439270,(LiveObject *)&local_24);
	return local_24;
}



ObjectType __cdecl FUN_00439110(LiveObject *liveObj,Point2F *param_2,TrainedFlags trainedType)
{
	ObjectType local_24;
	float local_20;
	char *local_1c;
	VehicleData *local_18;
	CreatureData *local_14;
	CreatureData *local_10;
	BuildingData *local_c;
	Container *local_8;
	UpgradeData *local_4;
	
	local_4 = (UpgradeData *)trainedType;
	local_24 = OBJECT_NONE;
	local_20 = 0.0;
	local_1c = (char *)0x0;
	local_18 = (VehicleData *)0x461c4000;
	local_14 = (CreatureData *)0x100;
	local_10 = (CreatureData *)0x0;
	local_c = (BuildingData *)0x0;
	local_8 = (Container *)0x0;
	if (param_2 != (Point2F *)0x0) {
		local_20 = param_2->x;
		local_1c = (char *)param_2->y;
	}
	if (liveObj != (LiveObject *)0x0) {
		lego::game::LiveObject_GetPosition(liveObj,&local_20,(float *)&local_1c);
	}
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00439270,(LiveObject *)&local_24);
	return local_24;
}



BOOL __cdecl lego::game::LiveObject_HasTraining(LiveObject *liveObj,TrainedFlags training)
{
	ObjectStatsFlags2 OVar1;
	
	OVar1 = LiveObject_GetStatsFlags2(liveObj);
	if (((OVar1 & STATS2_TRAINPILOT) == STATS2_NONE) || (training != TRAINED_PILOT)) {
		OVar1 = LiveObject_GetStatsFlags2(liveObj);
		if (((OVar1 & STATS2_TRAINSAILOR) == STATS2_NONE) || (training != TRAINED_SAILOR)) {
			OVar1 = LiveObject_GetStatsFlags2(liveObj);
			if (((OVar1 & STATS2_TRAINDRIVER) == STATS2_NONE) || (training != TRAINED_DRIVER)) {
				OVar1 = LiveObject_GetStatsFlags2(liveObj);
				if (((OVar1 & STATS2_TRAINDYNAMITE) == STATS2_NONE) || (training != TRAINED_DYNAMITE)) {
					OVar1 = LiveObject_GetStatsFlags2(liveObj);
					if (((OVar1 & STATS2_TRAINREPAIR) == STATS2_NONE) || (training != TRAINED_REPAIR)) {
						OVar1 = LiveObject_GetStatsFlags2(liveObj);
						if (((OVar1 & STATS2_TRAINSCANNER) == STATS2_NONE) || (training != TRAINED_SCANNER)) {
							return 0;
						}
					}
				}
			}
		}
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_IsDocksBuilding_Unk(LiveObject *liveObj)
{
	BOOL BVar1;
	ObjectType local_8;
	int local_4;
	
	BVar1 = Object_GetObjectByName("Docks",&local_8,&local_4,(Container **)0x0);
	if (((BVar1 != 0) && (liveObj->objType == local_8)) && (liveObj->objIndex == local_4)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl FUN_00439270(LiveObject *liveObj,int **param_2)
{
	int *piVar1;
	bool bVar2;
	BOOL BVar3;
	ObjectStatsFlags1 OVar4;
	ObjectStatsFlags2 OVar5;
	float local_8;
	float local_4;
	
	piVar1 = param_2[4];
	bVar2 = false;
	BVar3 = lego::game::LiveObject_CheckCondition_FUN_00438870(liveObj,(uint)piVar1 & 0x400);
	if (BVar3 == 0) {
		return 0;
	}
	if ((((uint)piVar1 & 0x4000) != 0) && ((*(byte *)&liveObj->flags4 & 0x10) != 0)) {
		return 0;
	}
	if (((uint)piVar1 & 0xfffffbff) == 0) {
		if (liveObj->objType != OBJECT_BUILDING) goto LAB_00439459;
	}
	else {
		if (((((uint)piVar1 & 1) != 0) &&
				(OVar4 = lego::game::LiveObject_GetStatsFlags1(liveObj),
				(OVar4 & STATS1_STOREOBJECTS) != STATS1_NONE)) &&
			 (BVar3 = lego::game::LiveObject_CanSpawnCarryableObject
													(liveObj,(ObjectType)param_2[5],(int)param_2[6]), BVar3 != 0)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x1000) != 0) &&
			 (BVar3 = lego::game::LiveObject_IsDocksBuilding_Unk(liveObj), BVar3 != 0)) {
			bVar2 = true;
		}
		if (((((uint)piVar1 & 0x2000) != 0) &&
				(OVar5 = lego::game::LiveObject_GetStatsFlags2(liveObj),
				(OVar5 & STATS2_SELFPOWERED) == STATS2_NONE)) &&
			 ((OVar5 = lego::game::LiveObject_GetStatsFlags2(liveObj),
				(OVar5 & STATS2_GENERATEPOWER) == STATS2_NONE &&
				(BVar3 = lego::game::LiveObject_CheckCondition_FUN_00438870(liveObj,0), BVar3 != 0)))) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x100) != 0) &&
			 (BVar3 = lego::game::LiveObject_HasTraining(liveObj,(TrainedFlags)param_2[8]), BVar3 != 0)) {
			bVar2 = true;
		}
		if (((((uint)piVar1 & 0x40) != 0) &&
				(OVar4 = lego::game::LiveObject_GetStatsFlags1(liveObj),
				(OVar4 & STATS1_STOREOBJECTS) == STATS1_NONE)) && (liveObj->objType == OBJECT_BUILDING)) {
			bVar2 = true;
		}
		if (((((uint)piVar1 & 0x80) != 0) &&
				(OVar5 = lego::game::LiveObject_GetStatsFlags2(liveObj),
				(OVar5 & STATS2_UPGRADEBUILDING) != STATS2_NONE)) &&
			 (liveObj->object_300 == (LiveObject *)0x0)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x800) != 0) &&
			 (OVar4 = lego::game::LiveObject_GetStatsFlags1(liveObj),
			 (OVar4 & STATS1_MANTELEPORTER) != STATS1_NONE)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x10) != 0) &&
			 (OVar4 = lego::game::LiveObject_GetStatsFlags1(liveObj),
			 (OVar4 & STATS1_SMALLTELEPORTER) != STATS1_NONE)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x20) != 0) &&
			 (OVar4 = lego::game::LiveObject_GetStatsFlags1(liveObj),
			 (OVar4 & STATS1_BIGTELEPORTER) != STATS1_NONE)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x200) != 0) &&
			 (OVar4 = lego::game::LiveObject_GetStatsFlags1(liveObj),
			 (OVar4 & STATS1_WATERTELEPORTER) != STATS1_NONE)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 2) != 0) &&
			 (((OVar4 = lego::game::LiveObject_GetStatsFlags1(liveObj),
				 (OVar4 & STATS1_PROCESSORE) != STATS1_NONE && (param_2[5] == (int *)&DAT_00000007)) ||
				((OVar4 = lego::game::LiveObject_GetStatsFlags1(liveObj),
				 (OVar4 & STATS1_PROCESSCRYSTAL) != STATS1_NONE && (param_2[5] == (int *)0x6)))))) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 4) != 0) &&
			 (OVar4 = lego::game::LiveObject_GetStatsFlags1(liveObj),
			 (OVar4 & STATS1_SNAXULIKE) != STATS1_NONE)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 8) == 0) ||
			 (OVar4 = lego::game::LiveObject_GetStatsFlags1(liveObj),
			 (OVar4 & STATS1_TOOLSTORE) == STATS1_NONE)) goto LAB_00439459;
	}
	bVar2 = true;
LAB_00439459:
	if (bVar2) {
		lego::game::LiveObject_GetPosition(liveObj,&local_8,&local_4);
		piVar1 = (int *)SQRT(((float)param_2[2] - local_4) * ((float)param_2[2] - local_4) +
												 ((float)param_2[1] - local_8) * ((float)param_2[1] - local_8));
		if ((float)piVar1 < (float)param_2[3]) {
			param_2[3] = piVar1;
			*param_2 = (int *)liveObj;
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl FUN_004394c0(ObjectType objType)
{
	BOOL BVar1;
	
	if (((objType != OBJECT_VEHICLE) && (objType != OBJECT_MINIFIGURE)) &&
		 (objType != OBJECT_BUILDING)) {
		BVar1 = lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00439500,(LiveObject *)&objType);
		if (BVar1 != 0) {
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl FUN_00439500(LiveObject *liveObj1,LiveObject *liveObj2)
{
	ObjectStatsFlags1 OVar1;
	BOOL BVar2;
	
	OVar1 = lego::game::LiveObject_GetStatsFlags1(liveObj1);
	if ((OVar1 & STATS1_STOREOBJECTS) != STATS1_NONE) {
		BVar2 = lego::game::LiveObject_CanSpawnCarryableObject(liveObj1,liveObj2->objType,0);
		if (BVar2 != 0) {
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::game::Level_GenerateCryOreAt(Point2I *position)
{
	Point2I *position_00;
	BOOL BVar1;
	Point2I *pPVar2;
	uint uVar3;
	uint local_c;
	uint local_8;
	uint local_4;
	
	position_00 = position;
	BVar1 = Level_GetBlockCryOre
										(position,(int *)&position,(int *)&local_c,(int *)&local_8,(int *)&local_4);
	if (BVar1 != 0) {
		pPVar2 = (Point2I *)0x0;
		if (position != (Point2I *)0x0) {
			do {
				Level_GenerateCrystal(position_00,0,(Point2F *)0x0,1);
				pPVar2 = (Point2I *)((int)&pPVar2->x + 1);
			} while (pPVar2 < position);
		}
		uVar3 = 0;
		if (local_c != 0) {
			do {
				Level_GenerateCrystal(position_00,1,(Point2F *)0x0,1);
				uVar3 = uVar3 + 1;
			} while (uVar3 < local_c);
		}
		uVar3 = 0;
		if (local_8 != 0) {
			do {
				Level_GenerateOre(position_00,0,(Point2F *)0x0,1);
				uVar3 = uVar3 + 1;
			} while (uVar3 < local_8);
		}
		uVar3 = 0;
		if (local_4 != 0) {
			do {
				Level_GenerateOre(position_00,1,(Point2F *)0x0,1);
				uVar3 = uVar3 + 1;
			} while (uVar3 < local_4);
		}
	}
	return;
}



void __cdecl FUN_00439600(uint *param_1,uint param_2)
{
	lego::game::Level_GenerateCrystal((Point2I *)param_1,param_2,(Point2F *)0x0,1);
	lego::game::Level_GenerateOre((Point2I *)param_1,param_2,(Point2F *)0x0,1);
	return;
}



void __cdecl
lego::game::Level_GenerateCrystal
					(Point2I *position,uint objLevel,Point2F *opt_point,BOOL showInfoMessage)
{
	SurfaceMap *pSVar1;
	float fVar2;
	LiveObject *liveObj;
	LevelData *pLVar3;
	int iVar4;
	float x;
	float10 fVar5;
	float10 fVar6;
	uint x_00;
	uint y;
	float *pfVar7;
	float local_30;
	float local_2c;
	float local_18;
	float local_14;
	
	pSVar1 = GetSurfaceMap();
	fVar5 = SurfaceMap_GetBlockSize(pSVar1);
	pSVar1 = GetSurfaceMap();
	fVar6 = SurfaceMap_GetBlockSize(pSVar1);
	fVar2 = (float)((float10)(float)(fVar5 * (float10)0.5) - fVar6 * (float10)0.25);
	if (opt_point == (Point2F *)0x0) {
		y = position->y;
		x_00 = position->x;
		pfVar7 = &local_30;
		pSVar1 = GetSurfaceMap();
		SurfaceMap_FillStruct30_FUN_00450390(pSVar1,x_00,y,pfVar7);
		fVar5 = math::Maths_RandRange(local_30 + fVar2,local_18 - fVar2);
		x = (float)fVar5;
		fVar5 = math::Maths_RandRange(local_2c - fVar2,local_14 + fVar2);
		fVar2 = (float)fVar5;
	}
	else {
		x = opt_point->x;
		fVar2 = opt_point->y;
	}
	liveObj = Game_CreateLiveResourceObject
											(globals::g_Game.RES_Crystal,OBJECT_POWERCRYSTAL,0,objLevel,x,fVar2,0.0);
	Level_AddMessageAction(MESSAGE_GENERATECRYSTAL_COMPLETE,liveObj,0,(Point2I *)0x0);
	if (showInfoMessage != 0) {
		front::Info_FUN_00419ab0(INFO_CRYSTALFOUND,(char *)0x0,(LiveObject *)0x0,position);
		front::Text_DisplayMessage(TEXT_CRYSTALFOUND,1,0);
		pLVar3 = GetLevel();
		iVar4 = (pLVar3->dimensions).width * position->y + position->x;
		pLVar3 = GetLevel();
		pLVar3->blocks[iVar4].generateCrystals = pLVar3->blocks[iVar4].generateCrystals + 1;
	}
	return;
}



void __cdecl
lego::game::Level_GenerateOre
					(Point2I *position,uint objLevel,Point2F *opt_point,BOOL showInfoMessage)
{
	SurfaceMap *pSVar1;
	float fVar2;
	LiveObject *liveObj;
	LevelData *pLVar3;
	int iVar4;
	float x;
	float10 fVar5;
	float10 fVar6;
	uint x_00;
	uint y;
	float *pfVar7;
	float local_30;
	float local_2c;
	float local_18;
	float local_14;
	
	pSVar1 = GetSurfaceMap();
	fVar5 = SurfaceMap_GetBlockSize(pSVar1);
	pSVar1 = GetSurfaceMap();
	fVar6 = SurfaceMap_GetBlockSize(pSVar1);
	fVar2 = (float)((float10)(float)(fVar5 * (float10)0.5) - fVar6 * (float10)0.25);
	if (opt_point == (Point2F *)0x0) {
		y = position->y;
		x_00 = position->x;
		pfVar7 = &local_30;
		pSVar1 = GetSurfaceMap();
		SurfaceMap_FillStruct30_FUN_00450390(pSVar1,x_00,y,pfVar7);
		fVar5 = math::Maths_RandRange(local_30 + fVar2,local_18 - fVar2);
		x = (float)fVar5;
		fVar5 = math::Maths_RandRange(local_2c - fVar2,local_14 + fVar2);
		fVar2 = (float)fVar5;
	}
	else {
		x = opt_point->x;
		fVar2 = opt_point->y;
	}
	liveObj = Game_CreateLiveResourceObject
											(globals::g_Game.RES_Ores_TABLE[0],OBJECT_ORE,0,objLevel,x,fVar2,0.0);
	Level_AddMessageAction(MESSAGE_GENERATEORE_COMPLETE,liveObj,0,(Point2I *)0x0);
	front::Text_DisplayMessage(TEXT_OREFOUND,1,0);
	if (showInfoMessage != 0) {
		pLVar3 = GetLevel();
		iVar4 = (pLVar3->dimensions).width * position->y + position->x;
		pLVar3 = GetLevel();
		pLVar3->blocks[iVar4].generateOre = pLVar3->blocks[iVar4].generateOre + 1;
	}
	return;
}



char * __cdecl lego::game::LiveObject_GetName(LiveObject *liveObj)
{
	switch(liveObj->objType) {
	case OBJECT_VEHICLE:
		return globals::g_Game.ObjectNames_VehicleTypes_TABLE[liveObj->vehicle->objIndex];
	case OBJECT_MINIFIGURE:
		return globals::g_Game.ObjectNames_MiniFigureTypes_TABLE[liveObj->miniFigure->objIndex];
	case OBJECT_ROCKMONSTER:
		return globals::g_Game.ObjectNames_RockMonsterTypes_TABLE[liveObj->rockMonster->objIndex];
	case OBJECT_BUILDING:
		return globals::g_Game.ObjectNames_BuildingTypes_TABLE[liveObj->building->objIndex];
	default:
		return (char *)0x0;
	case OBJECT_POWERCRYSTAL:
		return globals::g_Game.ObjectNames_PowerCrystal;
	case OBJECT_ORE:
		return globals::g_Game.ToolTypes_TABLE[liveObj->objIndex + -0x1b];
	case OBJECT_DYNAMITE:
		return globals::g_Game.ObjectNames_Dynamite;
	case OBJECT_BARRIER:
		return globals::g_Game.ObjectNames_Barrier;
	case OBJECT_UPGRADEPART:
		return globals::g_Game.ObjectNames_UpgradeTypes_TABLE[liveObj->upgrade->objectIndex];
	case OBJECT_ELECTRICFENCE:
		return globals::g_Game.ObjectNames_ElectricFence;
	case OBJECT_SPIDERWEB:
		return globals::g_Game.ObjectNames_SpiderWeb;
	case OBJECT_OOHSCARY:
		return globals::g_Game.ObjectNames_OohScary;
	case OBJECT_PATH:
		return globals::g_Game.ObjectNames_Path;
	}
}



char * __cdecl lego::game::Object_GetTypeName(ObjectType objType,int objIndex)
{
	if (objType < OBJECT_BARRIER) {
		if (objType == OBJECT_DYNAMITE) {
			return "Dynamite";
		}
		switch(objType) {
		case OBJECT_VEHICLE:
			return globals::g_Game.VehicleTypes_TABLE[objIndex];
		case OBJECT_MINIFIGURE:
			return globals::g_Game.MiniFigureTypes_TABLE[objIndex];
		case OBJECT_ROCKMONSTER:
			return globals::g_Game.RockMonsterTypes_TABLE[objIndex];
		case OBJECT_BUILDING:
			return globals::g_Game.BuildingTypes_TABLE[objIndex];
		case OBJECT_POWERCRYSTAL:
			return "PowerCrystal";
		case OBJECT_ORE:
			if (objIndex == 0) {
				return "Ore";
			}
			return "ProcessedOre";
		}
	}
	else {
		if (objType < OBJECT_OOHSCARY) {
			if (objType == OBJECT_SPIDERWEB) {
				return "SpiderWeb";
			}
			if (objType == OBJECT_BARRIER) {
				return "Barrier";
			}
			if (objType == OBJECT_ELECTRICFENCE) {
				return "ElectricFence";
			}
		}
		else {
			if (objType == OBJECT_OOHSCARY) {
				return "OohScary";
			}
			if (objType == OBJECT_TVCAMERA) {
				return "tvcamera";
			}
		}
	}
	return (char *)0x0;
}



char * __cdecl lego::game::Object_GetTheName(ObjectType objType,int objIndex)
{
	switch(objType) {
	case OBJECT_VEHICLE:
		return globals::g_Game.ObjectTheNames_VehicleTypes_TABLE[objIndex];
	case OBJECT_MINIFIGURE:
		return globals::g_Game.ObjectTheNames_MiniFigureTypes_TABLE[objIndex];
	case OBJECT_ROCKMONSTER:
		return globals::g_Game.ObjectTheNames_RockMonsterTypes_TABLE[objIndex];
	case OBJECT_BUILDING:
		return globals::g_Game.ObjectTheNames_BuildingTypes_TABLE[objIndex];
	default:
		return (char *)0x0;
	case OBJECT_POWERCRYSTAL:
		return globals::g_Game.ObjectTheNames_PowerCrystal;
	case OBJECT_ORE:
		return globals::g_Game.ToolTypes_TABLE[objIndex + -0x12];
	case OBJECT_DYNAMITE:
		return globals::g_Game.ObjectTheNames_Dynamite;
	case OBJECT_BARRIER:
		return globals::g_Game.ObjectTheNames_Barrier;
	case OBJECT_UPGRADEPART:
		return globals::g_Game.ObjectTheNames_UpgradeTypes_TABLE[objIndex];
	case OBJECT_ELECTRICFENCE:
		return globals::g_Game.ObjectTheNames_ElectricFence;
	case OBJECT_SPIDERWEB:
		return globals::g_Game.ObjectTheNames_SpiderWeb;
	case OBJECT_OOHSCARY:
		return globals::g_Game.ObjectTheNames_OohScary;
	case OBJECT_PATH:
		return globals::g_Game.ObjectTheNames_Path;
	}
}



char * __cdecl lego::game::Object_GetName(ObjectType objType,int objIndex)
{
	switch(objType) {
	case OBJECT_VEHICLE:
		return globals::g_Game.ObjectNames_VehicleTypes_TABLE[objIndex];
	case OBJECT_MINIFIGURE:
		return globals::g_Game.ObjectNames_MiniFigureTypes_TABLE[objIndex];
	case OBJECT_ROCKMONSTER:
		return globals::g_Game.ObjectNames_RockMonsterTypes_TABLE[objIndex];
	case OBJECT_BUILDING:
		return globals::g_Game.ObjectNames_BuildingTypes_TABLE[objIndex];
	default:
		return (char *)0x0;
	case OBJECT_POWERCRYSTAL:
		return globals::g_Game.ObjectNames_PowerCrystal;
	case OBJECT_ORE:
		return globals::g_Game.ToolTypes_TABLE[objIndex + -0x1b];
	case OBJECT_DYNAMITE:
		return globals::g_Game.ObjectNames_Dynamite;
	case OBJECT_BARRIER:
		return globals::g_Game.ObjectNames_Barrier;
	case OBJECT_UPGRADEPART:
		return globals::g_Game.ObjectNames_UpgradeTypes_TABLE[objIndex];
	case OBJECT_ELECTRICFENCE:
		return globals::g_Game.ObjectNames_ElectricFence;
	case OBJECT_SPIDERWEB:
		return globals::g_Game.ObjectNames_SpiderWeb;
	case OBJECT_OOHSCARY:
		return globals::g_Game.ObjectNames_OohScary;
	case OBJECT_PATH:
		return globals::g_Game.ObjectNames_Path;
	}
}



void __cdecl
lego::game::LiveObject_GetTypeIndex(LiveObject *param_1,int *out_objType,int *out_objIndex)
{
	*out_objType = param_1->objType;
	*out_objIndex = param_1->objIndex;
	return;
}



void __cdecl lego::main::Main_LoadToolNames(CFGProperty *root,char *keyBasePath)
{
	char *keyPath;
	char **ppcVar1;
	char ***pppcVar2;
	
	pppcVar2 = (char ***)globals::g_Game.ToolNames_TABLE;
	do {
		keyPath = cfg::CFG_JoinPath(keyBasePath,"ToolNames",pppcVar2[-0xb],0);
		ppcVar1 = (char **)cfg::CFG_CopyString(root,keyPath);
		*pppcVar2 = ppcVar1;
		pppcVar2 = pppcVar2 + 1;
	} while (pppcVar2 < &globals::g_Game.ObjectNames_VehicleTypes_TABLE);
	return;
}



void __cdecl lego::game::Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained(void)
{
	if ((pool::globals::ReservedPool_LiveObject___g_INITFLAGS & 0x10) != LIVEMANAGER_NONE) {
		pool::globals::ReservedPool_LiveObject___g_INITFLAGS =
				 pool::globals::ReservedPool_LiveObject___g_INITFLAGS | 8;
		return;
	}
	pool::globals::ReservedPool_LiveObject___g_INITFLAGS =
			 pool::globals::ReservedPool_LiveObject___g_INITFLAGS | 4;
	if (globals::g_Game.level != (LevelData *)0x0) {
		(globals::g_Game.level)->numDrainedCrystals = 0;
	}
	return;
}



BOOL __cdecl FUN_00439c80(LiveObject *liveObj)
{
	uint uVar1;
	uint uVar2;
	
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
		return 0;
	}
	if (liveObj->objType == OBJECT_VEHICLE) {
		uVar2 = liveObj->field_328;
		uVar1 = lego::game::LiveObject_GetMaxCarry(liveObj);
		if (uVar1 <= uVar2) {
			uVar2 = lego::game::LiveObject_GetMaxCarry(liveObj);
		}
		if ((liveObj->numCarriedObjects < uVar2) && (liveObj->elapsedTime1 < 75.0)) {
			return 0;
		}
	}
	return 1;
}



BOOL __cdecl FUN_00439ce0(LiveObject *liveObj1,LiveObject *liveObj2)
{
	LiveObject *liveObj1_00;
	LiveObject *liveObj;
	BOOL BVar1;
	SurfaceMap *pSVar2;
	LiveObject **ppLVar3;
	LiveObject **ppLVar4;
	float *local_24;
	float *local_20;
	LiveObject *local_1c;
	LiveObject *local_18;
	uint local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	liveObj1_00 = liveObj1;
	BVar1 = FUN_00439c80(liveObj1);
	liveObj = liveObj2;
	if ((BVar1 == 0) && (BVar1 = FUN_00439e90(liveObj1_00,liveObj2,1), BVar1 != 0)) {
		lego::game::LiveObject_GetPosition(liveObj,&local_10,&local_c);
		ppLVar4 = &liveObj1;
		ppLVar3 = &liveObj2;
		pSVar2 = lego::game::GetSurfaceMap();
		lego::game::SurfaceMap_ToBlockCoordinatesNoZ
							(pSVar2,local_10,local_c,(int *)ppLVar3,(int *)ppLVar4);
		lego::game::LiveObject_GetPosition(liveObj1_00,&local_8,&local_4);
		ppLVar4 = &local_18;
		ppLVar3 = &local_1c;
		pSVar2 = lego::game::GetSurfaceMap();
		lego::game::SurfaceMap_ToBlockCoordinatesNoZ
							(pSVar2,local_8,local_4,(int *)ppLVar3,(int *)ppLVar4);
		if ((local_1c == liveObj2) && (local_18 == liveObj1)) {
			lego::game::LiveObject_FUN_004419c0
								(liveObj1_00,1,(float *)&liveObj2,(float *)&liveObj1,&local_10);
		}
		else {
			BVar1 = lego::game::LiveObject_FUN_004413b0
												(liveObj1_00,local_1c,local_18,liveObj2,liveObj1,&local_24,&local_20,
												 &local_14,0,0);
			if (BVar1 == 0) {
				return 0;
			}
			lego::game::LiveObject_FUN_004419c0(liveObj1_00,local_14,local_24,local_20,&local_10);
			std::free(local_24);
			std::free(local_20);
		}
		*(undefined *)((int)liveObj1_00->routeptr_24 + liveObj1_00->routingBlocksTotal * 0x14 + -3) = 3;
		liveObj1_00->object_2fc = liveObj;
		return 1;
	}
	return 0;
}



BOOL __cdecl FUN_00439e40(LiveObject *liveObj,undefined4 *param_2)
{
	ObjectStatsFlags3 OVar1;
	LiveObject *pLVar2;
	
	if (liveObj->objType == OBJECT_VEHICLE) {
		if (param_2[1] != 0) {
			return 0;
		}
		OVar1 = lego::game::LiveObject_GetStatsFlags3(liveObj);
		if ((OVar1 & STATS3_ENTERTOOLSTORE) == STATS3_NONE) {
			pLVar2 = lego::game::LiveObject_FUN_00438da0(liveObj,(Point2I *)0x0,*param_2,param_2[0xcc]);
			return (uint)(pLVar2 != (LiveObject *)0x0);
		}
	}
	return 1;
}



BOOL __cdecl FUN_00439e90(LiveObject *liveObj1,LiveObject *liveObj2,BOOL param_3)
{
	BOOL BVar1;
	ObjectStatsFlags1 OVar2;
	
	if (liveObj1->objType == OBJECT_ROCKMONSTER) {
		if ((liveObj1->flags3 & 0x8000000) == LIVEOBJ3_NONE) {
			return 0;
		}
	}
	else {
		if ((*(byte *)&liveObj1->flags3 & 0x20) == 0) {
			return 0;
		}
	}
	if ((*(byte *)&liveObj1->flags1 & 1) != 0) {
		return 0;
	}
	if (param_3 != 0) {
		BVar1 = lego::game::LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj1);
		if (BVar1 != 0) {
			return 0;
		}
	}
	OVar2 = lego::game::LiveObject_GetStatsFlags1(liveObj1);
	if (((OVar2 & STATS1_PROCESSCRYSTAL) != STATS1_NONE) && (liveObj2->objType != OBJECT_POWERCRYSTAL)
		 ) {
		return 0;
	}
	OVar2 = lego::game::LiveObject_GetStatsFlags1(liveObj1);
	if (((OVar2 & STATS1_PROCESSORE) != STATS1_NONE) && (liveObj2->objType != OBJECT_ORE)) {
		return 0;
	}
	if ((liveObj1->numCarriedObjects != 0) &&
		 (liveObj1->carriedObjects[0]->objType != liveObj2->objType)) {
		return 0;
	}
	return 1;
}



void __cdecl lego::game::LiveObject_CompleteVehicleUpgrade(LiveObject *liveObj)
{
	uint uVar1;
	
	if (liveObj->objType == OBJECT_VEHICLE) {
		uVar1 = LiveObject_GetVehicle_UpgradesField8(liveObj->vehicle);
		uVar1 = uVar1 | 1 << ((byte)liveObj->field_404 & 0x1f);
		res::Vehicle_ChangeUpgradeParts(liveObj->vehicle,uVar1);
		LiveObject_SetLevel(liveObj,uVar1);
		front::Text_DisplayMessage(TEXT_UNITUPGRADED,1,0);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_SetLevel_thunk(LiveObject *liveObj,int objLevel)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_SetLevel(liveObj,objLevel);
	return BVar1;
}



BOOL __cdecl lego::game::LiveObject_IsSmallTeleporter(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	return OVar1 & STATS1_SMALLTELEPORTER;
}



BOOL __cdecl lego::game::LiveObject_IsBigTeleporter(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	return OVar1 & STATS1_BIGTELEPORTER;
}



BOOL __cdecl lego::game::LiveObject_IsWaterTeleporter(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	return OVar1 & STATS1_WATERTELEPORTER;
}



BOOL __cdecl FUN_0043a010(LiveObject *liveObj,Point2I *out_position)
{
	uint x;
	BOOL BVar1;
	int iVar2;
	uint y;
	uint uVar3;
	Point2I *pPVar4;
	Point2I local_28;
	Point2I DIRECTIONS [4];
	
	DIRECTIONS[0].y = -1;
	DIRECTIONS[3].x = -1;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[2].y = 1;
	DIRECTIONS[0].x = 0;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[3].y = 0;
	lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_28,&local_28.y);
	uVar3 = 0;
	pPVar4 = DIRECTIONS;
	do {
		pPVar4->x = pPVar4->x + local_28.x;
		y = pPVar4->y + local_28.y;
		pPVar4->y = y;
		x = pPVar4->x;
		BVar1 = lego::game::Level_GetBlockFlags1_8(x,y);
		if (BVar1 != 0) {
			iVar2 = lego::game::LiveObject_FUN_00431cd0((LiveObject *)0x0,x,pPVar4->y,x,pPVar4->y,0);
			if (iVar2 != 0) {
				if (out_position != (Point2I *)0x0) {
					iVar2 = DIRECTIONS[uVar3].y;
					out_position->x = DIRECTIONS[uVar3].x;
					out_position->y = iVar2;
				}
				return 1;
			}
		}
		uVar3 = uVar3 + 1;
		pPVar4 = pPVar4 + 1;
	} while (uVar3 < 4);
	return 0;
}



BOOL __cdecl FUN_0043a0d0(LiveObject *liveObj,uint *param_2)
{
	ObjectStatsFlags3 OVar1;
	BOOL BVar2;
	
	OVar1 = lego::game::LiveObject_GetStatsFlags3(liveObj);
	if ((OVar1 & STATS3_GETOUTATLAND) != STATS3_NONE) {
		BVar2 = FUN_0043a010(liveObj,(Point2I *)param_2);
		return BVar2;
	}
	return 0;
}



BOOL __cdecl FUN_0043a100(undefined4 *param_1,uint *param_2)
{
	ObjectStatsFlags3 OVar1;
	BOOL BVar2;
	
	OVar1 = lego::game::LiveObject_GetStatsFlags3((LiveObject *)param_1);
	if ((OVar1 & STATS3_GETINATLAND) != STATS3_NONE) {
		BVar2 = FUN_0043a010((LiveObject *)param_1,(Point2I *)param_2);
		return BVar2;
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_0043a130(LiveObject *in_liveObj,BOOL param_2)
{
	char cVar1;
	LiveFlags1 LVar2;
	LiveObject *liveObj;
	LiveObject *liveObj_00;
	LiveObject *liveObj1;
	ObjectStatsFlags1 OVar3;
	BOOL BVar4;
	uint uVar5;
	Container *cont;
	int iVar6;
	uint uVar7;
	LiveObject **ppLVar8;
	AITaskType taskType;
	Point2I local_20;
	float local_18;
	float local_14 [2];
	Vector3F local_c;
	
	liveObj1 = in_liveObj;
	LVar2 = in_liveObj->flags1;
	if (((LVar2 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
		 (((LVar2 & LIVEOBJ1_UNK_2000) == LIVEOBJ1_NONE || (param_2 != 0)))) {
		liveObj = in_liveObj->object_2fc;
		uVar7 = 0;
		in_liveObj = (LiveObject *)0x0;
		if (liveObj != (LiveObject *)0x0) {
			OVar3 = LiveObject_GetStatsFlags1(liveObj);
			in_liveObj = (LiveObject *)(OVar3 & STATS1_STOREOBJECTS);
		}
		if ((in_liveObj == (LiveObject *)0x0) && (param_2 != 0)) {
			LiveObject_SetAITaskUnk(liveObj1,AITASK_DUMP,(LiveObject *)0x0,1);
			LiveObject_SetAITaskUnk(liveObj1,AITASK_DYNAMITE,(LiveObject *)0x0,1);
			LiveObject_SetAITaskUnk(liveObj1,AITASK_ELECFENCE,(LiveObject *)0x0,1);
			LiveObject_SetAITaskUnk(liveObj1,AITASK_BIRDSCARER,(LiveObject *)0x0,1);
		}
		if (liveObj1->numCarriedObjects != 0) {
			ppLVar8 = liveObj1->carriedObjects;
			do {
				liveObj_00 = *ppLVar8;
				*ppLVar8 = (LiveObject *)0x0;
				liveObj_00->carryingThisObject = (LiveObject *)0x0;
				liveObj_00->object_300 = (LiveObject *)0x0;
				if ((in_liveObj == (LiveObject *)0x0) || (param_2 == 0)) {
					LiveObject_GetBlockCoordinates(liveObj_00,(int *)&local_20,&local_20.y);
					BVar4 = Level_GetBlockFlags1_8(local_20.x,local_20.y);
					if (BVar4 == 0) {
LAB_0043a27e:
						cont = LiveObject_GetResource(liveObj_00);
						LiveObject_GetPosition(liveObj1,&local_18,local_14);
						res::Container_GetPosition(cont,(Container *)0x0,&local_c);
						res::Container_SetPosition(cont,(Container *)0x0,local_18,local_14[0],local_c.z);
					}
					else {
						uVar5 = Level_IsBlockLava(&local_20);
						if (uVar5 != 0) goto LAB_0043a27e;
						BVar4 = Level_BlockCheck_FUN_004329d0(local_20.x,local_20.y,0);
						if (BVar4 != 0) goto LAB_0043a27e;
					}
					if (param_2 == 0) {
						if ((LVar2 & LIVEOBJ1_UNK_200) == LIVEOBJ1_NONE) {
							LiveObject_FUN_00403b30(liveObj1,AITASK_DEPOSITE,liveObj_00);
							LiveObject_FUN_00403b30(liveObj1,AITASK_DUMP,liveObj_00);
							LiveObject_FUN_00403b30(liveObj1,AITASK_DYNAMITE,liveObj_00);
							LiveObject_FUN_00403b30(liveObj1,AITASK_ELECFENCE,liveObj_00);
							LiveObject_FUN_00403b30(liveObj1,AITASK_REQUEST,liveObj_00);
							LiveObject_FUN_00403b30(liveObj1,AITASK_GATHER,(LiveObject *)0x0);
							taskType = AITASK_BIRDSCARER;
						}
						else {
							taskType = AITASK_COLLECT;
						}
						LiveObject_FUN_00403b30(liveObj1,taskType,liveObj_00);
					}
					else {
						LiveObject_SetAITaskUnk
											(liveObj1,AITASK_REQUEST,liveObj_00,
											 (uint)(uVar7 == liveObj1->numCarriedObjects - 1));
						if ((liveObj_00->objType != OBJECT_ORE) && (liveObj_00->objType != OBJECT_POWERCRYSTAL))
						{
							liveObj_00->flags1 = liveObj_00->flags1 | LIVEOBJ1_PLACING;
						}
					}
					if (liveObj_00->objType == OBJECT_BOULDER) {
						LiveObject_ReleaseBoulderUnk(liveObj_00);
					}
				}
				else {
					LiveObject_SetAITaskUnk(liveObj1,AITASK_DEPOSITE,liveObj_00,1);
					LiveObject_FUN_0043ab10(liveObj,liveObj_00);
					Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
				}
				uVar7 = uVar7 + 1;
				ppLVar8 = ppLVar8 + 1;
			} while (uVar7 < liveObj1->numCarriedObjects);
		}
		uVar7 = 0;
		liveObj1->numCarriedObjects = 0;
		liveObj1->flags1 = liveObj1->flags1 & ~LIVEOBJ1_CARRYING;
		if (liveObj1->routingBlocksTotal != 0) {
			iVar6 = 0;
			do {
				cVar1 = *(char *)(iVar6 + 0x11 + (int)liveObj1->routeptr_24);
				if ((cVar1 == '\a') || (cVar1 == '\x05')) {
					*(undefined *)(iVar6 + 0x11 + (int)liveObj1->routeptr_24) = 0;
				}
				uVar7 = uVar7 + 1;
				iVar6 = iVar6 + 0x14;
			} while (uVar7 < liveObj1->routingBlocksTotal);
		}
	}
	return;
}



int __cdecl FUN_0043a3e0(int *param_1,float *param_2,float *param_3,int param_4,int param_5)
{
	float fVar1;
	int iVar2;
	int iVar3;
	short sVar4;
	BOOL BVar5;
	uint uVar6;
	BOOL BVar7;
	float10 fVar8;
	float *local_1c;
	float *local_18;
	float local_14;
	float local_10;
	uint local_c;
	float local_8;
	float local_4;
	
	BVar7 = 0;
	if ((param_1[0xf8] & 0x400U) != 0) {
		lego::game::LiveObject_GetBlockCoordinates
							((LiveObject *)param_1,(int *)&local_14,(int *)&local_10);
		if ((local_14 == *param_2) && (local_10 == param_2[1])) {
			BVar7 = lego::game::LiveObject_FUN_004419c0
												((LiveObject *)param_1,1,param_2,param_2 + 1,(float *)0x0);
		}
		else {
			BVar5 = lego::game::LiveObject_FUN_004413b0
												(param_1,local_14,local_10,*param_2,param_2[1],&local_1c,&local_18,&local_c,
												 0,0);
			if (BVar5 != 0) {
				BVar7 = lego::game::LiveObject_FUN_004419c0
													((LiveObject *)param_1,local_c,local_1c,local_18,(float *)0x0);
				std::free(local_1c);
				std::free(local_18);
			}
		}
		if (BVar7 != 0) {
			if (*param_1 == 1) {
				fVar8 = lego::math::Maths_RandRange(0.55,0.75);
				fVar1 = (float)fVar8;
				sVar4 = lego::math::Maths_Rand();
				uVar6 = (int)sVar4 >> 0x1f;
				param_5 = 1;
				switch((((int)sVar4 ^ uVar6) - uVar6 & 3 ^ uVar6) - uVar6) {
				case 0:
					local_8 = 0.5;
					local_4 = fVar1;
					break;
				case 1:
					local_4 = 0.5;
					local_8 = fVar1;
					break;
				case 2:
					local_8 = 0.5;
					local_4 = 1.0 - fVar1;
					break;
				case 3:
					local_4 = 0.5;
					local_8 = 1.0 - fVar1;
				}
			}
			else {
				local_8 = *param_3;
				local_4 = param_3[1];
			}
			if (param_4 == 0) {
				*(undefined *)(param_1[9] + -3 + param_1[10] * 0x14) = 8;
			}
			else {
				*(undefined *)(param_1[9] + -3 + param_1[10] * 0x14) = 9;
			}
			if (param_3 != (float *)0x0) {
				iVar2 = param_1[10];
				iVar3 = param_1[9];
				*(float *)(iVar3 + -0xc + iVar2 * 0x14) = local_8;
				*(float *)(iVar3 + -8 + iVar2 * 0x14) = local_4;
			}
			if (param_5 != 0) {
				*(byte *)(param_1[9] + -4 + param_1[10] * 0x14) =
						 *(byte *)(param_1[9] + -4 + param_1[10] * 0x14) | 8;
			}
		}
	}
	return BVar7;
}



BOOL __cdecl lego::game::LiveObject_FUN_0043a5c0(LiveObject *liveObj1,LiveObject *liveObj2)
{
	byte *pbVar1;
	LiveObject *liveObj;
	LiveObject *liveObj_00;
	ObjectStatsFlags1 OVar2;
	BOOL BVar3;
	SurfaceMap *pSVar4;
	Container *cont;
	float in_x;
	float in_y;
	LiveObject **ppLVar5;
	LiveObject **ppLVar6;
	LiveObject *local_3c;
	float *local_38;
	float *local_34;
	LiveObject *local_30;
	uint local_2c;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	Vector3F local_18;
	Vector3F local_c;
	
	liveObj = liveObj1;
	if ((liveObj1->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		OVar2 = LiveObject_GetStatsFlags1(liveObj1);
		if (((OVar2 & STATS1_PROCESSCRYSTAL) != STATS1_NONE) ||
			 (OVar2 = LiveObject_GetStatsFlags1(liveObj), liveObj_00 = liveObj2,
			 (OVar2 & STATS1_PROCESSORE) != STATS1_NONE)) {
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_2000;
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_DESPOSIT,1);
			Game_UpdateSomeAITasks(liveObj);
			LiveObject_FUN_00447df0(liveObj,1.0);
			return 1;
		}
		BVar3 = FUN_00439e90(liveObj2,liveObj->carriedObjects[0],0);
		if ((BVar3 != 0) ||
			 (OVar2 = LiveObject_GetStatsFlags1(liveObj_00), (OVar2 & STATS1_STOREOBJECTS) != STATS1_NONE)
			 ) {
			cont = (Container *)0x0;
			OVar2 = LiveObject_GetStatsFlags1(liveObj_00);
			if ((OVar2 & STATS1_STOREOBJECTS) == STATS1_NONE) {
				if (liveObj_00->objType == OBJECT_BUILDING) {
					cont = res::Building_GetDepositNull(liveObj_00->building);
				}
			}
			else {
				cont = res::Building_GetToolNull(liveObj_00->building,DAT_004dfe40);
			}
			if (cont == (Container *)0x0) {
				LiveObject_GetPosition(liveObj_00,&local_28,&local_24);
			}
			else {
				res::Container_GetPosition(cont,(Container *)0x0,&local_c);
				res::Container_GetOrientation(cont,(Container *)0x0,&local_18,(Vector3F *)0x0);
				local_28 = local_c.x;
				local_24 = local_c.y;
				if (ABS(local_18.x) <= ABS(local_18.y)) {
					if ((ushort)((ushort)(local_18.y < 0.0) << 8 | (ushort)(local_18.y == 0.0) << 0xe) == 0) {
						liveObj1._0_1_ = 2;
					}
					else {
						liveObj1._0_1_ = 0;
					}
				}
				else {
					if ((ushort)((ushort)(local_18.x < 0.0) << 8 | (ushort)(local_18.x == 0.0) << 0xe) == 0) {
						liveObj1._0_1_ = 3;
					}
					else {
						liveObj1._0_1_ = 1;
					}
				}
			}
			ppLVar6 = &liveObj1;
			ppLVar5 = &liveObj2;
			in_x = local_28;
			in_y = local_24;
			pSVar4 = GetSurfaceMap();
			SurfaceMap_ToBlockCoordinatesNoZ(pSVar4,in_x,in_y,(int *)ppLVar5,(int *)ppLVar6);
			LiveObject_GetPosition(liveObj,&local_20,&local_1c);
			ppLVar6 = &local_3c;
			ppLVar5 = &local_30;
			pSVar4 = GetSurfaceMap();
			SurfaceMap_ToBlockCoordinatesNoZ(pSVar4,local_20,local_1c,(int *)ppLVar5,(int *)ppLVar6);
			if ((local_30 == liveObj2) && (local_3c == liveObj1)) {
				BVar3 = LiveObject_FUN_004419c0(liveObj,1,(float *)&liveObj2,(float *)&liveObj1,&local_28);
			}
			else {
				BVar3 = LiveObject_FUN_004413b0
													(liveObj,local_30,local_3c,liveObj2,liveObj1,&local_38,&local_34,&local_2c
													 ,0,0);
				if (BVar3 == 0) {
					return 0;
				}
				BVar3 = LiveObject_FUN_004419c0(liveObj,local_2c,local_38,local_34,&local_28);
				std::free(local_38);
				std::free(local_34);
			}
			if (BVar3 != 0) {
				liveObj->object_2fc = liveObj_00;
				OVar2 = LiveObject_GetStatsFlags1(liveObj_00);
				if ((OVar2 & STATS1_STOREOBJECTS) != STATS1_NONE) {
					*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 9;
					liveObj->object_2fc = liveObj_00;
					return 1;
				}
				*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 7;
				*(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) =
						 *(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) | 4;
				pbVar1 = (byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4);
				*pbVar1 = *pbVar1 | (byte)liveObj1 & 3;
			}
			return 1;
		}
	}
	return 0;
}



Container * __cdecl lego::game::LiveObject_GetDepositNull(LiveObject *liveObj)
{
	ObjectType OVar1;
	Container *pCVar2;
	
	pCVar2 = (Container *)0x0;
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_BUILDING) {
		pCVar2 = res::Building_GetDepositNull(liveObj->building);
	}
	else {
		if (OVar1 == OBJECT_ROCKMONSTER) {
			pCVar2 = res::Creature_GetDepositNull(liveObj->rockMonster);
		}
		else {
			if (OVar1 == OBJECT_MINIFIGURE) {
				pCVar2 = res::Creature_GetDepositNull(liveObj->miniFigure);
			}
			else {
				if (OVar1 == OBJECT_VEHICLE) {
					pCVar2 = res::Vehicle_GetDepositNull(liveObj->vehicle);
				}
			}
		}
	}
	if (pCVar2 == (Container *)0x0) {
		pCVar2 = LiveObject_GetResource(liveObj);
	}
	return pCVar2;
}



int __cdecl FUN_0043a910(LiveObject *liveObj,ObjectType objType,int objIndex,int objLevel)
{
	BOOL BVar1;
	int iVar2;
	Container *pCVar3;
	LiveObject *liveObj_00;
	MessageType msgType;
	Vector3F local_c;
	
	BVar1 = lego::game::LiveObject_CanSpawnCarryableObject(liveObj,objType,objIndex);
	if (BVar1 == 0) {
		return (int)(LiveObject *)0x0;
	}
	switch(objType) {
	case OBJECT_POWERCRYSTAL:
	case OBJECT_ORE:
		iVar2 = 10;
		break;
	case OBJECT_DYNAMITE:
		iVar2 = 9;
		break;
	case OBJECT_BARRIER:
		iVar2 = 8;
		break;
	default:
		iVar2 = 0;
	}
	pCVar3 = lego::res::Building_GetToolNull(liveObj->building,(&DAT_004dfe18)[iVar2]);
	lego::res::Container_GetPosition(pCVar3,(Container *)0x0,&local_c);
	pCVar3 = lego::globals::g_Game.RES_Crystal;
	if (objType == OBJECT_POWERCRYSTAL) {
		lego::game::Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
		lego::game::Level_SubtractCrystals(1);
	}
	else {
		if (objType == OBJECT_ORE) {
			pCVar3 = lego::globals::g_Game.RES_Ores_TABLE[objIndex];
			lego::game::Level_SubtractOre(objIndex,1);
		}
		else {
			pCVar3 = lego::globals::g_Game.RES_Barrier;
			if ((((objType != OBJECT_BARRIER) &&
					 (pCVar3 = lego::globals::g_Game.RES_Dynamite, objType != OBJECT_DYNAMITE)) &&
					(pCVar3 = lego::globals::g_Game.RES_ElectricFence, objType != OBJECT_ELECTRICFENCE)) &&
				 (pCVar3 = lego::globals::g_Game.RES_OohScary, objType != OBJECT_OOHSCARY)) {
				return (int)(LiveObject *)0x0;
			}
		}
	}
	liveObj_00 = lego::game::Game_CreateLiveResourceObject
												 (pCVar3,objType,objIndex,objLevel,local_c.x,local_c.y,0.0);
	if (objType == OBJECT_ORE) {
		msgType = MESSAGE_GENERATEORE_COMPLETE;
	}
	else {
		msgType = MESSAGE_GENERATECRYSTAL_COMPLETE;
	}
	lego::game::Level_AddMessageAction(msgType,liveObj_00,0,(Point2I *)0x0);
	if (objType != OBJECT_BARRIER) {
		if (objType == OBJECT_DYNAMITE) {
			lego::res::Container_SetActivity(liveObj_00->other,"Normal");
		}
		return (int)liveObj_00;
	}
	lego::res::Container_SetActivity(liveObj_00->other,"Short");
	return (int)liveObj_00;
}



BOOL __cdecl
lego::game::LiveObject_CanSpawnCarryableObject(LiveObject *liveObj,ObjectType objType,int objIndex)
{
	ObjectStatsFlags1 OVar1;
	int iVar2;
	
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_STOREOBJECTS) != STATS1_NONE) {
		if (objType == OBJECT_POWERCRYSTAL) {
			iVar2 = Level_GetCrystalCount(1);
			if (iVar2 != 0) {
				return 1;
			}
		}
		if (objType == OBJECT_ORE) {
			iVar2 = Level_GetOreCount(objIndex);
			if (iVar2 != 0) {
				return 1;
			}
		}
		if (objType == OBJECT_BARRIER) {
			return 1;
		}
		if (objType == OBJECT_DYNAMITE) {
			return 1;
		}
		if (objType == OBJECT_ELECTRICFENCE) {
			return 1;
		}
		if (objType == OBJECT_OOHSCARY) {
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_0043ab10(LiveObject *liveObj,LiveObject *liveObj2)
{
	int *piVar1;
	int iVar2;
	
	if ((liveObj->objType == OBJECT_ROCKMONSTER) && (liveObj->tableptr_348 == (int *)0x0)) {
		piVar1 = (int *)std::malloc(0x18);
		liveObj->tableptr_348 = piVar1;
		for (iVar2 = 6; iVar2 != 0; iVar2 = iVar2 + -1) {
			*piVar1 = 0;
			piVar1 = piVar1 + 1;
		}
	}
	if (liveObj2->objType == OBJECT_POWERCRYSTAL) {
		if (liveObj->objType == OBJECT_ROCKMONSTER) {
			liveObj->tableptr_348[liveObj2->objLevel] = liveObj->tableptr_348[liveObj2->objLevel] + 1;
		}
		else {
			Level_IncrementCrystals();
		}
	}
	else {
		if ((liveObj2->objType == OBJECT_ORE) && (liveObj->objType != OBJECT_ROCKMONSTER)) {
			Level_IncOre(liveObj2->objIndex);
		}
	}
	liveObj2->carryingThisObject = (LiveObject *)0x0;
	pool::ReservedPool_LiveObject___Release(liveObj2);
	if (liveObj->objType != OBJECT_ROCKMONSTER) {
		LiveObject_FUN_00403840(liveObj);
	}
	return;
}



void __cdecl FUN_0043abb0(undefined4 param_1,int param_2)
{
	if (param_2 != 0) {
		do {
			lego::game::Level_IncrementCrystals();
			param_2 = param_2 + -1;
		} while (param_2 != 0);
	}
	lego::game::Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
	return;
}



void __cdecl FUN_0043abd0(undefined4 param_1,int param_2)
{
	if (param_2 != 0) {
		do {
			lego::game::Level_IncOre(0);
			param_2 = param_2 + -1;
		} while (param_2 != 0);
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_0043abf0(LiveObject *liveObj)
{
	LiveObject **ppLVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (UINT_004ebd5c != 0) {
		ppLVar1 = PTR_ARRAY_004ebbcc;
		do {
			if (liveObj == *ppLVar1) {
				*ppLVar1 = (LiveObject *)0x0;
			}
			uVar2 = uVar2 + 1;
			ppLVar1 = ppLVar1 + 1;
		} while (uVar2 < UINT_004ebd5c);
	}
	return;
}



void __cdecl lego::game::LiveObject_Vehicle_FUN_0043ac20(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	int local_8;
	int local_4;
	
	if (liveObj->objType == OBJECT_VEHICLE) {
		OVar1 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar1 & STATS1_CROSSLAND) == STATS1_NONE) {
			LiveObject_GetBlockCoordinates(liveObj,&local_8,&local_4);
			if (((globals::g_Game.level)->blocks
					 [((globals::g_Game.level)->dimensions).width * local_4 + local_8].terrain == TERRAIN_LAKE
					) && (UINT_004ebd5c < 100)) {
				PTR_ARRAY_004ebbcc[UINT_004ebd5c] = liveObj;
				UINT_004ebd5c = UINT_004ebd5c + 1;
			}
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_Vehicle_FUN_0043aca0(LiveObject *liveObj)
{
	LiveObject_Vehicle_FUN_0043ac20(liveObj);
	return;
}



void __cdecl lego::game::LiveObject_FUN_0043acb0(LiveObject *liveObj1,LiveObject *liveObj2)
{
	int local_10;
	int local_c;
	int local_8;
	int local_4;
	
	if (((((liveObj1->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) &&
			 ((*(byte *)&liveObj1->flags2 & 1) == 0)) &&
			((liveObj1->flags1 & (LIVEOBJ1_UNK_100|LIVEOBJ1_UNK_1000000)) == LIVEOBJ1_NONE)) &&
		 ((((ushort)((ushort)(liveObj1->health < 0.0) << 8 | (ushort)(liveObj1->health == 0.0) << 0xe)
				== 0 && ((liveObj2->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
			(liveObj2->carriedObjects[0]->objType == OBJECT_POWERCRYSTAL)))) {
		LiveObject_GetBlockCoordinates(liveObj1,&local_10,&local_c);
		LiveObject_GetBlockCoordinates(liveObj2,&local_8,&local_4);
		if (globals::g_Activities_TABLE[36] != liveObj1->aitaskName1) {
			LiveObject_SetActivityUnk(liveObj1,ACTIVITY_STAMP,0);
			Game_UpdateSomeAITasks(liveObj1);
			liveObj1->flags2 = liveObj1->flags2 | LIVEOBJ2_UNK_200000;
		}
	}
	return;
}



void __cdecl FUN_0043ad70(uint *param_1)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	uint uVar3;
	SurfaceMap *pSVar4;
	float10 fVar5;
	float10 fVar6;
	float *out_x;
	float *out_y;
	Point2I local_18;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	if (*param_1 == 3) {
		OVar1 = lego::game::LiveObject_GetStatsFlags2((LiveObject *)param_1);
		if ((OVar1 & STATS2_ATTACKPATHS) != STATS2_NONE) {
			fVar5 = lego::game::LiveObject_GetPainThreshold((LiveObject *)param_1);
			if (((fVar5 < (float10)(float)param_1[0xd0]) &&
					(lego::globals::g_Activities_TABLE[36] != (char *)param_1[0xba])) &&
				 ((param_1[0xf8] & 0x400) == 0)) {
				lego::game::LiveObject_GetBlockCoordinates
									((LiveObject *)param_1,(int *)&local_18,&local_18.y);
				BVar2 = lego::game::Level_IsBlockPowerPath(&local_18);
				if (BVar2 != 0) {
					uVar3 = FUN_00432f60((int *)&local_18);
					if (uVar3 == 0) {
						lego::game::LiveObject_GetPosition((LiveObject *)param_1,&local_10,&local_c);
						out_y = &local_4;
						out_x = &local_8;
						pSVar4 = lego::game::GetSurfaceMap();
						lego::game::SurfaceMap_FUN_0044f900(pSVar4,local_18.x,local_18.y,out_x,out_y);
						pSVar4 = lego::game::GetSurfaceMap();
						fVar6 = lego::game::SurfaceMap_GetBlockSize(pSVar4);
						fVar5 = (float10)SQRT((local_c - local_4) * (local_c - local_4) +
																	(local_10 - local_8) * (local_10 - local_8));
						if ((ushort)((ushort)(fVar6 * (float10)0.3333333 < fVar5) << 8 |
												(ushort)(fVar6 * (float10)0.3333333 == fVar5) << 0xe) == 0) {
							lego::game::LiveObject_SetActivityUnk((LiveObject *)param_1,ACTIVITY_STAMP,0);
							lego::game::Game_UpdateSomeAITasks((LiveObject *)param_1);
							param_1[0xf9] = param_1[0xf9] | 0x200000;
						}
					}
				}
			}
		}
	}
	return;
}



void __cdecl FUN_0043aeb0(LiveObject *liveObj)
{
	short sVar1;
	BOOL BVar2;
	Point2I local_8;
	
	lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_8,&local_8.y);
	sVar1 = lego::math::Maths_Rand();
	if ((int)sVar1 % 5 == 0) {
		FUN_00435160(&local_8,3,1);
	}
	BVar2 = lego::game::Level_IsBlockPowerPath(&local_8);
	if (BVar2 != 0) {
		FUN_0040bde0(liveObj,(Vector3F *)0x0);
		lego::ai::AITask_DoClearTypeAction(&local_8,MESSAGE_CLEARREMOVEPATH_COMPLETE);
		lego::game::Level_UpdateBlockSurfaceUnk(lego::globals::g_Game.level,local_8.x,local_8.y);
	}
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_0043af50,liveObj);
	return;
}



undefined4 __cdecl FUN_0043af50(int *param_1,undefined4 *param_2)
{
	float10 fVar1;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	if (((*param_1 == 2) && ((param_1[0xf8] & 0x400U) != 0)) && (*(int *)param_1[0xc2] == 6)) {
		lego::game::LiveObject_GetPosition((LiveObject *)param_2,&local_8,&local_4);
		lego::game::LiveObject_GetPosition((LiveObject *)param_1,&local_10,&local_c);
		fVar1 = lego::game::LiveObject_GetStampRadius((LiveObject *)param_2);
		if ((float10)SQRT((local_c - local_4) * (local_c - local_4) +
											(local_10 - local_8) * (local_10 - local_8)) < fVar1) {
			lego::game::LiveObject_FUN_0043a130((LiveObject *)param_1,0);
			lego::game::LiveObject_UnkDoRouting_FUN_00441c00((LiveObject *)param_1,0);
		}
	}
	return 0;
}



uint * __cdecl FUN_0043b010(undefined4 *param_1,uint param_2)
{
	short sVar1;
	SurfaceMap *surfMap;
	LiveObject *liveObj;
	float10 fVar2;
	float10 fVar3;
	uint x;
	uint y;
	float *out_x;
	float *out_y;
	float local_18;
	float local_14;
	Point2I local_10;
	float local_8;
	float local_4;
	
	liveObj = (LiveObject *)0x0;
	if (lego::globals::g_SlimySlugHoles_COUNT != 0) {
		fVar2 = lego::math::Maths_RandRange(0.0,6.283185);
		fVar3 = (float10)fsin(fVar2);
		local_8 = (float)fVar3;
		fVar3 = (float10)fcos((float10)(float)fVar2);
		local_4 = (float)fVar3;
		if (param_1 == (undefined4 *)0x0) {
			sVar1 = lego::math::Maths_Rand();
			local_10.x = lego::globals::g_SlimySlugHoles_TABLE
									 [(uint)(int)sVar1 % lego::globals::g_SlimySlugHoles_COUNT].x;
			local_10.y = lego::globals::g_SlimySlugHoles_TABLE
									 [(uint)(int)sVar1 % lego::globals::g_SlimySlugHoles_COUNT].y;
		}
		else {
			lego::game::LiveObject_NearestSlugHole_FUN_0044a7b0((LiveObject *)param_1,&local_10);
		}
		out_y = &local_14;
		out_x = &local_18;
		x = local_10.x;
		y = local_10.y;
		surfMap = lego::game::GetSurfaceMap();
		lego::game::SurfaceMap_FUN_0044f900(surfMap,x,y,out_x,out_y);
		local_18 = local_8 * 12.75 + local_18;
		local_14 = local_4 * 12.75 + local_14;
		liveObj = lego::game::Game_CreateLiveResourceObject
												((Container *)(lego::globals::g_Game.RockMonsterData_TABLE + param_2),
												 OBJECT_ROCKMONSTER,param_2,0,local_18,local_14,(float)fVar2);
		if (liveObj != (LiveObject *)0x0) {
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_100;
			liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_80000000;
			lego::game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_EMERGE,0);
			lego::game::Game_UpdateSomeAITasks(liveObj);
			lego::ai::AITask_DoAnimationWait(liveObj);
			lego::front::Info_FUN_00419ab0(INFO_SLUGEMERGE,(char *)0x0,liveObj,(Point2I *)0x0);
		}
	}
	return (uint *)liveObj;
}



uint * __cdecl FUN_0043b160(void)
{
	int iVar1;
	int iVar2;
	short sVar3;
	short sVar4;
	uint uVar5;
	SurfaceMap *pSVar6;
	uint *puVar7;
	uint local_c;
	
	uVar5 = lego::game::Level_GetEmergeCreature();
	pSVar6 = lego::game::GetSurfaceMap();
	iVar1 = (pSVar6->smallDimensions).width;
	pSVar6 = lego::game::GetSurfaceMap();
	iVar2 = (pSVar6->smallDimensions).height;
	local_c = 0;
	do {
		sVar3 = lego::math::Maths_Rand();
		sVar4 = lego::math::Maths_Rand();
		puVar7 = FUN_0043b1f0((int **)(lego::globals::g_Game.RockMonsterData_TABLE + uVar5),4.203895e-45
													,uVar5,(int)sVar3 % iVar1,(int)sVar4 % iVar2);
		if (puVar7 != (uint *)0x0) {
			return puVar7;
		}
		local_c = local_c + 1;
	} while (local_c < 1000);
	return (uint *)0x0;
}



uint * __cdecl FUN_0043b1f0(int **param_1,float param_2,uint param_3,uint param_4,uint param_5)
{
	BOOL BVar1;
	uint uVar2;
	int iVar3;
	SurfaceMap *pSVar4;
	LiveObject *liveObj;
	Container *cont;
	uint uVar5;
	Point2I *position;
	bool bVar6;
	ObjectType x;
	uint uVar7;
	float *pfVar8;
	float *pfVar9;
	float local_44;
	float local_40;
	float local_3c;
	Point2I local_38;
	float local_30 [4];
	Point2I local_20;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar7 = param_5;
	x = param_4;
	local_38.x = param_4;
	local_38.y = param_5;
	if (param_2 != 4.203895e-45) {
		return (uint *)(LiveObject *)0x0;
	}
	BVar1 = lego::game::Level_GetBlockFlags1_10Not8(param_4,param_5);
	if (BVar1 == 0) {
		return (uint *)(LiveObject *)0x0;
	}
	BVar1 = lego::game::Level_GetBlockFlags1_20(x,uVar7);
	if (BVar1 != 0) {
		return (uint *)(LiveObject *)0x0;
	}
	BVar1 = lego::game::Level_GetBlockFlags1_c0(x,uVar7);
	if (BVar1 != 0) {
		return (uint *)(LiveObject *)0x0;
	}
	uVar2 = lego::game::Level_IsBlockSolid(&local_38);
	if (uVar2 != 0) {
		return (uint *)(LiveObject *)0x0;
	}
	uVar2 = lego::game::Level_GetBlockFlags1_8000000(&local_38);
	if (uVar2 != 0) {
		return (uint *)(LiveObject *)0x0;
	}
	uVar2 = 0;
	local_20.x = 0;
	local_20.y = -1;
	local_18 = 1;
	local_14 = 0;
	local_10 = 0;
	local_c = 1;
	local_8 = 0xffffffff;
	local_4 = 0;
	local_30[0] = 0.0;
	local_30[1] = 1.570796;
	local_30[2] = 3.141593;
	local_30[3] = 4.712389;
	position = &local_20;
	do {
		position->x = position->x + x;
		uVar5 = position->y + uVar7;
		position->y = uVar5;
		BVar1 = lego::game::Level_GetBlockFlags1_8(position->x,uVar5);
		if (((BVar1 != 0) && (BVar1 = lego::game::Level_GetBlockFlags1_180000(position), BVar1 == 0)) &&
			 (iVar3 = lego::game::LiveObject_FUN_00431cd0
													((LiveObject *)0x0,position->x,position->y,position->x,position->y,0),
			 iVar3 != 0)) break;
		uVar2 = uVar2 + 1;
		position = position + 1;
	} while (uVar2 < 4);
	if (3 < uVar2) {
		return (uint *)(LiveObject *)0x0;
	}
	pfVar9 = &local_3c;
	pfVar8 = &local_40;
	pSVar4 = lego::game::GetSurfaceMap();
	lego::game::SurfaceMap_FUN_0044f900(pSVar4,x,uVar7,pfVar8,pfVar9);
	uVar7 = (&local_20)[uVar2].y;
	pfVar9 = &param_2;
	pfVar8 = &local_44;
	uVar5 = (&local_20)[uVar2].x;
	pSVar4 = lego::game::GetSurfaceMap();
	lego::game::SurfaceMap_FUN_0044f900(pSVar4,uVar5,uVar7,pfVar8,pfVar9);
	local_44 = (local_40 * 9.0 + local_44 * 10.0) * 0.05263158;
	param_2 = (local_3c * 9.0 + param_2 * 10.0) * 0.05263158;
	liveObj = lego::game::Game_CreateLiveResourceObject
											((Container *)param_1,OBJECT_ROCKMONSTER,param_3,0,local_44,param_2,
											 local_30[uVar2]);
	liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_100;
	lego::game::LiveObject_RockMonster_DoWakeUp(liveObj);
	lego::game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_EMERGE,0);
	lego::game::Game_UpdateSomeAITasks(liveObj);
	lego::ai::AITask_DoAnimationWait(liveObj);
	cont = lego::game::LiveObject_GetResource(liveObj);
	lego::res::Res_PlayResourceSound(cont,SFX_ROCKMONSTER2,0,1,(Vector3F *)0x0);
	lego::game::Level_SetBlockFlags1_8000000(&local_38,1);
	bVar6 = false;
	(liveObj->point_2f4).x = (float)local_38.x;
	(liveObj->point_2f4).y = (float)local_38.y;
	BVar1 = lego::game::Object_GetObjectByName
										("RockMonster",&param_4,(int *)&param_5,(Container **)0x0);
	if (((BVar1 != 0) && (param_4 == liveObj->objType)) && (param_5 == liveObj->objIndex)) {
		lego::front::Info_FUN_00419ab0(INFO_ROCKMONSTER,(char *)0x0,liveObj,(Point2I *)0x0);
		bVar6 = true;
	}
	if (!bVar6) {
		BVar1 = lego::game::Object_GetObjectByName
											("Lavamonster",&param_4,(int *)&param_5,(Container **)0x0);
		if (((BVar1 != 0) && (param_4 == liveObj->objType)) && (param_5 == liveObj->objIndex)) {
			lego::front::Info_FUN_00419ab0(INFO_LAVAROCKMONSTER,(char *)0x0,liveObj,(Point2I *)0x0);
			bVar6 = true;
		}
		if (!bVar6) {
			BVar1 = lego::game::Object_GetObjectByName
												("Icemonster",&param_4,(int *)&param_5,(Container **)0x0);
			if (((BVar1 != 0) && (param_4 == liveObj->objType)) && (param_5 == liveObj->objIndex)) {
				lego::front::Info_FUN_00419ab0(INFO_ICEROCKMONSTER,(char *)0x0,liveObj,(Point2I *)0x0);
				bVar6 = true;
			}
			if (!bVar6) goto LAB_0043b517;
		}
	}
	lego::front::Info_FUN_00419ab0(INFO_GENERICMONSTER,(char *)0x0,liveObj,(Point2I *)0x0);
LAB_0043b517:
	lego::nerps::NERPs_IncInt_00556324();
	return (uint *)liveObj;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl lego::game::Game_UpdateLevelBlockPointsTable(float elapsedGame)
{
	LiveManagerFlags LVar1;
	LiveManagerFlags LVar2;
	
	if ((pool::globals::ReservedPool_LiveObject___g_INITFLAGS & 4) != LIVEMANAGER_NONE) {
		Game_LevelClearBlockFlag2_100_Points28C();
	}
	pool::globals::ReservedPool_LiveObject___g_INITFLAGS =
			 pool::globals::ReservedPool_LiveObject___g_INITFLAGS | 0x10;
	unk::DoLiveObjCallbacks_FUN_00437a90(Game_LiveObjectLargeCallback,&elapsedGame,0);
	LVar2 = pool::globals::ReservedPool_LiveObject___g_INITFLAGS & 0xffffffef;
	LVar1 = pool::globals::ReservedPool_LiveObject___g_INITFLAGS & 4;
	pool::globals::ReservedPool_LiveObject___g_INITFLAGS = LVar2;
	if (LVar1 != LIVEMANAGER_NONE) {
		Game_UpdateLevelBlocks_PointsAAC();
	}
	if ((pool::globals::ReservedPool_LiveObject___g_INITFLAGS & 8) == LIVEMANAGER_NONE) {
		pool::globals::ReservedPool_LiveObject___g_INITFLAGS =
				 pool::globals::ReservedPool_LiveObject___g_INITFLAGS & 0xfffffffb;
	}
	else {
		Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
		pool::globals::ReservedPool_LiveObject___g_INITFLAGS =
				 pool::globals::ReservedPool_LiveObject___g_INITFLAGS & 0xfffffff7;
	}
	FUN_0044c1c0(&elapsedGame);
	_DAT_004ebdc8 = _DAT_004ebdc8 - elapsedGame;
	if ((ushort)((ushort)(_DAT_004ebdc8 < 0.0) << 8 | (ushort)(_DAT_004ebdc8 == 0.0) << 0xe) != 0) {
		_DAT_004ebdc8 = 125.0;
		FUN_00425a70(1);
	}
	return;
}



void __cdecl FUN_0043b5e0(void)
{
	lego::pool::globals::ReservedPool_LiveObject___g_INITFLAGS =
			 lego::pool::globals::ReservedPool_LiveObject___g_INITFLAGS | 2;
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_0043b610,(LiveObject *)0x0);
	lego::pool::globals::ReservedPool_LiveObject___g_INITFLAGS =
			 lego::pool::globals::ReservedPool_LiveObject___g_INITFLAGS & 0xfffffffd;
	return;
}



void __cdecl FUN_0043b610(int *param_1)
{
	lego::pool::ReservedPool_LiveObject___Release((LiveObject *)param_1);
	return;
}



void __cdecl FUN_0043b620(uint mouseX,uint mouseY,undefined4 *param_3)
{
	undefined4 *local_c;
	float local_8;
	char *local_4;
	
	local_c = param_3;
	*param_3 = 0;
	local_8 = (float)(ulonglong)mouseX;
	local_4 = (char *)(float)(ulonglong)mouseY;
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_0043b670,(LiveObject *)&local_c);
	return;
}



BOOL __cdecl FUN_0043b670(LiveObject *liveObj,int **param_2)
{
	BOOL BVar1;
	SurfaceMap *pSVar2;
	Container *cont;
	Point2I *pPVar3;
	uint uVar4;
	uint uVar5;
	Direction rotation;
	Vector3F *pVVar6;
	Viewport *view;
	float10 fVar7;
	uint x;
	Vector3F *pVVar8;
	float x_00;
	Vector3F *camera;
	float *out_y;
	float y;
	uint local_d0;
	uint local_cc;
	Point2I *local_c8;
	Viewport *local_c4;
	Vector4F local_c0;
	Vector3F local_b0;
	Vector3F local_a4;
	Point2I local_98;
	Vector3F local_90;
	Vector3F local_84;
	Vector3F local_78 [10];
	
	view = lego::globals::g_Game.viewMain;
	local_c0.x = (float)param_2[1];
	local_c0.y = (float)param_2[2];
	rotation = DIRECTION_RIGHT;
	local_c4 = lego::globals::g_Game.viewMain;
	local_c0.z = 0.0;
	local_c0.w = 1.0;
	BVar1 = lego::game::LiveObject_CheckCondition_FUN_00438870(liveObj,1);
	if (BVar1 != 0) {
		lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_98,&local_98.y);
		lego::game::LiveObject_GetPosition(liveObj,(float *)local_78,&local_78[0].y);
		pSVar2 = lego::game::GetSurfaceMap();
		fVar7 = lego::game::SurfaceMap_GetSurfaceZ(pSVar2,local_78[0].x,local_78[0].y);
		local_78[0].z = (float)fVar7;
		fVar7 = lego::game::LiveObject_GetCollHeight(liveObj);
		local_78[0].z = (float)((float10)local_78[0].z - fVar7 * (float10)0.5);
		if (liveObj->objType == OBJECT_BUILDING) {
			cont = lego::game::LiveObject_GetResource(liveObj);
			uVar5 = 0;
			lego::res::Container_GetOrientation(cont,(Container *)0x0,&local_b0,(Vector3F *)0x0);
			if (ABS(local_b0.x) <= ABS(local_b0.y)) {
				if ((ushort)((ushort)(local_b0.y < 0.0) << 8 | (ushort)(local_b0.y == 0.0) << 0xe) == 0) {
					rotation = DIRECTION_UP;
				}
				else {
					rotation = DIRECTION_DOWN;
				}
			}
			else {
				if ((ushort)((ushort)(local_b0.x < 0.0) << 8 | (ushort)(local_b0.x == 0.0) << 0xe) != 0) {
					rotation = DIRECTION_LEFT;
				}
			}
			pPVar3 = lego::res::Building_GetShapePoints
												 (lego::globals::g_Game.BuildingData_TABLE + liveObj->objIndex,&local_cc);
			pPVar3 = lego::game::Game_TransformShapePoints(&local_98,pPVar3,local_cc,rotation);
			local_d0 = 0;
			if (local_cc != 0) {
				local_c8 = pPVar3 + 1;
				pVVar6 = local_78;
				uVar4 = local_cc;
				do {
					if (((uVar5 == uVar4 - 1) || (pPVar3->x != local_c8->x)) || (pPVar3->y != local_c8->y)) {
						uVar4 = pPVar3->y;
						x = pPVar3->x;
						pVVar8 = pVVar6;
						out_y = &pVVar6->y;
						pSVar2 = lego::game::GetSurfaceMap();
						lego::game::SurfaceMap_FUN_0044f900(pSVar2,x,uVar4,(float *)pVVar8,out_y);
						y = pVVar6->y;
						x_00 = pVVar6->x;
						pSVar2 = lego::game::GetSurfaceMap();
						fVar7 = lego::game::SurfaceMap_GetSurfaceZ(pSVar2,x_00,y);
						pVVar6->z = (float)fVar7;
						fVar7 = lego::game::LiveObject_GetCollHeight(liveObj);
						local_d0 = local_d0 + 1;
						pVVar6->z = (float)((float10)pVVar6->z - fVar7 * (float10)0.5);
						uVar4 = local_cc;
						pVVar6 = pVVar6 + 1;
					}
					else {
						uVar5 = uVar5 + 1;
						local_c8 = local_c8 + 1;
						pPVar3 = pPVar3 + 1;
					}
					uVar5 = uVar5 + 1;
					local_c8 = local_c8 + 1;
					pPVar3 = pPVar3 + 1;
					view = local_c4;
				} while (uVar5 < uVar4);
			}
		}
		else {
			local_d0 = 1;
		}
		lego::view::Viewport_InverseTransform(view,&local_a4,&local_c0);
		local_c0.z = 1.0;
		lego::view::Viewport_InverseTransform(view,&local_84,&local_c0);
		local_90.x = local_84.x - local_a4.x;
		local_84.y = local_84.y - local_a4.y;
		local_84.z = local_84.z - local_a4.z;
		uVar5 = 0;
		local_90.z = 1.0 / SQRT(local_84.z * local_84.z +
														local_84.y * local_84.y + local_90.x * local_90.x);
		local_90.x = local_90.z * local_90.x;
		local_90.y = local_90.z * local_84.y;
		local_90.z = local_90.z * local_84.z;
		if (local_d0 != 0) {
			pVVar6 = local_78;
			do {
				pVVar8 = &local_90;
				camera = &local_a4;
				fVar7 = lego::game::LiveObject_GetPickSphere(liveObj);
				BVar1 = lego::math::Maths_RaySphereIntersection(pVVar6,(float)fVar7,camera,pVVar8);
				if (BVar1 != 0) {
					**param_2 = (int)liveObj;
					return 1;
				}
				uVar5 = uVar5 + 1;
				pVVar6 = pVVar6 + 1;
			} while (uVar5 < local_d0);
			return 0;
		}
	}
	return 0;
}



void __cdecl lego::view::Viewport_DoSelection(Viewport *view,Point2F *dragStart,Point2F *dragEnd)
{
	TutorialFlags TVar1;
	Viewport *local_14;
	float local_10;
	char *local_c;
	VehicleData *local_8;
	CreatureData *local_4;
	
	TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
	if ((TVar1 & TUTORIAL_UNK_8) == TUTORIAL_NONE) {
		local_14 = view;
		if (dragEnd->x <= dragStart->x) {
			local_10 = dragEnd->x;
		}
		else {
			local_10 = dragStart->x;
		}
		if ((ushort)((ushort)(dragEnd->y < dragStart->y) << 8 |
								(ushort)(dragEnd->y == dragStart->y) << 0xe) == 0) {
			local_c = (char *)dragStart->y;
		}
		else {
			local_c = (char *)dragEnd->y;
		}
		if ((ushort)((ushort)(dragStart->x < dragEnd->x) << 8 |
								(ushort)(dragStart->x == dragEnd->x) << 0xe) == 0) {
			local_8 = (VehicleData *)dragStart->x;
		}
		else {
			local_8 = (VehicleData *)dragEnd->x;
		}
		if (dragStart->y <= dragEnd->y) {
			local_4 = (CreatureData *)dragEnd->y;
		}
		else {
			local_4 = (CreatureData *)dragStart->y;
		}
		unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_0043ba30,(LiveObject *)&local_14);
		game::Level_AddMessageAction(MESSAGE_REDUCESELECTION,0,0,(Point2I *)0x0);
	}
	return;
}



undefined4 __cdecl FUN_0043ba30(LiveObject *liveObj,int *param_2)
{
	Container *cont;
	Vector3F local_1c;
	Vector4F local_10;
	
	cont = lego::game::LiveObject_GetResource(liveObj);
	lego::res::Container_GetPosition(cont,(Container *)0x0,&local_1c);
	lego::view::Viewport_Transform((Viewport *)*param_2,&local_10,&local_1c);
	local_10.x = local_10.x / local_10.w;
	local_10.y = local_10.y / local_10.w;
	if (((((float)param_2[1] <= local_10.x) && ((float)param_2[2] <= local_10.y)) &&
			((ushort)((ushort)(local_10.x < (float)param_2[3]) << 8 |
							 (ushort)(local_10.x == (float)param_2[3]) << 0xe) != 0)) &&
		 ((ushort)((ushort)(local_10.y < (float)param_2[4]) << 8 |
							(ushort)(local_10.y == (float)param_2[4]) << 0xe) != 0)) {
		lego::game::Level_AddMessageAction(MESSAGE_SELECT,liveObj,1,(Point2I *)0x0);
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_FUN_0043bae0(LiveObject *liveObj,int camField14,BOOL in_polyIndexUnk)
{
	if ((liveObj->objType == OBJECT_MINIFIGURE) ||
		 ((liveObj = liveObj->drivenObject, liveObj != (LiveObject *)0x0 &&
			(liveObj->objType == OBJECT_MINIFIGURE)))) {
		res::Creature_FUN_00406b90(liveObj->miniFigure,in_polyIndexUnk,camField14);
	}
	return;
}



void __cdecl
FUN_0043bb10(LiveObject *liveObj,Container *resData,char *param_3,VehicleData *param_4,int param_5)
{
	LiveObject *pLVar1;
	LiveObjectInfo liveInfo;
	
	liveInfo.point_8.x = (float)param_3;
	liveInfo.point_8.y = (float)param_4;
	liveInfo.liveObj = liveObj;
	liveInfo.vector_10.x = 0.0;
	liveInfo.intbool_4 = param_5;
	liveInfo.vector_10.y = 0.0;
	liveInfo.vector_10.z = 0.0;
	if (((liveObj->objType != OBJECT_MINIFIGURE) &&
			(pLVar1 = liveObj->drivenObject, pLVar1 != (LiveObject *)0x0)) &&
		 (pLVar1->objType == OBJECT_MINIFIGURE)) {
		liveInfo.liveObj = pLVar1;
	}
	if (param_5 != 0) {
		lego::res::Container_GetPosition(resData,(Container *)0x0,&liveInfo.vector_10);
	}
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
						(lego::game::LiveObject_FUN_0043bb90,(LiveObject *)&liveInfo);
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_0043bb90(LiveObject *liveObj,LiveObjectInfo *liveInfo)
{
	float fVar1;
	int iVar2;
	ObjectType OVar3;
	float fVar4;
	float fVar5;
	Container *cont;
	Vector3F vector;
	
	if (liveObj != liveInfo->liveObj) {
		iVar2 = liveObj->mode_34c;
		if (liveInfo->intbool_4 == 0) {
			if (iVar2 == 1) {
				OVar3 = liveObj->objType;
				if (OVar3 == OBJECT_MINIFIGURE) {
					res::Creature_FUN_00406b30(liveObj->miniFigure,0);
				}
				else {
					if (OVar3 == OBJECT_ROCKMONSTER) {
						res::Creature_FUN_00406b30(liveObj->rockMonster,0);
					}
					else {
						if (OVar3 == OBJECT_VEHICLE) {
							res::Vehicle_FUN_0046d190(liveObj->vehicle,0);
						}
					}
				}
			}
			else {
				if (iVar2 == 2) {
					OVar3 = liveObj->objType;
					if (OVar3 == OBJECT_MINIFIGURE) {
						res::Creature_FUN_00406b60(liveObj->miniFigure,0);
					}
					else {
						if (OVar3 == OBJECT_ROCKMONSTER) {
							res::Creature_FUN_00406b60(liveObj->rockMonster,0);
						}
						else {
							if (OVar3 == OBJECT_VEHICLE) {
								res::Vehicle_FUN_0046d1e0(liveObj->vehicle,0);
							}
						}
					}
				}
			}
			liveObj->mode_34c = 0;
		}
		else {
			if (iVar2 == 0) {
				cont = LiveObject_GetResource(liveObj);
				res::Container_GetPosition(cont,(Container *)0x0,&vector);
				fVar5 = (liveInfo->vector_10).x - vector.x;
				fVar1 = (liveInfo->vector_10).y - vector.y;
				fVar4 = (liveInfo->vector_10).z - vector.z;
				fVar4 = SQRT(fVar4 * fVar4 + fVar1 * fVar1 + fVar5 * fVar5);
				fVar1 = (liveInfo->point_8).y;
				if ((ushort)((ushort)(fVar4 < fVar1) << 8 | (ushort)(fVar4 == fVar1) << 0xe) != 0) {
					OVar3 = liveObj->objType;
					if (OVar3 == OBJECT_MINIFIGURE) {
						res::Creature_FUN_00406b60(liveObj->miniFigure,1);
						liveObj->mode_34c = 2;
						return 0;
					}
					if (OVar3 != OBJECT_ROCKMONSTER) {
						if (OVar3 == OBJECT_VEHICLE) {
							res::Vehicle_FUN_0046d1e0(liveObj->vehicle,1);
						}
						liveObj->mode_34c = 2;
						return 0;
					}
					res::Creature_FUN_00406b60(liveObj->rockMonster,1);
					liveObj->mode_34c = 2;
					return 0;
				}
				fVar1 = (liveInfo->point_8).x;
				if ((ushort)((ushort)(fVar4 < fVar1) << 8 | (ushort)(fVar4 == fVar1) << 0xe) != 0) {
					OVar3 = liveObj->objType;
					if (OVar3 == OBJECT_MINIFIGURE) {
						res::Creature_FUN_00406b30(liveObj->miniFigure,1);
						liveObj->mode_34c = 1;
						return 0;
					}
					if (OVar3 != OBJECT_ROCKMONSTER) {
						if (OVar3 == OBJECT_VEHICLE) {
							res::Vehicle_FUN_0046d190(liveObj->vehicle,1);
						}
						liveObj->mode_34c = 1;
						return 0;
					}
					res::Creature_FUN_00406b30(liveObj->rockMonster,1);
					liveObj->mode_34c = 1;
					return 0;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(LiveObject *liveObj)
{
	if ((liveObj->flags1 &
			(LIVEOBJ1_LIFTING|LIVEOBJ1_TURNING|LIVEOBJ1_UNK_8|LIVEOBJ1_UNK_10|LIVEOBJ1_REINFORCING|
			 LIVEOBJ1_TURNRIGHT|LIVEOBJ1_UNK_100|LIVEOBJ1_UNK_200|LIVEOBJ1_UNK_1000|LIVEOBJ1_UNK_2000|
			 LIVEOBJ1_CLEARING|LIVEOBJ1_PLACING|LIVEOBJ1_UNK_100000|LIVEOBJ1_UNK_200000|
			 LIVEOBJ1_UNK_400000|LIVEOBJ1_UNK_10000000)) != LIVEOBJ1_NONE) {
		return 1;
	}
	return (uint)((liveObj->flags2 &
								(LIVEOBJ2_UNK_1|LIVEOBJ2_UNK_2|LIVEOBJ2_UNK_200|LIVEOBJ2_UNK_400000|
								 LIVEOBJ2_UNK_800000|LIVEOBJ2_UNK_1000000)) != LIVEOBJ2_NONE);
}



void __cdecl lego::game::LiveObject_FUN_0043bde0(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	uint uVar2;
	uint uVar3;
	
	if (liveObj->objType == OBJECT_BUILDING) {
		OVar1 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar1 & STATS1_PROCESSORE) == STATS1_NONE) {
			uVar3 = liveObj->numCarriedObjects;
		}
		else {
			uVar3 = liveObj->field_328;
			uVar2 = LiveObject_GetMaxCarry(liveObj);
			if (uVar2 <= uVar3) {
				uVar3 = LiveObject_GetMaxCarry(liveObj);
			}
		}
		if (((liveObj->numCarriedObjects < uVar3) ||
				((liveObj->flags1 & LIVEOBJ1_UNK_2000) != LIVEOBJ1_NONE)) ||
			 ((liveObj->flags3 & LIVEOBJ3_UNK_1000000) != LIVEOBJ3_NONE)) {
			liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_1000000;
		}
		else {
			OVar1 = LiveObject_GetStatsFlags1(liveObj);
			if (((OVar1 & STATS1_PROCESSCRYSTAL) != STATS1_NONE) ||
				 (OVar1 = LiveObject_GetStatsFlags1(liveObj), (OVar1 & STATS1_PROCESSORE) != STATS1_NONE)) {
				LiveObject_FUN_0043a5c0(liveObj,(LiveObject *)0x0);
				return;
			}
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_0043be80(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	
	if (liveObj->objType == OBJECT_ROCKMONSTER) {
		pLVar1 = liveObj->carriedObjects[0];
		if ((pLVar1 != (LiveObject *)0x0) && (pLVar1->objType == OBJECT_POWERCRYSTAL)) {
			liveObj->carriedObjects[0] = (LiveObject *)0x0;
			liveObj->numCarriedObjects = 0;
			pLVar1->carryingThisObject = (LiveObject *)0x0;
			liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CARRYING;
			pLVar1->health = -1.0;
		}
		if (liveObj->tableptr_348 != (int *)0x0) {
			Level_AddToField9c(*liveObj->tableptr_348);
		}
		liveObj->health = -1.0;
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_0043bf00(LiveObject *liveObj)
{
	LiveFlags1 *pLVar1;
	LiveObject *pLVar2;
	LiveFlags3 LVar3;
	ObjectType OVar4;
	char *actname;
	ObjectStatsFlags1 OVar5;
	ObjectStatsFlags2 OVar6;
	Container *pCVar7;
	ObjectStatsFlags3 OVar8;
	int iVar9;
	float10 fVar10;
	InfoType infoType;
	float x;
	float y;
	float z;
	int local_10;
	int local_c;
	Point2I local_8;
	
	if (liveObj->objType != OBJECT_BUILDING) {
		if ((liveObj->flags2 & LIVEOBJ2_UNK_8000000) != LIVEOBJ2_NONE) {
			return;
		}
		if ((liveObj->flags1 & LIVEOBJ1_UNK_200000) != LIVEOBJ1_NONE) {
			return;
		}
	}
	if ((ushort)((ushort)(liveObj->health < 0.0) << 8 | (ushort)(liveObj->health == 0.0) << 0xe) == 0)
	{
		return;
	}
	OVar5 = LiveObject_GetStatsFlags1(liveObj);
	if ((((OVar5 & (STATS1_SMALLTELEPORTER|STATS1_BIGTELEPORTER|STATS1_WATERTELEPORTER|
								 STATS1_MANTELEPORTER)) != STATS1_NONE) &&
			(pLVar2 = liveObj->object_3cc, pLVar2 != (LiveObject *)0x0)) &&
		 ((pLVar2->flags1 & LIVEOBJ1_UNK_200000) != LIVEOBJ1_NONE)) {
		pLVar2->health = -1.0;
		pLVar1 = &liveObj->object_3cc->flags1;
		*pLVar1 = *pLVar1 & ~LIVEOBJ1_UNK_200000;
		LiveObject_FUN_00438720(liveObj);
		LiveObject_SetActivityUnk(liveObj->object_3cc,ACTIVITY_STAND,1);
		Game_UpdateSomeAITasks(liveObj->object_3cc);
	}
	LVar3 = liveObj->flags3;
	if ((LVar3 & LIVEOBJ3_UNK_800000) != LIVEOBJ3_NONE) {
		if (liveObj->drivenObject != (LiveObject *)0x0) {
			LiveObject_FUN_0041ce50(liveObj);
			liveObj->drivenObject->flags2 = liveObj->drivenObject->flags2 & ~LIVEOBJ2_DRIVING;
			liveObj->drivenObject->drivenObject = (LiveObject *)0x0;
			liveObj->drivenObject = (LiveObject *)0x0;
		}
		if ((liveObj->objType == OBJECT_MINIFIGURE) && ((*(byte *)&liveObj->flags4 & 8) != 0)) {
			LiveObject_UnkRecallMiniFigureName(liveObj);
		}
		if (liveObj->objType == OBJECT_VEHICLE) {
			res::Vehicle_ChangeUpgradeParts(liveObj->vehicle,0);
		}
		LiveObject_FUN_0044b0a0(liveObj);
		if (liveObj->objType != OBJECT_BOULDER) {
			if (liveObj->objType != OBJECT_BUILDING) {
				pool::ReservedPool_LiveObject___Release(liveObj);
				return;
			}
			LiveObject_FUN_00409f20(liveObj);
			return;
		}
		LiveObject_ReleaseBoulderUnk(liveObj);
		return;
	}
	OVar4 = liveObj->objType;
	if (OVar4 == OBJECT_ROCKMONSTER) {
		OVar6 = LiveObject_GetStatsFlags2(liveObj);
		if ((OVar6 & STATS2_SPLITONZEROHEALTH) == STATS2_NONE) {
			OVar6 = LiveObject_GetStatsFlags2(liveObj);
			if ((OVar6 & STATS2_USEHOLES) == STATS2_NONE) {
				return;
			}
			LiveObject_FUN_00441df0(liveObj,0,1);
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_20000;
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_ENTER,0);
			Game_UpdateSomeAITasks(liveObj);
			return;
		}
		if ((liveObj->flags1 & LIVEOBJ1_UNK_100000) != LIVEOBJ1_NONE) {
			return;
		}
		LiveObject_UnkActivityCrumble_FUN_004424d0(liveObj);
		return;
	}
	if (((OVar4 != OBJECT_MINIFIGURE) && (OVar4 != OBJECT_VEHICLE)) && (OVar4 != OBJECT_ELECTRICFENCE)
		 ) {
		if (OVar4 != OBJECT_BUILDING) {
			if (OVar4 != OBJECT_POWERCRYSTAL) {
				return;
			}
			liveObj->flags3 = LVar3 | LIVEOBJ3_UNK_800000;
			return;
		}
		if (((*(byte *)&liveObj->field_390 & 4) == 0) && ((*(byte *)&liveObj->flags4 & 8) == 0)) {
			if ((liveObj->flags2 & LIVEOBJ2_UNK_100000) != LIVEOBJ2_NONE) {
				return;
			}
			liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_100000;
			FUN_00409c80(liveObj);
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_EXPLODE,0);
			Game_UpdateSomeAITasks(liveObj);
			FUN_00403490(liveObj);
			goto LAB_0043c4a7;
		}
	}
	if ((LVar3 & 0x40000) == LIVEOBJ3_NONE) {
		return;
	}
	if ((liveObj->flags1 & LIVEOBJ1_UNK_400000) != LIVEOBJ1_NONE) {
		return;
	}
	actname = liveObj->aitaskName1;
	pCVar7 = LiveObject_GetResource(liveObj);
	if ((*(byte *)&liveObj->flags4 & 8) != 0) {
		LiveObject_FUN_0044b0a0(liveObj);
	}
	if (liveObj->objType == OBJECT_BUILDING) {
		FUN_00409c80(liveObj);
	}
	if ((*(byte *)&liveObj->flags4 & 0x80) != 0) {
		pLVar2 = liveObj->object_2fc;
		if (pLVar2 != (LiveObject *)0x0) {
			pLVar2->flags4 = pLVar2->flags4 & ~LIVEOBJ4_UNK_80;
		}
		liveObj->object_2fc = (LiveObject *)0x0;
	}
	if (liveObj->drivenObject != (LiveObject *)0x0) {
		LiveObject_GetBlockCoordinates(liveObj,&local_10,&local_c);
		OVar8 = LiveObject_GetStatsFlags3(liveObj);
		if (((((OVar8 & STATS3_CARRYVEHICLES) != STATS3_NONE) &&
				 ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
				(liveObj->carriedObjects[0] != (LiveObject *)0x0)) &&
			 (iVar9 = LiveObject_FUN_00431cd0
													(liveObj->carriedObjects[0],local_10,local_c,local_10,local_c,1),
			 iVar9 == 0)) {
			liveObj->carriedObjects[0]->health = -1.0;
		}
		OVar5 = LiveObject_GetStatsFlags1(liveObj);
		if (((OVar5 & STATS1_CANBEDRIVEN) == STATS1_NONE) ||
			 (iVar9 = LiveObject_FUN_00431cd0(liveObj->drivenObject,local_10,local_c,local_10,local_c,1),
			 iVar9 != 0)) {
			LiveObject_FUN_0041ce50(liveObj);
			liveObj->drivenObject->flags2 = liveObj->drivenObject->flags2 & ~LIVEOBJ2_DRIVING;
			if (liveObj->drivenObject->objType == OBJECT_MINIFIGURE) {
				res::Creature_FUN_00406d70
									(liveObj->drivenObject->miniFigure,globals::g_Activities_TABLE[0],0.0);
			}
			liveObj->drivenObject->drivenObject = (LiveObject *)0x0;
			liveObj->drivenObject = (LiveObject *)0x0;
		}
		else {
			liveObj->drivenObject->health = -1.0;
		}
	}
	if (liveObj->objType == OBJECT_ELECTRICFENCE) {
		LiveObject_FUN_0040cfd0(liveObj);
	}
	LiveObject_GetBlockCoordinates(liveObj,(int *)&local_8,&local_8.y);
	OVar4 = liveObj->objType;
	if (((OVar4 == OBJECT_MINIFIGURE) || (OVar4 == OBJECT_VEHICLE)) || (OVar4 == OBJECT_BUILDING)) {
		front::Info_FUN_00419ab0(INFO_GENERICDEATH,(char *)0x0,(LiveObject *)0x0,&local_8);
	}
	OVar4 = liveObj->objType;
	if (OVar4 == OBJECT_MINIFIGURE) {
		infoType = INFO_LEGOMANDEATH;
LAB_0043c382:
		front::Info_FUN_00419ab0(infoType,(char *)0x0,(LiveObject *)0x0,&local_8);
	}
	else {
		if (OVar4 == OBJECT_VEHICLE) {
			infoType = INFO_VEHICLEDEATH;
			goto LAB_0043c382;
		}
		if (OVar4 == OBJECT_BUILDING) {
			infoType = INFO_BUILDINGDEATH;
			goto LAB_0043c382;
		}
	}
	if ((*(byte *)&liveObj->flags2 & 2) == 0) {
		LiveObject_FUN_00441df0(liveObj,0,1);
		res::Container_SetActivity(pCVar7,actname);
		liveObj->aitaskName2 = liveObj->aitaskName1;
	}
	else {
		LiveObject_FUN_00441df0(liveObj,1,1);
	}
	liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_400000;
	pCVar7 = res::Container_Clone(globals::g_Game.RES_MiniTeleportUp);
	liveObj->resData_2e4 = pCVar7;
	res::Container_SetAnimationTime(pCVar7,0.0);
	res::Container_Hide(liveObj->resData_2e4,0);
	z = 0.0;
	y = 0.0;
	x = 0.0;
	pCVar7 = LiveObject_GetResource(liveObj);
	res::Container_SetPosition(liveObj->resData_2e4,pCVar7,x,y,z);
	res::Container_SetOrientation(liveObj->resData_2e4,(Container *)0x0,0.0,1.0,0.0,0.0,0.0,-1.0);
	if (liveObj->objType == OBJECT_BUILDING) {
		fVar10 = LiveObject_GetCollRadius(liveObj);
		if ((ushort)((ushort)(fVar10 < (float10)0.0) << 8 | (ushort)(fVar10 == (float10)0.0) << 0xe) !=
				0) {
			fVar10 = (float10)4.0;
		}
		if ((ushort)((ushort)(fVar10 < (float10)0.0) << 8 | (ushort)(fVar10 == (float10)0.0) << 0xe) ==
				0) {
			res::Container_AddScale
								(liveObj->resData_2e4,D3DRMCOMBINE_BEFORE,(float)(fVar10 * (float10)0.25),1.0,
								 (float)(fVar10 * (float10)0.25));
		}
	}
LAB_0043c4a7:
	LiveObject_SelectedUnits_FUN_00452f10(liveObj);
	LiveObject_FUN_00452770(liveObj);
	return;
}



BOOL __cdecl
lego::game::Object_DoOxygenCheck_FUN_0043c4c0
					(ObjectType objType1,int objIndex1,ObjectType objType2,int objIndex2)
{
	int objIndex;
	float10 fVar1;
	float10 fVar2;
	
	objIndex = objIndex1;
	fVar1 = Object_GetOxygenCoef(objType1,objIndex1);
	if (fVar1 != (float10)0.0) {
		objIndex1 = OBJECT_NONE;
		unk::DoLiveObjCallbacks_True_FUN_00437a70
							(LiveObject_OxygenCallback_FUN_0043c540,(LiveObject *)&objIndex1);
		fVar1 = Object_GetOxygenCoef(objType2,objIndex2);
		fVar2 = Object_GetOxygenCoef(objType1,objIndex);
		fVar1 = fVar2 + (float10)(float)fVar1 + (float10)(float)objIndex1;
		if ((ushort)((ushort)(fVar1 < (float10)0.0) << 8 | (ushort)(fVar1 == (float10)0.0) << 0xe) != 0)
		{
			return 0;
		}
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_OxygenCallback_FUN_0043c540(LiveObject *liveObj,float *param_2)
{
	BOOL BVar1;
	float10 fVar2;
	
	if ((liveObj->objType == OBJECT_BUILDING) &&
		 (BVar1 = LiveObject_CheckCondition_FUN_00438870(liveObj,0), BVar1 == 0)) {
		return 0;
	}
	fVar2 = LiveObject_GetOxygenCoef(liveObj);
	*param_2 = (float)(fVar2 + (float10)*param_2);
	return 0;
}



void __cdecl FUN_0043c570(float param_1,ObjectType param_2)
{
	FLOAT_004dfe0c = param_1 + FLOAT_004dfe0c;
	if ((ushort)((ushort)(FLOAT_004dfe0c < 25.0) << 8 | (ushort)(FLOAT_004dfe0c == 25.0) << 0xe) == 0)
	{
		FLOAT_004dfe0c = 0.0;
	}
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_0043c5b0,(LiveObject *)&param_2);
	return;
}



undefined4 __cdecl FUN_0043c5b0(LiveObject *liveObj,int *param_2)
{
	int iVar1;
	BOOL BVar2;
	SurfaceMap *surfMap;
	LevelStruct_3c *pLVar3;
	float10 fVar4;
	Point2F *pPVar5;
	float fVar6;
	float fVar7;
	int local_10;
	int local_c;
	Point2F local_8;
	
	fVar6 = FLOAT_004dfe0c * 0.04;
	if (((*(byte *)&liveObj->flags5_3f0 & 0x20) != 0) &&
		 (iVar1 = lego::game::LiveObject_GetSurveyRadius(liveObj), iVar1 != 0)) {
		local_10 = iVar1;
		if ((liveObj->objType == OBJECT_BUILDING) &&
			 (BVar2 = lego::game::LiveObject_CheckCondition_FUN_00438870(liveObj,0), BVar2 == 0)) {
			return 0;
		}
		if (FLOAT_004dfe0c == 0.0) {
			lego::game::LiveObject_GetBlockCoordinates(liveObj,&local_10,&local_c);
			FUN_00434f40(&local_10,iVar1);
			return 0;
		}
		if (*param_2 != 0) {
			lego::game::LiveObject_GetPosition(liveObj,(float *)&local_8,&local_8.y);
			fVar7 = 1.0 - fVar6;
			surfMap = lego::game::GetSurfaceMap();
			fVar4 = lego::game::SurfaceMap_GetBlockSize(surfMap);
			pPVar5 = &local_8;
			fVar6 = (float)(fVar4 * (float10)fVar6 * (float10)local_10);
			pLVar3 = (LevelStruct_3c *)FUN_0042b430();
			lego::game::LevelStruct3C_FUN_0045ddc0(pLVar3,pPVar5,fVar6,fVar7);
		}
	}
	return 0;
}



undefined4 __cdecl FUN_0043c6a0(int *param_1)
{
	int *piVar1;
	BOOL BVar2;
	
	if ((((param_1 != (int *)0x0) && (*param_1 == 2)) &&
			(piVar1 = (int *)param_1[0xbc], piVar1 != (int *)0x0)) && (*piVar1 == 0x1a)) {
		BVar2 = lego::game::LiveObject_FUN_00472340((LiveObject *)param_1,(undefined4 *)piVar1[4]);
		if (BVar2 != 0) {
			BVar2 = lego::game::LiveObject_FUN_00471b90
												((LiveObject *)param_1,*(LiveObject **)(param_1[0xbc] + 0x10));
			if (BVar2 == 0) {
				return 1;
			}
		}
	}
	return 0;
}



uint __cdecl lego::game::LiveObject_GetEquippedBeam(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_LASER);
	if (BVar1 != 0) {
		return 1;
	}
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_PUSHERGUN);
	if (BVar1 != 0) {
		return 2;
	}
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_FREEZERGUN);
	return -(uint)(BVar1 != 0) & 3;
}



undefined4 __cdecl FUN_0043c750(undefined4 param_1,int param_2,int param_3)
{
	BOOL BVar1;
	
	BVar1 = lego::game::LiveObject_CheckCondition_FUN_00438870((LiveObject *)param_2,1);
	if ((BVar1 != 0) && (param_3 != 0)) {
		return 1;
	}
	return 0;
}



void __cdecl FUN_0043c780(uint *param_1)
{
	uint uVar1;
	int iVar2;
	
	if (param_1[0xbf] != 0) {
		uVar1 = lego::game::LiveObject_GetEquippedBeam((LiveObject *)param_1);
		iVar2 = FUN_0043c750(param_1,param_1[0xbf],uVar1);
		if (iVar2 != 0) {
			FUN_00442190((LiveObject *)param_1,(int *)param_1[0xbf],uVar1);
		}
	}
	param_1[0xf9] = param_1[0xf9] & 0xfbffffff;
	lego::game::LiveObject_SetAITaskUnk
						((LiveObject *)param_1,AITASK_ATTACKROCKMONSTER,(LiveObject *)0x0,1);
	return;
}



void __cdecl FUN_0043c7f0(uint *param_1)
{
	if ((((param_1 != (uint *)0x0) && (*param_1 == 2)) && ((int *)param_1[0xbc] != (int *)0x0)) &&
		 (*(int *)param_1[0xbc] == 0x1a)) {
		param_1[0xf9] = param_1[0xf9] | 0x4000000;
		FUN_0043c780(param_1);
	}
	return;
}



void __cdecl FUN_0043c830(LiveObject *liveObj)
{
	int iVar1;
	ObjectStatsFlags2 OVar2;
	BOOL BVar3;
	int local_8;
	int local_4;
	
	if ((liveObj->objType == OBJECT_BUILDING) &&
		 ((liveObj->flags3 & LIVEOBJ3_UNK_80000000) == LIVEOBJ3_NONE)) {
		iVar1 = lego::game::LiveObject_GetCrystalDrain(liveObj);
		lego::game::LiveObject_GetBlockCoordinates(liveObj,&local_8,&local_4);
		OVar2 = lego::game::LiveObject_GetStatsFlags2(liveObj);
		if ((OVar2 & STATS2_GENERATEPOWER) == STATS2_NONE) {
			OVar2 = lego::game::LiveObject_GetStatsFlags2(liveObj);
			if ((OVar2 & STATS2_SELFPOWERED) == STATS2_NONE) {
				iVar1 = FUN_00409380(&local_8,iVar1);
				if (iVar1 == 0) {
					liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_20000000;
					FUN_00407340(liveObj);
					return;
				}
			}
		}
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_20000000;
		OVar2 = lego::game::LiveObject_GetStatsFlags2(liveObj);
		if ((OVar2 & STATS2_GENERATEPOWER) != STATS2_NONE) {
			BVar3 = lego::game::LiveObject_CheckCondition_FUN_00438870(liveObj,0);
			if (BVar3 != 0) {
				iVar1 = lego::game::Level_GetCrystalCount(1);
				if (iVar1 != 0) {
					FUN_004092e0(&local_8);
				}
			}
		}
	}
	return;
}



BOOL __cdecl FUN_0043c910(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	int iVar2;
	uint uVar3;
	
	OVar1 = lego::game::LiveObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_CANSTEAL) != STATS1_NONE) {
		iVar2 = lego::game::LiveObject_GetCapacity(liveObj);
		if (((iVar2 != 0) && (liveObj->tableptr_348 != (int *)0x0)) &&
			 (uVar3 = lego::game::LiveObject_GetCapacity(liveObj), uVar3 <= (uint)*liveObj->tableptr_348))
		{
			return 0;
		}
		if ((liveObj->flags3 & LIVEOBJ3_UNK_80000000) == LIVEOBJ3_NONE) {
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_0043c970(LiveObject *liveObj,float elapsed)
{
	float fVar1;
	float fVar2;
	ObjectType OVar3;
	float fVar4;
	float10 fVar5;
	float10 fVar6;
	
	fVar4 = elapsed + liveObj->elapsedTime2;
	fVar1 = liveObj->elapsedTime2;
	fVar2 = liveObj->elapsedTime1;
	liveObj->elapsedTime2 = fVar4;
	OVar3 = liveObj->objType;
	liveObj->elapsedTime1 = elapsed + liveObj->elapsedTime1;
	liveObj->activityElapsedTime = elapsed + liveObj->activityElapsedTime;
	if (OVar3 == OBJECT_MINIFIGURE) {
		fVar5 = Level_GetObjectUpgradeTime(OBJECT_MINIFIGURE);
		if (fVar5 != (float10)0.0) {
			fVar5 = Level_GetObjectUpgradeTime(liveObj->objType);
			if ((ushort)((ushort)(fVar5 < (float10)liveObj->elapsedTime2) << 8 |
									(ushort)(fVar5 == (float10)liveObj->elapsedTime2) << 0xe) != 0) {
				fVar6 = Level_GetObjectUpgradeTime(liveObj->objType);
				fVar5 = (float10)fVar1;
				if ((ushort)((ushort)(fVar6 < fVar5) << 8 | (ushort)(fVar6 == fVar5) << 0xe) == 0) {
					front::Info_FUN_00419ab0(INFO_CANUPGRADEMINIFIGURE,(char *)0x0,liveObj,(Point2I *)0x0);
				}
			}
		}
		fVar5 = Level_GetTrainTime();
		if (fVar5 != (float10)0.0) {
			fVar5 = Level_GetTrainTime();
			if ((ushort)((ushort)(fVar5 < (float10)liveObj->elapsedTime1) << 8 |
									(ushort)(fVar5 == (float10)liveObj->elapsedTime1) << 0xe) != 0) {
				fVar5 = Level_GetTrainTime();
				if ((ushort)((ushort)(fVar5 < (float10)fVar2) << 8 |
										(ushort)(fVar5 == (float10)fVar2) << 0xe) == 0) {
					front::Info_FUN_00419ab0(INFO_CANTRAINMINIFIGURE,(char *)0x0,liveObj,(Point2I *)0x0);
					return;
				}
			}
		}
	}
	else {
		if (((((OVar3 == OBJECT_POWERCRYSTAL) || (OVar3 == OBJECT_ORE)) || (OVar3 == OBJECT_BARRIER)) ||
				((OVar3 == OBJECT_ELECTRICFENCE &&
				 ((liveObj->flags2 & LIVEOBJ2_UNK_2000000) == LIVEOBJ2_NONE)))) &&
			 ((750.0 <= fVar4 && (fVar1 < 750.0)))) {
			liveObj->elapsedTime2 = 0.0;
			LiveObject_FUN_004025f0(liveObj);
		}
	}
	return;
}


/*
Unable to decompile 'Game_LiveObjectLargeCallback'
Cause: Exception while decompiling 0043cad0: process: timeout

*/


BOOL __cdecl lego::game::Game_LiveObjectLargeCallback(LiveObject *in_liveObj,float *lpElapsed)
{
	LiveFlags3 *pLVar1;
	LiveFlags4 *pLVar2;
	float elapsed;
	void *pvVar3;
	LiveFlags2 LVar4;
	ObjectType OVar5;
	ushort uVar6;
	ushort uVar7;
	bool bVar8;
	LiveObject *liveObj;
	short sVar9;
	Container *pCVar10;
	SFXType SVar11;
	BOOL BVar12;
	LiveFlags4 LVar13;
	LevelData *pLVar14;
	ObjectStatsFlags1 OVar15;
	LiveFlags3 LVar16;
	Container *pCVar17;
	SurfaceType SVar18;
	int iVar19;
	SurfaceMap *pSVar20;
	ObjectStatsFlags2 OVar21;
	uint uVar22;
	LiveFlags1 LVar23;
	uint uVar24;
	float10 fVar25;
	longlong lVar26;
	float fVar27;
	float fVar28;
	LiveObject *pLVar29;
	BOOL BVar30;
	float fVar31;
	ActivityType AVar32;
	Vector3F *pVVar33;
	undefined4 uVar34;
	float fVar35;
	float upz;
	float *out_y;
	float local_34;
	Vector3F local_30;
	float local_24;
	Vector3F local_20;
	int local_14;
	float local_10;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	elapsed = *lpElapsed;
	bVar8 = true;
	DAT_00557090 = in_liveObj;
	LiveObject_FUN_0043c970(in_liveObj,elapsed);
	if ((liveObj->flags4 & LIVEOBJ4_UNK_200000) != LIVEOBJ4_NONE) {
		liveObj->aitaskName1 = NULL;
		Game_UpdateSomeAITasks(liveObj);
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_200000;
	}
	if ((liveObj->flags2 & LIVEOBJ2_UNK_8000000) != LIVEOBJ2_NONE) {
		if ((ushort)((ushort)(liveObj->float_368 < 0.0) << 8 |
								(ushort)(liveObj->float_368 == 0.0) << 0xe) != 0) {
			LiveObject_FUN_0044c3d0(liveObj);
		}
		liveObj->float_368 = liveObj->float_368 - elapsed;
		return 0;
	}
	if ((liveObj->flags4 & LIVEOBJ4_UNK_40000) != LIVEOBJ4_NONE) {
		pCVar10 = LiveObject_GetResource(liveObj);
		if ((pCVar10 != NULL) && (SVar11 = LiveObject_GetEngineSound(liveObj), SVar11 != SFX_NULL)) {
			res::Res_PlayResourceSound(pCVar10,SVar11,1,1,NULL);
			liveObj->field_354 = SVar11;
			liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_80000;
		}
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_40000;
	}
	if ((((byte)globals::g_Game.flags2 & GAME2_CALLTOARMS) == 0) ||
		 (BVar12 = LiveObject_MiniFigureHasBeamEquipped(liveObj), BVar12 == 0)) {
		LiveObject_MiniFigure_FUN_00407440(liveObj,0);
		LVar13 = liveObj->flags4 & ~LIVEOBJ4_CALLTOARMS_20;
	}
	else {
										/* Update MiniFigure with Call-to-arms behavior? */
		LiveObject_MiniFIgure_FUN_004073e0(liveObj);
		LVar13 = liveObj->flags4 | LIVEOBJ4_CALLTOARMS_20;
	}
	liveObj->flags4 = LVar13;
	if ((((liveObj->objType == OBJECT_VEHICLE) &&
			 ((liveObj->flags4 & LIVEOBJ4_UNK_40) != LIVEOBJ4_NONE)) && (liveObj->object_2fc == NULL)) &&
		 (liveObj->drivenObject == NULL)) {
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_40;
		LiveObject_Vehicle_FUN_0043ac20(liveObj);
	}
	if ((liveObj->objType == OBJECT_MINIFIGURE) || (liveObj->objType == OBJECT_VEHICLE)) {
		pLVar14 = GetLevel();
		LiveObject_GetBlockCoordinates(liveObj,(int *)&local_20,(int *)&local_20.y);
		if ((*(byte *)&pLVar14->blocks[(pLVar14->dimensions).width * (int)local_20.y + (int)local_20.x].
									 flags2 & BLOCK2_EMERGE_TRIGGER) != 0) {
			Level_UnkEmerge_FUN_0042c260(pLVar14,(Point2I *)&local_20,NULL);
		}
	}
	LiveObject_FUN_0043bde0(liveObj);
	if (((liveObj->objType == OBJECT_MINIFIGURE) &&
			((*(byte *)&liveObj->flags2 & LIVEOBJ2_DRIVING) != 0)) &&
		 ((pLVar29 = liveObj->drivenObject, pLVar29 != NULL && (pLVar29->objType == OBJECT_VEHICLE)))) {
		fVar25 = res::Vehicle_GetAnimFloat10(pLVar29->vehicle);
		res::Creature_DoCallbacks(liveObj->miniFigure,(float)fVar25);
	}
	else {
		fVar25 = LiveObject_FUN_00447df0(liveObj,elapsed);
		local_10 = (float)fVar25;
	}
	OVar15 = LiveObject_GetStatsFlags1(liveObj);
	if ((OVar15 & (STATS1_SMALLTELEPORTER|STATS1_BIGTELEPORTER|STATS1_WATERTELEPORTER|
								STATS1_MANTELEPORTER)) != STATS1_NONE) {
		LiveObject_FUN_0043f450(liveObj);
	}
	if ((liveObj->objType != OBJECT_BUILDING) ||
		 (BVar12 = LiveObject_CheckCondition_FUN_00438870(liveObj,0), BVar12 != 0)) {
		LiveObject_ConsumeOxygen(liveObj,elapsed);
	}
	if (((byte)pool::globals::ReservedPool<LiveObject>__g_INITFLAGS & 4) == 0) {
		liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_40000000;
	}
	else {
		FUN_0043c830(liveObj);
	}
	LVar23 = liveObj->flags1;
	if ((LVar23 & LIVEOBJ1_UNK_400000) != LIVEOBJ1_NONE) {
		if (liveObj->resData_2e4 == NULL) {
			liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
			return 0;
		}
		pCVar10 = LiveObject_GetResource(liveObj);
		res::Container_AddTranslation(pCVar10,D3DRMCOMBINE_AFTER,0.0,0.0,-elapsed);
		fVar25 = res::Container_MoveAnimation(liveObj->resData_2e4,elapsed);
		if ((ushort)((ushort)(fVar25 < (float10)0.0) << 8 | (ushort)(fVar25 == (float10)0.0) << 0xe) !=
				0) {
			return 0;
		}
		liveObj->health = -1.0;
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_400000;
		res::Container_Remove(liveObj->resData_2e4);
		return 0;
	}
	if ((LVar23 & LIVEOBJ1_UNK_8) == LIVEOBJ1_NONE) goto LAB_0043d12f;
	if ((LVar23 & LIVEOBJ1_UNK_10) != LIVEOBJ1_NONE) {
		pCVar10 = LiveObject_GetResource(liveObj);
		pVVar33 = NULL;
		BVar30 = 1;
		BVar12 = 1;
		SVar11 = LiveObject_GetDrillSoundType(liveObj,0);
		res::Res_PlayResourceSound(pCVar10,SVar11,BVar12,BVar30,pVVar33);
		liveObj->field_350 = SVar11;
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_100000;
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_10;
	}
	pvVar3 = liveObj->routeptr_24;
	if (pvVar3 == NULL) {
LAB_0043d0aa:
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_8;
		liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_2000000;
		pCVar10 = LiveObject_GetResource(liveObj);
		SVar11 = liveObj->field_350;
LAB_0043d0dd:
		snd::Sample_StopSoundBufferInstance(SVar11);
		pVVar33 = NULL;
		BVar30 = 1;
		BVar12 = 0;
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_100000;
		SVar11 = LiveObject_GetDrillSoundType(liveObj,1);
		res::Res_PlayResourceSound(pCVar10,SVar11,BVar12,BVar30,pVVar33);
		util::logf_removed(NULL,0,0);
		LVar16 = liveObj->flags3 & ~LIVEOBJ3_UNK_4000;
LAB_0043d129:
		liveObj->flags3 = LVar16;
	}
	else {
		fVar35 = *(float *)((int)pvVar3 + liveObj->routingBlocksCurrent * 0x14);
		fVar27 = *(float *)((int)pvVar3 + liveObj->routingBlocksCurrent * 0x14 + 4);
		BVar12 = 1;
		LVar16 = liveObj->flags3 & LIVEOBJ3_UNK_2000000;
		lVar26 = __ftol((float10)(liveObj->point_2f4).y);
		uVar22 = (uint)lVar26;
		lVar26 = __ftol((float10)(liveObj->point_2f4).x);
		BVar12 = LiveObject_FUN_004326a0(liveObj,(uint)lVar26,uVar22,LVar16,BVar12);
		if (BVar12 == 0) goto LAB_0043d0aa;
		BVar12 = LiveObject_GetDrillNullPosition(liveObj,(float *)&local_30,&local_34);
		if (BVar12 == 0) goto LAB_0043d12f;
		if (liveObj->objType == OBJECT_MINIFIGURE) {
			uVar34 = 0;
			pCVar10 = Game_GetCamera24_IfBool308_ElseCamera2C();
			pCVar17 = res::Creature_GetDrillNull(liveObj->miniFigure);
			util::logf_removed((char *)pCVar17,pCVar10,uVar34);
		}
		lVar26 = __ftol((float10)(liveObj->point_2f4).y);
		iVar19 = (int)lVar26;
		lVar26 = __ftol((float10)(liveObj->point_2f4).x);
		SVar18 = Level_GetBlockTerrain((int)lVar26,iVar19);
		fVar25 = LiveObject_GetDrillTimeType(liveObj,SVar18);
		in_liveObj = (LiveObject *)(float)fVar25;
		OVar15 = LiveObject_GetStatsFlags1(liveObj);
		if (((OVar15 & STATS1_SINGLEWIDTHDIG) != STATS1_NONE) &&
			 ((liveObj->flags3 & LIVEOBJ3_UNK_2000000) != LIVEOBJ3_NONE)) {
			in_liveObj = (LiveObject *)((float)in_liveObj * 0.5);
		}
		pLVar29 = in_liveObj;
		fVar28 = elapsed;
		lVar26 = __ftol((float10)(liveObj->point_2f4).y);
		iVar19 = (int)lVar26;
		lVar26 = __ftol((float10)(liveObj->point_2f4).x);
		BVar12 = Level_GetBlockUnkField14Test((int)lVar26,iVar19,(float)pLVar29,fVar28);
		if (BVar12 == 0) {
			BVar12 = Level_ToBlockCoordinatesNoZ(local_30.x,local_34,(int *)&local_24,(int *)&local_20);
			if (((BVar12 == 0) || (local_24 != fVar35)) || (local_20.x != fVar27)) goto LAB_0043d12f;
			LVar16 = liveObj->flags3 | LIVEOBJ3_UNK_4000;
			goto LAB_0043d129;
		}
		BVar12 = 1;
		LVar16 = liveObj->flags3 & LIVEOBJ3_UNK_2000000;
		lVar26 = __ftol((float10)(liveObj->point_2f4).y);
		uVar22 = (uint)lVar26;
		lVar26 = __ftol((float10)(liveObj->point_2f4).x);
		BVar12 = LiveObject_FUN_004326a0(liveObj,(uint)lVar26,uVar22,LVar16,BVar12);
		if (BVar12 != 0) {
			lVar26 = __ftol((float10)(liveObj->point_2f4).x);
			fVar28 = (float)lVar26;
			local_c.x = fVar28;
			lVar26 = __ftol((float10)(liveObj->point_2f4).y);
			fVar31 = (float)lVar26;
			local_c.y = fVar31;
			if ((liveObj->flags3 & LIVEOBJ3_UNK_2000000) == LIVEOBJ3_NONE) {
				BVar12 = 0;
				pLVar14 = GetLevel();
				iVar19 = Level_DestroyWall(pLVar14,(int)fVar35,(int)fVar27,BVar12);
			}
			else {
				pLVar14 = GetLevel();
				iVar19 = Level_DestroyWallConnection(pLVar14,(uint)fVar28,(uint)fVar31);
			}
			if (iVar19 == 0) goto LAB_0043d12f;
			LiveObject_SetAITaskUnk(liveObj,AITASK_DIG,NULL,1);
			liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_8;
			Level_SetBlockFlags1_8000000((Point2I *)&local_c,0);
			if (*(char *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) == '\x01')
			{
				*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 0;
			}
			pCVar10 = LiveObject_GetResource(liveObj);
			SVar11 = liveObj->field_350;
			goto LAB_0043d0dd;
		}
	}
LAB_0043d12f:
	if ((liveObj->flags2 & LIVEOBJ2_UNK_4000) != LIVEOBJ2_NONE) {
		LiveObject_FUN_0044c470(liveObj,elapsed);
	}
	if ((((liveObj->flags2 & LIVEOBJ2_UNK_40000000) != LIVEOBJ2_NONE) &&
			((ushort)((ushort)(elapsed < 0.0) << 8 | (ushort)(elapsed == 0.0) << 0xe) == 0)) &&
		 (pCVar10 = LiveObject_GetResource(liveObj), pCVar10 != NULL)) {
		res::Container_GetOrientation(pCVar10,NULL,&local_20,&local_c);
		local_c.x = local_c.x * 10.0;
		local_c.y = local_c.y * 10.0;
		local_c.z = local_c.z * 10.0;
		math::Maths_Vector3DRandom(&local_30);
		local_c.y = FLOAT_004a58b0 * 0.1 * (local_30.y + local_c.y);
		local_c.x = FLOAT_004a58b0 * 0.1 * (local_30.x + local_c.x);
		local_c.z = -1.0;
		res::Container_SetOrientation
							(pCVar10,NULL,local_20.x,local_20.y,local_20.z,local_c.x,local_c.y,-1.0);
		FLOAT_004a58b0 = FLOAT_004a58b0 - elapsed * 0.16;
		if (FLOAT_004a58b0 < 0.0) {
			FLOAT_004a58b0 = 1.0;
			liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_40000000;
		}
	}
	LVar23 = liveObj->flags1;
	if ((LVar23 & LIVEOBJ1_UNK_100000) != LIVEOBJ1_NONE) {
		LiveObject_DestroyRockMonster_FUN_0044c290(liveObj);
		goto LAB_0043f040;
	}
	if ((LVar23 & LIVEOBJ1_UNK_4000000) != LIVEOBJ1_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags1 = LVar23 & ~LIVEOBJ1_UNK_4000000;
		}
		goto LAB_0043f040;
	}
	LVar13 = liveObj->flags4;
	if ((LVar13 & LIVEOBJ4_UNK_1000) != LIVEOBJ4_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags4 = LVar13 & ~LIVEOBJ4_UNK_1000 | LIVEOBJ4_UNK_2000;
		}
		goto LAB_0043f040;
	}
	if ((LVar13 & LIVEOBJ4_UNK_4000) != LIVEOBJ4_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags4 = LVar13 & ~LIVEOBJ4_UNK_4000;
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		}
		goto LAB_0043f040;
	}
	if ((LVar13 & LIVEOBJ4_UNK_2000) != LIVEOBJ4_NONE) {
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_OPEN,0);
		goto LAB_0043f040;
	}
	LVar4 = liveObj->flags2;
	if ((LVar4 & LIVEOBJ2_UNK_4000) != LIVEOBJ2_NONE) goto LAB_0043f040;
	if ((LVar23 & LIVEOBJ1_TURNING) != LIVEOBJ1_NONE) {
		uVar6 = (ushort)(liveObj->float_2d4 < 0.0) << 8;
		uVar7 = (ushort)(liveObj->float_2d4 == 0.0) << 0xe;
		if ((LVar23 & LIVEOBJ1_TURNRIGHT) != LIVEOBJ1_NONE) {
			if ((uVar6 | uVar7) == 0) {
				pCVar10 = LiveObject_GetResource(liveObj);
				res::Container_AddRotation(pCVar10,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,1.570796);
				res::Container_SetAnimationTime(pCVar10,0.0);
				liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_TURNRIGHT;
			}
			goto LAB_0043f040;
		}
		if ((uVar6 | uVar7) != 0) goto LAB_0043f040;
		pCVar10 = LiveObject_GetResource(liveObj);
		if ((globals::g_Activities_TABLE[9] == liveObj->aitaskName1) ||
			 (globals::g_Activities_TABLE[20] == liveObj->aitaskName1)) {
			fVar35 = -1.570796;
		}
		else {
			fVar35 = 1.570796;
		}
		res::Container_AddRotation(pCVar10,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,fVar35);
		LVar23 = liveObj->flags1;
		liveObj->flags1 = LVar23 & ~LIVEOBJ1_TURNING | LIVEOBJ1_MOVING;
		if (liveObj->routingBlocksTotal != 0) {
			if (((LVar23 & LIVEOBJ1_UNK_800000) != LIVEOBJ1_NONE) &&
				 (liveObj->objType == OBJECT_MINIFIGURE)) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_RUNPANIC,0);
				goto LAB_0043f040;
			}
LAB_0043e732:
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_ROUTE,0);
			goto LAB_0043f040;
		}
LAB_0043ecae:
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_20) != LIVEOBJ2_NONE) {
		LiveObject_FUN_004499c0(liveObj);
		goto LAB_0043f040;
	}
	if ((LVar23 & LIVEOBJ1_UNK_80000000) != LIVEOBJ1_NONE) {
LAB_0043eb11:
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags1 = LVar23 & ~LIVEOBJ1_UNK_80000000;
		}
		goto LAB_0043f040;
	}
	if ((LVar23 & LIVEOBJ1_UNK_10000000) != LIVEOBJ1_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			pCVar10 = LiveObject_GetResource(liveObj);
			liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_10000000;
			res::Container_SetOrientation
								(pCVar10,NULL,(float)liveObj->field_2c8,(float)liveObj->field_2cc,0.0,0.0,0.0,-1.0);
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_400000) != LIVEOBJ2_NONE) {
		if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
			Game_GetWeaponUnk(liveObj,1);
		}
		if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
			 (LVar4 = liveObj->flags2, liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_400000,
			 (LVar4 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE)) {
			Game_GetWeaponUnk(liveObj,1);
		}
		goto LAB_0043f040;
	}
	if ((LVar13 & LIVEOBJ4_UNK_8000) != LIVEOBJ4_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) != 0) goto LAB_0043f040;
		liveObj->flags4 = LVar13 & ~LIVEOBJ4_UNK_8000;
		if (liveObj->object_2fc != NULL) {
			pCVar10 = LiveObject_GetDepositNull(liveObj->object_2fc);
			if (pCVar10 != NULL) {
				res::Container_GetPosition(pCVar10,NULL,&local_c);
				res::Container_GetOrientation(pCVar10,NULL,&local_20,NULL);
				fVar35 = local_c.x;
				fVar27 = local_c.y;
				pSVar20 = GetSurfaceMap();
				fVar25 = SurfaceMap_GetSurfaceZ(pSVar20,fVar35,fVar27);
				fVar35 = (float)fVar25;
				pCVar17 = NULL;
				fVar27 = local_c.x;
				fVar28 = local_c.y;
				pCVar10 = LiveObject_GetResource(liveObj);
				res::Container_SetPosition(pCVar10,pCVar17,fVar27,fVar28,fVar35);
				upz = -1.0;
				fVar31 = 0.0;
				fVar28 = 0.0;
				pCVar17 = NULL;
				fVar35 = local_20.x;
				fVar27 = local_20.y;
				pCVar10 = LiveObject_GetResource(liveObj);
				res::Container_SetOrientation(pCVar10,pCVar17,fVar35,fVar27,local_20.z,fVar28,fVar31,upz);
			}
			LiveObject_FUN_00437690(liveObj->object_2fc,0);
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
			goto LAB_0043f040;
		}
		goto LAB_0043ecae;
	}
	if ((LVar4 & LIVEOBJ2_UNK_80000000) != LIVEOBJ2_NONE) {
		if (liveObj->object_2fc == NULL) {
			liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_80000000;
		}
		else {
			pCVar10 = LiveObject_GetResource(liveObj);
			pCVar17 = LiveObject_GetResource(liveObj->object_2fc);
			pLVar29 = liveObj->object_2fc;
			res::Container_GetPosition(pCVar17,NULL,&local_c);
			res::Container_GetOrientation(pCVar17,NULL,&local_30,&local_20);
			res::Container_SetPosition(pCVar10,NULL,local_c.x,local_c.y,local_c.z);
			res::Container_SetOrientation
								(pCVar10,NULL,local_30.x,local_30.y,local_30.z,local_20.x,local_20.y,local_20.z);
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				pLVar29->carriedObjects[pLVar29->numCarriedObjects] = liveObj;
				pLVar29->carriedObjects[pLVar29->numCarriedObjects]->carryingThisObject = pLVar29;
				pLVar29->carriedObjects[(int)(LiveObject *)pLVar29->numCarriedObjects]->carriedObjects[6] =
						 (LiveObject *)pLVar29->numCarriedObjects;
				pLVar29->flags1 = pLVar29->flags1 | LIVEOBJ1_CARRYING;
				LiveObject_FUN_00437690(pLVar29,0);
				pLVar29->numCarriedObjects = pLVar29->numCarriedObjects + 1;
				liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_80000000;
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
				LiveObject_SetAITaskUnk(liveObj,AITASK_FINDLOAD,NULL,1);
				pLVar29->flags4 = pLVar29->flags4 & ~LIVEOBJ4_UNK_10000;
			}
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_10000000) != LIVEOBJ2_NONE) {
		if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
			 (liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_10000000,
			 (LVar23 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) {
			pVVar33 = &local_c;
			pCVar17 = NULL;
			liveObj->carriedObjects[0]->flags3 =
					 liveObj->carriedObjects[0]->flags3 & ~LIVEOBJ3_UNK_80000000;
			pCVar10 = LiveObject_GetResource(liveObj->carriedObjects[0]);
			res::Container_GetPosition(pCVar10,pCVar17,pVVar33);
			res::Res_PlayResourceSound(NULL,SFX_CRYSTALRECHARGE,0,0,&local_c);
			LiveObject_SetCrystalPoweredColor(liveObj->carriedObjects[0],1);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_800000) != LIVEOBJ2_NONE) {
		if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
			Game_GetWeaponUnk(liveObj,2);
		}
		if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
			 (LVar4 = liveObj->flags2, liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_800000,
			 (LVar4 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE)) {
			Game_GetWeaponUnk(liveObj,2);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_1000000) != LIVEOBJ2_NONE) {
		if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
			Game_GetWeaponUnk(liveObj,3);
		}
		if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
			 (LVar4 = liveObj->flags2, liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_1000000,
			 (LVar4 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE)) {
			Game_GetWeaponUnk(liveObj,3);
		}
		goto LAB_0043f040;
	}
	if ((LVar23 & LIVEOBJ1_UNK_800) != LIVEOBJ1_NONE) {
		if ((liveObj->objType == OBJECT_ROCKMONSTER) &&
			 (BVar12 = FUN_00406f70(liveObj->rockMonster), BVar12 != 0)) {
			FUN_00447a40(liveObj);
		}
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_800;
		}
		goto LAB_0043f040;
	}
	if ((LVar23 & LIVEOBJ1_UNK_4000) != LIVEOBJ1_NONE) {
		pLVar29 = liveObj->object_2fc;
		if ((((pLVar29 != NULL) && ((pLVar29->flags1 & LIVEOBJ1_UNK_2000) == LIVEOBJ1_NONE)) &&
				((pLVar29->flags3 & LIVEOBJ3_UNK_1000000) == LIVEOBJ3_NONE)) &&
			 (pLVar29->numCarriedObjects != pLVar29->field_328)) {
			liveObj->flags1 = LVar23 & ~LIVEOBJ1_UNK_4000 | LIVEOBJ1_UNK_2000;
		}
		goto LAB_0043f040;
	}
	if ((LVar23 & LIVEOBJ1_UNK_2000) != LIVEOBJ1_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags1 = LVar23 & ~LIVEOBJ1_UNK_2000;
			LiveObject_SetAITaskUnk(liveObj,AITASK_DEPOSITE,liveObj,1);
			FUN_0043f160(liveObj);
		}
		else {
			if (liveObj->object_2fc != NULL) {
				pLVar1 = &liveObj->object_2fc->flags3;
				*pLVar1 = *pLVar1 | LIVEOBJ3_UNK_1000000;
			}
		}
		goto LAB_0043f040;
	}
	if ((LVar23 & LIVEOBJ1_REST) != LIVEOBJ1_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags1 = LVar23 & ~LIVEOBJ1_REST;
			liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_4000;
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_200000) != LIVEOBJ2_NONE) {
		if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
			FUN_0043aeb0(liveObj);
		}
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_200000;
			LiveObject_SetAITaskUnk(liveObj,AITASK_ATTACKPATH,NULL,1);
			if ((liveObj->flags2 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE) {
				FUN_0043aeb0(liveObj);
			}
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_40000) != LIVEOBJ2_NONE) {
		if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
			LiveObject_FUN_004477b0(liveObj);
		}
		if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
			 (LVar4 = liveObj->flags2, liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_40000,
			 (LVar4 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE)) {
			LiveObject_FUN_004477b0(liveObj);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_20000000) != LIVEOBJ2_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_20000000;
			liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_80000000;
		}
		goto LAB_0043f040;
	}
	if ((LVar23 & LIVEOBJ1_UNK_1000000) != LIVEOBJ1_NONE) {
		OVar21 = LiveObject_GetStatsFlags2(liveObj);
		if ((((OVar21 & STATS2_DRAINPOWER) != STATS2_NONE) &&
				(pLVar29 = liveObj->object_2fc, pLVar29 != NULL)) &&
			 ((*(byte *)&pLVar29->flags4 & LIVEOBJ4_UNK_10) == 0)) {
			BVar12 = LiveObject_CheckCondition_FUN_00438870(pLVar29,0);
			if (BVar12 != 0) {
				front::Info_FUN_00419ab0(INFO_POWERDRAIN,NULL,liveObj->object_2fc,NULL);
				Game_SetCallToArmsOn(1);
			}
			pLVar2 = &liveObj->object_2fc->flags4;
			*pLVar2 = *pLVar2 | LIVEOBJ4_UNK_10;
			Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
		}
		if (((liveObj->flags2 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) &&
			 (iVar19 = LiveObject_FUN_00447880(liveObj), iVar19 != 0)) {
			liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_80000;
		}
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			if (((liveObj->flags2 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE) &&
				 (iVar19 = LiveObject_FUN_00447880(liveObj), iVar19 != 0)) {
				liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_80000;
				LiveObject_SetAITaskUnk(liveObj,AITASK_REPAIR,NULL,1);
			}
			if ((liveObj->flags2 & LIVEOBJ2_UNK_80000) == LIVEOBJ2_NONE) {
				liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_1000000;
				if (liveObj->object_2fc != NULL) {
					pLVar2 = &liveObj->object_2fc->flags4;
					*pLVar2 = *pLVar2 & ~LIVEOBJ4_UNK_10;
					Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
					liveObj->object_2fc = NULL;
				}
				LiveObject_SetAITaskUnk(liveObj,AITASK_REPAIR,NULL,1);
			}
			else {
				pCVar10 = LiveObject_GetResource(liveObj);
				res::Container_SetAnimationTime(pCVar10,liveObj->float_2d4);
			}
		}
		goto LAB_0043f040;
	}
	if ((LVar23 & LIVEOBJ1_EATING) != LIVEOBJ1_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			iVar19 = FUN_004479f0((int)liveObj);
			if (iVar19 == 0) {
				pCVar10 = LiveObject_GetResource(liveObj);
				res::Container_SetAnimationTime(pCVar10,liveObj->float_2d4);
			}
			else {
				liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_EATING;
				LiveObject_SetAITaskUnk(liveObj,AITASK_EAT,NULL,1);
				LiveObject_SetAITaskUnk(liveObj,AITASK_GOTOEAT,NULL,1);
			}
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_40) != LIVEOBJ2_NONE) {
		liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_40;
		if (liveObj->aitask_2f0 != NULL) {
			MiniFigure_EquipTool(liveObj,liveObj->aitask_2f0->toolType);
			LiveObject_SetAITaskUnk(liveObj,AITASK_GETTOOL,NULL,1);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_TRAINING) != LIVEOBJ2_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags2 = LVar4 & ~LIVEOBJ2_TRAINING;
			LiveObject_SetAITaskUnk(liveObj,AITASK_TRAIN,NULL,1);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UPGRADING) == LIVEOBJ2_NONE) {
		if ((LVar23 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
			pCVar10 = LiveObject_GetResource(liveObj);
			res::Container_ForceAnimationUpdate(pCVar10);
			if ((((liveObj->flags2 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) &&
					((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
				 (liveObj->carriedObjects[0] != NULL)) {
				pVVar33 = &local_c;
				pCVar17 = NULL;
				pCVar10 = LiveObject_GetResource(liveObj->carriedObjects[0]);
				res::Container_GetPosition(pCVar10,pCVar17,pVVar33);
				OVar5 = liveObj->carriedObjects[0]->objType;
				if (OVar5 == OBJECT_ORE) {
					SVar11 = SFX_PLACEORE;
				}
				else {
					if (OVar5 == OBJECT_POWERCRYSTAL) {
						SVar11 = SFX_PLACECRYSTAL;
					}
					else {
						SVar11 = SFX_PLACE;
					}
				}
				res::Res_PlayResourceSound(NULL,SVar11,0,0,&local_c);
			}
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_PLACING;
				LiveObject_FUN_0043a130(liveObj,1);
			}
			goto LAB_0043f040;
		}
		if ((LVar23 & LIVEOBJ1_UNK_1000) != LIVEOBJ1_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = LVar23 & ~LIVEOBJ1_UNK_1000;
			}
			goto LAB_0043f040;
		}
		if (liveObj->carryingThisObject != NULL) goto LAB_0043f040;
		if (((LVar23 & LIVEOBJ1_MOVING) != LIVEOBJ1_NONE) &&
			 (iVar19 = FUN_0043c6a0((int *)liveObj), iVar19 != 0)) {
			LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
			FUN_0043c7f0((uint *)liveObj);
			goto LAB_0043f040;
		}
		LVar23 = liveObj->flags1;
		if ((LVar23 & LIVEOBJ1_MOVING) != LIVEOBJ1_NONE) {
			FUN_00443b70(liveObj,elapsed);
			FUN_004443b0(liveObj,elapsed);
			FUN_0043ad70((uint *)liveObj);
			LVar4 = liveObj->flags2;
			if ((LVar4 & LIVEOBJ2_UNK_4000000) != LIVEOBJ2_NONE) {
				BVar12 = LiveObject_FUN_00472340(liveObj,(undefined4 *)liveObj->aitask_2f0->object_10);
				if ((BVar12 == 0) ||
					 (BVar12 = LiveObject_FUN_00471b90(liveObj,liveObj->aitask_2f0->object_10), BVar12 != 0))
				{
					liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_4000000;
				}
				else {
					FUN_0043c780((uint *)liveObj);
				}
				goto LAB_0043f040;
			}
			LVar23 = liveObj->flags1;
			if ((LVar23 & LIVEOBJ1_UNK_8) != LIVEOBJ1_NONE) {
				lVar26 = __ftol((float10)(liveObj->point_2f4).x);
				local_c.x = (float)lVar26;
				lVar26 = __ftol((float10)(liveObj->point_2f4).y);
				local_c.y = (float)lVar26;
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_DRILL,0);
				Level_SetBlockFlags1_8000000((Point2I *)&local_c,1);
				goto LAB_0043f040;
			}
			if ((LVar23 & LIVEOBJ1_LIFTING) != LIVEOBJ1_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_REVERSE,0);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_TRAINING) != LIVEOBJ2_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_TRAIN,0);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_UNK_10000000) != LIVEOBJ2_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_RECHARGE,0);
				goto LAB_0043f040;
			}
			if ((LVar23 & LIVEOBJ1_CLEARING) != LIVEOBJ1_NONE) {
				LiveObject_SetActivityUnk
									(liveObj,ACTIVITY_CLEAR,(liveObj->objType != OBJECT_MINIFIGURE) - 1 & 2);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_UNK_80000000) != LIVEOBJ2_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_FLOATON,0);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_UNK_4) != LIVEOBJ2_NONE) {
				if (liveObj->object_2fc != NULL) {
					FUN_0043f3c0(liveObj,(int)liveObj->object_2fc);
				}
				goto LAB_0043f040;
			}
			if ((LVar23 & LIVEOBJ1_REINFORCING) != LIVEOBJ1_NONE) {
				lVar26 = __ftol((float10)(liveObj->point_2f4).x);
				local_c.x = (float)lVar26;
				lVar26 = __ftol((float10)(liveObj->point_2f4).y);
				local_c.y = (float)lVar26;
				Level_SetBlockFlags1_8000000((Point2I *)&local_c,1);
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_REINFORCE,globals::g_Game.ReinforceHits);
				goto LAB_0043f040;
			}
			if ((LVar23 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_PLACE,0);
				goto LAB_0043f040;
			}
			if ((LVar23 & LIVEOBJ1_UNK_20000) != LIVEOBJ1_NONE) {
				lVar26 = __ftol((float10)(liveObj->point_2f4).x);
				local_20.x = (float)lVar26;
				lVar26 = __ftol((float10)(liveObj->point_2f4).y);
				local_20.y = (float)lVar26;
				OVar21 = LiveObject_GetStatsFlags2(liveObj);
				if (((OVar21 & STATS2_USEHOLES) == STATS2_NONE) &&
					 (BVar12 = Level_GetBlockFlags1_10Not8((uint)local_20.x,(uint)local_20.y), BVar12 == 0)) {
					liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_20000;
					liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_20;
				}
				else {
					BVar12 = Level_GetBlockFlags1_20((uint)local_20.x,(uint)local_20.y);
					if (BVar12 == 0) {
						LiveObject_SetActivityUnk(liveObj,ACTIVITY_ENTER,0);
					}
					else {
						LiveObject_SetActivityUnk(liveObj,ACTIVITY_ENTERREIN,0);
						BVar12 = Game_UpdateSomeAITasks(liveObj);
						if (BVar12 == 0) {
							LiveObject_SetActivityUnk(liveObj,ACTIVITY_ENTER,0);
							Game_UpdateSomeAITasks(liveObj);
						}
						OVar21 = LiveObject_GetStatsFlags2(liveObj);
						if ((OVar21 & STATS2_REMOVEREINFORCEMENT) != STATS2_NONE) {
							Block_RemoveReinforcement((Point2I *)&local_20);
						}
					}
				}
				goto LAB_0043f040;
			}
			if ((LVar23 & LIVEOBJ1_UNK_1000000) != LIVEOBJ1_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_REPAIR,0);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_UNK_200000) != LIVEOBJ2_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAMP,0);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_UPGRADING) != LIVEOBJ2_NONE) {
				if (liveObj->objType == OBJECT_MINIFIGURE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_TRAIN,100);
				}
				else {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_UPGRADE,0);
					LiveObject_SetActivityUnk(liveObj->object_2fc,ACTIVITY_UPGRADE,0);
					Game_UpdateSomeAITasks(liveObj->object_2fc);
					liveObj->object_2fc->flags2 = liveObj->object_2fc->flags2 | LIVEOBJ2_UPGRADING;
				}
				goto LAB_0043f040;
			}
			if ((LVar23 & LIVEOBJ1_EATING) != LIVEOBJ1_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_EAT,0);
				goto LAB_0043f040;
			}
			if ((LVar23 & LIVEOBJ1_UNK_200) == LIVEOBJ1_NONE) {
				if ((LVar23 & LIVEOBJ1_UNK_2000) != LIVEOBJ1_NONE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_DESPOSIT,0);
					pLVar29 = liveObj->object_2fc;
					if ((pLVar29 != NULL) &&
						 ((OVar15 = LiveObject_GetStatsFlags1(pLVar29),
							(OVar15 & STATS1_PROCESSCRYSTAL) != STATS1_NONE ||
							(OVar15 = LiveObject_GetStatsFlags1(pLVar29),
							(OVar15 & STATS1_PROCESSORE) != STATS1_NONE)))) {
						pLVar29 = liveObj->object_2fc;
						if (((pLVar29->flags1 & LIVEOBJ1_UNK_2000) == LIVEOBJ1_NONE) &&
							 (((pLVar29->flags3 & LIVEOBJ3_UNK_1000000) == LIVEOBJ3_NONE &&
								(pLVar29->numCarriedObjects != pLVar29->field_328)))) {
							pLVar29->flags3 = pLVar29->flags3 | LIVEOBJ3_UNK_1000000;
						}
						else {
							liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_2000 | LIVEOBJ1_UNK_4000;
						}
					}
					goto LAB_0043f040;
				}
				if ((LVar23 & LIVEOBJ1_UNK_800) != LIVEOBJ1_NONE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_THROW,0);
					goto LAB_0043f040;
				}
				if (((LVar23 & LIVEOBJ1_TURNING) != LIVEOBJ1_NONE) ||
					 ((LVar23 & LIVEOBJ1_REST) != LIVEOBJ1_NONE)) goto LAB_0043f040;
				if ((LVar23 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
					LiveObject_GetBlockCoordinates(liveObj,(int *)&local_20,(int *)&local_20.y);
					uVar22 = Level_GetBlockRubbleLevel_OrFlag200000((Point2I *)&local_20);
					if (((uVar22 < 3) &&
							((globals::g_Game.level)->blocks
							 [((globals::g_Game.level)->dimensions).width * (int)local_20.y + (int)local_20.x].
							 terrain != TERRAIN_LAKE)) ||
						 ((liveObj->flags3 & LIVEOBJ3_UNK_10000000) == LIVEOBJ3_NONE)) {
						LiveObject_SetActivityUnk(liveObj,ACTIVITY_CARRY,0);
					}
					else {
						LiveObject_SetActivityUnk(liveObj,ACTIVITY_CARRYRUBBLE,0);
					}
					goto LAB_0043f040;
				}
				if ((LVar23 & LIVEOBJ1_UNK_80000000) != LIVEOBJ1_NONE) {
					LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_CANTDO,1);
					goto LAB_0043f040;
				}
				if ((LVar23 & LIVEOBJ1_MOVING) == LIVEOBJ1_NONE) goto LAB_0043f040;
				LiveObject_GetBlockCoordinates(liveObj,(int *)&local_20,(int *)&local_20.y);
				if (((liveObj->flags1 & LIVEOBJ1_UNK_800000) != LIVEOBJ1_NONE) &&
					 (liveObj->objType == OBJECT_MINIFIGURE)) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_RUNPANIC,0);
					goto LAB_0043f040;
				}
				uVar22 = Level_GetBlockRubbleLevel_OrFlag200000((Point2I *)&local_20);
				if (((2 < uVar22) ||
						((globals::g_Game.level)->blocks
						 [((globals::g_Game.level)->dimensions).width * (int)local_20.y + (int)local_20.x].
						 terrain == TERRAIN_LAKE)) &&
					 ((liveObj->flags3 & LIVEOBJ3_UNK_10000000) != LIVEOBJ3_NONE)) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_ROUTERUBBLE,0);
					goto LAB_0043f040;
				}
				goto LAB_0043e732;
			}
			if ((liveObj->object_2fc == NULL) || (liveObj->object_2fc->carryingThisObject != NULL)) {
				liveObj->flags1 = LVar23 & ~LIVEOBJ1_UNK_200;
				goto LAB_0043f040;
			}
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_COLLECT,0);
			if (liveObj->objType == OBJECT_ROCKMONSTER) {
				OVar5 = liveObj->object_2fc->objType;
				if (OVar5 == OBJECT_BOULDER) {
					AVar32 = ACTIVITY_GATHER;
				}
				else {
					if (OVar5 != OBJECT_POWERCRYSTAL) goto LAB_0043e4b7;
					AVar32 = ACTIVITY_EAT;
				}
				LiveObject_SetActivityUnk(liveObj,AVar32,0);
			}
LAB_0043e4b7:
			liveObj->carriedObjects[liveObj->numCarriedObjects] = liveObj->object_2fc;
			liveObj->object_2fc = NULL;
			liveObj->carriedObjects[liveObj->numCarriedObjects]->carryingThisObject = liveObj;
			liveObj->carriedObjects[(int)(LiveObject *)liveObj->numCarriedObjects]->carriedObjects[6] =
					 (LiveObject *)liveObj->numCarriedObjects;
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_CARRYING;
			LiveObject_SetAITaskUnk
								(liveObj,AITASK_COLLECT,liveObj->carriedObjects[liveObj->numCarriedObjects],1);
			ai::AITask_DoAnimationWait(liveObj);
			liveObj->numCarriedObjects = liveObj->numCarriedObjects + 1;
			goto LAB_0043f040;
		}
		if ((LVar23 & LIVEOBJ1_UNK_200000) != LIVEOBJ1_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = LVar23 & ~LIVEOBJ1_UNK_200000;
				if (liveObj->objType == OBJECT_VEHICLE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_ROUTE,0);
					Game_UpdateSomeAITasks(liveObj);
				}
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
				LiveObject_FUN_00438720(liveObj);
			}
			FUN_00443240(liveObj,elapsed);
			pCVar10 = LiveObject_GetResource(liveObj);
			if (pCVar10 != NULL) {
				res::Container_GetOrientation(pCVar10,NULL,&local_c,NULL);
				res::Container_SetOrientation(pCVar10,NULL,local_c.x,local_c.y,local_c.z,0.0,0.0,-1.0);
			}
			goto LAB_0043f040;
		}
		BVar12 = FUN_00449c40(liveObj,elapsed,&local_14);
		if (BVar12 != 0) {
			if (local_14 != 0) {
				LiveObject_SetAITaskUnk(liveObj,AITASK_REINFORCE,NULL,1);
			}
			goto LAB_0043f040;
		}
		LVar23 = liveObj->flags1;
		if ((LVar23 & LIVEOBJ1_UNK_100) != LIVEOBJ1_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = LVar23 & ~LIVEOBJ1_UNK_100;
				BVar12 = LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj);
				if (BVar12 != 0) {
					lVar26 = __ftol((float10)(liveObj->point_2f4).x);
					local_c.x = (float)lVar26;
					lVar26 = __ftol((float10)(liveObj->point_2f4).y);
					local_c.y = (float)lVar26;
					Level_AddMessageAction(MESSAGE_GENERATEROCKMONSTER_COMPLETE,liveObj,0,NULL);
					Level_SetBlockFlags1_8000000((Point2I *)&local_c,0);
				}
			}
			goto LAB_0043f040;
		}
		LVar4 = liveObj->flags2;
		if ((LVar4 & LIVEOBJ2_UNK_100000) != LIVEOBJ2_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_100000;
				liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
			}
			goto LAB_0043f040;
		}
		if ((LVar4 & LIVEOBJ2_UNK_4) != LIVEOBJ2_NONE) {
			pLVar29 = liveObj->object_2fc;
			liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_4;
			LiveObject_SetAITaskUnk(liveObj,AITASK_FINDDRIVER,NULL,1);
			liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_DRIVING;
			pLVar29->flags4 = pLVar29->flags4 & ~LIVEOBJ4_UNK_80;
			if (pLVar29->object_2fc != NULL) {
				pLVar2 = &pLVar29->object_2fc->flags4;
				*pLVar2 = *pLVar2 & ~LIVEOBJ4_UNK_80;
			}
			pLVar29->object_2fc = NULL;
			pLVar29->flags2 = pLVar29->flags2 & ~LIVEOBJ2_UNK_10;
			liveObj->drivenObject = pLVar29;
			pLVar29->drivenObject = liveObj;
			liveObj->object_2fc = NULL;
			LiveObject_FUN_0041cdd0(liveObj->drivenObject);
			FUN_00443240(liveObj,elapsed);
			pLVar29->aitaskName2 = NULL;
			Game_UpdateSomeAITasks(pLVar29);
			goto LAB_0043f040;
		}
		if ((LVar4 & LIVEOBJ2_DRIVING) != LIVEOBJ2_NONE) goto LAB_0043f040;
		if ((LVar23 & LIVEOBJ1_UNK_20000) != LIVEOBJ1_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = LVar23 & ~LIVEOBJ1_UNK_20000;
				liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_20;
				LiveObject_FUN_0043be80(liveObj);
			}
			goto LAB_0043f040;
		}
		if ((LVar4 & LIVEOBJ2_UNK_200) != LIVEOBJ2_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				LiveObject_GetBlockCoordinates(liveObj,(int *)&local_20,(int *)&local_20.y);
				iVar19 = FUN_00408ff0((Point2I *)&local_20,NULL);
				if ((iVar19 != 0) && ((*(byte *)(iVar19 + 0xd0) & 2) != 0)) {
					FUN_00432530((Point2I *)&local_20);
					FUN_00409040((int *)&local_20);
					front::Info_FUN_00419ab0(INFO_PATHCOMPLETED,NULL,NULL,(Point2I *)&local_20);
					ai::AITask_DoAttackPath((Point2I *)&local_20);
				}
				liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_200;
				LiveObject_SetAITaskUnk(liveObj,AITASK_BUILDPATH,NULL,1);
			}
			goto LAB_0043f040;
		}
		if ((LVar23 & LIVEOBJ1_CLEARING) != LIVEOBJ1_NONE) {
			if (liveObj->objType == OBJECT_VEHICLE) {
				FUN_00443240(liveObj,elapsed);
			}
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CLEARING;
				LiveObject_SetAITaskUnk(liveObj,AITASK_CLEAR,NULL,1);
				if (liveObj->objType == OBJECT_VEHICLE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
				}
			}
			goto LAB_0043f040;
		}
		if ((LVar23 & LIVEOBJ1_UNK_80000000) != LIVEOBJ1_NONE) goto LAB_0043eb11;
		if ((LVar4 & LIVEOBJ2_UNK_100) != LIVEOBJ2_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_100;
			}
			goto LAB_0043f040;
		}
		if ((LVar23 & LIVEOBJ1_UNK_10000) != LIVEOBJ1_NONE) {
			sVar9 = math::Maths_Rand();
			if ((int)sVar9 % 10 != 0) {
				LiveObject_FUN_00444520(liveObj);
			}
			liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_10000;
			goto LAB_0043f040;
		}
		if ((LVar4 & LIVEOBJ2_UNK_2) != LIVEOBJ2_NONE) {
			if (((*(byte *)&liveObj->object_3c0->flags2 & 1) == 0) ||
				 ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0)) {
				liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_2;
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_GETUP,0);
				Game_UpdateSomeAITasks(liveObj);
				liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_100;
			}
			goto LAB_0043f040;
		}
		if ((LVar4 & LIVEOBJ2_UNK_1) != LIVEOBJ2_NONE) {
			if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
				LiveObject_GetPosition(liveObj,(float *)&local_c,&local_c.y);
				BVar12 = 1;
				fVar25 = LiveObject_UnkRadians_FUN_00442740(liveObj);
				LiveObject_UnkUpdatePositioning
									(liveObj->object_3c0,local_c.x,local_c.y,(float)fVar25,BVar12);
			}
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) != 0) goto LAB_0043f040;
			pCVar10 = LiveObject_GetDepositNull(liveObj);
			res::Container_GetPosition(pCVar10,NULL,&local_c);
			LiveObject_UnkUpdatePositioning(liveObj,local_c.x,local_c.y,0,0);
			liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_1;
			LiveObject_FUN_0043f960(liveObj->object_3c0,10.0,1,elapsed);
			goto LAB_0043ecae;
		}
		BVar12 = LiveObject_FUN_00433b40(liveObj,elapsed,0);
		if (BVar12 != 0) goto LAB_0043f040;
		iVar19 = LiveObject_FUN_00442dd0(liveObj,elapsed,&local_10);
		if (iVar19 != 0) {
			if (iVar19 == 1) {
				if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_ROUTE,0);
				}
				else {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_CARRY,0);
				}
			}
			else {
				if (iVar19 == 4) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
				}
				else {
					if (iVar19 == 2) {
						LiveObject_SetActivityUnk(liveObj,ACTIVITY_WALK,0);
					}
					else {
						if ((iVar19 == 3) &&
							 (BVar12 = LiveObject_GetDrillNullPosition
																	 (liveObj,(float *)&local_20,(float *)&in_liveObj), BVar12 != 0))
						{
							out_y = &local_30.y;
							pVVar33 = &local_30;
							fVar35 = local_20.x;
							pLVar29 = in_liveObj;
							pSVar20 = GetSurfaceMap();
							BVar12 = SurfaceMap_ToBlockCoordinatesNoZ
																 (pSVar20,fVar35,(float)pLVar29,(int *)pVVar33,(int *)out_y);
							if ((BVar12 != 0) &&
								 (BVar12 = Level_GetBlockFlags1_10Not8((uint)local_30.x,(uint)local_30.y),
								 BVar12 != 0)) {
								SVar18 = Level_GetBlockTerrain((int)local_30.x,(int)local_30.y);
								fVar25 = LiveObject_GetDrillTimeType(liveObj,SVar18);
								local_24 = (float)fVar25;
								if ((liveObj->flags4 & LIVEOBJ4_UNK_20000) == LIVEOBJ4_NONE) {
									LiveObject_GetResource(liveObj);
									BVar12 = 1;
									SVar11 = LiveObject_GetDrillSoundType(liveObj,0);
									snd::Audio_Play_FUN_00465260(SVar11,BVar12);
									liveObj->field_350 = SVar11;
									liveObj->flags4 = liveObj->flags4 | (LIVEOBJ4_UNK_20000|LIVEOBJ4_UNK_100000);
								}
								bVar8 = false;
								LiveObject_SetActivityUnk(liveObj,ACTIVITY_DRILL,0);
								BVar12 = Level_GetBlockUnkField14Test
																	 ((int)local_30.x,(int)local_30.y,local_24,elapsed);
								if ((BVar12 != 0) &&
									 (BVar12 = LiveObject_FUN_004326a0(liveObj,(uint)local_30.x,(uint)local_30.y,0,1),
									 BVar12 != 0)) {
									BVar12 = 0;
									pLVar14 = GetLevel();
									Level_DestroyWall(pLVar14,(int)local_30.x,(int)local_30.y,BVar12);
								}
							}
						}
					}
				}
			}
			if (liveObj->objType == OBJECT_MINIFIGURE) {
				if ((DAT_004ebdcc & 3) == 0) {
					snd::Audio_Play_FUN_00465260(SFX_STEP,0);
				}
				DAT_004ebdcc += 1;
			}
			goto LAB_0043f040;
		}
		LVar23 = liveObj->flags1;
		if ((LVar23 & LIVEOBJ1_UNK_200) != LIVEOBJ1_NONE) {
			if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
				 (liveObj->flags1 = LVar23 & ~LIVEOBJ1_UNK_200,
				 (LVar23 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) {
				if (liveObj->objType == OBJECT_ROCKMONSTER) {
					pLVar29 = liveObj->carriedObjects[0];
					if (pLVar29->objType == OBJECT_BOULDER) {
						BVar12 = FUN_00438e40(liveObj,0x400);
						Level_AddMessageAction(MESSAGE_GATHERROCK_COMPLETE,liveObj,BVar12,NULL);
					}
					else {
						liveObj->carriedObjects[0] = NULL;
						liveObj->numCarriedObjects = 0;
						pLVar29->carryingThisObject = NULL;
						pLVar29->object_300 = NULL;
						LiveObject_SetAITaskUnk(liveObj,AITASK_COLLECT,pLVar29,1);
						LiveObject_FUN_0043ab10(liveObj,pLVar29);
						liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CARRYING;
					}
				}
				else {
					OVar5 = liveObj->carriedObjects[liveObj->numCarriedObjects - 1]->objType;
					if (OVar5 == OBJECT_POWERCRYSTAL) {
						Level_IncField94();
					}
					else {
						if (OVar5 == OBJECT_ORE) {
							Level_IncFieldA8();
							front::Info_FUN_00419ab0(INFO_ORECOLLECTED,NULL,liveObj,NULL);
						}
					}
				}
			}
			goto LAB_0043f040;
		}
		if ((LVar23 & LIVEOBJ1_UNK_8000) != LIVEOBJ1_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = LVar23 & ~LIVEOBJ1_UNK_8000;
			}
			goto LAB_0043f040;
		}
		if ((LVar23 & LIVEOBJ1_TURNING) != LIVEOBJ1_NONE) goto LAB_0043f040;
		if ((LVar23 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
			OVar5 = liveObj->objType;
			if (OVar5 == OBJECT_BUILDING) {
				if ((liveObj->flags3 & LIVEOBJ3_UNK_20000000) != LIVEOBJ3_NONE) {
					if ((liveObj->flags3 & LIVEOBJ3_UNK_80000000) != LIVEOBJ3_NONE) {
						AVar32 = ACTIVITY_UNPOWERED;
						goto LAB_0043f029;
					}
					goto LAB_0043eff8;
				}
			}
			else {
LAB_0043eff8:
				if ((OVar5 != OBJECT_ROCKMONSTER) ||
					 ((liveObj->flags3 & LIVEOBJ3_UNK_80000000) == LIVEOBJ3_NONE)) {
					if ((OVar5 == OBJECT_VEHICLE) && ((liveObj->flags4 & LIVEOBJ4_UNK_2000) != LIVEOBJ4_NONE))
					{
						AVar32 = ACTIVITY_OPEN;
					}
					else {
						AVar32 = ACTIVITY_STAND;
					}
					goto LAB_0043f029;
				}
			}
			AVar32 = ACTIVITY_UNPOWERED;
		}
		else {
			AVar32 = ACTIVITY_CARRYSTAND;
		}
LAB_0043f029:
		LiveObject_SetActivityUnk(liveObj,AVar32,0);
		FUN_00443240(liveObj,elapsed);
		goto LAB_0043f040;
	}
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		if (liveObj->object_2fc == NULL) {
			liveObj->flags2 = LVar4 & ~LIVEOBJ2_UPGRADING;
		}
		else {
			fVar25 = res::Creature_GetAnimFloat10(liveObj->miniFigure);
			local_20.x = (float)fVar25;
			fVar25 = LiveObject_GetUpgradeTime(liveObj);
			in_liveObj = (LiveObject *)(float)fVar25;
			fVar25 = LiveObject_GetFunctionCoef(liveObj->object_2fc);
			if (fVar25 * (float10)(float)in_liveObj <= (float10)local_20.x) {
				LiveObject_SetAITaskUnk(liveObj,AITASK_UPGRADE,NULL,1);
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
				Game_UpdateSomeAITasks(liveObj);
				uVar24 = liveObj->objLevel + 1;
				uVar22 = Object_GetLevels(liveObj->objType,liveObj->objIndex);
				if (uVar24 < uVar22) {
					LiveObject_SetLevel(liveObj,uVar24);
					Game_UpdateObjectDependencies(liveObj->objType,liveObj->objIndex,liveObj->objLevel,0);
				}
				liveObj->object_2fc = NULL;
				liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UPGRADING;
			}
		}
		goto LAB_0043f040;
	}
	if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 | (ushort)(liveObj->float_2d4 == 0.0) << 0xe)
			!= 0) goto LAB_0043f040;
	if ((liveObj->object_2fc == NULL) ||
		 (OVar21 = LiveObject_GetStatsFlags2(liveObj->object_2fc),
		 (OVar21 & STATS2_UPGRADEBUILDING) == STATS2_NONE)) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UPGRADING;
		goto LAB_0043f040;
	}
	if ((liveObj->object_2fc->flags2 & LIVEOBJ2_UPGRADING) != LIVEOBJ2_NONE) goto LAB_0043f040;
	LiveObject_SetAITaskUnk(liveObj,AITASK_UPGRADE,NULL,1);
	uVar22 = Object_GetUpgradeCostOre(liveObj->objType,liveObj->objIndex,liveObj->field_404);
	uVar24 = Level_GetOreCount(0);
	if (uVar24 < uVar22) {
		uVar22 = Object_GetUpgradeCostStuds(liveObj->objType,liveObj->objIndex,liveObj->field_404);
		uVar24 = Level_GetOreCount(1);
		if (uVar22 <= uVar24) {
			LiveObject_CompleteVehicleUpgrade(liveObj);
			iVar19 = Object_GetUpgradeCostStuds(liveObj->objType,liveObj->objIndex,liveObj->field_404);
			BVar12 = 1;
			goto LAB_0043df73;
		}
	}
	else {
		LiveObject_CompleteVehicleUpgrade(liveObj);
		iVar19 = Object_GetUpgradeCostOre(liveObj->objType,liveObj->objIndex,liveObj->field_404);
		BVar12 = 0;
LAB_0043df73:
		Level_SubtractOre(BVar12,iVar19);
	}
	liveObj->object_2fc->object_300 = NULL;
	liveObj->object_2fc = NULL;
	liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UPGRADING;
LAB_0043f040:
	if ((bVar8) && ((liveObj->flags4 & LIVEOBJ4_UNK_20000) != LIVEOBJ4_NONE)) {
		LiveObject_GetResource(liveObj);
		snd::Sample_StopSoundBufferInstance(liveObj->field_350);
		BVar12 = 0;
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_100000;
		SVar11 = LiveObject_GetDrillSoundType(liveObj,1);
		snd::Audio_Play_FUN_00465260(SVar11,BVar12);
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_20000;
	}
	Game_UpdateSomeAITasks(liveObj);
	if ((liveObj->drivenObject != NULL) && (liveObj->objType != OBJECT_MINIFIGURE)) {
		FUN_004437d0(liveObj);
	}
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		LiveObject_UpdateCarrying(liveObj);
	}
	BVar12 = LiveObject_UnkTracker_FUN_00471fa0(liveObj);
	if (BVar12 != 0) {
		FUN_00472280((int *)liveObj,elapsed);
	}
	LiveObject_FUN_004459a0(liveObj);
	FUN_0044bef0(liveObj,*lpElapsed);
	LiveObject_UnkUpdateEnergyHealth(liveObj,elapsed);
	if ((liveObj->flags2 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_10000 | LIVEOBJ2_UNK_20000;
	}
	liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_2;
	LiveObject_FUN_0043bf00(liveObj);
	return 0;
}




void __cdecl FUN_0043f160(LiveObject *in_liveObj)
{
	LiveObject *pLVar1;
	LiveObject *liveObj2;
	bool bVar2;
	LiveObject *liveObj;
	ObjectStatsFlags1 OVar3;
	uint uVar4;
	Container *cont;
	LiveObject *liveObj_00;
	int iVar5;
	int iVar6;
	LiveObject **ppLVar7;
	uint uVar8;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	pLVar1 = in_liveObj->object_2fc;
	OVar3 = lego::game::LiveObject_GetStatsFlags1(in_liveObj);
	if (((OVar3 & STATS1_PROCESSCRYSTAL) == STATS1_NONE) &&
		 (OVar3 = lego::game::LiveObject_GetStatsFlags1(in_liveObj),
		 (OVar3 & STATS1_PROCESSORE) == STATS1_NONE)) {
		bVar2 = false;
	}
	else {
		bVar2 = true;
	}
	uVar8 = 0;
	if (in_liveObj->numCarriedObjects != 0) {
		in_liveObj = (LiveObject *)in_liveObj->carriedObjects;
		do {
			liveObj2 = (LiveObject *)in_liveObj->objType;
			liveObj2->object_2fc = (LiveObject *)0x0;
			if (bVar2) {
				liveObj2->carryingThisObject = (LiveObject *)0x0;
				liveObj2->object_300 = (LiveObject *)0x0;
				if (liveObj2->objType == OBJECT_ORE) {
					if ((uVar8 == 0) || (uVar4 = lego::game::LiveObject_GetMaxCarry(liveObj), uVar4 <= uVar8))
					{
						cont = lego::res::Building_GetDepositNull(liveObj->building);
						if (uVar8 == 0) {
							lego::res::Container_GetPosition(cont,(Container *)0x0,&local_c);
							liveObj_00 = lego::game::Game_CreateLiveResourceObject
																		 (lego::globals::g_Game.RES_Ores_TABLE[1],OBJECT_ORE,1,0,
																			local_c.x,local_c.y,0.0);
							lego::game::Level_AddMessageAction
												(MESSAGE_GENERATEORE_COMPLETE,liveObj_00,0,(Point2I *)0x0);
							lego::pool::ReservedPool_LiveObject___Release(liveObj2);
							goto LAB_0043f315;
						}
						lego::game::Level_IncOre(0);
					}
					lego::pool::ReservedPool_LiveObject___Release(liveObj2);
				}
				else {
					lego::game::LiveObject_FUN_0043ab10(liveObj,liveObj2);
					if (liveObj->objType == OBJECT_BUILDING) {
						lego::res::Building_FUN_00408210(liveObj->building,1);
					}
					lego::game::Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
				}
			}
			else {
				if (pLVar1->numCarriedObjects == pLVar1->field_328) {
					if (uVar8 < liveObj->numCarriedObjects) {
						iVar6 = uVar8 * 4;
						ppLVar7 = liveObj->carriedObjects + uVar8;
						uVar4 = uVar8;
						do {
							pLVar1 = *ppLVar7;
							iVar5 = iVar6 + uVar8 * -4;
							uVar4 = uVar4 + 1;
							iVar6 = iVar6 + 4;
							ppLVar7 = ppLVar7 + 1;
							*(LiveObject **)((int)liveObj + iVar5 + 0x308) = pLVar1;
						} while (uVar4 < liveObj->numCarriedObjects);
					}
					liveObj->numCarriedObjects = liveObj->numCarriedObjects - uVar8;
					return;
				}
				pLVar1->carriedObjects[pLVar1->numCarriedObjects] = liveObj2;
				liveObj2->carryingThisObject = pLVar1;
				liveObj2->carriedObjects[6] = (LiveObject *)pLVar1->numCarriedObjects;
				pLVar1->numCarriedObjects = pLVar1->numCarriedObjects + 1;
				pLVar1->flags1 = pLVar1->flags1 | LIVEOBJ1_CARRYING;
				lego::game::Level_AddMessageAction(MESSAGE_CRYSTALTOREFINERY_COMPLETE,0,0,(Point2I *)0x0);
				OVar3 = lego::game::LiveObject_GetStatsFlags1(pLVar1);
				if ((OVar3 & STATS1_PROCESSCRYSTAL) != STATS1_NONE) {
					lego::front::Info_FUN_00419ab0(INFO_CRYSTALPOWER,(char *)0x0,pLVar1,(Point2I *)0x0);
				}
			}
LAB_0043f315:
			uVar8 = uVar8 + 1;
			in_liveObj->objType = OBJECT_NONE;
			in_liveObj = (LiveObject *)&in_liveObj->objIndex;
		} while (uVar8 < liveObj->numCarriedObjects);
	}
	liveObj->numCarriedObjects = 0;
	liveObj->object_2fc = (LiveObject *)0x0;
	liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CARRYING;
	return;
}



void __cdecl FUN_0043f3c0(undefined4 param_1,int param_2)
{
	uint *puVar1;
	
	*(uint *)(param_2 + 0x3ec) = *(uint *)(param_2 + 0x3ec) & 0xffffffbf;
	if (*(int *)(param_2 + 0x2fc) != 0) {
		puVar1 = (uint *)(*(int *)(param_2 + 0x2fc) + 0x3ec);
		*puVar1 = *puVar1 & 0xffffffbf;
	}
	return;
}



void __cdecl lego::res::Res_ResourceDrawCallback(Container *resData,void *lpValue)
{
	void *pvVar1;
	
	pvVar1 = Container_GetUserData(resData);
	if (pvVar1 != (void *)0x0) {
		*(uint *)((int)pvVar1 + 0x3e4) = *(uint *)((int)pvVar1 + 0x3e4) | 0x10000;
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_QueueTeleport(LiveObject *liveObj,ObjectType objType,int objIndex)
{
	if (globals::g_Game.objTeleportQueue_COUNT < 9) {
		globals::g_Game.objTeleportQueueTypes_TABLE[globals::g_Game.objTeleportQueue_COUNT] = objType;
		globals::g_Game.objTeleportQueueIndexes_TABLE[globals::g_Game.objTeleportQueue_COUNT] = objIndex
		;
		globals::g_Game.objTeleportQueue_COUNT = globals::g_Game.objTeleportQueue_COUNT + 1;
		return 1;
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_0043f450(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	BOOL BVar1;
	ObjectStatsFlags2 OVar2;
	ObjectStatsFlags1 OVar3;
	int iVar4;
	int iVar5;
	LiveObject *pLVar6;
	Container *cont;
	SurfaceMap *pSVar7;
	int *piVar8;
	uint uVar9;
	ObjectType *pOVar10;
	float in_x;
	float in_y;
	uint *out_x;
	Vector3F *out_x_00;
	uint *out_y;
	float *out_y_00;
	ObjectType local_2c;
	int local_28;
	Container *local_24;
	uint local_20;
	uint local_1c;
	Vector3F local_18;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	local_28 = 0;
	BVar1 = LiveObject_CheckCondition_FUN_00438870(in_liveObj,0);
	if ((((BVar1 != 0) && (globals::g_Game.objTeleportQueue_COUNT != 0)) &&
			((liveObj->object_3cc == (LiveObject *)0x0 ||
			 ((liveObj->object_3cc->flags1 & LIVEOBJ1_UNK_200000) == LIVEOBJ1_NONE)))) &&
		 ((*(byte *)&liveObj->flags4 & 0xc0) == 0)) {
		uVar9 = 0;
		iVar4 = 0;
		if (globals::g_Game.objTeleportQueue_COUNT != 0) {
			pOVar10 = globals::g_Game.objTeleportQueueTypes_TABLE;
			do {
				OVar2 = Object_GetStatsFlags2(*pOVar10,pOVar10[0x14]);
				if (((((OVar2 & STATS2_USESMALLTELEPORTER) != STATS2_NONE) &&
						 (OVar3 = LiveObject_GetStatsFlags1(liveObj),
						 (OVar3 & STATS1_SMALLTELEPORTER) != STATS1_NONE)) ||
						(((OVar2 = Object_GetStatsFlags2(*pOVar10,pOVar10[0x14]),
							(OVar2 & STATS2_USEBIGTELEPORTER) != STATS2_NONE &&
							(OVar3 = LiveObject_GetStatsFlags1(liveObj),
							(OVar3 & STATS1_BIGTELEPORTER) != STATS1_NONE)) ||
						 ((OVar2 = Object_GetStatsFlags2(*pOVar10,pOVar10[0x14]),
							(OVar2 & STATS2_USEWATERTELEPORTER) != STATS2_NONE &&
							(OVar3 = LiveObject_GetStatsFlags1(liveObj),
							(OVar3 & STATS1_WATERTELEPORTER) != STATS1_NONE)))))) ||
					 ((OVar2 = Object_GetStatsFlags2(*pOVar10,pOVar10[0x14]),
						(OVar2 & STATS2_USELEGOMANTELEPORTER) != STATS2_NONE &&
						(OVar3 = LiveObject_GetStatsFlags1(liveObj),
						(OVar3 & STATS1_MANTELEPORTER) != STATS1_NONE)))) {
					iVar4 = Object_GetCostCrystal(*pOVar10,pOVar10[0x14],0);
					iVar5 = Level_GetCrystalCount(0);
					if (iVar4 <= iVar5) {
						Object_GetObjectByName("Barracks",&local_2c,(int *)&in_liveObj,(Container **)0x0);
						BVar1 = Object_DoOxygenCheck_FUN_0043c4c0
															(*pOVar10,pOVar10[0x14],local_2c,(int)in_liveObj);
						if (BVar1 != 0) {
							iVar4 = 1;
							break;
						}
					}
				}
				uVar9 = uVar9 + 1;
				pOVar10 = pOVar10 + 1;
				iVar4 = local_28;
			} while (uVar9 < globals::g_Game.objTeleportQueue_COUNT);
		}
		if (iVar4 != 0) {
			Object_GetTypeResource
								(globals::g_Game.objTeleportQueueTypes_TABLE[uVar9],
								 globals::g_Game.objTeleportQueueIndexes_TABLE[uVar9],&local_24);
			pLVar6 = Game_CreateLiveResourceObject
												 (local_24,globals::g_Game.objTeleportQueueTypes_TABLE[uVar9],
													globals::g_Game.objTeleportQueueIndexes_TABLE[uVar9],0,0.0,0.0,0.0);
			liveObj->object_3cc = pLVar6;
			iVar4 = Object_GetCostCrystal
												(globals::g_Game.objTeleportQueueTypes_TABLE[uVar9],
												 globals::g_Game.objTeleportQueueIndexes_TABLE[uVar9],0);
			Level_SubtractCrystals(iVar4);
			Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
			OVar3 = LiveObject_GetStatsFlags1(liveObj);
			if ((OVar3 & STATS1_WATERTELEPORTER) == STATS1_NONE) {
				OVar3 = LiveObject_GetStatsFlags1(liveObj->object_3cc);
				if ((OVar3 & STATS1_CANBEDRIVEN) != STATS1_NONE) {
					liveObj->object_3cc->flags4 = liveObj->object_3cc->flags4 | LIVEOBJ4_UNK_80;
					liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_80;
					liveObj->object_3cc->object_2fc = liveObj;
				}
			}
			else {
				liveObj->object_3cc->flags4 = liveObj->object_3cc->flags4 | LIVEOBJ4_UNK_40;
				liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_40;
				liveObj->object_3cc->object_2fc = liveObj;
			}
			cont = res::Building_GetDepositNull(liveObj->building);
			res::Container_GetPosition(cont,(Container *)0x0,&local_18);
			res::Container_GetOrientation(cont,(Container *)0x0,&local_c,(Vector3F *)0x0);
			if ((globals::g_Game.objTeleportQueueTypes_TABLE[uVar9] == OBJECT_VEHICLE) &&
				 (OVar2 = Object_GetStatsFlags2
														(OBJECT_VEHICLE,globals::g_Game.objTeleportQueueIndexes_TABLE[uVar9]),
				 (OVar2 & STATS2_USESMALLTELEPORTER) != STATS2_NONE)) {
				out_y = &local_1c;
				out_x = &local_20;
				in_x = local_18.x;
				in_y = local_18.y;
				pSVar7 = GetSurfaceMap();
				SurfaceMap_ToBlockCoordinatesNoZ(pSVar7,in_x,in_y,(int *)out_x,(int *)out_y);
				out_y_00 = &local_18.y;
				out_x_00 = &local_18;
				pSVar7 = GetSurfaceMap();
				SurfaceMap_FUN_0044f900(pSVar7,local_20,local_1c,(float *)out_x_00,out_y_00);
			}
			LiveObject_UnkUpdatePositioning(liveObj->object_3cc,local_18.x,local_18.y,0,0);
			LiveObject_UnkUpdateOrientation(liveObj->object_3cc,0.0,&local_c);
			LiveObject_RecallMiniFigure(liveObj->object_3cc);
			liveObj->object_3cc->flags1 = liveObj->object_3cc->flags1 | LIVEOBJ1_UNK_200000;
			LiveObject_SetActivityUnk(liveObj->object_3cc,ACTIVITY_TELEPORTIN,1);
			Game_UpdateSomeAITasks(liveObj->object_3cc);
			if (liveObj->object_3cc->objType == OBJECT_VEHICLE) {
				res::Vehicle_FUN_0046d280(liveObj->object_3cc->vehicle,1);
			}
			globals::g_Game.objTeleportQueue_COUNT = globals::g_Game.objTeleportQueue_COUNT - 1;
			if (uVar9 < globals::g_Game.objTeleportQueue_COUNT) {
				piVar8 = globals::g_Game.objTeleportQueueIndexes_TABLE + uVar9 + 1;
				do {
					uVar9 = uVar9 + 1;
					piVar8[-0x15] = piVar8[-0x14];
					piVar8[-1] = *piVar8;
					piVar8 = piVar8 + 1;
				} while (uVar9 < globals::g_Game.objTeleportQueue_COUNT);
			}
		}
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_0043f820(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_0043f840,liveObj);
	return BVar1;
}



BOOL __cdecl FUN_0043f840(int param_1,LiveObject *param_2)
{
	if (*(LiveObject **)(param_1 + 0x3cc) == param_2) {
		*(undefined4 *)(param_1 + 0x3cc) = 0;
		return 1;
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_TrainMiniFigure_instantunk(LiveObject *liveObj,TrainedFlags trainFlags)
{
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		liveObj->flags5_3f0 = liveObj->flags5_3f0 | trainFlags;
		globals::nerps::g_NERPs_TrainFlags = globals::nerps::g_NERPs_TrainFlags | trainFlags;
		if ((trainFlags & TRAINED_PILOT) != TRAINED_NONE) {
			front::Info_FUN_00419ab0(INFO_TRAINPILOT,(char *)0x0,liveObj,(Point2I *)0x0);
			liveObj->elapsedTime1 = 0.0;
			return;
		}
		if ((trainFlags & TRAINED_SAILOR) != TRAINED_NONE) {
			front::Info_FUN_00419ab0(INFO_TRAINSAILOR,(char *)0x0,liveObj,(Point2I *)0x0);
			liveObj->elapsedTime1 = 0.0;
			return;
		}
		if ((trainFlags & TRAINED_DRIVER) != TRAINED_NONE) {
			front::Info_FUN_00419ab0(INFO_TRAINDRIVER,(char *)0x0,liveObj,(Point2I *)0x0);
			liveObj->elapsedTime1 = 0.0;
			return;
		}
		if ((trainFlags & TRAINED_DYNAMITE) != TRAINED_NONE) {
			front::Info_FUN_00419ab0(INFO_TRAINDYNAMITE,(char *)0x0,liveObj,(Point2I *)0x0);
			liveObj->elapsedTime1 = 0.0;
			return;
		}
		if ((trainFlags & TRAINED_REPAIR) != TRAINED_NONE) {
			front::Info_FUN_00419ab0(INFO_TRAINREPAIR,(char *)0x0,liveObj,(Point2I *)0x0);
			liveObj->elapsedTime1 = 0.0;
			return;
		}
		if ((trainFlags & TRAINED_SCANNER) != TRAINED_NONE) {
			front::Info_FUN_00419ab0(INFO_TRAINSCANNER,(char *)0x0,liveObj,(Point2I *)0x0);
		}
		liveObj->elapsedTime1 = 0.0;
	}
	return;
}



void __cdecl
lego::game::LiveObject_FUN_0043f960(LiveObject *liveObj,float param_2,BOOL param_3,float param_4)
{
	BOOL BVar1;
	ObjectStatsFlags2 OVar2;
	float10 fVar3;
	longlong lVar4;
	longlong lVar5;
	
	BVar1 = LiveObject_CheckCondition_FUN_00438870(liveObj,1);
	if ((BVar1 != 0) && (liveObj->carryingThisObject == (LiveObject *)0x0)) {
		if ((liveObj->objType == OBJECT_BUILDING) &&
			 ((param_2 != 0.0 && ((undefined *)liveObj->health == &DAT_42c80000)))) {
			ai::AITask_DoRepair_Target(liveObj,0);
		}
		BVar1 = LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj);
		if (BVar1 != 0) {
			fVar3 = LiveObject_GetHealthDecayRate(liveObj);
			lVar4 = __ftol(fVar3 * (float10)0.04 * (float10)param_4 * (float10)10010.0);
			lVar5 = __ftol((float10)param_2 * (float10)10000.0);
			if ((uint)lVar4 < (uint)lVar5) {
				nerps::NERPs_AddToFloat_00556330(param_2);
			}
		}
		if (liveObj->objType == OBJECT_MINIFIGURE) {
			nerps::NERPs_AddToFloat_00556120(param_2);
		}
		liveObj->health = liveObj->health - param_2;
		if ((param_3 != 0) &&
			 ((ushort)((ushort)(param_2 < 0.0) << 8 | (ushort)(param_2 == 0.0) << 0xe) == 0)) {
			liveObj->flags2 = liveObj->flags2 | 0x3000;
			liveObj->field_3d0 = param_2 + (float)liveObj->field_3d0;
			LiveObject_FUN_00407470(liveObj);
		}
		OVar2 = LiveObject_GetStatsFlags2(liveObj);
		if (((OVar2 & STATS2_DAMAGECAUSESCALLTOARMS) != STATS2_NONE) &&
			 ((ushort)((ushort)(param_2 < 0.0) << 8 | (ushort)(param_2 == 0.0) << 0xe) == 0)) {
			Game_SetCallToArmsOn(1);
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_UnkUpdateEnergyHealth(LiveObject *in_liveObj,float elapsed)
{
	LiveObject *liveObj;
	ObjectStatsFlags2 OVar1;
	LiveObject *liveObj_00;
	uint uVar2;
	int *piVar3;
	float10 fVar4;
	longlong lVar5;
	BOOL BVar6;
	float fVar7;
	float damage;
	void *local_40;
	undefined local_3c [4];
	int local_38;
	int local_34;
	int local_30;
	int local_2c;
	int local_28;
	int local_24;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	liveObj = in_liveObj;
	damage = 0.0;
	if ((in_liveObj->objType != OBJECT_UPGRADEPART) && (in_liveObj->objType != OBJECT_BOULDER)) {
		if ((ushort)((ushort)(in_liveObj->health < 0.0) << 8 |
								(ushort)(in_liveObj->health == 0.0) << 0xe) == 0) {
			if ((in_liveObj->flags3 & LIVEOBJ3_UNK_80000000) == LIVEOBJ3_NONE) {
				BVar6 = 0;
				fVar7 = elapsed;
				fVar4 = LiveObject_GetHealthDecayRate(in_liveObj);
				LiveObject_FUN_0043f960
									(liveObj,(float)(fVar4 * (float10)0.04 * (float10)elapsed),BVar6,fVar7);
			}
		}
		else {
			in_liveObj->health = 0.0;
		}
		uVar2 = 0;
		if ((ushort)((ushort)(liveObj->energy < 0.0) << 8 | (ushort)(liveObj->energy == 0.0) << 0xe) ==
				0) {
			if ((liveObj->flags3 & LIVEOBJ3_UNK_80000000) == LIVEOBJ3_NONE) {
				fVar4 = LiveObject_GetEnergyDecayRate(liveObj);
				liveObj->energy =
						 (float)((float10)liveObj->energy - fVar4 * (float10)0.04 * (float10)elapsed);
			}
		}
		else {
			liveObj->energy = 0.0;
		}
		LiveObject_GetBlockCoordinates(liveObj,&local_38,&local_34);
		if (((liveObj->carryingThisObject == (LiveObject *)0x0) &&
				((globals::g_Game.level)->blocks
				 [((globals::g_Game.level)->dimensions).width * local_34 + local_38].terrain == TERRAIN_LAVA
				)) && ((liveObj->objType == OBJECT_ORE || (liveObj->objType == OBJECT_POWERCRYSTAL)))) {
			Level_AddToField9c(1);
			liveObj->health = -1.0;
			liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
		}
		fVar7 = elapsed;
		BVar6 = LiveObject_UnkGetDamage(liveObj,local_38,local_34,elapsed,&damage);
		if (BVar6 != 0) {
			LiveObject_FUN_0043f960(liveObj,damage,1,fVar7);
		}
		OVar1 = LiveObject_GetStatsFlags2(liveObj);
		if ((((OVar1 & STATS2_CANBEHITBYFENCE) != STATS2_NONE) &&
				((liveObj->flags1 & (LIVEOBJ1_UNK_100|LIVEOBJ1_UNK_100000)) == LIVEOBJ1_NONE)) &&
			 ((liveObj->flags2 & LIVEOBJ2_UNK_8000000) == LIVEOBJ2_NONE)) {
			LiveObject_FUN_0040dd70(liveObj);
		}
		if (((((globals::g_Game.flags2 & GAME2_NOAUTOEAT) == GAME2_NONE) &&
				 (liveObj->objType == OBJECT_MINIFIGURE)) &&
				(((liveObj->energy < liveObj->health * 0.01 * globals::g_Game.MinEnergyForEat &&
					(((ushort)((ushort)(liveObj->activityElapsedTime < 125.0) << 8 |
										(ushort)(liveObj->activityElapsedTime == 125.0) << 0xe) == 0 &&
					 (liveObj->activityElapsedTime = 0.0, liveObj->drivenObject == (LiveObject *)0x0)))) &&
				 (BVar6 = LiveObject_IsCurrentTaskType(liveObj,AITASK_GOTOEAT), BVar6 == 0)))) &&
			 (liveObj_00 = (LiveObject *)FUN_00438f20(liveObj), liveObj_00 != (LiveObject *)0x0)) {
			local_20[1] = 0xffffffff;
			local_8 = 0xffffffff;
			local_20[0] = 0;
			local_20[2] = 1;
			local_20[3] = 0;
			local_20[4] = 0;
			local_c = 1;
			local_4 = 0;
			LiveObject_GetBlockCoordinates(liveObj,&local_28,&local_24);
			LiveObject_GetBlockCoordinates(liveObj_00,&local_30,&local_2c);
			piVar3 = local_20;
			do {
				BVar6 = LiveObject_FUN_004413b0
													(liveObj,local_28,local_24,local_30 + *piVar3,piVar3[1] + local_2c,
													 &in_liveObj,&local_40,local_3c,0,0);
				if (BVar6 != 0) {
					std::free(in_liveObj);
					std::free(local_40);
					ai::AITask_DoGotoEat_Target(liveObj,liveObj_00);
					break;
				}
				uVar2 = uVar2 + 1;
				piVar3 = piVar3 + 2;
			} while (uVar2 < 4);
		}
		if ((ushort)((ushort)(liveObj->energy < liveObj->health) << 8 |
								(ushort)(liveObj->energy == liveObj->health) << 0xe) == 0) {
			liveObj->energy = liveObj->health;
		}
		LiveObject_AddDamage(liveObj,elapsed,damage);
		if (((liveObj->flags2 & 0x2000) != LIVEOBJ2_NONE) &&
			 ((liveObj->flags2 & 0x1000) == LIVEOBJ2_NONE)) {
			lVar5 = __ftol((float10)(float)liveObj->field_3d0);
			FUN_0040a3e0(liveObj,(uint)lVar5);
			liveObj->field_3d0 = 0;
			liveObj->flags2 = liveObj->flags2 & 0xffffdfff;
		}
		liveObj->flags2 = liveObj->flags2 & 0xffffefff;
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_AddDamage(LiveObject *in_liveObj,float elapsed,float damage)
{
	float fVar1;
	float fVar2;
	LiveObject *liveObj;
	BOOL BVar3;
	Container *cont;
	float10 fVar4;
	LiveObject *sfxType;
	BOOL flag4;
	Vector3F *opt_position;
	
	liveObj = in_liveObj;
	if ((in_liveObj->objType == OBJECT_MINIFIGURE) && (damage != 0.0)) {
		BVar3 = snd::SFX_GetType("SND_Hurt",(SFXType *)&in_liveObj);
		if (BVar3 != 0) {
			if (liveObj->floatSnd_3fc == 0.0) {
				opt_position = (Vector3F *)0x0;
				flag4 = 1;
				BVar3 = 0;
				sfxType = in_liveObj;
				cont = LiveObject_GetResource(liveObj);
				res::Res_PlayResourceSound(cont,(SFXType)sfxType,BVar3,flag4,opt_position);
				liveObj->floatSnd_3fc = elapsed + liveObj->floatSnd_3fc;
				fVar4 = snd::Sample_GetRandomDuration((int)in_liveObj);
				liveObj->floatSnd_400 = (float)fVar4;
			}
			else {
				fVar1 = liveObj->floatSnd_3fc - elapsed * -0.04;
				fVar2 = liveObj->floatSnd_400 + liveObj->floatSnd_400;
				liveObj->floatSnd_3fc = fVar1;
				if ((ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) == 0) {
					liveObj->floatSnd_3fc = 0.0;
					liveObj->floatSnd_400 = 0.0;
					return 1;
				}
			}
		}
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_FUN_0043fee0(LiveObject *carriedObj)
{
	LiveObject *liveObj;
	Container *pCVar1;
	SurfaceMap *surfMap;
	BOOL BVar2;
	int iVar3;
	Container *cont;
	float in_x;
	float in_y;
	int *out_x;
	int *out_y;
	int local_2c;
	int local_28;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	liveObj = carriedObj->carryingThisObject;
	if (liveObj != (LiveObject *)0x0) {
		pCVar1 = LiveObject_GetDepositNull(liveObj);
		if (pCVar1 != (Container *)0x0) {
			res::Container_GetPosition(pCVar1,(Container *)0x0,&local_24);
			out_y = &local_28;
			out_x = &local_2c;
			in_x = local_24.x;
			in_y = local_24.y;
			surfMap = GetSurfaceMap();
			BVar2 = SurfaceMap_ToBlockCoordinatesNoZ(surfMap,in_x,in_y,out_x,out_y);
			if (BVar2 != 0) {
				iVar3 = LiveObject_FUN_00431cd0(carriedObj,local_2c,local_28,local_2c,local_28,0);
				if (iVar3 != 0) {
					pCVar1 = LiveObject_GetResource(carriedObj);
					if (pCVar1 != (Container *)0x0) {
						cont = LiveObject_GetResource(liveObj);
						if (cont != (Container *)0x0) {
							carriedObj->carryingThisObject = (LiveObject *)0x0;
							liveObj->carriedObjects[0] = (LiveObject *)0x0;
							liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CARRYING;
							liveObj->numCarriedObjects = 0;
							res::Container_GetPosition(cont,(Container *)0x0,&local_24);
							res::Container_GetOrientation(cont,(Container *)0x0,&local_c,&local_18);
							res::Container_SetPosition(pCVar1,(Container *)0x0,local_24.x,local_24.y,local_24.z);
							res::Container_SetOrientation
												(pCVar1,(Container *)0x0,local_c.x,local_c.y,local_c.z,local_18.x,local_18.y
												 ,local_18.z);
							LiveObject_FUN_00437690(liveObj,1);
							ai::AITask_DoAnimationWait(liveObj);
							LiveObject_SetActivityUnk(carriedObj,ACTIVITY_FLOATOFF,0);
							Game_UpdateSomeAITasks(carriedObj);
							ai::AITask_DoAnimationWait(carriedObj);
							carriedObj->object_2fc = liveObj;
							carriedObj->flags4 = carriedObj->flags4 | LIVEOBJ4_UNK_8000;
							return 1;
						}
					}
				}
			}
		}
	}
	return 0;
}



undefined4 __cdecl FUN_00440080(int *param_1)
{
	ObjectStatsFlags3 OVar1;
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar2;
	int iVar3;
	int *out_x;
	int *out_y;
	int local_14;
	int local_10;
	Vector3F local_c;
	
	OVar1 = lego::game::LiveObject_GetStatsFlags3((LiveObject *)param_1);
	if (((((OVar1 & STATS3_CARRYVEHICLES) != STATS3_NONE) && ((param_1[0xf8] & 0x400U) != 0)) &&
			((int *)param_1[0xc2] != (int *)0x0)) && (*(int *)param_1[0xc2] == 1)) {
		cont = lego::game::LiveObject_GetDepositNull((LiveObject *)param_1);
		if (cont != (Container *)0x0) {
			lego::res::Container_GetPosition(cont,(Container *)0x0,&local_c);
			out_y = &local_10;
			out_x = &local_14;
			surfMap = lego::game::GetSurfaceMap();
			BVar2 = lego::game::SurfaceMap_ToBlockCoordinatesNoZ(surfMap,local_c.x,local_c.y,out_x,out_y);
			if (BVar2 != 0) {
				iVar3 = lego::game::LiveObject_FUN_00431cd0
													((LiveObject *)param_1[0xc2],local_14,local_10,local_14,local_10,1);
				if (iVar3 != 0) {
					return 1;
				}
			}
		}
	}
	return 0;
}



int __cdecl FUN_00440130(int *param_1,float *param_2)
{
	int *liveObj;
	float *liveObj_00;
	ObjectStatsFlags3 OVar1;
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar2;
	BOOL BVar3;
	float *out_x;
	float *out_y;
	uint local_20;
	float local_1c;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	liveObj = param_1;
	BVar3 = 0;
	OVar1 = lego::game::LiveObject_GetStatsFlags3((LiveObject *)param_1);
	liveObj_00 = param_2;
	if ((OVar1 & STATS3_VEHICLECANBECARRIED) != STATS3_NONE) {
		OVar1 = lego::game::LiveObject_GetStatsFlags3((LiveObject *)param_2);
		if (((OVar1 & STATS3_CARRYVEHICLES) != STATS3_NONE) && (liveObj[0xc1] == 0)) {
			lego::game::LiveObject_GetBlockCoordinates
								((LiveObject *)liveObj,(int *)&local_14,(int *)&local_10);
			cont = lego::game::LiveObject_GetDepositNull((LiveObject *)liveObj_00);
			if (cont != (Container *)0x0) {
				lego::res::Container_GetPosition(cont,(Container *)0x0,&local_c);
				out_y = &local_18;
				out_x = &local_1c;
				surfMap = lego::game::GetSurfaceMap();
				BVar2 = lego::game::SurfaceMap_ToBlockCoordinatesNoZ
													(surfMap,local_c.x,local_c.y,(int *)out_x,(int *)out_y);
				if (BVar2 != 0) {
					if ((local_1c == local_14) && (local_18 == local_10)) {
						BVar3 = lego::game::LiveObject_FUN_004419c0
															((LiveObject *)liveObj,1,&local_1c,&local_18,(float *)&local_c);
					}
					else {
						BVar3 = lego::game::LiveObject_FUN_004413b0
															(liveObj,local_14,local_10,local_1c,local_18,&param_1,&param_2,
															 &local_20,0,0);
						if (BVar3 == 0) {
							return 0;
						}
						BVar3 = lego::game::LiveObject_FUN_004419c0
															((LiveObject *)liveObj,local_20,(float *)param_1,param_2,
															 (float *)&local_c);
						std::free(param_1);
						std::free(param_2);
					}
					if (BVar3 != 0) {
						liveObj[0xbf] = (int)liveObj_00;
						*(undefined *)(liveObj[9] + -3 + liveObj[10] * 0x14) = 0x15;
						lego::game::LiveObject_FUN_00437690((LiveObject *)liveObj_00,1);
						return 1;
					}
				}
			}
		}
	}
	return BVar3;
}



undefined4 __cdecl FUN_004402b0(int *param_1)
{
	int *liveObj;
	LiveObject *liveObj_00;
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar1;
	float *out_x;
	float *out_y;
	float *local_24;
	uint local_20;
	float local_1c;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	liveObj = param_1;
	lego::game::LiveObject_GetBlockCoordinates
						((LiveObject *)param_1,(int *)&local_14,(int *)&local_10);
	liveObj_00 = (LiveObject *)FUN_00438ca0((LiveObject *)liveObj,1);
	if ((liveObj_00 != (LiveObject *)0x0) &&
		 (cont = lego::game::LiveObject_GetDepositNull(liveObj_00), cont != (Container *)0x0)) {
		lego::res::Container_GetPosition(cont,(Container *)0x0,&local_c);
		out_y = &local_18;
		out_x = &local_1c;
		surfMap = lego::game::GetSurfaceMap();
		BVar1 = lego::game::SurfaceMap_ToBlockCoordinatesNoZ
											(surfMap,local_c.x,local_c.y,(int *)out_x,(int *)out_y);
		if (BVar1 != 0) {
			if ((local_1c == local_14) && (local_18 == local_10)) {
				BVar1 = lego::game::LiveObject_FUN_004419c0
													((LiveObject *)liveObj,1,&local_1c,&local_18,(float *)&local_c);
			}
			else {
				BVar1 = lego::game::LiveObject_FUN_004413b0
													(liveObj,local_14,local_10,local_1c,local_18,&param_1,&local_24,&local_20,
													 0,0);
				if (BVar1 == 0) {
					return 0;
				}
				BVar1 = lego::game::LiveObject_FUN_004419c0
													((LiveObject *)liveObj,local_20,(float *)param_1,local_24,
													 (float *)&local_c);
				std::free(param_1);
				std::free(local_24);
			}
			if (BVar1 != 0) {
				liveObj[0xbf] = (int)liveObj_00;
				*(undefined *)(liveObj[9] + -3 + liveObj[10] * 0x14) = 0x13;
				return 1;
			}
		}
	}
	return 0;
}



void __cdecl FUN_004403f0(int param_1,int *param_2)
{
	LiveObject *liveObj;
	uint uVar1;
	LiveObject **ppLVar2;
	int local_8;
	int local_4;
	
	uVar1 = 0;
	if (UINT_004ebd5c != 0) {
		ppLVar2 = PTR_ARRAY_004ebbcc;
		do {
			liveObj = *ppLVar2;
			if (((liveObj != (LiveObject *)0x0) &&
					(lego::game::LiveObject_GetBlockCoordinates(liveObj,&local_8,&local_4),
					local_8 == *param_2)) && (local_4 == param_2[1])) {
				liveObj->object_2fc = (LiveObject *)param_1;
				FUN_00444360(liveObj);
				*ppLVar2 = (LiveObject *)0x0;
			}
			uVar1 = uVar1 + 1;
			ppLVar2 = ppLVar2 + 1;
		} while (uVar1 < UINT_004ebd5c);
	}
	return;
}



BOOL __cdecl FUN_00440470(LiveObject *in_liveObj,int param_2)
{
	LiveObject *liveObj;
	LiveObject *pLVar1;
	ObjectStatsFlags1 OVar2;
	Container *pCVar3;
	Container *cont;
	SurfaceMap *pSVar4;
	BOOL BVar5;
	int iVar6;
	float10 fVar7;
	float fVar8;
	float fVar9;
	int *out_x;
	Vector3F *out_x_00;
	int *out_y;
	float *out_y_00;
	int local_28;
	int local_24;
	uint local_20;
	uint local_1c;
	Vector3F local_18;
	Vector3F local_c;
	
	liveObj = in_liveObj->drivenObject;
	OVar2 = lego::game::LiveObject_GetStatsFlags1(in_liveObj);
	if ((OVar2 & STATS1_CANBEDRIVEN) == STATS1_NONE) {
		return 0;
	}
	if (liveObj == (LiveObject *)0x0) {
		return 0;
	}
	if ((*(byte *)&liveObj->flags1 & 1) != 0) {
		return 0;
	}
	pCVar3 = lego::game::LiveObject_GetDepositNull(in_liveObj);
	cont = lego::game::LiveObject_GetResource(liveObj);
	lego::res::Container_GetPosition(pCVar3,(Container *)0x0,&local_18);
	out_y = &local_24;
	out_x = &local_28;
	fVar8 = local_18.x;
	fVar9 = local_18.y;
	pSVar4 = lego::game::GetSurfaceMap();
	BVar5 = lego::game::SurfaceMap_ToBlockCoordinatesNoZ(pSVar4,fVar8,fVar9,out_x,out_y);
	if (BVar5 == 0) {
		return 0;
	}
	OVar2 = lego::game::LiveObject_GetStatsFlags1(in_liveObj);
	if (((OVar2 & STATS1_CROSSLAND) != STATS1_NONE) &&
		 (iVar6 = lego::game::LiveObject_FUN_00431cd0(liveObj,local_28,local_24,local_28,local_24,1),
		 iVar6 != 0)) {
LAB_004405c7:
		in_liveObj->drivenObject = (LiveObject *)0x0;
		liveObj->drivenObject = (LiveObject *)0x0;
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_DRIVING;
		fVar8 = local_18.x;
		fVar9 = local_18.y;
		pSVar4 = lego::game::GetSurfaceMap();
		fVar7 = lego::game::SurfaceMap_GetSurfaceZ(pSVar4,fVar8,fVar9);
		lego::res::Container_SetPosition(cont,(Container *)0x0,local_18.x,local_18.y,(float)fVar7);
		lego::res::Container_SetOrientation(cont,(Container *)0x0,local_c.x,local_c.y,0.0,0.0,0.0,-1.0);
		lego::game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		liveObj->aitaskName2 = (char *)0x0;
		lego::game::Game_UpdateSomeAITasks(liveObj);
		lego::game::LiveObject_SelectedUnits_FUN_00452f10(in_liveObj);
		return 1;
	}
	if ((*(byte *)&in_liveObj->flags4 & 0x40) == 0) {
		if ((param_2 == 0) && (iVar6 = FUN_0043a0d0(in_liveObj,&local_20), iVar6 != 0)) {
			out_y_00 = &local_18.y;
			out_x_00 = &local_18;
			pSVar4 = lego::game::GetSurfaceMap();
			lego::game::SurfaceMap_FUN_0044f900(pSVar4,local_20,local_1c,(float *)out_x_00,out_y_00);
			goto LAB_004405c7;
		}
		OVar2 = lego::game::LiveObject_GetStatsFlags1(in_liveObj);
		if ((OVar2 & STATS1_CROSSLAND) == STATS1_NONE) {
			lego::ai::AITask_DoDock(in_liveObj);
		}
	}
	else {
		pLVar1 = in_liveObj->object_2fc;
		if (((pLVar1 != (LiveObject *)0x0) && (pLVar1->objType == OBJECT_BUILDING)) &&
			 (pCVar3 = lego::res::Building_GetEntranceNull(pLVar1->building), pCVar3 != (Container *)0x0))
		{
			lego::res::Container_GetPosition(pCVar3,(Container *)0x0,&local_18);
			lego::res::Container_GetOrientation(pCVar3,(Container *)0x0,&local_c,(Vector3F *)0x0);
			goto LAB_004405c7;
		}
	}
	return 0;
}



undefined4 __cdecl FUN_00440690(int *param_1,float *param_2)
{
	byte *pbVar1;
	int *piVar2;
	int *liveObj;
	float *liveObj_00;
	ObjectStatsFlags1 OVar3;
	SurfaceMap *pSVar4;
	BOOL BVar5;
	int iVar6;
	byte bVar7;
	Container *cont;
	float *pfVar8;
	float *pfVar9;
	uint local_44;
	uint local_40;
	uint local_3c;
	uint local_38;
	float local_34;
	float local_30;
	float local_2c;
	float local_28;
	Vector3F local_24;
	Vector3F local_18;
	float local_c;
	float local_8 [2];
	
	liveObj_00 = param_2;
	liveObj = param_1;
	cont = (Container *)0x0;
	piVar2 = (int *)param_1[0xbc];
	if (piVar2 != (int *)0x0) {
		if (*piVar2 != 0x12) {
			return 0;
		}
		if (piVar2[0x18] != 0) {
			return 0;
		}
	}
	if (param_1[0xdb] != 0) {
		return 0;
	}
	if (param_2[0xdb] != 0.0) {
		return 0;
	}
	if (*param_1 != 2) {
		return 0;
	}
	if (((((param_1[0xfc] & 5U) == 0) ||
			 (OVar3 = lego::game::LiveObject_GetStatsFlags1((LiveObject *)param_2),
			 (OVar3 & STATS1_CROSSLAND) == STATS1_NONE)) ||
			(OVar3 = lego::game::LiveObject_GetStatsFlags1((LiveObject *)liveObj_00),
			(OVar3 & STATS1_CANBEDRIVEN) == STATS1_NONE)) || ((*(byte *)(liveObj_00 + 0xfb) & 0x40) != 0))
	{
		if ((*(byte *)(liveObj + 0xfc) & 2) != 0) {
			OVar3 = lego::game::LiveObject_GetStatsFlags1((LiveObject *)liveObj_00);
			if ((((OVar3 & STATS1_CANBEDRIVEN) == STATS1_NONE) ||
					((*(byte *)(liveObj_00 + 0xfb) & 0x40) == 0)) ||
				 ((piVar2 = (int *)liveObj_00[0xbf], piVar2 == (int *)0x0 || (*piVar2 != 4)))) {
				if ((((*(byte *)(liveObj + 0xfc) & 2) != 0) &&
						(OVar3 = lego::game::LiveObject_GetStatsFlags1((LiveObject *)liveObj_00),
						(OVar3 & STATS1_CANBEDRIVEN) != STATS1_NONE)) &&
					 (iVar6 = FUN_0043a100(liveObj_00,(uint *)0x0), iVar6 != 0)) {
					lego::game::LiveObject_GetBlockCoordinates
										((LiveObject *)liveObj_00,(int *)&local_40,(int *)&local_44);
					BVar5 = lego::game::LiveObject_FUN_00446c80
														((LiveObject *)liveObj,local_40,local_44,0,&local_3c,1);
					if (BVar5 != 0) {
						*(undefined4 *)(liveObj[9] + -8 + liveObj[10] * 0x14) = 0x3f000000;
						*(undefined4 *)(liveObj[9] + -0xc + liveObj[10] * 0x14) = 0x3f000000;
						switch(local_3c) {
						case 0:
							*(undefined4 *)(liveObj[9] + -8 + liveObj[10] * 0x14) = 0x3dcccccd;
							break;
						case 1:
							*(undefined4 *)(liveObj[9] + -0xc + liveObj[10] * 0x14) = 0x3dcccccd;
							break;
						case 2:
							*(undefined4 *)(liveObj[9] + -8 + liveObj[10] * 0x14) = 0x3f666666;
							break;
						case 3:
							*(undefined4 *)(liveObj[9] + -0xc + liveObj[10] * 0x14) = 0x3f666666;
						}
						*(byte *)(liveObj[9] + -4 + liveObj[10] * 0x14) =
								 *(byte *)(liveObj[9] + -4 + liveObj[10] * 0x14) | 8;
						*(undefined *)(liveObj[9] + -3 + liveObj[10] * 0x14) = 0xc;
						liveObj[0xbf] = (int)liveObj_00;
						return 1;
					}
				}
			}
			else {
				cont = lego::res::Building_GetEntranceNull((BuildingData *)piVar2[6]);
			}
		}
	}
	else {
		cont = lego::game::LiveObject_GetResource((LiveObject *)liveObj_00);
	}
	if (cont != (Container *)0x0) {
		lego::res::Container_GetPosition(cont,(Container *)0x0,&local_18);
		lego::res::Container_GetOrientation(cont,(Container *)0x0,&local_24,(Vector3F *)0x0);
		if (ABS(local_24.x) <= ABS(local_24.y)) {
			if ((ushort)((ushort)(local_24.y < 0.0) << 8 | (ushort)(local_24.y == 0.0) << 0xe) == 0) {
				bVar7 = 0;
			}
			else {
				bVar7 = 2;
			}
		}
		else {
			if ((ushort)((ushort)(local_24.x < 0.0) << 8 | (ushort)(local_24.x == 0.0) << 0xe) == 0) {
				bVar7 = 1;
			}
			else {
				bVar7 = 3;
			}
		}
		pfVar9 = &local_30;
		pfVar8 = &local_34;
		pSVar4 = lego::game::GetSurfaceMap();
		lego::game::SurfaceMap_ToBlockCoordinatesNoZ
							(pSVar4,local_18.x,local_18.y,(int *)pfVar8,(int *)pfVar9);
		lego::game::LiveObject_GetPosition((LiveObject *)liveObj,&local_c,local_8);
		pfVar9 = &local_28;
		pfVar8 = &local_2c;
		pSVar4 = lego::game::GetSurfaceMap();
		lego::game::SurfaceMap_ToBlockCoordinatesNoZ
							(pSVar4,local_c,local_8[0],(int *)pfVar8,(int *)pfVar9);
		if ((local_2c == local_34) && (local_28 == local_30)) {
			BVar5 = lego::game::LiveObject_FUN_004419c0
												((LiveObject *)liveObj,1,&local_34,&local_30,(float *)&local_18);
		}
		else {
			BVar5 = lego::game::LiveObject_FUN_004413b0
												(liveObj,local_2c,local_28,local_34,local_30,&param_1,&param_2,&local_38,0,0
												);
			if (BVar5 == 0) {
				return 0;
			}
			BVar5 = lego::game::LiveObject_FUN_004419c0
												((LiveObject *)liveObj,local_38,(float *)param_1,param_2,(float *)&local_18)
			;
			std::free(param_1);
			std::free(param_2);
		}
		if (BVar5 != 0) {
			liveObj[0xbf] = (int)liveObj_00;
			*(undefined *)(liveObj[9] + -3 + liveObj[10] * 0x14) = 0xc;
			*(byte *)(liveObj[9] + -4 + liveObj[10] * 0x14) =
					 *(byte *)(liveObj[9] + -4 + liveObj[10] * 0x14) | 4;
			pbVar1 = (byte *)(liveObj[9] + -4 + liveObj[10] * 0x14);
			*pbVar1 = *pbVar1 | bVar7;
			return 1;
		}
	}
	return 0;
}



void __cdecl
FUN_00440a70(LiveObject *liveObj,VehicleData *param_2,CreatureData *param_3,CreatureData *param_4)
{
	LiveObject *local_18;
	float local_14;
	float local_10;
	VehicleData *local_c;
	CreatureData *local_8;
	CreatureData *local_4;
	
	local_18 = liveObj;
	lego::game::LiveObject_GetPosition(liveObj,&local_14,&local_10);
	local_c = param_2;
	local_8 = param_3;
	local_4 = param_4;
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00440ac0,(LiveObject *)&local_18);
	return;
}



undefined4 __cdecl FUN_00440ac0(LiveObject *param_1,LiveObject **param_2)
{
	float fVar1;
	float local_8;
	float local_4;
	
	if ((param_1 != *param_2) && ((param_1->flags3 & 0x40000) != LIVEOBJ3_NONE)) {
		lego::game::LiveObject_GetPosition(param_1,&local_8,&local_4);
		fVar1 = SQRT((local_8 - (float)param_2[1]) * (local_8 - (float)param_2[1]) +
								 (local_4 - (float)param_2[2]) * (local_4 - (float)param_2[2]));
		if (fVar1 < (float)param_2[3]) {
			lego::game::LiveObject_FUN_0043f960
								(param_1,(1.0 - fVar1 / (float)param_2[3]) * (float)param_2[4],1,1.0);
		}
		if ((param_1->objType == OBJECT_ROCKMONSTER) && (fVar1 < (float)param_2[5])) {
			lego::game::LiveObject_RockMonster_DoWakeUp(param_1);
		}
	}
	return 0;
}



void __cdecl FUN_00440b80(undefined4 *param_1,undefined4 *param_2,VehicleData *param_3)
{
	undefined4 *local_18;
	float local_14;
	char *local_10;
	VehicleData *local_c;
	
	local_18 = param_1;
	if (param_2 == (undefined4 *)0x0) {
		lego::game::LiveObject_GetPosition((LiveObject *)param_1,&local_14,(float *)&local_10);
	}
	else {
		local_14 = (float)*param_2;
		local_10 = (char *)param_2[1];
	}
	local_c = param_3;
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00440be0,(LiveObject *)&local_18);
	return;
}



undefined4 __cdecl FUN_00440be0(LiveObject *param_1,LiveObject **param_2)
{
	float fVar1;
	ObjectStatsFlags2 OVar2;
	Point2F local_10;
	float local_8;
	float local_4;
	
	if (param_1 != *param_2) {
		OVar2 = lego::game::LiveObject_GetStatsFlags2(param_1);
		if ((OVar2 & STATS2_SCAREDBYBIGBANGS) != STATS2_NONE) {
			lego::game::LiveObject_GetPosition(param_1,&local_8,&local_4);
			local_10.x = local_8 - (float)param_2[1];
			local_10.y = local_4 - (float)param_2[2];
			fVar1 = SQRT(local_10.y * local_10.y + local_10.x * local_10.x);
			if (fVar1 < (float)param_2[3]) {
				if (param_1->objType == OBJECT_ROCKMONSTER) {
					lego::game::LiveObject_RockMonster_DoWakeUp(param_1);
				}
				fVar1 = 1.0 / fVar1;
				local_10.x = fVar1 * local_10.x;
				local_10.y = fVar1 * local_10.y;
				lego::game::LiveObject_FUN_00444720(param_1,&local_10);
			}
		}
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_SetActivityUnk(LiveObject *liveObj,ActivityType actType,BOOL actData)
{
	liveObj->aitaskName1 = globals::g_Activities_TABLE[actType];
	liveObj->unkbool_2d8 = actData;
	liveObj->float_2d4 = 0.0;
	return;
}



void __cdecl lego::game::LiveObject_UpdateCarrying(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	ObjectType OVar1;
	float fVar2;
	float fVar3;
	LiveObject *pLVar4;
	int iVar5;
	Container *cont;
	VehicleData *vehicle;
	LiveObject **local_14;
	uint local_10;
	Vector3F local_c;
	
	local_10 = 0;
	if (in_liveObj->numCarriedObjects != 0) {
		local_14 = in_liveObj->carriedObjects;
		pLVar4 = in_liveObj;
		do {
			liveObj = *local_14;
			if ((liveObj->flags3 & 0x2000) == LIVEOBJ3_NONE) {
				OVar1 = in_liveObj->objType;
				if (OVar1 == OBJECT_ROCKMONSTER) {
					pLVar4 = (LiveObject *)res::Creature_GetCarryNull(in_liveObj->rockMonster);
				}
				else {
					if (OVar1 == OBJECT_MINIFIGURE) {
						pLVar4 = in_liveObj->drivenObject;
						if ((pLVar4 == (LiveObject *)0x0) || (pLVar4->objType != OBJECT_VEHICLE)) {
							pLVar4 = (LiveObject *)res::Creature_GetCarryNull(in_liveObj->miniFigure);
						}
						else {
							iVar5 = LiveObject_GetCarryStart(pLVar4);
							vehicle = in_liveObj->drivenObject->vehicle;
LAB_00440d93:
							pLVar4 = (LiveObject *)res::Vehicle_GetCarryNull(vehicle,iVar5);
						}
					}
					else {
						if (OVar1 == OBJECT_BUILDING) {
							pLVar4 = (LiveObject *)
											 res::Building_GetCarryNull
																 (in_liveObj->building,(int)liveObj->carriedObjects[6]);
						}
						else {
							if (OVar1 == OBJECT_VEHICLE) {
								iVar5 = LiveObject_GetCarryStart(in_liveObj);
								vehicle = in_liveObj->vehicle;
								iVar5 = (int)liveObj->carriedObjects[6]->floats_34 + iVar5 + -0x34;
								goto LAB_00440d93;
							}
						}
					}
				}
				if (pLVar4 != (LiveObject *)0x0) {
					cont = LiveObject_GetResource(liveObj);
					res::Container_GetPosition(cont,(Container *)0x0,&liveObj->vector_2a0);
					res::Container_SetPosition(cont,(Container *)pLVar4,0.0,0.0,0.0);
					res::Container_SetOrientation(cont,(Container *)pLVar4,0.0,0.0,1.0,0.0,1.0,0.0);
					res::Container_GetPosition(cont,(Container *)0x0,&local_c);
					local_c.x = local_c.x - (liveObj->vector_2a0).x;
					local_c.y = local_c.y - (liveObj->vector_2a0).y;
					local_c.z = local_c.z - (liveObj->vector_2a0).z;
					fVar2 = SQRT(local_c.z * local_c.z + local_c.y * local_c.y + local_c.x * local_c.x);
					fVar3 = 1.0 / fVar2;
					liveObj->float_2b8 = fVar2;
					(liveObj->faceDirection).x = fVar3 * local_c.x;
					(liveObj->faceDirection).y = fVar3 * local_c.y;
					(liveObj->faceDirection).z = fVar3 * local_c.z;
				}
			}
			local_10 = local_10 + 1;
			local_14 = local_14 + 1;
		} while (local_10 < in_liveObj->numCarriedObjects);
	}
	return;
}



void __cdecl
lego::game::LiveObject_InitBoulderMesh_FUN_00440eb0(LiveObject *liveObj,undefined **param_2)
{
	D3DRMGroupIndex DVar1;
	D3DRMGroupIndex groupID;
	
	if (liveObj->objType == OBJECT_BOULDER) {
		DVar1 = res::Container_Mesh_GetGroupCount(liveObj->other);
		groupID = D3DRMGROUP_0;
		if (DVar1 != D3DRMGROUP_0) {
			do {
				res::Container_Mesh_SetTexture(liveObj->other,groupID,(Container_Texture *)param_2);
				groupID = groupID + 1;
			} while (groupID < DVar1);
		}
	}
	return;
}



void FUN_00440ef0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
								 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8)
{
	lego::game::LiveObject_FUN_004413b0
						(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,0,0);
	return;
}



BOOL __cdecl
FUN_00440f30(int *param_1,uint param_2,uint param_3,uint param_4,uint param_5,uint **param_6,
						uint **param_7,uint *param_8,undefined *param_9,undefined4 param_10)
{
	uint uVar1;
	uint uVar2;
	uint uVar3;
	SurfaceMap *pSVar4;
	int iVar5;
	int iVar6;
	uint uVar7;
	uint *puVar8;
	uint *puVar9;
	int iVar10;
	void *pvVar11;
	uint uVar12;
	uint uVar13;
	undefined4 *puVar14;
	uint uVar15;
	uint *local_ff0;
	uint local_fec;
	uint *local_fe8;
	uint local_fe4;
	uint local_fe0;
	uint local_fdc;
	uint local_fd0 [4];
	uint local_fc0 [9];
	uint local_f9c;
	
	local_fc0[0] = 0;
	local_fc0[1] = 0xffffffff;
	local_fc0[2] = 1;
	local_fc0[3] = 0;
	local_fc0[4] = 0;
	local_fc0[5] = 1;
	local_fc0[6] = 0xffffffff;
	local_fc0[7] = 0;
	local_fec = 0;
	pSVar4 = lego::game::GetSurfaceMap();
	uVar1 = (pSVar4->smallDimensions).width;
	uVar2 = (pSVar4->smallDimensions).height;
	if (uVar1 <= param_2) {
		return 0;
	}
	if (uVar2 <= param_3) {
		return 0;
	}
	if (param_9 == (undefined *)0x0) {
		if (uVar1 <= param_4) {
			return 0;
		}
		if (uVar2 <= param_5) {
			return 0;
		}
		iVar5 = lego::game::LiveObject_FUN_00431cd0
											((LiveObject *)param_1,param_4,param_5,param_4,param_5,0);
		if (iVar5 == 0) {
			return 0;
		}
	}
	if (lego::globals::g_UnkSurfaceGrid_2_TABLE != (void *)0x0) {
		if (lego::globals::g_UnkSurfaceGrid_COUNT == uVar2 * uVar1) goto LAB_00441021;
		if (lego::globals::g_UnkSurfaceGrid_2_TABLE != (void *)0x0) {
			std::free(lego::globals::g_UnkSurfaceGrid_2_TABLE);
		}
	}
	lego::globals::g_UnkSurfaceGrid_COUNT = uVar2 * uVar1;
	lego::globals::g_UnkSurfaceGrid_2_TABLE = std::malloc(lego::globals::g_UnkSurfaceGrid_COUNT * 4);
LAB_00441021:
	iVar5 = uVar2 * uVar1;
	puVar14 = (undefined4 *)lego::globals::g_UnkSurfaceGrid_2_TABLE;
	if (lego::globals::g_UnkSurfaceGrid_2_TABLE != (void *)0x0) {
		for (; iVar5 != 0; iVar5 = iVar5 + -1) {
			*puVar14 = 0;
			puVar14 = puVar14 + 1;
		}
		local_fe4 = 0;
		local_f9c = param_3;
		*(undefined4 *)((int)lego::globals::g_UnkSurfaceGrid_2_TABLE + (uVar1 * param_3 + param_2) * 4)
				 = 1;
		local_ff0 = local_fd0;
		local_fc0[8] = param_2;
		local_fd0[0] = 1;
		local_fd0[1] = 0;
		uVar12 = 1;
		do {
			local_fe0 = uVar12;
			uVar12 = local_fe0 + 1;
			local_fdc = 0;
			if (*local_ff0 != 0) {
				iVar5 = 0;
				local_fe8 = local_fc0 + local_fe4 * 500 + 9;
				while( true ) {
					do {
						uVar13 = local_fe8[-1];
						uVar15 = *local_fe8;
						if (iVar5 == 0) {
							uVar15 = uVar15 - 1;
						}
						else {
							if (iVar5 == 1) {
								uVar13 = uVar13 + 1;
							}
							else {
								if (iVar5 == 2) {
									uVar15 = uVar15 + 1;
								}
								else {
									if (iVar5 == 3) {
										uVar13 = uVar13 - 1;
									}
								}
							}
						}
						if ((uVar13 < uVar1) && (uVar15 < uVar2)) {
							iVar6 = lego::game::LiveObject_FUN_00431cd0
																((LiveObject *)param_1,uVar13,uVar15,local_fc0[iVar5 * 2] + uVar13,
																 local_fc0[iVar5 * 2 + 1] + uVar15,0);
							iVar10 = uVar15 * uVar1 + uVar13;
							if ((*(int *)((int)lego::globals::g_UnkSurfaceGrid_2_TABLE + iVar10 * 4) == 0) &&
								 (iVar6 != 0)) {
								uVar7 = (uint)(local_fe4 == 0);
								uVar3 = local_fd0[uVar7];
								iVar6 = uVar3 + uVar7 * 100;
								local_fc0[iVar6 * 5 + 8] = uVar13;
								local_fc0[iVar6 * 5 + 9] = uVar15;
								local_fd0[uVar7] = uVar3 + 1;
								*(uint *)((int)lego::globals::g_UnkSurfaceGrid_2_TABLE + iVar10 * 4) = uVar12;
								if (param_9 == (undefined *)0x0) {
									if ((uVar13 == param_4) && (uVar15 == param_5)) {
										local_fec = 1;
									}
								}
								else {
									local_fd0[2] = uVar13;
									local_fd0[3] = uVar15;
									iVar6 = (*(code *)param_9)(param_1,local_fd0 + 2,param_10);
									if (iVar6 != 0) {
										local_fec = 1;
										param_4 = uVar13;
										param_5 = uVar15;
									}
								}
							}
						}
						iVar5 = iVar5 + 1;
					} while (iVar5 < 4);
					local_fdc = local_fdc + 1;
					local_fe8 = local_fe8 + 5;
					if (*local_ff0 <= local_fdc) break;
					iVar5 = 0;
				}
			}
			iVar5 = 0;
			*local_ff0 = 0;
			local_fe4 = (uint)(local_fe4 == 0);
			local_ff0 = local_fd0 + local_fe4;
			if (local_fd0[local_fe4] == 0) {
				local_fec = -1;
			}
		} while (local_fec == 0);
		if (local_fec == -1) {
			return 0;
		}
		local_fd0[0] = uVar12;
		puVar8 = (uint *)std::malloc(uVar12 * 4);
		if ((puVar8 != (uint *)0x0) && (puVar9 = (uint *)std::malloc(uVar12 * 4), puVar9 != (uint *)0x0)
			 ) {
			local_fec = param_5;
			local_ff0 = puVar9 + local_fe0;
			puVar8[local_fe0] = param_4;
			*local_ff0 = param_5;
			*puVar8 = param_2;
			*puVar9 = param_3;
			if (local_fe0 != 1) {
				pvVar11 = lego::globals::g_UnkSurfaceGrid_2_TABLE;
				do {
					local_fdc = 0;
					uVar12 = param_5;
					do {
						uVar13 = param_4;
						if (iVar5 == 0) {
							param_5 = uVar12 - 1;
						}
						else {
							param_5 = uVar12;
							if (iVar5 == 1) {
								uVar13 = param_4 + 1;
							}
							else {
								if (iVar5 == 2) {
									param_5 = uVar12 + 1;
								}
								else {
									if (iVar5 == 3) {
										uVar13 = param_4 - 1;
									}
								}
							}
						}
						if (((uVar13 < uVar1) && (param_5 < uVar2)) &&
							 (uVar12 = local_fec,
							 *(uint *)((int)pvVar11 + (param_5 * uVar1 + uVar13) * 4) == local_fe0)) {
							*(uint *)((int)puVar8 + (-4 - (int)puVar9) + (int)local_ff0) = uVar13;
							local_ff0[-1] = param_5;
							pvVar11 = lego::globals::g_UnkSurfaceGrid_2_TABLE;
							param_4 = uVar13;
							local_fec = param_5;
							break;
						}
						param_5 = uVar12;
						iVar5 = iVar5 + 1;
						if (3 < iVar5) {
							iVar5 = 0;
						}
						local_fdc = local_fdc + 1;
						uVar12 = param_5;
					} while ((int)local_fdc < 4);
					local_fe0 = local_fe0 - 1;
					local_ff0 = local_ff0 + -1;
				} while (local_fe0 != 1);
			}
			*param_6 = puVar8;
			*param_7 = puVar9;
			*param_8 = local_fd0[0];
		}
	}
	return 1;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

BOOL lego::game::LiveObject_FUN_004413b0
							 (LiveObject *liveObj,uint bx,uint by,uint param_4,uint param_5,uint **param_6,
							 uint **param_7,float *param_8,code *callback,undefined4 param_10)
{
	float *pfVar1;
	float fVar2;
	float fVar3;
	int iVar4;
	float fVar5;
	bool bVar6;
	SurfaceMap *pSVar7;
	int iVar8;
	BOOL BVar9;
	uint uVar10;
	uint *puVar11;
	uint *buffer;
	uint uVar12;
	uint uVar13;
	uint uVar14;
	uint uVar15;
	undefined4 *puVar16;
	uint uVar17;
	int iStack4108;
	uint *puStack4104;
	uint uStack4096;
	float fStack4092;
	float fStack4088;
	uint *puStack4080;
	int iStack4076;
	uint uStack4068;
	uint auStack4060 [2];
	float fStack4052;
	Point2I PStack4048;
	Point2I PStack4040;
	int aiStack4032 [4];
	undefined4 uStack4016;
	undefined4 uStack4012;
	undefined4 uStack4008;
	undefined4 uStack4004;
	uint auStack4000 [999];
	undefined4 uStack4;
	
	uStack4 = 0x4413ba;
	aiStack4032[0] = 0;
	aiStack4032[1] = 0xffffffff;
	aiStack4032[2] = 1;
	aiStack4032[3] = 0;
	uStack4016 = 0;
	uStack4012 = 1;
	uStack4008 = 0xffffffff;
	uStack4004 = 0;
	iStack4076 = 0;
	bVar6 = false;
	pSVar7 = GetSurfaceMap();
	uVar12 = (pSVar7->smallDimensions).width;
	uVar13 = (pSVar7->smallDimensions).height;
	if (uVar12 <= bx) {
		return 0;
	}
	if (uVar13 <= by) {
		return 0;
	}
	if (callback == (code *)0x0) {
		if (uVar12 <= param_4) {
			return 0;
		}
		if (uVar13 <= param_5) {
			return 0;
		}
		iVar8 = LiveObject_FUN_00431cd0(liveObj,param_4,param_5,param_4,param_5,0);
		if (iVar8 == 0) {
			return 0;
		}
	}
	if (globals::g_UnkSurfaceGrid_1_TABLE != (void *)0x0) {
		if (globals::g_UnkSurfaceGrid_COUNT == uVar13 * uVar12) goto LAB_004414be;
		if (globals::g_UnkSurfaceGrid_1_TABLE != (void *)0x0) {
			std::free(globals::g_UnkSurfaceGrid_1_TABLE);
		}
	}
	globals::g_UnkSurfaceGrid_COUNT = uVar13 * uVar12;
	globals::g_UnkSurfaceGrid_1_TABLE = std::malloc(globals::g_UnkSurfaceGrid_COUNT * 4);
LAB_004414be:
	iVar8 = uVar13 * uVar12;
	puVar16 = (undefined4 *)globals::g_UnkSurfaceGrid_1_TABLE;
	if (globals::g_UnkSurfaceGrid_1_TABLE != (void *)0x0) {
		for (; iVar8 != 0; iVar8 = iVar8 + -1) {
			*puVar16 = 0;
			puVar16 = puVar16 + 1;
		}
		fStack4092 = 1.401298e-45;
		auStack4060[0] = 1;
		puStack4104 = auStack4060;
		uStack4096 = 0;
		*(undefined4 *)((int)globals::g_UnkSurfaceGrid_1_TABLE + (uVar12 * by + bx) * 4) = 0x3f800000;
		auStack4000[0] = bx;
		auStack4000[1] = by;
		auStack4060[1] = 0;
		do {
			fStack4092 = (float)((int)fStack4092 + 1);
			uStack4068 = 0;
			if (*puStack4104 != 0) {
				puVar11 = auStack4000 + uStack4096 * 500 + 1;
				do {
					fVar2 = *(float *)((int)globals::g_UnkSurfaceGrid_1_TABLE +
														(uVar12 * *puVar11 + puVar11[-1]) * 4);
					iStack4108 = 0;
					do {
						uVar14 = puVar11[-1];
						uVar17 = *puVar11;
						if (iStack4108 == 0) {
							uVar17 = uVar17 - 1;
						}
						else {
							if (iStack4108 == 1) {
								uVar14 = uVar14 + 1;
							}
							else {
								if (iStack4108 == 2) {
									uVar17 = uVar17 + 1;
								}
								else {
									if (iStack4108 == 3) {
										uVar14 = uVar14 - 1;
									}
								}
							}
						}
						if ((uVar14 < uVar12) && (uVar17 < uVar13)) {
							fStack4088 = 1.0;
							iVar8 = aiStack4032[iStack4108 * 2];
							iVar4 = aiStack4032[iStack4108 * 2 + 1];
							PStack4040.x = iVar8 + uVar14;
							PStack4040.y = iVar4 + uVar17;
							BVar9 = Level_IsBlockPowerPath(&PStack4040);
							if (BVar9 != 0) {
								fStack4088 = 0.5;
							}
							iVar8 = LiveObject_FUN_00431cd0(liveObj,uVar14,uVar17,iVar8 + uVar14,iVar4 + uVar17,0)
							;
							if ((iVar8 != 0) &&
								 ((iVar8 = uVar17 * uVar12 + uVar14,
									pfVar1 = (float *)((int)globals::g_UnkSurfaceGrid_1_TABLE + iVar8 * 4),
									*(float *)((int)globals::g_UnkSurfaceGrid_1_TABLE + iVar8 * 4) == 0.0 ||
									(fVar5 = fStack4088 + fVar2, fVar3 = *pfVar1,
									(ushort)((ushort)(fVar3 < fVar5) << 8 | (ushort)(fVar3 == fVar5) << 0xe) == 0))))
							{
								uVar10 = (uint)(uStack4096 == 0);
								uVar15 = auStack4060[uVar10];
								iVar8 = uVar15 + uVar10 * 100;
								*pfVar1 = fStack4088 + fVar2;
								auStack4000[iVar8 * 5] = uVar14;
								auStack4000[iVar8 * 5 + 1] = uVar17;
								auStack4060[uVar10] = uVar15 + 1;
								if (callback == (code *)0x0) {
									if ((uVar14 == param_4) && (uVar17 == param_5)) {
										bVar6 = true;
										fStack4052 = fStack4092;
									}
								}
								else {
									PStack4048.x = uVar14;
									PStack4048.y = uVar17;
									iVar8 = (*callback)(liveObj,&PStack4048,param_10);
									if (iVar8 != 0) {
										iStack4076 = 1;
										param_4 = uVar14;
										param_5 = uVar17;
									}
								}
							}
						}
						iStack4108 = iStack4108 + 1;
					} while (iStack4108 < 4);
					uStack4068 = uStack4068 + 1;
					puVar11 = puVar11 + 5;
				} while (uStack4068 < *puStack4104);
			}
			*puStack4104 = 0;
			uStack4096 = (uint)(uStack4096 == 0);
			puStack4104 = auStack4060 + uStack4096;
			if (auStack4060[uStack4096] == 0) {
				iStack4076 = -1;
			}
		} while (iStack4076 == 0);
		if (bVar6) {
			iStack4076 = 1;
			fStack4092 = fStack4052;
		}
		if (iStack4076 == -1) {
			return 0;
		}
		puVar11 = (uint *)std::malloc((int)fStack4092 * 4);
		if ((puVar11 != (uint *)0x0) &&
			 (buffer = (uint *)std::malloc((int)fStack4092 * 4), buffer != (uint *)0x0)) {
			iVar8 = (int)fStack4092 + -1;
			puVar11[iVar8] = param_4;
			puStack4080 = buffer + iVar8;
			*puStack4080 = param_5;
			*puVar11 = bx;
			*buffer = by;
			if (iVar8 != 1) {
				uStack4068 = (int)fStack4092 + -2;
				uVar14 = param_4;
				uVar17 = param_5;
				do {
					puStack4104 = (uint *)0x461c4000;
					iStack4108 = 0;
					do {
						uVar15 = uVar14;
						if (iStack4108 == 0) {
							uVar10 = uVar17 - 1;
						}
						else {
							uVar10 = uVar17;
							if (iStack4108 == 1) {
								uVar15 = uVar14 + 1;
							}
							else {
								if (iStack4108 == 2) {
									uVar10 = uVar17 + 1;
								}
								else {
									if (iStack4108 == 3) {
										uVar15 = uVar14 - 1;
									}
								}
							}
						}
						PStack4048.x = uVar15;
						PStack4048.y = uVar10;
						if (((uVar15 < uVar12) && (uVar10 < uVar13)) &&
							 (((fStack4052 = *(float *)((int)globals::g_UnkSurfaceGrid_1_TABLE +
																				 (uVar17 * uVar12 + uVar14) * 4) -
															 *(float *)((int)globals::g_UnkSurfaceGrid_1_TABLE +
																				 (uVar10 * uVar12 + uVar15) * 4),
								 (ushort)((ushort)(fStack4052 < 0.0) << 8 | (ushort)(fStack4052 == 0.0) << 0xe) == 0
								 && (fStack4052 < (float)puStack4104)) ||
								((fStack4052 == (float)puStack4104 &&
								 (BVar9 = Level_IsBlockPowerPath(&PStack4048), BVar9 != 0)))))) {
							puStack4104 = (uint *)fStack4052;
							auStack4060[0] = uVar15;
							auStack4060[1] = uVar10;
						}
						iStack4108 = iStack4108 + 1;
					} while (iStack4108 < 4);
					puStack4080 = puStack4080 + -1;
					*(uint *)((int)((int)puVar11 - (int)buffer) + (int)puStack4080) = auStack4060[0];
					*puStack4080 = auStack4060[1];
					uStack4068 = uStack4068 + -1;
					uVar14 = auStack4060[0];
					uVar17 = auStack4060[1];
				} while (uStack4068 != 0);
			}
			*param_6 = puVar11;
			*param_7 = buffer;
			*param_8 = fStack4092;
			if (((*puVar11 != puVar11[1]) ||
					(uVar12 = (int)(*buffer - buffer[1]) >> 0x1f, (*buffer - buffer[1] ^ uVar12) - uVar12 != 1
					)) && ((*buffer != buffer[1] ||
								 (uVar12 = *puVar11 - puVar11[1], uVar13 = (int)uVar12 >> 0x1f,
								 (uVar12 ^ uVar13) - uVar13 != 1)))) {
				std::free(puVar11);
				std::free(buffer);
				BVar9 = FUN_00440f30((int *)liveObj,bx,by,param_4,param_5,param_6,param_7,(uint *)param_8,
														 callback,param_10);
				return BVar9;
			}
		}
	}
	return 1;
}



BOOL __cdecl
lego::game::LiveObject_FUN_004419c0
					(LiveObject *liveObj,uint param_2,float *param_3,float *param_4,float *param_5)
{
	bool bVar1;
	BOOL BVar2;
	void *buffer;
	SurfaceMap *surfMap;
	ObjectStatsFlags1 OVar3;
	int iVar4;
	int iVar5;
	float *pfVar6;
	float *pfVar7;
	float *pfVar8;
	float10 fVar9;
	Point2F *pPVar10;
	Point2F *pPVar11;
	Point2F *pPVar12;
	uint local_1c;
	int local_14;
	Point2F local_8;
	
	BVar2 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj);
	if (BVar2 == 0) {
		local_14 = -1;
		bVar1 = false;
		local_8.x = 0.5;
		local_8.y = 0.5;
		if ((liveObj->flags4 & LIVEOBJ4_UNK_40) != LIVEOBJ4_NONE) {
			liveObj->object_2fc = (LiveObject *)0x0;
			liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_40;
		}
		buffer = std::malloc(param_2 * 0x14);
		if ((buffer != (void *)0x0) && (local_1c = 0, param_2 != 0)) {
			pfVar7 = (float *)((int)buffer + 8);
			pfVar6 = (float *)((int)param_4 - (int)param_3);
			do {
				pfVar8 = param_3 + 1;
				pfVar7[-2] = *param_3;
				pfVar7[-1] = *param_4;
				if ((param_5 == (float *)0x0) || (local_1c != param_2 - 1)) {
					if (((liveObj->flags3 & 0x1000) == LIVEOBJ3_NONE) &&
						 (OVar3 = LiveObject_GetStatsFlags1(liveObj),
						 (OVar3 & STATS1_ROUTEAVOIDANCE) != STATS1_NONE)) {
						fVar9 = math::Maths_RandRange(0.3,0.7);
						*pfVar7 = (float)fVar9;
						fVar9 = math::Maths_RandRange(0.3,0.7);
						pfVar7[1] = (float)fVar9;
					}
					else {
						pfVar7[1] = 0.5;
						*pfVar7 = 0.5;
					}
				}
				else {
					pPVar12 = &local_8;
					pPVar11 = (Point2F *)0x0;
					pPVar10 = (Point2F *)param_5;
					surfMap = GetSurfaceMap();
					SurfaceMap_FUN_0044fb30(surfMap,pPVar10,pPVar11,pPVar12);
					*pfVar7 = local_8.x;
					pfVar7[1] = local_8.y;
				}
				*(undefined *)(pfVar7 + 2) = 0;
				*(undefined *)((int)pfVar7 + 9) = 0;
				iVar4 = local_14;
				if (local_1c < param_2 - 1) {
					iVar4 = unk::Lego_CheckComparison_FUN_00450b60
														((int)*pfVar8,*(int *)((int)pfVar6 + (int)pfVar8),(int)*param_3,
														 (int)*param_4);
					if (iVar4 == -1) {
						bVar1 = true;
						break;
					}
					if (((local_1c != 0) && (local_14 != iVar4)) &&
						 (iVar5 = LiveObject_FUN_00431cd0
																(liveObj,(int)*pfVar8,*(int *)((int)pfVar6 + (int)pfVar8),
																 (int)param_3[-1],(int)param_4[-1],0), iVar5 == 2)) {
						*(byte *)(pfVar7 + 2) = *(byte *)(pfVar7 + 2) | 0x10;
					}
				}
				local_14 = iVar4;
				local_1c = local_1c + 1;
				param_4 = param_4 + 1;
				pfVar7 = pfVar7 + 5;
				param_3 = pfVar8;
			} while (local_1c < param_2);
		}
		if (!bVar1) {
			LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
			liveObj->flags3 = liveObj->flags3 & 0xfffffbff;
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_MOVING;
			liveObj->routeptr_24 = buffer;
			liveObj->routingBlocksTotal = param_2;
			liveObj->routingBlocksCurrent = 0;
			(liveObj->vector_28c).y = 0.0;
			(liveObj->vector_28c).x = 0.0;
			return 1;
		}
		std::free(buffer);
	}
	return 0;
}



void __cdecl lego::game::LiveObject_UnkDoRouting_FUN_00441c00(LiveObject *in_liveObj,BOOL param_2)
{
	LiveFlags4 *pLVar1;
	float fVar2;
	LiveFlags1 LVar3;
	LiveFlags3 LVar4;
	LiveObject *pLVar5;
	uint uVar6;
	char *pcVar7;
	longlong lVar8;
	Point2I point;
	
	if (in_liveObj->routeptr_24 != (void *)0x0) {
		if (param_2 == 0) {
			uVar6 = in_liveObj->routingBlocksCurrent;
			if (uVar6 < in_liveObj->routingBlocksTotal) {
				pcVar7 = (char *)((int)in_liveObj->routeptr_24 + uVar6 * 0x14 + 0x11);
				do {
					if (*pcVar7 == '\x03') {
						pLVar5 = in_liveObj->object_2fc;
						if (pLVar5 != (LiveObject *)0x0) {
							if (pLVar5->objType == OBJECT_BOULDER) {
								LiveObject_ReleaseBoulderUnk(pLVar5);
							}
							else {
								pLVar5->object_300 = (LiveObject *)0x0;
							}
LAB_00441ca7:
							in_liveObj->object_2fc = (LiveObject *)0x0;
						}
						break;
					}
					if (*pcVar7 == '\a') goto LAB_00441ca7;
					uVar6 = uVar6 + 1;
					pcVar7 = pcVar7 + 0x14;
				} while (uVar6 < in_liveObj->routingBlocksTotal);
			}
			if (in_liveObj->objType == OBJECT_ROCKMONSTER) {
				if (((in_liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
					 (in_liveObj->carriedObjects[0]->objType == OBJECT_BOULDER)) {
					LiveObject_FUN_0043a130(in_liveObj,0);
				}
				LiveObject_FUN_00403b30(in_liveObj,AITASK_GATHER,(LiveObject *)0x0);
				LiveObject_FUN_00403b30(in_liveObj,AITASK_REPAIR,(LiveObject *)0x0);
			}
			if ((*(byte *)&in_liveObj->flags1 & 8) != 0) {
				lVar8 = __ftol((float10)(in_liveObj->point_2f4).x);
				point.x = (int)lVar8;
				lVar8 = __ftol((float10)(in_liveObj->point_2f4).y);
				point.y = (int)lVar8;
				Level_SetBlockFlags1_8000000(&point,0);
			}
			Game_UnkLiveObjectHandleDynamite(in_liveObj);
		}
		else {
			if (in_liveObj->objType == OBJECT_MINIFIGURE) {
				res::Creature_SetOrientation
									(in_liveObj->miniFigure,(in_liveObj->point_298).x,(in_liveObj->point_298).y);
				fVar2 = (in_liveObj->point_298).y;
				(in_liveObj->faceDirection).x = (in_liveObj->point_298).x;
				(in_liveObj->faceDirection).y = fVar2;
			}
		}
		std::free(in_liveObj->routeptr_24);
		in_liveObj->routeptr_24 = (void *)0x0;
		FUN_00403a20(in_liveObj,param_2);
	}
	LVar3 = in_liveObj->flags1;
	LVar4 = in_liveObj->flags3;
	pLVar5 = in_liveObj->object_2fc;
	in_liveObj->routingBlocksTotal = 0;
	in_liveObj->routingBlocksCurrent = 0;
	(in_liveObj->vector_28c).y = 0.0;
	(in_liveObj->vector_28c).x = 0.0;
	(in_liveObj->vector_28c).z = 0.0;
	in_liveObj->flags1 = LVar3 & ~(LIVEOBJ1_MOVING|LIVEOBJ1_UNK_800000);
	in_liveObj->flags3 = LVar4 & 0xffffbbff;
	if (pLVar5 != (LiveObject *)0x0) {
		pLVar1 = &pLVar5->flags4;
		*pLVar1 = *pLVar1 & ~LIVEOBJ4_UNK_10;
	}
	if ((*(byte *)&in_liveObj->flags1 & 2) != 0) {
		(in_liveObj->faceDirection).x = (in_liveObj->faceDirection).x * -1.0;
		(in_liveObj->faceDirection).y = (in_liveObj->faceDirection).y * -1.0;
		(in_liveObj->faceDirection).z = (in_liveObj->faceDirection).z * -1.0;
		in_liveObj->flags1 = in_liveObj->flags1 & ~LIVEOBJ1_LIFTING;
	}
	LiveObject_SetActivityUnk(in_liveObj,ACTIVITY_STAND,0);
	return;
}



void __cdecl lego::game::LiveObject_FUN_00441df0(LiveObject *liveObj,BOOL param_2,BOOL param_3)
{
	LiveFlags2 *pLVar1;
	LiveFlags3 *pLVar2;
	LiveFlags2 LVar3;
	LiveFlags1 LVar4;
	ObjectStatsFlags2 OVar5;
	longlong lVar6;
	Point2I local_8;
	
	LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
	if (param_3 != 0) {
		LiveObject_FUN_0043a130(liveObj,0);
	}
	if ((liveObj->flags2 & LIVEOBJ2_UNK_2) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_2;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_GETUP,0);
		Game_UpdateSomeAITasks(liveObj);
		liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_100;
		LVar3 = liveObj->object_3c0->flags2;
		if ((LVar3 & LIVEOBJ2_UNK_1) != LIVEOBJ2_NONE) {
			liveObj->object_3c0->flags2 = LVar3 & ~LIVEOBJ2_UNK_1;
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		}
	}
	if ((liveObj->flags2 & LIVEOBJ2_UNK_1) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_1;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		LVar3 = liveObj->object_3c0->flags2;
		if ((LVar3 & LIVEOBJ2_UNK_2) != LIVEOBJ2_NONE) {
			liveObj->object_3c0->flags2 = LVar3 & ~LIVEOBJ2_UNK_2;
			LiveObject_SetActivityUnk(liveObj->object_3c0,ACTIVITY_GETUP,0);
			Game_UpdateSomeAITasks(liveObj->object_3c0);
			pLVar1 = &liveObj->object_3c0->flags2;
			*pLVar1 = *pLVar1 | LIVEOBJ2_UNK_100;
		}
	}
	LVar4 = liveObj->flags1;
	liveObj->flags2 =
			 liveObj->flags2 &
			 ~(LIVEOBJ2_UNK_20|LIVEOBJ2_UNK_4000|LIVEOBJ2_UNK_400000|LIVEOBJ2_UNK_800000|
				LIVEOBJ2_UNK_1000000);
	liveObj->flags1 = LVar4 & ~(LIVEOBJ1_UNK_800|LIVEOBJ1_UNK_10000000|LIVEOBJ1_UNK_80000000);
	if ((LVar4 & LIVEOBJ1_UNK_2000) != LIVEOBJ1_NONE) {
		liveObj->flags1 =
				 LVar4 & ~(LIVEOBJ1_UNK_800|LIVEOBJ1_UNK_2000|LIVEOBJ1_UNK_10000000|LIVEOBJ1_UNK_80000000);
		LiveObject_SetAITaskUnk(liveObj,AITASK_DEPOSITE,liveObj,1);
		FUN_0043f160(liveObj);
		if (liveObj->object_2fc != (LiveObject *)0x0) {
			pLVar2 = &liveObj->object_2fc->flags3;
			*pLVar2 = *pLVar2 & ~LIVEOBJ3_UNK_1000000;
		}
	}
	LVar4 = liveObj->flags1;
	liveObj->flags1 = LVar4 & ~(LIVEOBJ1_UNK_200|LIVEOBJ1_REST);
	liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_4000;
	if ((liveObj->flags2 & LIVEOBJ2_UNK_200000) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_200000;
	}
	LVar3 = liveObj->flags2;
	liveObj->flags2 = LVar3 & ~LIVEOBJ2_UNK_40000;
	if ((LVar4 & LIVEOBJ1_UNK_1000000) != LIVEOBJ1_NONE) {
		liveObj->flags2 = LVar3 & ~(LIVEOBJ2_UNK_40000|LIVEOBJ2_UNK_80000);
		LiveObject_SetAITaskUnk(liveObj,AITASK_REPAIR,(LiveObject *)0x0,1);
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_1000000;
	}
	if ((liveObj->flags1 & LIVEOBJ1_EATING) != LIVEOBJ1_NONE) {
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_EATING;
	}
	if ((liveObj->flags2 & LIVEOBJ2_UNK_40) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_40;
	}
	if ((liveObj->flags2 & LIVEOBJ2_TRAINING) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_TRAINING;
	}
	if ((liveObj->flags2 & LIVEOBJ2_UPGRADING) != LIVEOBJ2_NONE) {
		if (liveObj->object_2fc != (LiveObject *)0x0) {
			OVar5 = LiveObject_GetStatsFlags2(liveObj->object_2fc);
			if ((OVar5 & STATS2_UPGRADEBUILDING) != STATS2_NONE) {
				if ((liveObj->object_2fc->flags2 & LIVEOBJ2_UPGRADING) != LIVEOBJ2_NONE) goto LAB_00442065;
				LiveObject_SetAITaskUnk(liveObj,AITASK_UPGRADE,(LiveObject *)0x0,1);
				liveObj->object_2fc->object_300 = (LiveObject *)0x0;
				liveObj->object_2fc = (LiveObject *)0x0;
			}
		}
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UPGRADING;
	}
LAB_00442065:
	if ((liveObj->flags1 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_PLACING;
		LiveObject_FUN_0043a130(liveObj,1);
	}
	LVar4 = liveObj->flags1;
	liveObj->flags1 = LVar4 & ~LIVEOBJ1_UNK_1000;
	if ((LVar4 & LIVEOBJ1_REINFORCING) != LIVEOBJ1_NONE) {
		lVar6 = __ftol((float10)(liveObj->point_2f4).x);
		local_8.x = (int)lVar6;
		lVar6 = __ftol((float10)(liveObj->point_2f4).y);
		local_8.y = (int)lVar6;
		liveObj->flags1 = LVar4 & ~(LIVEOBJ1_REINFORCING|LIVEOBJ1_UNK_1000) | LIVEOBJ1_UNK_80000000;
		Level_SetBlockFlags1_8000000(&local_8,0);
	}
	LVar4 = liveObj->flags1;
	liveObj->flags1 = LVar4 & ~LIVEOBJ1_UNK_4000000;
	if ((liveObj->flags2 & LIVEOBJ2_UNK_4) != LIVEOBJ2_NONE) {
		liveObj->object_2fc = (LiveObject *)0x0;
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_4;
	}
	liveObj->flags1 =
			 LVar4 & ~(LIVEOBJ1_UNK_8000|LIVEOBJ1_UNK_10000|LIVEOBJ1_CLEARING|LIVEOBJ1_UNK_4000000|
								LIVEOBJ1_UNK_80000000);
	liveObj->flags2 =
			 liveObj->flags2 & ~(LIVEOBJ2_UNK_100|LIVEOBJ2_UNK_200|LIVEOBJ2_UNK_10000|LIVEOBJ2_UNK_20000);
	if (param_2 != 0) {
		LiveObject_FUN_00403e90(liveObj);
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,1);
		Game_UpdateSomeAITasks(liveObj);
	}
	return;
}



void __cdecl lego::game::LiveObject_ReleaseBoulderUnk(LiveObject *liveObj)
{
	if ((((byte)pool::globals::ReservedPool_LiveObject___g_INITFLAGS & 2) == 0) &&
		 (liveObj->objType == OBJECT_BOULDER)) {
		FUN_0040bd10(liveObj);
		pool::ReservedPool_LiveObject___Release(liveObj);
	}
	return;
}



undefined4 __cdecl FUN_00442190(LiveObject *liveObj,int *param_2,int param_3)
{
	float fVar1;
	float fVar2;
	float fVar3;
	BOOL BVar4;
	Container *pCVar5;
	LiveFlags2 LVar6;
	float10 fVar7;
	Container *pCVar8;
	Vector3F *pVVar9;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	if ((((ushort)((ushort)((float)liveObj->field_360 < 0.0) << 8 |
								(ushort)((float)liveObj->field_360 == 0.0) << 0xe) == 0) ||
			(((byte)lego::globals::g_Game.flags2 & 4) != 0)) || (*param_2 != 3)) {
		return 0;
	}
	BVar4 = lego::game::LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj);
	if (BVar4 != 0) {
		return 0;
	}
	lego::game::LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
	pVVar9 = &local_18;
	pCVar8 = (Container *)0x0;
	pCVar5 = lego::game::LiveObject_GetResource((LiveObject *)param_2);
	lego::res::Container_GetPosition(pCVar5,pCVar8,pVVar9);
	pVVar9 = &local_c;
	pCVar8 = (Container *)0x0;
	pCVar5 = lego::game::LiveObject_GetResource(liveObj);
	lego::res::Container_GetPosition(pCVar5,pCVar8,pVVar9);
	fVar7 = lego::game::LiveObject_GetCollHeight(liveObj);
	local_c.z = (float)((float10)local_c.z - fVar7 * (float10)0.5);
	fVar7 = lego::game::LiveObject_GetCollHeight((LiveObject *)param_2);
	fVar7 = (float10)local_18.z - fVar7 * (float10)0.5;
	local_18.z = (float)fVar7;
	fVar7 = fVar7 - (float10)local_c.z;
	fVar1 = (float)((float10)local_18.x - (float10)local_c.x);
	fVar2 = (float)((float10)local_18.y - (float10)local_c.y);
	fVar3 = (float)fVar7;
	fVar7 = (float10)1.0 /
					SQRT(fVar7 * (float10)fVar3 +
							 ((float10)local_18.y - (float10)local_c.y) * (float10)fVar2 +
							 ((float10)local_18.x - (float10)local_c.x) * (float10)fVar1);
	local_24.x = (float)(fVar7 * (float10)fVar1);
	local_24.y = (float)(fVar7 * (float10)fVar2);
	local_24.z = (float)(fVar7 * (float10)fVar3);
	lego::game::LiveObject_UnkUpdateOrientation(liveObj,0.0,&local_24);
	if (param_3 == 1) {
		lego::game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_FIRELASER,1);
		lego::game::Game_UpdateSomeAITasks(liveObj);
		LVar6 = liveObj->flags2 | LIVEOBJ2_UNK_400000;
	}
	else {
		if (param_3 == 2) {
			lego::game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_FIRELASER,1);
			lego::game::Game_UpdateSomeAITasks(liveObj);
			LVar6 = liveObj->flags2 | LIVEOBJ2_UNK_800000;
		}
		else {
			if (param_3 != 3) goto LAB_0044233f;
			lego::game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_FIRELASER,1);
			lego::game::Game_UpdateSomeAITasks(liveObj);
			LVar6 = liveObj->flags2 | LIVEOBJ2_UNK_1000000;
		}
	}
	liveObj->flags2 = LVar6;
LAB_0044233f:
	liveObj->field_3a8 = local_18.x;
	liveObj->field_3ac = local_18.y;
	liveObj->field_39c = local_24.x;
	liveObj->field_3b0 = local_18.z;
	liveObj->field_3a0 = local_24.y;
	liveObj->field_3a4 = local_24.z;
	return 1;
}



void __cdecl lego::game::Game_GetWeaponUnk(LiveObject *liveObj,int weaponType)
{
	SurfaceMap *surfMap;
	float weaponType_00;
	float10 fVar1;
	float local_c;
	float local_8;
	float local_4;
	
	LiveObject_GetPosition(liveObj,&local_c,&local_8);
	surfMap = GetSurfaceMap();
	fVar1 = SurfaceMap_GetSurfaceZ(surfMap,local_c,local_8);
	weaponType_00 = (float)fVar1;
	fVar1 = LiveObject_GetCollHeight(liveObj);
	local_4 = (float)((float10)weaponType_00 - fVar1 * (float10)0.5);
	switch(weaponType) {
	case 1:
		weaponType_00 = (float)tools::Weapon_GetWeaponTypeByName("Lazer");
		FUN_0046fdb0(liveObj,&local_c,(float *)&liveObj->field_39c,(uint)weaponType_00,1);
		break;
	case 2:
		weaponType_00 = (float)tools::Weapon_GetWeaponTypeByName("Pusher");
		FUN_0046fdb0(liveObj,&local_c,(float *)&liveObj->field_39c,(uint)weaponType_00,2);
		break;
	case 3:
		weaponType_00 = (float)tools::Weapon_GetWeaponTypeByName("Freezer");
		FUN_0046fdb0(liveObj,&local_c,(float *)&liveObj->field_39c,(uint)weaponType_00,3);
		break;
	case 4:
		weaponType_00 = (float)tools::Weapon_GetWeaponTypeByName("Lazer");
		FUN_0046ff30(liveObj,&local_c,(float *)&liveObj->field_3a8,weaponType_00,4);
	}
	fVar1 = tools::Weapon_GetRechargeTime((int)weaponType_00);
	liveObj->field_360 = (float)fVar1;
	return;
}



void __cdecl lego::game::LiveObject_UnkActivityCrumble_FUN_004424d0(LiveObject *liveObj)
{
	BOOL BVar1;
	
	LiveObject_FUN_00441df0(liveObj,0,1);
	LiveObject_SetActivityUnk(liveObj,ACTIVITY_CRUMBLE,1);
	BVar1 = Game_UpdateSomeAITasks(liveObj);
	if (BVar1 != 0) {
		liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_100000;
	}
	liveObj->health = -1.0;
	return;
}



void __cdecl lego::game::LiveObject_GetPosition(LiveObject *liveObj,float *out_x,float *out_y)
{
	Container *cont;
	Vector3F vector;
	
	cont = LiveObject_GetResource(liveObj);
	res::Container_GetPosition(cont,(Container *)0x0,&vector);
	*out_x = vector.x;
	*out_y = vector.y;
	return;
}



void __cdecl lego::game::LiveObject_GetFaceDirection(LiveObject *liveObj,Point2F *out_point)
{
	float fVar1;
	Container *cont;
	Vector3F local_c;
	
	cont = LiveObject_GetResource(liveObj);
	res::Container_GetOrientation(cont,(Container *)0x0,&local_c,(Vector3F *)0x0);
	fVar1 = 1.0 / SQRT(local_c.x * local_c.x + local_c.y * local_c.y);
	out_point->x = fVar1 * local_c.x;
	out_point->y = fVar1 * local_c.y;
	return;
}



void __cdecl
lego::game::LiveObject_UnkUpdateOrientation(LiveObject *liveObj,float theta,Vector3F *dvector)
{
	ObjectType OVar1;
	Vector3F local_18;
	Vector3F local_c;
	
	if (dvector == (Vector3F *)0x0) {
		local_18.z = 0.0;
		local_18.x = 0.0;
		local_18.y = 1.0;
		local_c.y = 0.0;
		local_c.x = 0.0;
		local_c.z = -1.0;
		math::Maths_Vector3DRotate(&local_18,&local_18,&local_c,theta);
	}
	else {
		local_18.x = dvector->x;
		local_18.y = dvector->y;
		local_18.z = dvector->z;
	}
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		res::Vehicle_SetOrientation(liveObj->vehicle,local_18.x,local_18.y,local_18.z);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			res::Creature_SetOrientation(liveObj->miniFigure,local_18.x,local_18.y);
		}
		else {
			if (OVar1 == OBJECT_ROCKMONSTER) {
				res::Creature_SetOrientation(liveObj->rockMonster,local_18.x,local_18.y);
			}
			else {
				if (OVar1 == OBJECT_BUILDING) {
					res::Building_SetOrientation(liveObj->building,local_18.x,local_18.y);
				}
				else {
					if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
						res::Container_SetOrientation
											(liveObj->other,(Container *)0x0,local_18.x,local_18.y,local_18.z,0.0,0.0,-1.0
											);
					}
				}
			}
		}
	}
	liveObj->float_2b8 = 0.01;
	(liveObj->faceDirection).x = local_18.x;
	(liveObj->faceDirection).y = local_18.y;
	(liveObj->faceDirection).z = local_18.z;
	(liveObj->vector_2a0).x = (liveObj->faceDirection).x * -0.01;
	(liveObj->vector_2a0).y = (liveObj->faceDirection).y * -0.01;
	(liveObj->vector_2a0).z = (liveObj->faceDirection).z * -0.01;
	return;
}



float10 __cdecl lego::game::LiveObject_UnkRadians_FUN_00442740(LiveObject *liveObj)
{
	float10 fVar1;
	Point2F local_8;
	
	LiveObject_GetFaceDirection(liveObj,&local_8);
	fVar1 = std::acos((float10)local_8.y /
										(SQRT((float10)1.0) *
										SQRT((float10)local_8.y * (float10)local_8.y +
												 (float10)local_8.x * (float10)local_8.x)));
	if (local_8.x < 0.0) {
		fVar1 = (float10)6.283185 - fVar1;
	}
	return fVar1;
}



BOOL __cdecl lego::game::LiveObject_GetBlockCoordinates(LiveObject *liveObj,int *out_bx,int *out_by)
{
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar1;
	Vector3F local_c;
	
	cont = LiveObject_GetResource(liveObj);
	res::Container_GetPosition(cont,(Container *)0x0,&local_c);
	surfMap = GetSurfaceMap();
	BVar1 = SurfaceMap_ToBlockCoordinatesNoZ(surfMap,local_c.x,local_c.y,out_bx,out_by);
	return BVar1;
}



float10 __cdecl lego::res::Res_GetSurfaceMapZ_Callback(float x,float y,SurfaceMap *surfMap)
{
	float10 fVar1;
	
	fVar1 = game::SurfaceMap_GetSurfaceZ(surfMap,x,y);
	return fVar1;
}



float10 __cdecl
lego::game::SurfaceMap_LevelCallback_FUN_00442820(float in_x,float in_y,SurfaceMap *surfMap)
{
	BOOL BVar1;
	float10 fVar2;
	float local_c;
	int local_8;
	int local_4;
	
	local_c = 0.0;
	BVar1 = SurfaceMap_ToBlockCoordinates(surfMap,in_x,in_y,&local_8,&local_4,&local_c);
	if (BVar1 != 0) {
		if ((globals::g_Game.level)->blocks
				[((globals::g_Game.level)->dimensions).width * local_4 + local_8].terrain == TERRAIN_LAKE) {
			local_c = local_c * 8.0;
		}
		else {
			local_c = 0.0;
		}
	}
	fVar2 = SurfaceMap_GetSurfaceZ(surfMap,in_x,in_y);
	return fVar2 + (float10)local_c;
}



void __cdecl lego::game::LiveObject_FUN_004428b0(LiveObject *liveObj,float x,float y)
{
	ObjectType OVar1;
	Container *cont;
	SurfaceMap *pSVar2;
	VehicleData *vehicle;
	float fVar3;
	float fVar4;
	float fVar5;
	Vector3F local_c;
	
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		cont = res::Vehicle_GetAEResource(liveObj->vehicle);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			cont = res::Object_GetAEResource((BasicObjectData *)liveObj->miniFigure);
		}
		else {
			cont = (Container *)y;
			if (OVar1 == OBJECT_ROCKMONSTER) {
				cont = res::Object_GetAEResource((BasicObjectData *)liveObj->rockMonster);
			}
		}
	}
	res::Container_GetPosition(cont,(Container *)0x0,&local_c);
	if ((x != local_c.x) || (y != local_c.y)) {
		(liveObj->faceDirection).z = 0.0;
		(liveObj->faceDirection).x = x;
		(liveObj->faceDirection).y = y;
		(liveObj->vector_2a0).x = local_c.x;
		(liveObj->vector_2a0).y = local_c.y;
		(liveObj->vector_2a0).z = local_c.z;
		(liveObj->faceDirection).x = (liveObj->faceDirection).x - (liveObj->vector_2a0).x;
		(liveObj->faceDirection).y = (liveObj->faceDirection).y - (liveObj->vector_2a0).y;
		(liveObj->faceDirection).z = (liveObj->faceDirection).z - (liveObj->vector_2a0).z;
		(liveObj->faceDirection).z = 0.0;
		fVar4 = (liveObj->faceDirection).z;
		fVar3 = (liveObj->faceDirection).y;
		fVar5 = (liveObj->faceDirection).x;
		fVar4 = SQRT(fVar5 * fVar5 + fVar4 * fVar4 + fVar3 * fVar3);
		fVar5 = 1.0 / fVar4;
		liveObj->float_2b8 = fVar4;
		(liveObj->faceDirection).x = fVar5 * (liveObj->faceDirection).x;
		(liveObj->faceDirection).y = (liveObj->faceDirection).y * fVar5;
		(liveObj->faceDirection).z = (liveObj->faceDirection).z * fVar5;
	}
	OVar1 = liveObj->objType;
	if (OVar1 != OBJECT_VEHICLE) {
		if (OVar1 != OBJECT_MINIFIGURE) {
			if (OVar1 == OBJECT_ROCKMONSTER) {
				res::Creature_SetOrientation
									(liveObj->rockMonster,(liveObj->faceDirection).x,(liveObj->faceDirection).y);
				pSVar2 = GetSurfaceMap();
				res::Creature_SetPosition(liveObj->rockMonster,x,y,res::Res_GetSurfaceMapZ_Callback,pSVar2);
			}
			return;
		}
		if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_LIFTING) == 0) {
			fVar5 = (liveObj->faceDirection).y;
			fVar4 = (liveObj->faceDirection).x;
		}
		else {
			fVar5 = -(liveObj->faceDirection).y;
			fVar4 = -(liveObj->faceDirection).x;
		}
		res::Creature_SetOrientation(liveObj->miniFigure,fVar4,fVar5);
		pSVar2 = GetSurfaceMap();
		res::Creature_SetPosition(liveObj->miniFigure,x,y,SurfaceMap_LevelCallback_FUN_00442820,pSVar2);
		return;
	}
	if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_LIFTING) == 0) {
		fVar5 = (liveObj->faceDirection).z;
		fVar4 = (liveObj->faceDirection).y;
		fVar3 = (liveObj->faceDirection).x;
		vehicle = liveObj->vehicle;
	}
	else {
		vehicle = liveObj->vehicle;
		fVar5 = -(liveObj->faceDirection).z;
		fVar4 = -(liveObj->faceDirection).y;
		fVar3 = -(liveObj->faceDirection).x;
	}
	res::Vehicle_SetOrientation(vehicle,fVar3,fVar4,fVar5);
	pSVar2 = GetSurfaceMap();
	res::Vehicle_SetPosition(liveObj->vehicle,x,y,res::Res_GetSurfaceMapZ_Callback,pSVar2);
	return;
}



void __cdecl
lego::game::LiveObject_UnkUpdatePositioning
					(LiveObject *liveObj,float x,float y,float theta,BOOL includeRotation)
{
	ObjectType OVar1;
	SurfaceMap *pSVar2;
	float10 fVar3;
	float x_00;
	float y_00;
	Vector3F local_18;
	Vector3F local_c;
	
	if (includeRotation != 0) {
		local_18.z = 0.0;
		local_18.x = 0.0;
		local_18.y = 1.0;
		local_c.y = 0.0;
		local_c.x = 0.0;
		local_c.z = -1.0;
		math::Maths_Vector3DRotate(&local_18,&local_18,&local_c,theta);
	}
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		if (includeRotation != 0) {
			res::Vehicle_SetOrientation(liveObj->vehicle,local_18.x,local_18.y,local_18.z);
		}
		pSVar2 = GetSurfaceMap();
		res::Vehicle_SetPosition(liveObj->vehicle,x,y,res::Res_GetSurfaceMapZ_Callback,pSVar2);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			if (includeRotation != 0) {
				res::Creature_SetOrientation(liveObj->miniFigure,local_18.x,local_18.y);
			}
			pSVar2 = GetSurfaceMap();
			res::Creature_SetPosition
								(liveObj->miniFigure,x,y,SurfaceMap_LevelCallback_FUN_00442820,pSVar2);
		}
		else {
			if (OVar1 == OBJECT_ROCKMONSTER) {
				if (includeRotation != 0) {
					res::Creature_SetOrientation(liveObj->rockMonster,local_18.x,local_18.y);
				}
				pSVar2 = GetSurfaceMap();
				res::Creature_SetPosition(liveObj->rockMonster,x,y,res::Res_GetSurfaceMapZ_Callback,pSVar2);
			}
			else {
				if (OVar1 == OBJECT_BUILDING) {
					if (includeRotation != 0) {
						res::Building_SetOrientation(liveObj->building,local_18.x,local_18.y);
					}
					pSVar2 = GetSurfaceMap();
					res::Building_SetPosition(liveObj->building,x,y,res::Res_GetSurfaceMapZ_Callback,pSVar2);
				}
				else {
					if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
						if (includeRotation != 0) {
							res::Container_SetOrientation
												(liveObj->other,(Container *)0x0,local_18.x,local_18.y,local_18.z,0.0,0.0,
												 -1.0);
						}
						x_00 = x;
						y_00 = y;
						pSVar2 = GetSurfaceMap();
						fVar3 = SurfaceMap_GetSurfaceZ(pSVar2,x_00,y_00);
						res::Container_SetPosition(liveObj->other,(Container *)0x0,x,y,(float)fVar3);
					}
				}
			}
		}
	}
	if (includeRotation != 0) {
		(liveObj->faceDirection).x = local_18.x;
		(liveObj->faceDirection).y = local_18.y;
		(liveObj->faceDirection).z = local_18.z;
	}
	liveObj->float_2b8 = 0.01;
	(liveObj->vector_2a0).x = (liveObj->faceDirection).x * -0.01;
	(liveObj->vector_2a0).y = (liveObj->faceDirection).y * -0.01;
	(liveObj->vector_2a0).z = (liveObj->faceDirection).z * -0.01;
	(liveObj->vector_2a0).x = (liveObj->vector_2a0).x + x;
	(liveObj->vector_2a0).y = (liveObj->vector_2a0).y + y;
	(liveObj->vector_2a0).z = (liveObj->vector_2a0).z;
	return;
}



int __cdecl lego::game::LiveObject_FUN_00442dd0(LiveObject *in_liveObj,float param_2,float *param_3)
{
	ObjectType OVar1;
	bool bVar2;
	LiveObject *in_liveObj_00;
	Container *cont;
	LiveObject *liveObj;
	BOOL BVar3;
	int iVar4;
	uint uVar5;
	SurfaceMap *pSVar6;
	ObjectStatsFlags1 OVar7;
	CreatureData *creature;
	int iVar8;
	float fVar9;
	float fVar10;
	float fVar11;
	float *out_x;
	code *getZcallback;
	float *out_y;
	uint local_50;
	float local_4c;
	uint local_48;
	float local_44;
	float local_40;
	float local_3c;
	float local_38;
	float local_34;
	float local_30;
	float local_2c;
	float local_28;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	in_liveObj_00 = in_liveObj;
	cont = LiveObject_GetResource(in_liveObj);
	iVar8 = 0;
	uVar5 = (uint)(in_liveObj_00->forwardSpeed_2c0 < 0);
	local_48 = uVar5;
	LiveObject_FUN_004468d0(in_liveObj_00,param_2,&local_4c,&local_44);
	res::Container_GetOrientation(cont,(Container *)0x0,&local_24,&local_c);
	res::Container_GetPosition(cont,(Container *)0x0,&local_18);
	local_38 = local_18.x;
	local_34 = local_18.y;
	if (in_liveObj_00->rotateSpeed_2c4 != 0.0) {
		fVar9 = 1.0;
		if (in_liveObj_00->objType == OBJECT_VEHICLE) {
			if (uVar5 == 0) {
				fVar9 = 1.0;
			}
			else {
				fVar9 = -1.0;
			}
		}
		res::Container_AddRotation
							(cont,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,fVar9 * param_2 * in_liveObj_00->rotateSpeed_2c4
							);
		iVar8 = 1;
		(in_liveObj_00->faceDirection).x = local_24.x;
		(in_liveObj_00->faceDirection).y = local_24.y;
		(in_liveObj_00->faceDirection).z = local_24.z;
	}
	param_2 = (float)in_liveObj_00->strafeSpeed_2bc;
	if ((param_2 != 0.0) || (in_liveObj_00->forwardSpeed_2c0 != 0)) {
		fVar11 = (float)in_liveObj_00->forwardSpeed_2c0;
		fVar10 = (float)(int)param_2;
		local_2c = 0.0;
		fVar9 = 1.0 / SQRT(fVar11 * fVar11 + fVar10 * fVar10);
		local_28 = fVar9 * fVar11 * local_4c;
		local_30 = fVar9 * fVar10 * local_4c;
		res::Container_AddTranslation(cont,D3DRMCOMBINE_BEFORE,local_30,0.0,local_28);
		iVar8 = 1;
	}
	if (iVar8 == 0) goto LAB_00443210;
	bVar2 = false;
	LiveObject_GetBlockCoordinates(in_liveObj_00,(int *)&local_50,(int *)&in_liveObj);
	LiveObject_GetPosition(in_liveObj_00,&local_40,&local_3c);
	liveObj = (LiveObject *)LiveObject_FUN_00446030(in_liveObj_00,&local_40,0,1);
	if (liveObj != (LiveObject *)0x0) {
		LiveObject_GetPosition(liveObj,&local_30,&local_2c);
		local_30 = local_40 - local_30;
		local_2c = local_3c - local_2c;
		local_38 = local_40 - local_38;
		local_34 = local_3c - local_34;
		fVar9 = 1.0 / SQRT(local_34 * local_34 + local_38 * local_38);
		param_2 = 1.0 / SQRT(local_2c * local_2c + local_30 * local_30);
		fVar9 = param_2 * local_2c * fVar9 * local_34 + param_2 * local_30 * fVar9 * local_38;
		if ((ushort)((ushort)(fVar9 < 0.0) << 8 | (ushort)(fVar9 == 0.0) << 0xe) != 0) {
			bVar2 = true;
		}
	}
	BVar3 = Game_IsNoclipOn();
	if ((BVar3 == 0) &&
		 (((iVar4 = LiveObject_FUN_00431cd0
													(in_liveObj_00,local_50,(int)in_liveObj,local_50,(int)in_liveObj,1),
			 iVar4 == 0 || (bVar2)) || (iVar4 = FUN_00432ac0(local_50,(int)in_liveObj), iVar4 != 0)))) {
		res::Container_SetPosition(cont,(Container *)0x0,local_18.x,local_18.y,local_18.z);
		res::Container_SetOrientation
							(cont,(Container *)0x0,local_24.x,local_24.y,local_24.z,local_c.x,local_c.y,local_c.z)
		;
		(in_liveObj_00->faceDirection).x = local_24.x;
		(in_liveObj_00->faceDirection).y = local_24.y;
		(in_liveObj_00->faceDirection).z = local_24.z;
	}
	else {
		BVar3 = Level_GetBlockFlags1_10Not8(local_50,(uint)in_liveObj);
		if (BVar3 != 0) {
			out_y = &local_3c;
			out_x = &local_40;
			fVar11 = 0.0;
			uVar5 = FUN_00432f00(local_50,(int)in_liveObj);
			fVar9 = local_40;
			fVar10 = local_3c;
			pSVar6 = GetSurfaceMap();
			SurfaceMap_FUN_0044fe50(pSVar6,fVar9,fVar10,uVar5,fVar11,out_x,out_y);
		}
		OVar1 = in_liveObj_00->objType;
		if (OVar1 == OBJECT_VEHICLE) {
			pSVar6 = GetSurfaceMap();
			res::Vehicle_SetPosition
								(in_liveObj_00->vehicle,local_40,local_3c,res::Res_GetSurfaceMapZ_Callback,pSVar6);
		}
		else {
			if (OVar1 == OBJECT_MINIFIGURE) {
				pSVar6 = GetSurfaceMap();
				creature = in_liveObj_00->miniFigure;
				getZcallback = SurfaceMap_LevelCallback_FUN_00442820;
			}
			else {
				if (OVar1 != OBJECT_ROCKMONSTER) goto LAB_004431a9;
				pSVar6 = GetSurfaceMap();
				creature = in_liveObj_00->rockMonster;
				getZcallback = res::Res_GetSurfaceMapZ_Callback;
			}
			res::Creature_SetPosition(creature,local_40,local_3c,getZcallback,pSVar6);
		}
	}
LAB_004431a9:
	BVar3 = Level_GetBlockFlags1_10Not8(local_50,(uint)in_liveObj);
	if (((BVar3 != 0) &&
			(BVar3 = LiveObject_FUN_004326a0(in_liveObj_00,local_50,(uint)in_liveObj,0,1), BVar3 != 0)) &&
		 ((in_liveObj_00->objType != OBJECT_MINIFIGURE ||
			(BVar3 = LiveObject_HasToolEquipped(in_liveObj_00,TOOL_DRILL), BVar3 != 0)))) {
		iVar8 = 3;
	}
	if ((local_48 != 0) &&
		 (OVar7 = LiveObject_GetStatsFlags1(in_liveObj_00), (OVar7 & STATS1_CROSSLAND) == STATS1_NONE))
	{
		iVar8 = 4;
	}
LAB_00443210:
	in_liveObj_00->strafeSpeed_2bc = 0;
	in_liveObj_00->forwardSpeed_2c0 = 0;
	in_liveObj_00->rotateSpeed_2c4 = 0.0;
	if (iVar8 != 0) {
		*param_3 = local_44;
	}
	return iVar8;
}



void __cdecl FUN_00443240(LiveObject *in_liveObj,float param_2)
{
	ObjectType OVar1;
	LiveFlags3 LVar2;
	LiveObject *liveObj;
	SurfaceMap *pSVar3;
	Container *pCVar4;
	BOOL BVar5;
	int iVar6;
	uint uVar7;
	float10 fVar8;
	longlong lVar9;
	float fVar10;
	float fVar11;
	float unkMultiplier;
	Vector3F *out_x;
	float *out_y;
	uint local_30;
	float local_2c;
	float local_28;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	FUN_00403a70(in_liveObj);
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		lego::game::LiveObject_GetPosition(liveObj,(float *)&in_liveObj,&param_2);
		pSVar3 = lego::game::GetSurfaceMap();
		lego::res::Vehicle_SetPosition
							(liveObj->vehicle,(float)in_liveObj,param_2,lego::res::Res_GetSurfaceMapZ_Callback,
							 pSVar3);
		return;
	}
	if (OVar1 == OBJECT_BUILDING) {
		lego::game::LiveObject_GetPosition(liveObj,(float *)&in_liveObj,&param_2);
		pSVar3 = lego::game::GetSurfaceMap();
		lego::res::Building_SetPosition
							(liveObj->building,(float)in_liveObj,param_2,lego::res::Res_GetSurfaceMapZ_Callback,
							 pSVar3);
		return;
	}
	if (OVar1 == OBJECT_ROCKMONSTER) {
		lego::game::LiveObject_GetPosition(liveObj,(float *)&in_liveObj,&param_2);
		pSVar3 = lego::game::GetSurfaceMap();
		lego::res::Creature_SetPosition
							(liveObj->rockMonster,(float)in_liveObj,param_2,lego::res::Res_GetSurfaceMapZ_Callback
							 ,pSVar3);
		return;
	}
	if (OVar1 == OBJECT_MINIFIGURE) {
		pCVar4 = lego::game::LiveObject_GetResource(liveObj);
		lego::res::Container_GetPosition(pCVar4,(Container *)0x0,&local_18);
		local_2c = local_18.x;
		local_28 = local_18.y;
		lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_30,(int *)&in_liveObj);
		BVar5 = lego::game::Level_GetBlockFlags1_10Not8(local_30,(uint)in_liveObj);
		if ((BVar5 != 0) && (iVar6 = FUN_00432ac0(local_30,(int)in_liveObj), iVar6 == 0)) {
			out_y = &local_24.y;
			out_x = &local_24;
			unkMultiplier = 0.0;
			uVar7 = FUN_00432f00(local_30,(int)in_liveObj);
			fVar10 = local_2c;
			fVar11 = local_28;
			pSVar3 = lego::game::GetSurfaceMap();
			lego::game::SurfaceMap_FUN_0044fe50
								(pSVar3,fVar10,fVar11,uVar7,unkMultiplier,(float *)out_x,out_y);
			local_24.x = local_24.x - local_2c;
			local_24.y = local_24.y - local_28;
			fVar11 = param_2 * 0.5;
			fVar10 = SQRT(local_24.y * local_24.y + local_24.x * local_24.x);
			if ((ushort)((ushort)(fVar10 < fVar11) << 8 | (ushort)(fVar10 == fVar11) << 0xe) == 0) {
				local_2c = (fVar11 / fVar10) * local_24.x + local_2c;
				local_28 = (fVar11 / fVar10) * local_24.y + local_28;
			}
		}
		pSVar3 = lego::game::GetSurfaceMap();
		fVar11 = local_28;
		fVar10 = local_2c;
		fVar8 = lego::res::Res_GetSurfaceMapZ_Callback(local_2c,local_28,pSVar3);
		local_c.z = (float)fVar8;
		if (((local_18.x == local_2c) && (local_18.y == local_28)) && (local_18.z == local_c.z)) {
			return;
		}
		pSVar3 = lego::game::GetSurfaceMap();
		lego::res::Creature_SetPosition
							(liveObj->miniFigure,fVar10,fVar11,lego::game::SurfaceMap_LevelCallback_FUN_00442820,
							 pSVar3);
		return;
	}
	if ((((OVar1 != OBJECT_POWERCRYSTAL) && (OVar1 != OBJECT_ORE)) &&
			((OVar1 != OBJECT_BARRIER && ((OVar1 != OBJECT_DYNAMITE && (OVar1 != OBJECT_ELECTRICFENCE)))))
			) && (OVar1 != OBJECT_OOHSCARY)) {
		return;
	}
	if (liveObj->carryingThisObject != (LiveObject *)0x0) {
		return;
	}
	lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_30,(int *)&local_2c);
	if ((liveObj->objType == OBJECT_BARRIER) ||
		 (uVar7 = FUN_00432a30(local_30,(uint)local_2c), uVar7 == 0)) {
LAB_00443554:
		if (liveObj->resData_2dc == (Container *)0x0) goto LAB_00443614;
	}
	else {
		if (liveObj->resData_2dc == (Container *)0x0) {
			pCVar4 = (Container *)FUN_0040c4e0(local_30,(uint)local_2c);
			liveObj->resData_2dc = pCVar4;
			local_24.y = 0.0;
			local_24.x = local_2c;
			LVar2 = liveObj->flags3;
			(liveObj->point_2f4).x = (float)(ulonglong)local_30;
			liveObj->flags3 = LVar2 & ~LIVEOBJ3_UNK_100000;
			(liveObj->point_2f4).y = (float)(ulonglong)(uint)local_2c;
			goto LAB_00443554;
		}
	}
	lVar9 = __ftol((float10)(liveObj->point_2f4).y);
	uVar7 = (uint)lVar9;
	lVar9 = __ftol((float10)(liveObj->point_2f4).x);
	uVar7 = FUN_00432a30((uint)lVar9,uVar7);
	if (uVar7 != 0) {
		lego::res::Container_GetPosition(liveObj->resData_2dc,(Container *)0x0,&local_18);
		fVar10 = local_18.x;
		fVar11 = local_18.y;
		pSVar3 = lego::game::GetSurfaceMap();
		fVar8 = lego::game::SurfaceMap_GetSurfaceZ(pSVar3,fVar10,fVar11);
		fVar8 = fVar8 - (float10)1.2285;
		if ((ushort)((ushort)((float10)local_18.z < fVar8) << 8 |
								(ushort)((float10)local_18.z == fVar8) << 0xe) == 0) {
			local_18.z = (float)fVar8;
		}
		lego::res::Container_SetPosition
							(liveObj->other,(Container *)0x0,local_18.x,local_18.y,local_18.z);
		lego::res::Container_SetOrientation(liveObj->other,liveObj->resData_2dc,0.0,0.0,1.0,0.0,1.0,0.0)
		;
		return;
	}
LAB_00443614:
	liveObj->resData_2dc = (Container *)0x0;
	lego::res::Container_GetPosition(liveObj->other,(Container *)0x0,&local_24);
	fVar10 = local_24.x;
	fVar11 = local_24.y;
	pSVar3 = lego::game::GetSurfaceMap();
	fVar8 = lego::game::SurfaceMap_GetSurfaceZ(pSVar3,fVar10,fVar11);
	in_liveObj = (LiveObject *)(float)(fVar8 - (float10)1.2285);
	fVar8 = (fVar8 - (float10)1.2285) - (float10)0.5;
	if ((ushort)((ushort)(fVar8 < (float10)local_24.z) << 8 |
							(ushort)(fVar8 == (float10)local_24.z) << 0xe) == 0) {
		local_24.z = local_24.z + param_2;
		if ((ushort)((ushort)(local_24.z < (float)in_liveObj) << 8 |
								(ushort)(local_24.z == (float)in_liveObj) << 0xe) == 0) {
			local_24.z = (float)in_liveObj;
		}
		lego::res::Container_SetPosition
							(liveObj->other,(Container *)0x0,local_24.x,local_24.y,local_24.z);
	}
	if ((ushort)((ushort)(local_24.z < (float)in_liveObj - -0.5) << 8 |
							(ushort)(local_24.z == (float)in_liveObj - -0.5) << 0xe) == 0) {
		local_24.z = local_24.z - param_2;
		if (local_24.z < (float)in_liveObj) {
			local_24.z = (float)in_liveObj;
		}
		lego::res::Container_SetPosition
							(liveObj->other,(Container *)0x0,local_24.x,local_24.y,local_24.z);
	}
	lego::res::Container_GetOrientation(liveObj->other,(Container *)0x0,&local_18,&local_c);
	if (0.0 <= local_18.z) {
		if ((ushort)((ushort)(local_18.z < 0.0) << 8 | (ushort)(local_18.z == 0.0) << 0xe) == 0) {
			local_18.z = local_18.z - param_2 * 0.05;
			if (local_18.z < 0.0) {
				local_18.z = 0.0;
			}
			lego::res::Container_SetOrientation
								(liveObj->other,(Container *)0x0,local_18.x,local_18.y,local_18.z,0.0,0.0,-1.0);
		}
		return;
	}
	local_18.z = local_18.z - param_2 * -0.05;
	if ((ushort)((ushort)(local_18.z < 0.0) << 8 | (ushort)(local_18.z == 0.0) << 0xe) == 0) {
		local_18.z = 0.0;
	}
	lego::res::Container_SetOrientation
						(liveObj->other,(Container *)0x0,local_18.x,local_18.y,local_18.z,0.0,0.0,-1.0);
	return;
}



void __cdecl FUN_004437d0(LiveObject *liveObj)
{
	Container *cont;
	Container *cont_00;
	Vector3F local_48;
	Vector3F local_3c;
	Vector3F local_30;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	cont = lego::game::LiveObject_GetResource(liveObj->drivenObject);
	if (liveObj->objType == OBJECT_VEHICLE) {
		cont_00 = lego::res::Vehicle_GetDriverNull(liveObj->vehicle);
		if (cont_00 != (Container *)0x0) goto LAB_0044380f;
	}
	cont_00 = lego::game::LiveObject_GetResource(liveObj);
LAB_0044380f:
	lego::res::Container_GetPosition(cont,(Container *)0x0,&local_24);
	lego::res::Container_GetPosition(cont_00,(Container *)0x0,&local_48);
	if (((local_24.x != local_48.x) || (local_24.y != local_48.y)) || (local_24.z != local_48.z)) {
		lego::res::Container_SetPosition(cont,(Container *)0x0,local_48.x,local_48.y,local_48.z);
	}
	lego::res::Container_GetOrientation(cont,(Container *)0x0,&local_18,&local_c);
	lego::res::Container_GetOrientation(cont_00,(Container *)0x0,&local_30,&local_3c);
	if ((((local_18.x != local_30.x) || (local_18.y != local_30.y)) ||
			((local_18.z != local_30.z || ((local_c.x != local_3c.x || (local_c.y != local_3c.y)))))) ||
		 (local_c.z != local_3c.z)) {
		lego::res::Container_SetOrientation
							(cont,(Container *)0x0,local_30.x,local_30.y,local_30.z,local_3c.x,local_3c.y,
							 local_3c.z);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_00443930(LiveObject *liveObj)
{
	short sVar1;
	BOOL BVar2;
	uint uVar3;
	undefined4 actData;
	
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
		BVar2 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj);
		if (BVar2 == 0) {
			uVar3 = 0;
			do {
				actData = 1;
				sVar1 = math::Maths_Rand();
				LiveObject_SetActivityUnk(liveObj,(int)sVar1 % 0x15 + ACTIVITY_WAITING1,actData);
				BVar2 = Game_UpdateSomeAITasks(liveObj);
				if (BVar2 != 0) {
					liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_8000;
					return 1;
				}
				uVar3 = uVar3 + 1;
			} while (uVar3 < 5);
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_CheckRockMonsterAnd_FUN_004439b0(LiveObject *liveObj)
{
	if ((liveObj->objType == OBJECT_ROCKMONSTER) &&
		 ((liveObj->flags3 & LIVEOBJ3_UNK_4000000) != LIVEOBJ3_NONE)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl FUN_004439d0(LiveObject *liveObj,uint *param_2,undefined4 *param_3,undefined4 param_4)
{
	LiveObject *liveObj_00;
	uint *puVar1;
	BOOL BVar2;
	int local_8;
	void *local_4;
	
	puVar1 = param_2;
	liveObj_00 = liveObj;
	local_8 = 0;
	BVar2 = FUN_00443b00(liveObj,(Point2I *)param_2,&local_8);
	if (BVar2 != 0) {
		return 0;
	}
	BVar2 = lego::game::LiveObject_FUN_004413b0
										(liveObj_00,*puVar1,puVar1[1],0,0,&local_4,&param_2,&liveObj,FUN_00443b00,
										 &local_8);
	if ((BVar2 == 0) &&
		 (BVar2 = lego::game::LiveObject_FUN_004413b0
												(liveObj_00,*puVar1,puVar1[1],0,0,&local_4,&param_2,&liveObj,FUN_00443b00,
												 &local_8), BVar2 == 0)) {
		return 0;
	}
	*param_3 = *(undefined4 *)((int)local_4 + (int)liveObj * 4 + -4);
	param_3[1] = param_2[(int)&liveObj[-1].pool_m_next + 3];
	std::free(local_4);
	std::free(param_2);
	return 1;
}



void __cdecl lego::game::LiveObject_RockMonster_DoWakeUp(LiveObject *liveObj)
{
	if (((liveObj->objType == OBJECT_ROCKMONSTER) &&
			((liveObj->flags3 & LIVEOBJ3_UNK_80000000) != LIVEOBJ3_NONE)) &&
		 ((liveObj->flags2 & LIVEOBJ2_UNK_20000000) == LIVEOBJ2_NONE)) {
		liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_20000000;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_WAKEUP,0);
		Game_UpdateSomeAITasks(liveObj);
	}
	return;
}



BOOL __cdecl FUN_00443b00(LiveObject *liveObj,Point2I *position,int *param_3)
{
	BOOL BVar1;
	int iVar2;
	
	if ((*param_3 == 0) &&
		 (BVar1 = lego::game::Level_GetBlockFlags1_10Not8(position->x,position->y), BVar1 != 0)) {
		return 0;
	}
	iVar2 = lego::game::LiveObject_FUN_00431cd0
										(liveObj,position->x,position->y,position->x,position->y,1);
	if (((iVar2 != 0) &&
			(BVar1 = lego::game::LiveObject_UnkGetDamage(liveObj,position->x,position->y,0.0,(float *)0x0)
			, BVar1 == 0)) && (BVar1 = lego::game::Level_GetBlockFlags1_180000(position), BVar1 == 0)) {
		return 1;
	}
	return 0;
}



float __cdecl FUN_00443b70(LiveObject *in_liveObj,float param_2)
{
	float fVar1;
	float fVar2;
	char cVar3;
	void *pvVar4;
	LiveObject *liveObj;
	short sVar5;
	LiveFlags3 LVar6;
	LiveFlags1 LVar7;
	LiveObject *pLVar8;
	ObjectStatsFlags1 OVar9;
	SurfaceMap *surfMap;
	BOOL BVar10;
	uint uVar11;
	int iVar12;
	float10 in_ST0;
	float10 extraout_ST0;
	float10 extraout_ST0_00;
	float10 extraout_ST0_01;
	float10 extraout_ST0_02;
	float10 extraout_ST0_03;
	float10 extraout_ST0_04;
	float10 extraout_ST0_05;
	float10 extraout_ST0_06;
	float10 extraout_ST0_07;
	float10 extraout_ST0_08;
	float10 fVar13;
	float10 extraout_ST1;
	ulonglong uVar14;
	longlong lVar15;
	float *out_x;
	float *out_y;
	uint local_2c;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	float local_18;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	liveObj = in_liveObj;
	iVar12 = 0;
	pvVar4 = in_liveObj->routeptr_24;
	local_1c = param_2;
	BVar10 = 1;
	if (pvVar4 == (void *)0x0) {
		in_ST0 = (float10)lego::game::LiveObject_UnkDoRouting_FUN_00441c00(in_liveObj,0);
	}
	else {
		if (in_liveObj->objType == OBJECT_VEHICLE) {
			in_liveObj->elapsedTime1 = 0.0;
		}
		if ((in_liveObj->vector_28c).x <= (in_liveObj->vector_28c).y) {
			LVar6 = in_liveObj->flags3;
			if ((LVar6 & 0x400) != LIVEOBJ3_NONE) {
				uVar11 = in_liveObj->routingBlocksCurrent;
				in_liveObj->flags3 = LVar6 & 0xfffffbff;
				switch(*(undefined *)((int)pvVar4 + uVar11 * 0x14 + 0x11)) {
				case 2:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_REINFORCING;
					break;
				case 3:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_UNK_200;
					break;
				case 4:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_CLEARING;
					break;
				case 5:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_UNK_800;
					break;
				case 6:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_UNK_1000000;
					break;
				case 7:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_UNK_2000;
					break;
				case 8:
					lego::game::LiveObject_FUN_0043a130(in_liveObj,1);
					break;
				case 9:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_PLACING;
					break;
				case 10:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_UNK_20000;
					break;
				case 0xb:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_EATING;
					break;
				case 0xc:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_4;
					break;
				case 0xd:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_40;
					break;
				case 0xe:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_TRAINING;
					break;
				case 0xf:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UPGRADING;
					break;
				case 0x10:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_200000;
					break;
				case 0x11:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_4000000;
					break;
				case 0x12:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_10000000;
					break;
				case 0x13:
					FUN_00444360(in_liveObj);
					break;
				case 0x14:
					lego::game::LiveObject_SetAITaskUnk(in_liveObj,AITASK_ATTACKOBJECT,(LiveObject *)0x0,1);
					break;
				case 0x15:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_80000000;
				}
				if ((*(byte *)((int)pvVar4 + uVar11 * 0x14 + 0x10) & 0x20) != 0) {
					liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_80000;
				}
				in_ST0 = (float10)lego::game::LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
				if ((liveObj->flags1 & 0x8000000) != LIVEOBJ1_NONE) {
					sVar5 = lego::math::Maths_Rand();
					uVar14 = __ftol((float10)10.0 / (float10)param_2);
					if ((int)((ulonglong)(uint)(int)sVar5 % (uVar14 & 0xffffffff)) != 0) {
						lego::game::LiveObject_FUN_00433b40(liveObj,150.0,1);
						return (float)extraout_ST0_00;
					}
					liveObj->flags1 = liveObj->flags1 & 0xf7ffffff;
					return (float)extraout_ST0;
				}
				goto LAB_004442ff;
			}
			if (in_liveObj->routingBlocksTotal < 2) {
				in_liveObj->flags3 = LVar6 | 0x400;
				*(byte *)((int)pvVar4 + in_liveObj->routingBlocksCurrent * 0x14 + 0x10) =
						 *(byte *)((int)pvVar4 + in_liveObj->routingBlocksCurrent * 0x14 + 0x10) | 8;
			}
			else {
				uVar11 = in_liveObj->routingBlocksCurrent + 1;
				in_liveObj->routingBlocksCurrent = uVar11;
				if (((*(byte *)((int)pvVar4 + uVar11 * 0x14 + 0x10) & 0x10) != 0) &&
					 (*(char *)((int)pvVar4 + uVar11 * 0x14 + 0x11) != '\x01')) {
					iVar12 = 1;
				}
			}
			uVar11 = in_liveObj->routingBlocksCurrent;
			if (iVar12 != 0) {
				uVar11 = uVar11 + 1;
			}
			if (*(char *)((int)pvVar4 + uVar11 * 0x14 + 0x11) == '\x05') {
				FUN_00447a90(in_liveObj);
			}
			BVar10 = FUN_00444940(liveObj,iVar12,liveObj->flags3 & 8,~liveObj->flags1 >> 10 & 1);
			in_ST0 = extraout_ST0_01;
			if (liveObj->routingBlocksTotal - 1 <= liveObj->routingBlocksCurrent) {
				liveObj->flags3 = liveObj->flags3 | 0x400;
			}
		}
		if (BVar10 != 0) {
			if ((((((*(byte *)&liveObj->flags1 & 8) == 0) &&
						(*(char *)((int)pvVar4 + liveObj->routingBlocksCurrent * 0x14 + 0x11) == '\x01')) &&
					 (BVar10 = lego::game::LiveObject_GetDrillNullPosition(liveObj,&local_20,&local_24),
					 BVar10 != 0)) &&
					((BVar10 = lego::game::Level_ToBlockCoordinatesNoZ
															 (local_20,local_24,(int *)&in_liveObj,(int *)&local_2c), BVar10 != 0
					 && (BVar10 = lego::game::Level_GetBlockFlags1_10Not8((uint)in_liveObj,local_2c),
							BVar10 != 0)))) &&
				 ((in_liveObj == *(LiveObject **)((int)pvVar4 + liveObj->routingBlocksCurrent * 0x14) &&
					(local_2c == *(uint *)((int)pvVar4 + liveObj->routingBlocksCurrent * 0x14 + 4))))) {
				BVar10 = 1;
				LVar6 = liveObj->flags3 & LIVEOBJ3_UNK_2000000;
				lVar15 = __ftol((float10)(liveObj->point_2f4).y);
				uVar11 = (uint)lVar15;
				lVar15 = __ftol((float10)(liveObj->point_2f4).x);
				BVar10 = lego::game::LiveObject_FUN_004326a0(liveObj,(uint)lVar15,uVar11,LVar6,BVar10);
				if (BVar10 == 0) {
					LVar7 = liveObj->flags1 | LIVEOBJ1_UNK_80000000;
				}
				else {
					LVar7 = liveObj->flags1 | (LIVEOBJ1_UNK_8|LIVEOBJ1_UNK_10);
				}
				liveObj->flags1 = LVar7;
			}
			lego::game::LiveObject_FUN_004468d0(liveObj,param_2,&local_28,&local_1c);
			if ((liveObj->flags3 & LIVEOBJ3_UNK_4000) == LIVEOBJ3_NONE) {
				(liveObj->vector_28c).y = local_28 + (liveObj->vector_28c).y;
			}
			fVar1 = (liveObj->vector_28c).y;
			fVar2 = (liveObj->vector_28c).x;
			if ((ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) == 0) {
				fVar1 = (liveObj->vector_28c).y;
				(liveObj->vector_28c).y = (liveObj->vector_28c).x;
				(liveObj->vector_28c).z = fVar1 - (liveObj->vector_28c).x;
			}
			FUN_004067f0((uint *)&liveObj->value_30,(liveObj->vector_28c).y,&local_18);
			cVar3 = *(char *)((int)pvVar4 + liveObj->routingBlocksCurrent * 0x14 + 0x11);
			in_ST0 = extraout_ST0_02;
			if (cVar3 == '\x03') {
				if (liveObj->object_2fc != (LiveObject *)0x0) {
					lego::game::LiveObject_GetPosition(liveObj->object_2fc,&local_8,&local_4);
					local_10 = local_8 - local_18;
					local_c = local_4 - local_14;
					param_2 = SQRT(local_c * local_c + local_10 * local_10);
					in_ST0 = extraout_ST0_03;
					if ((ushort)((ushort)(param_2 < 6.6) << 8 | (ushort)(param_2 == 6.6) << 0xe) != 0) {
						liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_200;
						in_ST0 = (float10)lego::game::LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
						if ((liveObj->objType == OBJECT_MINIFIGURE) && (param_2 != 0.0)) {
							lego::res::Creature_SetOrientation(liveObj->miniFigure,local_10,local_c);
							(liveObj->faceDirection).x = local_10;
							(liveObj->faceDirection).y = local_c;
							return (float)extraout_ST0_04;
						}
						goto LAB_004442ff;
					}
				}
			}
			else {
				if (cVar3 == '\f') {
					if (liveObj->object_2fc != (LiveObject *)0x0) {
						lego::game::LiveObject_GetPosition(liveObj->object_2fc,&local_8,&local_4);
						param_2 = SQRT((local_14 - local_4) * (local_14 - local_4) +
													 (local_18 - local_8) * (local_18 - local_8));
						fVar13 = lego::game::LiveObject_GetCollRadius(liveObj->object_2fc);
						in_ST0 = extraout_ST1;
						if ((ushort)((ushort)((float10)param_2 < fVar13) << 8 |
												(ushort)((float10)param_2 == fVar13) << 0xe) != 0) {
							liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_4;
							fVar13 = (float10)lego::game::LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
							return (float)fVar13;
						}
					}
				}
				else {
					if ((cVar3 == '\t') &&
						 ((*(byte *)((int)pvVar4 + liveObj->routingBlocksCurrent * 0x14 + 0x10) & 0xc) == 0)) {
						uVar11 = liveObj->value_30;
						local_8 = liveObj->floats_34[uVar11 * 2 + -2];
						local_4 = liveObj->floats_34[uVar11 * 2 + -1];
						param_2 = local_18 - local_8;
						fVar1 = SQRT((local_14 - local_4) * (local_14 - local_4) + param_2 * param_2);
						if ((ushort)((ushort)(fVar1 < 6.0) << 8 | (ushort)(fVar1 == 6.0) << 0xe) != 0) {
							liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_PLACING;
							fVar13 = (float10)lego::game::LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
							return (float)fVar13;
						}
					}
				}
			}
			if (((((liveObj->flags3 & 0x800) == LIVEOBJ3_NONE) &&
					 (cVar3 = *(char *)((int)pvVar4 + liveObj->routingBlocksCurrent * 0x14 + 0x11),
					 cVar3 != '\a')) && (cVar3 != '\x06')) &&
				 (((cVar3 != '\x03' && (cVar3 != '\x05')) &&
					(pLVar8 = (LiveObject *)lego::game::LiveObject_FUN_00446030(liveObj,&local_18,0,0),
					in_ST0 = extraout_ST0_05, pLVar8 != (LiveObject *)0x0)))) {
				OVar9 = lego::game::LiveObject_GetStatsFlags1(liveObj);
				if (((OVar9 & STATS1_BUMPDAMAGE) != STATS1_NONE) && (pLVar8->objType == OBJECT_VEHICLE)) {
					lego::game::LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
					lego::game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_REPAIR,0);
					lego::game::Game_UpdateSomeAITasks(liveObj);
					liveObj->object_2fc = pLVar8;
					liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_40000;
					return (float)extraout_ST0_06;
				}
				FUN_00444940(liveObj,0,0,0);
				fVar1 = (liveObj->vector_28c).y;
				liveObj->flags3 = liveObj->flags3 | 0x800;
				(liveObj->vector_28c).y = local_28 + fVar1;
				in_ST0 = extraout_ST0_07;
			}
			if ((liveObj->flags3 & LIVEOBJ3_UNK_4000) == LIVEOBJ3_NONE) {
				in_ST0 = (float10)lego::game::LiveObject_FUN_004428b0(liveObj,local_18,local_14);
			}
			if ((*(char *)((int)pvVar4 + liveObj->routingBlocksTotal * 0x14 + -3) == '\x04') &&
				 (liveObj->objType == OBJECT_VEHICLE)) {
				out_y = &local_4;
				out_x = &local_8;
				surfMap = lego::game::GetSurfaceMap();
				lego::game::SurfaceMap_ToBlockCoordinatesNoZ
									(surfMap,local_18,local_14,(int *)out_x,(int *)out_y);
				in_ST0 = extraout_ST0_08;
				if ((local_8 == *(float *)((int)pvVar4 + liveObj->routingBlocksTotal * 0x14 + -0x14)) &&
					 (local_4 == *(float *)((int)pvVar4 + liveObj->routingBlocksTotal * 0x14 + -0x10))) {
					liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_CLEARING;
					fVar13 = (float10)lego::game::LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
					return (float)fVar13;
				}
			}
		}
	}
LAB_004442ff:
	return (float)in_ST0;
}



void __cdecl FUN_00444360(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	
	pLVar1 = liveObj->object_2fc;
	if ((pLVar1 != (LiveObject *)0x0) && (pLVar1->objType == OBJECT_BUILDING)) {
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_40;
		pLVar1->flags4 = pLVar1->flags4 | LIVEOBJ4_UNK_40;
		lego::game::LiveObject_SetAITaskUnk(liveObj,AITASK_DOCK,(LiveObject *)0x0,1);
	}
	return;
}



void __cdecl FUN_004443b0(LiveObject *liveObj,float elapsed)
{
	uint uVar1;
	float10 fVar2;
	Point2I local_8;
	
	if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
		 ((liveObj->objType != OBJECT_ROCKMONSTER ||
			(liveObj->carriedObjects[0]->objType == OBJECT_BOULDER)))) {
		fVar2 = lego::game::LiveObject_GetCarryMinHealth(liveObj);
		if ((fVar2 < (float10)liveObj->health) && ((*(byte *)&liveObj->flags4 & 0x20) == 0)) {
			fVar2 = lego::game::LiveObject_GetRestPercent(liveObj);
			if ((((float)(fVar2 * (float10)0.01) != 0.0) && ((*(byte *)&liveObj->flags1 & 4) == 0)) &&
				 ((float)(fVar2 * (float10)0.01) * liveObj->health < liveObj->float_33c * 0.04)) {
				lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_8,&local_8.y);
				uVar1 = lego::game::Level_IsBlockLava(&local_8);
				if (((uVar1 == 0) &&
						((lego::globals::g_Game.level)->blocks
						 [((lego::globals::g_Game.level)->dimensions).width * local_8.y + local_8.x].terrain !=
						 TERRAIN_LAKE)) && (liveObj->routingBlocksCurrent != liveObj->routingBlocksTotal - 1)) {
					liveObj->float_33c = 0.0;
					liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_4000;
					liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_REST;
					lego::game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_REST,0);
					lego::game::Game_UpdateSomeAITasks(liveObj);
				}
			}
			liveObj->float_33c = elapsed + liveObj->float_33c;
			return;
		}
		lego::game::LiveObject_FUN_0043a130(liveObj,0);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_00444520(LiveObject *liveObj)
{
	int iVar1;
	short sVar2;
	BOOL BVar3;
	int iVar4;
	int iVar5;
	SurfaceMap *surfMap;
	uint uVar6;
	uint y;
	float10 fVar7;
	float *pfVar8;
	int local_90;
	float *local_8c;
	int local_88;
	float *local_84;
	uint local_80;
	uint local_7c;
	float local_78;
	float local_74;
	Point2I ANGLES [8];
	float local_30;
	float local_2c;
	float local_18;
	float local_14;
	
	ANGLES[0].x = -1;
	ANGLES[0].y = 0;
	ANGLES[1].x = -1;
	ANGLES[1].y = 1;
	ANGLES[2].x = 0;
	ANGLES[2].y = 1;
	ANGLES[3].x = 1;
	ANGLES[3].y = 1;
	ANGLES[4].x = 1;
	ANGLES[4].y = 0;
	ANGLES[5].x = 1;
	ANGLES[5].y = -1;
	ANGLES[6].x = 0;
	ANGLES[6].y = -1;
	ANGLES[7].x = -1;
	ANGLES[7].y = -1;
	BVar3 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj);
	if (BVar3 != 0) {
		return 0;
	}
	LiveObject_GetBlockCoordinates(liveObj,&local_90,&local_88);
	local_80 = 0;
	do {
		sVar2 = math::Maths_Rand();
		uVar6 = (int)sVar2 >> 0x1f;
										// positive modulus 8 (???)
		iVar4 = (((int)sVar2 ^ uVar6) - uVar6 & 7 ^ uVar6) - uVar6;
		iVar1 = ANGLES[iVar4].y;
		iVar4 = ANGLES[iVar4].x;
		iVar5 = LiveObject_FUN_00431cd0
											(liveObj,local_90 + iVar4,local_88 + iVar1,local_90 + iVar4,local_88 + iVar1,0
											);
		if (iVar5 != 0) {
			pfVar8 = &local_30;
			y = local_88 + iVar1;
			uVar6 = local_90 + iVar4;
			surfMap = GetSurfaceMap();
			SurfaceMap_FillStruct30_FUN_00450390(surfMap,uVar6,y,pfVar8);
			fVar7 = math::Maths_RandRange(local_30 - -1.0,local_18 - 1.0);
			local_78 = (float)fVar7;
			fVar7 = math::Maths_RandRange(local_2c - -1.0,local_14 - 1.0);
			local_74 = (float)fVar7;
			BVar3 = LiveObject_FUN_004413b0
												(liveObj,local_90,local_88,local_90 + iVar4,local_88 + iVar1,&local_8c,
												 &local_84,&local_7c,0,0);
			if (BVar3 != 0) {
				BVar3 = LiveObject_FUN_004419c0(liveObj,local_7c,local_8c,local_84,&local_78);
				if (BVar3 != 0) {
					std::free(local_8c);
					std::free(local_84);
					return 1;
				}
				std::free(local_8c);
				std::free(local_84);
			}
		}
		local_80 = local_80 + 1;
	} while (local_80 < 0x10);
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_00444720(LiveObject *liveObj,Point2F *param_2)
{
	BOOL BVar1;
	SurfaceMap *surfMap;
	float in_x;
	float in_y;
	char **out_x;
	VehicleData **out_y;
	VehicleData **local_20;
	uint local_1c;
	float local_18;
	float local_14;
	char *local_10;
	VehicleData *local_c;
	char *local_8;
	VehicleData *local_4;
	LiveObject *liveObj_00;
	
	liveObj_00 = liveObj;
	LiveObject_GetBlockCoordinates(liveObj,(int *)&local_10,(int *)&local_c);
	if (((((liveObj_00->flags1 & LIVEOBJ1_UNK_800000) == LIVEOBJ1_NONE) &&
			 (BVar1 = LiveObject_CheckCondition_FUN_00438870(liveObj_00,1), BVar1 != 0)) &&
			(BVar1 = LiveObject_Check_FUN_004294f0(liveObj_00), BVar1 == 0)) &&
		 ((liveObj_00->drivenObject == (LiveObject *)0x0 &&
			(BVar1 = Level_GetBlockFlags1_10Not8((uint)local_10,(uint)local_c), BVar1 == 0)))) {
		LiveObject_FUN_00441df0(liveObj_00,1,1);
		LiveObject_GetPosition(liveObj_00,&local_18,&local_14);
		out_x = &local_8;
		in_x = globals::g_Game.MiniFigureRunAway * param_2->x + local_18;
		out_y = &local_4;
		in_y = param_2->y * globals::g_Game.MiniFigureRunAway + local_14;
		local_18 = in_x;
		local_14 = in_y;
		surfMap = GetSurfaceMap();
		BVar1 = SurfaceMap_ToBlockCoordinatesNoZ(surfMap,in_x,in_y,(int *)out_x,(int *)out_y);
		if (BVar1 != 0) {
			if ((local_8 == local_10) && (local_4 == local_c)) {
				liveObj = (LiveObject *)&local_10;
				local_20 = &local_c;
				local_1c = 1;
			}
			else {
				BVar1 = LiveObject_FUN_004413b0
													(liveObj_00,local_10,local_c,local_8,local_4,&liveObj,&local_20,&local_1c,
													 0,0);
				if (BVar1 == 0) {
					return;
				}
			}
			BVar1 = LiveObject_FUN_004419c0
												(liveObj_00,local_1c,(float *)liveObj,(float *)local_20,&local_18);
			if (BVar1 != 0) {
				*(byte *)((int)liveObj_00->routeptr_24 + liveObj_00->routingBlocksTotal * 0x14 + -4) =
						 *(byte *)((int)liveObj_00->routeptr_24 + liveObj_00->routingBlocksTotal * 0x14 + -4) |
						 0x40;
			}
			std::free(liveObj);
			std::free(local_20);
			liveObj_00->flags1 = liveObj_00->flags1 | LIVEOBJ1_UNK_800000;
			LiveObject_MiniFigure_FUN_00407380(liveObj_00);
		}
	}
	return;
}



void __cdecl lego::ai::AI_LiveObject_DoSlip(LiveObject *liveObj)
{
	if (((liveObj->flags1 & LIVEOBJ1_UNK_4000000) == LIVEOBJ1_NONE) &&
		 (liveObj->drivenObject == (LiveObject *)0x0)) {
		game::LiveObject_FUN_00441df0(liveObj,0,1);
		liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_4000000;
		game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_SLIP,0);
		game::Game_UpdateSomeAITasks(liveObj);
		AITask_DoAnimationWait(liveObj);
	}
	return;
}



BOOL __cdecl FUN_00444940(LiveObject *liveObj,int param_2,int param_3,int param_4)
{
	Vector3F *out_vector;
	uint *puVar1;
	byte bVar2;
	LiveFlags1 LVar3;
	LiveFlags3 LVar4;
	SurfaceMap *pSVar5;
	uint uVar6;
	float fVar7;
	BOOL BVar8;
	int iVar9;
	uint uVar10;
	float *pfVar11;
	float fVar12;
	float10 fVar13;
	float fVar14;
	uint uVar15;
	uint y;
	float unkMultiplier;
	float *pfVar16;
	ActivityType AVar17;
	float local_74;
	float local_70;
	float local_6c;
	float local_68;
	undefined4 local_64;
	BOOL local_60;
	uint local_5c;
	uint local_58;
	float local_54;
	float local_50;
	float local_4c;
	float local_48;
	float local_44;
	float local_40;
	float local_3c;
	float local_38;
	float local_34;
	float local_30;
	Vector3F local_2c;
	float local_20 [4];
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_6c = 0.0;
	local_70 = 0.0;
	local_60 = 1;
	uVar10 = *(uint *)((int)liveObj->routeptr_24 + liveObj->routingBlocksCurrent * 0x14);
	y = *(uint *)((int)liveObj->routeptr_24 + liveObj->routingBlocksCurrent * 0x14 + 4);
	lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_58,(int *)&local_5c);
	lego::game::LiveObject_GetPosition(liveObj,&local_3c,&local_38);
	local_44 = (liveObj->faceDirection).x;
	local_40 = (liveObj->faceDirection).y;
	out_vector = &liveObj->faceDirection;
	if (param_2 == 0) {
		pfVar11 = &local_48;
		pfVar16 = &local_4c;
		pSVar5 = lego::game::GetSurfaceMap();
		lego::game::SurfaceMap_FUN_0044f900(pSVar5,uVar10,y,pfVar16,pfVar11);
	}
	else {
		pfVar11 = &local_30;
		uVar6 = *(uint *)((int)liveObj->routeptr_24 + liveObj->routingBlocksCurrent * 0x14 + 4);
		pfVar16 = &local_34;
		uVar15 = *(uint *)((int)liveObj->routeptr_24 + liveObj->routingBlocksCurrent * 0x14);
		pSVar5 = lego::game::GetSurfaceMap();
		lego::game::SurfaceMap_FUN_0044f900(pSVar5,uVar15,uVar6,pfVar16,pfVar11);
		uVar6 = liveObj->routingBlocksCurrent + 1;
		liveObj->routingBlocksCurrent = uVar6;
		pfVar11 = &local_48;
		pfVar16 = &local_4c;
		puVar1 = (uint *)((int)liveObj->routeptr_24 + uVar6 * 0x14);
		uVar6 = *puVar1;
		uVar15 = puVar1[1];
		pSVar5 = lego::game::GetSurfaceMap();
		lego::game::SurfaceMap_FUN_0044f900(pSVar5,uVar6,uVar15,pfVar16,pfVar11);
		local_58 = uVar10;
		local_5c = y;
	}
	pfVar16 = &local_50;
	pfVar11 = &local_54;
	pSVar5 = lego::game::GetSurfaceMap();
	lego::game::SurfaceMap_FUN_0044f900(pSVar5,local_58,local_5c,pfVar11,pfVar16);
	fVar12 = local_6c;
	fVar7 = local_70;
	if (*(char *)((int)liveObj->routeptr_24 + liveObj->routingBlocksCurrent * 0x14 + 0x11) != '\x01')
	{
		pfVar11 = &local_74;
		pfVar16 = &local_70;
		fVar12 = local_4c;
		fVar7 = local_48;
		pSVar5 = lego::game::GetSurfaceMap();
		lego::game::SurfaceMap_ToBlockCoordinatesNoZ(pSVar5,fVar12,fVar7,(int *)pfVar16,(int *)pfVar11);
		fVar7 = (float)FUN_00432f00((int)local_70,(int)local_74);
		BVar8 = lego::game::Level_GetBlockFlags1_10Not8((uint)local_70,(uint)local_74);
		fVar12 = local_6c;
		if ((BVar8 != 0) &&
			 (iVar9 = FUN_00432ac0((int)local_70,(int)local_74), fVar12 = local_6c, iVar9 == 0)) {
			uVar10 = FUN_00432f30((int)local_70,(int)local_74);
			if (uVar10 != 0) {
				if (ABS(local_4c - local_54) <= ABS(local_48 - local_50)) {
					local_20[0] = 0.1;
					local_20[1] = 0.0;
					local_20[2] = -0.1;
					local_20[3] = 0.0;
					local_10 = 0xbdcccccd;
					local_c = 0;
					local_8 = 0x3dcccccd;
					local_4 = 0;
					uVar10 = FUN_004331f0((int)local_70,(int)local_74);
					pfVar11 = local_20 + uVar10 * 2;
				}
				else {
					local_20[0] = 0.0;
					local_20[1] = -0.1;
					local_20[2] = 0.0;
					local_20[3] = -0.1;
					local_10 = 0;
					local_c = 0x3dcccccd;
					local_8 = 0;
					local_4 = 0x3dcccccd;
					uVar10 = FUN_004331f0((int)local_70,(int)local_74);
					pfVar11 = local_20 + uVar10 * 2;
				}
				local_4c = *pfVar11 + local_4c;
				local_48 = pfVar11[1] + local_48;
			}
			pfVar11 = &local_48;
			pfVar16 = &local_4c;
			unkMultiplier = 0.05;
			uVar10 = FUN_00432f00((int)local_70,(int)local_74);
			fVar12 = local_4c;
			fVar14 = local_48;
			pSVar5 = lego::game::GetSurfaceMap();
			lego::game::SurfaceMap_FUN_0044fe50(pSVar5,fVar12,fVar14,uVar10,unkMultiplier,pfVar16,pfVar11)
			;
			fVar12 = 1.401298e-45;
		}
	}
	if (fVar12 == 0.0) {
		pSVar5 = lego::game::GetSurfaceMap();
		fVar13 = lego::game::SurfaceMap_GetBlockSize(pSVar5);
		local_6c = (float)(((float10)*(float *)((int)liveObj->routeptr_24 +
																					 liveObj->routingBlocksCurrent * 0x14 + 8) - (float10)0.5)
											* fVar13);
		pSVar5 = lego::game::GetSurfaceMap();
		fVar13 = lego::game::SurfaceMap_GetBlockSize(pSVar5);
		local_68 = (float)(((float10)*(float *)((int)liveObj->routeptr_24 +
																					 liveObj->routingBlocksCurrent * 0x14 + 0xc) -
											 (float10)0.5) * fVar13);
		local_4c = local_6c + local_4c;
		local_48 = local_68 + local_48;
	}
	bVar2 = *(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksCurrent * 0x14 + 0x10);
	if ((bVar2 & 4) == 0) {
		if ((bVar2 & 0x40) == 0) {
			if (((bVar2 & 8) != 0) && ((local_6c != 0.0 || (local_68 != 0.0)))) {
				local_54 = local_6c;
				local_50 = local_68;
				goto LAB_00444e0b;
			}
			local_54 = local_4c - local_54;
			fVar14 = local_48 - local_50;
			local_50 = fVar14;
			if ((fVar12 != 0.0) && (fVar7 == 0.0)) {
				local_50 = fVar7;
				if (ABS(local_54) <= ABS(fVar14)) {
					local_54 = 0.0;
					local_50 = fVar14;
				}
				goto LAB_00444e0b;
			}
			if ((local_54 != 0.0) || (fVar14 != 0.0)) goto LAB_00444e0b;
		}
		local_54 = local_4c - local_3c;
		local_50 = local_48 - local_38;
		goto LAB_00444e0b;
	}
	switch(bVar2 & 3) {
	case 0:
		local_54 = 0.0;
		local_50 = 1.0;
		param_3 = 0;
		goto LAB_00444e0b;
	case 1:
		local_54 = 1.0;
		break;
	case 2:
		local_54 = 0.0;
		local_50 = -1.0;
		param_3 = 0;
		goto LAB_00444e0b;
	case 3:
		local_54 = -1.0;
		break;
	default:
		goto switchD_00444cce_caseD_4;
	}
	local_50 = 0.0;
switchD_00444cce_caseD_4:
	param_3 = 0;
LAB_00444e0b:
	if (param_3 != 0) {
		local_2c.x = local_4c - local_3c;
		fVar12 = local_48 - local_38;
		local_2c.z = 0.0;
		local_64 = 0;
		local_2c.y = 1.0 / SQRT(fVar12 * fVar12 + local_2c.x * local_2c.x);
		local_68 = 1.0 / SQRT(local_40 * local_40 + local_44 * local_44);
		fVar7 = 1.0 / SQRT(local_50 * local_50 + local_54 * local_54);
		local_2c.x = local_2c.y * local_2c.x;
		local_2c.y = local_2c.y * fVar12;
		local_6c = local_68 * local_44;
		local_68 = local_68 * local_40;
		local_74 = fVar7 * local_50 * local_68 + fVar7 * local_54 * local_6c;
		local_70 = local_2c.y * local_68 + local_2c.x * local_6c + 0.0;
		if (((param_4 == 0) ||
				((ushort)((ushort)(local_74 < 0.7) << 8 | (ushort)(local_74 == 0.7) << 0xe) != 0)) ||
			 (-0.7 <= local_70)) {
			if (((((ushort)((ushort)(local_74 < 0.0) << 8 | (ushort)(local_74 == 0.0) << 0xe) != 0) &&
					 (local_70 < 0.7)) &&
					((ushort)((ushort)(ABS(local_70) < 0.1) << 8 | (ushort)(ABS(local_70) == 0.1) << 0xe) == 0
					)) || (BVar8 = FUN_00445860(liveObj), BVar8 != 0)) {
				if (-0.9 <= local_74) {
					fVar12 = local_2c.x * (liveObj->faceDirection).z;
					fVar7 = local_2c.x * (liveObj->faceDirection).y;
					fVar14 = out_vector->x * local_2c.y;
					local_2c.x = local_2c.y * (liveObj->faceDirection).z -
											 local_2c.z * (liveObj->faceDirection).y;
					local_2c.y = out_vector->x * local_2c.z - fVar12;
					local_2c.z = fVar7 - fVar14;
					lego::math::Maths_Vector3DRotate(out_vector,out_vector,&local_2c,-1.570796);
					if (liveObj->objType != OBJECT_VEHICLE) {
						local_44 = out_vector->x;
						local_40 = (liveObj->faceDirection).y;
					}
					if ((ushort)((ushort)(local_2c.z < 0.0) << 8 | (ushort)(local_2c.z == 0.0) << 0xe) == 0) {
						if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
							AVar17 = ACTIVITY_TURNRIGHT;
						}
						else {
							AVar17 = ACTIVITY_CARRYTURNRIGHT;
						}
					}
					else {
						if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
							AVar17 = ACTIVITY_TURNLEFT;
						}
						else {
							AVar17 = ACTIVITY_CARRYTURNLEFT;
						}
					}
					lego::game::LiveObject_SetActivityUnk(liveObj,AVar17,1);
				}
				else {
					if (liveObj->objType != OBJECT_VEHICLE) {
						local_44 = -out_vector->x;
						out_vector->x = local_44;
						local_40 = -(liveObj->faceDirection).y;
						(liveObj->faceDirection).y = local_40;
					}
					if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
						AVar17 = ACTIVITY_TURNRIGHT;
					}
					else {
						AVar17 = ACTIVITY_CARRYTURNRIGHT;
					}
					lego::game::LiveObject_SetActivityUnk(liveObj,AVar17,0);
					if (liveObj->objType != OBJECT_VEHICLE) {
						liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_TURNRIGHT;
					}
				}
				LVar3 = liveObj->flags1;
				liveObj->flags1 = LVar3 | LIVEOBJ1_TURNING;
				if (liveObj->objType != OBJECT_VEHICLE) {
					local_60 = 0;
					liveObj->flags1 = LVar3 & ~LIVEOBJ1_MOVING | LIVEOBJ1_TURNING;
				}
			}
		}
		else {
			local_44 = -local_44;
			local_40 = -local_40;
			local_54 = -local_54;
			local_50 = -local_50;
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_LIFTING;
		}
	}
	local_6c = SQRT((local_38 - local_48) * (local_38 - local_48) +
									(local_3c - local_4c) * (local_3c - local_4c)) * 0.2;
	if ((ushort)((ushort)(local_6c < 0.1) << 8 | (ushort)(local_6c == 0.1) << 0xe) == 0) {
		fVar12 = (float)std::_finite((double)local_44);
		if (fVar12 == 0.0) {
			local_44 = 1.0;
			local_40 = fVar12;
		}
		FUN_00406690(&local_44,local_6c);
		FUN_00406690(&local_54,local_6c * 1.6);
		FUN_00406750((uint *)&liveObj->value_30,&local_3c,&local_44,&local_4c,&local_54,0x32);
		FUN_004454a0(liveObj);
	}
	else {
		liveObj->floats_34[0] = local_3c;
		liveObj->floats_34[1] = local_38;
		liveObj->value_30 = 0;
	}
	fVar13 = FUN_004066e0((uint *)&liveObj->value_30);
	LVar4 = liveObj->flags3;
	fVar12 = (liveObj->vector_28c).z;
	(liveObj->vector_28c).x = (float)fVar13;
	(liveObj->point_298).x = local_54;
	liveObj->flags3 = LVar4 & 0xfffff7ff;
	(liveObj->vector_28c).y = fVar12;
	(liveObj->point_298).y = local_50;
	return local_60;
}



void __cdecl lego::game::LiveObject_FUN_00445270(LiveObject *liveObj,Point2F *point)
{
	Vector3F *out_vector;
	float fVar1;
	float fVar2;
	float fVar3;
	LiveFlags1 LVar4;
	ActivityType actType;
	float10 fVar5;
	Vector3F local_c;
	
	if (liveObj->objType != OBJECT_MINIFIGURE) {
		return;
	}
	fVar1 = (liveObj->faceDirection).y;
	fVar2 = (liveObj->faceDirection).z;
	out_vector = &liveObj->faceDirection;
	local_c.x = point->x;
	fVar3 = point->y;
	local_c.z = 0.0;
	fVar1 = 1.0 / SQRT(out_vector->x * out_vector->x + fVar2 * fVar2 + fVar1 * fVar1);
	local_c.y = 1.0 / SQRT(fVar3 * fVar3 + local_c.x * local_c.x);
	local_c.x = local_c.y * local_c.x;
	out_vector->x = out_vector->x * fVar1;
	local_c.y = local_c.y * fVar3;
	(liveObj->faceDirection).y = fVar1 * (liveObj->faceDirection).y;
	(liveObj->faceDirection).z = fVar1 * (liveObj->faceDirection).z;
	fVar5 = std::acos((float10)(liveObj->faceDirection).y * (float10)local_c.y +
										(float10)(liveObj->faceDirection).z * (float10)0.0 +
										(float10)out_vector->x * (float10)local_c.x);
	fVar1 = (float)fVar5;
	LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
	if ((ushort)((ushort)(fVar1 < 2.356194) << 8 | (ushort)(fVar1 == 2.356194) << 0xe) == 0) {
		LVar4 = liveObj->flags1;
		out_vector->x = -out_vector->x;
		(liveObj->faceDirection).y = -(liveObj->faceDirection).y;
		liveObj->flags1 = LVar4 | LIVEOBJ1_TURNRIGHT;
	}
	else {
		if ((ushort)((ushort)(fVar1 < 0.7853982) << 8 | (ushort)(fVar1 == 0.7853982) << 0xe) != 0) {
			return;
		}
		fVar1 = local_c.x * (liveObj->faceDirection).z;
		fVar2 = local_c.x * (liveObj->faceDirection).y;
		fVar3 = out_vector->x * local_c.y;
		local_c.x = local_c.y * (liveObj->faceDirection).z - local_c.z * (liveObj->faceDirection).y;
		local_c.y = out_vector->x * local_c.z - fVar1;
		local_c.z = fVar2 - fVar3;
		math::Maths_Vector3DRotate(out_vector,out_vector,&local_c,-1.570796);
		actType = ACTIVITY_TURNLEFT;
		if (local_c.z < 0.0) goto LAB_00445461;
	}
	actType = ACTIVITY_TURNRIGHT;
LAB_00445461:
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		actType = (actType == ACTIVITY_TURNRIGHT) + ACTIVITY_CARRYTURNLEFT;
	}
	liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_TURNING;
	LiveObject_SetActivityUnk(liveObj,actType,0);
	Game_UpdateSomeAITasks(liveObj);
	return;
}



void __cdecl FUN_004454a0(LiveObject *in_liveObj)
{
	char cVar1;
	LiveObject *liveObj;
	ObjectStatsFlags1 OVar2;
	SurfaceMap *pSVar3;
	BOOL BVar4;
	float *pfVar5;
	uint uVar6;
	float10 fVar7;
	float fVar8;
	uint x;
	float fVar9;
	LiveObject *y;
	uint *out_x;
	char **out_x_00;
	LiveObject **out_y;
	VehicleData **out_y_00;
	uint local_14;
	LiveObject *local_10;
	float local_c;
	char *local_8;
	VehicleData *local_4;
	
	liveObj = in_liveObj;
	OVar2 = lego::game::LiveObject_GetStatsFlags1(in_liveObj);
	if (((((OVar2 & STATS1_ROUTEAVOIDANCE) != STATS1_NONE) &&
			 (cVar1 = *(char *)((int)liveObj->routeptr_24 + liveObj->routingBlocksCurrent * 0x14 + 0x11),
			 cVar1 != '\a')) && (cVar1 != '\x03')) && ((cVar1 != '\x06' && (cVar1 != '\x05')))) {
		local_10 = liveObj;
		OVar2 = lego::game::LiveObject_GetStatsFlags1(liveObj);
		if ((OVar2 & STATS1_COLLRADIUS) != STATS1_NONE) {
			lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00445600,(LiveObject *)&local_10);
		}
		uVar6 = 0;
		if (liveObj->value_30 != 0) {
			pfVar5 = liveObj->floats_34;
			do {
				fVar9 = pfVar5[1];
				out_y = &in_liveObj;
				out_x = &local_14;
				fVar8 = *pfVar5;
				pSVar3 = lego::game::GetSurfaceMap();
				lego::game::SurfaceMap_ToBlockCoordinatesNoZ(pSVar3,fVar8,fVar9,(int *)out_x,(int *)out_y);
				BVar4 = lego::game::Level_BlockCheck_FUN_004329d0(local_14,(int)in_liveObj,0);
				if (BVar4 != 0) {
					out_y_00 = &local_4;
					out_x_00 = &local_8;
					x = local_14;
					y = in_liveObj;
					pSVar3 = lego::game::GetSurfaceMap();
					lego::game::SurfaceMap_FUN_0044f900(pSVar3,x,(uint)y,(float *)out_x_00,(float *)out_y_00);
					fVar8 = *pfVar5 - (float)local_8;
					fVar9 = pfVar5[1] - (float)local_4;
					local_c = SQRT(fVar8 * fVar8 + fVar9 * fVar9);
					*pfVar5 = (1.0 / local_c) * fVar8;
					pfVar5[1] = (1.0 / local_c) * fVar9;
					pSVar3 = lego::game::GetSurfaceMap();
					fVar7 = lego::game::SurfaceMap_GetBlockSize(pSVar3);
					*pfVar5 = (float)(fVar7 * (float10)0.71 * (float10)*pfVar5 + (float10)(float)local_8);
					pfVar5[1] = (float)(fVar7 * (float10)0.71 * (float10)pfVar5[1] + (float10)(float)local_4);
				}
				uVar6 = uVar6 + 1;
				pfVar5 = pfVar5 + 2;
			} while (uVar6 < (uint)liveObj->value_30);
		}
	}
	return;
}



BOOL __cdecl FUN_00445600(LiveObject *liveObj1,LiveObject **param_2)
{
	float fVar1;
	LiveObject *pLVar2;
	int iVar3;
	float fVar4;
	ObjectStatsFlags1 OVar5;
	uint uVar6;
	float *pfVar7;
	float10 fVar8;
	float10 fVar9;
	float10 fVar10;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pLVar2 = *param_2;
	if ((((liveObj1 != pLVar2) && (liveObj1->carryingThisObject != pLVar2)) &&
			(liveObj1->object_300 != pLVar2)) && ((liveObj1->flags3 & 0x2000) == LIVEOBJ3_NONE)) {
		OVar5 = lego::game::LiveObject_GetStatsFlags1(liveObj1);
		if ((OVar5 & STATS1_CAUSESLIP) == STATS1_NONE) {
			pLVar2 = *param_2;
			fVar8 = lego::game::LiveObject_GetCollRadius(pLVar2);
			lego::game::LiveObject_GetPosition(liveObj1,&local_8,&local_4);
			uVar6 = 1;
			if (1 < pLVar2->value_30 - 1U) {
				pfVar7 = pLVar2->floats_34 + 3;
				do {
					fVar4 = local_4 - *pfVar7;
					fVar1 = local_8 - pfVar7[-1];
					fVar9 = lego::game::LiveObject_GetCollRadius(liveObj1);
					if ((float10)SQRT(fVar1 * fVar1 + fVar4 * fVar4) < fVar9 + (float10)(float)fVar8) {
						local_10 = pfVar7[-1] - local_8;
						fVar1 = *pfVar7 - local_4;
						local_c = SQRT(fVar1 * fVar1 + local_10 * local_10);
						if (local_c == 0.0) {
							fVar9 = lego::math::Maths_RandRange(0.0,1.0);
							fVar1 = (float)fVar9;
							fVar9 = lego::math::Maths_RandRange(0.0,1.0);
							fVar10 = (float10)1.0 /
											 SQRT(fVar9 * (float10)(float)fVar9 + (float10)fVar1 * (float10)fVar1);
							local_10 = (float)(fVar10 * (float10)fVar1);
							local_c = (float)(fVar10 * (float10)(float)fVar9);
						}
						else {
							local_c = 1.0 / local_c;
							local_10 = local_c * local_10;
							local_c = local_c * fVar1;
						}
						fVar9 = lego::game::LiveObject_GetCollRadius(liveObj1);
						fVar9 = fVar9 + (float10)(float)fVar8;
						pfVar7[-1] = (pfVar7[-3] +
												 pfVar7[1] + (float)(fVar9 * (float10)local_10 + (float10)local_8)) *
												 0.3333333;
						*pfVar7 = (pfVar7[-2] + pfVar7[2] + (float)fVar9 * local_c + local_4) * 0.3333333;
					}
					uVar6 = uVar6 + 1;
					pfVar7 = pfVar7 + 2;
				} while (uVar6 < pLVar2->value_30 - 1U);
			}
			iVar3 = pLVar2->value_30;
			fVar1 = pLVar2->floats_34[iVar3 * 2 + -3];
			pfVar7 = pLVar2->floats_34 + iVar3 * 2 + -1;
			pfVar7[-1] = (pLVar2->floats_34[iVar3 * 2 + -4] - pLVar2->floats_34[iVar3 * 2 + -6]) +
									 pfVar7[-3];
			*pfVar7 = pfVar7[-2] + (fVar1 - pfVar7[-4]);
		}
	}
	return 0;
}



BOOL __cdecl FUN_00445860(LiveObject *liveObj)
{
	BOOL BVar1;
	SurfaceMap *pSVar2;
	float10 fVar3;
	float fVar4;
	float in_y;
	uint *out_x;
	uint *out_y;
	uint local_20;
	uint local_1c;
	uint local_18;
	uint local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_14,(int *)&local_18);
	BVar1 = lego::game::Level_GetBlockFlags1_10Not8(local_14,local_18);
	if (BVar1 != 0) {
		return 0;
	}
	lego::game::LiveObject_GetPosition(liveObj,&local_8,&local_4);
	local_10 = (liveObj->faceDirection).x;
	local_c = (liveObj->faceDirection).y;
	fVar4 = 1.0 / SQRT(local_c * local_c + local_10 * local_10);
	pSVar2 = lego::game::GetSurfaceMap();
	fVar3 = lego::game::SurfaceMap_GetBlockSize(pSVar2);
	out_y = &local_20;
	local_c = fVar4 * local_c * (float)(fVar3 * (float10)0.3333333);
	local_10 = fVar4 * local_10 * (float)(fVar3 * (float10)0.3333333);
	in_y = local_c + local_4;
	fVar4 = local_10 + local_8;
	out_x = &local_1c;
	local_8 = fVar4;
	local_4 = in_y;
	pSVar2 = lego::game::GetSurfaceMap();
	lego::game::SurfaceMap_ToBlockCoordinatesNoZ(pSVar2,fVar4,in_y,(int *)out_x,(int *)out_y);
	BVar1 = lego::game::Level_GetBlockFlags1_10Not8(local_1c,local_20);
	if ((BVar1 == 0) &&
		 (BVar1 = lego::game::Level_BlockCheck_FUN_004329d0(local_1c,local_20,0), BVar1 == 0)) {
		return 0;
	}
	return 1;
}



void __cdecl lego::game::LiveObject_FUN_004459a0(LiveObject *liveObj)
{
	uint uVar1;
	float10 fVar2;
	
	if (liveObj->objType == OBJECT_ROCKMONSTER) {
		unk::DoLiveObjCallbacks_True_FUN_00437a70(LiveObject_FUN_00445af0,liveObj);
	}
	if (((liveObj->objType == OBJECT_DYNAMITE) || (liveObj->objType == OBJECT_OOHSCARY)) &&
		 ((liveObj->flags3 & 0x10000) != LIVEOBJ3_NONE)) {
		uVar1 = res::Container_GetAnimationFrames(liveObj->other);
		fVar2 = res::Container_GetAnimationTime(liveObj->other);
		if ((float10)(ulonglong)uVar1 - (float10)75.0 < fVar2) {
			unk::DoLiveObjCallbacks_True_FUN_00437a70(LiveObject_FUN_00445a30,liveObj);
		}
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_00445a30(LiveObject *liveObj1,LiveObject *liveObj2)
{
	float fVar1;
	float fVar2;
	float fVar3;
	Vector3F local_18;
	Vector3F local_c;
	
	if ((liveObj1->objType == OBJECT_MINIFIGURE) &&
		 ((*(byte *)&liveObj1->flags5_3f0 & LIVEOBJ5_UNK_8) != 0)) {
		LiveObject_GetPosition(liveObj1,(float *)&local_18,&local_18.y);
		LiveObject_GetPosition(liveObj2,&local_18.z,(float *)&local_c);
		fVar3 = local_18.x - local_18.z;
		fVar1 = local_18.y - local_c.x;
		fVar2 = SQRT(fVar1 * fVar1 + fVar3 * fVar3);
		if (fVar2 < globals::g_Game.DynamiteDamageRadius) {
			fVar2 = 1.0 / fVar2;
			local_c.y = fVar2 * fVar3;
			local_c.z = fVar2 * fVar1;
			LiveObject_FUN_00444720(liveObj1,(Point2F *)&local_c.y);
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_00445af0(LiveObject *liveObj1,LiveObject *liveObj2)
{
	float fVar1;
	float fVar2;
	float fVar3;
	ObjectStatsFlags1 OVar4;
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar5;
	uint weaponType;
	float10 fVar6;
	float10 fVar7;
	float in_x;
	float in_y;
	LiveObject *liveObj;
	uint *puVar8;
	float *out_y;
	float fVar9;
	ObjectType local_34;
	int local_30;
	Point2F local_2c;
	Point2F local_24;
	Point2F local_1c;
	uint local_14;
	float local_10;
	Vector3F local_c;
	
	LiveObject_GetPosition(liveObj2,(float *)&local_1c,&local_1c.y);
	LiveObject_GetPosition(liveObj1,(float *)&local_24,&local_24.y);
	local_2c.x = local_24.x - local_1c.x;
	local_2c.y = local_24.y - local_1c.y;
	fVar2 = SQRT(local_2c.y * local_2c.y + local_2c.x * local_2c.x);
	fVar6 = LiveObject_GetAlertRadius(liveObj2);
	fVar1 = (float)fVar6;
	if ((liveObj2->flags3 & LIVEOBJ3_UNK_80000000) == LIVEOBJ3_NONE) {
		if (((((liveObj1->flags2 & LIVEOBJ2_UNK_2) == LIVEOBJ2_NONE) &&
				 ((liveObj1->flags2 & LIVEOBJ2_UNK_100) == LIVEOBJ2_NONE)) &&
				((((byte)globals::g_Game.flags2 & 1) == 0 || ((*(byte *)&liveObj1->flags4 & 4) == 0)))) &&
			 (liveObj1->drivenObject == (LiveObject *)0x0)) {
			if (liveObj1->objType == OBJECT_MINIFIGURE) {
				OVar4 = LiveObject_GetStatsFlags1(liveObj2);
				if ((OVar4 & STATS1_GRABMINIFIGURE) != STATS1_NONE) {
					cont = LiveObject_GetResource(liveObj2);
					res::Container_GetOrientation(cont,(Container *)0x0,&local_c,(Vector3F *)0x0);
					out_y = &local_10;
					puVar8 = &local_14;
					fVar9 = 1.0 / SQRT(local_c.y * local_c.y + local_c.x * local_c.x);
					fVar3 = fVar9 * local_c.y * 15.0 + local_1c.y;
					fVar9 = fVar9 * local_c.x * 15.0 + local_1c.x;
					in_x = fVar9;
					in_y = fVar3;
					surfMap = GetSurfaceMap();
					SurfaceMap_ToBlockCoordinatesNoZ(surfMap,in_x,in_y,(int *)puVar8,(int *)out_y);
					BVar5 = Level_GetBlockFlags1_10Not8(local_14,(uint)local_10);
					if (BVar5 == 0) {
						BVar5 = Level_BlockCheck_FUN_004329d0(local_14,(int)local_10,1);
						if (BVar5 == 0) {
							fVar9 = local_24.x - fVar9;
							fVar3 = local_24.y - fVar3;
							fVar6 = LiveObject_GetCollRadius(liveObj1);
							if ((float10)SQRT(fVar3 * fVar3 + fVar9 * fVar9) < fVar6) {
								ai::AI_LiveObject_DoThrowLegoman(liveObj2,liveObj1);
								return 0;
							}
						}
					}
				}
				OVar4 = LiveObject_GetStatsFlags1(liveObj2);
				if ((OVar4 & STATS1_CAUSESLIP) != STATS1_NONE) {
					fVar6 = LiveObject_GetCollRadius(liveObj2);
					fVar7 = LiveObject_GetCollRadius(liveObj1);
					if ((ushort)((ushort)(fVar7 + (float10)(float)fVar6 < (float10)fVar2) << 8 |
											(ushort)(fVar7 + (float10)(float)fVar6 == (float10)fVar2) << 0xe) == 0) {
						ai::AI_LiveObject_DoSlip(liveObj1);
						liveObj2->health = -1.0;
						liveObj2->flags3 = liveObj2->flags3 | LIVEOBJ3_UNK_800000;
					}
				}
				OVar4 = LiveObject_GetStatsFlags1(liveObj2);
				if (((OVar4 & STATS1_CANSCARE) != STATS1_NONE) && (fVar1 != 0.0)) {
					fVar6 = LiveObject_GetCollRadius(liveObj1);
					if ((float10)fVar2 < fVar6 + (float10)fVar1) {
						local_2c.x = (1.0 / fVar2) * local_2c.x;
						local_2c.y = (1.0 / fVar2) * local_2c.y;
						LiveObject_FUN_00444720(liveObj1,&local_2c);
					}
				}
			}
			if (((liveObj1->objType == OBJECT_VEHICLE) || (liveObj1->objType == OBJECT_MINIFIGURE)) &&
				 ((liveObj1->flags1 & LIVEOBJ1_UNK_200) == LIVEOBJ1_NONE)) {
				fVar6 = LiveObject_GetPainThreshold(liveObj2);
				if (fVar6 < (float10)liveObj2->health) {
					fVar6 = LiveObject_GetStampRadius(liveObj2);
					if ((ushort)((ushort)(fVar6 < (float10)fVar2) << 8 |
											(ushort)(fVar6 == (float10)fVar2) << 0xe) == 0) {
						LiveObject_FUN_0043acb0(liveObj2,liveObj1);
					}
				}
			}
			if ((liveObj1->objType == OBJECT_MINIFIGURE) || (liveObj1->objType == OBJECT_VEHICLE)) {
				OVar4 = LiveObject_GetStatsFlags1(liveObj2);
				if (((OVar4 & STATS1_SCAREDBYPLAYER) != STATS1_NONE) &&
					 ((liveObj2->flags1 & 0x8000000) == LIVEOBJ1_NONE)) {
					fVar6 = LiveObject_GetCollRadius(liveObj1);
					if ((float10)fVar2 < fVar6 + (float10)fVar1) {
						BVar5 = LiveObject_FUN_00444520(liveObj2);
						if (BVar5 != 0) {
							liveObj2->flags1 = liveObj2->flags1 | 0x8000000;
						}
					}
				}
			}
			if (liveObj1->objType == OBJECT_MINIFIGURE) {
				OVar4 = LiveObject_GetStatsFlags1(liveObj2);
				if ((OVar4 & STATS1_FLOCKS) != STATS1_NONE) {
					fVar3 = local_24.x - (float)liveObj2->flocksData_32c->field_18;
					local_10 = local_24.y - (float)liveObj2->flocksData_32c->field_20;
					fVar9 = local_10 * local_10;
					fVar6 = LiveObject_GetCollRadius(liveObj1);
					if ((float10)SQRT(fVar9 + fVar3 * fVar3) < fVar6 + (float10)fVar1) {
						fVar9 = 1.0;
						BVar5 = 1;
						liveObj = liveObj1;
						weaponType = tools::Weapon_GetWeaponTypeByName("BatAttack");
						fVar6 = Weapon_GetDamageForLiveObject(weaponType,liveObj);
						LiveObject_FUN_0043f960(liveObj1,(float)fVar6,BVar5,fVar9);
						liveObj2->flags2 = liveObj2->flags2 | 0x80;
						if ((*(byte *)&liveObj2->flocksData_32c->field_24 & 1) == 0) {
							ai::AITask_DoFollow_Group(&liveObj2,1,liveObj1);
							puVar8 = &liveObj2->flocksData_32c->field_24;
							*puVar8 = *puVar8 | 1;
						}
					}
				}
			}
			OVar4 = LiveObject_GetStatsFlags1(liveObj2);
			if ((OVar4 & STATS1_CANSCARESCORPION) != STATS1_NONE) {
				BVar5 = Object_GetObjectByName("Scorpion",&local_34,&local_30,(Container **)0x0);
				if (((BVar5 != 0) && (local_34 == liveObj1->objType)) &&
					 ((local_30 == liveObj1->objIndex && (fVar1 != 0.0)))) {
					fVar6 = LiveObject_GetCollRadius(liveObj1);
					if ((float10)fVar2 < fVar6 + (float10)fVar1) {
						local_2c.x = (1.0 / fVar2) * local_2c.x;
						local_2c.y = (1.0 / fVar2) * local_2c.y;
						LiveObject_FUN_00444720(liveObj1,&local_2c);
					}
				}
			}
		}
	}
	else {
		if ((liveObj1->objType == OBJECT_MINIFIGURE) || (liveObj1->objType == OBJECT_VEHICLE)) {
			fVar6 = LiveObject_GetWakeRadius(liveObj2);
			if ((ushort)((ushort)(fVar6 < (float10)fVar2) << 8 | (ushort)(fVar6 == (float10)fVar2) << 0xe)
					== 0) {
				LiveObject_RockMonster_DoWakeUp(liveObj2);
				return 1;
			}
		}
	}
	return 0;
}



VehicleData * __cdecl
lego::game::LiveObject_FUN_00446030
					(LiveObject *liveObj,int param_2,char *param_3,CreatureData *param_4)
{
	ObjectStatsFlags1 OVar1;
	LiveObject *local_14;
	int local_10;
	char *local_c;
	VehicleData *local_8;
	CreatureData *local_4;
	
	local_10 = param_2;
	local_14 = liveObj;
	local_c = param_3;
	local_8 = (VehicleData *)0x0;
	local_4 = param_4;
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_COLLBOX) != STATS1_NONE) {
		unk::DoLiveObjCallbacks_True_FUN_00437a70
							(LiveObject_Callback_FUN_004463b0,(LiveObject *)&local_14);
	}
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_COLLRADIUS) != STATS1_NONE) {
		unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_004460b0,(LiveObject *)&local_14);
	}
	return local_8;
}



BOOL __cdecl FUN_004460b0(undefined4 *param_1,int *param_2)
{
	LiveObject *liveObj;
	float fVar1;
	ObjectStatsFlags1 OVar2;
	Container *cont;
	float *pfVar3;
	int iVar4;
	BOOL BVar5;
	Vector3F *out_vector;
	Point2F *pPVar6;
	float10 fVar7;
	float10 fVar8;
	float10 fVar9;
	float local_60;
	float local_5c;
	Point2F local_58;
	Point2F local_50 [3];
	float local_38;
	float local_34;
	Vector3F local_30;
	float local_24;
	undefined4 local_20;
	float local_1c;
	float local_18;
	undefined4 local_14;
	float local_10;
	float local_c;
	undefined4 local_8;
	float local_4;
	
	liveObj = (LiveObject *)*param_2;
	if (((((param_2[4] == 0) ||
				(OVar2 = lego::game::LiveObject_GetStatsFlags1(liveObj),
				(OVar2 & STATS1_STOREOBJECTS) == STATS1_NONE)) && ((LiveObject *)param_1 != liveObj)) &&
			(((LiveObject *)param_1[0xc1] != liveObj &&
			 (liveObj->carryingThisObject != (LiveObject *)param_1)))) &&
		 (((LiveObject *)param_1 != liveObj->drivenObject &&
			(((liveObj->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE &&
			 ((param_1[0xf8] & 0x600000) == 0)))))) {
		fVar7 = lego::game::LiveObject_GetCollHeight((LiveObject *)param_1);
		if ((ushort)((ushort)(fVar7 < (float10)(float)param_2[2]) << 8 |
								(ushort)(fVar7 == (float10)(float)param_2[2]) << 0xe) == 0) {
			lego::game::LiveObject_GetPosition((LiveObject *)param_1,&local_60,&local_5c);
			cont = lego::game::LiveObject_GetResource((LiveObject *)param_1);
			local_60 = local_60 - *(float *)param_2[1];
			local_5c = local_5c - ((float *)param_2[1])[1];
			fVar1 = SQRT(local_5c * local_5c + local_60 * local_60);
			OVar2 = lego::game::LiveObject_GetStatsFlags1((LiveObject *)param_1);
			if ((OVar2 & STATS1_COLLRADIUS) == STATS1_NONE) {
				OVar2 = lego::game::LiveObject_GetStatsFlags1((LiveObject *)param_1);
				if ((OVar2 & STATS1_COLLBOX) != STATS1_NONE) {
					fVar8 = lego::game::LiveObject_GetCollRadius(liveObj);
					fVar9 = lego::game::LiveObject_GetCollRadius((LiveObject *)param_1);
					fVar7 = (float10)fVar1;
					if ((ushort)((ushort)(fVar9 + (float10)(float)fVar8 < fVar7) << 8 |
											(ushort)(fVar9 + (float10)(float)fVar8 == fVar7) << 0xe) == 0) {
						pfVar3 = (float *)lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
						local_30.x = *pfVar3 * -0.5;
						iVar4 = lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
						local_30.z = *(float *)(iVar4 + 4) * 0.5;
						pfVar3 = (float *)lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
						local_24 = *pfVar3 * 0.5;
						iVar4 = lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
						local_1c = *(float *)(iVar4 + 4) * 0.5;
						pfVar3 = (float *)lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
						local_18 = *pfVar3 * 0.5;
						iVar4 = lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
						local_10 = *(float *)(iVar4 + 4) * -0.5;
						pfVar3 = (float *)lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
						local_c = *pfVar3 * -0.5;
						iVar4 = lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
						local_4 = *(float *)(iVar4 + 4) * -0.5;
						local_8 = 0;
						local_14 = 0;
						local_20 = 0;
						local_30.y = 0.0;
						pPVar6 = &local_58;
						out_vector = &local_30;
						iVar4 = 4;
						do {
							lego::res::Container_Transform(cont,out_vector,out_vector);
							fVar1 = out_vector->y;
							pPVar6->x = out_vector->x;
							pPVar6->y = fVar1;
							out_vector = out_vector + 1;
							pPVar6 = pPVar6 + 1;
							iVar4 = iVar4 + -1;
						} while (iVar4 != 0);
						local_38 = local_58.x;
						local_34 = local_58.y;
						BVar5 = lego::math::Maths_PointInsidePoly((Point2F *)param_2[1],&local_58,local_50,4);
						if (BVar5 == 0) {
							fVar7 = lego::math::Math_FUN_00408a30((Point2F *)param_2[1],&local_58,local_50,4);
							fVar8 = lego::game::LiveObject_GetCollRadius(liveObj);
							if ((ushort)((ushort)(fVar8 < (float10)(float)fVar7) << 8 |
													(ushort)(fVar8 == (float10)(float)fVar7) << 0xe) == 0) {
								param_2[3] = (int)param_1;
							}
						}
						else {
							param_2[3] = (int)param_1;
						}
					}
				}
			}
			else {
				fVar8 = lego::game::LiveObject_GetCollRadius(liveObj);
				fVar9 = lego::game::LiveObject_GetCollRadius((LiveObject *)param_1);
				fVar7 = (float10)fVar1;
				if ((ushort)((ushort)(fVar9 + (float10)(float)fVar8 < fVar7) << 8 |
										(ushort)(fVar9 + (float10)(float)fVar8 == fVar7) << 0xe) == 0) {
					param_2[3] = (int)param_1;
				}
			}
		}
		if (param_2[3] != 0) {
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_Callback_FUN_004463b0(LiveObject *in_liveObj,int **param_2)
{
	float fVar1;
	LiveObject *liveObj;
	ObjectStatsFlags1 OVar2;
	float *pfVar3;
	int iVar4;
	BOOL BVar5;
	float *pfVar6;
	int iVar7;
	LiveObject **ppLVar8;
	Point2F *pPVar9;
	Vector3F *out_vector;
	Vector3F *pVVar10;
	float10 fVar11;
	float10 fVar12;
	float local_f8;
	float local_f4;
	Point2F local_f0;
	LiveObject *local_e8 [2];
	Container *local_e0;
	Container *local_dc;
	Vector3F local_d8;
	float local_cc;
	undefined4 local_c8;
	float local_c4;
	float local_c0;
	undefined4 local_bc;
	float local_b8;
	float local_b4;
	Point2F local_b0;
	Point2F local_a8 [4];
	Point2F local_88;
	Point2F local_80 [3];
	float local_68;
	float local_64;
	Vector3F local_60 [4];
	Vector3F local_30 [4];
	
	local_e8[1] = (LiveObject *)*param_2;
	if (((((param_2[4] == (int *)0x0) ||
				(OVar2 = LiveObject_GetStatsFlags1(local_e8[1]),
				(OVar2 & STATS1_STOREOBJECTS) == STATS1_NONE)) && (in_liveObj != local_e8[1])) &&
			((in_liveObj->carryingThisObject != local_e8[1] &&
			 (local_e8[1]->carryingThisObject != in_liveObj)))) &&
		 (((local_e8[1]->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE &&
			(((in_liveObj->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE &&
			 (fVar11 = LiveObject_GetCollHeight(in_liveObj),
			 (ushort)((ushort)(fVar11 < (float10)(float)param_2[2]) << 8 |
							 (ushort)(fVar11 == (float10)(float)param_2[2]) << 0xe) == 0)))))) {
		LiveObject_GetPosition(in_liveObj,(float *)&local_f0,&local_f0.y);
		LiveObject_GetPosition(local_e8[1],&local_f8,&local_f4);
		local_f8 = local_f8 - (float)*param_2[1];
		local_f4 = local_f4 - (float)param_2[1][1];
		local_dc = LiveObject_GetResource(in_liveObj);
		local_e0 = LiveObject_GetResource(local_e8[1]);
		OVar2 = LiveObject_GetStatsFlags1(in_liveObj);
		if ((OVar2 & STATS1_COLLRADIUS) == STATS1_NONE) {
			OVar2 = LiveObject_GetStatsFlags1(in_liveObj);
			if ((OVar2 & STATS1_COLLBOX) != STATS1_NONE) {
				local_f0.y = local_f0.y - (float)param_2[1][1];
				local_f0.x = local_f0.x - (float)*param_2[1];
				fVar11 = LiveObject_GetCollRadius(in_liveObj);
				local_e8[0] = (LiveObject *)(float)fVar11;
				fVar11 = LiveObject_GetCollRadius(local_e8[1]);
				if ((float10)SQRT(local_f0.x * local_f0.x + local_f0.y * local_f0.y) <
						fVar11 + (float10)(float)local_e8[0]) {
					local_e8[0] = in_liveObj;
					ppLVar8 = local_e8;
					iVar4 = 2;
					pfVar3 = &local_60[0].z;
					do {
						liveObj = *ppLVar8;
						pfVar6 = (float *)LiveObject_GetCollBox(liveObj);
						pfVar3[-2] = *pfVar6 * -0.5;
						iVar7 = LiveObject_GetCollBox(liveObj);
						*pfVar3 = *(float *)(iVar7 + 4) * 0.5;
						pfVar6 = (float *)LiveObject_GetCollBox(liveObj);
						pfVar3[1] = *pfVar6 * 0.5;
						iVar7 = LiveObject_GetCollBox(liveObj);
						pfVar3[3] = *(float *)(iVar7 + 4) * 0.5;
						pfVar6 = (float *)LiveObject_GetCollBox(liveObj);
						pfVar3[4] = *pfVar6 * 0.5;
						iVar7 = LiveObject_GetCollBox(liveObj);
						pfVar3[6] = *(float *)(iVar7 + 4) * -0.5;
						pfVar6 = (float *)LiveObject_GetCollBox(liveObj);
						pfVar3[7] = *pfVar6 * -0.5;
						iVar7 = LiveObject_GetCollBox(liveObj);
						ppLVar8 = ppLVar8 + 1;
						iVar4 = iVar4 + -1;
						pfVar3[9] = *(float *)(iVar7 + 4) * -0.5;
						pfVar3[8] = 0.0;
						pfVar3[5] = 0.0;
						pfVar3[2] = 0.0;
						pfVar3[-1] = 0.0;
						pfVar3 = pfVar3 + 0xc;
					} while (iVar4 != 0);
					pPVar9 = &local_b0;
					pVVar10 = local_30;
					iVar4 = 4;
					do {
						res::Container_Transform(local_e0,pVVar10,pVVar10);
						fVar1 = pVVar10->y;
						pPVar9->x = pVVar10->x;
						pPVar9->y = fVar1;
						pVVar10 = pVVar10 + 1;
						pPVar9 = pPVar9 + 1;
						iVar4 = iVar4 + -1;
					} while (iVar4 != 0);
					pVVar10 = &local_d8;
					out_vector = local_60;
					iVar4 = 4;
					do {
						res::Container_Transform(local_dc,out_vector,out_vector);
						fVar1 = out_vector->y;
						pVVar10->x = out_vector->x;
						pVVar10->y = fVar1;
						out_vector = out_vector + 1;
						pVVar10 = (Vector3F *)&pVVar10->z;
						iVar4 = iVar4 + -1;
					} while (iVar4 != 0);
					pfVar3 = &local_b8;
					iVar4 = 2;
					do {
						*pfVar3 = pfVar3[-8];
						pfVar3[1] = pfVar3[-7];
						pfVar3 = pfVar3 + 10;
						iVar4 = iVar4 + -1;
					} while (iVar4 != 0);
					pVVar10 = &local_d8;
					iVar4 = 4;
					do {
						BVar5 = math::Maths_PointInsidePoly((Point2F *)pVVar10,&local_b0,local_a8,4);
						if (BVar5 != 0) {
							param_2[3] = (int *)in_liveObj;
						}
						pVVar10 = (Vector3F *)&pVVar10->z;
						iVar4 = iVar4 + -1;
					} while (iVar4 != 0);
				}
			}
		}
		else {
			local_f0.y = local_f0.y - (float)param_2[1][1];
			local_f0.x = local_f0.x - (float)*param_2[1];
			fVar11 = LiveObject_GetCollRadius(in_liveObj);
			local_e8[0] = (LiveObject *)(float)fVar11;
			fVar11 = LiveObject_GetCollRadius(local_e8[1]);
			if ((float10)SQRT(local_f0.x * local_f0.x + local_f0.y * local_f0.y) <
					fVar11 + (float10)(float)local_e8[0]) {
				pfVar3 = (float *)LiveObject_GetCollBox(local_e8[1]);
				local_d8.x = *pfVar3 * -0.5;
				iVar4 = LiveObject_GetCollBox(local_e8[1]);
				local_d8.z = *(float *)(iVar4 + 4) * 0.5;
				pfVar3 = (float *)LiveObject_GetCollBox(local_e8[1]);
				local_cc = *pfVar3 * 0.5;
				iVar4 = LiveObject_GetCollBox(local_e8[1]);
				local_c4 = *(float *)(iVar4 + 4) * 0.5;
				pfVar3 = (float *)LiveObject_GetCollBox(local_e8[1]);
				local_c0 = *pfVar3 * 0.5;
				iVar4 = LiveObject_GetCollBox(local_e8[1]);
				local_b8 = *(float *)(iVar4 + 4) * -0.5;
				pfVar3 = (float *)LiveObject_GetCollBox(local_e8[1]);
				local_b4 = *pfVar3 * -0.5;
				iVar4 = LiveObject_GetCollBox(local_e8[1]);
				local_b0.y = *(float *)(iVar4 + 4) * -0.5;
				local_b0.x = 0.0;
				local_bc = 0;
				local_c8 = 0;
				local_d8.y = 0.0;
				pVVar10 = &local_d8;
				iVar4 = 4;
				pPVar9 = &local_88;
				do {
					res::Container_Transform(local_e0,pVVar10,pVVar10);
					fVar1 = pVVar10->y;
					pPVar9->x = pVVar10->x;
					pPVar9->y = fVar1;
					pVVar10 = pVVar10 + 1;
					iVar4 = iVar4 + -1;
					pPVar9->x = local_f8 + pPVar9->x;
					pPVar9->y = local_f4 + pPVar9->y;
					pPVar9 = pPVar9 + 1;
				} while (iVar4 != 0);
				local_68 = local_88.x;
				local_64 = local_88.y;
				BVar5 = math::Maths_PointInsidePoly(&local_f0,&local_88,local_80,4);
				if (BVar5 == 0) {
					fVar11 = math::Math_FUN_00408a30(&local_f0,&local_88,local_80,4);
					fVar12 = LiveObject_GetCollRadius(in_liveObj);
					if ((ushort)((ushort)(fVar12 < (float10)(float)fVar11) << 8 |
											(ushort)(fVar12 == (float10)(float)fVar11) << 0xe) == 0) {
						param_2[3] = (int *)in_liveObj;
					}
				}
				else {
					param_2[3] = (int *)in_liveObj;
				}
			}
		}
		if (param_2[3] != (int *)0x0) {
			return TRUE;
		}
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_FUN_004468d0
					(LiveObject *in_liveObj,float elapsed,float *param_3,float *out_float_4)
{
	LiveFlags1 LVar1;
	ObjectType OVar2;
	ulonglong uVar3;
	LiveObject *liveObj;
	float *pfVar4;
	SurfaceMap *surfMap;
	BOOL BVar5;
	ObjectStatsFlags2 OVar6;
	float10 fVar7;
	Point2I *out_x;
	int *out_y;
	float *out_unk_z;
	float local_1c;
	Point2I local_18;
	float local_10;
	float local_c;
	uint local_8;
	undefined4 uStack4;
	
	pfVar4 = param_3;
	liveObj = in_liveObj;
	LVar1 = in_liveObj->flags1;
	local_1c = (float)(LVar1 & 0x2000000);
	OVar2 = in_liveObj->objType;
	if (OVar2 == OBJECT_VEHICLE) {
		fVar7 = res::Vehicle_GetFloat14(in_liveObj->vehicle);
		in_liveObj = (LiveObject *)(float)fVar7;
	}
	else {
		if (OVar2 == OBJECT_MINIFIGURE) {
			fVar7 = LiveObject_GetCreatureResFloat(in_liveObj->miniFigure);
			in_liveObj = (LiveObject *)(float)fVar7;
		}
		else {
			if (OVar2 == OBJECT_ROCKMONSTER) {
				fVar7 = LiveObject_GetCreatureResFloat(in_liveObj->rockMonster);
				in_liveObj = (LiveObject *)(float)fVar7;
			}
			else {
				if (OVar2 == OBJECT_BUILDING) {
					fVar7 = res::Building_GetAnimFloat14_zero(in_liveObj->building);
					in_liveObj = (LiveObject *)(float)fVar7;
				}
				else {
					if (((in_liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) ||
						 (OVar2 == OBJECT_UPGRADEPART)) {
						*out_float_4 = elapsed;
						return;
					}
				}
			}
		}
	}
	if ((LVar1 & LIVEOBJ1_UNK_8) == LIVEOBJ1_NONE) {
		if (((LVar1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) || (liveObj->objType == OBJECT_VEHICLE)) {
			fVar7 = LiveObject_GetRouteSpeed(liveObj);
			*param_3 = (float)fVar7;
			if ((LVar1 & LIVEOBJ1_LIFTING) != LIVEOBJ1_NONE) {
				*param_3 = (float)(fVar7 * (float10)0.5);
			}
		}
		else {
			fVar7 = LiveObject_GetRouteSpeed(liveObj);
			*param_3 = (float)(fVar7 * (float10)0.5);
		}
	}
	else {
		fVar7 = LiveObject_GetRouteSpeed(liveObj);
		*param_3 = (float)(fVar7 * (float10)0.05);
	}
	if (local_1c != 0.0) {
		*param_3 = *param_3 * 0.05;
	}
	local_1c = 1.0;
	LiveObject_GetPosition(liveObj,&local_10,&local_c);
	out_unk_z = &local_1c;
	out_y = &local_18.y;
	out_x = &local_18;
	surfMap = GetSurfaceMap();
	BVar5 = SurfaceMap_ToBlockCoordinates(surfMap,local_10,local_c,(int *)out_x,out_y,out_unk_z);
	if (BVar5 != 0) {
		local_8 = Level_GetBlockRubbleLevel_OrFlag200000(&local_18);
		uStack4 = 0;
		uVar3 = (ulonglong)local_8;
		fVar7 = LiveObject_GetRubbleCoef(liveObj);
		param_3 = (float *)(float)((float10)1.0 -
															((float10)1.0 - fVar7) * (float10)((float)uVar3 * 0.25));
		BVar5 = Level_IsBlockPowerPath(&local_18);
		if (BVar5 != 0) {
			fVar7 = LiveObject_GetPathCoef(liveObj);
			param_3 = (float *)(float)(fVar7 * (float10)(float)param_3);
		}
		if ((liveObj->objType == OBJECT_MINIFIGURE) &&
			 ((globals::g_Game.level)->blocks
				[((globals::g_Game.level)->dimensions).width * local_18.y + local_18.x].terrain ==
				TERRAIN_LAKE)) {
			param_3 = (float *)((1.0 - local_1c * 0.8) * (float)param_3);
		}
		BVar5 = Level_GetBlockFlags1_8(local_18.x,local_18.y);
		if (BVar5 != 0) {
			*pfVar4 = *pfVar4 * (float)param_3;
		}
	}
	if ((float)in_liveObj == 0.0) {
		*out_float_4 = 1.0;
	}
	else {
		*out_float_4 = *pfVar4 / (float)in_liveObj;
	}
	if (((liveObj->objType == OBJECT_BUILDING) &&
			(OVar6 = LiveObject_GetStatsFlags2(liveObj), (OVar6 & STATS2_UPGRADEBUILDING) != STATS2_NONE))
		 && ((liveObj->flags2 & LIVEOBJ2_UPGRADING) != LIVEOBJ2_NONE)) {
		fVar7 = LiveObject_GetFunctionCoef(liveObj);
		*out_float_4 = (float)(fVar7 * (float10)*out_float_4);
	}
	*out_float_4 = *out_float_4 * elapsed;
	*pfVar4 = *pfVar4 * elapsed;
	return;
}



BOOL __cdecl
lego::game::LiveObject_RoutingPtr_Important_FUN_00446b80
					(LiveObject *liveObj,int param_2,int param_3)
{
	uint uVar1;
	int iVar2;
	int iVar3;
	void *pvVar4;
	
	if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_MOVING) != 0) {
		uVar1 = liveObj->routingBlocksTotal;
		pvVar4 = liveObj->routeptr_24;
		iVar2 = *(int *)((int)pvVar4 + uVar1 * 0x14 + -0x14);
		iVar3 = *(int *)((int)pvVar4 + uVar1 * 0x14 + -0x10);
		if ((((param_2 == iVar2) && ((param_3 == iVar3 + -1 || (param_3 == iVar3 + 1)))) ||
				((param_3 == iVar3 && ((param_2 == iVar2 + -1 || (param_2 == iVar2 + 1)))))) &&
			 (pvVar4 = std::realloc(pvVar4,(uVar1 + 1) * 0x14), pvVar4 != (void *)0x0)) {
			liveObj->routeptr_24 = pvVar4;
			*(int *)((int)pvVar4 + liveObj->routingBlocksTotal * 0x14) = param_2;
			*(int *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + 4) = param_3;
			*(undefined4 *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + 8) =
					 0x3f000000;
			*(undefined4 *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + 0xc) =
					 0x3f000000;
			*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + 0x10) = 0;
			*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + 0x11) = 1;
			liveObj->routingBlocksTotal = liveObj->routingBlocksTotal + 1;
			liveObj->flags3 = liveObj->flags3 & 0xfffffbff;
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_FUN_00446c80
					(LiveObject *liveObj,uint param_2,uint param_3,int param_4,uint *param_5,int param_6)
{
	float fVar1;
	bool bVar2;
	SurfaceMap *pSVar3;
	BOOL BVar4;
	undefined4 uVar5;
	uint y;
	int iVar6;
	float **ppfVar7;
	uint uVar8;
	float *pfVar9;
	int *piVar10;
	uint uVar11;
	uint uVar12;
	longlong lVar13;
	float **ppfVar14;
	float **ppfVar15;
	uint *puVar16;
	float *out_x;
	undefined4 callback;
	undefined4 uVar17;
	int *local_11c;
	float *local_118;
	BOOL local_114;
	float local_110;
	float local_10c;
	uint local_108;
	float local_104;
	float local_100;
	undefined4 uStack252;
	uint local_f8;
	uint local_f4;
	float local_f0;
	float local_ec;
	float local_e8;
	float local_e4;
	float local_e0;
	undefined4 local_dc;
	undefined4 local_d8;
	undefined4 local_d4;
	undefined4 local_d0;
	undefined4 local_cc;
	undefined4 local_c8;
	undefined4 local_c4;
	float local_c0;
	undefined4 local_bc;
	undefined4 local_b8;
	undefined4 local_b4;
	undefined4 local_b0;
	undefined4 local_ac;
	undefined4 local_a8;
	undefined4 local_a4;
	undefined4 local_a0;
	undefined4 local_9c;
	undefined4 local_98;
	undefined4 local_94;
	undefined4 local_90;
	undefined4 local_8c;
	undefined4 local_88;
	undefined4 local_84;
	int local_80 [8];
	float *local_60 [8];
	float *local_40 [8];
	uint local_20 [8];
	
	local_108 = 0xffffffff;
	local_f8 = 0xffffffff;
	local_f4 = 0xffffffff;
	piVar10 = local_80;
	local_80[0] = 0;
	local_b8 = 0;
	for (iVar6 = 7; piVar10 = piVar10 + 1, iVar6 != 0; iVar6 = iVar6 + -1) {
		*piVar10 = 0;
	}
	local_a4 = 0;
	local_a0 = 0;
	local_8c = 0;
	local_e0 = 0.0;
	local_d4 = 0;
	local_d0 = 0;
	local_c4 = 0;
	local_114 = 0;
	local_c0 = -1.0;
	local_bc = 0xc0000000;
	local_b4 = 0xc0000000;
	local_b0 = 0x3f800000;
	local_ac = 0xbf800000;
	local_a8 = 0x3f800000;
	local_9c = 0x3f800000;
	local_98 = 0xbf800000;
	local_94 = 0x3f800000;
	local_90 = 0xc0000000;
	local_88 = 0xc0000000;
	local_84 = 0xbf800000;
	local_dc = 0xbf800000;
	local_d8 = 0x3f800000;
	local_cc = 0x3f800000;
	local_c8 = 0xbf800000;
	bVar2 = true;
	if (param_4 == 0) {
		local_118 = &local_e0;
		uVar8 = 4;
	}
	else {
		local_118 = &local_c0;
		uVar8 = 8;
	}
	LiveObject_GetBlockCoordinates(liveObj,(int *)&local_110,(int *)&local_10c);
	if (param_6 == 0) {
		pfVar9 = &local_ec;
		out_x = &local_f0;
		uVar12 = param_2;
		uVar11 = param_3;
		pSVar3 = GetSurfaceMap();
		SurfaceMap_FUN_0044f900(pSVar3,uVar12,uVar11,out_x,pfVar9);
		LiveObject_GetPosition(liveObj,&local_e8,&local_e4);
		local_104 = SQRT((local_ec - local_e4) * (local_ec - local_e4) +
										 (local_f0 - local_e8) * (local_f0 - local_e8));
		pSVar3 = GetSurfaceMap();
		if (local_104 < pSVar3->BlockSize) {
			bVar2 = false;
		}
	}
	uVar11 = 0;
	uVar12 = local_f4;
	if (uVar8 != 0) {
		local_104 = (float)(ulonglong)param_2;
		uStack252 = 0;
		local_100 = (float)(ulonglong)param_3;
		pfVar9 = local_118;
		do {
			*pfVar9 = *pfVar9 + local_104;
			fVar1 = pfVar9[1];
			pfVar9[1] = fVar1 + local_100;
			if ((((*pfVar9 == (float)(int)local_110) && (fVar1 + local_100 == (float)(int)local_10c)) &&
					(bVar2)) &&
				 ((uVar12 = uVar11, param_4 != 0 ||
					(BVar4 = Level_GetBlockFlags1_10Not8((uint)local_110,(uint)local_10c), BVar4 == 0))))
			break;
			uVar11 = uVar11 + 1;
			pfVar9 = pfVar9 + 2;
			uVar12 = local_f4;
		} while (uVar11 < uVar8);
	}
	if (uVar12 != 0xffffffff) {
		BVar4 = LiveObject_FUN_004419c0(liveObj,1,&local_110,&local_10c,(float *)0x0);
		if (BVar4 == 0) {
			return 0;
		}
		if (param_5 != (uint *)0x0) {
			*param_5 = uVar12;
		}
		return 1;
	}
	uVar12 = 0;
	if (uVar8 != 0) {
		local_11c = local_80;
		ppfVar7 = local_40;
		pfVar9 = local_118;
		do {
			if (((float)(int)local_110 != *pfVar9) || ((float)(int)local_10c != pfVar9[1])) {
				lVar13 = __ftol((float10)pfVar9[1]);
				uVar5 = (undefined4)lVar13;
				uVar17 = 0;
				puVar16 = local_20 + uVar12;
				callback = 0;
				ppfVar15 = local_60 + uVar12;
				ppfVar14 = ppfVar7;
				lVar13 = __ftol((float10)*pfVar9);
				BVar4 = LiveObject_FUN_004413b0
													(liveObj,local_110,local_10c,(int)lVar13,uVar5,ppfVar14,ppfVar15,puVar16,
													 callback,uVar17);
				if (BVar4 != 0) {
					*local_11c = 1;
				}
			}
			uVar12 = uVar12 + 1;
			pfVar9 = pfVar9 + 2;
			ppfVar7 = ppfVar7 + 1;
			local_11c = local_11c + 1;
		} while (uVar12 < uVar8);
	}
	uVar12 = 0;
	if (uVar8 != 0) {
		do {
			if ((local_108 != 0xffffffff) && (uVar12 == uVar8)) break;
			uVar11 = uVar12 % uVar8;
			if (local_80[uVar11] != 0) {
				if (uVar12 < uVar8) {
					lVar13 = __ftol((float10)local_118[uVar11 * 2 + 1]);
					y = (uint)lVar13;
					lVar13 = __ftol((float10)local_118[uVar11 * 2]);
					BVar4 = Level_GetBlockFlags1_10Not8((uint)lVar13,y);
					if (BVar4 != 0) goto LAB_0044704f;
				}
				if (local_20[uVar11] < local_f8) {
					local_108 = uVar11;
					local_f8 = local_20[uVar11];
				}
			}
LAB_0044704f:
			uVar12 = uVar12 + 1;
		} while (uVar12 < uVar8 * 2);
	}
	if (local_108 != 0xffffffff) {
		BVar4 = LiveObject_FUN_004419c0
											(liveObj,local_20[local_108],local_40[local_108],local_60[local_108],
											 (float *)0x0);
		if (BVar4 == 0) {
			local_114 = 0;
		}
		else {
			if (param_5 != (uint *)0x0) {
				*param_5 = local_108;
			}
			local_114 = 1;
		}
	}
	uVar12 = 0;
	if (uVar8 != 0) {
		ppfVar7 = local_60;
		do {
			if (local_80[uVar12] != 0) {
				std::free(local_40[uVar12]);
				std::free(*ppfVar7);
			}
			uVar12 = uVar12 + 1;
			ppfVar7 = ppfVar7 + 1;
		} while (uVar12 < uVar8);
	}
	return local_114;
}



BOOL __cdecl
lego::game::LiveObject_FUN_00447100(LiveObject *liveObj,uint param_2,uint param_3,int param_4)
{
	uint uVar1;
	void *pvVar2;
	undefined4 uVar3;
	LiveFlags3 LVar4;
	BOOL BVar5;
	float10 fVar6;
	uint local_84;
	int local_80 [4];
	undefined4 local_70;
	undefined4 local_6c;
	undefined4 local_68;
	undefined4 local_64;
	int local_60 [4];
	undefined4 local_50;
	undefined4 local_4c;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40 [4];
	undefined4 local_30;
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	BVar5 = LiveObject_FUN_004326a0(liveObj,param_2,param_3,param_4,1);
	if (BVar5 != 0) {
		BVar5 = LiveObject_FUN_00446c80(liveObj,param_2,param_3,param_4,&local_84,1);
		if (BVar5 != 0) {
			if (param_4 != 0) {
				local_60[0] = 0;
				local_60[1] = 1;
				local_60[2] = 1;
				local_44 = 0;
				local_60[3] = 2;
				local_50 = 2;
				local_80[2] = 0;
				local_4c = 3;
				local_48 = 3;
				local_70 = 0;
				local_80[0] = -1;
				local_80[1] = 0xffffffff;
				local_80[3] = 0xffffffff;
				local_68 = 0xffffffff;
				local_6c = 0;
				local_64 = 0;
				local_40[0] = 0x3f666666;
				local_40[1] = 0x3f000000;
				local_40[2] = 0x3dcccccd;
				local_40[3] = 0x3f000000;
				local_30 = 0x3f000000;
				local_2c = 0x3dcccccd;
				local_28 = 0x3f000000;
				local_24 = 0x3f666666;
				local_20 = 0x3dcccccd;
				local_1c = 0x3f000000;
				local_18 = 0x3f666666;
				local_14 = 0x3f000000;
				local_10 = 0x3f000000;
				local_c = 0x3f666666;
				local_8 = 0x3f000000;
				local_4 = 0x3dcccccd;
				LiveObject_RoutingPtr_Important_FUN_00446b80
									(liveObj,local_80[local_60[local_84] * 2] + param_2,
									 local_80[local_60[local_84] * 2 + 1] + param_3);
				uVar1 = liveObj->routingBlocksTotal;
				pvVar2 = liveObj->routeptr_24;
				uVar3 = local_40[local_84 * 2 + 1];
				*(undefined4 *)((int)pvVar2 + uVar1 * 0x14 + -0xc) = local_40[local_84 * 2];
				*(undefined4 *)((int)pvVar2 + uVar1 * 0x14 + -8) = uVar3;
				LVar4 = liveObj->flags3;
				(liveObj->point_2f4).x = (float)(ulonglong)param_2;
				liveObj->flags3 = LVar4 | LIVEOBJ3_UNK_2000000;
				(liveObj->point_2f4).y = (float)(ulonglong)param_3;
				return 1;
			}
			LiveObject_RoutingPtr_Important_FUN_00446b80(liveObj,param_2,param_3);
			fVar6 = math::Maths_RandRange(0.3,0.7);
			*(float *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -0xc) =
					 (float)fVar6;
			fVar6 = math::Maths_RandRange(0.3,0.7);
			*(float *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -8) = (float)fVar6
			;
			LVar4 = liveObj->flags3;
			(liveObj->point_2f4).x = (float)(ulonglong)param_2;
			liveObj->flags3 = LVar4 & ~LIVEOBJ3_UNK_2000000;
			(liveObj->point_2f4).y = (float)(ulonglong)param_3;
			return 1;
		}
	}
	return 0;
}



// WARNING: Variable defined which should be unmapped: param_4

undefined4 FUN_004472ed(undefined param_1,undefined param_2,undefined param_3,undefined8 param_4)
{
	LiveFlags3 LVar1;
	int unaff_EBX;
	int unaff_EBP;
	LiveObject *unaff_ESI;
	undefined4 unaff_EDI;
	float10 fVar2;
	
	lego::game::LiveObject_RoutingPtr_Important_FUN_00446b80(unaff_ESI,unaff_EBP,unaff_EBX);
	fVar2 = lego::math::Maths_RandRange(0.3,0.7);
	*(float *)((int)unaff_ESI->routeptr_24 + unaff_ESI->routingBlocksTotal * 0x14 + -0xc) =
			 (float)fVar2;
	fVar2 = lego::math::Maths_RandRange(0.3,0.7);
	*(float *)((int)unaff_ESI->routeptr_24 + unaff_ESI->routingBlocksTotal * 0x14 + -8) = (float)fVar2
	;
	LVar1 = unaff_ESI->flags3;
	(unaff_ESI->point_2f4).x = (float)CONCAT44(unaff_EDI,unaff_EBP);
	unaff_ESI->flags3 = LVar1 & ~LIVEOBJ3_UNK_2000000;
	(unaff_ESI->point_2f4).y = (float)CONCAT44(unaff_EDI,unaff_EBX);
	return 1;
}



BOOL __cdecl lego::game::LiveObject_TryCarryBoulder_FUN_00447390(LiveObject *in_liveObj)
{
	BOOL BVar1;
	LiveObject *liveObj;
	undefined **ppuVar2;
	float10 fVar3;
	Point2I point;
	
	if ((in_liveObj->flags3 & LIVEOBJ3_UNK_4000000) != LIVEOBJ3_NONE) {
		fVar3 = LiveObject_GetCarryMinHealth(in_liveObj);
		if (fVar3 < (float10)in_liveObj->health) {
			BVar1 = LiveObject_FUN_0044a890(in_liveObj,(int *)&point,&point.y,1,0,0);
			if (BVar1 != 0) {
				liveObj = LiveObject__Create((int **)globals::g_Game.RES_Boulder,OBJECT_BOULDER,0);
				LiveObject_UnkUpdatePositioning(liveObj,10000.0,10000.0,0,1);
				LiveObject_FUN_0044a210(liveObj,1);
				BVar1 = LiveObject_RoutingNoCarry_FUN_00447470(in_liveObj,point.x,point.y,liveObj);
				if (BVar1 != 0) {
					ppuVar2 = (undefined **)FUN_00429090(&point);
					LiveObject_InitBoulderMesh_FUN_00440eb0(liveObj,ppuVar2);
					in_liveObj->float_33c = 0.0;
					return 1;
				}
				LiveObject_ReleaseBoulderUnk(liveObj);
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_RoutingNoCarry_FUN_00447470
					(LiveObject *liveObj,uint x,uint y,LiveObject *liveObj2)
{
	BOOL BVar1;
	
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
		BVar1 = LiveObject_RoutingPointerBlocks_FUN_00449b40(liveObj,x,y,4.0);
		if (BVar1 != 0) {
			*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 3;
			liveObj->object_2fc = liveObj2;
			liveObj2->object_300 = liveObj;
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_004474d0(LiveObject *liveObj1,LiveObject *liveObj2)
{
	short sVar1;
	short sVar2;
	uint uVar3;
	BOOL BVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	uint uVar9;
	Point2I local_70;
	int local_68;
	int local_64;
	int local_60 [4];
	undefined4 local_50;
	undefined4 local_4c;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40;
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	undefined4 local_30;
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if (liveObj1->objType == OBJECT_ROCKMONSTER) {
		if (liveObj2 != (LiveObject *)0x0) {
			local_60[0] = 2;
			local_60[1] = 0;
			local_60[2] = 0;
			local_60[3] = 2;
			local_50 = 0xfffffffe;
			local_4c = 0;
			local_48 = 0;
			local_44 = 0xfffffffe;
			local_40 = 2;
			local_3c = 0xffffffff;
			local_38 = 2;
			local_34 = 1;
			local_30 = 1;
			local_2c = 2;
			local_28 = 0xffffffff;
			local_24 = 2;
			local_20 = 0xfffffffe;
			local_1c = 1;
			local_18 = 0xfffffffe;
			local_14 = 0xffffffff;
			local_10 = 0xffffffff;
			local_c = 0xfffffffe;
			local_8 = 1;
			local_4 = 0xfffffffe;
			sVar1 = math::Maths_Rand();
			sVar2 = math::Maths_Rand();
			uVar6 = (int)sVar2 >> 0x1f;
			LiveObject_GetBlockCoordinates(liveObj2,&local_68,&local_64);
			uVar9 = 0;
			do {
				uVar7 = 0;
				uVar8 = (int)sVar1 % 0xc;
				do {
					uVar3 = uVar8;
					if ((((int)sVar2 ^ uVar6) - uVar6 & 1 ^ uVar6) - uVar6 == 1) {
						uVar3 = 0x18 - uVar8;
					}
					local_70.x = local_60[(uVar3 % 0xc) * 2] + local_68;
					local_70.y = local_60[(uVar3 % 0xc) * 2 + 1] + local_64;
					if (((uVar9 == 1) || (BVar4 = Level_GetBlockFlags1_180000(&local_70), BVar4 == 0)) &&
						 (iVar5 = LiveObject_FUN_00447670
																(liveObj1,(float)local_70.x,(float *)local_70.y,liveObj2),
						 iVar5 != 0)) {
						return 1;
					}
					uVar7 = uVar7 + 1;
					uVar8 = uVar8 + 1;
				} while (uVar7 < 0xc);
				uVar9 = uVar9 + 1;
				if (1 < uVar9) {
					return 0;
				}
			} while( true );
		}
		LiveObject_FUN_0043a130(liveObj1,0);
	}
	return 0;
}



int __cdecl
lego::game::LiveObject_FUN_00447670
					(LiveObject *in_liveObj,float param_2,float *param_3,LiveObject *liveObj2)
{
	LiveObject *liveObj;
	float fVar1;
	float *pfVar2;
	BOOL BVar3;
	BOOL BVar4;
	float *local_10;
	float local_c;
	float *local_8;
	uint local_4;
	
	liveObj = in_liveObj;
	BVar4 = 0;
	if ((in_liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		BVar3 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(in_liveObj);
		if (BVar3 == 0) {
			LiveObject_GetBlockCoordinates(liveObj2,(int *)&local_c,(int *)&local_8);
			pfVar2 = param_3;
			fVar1 = param_2;
			if ((local_c != param_2) || (local_8 != param_3)) {
				LiveObject_GetBlockCoordinates(liveObj,(int *)&param_2,(int *)&in_liveObj);
				if ((param_2 == fVar1) && (in_liveObj == (LiveObject *)pfVar2)) {
					BVar4 = LiveObject_FUN_004419c0(liveObj,1,&param_2,(float *)&in_liveObj,(float *)0x0);
				}
				else {
					BVar4 = LiveObject_FUN_004413b0
														(liveObj,param_2,in_liveObj,fVar1,pfVar2,&param_3,&local_10,&local_4,0,0
														);
					if (BVar4 == 0) {
						return 0;
					}
					BVar4 = LiveObject_FUN_004419c0(liveObj,local_4,param_3,local_10,(float *)0x0);
					std::free(param_3);
					std::free(local_10);
				}
				if (BVar4 != 0) {
					*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 5;
					liveObj->carriedObjects[0]->object_2fc = liveObj2;
					return BVar4;
				}
			}
		}
	}
	return BVar4;
}



void __cdecl lego::game::LiveObject_FUN_004477b0(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	float fVar1;
	float fVar2;
	float10 fVar3;
	float10 fVar4;
	Point2F local_18;
	Point2F local_10;
	Point2F local_8;
	
	liveObj = in_liveObj->object_2fc;
	in_liveObj->object_2fc = (LiveObject *)0x0;
	if (liveObj != (LiveObject *)0x0) {
		LiveObject_GetPosition(liveObj,(float *)&local_10,&local_10.y);
		LiveObject_GetPosition(in_liveObj,(float *)&local_8,&local_8.y);
		local_18.x = local_10.x - local_8.x;
		local_18.y = local_10.y - local_8.y;
		fVar2 = local_18.x * local_18.x;
		fVar1 = local_18.y * local_18.y;
		fVar3 = LiveObject_GetCollRadius(liveObj);
		fVar4 = LiveObject_GetCollRadius(in_liveObj);
		if ((float10)SQRT(fVar1 + fVar2) < fVar4 + fVar4 + (float10)(float)fVar3) {
			LiveObject_FUN_00447c10(liveObj,&local_18,1);
			LiveObject_FUN_0043f960(liveObj,10.0,1,1.0);
		}
	}
	return;
}



int __cdecl lego::game::LiveObject_FUN_00447880(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	int iVar3;
	float10 fVar4;
	
	iVar3 = 0;
	liveObj = in_liveObj->object_2fc;
	if ((liveObj != (LiveObject *)0x0) && ((liveObj->flags2 & LIVEOBJ2_UNK_100000) == LIVEOBJ2_NONE))
	{
		OVar1 = LiveObject_GetStatsFlags2(in_liveObj);
		if ((OVar1 & STATS2_DRAINPOWER) == STATS2_NONE) {
			if ((in_liveObj->flags4 & 0x400000) == LIVEOBJ4_NONE) {
				if (in_liveObj->objType == OBJECT_ROCKMONSTER) {
					front::Info_FUN_00419ab0(INFO_UNDERATTACK,(char *)0x0,liveObj,(Point2I *)0x0);
				}
				fVar4 = LiveObject_GetRepairValue(in_liveObj);
				if ((float10)0.0 <= fVar4) {
					liveObj->health = (float)(fVar4 + (float10)liveObj->health);
				}
				else {
					LiveObject_FUN_0043f960(liveObj,(float)-fVar4,1,1.0);
					liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_40000000;
				}
				if (liveObj->health < 100.0) {
					ai::AITask_DoRepair_Target(liveObj,0);
				}
				else {
					liveObj->health = (float)&DAT_42c80000;
					iVar3 = 1;
				}
			}
			else {
				LiveObject_FUN_00438ab0(liveObj);
				in_liveObj->flags4 = in_liveObj->flags4 & 0xffbfffff;
			}
		}
		else {
			BVar2 = LiveObject_CheckCondition_FUN_00438870(liveObj,0);
			if (BVar2 == 0) {
				return 1;
			}
			if (globals::g_Game.DrainTime <= in_liveObj->elapsedTime2) {
				LiveObject_Weapon_FUN_004375c0(in_liveObj,-1,1.0);
				in_liveObj->elapsedTime2 = 0.0;
			}
		}
		if ((ushort)((ushort)(liveObj->health < 0.0) << 8 | (ushort)(liveObj->health == 0.0) << 0xe) ==
				0) goto LAB_004479d1;
	}
	iVar3 = 1;
LAB_004479d1:
	if (iVar3 != 0) {
		in_liveObj->object_2fc = (LiveObject *)0x0;
	}
	return iVar3;
}



undefined4 __cdecl FUN_004479f0(int param_1)
{
	float fVar1;
	
	fVar1 = *(float *)(param_1 + 0x344) - -25.0;
	*(undefined4 *)(param_1 + 0x2fc) = 0;
	*(float *)(param_1 + 0x344) = fVar1;
	if ((ushort)((ushort)(fVar1 < *(float *)(param_1 + 0x340)) << 8 |
							(ushort)(fVar1 == *(float *)(param_1 + 0x340)) << 0xe) == 0) {
		*(undefined4 *)(param_1 + 0x344) = *(undefined4 *)(param_1 + 0x340);
		return 1;
	}
	return 0;
}



void __cdecl FUN_00447a40(LiveObject *liveObj)
{
	LiveObject *liveObj2;
	
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		liveObj2 = liveObj->carriedObjects[0];
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CARRYING;
		liveObj->numCarriedObjects = 0;
		liveObj->carriedObjects[0] = (LiveObject *)0x0;
		liveObj2->flags3 = liveObj2->flags3 | 0x2000;
		lego::game::LiveObject_SetAITaskUnk(liveObj,AITASK_GATHER,liveObj2,1);
	}
	return;
}



void __cdecl FUN_00447a90(LiveObject *liveObj)
{
	void *pvVar1;
	LiveObject *pLVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	SurfaceMap *pSVar6;
	uint x;
	uint uVar7;
	Point2F *pPVar8;
	Point2F *pPVar9;
	Point2F *pPVar10;
	float *out_y;
	Point2F local_20;
	float local_14;
	float local_10;
	float local_c;
	Point2F local_8;
	
	pLVar2 = liveObj->carriedObjects[0]->object_2fc;
	pvVar1 = (void *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14);
	out_y = &local_20.y;
	pPVar9 = &local_20;
	uVar7 = *(uint *)((int)pvVar1 + -0x10);
	x = *(uint *)((int)pvVar1 + -0x14);
	pSVar6 = lego::game::GetSurfaceMap();
	lego::game::SurfaceMap_FUN_0044f900(pSVar6,x,uVar7,(float *)pPVar9,out_y);
	lego::game::LiveObject_GetPosition(pLVar2,&local_10,&local_c);
	fVar3 = local_10 - local_20.x;
	fVar5 = local_c - local_20.y;
	pPVar9 = &local_8;
	pPVar8 = &local_20;
	pPVar10 = (Point2F *)0x0;
	fVar4 = 1.0 / SQRT(fVar5 * fVar5 + fVar3 * fVar3);
	local_14 = fVar4 * fVar5 * 0.1;
	local_20.x = fVar4 * fVar3 * 0.1 + local_20.x;
	local_20.y = local_14 + local_20.y;
	pSVar6 = lego::game::GetSurfaceMap();
	lego::game::SurfaceMap_FUN_0044fb30(pSVar6,pPVar8,pPVar10,pPVar9);
	uVar7 = liveObj->routingBlocksTotal;
	pvVar1 = liveObj->routeptr_24;
	*(float *)((int)pvVar1 + uVar7 * 0x14 + -0xc) = local_8.x;
	*(float *)((int)pvVar1 + uVar7 * 0x14 + -8) = local_8.y;
	*(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) =
			 *(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) | 8;
	pLVar2 = liveObj->carriedObjects[0];
	(pLVar2->point_2f4).x = local_10;
	(pLVar2->point_2f4).y = local_c;
	liveObj->carriedObjects[0]->object_2fc = (LiveObject *)0x0;
	return;
}



void __cdecl lego::game::LiveObject_FUN_00447bc0(LiveObject *liveObj)
{
	if (liveObj->objType == OBJECT_BUILDING) {
		unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_00447be0,liveObj);
	}
	return;
}



undefined4 __cdecl FUN_00447be0(int *param_1,int param_2)
{
	if (((*param_1 == 5) && (param_1[0xbf] == param_2)) &&
		 ((LiveObject *)param_1[0xc1] != (LiveObject *)0x0)) {
		lego::game::LiveObject_UnkDoRouting_FUN_00441c00((LiveObject *)param_1[0xc1],0);
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_00447c10(LiveObject *liveObj,Point2F *param_2,BOOL param_3)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	BOOL BVar5;
	ActivityType actType;
	float10 fVar6;
	
	if (((*(byte *)&liveObj->flags2 & LIVEOBJ2_UNK_2) != 0) &&
		 (liveObj->object_3c0 != (LiveObject *)0x0)) {
		liveObj = liveObj->object_3c0;
	}
	if ((liveObj->flags1 & LIVEOBJ1_UNK_1000) == LIVEOBJ1_NONE) {
		BVar5 = LiveObject_CheckCondition_FUN_00438870(liveObj,1);
		if (BVar5 != 0) {
			if (param_2 == (Point2F *)0x0) {
				actType = (-(uint)(param_3 != 0) & 0xfffffff7) + ACTIVITY_STAMP;
			}
			else {
				fVar1 = (liveObj->faceDirection).x;
				fVar2 = (liveObj->faceDirection).y;
				fVar6 = (float10)fcos((float10)0.7853981852531433);
				fVar3 = 1.0 / SQRT(fVar2 * fVar2 + fVar1 * fVar1);
				fVar1 = fVar3 * fVar1;
				fVar3 = fVar3 * fVar2;
				fVar4 = 1.0 - (float)fVar6;
				fVar2 = fVar3 * param_2->y + fVar1 * param_2->x;
				if ((ushort)((ushort)(fVar2 < fVar4) << 8 | (ushort)(fVar2 == fVar4) << 0xe) == 0) {
					actType = ACTIVITY_HITBACK;
				}
				else {
					if (-fVar4 <= fVar2) {
						fVar1 = fVar3 * param_2->x - fVar1 * param_2->y;
						if ((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) == 0) {
							actType = ACTIVITY_HITRIGHT;
						}
						else {
							actType = ACTIVITY_HITLEFT;
						}
					}
					else {
						actType = ACTIVITY_HITFRONT;
					}
				}
			}
			LiveObject_FUN_00441df0(liveObj,0,1);
			LiveObject_SetActivityUnk(liveObj,actType,1);
			BVar5 = Game_UpdateSomeAITasks(liveObj);
			if (BVar5 == 0) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,1);
				Game_UpdateSomeAITasks(liveObj);
			}
			LiveObject_FUN_00447df0(liveObj,1.0);
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_1000;
			if (liveObj->objType == OBJECT_ROCKMONSTER) {
				liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_80000000;
			}
		}
	}
	return;
}



void __cdecl FUN_00447dc0(uint *param_1)
{
	lego::game::LiveObject_SetActivityUnk((LiveObject *)param_1,ACTIVITY_TELEPORT,0);
	lego::game::Game_UpdateSomeAITasks((LiveObject *)param_1);
	param_1[0xf8] = param_1[0xf8] | 0x200000;
	return;
}



float10 __cdecl lego::game::LiveObject_FUN_00447df0(LiveObject *in_liveObj,float elapsed)
{
	ObjectType OVar1;
	LiveObject *liveObj;
	float elapsed2;
	float10 fVar2;
	
	elapsed2 = elapsed;
	liveObj = in_liveObj;
	LiveObject_FUN_004468d0(in_liveObj,elapsed,(float *)&in_liveObj,&elapsed);
	if ((liveObj->flags1 & LIVEOBJ1_UNK_4000) != LIVEOBJ1_NONE) goto LAB_00447ed1;
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		fVar2 = res::Vehicle_FUN_0046d480(liveObj->vehicle,elapsed,elapsed2,liveObj->unkbool_2d8);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			fVar2 = res::Creature_FUN_00406c60(liveObj->miniFigure,elapsed,liveObj->unkbool_2d8);
		}
		else {
			if (OVar1 == OBJECT_ROCKMONSTER) {
				fVar2 = res::Creature_FUN_00406c60(liveObj->rockMonster,elapsed,liveObj->unkbool_2d8);
			}
			else {
				if (OVar1 == OBJECT_BUILDING) {
					fVar2 = res::Building_FUN_00408790(liveObj->building,elapsed,liveObj->unkbool_2d8);
				}
				else {
					if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
						FUN_00448160(liveObj,elapsed2);
						goto LAB_00447ed1;
					}
					if (OVar1 != OBJECT_UPGRADEPART) goto LAB_00447ed1;
					fVar2 = res::Upgrade_DoAnimElapsedCallbacks(liveObj->upgrade,elapsed,liveObj->unkbool_2d8)
					;
				}
			}
		}
	}
	liveObj->float_2d4 = (float)fVar2;
LAB_00447ed1:
	if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 | (ushort)(liveObj->float_2d4 == 0.0) << 0xe)
			== 0) {
		LiveObject_FUN_00403e90(liveObj);
	}
	return (float10)elapsed;
}



BOOL __cdecl lego::game::Game_UpdateSomeAITasks(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	int iVar2;
	char *pcVar3;
	Container *pCVar4;
	BOOL BVar5;
	char *pcVar6;
	char local_100 [256];
	
	BVar5 = 0;
	pcVar6 = liveObj->aitaskName1;
	if (pcVar6 == liveObj->aitaskName2) {
		return 0;
	}
	if ((((pcVar6 != globals::g_Activities_TABLE[0]) && (pcVar6 != globals::g_Activities_TABLE[1])) &&
			(pcVar6 != globals::g_Activities_TABLE[4])) &&
		 (((pcVar6 != globals::g_Activities_TABLE[6] && (pcVar6 != globals::g_Activities_TABLE[8])) &&
			((pcVar6 != globals::g_Activities_TABLE[17] &&
			 ((pcVar6 != globals::g_Activities_TABLE[22] && (pcVar6 != globals::g_Activities_TABLE[2])))))
			))) {
		ai::AITask_DoAnimationWait(liveObj);
	}
	switch(liveObj->objType) {
	case OBJECT_VEHICLE:
		BVar5 = res::Vehicle_FUN_0046c6b0(liveObj->vehicle,liveObj->aitaskName1,liveObj->float_2d4);
		pCVar4 = res::Vehicle_GetCameraNull(liveObj->vehicle,liveObj->index_2e0);
		break;
	case OBJECT_MINIFIGURE:
		BVar5 = res::Creature_FUN_00406d70(liveObj->miniFigure,liveObj->aitaskName1,liveObj->float_2d4);
		pCVar4 = res::Creature_GetCameraNull(liveObj->miniFigure,liveObj->index_2e0);
		break;
	case OBJECT_ROCKMONSTER:
		BVar5 = res::Creature_FUN_00406d70(liveObj->rockMonster,liveObj->aitaskName1,liveObj->float_2d4)
		;
		pCVar4 = res::Creature_GetCameraNull(liveObj->rockMonster,liveObj->index_2e0);
		break;
	case OBJECT_BUILDING:
		BVar5 = res::Building_FUN_004084a0(liveObj->building,liveObj->aitaskName1,liveObj->float_2d4);
		pCVar4 = (Container *)res::Building_FUN_00408520(liveObj->building,liveObj->index_2e0);
		break;
	default:
		goto switchD_00447f7d_caseD_4;
	}
	liveObj->resData_2dc = pCVar4;
switchD_00447f7d_caseD_4:
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	if ((((OVar1 & STATS1_CANBEDRIVEN) != STATS1_NONE) && (liveObj->drivenObject != (LiveObject *)0x0)
			) && (liveObj->drivenObject->objType == OBJECT_MINIFIGURE)) {
		iVar2 = std::_stricmp(globals::g_Activities_TABLE[1],liveObj->aitaskName1);
		pcVar6 = "Activity_";
		if (iVar2 != 0) {
			pcVar6 = liveObj->aitaskName1;
		}
		pcVar3 = Object_GetTypeName(liveObj->objType,liveObj->objIndex);
		std::sprintf(local_100,"%s%s",pcVar6,pcVar3);
		res::Creature_FUN_00406d70(liveObj->drivenObject->miniFigure,local_100,0.0);
		pCVar4 = res::Creature_GetCameraNull
											 (liveObj->drivenObject->miniFigure,liveObj->drivenObject->index_2e0);
		liveObj->drivenObject->resData_2dc = pCVar4;
		liveObj->drivenObject->aitaskName1 = liveObj->drivenObject->aitaskName2;
	}
	liveObj->float_2d4 = 0.0;
	liveObj->aitaskName2 = liveObj->aitaskName1;
	liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_20000;
	return BVar5;
}



void __cdecl FUN_00448160(LiveObject *param_1,float param_2)
{
	LiveFlags2 *pLVar1;
	ObjectType OVar2;
	LiveObject *liveObj;
	SurfaceMap *pSVar3;
	LiveObject *pLVar4;
	uint uVar5;
	LiveFlags1 LVar6;
	int iVar7;
	int iVar8;
	LevelData *level;
	LiveFlags3 LVar9;
	float10 fVar10;
	float10 fVar11;
	float10 fVar12;
	longlong lVar13;
	float fVar14;
	BOOL BVar15;
	Point2I *out_x;
	float fVar16;
	float *out_x_00;
	Container *cont;
	int *out_y;
	float *pfVar17;
	char *pcVar18;
	float local_4c;
	float local_48;
	Point2I local_44;
	Point2I local_3c;
	float local_34;
	float local_30;
	float local_2c;
	float local_28;
	Vector3F local_24;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	liveObj = param_1;
	OVar2 = param_1->objType;
	if (OVar2 == OBJECT_BOULDER) {
		if ((param_1->flags3 & 0x2000) != LIVEOBJ3_NONE) {
			lego::res::Container_GetPosition(param_1->other,(Container *)0x0,&local_c);
			fVar16 = (liveObj->point_2f4).y;
			fVar14 = (liveObj->point_2f4).x;
			local_24.z = 0.0;
			local_24.x = fVar14;
			local_24.y = fVar16;
			pSVar3 = lego::game::GetSurfaceMap();
			fVar10 = lego::game::SurfaceMap_GetSurfaceZ(pSVar3,fVar14,fVar16);
			param_1 = (LiveObject *)(float)fVar10;
			fVar11 = lego::game::LiveObject_GetCollRadius(liveObj);
			fVar10 = (float10)(float)param_1;
			fVar12 = (fVar10 - fVar11) - (float10)local_c.z;
			fVar16 = (float)((float10)local_24.x - (float10)local_c.x);
			fVar14 = (float)((float10)local_24.y - (float10)local_c.y);
			local_10 = (float)fVar12;
			param_1 = (LiveObject *)(param_2 * 3.5);
			local_4c = (float)SQRT(fVar12 * (float10)local_10 +
														 ((float10)local_24.y - (float10)local_c.y) * (float10)fVar14 +
														 ((float10)local_24.x - (float10)local_c.x) * (float10)fVar16);
			param_2 = 1.0 / local_4c;
			local_18 = param_2 * fVar16 * (float)param_1;
			local_c.x = local_18 + local_c.x;
			local_14 = param_2 * fVar14 * (float)param_1;
			local_c.y = local_14 + local_c.y;
			local_c.z = param_2 * local_10 * (float)param_1 + local_c.z;
			fVar16 = local_c.x;
			fVar14 = local_c.y;
			local_24.z = local_c.z;
			if (local_4c < (float)param_1) {
				liveObj->carryingThisObject = (LiveObject *)0x0;
				liveObj->health = -1.0;
				liveObj->flags3 = liveObj->flags3 & 0xffffdfff | LIVEOBJ3_UNK_800000;
				fVar16 = local_24.x;
				fVar14 = local_24.y;
				local_24.z = (float)(fVar10 - fVar11);
			}
			local_24.y = fVar14;
			local_24.x = fVar16;
			local_34 = local_24.x;
			out_y = &local_3c.y;
			out_x = &local_3c;
			local_30 = local_24.y;
			fVar16 = local_24.x;
			fVar14 = local_24.y;
			local_44.x = (int)param_1;
			pSVar3 = lego::game::GetSurfaceMap();
			lego::game::SurfaceMap_ToBlockCoordinatesNoZ(pSVar3,fVar16,fVar14,(int *)out_x,out_y);
			fVar16 = local_24.x;
			fVar14 = local_24.y;
			pSVar3 = lego::game::GetSurfaceMap();
			fVar10 = lego::game::SurfaceMap_GetSurfaceZ(pSVar3,fVar16,fVar14);
			param_2 = (float)(fVar10 - (float10)local_24.z);
			pLVar4 = (LiveObject *)lego::game::LiveObject_FUN_00446030(liveObj,&local_34,param_2,1);
			if (pLVar4 != (LiveObject *)0x0) {
				liveObj->carryingThisObject = (LiveObject *)0x0;
				liveObj->flags3 = liveObj->flags3 & 0xffffdfff;
				pfVar17 = &local_2c;
				fVar16 = 0.0;
				BVar15 = 1;
				local_28 = 1.0 / SQRT(local_14 * local_14 + local_18 * local_18);
				local_2c = local_28 * local_18;
				local_28 = local_28 * local_14;
				uVar5 = lego::tools::Weapon_GetWeaponTypeByName("Boulder");
				lego::game::LiveObject_FUN_0046f530(pLVar4,uVar5,BVar15,fVar16,pfVar17);
				liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
				liveObj->health = -1.0;
				lego::res::Res_PlayResourceSound((Container *)0x0,SFX_BOULDERHIT,0,0,&local_24);
			}
			lego::res::Container_SetPosition
								(liveObj->other,(Container *)0x0,local_24.x,local_24.y,local_24.z);
			return;
		}
	}
	else {
		if (OVar2 == OBJECT_POWERCRYSTAL) {
			if (param_1->carryingThisObject == (LiveObject *)0x0) {
				lego::res::Container_AddRotation
									(param_1->other,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,param_2 * 0.01);
				return;
			}
		}
		else {
			if ((OVar2 == OBJECT_DYNAMITE) || (OVar2 == OBJECT_OOHSCARY)) {
				if ((param_1->flags3 & 0x10000) == LIVEOBJ3_NONE) {
					if ((param_1->flags1 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
						param_1->flags1 = param_1->flags1 & ~LIVEOBJ1_PLACING;
						param_1->flags3 = param_1->flags3 | 0x10000;
						lego::res::Container_SetActivity(param_1->other,"TickDown");
						lego::res::Container_SetAnimationTime(liveObj->other,0.0);
						lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_44,&local_44.y);
						FUN_00432640(&local_44,1);
						lego::front::Info_FUN_00419ab0(INFO_DYNAMITEPLACED,(char *)0x0,liveObj,(Point2I *)0x0);
						lVar13 = __ftol((float10)(liveObj->point_2f4).y);
						iVar7 = (int)lVar13;
						lVar13 = __ftol((float10)(liveObj->point_2f4).x);
						iVar8 = (int)lVar13;
						pSVar3 = lego::game::GetSurfaceMap();
						lego::game::SurfaceMap_FUN_0044f830(pSVar3,iVar8,iVar7);
						return;
					}
					lego::res::Container_MoveAnimation(param_1->other,param_2);
				}
				else {
					if (((ushort)((ushort)(param_1->health < 0.0) << 8 |
											 (ushort)(param_1->health == 0.0) << 0xe) != 0) ||
						 (fVar10 = lego::res::Container_MoveAnimation(param_1->other,param_2),
						 fVar10 != (float10)0.0)) {
						lVar13 = __ftol((float10)(liveObj->point_2f4).x);
						iVar7 = (int)lVar13;
						local_3c.x = iVar7;
						lVar13 = __ftol((float10)(liveObj->point_2f4).y);
						iVar8 = (int)lVar13;
						local_3c.y = iVar8;
						if ((iVar7 != 0) && (iVar8 != 0)) {
							BVar15 = 0;
							level = lego::game::GetLevel();
							lego::game::Level_DestroyWall(level,iVar7,iVar8,BVar15);
						}
						if (liveObj->objType == OBJECT_DYNAMITE) {
							lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_3c,&local_3c.y);
							FUN_00432640(&local_3c,0);
							FUN_00440a70(liveObj,lego::globals::g_Game.DynamiteDamageRadius,
													 lego::globals::g_Game.DynamiteMaxDamage,
													 lego::globals::g_Game.DynamiteWakeRadius);
							lego::snd::Audio_Play_FUN_00465260(SFX_DYNAMITE,0);
							FUN_0040c680(liveObj,(Point2F *)0x0);
							lego::view::Camera_SetFloata0_a4_Zeroa8(lego::globals::g_Game.cameraMain,5.0,50.0);
						}
						else {
							if (liveObj->objType == OBJECT_OOHSCARY) {
								lego::game::LiveObject_GetPosition(liveObj,(float *)&local_c,&local_c.y);
								lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_44,&local_44.y);
								pSVar3 = lego::game::GetSurfaceMap();
								fVar10 = lego::game::SurfaceMap_GetSurfaceZ(pSVar3,local_c.x,local_c.y);
								local_c.z = (float)fVar10;
								FUN_0040cc10(8,(undefined4 *)&local_c,(undefined4 *)0x0);
								lego::view::Camera_SetFloata0_a4_Zeroa8
													(lego::globals::g_Game.cameraMain,2.0,(float)&DAT_42c80000);
								FUN_00432640(&local_44,0);
							}
						}
						liveObj->health = -1.0;
						liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
						return;
					}
				}
			}
			else {
				if (OVar2 == OBJECT_ELECTRICFENCE) {
					if ((param_1->flags1 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
						param_1->flags1 = param_1->flags1 & ~LIVEOBJ1_PLACING;
						lego::game::LiveObject_AssignBlockObject(param_1);
						lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_44,(int *)&param_1);
						pfVar17 = &local_48;
						out_x_00 = &local_4c;
						uVar5 = local_44.x;
						pLVar4 = param_1;
						pSVar3 = lego::game::GetSurfaceMap();
						lego::game::SurfaceMap_FUN_0044f900(pSVar3,uVar5,(uint)pLVar4,out_x_00,pfVar17);
						fVar10 = lego::game::LiveObject_UnkRadians_FUN_00442740(liveObj);
						BVar15 = 1;
						param_2 = (float)(fVar10 - (float10)-0.7853982);
						fVar10 = std::fmod((float10)param_2,(float10)1.570796370506287);
						lego::game::LiveObject_UnkUpdatePositioning
											(liveObj,local_4c,local_48,(float)((float10)param_2 - fVar10),BVar15);
						lego::game::Level_SetBlockFlag8(local_44.x,(int)param_1,0);
						return;
					}
				}
				else {
					if (OVar2 == OBJECT_BARRIER) {
						fVar10 = lego::res::Container_MoveAnimation(param_1->other,param_2);
						if (fVar10 == (float10)0.0) {
							return;
						}
						LVar6 = liveObj->flags1;
						if ((LVar6 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
							pcVar18 = "Expand";
							liveObj->flags1 = LVar6 & ~LIVEOBJ1_PLACING | LIVEOBJ1_UNK_100;
							goto LAB_0044872d;
						}
						if ((LVar6 & LIVEOBJ1_UNK_100) != LIVEOBJ1_NONE) {
							liveObj->flags1 = LVar6 & ~LIVEOBJ1_UNK_100;
							liveObj->flags3 = liveObj->flags3 | 0x10000;
							pcVar18 = "Long";
							goto LAB_00448783;
						}
						LVar9 = liveObj->flags3;
						if ((LVar9 & LIVEOBJ3_UNK_800000) != LIVEOBJ3_NONE) {
							liveObj->health = (float)&DAT_42c80000;
							liveObj->flags3 = LVar9 & ~LIVEOBJ3_UNK_800000;
							liveObj->flags1 = LVar6 | LIVEOBJ1_UNK_200000;
							lego::res::Container_SetActivity(liveObj->other,"Teleport");
							lego::res::Container_SetAnimationTime(liveObj->other,0.0);
							return;
						}
					}
					else {
						if (OVar2 != OBJECT_SPIDERWEB) {
							if (OVar2 != OBJECT_ICECUBE) {
								if ((((OVar2 != OBJECT_ELECTRICFENCESTUD) && (OVar2 != OBJECT_PUSHER)) &&
										(OVar2 != OBJECT_FREEZER)) && (OVar2 != OBJECT_LASERSHOT)) {
									return;
								}
								lego::res::Container_MoveAnimation(param_1->other,param_2);
								return;
							}
							fVar10 = lego::res::Container_MoveAnimation(param_1->other,param_2);
							if (fVar10 == (float10)0.0) {
								return;
							}
							LVar6 = liveObj->flags1;
							if ((LVar6 & LIVEOBJ1_UNK_100) == LIVEOBJ1_NONE) {
								LVar9 = liveObj->flags3;
								if ((LVar9 & LIVEOBJ3_UNK_800000) == LIVEOBJ3_NONE) {
									if ((LVar6 & LIVEOBJ1_UNK_200000) == LIVEOBJ1_NONE) {
										return;
									}
									liveObj->flags1 = LVar6 & ~LIVEOBJ1_UNK_200000;
									liveObj->health = -1.0;
									liveObj->flags3 = LVar9 | LIVEOBJ3_UNK_800000;
									pLVar1 = &liveObj->object_364->flags2;
									*pLVar1 = *pLVar1 & ~LIVEOBJ2_UNK_8000000;
									return;
								}
								liveObj->health = (float)&DAT_42c80000;
								liveObj->flags3 = LVar9 & ~LIVEOBJ3_UNK_800000;
								liveObj->flags1 = LVar6 | LIVEOBJ1_UNK_200000;
								pcVar18 = "Melt";
LAB_00448783:
								lego::res::Container_SetActivity(liveObj->other,pcVar18);
								lego::res::Container_SetAnimationTime(liveObj->other,0.0);
								return;
							}
							liveObj->flags1 = LVar6 & ~LIVEOBJ1_UNK_100;
							liveObj->flags3 = liveObj->flags3 | 0x10000;
							pcVar18 = "Normal";
LAB_0044872d:
							lego::res::Container_SetActivity(liveObj->other,pcVar18);
							lego::res::Container_SetAnimationTime(liveObj->other,0.0);
							return;
						}
						if (((param_1->flags1 & 0x2000000) == LIVEOBJ1_NONE) ||
							 ((param_1->flags1 & LIVEOBJ1_UNK_100) != LIVEOBJ1_NONE)) {
							cont = param_1->other;
							fVar16 = param_2;
						}
						else {
							cont = param_1->other;
							fVar16 = 0.0;
						}
						fVar10 = lego::res::Container_MoveAnimation(cont,fVar16);
						if (fVar10 == (float10)0.0) {
							return;
						}
						LVar6 = liveObj->flags1;
						if ((LVar6 & LIVEOBJ1_UNK_100) != LIVEOBJ1_NONE) {
							liveObj->flags1 = LVar6 & ~LIVEOBJ1_UNK_100;
							liveObj->flags3 = liveObj->flags3 | 0x10000;
							pcVar18 = "FlapInWind";
							goto LAB_0044872d;
						}
						LVar9 = liveObj->flags3;
						if ((LVar9 & LIVEOBJ3_UNK_800000) != LIVEOBJ3_NONE) {
							liveObj->health = (float)&DAT_42c80000;
							liveObj->flags3 = LVar9 & ~LIVEOBJ3_UNK_800000;
							liveObj->flags1 = LVar6 | LIVEOBJ1_UNK_200000;
							pcVar18 = "Disintegrate";
							goto LAB_00448783;
						}
					}
					if ((LVar6 & LIVEOBJ1_UNK_200000) != LIVEOBJ1_NONE) {
						liveObj->flags1 = LVar6 & ~LIVEOBJ1_UNK_200000;
						liveObj->health = -1.0;
						liveObj->flags3 = LVar9 | LIVEOBJ3_UNK_800000;
						return;
					}
				}
			}
		}
	}
	return;
}



void __cdecl FUN_00448a80(int *param_1)
{
	if (((param_1[0xf8] & 0x400U) != 0) && (*(int *)param_1[0xc2] == 8)) {
		((int *)param_1[0xc2])[0xbe] = 0;
		*(undefined4 *)(param_1[0xc2] + 0x2f4) = 0;
		lego::game::LiveObject_FUN_0043a130((LiveObject *)param_1,1);
	}
	return;
}



undefined4 __cdecl FUN_00448ac0(int *param_1,uint *param_2)
{
	int iVar1;
	BOOL BVar2;
	
	if (*(int *)param_1[0xc2] == 8) {
		iVar1 = FUN_00432880((int)param_1,*param_2,param_2[1]);
		if (iVar1 != 0) {
			BVar2 = lego::game::LiveObject_RoutingPointerBlocks_FUN_00449b40
												((LiveObject *)param_1,*param_2,param_2[1],7.0);
			if (BVar2 != 0) {
				iVar1 = param_1[0xc2];
				*(undefined *)(param_1[9] + -3 + param_1[10] * 0x14) = 9;
				*(float *)(iVar1 + 0x2f4) = (float)*param_2;
				*(float *)(iVar1 + 0x2f8) = (float)param_2[1];
				return 1;
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_DoBirdScarer(LiveObject *liveObj,Point2I *position)
{
	float *pfVar1;
	LiveObject *pLVar2;
	Point2I *pPVar3;
	BOOL BVar4;
	uint local_c;
	int local_8;
	float local_4;
	LiveObject *liveObj_00;
	
	pPVar3 = position;
	liveObj_00 = liveObj;
	if (liveObj->carriedObjects[0]->objType == OBJECT_OOHSCARY) {
		pfVar1 = (float *)&position->y;
		BVar4 = Level_BlockCheck_FUN_00432900(liveObj,position->x,position->y);
		if (BVar4 != 0) {
			LiveObject_GetBlockCoordinates(liveObj_00,&local_8,(int *)&local_4);
			if ((local_8 == pPVar3->x) && (local_4 == *pfVar1)) {
				LiveObject_FUN_004419c0(liveObj_00,1,(float *)pPVar3,pfVar1,(float *)0x0);
				return 0;
			}
			BVar4 = LiveObject_FUN_004413b0
												(liveObj_00,local_8,local_4,pPVar3->x,*pfVar1,&liveObj,&position,&local_c,0,
												 0);
			if (BVar4 != 0) {
				BVar4 = LiveObject_FUN_004419c0
													(liveObj_00,local_c,(float *)liveObj,(float *)position,(float *)0x0);
				std::free(liveObj);
				std::free(position);
				if (BVar4 != 0) {
					pLVar2 = liveObj_00->carriedObjects[0];
					*(undefined *)((int)liveObj_00->routeptr_24 + liveObj_00->routingBlocksTotal * 0x14 + -3)
							 = 9;
					(pLVar2->point_2f4).x = (float)pPVar3->x;
					(pLVar2->point_2f4).y = (float)(int)*pfVar1;
					return 1;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_00448c60(LiveObject *liveObj)
{
	BOOL BVar1;
	LiveObject *pLVar2;
	float10 fVar3;
	float local_10;
	float local_c;
	Point2I local_8;
	
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_BIRDSCARER);
	if (BVar1 != 0) {
		LiveObject_GetPosition(liveObj,&local_10,&local_c);
		LiveObject_GetBlockCoordinates(liveObj,(int *)&local_8,&local_8.y);
		fVar3 = LiveObject_UnkRadians_FUN_00442740(liveObj);
		pLVar2 = Game_CreateLiveResourceObject
											 (globals::g_Game.RES_OohScary,OBJECT_OOHSCARY,0,0,local_10,local_c,
												(float)fVar3);
		FUN_00432640(&local_8,1);
		res::Container_SetActivity(pLVar2->other,"TickDown");
		res::Container_SetAnimationTime(pLVar2->other,0.0);
		pLVar2->flags3 = pLVar2->flags3 | 0x10000;
		return 1;
	}
	return 0;
}



undefined4 __cdecl FUN_00448d20(int *param_1,float *param_2)
{
	float *pfVar1;
	float fVar2;
	int iVar3;
	float *pfVar4;
	short sVar5;
	int iVar6;
	BOOL BVar7;
	uint uVar8;
	float10 fVar9;
	float *local_18;
	uint local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pfVar4 = param_2;
	if (*(int *)param_1[0xc2] == 0xb) {
		pfVar1 = param_2 + 1;
		iVar6 = FUN_0040d170((int)*param_2,(int)param_2[1]);
		if (iVar6 != 0) {
			lego::game::LiveObject_GetBlockCoordinates
								((LiveObject *)param_1,(int *)&local_8,(int *)&local_4);
			if ((local_8 == *pfVar4) && (local_4 == *pfVar1)) {
				BVar7 = lego::game::LiveObject_FUN_004419c0
													((LiveObject *)param_1,1,pfVar4,pfVar1,(float *)0x0);
			}
			else {
				BVar7 = lego::game::LiveObject_FUN_004413b0
													(param_1,local_8,local_4,*pfVar4,*pfVar1,&param_2,&local_18,&local_14,0,0)
				;
				if (BVar7 == 0) {
					return 0;
				}
				BVar7 = lego::game::LiveObject_FUN_004419c0
													((LiveObject *)param_1,local_14,param_2,local_18,(float *)0x0);
				std::free(param_2);
				std::free(local_18);
			}
			if (BVar7 != 0) {
				*(undefined *)(param_1[9] + -3 + param_1[10] * 0x14) = 9;
				if (*param_1 == 1) {
					fVar9 = lego::math::Maths_RandRange(0.55,0.75);
					fVar2 = (float)fVar9;
					sVar5 = lego::math::Maths_Rand();
					uVar8 = (int)sVar5 >> 0x1f;
					switch((((int)sVar5 ^ uVar8) - uVar8 & 3 ^ uVar8) - uVar8) {
					case 0:
						local_10 = 0.5;
						local_c = fVar2;
						break;
					case 1:
						local_c = 0.5;
						local_10 = fVar2;
						break;
					case 2:
						local_10 = 0.5;
						local_c = 1.0 - fVar2;
						break;
					case 3:
						local_c = 0.5;
						local_10 = 1.0 - fVar2;
					}
					iVar6 = param_1[10];
					iVar3 = param_1[9];
					*(float *)(iVar3 + -0xc + iVar6 * 0x14) = local_10;
					*(float *)(iVar3 + -8 + iVar6 * 0x14) = local_c;
					*(byte *)(param_1[9] + -4 + param_1[10] * 0x14) =
							 *(byte *)(param_1[9] + -4 + param_1[10] * 0x14) | 8;
				}
				iVar6 = param_1[0xc2];
				*(float *)(iVar6 + 0x2f4) = (float)(int)*pfVar4;
				*(float *)(iVar6 + 0x2f8) = (float)(int)*pfVar1;
				return 1;
			}
		}
	}
	return 0;
}



undefined4 __cdecl FUN_00448f10(uint *param_1)
{
	lego::game::LiveObject_SetActivityUnk((LiveObject *)param_1,ACTIVITY_CLEAR,0);
	lego::game::Game_UpdateSomeAITasks((LiveObject *)param_1);
	param_1[0xf9] = param_1[0xf9] | 0x200;
	return 1;
}



int __cdecl FUN_00448f50(int *param_1,float *param_2,int param_3)
{
	byte *pbVar1;
	float fVar2;
	int *liveObj;
	float *liveObj_00;
	int iVar3;
	Container *cont;
	SurfaceMap *surfMap;
	byte bVar4;
	BOOL BVar5;
	float *out_x;
	float *out_y;
	uint local_30;
	float local_2c;
	float local_28;
	float local_24;
	float local_20;
	int local_1c;
	int local_18 [2];
	float local_10;
	Vector3F local_c;
	
	liveObj_00 = param_2;
	liveObj = param_1;
	BVar5 = 0;
	if (*param_2 == 5.605194e-45) {
		if (*param_1 == 2) {
			iVar3 = FUN_00449170(param_1,(int *)param_2,1);
			if (iVar3 != 0) {
				return 1;
			}
		}
		else {
			if (*param_1 == 1) {
				cont = lego::game::LiveObject_GetDepositNull((LiveObject *)param_2);
				lego::res::Container_GetPosition(cont,(Container *)0x0,&local_c);
				out_y = &local_28;
				out_x = &local_2c;
				surfMap = lego::game::GetSurfaceMap();
				lego::game::SurfaceMap_ToBlockCoordinatesNoZ
									(surfMap,local_c.x,local_c.y,(int *)out_x,(int *)out_y);
				lego::game::LiveObject_GetBlockCoordinates
									((LiveObject *)liveObj,(int *)&local_24,(int *)&local_20);
				lego::game::LiveObject_GetBlockCoordinates((LiveObject *)liveObj_00,&local_1c,local_18);
				fVar2 = (float)(int)local_2c - (float)local_1c;
				local_10 = (float)(int)local_28 - (float)local_18[0];
				if (ABS(fVar2) <= ABS(local_10)) {
					if ((ushort)((ushort)(local_10 < 0.0) << 8 | (ushort)(local_10 == 0.0) << 0xe) == 0) {
						bVar4 = 0;
					}
					else {
						bVar4 = 2;
					}
				}
				else {
					if ((ushort)((ushort)(fVar2 < 0.0) << 8 | (ushort)(fVar2 == 0.0) << 0xe) == 0) {
						bVar4 = 1;
					}
					else {
						bVar4 = 3;
					}
				}
				if ((local_24 == local_2c) && (local_20 == local_28)) {
					BVar5 = lego::game::LiveObject_FUN_004419c0
														((LiveObject *)liveObj,1,&local_2c,&local_28,(float *)0x0);
				}
				else {
					BVar5 = lego::game::LiveObject_FUN_004413b0
														(liveObj,local_24,local_20,local_2c,local_28,&param_2,&param_1,&local_30
														 ,0,0);
					if (BVar5 == 0) {
						return 0;
					}
					BVar5 = lego::game::LiveObject_FUN_004419c0
														((LiveObject *)liveObj,local_30,param_2,(float *)param_1,(float *)0x0);
					std::free(param_2);
					std::free(param_1);
				}
				if (BVar5 != 0) {
					*(undefined *)(liveObj[9] + -3 + liveObj[10] * 0x14) = 0xf;
					pbVar1 = (byte *)(liveObj[9] + -4 + liveObj[10] * 0x14);
					*pbVar1 = *pbVar1 | 4;
					*(byte *)(liveObj[9] + -4 + liveObj[10] * 0x14) =
							 *(byte *)(liveObj[9] + -4 + liveObj[10] * 0x14) | bVar4;
					liveObj[0x101] = param_3;
					liveObj[0xbf] = (int)liveObj_00;
					liveObj_00[0xc0] = (float)liveObj;
					return BVar5;
				}
			}
		}
	}
	return BVar5;
}



undefined4 __cdecl FUN_00449170(int *param_1,int *param_2,int param_3)
{
	byte *pbVar1;
	int iVar2;
	int iVar3;
	float fVar4;
	int *piVar5;
	BOOL BVar6;
	SurfaceMap *surfMap;
	uint uVar7;
	float10 fVar8;
	uint local_28;
	uint local_24;
	float local_20 [4];
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	piVar5 = param_2;
	if ((*param_1 == 2) && (*param_2 == 4)) {
		lego::game::LiveObject_GetBlockCoordinates
							((LiveObject *)param_2,(int *)&local_28,(int *)&local_24);
		BVar6 = lego::game::LiveObject_FUN_00446c80
											((LiveObject *)param_1,local_28,local_24,0,(uint *)&param_2,1);
		if (BVar6 != 0) {
			surfMap = lego::game::GetSurfaceMap();
			fVar8 = lego::game::SurfaceMap_GetBlockSize(surfMap);
			local_c = (float)((float10)4.0 / fVar8);
			fVar8 = lego::math::Maths_RandRange(0.1,0.9);
			iVar2 = param_1[10];
			local_20[0] = (float)fVar8;
			local_8 = local_c;
			uVar7 = (int)param_2 - 2U & 3;
			local_20[3] = local_20[0];
			local_10 = local_20[0];
			local_4 = local_20[0];
			local_20[1] = 1.0 - local_c;
			local_20[2] = 1.0 - local_c;
			iVar3 = param_1[9];
			fVar4 = local_20[uVar7 * 2 + 1];
			*(float *)(iVar3 + -0xc + iVar2 * 0x14) = local_20[uVar7 * 2];
			*(float *)(iVar3 + -8 + iVar2 * 0x14) = fVar4;
			if (param_3 == 0) {
				*(undefined *)(param_1[9] + -3 + param_1[10] * 0x14) = 0xe;
			}
			else {
				*(undefined *)(param_1[9] + -3 + param_1[10] * 0x14) = 0xf;
			}
			*(byte *)(param_1[9] + -4 + param_1[10] * 0x14) =
					 *(byte *)(param_1[9] + -4 + param_1[10] * 0x14) | 4;
			pbVar1 = (byte *)(param_1[9] + -4 + param_1[10] * 0x14);
			param_2._0_1_ = (byte)uVar7;
			*pbVar1 = *pbVar1 | (byte)param_2;
			param_1[0xbf] = (int)piVar5;
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_004492d0(LiveObject *liveObj)
{
	BOOL BVar1;
	Point2I local_8;
	
	if ((((liveObj->objType == OBJECT_MINIFIGURE) &&
			 ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
			(liveObj->carriedObjects[0]->objType == OBJECT_POWERCRYSTAL)) &&
		 ((liveObj->carriedObjects[0]->flags3 & LIVEOBJ3_UNK_80000000) != LIVEOBJ3_NONE)) {
		BVar1 = LiveObject_FindRechargeSeam_FUN_0044a690(liveObj,&local_8);
		if (BVar1 != 0) {
			BVar1 = LiveObject_RoutingPointerBlocks_FUN_00449b40(liveObj,local_8.x,local_8.y,3.0);
			if (BVar1 != 0) {
				*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 0x12;
				(liveObj->point_2f4).x = (float)local_8.x;
				(liveObj->point_2f4).y = (float)local_8.y;
				return 1;
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_TryRepair_FUN_00449360
					(LiveObject *in_liveObj,LiveObject *targetObj,BOOL param_3,BOOL param_4)
{
	byte *pbVar1;
	ObjectType OVar2;
	uint uVar3;
	void *pvVar4;
	float fVar5;
	bool bVar6;
	LiveObject *liveObj;
	ObjectStatsFlags2 OVar7;
	BOOL BVar8;
	SurfaceMap *surfMap;
	uint uVar9;
	float10 fVar10;
	uint local_28;
	uint local_24;
	float local_20 [4];
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	liveObj = targetObj;
	OVar2 = in_liveObj->objType;
	if ((OVar2 != OBJECT_MINIFIGURE) && (OVar2 != OBJECT_ROCKMONSTER)) {
		return 0;
	}
	if (targetObj->objType != OBJECT_BUILDING) {
		return 0;
	}
	if ((OVar2 == OBJECT_ROCKMONSTER) &&
		 (OVar7 = LiveObject_GetStatsFlags2(in_liveObj), (OVar7 & STATS2_DRAINPOWER) == STATS2_NONE)) {
		bVar6 = true;
	}
	else {
		bVar6 = false;
	}
	LiveObject_GetBlockCoordinates(liveObj,(int *)&local_28,(int *)&local_24);
	BVar8 = LiveObject_FUN_00446c80
										(in_liveObj,local_28,local_24,0,(uint *)&targetObj,
										 (uint)(in_liveObj->objType != OBJECT_ROCKMONSTER));
	if (BVar8 == 0) {
		return 0;
	}
	surfMap = GetSurfaceMap();
	fVar10 = SurfaceMap_GetBlockSize(surfMap);
	local_c = (float)((float10)4.0 / fVar10);
	if (bVar6) {
		fVar10 = (float10)0.5;
	}
	else {
		fVar10 = math::Maths_RandRange(0.2,0.8);
	}
	local_20[0] = (float)fVar10;
	local_8 = local_c;
	uVar9 = (int)&targetObj[-1].pool_m_next + 2U & 3;
	local_20[1] = 1.0 - local_c;
	local_20[2] = 1.0 - local_c;
	uVar3 = in_liveObj->routingBlocksTotal;
	local_20[3] = (float)fVar10;
	local_10 = (float)fVar10;
	local_4 = (float)fVar10;
	pvVar4 = in_liveObj->routeptr_24;
	fVar5 = local_20[uVar9 * 2 + 1];
	*(float *)((int)pvVar4 + uVar3 * 0x14 + -0xc) = local_20[uVar9 * 2];
	*(float *)((int)pvVar4 + uVar3 * 0x14 + -8) = fVar5;
	*(undefined *)((int)in_liveObj->routeptr_24 + in_liveObj->routingBlocksTotal * 0x14 + -3) = 6;
	*(byte *)((int)in_liveObj->routeptr_24 + in_liveObj->routingBlocksTotal * 0x14 + -4) =
			 *(byte *)((int)in_liveObj->routeptr_24 + in_liveObj->routingBlocksTotal * 0x14 + -4) | 4;
	targetObj._0_1_ = (byte)uVar9;
	pbVar1 = (byte *)((int)in_liveObj->routeptr_24 + in_liveObj->routingBlocksTotal * 0x14 + -4);
	*pbVar1 = *pbVar1 | (byte)targetObj;
	if (param_3 != 0) {
		pbVar1 = (byte *)((int)in_liveObj->routeptr_24 + in_liveObj->routingBlocksTotal * 0x14 + -4);
		*pbVar1 = *pbVar1 | 0x20;
	}
	if (param_4 != 0) {
		in_liveObj->flags4 = in_liveObj->flags4 | 0x400000;
	}
	in_liveObj->object_2fc = liveObj;
	return 1;
}



undefined4 __cdecl FUN_00449500(int *param_1,uint *param_2)
{
	BOOL BVar1;
	
	BVar1 = lego::game::LiveObject_FUN_00432950((LiveObject *)param_1,*param_2,param_2[1]);
	if (BVar1 != 0) {
		BVar1 = lego::game::LiveObject_RoutingPointerBlocks_FUN_00449b40
											((LiveObject *)param_1,*param_2,param_2[1],3.0);
		if (BVar1 != 0) {
			*(undefined *)(param_1[9] + -3 + param_1[10] * 0x14) = 2;
			param_1[0xbd] = (int)(float)*param_2;
			param_1[0xbe] = (int)(float)param_2[1];
			return 1;
		}
	}
	return 0;
}



undefined4 __cdecl FUN_00449570(int *param_1,float *param_2)
{
	int *liveObj;
	float *blockPosition;
	int iVar1;
	ObjectStatsFlags1 OVar2;
	BOOL BVar3;
	uint local_c;
	float local_8;
	float local_4;
	
	blockPosition = param_2;
	iVar1 = lego::game::Level_GetBlockRubbleLevel_OrFlag200000((Point2I *)param_2);
	liveObj = param_1;
	if (iVar1 != 0) {
		OVar2 = lego::game::LiveObject_GetStatsFlags1((LiveObject *)param_1);
		if ((OVar2 & STATS1_CANCLEARRUBBLE) == STATS1_NONE) {
			return 1;
		}
		lego::game::LiveObject_GetBlockCoordinates
							((LiveObject *)liveObj,(int *)&local_8,(int *)&local_4);
		if ((local_8 == *blockPosition) && (local_4 == blockPosition[1])) {
			BVar3 = lego::game::LiveObject_FUN_004419c0
												((LiveObject *)liveObj,1,blockPosition,blockPosition + 1,(float *)0x0);
		}
		else {
			BVar3 = lego::game::LiveObject_FUN_004413b0
												(liveObj,local_8,local_4,*blockPosition,blockPosition[1],&param_2,&param_1,
												 &local_c,0,0);
			if (BVar3 == 0) {
				return 0;
			}
			BVar3 = lego::game::LiveObject_FUN_004419c0
												((LiveObject *)liveObj,local_c,param_2,(float *)param_1,(float *)0x0);
			std::free(param_2);
			std::free(param_1);
		}
		if (BVar3 == 0) {
			return 0;
		}
		*(undefined *)(liveObj[9] + -3 + liveObj[10] * 0x14) = 4;
		if (*liveObj == 1) {
			FUN_00432640((Point2I *)blockPosition,1);
			FUN_00433050((int *)blockPosition,1);
			return 1;
		}
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_MiniFigureHasBeamEquipped(LiveObject *liveObj)
{
	BOOL BVar1;
	
	if (liveObj->objType != OBJECT_MINIFIGURE) {
		return 0;
	}
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_LASER);
	if (((BVar1 == 0) && (BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_PUSHERGUN), BVar1 == 0)) &&
		 (BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_FREEZERGUN), BVar1 == 0)) {
		return 0;
	}
	return 1;
}



int __cdecl FUN_004496f0(int *param_1,float *param_2)
{
	float *pfVar1;
	BOOL BVar2;
	float *local_18;
	uint local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pfVar1 = param_2;
	lego::game::LiveObject_GetBlockCoordinates((LiveObject *)param_2,(int *)&local_10,(int *)&local_c)
	;
	lego::game::LiveObject_GetBlockCoordinates((LiveObject *)param_1,(int *)&local_8,(int *)&local_4);
	if ((local_8 == local_10) && (local_4 == local_c)) {
		BVar2 = lego::game::LiveObject_FUN_004419c0
											((LiveObject *)param_1,1,&local_10,&local_c,(float *)0x0);
	}
	else {
		BVar2 = lego::game::LiveObject_FUN_004413b0
											(param_1,local_8,local_4,local_10,local_c,&param_2,&local_18,&local_14,0,0);
		if (BVar2 == 0) {
			return 0;
		}
		BVar2 = lego::game::LiveObject_FUN_004419c0
											((LiveObject *)param_1,local_14,param_2,local_18,(float *)0x0);
		std::free(param_2);
		std::free(local_18);
	}
	if (BVar2 != 0) {
		*(undefined *)(param_1[9] + -3 + param_1[10] * 0x14) = 0x11;
		param_1[0xbf] = (int)pfVar1;
	}
	return BVar2;
}



int __cdecl FUN_004497e0(int *param_1,undefined4 *param_2)
{
	int *liveObj;
	BOOL BVar1;
	float *local_18;
	uint local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	liveObj = param_1;
	lego::game::LiveObject_GetBlockCoordinates((LiveObject *)param_1,(int *)&local_8,(int *)&local_4);
	lego::game::LiveObject_GetBlockCoordinates((LiveObject *)param_2,(int *)&local_10,(int *)&local_c)
	;
	if ((local_8 == local_10) && (local_4 == local_c)) {
		BVar1 = lego::game::LiveObject_FUN_004419c0
											((LiveObject *)liveObj,1,&local_10,&local_c,(float *)0x0);
	}
	else {
		BVar1 = lego::game::LiveObject_FUN_004413b0
											(liveObj,local_8,local_4,local_10,local_c,&param_1,&local_18,&local_14,0,0);
		if (BVar1 == 0) {
			return 0;
		}
		BVar1 = lego::game::LiveObject_FUN_004419c0
											((LiveObject *)liveObj,local_14,(float *)param_1,local_18,(float *)0x0);
		std::free(param_1);
		std::free(local_18);
	}
	if (BVar1 != 0) {
		*(undefined *)(liveObj[9] + -3 + liveObj[10] * 0x14) = 0x14;
	}
	return BVar1;
}



int __cdecl FUN_004498d0(LiveObject *liveObj,float *param_2)
{
	LiveObject *liveObj_00;
	float *pfVar1;
	BOOL BVar2;
	float *local_10;
	uint local_c;
	float local_8;
	float local_4;
	
	liveObj_00 = liveObj;
	lego::game::LiveObject_GetBlockCoordinates(liveObj,(int *)&local_8,(int *)&local_4);
	pfVar1 = param_2;
	if ((local_8 == *param_2) && (local_4 == param_2[1])) {
		BVar2 = lego::game::LiveObject_FUN_004419c0(liveObj_00,1,param_2,param_2 + 1,(float *)0x0);
	}
	else {
		BVar2 = lego::game::LiveObject_FUN_004413b0
											(liveObj_00,local_8,local_4,*param_2,param_2[1],&liveObj,&local_10,&local_c,0,
											 0);
		if (BVar2 == 0) {
			return 0;
		}
		BVar2 = lego::game::LiveObject_FUN_004419c0
											(liveObj_00,local_c,(float *)liveObj,local_10,(float *)0x0);
		std::free(liveObj);
		std::free(local_10);
	}
	if (BVar2 != 0) {
		*(undefined *)((int)liveObj_00->routeptr_24 + liveObj_00->routingBlocksTotal * 0x14 + -3) = 0x10
		;
		(liveObj_00->point_2f4).x = (float)(int)*pfVar1;
		(liveObj_00->point_2f4).y = (float)(int)pfVar1[1];
	}
	return BVar2;
}



int __cdecl lego::game::LiveObject_FUN_004499c0(LiveObject *liveObj)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	BOOL BVar3;
	float *local_18;
	uint local_14;
	Point2I local_10;
	float local_8;
	float local_4;
	LiveObject *liveObj_00;
	
	liveObj_00 = liveObj;
	BVar3 = 0;
	OVar1 = LiveObject_GetStatsFlags2(liveObj);
	if ((OVar1 & STATS2_USEHOLES) == STATS2_NONE) {
		BVar2 = LiveObject_FUN_0044a890(liveObj_00,(int *)&local_10,&local_10.y,1,0,1);
		if ((BVar2 != 0) &&
			 (BVar2 = LiveObject_RoutingPointerBlocks_FUN_00449b40(liveObj_00,local_10.x,local_10.y,3.0),
			 BVar2 != 0)) {
			BVar3 = 1;
			*(undefined *)((int)liveObj_00->routeptr_24 + liveObj_00->routingBlocksTotal * 0x14 + -3) = 10
			;
			(liveObj_00->point_2f4).x = (float)local_10.x;
			(liveObj_00->point_2f4).y = (float)local_10.y;
		}
	}
	else {
		BVar2 = LiveObject_NearestSlugHole_FUN_0044a7b0(liveObj_00,&local_10);
		if (BVar2 != 0) {
			LiveObject_GetBlockCoordinates(liveObj_00,(int *)&local_8,(int *)&local_4);
			if ((local_8 == (float)local_10.x) && (local_4 == (float)local_10.y)) {
				BVar3 = LiveObject_FUN_004419c0
													(liveObj_00,1,(float *)&local_10,(float *)&local_10.y,(float *)0x0);
			}
			else {
				BVar3 = LiveObject_FUN_004413b0
													(liveObj_00,local_8,local_4,local_10.x,local_10.y,&liveObj,&local_18,
													 &local_14,0,0);
				if (BVar3 == 0) {
					BVar3 = 0;
				}
				else {
					BVar3 = LiveObject_FUN_004419c0
														(liveObj_00,local_14,(float *)liveObj,local_18,(float *)0x0);
					std::free(liveObj);
					std::free(local_18);
				}
			}
			if (BVar3 == 0) {
				return 0;
			}
			*(undefined *)((int)liveObj_00->routeptr_24 + liveObj_00->routingBlocksTotal * 0x14 + -3) = 10
			;
			(liveObj_00->point_2f4).x = (float)local_10.x;
			(liveObj_00->point_2f4).y = (float)local_10.y;
		}
	}
	if (BVar3 != 0) {
		LiveObject_FUN_004029d0(liveObj_00);
	}
	return BVar3;
}



BOOL __cdecl
lego::game::LiveObject_RoutingPointerBlocks_FUN_00449b40
					(LiveObject *liveObj,uint x,uint y,float param_4)
{
	byte *pbVar1;
	uint uVar2;
	BOOL BVar3;
	SurfaceMap *surfMap;
	float10 fVar4;
	
	uVar2 = y;
	BVar3 = Level_GetBlockFlags1_10Not8(x,y);
	if ((BVar3 != 0) && (BVar3 = LiveObject_FUN_00446c80(liveObj,x,uVar2,0,&y,1), BVar3 != 0)) {
		surfMap = GetSurfaceMap();
		fVar4 = SurfaceMap_GetBlockSize(surfMap);
		fVar4 = (float10)param_4 / fVar4;
		*(undefined4 *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -8) =
				 0x3f000000;
		*(undefined4 *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -0xc) =
				 0x3f000000;
		switch(y) {
		case 0:
			*(float *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -8) = (float)fVar4
			;
			break;
		case 1:
			*(float *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -0xc) =
					 (float)fVar4;
			break;
		case 2:
			*(float *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -8) =
					 (float)((float10)1.0 - fVar4);
			break;
		case 3:
			*(float *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -0xc) =
					 (float)((float10)1.0 - fVar4);
		}
		pbVar1 = (byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4);
		*pbVar1 = *pbVar1 | 8;
		return 1;
	}
	return 0;
}



BOOL __cdecl FUN_00449c40(LiveObject *liveObj,undefined4 param_2,BOOL *out_bool)
{
	BOOL BVar1;
	longlong lVar2;
	longlong lVar3;
	Point2I local_8;
	
	*out_bool = 0;
	if ((*(byte *)&liveObj->flags1 & 0x40) == 0) {
		return 0;
	}
	lVar2 = __ftol((float10)(liveObj->point_2f4).x);
	local_8.x = (uint)lVar2;
	lVar3 = __ftol((float10)(liveObj->point_2f4).y);
	local_8.y = (int)lVar3;
	BVar1 = lego::game::LiveObject_FUN_00432950(liveObj,(uint)lVar2,local_8.y);
	if (BVar1 == 0) {
		lego::game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_CANTDO,1);
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_REINFORCING | LIVEOBJ1_UNK_80000000;
	}
	else {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) != 0) {
			return 1;
		}
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_REINFORCING;
		lego::game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		FUN_00431070(local_8.x,local_8.y);
		(liveObj->point_2f4).y = -1.0;
		(liveObj->point_2f4).x = -1.0;
		*out_bool = 1;
	}
	lego::game::Level_SetBlockFlags1_8000000(&local_8,0);
	return 1;
}



void __cdecl lego::game::LiveObject_GoEat_unk(LiveObject *liveObj)
{
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_800;
	}
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
		liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_EATING;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_EAT,0);
		Game_UpdateSomeAITasks(liveObj);
		ai::AITask_DoAnimationWait(liveObj);
	}
	return;
}



BOOL __cdecl FUN_00449d80(LiveObject *liveObj1,LiveObject *liveObj2)
{
	byte *pbVar1;
	uint uVar2;
	void *pvVar3;
	LiveObject *liveObj;
	LiveObject *pLVar4;
	BOOL BVar5;
	SurfaceMap *surfMap;
	uint uVar6;
	float10 fVar7;
	uint local_28;
	uint local_24;
	float local_20 [4];
	undefined4 local_10;
	float local_c;
	float local_8;
	undefined4 local_4;
	
	pLVar4 = liveObj2;
	liveObj = liveObj1;
	if ((liveObj1->objType == OBJECT_MINIFIGURE) && (liveObj2->objType == OBJECT_BUILDING)) {
		lego::game::LiveObject_GetBlockCoordinates(liveObj2,(int *)&local_28,(int *)&local_24);
		BVar5 = lego::game::LiveObject_FUN_00446c80(liveObj,local_28,local_24,0,(uint *)&liveObj1,1);
		if (BVar5 != 0) {
			surfMap = lego::game::GetSurfaceMap();
			fVar7 = lego::game::SurfaceMap_GetBlockSize(surfMap);
			fVar7 = (float10)4.0 / fVar7;
			local_20[0] = 0.5;
			local_20[3] = 0.5;
			local_10 = 0x3f000000;
			local_4 = 0x3f000000;
			uVar6 = (int)&liveObj1[-1].pool_m_next + 2U & 3;
			uVar2 = liveObj->routingBlocksTotal;
			pvVar3 = liveObj->routeptr_24;
			local_20[1] = (float)((float10)1.0 - fVar7);
			local_20[2] = (float)((float10)1.0 - fVar7);
			local_c = (float)fVar7;
			local_8 = (float)fVar7;
			*(float *)((int)pvVar3 + uVar2 * 0x14 + -0xc) = local_20[uVar6 * 2];
			*(float *)((int)pvVar3 + uVar2 * 0x14 + -8) = local_20[uVar6 * 2 + 1];
			*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 0xb;
			*(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) =
					 *(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) | 4;
			liveObj1._0_1_ = (byte)uVar6;
			pbVar1 = (byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4);
			*pbVar1 = *pbVar1 | (byte)liveObj1;
			liveObj->object_2fc = pLVar4;
			return 1;
		}
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_800;
	}
	return 0;
}



BOOL __cdecl FUN_00449ec0(void)
{
	BOOL BVar1;
	
	BVar1 = lego::unk::DoLiveObjCallbacks_FUN_00437a90
										(lego::game::LiveObject_FUN_00449fb0,(void *)0x0,0);
	return BVar1;
}



void __cdecl
lego::game::Flocks_CallbackFUN_00449ee0(FlockData *flockData,FlockSubdata *subdata,void *lpContext)
{
	Container *cont;
	SurfaceMap *surfMap;
	LevelData *pLVar1;
	BOOL BVar2;
	FlockSubdata **out_x;
	uint *puVar3;
	uint local_10;
	Vector3F local_c;
	
	cont = subdata->resData_98;
	res::Container_GetPosition(cont,(Container *)0x0,&local_c);
	puVar3 = &local_10;
	out_x = &subdata;
	surfMap = GetSurfaceMap();
	SurfaceMap_ToBlockCoordinatesNoZ(surfMap,local_c.x,local_c.y,(int *)out_x,(int *)puVar3);
	pLVar1 = GetLevel();
	if (subdata <= (FlockSubdata *)(pLVar1->dimensions).width) {
		pLVar1 = GetLevel();
		puVar3 = (uint *)&(pLVar1->dimensions).height;
		if (local_10 < *puVar3 || local_10 == *puVar3) {
			BVar2 = Level_Block_FUN_00433d60((int)subdata,local_10);
			if (BVar2 == 0) {
				BVar2 = FUN_00432e70((uint)subdata,local_10);
				if (BVar2 == 0) {
					res::Container_Hide(cont,0);
					return;
				}
			}
		}
	}
	res::Container_Hide(cont,1);
	return;
}



void __cdecl lego::game::LiveObject_SetResourceFlag80(LiveObject *liveObj,BOOL state)
{
	Container *cont;
	
	cont = LiveObject_GetResource(liveObj);
	if (cont != (Container *)0x0) {
		res::Container_Hide2(cont,state);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_00449fb0(LiveObject *liveObj)
{
	bool bVar1;
	ObjectStatsFlags1 OVar2;
	BOOL BVar3;
	ObjectStatsFlags2 OVar4;
	Point2I *pPVar5;
	Point2I *pPVar6;
	uint uVar7;
	Point2I *pPVar8;
	Direction rotation;
	uint uVar9;
	uint y;
	uint x;
	uint local_20;
	BOOL local_1c;
	Point2F local_18;
	Point2I local_10;
	float local_8;
	float local_4;
	
	uVar9 = 0;
	local_1c = 0;
	OVar2 = LiveObject_GetStatsFlags1(liveObj);
	if ((OVar2 & STATS1_FLOCKS) != STATS1_NONE) {
		Flocks_CallbackForAllSubdata(liveObj->flocksData_32c,Flocks_CallbackFUN_00449ee0,(void *)0x0);
		return 0;
	}
	BVar3 = LiveObject_GetBlockCoordinates(liveObj,(int *)&x,(int *)&y);
	if (BVar3 == 0) {
		LiveObject_FUN_0044a210(liveObj,1);
		return 0;
	}
	BVar3 = Level_GetBlockFlags1_8(x,y);
	if (BVar3 != 0) {
		liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_100000;
	}
	BVar3 = FUN_00432e70(x,y);
	if (((BVar3 == 0) && ((liveObj->flags3 & LIVEOBJ3_UNK_100000) == LIVEOBJ3_NONE)) &&
		 ((liveObj->objType != OBJECT_MINIFIGURE ||
			((liveObj->drivenObject == (LiveObject *)0x0 ||
			 (OVar4 = LiveObject_GetStatsFlags2(liveObj->drivenObject),
			 (OVar4 & STATS2_INVISIBLEDRIVER) == STATS2_NONE)))))) {
		BVar3 = 0;
	}
	else {
		BVar3 = 1;
	}
	LiveObject_FUN_0044a210(liveObj,BVar3);
	BVar3 = Level_Block_FUN_00433d60(x,y);
	if (((BVar3 != 0) || (BVar3 = FUN_00432e70(x,y), BVar3 != 0)) ||
		 ((liveObj->flags3 & LIVEOBJ3_UNK_100000) != LIVEOBJ3_NONE)) {
		rotation = DIRECTION_RIGHT;
		local_1c = 1;
		if (liveObj->objType == OBJECT_BUILDING) {
			LiveObject_GetFaceDirection(liveObj,&local_18);
			LiveObject_GetBlockCoordinates(liveObj,(int *)&local_10,&local_10.y);
			LiveObject_GetPosition(liveObj,&local_8,&local_4);
			if (ABS(local_18.x) <= ABS(local_18.y)) {
				if ((ushort)((ushort)(local_18.y < 0.0) << 8 | (ushort)(local_18.y == 0.0) << 0xe) == 0) {
					rotation = DIRECTION_UP;
				}
				else {
					rotation = DIRECTION_DOWN;
				}
			}
			else {
				if ((ushort)((ushort)(local_18.x < 0.0) << 8 | (ushort)(local_18.x == 0.0) << 0xe) != 0) {
					rotation = DIRECTION_LEFT;
				}
			}
			pPVar5 = res::Building_GetShapePoints
												 (globals::g_Game.BuildingData_TABLE + liveObj->objIndex,&local_20);
			pPVar6 = Game_TransformShapePoints(&local_10,pPVar5,local_20,rotation);
			uVar7 = local_20;
			pPVar5 = pPVar6;
			if (local_20 != 0) {
				do {
					pPVar8 = pPVar5 + 1;
					if (((uVar9 == uVar7 - 1) || (pPVar6->x != pPVar8->x)) || (pPVar6->y != pPVar5[1].y)) {
						bVar1 = false;
						BVar3 = Level_Block_FUN_00433d60(pPVar6->x,pPVar6->y);
						uVar7 = local_20;
						if (BVar3 == 0) {
							local_1c = 0;
							break;
						}
					}
					else {
						bVar1 = true;
					}
					if (bVar1) {
						uVar9 = uVar9 + 1;
						pPVar8 = pPVar5 + 2;
						pPVar6 = pPVar6 + 1;
					}
					uVar9 = uVar9 + 1;
					pPVar6 = pPVar6 + 1;
					pPVar5 = pPVar8;
				} while (uVar9 < uVar7);
			}
		}
	}
	LiveObject_SetResourceFlag80(liveObj,local_1c);
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_0044a210(LiveObject *liveObj,BOOL use3rdFrame)
{
	ObjectType OVar1;
	
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		res::Vehicle_FUN_0046d580(liveObj->vehicle,use3rdFrame);
		return;
	}
	if (OVar1 == OBJECT_MINIFIGURE) {
		FUN_00406bc0((BasicObjectData *)liveObj->miniFigure,use3rdFrame);
		return;
	}
	if (OVar1 == OBJECT_ROCKMONSTER) {
		FUN_00406bc0((BasicObjectData *)liveObj->rockMonster,use3rdFrame);
		return;
	}
	if (OVar1 == OBJECT_BUILDING) {
		FUN_004085a0(liveObj->building,use3rdFrame);
		return;
	}
	if (OVar1 == OBJECT_UPGRADEPART) {
		FUN_00406bc0((BasicObjectData *)liveObj->upgrade,use3rdFrame);
		return;
	}
	if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
		res::Container_Hide(liveObj->other,use3rdFrame);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_0044a2b0(LiveObject *liveObj)
{
	ObjectType OVar1;
	
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		OVar1 = res::Vehicle_GetFlag2(liveObj->vehicle);
		return OVar1;
	}
	if (OVar1 == OBJECT_MINIFIGURE) {
		OVar1 = res::Object_GetFlag8((BasicObjectData *)liveObj->miniFigure);
		return OVar1;
	}
	if (OVar1 == OBJECT_ROCKMONSTER) {
		OVar1 = res::Object_GetFlag8((BasicObjectData *)liveObj->rockMonster);
		return OVar1;
	}
	if (OVar1 == OBJECT_BUILDING) {
		OVar1 = res::Object_GetFlag8((BasicObjectData *)liveObj->building);
		return OVar1;
	}
	if (OVar1 == OBJECT_UPGRADEPART) {
		OVar1 = res::Object_GetFlag8((BasicObjectData *)liveObj->upgrade);
		return OVar1;
	}
	if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
		OVar1 = res::Container_IsHidden(liveObj->other);
	}
	return OVar1;
}



void __cdecl
lego::game::LiveObject_UnkCameraFunc
					(LiveObject *liveObj,int param_2,Vector3F *param_3,Vector3F *param_4)
{
	ObjectType OVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	Container *pCVar5;
	LiveObject *pLVar6;
	Vector3F local_c;
	
	if ((liveObj->resData_2dc != (Container *)0x0) && (liveObj->index_2e0 == param_2))
	goto LAB_0044a3a2;
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		pCVar5 = res::Vehicle_GetCameraNull(liveObj->vehicle,param_2);
LAB_0044a371:
		liveObj->resData_2dc = pCVar5;
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			pCVar5 = res::Creature_GetCameraNull(liveObj->miniFigure,param_2);
			goto LAB_0044a371;
		}
		if (OVar1 != OBJECT_ROCKMONSTER) goto LAB_0044a3a2;
		pCVar5 = res::Creature_GetCameraNull(liveObj->rockMonster,param_2);
		liveObj->resData_2dc = pCVar5;
	}
	if (pCVar5 != (Container *)0x0) {
		liveObj->index_2e0 = param_2;
	}
LAB_0044a3a2:
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		pLVar6 = (LiveObject *)res::Vehicle_IsCameraFlipDir(liveObj->vehicle);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			pLVar6 = (LiveObject *)res::Creature_IsCameraFlipDir(liveObj->miniFigure);
		}
		else {
			pLVar6 = liveObj;
			if (OVar1 == OBJECT_ROCKMONSTER) {
				pLVar6 = (LiveObject *)res::Creature_IsCameraFlipDir(liveObj->rockMonster);
			}
		}
	}
	if (liveObj->resData_2dc != (Container *)0x0) {
		res::Container_GetPosition(liveObj->resData_2dc,(Container *)0x0,param_3);
		res::Container_GetOrientation(liveObj->resData_2dc,(Container *)0x0,param_4,&local_c);
		fVar2 = 1.0 / SQRT(param_4->x * param_4->x + param_4->z * param_4->z + param_4->y * param_4->y);
		fVar4 = fVar2 * param_4->x;
		fVar3 = fVar2 * param_4->y;
		fVar2 = fVar2 * param_4->z;
		param_4->x = fVar4;
		param_4->y = fVar3;
		param_4->z = fVar2;
		if (pLVar6 != (LiveObject *)0x0) {
			param_4->x = fVar4 * -1.0;
			param_4->y = fVar3 * -1.0;
			param_4->z = fVar2 * -1.0;
			return;
		}
	}
	return;
}



Container * __cdecl lego::game::LiveObject_GetResource(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	
	switch(liveObj->objType) {
	case OBJECT_VEHICLE:
		pLVar1 = (LiveObject *)res::Vehicle_GetAEResource(liveObj->vehicle);
		return (Container *)pLVar1;
	case OBJECT_MINIFIGURE:
		pLVar1 = (LiveObject *)res::Object_GetAEResource((BasicObjectData *)liveObj->miniFigure);
		return (Container *)pLVar1;
	case OBJECT_ROCKMONSTER:
		pLVar1 = (LiveObject *)res::Object_GetAEResource((BasicObjectData *)liveObj->rockMonster);
		return (Container *)pLVar1;
	case OBJECT_BUILDING:
		pLVar1 = (LiveObject *)res::Object_GetAEResource((BasicObjectData *)liveObj->building);
		return (Container *)pLVar1;
	case OBJECT_UPGRADEPART:
		pLVar1 = (LiveObject *)res::Object_GetAEResource((BasicObjectData *)liveObj->upgrade);
		return (Container *)pLVar1;
	}
	if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
		return (Container *)(LiveObject *)liveObj->other;
	}
	return (Container *)liveObj;
}



BOOL __cdecl
lego::game::LiveObject_GetDrillNullPosition(LiveObject *liveObj,float *out_x,float *out_y)
{
	ObjectType OVar1;
	Container *cont;
	CreatureData *creature;
	Vector3F vector;
	
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		cont = res::Vehicle_GetDrillNull(liveObj->vehicle);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			creature = liveObj->miniFigure;
		}
		else {
			if (OVar1 != OBJECT_ROCKMONSTER) {
				return 0;
			}
			creature = liveObj->rockMonster;
		}
		cont = res::Creature_GetDrillNull(creature);
	}
	if (cont == (Container *)0x0) {
		return 0;
	}
	res::Container_GetPosition(cont,(Container *)0x0,&vector);
	*out_x = vector.x;
	*out_y = vector.y;
	return 1;
}



void __cdecl lego::game::LiveObject_FPMove(LiveObject *liveObj,int forward,int strafe,float rotate)
{
	ObjectStatsFlags3 OVar1;
	
	if ((liveObj->objType == OBJECT_MINIFIGURE) && (liveObj->drivenObject != (LiveObject *)0x0)) {
		liveObj = liveObj->drivenObject;
	}
	if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_MOVING) != 0) {
		LiveObject_UnkDoRouting_FUN_00441c00(liveObj,FALSE);
	}
	OVar1 = LiveObject_GetStatsFlags3(liveObj);
	if ((OVar1 & STATS3_CANSTRAFE) == STATS3_NONE) {
		strafe = 0;
	}
	liveObj->strafeSpeed_2bc = liveObj->strafeSpeed_2bc + strafe;
	liveObj->forwardSpeed_2c0 = liveObj->forwardSpeed_2c0 + forward;
	liveObj->rotateSpeed_2c4 = rotate + liveObj->rotateSpeed_2c4;
	return;
}



void __cdecl lego::game::Level_RegisterRechargeSeam(Point2I *blockPos)
{
	if (globals::g_RechargeSeams_COUNT < 10) {
		globals::g_RechargeSeams_TABLE[globals::g_RechargeSeams_COUNT].x = blockPos->x;
		globals::g_RechargeSeams_TABLE[globals::g_RechargeSeams_COUNT].y = blockPos->y;
		globals::g_RechargeSeams_COUNT = globals::g_RechargeSeams_COUNT + 1;
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_FindRechargeSeam_FUN_0044a690(LiveObject *liveObj,Point2I *out_seamBlockPos)
{
	float fVar1;
	SurfaceMap *surfMap;
	uint uVar2;
	uint uVar3;
	Point2I *pPVar4;
	uint x;
	uint y;
	float *out_x;
	float *out_y;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	uVar2 = 0xffffffff;
	local_14 = 10000.0;
	LiveObject_GetPosition(liveObj,&local_10,&local_c);
	uVar3 = 0;
	if (globals::g_RechargeSeams_COUNT != 0) {
		pPVar4 = globals::g_RechargeSeams_TABLE;
		do {
			y = pPVar4->y;
			x = pPVar4->x;
			out_y = &local_4;
			out_x = &local_8;
			surfMap = GetSurfaceMap();
			SurfaceMap_FUN_0044f900(surfMap,x,y,out_x,out_y);
			fVar1 = SQRT((local_c - local_4) * (local_c - local_4) +
									 (local_10 - local_8) * (local_10 - local_8));
			if (fVar1 < local_14) {
				uVar2 = uVar3;
				local_14 = fVar1;
			}
			uVar3 = uVar3 + 1;
			pPVar4 = pPVar4 + 1;
		} while (uVar3 < globals::g_RechargeSeams_COUNT);
	}
	if (uVar2 == 0xffffffff) {
		return 0;
	}
	if (out_seamBlockPos != (Point2I *)0x0) {
		out_seamBlockPos->x = globals::g_RechargeSeams_TABLE[uVar2].x;
		out_seamBlockPos->y = globals::g_RechargeSeams_TABLE[uVar2].y;
	}
	return 1;
}



void __cdecl lego::game::Level_RegisterSlimySlugHole(Point2I *position)
{
	if (globals::g_SlimySlugHoles_COUNT < 20) {
		globals::g_SlimySlugHoles_TABLE[globals::g_SlimySlugHoles_COUNT].x = position->x;
		globals::g_SlimySlugHoles_TABLE[globals::g_SlimySlugHoles_COUNT].y = position->y;
		globals::g_SlimySlugHoles_COUNT = globals::g_SlimySlugHoles_COUNT + 1;
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_NearestSlugHole_FUN_0044a7b0(LiveObject *liveObj,Point2I *out_blockPos)
{
	float fVar1;
	SurfaceMap *surfMap;
	uint uVar2;
	uint uVar3;
	Point2I *pPVar4;
	uint x;
	uint y;
	float *out_x;
	float *out_y;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	uVar2 = 0xffffffff;
	local_14 = 10000.0;
	LiveObject_GetPosition(liveObj,&local_10,&local_c);
	uVar3 = 0;
	if (globals::g_SlimySlugHoles_COUNT != 0) {
		pPVar4 = globals::g_SlimySlugHoles_TABLE;
		do {
			y = pPVar4->y;
			x = pPVar4->x;
			out_y = &local_4;
			out_x = &local_8;
			surfMap = GetSurfaceMap();
			SurfaceMap_FUN_0044f900(surfMap,x,y,out_x,out_y);
			fVar1 = SQRT((local_c - local_4) * (local_c - local_4) +
									 (local_10 - local_8) * (local_10 - local_8));
			if (fVar1 < local_14) {
				uVar2 = uVar3;
				local_14 = fVar1;
			}
			uVar3 = uVar3 + 1;
			pPVar4 = pPVar4 + 1;
		} while (uVar3 < globals::g_SlimySlugHoles_COUNT);
	}
	if (uVar2 == 0xffffffff) {
		return 0;
	}
	if (out_blockPos != (Point2I *)0x0) {
		out_blockPos->x = globals::g_SlimySlugHoles_TABLE[uVar2].x;
		out_blockPos->y = globals::g_SlimySlugHoles_TABLE[uVar2].y;
	}
	return 1;
}



BOOL __cdecl
lego::game::LiveObject_FUN_0044a890
					(LiveObject *liveObj,int *param_2,int *param_3,BOOL param_4,BOOL param_5,BOOL param_6)
{
	float fVar1;
	BOOL BVar2;
	int iVar3;
	int iVar4;
	float *pfVar5;
	float *pfVar6;
	uint number;
	uint x;
	uint y;
	longlong lVar7;
	int local_4cc;
	int local_4c8;
	SurfaceMap *local_4c4;
	float local_4c0;
	float local_4bc;
	float local_4b8;
	float local_4b4;
	float local_4b0;
	float local_4ac [299];
	
	local_4c4 = GetSurfaceMap();
	number = 0;
	LiveObject_GetPosition(liveObj,&local_4b8,&local_4b4);
	LiveObject_GetBlockCoordinates(liveObj,&local_4cc,&local_4c8);
	y = local_4c8 - 10;
	iVar3 = local_4cc;
	iVar4 = local_4c8;
	if ((int)y < local_4c8 + 10) {
		do {
			x = iVar3 - 10;
			if ((int)x < iVar3 + 10) {
				pfVar5 = local_4ac + number * 3;
				do {
					BVar2 = Level_GetBlockFlags1_10Not8(x,y);
					pfVar6 = pfVar5;
					if (((BVar2 != 0) &&
							((param_6 != 0 || (BVar2 = Level_GetBlockFlags1_20(x,y), BVar2 == 0)))) &&
						 ((param_5 != 0 || (BVar2 = Level_GetBlockFlags1_c0(x,y), BVar2 == 0)))) {
						SurfaceMap_FUN_0044f900(local_4c4,x,y,&local_4c0,&local_4bc);
						fVar1 = SQRT((local_4bc - local_4b4) * (local_4bc - local_4b4) +
												 (local_4c0 - local_4b8) * (local_4c0 - local_4b8));
						if (((param_4 == 0) || (local_4c4->BlockSize <= fVar1)) && (number < 100)) {
							number = number + 1;
							pfVar6 = pfVar5 + 3;
							pfVar5[-1] = (float)x;
							*pfVar5 = (float)y;
							pfVar5[1] = fVar1;
						}
					}
					x = x + 1;
					iVar3 = local_4cc;
					iVar4 = local_4c8;
					pfVar5 = pfVar6;
				} while ((int)x < local_4cc + 10);
			}
			y = y + 1;
		} while ((int)y < iVar4 + 10);
	}
	if (number == 0) {
		return 0;
	}
	std::qsort(&local_4b0,number,0xc,FUN_0044aa60);
	lVar7 = __ftol((float10)local_4b0);
	*param_2 = (int)lVar7;
	lVar7 = __ftol((float10)local_4ac[0]);
	*param_3 = (int)lVar7;
	return 1;
}



BOOL __cdecl FUN_0044aa60(int param_1,int param_2)
{
	if ((ushort)((ushort)(*(float *)(param_1 + 8) < *(float *)(param_2 + 8)) << 8 |
							(ushort)(*(float *)(param_1 + 8) == *(float *)(param_2 + 8)) << 0xe) == 0) {
		return 1;
	}
	if (*(float *)(param_1 + 8) < *(float *)(param_2 + 8)) {
		return -1;
	}
	return 0;
}



PolyMeshData * __cdecl
lego::res::Res_LoadPolyMesh
					(CFGProperty *aeRoot,char *rootName,char *dirname,PolyMode polyMode,uint numCameraFrames)
{
	char *pcVar1;
	CFGProperty *prop;
	int iVar2;
	PolyMeshData *lastPolyData;
	uint index;
	PolyMeshData *local_104;
	char local_100 [256];
	
	index = 0;
	lastPolyData = (PolyMeshData *)0x0;
	local_104 = (PolyMeshData *)0x0;
	if (polyMode != POLY_FP) {
		numCameraFrames = 1;
	}
	if (numCameraFrames != 0) {
		do {
			if (polyMode == POLY_FP) {
				std::sprintf(local_100,"FPPoly::Camera%i",index + 1);
			}
			else {
				if (polyMode == POLY_HIGH) {
					pcVar1 = "HighPoly";
				}
				else {
					if (polyMode != POLY_MEDIUM) goto LAB_0044ab0b;
					pcVar1 = "MediumPoly";
				}
				std::sprintf(local_100,pcVar1);
			}
LAB_0044ab0b:
			pcVar1 = cfg::CFG_JoinPath(rootName,local_100,0);
			for (prop = cfg::CFG_GetChildren(aeRoot,pcVar1); prop != (CFGProperty *)0x0;
					prop = cfg::CFG_NextFlat(prop)) {
				pcVar1 = prop->key;
				if (*pcVar1 == '!') {
					if ((globs::mainGlobs.flags & CMD_REDUCEPROMESHES) == CMD_NONE) {
						pcVar1 = pcVar1 + 1;
						goto LAB_0044ab53;
					}
				}
				else {
LAB_0044ab53:
					iVar2 = std::_stricmp("NULL",prop->value);
					if (iVar2 == 0) {
						lastPolyData = Res_CreateNullPolyMesh(lastPolyData,pcVar1,index);
					}
					else {
						lastPolyData = Res_CreatePolyMesh(lastPolyData,pcVar1,dirname,prop->value,index);
					}
					if (local_104 == (PolyMeshData *)0x0) {
						local_104 = lastPolyData;
					}
				}
			}
			index = index + 1;
		} while (index < numCameraFrames);
	}
	return local_104;
}



BOOL __cdecl
lego::game::Game_UnkBuildingPlaceDirection
					(ObjectType objType,int objIndex,BOOL param_3,BOOL param_4,Point2F *param_5,uint x,uint y,
					BOOL param_8,Container **pResData)
{
	float fVar1;
	float fVar2;
	BOOL BVar3;
	Point2I *pPVar4;
	int iVar5;
	SurfaceMap *surfMap;
	Point2I *pPVar6;
	undefined4 uVar7;
	LiveObject *pLVar8;
	ObjectStatsFlags1 OVar9;
	int iVar10;
	uint uVar11;
	uint y_00;
	Point2F *out_x;
	float *out_y;
	Point2I local_10;
	Point2F local_8;
	
	y_00 = y;
	uVar11 = x;
	local_10.x = x;
	local_10.y = y;
	if (objType == OBJECT_BUILDING) {
		if (param_8 != 0) {
			BVar3 = Level_GetBlockFlags1_8(x,y);
			if (BVar3 == 0) {
				if ((param_4 == 0) &&
					 (front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_CANNOTBUILD), param_3 != 0)) {
					snd::Audio_FUN_00428730(1);
				}
				res::ResLp_UnkSetup3DFrameTransform(pResData,1);
			}
			else {
				pPVar4 = res::Building_GetShapePoints(globals::g_Game.BuildingData_TABLE + objIndex,&x);
				iVar5 = Object_GetWaterEntrances(OBJECT_BUILDING,objIndex,0);
				res::ResLp_UnkSetup3DFrameTransform(pResData,0);
				out_y = &local_8.y;
				out_x = &local_8;
				surfMap = GetSurfaceMap();
				SurfaceMap_FUN_0044f900(surfMap,uVar11,y_00,(float *)out_x,out_y);
				fVar1 = param_5->x - local_8.x;
				fVar2 = param_5->y - local_8.y;
				if (((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) != 0) ||
					 (fVar1 <= ABS(fVar2))) {
					if ((0.0 <= fVar1) ||
						 (y = (uint)ABS(fVar1),
						 (ushort)((ushort)((float)y < ABS(fVar2)) << 8 | (ushort)((float)y == ABS(fVar2)) << 0xe
										 ) != 0)) {
						if (((ushort)((ushort)(fVar2 < 0.0) << 8 | (ushort)(fVar2 == 0.0) << 0xe) != 0) ||
							 (fVar2 <= ABS(fVar1))) {
							if ((fVar2 < 0.0) &&
								 (y = (uint)ABS(fVar2),
								 (ushort)((ushort)((float)y < ABS(fVar1)) << 8 |
												 (ushort)((float)y == ABS(fVar1)) << 0xe) == 0)) {
								globals::g_Game.placeObjDirection = DIRECTION_DOWN;
							}
						}
						else {
							globals::g_Game.placeObjDirection = DIRECTION_UP;
						}
					}
					else {
						globals::g_Game.placeObjDirection = DIRECTION_LEFT;
					}
				}
				else {
					globals::g_Game.placeObjDirection = DIRECTION_RIGHT;
				}
				uVar11 = 0;
				do {
					pPVar6 = (Point2I *)
									 res::ResLp_UnkSurfaceMap_FUN_00464480
														 (pResData,(int *)&local_10,(int)pPVar4,x,
															uVar11 + globals::g_Game.placeObjDirection & DIRECTION_LEFT,
															(globals::g_Game.level)->surfaceMap,iVar5);
					if (pPVar6 != (Point2I *)0x0) {
						if ((param_4 == 0) &&
							 (front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_CANBUILD), param_3 != 0)) {
							uVar7 = FUN_004096c0(objIndex,&local_10,
																	 uVar11 + globals::g_Game.placeObjDirection & DIRECTION_LEFT,
																	 pPVar6,x);
							pLVar8 = LiveObject_FUN_00438da0((LiveObject *)0x0,&local_10,OBJECT_ORE,0);
							iVar5 = Object_GetCostRefinedOre(OBJECT_BUILDING,objIndex,0);
							OVar9 = Object_GetStatsFlags1(OBJECT_BUILDING,objIndex);
							if ((OVar9 & STATS1_STOREOBJECTS) == STATS1_NONE) {
								FUN_00408df0((int *)&local_10,(uint *)pPVar6,x);
							}
							iVar10 = Object_GetCostCrystal(OBJECT_BUILDING,objIndex,0);
							Level_SpawnCarryableObject(&local_10,OBJECT_POWERCRYSTAL,0,0,iVar10);
							if ((pLVar8 == (LiveObject *)0x0) || (iVar5 == 0)) {
								iVar5 = Object_GetCostOre(OBJECT_BUILDING,objIndex,0);
								iVar10 = 0;
							}
							else {
								iVar10 = 1;
							}
							Level_SpawnCarryableObject(&local_10,OBJECT_ORE,iVar10,0,iVar5);
							FUN_00408c10(uVar7,(LiveObject *)0x0);
							res::ResLp_UnkSetup3DFrameTransform(pResData,1);
							FUN_0041e680();
							snd::Audio_FUN_00428730(0);
							return 0;
						}
						globals::g_Game.placeObjDirection =
								 uVar11 + globals::g_Game.placeObjDirection & DIRECTION_LEFT;
						break;
					}
					uVar11 = uVar11 + 1;
				} while (uVar11 < 5);
				if (uVar11 != 5) {
					return 1;
				}
				if ((param_4 == 0) &&
					 (front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_CANNOTBUILD), param_3 != 0)) {
					snd::Audio_FUN_00428730(1);
					front::Text_DisplayMessage(TEXT_CANNOTPLACEBUILDING,0,0);
					return 1;
				}
			}
			front::Text_DisplayMessage(TEXT_CANNOTPLACEBUILDING,0,0);
			return 1;
		}
		res::ResLp_UnkSetup3DFrameTransform(pResData,1);
	}
	return 1;
}



void __cdecl lego::main::Main_LoadObjTtSFXs(CFGProperty *root,char *keyBasePath)
{
	char *keyPath;
	CFGProperty *prop;
	BOOL BVar1;
	int iVar2;
	int (*paiVar3) [15];
	ObjectType local_8;
	int local_4;
	
	paiVar3 = globals::g_ObjTtSFX_TABLE;
	for (iVar2 = 300; iVar2 != 0; iVar2 = iVar2 + -1) {
		(*paiVar3)[0] = 0;
		paiVar3 = (int (*) [15])(*paiVar3 + 1);
	}
	iVar2 = 0x14;
	local_8 = 0x14;
	do {
		iVar2 = iVar2 + -1;
		local_4 = 0xf;
	} while (iVar2 != 0);
	keyPath = cfg::CFG_JoinPath(keyBasePath,"ObjTtSFXs",0);
	for (prop = cfg::CFG_GetChildren(root,keyPath); prop != (CFGProperty *)0x0;
			prop = cfg::CFG_NextFlat(prop)) {
		BVar1 = game::Object_GetObjectByName(prop->key,&local_8,&local_4,(Container **)0x0);
		if ((BVar1 != 0) && (BVar1 = snd::SFX_GetType(prop->value,(SFXType *)&keyBasePath), BVar1 != 0))
		{
			globals::g_ObjTtSFX_TABLE[local_8][local_4] = (int)keyBasePath;
		}
	}
	return;
}



int __cdecl lego::game::LiveObject_GetObjTtSFX(LiveObject *liveObj)
{
	int local_4;
	
	LiveObject_GetTypeIndex(liveObj,(int *)&liveObj,&local_4);
	return globals::g_ObjTtSFX_TABLE[(int)liveObj][local_4];
}



void __cdecl lego::game::LiveManager_SetFlag20(BOOL state)
{
	if (state != 0) {
		pool::globals::ReservedPool_LiveObject___g_INITFLAGS =
				 pool::globals::ReservedPool_LiveObject___g_INITFLAGS | LIVEMANAGER_UNK_20;
		return;
	}
	pool::globals::ReservedPool_LiveObject___g_INITFLAGS =
			 pool::globals::ReservedPool_LiveObject___g_INITFLAGS & ~LIVEMANAGER_UNK_20;
	return;
}



void __cdecl lego::game::LiveObject_FUN_0044b0a0(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	int crystalCount;
	uint uVar2;
	LiveObject *in_liveObj;
	
	pLVar1 = (LiveObject *)0x0;
	if (((((byte)pool::globals::ReservedPool_LiveObject___g_INITFLAGS & LIVEMANAGER_UNK_20) == 0) &&
			(liveObj->objType == OBJECT_VEHICLE)) &&
		 ((liveObj->flags4 & LIVEOBJ4_UNK_800) == LIVEOBJ4_NONE)) {
		if ((liveObj->flags4 & LIVEOBJ4_UNK_40) != LIVEOBJ4_NONE) {
			pLVar1 = liveObj->object_2fc;
		}
		in_liveObj = pLVar1;
		if (pLVar1 == (LiveObject *)0x0) {
			in_liveObj = liveObj;
		}
		uVar2 = (uint)(pLVar1 != (LiveObject *)0x0);
		crystalCount = Object_GetCostCrystal(OBJECT_VEHICLE,liveObj->objIndex,0);
		LiveObject_SpawnDropCrystals_FUN_0044b110(in_liveObj,crystalCount,uVar2);
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_800;
	}
	return;
}



void __cdecl
lego::game::LiveObject_SpawnDropCrystals_FUN_0044b110
					(LiveObject *in_liveObj,int crystalCount,BOOL param_3)
{
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar1;
	LiveObject *liveObj;
	float10 fVar2;
	float in_x;
	float in_y;
	uint *out_x;
	uint *out_y;
	float local_24;
	float local_20;
	float local_1c;
	float local_18;
	uint local_14;
	uint local_10;
	Vector3F local_c;
	
	if (crystalCount != 0) {
		do {
			if (((param_3 == 0) || (in_liveObj->objType != OBJECT_BUILDING)) ||
				 (cont = res::Building_GetEntranceNull(in_liveObj->building), cont == (Container *)0x0)) {
				LiveObject_GetPosition(in_liveObj,&local_24,&local_20);
			}
			else {
				res::Container_GetPosition(cont,(Container *)0x0,&local_c);
				local_24 = local_c.x;
				local_20 = local_c.y;
			}
			fVar2 = math::Maths_RandRange(-5.0,5.0);
			local_1c = (float)fVar2;
			fVar2 = math::Maths_RandRange(-5.0,5.0);
			local_18 = (float)fVar2;
			in_y = local_18 + local_20;
			out_y = &local_10;
			out_x = &local_14;
			in_x = local_1c + local_24;
			surfMap = GetSurfaceMap();
			BVar1 = SurfaceMap_ToBlockCoordinatesNoZ(surfMap,in_x,in_y,(int *)out_x,(int *)out_y);
			if ((BVar1 != 0) && (BVar1 = Level_GetBlockFlags1_8(local_14,local_10), BVar1 != 0)) {
				local_24 = local_1c + local_24;
				local_20 = local_18 + local_20;
			}
			liveObj = Game_CreateLiveResourceObject
													(globals::g_Game.RES_Crystal,OBJECT_POWERCRYSTAL,0,0,local_24,local_20,0.0
													);
			ai::AITask_DoCollect(liveObj,0.0);
			crystalCount = crystalCount + -1;
		} while (crystalCount != 0);
	}
	return;
}



void __cdecl lego::game::LiveObject_CallsSpawnDropCrystals_FUN_0044b250(LiveObject *liveObj)
{
	if (liveObj->tableptr_348 != (int *)0x0) {
		LiveObject_SpawnDropCrystals_FUN_0044b110(liveObj,*liveObj->tableptr_348,0);
	}
	return;
}



void __cdecl lego::game::LiveObject_GenerateTinyRMs_FUN_0044b270(LiveObject *in_liveObj)
{
	short sVar1;
	BOOL BVar2;
	LiveObject *liveObj;
	int iVar3;
	bool bVar4;
	char *objName;
	uint uVar5;
	int out_objIndex;
	ObjectType out_objType;
	Container *local_c;
	float local_8;
	float local_4;
	
	bVar4 = false;
	BVar2 = Object_GetObjectByName("RockMonster",&out_objType,&out_objIndex,(Container **)0x0);
	objName = (char *)in_liveObj;
	if (((BVar2 != 0) && (out_objType == in_liveObj->objType)) &&
		 (out_objIndex == in_liveObj->objIndex)) {
		objName = "TinyRM";
		bVar4 = true;
	}
	if (!bVar4) {
		BVar2 = Object_GetObjectByName("Lavamonster",&out_objType,&out_objIndex,(Container **)0x0);
		if (((BVar2 != 0) && (out_objType == in_liveObj->objType)) &&
			 (out_objIndex == in_liveObj->objIndex)) {
			objName = "TinyRM";
			bVar4 = true;
		}
		if (((!bVar4) &&
				(BVar2 = Object_GetObjectByName("Icemonster",&out_objType,&out_objIndex,(Container **)0x0),
				BVar2 != 0)) &&
			 ((out_objType == in_liveObj->objType && (out_objIndex == in_liveObj->objIndex)))) {
			objName = "TinyIM";
		}
	}
	BVar2 = Object_GetObjectByName(objName,&out_objType,&out_objIndex,&local_c);
	if (BVar2 != 0) {
		LiveObject_GetPosition(in_liveObj,&local_8,&local_4);
		uVar5 = 0;
		while( true ) {
			sVar1 = math::Maths_Rand();
			liveObj = Game_CreateLiveResourceObject
													(local_c,out_objType,out_objIndex,0,local_8,local_4,
													 (float)((int)sVar1 % 7));
			liveObj->health = -1.0;
			iVar3 = LiveObject_FUN_004499c0(liveObj);
			if (iVar3 == 0) break;
			uVar5 = uVar5 + 1;
			in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_20;
			if (2 < uVar5) {
				return;
			}
		}
		pool::ReservedPool_LiveObject___Release(liveObj);
	}
	return;
}



void __cdecl lego::game::Level_GenerateSmallSpiders(uint x,uint y,uint randSeed)
{
	short sVar1;
	BOOL BVar2;
	SurfaceMap *surfMap;
	LiveObject *pLVar3;
	int iVar4;
	float10 fVar5;
	Point2F *pPVar6;
	int objIndex;
	ObjectType objType;
	Container *objRes;
	Point2F genPos;
	Point2F local_30;
	Point2F local_18;
	
	BVar2 = Object_GetObjectByName("SmallSpider",&objType,&objIndex,&objRes);
	if (BVar2 != 0) {
		pPVar6 = &local_30;
		surfMap = GetSurfaceMap();
		SurfaceMap_FillStruct30_FUN_00450390(surfMap,x,y,(undefined4 *)pPVar6);
		for (iVar4 = (randSeed & 3) + 2; iVar4 != 0; iVar4 = iVar4 + -1) {
			sVar1 = math::Maths_Rand();
			fVar5 = math::Maths_RandRange(local_30.x - -1.0,local_18.x - 1.0);
			genPos.x = (float)fVar5;
			fVar5 = math::Maths_RandRange(local_30.y - 1.0,local_18.y - -1.0);
			genPos.y = (float)fVar5;
			pLVar3 = Game_CreateLiveResourceObject
												 (objRes,objType,objIndex,0,genPos.x,genPos.y,(float)((int)sVar1 % 7));
			pLVar3->flags1 = pLVar3->flags1 | LIVEOBJ1_UNK_10000;
		}
	}
	return;
}



void __cdecl lego::ai::AI_LiveObject_DoThrowLegoman(LiveObject *liveObj1,LiveObject *liveObj2)
{
	BOOL BVar1;
	float10 fVar2;
	
	BVar1 = game::LiveObject_CheckCondition_FUN_00438870(liveObj2,1);
	if ((((BVar1 != 0) && ((liveObj2->flags2 & LIVEOBJ2_UNK_100) == LIVEOBJ2_NONE)) &&
			((*(byte *)&liveObj1->flags2 & 1) == 0)) &&
		 ((liveObj2->flags2 & LIVEOBJ2_UNK_2) == LIVEOBJ2_NONE)) {
		BVar1 = game::LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj1);
		if (BVar1 == 0) {
			fVar2 = game::LiveObject_GetPainThreshold(liveObj1);
			if (fVar2 < (float10)liveObj1->health) {
				game::LiveObject_FUN_0041cf40(liveObj2);
				game::LiveObject_FUN_00441df0(liveObj2,0,1);
				game::LiveObject_FUN_00441df0(liveObj1,0,1);
				game::LiveObject_SetActivityUnk(liveObj1,ACTIVITY_THROWMAN,1);
				game::Game_UpdateSomeAITasks(liveObj1);
				game::LiveObject_SetActivityUnk(liveObj2,ACTIVITY_THROWNBYROCKMONSTER,1);
				game::Game_UpdateSomeAITasks(liveObj2);
				AITask_DoAnimationWait(liveObj1);
				AITask_DoAnimationWait(liveObj2);
				liveObj1->flags2 = liveObj1->flags2 | LIVEOBJ2_UNK_1;
				liveObj2->flags2 = liveObj2->flags2 | LIVEOBJ2_UNK_2;
				liveObj1->object_3c0 = liveObj2;
				liveObj2->object_3c0 = liveObj1;
			}
		}
	}
	return;
}



BOOL __cdecl lego::tools::Tool_IsBeamWeapon(ToolType toolType)
{
	if (((toolType != TOOL_LASER) && (toolType != TOOL_PUSHERGUN)) && (toolType != TOOL_FREEZERGUN)) {
		return 0;
	}
	return 1;
}



void __cdecl lego::game::MiniFigure_EquipTool(LiveObject *liveObj,ToolType toolType)
{
	uint uVar1;
	uint uVar2;
	BOOL BVar3;
	ToolType *pTVar4;
	uint uVar5;
	
	uVar1 = LiveObject_GetNumOfToolsCanCarry(liveObj);
	uVar5 = 0;
	liveObj->field_3f4 = 0;
	if (uVar1 != 0) {
		liveObj->flags4 = liveObj->flags4 & 0xfffffffb;
		uVar2 = LiveObject_GetEquippedBeam(liveObj);
		if ((uVar2 != 0) || (BVar3 = tools::Tool_IsBeamWeapon(toolType), BVar3 != 0)) {
			liveObj->flags4 = liveObj->flags4 | 4;
		}
		BVar3 = tools::Tool_IsBeamWeapon(toolType);
		if ((BVar3 != 0) && (liveObj->numCarriedTools != 0)) {
			pTVar4 = liveObj->carriedTools;
			do {
				BVar3 = tools::Tool_IsBeamWeapon(*pTVar4);
				if (BVar3 != 0) {
					liveObj->carriedTools[uVar5] = toolType;
					return;
				}
				uVar5 = uVar5 + 1;
				pTVar4 = pTVar4 + 1;
			} while (uVar5 < liveObj->numCarriedTools);
		}
		if (uVar1 != 0) {
			uVar5 = liveObj->numCarriedTools;
			if (uVar5 == uVar1) {
				uVar1 = 0;
				if (uVar5 != 1) {
					pTVar4 = liveObj->carriedTools;
					do {
						uVar1 = uVar1 + 1;
						*pTVar4 = pTVar4[1];
						pTVar4 = pTVar4 + 1;
					} while (uVar1 < liveObj->numCarriedTools - 1);
				}
				liveObj->carriedTools[liveObj->numCarriedTools - 1] = toolType;
				return;
			}
			liveObj->carriedTools[uVar5] = toolType;
			liveObj->numCarriedTools = liveObj->numCarriedTools + 1;
		}
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_HasToolEquipped(LiveObject *liveObj,ToolType toolType)
{
	uint uVar1;
	ToolType *pTVar2;
	
	uVar1 = 0;
	if (liveObj->numCarriedTools == 0) {
		return 0;
	}
	pTVar2 = liveObj->carriedTools;
	do {
		if (*pTVar2 == toolType) {
			return 1;
		}
		uVar1 = uVar1 + 1;
		pTVar2 = pTVar2 + 1;
	} while (uVar1 < liveObj->numCarriedTools);
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_TaskHasTool_FUN_0044b780(LiveObject *in_liveObj,AITaskType taskType)
{
	LiveObject *liveObj;
	BOOL BVar1;
	
	liveObj = in_liveObj;
	if (in_liveObj->objType == OBJECT_MINIFIGURE) {
		BVar1 = ai::AI_GetToolFromTaskType(taskType,(ToolType *)&in_liveObj);
		if (BVar1 != 0) {
			BVar1 = LiveObject_HasToolEquipped(liveObj,(ToolType)in_liveObj);
			return BVar1;
		}
	}
	return 1;
}



int __cdecl lego::game::LiveObject_DoGetTool(LiveObject *liveObj,ToolType toolType)
{
	LiveObject *pLVar1;
	Container *cont;
	SurfaceMap *pSVar2;
	BOOL BVar3;
	int iVar4;
	float *pfVar5;
	float *pfVar6;
	uint local_34;
	BOOL local_30;
	float local_2c;
	float local_28;
	Point2F local_24;
	float local_1c;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	LiveObject *liveObj_00;
	
	liveObj_00 = liveObj;
	local_30 = 0;
	iVar4 = 0;
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		LiveObject_GetPosition(liveObj,(float *)&local_24,&local_24.y);
		pLVar1 = Level_GetBuildingAtPosition(&local_24);
		if (pLVar1 != (LiveObject *)0x0) {
			cont = res::Building_GetToolNull(pLVar1->building,(&DAT_004dfe18)[toolType]);
			res::Container_GetPosition(cont,(Container *)0x0,&local_c);
			local_14 = local_c.x;
			pfVar6 = &local_28;
			pfVar5 = &local_2c;
			local_10 = local_c.y;
			pSVar2 = GetSurfaceMap();
			SurfaceMap_ToBlockCoordinatesNoZ(pSVar2,local_c.x,local_c.y,(int *)pfVar5,(int *)pfVar6);
			pfVar6 = &local_18;
			pfVar5 = &local_1c;
			pSVar2 = GetSurfaceMap();
			SurfaceMap_ToBlockCoordinatesNoZ(pSVar2,local_24.x,local_24.y,(int *)pfVar5,(int *)pfVar6);
			if ((local_1c == local_2c) && (local_18 == local_28)) {
				local_30 = LiveObject_FUN_004419c0(liveObj_00,1,&local_2c,&local_28,&local_14);
			}
			else {
				BVar3 = LiveObject_FUN_004413b0
													(liveObj_00,local_1c,local_18,local_2c,local_28,&liveObj,&toolType,
													 &local_34,0,0);
				if (BVar3 != 0) {
					BVar3 = LiveObject_FUN_004419c0
														(liveObj_00,local_34,(float *)liveObj,(float *)toolType,&local_14);
					std::free(liveObj);
					std::free((void *)toolType);
					local_30 = BVar3;
				}
			}
			iVar4 = local_30;
			if (local_30 != 0) {
				liveObj_00->object_2fc = pLVar1;
				*(undefined *)((int)liveObj_00->routeptr_24 + liveObj_00->routingBlocksTotal * 0x14 + -3) =
						 0xd;
			}
		}
	}
	return iVar4;
}



void __cdecl lego::game::LiveObject_FlocksInit(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	LiveObject *pLVar1;
	Container *opt_parent;
	Container *in_child;
	Container *pCVar2;
	FlockData *pFVar3;
	FlockSubdata *flockSubdata;
	float10 fVar4;
	float speed;
	float fVar5;
	float fVar6;
	LiveObject *resData;
	Vector3F vector2;
	Vector3F vector1;
	
	liveObj = in_liveObj;
	vector1.x = 0.0;
	vector1.y = 0.0;
	vector1.z = 0.0;
	vector2.x = 0.0;
	vector2.y = 0.0;
	vector2.z = 0.0;
	pLVar1 = (LiveObject *)LiveObject_GetFlocks_Size(in_liveObj);
	opt_parent = LiveObject_GetResource(in_liveObj);
	in_child = res::Container_Create(opt_parent);
	pCVar2 = res::GetRoot();
	res::Container_SetParent(in_child,pCVar2);
	fVar6 = 0.0;
	resData = in_liveObj;
	fVar4 = LiveObject_GetFlocks_Speed(in_liveObj);
	fVar5 = (float)fVar4;
	fVar4 = LiveObject_GetFlocks_Turn(in_liveObj);
	pFVar3 = LiveObject_FlocksAllocData
										 ((Vector3F *)0x0,(Vector3F *)0x0,(float)fVar4,fVar5,fVar6,(Container *)resData)
	;
	in_liveObj->flocksData_32c = pFVar3;
	pFVar3->flocksSubdata1->resData_98 = in_child;
	in_liveObj = pLVar1;
	if (0 < (int)pLVar1) {
		do {
			pCVar2 = res::Container_Clone(opt_parent);
			res::Container_SetParent(pCVar2,in_child);
			fVar4 = LiveObject_GetFlocks_GoalUpdate(liveObj);
			fVar5 = (float)fVar4;
			fVar4 = LiveObject_GetFlocks_Tightness(liveObj);
			fVar6 = (float)fVar4;
			fVar4 = LiveObject_GetFlocks_Speed(liveObj);
			speed = (float)fVar4;
			fVar4 = LiveObject_GetFlocks_Turn(liveObj);
			flockSubdata = LiveObject_FlocksAllocSubdata
															 (&vector1,&vector2,(float)fVar4,speed,fVar6,fVar5,pCVar2);
			LiveObject_FlocksAddSubdata(liveObj->flocksData_32c,flockSubdata);
			in_liveObj = (LiveObject *)((int)&in_liveObj[-1].pool_m_next + 3);
		} while (in_liveObj != (LiveObject *)0x0);
	}
	return;
}



void __cdecl
lego::math::FlocksMatrix_FUN_0044ba60(Container *resData,Matrix4F *ref_matrix,float scalar)
{
	float fVar1;
	float fVar2;
	float fVar3;
	Vector3F vector;
	Matrix4F matrix_b;
	Matrix4F matrix_a;
	
	fVar1 = ref_matrix->values[3][1];
	fVar2 = ref_matrix->values[3][0];
	fVar3 = ref_matrix->values[3][2];
	ref_matrix->values[3][0] = 0.0;
	ref_matrix->values[3][1] = 0.0;
	ref_matrix->values[3][2] = 0.0;
										// M_PI / 2 (1.570796)
	Matrix_RotX(&matrix_b,1.570796);
	Matrix_Mult(&matrix_a,&matrix_b,ref_matrix);
	Matrix_Copy(ref_matrix,&matrix_a);
	ref_matrix->values[3][0] = fVar2;
	ref_matrix->values[3][1] = fVar3;
	ref_matrix->values[3][2] = -fVar1 - scalar;
	res::Container_AddTransform(resData,D3DRMCOMBINE_REPLACE,ref_matrix);
	return;
}



void __cdecl FUN_0044bb10(undefined4 param_1,int param_2,float *param_3)
{
	Container *cont;
	float y;
	float x;
	SurfaceMap *pSVar1;
	float10 fVar2;
	float fVar3;
	float fVar4;
	Vector3F *out_vector;
	Vector3F local_30;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	cont = *(Container **)(param_2 + 0x98);
	if (param_3[3] == 0.0) {
		lego::math::FlocksMatrix_FUN_0044ba60(cont,(Matrix4F *)(param_2 + 0x58),param_3[1]);
		if (param_3[2] != 0.0) {
			lego::res::Container_GetOrientation(cont,(Container *)0x0,&local_24,&local_30);
			local_30.x = local_30.x * 0.5;
			local_30.y = local_30.y * 0.5;
			local_30.z = (local_30.z - 1.0) * 0.5;
			lego::res::Container_SetOrientation
								(cont,(Container *)0x0,local_24.x,local_24.y,local_24.z,local_30.x,local_30.y,
								 local_30.z);
		}
	}
	else {
		y = *(float *)(param_2 + 0x90);
		x = *(float *)(param_2 + 0x88);
		local_c.x = 0.0;
		local_c.y = 1.0;
		local_c.z = 0.0;
		local_18.x = 0.0;
		local_18.y = 0.0;
		local_18.z = -1.0;
		fVar3 = x;
		fVar4 = y;
		pSVar1 = lego::game::GetSurfaceMap();
		fVar2 = lego::game::SurfaceMap_GetSurfaceZ(pSVar1,fVar3,fVar4);
		out_vector = &local_30;
		fVar3 = x;
		fVar4 = y;
		pSVar1 = lego::game::GetSurfaceMap();
		lego::game::SurfaceMap_FUN_0044fd70(pSVar1,fVar3,fVar4,out_vector);
		lego::math::Maths_Vector3DRotate(&local_24,&local_c,&local_18,-*(float *)(param_2 + 0x24));
		lego::res::Container_SetOrientation
							(cont,(Container *)0x0,local_30.x,local_30.y,local_30.z,local_24.x,local_24.y,
							 local_24.z);
		lego::res::Container_GetOrientation(cont,(Container *)0x0,&local_30,&local_24);
		lego::res::Container_SetOrientation
							(cont,(Container *)0x0,local_24.x,local_24.y,local_24.z,local_30.x,local_30.y,
							 local_30.z);
		lego::res::Container_SetPosition(cont,(Container *)0x0,x,y,(float)fVar2);
	}
	if (param_3[4] == 0.0) {
		lego::res::Container_MoveAnimation(cont,*param_3);
	}
	else {
		if (0.0 <= *(float *)(param_2 + 0x28)) {
			lego::res::Container_MoveAnimation(cont,*param_3);
			return;
		}
		fVar2 = lego::res::Container_GetAnimationTime(cont);
		if (fVar2 != (float10)0.0) {
			fVar2 = lego::res::Container_MoveAnimation(cont,*param_3);
			if ((ushort)((ushort)(fVar2 < (float10)0.0) << 8 | (ushort)(fVar2 == (float10)0.0) << 0xe) ==
					0) {
				lego::res::Container_SetAnimationTime(cont,0.0);
				return;
			}
		}
	}
	return;
}



void __cdecl
lego::game::Flocks_ReleaseResourceCallback
					(FlockData *flockData,FlockSubdata *subdata,void *lpContext)
{
	Container *in_child;
	
	in_child = subdata->resData_98;
	if (in_child != (Container *)0x0) {
		res::Container_SetParent(in_child,(Container *)0x0);
		res::Container_Remove(in_child);
	}
	return;
}



void __cdecl lego::game::Flocks_ReleaseData(FlockData *flockData)
{
	Container *in_child;
	
	if (flockData != (FlockData *)0x0) {
		Flocks_CallbackForAllSubdata(flockData,Flocks_ReleaseResourceCallback,(void *)0x0);
		in_child = flockData->flocksSubdata1->resData_98;
		res::Container_SetParent(in_child,(Container *)0x0);
		res::Container_Remove(in_child);
		flockData->flocksSubdata1->resData_98 = (Container *)0x0;
		unk::Lego_UnkRecurseFree__0040f780((undefined4 *)flockData);
	}
	return;
}



void __cdecl FUN_0044bdf0(LiveObject *liveObj,BOOL param_2)
{
	FlockData *flockData;
	float10 fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	
	flockData = liveObj->flocksData_32c;
	if (param_2 != 0) {
		fVar1 = lego::game::LiveObject_GetFlocks_Tightness(liveObj);
		fVar4 = (float)(fVar1 + fVar1);
		fVar1 = lego::game::LiveObject_GetFlocks_Speed(liveObj);
		fVar3 = (float)(fVar1 + fVar1);
		fVar1 = lego::game::LiveObject_GetFlocks_Turn(liveObj);
		lego::game::Flocks_SetParameters1(flockData,(float)(fVar1 + fVar1),fVar3,fVar4);
		fVar1 = lego::game::LiveObject_GetFlocks_GoalUpdate(liveObj);
		fVar4 = (float)(fVar1 + fVar1);
		fVar1 = lego::game::LiveObject_GetFlocks_Tightness(liveObj);
		fVar3 = (float)(fVar1 + fVar1);
		fVar1 = lego::game::LiveObject_GetFlocks_Speed(liveObj);
		fVar2 = (float)(fVar1 * (float10)3.0);
		fVar1 = lego::game::LiveObject_GetFlocks_Turn(liveObj);
		FUN_0040ff10(flockData,(float)(fVar1 * (float10)4.0),fVar2,fVar3,fVar4);
		return;
	}
	fVar1 = lego::game::LiveObject_GetFlocks_Tightness(liveObj);
	fVar4 = (float)fVar1;
	fVar1 = lego::game::LiveObject_GetFlocks_Speed(liveObj);
	fVar3 = (float)fVar1;
	fVar1 = lego::game::LiveObject_GetFlocks_Turn(liveObj);
	lego::game::Flocks_SetParameters1(flockData,(float)fVar1,fVar3,fVar4);
	fVar1 = lego::game::LiveObject_GetFlocks_GoalUpdate(liveObj);
	fVar4 = (float)fVar1;
	fVar1 = lego::game::LiveObject_GetFlocks_Tightness(liveObj);
	fVar3 = (float)fVar1;
	fVar1 = lego::game::LiveObject_GetFlocks_Speed(liveObj);
	fVar2 = (float)fVar1;
	fVar1 = lego::game::LiveObject_GetFlocks_Turn(liveObj);
	FUN_0040ff10(flockData,(float)fVar1,fVar2,fVar3,fVar4);
	return;
}



void __cdecl FUN_0044bef0(LiveObject *liveObj,float param_2)
{
	uint *puVar1;
	FlockData *pFVar2;
	ObjectStatsFlags1 OVar3;
	Container *pCVar4;
	BOOL BVar5;
	float10 fVar6;
	Container *opt_ref;
	Vector3F *out_pos;
	float local_2c;
	float local_28;
	float local_24;
	Vector3F local_20;
	float local_14;
	float local_10;
	uint local_c;
	uint local_8;
	uint local_4;
	
	OVar3 = lego::game::LiveObject_GetStatsFlags1(liveObj);
	if ((OVar3 & STATS1_FLOCKS) != STATS1_NONE) {
		OVar3 = lego::game::LiveObject_GetStatsFlags1(liveObj);
		if ((OVar3 & STATS1_FLOCKS_DEBUG) == STATS1_NONE) {
			pCVar4 = lego::game::LiveObject_GetResource(liveObj);
			BVar5 = lego::res::Container_IsHidden(pCVar4);
			if (BVar5 == 0) {
				lego::game::LiveObject_FUN_0044a210(liveObj,1);
			}
		}
		pFVar2 = liveObj->flocksData_32c;
		if ((*(byte *)&pFVar2->field_24 & 1) != 0) {
			pFVar2->field_14 = param_2 + (float)pFVar2->field_14;
		}
		fVar6 = lego::game::LiveObject_GetFlocks_AttackTime(liveObj);
		if (((ushort)((ushort)(fVar6 < (float10)param_2) << 8 |
								 (ushort)(fVar6 == (float10)param_2) << 0xe) != 0) &&
			 ((*(byte *)&liveObj->flags2 & 0x80) == 0)) {
			lego::game::LiveObject_SetAITaskUnk(liveObj,AITASK_FOLLOW,(LiveObject *)0x0,1);
			puVar1 = &liveObj->flocksData_32c->field_24;
			*puVar1 = *puVar1 & 0xfffffffe;
		}
		out_pos = &local_20;
		opt_ref = (Container *)0x0;
		pCVar4 = lego::game::LiveObject_GetResource(liveObj);
		lego::res::Container_GetPosition(pCVar4,opt_ref,out_pos);
		local_28 = -local_20.z;
		local_2c = local_20.x;
		local_24 = local_20.y;
		BVar5 = lego::res::AnimClone_IsLws((AnimClone *)liveObj->flocksData_32c);
		if (BVar5 == 0) {
			lego::game::Flocks_FUN_0040ff50(liveObj->flocksData_32c,&local_2c);
			FUN_0040ffa0((int)liveObj->flocksData_32c,&local_2c);
			lego::game::Flocks_FUN_0040ffe0(liveObj->flocksData_32c,&local_2c);
		}
		if ((*(byte *)&liveObj->flags2 & 0x80) == 0) {
			FUN_0044bdf0(liveObj,0);
		}
		else {
			FUN_0044bdf0(liveObj,1);
			liveObj->flags2 = liveObj->flags2 & 0xffffff7f;
		}
		FUN_0040fce0((int *)liveObj->flocksData_32c,&local_2c);
		fVar6 = lego::game::LiveObject_GetFlocks_Randomness(liveObj);
		FUN_0040fe80((int)liveObj->flocksData_32c,(float)fVar6);
		lego::game::Flocks_FUN_0040fd30(liveObj->flocksData_32c,param_2);
		local_14 = param_2;
		fVar6 = lego::game::LiveObject_GetFlocks_Height(liveObj);
		local_10 = (float)fVar6;
		OVar3 = lego::game::LiveObject_GetStatsFlags1(liveObj);
		local_c = OVar3 >> 0x17 & 1;
		OVar3 = lego::game::LiveObject_GetStatsFlags1(liveObj);
		local_8 = OVar3 >> 0x1a & 1;
		OVar3 = lego::game::LiveObject_GetStatsFlags1(liveObj);
		local_4 = OVar3 >> 0x1c & 1;
		lego::game::Flocks_CallbackForAllSubdata(liveObj->flocksData_32c,FUN_0044bb10,&local_14);
	}
	return;
}



void __cdecl lego::game::LiveObject_FlocksDestroy(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	FlockData **ppFVar2;
	FlockData *pFVar3;
	float10 fVar4;
	float local_c;
	float local_8;
	float local_4;
	
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_FLOCKS_QUICKDESTROY) != STATS1_NONE) {
		Flocks_ReleaseData(liveObj->flocksData_32c);
		return;
	}
	ppFVar2 = (FlockData **)std::malloc(0x10);
	if (ppFVar2 == (FlockData **)0x0) {
		Flocks_ReleaseData(liveObj->flocksData_32c);
		return;
	}
	pFVar3 = liveObj->flocksData_32c;
	local_c = (pFVar3->flocksSubdata1->vector_0).x;
	local_8 = (pFVar3->flocksSubdata1->vector_0).y;
	local_4 = (pFVar3->flocksSubdata1->vector_0).z;
	*ppFVar2 = pFVar3;
	pFVar3 = (FlockData *)LiveObject_GetStatsFlags1(liveObj);
	ppFVar2[2] = pFVar3;
	ppFVar2[1] = DAT_004ebdd0;
	fVar4 = LiveObject_GetFlocks_Height(liveObj);
	ppFVar2[3] = (FlockData *)(float)fVar4;
	DAT_004ebdd0 = (FlockData *)ppFVar2;
	Flocks_FUN_0040ff50(liveObj->flocksData_32c,&local_c);
	Flocks_FUN_0040ffe0(liveObj->flocksData_32c,&local_c);
	return;
}



// WARNING: Type propagation algorithm not settling

void __cdecl FUN_0044c1c0(undefined4 *param_1)
{
	FlockSubdata *pFVar1;
	int iVar2;
	FlockSubdata *pFVar3;
	FlockSubdata *buffer;
	FlockSubdata *pFVar4;
	undefined4 local_14;
	uint local_10;
	uint local_c;
	uint local_8;
	uint local_4;
	
	pFVar3 = (FlockSubdata *)0x0;
	buffer = DAT_004ebdd0;
	if (DAT_004ebdd0 != (FlockSubdata *)0x0) {
		do {
			lego::game::Flocks_CallbackForAllSubdata
								(*(FlockData **)&buffer->vector_0,FUN_00410000,param_1);
			local_14 = *param_1;
			local_10 = (uint)(buffer->vector_c).x;
			local_c = (uint)*(float *)((int)&buffer->vector_0 + 8) >> 0x17 & 1;
			local_8 = (uint)*(float *)((int)&buffer->vector_0 + 8) >> 0x1a & 1;
			local_4 = (uint)*(float *)((int)&buffer->vector_0 + 8) >> 0x1c & 1;
			lego::game::Flocks_CallbackForAllSubdata
								(*(FlockData **)&buffer->vector_0,FUN_0044bb10,&local_14);
			iVar2 = FUN_004101b0(*(int *)&buffer->vector_0);
			if (iVar2 == 0) {
				pFVar4 = *(FlockSubdata **)((int)&buffer->vector_0 + 4);
			}
			else {
				pFVar4 = *(FlockSubdata **)((int)&buffer->vector_0 + 4);
				pFVar1 = pFVar4;
				if (pFVar3 != (FlockSubdata *)0x0) {
					*(FlockSubdata **)((int)&pFVar3->vector_0 + 4) = pFVar4;
					pFVar1 = DAT_004ebdd0;
				}
				DAT_004ebdd0 = pFVar1;
				lego::game::Flocks_ReleaseData(*(FlockData **)&buffer->vector_0);
				std::free(buffer);
				buffer = pFVar3;
			}
			pFVar3 = buffer;
			buffer = pFVar4;
		} while (pFVar4 != (FlockSubdata *)0x0);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_DestroyRockMonster_FUN_0044c290(LiveObject *liveObj)
{
	if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 | (ushort)(liveObj->float_2d4 == 0.0) << 0xe)
			== 0) {
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_100000;
		LiveObject_GenerateTinyRMs_FUN_0044b270(liveObj);
		LiveObject_CallsSpawnDropCrystals_FUN_0044b250(liveObj);
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
		nerps::NERPs_IncRockMonstersDestroyed();
		return 1;
	}
	return 0;
}



undefined4 __cdecl FUN_0044c2f0(int *param_1,float param_2)
{
	LiveObject *pLVar1;
	float10 fVar2;
	float local_c;
	float local_8 [2];
	
	if (((param_1[0xf9] & 0x8000000U) == 0) && (*param_1 == 3)) {
		param_1[0xf9] = param_1[0xf9] | 0x8000000;
		param_1[0xda] = (int)(param_2 * 25.0);
		lego::game::LiveObject_GetPosition((LiveObject *)param_1,&local_c,local_8);
		fVar2 = lego::game::LiveObject_UnkRadians_FUN_00442740((LiveObject *)param_1);
		pLVar1 = lego::game::Game_CreateLiveResourceObject
											 (lego::globals::g_Game.RES_IceCube,OBJECT_ICECUBE,0,0,local_c,local_8[0],
												(float)fVar2);
		lego::res::Container_SetActivity(pLVar1->other,"Start");
		lego::res::Container_SetAnimationTime(pLVar1->other,0.0);
		pLVar1->flags1 = pLVar1->flags1 | LIVEOBJ1_UNK_100;
		param_1[0xd9] = (int)pLVar1;
		pLVar1->object_364 = (LiveObject *)param_1;
		return 1;
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_0044c3d0(LiveObject *liveObj)
{
	LiveFlags3 *pLVar1;
	
	if ((liveObj->object_364->flags1 & LIVEOBJ1_UNK_200000) == LIVEOBJ1_NONE) {
										// 100.0
		liveObj->object_364->health = (float)&DAT_42c80000;
		pLVar1 = &liveObj->object_364->flags3;
		*pLVar1 = *pLVar1 | LIVEOBJ3_UNK_800000;
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_Unk_AndSetVector3B4(LiveObject *liveObj,Point2F *param_2,float param_3)
{
	ObjectType OVar1;
	
	OVar1 = liveObj->objType;
	if (((OVar1 != OBJECT_MINIFIGURE) && (OVar1 != OBJECT_ROCKMONSTER)) && (OVar1 != OBJECT_VEHICLE))
	{
		return 0;
	}
	LiveObject_FUN_00441df0(liveObj,0,1);
	(liveObj->vector_3b4).x = param_2->x;
	(liveObj->vector_3b4).y = param_2->y;
	(liveObj->vector_3b4).z = param_3;
	liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_4000;
	return 1;
}



void __cdecl lego::game::LiveObject_FUN_0044c470(LiveObject *liveObj,float param_2)
{
	float fVar1;
	SurfaceMap *pSVar2;
	int iVar3;
	float fVar4;
	float fVar5;
	int *piVar6;
	int *piVar7;
	float local_18;
	float local_14;
	float local_10;
	float local_c;
	int local_8;
	int local_4;
	
	LiveObject_GetPosition(liveObj,&local_18,&local_14);
	local_10 = (liveObj->vector_3b4).x * param_2;
	piVar7 = &local_4;
	piVar6 = &local_8;
	local_c = (liveObj->vector_3b4).y * param_2;
	fVar4 = local_10 + local_18;
	fVar5 = local_c + local_14;
	local_18 = fVar4;
	local_14 = fVar5;
	pSVar2 = GetSurfaceMap();
	SurfaceMap_ToBlockCoordinatesNoZ(pSVar2,fVar4,fVar5,piVar6,piVar7);
	iVar3 = LiveObject_FUN_00431cd0(liveObj,local_8,local_4,local_8,local_4,1);
	if (iVar3 == 0) {
LAB_0044c517:
		fVar5 = (liveObj->vector_3b4).x;
		fVar1 = (liveObj->vector_3b4).y;
		fVar4 = (liveObj->vector_3b4).y;
		fVar4 = 1.0 / SQRT(fVar5 * fVar5 + fVar4 * fVar4);
		fVar5 = SQRT(fVar5 * fVar5 + fVar1 * fVar1);
		(liveObj->vector_3b4).x = (liveObj->vector_3b4).x * fVar4;
		(liveObj->vector_3b4).y = fVar4 * (liveObj->vector_3b4).y;
		fVar4 = (liveObj->vector_3b4).x;
		if ((ushort)((ushort)(fVar4 < 0.5) << 8 | (ushort)(fVar4 == 0.5) << 0xe) == 0) {
			(liveObj->vector_3b4).x = 1.0;
			(liveObj->vector_3b4).y = 0.0;
		}
		else {
			if (-0.5 <= (liveObj->vector_3b4).x) {
				fVar4 = (liveObj->vector_3b4).y;
				if ((ushort)((ushort)(fVar4 < 0.5) << 8 | (ushort)(fVar4 == 0.5) << 0xe) == 0) {
					(liveObj->vector_3b4).x = 0.0;
					(liveObj->vector_3b4).y = 1.0;
				}
				else {
					if ((liveObj->vector_3b4).y < -0.5) {
						(liveObj->vector_3b4).x = 0.0;
						(liveObj->vector_3b4).y = -1.0;
					}
				}
			}
			else {
				(liveObj->vector_3b4).x = -1.0;
				(liveObj->vector_3b4).y = 0.0;
			}
		}
		(liveObj->vector_3b4).x = (liveObj->vector_3b4).x * fVar5;
		(liveObj->vector_3b4).y = (liveObj->vector_3b4).y * fVar5;
		LiveObject_GetPosition(liveObj,&local_18,&local_14);
		local_10 = (liveObj->vector_3b4).x * param_2;
		piVar7 = &local_4;
		piVar6 = &local_8;
		local_c = (liveObj->vector_3b4).y * param_2;
		fVar4 = local_10 + local_18;
		fVar5 = local_c + local_14;
		local_18 = fVar4;
		local_14 = fVar5;
		pSVar2 = GetSurfaceMap();
		SurfaceMap_ToBlockCoordinatesNoZ(pSVar2,fVar4,fVar5,piVar6,piVar7);
		iVar3 = LiveObject_FUN_00431cd0(liveObj,local_8,local_4,local_8,local_4,1);
		if (iVar3 != 0) {
			iVar3 = LiveObject_FUN_00446030(liveObj,&local_18,0,0);
			if (iVar3 == 0) goto LAB_0044c6eb;
		}
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_4000;
	}
	else {
		iVar3 = LiveObject_FUN_00446030(liveObj,&local_18,0,0);
		if (iVar3 != 0) goto LAB_0044c517;
LAB_0044c6eb:
		LiveObject_UnkUpdatePositioning(liveObj,local_18,local_14,0,0);
	}
	fVar4 = (liveObj->vector_3b4).z;
	if ((ushort)((ushort)(fVar4 < 0.0) << 8 | (ushort)(fVar4 == 0.0) << 0xe) != 0) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_4000;
	}
	(liveObj->vector_3b4).z = (liveObj->vector_3b4).z - SQRT(local_c * local_c + local_10 * local_10);
	return;
}



void __cdecl lego::game::LiveObject_FUN_0044c760(LiveObject *liveObj)
{
	ObjectStatsFlags2 OVar1;
	ObjectStatsFlags1 OVar2;
	
	if ((*(byte *)&liveObj->flags4 & 2) != 0) {
		OVar1 = LiveObject_GetStatsFlags2(liveObj);
		if ((OVar1 & STATS2_CANDOUBLESELECT) != STATS2_NONE) {
			OVar2 = LiveObject_GetStatsFlags1(liveObj);
			if (((OVar2 & STATS1_CANBEDRIVEN) == STATS1_NONE) ||
				 (liveObj->drivenObject != (LiveObject *)0x0)) {
				globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_LASERTRACKER;
				liveObj->flags4 = liveObj->flags4 | 1;
			}
		}
	}
	FUN_0041e680();
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_0044c7c0(LiveObject *liveObj)
{
	if ((*(byte *)&liveObj->flags4 & 1) != 0) {
		globals::g_Game.flags1 = globals::g_Game.flags1 & ~GAME1_LASERTRACKER;
	}
	liveObj->flags4 = liveObj->flags4 & 0xfffffffe;
	return 0;
}



BOOL __cdecl lego::game::LiveObject_MiniFigureHasBeamEquipped(LiveObject *liveObj)
{
	uint uVar1;
	
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		uVar1 = LiveObject_GetEquippedBeam(liveObj);
		if (uVar1 != 0) {
			return 1;
		}
	}
	return 0;
}



void __cdecl FUN_0044c810(void)
{
	BOOL BVar1;
	ObjectType local_4;
	
	lego::pool::globals::ReservedPool_LiveObject___g_INITFLAGS =
			 lego::pool::globals::ReservedPool_LiveObject___g_INITFLAGS | 0x40;
	BVar1 = lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
										(lego::game::LiveObject_FUN_0044c8b0,(LiveObject *)0x0);
	if (BVar1 == 0) {
		if (DAT_004ebbc8 == 0) {
			local_4 = OBJECT_VEHICLE;
			BVar1 = lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
												(lego::game::LiveObject_FUN_0044c8b0,(LiveObject *)&local_4);
			if ((BVar1 == 0) && (DAT_004ebbc4 != 0)) {
				DAT_004ebbc4 = 0;
				DAT_004ebbc8 = 0;
				lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
									(lego::game::LiveObject_FUN_0044c8b0,(LiveObject *)&local_4);
				return;
			}
		}
		else {
			DAT_004ebbc4 = 0;
			DAT_004ebbc8 = 0;
			lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
								(lego::game::LiveObject_FUN_0044c8b0,(LiveObject *)0x0);
		}
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_0044c8b0(LiveObject *liveObj,int *param_2)
{
	int iVar1;
	uint uVar2;
	BOOL BVar3;
	LiveObject **ppLVar4;
	float local_c;
	float local_8;
	float local_4;
	
	iVar1 = 0;
	if (param_2 != (int *)0x0) {
		iVar1 = *param_2;
	}
	if (iVar1 == 0) {
		if (liveObj->objType != OBJECT_BUILDING) {
			return 0;
		}
	}
	else {
		if (liveObj->objType != OBJECT_MINIFIGURE) {
			return 0;
		}
	}
	uVar2 = 0;
	if (DAT_004ebbc4 != 0) {
		ppLVar4 = (LiveObject **)&DAT_004eb7c4;
		do {
			if (*ppLVar4 == liveObj) {
				return 0;
			}
			uVar2 = uVar2 + 1;
			ppLVar4 = ppLVar4 + 1;
		} while (uVar2 < DAT_004ebbc4);
	}
	if (DAT_004ebbc4 < 0x100) {
		(&DAT_004eb7c4)[DAT_004ebbc4] = liveObj;
		DAT_004ebbc4 = DAT_004ebbc4 + 1;
		if (liveObj->objType == OBJECT_BUILDING) {
			DAT_004ebbc8 = DAT_004ebbc8 + 1;
		}
		LiveObject_FUN_0042dd70(liveObj,(uint *)0x0,0);
		BVar3 = SurfaceMap_FUN_004505a0
											((globals::g_Game.level)->surfaceMap,globals::g_Game.viewMain,globs::INPUT.msx
											 ,globs::INPUT.msy,(uint *)&param_2,(uint *)&liveObj,&local_c);
		if (BVar3 != 0) {
			res::Container_SetPosition
								(globals::g_Game.resRootLight,(Container *)0x0,local_c,local_8,local_4 - 250.0);
			return 1;
		}
	}
	else {
		DAT_004ebbc4 = 0;
		DAT_004ebbc8 = 0;
	}
	return 1;
}



void __cdecl
lego::light::InitLightEffects
					(Container *resRootSpotlight,Container *resRootLight,float initialRed,float initialGreen,
					float initialBlue)
{
	globals::g_Light.initialRGB.red = initialRed;
	globals::g_Light.initialRGB.green = initialGreen;
	globals::g_Light.currentRGB.red = initialRed;
	globals::g_Light.currentRGB.green = initialGreen;
	globals::g_Light.initialRGB.blue = initialBlue;
	globals::g_Light.currentRGB.blue = initialBlue;
	globals::g_Light.resSpotlight = resRootSpotlight;
	globals::g_Light.resRootLight = resRootLight;
	LightEffects_ResetColor();
	return;
}



// Resets LightEffects to its initialRGB colour value (hardcoded as 0.8:0.8:0.8)

void __cdecl lego::light::LightEffects_ResetColor(void)
{
	res::Container_SetColourAlpha
						(globals::g_Light.resSpotlight,globals::g_Light.initialRGB.red,
						 globals::g_Light.initialRGB.green,globals::g_Light.initialRGB.blue,1.0);
	return;
}



void __cdecl lego::light::LightEffects_SetDisabled(BOOL isDisabled)
{
	if (isDisabled != 0) {
		globals::g_Light.flags = globals::g_Light.flags | LIGHTEFFECTS_DISABLED;
		LightEffects_ResetColor();
		return;
	}
	globals::g_Light.flags = globals::g_Light.flags & ~LIGHTEFFECTS_DISABLED;
	return;
}



BOOL __cdecl lego::light::LightEffects_Load(CFGProperty *root,char *rootPath)
{
	BOOL BVar1;
	
	LightEffects_LoadBlink(root,rootPath);
	LightEffects_LoadFade(root,rootPath);
	BVar1 = LightEffects_LoadMove(root,rootPath);
	return BVar1;
}



BOOL __cdecl lego::light::LightEffects_LoadBlink(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	BOOL BVar2;
	char *pcVar3;
	int iVar4;
	float10 fVar5;
	float10 fVar6;
	float *out_r;
	float *out_g;
	float *out_b;
	float blink_blue;
	float blink_green;
	float blink_red;
	char *stringParts [10];
	
	pcVar3 = rootPath;
	out_b = &blink_blue;
	out_g = &blink_green;
	out_r = &blink_red;
	pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","BlinkRGBMax",0);
	BVar2 = cfg::CFG_ReadRGBF(root,pcVar1,out_r,out_g,out_b);
	if (BVar2 != 0) {
		pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","MaxChangeAllowed",0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		if (pcVar1 == (char *)0x0) {
			pcVar1 = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","MaxChangeAllowed",0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		}
		fVar5 = std::atof(pcVar1);
		rootPath = (char *)(float)fVar5;
		if ((float10)0.0 != fVar5) {
			rootPath = (char *)((float)rootPath * 0.003921569);
		}
		pcVar3 = cfg::CFG_JoinPath(pcVar3,"LightEffects","RandomRangeForTimeBetweenBlinks",0);
		pcVar3 = cfg::CFG_CopyString(root,pcVar3);
		if (pcVar3 != (char *)0x0) {
			iVar4 = util::Util_Tokenise(pcVar3,stringParts,":");
			if (iVar4 == 2) {
				fVar5 = std::atof(stringParts[0]);
				fVar6 = std::atof(stringParts[1]);
				std::free(pcVar3);
				LightEffects_SetBlink
									(blink_red,blink_green,blink_blue,(float)rootPath,(float)(fVar5 * (float10)25.0),
									 (float)(fVar6 * (float10)25.0));
				return 1;
			}
			std::free(pcVar3);
		}
	}
	return 0;
}



void __cdecl
lego::light::LightEffects_SetBlink
					(float red,float green,float blue,float maxChange,float minRange,float maxRange)
{
	globals::g_Light.BlinkRGBMax.red = red;
	globals::g_Light.BlinkRGBMax.green = green;
	globals::g_Light.BlinkRGBMax.blue = blue;
	globals::g_Light.RandomRangeForTimeBetweenBlinks.min = minRange;
	globals::g_Light.RandomRangeForTimeBetweenBlinks.max = maxRange;
	globals::g_Light.MaxChangeAllowed = maxChange;
	globals::g_Light.flags = globals::g_Light.flags | LIGHTEFFECTS_HASBLINK;
	return;
}



BOOL __cdecl lego::light::LightEffects_LoadFade(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	BOOL BVar2;
	int iVar3;
	float10 fVar4;
	float10 fVar5;
	float10 fVar6;
	float10 fVar7;
	float10 fVar8;
	float10 fVar9;
	float *pfVar10;
	float *pfVar11;
	float *pfVar12;
	float maxFade;
	float minFade;
	float maxTime;
	float minTime;
	float fadeMax_b;
	float fadeMax_g;
	float fadeMax_r;
	float fadeMin_b;
	float fadeMin_g;
	float fadeMin_r;
	char *stringParts [10];
	
	pfVar12 = &fadeMin_b;
	pfVar11 = &fadeMin_g;
	pfVar10 = &fadeMin_r;
	pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","FadeRGBMin",0);
	BVar2 = cfg::CFG_ReadRGBF(root,pcVar1,pfVar10,pfVar11,pfVar12);
	if (BVar2 != 0) {
		pfVar12 = &fadeMax_b;
		pfVar11 = &fadeMax_g;
		pfVar10 = &fadeMax_r;
		pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","FadeRGBMax",0);
		BVar2 = cfg::CFG_ReadRGBF(root,pcVar1,pfVar10,pfVar11,pfVar12);
		if (BVar2 != 0) {
			pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForTimeBetweenFades",0);
			pcVar1 = cfg::CFG_CopyString(root,pcVar1);
			if (pcVar1 != (char *)0x0) {
				iVar3 = util::Util_Tokenise(pcVar1,stringParts,":");
				if (iVar3 == 2) {
					fVar4 = std::atof(stringParts[0]);
					fVar5 = std::atof(stringParts[1]);
					std::free(pcVar1);
					pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForFadeTimeFade",0);
					pcVar1 = cfg::CFG_CopyString(root,pcVar1);
					if (pcVar1 == (char *)0x0) {
						return 0;
					}
					iVar3 = util::Util_Tokenise(pcVar1,stringParts,":");
					if (iVar3 == 2) {
						fVar6 = std::atof(stringParts[0]);
						fVar7 = std::atof(stringParts[1]);
						std::free(pcVar1);
						pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForHoldTimeOfFade",0);
						pcVar1 = cfg::CFG_CopyString(root,pcVar1);
						if (pcVar1 == (char *)0x0) {
							return 0;
						}
						iVar3 = util::Util_Tokenise(pcVar1,stringParts,":");
						if (iVar3 == 2) {
							fVar8 = std::atof(stringParts[0]);
							fVar9 = std::atof(stringParts[1]);
							std::free(pcVar1);
							LightEffects_SetFade
												(fadeMin_r,fadeMin_g,fadeMin_b,fadeMax_r,fadeMax_g,fadeMax_b,
												 (float)(fVar4 * (float10)25.0),(float)(fVar5 * (float10)25.0),
												 (float)(fVar6 * (float10)25.0),(float)(fVar7 * (float10)25.0),
												 (float)(fVar8 * (float10)25.0),(float)(fVar9 * (float10)25.0));
							return 1;
						}
					}
				}
										// this will free any of the 3 str mallocs above, if any numParts != 2
				std::free(pcVar1);
			}
		}
	}
	return 0;
}



void __cdecl
lego::light::LightEffects_SetFade
					(float minRed,float minGreen,float minBlue,float maxRed,float maxGreen,float maxBlue,
					float minTime,float maxTime,float minFade,float maxFade,float minHold,float maxHold)
{
	globals::g_Light.FadeRGBMin.red = minRed;
	globals::g_Light.FadeRGBMin.green = minGreen;
	globals::g_Light.FadeRGBMin.blue = minBlue;
	globals::g_Light.FadeRGBMax.red = maxRed;
	globals::g_Light.FadeRGBMax.green = maxGreen;
	globals::g_Light.FadeRGBMax.blue = maxBlue;
	globals::g_Light.RandomRangeForTimeBetweenFades.min = minTime;
	globals::g_Light.RandomRangeForTimeBetweenFades.max = maxTime;
	globals::g_Light.RandomRangeForFadeTimeFade.min = minFade;
	globals::g_Light.RandomRangeForFadeTimeFade.max = maxFade;
	globals::g_Light.RandomRangeForHoldTimeOfFade.min = minHold;
	globals::g_Light.RandomRangeForHoldTimeOfFade.max = maxHold;
	globals::g_Light.flags = globals::g_Light.flags | LIGHTEFFECTS_HASFADE;
	return;
}



BOOL __cdecl lego::light::LightEffects_LoadMove(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	int iVar2;
	float10 fVar3;
	float10 fVar4;
	float10 fVar5;
	float10 fVar6;
	float10 fVar7;
	float10 fVar8;
	float10 fVar9;
	float10 fVar10;
	float10 fVar11;
	float limitX;
	float maxDist;
	float minDist;
	float maxSpeed;
	float minSpeed;
	float maxTime;
	float minTime;
	char *stringParts [10];
	
	pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForTimeBetweenMoves",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		iVar2 = util::Util_Tokenise(pcVar1,stringParts,":");
		if (iVar2 == 2) {
			fVar3 = std::atof(stringParts[0]);
			fVar4 = std::atof(stringParts[1]);
			std::free(pcVar1);
			pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForSpeedOfMove",0);
			pcVar1 = cfg::CFG_CopyString(root,pcVar1);
			if (pcVar1 == (char *)0x0) {
				return 0;
			}
			iVar2 = util::Util_Tokenise(pcVar1,stringParts,":");
			if (iVar2 == 2) {
				fVar5 = std::atof(stringParts[0]);
				fVar6 = std::atof(stringParts[1]);
				std::free(pcVar1);
				pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForDistOfMove",0);
				pcVar1 = cfg::CFG_CopyString(root,pcVar1);
				if (pcVar1 == (char *)0x0) {
					return 0;
				}
				iVar2 = util::Util_Tokenise(pcVar1,stringParts,":");
				if (iVar2 == 2) {
					fVar7 = std::atof(stringParts[0]);
					fVar8 = std::atof(stringParts[1]);
					std::free(pcVar1);
					pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","MoveLimit",0);
					pcVar1 = cfg::CFG_CopyString(root,pcVar1);
					if (pcVar1 == (char *)0x0) {
						return 0;
					}
					iVar2 = util::Util_Tokenise(pcVar1,stringParts,":");
					if (iVar2 == 3) {
						fVar9 = std::atof(stringParts[0]);
						fVar10 = std::atof(stringParts[1]);
						fVar11 = std::atof(stringParts[2]);
						std::free(pcVar1);
						LightEffects_SetMove
											((float)(fVar3 * (float10)25.0),(float)(fVar4 * (float10)25.0),
											 (float)(fVar5 * (float10)25.0),(float)(fVar6 * (float10)25.0),(float)fVar7,
											 (float)fVar8,(float)fVar9,(float)fVar10,(float)fVar11);
						return 1;
					}
				}
			}
		}
										// this will free any of the 4 str mallocs above, if any numParts != 2 (or
										// numParts != 3 for limit)
		std::free(pcVar1);
	}
	return 0;
}



void __cdecl
lego::light::LightEffects_SetMove
					(float minTime,float maxTime,float minSpeed,float maxSpeed,float minDist,float maxDist,
					float limitX,float limitY,float limitZ)
{
	globals::g_Light.RandomRangeForTimeBetweenMoves.min = minTime;
	globals::g_Light.RandomRangeForTimeBetweenMoves.max = maxTime;
	globals::g_Light.RandomRangeForSpeedOfMove.max = maxSpeed;
	globals::g_Light.RandomRangeForDistOfMove.min = minDist;
	globals::g_Light.RandomRangeForSpeedOfMove.min = minSpeed;
	globals::g_Light.RandomRangeForDistOfMove.max = maxDist;
										// Writes position to Vector3F globals::g_Light.resMoveLimit
	res::Container_GetPosition
						(globals::g_Light.resSpotlight,globals::g_Light.resRootLight,
						 &globals::g_Light.resPosition);
	globals::g_Light.MoveLimit.x = limitX;
	globals::g_Light.MoveLimit.y = limitY;
	globals::g_Light.MoveLimit.z = limitZ;
	globals::g_Light.flags = globals::g_Light.flags | LIGHTEFFECTS_HASMOVE;
	return;
}



// Forces the LightEffect to re-obtain the resRootSpotlight position, and also restarts movement
// effects.

void __cdecl lego::light::LightEffects_InvalidatePosition(void)
{
										// Writes position to Vector3F globals::g_Light.resMoveLimit
	res::Container_GetPosition
						(globals::g_Light.resSpotlight,globals::g_Light.resRootLight,
						 &globals::g_Light.resPosition);
	globals::g_Light.flags = globals::g_Light.flags & ~LIGHTEFFECTS_MOVING;
	return;
}



void __cdecl lego::light::LightEffects_Update(float elapsed)
{
	if (((globals::g_Light.flags & LIGHTEFFECTS_DISABLED) == LIGHTEFFECTS_NONE) &&
		 (globals::g_Light.resSpotlight != (Container *)0x0)) {
		LightEffects_UpdateBlink(elapsed);
		LightEffects_UpdateFade(elapsed);
		LightEffects_UpdateMove(elapsed);
		LightEffects_UpdateDimmer(elapsed);
		LightEffects_UpdateResource();
	}
	return;
}



void __cdecl lego::light::LightEffects_UpdateResource(void)
{
	float b;
	float g;
	float r;
	
	r = globals::g_Light.currentRGB.red;
	g = globals::g_Light.currentRGB.green;
	b = globals::g_Light.currentRGB.blue;
	if (globals::g_Light.currentRGB.red < 0.0) {
		r = 0.0;
	}
	if ((ushort)((ushort)(r < 1.0) << 8 | (ushort)(r == 1.0) << 0xe) == 0) {
		r = 1.0;
	}
	if (globals::g_Light.currentRGB.green < 0.0) {
		g = 0.0;
	}
	if ((ushort)((ushort)(g < 1.0) << 8 | (ushort)(g == 1.0) << 0xe) == 0) {
		g = 1.0;
	}
	if (globals::g_Light.currentRGB.blue < 0.0) {
		b = 0.0;
	}
	if ((ushort)((ushort)(b < 1.0) << 8 | (ushort)(b == 1.0) << 0xe) == 0) {
		b = 1.0;
	}
	res::Container_SetColourAlpha(globals::g_Light.resSpotlight,r,g,b,1.0);
	return;
}



void __cdecl lego::light::LightEffects_UpdateBlink(float elapsed)
{
	float fVar1;
	float fVar2;
	bool bVar3;
	short sVar4;
	float10 fVar5;
	float local_8;
	float local_4;
	
	bVar3 = false;
	if (((byte)globals::g_Light.flags & LIGHTEFFECTS_HASBLINK) == 0) {
		return;
	}
	globals::g_Light.blinkTime = globals::g_Light.blinkTime - elapsed;
	if ((ushort)((ushort)(globals::g_Light.blinkTime < 0.0) << 8 |
							(ushort)(globals::g_Light.blinkTime == 0.0) << 0xe) == 0) {
		return;
	}
	fVar5 = math::Maths_RandRange
										(globals::g_Light.RandomRangeForTimeBetweenBlinks.min,
										 globals::g_Light.RandomRangeForTimeBetweenBlinks.max);
	globals::g_Light.blinkTime = (float)fVar5;
	sVar4 = math::Maths_Rand();
	fVar2 = (float)((int)sVar4 % 1000) * 0.001;
	elapsed = (globals::g_Light.BlinkRGBMax.red + globals::g_Light.BlinkRGBMax.red) * fVar2 -
						globals::g_Light.BlinkRGBMax.red;
	local_8 = (globals::g_Light.BlinkRGBMax.green + globals::g_Light.BlinkRGBMax.green) * fVar2 -
						globals::g_Light.BlinkRGBMax.green;
	fVar1 = elapsed + globals::g_Light.blinkChange;
	local_4 = (globals::g_Light.BlinkRGBMax.blue + globals::g_Light.BlinkRGBMax.blue) * fVar2 -
						globals::g_Light.BlinkRGBMax.blue;
	if (globals::g_Light.MaxChangeAllowed <= ABS(fVar1)) {
		LightEffects_UpdateBlink_FlipSign(&elapsed);
		LightEffects_UpdateBlink_FlipSign(&local_8);
		LightEffects_UpdateBlink_FlipSign(&local_4);
		fVar1 = elapsed + globals::g_Light.blinkChange;
		if (globals::g_Light.MaxChangeAllowed <= ABS(fVar1)) goto LAB_0044d4b5;
	}
	bVar3 = true;
LAB_0044d4b5:
	if (!bVar3) {
		return;
	}
	globals::g_Light.currentRGB.red = elapsed + globals::g_Light.currentRGB.red;
	globals::g_Light.currentRGB.green = local_8 + globals::g_Light.currentRGB.green;
	globals::g_Light.currentRGB.blue = local_4 + globals::g_Light.currentRGB.blue;
	globals::g_Light.blinkChange = fVar1;
	return;
}



// ref_value = -ref_value
// NOTES: This function is kind of dumb, the way it negates the value is different depending on the
// sign, but the end result will always be the same.

void __cdecl lego::light::LightEffects_UpdateBlink_FlipSign(float *ref_value)
{
	if (*ref_value < 0.0) {
		*ref_value = *ref_value * -1.0;
		return;
	}
	*ref_value = -*ref_value;
	return;
}



void __cdecl lego::light::LightEffects_UpdateFade(float elapsed)
{
	float fVar1;
	short sVar2;
	float10 fVar3;
	
	if ((globals::g_Light.flags & LIGHTEFFECTS_HASFADE) != LIGHTEFFECTS_NONE) {
		if ((globals::g_Light.flags & LIGHTEFFECTS_FADING) == LIGHTEFFECTS_NONE) {
			globals::g_Light.fadeTime = globals::g_Light.fadeTime - elapsed;
			if ((ushort)((ushort)(globals::g_Light.fadeTime < 0.0) << 8 |
									(ushort)(globals::g_Light.fadeTime == 0.0) << 0xe) != 0) {
				fVar3 = math::Maths_RandRange
													(globals::g_Light.RandomRangeForTimeBetweenFades.min,
													 globals::g_Light.RandomRangeForTimeBetweenFades.max);
				globals::g_Light.fadeTime = (float)fVar3;
				fVar3 = math::Maths_RandRange
													(globals::g_Light.RandomRangeForHoldTimeOfFade.min,
													 globals::g_Light.RandomRangeForHoldTimeOfFade.max);
				globals::g_Light.fadeHoldTime = (float)fVar3;
				sVar2 = math::Maths_Rand();
				globals::g_Light.fadePosRGB.red = 0.0;
				globals::g_Light.fadePosRGB.green = 0.0;
				globals::g_Light.fadePosRGB.blue = 0.0;
				fVar1 = (float)((int)sVar2 % 1000) * 0.001;
				globals::g_Light.fadeDestRGB.red =
						 ABS(globals::g_Light.FadeRGBMax.red - globals::g_Light.FadeRGBMin.red) * fVar1 +
						 globals::g_Light.FadeRGBMin.red;
				globals::g_Light.fadeDestRGB.green =
						 ABS(globals::g_Light.FadeRGBMax.green - globals::g_Light.FadeRGBMin.green) * fVar1 +
						 globals::g_Light.FadeRGBMin.green;
				globals::g_Light.fadeDestRGB.blue =
						 ABS(globals::g_Light.FadeRGBMax.blue - globals::g_Light.FadeRGBMin.blue) * fVar1 +
						 globals::g_Light.FadeRGBMin.blue;
				LightEffects_RandomizeFadeSpeedRGB();
				globals::g_Light.flags =
						 globals::g_Light.flags | (LIGHTEFFECTS_FADING|LIGHTEFFECTS_FADE_FORWARD);
			}
		}
		else {
			if ((globals::g_Light.flags & LIGHTEFFECTS_FADE_FORWARD) == LIGHTEFFECTS_NONE) {
				if ((globals::g_Light.flags & LIGHTEFFECTS_FADE_REVERSE) == LIGHTEFFECTS_NONE) {
					globals::g_Light.fadeHoldTime = globals::g_Light.fadeHoldTime - elapsed;
					if ((ushort)((ushort)(globals::g_Light.fadeHoldTime < 0.0) << 8 |
											(ushort)(globals::g_Light.fadeHoldTime == 0.0) << 0xe) != 0) {
						LightEffects_RandomizeFadeSpeedRGB();
						globals::g_Light.fadePosRGB.red = globals::g_Light.fadeDestRGB.red;
						globals::g_Light.fadePosRGB.green = globals::g_Light.fadeDestRGB.green;
						globals::g_Light.fadePosRGB.blue = globals::g_Light.fadeDestRGB.blue;
						globals::g_Light.flags = globals::g_Light.flags | LIGHTEFFECTS_FADE_REVERSE;
						return;
					}
				}
				else {
					fVar1 = elapsed * globals::g_Light.fadeSpeedRGB.red;
					globals::g_Light.currentRGB.red = globals::g_Light.currentRGB.red - fVar1;
					globals::g_Light.fadePosRGB.red = globals::g_Light.fadePosRGB.red - fVar1;
					globals::g_Light.currentRGB.green =
							 globals::g_Light.currentRGB.green - elapsed * globals::g_Light.fadeSpeedRGB.green;
					globals::g_Light.fadePosRGB.green =
							 globals::g_Light.fadePosRGB.green - elapsed * globals::g_Light.fadeSpeedRGB.green;
					globals::g_Light.currentRGB.blue =
							 globals::g_Light.currentRGB.blue - elapsed * globals::g_Light.fadeSpeedRGB.blue;
					globals::g_Light.fadePosRGB.blue =
							 globals::g_Light.fadePosRGB.blue - elapsed * globals::g_Light.fadeSpeedRGB.blue;
					if (fVar1 < 0.0) {
						if (globals::g_Light.fadePosRGB.red >= 0.0) {
							globals::g_Light.currentRGB.red =
									 globals::g_Light.currentRGB.red - globals::g_Light.fadePosRGB.red;
							globals::g_Light.currentRGB.green =
									 globals::g_Light.currentRGB.green - globals::g_Light.fadePosRGB.green;
							globals::g_Light.currentRGB.blue =
									 globals::g_Light.currentRGB.blue - globals::g_Light.fadePosRGB.blue;
							globals::g_Light.flags =
									 globals::g_Light.flags & ~(LIGHTEFFECTS_FADING|LIGHTEFFECTS_FADE_REVERSE);
							return;
						}
					}
					else {
						if ((ushort)((ushort)(globals::g_Light.fadePosRGB.red < 0.0) << 8 |
												(ushort)(globals::g_Light.fadePosRGB.red == 0.0) << 0xe) != 0) {
							globals::g_Light.currentRGB.red =
									 globals::g_Light.currentRGB.red - globals::g_Light.fadePosRGB.red;
							globals::g_Light.currentRGB.green =
									 globals::g_Light.currentRGB.green - globals::g_Light.fadePosRGB.green;
							globals::g_Light.currentRGB.blue =
									 globals::g_Light.currentRGB.blue - globals::g_Light.fadePosRGB.blue;
							globals::g_Light.flags =
									 globals::g_Light.flags & ~(LIGHTEFFECTS_FADING|LIGHTEFFECTS_FADE_REVERSE);
							return;
						}
					}
				}
			}
			else {
				fVar1 = elapsed * globals::g_Light.fadeSpeedRGB.red;
				globals::g_Light.currentRGB.red = fVar1 + globals::g_Light.currentRGB.red;
				globals::g_Light.currentRGB.green =
						 elapsed * globals::g_Light.fadeSpeedRGB.green + globals::g_Light.currentRGB.green;
				globals::g_Light.currentRGB.blue =
						 elapsed * globals::g_Light.fadeSpeedRGB.blue + globals::g_Light.currentRGB.blue;
				globals::g_Light.fadePosRGB.red = fVar1 + globals::g_Light.fadePosRGB.red;
				globals::g_Light.fadePosRGB.green =
						 elapsed * globals::g_Light.fadeSpeedRGB.green + globals::g_Light.fadePosRGB.green;
				globals::g_Light.fadePosRGB.blue =
						 elapsed * globals::g_Light.fadeSpeedRGB.blue + globals::g_Light.fadePosRGB.blue;
				if (fVar1 < 0.0) {
					if ((ushort)((ushort)(globals::g_Light.fadePosRGB.red < globals::g_Light.fadeDestRGB.red)
											 << 8 | (ushort)(globals::g_Light.fadePosRGB.red ==
																			globals::g_Light.fadeDestRGB.red) << 0xe) != 0) {
						globals::g_Light.currentRGB.red =
								 (globals::g_Light.fadeDestRGB.red - globals::g_Light.fadePosRGB.red) +
								 globals::g_Light.currentRGB.red;
						globals::g_Light.currentRGB.green =
								 (globals::g_Light.fadeDestRGB.green - globals::g_Light.fadePosRGB.green) +
								 globals::g_Light.currentRGB.green;
						globals::g_Light.currentRGB.blue =
								 (globals::g_Light.fadeDestRGB.blue - globals::g_Light.fadePosRGB.blue) +
								 globals::g_Light.currentRGB.blue;
						globals::g_Light.flags = globals::g_Light.flags & ~LIGHTEFFECTS_FADE_FORWARD;
						return;
					}
				}
				else {
					if (globals::g_Light.fadePosRGB.red >= globals::g_Light.fadeDestRGB.red) {
						globals::g_Light.currentRGB.red =
								 globals::g_Light.currentRGB.red -
								 (globals::g_Light.fadePosRGB.red - globals::g_Light.fadeDestRGB.red);
						globals::g_Light.currentRGB.green =
								 globals::g_Light.currentRGB.green -
								 (globals::g_Light.fadePosRGB.green - globals::g_Light.fadeDestRGB.green);
						globals::g_Light.currentRGB.blue =
								 globals::g_Light.currentRGB.blue -
								 (globals::g_Light.fadePosRGB.blue - globals::g_Light.fadeDestRGB.blue);
						globals::g_Light.flags = globals::g_Light.flags & ~LIGHTEFFECTS_FADE_FORWARD;
						return;
					}
				}
			}
		}
	}
	return;
}



void __cdecl lego::light::LightEffects_RandomizeFadeSpeedRGB(void)
{
	float10 fVar1;
	
	fVar1 = math::Maths_RandRange
										(globals::g_Light.RandomRangeForFadeTimeFade.min,
										 globals::g_Light.RandomRangeForFadeTimeFade.max);
	globals::g_Light.fadeSpeedRGB.red = (float)((float10)globals::g_Light.fadeDestRGB.red / fVar1);
	globals::g_Light.fadeSpeedRGB.green = (float)((float10)globals::g_Light.fadeDestRGB.green / fVar1)
	;
	globals::g_Light.fadeSpeedRGB.blue = (float)((float10)globals::g_Light.fadeDestRGB.blue / fVar1);
	return;
}



void __cdecl lego::light::LightEffects_UpdateMove(float elapsed)
{
	bool bVar1;
	float fVar2;
	BOOL BVar3;
	float10 fVar4;
	Vector3F newPosition;
	Vector3F lastPosition;
	
	bVar1 = false;
	if ((globals::g_Light.flags & LIGHTEFFECTS_HASMOVE) == LIGHTEFFECTS_NONE) {
		return;
	}
	if ((globals::g_Light.flags & LIGHTEFFECTS_MOVING) == LIGHTEFFECTS_NONE) {
		globals::g_Light.moveTime = globals::g_Light.moveTime - elapsed;
		if ((ushort)((ushort)(globals::g_Light.moveTime < 0.0) << 8 |
								(ushort)(globals::g_Light.moveTime == 0.0) << 0xe) == 0) {
			return;
		}
		fVar4 = math::Maths_RandRange
											(globals::g_Light.RandomRangeForTimeBetweenMoves.min,
											 globals::g_Light.RandomRangeForTimeBetweenMoves.max);
		globals::g_Light.moveTime = (float)fVar4;
		fVar4 = math::Maths_RandRange
											(globals::g_Light.RandomRangeForSpeedOfMove.min,
											 globals::g_Light.RandomRangeForSpeedOfMove.max);
		globals::g_Light.moveSpeed = (float)fVar4;
		fVar4 = math::Maths_RandRange
											(globals::g_Light.RandomRangeForDistOfMove.min,
											 globals::g_Light.RandomRangeForDistOfMove.max);
		globals::g_Light.moveDist = (float)fVar4;
										// Randomize + Normalize vector, multiplied by speed.
										// AKA: speed in a random 3D direction.
		math::Maths_Vector3DRandom(&globals::g_Light.vectorMove);
		fVar2 = 1.0 / SQRT(globals::g_Light.vectorMove.z * globals::g_Light.vectorMove.z +
											 globals::g_Light.vectorMove.y * globals::g_Light.vectorMove.y +
											 globals::g_Light.vectorMove.x * globals::g_Light.vectorMove.x);
		globals::g_Light.vectorMove.x =
				 fVar2 * globals::g_Light.vectorMove.x * globals::g_Light.moveSpeed;
		globals::g_Light.vectorMove.y =
				 fVar2 * globals::g_Light.vectorMove.y * globals::g_Light.moveSpeed;
		globals::g_Light.vectorMove.z =
				 fVar2 * globals::g_Light.vectorMove.z * globals::g_Light.moveSpeed;
		globals::g_Light.flags = globals::g_Light.flags | LIGHTEFFECTS_MOVING;
		return;
	}
	res::Container_GetPosition
						(globals::g_Light.resSpotlight,globals::g_Light.resRootLight,&lastPosition);
	newPosition.x = lastPosition.x + globals::g_Light.vectorMove.x;
	newPosition.y = lastPosition.y + globals::g_Light.vectorMove.y;
	newPosition.z = lastPosition.z + globals::g_Light.vectorMove.z;
	BVar3 = LightEffects_CheckMoveLimit(&newPosition);
	if (BVar3 == 0) {
										// This is the same deal as the `LightEffects_UpdateBlink_FlipSign(float*)`
										// tuple seen in UpdateBlink
										//  it's just that blink doesn't have extra math involved.
		newPosition.x = lastPosition.x - globals::g_Light.vectorMove.x;
		newPosition.y = lastPosition.y - globals::g_Light.vectorMove.y;
		newPosition.z = lastPosition.z - globals::g_Light.vectorMove.z;
		BVar3 = LightEffects_CheckMoveLimit(&newPosition);
		if (BVar3 == 0) goto LAB_0044dae5;
	}
	bVar1 = true;
LAB_0044dae5:
	if (!bVar1) {
		globals::g_Light.flags = globals::g_Light.flags & ~LIGHTEFFECTS_MOVING;
		return;
	}
	res::Container_SetPosition
						(globals::g_Light.resSpotlight,globals::g_Light.resRootLight,newPosition.x,newPosition.y
						 ,newPosition.z);
	globals::g_Light.moveDist = globals::g_Light.moveDist - globals::g_Light.moveSpeed;
	if ((ushort)((ushort)(globals::g_Light.moveDist < 0.0) << 8 |
							(ushort)(globals::g_Light.moveDist == 0.0) << 0xe) == 0) {
		return;
	}
	globals::g_Light.flags = globals::g_Light.flags & ~LIGHTEFFECTS_MOVING;
	return;
}



BOOL __cdecl lego::light::LightEffects_CheckMoveLimit(Vector3F *vector)
{
	float fVar1;
	
	fVar1 = ABS(vector->x - globals::g_Light.resPosition.x);
	if ((ushort)((ushort)(fVar1 < globals::g_Light.MoveLimit.x) << 8 |
							(ushort)(fVar1 == globals::g_Light.MoveLimit.x) << 0xe) == 0) {
		return 0;
	}
	fVar1 = ABS(vector->y - globals::g_Light.resPosition.y);
	if ((ushort)((ushort)(fVar1 < globals::g_Light.MoveLimit.y) << 8 |
							(ushort)(fVar1 == globals::g_Light.MoveLimit.y) << 0xe) == 0) {
		return 0;
	}
	fVar1 = ABS(vector->z - globals::g_Light.resPosition.z);
	if ((ushort)((ushort)(fVar1 < globals::g_Light.MoveLimit.z) << 8 |
							(ushort)(fVar1 == globals::g_Light.MoveLimit.z) << 0xe) == 0) {
		return 0;
	}
	return 1;
}



void __cdecl lego::light::LightEffects_SetDimmerMode(BOOL isDimoutMode)
{
	if (isDimoutMode != 0) {
		globals::g_Light.flags = globals::g_Light.flags & ~LIGHTEFFECTS_DIMIN_DONE | LIGHTEFFECTS_DIMOUT
		;
		return;
	}
	globals::g_Light.flags = globals::g_Light.flags & ~(LIGHTEFFECTS_DIMOUT|LIGHTEFFECTS_DIMOUT_DONE);
	return;
}



void __cdecl lego::light::LightEffects_UpdateDimmer(float elapsed)
{
	float fVar1;
	
	if ((globals::g_Light.flags & LIGHTEFFECTS_DIMOUT) == LIGHTEFFECTS_NONE) {
		if ((globals::g_Light.flags & LIGHTEFFECTS_DIMIN_DONE) == LIGHTEFFECTS_NONE) {
			fVar1 = elapsed * 0.1;
			globals::g_Light.currentRGB.red = fVar1 + globals::g_Light.currentRGB.red;
			globals::g_Light.currentRGB.green = fVar1 + globals::g_Light.currentRGB.green;
			globals::g_Light.currentRGB.blue = fVar1 + globals::g_Light.currentRGB.blue;
			if (globals::g_Light.initialRGB.red <= globals::g_Light.currentRGB.red) {
				globals::g_Light.flags = globals::g_Light.flags | LIGHTEFFECTS_DIMIN_DONE;
										// Uhhh... assigning blue to red??? (this has to be a bug)
										// Actually... why is this only assigning red and no other colors???
				globals::g_Light.currentRGB.red = globals::g_Light.initialRGB.blue;
			}
		}
	}
	else {
		if ((globals::g_Light.flags & LIGHTEFFECTS_DIMOUT_DONE) != LIGHTEFFECTS_NONE) {
			globals::g_Light.currentRGB.red = 0.0;
			globals::g_Light.currentRGB.green = 0.0;
			globals::g_Light.currentRGB.blue = 0.0;
			return;
		}
		fVar1 = elapsed * 0.1;
		globals::g_Light.currentRGB.red = globals::g_Light.currentRGB.red - fVar1;
		globals::g_Light.currentRGB.green = globals::g_Light.currentRGB.green - fVar1;
		globals::g_Light.currentRGB.blue = globals::g_Light.currentRGB.blue - fVar1;
		if ((ushort)((ushort)(globals::g_Light.currentRGB.red < 0.0) << 8 |
								(ushort)(globals::g_Light.currentRGB.red == 0.0) << 0xe) != 0) {
			globals::g_Light.currentRGB.red = 0.0;
			globals::g_Light.flags = globals::g_Light.flags | LIGHTEFFECTS_DIMOUT_DONE;
			return;
		}
	}
	return;
}



void __cdecl
lego::main::Main_LoadLoadScreen
					(char *loadScreen,char *shutdownScreen,ImageFont *font5HI,char *profileFilename,
					Direction progressDirection,char *progressBar,Rect2F *progressArea,char *loadingText)
{
	char cVar1;
	char *pcVar2;
	undefined4 *puVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	FileStream *f;
	LoaderProfileItem *pLVar7;
	undefined4 *puVar8;
	ImageBMP **ppIVar9;
	char *pcVar10;
	char *local_128;
	char *local_124;
	char local_100 [256];
	
	f = (FileStream *)0x0;
	ppIVar9 = &globals::g_LoadScreen_bmp;
	for (iVar4 = 0xa4; iVar4 != 0; iVar4 = iVar4 + -1) {
		*ppIVar9 = (ImageBMP *)0x0;
		ppIVar9 = ppIVar9 + 1;
	}
	globals::g_LoadScreen_bmp = image::Image_LoadBMPScaled(loadScreen,0,0);
	globals::g_ShutdownScreen_bmp = image::Image_LoadBMPScaled(shutdownScreen,0,0);
	globals::g_LoadScreen_Font = font5HI;
	globals::g_LoaderProfileItems_LAST = (LoaderProfileItem *)0x0;
	globals::g_ProgressBar_bmp = image::Image_LoadBMPScaled(progressBar,0,0);
	globals::g_LoadScreen_ProgressArea.x = progressArea->x;
	globals::g_LoadScreen_ProgressArea.y = progressArea->y;
	globals::g_LoadScreen_ProgressArea.width = progressArea->width;
	globals::g_LoadScreen_ProgressArea.height = progressArea->height;
	globals::g_LoadScreen_ProgressDirection = progressDirection;
	if (loadingText == (char *)0x0) {
		globals::g_LoadingText = (char *)0x0;
	}
	else {
		pcVar2 = std::_strdup(loadingText);
		cVar1 = *pcVar2;
		globals::g_LoadingText = pcVar2;
		while (cVar1 != '\0') {
			if (cVar1 == '_') {
				*pcVar2 = ' ';
			}
			pcVar10 = pcVar2 + 1;
			pcVar2 = pcVar2 + 1;
			cVar1 = *pcVar10;
		}
		unk::UnkFont_FUN_00401bc0(font5HI,&DAT_00557084,(uint *)0x0,"%s",loadingText);
	}
	if (profileFilename != (char *)0x0) {
		f = lego::file::File_Open(profileFilename,"r");
	}
	pLVar7 = globals::g_LoaderProfileItems_TABLE;
	do {
		if (((f == (FileStream *)0x0) ||
				(pcVar2 = lego::file::File_GetS(local_100,0x100,f), pcVar2 == (char *)0x0)) ||
			 (iVar4 = util::Util_Tokenise(local_100,&local_128,"="), iVar4 != 2)) {
			pLVar7->name = (char *)0x0;
		}
		else {
			uVar5 = 0xffffffff;
			pcVar2 = local_128;
			do {
				if (uVar5 == 0) break;
				uVar5 = uVar5 - 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar2 + 1;
			} while (cVar1 != '\0');
			puVar3 = (undefined4 *)std::malloc(~uVar5);
			uVar5 = 0xffffffff;
			pLVar7->name = (char *)puVar3;
			pcVar2 = local_128;
			do {
				pcVar10 = pcVar2;
				if (uVar5 == 0) break;
				uVar5 = uVar5 - 1;
				pcVar10 = pcVar2 + 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar10;
			} while (cVar1 != '\0');
			uVar5 = ~uVar5;
			puVar8 = (undefined4 *)(pcVar10 + -uVar5);
			for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
				*puVar3 = *puVar8;
				puVar8 = puVar8 + 1;
				puVar3 = puVar3 + 1;
			}
			for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
				*(undefined *)puVar3 = *(undefined *)puVar8;
				puVar8 = (undefined4 *)((int)puVar8 + 1);
				puVar3 = (undefined4 *)((int)puVar3 + 1);
			}
			iVar4 = std::atoi(local_124);
			pLVar7->field_8 = iVar4;
			pLVar7->field_4 = 0;
		}
		pLVar7 = pLVar7 + 1;
		if ((LoaderProfileItem *)((int)&globals::g_LoaderProfileItems_TABLE[0x31].field_8 + 3U) < pLVar7
			 ) {
			if (f != (FileStream *)0x0) {
				lego::file::File_Close(f);
			}
			lego::file::File_SetLoadCallback(lego::file::LoaderProfile_FileOpenCallback,(void *)0x0);
			return;
		}
	} while( true );
}



void __cdecl lego::file::Log_LoaderProfile(char *filename)
{
	FileStream *f;
	int iVar1;
	LoaderProfileItem *pLVar2;
	
	if (filename == (char *)0x0) {
		f = (FileStream *)0x0;
	}
	else {
		f = File_Open(filename,"w");
	}
	pLVar2 = globals::g_LoaderProfileItems_TABLE;
	do {
		if (pLVar2->name != (char *)0x0) {
			iVar1 = pLVar2->field_4;
			if (iVar1 == 0) {
				iVar1 = pLVar2->field_8;
			}
			if (f != (FileStream *)0x0) {
				File_PrintF(f,"%s%s%i\n",pLVar2->name,"=",iVar1);
			}
			std::free(pLVar2->name);
		}
		pLVar2 = pLVar2 + 1;
	} while (pLVar2 < &globals::g_LoaderProfileItems_LAST);
	if (f != (FileStream *)0x0) {
		File_Close(f);
	}
	image::Image_Remove(globals::g_LoadScreen_bmp);
	if (globals::g_ShutdownScreen_bmp != (ImageBMP *)0x0) {
		image::Image_Remove(globals::g_ShutdownScreen_bmp);
	}
	return;
}



void __cdecl lego::main::LoaderProfile_Lookup(char *itemName)
{
	char cVar1;
	int iVar2;
	undefined4 *puVar3;
	uint uVar4;
	uint uVar5;
	LoaderProfileItem *pLVar6;
	LoaderProfileItem *pLVar7;
	LoaderProfileItem *pLVar8;
	undefined4 *puVar9;
	int iVar10;
	char *pcVar11;
	
	if (itemName == (char *)0x0) {
		globals::g_LoaderProfileFlags = globals::g_LoaderProfileFlags & 0xfffffffe;
		return;
	}
	iVar10 = 0;
	pLVar8 = globals::g_LoaderProfileItems_TABLE;
	pLVar6 = (LoaderProfileItem *)0x0;
	do {
		pLVar7 = pLVar8;
		if ((pLVar8->name != (char *)0x0) &&
			 (iVar2 = std::_stricmp(pLVar8->name,itemName), pLVar7 = pLVar6, iVar2 == 0)) {
			globals::g_LoaderProfileItems_LAST = globals::g_LoaderProfileItems_TABLE + iVar10;
			globals::g_LoaderProfileItems_TABLE[iVar10].field_4 = 0;
			break;
		}
		pLVar8 = pLVar8 + 1;
		iVar10 = iVar10 + 1;
		pLVar6 = pLVar7;
	} while (pLVar8 < &globals::g_LoaderProfileItems_LAST);
	if ((iVar10 == 0x32) && (pLVar7 != (LoaderProfileItem *)0x0)) {
		uVar4 = 0xffffffff;
		pcVar11 = itemName;
		do {
			if (uVar4 == 0) break;
			uVar4 = uVar4 - 1;
			cVar1 = *pcVar11;
			pcVar11 = pcVar11 + 1;
		} while (cVar1 != '\0');
		puVar3 = (undefined4 *)std::malloc(~uVar4);
		uVar4 = 0xffffffff;
		pLVar7->name = (char *)puVar3;
		do {
			pcVar11 = itemName;
			if (uVar4 == 0) break;
			uVar4 = uVar4 - 1;
			pcVar11 = itemName + 1;
			cVar1 = *itemName;
			itemName = pcVar11;
		} while (cVar1 != '\0');
		uVar4 = ~uVar4;
		puVar9 = (undefined4 *)(pcVar11 + -uVar4);
		for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
			*puVar3 = *puVar9;
			puVar9 = puVar9 + 1;
			puVar3 = puVar3 + 1;
		}
		for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
			*(undefined *)puVar3 = *(undefined *)puVar9;
			puVar9 = (undefined4 *)((int)puVar9 + 1);
			puVar3 = (undefined4 *)((int)puVar3 + 1);
		}
		pLVar7->field_4 = 0;
		pLVar7->field_8 = 0;
		globals::g_LoaderProfileItems_LAST = pLVar7;
	}
	globals::g_LoaderProfileFlags = globals::g_LoaderProfileFlags | 1;
	FLOAT_00557088 = -1.0;
	lego::file::LoaderProfile_FileOpenCallback((char *)0x0,0,(void *)0x0);
	return;
}



void __cdecl lego::file::LoaderProfile_FileOpenCallback(char *filename,uint fileSize,void *lpValue)
{
	float fVar1;
	int y;
	longlong lVar2;
	char *msg;
	char *pcVar3;
	Size2F local_10;
	Point2F local_8;
	
	if (((byte)globals::g_LoaderProfileFlags & 1) != 0) {
		if (((globals::g_LoaderProfileItems_LAST == (LoaderProfileItem *)0x0) ||
				(globals::g_LoaderProfileItems_LAST->field_4 =
							globals::g_LoaderProfileItems_LAST->field_4 + fileSize,
				globals::g_LoaderProfileItems_LAST == (LoaderProfileItem *)0x0)) ||
			 (globals::g_LoaderProfileItems_LAST->field_8 == 0)) {
			fileSize = 0;
		}
		else {
			fileSize = (uint)((float)(ulonglong)(uint)globals::g_LoaderProfileItems_LAST->field_4 /
											 (float)globals::g_LoaderProfileItems_LAST->field_8);
		}
		if ((ushort)((ushort)((float)fileSize < FLOAT_00557088 - -0.002) << 8 |
								(ushort)((float)fileSize == FLOAT_00557088 - -0.002) << 0xe) == 0) {
			local_8.y = globals::g_LoadScreen_ProgressArea.y;
			local_8.x = globals::g_LoadScreen_ProgressArea.x;
			local_10.width = globals::g_LoadScreen_ProgressArea.width;
			local_10.height = globals::g_LoadScreen_ProgressArea.height;
			image::Image_DisplayScaled
								(globals::g_LoadScreen_bmp,(Rect2F *)0x0,(Point2F *)0x0,(Size2F *)0x0);
			if ((ushort)((ushort)((float)fileSize < 1.0) << 8 | (ushort)((float)fileSize == 1.0) << 0xe)
					== 0) {
				fileSize = 1065353216;
			}
			switch(globals::g_LoadScreen_ProgressDirection) {
			case DIRECTION_UP:
				fVar1 = local_10.height + local_8.y;
				local_8.y = fVar1 - local_10.height * (float)fileSize;
				local_10.height = fVar1 - local_8.y;
				break;
			case DIRECTION_RIGHT:
				local_10.width = local_10.width * (float)fileSize;
				break;
			case DIRECTION_DOWN:
				local_10.height = local_10.height * (float)fileSize;
				break;
			case DIRECTION_LEFT:
				fVar1 = local_10.width + local_8.x;
				local_8.x = fVar1 - local_10.width * (float)fileSize;
				local_10.width = fVar1 - local_8.x;
			}
			if (globals::g_ProgressBar_bmp != (ImageBMP *)0x0) {
				image::Image_DisplayScaled(globals::g_ProgressBar_bmp,(Rect2F *)0x0,&local_8,&local_10);
			}
			if (globals::g_LoadingText != (char *)0x0) {
				msg = "%s";
				pcVar3 = globals::g_LoadingText;
				lVar2 = __ftol((float10)globals::g_LoadScreen_ProgressArea.y);
				y = (int)lVar2 + -1;
				lVar2 = __ftol((float10)globals::g_LoadScreen_ProgressArea.width * (float10)0.5 +
											 (float10)globals::g_LoadScreen_ProgressArea.x);
				image::Font_PrintF(globals::g_LoadScreen_Font,(int)lVar2 - (DAT_00557084 >> 1),y,msg,pcVar3)
				;
			}
			main::Main_LoopUpdate(0);
			FLOAT_00557088 = (float)fileSize;
		}
	}
	return;
}



void __cdecl lego::main::Main_ShowShutdownScreen(void)
{
	if (globals::g_ShutdownScreen_bmp != (ImageBMP *)0x0) {
		image::Image_DisplayScaled
							(globals::g_ShutdownScreen_bmp,(Rect2F *)0x0,(Point2F *)0x0,(Size2F *)0x0);
		ddraw::DirectDraw_Flip();
		return;
	}
	return;
}



SurfaceMap * __cdecl
lego::game::SurfaceMap_Load(Container *in_resData,char *filename,float blockSize,float roughLevel)
{
	Size2I *out_width;
	float *pfVar1;
	int iVar2;
	ushort uVar3;
	MapFileInfo *mapFileInfo;
	SurfaceMap *surfMap;
	uint uVar4;
	int *piVar5;
	SurfaceMapStruct38 *pSVar6;
	Container *pCVar7;
	void *pvVar8;
	D3DRMGroupIndex group;
	int iVar9;
	uint uVar10;
	uint uVar11;
	SurfaceMapStruct38 *pSVar12;
	undefined4 *puVar13;
	uint uVar14;
	float10 fVar15;
	float10 fVar16;
	uint local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar11 = 0;
	mapFileInfo = (MapFileInfo *)lego::file::File_LoadBinary(filename,(uint *)0x0);
	if (mapFileInfo != (MapFileInfo *)0x0) {
		surfMap = (SurfaceMap *)std::malloc(0x73d4);
		if (surfMap != (SurfaceMap *)0x0) {
			piVar5 = &(surfMap->dimensions).height;
			out_width = &surfMap->dimensions;
			surfMap->BlockSize = blockSize;
			surfMap->RoughLevel = roughLevel;
			MapFile_GetDimensions(mapFileInfo,(int *)out_width,piVar5);
			uVar4 = out_width->width - 1;
			uVar10 = *piVar5 - 1;
			(surfMap->smallDimensions).width = uVar4;
			(surfMap->smallDimensions).height = uVar10;
			(surfMap->blockDimensions_neg).width = -((float)(ulonglong)uVar4 * blockSize * 0.5);
			surfMap->field_2c = 0;
			(surfMap->blockDimensions_neg).height = (float)(ulonglong)uVar10 * blockSize * 0.5;
			puVar13 = (undefined4 *)surfMap->texsNum;
			for (iVar9 = 0x20; iVar9 != 0; iVar9 = iVar9 + -1) {
				*puVar13 = 0;
				puVar13 = puVar13 + 1;
			}
			surfMap->field_73d0 = 0;
			surfMap->coordsNum = 0;
			surfMap->field_7198 = 0;
			surfMap->float_20 = 0.0;
			piVar5 = res::UNK_Material_Create(1.0,1.0,1.0,0.0,0,0,0);
			pSVar6 = surfMap->table38_719c;
			surfMap->unkMaterialData_30 = piVar5;
			pSVar12 = pSVar6;
			for (iVar9 = 0x8c; iVar9 != 0; iVar9 = iVar9 + -1) {
				pSVar12->field_0 = 0;
				pSVar12 = (SurfaceMapStruct38 *)&pSVar12->float_4;
			}
			puVar13 = surfMap->flat_40b4;
			for (iVar9 = 0x80; iVar9 != 0; iVar9 = iVar9 + -1) {
				*puVar13 = 0;
				puVar13 = puVar13 + 1;
			}
			iVar9 = 10;
			do {
				pSVar6->field_0 = 0xffffffff;
				pSVar6 = pSVar6 + 1;
				iVar9 = iVar9 + -1;
			} while (iVar9 != 0);
			pCVar7 = res::Container_MakeMesh2(in_resData,3);
			surfMap->resData_73cc = pCVar7;
			pCVar7 = res::Container_MakeMesh2(in_resData,2);
			surfMap->resData_24 = pCVar7;
			if (pCVar7 != (Container *)0x0) {
				pvVar8 = std::malloc(out_width->width * (surfMap->dimensions).height * 0x28);
				surfMap->field_28 = pvVar8;
				if (pvVar8 != (void *)0x0) {
					local_18 = 0;
					local_14 = 1;
					local_10 = 3;
					local_c = 1;
					local_8 = 2;
					local_4 = 3;
					if ((surfMap->smallDimensions).width * (surfMap->smallDimensions).height != 0) {
						do {
							group = res::Container_Mesh_AddGroup(surfMap->resData_24,4,2,3,&local_18);
							res::Container_Mesh_HideGroup(surfMap->resData_24,group,1);
							res::Container_Mesh_SetQuality(surfMap->resData_24,group,QUALITY_GOURAUD);
							uVar11 = uVar11 + 1;
						} while (uVar11 < (uint)((surfMap->smallDimensions).width *
																		(surfMap->smallDimensions).height));
					}
					uVar11 = 0;
					if ((surfMap->dimensions).height != 0) {
						do {
							uVar10 = out_width->width;
							uVar4 = 0;
							if (uVar10 != 0) {
								do {
									*(undefined *)(surfMap->field_28 + 0x19 + (uVar11 * uVar10 + uVar4) * 0x28) = 0x60
									;
									*(undefined *)
									 (surfMap->field_28 + 0x18 + (uVar11 * out_width->width + uVar4) * 0x28) = 0;
									iVar9 = out_width->width;
									iVar2 = surfMap->field_28;
									uVar3 = MapFile_GetBlock(mapFileInfo,uVar4,uVar11,iVar9);
									*(char *)(iVar2 + (uVar11 * iVar9 + uVar4) * 0x28 + 0x1a) = (char)uVar3;
									pfVar1 = (float *)(surfMap->field_28 + 0x1c +
																		(uVar11 * out_width->width + uVar4) * 0x28);
									fVar15 = math::Maths_RandRange(0.0,1.0);
									*pfVar1 = (float)fVar15;
									fVar15 = math::Maths_RandRange(0.0,1.0);
									fVar16 = (float10)1.0 /
													 SQRT((float10)*pfVar1 * (float10)*pfVar1 + fVar15 * fVar15);
									*pfVar1 = (float)(fVar16 * (float10)*pfVar1);
									pfVar1[1] = (float)(fVar16 * fVar15);
									iVar9 = uVar11 * out_width->width + uVar4;
									pfVar1 = (float *)(surfMap->field_28 + 0x1c + iVar9 * 0x28);
									*pfVar1 = *(float *)(surfMap->field_28 + 0x1c + iVar9 * 0x28) * 0.3;
									pfVar1[1] = pfVar1[1] * 0.3;
									iVar9 = uVar11 * out_width->width + uVar4;
									uVar4 = uVar4 + 1;
									*(undefined *)(surfMap->field_28 + 0x24 + iVar9 * 0x28) = 0;
									uVar10 = out_width->width;
								} while (uVar4 < uVar10);
							}
							uVar11 = uVar11 + 1;
						} while (uVar11 < (uint)(surfMap->dimensions).height);
					}
					SurfaceMap_FUN_0044e790(surfMap);
					filename = (char *)0x0;
					if ((surfMap->smallDimensions).height != 0) {
						do {
							blockSize = 0.0;
							if ((surfMap->smallDimensions).width != 0) {
								do {
									iVar9 = surfMap->field_28 +
													((int)filename * out_width->width + (int)blockSize) * 0x28;
									iVar2 = surfMap->field_28 +
													((int)(filename + 1) * out_width->width + (int)blockSize) * 0x28;
									uVar11 = (uint)*(byte *)(iVar9 + 0x1a) - (uint)*(byte *)(iVar2 + 0x42);
									uVar14 = (uint)*(byte *)(iVar9 + 0x42) - (uint)*(byte *)(iVar2 + 0x1a);
									uVar10 = (int)uVar11 >> 0x1f;
									uVar4 = (int)uVar14 >> 0x1f;
									if ((uVar11 ^ uVar10) - uVar10 < (uVar14 ^ uVar4) - uVar4) {
										SurfaceMap_FUN_0044f0b0(surfMap,(uint)blockSize,(uint)filename,1);
									}
									else {
										SurfaceMap_FUN_004517b0(surfMap,(uint)blockSize,(uint)filename);
									}
									blockSize = (float)((int)blockSize + 1);
								} while ((uint)blockSize < (uint)(surfMap->smallDimensions).width);
							}
							filename = filename + 1;
						} while (filename < (char *)(surfMap->smallDimensions).height);
					}
					std::free(mapFileInfo);
					return surfMap;
				}
				res::Container_Remove(surfMap->resData_24);
			}
			std::free(surfMap);
		}
		std::free(mapFileInfo);
	}
	return (SurfaceMap *)0x0;
}



void __cdecl lego::game::SurfaceMap_FUN_0044e790(SurfaceMap *surfMap)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	int iVar6;
	float *pfVar7;
	float *pfVar8;
	float10 fVar9;
	float10 extraout_ST0;
	longlong lVar10;
	longlong lVar11;
	uint local_d8;
	uint local_d4;
	int local_d0;
	float local_b0 [5];
	undefined4 local_9c;
	undefined4 local_98;
	undefined4 local_94;
	D3DRMVertex local_90 [4];
	
	local_b0[0] = 0.0;
	fVar5 = surfMap->RoughLevel;
	local_b0[1] = 0.0;
	local_b0[2] = 1.0;
	local_b0[3] = 0.0;
	local_b0[4] = 1.0;
	local_9c = 0x3f800000;
	local_98 = 0;
	local_94 = 0x3f800000;
	local_d8 = 0;
	if ((surfMap->smallDimensions).height != 0) {
		do {
			local_d4 = 0;
			if ((surfMap->smallDimensions).width != 0) {
				do {
					pfVar7 = local_b0;
					fVar9 = (float10)(ulonglong)local_d4;
					pfVar8 = &local_90[0].position.y;
					local_d0 = 4;
					do {
						fVar1 = pfVar7[1];
						fVar2 = surfMap->BlockSize;
						fVar3 = pfVar7[1];
						fVar4 = (surfMap->blockDimensions_neg).height;
						pfVar8[-1] = (float)((fVar9 + (float10)*pfVar7) * (float10)surfMap->BlockSize +
																(float10)(surfMap->blockDimensions_neg).width);
						*pfVar8 = fVar4 - (fVar1 + (float)(ulonglong)local_d8) * fVar2;
						lVar10 = __ftol((float10)fVar3);
						iVar6 = (surfMap->dimensions).width;
						lVar11 = __ftol((float10)*pfVar7);
						fVar2 = -((float)(uint)*(byte *)(surfMap->field_28 + 0x1a +
																						((local_d8 + (int)lVar10) * iVar6 + local_d4 +
																						(int)lVar11) * 0x28) * fVar5);
						fVar1 = surfMap->float_20;
						pfVar8[1] = fVar2;
						if (fVar2 < fVar1) {
							surfMap->float_20 = fVar2;
						}
						pfVar7 = pfVar7 + 2;
						pfVar8 = pfVar8 + 9;
						local_d0 = local_d0 + -1;
						fVar9 = extraout_ST0;
					} while (local_d0 != 0);
					res::Container_Mesh_SetVertices
										(surfMap->resData_24,local_d8 * (surfMap->smallDimensions).width + local_d4,0,4,
										 local_90);
					local_d4 = local_d4 + 1;
				} while (local_d4 < (uint)(surfMap->smallDimensions).width);
			}
			local_d8 = local_d8 + 1;
		} while (local_d8 < (uint)(surfMap->smallDimensions).height);
	}
	return;
}



void __cdecl lego::game::SurfaceMap_Free(SurfaceMap *surfMap)
{
	res::Container_Remove(surfMap->resData_24);
	res::Container_Remove(surfMap->resData_73cc);
	std::free((void *)surfMap->field_28);
	std::free(surfMap);
	return;
}



void __cdecl lego::game::SurfaceMap_SetArray40B4_IndexToTrue(SurfaceMap *surfMap,uint index)
{
	surfMap->flat_40b4[index & 0xff] = 1;
	return;
}



void __cdecl
lego::game::SurfaceMap_FadeInBlock(SurfaceMap *surfMap,int x,int y,uint param_4,uint param_5)
{
	byte bVar1;
	uint uVar2;
	float *pfVar3;
	Container_Texture *ref_itext;
	float *pfVar4;
	int iVar5;
	SurfaceMapStruct38 *pSVar6;
	uint local_a8;
	undefined4 local_a4;
	undefined4 local_a0;
	undefined4 local_9c;
	undefined4 local_98;
	undefined4 local_94;
	D3DRMVertex local_90 [4];
	
	local_a4 = 1;
	local_9c = 1;
	iVar5 = (surfMap->smallDimensions).width;
	local_a8 = 0;
	local_a0 = 3;
	local_98 = 2;
	local_94 = 3;
	bVar1 = *(byte *)(surfMap->field_28 + 0x18 + (y * (surfMap->dimensions).width + x) * 0x28);
	if ((bVar1 != (byte)param_4) && (surfMap->flat_40b4[bVar1] == 0)) {
		uVar2 = 0;
		pSVar6 = surfMap->table38_719c;
		do {
			if ((*(byte *)&pSVar6->flags & 1) == 0) {
				if (pSVar6->field_0 == D3DRMGROUP_ALLGROUPS) {
					uVar2 = res::Container_Mesh_AddGroup(surfMap->resData_73cc,4,2,3,&local_a8);
					pSVar6->field_0 = uVar2;
				}
				else {
					res::Container_Mesh_HideGroup(surfMap->resData_73cc,pSVar6->field_0,0);
				}
				res::Container_Mesh_GetVertices(surfMap->resData_24,y * iVar5 + x,0,4,local_90);
				pfVar4 = (float *)(pSVar6->table_10 + 1);
				iVar5 = 4;
				pfVar3 = &local_90[0].tv;
				do {
					pfVar4[-1] = pfVar3[-1];
					*pfVar4 = *pfVar3;
					pfVar4 = pfVar4 + 2;
					iVar5 = iVar5 + -1;
					pfVar3 = pfVar3 + 9;
				} while (iVar5 != 0);
				ref_itext = (Container_Texture *)
										FUN_0040b780((int *)surfMap->field_2c,
																 (uint)pfVar4 & 0xffffff00 |
																 (uint)*(byte *)(surfMap->field_28 + 0x18 +
																								(y * (surfMap->dimensions).width + x) * 0x28));
				res::Container_Mesh_SetTexture(surfMap->resData_73cc,pSVar6->field_0,ref_itext);
				pSVar6->field_8 = x;
				pSVar6->field_c = y;
				pSVar6->float_4 = 0.05;
				pSVar6->flags = pSVar6->flags | 1;
				break;
			}
			uVar2 = uVar2 + 1;
			pSVar6 = pSVar6 + 1;
		} while (uVar2 < 10);
	}
	SurfaceMap_UpdateBlockVisual(surfMap,x,y,param_4,param_5);
	return;
}



BOOL __cdecl lego::game::SurfaceMap_FUN_0044eb20(SurfaceMap *surfMap,int x,int y)
{
	BOOL BVar1;
	
	BVar1 = res::Container_Mesh_IsGroupHidden
										(surfMap->resData_24,(surfMap->smallDimensions).width * y + x);
	return BVar1;
}



void __cdecl lego::game::SurfaceMap_FUN_0044eb40(SurfaceMap *surfMap)
{
	uint y;
	uint x;
	
	y = 0;
	if ((surfMap->dimensions).height != 0) {
		do {
			x = 0;
			if ((surfMap->dimensions).width != 0) {
				do {
					SurfaceMap_FUN_004511f0(surfMap,x,y);
					x = x + 1;
				} while (x < (uint)(surfMap->dimensions).width);
			}
			y = y + 1;
		} while (y < (uint)(surfMap->dimensions).height);
	}
	return;
}



BOOL __cdecl
lego::game::SurfaceMap_FUN_0044eb80
					(SurfaceMap *surfMap,uint *param_2,uint param_3,float buildTolerance,
					float buildMaxVariation)
{
	bool bVar1;
	int *piVar2;
	uint *puVar3;
	uint uVar4;
	float *pfVar5;
	float local_9c;
	float local_98;
	int local_90;
	uint local_8c;
	int local_80 [5];
	undefined4 local_6c;
	undefined4 local_68;
	undefined4 local_64;
	int local_60 [5];
	undefined4 local_4c;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40;
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	undefined4 local_30 [2];
	float local_28 [10];
	
	local_4c = 3;
	local_3c = 3;
	local_34 = 3;
	local_80[0] = 0;
	local_80[1] = 0;
	local_80[2] = 1;
	local_80[3] = 0;
	local_80[4] = 1;
	local_6c = 1;
	local_68 = 0;
	local_64 = 1;
	local_60[0] = 0;
	local_60[1] = 1;
	local_60[2] = 0;
	local_60[3] = 2;
	local_60[4] = 0;
	local_48 = 1;
	local_44 = 2;
	local_40 = 1;
	local_38 = 2;
	bVar1 = false;
	local_98 = 10000.0;
	local_9c = -10000.0;
	local_8c = 0;
	if (param_3 != 0) {
		puVar3 = param_2 + 2;
		do {
			if (((local_8c == param_3 - 1) || (*param_2 != *puVar3)) || (param_2[1] != puVar3[1])) {
				SurfaceMap_FillStruct30_FUN_00450390(surfMap,*param_2,param_2[1],local_30);
				uVar4 = 0;
				piVar2 = local_60 + 1;
				do {
					if (buildMaxVariation < ABS(local_28[piVar2[-1] * 3] - local_28[*piVar2 * 3])) {
						return 0;
					}
					uVar4 = uVar4 + 1;
					piVar2 = piVar2 + 2;
				} while (uVar4 < 6);
				pfVar5 = local_28;
				piVar2 = local_80;
				local_90 = 4;
				do {
					if ((*(byte *)(surfMap->field_28 + 0x19 +
												((piVar2[1] + param_2[1]) * (surfMap->dimensions).width + *piVar2 + *param_2
												) * 0x28) & 8) != 0) {
						if (*pfVar5 < local_98) {
							local_98 = *pfVar5;
						}
						if ((ushort)((ushort)(*pfVar5 < local_9c) << 8 | (ushort)(*pfVar5 == local_9c) << 0xe)
								== 0) {
							local_9c = *pfVar5;
						}
						bVar1 = true;
					}
					piVar2 = piVar2 + 2;
					pfVar5 = pfVar5 + 3;
					local_90 = local_90 + -1;
				} while (local_90 != 0);
			}
			else {
				local_8c = local_8c + 1;
				puVar3 = puVar3 + 2;
				param_2 = param_2 + 2;
			}
			local_8c = local_8c + 1;
			puVar3 = puVar3 + 2;
			param_2 = param_2 + 2;
		} while (local_8c < param_3);
	}
	if ((bVar1) &&
		 ((ushort)((ushort)(local_9c - local_98 < buildTolerance) << 8 |
							(ushort)(local_9c - local_98 == buildTolerance) << 0xe) == 0)) {
		return 0;
	}
	return 1;
}



void __cdecl
lego::game::SurfaceMap_FUN_0044ed90(SurfaceMap *surfMap,uint *param_2,uint param_3,float param_4)
{
	int iVar1;
	float *pfVar2;
	int iVar3;
	float fVar4;
	float fVar5;
	int *piVar6;
	int iVar7;
	int *piVar8;
	uint *puVar9;
	uint uVar10;
	uint *puVar11;
	float local_230;
	int *local_22c;
	uint local_228;
	uint local_224;
	uint local_220;
	uint local_218;
	float local_214;
	undefined4 *local_210;
	int local_200 [5];
	undefined4 local_1ec;
	undefined4 local_1e8;
	undefined4 local_1e4;
	undefined4 local_1e0 [2];
	float afStack472 [118];
	
	fVar4 = param_4 * 0.5;
	local_200[2] = 1;
	local_200[4] = 1;
	local_1ec = 1;
	local_1e4 = 1;
	local_224 = 0;
	local_228 = 0;
	local_230 = 0.0;
	local_200[0] = 0;
	local_200[1] = 0;
	local_200[3] = 0;
	local_1e8 = 0;
	local_214 = 10000.0;
	local_22c = (int *)0xc61c4000;
	local_220 = 0;
	local_218 = 0;
	if (param_3 != 0) {
		local_210 = local_1e0;
		puVar9 = param_2 + 2;
		puVar11 = &DAT_004ebed0;
		do {
			if (((local_218 == param_3 - 1) || (*param_2 != *puVar9)) || (param_2[1] != puVar9[1])) {
				*puVar11 = *param_2;
				uVar10 = param_2[1];
				puVar11[1] = uVar10;
				SurfaceMap_FillStruct30_FUN_00450390(surfMap,*puVar11,uVar10,local_210);
				uVar10 = 0;
				piVar8 = local_200;
				do {
					iVar3 = uVar10 + local_220 * 4;
					if ((*(byte *)(surfMap->field_28 + 0x19 +
												((piVar8[1] + puVar11[1]) * (surfMap->dimensions).width + *puVar11 + *piVar8
												) * 0x28) & 8) == 0) {
						local_230 = afStack472[iVar3 * 3] + local_230;
						local_224 = local_224 + 1;
					}
					else {
						pfVar2 = afStack472 + iVar3 * 3;
						if (afStack472[iVar3 * 3] < local_214) {
							local_214 = *pfVar2;
						}
						if ((ushort)((ushort)(*pfVar2 < (float)local_22c) << 8 |
												(ushort)(*pfVar2 == (float)local_22c) << 0xe) == 0) {
							local_22c = (int *)*pfVar2;
						}
						local_228 = local_228 + 1;
					}
					uVar10 = uVar10 + 1;
					piVar8 = piVar8 + 2;
				} while (uVar10 < 4);
				local_220 = local_220 + 1;
				local_210 = local_210 + 0xc;
				puVar11 = puVar11 + 2;
			}
			else {
				local_218 = local_218 + 1;
				puVar9 = puVar9 + 2;
				param_2 = param_2 + 2;
			}
			local_218 = local_218 + 1;
			puVar9 = puVar9 + 2;
			param_2 = param_2 + 2;
		} while (local_218 < param_3);
	}
	local_230 = local_230 / (float)(ulonglong)local_224;
	if (local_228 != 0) {
		if ((ushort)((ushort)(fVar4 + local_230 < (float)local_22c) << 8 |
								(ushort)(fVar4 + local_230 == (float)local_22c) << 0xe) == 0) {
			local_230 = (float)local_22c - fVar4;
		}
		if (local_230 - fVar4 < local_214) {
			local_230 = fVar4 + local_214;
		}
	}
	local_218 = 0;
	if (local_220 != 0) {
		local_22c = &DAT_004ebed0;
		do {
			local_228 = 0;
			piVar8 = local_22c + 1;
			piVar6 = local_200;
			do {
				iVar3 = piVar6[1];
				iVar7 = *piVar6;
				if ((*(byte *)(surfMap->field_28 + 0x19 +
											((iVar3 + *piVar8) * (surfMap->dimensions).width + *local_22c + iVar7) * 0x28)
						& 8) == 0) {
					iVar1 = local_228 + local_218 * 4;
					fVar5 = afStack472[iVar1 * 3] - local_230;
					if (fVar4 < ABS(fVar5)) {
						SurfaceMap_Unk_ChangeWallDepth
											(surfMap,*local_22c + iVar7,*piVar8 + iVar3,
											 ((fVar5 / fVar5) * fVar4 + local_230) - afStack472[iVar1 * 3]);
					}
					iVar7 = (*piVar8 + iVar3) * (surfMap->dimensions).width + *local_22c + iVar7;
					*(byte *)(surfMap->field_28 + 0x19 + iVar7 * 0x28) =
							 *(byte *)(surfMap->field_28 + 0x19 + iVar7 * 0x28) | 8;
				}
				local_228 = local_228 + 1;
				piVar6 = piVar6 + 2;
			} while (local_228 < 4);
			local_218 = local_218 + 1;
			local_22c = local_22c + 2;
		} while (local_218 < local_220);
	}
	return;
}



void __cdecl lego::game::SurfaceMap_FUN_0044f0b0(SurfaceMap *surfMap,uint x,uint y,BOOL condition)
{
	byte *pbVar1;
	byte bVar2;
	int iVar3;
	D3DRMGroupIndex groupID;
	float *pfVar4;
	D3DRMVertex *pDVar5;
	float *pfVar6;
	D3DRMVertex local_b4;
	float local_90 [9];
	float local_6c [9];
	D3DRMVertex local_48;
	float local_24 [9];
	
	if (((condition != 0) &&
			((*(byte *)(surfMap->field_28 + 0x19 + (y * (surfMap->dimensions).width + x) * 0x28) & 1) == 0
			)) || ((condition == 0 &&
						 ((*(byte *)(surfMap->field_28 + 0x19 + (y * (surfMap->dimensions).width + x) * 0x28) &
							1) != 0)))) {
		groupID = (surfMap->smallDimensions).width * y + x;
		res::Container_Mesh_GetVertices(surfMap->resData_24,groupID,0,4,&local_b4);
		iVar3 = y * (surfMap->dimensions).width + x;
		bVar2 = *(byte *)(surfMap->field_28 + 0x19 + iVar3 * 0x28);
		pbVar1 = (byte *)(surfMap->field_28 + 0x19 + iVar3 * 0x28);
		if ((bVar2 & 1) == 0) {
			*pbVar1 = bVar2 | 1;
			pDVar5 = &local_48;
			pfVar4 = local_24;
			for (iVar3 = 9; iVar3 != 0; iVar3 = iVar3 + -1) {
				*pfVar4 = (pDVar5->position).x;
				pDVar5 = (D3DRMVertex *)&(pDVar5->position).y;
				pfVar4 = pfVar4 + 1;
			}
			pfVar4 = local_6c;
			pDVar5 = &local_48;
			for (iVar3 = 9; iVar3 != 0; iVar3 = iVar3 + -1) {
				(pDVar5->position).x = *pfVar4;
				pfVar4 = pfVar4 + 1;
				pDVar5 = (D3DRMVertex *)&(pDVar5->position).y;
			}
			pfVar4 = local_90;
			pfVar6 = local_6c;
			for (iVar3 = 9; iVar3 != 0; iVar3 = iVar3 + -1) {
				*pfVar6 = *pfVar4;
				pfVar4 = pfVar4 + 1;
				pfVar6 = pfVar6 + 1;
			}
			pDVar5 = &local_b4;
			pfVar4 = local_90;
			for (iVar3 = 9; iVar3 != 0; iVar3 = iVar3 + -1) {
				*pfVar4 = (pDVar5->position).x;
				pDVar5 = (D3DRMVertex *)&(pDVar5->position).y;
				pfVar4 = pfVar4 + 1;
			}
			pDVar5 = &local_b4;
		}
		else {
			*pbVar1 = bVar2 & 0xfe;
			pDVar5 = &local_b4;
			pfVar4 = local_24;
			for (iVar3 = 9; iVar3 != 0; iVar3 = iVar3 + -1) {
				*pfVar4 = (pDVar5->position).x;
				pDVar5 = (D3DRMVertex *)&(pDVar5->position).y;
				pfVar4 = pfVar4 + 1;
			}
			pfVar4 = local_90;
			pDVar5 = &local_b4;
			for (iVar3 = 9; iVar3 != 0; iVar3 = iVar3 + -1) {
				(pDVar5->position).x = *pfVar4;
				pfVar4 = pfVar4 + 1;
				pDVar5 = (D3DRMVertex *)&(pDVar5->position).y;
			}
			pfVar4 = local_6c;
			pfVar6 = local_90;
			for (iVar3 = 9; iVar3 != 0; iVar3 = iVar3 + -1) {
				*pfVar6 = *pfVar4;
				pfVar4 = pfVar4 + 1;
				pfVar6 = pfVar6 + 1;
			}
			pDVar5 = &local_48;
			pfVar4 = local_6c;
			for (iVar3 = 9; iVar3 != 0; iVar3 = iVar3 + -1) {
				*pfVar4 = (pDVar5->position).x;
				pDVar5 = (D3DRMVertex *)&(pDVar5->position).y;
				pfVar4 = pfVar4 + 1;
			}
			pDVar5 = &local_48;
		}
		pfVar4 = local_24;
		for (iVar3 = 9; iVar3 != 0; iVar3 = iVar3 + -1) {
			(pDVar5->position).x = *pfVar4;
			pfVar4 = pfVar4 + 1;
			pDVar5 = (D3DRMVertex *)&(pDVar5->position).y;
		}
		res::Container_Mesh_SetVertices(surfMap->resData_24,groupID,0,4,&local_b4);
		SurfaceMap_FUN_004517b0(surfMap,x,y);
										// Perform action in a square: { { 0, 0 }, { 1, 0 },
										//                               { 0, 1 }, { 1, 1 } }
		SurfaceMap_FUN_0044f270(surfMap,x,y);
		SurfaceMap_FUN_0044f270(surfMap,x + 1,y);
		SurfaceMap_FUN_0044f270(surfMap,x + 1,y + 1);
		SurfaceMap_FUN_0044f270(surfMap,x,y + 1);
	}
	return;
}



void __cdecl lego::game::SurfaceMap_FUN_0044f270(SurfaceMap *surfMap,int x,int y)
{
	byte *pbVar1;
	
	pbVar1 = (byte *)(surfMap->field_28 + 0x19 + ((surfMap->dimensions).width * y + x) * 0x28);
	*pbVar1 = *pbVar1 | 4;
	surfMap->field_73d0 = surfMap->field_73d0 | 2;
	return;
}



void __cdecl lego::game::SurfaceMap_FUN_0044f2b0(SurfaceMap *surfMap,float param_2)
{
	int iVar1;
	uint uVar2;
	uint y;
	uint x;
	
	if ((*(byte *)&surfMap->field_73d0 & 2) != 0) {
		y = 0;
		if ((surfMap->dimensions).height != 0) {
			do {
				uVar2 = (surfMap->dimensions).width;
				x = 0;
				if (uVar2 != 0) {
					do {
						if ((*(byte *)(surfMap->field_28 + 0x19 + (y * uVar2 + x) * 0x28) & 4) != 0) {
							SurfaceMap_FUN_004511f0(surfMap,x,y);
							iVar1 = y * (surfMap->dimensions).width + x;
							*(byte *)(surfMap->field_28 + 0x19 + iVar1 * 0x28) =
									 *(byte *)(surfMap->field_28 + 0x19 + iVar1 * 0x28) & 0xfb;
						}
						uVar2 = (surfMap->dimensions).width;
						x = x + 1;
					} while (x < uVar2);
				}
				y = y + 1;
			} while (y < (uint)(surfMap->dimensions).height);
		}
		surfMap->field_73d0 = surfMap->field_73d0 & 0xfffffffd;
	}
	SurfaceMap_FUN_00450e20(surfMap,param_2);
	SurfaceMap_FUN_0044f350(surfMap,param_2);
	return;
}



void __cdecl lego::game::SurfaceMap_FUN_0044f350(SurfaceMap *surfMap,float param_2)
{
	float fVar1;
	float *pfVar2;
	float *pfVar3;
	int iVar4;
	int iVar5;
	float *pfVar6;
	D3DRMVertex local_90 [4];
	
	iVar5 = 10;
	pfVar6 = (float *)&surfMap->table38_719c[0].field_c;
	do {
		if ((*(byte *)(pfVar6 + 10) & 1) != 0) {
			res::Container_Mesh_GetVertices
								(surfMap->resData_24,
								 (surfMap->smallDimensions).width * (int)*pfVar6 + (int)pfVar6[-1],0,4,local_90);
			pfVar3 = &local_90[0].tv;
			iVar4 = 4;
			pfVar2 = pfVar6;
			do {
				pfVar3[-1] = pfVar2[1];
				*pfVar3 = pfVar2[2];
				pfVar3 = pfVar3 + 9;
				iVar4 = iVar4 + -1;
				pfVar2 = pfVar2 + 2;
			} while (iVar4 != 0);
			res::Container_Mesh_SetVertices
								(surfMap->resData_73cc,(D3DRMGroupIndex)pfVar6[-3],0,4,local_90);
			res::Container_Mesh_SetColourAlpha
								(surfMap->resData_73cc,(D3DRMGroupIndex)pfVar6[-3],1.0,1.0,1.0,1.0 - pfVar6[-2]);
			fVar1 = pfVar6[-2] - param_2 * -0.04;
			pfVar6[-2] = fVar1;
			if ((ushort)((ushort)(fVar1 < 1.0) << 8 | (ushort)(fVar1 == 1.0) << 0xe) == 0) {
				res::Container_Mesh_HideGroup(surfMap->resData_73cc,(D3DRMGroupIndex)pfVar6[-3],1);
				pfVar6[10] = (float)((uint)pfVar6[10] & 0xfffffffe);
			}
		}
		pfVar6 = pfVar6 + 0xe;
		iVar5 = iVar5 + -1;
	} while (iVar5 != 0);
	return;
}



void __cdecl
lego::game::SurfaceMap_AddTextureCoordMapping
					(SurfaceMap *surfMap,SurfaceTexture texA,SurfaceTexture texB)
{
	uint texNum;
	uint i;
	uint texId;
	
	texId = (uint)texA;
	i = 0;
	texNum = (uint)surfMap->texsNum[texId];
										// check if mapping has already been created. If so, end operation
	if (texNum != 0) {
		do {
										// mapping already exists at index?
			if (surfMap->texsGrid[texId][i] == texB) {
				return;
			}
			i = i + 1;
		} while (i < texNum);
	}
										// mapping not found, add texB to end of texA[] list
	surfMap->texsGrid[texId][texNum] = texB;
	surfMap->texsNum[texId] = surfMap->texsNum[texId] + 1;
										// now create the reverse mapping, add texA to end of texB[] list
	texId = (uint)texB;
	surfMap->texsGrid[texId][surfMap->texsNum[texId]] = texA;
	surfMap->texsNum[texId] = surfMap->texsNum[texId] + 1;
	return;
}



void __cdecl lego::game::SurfaceMap_SetField_2c(SurfaceMap *surfMap,undefined4 field2c)
{
	surfMap->field_2c = field2c;
	return;
}



void __cdecl
lego::game::SurfaceMap_UpdateBlockVisual
					(SurfaceMap *surfMap,uint x,uint y,uint param_4,uint param_5)
{
	byte bVar1;
	Container_Texture *ref_itext;
	uint uVar2;
	D3DRMGroupIndex groupID;
	float *pfVar3;
	byte local_94 [4];
	D3DRMVertex local_90 [4];
	
	uVar2 = (surfMap->smallDimensions).width;
	if ((x < uVar2) && (y < (uint)(surfMap->smallDimensions).height)) {
		groupID = y * uVar2 + x;
		local_94[0] = 1;
		local_94[1] = 3;
		local_94[2] = 2;
		local_94[3] = 0;
		ref_itext = (Container_Texture *)FUN_0040b780((int *)surfMap->field_2c,param_4);
		*(undefined *)(surfMap->field_28 + 0x18 + (y * (surfMap->dimensions).width + x) * 0x28) =
				 (undefined)param_4;
		if ((*(byte *)(surfMap->field_28 + 0x19 + (y * (surfMap->dimensions).width + x) * 0x28) & 1) !=
				0) {
			param_5 = (uint)(byte)((char)param_5 + 1);
		}
		res::Container_Mesh_SetTexture(surfMap->resData_24,groupID,ref_itext);
		if ((*(byte *)(surfMap->field_28 + 0x19 + (y * (surfMap->dimensions).width + x) * 0x28) & 0x10)
				== 0) {
			res::Container_Mesh_GetVertices(surfMap->resData_24,groupID,0,4,local_90);
			uVar2 = 0;
			pfVar3 = &local_90[0].tv;
			do {
				bVar1 = local_94[uVar2 - (param_5 & 0xff) & 3];
				uVar2 = uVar2 + 1;
				pfVar3[-1] = (float)(uint)(bVar1 >> 1);
				*pfVar3 = (float)(uint)(bVar1 & 1);
				pfVar3 = pfVar3 + 9;
			} while (uVar2 < 4);
			res::Container_Mesh_SetVertices(surfMap->resData_24,groupID,0,4,local_90);
		}
	}
	return;
}



void __cdecl
lego::game::SurfaceMap_Unk_ChangeWallDepth(SurfaceMap *surfMap,uint x,uint y,float digDepth)
{
	float *pfVar1;
	uint uVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	longlong lVar6;
	float *pfVar7;
	float local_2c;
	undefined4 uStack40;
	float local_24;
	float local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar4 = 0;
	local_24 = digDepth;
	local_20[0] = 0.0;
	local_20[1] = 0.0;
	local_20[2] = -1.0;
	local_20[3] = 0.0;
	local_20[4] = -1.0;
	local_c = 0xbf800000;
	local_8 = 0;
	local_4 = 0xbf800000;
	local_2c = 0.0;
	uStack40 = 0;
	iVar3 = 4;
	pfVar1 = local_20 + 1;
	do {
		iVar3 = iVar3 + -1;
		pfVar1[-1] = (float)(ulonglong)x + pfVar1[-1];
		*pfVar1 = *pfVar1 + (float)(ulonglong)y;
		pfVar1 = pfVar1 + 2;
	} while (iVar3 != 0);
	pfVar1 = local_20;
	do {
		pfVar7 = &local_2c;
		uVar5 = uVar4;
		lVar6 = __ftol((float10)pfVar1[1]);
		uVar2 = (uint)lVar6;
		lVar6 = __ftol((float10)*pfVar1);
		SurfaceMap_FUN_00451710(surfMap,(uint)lVar6,uVar2,uVar5,pfVar7);
		uVar4 = uVar4 + 1;
		pfVar1 = pfVar1 + 2;
	} while (uVar4 < 4);
	for (uVar4 = y - 1; uVar4 <= y; uVar4 = uVar4 + 1) {
		for (uVar5 = x - 1; uVar5 <= x; uVar5 = uVar5 + 1) {
			SurfaceMap_FUN_004517b0(surfMap,uVar5,uVar4);
		}
	}
	return;
}



void __cdecl lego::game::SurfaceMap_FUN_0044f750(SurfaceMap *surfMap,int param_2)
{
	uint uVar1;
	uint uVar2;
	uint uVar3;
	
	uVar2 = 0;
	if ((surfMap->smallDimensions).height != 0) {
		do {
			uVar1 = (surfMap->smallDimensions).width;
			uVar3 = 0;
			if (uVar1 != 0) {
				do {
					res::Container_Mesh_SetPerspectiveCorrection
										(surfMap->resData_24,uVar2 * uVar1 + uVar3,param_2);
					uVar1 = (surfMap->smallDimensions).width;
					uVar3 = uVar3 + 1;
				} while (uVar3 < uVar1);
			}
			uVar2 = uVar2 + 1;
		} while (uVar2 < (uint)(surfMap->smallDimensions).height);
	}
	return;
}



uint __cdecl lego::game::SurfaceMap_FUN_0044f7a0(SurfaceMap *surfMap,int x,int y,int index)
{
	byte bVar1;
	int iVar2;
	
	iVar2 = (surfMap->dimensions).width * y + x;
	bVar1 = *(byte *)(surfMap->field_28 + 0x24 + iVar2 * 0x28);
	*(char *)(surfMap->field_28 + 0x24 + iVar2 * 0x28) = (char)index;
	SurfaceMap_FUN_0044f880
						(surfMap,x,y,1,(&FLOAT_004a62c0)[index * 3],(&FLOAT_004a62c4)[index * 3],
						 (&FLOAT_004a62c8)[index * 3]);
	return (uint)bVar1;
}



uint __cdecl lego::game::SurfaceMap_FUN_0044f800(SurfaceMap *surfMap,int x,int y)
{
	return (uint)*(byte *)(surfMap->field_28 + 0x24 + ((surfMap->dimensions).width * y + x) * 0x28);
}



void __cdecl lego::game::SurfaceMap_FUN_0044f830(SurfaceMap *surfMap,int param_2,int param_3)
{
	SurfaceMap_FUN_0044f880(surfMap,param_2,param_3,0,1.0,1.0,1.0);
	*(undefined *)
	 (surfMap->field_28 + 0x24 + ((surfMap->dimensions).width * param_3 + param_2) * 0x28) = 0;
	return;
}



void __cdecl
lego::game::SurfaceMap_FUN_0044f880
					(SurfaceMap *surfMap,int param_2,int param_3,int param_4,float param_5,float param_6,
					float param_7)
{
	D3DRMGroupIndex groupID;
	
	groupID = (surfMap->smallDimensions).width * param_3 + param_2;
	if (param_4 != 0) {
		res::Container_Mesh_SetColourAlpha(surfMap->resData_24,groupID,param_5,param_6,param_7,1.0);
		return;
	}
	res::Container_Mesh_SetColourAlpha(surfMap->resData_24,groupID,1.0,1.0,1.0,1.0);
	*(undefined *)
	 (surfMap->field_28 + 0x24 + ((surfMap->dimensions).width * param_3 + param_2) * 0x28) = 0;
	return;
}



BOOL __cdecl
lego::game::SurfaceMap_FUN_0044f900(SurfaceMap *surfMap,uint x,uint y,float *out_x,float *out_y)
{
	if ((x < (uint)(surfMap->smallDimensions).width) && (y < (uint)(surfMap->smallDimensions).height))
	{
		*out_x = surfMap->BlockSize * 0.5 +
						 (float)(ulonglong)x * surfMap->BlockSize + (surfMap->blockDimensions_neg).width;
		*out_y = (surfMap->blockDimensions_neg).height -
						 (surfMap->BlockSize * 0.5 + (float)(ulonglong)y * surfMap->BlockSize);
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::game::SurfaceMap_ToBlockCoordinatesNoZ
					(SurfaceMap *surfMap,float in_x,float in_y,int *out_x,int *out_y)
{
	BOOL BVar1;
	
										// The final argument here ((float *)&out_y) is a dummy argument that won't
										// output the pointed-to value
	BVar1 = SurfaceMap_ToBlockCoordinates(surfMap,in_x,in_y,out_x,out_y,(float *)&out_y);
	return BVar1;
}



BOOL __cdecl
lego::game::SurfaceMap_ToBlockCoordinates
					(SurfaceMap *surfMap,float in_x,float in_y,int *out_x,int *out_y,float *out_unk_z)
{
	float fVar1;
	int iVar2;
	int iVar3;
	longlong lVar4;
	
	lVar4 = __ftol(((float10)in_x - (float10)(surfMap->blockDimensions_neg).width) /
								 (float10)surfMap->BlockSize);
	iVar2 = (int)lVar4;
	lVar4 = __ftol(((float10)(surfMap->blockDimensions_neg).height - (float10)in_y) /
								 (float10)surfMap->BlockSize);
	iVar3 = (int)lVar4;
	if (out_x != (int *)0x0) {
		*out_x = iVar2;
	}
	if (out_y != (int *)0x0) {
		*out_y = iVar3;
	}
	if ((((-1 < iVar2) && (iVar2 < (surfMap->smallDimensions).width)) && (-1 < iVar3)) &&
		 (iVar3 < (surfMap->smallDimensions).height)) {
		if (out_unk_z != (float *)0x0) {
			fVar1 = surfMap->BlockSize * 0.5;
			in_x = (in_x - ((float)iVar2 * surfMap->BlockSize + (surfMap->blockDimensions_neg).width)) /
						 fVar1;
			fVar1 = -((in_y - ((surfMap->blockDimensions_neg).height - (float)iVar3 * surfMap->BlockSize))
							 / fVar1);
			if ((ushort)((ushort)(in_x < 1.0) << 8 | (ushort)(in_x == 1.0) << 0xe) == 0) {
				in_x = 2.0 - in_x;
			}
			if ((ushort)((ushort)(fVar1 < 1.0) << 8 | (ushort)(fVar1 == 1.0) << 0xe) == 0) {
				fVar1 = 2.0 - fVar1;
			}
			if (in_x < fVar1) {
				fVar1 = in_x;
			}
			*out_unk_z = fVar1;
		}
		return 1;
	}
	return 0;
}



void __cdecl
lego::game::SurfaceMap_FUN_0044fad0(SurfaceMap *surfMap,float in_x,float in_y,int *out_x,int *out_y)
{
	int iVar1;
	int iVar2;
	int iVar3;
	longlong lVar4;
	
	lVar4 = __ftol(((float10)in_x - (float10)(surfMap->blockDimensions_neg).width) /
								 (float10)surfMap->BlockSize);
	iVar3 = (int)lVar4;
	lVar4 = __ftol(((float10)(surfMap->blockDimensions_neg).height - (float10)in_y) /
								 (float10)surfMap->BlockSize);
	iVar2 = (int)lVar4;
	if (iVar3 < 0) {
		iVar3 = 0;
	}
	iVar1 = (surfMap->smallDimensions).width;
	if (iVar1 <= iVar3) {
		iVar3 = iVar1 + -1;
	}
	if (iVar2 < 0) {
		iVar2 = 0;
	}
	iVar1 = (surfMap->smallDimensions).height;
	if (iVar1 <= iVar2) {
		iVar2 = iVar1 + -1;
	}
	if (out_x != (int *)0x0) {
		*out_x = iVar3;
	}
	if (out_y != (int *)0x0) {
		*out_y = iVar2;
	}
	return;
}



BOOL __cdecl
lego::game::SurfaceMap_FUN_0044fb30
					(SurfaceMap *surfMap,Point2F *param_2,Point2F *param_3,Point2F *param_4)
{
	float fVar1;
	Point2F *pPVar2;
	Point2F *pPVar3;
	BOOL BVar4;
	Point2F *local_8;
	float fStack4;
	SurfaceMap *surfMap_00;
	
	pPVar2 = param_2;
	surfMap_00 = surfMap;
	BVar4 = SurfaceMap_ToBlockCoordinatesNoZ
										(surfMap,param_2->x,param_2->y,(int *)&surfMap,(int *)&param_2);
	pPVar3 = param_4;
	if (BVar4 != 0) {
		if (param_3 != (Point2F *)0x0) {
			local_8 = param_2;
			fStack4 = 0.0;
			param_3->x = (float)ZEXT48(surfMap);
			param_3->y = (float)ZEXT48(param_2);
		}
		if (param_4 != (Point2F *)0x0) {
			SurfaceMap_FUN_0044f900(surfMap_00,(uint)surfMap,(uint)param_2,(float *)&local_8,&fStack4);
			pPVar3->x = pPVar2->x - (float)local_8;
			pPVar3->y = pPVar2->y - fStack4;
			fVar1 = 1.0 / surfMap_00->BlockSize;
			pPVar3->x = fVar1 * pPVar3->x - -0.5;
			pPVar3->y = fVar1 * pPVar3->y - -0.5;
		}
	}
	return 0;
}



float10 __cdecl lego::game::SurfaceMap_GetSurfaceZ(SurfaceMap *surfMap,float x,float y)
{
	SurfaceMap *surfMap_00;
	BOOL BVar1;
	float10 fVar2;
	uint local_38;
	float local_34;
	float local_30;
	float local_2c;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	float local_18;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	surfMap_00 = surfMap;
	local_34 = 0.0;
	BVar1 = SurfaceMap_ToBlockCoordinatesNoZ(surfMap,x,y,(int *)&local_38,(int *)&surfMap);
	if (BVar1 != 0) {
		BVar1 = SurfaceMap_FillStruct30_FUN_00450390(surfMap_00,local_38,(uint)surfMap,&local_30);
		if (BVar1 == 0) {
			if (surfMap_00->BlockSize <= (x - local_30) + (local_2c - y)) {
				local_28 = (local_4 - local_10) + (local_1c - local_10) + local_10;
			}
			else {
				local_10 = (local_4 - local_28) + (local_1c - local_28) + local_28;
			}
		}
		else {
			if (surfMap_00->BlockSize <= (local_24 - x) + (local_20 - y)) {
				local_1c = (local_10 - local_4) + (local_28 - local_4) + local_4;
			}
			else {
				local_4 = (local_10 - local_1c) + (local_28 - local_1c) + local_1c;
			}
		}
		fVar2 = ((float10)local_10 - (float10)local_4) *
						(((float10)local_18 - (float10)local_c) / ((float10)x - (float10)local_c)) +
						(float10)local_4;
		return (((float10)local_2c - (float10)local_8) / ((float10)y - (float10)local_8)) *
					 ((((float10)local_1c - (float10)local_28) *
						 (((float10)x - (float10)local_30) / ((float10)local_24 - (float10)local_30)) +
						(float10)local_28) - fVar2) + fVar2;
	}
	return (float10)local_34;
}



void __cdecl
lego::game::SurfaceMap_FUN_0044fd70(SurfaceMap *surfMap,float in_x,float in_y,Vector3F *out_vector)
{
	BOOL BVar1;
	int iVar2;
	float *pfVar3;
	uint local_34;
	float local_30;
	float local_2c;
	float local_24;
	float local_20;
	SurfaceMap *surfMap_00;
	
	surfMap_00 = surfMap;
	BVar1 = SurfaceMap_ToBlockCoordinatesNoZ(surfMap,in_x,in_y,(int *)&local_34,(int *)&surfMap);
	if (BVar1 == 0) {
		return;
	}
	BVar1 = SurfaceMap_FillStruct30_FUN_00450390(surfMap_00,local_34,(uint)surfMap,&local_30);
	if (BVar1 == 0) {
		iVar2 = (surfMap_00->dimensions).width;
		if ((local_2c - in_y) + (in_x - local_30) < surfMap_00->BlockSize) {
LAB_0044fe14:
			pfVar3 = (float *)(surfMap_00->field_28 + (iVar2 * (int)surfMap + local_34) * 0x28);
			goto LAB_0044fe28;
		}
	}
	else {
		iVar2 = (surfMap_00->dimensions).width;
		if (surfMap_00->BlockSize <= (local_20 - in_y) + (local_24 - in_x)) goto LAB_0044fe14;
	}
	pfVar3 = (float *)(surfMap_00->field_28 + 0xc + (iVar2 * (int)surfMap + local_34) * 0x28);
LAB_0044fe28:
	out_vector->x = *pfVar3;
	out_vector->y = pfVar3[1];
	out_vector->z = pfVar3[2];
	return;
}



BOOL __cdecl
lego::game::SurfaceMap_FUN_0044fe50
					(SurfaceMap *surfMap,float in_x,float in_y,BOOL condition,float unkMultiplier,float *out_x
					,float *out_y)
{
	float fVar1;
	float fVar2;
	SurfaceMap *surfMap_00;
	BOOL BVar3;
	float *pfVar4;
	int iVar5;
	int iVar6;
	uint local_68;
	Point2F local_64;
	Point2F local_5c;
	Point2F local_54;
	Point2F local_4c;
	Point2F local_44;
	float local_3c;
	float local_38;
	float local_34;
	float local_30 [12];
	
	surfMap_00 = surfMap;
	BVar3 = SurfaceMap_ToBlockCoordinatesNoZ(surfMap,in_x,in_y,(int *)&local_68,(int *)&surfMap);
	if (BVar3 == 0) {
		return 0;
	}
	BVar3 = SurfaceMap_FillStruct30_FUN_00450390(surfMap_00,local_68,(uint)surfMap,local_30);
	if (BVar3 == 0) {
		iVar5 = (surfMap_00->dimensions).width;
		if ((in_x - local_30[0]) + (local_30[1] - in_y) < surfMap_00->BlockSize) {
			pfVar4 = (float *)(surfMap_00->field_28 + (iVar5 * (int)surfMap + local_68) * 0x28);
			local_3c = *pfVar4;
			local_38 = pfVar4[1];
			local_34 = pfVar4[2];
			goto LAB_0044ff78;
		}
		pfVar4 = (float *)(surfMap_00->field_28 + 0xc + (iVar5 * (int)surfMap + local_68) * 0x28);
	}
	else {
		iVar5 = (surfMap_00->dimensions).width;
		if ((local_30[3] - in_x) + (local_30[4] - in_y) < surfMap_00->BlockSize) {
			pfVar4 = (float *)(surfMap_00->field_28 + 0xc + (iVar5 * (int)surfMap + local_68) * 0x28);
			local_3c = *pfVar4;
			local_38 = pfVar4[1];
			local_34 = pfVar4[2];
			goto LAB_0044ff78;
		}
		pfVar4 = (float *)(surfMap_00->field_28 + (iVar5 * (int)surfMap + local_68) * 0x28);
	}
	local_3c = *pfVar4;
	local_38 = pfVar4[1];
	local_34 = pfVar4[2];
LAB_0044ff78:
	if (condition == 0) {
		if (ABS(local_3c) <= ABS(local_38)) {
			if (0.0 <= local_38) {
				iVar5 = 0;
				iVar6 = 1;
			}
			else {
				iVar5 = 2;
				iVar6 = 3;
			}
		}
		else {
			if (0.0 <= local_3c) {
				iVar5 = 1;
				iVar6 = 2;
			}
			else {
				iVar5 = 0;
				iVar6 = 3;
			}
		}
	}
	else {
		if (BVar3 == 0) {
			iVar5 = 1;
			iVar6 = 3;
		}
		else {
			iVar5 = 0;
			iVar6 = 2;
		}
	}
	local_54.x = local_30[iVar5 * 3];
	local_54.y = local_30[iVar5 * 3 + 1];
	local_4c.x = in_x;
	local_5c.x = local_30[iVar6 * 3] - local_54.x;
	local_5c.y = local_30[iVar6 * 3 + 1] - local_54.y;
	local_4c.y = in_y;
	local_64.x = local_3c;
	local_64.y = local_38;
	math::Maths_Vector2DIntersection(&local_44,&local_54,&local_5c,&local_4c,&local_64);
	fVar2 = unkMultiplier * surfMap_00->BlockSize;
	fVar1 = 1.0 / SQRT(local_64.y * local_64.y + local_64.x * local_64.x);
	*out_x = local_44.x - fVar1 * local_64.x * fVar2;
	*out_y = local_44.y - fVar1 * local_64.y * fVar2;
	return 1;
}



float10 __cdecl lego::game::SurfaceMap_UnkCameraXYFunc_RetZunk(SurfaceMap *surfMap,float x,float y)
{
	SurfaceMap *pSVar1;
	BOOL BVar2;
	float *pfVar3;
	float *pfVar4;
	int iVar5;
	float10 fVar6;
	float10 extraout_ST0;
	longlong lVar7;
	uint local_68;
	int local_64;
	float local_60;
	undefined4 uStack92;
	float local_58;
	undefined4 uStack84;
	float local_50 [5];
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	float local_30;
	float local_2c;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	float local_18;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pSVar1 = surfMap;
	local_58 = 0.0;
	BVar2 = SurfaceMap_ToBlockCoordinatesNoZ(surfMap,x,y,(int *)&local_68,(int *)&surfMap);
	if (BVar2 != 0) {
		uStack92 = 0;
		local_58 = (float)local_68;
		fVar6 = (float10)ZEXT48(surfMap);
		uStack84 = 0;
		local_60 = (float)(ulonglong)local_68;
		local_50[0] = 0.0;
		local_50[1] = 0.0;
		local_50[2] = 1.0;
		local_50[3] = 0.0;
		local_50[4] = 1.0;
		local_3c = 0x3f800000;
		local_38 = 0;
		local_34 = 0x3f800000;
		pfVar3 = local_50;
		local_64 = 4;
		pfVar4 = &local_2c;
		do {
			pfVar4[-1] = (*pfVar3 + local_60) * pSVar1->BlockSize + (pSVar1->blockDimensions_neg).width;
			*pfVar4 = (float)((float10)(pSVar1->blockDimensions_neg).height -
											 ((float10)pfVar3[1] + fVar6) * (float10)pSVar1->BlockSize);
			lVar7 = __ftol((float10)pfVar3[1]);
			iVar5 = (int)(surfMap->texsGrid[-1] + (int)lVar7 + 0x4c) * (pSVar1->dimensions).width +
							local_68;
			lVar7 = __ftol((float10)*pfVar3);
			pfVar3 = pfVar3 + 2;
			local_58 = (float)(uint)*(byte *)(pSVar1->field_28 + 0x1a + (iVar5 + (int)lVar7) * 0x28);
			local_64 = local_64 + -1;
			pfVar4[1] = -((float)(int)local_58 * pSVar1->RoughLevel);
			pfVar4 = pfVar4 + 3;
			fVar6 = extraout_ST0;
		} while (local_64 != 0);
		if (pSVar1->BlockSize <= (local_24 - x) + (local_20 - y)) {
			fVar6 = (float10)local_4;
			local_1c = (float)(((float10)local_10 - fVar6) + ((float10)local_28 - fVar6) + fVar6);
		}
		else {
			fVar6 = ((float10)local_10 - (float10)local_1c) + ((float10)local_28 - (float10)local_1c) +
							(float10)local_1c;
		}
		fVar6 = ((float10)local_10 - fVar6) *
						(((float10)local_18 - (float10)local_c) / ((float10)x - (float10)local_c)) + fVar6;
		return (((float10)local_2c - (float10)local_8) / ((float10)y - (float10)local_8)) *
					 ((((float10)local_1c - (float10)local_28) *
						 (((float10)x - (float10)local_30) / ((float10)local_24 - (float10)local_30)) +
						(float10)local_28) - fVar6) + fVar6;
	}
	return (float10)local_58;
}



void __cdecl
lego::game::SurfaceMap_FUN_00450320(SurfaceMap *surfMap,int sx,int sy,Vector3F *out_vector)
{
	D3DRMVertex local_24;
	
	res::Container_Mesh_GetVertices
						(surfMap->resData_24,sy * (surfMap->smallDimensions).width + sx,
						 *(byte *)(surfMap->field_28 + 0x19 + ((surfMap->dimensions).width * sy + sx) * 0x28) &
						 1,1,&local_24);
	out_vector->x = local_24.position.x;
	out_vector->y = local_24.position.y;
	out_vector->z = local_24.position.z;
	return;
}



BOOL __cdecl
lego::game::SurfaceMap_FillStruct30_FUN_00450390
					(SurfaceMap *surfMap,uint x,uint y,undefined4 *param_4)
{
	uint uVar1;
	D3DRMVertex local_90;
	undefined4 local_6c;
	undefined4 local_68;
	undefined4 local_64;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	
	uVar1 = (surfMap->smallDimensions).width;
	if ((x < uVar1) && (y < (uint)(surfMap->smallDimensions).height)) {
		res::Container_Mesh_GetVertices(surfMap->resData_24,y * uVar1 + x,0,4,&local_90);
		if ((*(byte *)(surfMap->field_28 + 0x19 + ((surfMap->dimensions).width * y + x) * 0x28) & 1) !=
				0) {
			*param_4 = local_6c;
			param_4[1] = local_68;
			param_4[2] = local_64;
			param_4[3] = local_48;
			param_4[4] = local_44;
			param_4[5] = local_40;
			param_4[6] = local_24;
			param_4[7] = local_20;
			param_4[8] = local_1c;
			param_4[9] = local_90.position.x;
			param_4[10] = local_90.position.y;
			param_4[0xb] = local_90.position.z;
			return 1;
		}
		*param_4 = local_90.position.x;
		param_4[1] = local_90.position.y;
		param_4[2] = local_90.position.z;
		param_4[3] = local_6c;
		param_4[4] = local_68;
		param_4[5] = local_64;
		param_4[6] = local_48;
		param_4[7] = local_44;
		param_4[8] = local_40;
		param_4[9] = local_24;
		param_4[10] = local_20;
		param_4[0xb] = local_1c;
		uVar1 = 0;
	}
	return uVar1;
}



void __cdecl
lego::game::SurfaceMap_FillLargeStruct_AtXY_FUN_004504e0
					(SurfaceMap *surfMap,int sx,int sy,undefined4 *out_struct)
{
	D3DRMVertex local_90;
	undefined4 local_6c;
	undefined4 local_68;
	undefined4 local_64;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	
	res::Container_Mesh_GetVertices
						(surfMap->resData_24,sy * (surfMap->smallDimensions).width + sx,0,4,&local_90);
	*out_struct = local_90.position.x;
	out_struct[1] = local_90.position.y;
	out_struct[2] = local_90.position.z;
	out_struct[3] = local_6c;
	out_struct[4] = local_68;
	out_struct[5] = local_64;
	out_struct[6] = local_48;
	out_struct[7] = local_44;
	out_struct[8] = local_40;
	out_struct[9] = local_24;
	out_struct[10] = local_20;
	out_struct[0xb] = local_1c;
	return;
}



BOOL __cdecl lego::game::SurfaceMap_IsInsideDimensions(SurfaceMap *surfMap,uint sx,uint sy)
{
	if ((uint)(surfMap->smallDimensions).width <= sx) {
		return 0;
	}
	return (uint)(sy < (uint)(surfMap->smallDimensions).height);
}



BOOL __cdecl
lego::game::SurfaceMap_FUN_004505a0
					(SurfaceMap *surfMap,Viewport *view,uint param_3,uint param_4,uint *out_x,uint *out_y,
					float *param_7)
{
	int iVar1;
	BOOL BVar2;
	float *pfVar3;
	Vector3F *vector;
	Point2I local_b8;
	int local_b0;
	int local_ac;
	Point2F local_a8;
	Vector3F local_a0;
	Vector3F local_94;
	Vector4F local_88;
	Vector4F local_78;
	Vector4F local_68;
	Point2F local_58;
	Point2F local_50 [3];
	float local_38;
	float local_34;
	Vector3F local_30 [4];
	
	local_a8.x = (float)(ulonglong)param_3;
	local_b8.x = param_4;
	local_b8.y = 0;
	local_a8.y = (float)(ulonglong)param_4;
	local_78.z = 0.0;
	local_78.w = 1.0;
	local_68.z = 1.0;
	local_68.w = 1.0;
	local_78.x = local_a8.x;
	local_78.y = local_a8.y;
	local_68.x = local_a8.x;
	local_68.y = local_a8.y;
	lego::view::Viewport_InverseTransform(view,&local_94,&local_78);
	lego::view::Viewport_InverseTransform(view,&local_a0,&local_68);
	local_a0.x = local_a0.x - local_94.x;
	local_a0.y = local_a0.y - local_94.y;
	local_94.z = local_a0.z - local_94.z;
	local_a0.z = 1.0 / SQRT(local_94.z * local_94.z +
													local_a0.y * local_a0.y + local_a0.x * local_a0.x);
	local_a0.x = local_a0.z * local_a0.x;
	local_a0.y = local_a0.z * local_a0.y;
	local_a0.z = local_a0.z * local_94.z;
	iVar1 = SurfaceMap_FUN_00450820(surfMap,&local_94,&local_a0,(Vector3F *)param_7,&local_b8,0x14);
	if (iVar1 == 0) {
		return 0;
	}
	local_ac = -2;
	do {
		local_b0 = -2;
		iVar1 = local_ac;
		do {
			if (((uint)(local_b0 + local_b8.x) < (uint)(surfMap->smallDimensions).width) &&
				 ((uint)(local_b8.y + iVar1) < (uint)(surfMap->smallDimensions).height)) {
				SurfaceMap_FillStruct30_FUN_00450390
									(surfMap,local_b0 + local_b8.x,local_b8.y + iVar1,(undefined4 *)local_30);
				vector = local_30;
				iVar1 = 4;
				pfVar3 = &local_58.y;
				do {
					lego::view::Viewport_Transform(view,&local_88,vector);
					vector = vector + 1;
					iVar1 = iVar1 + -1;
					pfVar3[-1] = local_88.x / local_88.w;
					*pfVar3 = local_88.y / local_88.w;
					pfVar3 = pfVar3 + 2;
				} while (iVar1 != 0);
				local_38 = local_58.x;
				local_34 = local_58.y;
				BVar2 = math::Maths_PointInsidePoly(&local_a8,&local_58,local_50,4);
				iVar1 = local_ac;
				if (BVar2 != 0) {
					*out_x = local_b0 + local_b8.x;
					*out_y = local_b8.y + local_ac;
					SurfaceMap_FUN_004518a0
										(surfMap,*out_x,local_b8.y + local_ac,&local_94,&local_a0,(Vector3F *)param_7);
					return 1;
				}
			}
			local_b0 = local_b0 + 1;
		} while (local_b0 < 3);
		local_ac = iVar1 + 1;
		if (2 < local_ac) {
			return 0;
		}
	} while( true );
}



void __cdecl
lego::game::SurfaceMap_FUN_00450820
					(SurfaceMap *surfMap,Vector3F *param_2,Vector3F *param_3,Vector3F *param_4,
					Point2I *out_coordinates,int unkCount)
{
	float10 fVar1;
	Vector3F local_18;
	Vector3F local_c;
	
	local_18.x = 0.0;
	local_18.y = 0.0;
	local_18.z = -50.0;
	local_c.x = 0.0;
	local_c.y = 0.0;
	local_c.z = -1.0;
	if (unkCount != 0) {
		do {
			math::Maths_RayPlaneIntersection(param_4,param_2,param_3,&local_18,&local_c);
			fVar1 = SurfaceMap_GetSurfaceZ(surfMap,param_4->x,param_4->y);
			local_18.z = (float)fVar1;
			unkCount = unkCount + -1;
		} while (unkCount != 0);
	}
	SurfaceMap_ToBlockCoordinatesNoZ
						(surfMap,param_4->x,param_4->y,(int *)out_coordinates,&out_coordinates->y);
	return;
}



void __cdecl
lego::game::SurfaceMap_AddCoordsInRadius_AndDoCallbacks
					(SurfaceMap *surfMap,int in_x,int in_y,int radius,XYCallback *opt_callback)
{
	int rel_y;
	int abs_x;
	int abs_y;
	int neg_radius;
	int rel_x;
	
	neg_radius = -radius;
	if (-radius == radius || SBORROW4(neg_radius,radius) != radius * -2 < 0) {
		abs_y = neg_radius + in_y;
		rel_y = neg_radius;
		do {
			if (neg_radius <= radius) {
				abs_x = neg_radius + in_x;
				rel_x = neg_radius;
				do {
					if ((((rel_x * rel_x + rel_y * rel_y <= radius * radius) && (-1 < abs_x)) &&
							(abs_x < (surfMap->smallDimensions).width)) &&
						 ((-1 < abs_y && (abs_y < (surfMap->smallDimensions).height)))) {
						SurfaceMap_DoForBlockIndex_Mesh_FUN_00474df0(surfMap,abs_x,abs_y,0);
						if (opt_callback != (XYCallback *)0x0) {
							(*opt_callback)(abs_x,abs_y);
						}
						surfMap->coordsTable[surfMap->coordsNum].sx = (short)rel_x + (short)in_x;
						surfMap->coordsTable[surfMap->coordsNum].sy = (short)rel_y + (short)in_y;
						surfMap->coordsNum = surfMap->coordsNum + 1;
					}
					rel_x = rel_x + 1;
					abs_x = abs_x + 1;
				} while (rel_x <= radius);
			}
			rel_y = rel_y + 1;
			abs_y = abs_y + 1;
		} while (rel_y <= radius);
	}
	return;
}



void __cdecl
lego::game::SurfaceMap_DoForBlockIndex_Mesh_FUN_00474df0(SurfaceMap *surfMap,int x,int y,BOOL state)
{
	res::Container_Mesh_HideGroup(surfMap->resData_24,y * (surfMap->smallDimensions).width + x,state);
	return;
}



void __cdecl lego::game::SurfaceMap_AddBlockCoord(SurfaceMap *surfMap,int x,int y)
{
	SurfaceMap_DoForBlockIndex_Mesh_FUN_00474df0(surfMap,x,y,0);
	surfMap->coordsTable[surfMap->coordsNum].sx = (short)x;
	surfMap->coordsTable[surfMap->coordsNum].sy = (short)y;
	surfMap->coordsNum = surfMap->coordsNum + 1;
	return;
}



void __cdecl lego::game::SurfaceMap_DoForCoordsAndClear_Mesh_FUN_00474df0(SurfaceMap *surfMap)
{
	uint uVar1;
	Coord2I *coord;
	
	uVar1 = 0;
	if (surfMap->coordsNum != 0) {
		coord = surfMap->coordsTable;
		do {
			SurfaceMap_DoForBlockIndex_Mesh_FUN_00474df0
								(surfMap,(uint)(ushort)coord->sx,(uint)(ushort)coord->sy,TRUE);
			uVar1 = uVar1 + 1;
			coord = coord + 1;
		} while (uVar1 < surfMap->coordsNum);
	}
	surfMap->coordsNum = 0;
	return;
}



void __cdecl
lego::game::SurfaceMap_FUN_00450a90
					(SurfaceMap *surfMap,uint in_x,uint in_y,float *out_x,float *out_y,float *out_z)
{
	uint uVar1;
	uint uVar2;
	uint index;
	float local_24;
	float local_20;
	float local_1c;
	
	uVar1 = (surfMap->dimensions).width;
	if (uVar1 <= in_x) {
		return;
	}
	if ((uint)(surfMap->dimensions).height <= in_y) {
		return;
	}
	uVar2 = (surfMap->smallDimensions).width;
	index = 0;
	if (in_x == uVar2) {
		if (in_y == (surfMap->smallDimensions).height) {
			in_x = in_x - 1;
			in_y = in_y - 1;
			index = 2;
			goto LAB_00450ae4;
		}
		if (in_x == uVar2) {
			in_x = in_x - 1;
			index = 1;
			goto LAB_00450ae4;
		}
	}
	if (in_y == (surfMap->smallDimensions).height) {
		in_y = in_y - 1;
		index = 0xffffffff;
	}
LAB_00450ae4:
	if ((*(byte *)(surfMap->field_28 + 0x19 + (in_y * uVar1 + in_x) * 0x28) & 1) != 0) {
		index = index + 1;
	}
	if (index == 0xffffffff) {
		index = 3;
	}
	res::Container_Mesh_GetVertices
						(surfMap->resData_24,in_y * uVar2 + in_x,index,1,(D3DRMVertex *)&local_24);
	*out_x = local_24;
	*out_y = local_20;
	*out_z = local_1c;
	return;
}



float10 __cdecl lego::game::SurfaceMap_GetBlockSize(SurfaceMap *surfMap)
{
	return (float10)surfMap->BlockSize;
}



int __cdecl
lego::unk::Lego_CheckComparison_FUN_00450b60(int param_1,int param_2,int param_3,int param_4)
{
	int iVar1;
	int iVar2;
	
	iVar2 = -1;
	if (param_1 == param_3) {
		if (param_2 + -1 == param_4) {
			return 0;
		}
		if (param_2 + 1 == param_4) {
			return 2;
		}
	}
	else {
		iVar1 = param_1 + 1;
		if (param_2 == param_4) {
			if (iVar1 == param_3) {
				return 1;
			}
			if (param_1 + -1 == param_3) {
				return 3;
			}
		}
		else {
			if (iVar1 == param_3) {
				if (param_2 + -1 == param_4) {
					return 4;
				}
				if ((iVar1 == param_3) && (param_2 + 1 == param_4)) {
					return 5;
				}
			}
			if (param_1 + -1 == param_3) {
				if (param_2 + 1 == param_4) {
					return 6;
				}
				if ((param_1 + -1 == param_3) && (param_2 + -1 == param_4)) {
					iVar2 = 7;
				}
			}
		}
	}
	return iVar2;
}



void __cdecl lego::game::SurfaceMap_FUN_00450c20(SurfaceMap *surfMap,uint bx,uint by,BOOL param_4)
{
	uint uVar1;
	int iVar2;
	uint uVar3;
	ushort *puVar4;
	
	if (param_4 == 0) {
		if ((*(byte *)(surfMap->field_28 + 0x19 + (by * (surfMap->dimensions).width + bx) * 0x28) & 0x10
				) != 0) {
			uVar1 = surfMap->field_7198;
			uVar3 = 0;
			if (uVar1 != 0) {
				puVar4 = (ushort *)&surfMap->field_0x4a8a;
				while ((puVar4[-1] != bx || (*puVar4 != by))) {
					uVar3 = uVar3 + 1;
					puVar4 = puVar4 + 2;
					if (uVar1 <= uVar3) {
						return;
					}
				}
				surfMap->field_7198 = uVar1 - 1;
				*(undefined2 *)(&surfMap->field_0x4a88 + uVar3 * 4) =
						 *(undefined2 *)(&surfMap->coordsNum + uVar1);
				*(undefined2 *)(&surfMap->field_0x4a8a + uVar3 * 4) =
						 *(undefined2 *)(&surfMap->field_0x4a8a + surfMap->field_7198 * 4);
				iVar2 = by * (surfMap->dimensions).width + bx;
				*(byte *)(surfMap->field_28 + 0x19 + iVar2 * 0x28) =
						 *(byte *)(surfMap->field_28 + 0x19 + iVar2 * 0x28) & 0xef;
			}
		}
	}
	else {
		if ((*(byte *)(surfMap->field_28 + 0x19 + (by * (surfMap->dimensions).width + bx) * 0x28) & 0x10
				) == 0) {
			*(short *)(&surfMap->field_0x4a88 + surfMap->field_7198 * 4) = (short)bx;
			*(short *)(&surfMap->field_0x4a8a + surfMap->field_7198 * 4) = (short)by;
			iVar2 = by * (surfMap->dimensions).width + bx;
			surfMap->field_7198 = surfMap->field_7198 + 1;
			*(byte *)(surfMap->field_28 + 0x19 + iVar2 * 0x28) =
					 *(byte *)(surfMap->field_28 + 0x19 + iVar2 * 0x28) | 0x10;
			return;
		}
	}
	return;
}



void __cdecl lego::game::SurfaceMap_FUN_00450d40(SurfaceMap *surfMap,BOOL param_2)
{
	uint uVar1;
	ushort *puVar2;
	
	if ((param_2 != 0) && ((*(byte *)&surfMap->field_73d0 & 4) == 0)) {
		uVar1 = 0;
		if (surfMap->field_7198 != 0) {
			puVar2 = (ushort *)&surfMap->field_0x4a88;
			do {
				res::Container_Mesh_SetEmissive
									(surfMap->resData_24,
									 (uint)puVar2[1] * (surfMap->smallDimensions).width + (uint)*puVar2,0.3,0.3,0.3);
				uVar1 = uVar1 + 1;
				puVar2 = puVar2 + 2;
			} while (uVar1 < (uint)surfMap->field_7198);
		}
		surfMap->field_73d0 = surfMap->field_73d0 | 4;
		return;
	}
	if ((param_2 == 0) && ((*(byte *)&surfMap->field_73d0 & 4) != 0)) {
		uVar1 = 0;
		if (surfMap->field_7198 != 0) {
			puVar2 = (ushort *)&surfMap->field_0x4a88;
			do {
				res::Container_Mesh_SetEmissive
									(surfMap->resData_24,
									 (uint)puVar2[1] * (surfMap->smallDimensions).width + (uint)*puVar2,0.0,0.0,0.0);
				uVar1 = uVar1 + 1;
				puVar2 = puVar2 + 2;
			} while (uVar1 < (uint)surfMap->field_7198);
		}
		surfMap->field_73d0 = surfMap->field_73d0 & 0xfffffffb;
	}
	return;
}



void __cdecl lego::game::SurfaceMap_FUN_00450e20(SurfaceMap *surfMap,float param_2)
{
	float *pfVar1;
	byte bVar2;
	int iVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	ushort *puVar9;
	int iVar10;
	D3DRMGroupIndex groupID;
	uint uVar11;
	uint uVar12;
	uint uVar13;
	int iVar14;
	float10 fVar15;
	float10 fVar16;
	float10 fVar17;
	uint local_11c;
	float local_118;
	float local_114;
	float local_110;
	float local_10c;
	float *local_108;
	int *local_104;
	uint local_100;
	uint local_f4;
	float local_d0;
	float local_cc [4];
	undefined4 local_bc;
	undefined4 local_b8;
	undefined4 local_b4;
	int local_b0;
	int local_ac [4];
	undefined4 local_9c;
	undefined4 local_98;
	undefined4 local_94;
	D3DRMVertex local_90 [4];
	
	if ((ushort)((ushort)(param_2 < 0.001) << 8 | (ushort)(param_2 == 0.001) << 0xe) == 0) {
		local_ac[1] = 1;
		local_ac[3] = 1;
		local_9c = 1;
		local_94 = 1;
		local_d0 = 0.0;
		local_cc[0] = 1.0;
		local_cc[1] = 1.0;
		local_cc[2] = 1.0;
		local_cc[3] = 1.0;
		local_bc = 0;
		local_b8 = 0;
		local_b4 = 0;
		local_b0 = 0;
		local_ac[0] = 0;
		local_ac[2] = 0;
		local_98 = 0;
		local_f4 = 0;
		if (surfMap->field_7198 != 0) {
			fVar6 = 50.0 / param_2;
			puVar9 = (ushort *)&surfMap->field_0x4a8a;
			fVar7 = 1.0 / (fVar6 - -1.0);
			do {
				uVar13 = (uint)*puVar9;
				uVar12 = (uint)puVar9[-1];
				groupID = (surfMap->smallDimensions).width * uVar13 + uVar12;
				bVar2 = *(byte *)(surfMap->field_28 + 0x19 +
												 (uVar13 * (surfMap->dimensions).width + uVar12) * 0x28);
				res::Container_Mesh_GetVertices(surfMap->resData_24,groupID,0,4,local_90);
				local_108 = &local_d0;
				local_104 = &local_b0;
				local_100 = 0;
				local_11c = 0;
				do {
					uVar11 = local_100;
					if ((bVar2 & 1) != 0) {
						uVar11 = local_100 + 1 & 3;
					}
					iVar14 = uVar13 + *(int *)((int)local_ac + local_11c);
					iVar3 = *local_104;
					iVar10 = iVar14 * (surfMap->dimensions).width + uVar12 + iVar3;
					fVar4 = local_90[uVar11].tu;
					local_110 = *(float *)(surfMap->field_28 + 0x1c + iVar10 * 0x28) + *local_108;
					fVar5 = local_90[uVar11].tv;
					local_10c = *(float *)(surfMap->field_28 + 0x20 + iVar10 * 0x28) +
											*(float *)((int)local_cc + local_11c);
					fVar8 = SQRT((fVar5 - local_10c) * (fVar5 - local_10c) +
											 (fVar4 - local_110) * (fVar4 - local_110));
					local_118 = local_110;
					local_114 = local_10c;
					if (((ushort)((ushort)(fVar8 < 0.36) << 8 | (ushort)(fVar8 == 0.36) << 0xe) != 0) &&
						 (local_118 = fVar4, local_114 = fVar5, fVar8 < 0.05)) {
						fVar15 = math::Maths_RandRange(0.0,1.0);
						fVar4 = (float)fVar15;
						fVar15 = math::Maths_RandRange(0.0,1.0);
						pfVar1 = (float *)(surfMap->field_28 + 0x1c +
															(iVar14 * (surfMap->dimensions).width + uVar12 + iVar3) * 0x28);
						fVar16 = (float10)1.0 /
										 SQRT(fVar15 * (float10)(float)fVar15 + (float10)fVar4 * (float10)fVar4);
						fVar17 = ((float10)*pfVar1 + fVar16 * (float10)fVar4) * (float10)0.3;
						fVar4 = (pfVar1[1] + (float)(fVar16 * (float10)(float)fVar15)) * 0.3;
						local_10c = fVar4 + *(float *)((int)local_cc + local_11c);
						local_110 = (float)(fVar17 + (float10)*local_108);
						*pfVar1 = (float)fVar17;
						pfVar1[1] = fVar4;
					}
					local_11c = local_11c + 8;
					local_104 = local_104 + 2;
					local_108 = local_108 + 2;
					local_90[uVar11].tu = fVar7 * (fVar6 * local_118 + local_110);
					local_100 = local_100 + 1;
					local_90[uVar11].tv = fVar7 * (fVar6 * local_114 + local_10c);
				} while (local_11c < 0x20);
				res::Container_Mesh_SetVertices(surfMap->resData_24,groupID,0,4,local_90);
				local_f4 = local_f4 + 1;
				puVar9 = puVar9 + 2;
			} while (local_f4 < (uint)surfMap->field_7198);
		}
	}
	return;
}



void __cdecl lego::game::SurfaceMap_FUN_004511f0(SurfaceMap *surfMap,uint x,uint y)
{
	float fVar1;
	float fVar2;
	float *pfVar3;
	uint uVar4;
	BOOL BVar5;
	int iVar6;
	Vector3F *pVVar7;
	float *pfVar8;
	undefined4 *puVar9;
	uint uVar10;
	float *pfVar11;
	float *pfVar12;
	longlong lVar13;
	longlong lVar14;
	longlong lVar15;
	uint uVar16;
	Vector3F *pVVar17;
	undefined4 *puVar18;
	int local_a0;
	int local_94;
	float local_80 [5];
	undefined4 local_6c;
	undefined4 local_68;
	undefined4 local_64;
	undefined4 local_60;
	undefined4 local_5c;
	float local_58;
	undefined4 local_54;
	undefined4 local_50;
	undefined4 local_4c;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40;
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	Vector3F local_30 [4];
	
	uVar10 = 0;
	local_80[0] = 0.0;
	local_80[1] = 0.0;
	local_80[2] = -1.0;
	local_80[3] = 0.0;
	local_80[4] = -1.0;
	local_6c = 0xbf800000;
	local_68 = 0;
	local_64 = 0xbf800000;
	local_60 = 0;
	local_5c = 0;
	local_58 = 0.0;
	local_54 = 0;
	local_50 = 0;
	local_4c = 0;
	local_48 = 0;
	local_44 = 0;
	local_40 = 0;
	local_3c = 0;
	local_38 = 0;
	local_34 = 0;
	iVar6 = 4;
	pfVar3 = local_80 + 1;
	do {
		iVar6 = iVar6 + -1;
		pfVar3[-1] = pfVar3[-1] + (float)(ulonglong)x;
		*pfVar3 = (float)(ulonglong)y + *pfVar3;
		pfVar3 = pfVar3 + 2;
	} while (iVar6 != 0);
	pfVar3 = local_80;
	pVVar7 = local_30;
	do {
		uVar16 = uVar10;
		pVVar17 = pVVar7;
		lVar13 = __ftol((float10)pfVar3[1]);
		uVar4 = (uint)lVar13;
		lVar13 = __ftol((float10)*pfVar3);
		SurfaceMap_FUN_00451590(surfMap,(uint)lVar13,uVar4,uVar16,pVVar17);
		uVar10 = uVar10 + 1;
		pVVar7 = pVVar7 + 1;
		pfVar3 = pfVar3 + 2;
	} while (uVar10 < 4);
	pfVar3 = local_80;
	local_a0 = 4;
	pfVar11 = &local_58;
	do {
		lVar13 = __ftol((float10)pfVar3[1]);
		lVar14 = __ftol((float10)*pfVar3);
		pfVar12 = local_80;
		pfVar8 = &local_30[0].z;
		local_94 = 4;
		do {
			lVar15 = __ftol((float10)pfVar12[1]);
			uVar10 = (uint)lVar15;
			lVar15 = __ftol((float10)*pfVar12);
			BVar5 = SurfaceMap_FUN_00451440(surfMap,(uint)lVar14,(uint)lVar13,(uint)lVar15,uVar10);
			if (BVar5 == 0) {
				fVar1 = pfVar8[-1];
				fVar2 = *pfVar8;
				pfVar11[-2] = pfVar8[-2] + pfVar11[-2];
				pfVar11[-1] = fVar1 + pfVar11[-1];
				*pfVar11 = fVar2 + *pfVar11;
			}
			pfVar12 = pfVar12 + 2;
			pfVar8 = pfVar8 + 3;
			local_94 = local_94 + -1;
		} while (local_94 != 0);
		pfVar3 = pfVar3 + 2;
		local_a0 = local_a0 + -1;
		fVar1 = 1.0 / SQRT(pfVar11[-2] * pfVar11[-2] + *pfVar11 * *pfVar11 + pfVar11[-1] * pfVar11[-1]);
		*pfVar11 = fVar1 * *pfVar11;
		pfVar11[-2] = fVar1 * pfVar11[-2];
		pfVar11[-1] = fVar1 * pfVar11[-1];
		pfVar11 = pfVar11 + 3;
	} while (local_a0 != 0);
	uVar10 = 0;
	pfVar3 = local_80;
	puVar9 = &local_60;
	do {
		uVar16 = uVar10;
		puVar18 = puVar9;
		lVar13 = __ftol((float10)pfVar3[1]);
		uVar4 = (uint)lVar13;
		lVar13 = __ftol((float10)*pfVar3);
		SurfaceMap_FUN_004514f0(surfMap,(uint)lVar13,uVar4,uVar16,puVar18);
		uVar10 = uVar10 + 1;
		puVar9 = puVar9 + 3;
		pfVar3 = pfVar3 + 2;
	} while (uVar10 < 4);
	return;
}



BOOL __cdecl
lego::game::SurfaceMap_FUN_00451440
					(SurfaceMap *surfMap,uint param_2,uint param_3,uint param_4,uint param_5)
{
	byte bVar1;
	byte bVar2;
	uint uVar3;
	int iVar4;
	uint uVar5;
	
	if (((((param_3 != param_5) || (param_2 != param_4)) &&
			 (uVar5 = (surfMap->smallDimensions).width, param_2 < uVar5)) &&
			((uVar3 = (surfMap->smallDimensions).height, param_3 < uVar3 && (param_4 < uVar5)))) &&
		 (param_5 < uVar3)) {
		iVar4 = (surfMap->dimensions).width;
		bVar1 = *(byte *)(surfMap->field_28 + 0x18 + (param_3 * iVar4 + param_2) * 0x28);
		bVar2 = *(byte *)(surfMap->field_28 + 0x18 + (param_5 * iVar4 + param_4) * 0x28);
		param_3 = (uint)bVar1;
		if ((bVar1 != 0xff) && (bVar2 != 0xff)) {
			uVar5 = 0;
			if (surfMap->texsNum[param_3] != 0) {
				do {
					if (surfMap->texsGrid[param_3][uVar5] == bVar2) {
						return 1;
					}
					uVar5 = uVar5 + 1;
				} while (uVar5 < surfMap->texsNum[param_3]);
				return 0;
			}
		}
	}
	return 0;
}



void __cdecl
lego::game::SurfaceMap_FUN_004514f0
					(SurfaceMap *surfMap,uint param_2,uint param_3,uint param_4,undefined4 *param_5)
{
	uint uVar1;
	D3DRMGroupIndex groupID;
	D3DRMVertex local_24;
	
	uVar1 = (surfMap->smallDimensions).width;
	groupID = param_3 * uVar1 + param_2;
	if ((param_2 < uVar1) && (param_3 < (uint)(surfMap->smallDimensions).height)) {
		if ((*(byte *)(surfMap->field_28 + 0x19 +
									((surfMap->dimensions).width * param_3 + param_2) * 0x28) & 1) != 0) {
			param_4 = param_4 + 1 & 3;
		}
		res::Container_Mesh_GetVertices(surfMap->resData_24,groupID,param_4,1,&local_24);
		local_24.normal.x = (float)*param_5;
		local_24.normal.y = (float)param_5[1];
		local_24.normal.z = (float)param_5[2];
		res::Container_Mesh_SetVertices(surfMap->resData_24,groupID,param_4,1,&local_24);
	}
	return;
}



BOOL __cdecl
lego::game::SurfaceMap_FUN_00451590
					(SurfaceMap *surfMap,uint x,uint y,uint param_4,Vector3F *param_5)
{
	float *pfVar1;
	int iVar2;
	float fVar3;
	int iVar4;
	
	if ((x < (uint)(surfMap->smallDimensions).width) && (y < (uint)(surfMap->smallDimensions).height))
	{
		pfVar1 = (float *)(surfMap->field_28 + (y * (surfMap->dimensions).width + x) * 0x28);
		if ((*(byte *)((int)pfVar1 + 0x19) & 1) != 0) {
			param_4 = param_4 + 1 & 3;
		}
		if (param_4 == 0) {
			param_5->x = *pfVar1;
			param_5->y = pfVar1[1];
			param_5->z = pfVar1[2];
		}
		if (param_4 == 2) {
			pfVar1 = (float *)(surfMap->field_28 + 0xc + (y * (surfMap->dimensions).width + x) * 0x28);
			param_5->x = *pfVar1;
			param_5->y = pfVar1[1];
			param_5->z = pfVar1[2];
		}
		if ((param_4 == 1) || (param_4 == 3)) {
			pfVar1 = (float *)(surfMap->field_28 + (y * (surfMap->dimensions).width + x) * 0x28);
			param_5->x = *pfVar1;
			param_5->y = pfVar1[1];
			param_5->z = pfVar1[2];
			iVar4 = y * (surfMap->dimensions).width + x;
			iVar2 = surfMap->field_28 + 0xc + iVar4 * 0x28;
			param_5->x = *(float *)(surfMap->field_28 + 0xc + iVar4 * 0x28) + param_5->x;
			param_5->y = *(float *)(iVar2 + 4) + param_5->y;
			fVar3 = *(float *)(iVar2 + 8) + param_5->z;
			param_5->z = fVar3;
			fVar3 = 1.0 / SQRT(param_5->x * param_5->x + fVar3 * fVar3 + param_5->y * param_5->y);
			param_5->x = fVar3 * param_5->x;
			param_5->y = fVar3 * param_5->y;
			param_5->z = fVar3 * param_5->z;
		}
		return 1;
	}
	param_5->z = 0.0;
	param_5->y = 0.0;
	param_5->x = 0.0;
	return 0;
}



void __cdecl
lego::game::SurfaceMap_FUN_00451710
					(SurfaceMap *surfMap,uint param_2,uint param_3,uint param_4,float *param_5)
{
	uint uVar1;
	D3DRMGroupIndex groupID;
	D3DRMVertex local_24;
	
	uVar1 = (surfMap->smallDimensions).width;
	groupID = param_3 * uVar1 + param_2;
	if ((param_2 < uVar1) && (param_3 < (uint)(surfMap->smallDimensions).height)) {
		if ((*(byte *)(surfMap->field_28 + 0x19 +
									((surfMap->dimensions).width * param_3 + param_2) * 0x28) & 1) != 0) {
			param_4 = param_4 + 1 & 3;
		}
		res::Container_Mesh_GetVertices(surfMap->resData_24,groupID,param_4,1,&local_24);
		local_24.position.x = *param_5 + local_24.position.x;
		local_24.position.y = param_5[1] + local_24.position.y;
		local_24.position.z = param_5[2] + local_24.position.z;
		res::Container_Mesh_SetVertices(surfMap->resData_24,groupID,param_4,1,&local_24);
	}
	return;
}



void __cdecl lego::game::SurfaceMap_FUN_004517b0(SurfaceMap *surfMap,uint x,uint y)
{
	uint uVar1;
	D3DRMVertex local_90;
	Vector3F local_6c [3];
	Vector3F local_48 [3];
	Vector3F local_24 [3];
	
	uVar1 = (surfMap->smallDimensions).width;
	if ((x < uVar1) && (y < (uint)(surfMap->smallDimensions).height)) {
		res::Container_Mesh_GetVertices(surfMap->resData_24,y * uVar1 + x,0,4,&local_90);
		math::Maths_PlaneNormal
							((Vector3F *)(surfMap->field_28 + (y * (surfMap->dimensions).width + x) * 0x28),
							 (Vector3F *)&local_90,local_6c,local_24);
		math::Maths_PlaneNormal
							((Vector3F *)(surfMap->field_28 + 0xc + (y * (surfMap->dimensions).width + x) * 0x28),
							 local_6c,local_48,local_24);
	}
	return;
}



void __cdecl
lego::game::MapFile_GetDimensions(MapFileInfo *mapFileInfo,int *out_width,int *out_height)
{
	*out_width = (mapFileInfo->dimensions).width;
	*out_height = (mapFileInfo->dimensions).height;
	return;
}



ushort __cdecl lego::game::MapFile_GetBlock(MapFileInfo *mapFile,int x,int y,int width)
{
	return mapFile->blocks[width * y + x];
}



BOOL __cdecl
lego::game::SurfaceMap_FUN_004518a0
					(SurfaceMap *surfMap,uint x,uint y,Vector3F *param_4,Vector3F *param_5,
					Vector3F *out_vector)
{
	int iVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	bool bVar8;
	int iVar9;
	BOOL BVar10;
	Point2F local_88;
	Vector3F local_7c;
	Point2F local_70;
	Point2F local_68;
	float local_60;
	float local_5c;
	float local_58;
	float local_54;
	Vector3F local_50;
	Vector3F local_44;
	int local_38;
	BOOL local_34;
	Vector3F local_30;
	float local_24;
	float local_20;
	Vector3F local_18;
	float local_c;
	float local_8;
	
	local_34 = SurfaceMap_FillStruct30_FUN_00450390(surfMap,x,y,(undefined4 *)&local_30);
	bVar8 = false;
	local_38 = 0;
	iVar9 = y * (surfMap->dimensions).width + x;
	iVar1 = surfMap->field_28 + iVar9 * 0x28;
	local_7c.x = *(float *)(surfMap->field_28 + iVar9 * 0x28);
	local_7c.y = *(float *)(iVar1 + 4);
	local_7c.z = *(float *)(iVar1 + 8);
	BVar10 = math::Maths_RayPlaneIntersection(&local_50,param_4,param_5,&local_30,&local_7c);
	if (BVar10 != 0) {
		if (local_34 == 0) {
			local_68.x = local_24;
			local_68.y = local_20;
		}
		else {
			local_68.x = local_18.x;
			local_68.y = local_18.y;
		}
		local_88.x = local_50.x;
		local_88.y = local_50.y;
		BVar10 = math::Maths_PointInsidePoly(&local_88,&local_70,&local_68,3);
		if (BVar10 != 0) {
			bVar8 = true;
		}
	}
	iVar9 = y * (surfMap->dimensions).width + x;
	iVar1 = surfMap->field_28 + 0xc + iVar9 * 0x28;
	local_7c.x = *(float *)(surfMap->field_28 + 0xc + iVar9 * 0x28);
	local_7c.y = *(float *)(iVar1 + 4);
	local_7c.z = *(float *)(iVar1 + 8);
	BVar10 = math::Maths_RayPlaneIntersection(&local_44,param_4,param_5,&local_18,&local_7c);
	if (BVar10 != 0) {
		if (local_34 == 0) {
			local_68.x = local_18.x;
			local_68.y = local_18.y;
			local_60 = local_c;
			local_5c = local_8;
			local_58 = local_24;
			local_54 = local_20;
		}
		else {
			local_68.x = local_24;
			local_68.y = local_20;
			local_60 = local_18.x;
			local_5c = local_18.y;
			local_58 = local_30.x;
			local_54 = local_30.y;
		}
		local_88.x = local_44.x;
		local_88.y = local_44.y;
		local_70.x = local_58;
		local_70.y = local_54;
		BVar10 = math::Maths_PointInsidePoly(&local_88,&local_70,&local_68,3);
		if (BVar10 != 0) {
			local_38 = 1;
		}
	}
	if (bVar8) {
		if (local_38 == 0) {
			if (bVar8) {
				out_vector->x = local_50.x;
				out_vector->y = local_50.y;
				out_vector->z = local_50.z;
				return 1;
			}
		}
		else {
			fVar2 = local_50.x - param_4->x;
			fVar3 = local_44.x - param_4->x;
			fVar7 = local_50.y - param_4->y;
			fVar4 = local_44.y - param_4->y;
			fVar6 = local_50.z - param_4->z;
			fVar5 = local_44.z - param_4->z;
			fVar2 = SQRT(fVar6 * fVar6 + fVar7 * fVar7 + fVar2 * fVar2);
			fVar3 = SQRT(fVar5 * fVar5 + fVar4 * fVar4 + fVar3 * fVar3);
			if ((ushort)((ushort)(fVar3 < fVar2) << 8 | (ushort)(fVar3 == fVar2) << 0xe) == 0) {
				out_vector->x = local_50.x;
				out_vector->y = local_50.y;
				out_vector->z = local_50.z;
				return 1;
			}
		}
	}
	else {
		if (local_38 == 0) {
			return 0;
		}
	}
	out_vector->x = local_44.x;
	out_vector->y = local_44.y;
	out_vector->z = local_44.z;
	return 1;
}



PolyMeshData * __cdecl
lego::res::Res_CreatePolyMesh
					(PolyMeshData *lastPolyData,char *partName,char *dirname,char *meshFilename,uint index)
{
	char cVar1;
	Container *pCVar2;
	PolyMeshData *pPVar3;
	undefined4 *puVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	char filenameBuffer [256];
	
	std::sprintf(filenameBuffer,"%s\\%s",dirname,meshFilename);
	pCVar2 = Container_Load((Container *)0x0,filenameBuffer,"LWO",1);
	if (pCVar2 == (Container *)0x0) {
		pCVar2 = Container_Load((Container *)0x0,filenameBuffer,"MESH",1);
		if (pCVar2 == (Container *)0x0) {
			return (PolyMeshData *)0x0;
		}
	}
	pPVar3 = (PolyMeshData *)std::malloc(0x18);
	pPVar3->int_10 = 2;
	if (lastPolyData != (PolyMeshData *)0x0) {
		lastPolyData->previous = pPVar3;
	}
	pPVar3->field_0 = pCVar2;
	uVar5 = 0xffffffff;
	pPVar3->previous = (PolyMeshData *)0x0;
	pPVar3->index = index;
	pcVar8 = partName;
	do {
		if (uVar5 == 0) break;
		uVar5 = uVar5 - 1;
		cVar1 = *pcVar8;
		pcVar8 = pcVar8 + 1;
	} while (cVar1 != '\0');
	puVar4 = (undefined4 *)std::malloc(~uVar5);
	uVar5 = 0xffffffff;
	pPVar3->partName = (char *)puVar4;
	do {
		pcVar8 = partName;
		if (uVar5 == 0) break;
		uVar5 = uVar5 - 1;
		pcVar8 = partName + 1;
		cVar1 = *partName;
		partName = pcVar8;
	} while (cVar1 != '\0');
	uVar5 = ~uVar5;
	puVar7 = (undefined4 *)(pcVar8 + -uVar5);
	for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
		*puVar4 = *puVar7;
		puVar7 = puVar7 + 1;
		puVar4 = puVar4 + 1;
	}
	for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
		*(undefined *)puVar4 = *(undefined *)puVar7;
		puVar7 = (undefined4 *)((int)puVar7 + 1);
		puVar4 = (undefined4 *)((int)puVar4 + 1);
	}
	pPVar3->resDataUnassigned_4 = (Container *)0x0;
	return pPVar3;
}



PolyMeshData * __cdecl
lego::res::Res_CreateNullPolyMesh(PolyMeshData *lastPolyData,char *partName,uint index)
{
	char cVar1;
	PolyMeshData *pPVar2;
	undefined4 *puVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	
	pPVar2 = (PolyMeshData *)std::malloc(0x18);
	pPVar2->int_10 = 2;
	if (lastPolyData != (PolyMeshData *)0x0) {
		lastPolyData->previous = pPVar2;
	}
	pPVar2->index = index;
	uVar4 = 0xffffffff;
	pPVar2->previous = (PolyMeshData *)0x0;
	pPVar2->field_0 = 0;
	pcVar7 = partName;
	do {
		if (uVar4 == 0) break;
		uVar4 = uVar4 - 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar7 + 1;
	} while (cVar1 != '\0');
	puVar3 = (undefined4 *)std::malloc(~uVar4);
	uVar4 = 0xffffffff;
	pPVar2->partName = (char *)puVar3;
	do {
		pcVar7 = partName;
		if (uVar4 == 0) break;
		uVar4 = uVar4 - 1;
		pcVar7 = partName + 1;
		cVar1 = *partName;
		partName = pcVar7;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar6 = (undefined4 *)(pcVar7 + -uVar4);
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
		*puVar3 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar3 = puVar3 + 1;
	}
	for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
		*(undefined *)puVar3 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar3 = (undefined4 *)((int)puVar3 + 1);
	}
	pPVar2->resDataUnassigned_4 = (Container *)0x0;
	return pPVar2;
}



PolyMeshData * __cdecl lego::res::PolyMesh_Duplicate(PolyMeshData *polyData)
{
	PolyMeshData *pPVar1;
	int iVar2;
	int iVar3;
	uint *puVar4;
	PolyMeshData *pPVar5;
	uint *puVar6;
	
	iVar2 = 0;
	pPVar1 = polyData;
	if (polyData != (PolyMeshData *)0x0) {
		do {
			pPVar1 = pPVar1->previous;
			iVar2 = iVar2 + 1;
		} while (pPVar1 != (PolyMeshData *)0x0);
	}
	if (iVar2 == 0) {
		return (PolyMeshData *)0x0;
	}
	pPVar1 = (PolyMeshData *)std::malloc(iVar2 * 0x18);
	iVar2 = 0;
	if (polyData != (PolyMeshData *)0x0) {
		puVar4 = (uint *)&pPVar1->int_10;
		do {
			pPVar5 = polyData;
			puVar6 = puVar4 + -4;
			for (iVar3 = 6; iVar3 != 0; iVar3 = iVar3 + -1) {
				*puVar6 = pPVar5->field_0;
				pPVar5 = (PolyMeshData *)&pPVar5->resDataUnassigned_4;
				puVar6 = puVar6 + 1;
			}
			puVar4[-3] = 0;
			iVar2 = iVar2 + 1;
			*puVar4 = *puVar4 & 0xfffffffd | 1;
			puVar4[1] = (uint)(puVar4 + 2);
			polyData = polyData->previous;
			puVar4 = puVar4 + 6;
		} while (polyData != (PolyMeshData *)0x0);
	}
	pPVar1->int_10 = pPVar1->int_10 | 2;
	pPVar1[iVar2 + -1].previous = (PolyMeshData *)0x0;
	return pPVar1;
}



void __cdecl
lego::res::PolyMesh_FUN_00451e80
					(PolyMeshData *polyData,Container *resData,BOOL condition,int in_polyIndexUnk)
{
	char *name;
	Container *pCVar1;
	
	if (polyData != (PolyMeshData *)0x0) {
		do {
			if (in_polyIndexUnk == polyData->index) {
				if (polyData->resDataUnassigned_4 == (Container *)0x0) {
					name = Container_FormatPartName(resData,polyData->partName,(int *)0x0);
					pCVar1 = Container_SearchTree
														 (resData,name,CONTAINER_SEARCHMODE_FIRSTMATCH,(undefined4 *)0x0);
					polyData->resDataUnassigned_4 = pCVar1;
				}
				if (polyData->resDataUnassigned_4 != (Container *)0x0) {
					Container_Mesh_Swap(polyData->resDataUnassigned_4,(Container *)polyData->field_0,condition
														 );
				}
			}
			polyData = polyData->previous;
		} while (polyData != (PolyMeshData *)0x0);
	}
	return;
}



void __cdecl lego::res::PolyMesh_FUN_00451ef0(PolyMeshData *polyData)
{
	if (polyData != (PolyMeshData *)0x0) {
		do {
			polyData->resDataUnassigned_4 = (Container *)0x0;
			polyData = polyData->previous;
		} while (polyData != (PolyMeshData *)0x0);
	}
	return;
}



void __cdecl lego::res::PolyMesh_Destroy(PolyMeshData *polyData)
{
	PolyMeshData **ppPVar1;
	PolyMeshData *pPVar2;
	PolyMeshData *pPVar3;
	PolyMeshData *pPVar4;
	
	pPVar3 = (PolyMeshData *)0x0;
	pPVar2 = polyData;
	pPVar4 = pPVar3;
	if (polyData != (PolyMeshData *)0x0) {
		do {
			if ((*(byte *)&pPVar2->int_10 & 1) == 0) {
				if (pPVar2->partName != (char *)0x0) {
					std::free(pPVar2->partName);
				}
				if ((Container *)pPVar2->field_0 != (Container *)0x0) {
					Container_Remove((Container *)pPVar2->field_0);
				}
			}
			pPVar3 = pPVar2;
			if (((*(byte *)&pPVar2->int_10 & 2) == 0) && (pPVar3 = pPVar4, pPVar4 != (PolyMeshData *)0x0))
			{
				pPVar4->previous = pPVar2->previous;
			}
			ppPVar1 = &pPVar2->previous;
			pPVar2 = *ppPVar1;
			pPVar4 = pPVar3;
		} while (*ppPVar1 != (PolyMeshData *)0x0);
	}
	if ((pPVar3 != (PolyMeshData *)0x0) && (polyData != (PolyMeshData *)0x0)) {
		do {
			pPVar2 = polyData->previous;
			std::free(polyData);
			polyData = pPVar2;
		} while (pPVar2 != (PolyMeshData *)0x0);
	}
	return;
}



void __cdecl lego::main::Boot_InitTable_Message(void)
{
	globals::g_Messages_TABLE[0] = "Message_Null";
	globals::g_Messages_TABLE[1] = "Message_Select";
	globals::g_Messages_TABLE[2] = "Message_Selected";
	globals::g_Messages_TABLE[3] = "Message_ClearSelection";
	globals::g_Messages_TABLE[4] = "Message_Deselect";
	globals::g_Messages_TABLE[5] = "Message_Goto";
	globals::g_Messages_TABLE[6] = "Message_RockMonsterGoto";
	globals::g_Messages_TABLE[7] = "Message_RockMonsterGotoComplete";
	globals::g_Messages_TABLE[8] = "Message_UserGoto";
	globals::g_Messages_TABLE[9] = "Message_FirstPerson";
	globals::g_Messages_TABLE[10] = "Message_TrackObject";
	globals::g_Messages_TABLE[11] = "Message_TopView";
	globals::g_Messages_TABLE[12] = "Message_PlaySample";
	globals::g_Messages_TABLE[13] = "Message_Dig";
	globals::g_Messages_TABLE[14] = "Message_DigComplete";
	globals::g_Messages_TABLE[15] = "Message_Repair";
	globals::g_Messages_TABLE[16] = "Message_RepairComplete";
	globals::g_Messages_TABLE[17] = "Message_Reinforce";
	globals::g_Messages_TABLE[18] = "Message_ReinforceComplete";
	globals::g_Messages_TABLE[19] = "Message_RockFall";
	globals::g_Messages_TABLE[20] = "Message_RockFallComplete";
	globals::g_Messages_TABLE[21] = "Message_GenerateCrystal";
	globals::g_Messages_TABLE[22] = "Message_GenerateCrystalComplete";
	globals::g_Messages_TABLE[23] = "Message_CollectCrystal";
	globals::g_Messages_TABLE[24] = "Message_CollectCrystalComplete";
	globals::g_Messages_TABLE[25] = "Message_CrystalToRefinery";
	globals::g_Messages_TABLE[26] = "Message_CrystalToRefineryComplete";
	globals::g_Messages_TABLE[27] = "Message_GenerateOre";
	globals::g_Messages_TABLE[28] = "Message_GenerateOreComplete";
	globals::g_Messages_TABLE[29] = "Message_CollectOre";
	globals::g_Messages_TABLE[30] = "Message_CollectOreComplete";
	globals::g_Messages_TABLE[31] = "Message_GenerateRockMonster";
	globals::g_Messages_TABLE[32] = "Message_GenerateRockMonsterComplete";
	globals::g_Messages_TABLE[33] = "Message_GatherRock";
	globals::g_Messages_TABLE[34] = "Message_GatherRockComplete";
	globals::g_Messages_TABLE[35] = "Message_PickRandomFloor";
	globals::g_Messages_TABLE[36] = "Message_PickRandomFloorComplete";
	globals::g_Messages_TABLE[37] = "Message_AttackBuilding";
	globals::g_Messages_TABLE[38] = "Message_AttackBuildingComplete";
	globals::g_Messages_TABLE[39] = "Message_Clear";
	globals::g_Messages_TABLE[40] = "Message_ClearComplete";
	globals::g_Messages_TABLE[41] = "Message_GetIn";
	globals::g_Messages_TABLE[42] = "Message_ManSelectedAndMonsterClicked";
	globals::g_Messages_TABLE[43] = "Message_FollowAttack";
	globals::g_Messages_TABLE[44] = "Message_CollectTool";
	globals::g_Messages_TABLE[45] = "Message_ReduceSelection";
	globals::g_Messages_TABLE[46] = "Message_ClearFallIn";
	globals::g_Messages_TABLE[47] = "Message_ClearFallInComplete";
	globals::g_Messages_TABLE[48] = "Message_BuildPath";
	globals::g_Messages_TABLE[49] = "Message_BuildPathComplete";
	globals::g_Messages_TABLE[50] = "Message_Train";
	globals::g_Messages_TABLE[51] = "Message_TrainComplete";
	globals::g_Messages_TABLE[52] = "Message_GenerateCrystalAndOre";
	globals::g_Messages_TABLE[53] = "Message_GenerateCrystalAndOreComplete";
	globals::g_Messages_TABLE[54] = "Message_GenerateFromCryOre";
	globals::g_Messages_TABLE[55] = "Message_GenerateFromCryOreComplete";
	globals::g_Messages_TABLE[56] = "Message_Upgrade";
	globals::g_Messages_TABLE[57] = "Message_UpgradeComplete";
	globals::g_Messages_TABLE[58] = "Message_ClearBuilding";
	globals::g_Messages_TABLE[59] = "Message_ClearBuildingComplete";
	globals::g_Messages_TABLE[60] = "Message_ClearInitial";
	globals::g_Messages_TABLE[61] = "Message_ClearInitialComplete";
	globals::g_Messages_TABLE[62] = "Message_ClearRemovePath";
	globals::g_Messages_TABLE[63] = "Message_ClearRemovePathComplete";
	globals::g_Messages_TABLE[64] = "Message_Debug_DestroyAll";
	return;
}



void __cdecl lego::game::LiveObject_FUN_00452220(LiveObject *liveObj)
{
	int iVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	MessageAction *pMVar5;
	MessageAction *pMVar6;
	
	uVar4 = 0;
	uVar2 = UINT_ARRAY_004fff20[BOOL_004fff28];
	if (uVar2 != 0) {
		do {
			uVar3 = uVar2;
			if (liveObj == MessageAction_ARRAY_ARRAY_004ebf20[BOOL_004fff28][uVar4].object_4) {
				uVar3 = uVar2 - 1;
				pMVar5 = MessageAction_ARRAY_ARRAY_004ebf20[BOOL_004fff28 + -1] + uVar2 + 0x7ff;
				pMVar6 = MessageAction_ARRAY_ARRAY_004ebf20[BOOL_004fff28] + uVar4;
				for (iVar1 = 5; iVar1 != 0; iVar1 = iVar1 + -1) {
					pMVar6->event = pMVar5->event;
					pMVar5 = (MessageAction *)&pMVar5->object_4;
					pMVar6 = (MessageAction *)&pMVar6->object_4;
				}
				UINT_ARRAY_004fff20[BOOL_004fff28] = uVar3;
			}
			uVar4 = uVar4 + 1;
			uVar2 = uVar3;
		} while (uVar4 < uVar3);
	}
	return;
}



int __cdecl lego::game::Game_LookupPTLEventIndex(char *ptlName)
{
	int cmpResult;
	char **ppcVar1;
	int index;
	
	index = 0;
	ppcVar1 = globals::g_Messages_TABLE;
	do {
		cmpResult = std::_stricmp(*ppcVar1 + 8,ptlName);
		if (cmpResult == 0) {
			return index;
		}
		ppcVar1 = ppcVar1 + 1;
		index = index + 1;
	} while (ppcVar1 < &DAT_00500294);
	return cmpResult;
}



void __cdecl
lego::game::Debug_RegisterSelectedUnitHotkey
					(KeysByte key,MessageType event,LiveObject *liveObj,BOOL unkBool,Point2I *opt_position)
{
	uint uVar1;
	
	globals::g_SelectedUnit_Hotkeys_Keys_TABLE[globals::g_SelectedUnit_Hotkeys_COUNT] = key;
	uVar1 = globals::g_SelectedUnit_Hotkeys_COUNT;
	globals::g_SelectedUnit_Hotkeys_Actions_TABLE[globals::g_SelectedUnit_Hotkeys_COUNT].event = event
	;
	globals::g_SelectedUnit_Hotkeys_Actions_TABLE[uVar1].field_8 = unkBool;
	globals::g_SelectedUnit_Hotkeys_Actions_TABLE[uVar1].object_4 = liveObj;
	if (opt_position != (Point2I *)0x0) {
		globals::g_SelectedUnit_Hotkeys_Actions_TABLE[uVar1].position.x = opt_position->x;
		globals::g_SelectedUnit_Hotkeys_Actions_TABLE[uVar1].position.y = opt_position->y;
	}
	globals::g_SelectedUnit_Hotkeys_COUNT = globals::g_SelectedUnit_Hotkeys_COUNT + 1;
	return;
}



void __cdecl
lego::game::Level_AddMessageAction
					(MessageType msgType,LiveObject *liveObj,BOOL param_3,Point2I *opt_position)
{
	uint uVar1;
	BOOL BVar2;
	
	BVar2 = BOOL_004fff28;
	uVar1 = UINT_ARRAY_004fff20[BOOL_004fff28];
	if (uVar1 < 0x800) {
		UINT_ARRAY_004fff20[BOOL_004fff28] = uVar1 + 1;
		MessageAction_ARRAY_ARRAY_004ebf20[BVar2][uVar1].event = MESSAGE_NULL;
		MessageAction_ARRAY_ARRAY_004ebf20[BVar2][uVar1].object_4 = (LiveObject *)0x0;
		MessageAction_ARRAY_ARRAY_004ebf20[BVar2][uVar1].field_8 = 0;
		MessageAction_ARRAY_ARRAY_004ebf20[BVar2][uVar1].position.x = 0;
		MessageAction_ARRAY_ARRAY_004ebf20[BVar2][uVar1].position.y = 0;
		MessageAction_ARRAY_ARRAY_004ebf20[BVar2][uVar1].event = msgType;
		MessageAction_ARRAY_ARRAY_004ebf20[BVar2][uVar1].object_4 = liveObj;
		MessageAction_ARRAY_ARRAY_004ebf20[BVar2][uVar1].field_8 = param_3;
		if (opt_position != (Point2I *)0x0) {
			MessageAction_ARRAY_ARRAY_004ebf20[BVar2][uVar1].position.x = opt_position->x;
			MessageAction_ARRAY_ARRAY_004ebf20[BVar2][uVar1].position.y = opt_position->y;
		}
	}
	return;
}



void __cdecl lego::game::Game_PTL_UNKInit__00452390(void)
{
	BOOL BVar1;
	BOOL *pBVar2;
	LiveObject **ppLVar3;
	uint uVar4;
	
	if (((globals::g_Game.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) &&
		 (uVar4 = 0, globals::g_SelectedUnit_Hotkeys_COUNT != 0)) {
		pBVar2 = &globals::g_SelectedUnit_Hotkeys_Actions_TABLE[0].field_8;
		do {
			if (globs::INPUT.Key_Map[globals::g_SelectedUnit_Hotkeys_Keys_TABLE[uVar4]] != false) {
				Level_AddMessageAction(pBVar2[-2],pBVar2[-1],*pBVar2,(Point2I *)(pBVar2 + 1));
			}
			uVar4 = uVar4 + 1;
			pBVar2 = pBVar2 + 5;
		} while (uVar4 < globals::g_SelectedUnit_Hotkeys_COUNT);
	}
	uVar4 = 0;
	if (UINT_ARRAY_004fff20[BOOL_004fff28] != 0) {
		do {
			Game_PTLEventToAction__0045db30(MessageAction_ARRAY_ARRAY_004ebf20[BOOL_004fff28] + uVar4);
			uVar4 = uVar4 + 1;
		} while (uVar4 < UINT_ARRAY_004fff20[BOOL_004fff28]);
	}
	BVar1 = BOOL_004fff28;
	uVar4 = UINT_ARRAY_004fff20[BOOL_004fff28];
	UINT_ARRAY_004fff20[BOOL_004fff28] = 0;
	BOOL_004fff28 = ZEXT14(BOOL_004fff28 == 0);
	UINT_ARRAY_004fff20[BOOL_004fff28] = 0;
	if (uVar4 != 0) {
		ppLVar3 = (LiveObject **)&MessageAction_ARRAY_ARRAY_004ebf20[BVar1][0].field_8;
		do {
			switch(ppLVar3[-2]) {
			case (LiveObject *)0x1:
				LiveObject_FUN_00452980(ppLVar3[-1],(int)*ppLVar3);
				break;
			case (LiveObject *)0x3:
				Game_UnselectAllUnits();
				break;
			case (LiveObject *)0x4:
				LiveObject_SelectedUnits_FUN_00452f10(ppLVar3[-1]);
				break;
			case (LiveObject *)0x5:
			case (LiveObject *)0x6:
				ai::AITask_DoGoto_AtPosition(ppLVar3[-1],(Point2I *)(ppLVar3 + 1),*ppLVar3);
				break;
			case (LiveObject *)0x8:
				ai::AITask_DoGoto_Group
									(globals::g_SelectedUnits_TABLE,globals::g_SelectedUnits_COUNT,
									 (Point2I *)(ppLVar3 + 1),(BOOL)*ppLVar3);
				break;
			case (LiveObject *)0x9:
				Game_SelectedUnits_FUN_00453020((int)*ppLVar3);
				break;
			case (LiveObject *)0xa:
				if (globals::g_SelectedUnits_COUNT != 0) {
					LiveObject_FUN_00425c80(globals::g_SelectedUnits_TABLE[0]);
				}
				break;
			case (LiveObject *)0xb:
				FUN_00429520(1,(LiveObject *)0x0,0);
				break;
			case (LiveObject *)0xc:
				snd::Audio_Play_FUN_00465260((SFXType)*ppLVar3,0);
				break;
			case (LiveObject *)0x13:
				FUN_004316b0((uint)ppLVar3[1],(uint)ppLVar3[2],(uint)*ppLVar3 & 0xffff,
										 (float)((uint)*ppLVar3 >> 0x10));
				break;
			case (LiveObject *)0x15:
				Level_GenerateCrystal((Point2I *)(ppLVar3 + 1),0,(Point2F *)0x0,1);
				break;
			case (LiveObject *)0x17:
				ai::AITask_DoCollect(ppLVar3[-1],0.0);
				break;
			case (LiveObject *)0x19:
				ai::AITask_DoDeposit_Target(ppLVar3[-1],*ppLVar3);
				break;
			case (LiveObject *)0x1b:
				Level_GenerateOre((Point2I *)(ppLVar3 + 1),0,(Point2F *)0x0,1);
				break;
			case (LiveObject *)0x1d:
				ai::AITask_DoCollect(ppLVar3[-1],0.0);
				break;
			case (LiveObject *)0x1f:
				FUN_0043b160();
				break;
			case (LiveObject *)0x21:
				LiveObject_TryCarryBoulder_FUN_00447390(ppLVar3[-1]);
				break;
			case (LiveObject *)0x23:
				FUN_004526f0(ppLVar3[-1]);
				break;
			case (LiveObject *)0x25:
				LiveObject_FUN_004474d0(ppLVar3[-1],*ppLVar3);
				break;
			case (LiveObject *)0x2b:
				ai::AITask_DoFollowAttack(ppLVar3[-1],*ppLVar3);
				break;
			case (LiveObject *)0x2d:
				Game_UnkSelectedUnits_FUN_00452b80();
				break;
			case (LiveObject *)0x34:
				FUN_00439600((uint *)(ppLVar3 + 1),0);
				break;
			case (LiveObject *)0x36:
				Level_GenerateCryOreAt((Point2I *)(ppLVar3 + 1));
				break;
			case (LiveObject *)0x40:
				Game_SelectedUnits_FUN_00452f80();
			}
			ppLVar3 = ppLVar3 + 5;
			uVar4 = uVar4 - 1;
		} while (uVar4 != 0);
	}
	return;
}



void __cdecl FUN_004526f0(LiveObject *liveObj)
{
	int iVar1;
	int iVar2;
	bool bVar3;
	short sVar4;
	SurfaceMap *pSVar5;
	BOOL BVar6;
	uint uVar7;
	Point2I local_8;
	
	pSVar5 = lego::game::GetSurfaceMap();
	iVar1 = (pSVar5->smallDimensions).width;
	pSVar5 = lego::game::GetSurfaceMap();
	iVar2 = (pSVar5->smallDimensions).height;
	bVar3 = false;
	uVar7 = 0;
	do {
		sVar4 = lego::math::Maths_Rand();
		local_8.x = (int)sVar4 % iVar1;
		sVar4 = lego::math::Maths_Rand();
		local_8.y = (int)sVar4 % iVar2;
		BVar6 = lego::game::Level_GetBlockFlags1_8(local_8.x,local_8.y);
		if (BVar6 != 0) {
			bVar3 = true;
			break;
		}
		uVar7 = uVar7 + 1;
	} while (uVar7 < 1000);
	if (bVar3) {
		lego::game::Level_AddMessageAction(MESSAGE_PICKRANDOMFLOOR_COMPLETE,liveObj,0,&local_8);
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_00452770(LiveObject *liveObj)
{
	LiveObject_FUN_00452220(liveObj);
	LiveObject_SelectedUnits_FUN_00452f10(liveObj);
	if (globals::g_Game.objectFP == liveObj) {
		FUN_00429520(1,(LiveObject *)0x0,0);
		globals::g_Game.objectFP = (LiveObject *)0x0;
	}
	if ((globals::g_Game.cameraRadar)->object_4 == liveObj) {
		(globals::g_Game.cameraRadar)->object_4 = (LiveObject *)0x0;
		LiveObject_GetPosition
							(liveObj,(float *)&globals::g_Game.tvFaceDirection_338,
							 &globals::g_Game.tvFaceDirection_338.y);
		globals::g_Game.flags1 = globals::g_Game.flags1 | GAME1_UNK_4000;
	}
	return;
}



BOOL __cdecl lego::game::Game_CopySelectedUnits(LiveObject **out_unitsTable,uint *out_unitsCount)
{
	LiveObject *pLVar1;
	uint uVar2;
	int iVar3;
	LiveObject **ppLVar4;
	
	if (globals::g_SelectedUnits_COUNT != 0) {
		*out_unitsCount = globals::g_SelectedUnits_COUNT;
		pLVar1 = (LiveObject *)std::malloc(globals::g_SelectedUnits_COUNT * 4);
		*out_unitsTable = pLVar1;
		ppLVar4 = globals::g_SelectedUnits_TABLE;
		for (uVar2 = *out_unitsCount & 0x3fffffff; uVar2 != 0; uVar2 = uVar2 - 1) {
			pLVar1->objType = (ObjectType)*ppLVar4;
			ppLVar4 = ppLVar4 + 1;
			pLVar1 = (LiveObject *)&pLVar1->objIndex;
		}
		for (iVar3 = 0; iVar3 != 0; iVar3 = iVar3 + -1) {
			*(undefined *)&pLVar1->objType = *(undefined *)ppLVar4;
			ppLVar4 = (LiveObject **)((int)ppLVar4 + 1);
			pLVar1 = (LiveObject *)((int)&pLVar1->objType + 1);
		}
		return 1;
	}
	return 0;
}



// Returns the table of selected units, and can return the number of units in the table with
// out_count

LiveObject ** __cdecl lego::game::Game_GetSelectedUnits(int *out_count)
{
	if (globals::g_SelectedUnits_COUNT != 0) {
		if (out_count != (int *)0x0) {
			*out_count = globals::g_SelectedUnits_COUNT;
		}
		return globals::g_SelectedUnits_TABLE;
	}
	if (out_count != (int *)0x0) {
		*out_count = 0;
	}
	return (LiveObject **)0x0;
}



BOOL __cdecl lego::game::Game_IsAnyUnitsSelected(void)
{
	return (uint)(globals::g_SelectedUnits_COUNT != 0);
}



LiveObject * __cdecl lego::game::Game_GetPrimarySelectedObject(void)
{
										// Return the first-selected Object if count is non-zero (otherwise address is
										// masked against 0x0)
	return (LiveObject *)
				 (-(uint)(globals::g_SelectedUnits_COUNT != 0) & (uint)globals::g_SelectedUnits_TABLE[0]);
}



LiveObject ** __cdecl lego::game::Game_GetSelectedUnits(void)
{
	return globals::g_SelectedUnits_TABLE;
}



uint __cdecl lego::game::Game_GetNumSelectedUnits(void)
{
	return globals::g_SelectedUnits_COUNT;
}



void __cdecl lego::game::Game_CleanupSelectedUnitsCount(void)
{
	globals::g_SelectedUnits_COUNT = 0;
	return;
}



BOOL __cdecl lego::game::LiveObject_Check_FUN_004528d0(LiveObject *liveObj,uint *out_index)
{
	LiveFlags3 LVar1;
	
	if (out_index != (uint *)0x0) {
		LVar1 = LiveObject_FindIndexOfInTable
											(globals::g_SelectedUnits_TABLE,globals::g_SelectedUnits_COUNT,liveObj,
											 out_index);
		return LVar1;
	}
	return liveObj->flags3 & 0x200000;
}



BOOL __cdecl
lego::game::LiveObject_FindIndexOfInTable
					(LiveObject **objsTable,uint objsCount,LiveObject *thisObj,uint *out_index)
{
	uint uVar1;
	
	uVar1 = 0;
	if (objsCount == 0) {
		return 0;
	}
	do {
		if (*objsTable == thisObj) {
			if (out_index != (uint *)0x0) {
				*out_index = uVar1;
			}
			return 1;
		}
		uVar1 = uVar1 + 1;
		objsTable = objsTable + 1;
	} while (uVar1 < objsCount);
	return 0;
}



BOOL __cdecl lego::game::LiveObject_Check_FUN_00452950(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_Check_FUN_004528d0(liveObj,(uint *)0x0);
	if ((BVar1 == 0) && ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_2) == 0)) {
		return 0;
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_FUN_00452980(LiveObject *liveObj,int param_2)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_FUN_004529a0(liveObj,param_2,1);
	return BVar1;
}



BOOL __cdecl lego::game::LiveObject_FUN_004529a0(LiveObject *liveObj,int param_2,int param_3)
{
	BOOL BVar1;
	ObjectStatsFlags1 OVar2;
	Container *cont;
	Point2F local_14;
	Vector3F local_c;
	
	if (liveObj->carryingThisObject != (LiveObject *)0x0) {
		liveObj = liveObj->carryingThisObject;
	}
	BVar1 = LiveObject_Check_FUN_00452b30(liveObj);
	if (BVar1 != 0) {
		if (param_2 == 0) {
			BVar1 = LiveObject_Check_FUN_00452950(liveObj);
			if (BVar1 != 0) {
				LiveObject_FUN_0044c760(liveObj);
				return 0;
			}
		}
		BVar1 = LiveObject_Check_FUN_004528d0(liveObj,(uint *)0x0);
		if ((BVar1 == 0) && (globals::g_SelectedUnits_COUNT < 100)) {
			unk::DoLiveObjCallbacks_True_FUN_00437a70(LiveObject_FUN_0044c7c0,(LiveObject *)0x0);
			globals::g_SelectedUnits_TABLE[globals::g_SelectedUnits_COUNT] = liveObj;
			globals::g_SelectedUnits_COUNT = globals::g_SelectedUnits_COUNT + 1;
			liveObj->flags3 = liveObj->flags3 | 0x200000;
			if ((liveObj->objType != OBJECT_BUILDING) &&
				 (((liveObj->flags1 & (LIVEOBJ1_UNK_2000|LIVEOBJ1_UNK_4000000|LIVEOBJ1_REST)) ==
					 LIVEOBJ1_NONE && ((liveObj->flags2 & LIVEOBJ2_UNK_100) == LIVEOBJ2_NONE)))) {
				LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
				ai::AITask_VariousGatherTasks_FUN_00403a90(liveObj);
				if ((liveObj->objType == OBJECT_MINIFIGURE) && (param_3 != 0)) {
					res::Container_GetOrientation
										((globals::g_Game.cameraMain)->resData4,(Container *)0x0,&local_c,
										 (Vector3F *)0x0);
					local_14.x = -local_c.x;
					local_14.y = -local_c.y;
					LiveObject_FUN_00441df0(liveObj,0,0);
					LiveObject_FUN_00445270(liveObj,&local_14);
				}
			}
			if ((*(byte *)&liveObj->flags3 & 0x80) != 0) {
				OVar2 = LiveObject_GetStatsFlags1(liveObj);
				if (((OVar2 & STATS1_CANBEDRIVEN) == STATS1_NONE) ||
					 (liveObj->drivenObject != (LiveObject *)0x0)) {
					cont = LiveObject_GetResource(liveObj);
					res::Res_PlayResourceSound(cont,SFX_YESSIR,FALSE,TRUE,(Vector3F *)0x0);
					return TRUE;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_Check_FUN_00452b30(LiveObject *liveObj)
{
	BOOL BVar1;
	
	if ((liveObj->flags3 & 0x100) != LIVEOBJ3_NONE) {
		BVar1 = LiveObject_CheckCondition_FUN_00438870(liveObj,TRUE);
		if ((((BVar1 != 0) && ((*(byte *)&liveObj->flags2 & 10) == 0)) &&
				((liveObj->flags1 & (LIVEOBJ1_UNK_4000000|LIVEOBJ1_REST)) == LIVEOBJ1_NONE)) &&
			 ((liveObj->objType != OBJECT_VEHICLE ||
				((liveObj->flags1 & LIVEOBJ1_CLEARING) == LIVEOBJ1_NONE)))) {
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::game::Game_UnkSelectedUnits_FUN_00452b80(void)
{
	LiveObject *pLVar1;
	ObjectType OVar2;
	LiveObject *pLVar3;
	bool bVar4;
	bool bVar5;
	bool bVar6;
	bool bVar7;
	bool bVar8;
	bool bVar9;
	bool bVar10;
	bool bVar11;
	ObjectStatsFlags1 OVar12;
	LiveObject **ppLVar13;
	uint uVar14;
	int iVar15;
	
	uVar14 = 0;
	bVar5 = false;
	bVar6 = false;
	bVar8 = false;
	bVar7 = false;
	bVar9 = false;
	bVar10 = false;
	bVar11 = false;
	if (globals::g_SelectedUnits_COUNT != 0) {
		ppLVar13 = globals::g_SelectedUnits_TABLE;
		do {
			pLVar1 = *ppLVar13;
			if ((pLVar1->objType == OBJECT_MINIFIGURE) && (pLVar1->drivenObject == (LiveObject *)0x0)) {
				bVar5 = true;
				break;
			}
			OVar12 = LiveObject_GetStatsFlags1(pLVar1);
			if ((OVar12 & STATS1_CANBEDRIVEN) == STATS1_NONE) {
				OVar2 = pLVar1->objType;
				if (OVar2 == OBJECT_VEHICLE) {
					OVar12 = LiveObject_GetStatsFlags1(pLVar1);
					if (((OVar12 & STATS1_CROSSLAND) == STATS1_NONE) &&
						 ((*(byte *)&pLVar1->flags4 & 0x40) == 0)) {
						bVar7 = true;
					}
					else {
						bVar6 = true;
					}
				}
				else {
					if (OVar2 == OBJECT_BUILDING) {
						bVar9 = true;
					}
					else {
						if ((OVar2 == OBJECT_ELECTRICFENCE) &&
							 ((pLVar1->flags2 & LIVEOBJ2_UNK_2000000) != LIVEOBJ2_NONE)) {
							bVar10 = true;
						}
					}
				}
			}
			else {
				if (pLVar1->drivenObject == (LiveObject *)0x0) {
					bVar8 = true;
				}
				else {
					OVar12 = LiveObject_GetStatsFlags1(pLVar1);
					if (((OVar12 & STATS1_CROSSLAND) == STATS1_NONE) &&
						 ((*(byte *)&pLVar1->flags4 & 0x40) == 0)) {
						bVar7 = true;
					}
					else {
						bVar6 = true;
					}
				}
			}
			uVar14 = uVar14 + 1;
			ppLVar13 = ppLVar13 + 1;
		} while (uVar14 < globals::g_SelectedUnits_COUNT);
	}
	uVar14 = 0;
	if (bVar5) {
		FUN_0041b200(9,(Point2I *)0x0);
		bVar7 = false;
		bVar6 = false;
		bVar8 = false;
		bVar9 = false;
		bVar10 = false;
	}
	else {
		if (bVar6) {
			FUN_0041b200(10,(Point2I *)0x0);
			bVar7 = false;
			bVar8 = false;
			bVar9 = false;
			bVar10 = false;
		}
		else {
			if (bVar7) {
				FUN_0041b200(0xb,(Point2I *)0x0);
				bVar8 = false;
				bVar9 = false;
				bVar10 = false;
			}
			else {
				if (bVar8) {
					FUN_0041b200(0xc,(Point2I *)0x0);
					bVar9 = false;
					bVar10 = false;
				}
				else {
					if (bVar9) {
						FUN_0041b200(0xd,(Point2I *)0x0);
						bVar10 = false;
					}
					else {
						bVar11 = !bVar10;
						if (bVar11) {
							iVar15 = 0;
						}
						else {
							iVar15 = 0xe;
						}
						FUN_0041b200(iVar15,(Point2I *)0x0);
					}
				}
			}
		}
	}
	if (globals::g_SelectedUnits_COUNT != 0) {
		ppLVar13 = globals::g_SelectedUnits_TABLE;
		do {
			pLVar1 = *ppLVar13;
			bVar4 = false;
			if ((bVar5) &&
				 ((pLVar1->objType != OBJECT_MINIFIGURE || (pLVar1->drivenObject != (LiveObject *)0x0))))
			goto LAB_00452e44;
			if (bVar6) {
				OVar12 = LiveObject_GetStatsFlags1(pLVar1);
				if ((OVar12 & STATS1_CANBEDRIVEN) == STATS1_NONE) {
LAB_00452df3:
					if (pLVar1->objType != OBJECT_VEHICLE) goto LAB_00452e44;
				}
				else {
					OVar12 = LiveObject_GetStatsFlags1(pLVar1);
					if (((OVar12 & STATS1_CROSSLAND) == STATS1_NONE) &&
						 ((*(byte *)&pLVar1->flags4 & 0x40) == 0)) {
LAB_00452de2:
						bVar4 = true;
					}
LAB_00452de7:
					pLVar3 = pLVar1->drivenObject;
joined_r0x00452e42:
					if (pLVar3 == (LiveObject *)0x0) goto LAB_00452e44;
				}
			}
			else {
				if (bVar7) {
					OVar12 = LiveObject_GetStatsFlags1(pLVar1);
					if ((OVar12 & STATS1_CANBEDRIVEN) == STATS1_NONE) goto LAB_00452df3;
					OVar12 = LiveObject_GetStatsFlags1(pLVar1);
					if (((OVar12 & STATS1_CROSSLAND) != STATS1_NONE) ||
						 ((*(byte *)&pLVar1->flags4 & 0x40) != 0)) goto LAB_00452de2;
					goto LAB_00452de7;
				}
				if (bVar8) {
					OVar12 = LiveObject_GetStatsFlags1(pLVar1);
					if ((OVar12 & STATS1_CANBEDRIVEN) != STATS1_NONE) {
						pLVar3 = pLVar1->drivenObject;
						goto joined_r0x00452e42;
					}
				}
				else {
					if ((!bVar9) || (pLVar1->objType == OBJECT_BUILDING)) {
						if (!bVar10) goto LAB_00452e49;
						if (pLVar1->objType == OBJECT_ELECTRICFENCE) {
							pLVar3 = (LiveObject *)(pLVar1->flags2 & LIVEOBJ2_UNK_2000000);
							goto joined_r0x00452e42;
						}
					}
				}
LAB_00452e44:
				bVar4 = true;
			}
LAB_00452e49:
			if ((bVar4) || (bVar11)) {
				globals::g_SelectedUnits_COUNT = globals::g_SelectedUnits_COUNT - 1;
				*ppLVar13 = globals::g_SelectedUnits_TABLE[globals::g_SelectedUnits_COUNT];
				uVar14 = uVar14 - 1;
				pLVar1->flags3 = pLVar1->flags3 & 0xffdfffff;
				ppLVar13 = ppLVar13 + -1;
			}
			uVar14 = uVar14 + 1;
			ppLVar13 = ppLVar13 + 1;
		} while (uVar14 < globals::g_SelectedUnits_COUNT);
	}
	return;
}



void __cdecl lego::game::Game_UnselectAllUnits(void)
{
	LiveFlags4 *pLVar1;
	LiveObject **ppLVar2;
	uint uVar3;
	
	uVar3 = 0;
	if (globals::g_SelectedUnits_COUNT != 0) {
		ppLVar2 = globals::g_SelectedUnits_TABLE;
		do {
			if (((*ppLVar2)->flags3 & 0x200000) != LIVEOBJ3_NONE) {
				pLVar1 = &(*ppLVar2)->flags4;
				*pLVar1 = *pLVar1 | LIVEOBJ4_UNK_2;
			}
			(*ppLVar2)->flags3 = (*ppLVar2)->flags3 & 0xffdfffff;
			(*ppLVar2)->flags4 = (*ppLVar2)->flags4 & 0xfffffffe;
			uVar3 = uVar3 + 1;
			ppLVar2 = ppLVar2 + 1;
		} while (uVar3 < globals::g_SelectedUnits_COUNT);
	}
	globals::g_SelectedUnits_COUNT = 0;
	return;
}



BOOL __cdecl lego::game::LiveObject_SelectedUnits_FUN_00452f10(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	BOOL BVar2;
	
	pLVar1 = liveObj;
	if (globals::g_SelectedUnits_COUNT != 0) {
		BVar2 = LiveObject_Check_FUN_004528d0(liveObj,(uint *)&liveObj);
		if (BVar2 != 0) {
			if (liveObj == (LiveObject *)0x0) {
				FUN_0041b200(0,(Point2I *)0x0);
			}
										// param_1 is no longer liveObject, transformed by first function call of this
										// function
			globals::g_SelectedUnits_COUNT = globals::g_SelectedUnits_COUNT - 1;
			globals::g_SelectedUnits_TABLE[(int)liveObj] =
					 globals::g_SelectedUnits_TABLE[globals::g_SelectedUnits_COUNT];
			pLVar1->flags3 = pLVar1->flags3 & 0xffdfffff;
			return 1;
		}
	}
	return 0;
}



int __cdecl lego::game::Game_SelectedUnits_FUN_00452f80(void)
{
	LiveObject *pLVar1;
	ObjectStatsFlags1 OVar2;
	uint uVar3;
	
	uVar3 = globals::g_SelectedUnits_COUNT;
	if (globals::g_SelectedUnits_COUNT != 0) {
		do {
			OVar2 = LiveObject_GetStatsFlags1(globals::g_SelectedUnits_TABLE[0]);
			if (((OVar2 & STATS1_CANBEDRIVEN) != STATS1_NONE) &&
				 (pLVar1 = globals::g_SelectedUnits_TABLE[0]->drivenObject, pLVar1 != (LiveObject *)0x0)) {
				pLVar1->flags2 = pLVar1->flags2 & ~LIVEOBJ2_DRIVING;
				globals::g_SelectedUnits_TABLE[0]->drivenObject->drivenObject = (LiveObject *)0x0;
			}
			if (globals::g_SelectedUnits_TABLE[0]->objType == OBJECT_BUILDING) {
				LiveObject_FUN_00409f20(globals::g_SelectedUnits_TABLE[0]);
			}
			else {
				if (globals::g_SelectedUnits_TABLE[0]->objType == OBJECT_ELECTRICFENCE) {
					LiveObject_FUN_0040cfd0(globals::g_SelectedUnits_TABLE[0]);
				}
				pool::ReservedPool_LiveObject___Release(globals::g_SelectedUnits_TABLE[0]);
			}
			uVar3 = uVar3 - 1;
		} while (uVar3 != 0);
	}
	return globals::g_SelectedUnits_COUNT;
}



BOOL __cdecl lego::game::Game_SelectedUnits_FUN_00453020(int param_1)
{
	LiveObject *liveObj;
	LiveObject **ppLVar1;
	uint uVar2;
	
	if (((globals::g_Game.objectFP != (LiveObject *)0x0) &&
			((*(byte *)&(globals::g_Game.objectFP)->flags3 & 0x10) != 0)) &&
		 ((liveObj = globals::g_Game.objectFP, (globals::g_Game.objectFP)->objType == OBJECT_MINIFIGURE
			|| ((globals::g_Game.objectFP)->drivenObject != (LiveObject *)0x0)))) {
LAB_00453096:
		FUN_00429520(0,liveObj,param_1);
		return 1;
	}
	uVar2 = 0;
	if (globals::g_SelectedUnits_COUNT != 0) {
		ppLVar1 = globals::g_SelectedUnits_TABLE;
		do {
			liveObj = *ppLVar1;
			if ((liveObj->objType == OBJECT_MINIFIGURE) && (liveObj->drivenObject != (LiveObject *)0x0)) {
				liveObj = liveObj->drivenObject;
			}
			if (((*(byte *)&liveObj->flags3 & 0x10) != 0) &&
				 ((liveObj->objType == OBJECT_MINIFIGURE || (liveObj->drivenObject != (LiveObject *)0x0))))
			goto LAB_00453096;
			uVar2 = uVar2 + 1;
			ppLVar1 = ppLVar1 + 1;
		} while (uVar2 < globals::g_SelectedUnits_COUNT);
	}
	return 0;
}



BOOL __cdecl lego::game::Level_LoadNERPsFile(char *filename)
{
	int iVar1;
	BOOL *pBVar2;
	int *piVar3;
	int local_4;
	
	pBVar2 = &globals::nerps::g_NERPs_Camera_IsLockedOn;
	for (iVar1 = 0x2d; iVar1 != 0; iVar1 = iVar1 + -1) {
		*pBVar2 = 0;
		pBVar2 = pBVar2 + 1;
	}
	local_4 = 1;
	FUN_0046ad50();
	globals::nerps::g_NERPs_FileLength = 0;
	piVar3 = globals::nerps::g_NERPs_REGISTERS_TABLE;
	for (iVar1 = 0xb; iVar1 != 0; iVar1 = iVar1 + -1) {
		*piVar3 = 0;
		piVar3 = piVar3 + 1;
	}
	globals::nerps::g_NERPs_FileData = (void *)0x0;
	globals::nerps::g_NERPs_IsLoaded = 1;
	nerps::funcs::NERPFunc__SetMessagePermit(&local_4);
	globals::nerps::g_NERPs_FileData =
			 lego::file::File_LoadBinary(filename,&globals::nerps::g_NERPs_FileLength);
	return (uint)((byte *)globals::nerps::g_NERPs_FileData != (byte *)0x0);
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

BOOL __cdecl lego::game::Level_LoadNERPMessageFile(char *filename)
{
	undefined4 *puVar1;
	NERPMessageSound *pNVar2;
	char cVar3;
	byte bVar4;
	IDirectDrawSurface4 **ppIVar5;
	char *buffer;
	ImageBMP *pIVar6;
	void *pvVar7;
	char *pcVar8;
	int iVar9;
	NERPMessageSound *pNVar10;
	uint uVar11;
	char **ppcVar12;
	char **ppcVar13;
	byte *pbVar14;
	uint uVar15;
	bool bVar16;
	uint uStack8464;
	byte *pbStack8460;
	char **ppcStack8456;
	int iStack8452;
	char acStack8448 [128];
	ImageBMP aIStack8320 [4];
	char acStack8192 [4096];
	char local_1000 [4092];
	undefined4 uStack4;
	
	uStack4 = 0x45313a;
	bVar16 = true;
	uStack8464 = 0;
	buffer = (char *)lego::file::File_LoadBinary(filename,(uint *)&pbStack8460);
	if (buffer == (char *)0x0) {
		globals::nerps::g_NERPMessageBuffer = buffer;
		globals::nerps::g_NERPMessageSounds_UNKCOUNT = globals::nerps::g_NERPMessageSounds_COUNT;
		return 0;
	}
	globals::nerps::g_NERPMessageBuffer = buffer;
	if (pbStack8460 != (byte *)0x0) {
		iStack8452 = 0;
		pbVar14 = pbStack8460;
		do {
			if (*buffer == '_') {
				*buffer = ' ';
			}
			bVar4 = *buffer;
			pIVar6 = (ImageBMP *)((uint)pbVar14 & 0xffffff00 | (uint)bVar4);
			if (bVar4 < 0x20) {
				*buffer = 0;
				bVar16 = true;
			}
			else {
				if (bVar16) {
					if (bVar4 == ':') {
						pIVar6 = aIStack8320;
						pbVar14 = (byte *)buffer + 1;
						std::sscanf((char *)pbVar14,"%s",pIVar6);
						buffer = (char *)pbVar14;
						if (pIVar6 != (ImageBMP *)0x0) {
							uVar15 = 0xffffffff;
							pIVar6 = aIStack8320;
							do {
								if (uVar15 == 0) break;
								uVar15 = uVar15 - 1;
								ppIVar5 = &pIVar6->surface;
								pIVar6 = (ImageBMP *)((int)&pIVar6->surface + 1);
							} while (*(char *)ppIVar5 != '\0');
							bVar16 = false;
							buffer = (char *)(pbVar14 + (~uVar15 - 1));
							bVar4 = *buffer;
							for (; (pIVar6 = (ImageBMP *)(uint)bVar4, bVar4 < 0x21 &&
										 ((byte *)buffer + -(int)globals::nerps::g_NERPMessageBuffer < pbStack8460));
									buffer = (char *)((byte *)buffer + 1)) {
								if (bVar4 == '\r') {
									bVar16 = true;
								}
								*buffer = 0;
								bVar4 = ((byte *)buffer)[1];
							}
							std::sscanf(buffer,"%s",acStack8448);
							if ((pIVar6 != (ImageBMP *)0x0) && (!bVar16)) {
								uVar15 = 0xffffffff;
								pcVar8 = acStack8448;
								do {
									if (uVar15 == 0) break;
									uVar15 = uVar15 - 1;
									cVar3 = *pcVar8;
									pcVar8 = pcVar8 + 1;
								} while (cVar3 != '\0');
								buffer = (char *)((byte *)buffer + (~uVar15 - 1));
								pIVar6 = image::Image_LoadBMPScaled(acStack8448,0,0);
								if (pIVar6 != (ImageBMP *)0x0) {
									pvVar7 = std::malloc(globals::nerps::g_NERPMessages_COUNT * 8 + 8);
									uVar15 = 0;
									bVar16 = globals::nerps::g_NERPMessages_COUNT == 0;
									if (!bVar16) {
										do {
											puVar1 = (undefined4 *)
															 ((int)globals::nerps::g_NERPMessages_TABLE + uVar15 * 8);
											uVar15 = uVar15 + 1;
											*(undefined4 *)((int)pvVar7 + uVar15 * 8 + -8) = *puVar1;
											*(undefined4 *)((int)pvVar7 + uVar15 * 8 + -4) = puVar1[1];
										} while (uVar15 < (uint)globals::nerps::g_NERPMessages_COUNT);
										bVar16 = globals::nerps::g_NERPMessages_COUNT == 0;
									}
									if (!bVar16) {
										std::free(globals::nerps::g_NERPMessages_TABLE);
									}
									*(byte **)((int)pvVar7 + globals::nerps::g_NERPMessages_COUNT * 8) = pbVar14;
									*(ImageBMP **)((int)pvVar7 + globals::nerps::g_NERPMessages_COUNT * 8 + 4) =
											 pIVar6;
									pIVar6 = (ImageBMP *)(globals::nerps::g_NERPMessages_COUNT + 1);
									globals::nerps::g_NERPMessages_COUNT = (int)pIVar6;
									globals::nerps::g_NERPMessages_TABLE = pvVar7;
								}
							}
						}
					}
					iVar9 = iStack8452;
					if (*buffer == '$') {
						pbVar14 = (byte *)buffer + 1;
						std::sscanf((char *)pbVar14,"%s",local_1000);
						buffer = (char *)pbVar14;
						if (pIVar6 != (ImageBMP *)0x0) {
							uVar15 = 0xffffffff;
							pcVar8 = local_1000;
							do {
								if (uVar15 == 0) break;
								uVar15 = uVar15 - 1;
								cVar3 = *pcVar8;
								pcVar8 = pcVar8 + 1;
							} while (cVar3 != '\0');
							bVar16 = false;
							buffer = (char *)(pbVar14 + (~uVar15 - 1));
							bVar4 = *buffer;
							for (; (bVar4 < 0x21 &&
										 ((byte *)buffer + -(int)globals::nerps::g_NERPMessageBuffer < pbStack8460));
									buffer = (char *)((byte *)buffer + 1)) {
								if (bVar4 == '\r') {
									bVar16 = true;
								}
								*buffer = 0;
								bVar4 = ((byte *)buffer)[1];
							}
							pcVar8 = acStack8192;
							std::sscanf(buffer,"%s",pcVar8);
							if ((pcVar8 != (char *)0x0) && (!bVar16)) {
								uVar15 = 0xffffffff;
								pcVar8 = acStack8192;
								do {
									if (uVar15 == 0) break;
									uVar15 = uVar15 - 1;
									cVar3 = *pcVar8;
									pcVar8 = pcVar8 + 1;
								} while (cVar3 != '\0');
								buffer = (char *)((byte *)buffer + (~uVar15 - 1));
								iVar9 = snd::Sound3D_Load(acStack8192,1,0,0);
								if (iVar9 != 0) {
									pNVar10 = (NERPMessageSound *)
														std::malloc(globals::nerps::g_NERPMessageSounds_COUNT * 8 + 8);
									bVar16 = globals::nerps::g_NERPMessageSounds_COUNT == 0;
									uVar15 = 0;
									if (!bVar16) {
										do {
											pNVar2 = globals::nerps::g_NERPMessageSounds_TABLE + uVar15;
											uVar11 = uVar15 + 1;
											pNVar10[uVar15].key = pNVar2->key;
											pNVar10[uVar15].sampleIndex = pNVar2->sampleIndex;
											uVar15 = uVar11;
										} while (uVar11 < (uint)globals::nerps::g_NERPMessageSounds_COUNT);
										bVar16 = globals::nerps::g_NERPMessageSounds_COUNT == 0;
									}
									if (!bVar16) {
										std::free(globals::nerps::g_NERPMessageSounds_TABLE);
									}
									pNVar10[globals::nerps::g_NERPMessageSounds_COUNT].key = (char *)pbVar14;
									pNVar10[globals::nerps::g_NERPMessageSounds_COUNT].sampleIndex = iVar9;
									globals::nerps::g_NERPMessageSounds_COUNT =
											 globals::nerps::g_NERPMessageSounds_COUNT + 1;
									globals::nerps::g_NERPMessageSounds_TABLE = pNVar10;
									globals::nerps::g_NERPMessageSounds_UNKCOUNT =
											 globals::nerps::g_NERPMessageSounds_COUNT;
								}
							}
						}
					}
					else {
						ppcVar12 = (char **)std::malloc(iStack8452 + 4);
						if (iVar9 != 0) {
							ppcVar13 = ppcVar12;
							uVar15 = uStack8464;
							do {
								*ppcVar13 = *(char **)((int)((int)ppcStack8456 - (int)ppcVar12) + (int)ppcVar13);
								ppcVar13 = ppcVar13 + 1;
								uVar15 = uVar15 - 1;
							} while (uVar15 != 0);
						}
						if (iVar9 != 0) {
							std::free(ppcStack8456);
						}
						*(char **)((int)ppcVar12 + iVar9) = buffer;
						uStack8464 = uStack8464 + 1;
						iStack8452 = iVar9 + 4;
						ppcStack8456 = ppcVar12;
					}
				}
				bVar16 = false;
			}
			buffer = (char *)((byte *)buffer + 1);
			pbVar14 = (byte *)buffer + -(int)globals::nerps::g_NERPMessageBuffer;
		} while (pbVar14 < pbStack8460);
	}
	globals::g_NERPMessageLines_COUNT = uStack8464;
	globals::g_NERPMessageLines_TABLE = ppcStack8456;
	return 1;
}



char * __cdecl lego::nerps::NERPs_GetMessageLine(uint lineIndex)
{
	if (lineIndex < globals::g_NERPMessageLines_COUNT) {
		return globals::g_NERPMessageLines_TABLE[lineIndex];
	}
	return (char *)0x0;
}



BOOL __cdecl lego::nerps::NERPs_Cleanup(void)
{
	int iVar1;
	uint uVar2;
	BOOL *pBVar3;
	
	if (globals::nerps::g_NERPs_FileLength != 0) {
		std::free(globals::nerps::g_NERPs_FileData);
	}
	if (globals::nerps::g_NERPMessageBuffer != (char *)0x0) {
		std::free(globals::nerps::g_NERPMessageBuffer);
		if (globals::g_NERPMessageLines_TABLE != (char **)0x0) {
			std::free(globals::g_NERPMessageLines_TABLE);
		}
	}
	uVar2 = 0;
	globals::nerps::g_NERPMessageBuffer = (char *)0x0;
	globals::g_NERPMessageLines_TABLE = (char **)0x0;
	globals::g_NERPMessageLines_COUNT = 0;
	globals::nerps::g_NERPs_FileLength = 0;
	if (globals::nerps::g_NERPMessageSounds_COUNT != 0) {
		do {
			snd::Sound3D_Remove(globals::nerps::g_NERPMessageSounds_TABLE[uVar2].sampleIndex);
			uVar2 = uVar2 + 1;
		} while (uVar2 < (uint)globals::nerps::g_NERPMessageSounds_COUNT);
		if (globals::nerps::g_NERPMessageSounds_COUNT != 0) {
			if (globals::nerps::g_NERPMessageSounds_TABLE != (NERPMessageSound *)0x0) {
				std::free(globals::nerps::g_NERPMessageSounds_TABLE);
				globals::nerps::g_NERPMessageSounds_TABLE = (NERPMessageSound *)0x0;
			}
			globals::nerps::g_NERPMessageSounds_COUNT = 0;
		}
	}
	pBVar3 = &globals::nerps::g_NERPs_Camera_IsLockedOn;
	for (iVar1 = 0x2d; iVar1 != 0; iVar1 = iVar1 + -1) {
		*pBVar3 = 0;
		pBVar3 = pBVar3 + 1;
	}
	FUN_0046ad50();
	return 1;
}



void __cdecl lego::nerps::NERPs_UnkReserveStack__004535a0(uint *param_1)
{
	uint uVar1;
	
	uVar1 = *param_1;
	if (((uVar1 & 0xffff0000) == 0x20000) &&
		 (globals::nerps::g_NERPs_FUNCTIONS_TABLE[uVar1 & 0xffff].arguments == NERPS_ARGS_0)) {
		uVar1 = (*globals::nerps::g_NERPs_FUNCTIONS_TABLE[uVar1 & 0xffff].function)((int *)0x0);
	}
	*param_1 = uVar1;
	return;
}



void __cdecl lego::nerps::NERPs_Exec__004535e0(float param_1)
{
	NERPSFunctionArgs NVar1;
	void *pvVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	uint local_220;
	uint local_21c;
	uint local_210;
	uint local_20c;
	uint local_208;
	uint local_204;
	char local_200 [512];
	
	pvVar2 = globals::nerps::g_NERPs_FileData;
	uVar5 = 0;
	if (globals::nerps::g_NERPs_FileData != (void *)0x0) {
		local_204 = globals::nerps::g_NERPs_FileLength >> 2;
		local_220 = 0;
		uVar10 = 0;
		uVar8 = 0;
		uVar4 = local_21c;
		if (local_204 != 0) {
			do {
				iVar7 = 0;
				uVar3 = *(uint *)((int)pvVar2 + local_220 * 4);
				if ((uVar3 & 0x20000) == 0) {
					if ((uVar3 & 0x10000) == 0) {
						if ((uVar3 & 0x40000) == 0) {
							if ((uVar3 & 0x80000) == 0) {
								uVar4 = SEXT24(*(short *)((int)pvVar2 + local_220 * 4));
								if (uVar5 != 0) {
									uVar4 = (uint)(uVar4 == 0);
								}
								uVar5 = uVar4;
								local_21c = uVar4;
								if (uVar8 != 0) {
									if (uVar8 == 1) {
										if ((uVar10 == 0) || (uVar5 = uVar8, uVar4 == 0)) {
LAB_00453acb:
											uVar5 = 0;
										}
									}
									else {
										if (uVar8 == 2) {
											if ((uVar10 == 0) && (uVar4 == 0)) goto LAB_00453acb;
											uVar5 = 1;
										}
										else {
											if (uVar8 == 3) {
												uVar5 = (uint)(uVar4 < uVar10);
											}
											else {
												if (uVar8 == 4) {
													uVar5 = (uint)(uVar10 < uVar4);
												}
												else {
													if (uVar8 == 5) {
														uVar5 = (uint)(uVar10 == uVar4);
													}
													else {
														if (uVar8 == 6) {
															uVar5 = (uint)(uVar4 <= uVar10);
														}
														else {
															if (uVar8 != 7) goto joined_r0x00453b1b;
															uVar5 = (uint)(uVar10 <= uVar4);
														}
													}
												}
											}
										}
									}
								}
								goto LAB_00453b28;
							}
							if (uVar10 != 0) {
								local_220 = uVar3 & 0xffff;
							}
LAB_00453a74:
							uVar10 = 0;
							uVar5 = 0;
							uVar9 = 0;
						}
						else {
							uVar10 = 0;
							uVar5 = 0;
							uVar9 = 0;
						}
					}
					else {
						uVar6 = 0;
						uVar3 = uVar3 & 0xffff;
						uVar5 = uVar10;
						if (uVar3 == 0) goto LAB_00453b28;
						uVar5 = uVar6;
						uVar9 = uVar3;
						if ((uVar3 != 2) && (uVar5 = uVar3, uVar9 = uVar8, uVar3 != 1)) {
							if (uVar3 == 5) {
								uVar5 = uVar6;
								uVar9 = 3;
							}
							else {
								if (uVar3 == 6) {
									uVar5 = uVar6;
									uVar9 = 4;
								}
								else {
									if (uVar3 == 7) {
										uVar5 = uVar6;
										uVar9 = 5;
									}
									else {
										if (uVar3 == 8) {
											uVar5 = uVar6;
											uVar9 = 6;
										}
										else {
											if (uVar3 == 9) {
												uVar5 = uVar6;
												uVar9 = 7;
											}
											else {
												uVar5 = uVar6;
												if (uVar3 == 10) {
													uVar9 = 8;
												}
											}
										}
									}
								}
							}
						}
					}
				}
				else {
					uVar3 = uVar3 & 0xffff;
					if ((uVar3 == 0) && ((uVar10 != 0 || (uVar8 == 0)))) break;
					NVar1 = globals::nerps::g_NERPs_FUNCTIONS_TABLE[uVar3].arguments;
					if (NVar1 == NERPS_ARGS_0) {
LAB_0045383f:
						uVar4 = (*globals::nerps::g_NERPs_FUNCTIONS_TABLE[uVar3].function)((int *)0x0);
						local_21c = uVar4;
					}
					else {
						if ((NVar1 != NERPS_ARGS_1) && (NVar1 != NERPS_ARGS_2)) {
							if (NVar1 == NERPS_ARGS_0_NORETURN) {
								if (uVar10 == 0) goto LAB_00453a74;
								if (DAT_00500998 != 0) {
									std::sprintf(local_200,"Func Call %s",
															 globals::nerps::g_NERPs_FUNCTIONS_TABLE[uVar3].name);
								}
								(*globals::nerps::g_NERPs_FUNCTIONS_TABLE
									[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)((int *)0x0);
								uVar10 = 0;
								uVar4 = local_21c;
								uVar5 = 0;
								uVar9 = 0;
							}
							else {
								if (NVar1 == NERPS_ARGS_1_NORETURN) {
									if (uVar10 != 0) {
										if (DAT_00500998 != 0) {
											std::sprintf(local_200,"Func Call %s",
																	 globals::nerps::g_NERPs_FUNCTIONS_TABLE[uVar3].name);
										}
										local_210 = *(uint *)((int)pvVar2 + local_220 * 4 + 4);
										NERPs_UnkReserveStack__004535a0(&local_210);
										(*globals::nerps::g_NERPs_FUNCTIONS_TABLE
											[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)((int *)&local_210)
										;
										uVar4 = local_21c;
									}
									local_220 = local_220 + 1;
								}
								else {
									if (NVar1 == NERPS_ARGS_2_NORETURN) {
										if (uVar10 != 0) {
											local_210 = *(uint *)((int)pvVar2 + local_220 * 4 + 4);
											local_20c = *(uint *)((int)pvVar2 + local_220 * 4 + 8);
											NERPs_UnkReserveStack__004535a0(&local_210);
											NERPs_UnkReserveStack__004535a0(&local_20c);
											(*globals::nerps::g_NERPs_FUNCTIONS_TABLE
												[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)
																((int *)&local_210);
											uVar4 = local_21c;
										}
										local_220 = local_220 + 2;
									}
									else {
										uVar9 = uVar8;
										if (NVar1 != NERPS_ARGS_3_NORETURN) goto LAB_00453b2d;
										if (uVar10 != 0) {
											local_210 = *(uint *)((int)pvVar2 + local_220 * 4 + 4);
											local_20c = *(uint *)((int)pvVar2 + local_220 * 4 + 8);
											local_208 = *(uint *)((int)pvVar2 + local_220 * 4 + 0xc);
											NERPs_UnkReserveStack__004535a0(&local_210);
											NERPs_UnkReserveStack__004535a0(&local_20c);
											NERPs_UnkReserveStack__004535a0(&local_208);
											(*globals::nerps::g_NERPs_FUNCTIONS_TABLE
												[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)
																((int *)&local_210);
											uVar4 = local_21c;
										}
										local_220 = local_220 + 3;
									}
								}
								uVar10 = 0;
								uVar5 = 0;
								uVar9 = 0;
							}
							goto LAB_00453b2d;
						}
						if (NVar1 == NERPS_ARGS_0) goto LAB_0045383f;
						if (NVar1 == NERPS_ARGS_1) {
							local_210 = *(uint *)((int)pvVar2 + local_220 * 4 + 4);
							NERPs_UnkReserveStack__004535a0(&local_210);
							uVar4 = (*globals::nerps::g_NERPs_FUNCTIONS_TABLE
												[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)
																((int *)&local_210);
							iVar7 = 1;
							local_21c = uVar4;
						}
						else {
							if (NVar1 == NERPS_ARGS_2) {
								local_210 = *(uint *)((int)pvVar2 + local_220 * 4 + 4);
								local_20c = *(uint *)((int)pvVar2 + local_220 * 4 + 8);
								NERPs_UnkReserveStack__004535a0(&local_210);
								NERPs_UnkReserveStack__004535a0(&local_20c);
								uVar4 = (*globals::nerps::g_NERPs_FUNCTIONS_TABLE
													[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)
																	((int *)&local_210);
								iVar7 = 2;
								local_21c = uVar4;
							}
						}
					}
					local_220 = local_220 + iVar7;
					if (uVar5 != 0) {
						uVar4 = (uint)(uVar4 == 0);
						local_21c = uVar4;
					}
					uVar5 = uVar4;
					if (uVar8 != 0) {
						if (uVar8 == 1) {
							if ((uVar10 == 0) || (uVar5 = uVar8, uVar4 == 0)) {
LAB_00453947:
								uVar5 = 0;
							}
						}
						else {
							if (uVar8 == 2) {
								if ((uVar10 == 0) && (uVar4 == 0)) goto LAB_00453947;
								uVar5 = 1;
							}
							else {
								if (uVar8 == 3) {
									uVar5 = (uint)(uVar4 < uVar10);
								}
								else {
									if (uVar8 == 4) {
										uVar5 = (uint)(uVar10 < uVar4);
									}
									else {
										if (uVar8 == 5) {
											uVar5 = (uint)(uVar10 == uVar4);
										}
										else {
											if (uVar8 == 6) {
												uVar5 = (uint)(uVar4 <= uVar10);
											}
											else {
												if (uVar8 == 7) {
													uVar5 = (uint)(uVar10 <= uVar4);
												}
												else {
joined_r0x00453b1b:
													uVar5 = uVar10;
													if (uVar8 == 8) {
														uVar5 = (uint)(uVar10 != uVar4);
													}
												}
											}
										}
									}
								}
							}
						}
					}
LAB_00453b28:
					uVar10 = uVar5;
					uVar5 = 0;
					uVar9 = 1;
				}
LAB_00453b2d:
				local_220 = local_220 + 1;
				uVar8 = uVar9;
			} while (local_220 < local_204);
		}
		FUN_00454060(param_1);
	}
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGameSpeed(int *stack)
{
	LevelData *pLVar1;
	
	if ((*stack == 0) && (pLVar1 = game::GetLevel(), pLVar1->status != LEVELSTATUS_NONE)) {
		return 0;
	}
	game::Game_UnkSetGameSpeed_UnkBool(stack[1]);
	game::Game_SetGameSpeed((float)(ulonglong)(uint)*stack * 0.01);
	game::Game_UnkSetGameSpeed_UnkBool(stack[1]);
	return 0;
}



void __cdecl lego::unk::Lego_SetDatTo_004a773c___00453bc0(undefined4 param_1)
{
	DAT_004a773c = param_1;
	return;
}



void __cdecl FUN_00453bd0(void)
{
	if (DAT_004a773c != 0) {
		FUN_00456ad0();
		return;
	}
	return;
}



void __cdecl FUN_00453be0(void)
{
	char *pcVar1;
	TutorialFlags TVar2;
	int local_8;
	undefined4 local_4;
	
	local_8 = 100;
	local_4 = 0;
	lego::snd::Audio_FUN_00428730(0);
	if (UINT_00556de4 != 0) {
		UINT_00556de4 = UINT_00556de4 - 1;
		if (3 < (int)UINT_00556de4) {
			UINT_00556de4 = 3;
		}
		if ((int)UINT_00556de0 < (int)UINT_00556de4) {
			UINT_00556de4 = UINT_00556de0;
		}
		pcVar1 = lego::nerps::NERPs_GetMessageLine
											 ((&lego::globals::nerps::g_NERPMessageSounds_UNKCOUNT)
												[UINT_00556de0 - UINT_00556de4]);
		FUN_0046aee0(pcVar1,0);
		if (UINT_00556de4 == 0) {
			lego::game::Game_SetFlags2_40_And_2_unkCamera(0,1);
			TVar2 = lego::nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
			if (TVar2 != TUTORIAL_NONE) {
				lego::nerps::funcs::NERPFunc__SetGameSpeed(&local_8);
			}
		}
		lego::game::Game_SetFlags2_80(1);
		return;
	}
	if (BOOL_004a7740 != 0) {
		UINT_00556de8 = UINT_00556de8 + 1;
	}
	BOOL_004a7740 = 0;
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMessagesAreUpToDate(int *stack)
{
	return (uint)(globals::g_NERPMessageLines_COUNT <= UINT_00556de8);
}



int __cdecl lego::nerps::funcs::NERPFunc__SupressArrow(int *stack)
{
	DAT_005009b0 = *stack;
	if (UINT_00556de4 == 0) {
		game::Game_SetFlags2_40_And_2_unkCamera((uint)(DAT_005009b0 == 0),1);
		return 0;
	}
	game::Game_SetFlags2_40_And_2_unkCamera(1,1);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__AdvanceMessage(int *stack)
{
	if (1 < (int)UINT_00556de4) {
		UINT_00556de4 = 1;
	}
	FUN_00453be0();
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__AllowCameraMovement(int *stack)
{
	DAT_005009b4 = *stack << 0xc;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__ClickOnlyObjects(int *stack)
{
	int local_4;
	
	local_4 = 0x1ff3 - DAT_005009b4;
	NERPFunc__SetTutorialFlags(&local_4);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__ClickOnlyMap(int *stack)
{
	int local_4;
	
	local_4 = 0x1ffb - DAT_005009b4;
	NERPFunc__SetTutorialFlags(&local_4);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__ClickOnlyIcon(int *stack)
{
	int local_4;
	
	local_4 = 0x1ffe - DAT_005009b4;
	NERPFunc__SetTutorialFlags(&local_4);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__ClickOnlyCalltoarms(int *stack)
{
	int local_4;
	
	local_4 = 0x1f7f - DAT_005009b4;
	NERPFunc__SetTutorialFlags(&local_4);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__DisallowAll(int *stack)
{
	int local_4;
	
	local_4 = 0x1fff - DAT_005009b4;
	NERPFunc__SetTutorialFlags(&local_4);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashCallToArmsIcon(int *stack)
{
	if (*stack != 0) {
		front::Panel_SetCurrentAdvisorFromButton(6,2,1);
		return 0;
	}
	front::Advisor_ClearFlag2();
	return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_00453e70(float elapsed)
{
	float fVar1;
	float *pfVar2;
	float *pfVar3;
	
	fVar1 = elapsed * 1000.0 * 0.04;
	pfVar2 = lego::globals::nerps::g_NERPs_TIMERS_TABLE;
	do {
		pfVar3 = pfVar2 + 1;
		*pfVar2 = *pfVar2 + fVar1;
		pfVar2 = pfVar3;
	} while (pfVar3 < &DAT_005009b0);
	if (_DAT_0050098c == 0.0) {
		return;
	}
	if (0.0 <= _DAT_0050098c) {
		if ((DAT_004a773c == 0) || (DAT_00500988 != 0)) {
			_DAT_0050098c = _DAT_0050098c - fVar1;
			if ((ushort)((ushort)(_DAT_0050098c < 0.0) << 8 | (ushort)(_DAT_0050098c == 0.0) << 0xe) == 0)
			goto LAB_00453f3e;
		}
		else {
			if ((DAT_00500984 != 0) &&
				 (((0 < (int)UINT_00556de4 && (DAT_005009b0 != 0)) || (DAT_005009b0 == 0)))) {
				lego::game::Game_SetFlags2_40_And_2_unkCamera(BOOL_004a7740,1);
			}
			DAT_00500984 = BOOL_004a7740;
			if (BOOL_004a7740 != 0) goto LAB_00453f3e;
		}
	}
	_DAT_0050098c = 0.0;
LAB_00453f3e:
	if ((DAT_00556df0 != 0) && (_DAT_0050098c < 1000.0)) {
		lego::front::Advisor_ClearFlag2();
		return;
	}
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTimer0(int *stack)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)globals::nerps::g_NERPs_TIMERS_TABLE[0]);
	return (int)lVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTimer1(int *stack)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)globals::nerps::g_NERPs_TIMERS_TABLE[1]);
	return (int)lVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTimer2(int *stack)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)globals::nerps::g_NERPs_TIMERS_TABLE[2]);
	return (int)lVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTimer3(int *stack)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)globals::nerps::g_NERPs_TIMERS_TABLE[3]);
	return (int)lVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTimer0(int *stack)
{
	globals::nerps::g_NERPs_TIMERS_TABLE[0] = (float)(ulonglong)(uint)*stack;
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTimer1(int *stack)
{
	globals::nerps::g_NERPs_TIMERS_TABLE[1] = (float)(ulonglong)(uint)*stack;
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTimer2(int *stack)
{
	globals::nerps::g_NERPs_TIMERS_TABLE[2] = (float)(ulonglong)(uint)*stack;
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTimer3(int *stack)
{
	globals::nerps::g_NERPs_TIMERS_TABLE[3] = (float)(ulonglong)(uint)*stack;
	return 1;
}



void __cdecl FUN_00454060(float param_1)
{
	float fVar1;
	BOOL BVar2;
	LevelData *pLVar3;
	float10 fVar4;
	LiveObject *local_10;
	undefined4 local_c;
	int local_8;
	int local_4;
	
	if (lego::globals::nerps::g_NERPs_Camera_IsLockedOn == 0) goto LAB_00454114;
	if (LIVEOBJ_00556d50 == (LiveObject *)0x0) {
		if (&DAT_00000009 < lego::globals::nerps::g_NERPs_Camera_LockedOnTarget) goto LAB_00454114;
		BVar2 = FUN_0042df20((uint)lego::globals::nerps::g_NERPs_Camera_LockedOnTarget,(int *)&local_10)
		;
		if (BVar2 == 0) {
			lego::globals::nerps::g_NERPs_Camera_IsLockedOn = 0;
			goto LAB_00454114;
		}
		lego::game::LiveObject_GetBlockCoordinates(local_10,&local_8,&local_4);
		lego::game::LiveObject_GetPosition
							(local_10,(float *)&Point2I_00556d48,(float *)&Point2I_00556d48.y);
	}
	else {
		lego::game::LiveObject_GetBlockCoordinates(LIVEOBJ_00556d50,&local_8,&local_4);
		lego::game::LiveObject_GetPosition
							(LIVEOBJ_00556d50,(float *)&Point2I_00556d48,(float *)&Point2I_00556d48.y);
		local_10 = LIVEOBJ_00556d50;
	}
	lego::game::LiveObject_FUN_0042dd70(local_10,(uint *)0x0,1);
LAB_00454114:
	if (BOOL_00556d54 != 0) {
		fVar1 = FLOAT_00556d58 / (param_1 * 25.0);
		FLOAT_00556d5c = fVar1 + FLOAT_00556d5c;
		if (((ushort)((ushort)(FLOAT_00556d5c < FLOAT_00556d58 - 5.0) << 8 |
								 (ushort)(FLOAT_00556d5c == FLOAT_00556d58 - 5.0) << 0xe) == 0) &&
			 ((ushort)((ushort)(FLOAT_00556d58 - -5.0 < FLOAT_00556d5c) << 8 |
								(ushort)(FLOAT_00556d58 - -5.0 == FLOAT_00556d5c) << 0xe) == 0)) {
			BOOL_00556d54 = 0;
			FLOAT_00556d5c = 0.0;
		}
		lego::view::AddDist(lego::globals::g_Game.cameraMain,fVar1);
	}
	if (BOOL_00556d60 != 0) {
		if ((ushort)((ushort)(FLOAT_00556d64 < 0.0) << 8 | (ushort)(FLOAT_00556d64 == 0.0) << 0xe) == 0)
		{
			fVar1 = FLOAT_00556d64 - FLOAT_00556d68;
		}
		else {
			fVar1 = FLOAT_00556d64 + FLOAT_00556d68;
		}
		fVar4 = lego::game::Game_GetFloatFPS_e40();
		fVar4 = fVar4 * (float10)(fVar1 * 0.1666667) * (float10)0.3333333;
		FLOAT_00556d68 = (float)(fVar4 + (float10)FLOAT_00556d68);
		if ((((ushort)((ushort)(FLOAT_00556d64 < 0.0) << 8 | (ushort)(FLOAT_00556d64 == 0.0) << 0xe) ==
					0) && ((ushort)((ushort)(FLOAT_00556d68 < FLOAT_00556d64 - 1.0) << 8 |
												 (ushort)(FLOAT_00556d68 == FLOAT_00556d64 - 1.0) << 0xe) == 0)) ||
			 ((FLOAT_00556d64 < 0.0 && (FLOAT_00556d68 < FLOAT_00556d64 - -1.0)))) {
			BOOL_00556d60 = 0;
			FLOAT_00556d68 = 0.0;
		}
		lego::view::Camera_AddYaw(lego::globals::g_Game.cameraMain,(float)(fVar4 * (float10)0.01745329))
		;
	}
	pLVar3 = lego::game::GetLevel();
	if (pLVar3->status != LEVELSTATUS_NONE) {
		local_10 = (LiveObject *)0x64;
		local_c = 0;
		lego::nerps::funcs::NERPFunc__SetGameSpeed((int *)&local_10);
	}
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraLockOnMonster(int *stack)
{
	if (*stack != 0) {
		unk::DoLiveObjCallbacks_True_FUN_00437a70
							(game::LiveObject_GetIfRockMonsterAnd_FUN_004542e0,(LiveObject *)&LIVEOBJ_00556d50);
		globals::nerps::g_NERPs_Camera_IsLockedOn = 1;
		return 0;
	}
	globals::nerps::g_NERPs_Camera_IsLockedOn = 0;
	LIVEOBJ_00556d50 = (LiveObject *)0x0;
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_GetIfRockMonsterAnd_FUN_004542e0
					(LiveObject *liveObj,LiveObject **out_liveObj)
{
	BOOL BVar1;
	
	if (liveObj != (LiveObject *)0x0) {
		BVar1 = LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj);
		if (BVar1 != 0) {
			*out_liveObj = liveObj;
			return 1;
		}
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraLockOnObject(int *stack)
{
	if (*stack != 0) {
		globals::nerps::g_NERPs_Camera_LockedOnTarget = (void *)(*stack + -1);
		globals::nerps::g_NERPs_Camera_IsLockedOn = 1;
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraUnlock(int *stack)
{
	globals::nerps::g_NERPs_Camera_IsLockedOn = 0;
	globals::nerps::g_NERPs_Camera_LockedOnTarget = (void *)0xffffffff;
	LIVEOBJ_00556d50 = (LiveObject *)0x0;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraZoomIn(int *stack)
{
	if (FLOAT_00556d5c != 0.0) {
		lego::view::AddDist(globals::g_Game.cameraMain,FLOAT_00556d58 - FLOAT_00556d5c);
		FLOAT_00556d5c = 0.0;
	}
	if (-(float)(ulonglong)(uint)*stack != 0.0) {
		BOOL_00556d54 = 1;
	}
	FLOAT_00556d58 = -(float)(ulonglong)(uint)*stack;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraZoomOut(int *stack)
{
	if (FLOAT_00556d5c != 0.0) {
		lego::view::AddDist(globals::g_Game.cameraMain,FLOAT_00556d58 - FLOAT_00556d5c);
	}
	if ((float)(ulonglong)(uint)*stack != 0.0) {
		BOOL_00556d54 = 1;
	}
	FLOAT_00556d58 = (float)(ulonglong)(uint)*stack;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraRotate(int *stack)
{
	if (FLOAT_00556d68 != 0.0) {
		lego::view::Camera_AddYaw
							(globals::g_Game.cameraMain,(FLOAT_00556d64 - FLOAT_00556d68) * 0.01745329);
		FLOAT_00556d68 = 0.0;
	}
	FLOAT_00556d64 = (float)(ulonglong)(uint)*stack;
	if ((ushort)((ushort)(FLOAT_00556d64 < 180.0) << 8 | (ushort)(FLOAT_00556d64 == 180.0) << 0xe) ==
			0) {
		FLOAT_00556d64 = FLOAT_00556d64 - 360.0;
	}
	if (FLOAT_00556d64 != 0.0) {
		BOOL_00556d60 = 1;
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSelectedRecordObject(int *stack)
{
	BOOL BVar1;
	uint uVar2;
	LiveObject *local_4;
	
	uVar2 = 0;
	do {
		local_4 = (LiveObject *)0x0;
		BVar1 = FUN_0042df20(uVar2,(int *)&local_4);
		if (BVar1 != 0) {
			BVar1 = game::LiveObject_Check_FUN_004528d0(local_4,(uint *)0x0);
			if (BVar1 != 0) {
				return uVar2 + 1;
			}
		}
		uVar2 = uVar2 + 1;
	} while (uVar2 < 10);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetCrystalPriority(int *stack)
{
	game::Game_SetIsPriorityDisabled(0,(uint)(*stack == 0));
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMonsterAttackPowerstation(int *stack)
{
	ObjectType local_c;
	int local_8;
	char *local_4;
	
	if (*stack == 1) {
		local_c = 0x200;
		local_8 = -1;
		local_4 = (char *)0x1;
		unk::DoLiveObjCallbacks_True_FUN_00437a70(game::LiveObject_FUN_004545c0,(LiveObject *)&local_c);
		return 0;
	}
	local_c = OBJECT_NONE;
	local_8 = -1;
	local_4 = (char *)0x0;
	unk::DoLiveObjCallbacks_True_FUN_00437a70(game::LiveObject_FUN_004545c0,(LiveObject *)&local_c);
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_004545c0(LiveObject *liveObj,uint *param_2)
{
	BOOL BVar1;
	ObjectStatsFlags2 OVar2;
	int local_8;
	int local_4;
	
	if (liveObj != (LiveObject *)0x0) {
		LiveObject_GetBlockCoordinates(liveObj,&local_8,&local_4);
		BVar1 = Level_BlockCheck_FUN_004329d0(local_8,local_4,1);
		if (BVar1 != 0) {
			OVar2 = LiveObject_GetStatsFlags2(liveObj);
			if (((*param_2 & OVar2) != STATS2_NONE) || (param_2[1] != 0xffffffff)) {
				OVar2 = LiveObject_GetStatsFlags2(liveObj);
				if ((param_2[1] & OVar2) == STATS2_NONE) {
					return 0;
				}
				if (*param_2 != 0xffffffff) {
					return 0;
				}
			}
			if (param_2[2] == 0) {
				ai::AITask_DoRepair(liveObj);
			}
			else {
				if (param_2[2] == 1) {
					FUN_00403490(liveObj);
					return 0;
				}
			}
		}
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMonsterAttackNowt(int *stack)
{
	ObjectType local_c;
	int local_8;
	char *local_4;
	
	if (*stack == 1) {
		local_c = OBJECT_NONE;
		local_8 = -1;
		local_4 = (char *)0x1;
		unk::DoLiveObjCallbacks_True_FUN_00437a70(game::LiveObject_FUN_004545c0,(LiveObject *)&local_c);
		return 0;
	}
	local_c = OBJECT_NONE;
	local_8 = -1;
	local_4 = (char *)0x0;
	unk::DoLiveObjCallbacks_True_FUN_00437a70(game::LiveObject_FUN_004545c0,(LiveObject *)&local_c);
	return 0;
}



void __cdecl FUN_004546d0(char *objName,float param_2)
{
	char local_8c [128];
	float local_c;
	ObjectType local_8;
	int local_4;
	
	std::sprintf(local_8c,"%s",objName);
	local_c = param_2;
	lego::game::Object_GetObjectByName(objName,&local_8,&local_4,(Container **)0x0);
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
						(lego::game::LiveObject_Callback_FUN_00454740,(LiveObject *)local_8c);
	return;
}



BOOL __cdecl lego::game::LiveObject_Callback_FUN_00454740(LiveObject *liveObj,int param_2)
{
	if (((liveObj != (LiveObject *)0x0) && (liveObj->objType == *(ObjectType *)(param_2 + 0x84))) &&
		 (liveObj->objIndex == *(int *)(param_2 + 0x88))) {
		LiveObject_SetLevel(liveObj,*(uint *)(param_2 + 0x80));
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_Callback_IsOnBlock_FUN_00454780
					(undefined4 param_1,int bx,int by,int *ref_param_4)
{
	LevelData *pLVar1;
	Point2I blockPos;
	float local_c;
	float local_8 [2];
	
	pLVar1 = GetLevel();
	LiveObject_GetPosition((LiveObject *)ref_param_4[1],&local_c,local_8);
	SurfaceMap_ToBlockCoordinatesNoZ
						(pLVar1->surfaceMap,local_c,local_8[0],(int *)&blockPos,&blockPos.y);
	if ((bx == blockPos.x) && (by == blockPos.y)) {
		*ref_param_4 = *ref_param_4 + 1;
	}
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRecordObjectAtTutorial(int *stack)
{
	int *piVar1;
	BOOL BVar2;
	uint uVar3;
	int local_8;
	int *local_4;
	
	piVar1 = stack;
	uVar3 = 0;
	do {
		stack = (int *)0x0;
		BVar2 = FUN_0042df20(uVar3,(int *)&stack);
		if (BVar2 != 0) {
			local_4 = stack;
			local_8 = 0;
			game::Level_BlockPointers_FUN_00456f70
								(*piVar1,game::LiveObject_Callback_IsOnBlock_FUN_00454780,&local_8);
			if (local_8 != 0) {
				return uVar3 + 1;
			}
		}
		uVar3 = uVar3 + 1;
	} while (uVar3 < 10);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRecordObjectAmountAtTutorial(int *stack)
{
	int *piVar1;
	BOOL BVar2;
	uint uVar3;
	int local_8;
	int *local_4;
	
	piVar1 = stack;
	local_8 = 0;
	uVar3 = 0;
	do {
		stack = (int *)0x0;
		BVar2 = FUN_0042df20(uVar3,(int *)&stack);
		if (BVar2 != 0) {
			local_4 = stack;
			game::Level_BlockPointers_FUN_00456f70
								(*piVar1,game::LiveObject_Callback_IsOnBlock_FUN_00454780,&local_8);
		}
		uVar3 = uVar3 + 1;
	} while (uVar3 < 10);
	return local_8;
}



void __cdecl FUN_004548c0(LevelData *level,int param_2,undefined4 param_3,float param_4)
{
	BOOL BVar1;
	float10 fVar2;
	float10 fVar3;
	Point2F local_14;
	Vector3F local_c;
	
	fVar2 = (float10)fsin((float10)FLOAT_005009b8);
	FLOAT_005009b8 = FLOAT_005009b8 - param_4 * 25.0 * -0.01333333;
	if (INT_00556dec != 0) {
		BVar1 = FUN_0042df20(INT_00556dec - 1,(int *)&param_4);
		if (BVar1 != 0) {
			*(undefined4 *)((int)param_4 + 0x3f8) = 1;
			lego::game::LiveObject_GetPosition((LiveObject *)param_4,(float *)&local_c,&local_c.y);
			fVar3 = lego::game::SurfaceMap_GetSurfaceZ(level->surfaceMap,local_c.x,local_c.y);
			local_c.z = (float)fVar3;
			lego::view::Viewport_WorldToScreen((Viewport *)param_2,&local_14,&local_c);
			local_14.x = local_14.x - (float)((int)(lego::globals::g_Game.TutorialIcon)->width / 2);
			local_14.y = local_14.y -
									 ((float)fVar2 * 20.0 + (float)((lego::globals::g_Game.TutorialIcon)->height << 1)
									 );
			lego::image::Image_DisplayScaled
								(lego::globals::g_Game.TutorialIcon,(Rect2F *)0x0,&local_14,(Size2F *)0x0);
		}
	}
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetRecordObjectPointer(int *stack)
{
	INT_00556dec = *stack;
	return *stack;
}



void __cdecl FUN_004549d0(int *param_1)
{
	FUN_0041e740(*param_1);
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetOxygenLevel(int *stack)
{
	BOOL BVar1;
	longlong lVar2;
	float local_4;
	
	local_4 = (globals::g_Game.level)->oxygenLevel;
	if (local_4 < 1.0) {
		local_4 = 0.0;
	}
	if (local_4 == 0.0) {
		BVar1 = FUN_0046a780(0x40b);
		if (BVar1 == 0) {
			local_4 = 1.0;
		}
	}
	if (local_4 < 1.0) {
		local_4 = 1.0;
	}
	lVar2 = __ftol((float10)local_4);
	return (int)lVar2;
}



int __cdecl lego::nerps::funcs::NERPFunc__GenerateSlug(int *stack)
{
	uint local_c;
	Container *local_8;
	ObjectType local_4;
	
	game::Object_GetObjectByName("Slug",&local_4,(int *)&local_c,&local_8);
	FUN_0043b010((undefined4 *)0x0,local_c);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetAttackDefer(int *stack)
{
	FUN_004359b0(*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetCallToArms(int *stack)
{
	game::Game_SetCallToArmsOn(*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetCallToArmsButtonClicked(int *stack)
{
	return globals::g_Game.flags2 & GAME2_CALLTOARMS;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetRockMonster(int *stack)
{
	uint uVar1;
	
	uVar1 = game::Level_GetEmergeCreature();
	FUN_0043b1f0((int **)(globals::g_Game.RockMonsterData_TABLE + uVar1),4.203895e-45,uVar1,*stack - 1
							 ,stack[1] - 1);
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRockMonstersDestroyed(int *stack)
{
	return globals::nerps::g_NERPs_RockMonstersDestroyed;
}



void __cdecl lego::game::Game_IncHiddenObjectsFound(ObjectType unused_objType)
{
	globals::nerps::g_NERPs_HiddenObjectsFound = globals::nerps::g_NERPs_HiddenObjectsFound + 1;
	return;
}



void __cdecl lego::game::Game_ClearHiddenObjectsFound(void)
{
	globals::nerps::g_NERPs_HiddenObjectsFound = 0;
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetHiddenObjectsFound(int *stack)
{
	return globals::nerps::g_NERPs_HiddenObjectsFound;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetHiddenObjectsFound(int *stack)
{
	globals::nerps::g_NERPs_HiddenObjectsFound = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetUpgradeBuildingIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0x41,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetUpgradeBuildingIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x41;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashUpgradeBuildingIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0x41,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGoBackIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGoBackIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGoBackIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRockMonsterRunningAway(int *stack)
{
	ObjectType local_c;
	int local_8;
	
	local_c = OBJECT_NONE;
	local_8 = 0;
	unk::DoLiveObjCallbacks_True_FUN_00437a70
						(game::LiveObject_Callback_RockMonster_FUN_00454c70,(LiveObject *)&local_c);
	return local_8;
}



BOOL __cdecl
lego::game::LiveObject_Callback_RockMonster_FUN_00454c70(LiveObject *liveObj,int *param_2)
{
	int iVar1;
	
	iVar1 = *param_2;
	if ((((iVar1 == 0) || (iVar1 == 1)) || (iVar1 == 2)) && (liveObj->objType == OBJECT_ROCKMONSTER))
	{
		if (iVar1 == 0) {
			if (((ushort)((ushort)(liveObj->health < 0.0) << 8 | (ushort)(liveObj->health == 0.0) << 0xe)
					 == 0) &&
				 (liveObj->health <
					liveObj->stats->PainThreshold - liveObj->stats->PainThreshold * 0.01 * 20.0)) {
				LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
				param_2[1] = param_2[1] + 1;
			}
		}
		else {
			if (iVar1 == 1) {
				liveObj->stats->PainThreshold = (float)param_2[2];
				return 0;
			}
			if (iVar1 == 2) {
				liveObj->health = (float)param_2[2];
				return 0;
			}
		}
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetRockMonsterPainThreshold(int *stack)
{
	ObjectType local_c;
	char *local_4;
	
	local_c = OBJECT_VEHICLE;
	local_4 = (char *)(float)(ulonglong)(uint)*stack;
	unk::DoLiveObjCallbacks_True_FUN_00437a70
						(game::LiveObject_Callback_RockMonster_FUN_00454c70,(LiveObject *)&local_c);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetRockMonsterHealth(int *stack)
{
	ObjectType local_c;
	char *local_4;
	
	local_c = OBJECT_MINIFIGURE;
	local_4 = (char *)(float)(ulonglong)(uint)*stack;
	unk::DoLiveObjCallbacks_True_FUN_00437a70
						(game::LiveObject_Callback_RockMonster_FUN_00454c70,(LiveObject *)&local_c);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetPauseGame(int *stack)
{
	FUN_00425b60(0,*stack);
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetAnyKeyPressed(int *stack)
{
	uint uVar1;
	
	uVar1 = input::Input_AnyKeyPressed();
	return uVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetIconPos(int *stack)
{
	globals::nerps::g_NERPs_IconPos.x = (float)(ulonglong)(uint)*stack;
	globals::nerps::g_NERPs_IconPos.y = (float)(ulonglong)(uint)stack[1];
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetIconSpace(int *stack)
{
	globals::nerps::g_NERPs_IconSpace = *stack;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetIconWidth(int *stack)
{
	globals::nerps::g_NERPs_IconWidth = *stack;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetLevelCompleted(int *stack)
{
	game::Level_SetCompleteStatus(LEVELSTATUS_COMPLETE);
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetLevelFail(int *stack)
{
	if ((globals::g_Game.flags1 & GAME1_UNK_8000000) == GAME1_NONE) {
		game::Level_SetCompleteStatus(LEVELSTATUS_FAILED);
	}
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGameFail(int *stack)
{
	game::Level_SetCompleteStatus(LEVELSTATUS_FAILED);
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialPointer(int *stack)
{
	FUN_00457430(*stack,stack[1]);
	return 1;
}



void __cdecl lego::nerps::NERPs_SetSubmenuIconClicked__00454e90(char *itemName,BOOL state)
{
	ObjectType objType;
	
	game::Object_GetObjectByName(itemName,&objType,(int *)&itemName,(Container **)0x0);
	NERPs_SetSubmenuIconClicked_internal___0041e750(objType,(int)itemName,state);
	return;
}



int __cdecl lego::nerps::NERPs_FlashSubmenuIcon__00454ed0(char *itemName,BOOL state)
{
	int local_4;
	
	game::Object_GetObjectByName(itemName,(ObjectType *)&itemName,&local_4,(Container **)0x0);
	NERPs_FlashSubmenuIcon_internal___0041e6d0((ObjectType)itemName,local_4,state);
	return (int)itemName;
}



BOOL __cdecl lego::game::Level_SetBlockClickCount(undefined4 unused,int bx,int by,int *pClickCount)
{
	LevelData *pLVar1;
	
	pLVar1 = GetLevel();
	pLVar1->blocks[(pLVar1->dimensions).width * by + bx].clickCount = *pClickCount;
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialBlockClicks(int *stack)
{
	game::Level_BlockPointers_FUN_00456f70(*stack,game::Level_SetBlockClickCount,stack + 1);
	return 1;
}



BOOL __cdecl
lego::game::Level_GenTutorialCrystals_FUN_00454f60
					(undefined4 unused,uint bx,int by,int *pTutorialCrystals)
{
	LevelData *level;
	int iVar1;
	Point2I blockPos;
	
	level = GetLevel();
	blockPos.x = bx;
	blockPos.y = by;
	iVar1 = 0;
	level->blocks[(level->dimensions).width * by + bx].generateCrystals = *pTutorialCrystals;
	if (0 < *pTutorialCrystals) {
		do {
			Level_GenerateCrystal(&blockPos,0,(Point2F *)0x0,1);
			iVar1 = iVar1 + 1;
		} while (iVar1 < *pTutorialCrystals);
	}
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialCrystals(int *stack)
{
	game::Level_BlockPointers_FUN_00456f70
						(*stack,game::Level_GenTutorialCrystals_FUN_00454f60,stack + 1);
	return 1;
}



BOOL __cdecl FUN_00454ff0(undefined4 unused,uint bx,int by,int *pGenerateOre)
{
	LevelData *level;
	Point2I blockPos;
	
	level = lego::game::GetLevel();
	blockPos.x = bx;
	blockPos.y = by;
	level->blocks[(level->dimensions).width * by + bx].generateOre = *pGenerateOre;
	lego::game::Level_GenerateOre(&blockPos,0,(Point2F *)0x0,0);
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetOreAtIconPositions(int *stack)
{
	game::Level_BlockPointers_FUN_00456f70(*stack,FUN_00454ff0,stack + 1);
	return 1;
}



int __cdecl lego::game::Game_CountSelectedUnits_ByObjectName(char *objName)
{
	LiveObject **ppLVar1;
	uint uVar2;
	int iVar3;
	uint uVar4;
	int local_4;
	
	iVar3 = 0;
	Object_GetObjectByName(objName,(ObjectType *)&objName,&local_4,(Container **)0x0);
	ppLVar1 = Game_GetSelectedUnits();
	uVar4 = 0;
	uVar2 = Game_GetNumSelectedUnits();
	if (uVar2 != 0) {
		do {
			if (((char *)(*ppLVar1)->objType == objName) && ((*ppLVar1)->objIndex == local_4)) {
				iVar3 = iVar3 + 1;
			}
			uVar4 = uVar4 + 1;
			ppLVar1 = ppLVar1 + 1;
			uVar2 = Game_GetNumSelectedUnits();
		} while (uVar4 < uVar2);
	}
	return iVar3;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureSelected(int *stack)
{
	int iVar1;
	
	iVar1 = game::Game_CountSelectedUnits_ByObjectName("Pilot");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSmallTruckSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = game::Game_GetFirstSelectedObject();
	if (pLVar1 == (LiveObject *)0x0) {
		return 0;
	}
	game::Object_GetObjectByName("SmallTruck",&local_4,&local_8,(Container **)0x0);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSmallDiggerSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = game::Game_GetFirstSelectedObject();
	if (pLVar1 == (LiveObject *)0x0) {
		return 0;
	}
	game::Object_GetObjectByName("SmallDigger",&local_4,&local_8,(Container **)0x0);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRapidRiderSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = game::Game_GetFirstSelectedObject();
	if (pLVar1 == (LiveObject *)0x0) {
		return 0;
	}
	game::Object_GetObjectByName("SmallCat",&local_4,&local_8,(Container **)0x0);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSmallHelicopterSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = game::Game_GetFirstSelectedObject();
	if (pLVar1 == (LiveObject *)0x0) {
		return 0;
	}
	game::Object_GetObjectByName("SmallHeli",&local_4,&local_8,(Container **)0x0);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGraniteGrinderSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = game::Game_GetFirstSelectedObject();
	if (pLVar1 == (LiveObject *)0x0) {
		return 0;
	}
	game::Object_GetObjectByName("WalkerDigger",&local_4,&local_8,(Container **)0x0);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



int __cdecl lego::nerps::funcs::NERPFunc__GetChromeCrusherSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = game::Game_GetFirstSelectedObject();
	if (pLVar1 == (LiveObject *)0x0) {
		return 0;
	}
	game::Object_GetObjectByName("LargeDigger",&local_4,&local_8,(Container **)0x0);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



BOOL __cdecl lego::game::Game_DoCallbacks_ByObjectName(char *objName)
{
	ObjectType local_c;
	int local_8;
	char *local_4;
	
	Object_GetObjectByName(objName,&local_c,&local_8,(Container **)0x0);
	local_4 = (char *)0x0;
	unk::DoLiveObjCallbacks_True_FUN_00437a70
						(LiveObject_Callback_ByObjectTypeIndex_IsDriving,(LiveObject *)&local_c);
	return (BOOL)local_4;
}



BOOL __cdecl
lego::game::LiveObject_Callback_ByObjectTypeIndex_IsDriving
					(LiveObject *liveObj1,LiveObject *liveObj_template)
{
	if (((liveObj1->objType == liveObj_template->objType) &&
			(liveObj1->objIndex == liveObj_template->objIndex)) &&
		 (liveObj1->drivenObject != (LiveObject *)0x0)) {
		liveObj_template->customName = liveObj_template->customName + 1;
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__AddPoweredCrystals(int *stack)
{
	uint uVar1;
	
	uVar1 = 0;
	if (*stack != 0) {
		do {
			game::Level_IncrementCrystals();
			uVar1 = uVar1 + 1;
		} while (uVar1 < (uint)*stack);
	}
	game::Level_UnkLiveObjInitFlagsToggle_AndClearNumDrained();
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__AddStoredOre(int *stack)
{
	uint uVar1;
	
	uVar1 = 0;
	if (*stack != 0) {
		do {
			game::Level_IncOre(0);
			uVar1 = uVar1 + 1;
		} while (uVar1 < (uint)*stack);
	}
	return *stack;
}



BOOL __cdecl
lego::game::Level_GetBlockGenerateCrystals
					(undefined4 unused,int bx,int by,int *out_generateCrystals)
{
	LevelData *level;
	
	level = GetLevel();
	*out_generateCrystals =
			 *out_generateCrystals + level->blocks[(level->dimensions).width * by + bx].generateCrystals;
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTutorialCrystals(int *stack)
{
	int local_4;
	
	local_4 = 0;
	game::Level_BlockPointers_FUN_00456f70(*stack,game::Level_GetBlockGenerateCrystals,&local_4);
	return local_4;
}



BOOL __cdecl
lego::game::Level_Callback_GetBlockClickCount(undefined4 unused,int bx,int by,int *out_clickCount)
{
	LevelData *level;
	
	level = GetLevel();
	*out_clickCount = *out_clickCount + level->blocks[(level->dimensions).width * by + bx].clickCount;
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTutorialBlockClicks(int *stack)
{
	int local_4;
	
	local_4 = 0;
	game::Level_BlockPointers_FUN_00456f70(*stack,game::Level_Callback_GetBlockClickCount,&local_4);
	return local_4;
}



int __cdecl lego::game::Level_GetObjectsOfLevel(char *objName,int in_objLevel)
{
	int iVar1;
	uint uVar2;
	int iVar3;
	char *pcVar4;
	uint objLevel;
	ObjectType objType;
	ObjectType local_c;
	char *local_8;
	char *local_4;
	
	Object_GetObjectByName(objName,&objType,(int *)&objName,(Container **)0x0);
	iVar3 = in_objLevel;
	if (in_objLevel < 0) {
		pcVar4 = (char *)0x0;
		objLevel = 0;
		iVar1 = Object_GetLevels(objType,(int)objName);
		if (iVar1 != 0) {
			do {
				if (iVar3 == -1) {
					iVar1 = LiveObject_GetOrSubLevelsTable(objType,(int)objName,objLevel,1);
					pcVar4 = pcVar4 + iVar1;
				}
				if (iVar3 == -2) {
					local_c = objType;
					local_8 = objName;
					local_4 = (char *)0x0;
					unk::DoLiveObjCallbacks_True_FUN_00437a70
										(LiveObject_CallbackCheck_FUN_00455580,(LiveObject *)&local_c);
					pcVar4 = local_4 + (int)pcVar4;
				}
				objLevel = objLevel + 1;
				uVar2 = Object_GetLevels(objType,(int)objName);
			} while (objLevel < uVar2);
		}
		return (int)pcVar4;
	}
	iVar3 = LiveObject_GetOrSubLevelsTable(objType,(int)objName,in_objLevel,1);
	return iVar3;
}



BOOL __cdecl
lego::game::LiveObject_CallbackCheck_FUN_00455580(LiveObject *liveObj,LiveObject *liveObj_template)
{
	if ((liveObj->objType == liveObj_template->objType) &&
		 (liveObj->objIndex == liveObj_template->objIndex)) {
		if ((liveObj->flags3 & LIVEOBJ3_UNK_20000000) != LIVEOBJ3_NONE) {
			liveObj_template->customName = liveObj_template->customName + 1;
			return 0;
		}
		liveObj_template->customName = (char *)0x0;
	}
	return 0;
}



uint __cdecl lego::game::Game_GetPilotPreviousLevel(char *objName,int objLevel)
{
	uint uVar1;
	ObjectType objType;
	
	Object_GetObjectByName(objName,&objType,(int *)&objName,(Container **)0x0);
	uVar1 = LiveObject_GetPreviousLevel(objType,(int)objName,objLevel);
	return uVar1;
}



undefined4 __cdecl lego::front::SubMenu_GetBuildingVehicleIcon_ByObjectName(char *objName)
{
	undefined4 uVar1;
	ObjectType local_4;
	
	game::Object_GetObjectByName(objName,&local_4,(int *)&objName,(Container **)0x0);
	uVar1 = SubMenu_GetBuildingVehicleIcon(local_4,(int)objName);
	return uVar1;
}



BOOL __cdecl FUN_00455630(int menuIcon,int param_2)
{
	BOOL BVar1;
	
	if (param_2 == 1) {
		BVar1 = FUN_0041e7c0(menuIcon,1);
		if (BVar1 != 0) {
			lego::nerps::NERPs_SetIconFlag4__0041e6a0(menuIcon,1);
			return 1;
		}
	}
	else {
		lego::front::Advisor_ClearFlag2();
		lego::nerps::NERPs_SetIconFlag4__0041e6a0(menuIcon,0);
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinGraniteGrinder(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::Game_DoCallbacks_ByObjectName("Walkerdigger");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinChromeCrusher(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::Game_DoCallbacks_ByObjectName("LargeDigger");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinSmallDigger(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::Game_DoCallbacks_ByObjectName("SmallDigger");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinRapidRider(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::Game_DoCallbacks_ByObjectName("SmallCat");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinSmallTruck(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::Game_DoCallbacks_ByObjectName("SmallTruck");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinSmallHelicopter(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::Game_DoCallbacks_ByObjectName("SmallHeli");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetBarracksLevel(int *stack)
{
	FUN_004546d0("Barracks",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetDocksLevel(int *stack)
{
	FUN_004546d0("Docks",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGeoDomeLevel(int *stack)
{
	FUN_004546d0("Geo-dome",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetPowerstationLevel(int *stack)
{
	FUN_004546d0("Powerstation",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetToolStoreLevel(int *stack)
{
	FUN_004546d0("Toolstation",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGunstationLevel(int *stack)
{
	FUN_004546d0("Gunstation",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTeleportPadLevel(int *stack)
{
	FUN_004546d0("TeleportPad",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetSuperTeleportLevel(int *stack)
{
	FUN_004546d0("TeleportBIG",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetUpgradeStationLevel(int *stack)
{
	FUN_004546d0("Upgrade",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetBarracksSelected(int *stack)
{
	int iVar1;
	
	iVar1 = game::Game_CountSelectedUnits_ByObjectName("Barracks");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDocksSelected(int *stack)
{
	int iVar1;
	
	iVar1 = game::Game_CountSelectedUnits_ByObjectName("Docks");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGeoDomeSelected(int *stack)
{
	int iVar1;
	
	iVar1 = game::Game_CountSelectedUnits_ByObjectName("Geo-Dome");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPowerstationSelected(int *stack)
{
	int iVar1;
	
	iVar1 = game::Game_CountSelectedUnits_ByObjectName("Powerstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetToolStoreSelected(int *stack)
{
	int iVar1;
	
	iVar1 = game::Game_CountSelectedUnits_ByObjectName("Toolstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGunstationSelected(int *stack)
{
	int iVar1;
	
	iVar1 = game::Game_CountSelectedUnits_ByObjectName("Gunstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTeleportPadSelected(int *stack)
{
	int iVar1;
	
	iVar1 = game::Game_CountSelectedUnits_ByObjectName("TeleportPad");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSuperTeleportSelected(int *stack)
{
	int iVar1;
	
	iVar1 = game::Game_CountSelectedUnits_ByObjectName("TeleportBIG");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetUpgradeStationSelected(int *stack)
{
	int iVar1;
	
	iVar1 = game::Game_CountSelectedUnits_ByObjectName("Upgrade");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredBarracksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Barracks",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredDocksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Docks",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredGeodomeBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Geo-dome",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredPowerstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Powerstation",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredToolStoresBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Toolstation",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredGunstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("GunStation",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("TeleportPad",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredVehicleTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("TeleportBIG",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredUpgradeStationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Upgrade",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetBarracksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Barracks",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDocksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Docks",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGeodomeBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Geo-dome",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPowerstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Powerstation",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetToolStoresBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Toolstation",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGunstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("GunStation",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("TeleportPad",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetVehicleTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("TeleportBIG",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetUpgradeStationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Upgrade",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1BarracksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Barracks",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1DocksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Docks",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1GeodomeBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Geo-dome",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1PowerstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Powerstation",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1ToolStoresBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Toolstation",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1GunstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("GunStation",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1TeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("TeleportPad",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1VehicleTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("TeleportBIG",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1UpgradeStationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Upgrade",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2BarracksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Barracks",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2DocksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Docks",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2GeodomeBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Geo-dome",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2PowerstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Powerstation",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2ToolStoresBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Toolstation",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2GunstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("GunStation",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2TeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("TeleportPad",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2VehicleTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("TeleportBIG",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2UpgradeStationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Upgrade",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetBarracksIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::SubMenu_GetBuildingVehicleIcon_ByObjectName("Barracks");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGeodomeIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::SubMenu_GetBuildingVehicleIcon_ByObjectName("Geo-dome");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPowerstationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::SubMenu_GetBuildingVehicleIcon_ByObjectName("Powerstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetToolStoreIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::SubMenu_GetBuildingVehicleIcon_ByObjectName("Toolstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGunstationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::SubMenu_GetBuildingVehicleIcon_ByObjectName("Gunstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTeleportPadIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::SubMenu_GetBuildingVehicleIcon_ByObjectName("TeleportPad");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetVehicleTransportIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::SubMenu_GetBuildingVehicleIcon_ByObjectName("TeleportBIG");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetUpgradeStationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = front::SubMenu_GetBuildingVehicleIcon_ByObjectName("Upgrade");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetBarracksIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("Barracks",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGeodomeIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("Geo-dome",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetPowerstationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("Powerstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetToolStoreIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("Toolstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGunstationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("Gunstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTeleportPadIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("TeleportPad",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetVehicleTransportIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("TeleportBIG",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetUpgradeStationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("Upgrade",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashBarracksIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("Barracks",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGeodomeIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("Geo-dome",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashPowerStationIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("Powerstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashToolStoreIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("Toolstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGunstationIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("Gunstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTeleportPadIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("TeleportPad",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashVehicleTransportIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("TeleportBIG",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashUpgradeStationIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("Upgrade",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPathsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Path",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetStudCount(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("ProcessedOre",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSmallHelicoptersOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("SmallHeli",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGraniteGrindersOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("WalkerDigger",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRapidRidersOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("SmallCat",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSmallDiggersOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("SmallDigger",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSlugsOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Slug",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFiguresOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Pilot",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetOreRefineriesBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("Refinery",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetCrystalRefineriesBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetObjectsOfLevel("CrystalRefinery",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTeleportIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 1;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDynamiteClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0xd;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMountIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x18;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTrainIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x39;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDropSonicBlasterIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x21;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGetToolIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x30;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGetPusherIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x36;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGetSonicBlasterIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x38;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTrainSailorIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x3e;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTrainPilotIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x3d;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTrainDriverIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x3a;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGetLaserIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x35;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDismountIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x19;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDigIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0xb;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetBuildIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 2;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLayPathIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 5;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPlaceFenceIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0xe;
	iVar1 = FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTeleportIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(1,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetDynamiteClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0xd,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTrainIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0x39,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTrainDriverIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0x3a,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTrainSailorIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0x3e,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGetToolIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0x30,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetDropSonicBlasterIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0x21,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGetLaserIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0x35,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGetPusherIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0x36,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGetSonicBlasterIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0x38,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetDismountIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0x19,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTrainPilotIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0x3d,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMountIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0x18,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetDigIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0xb,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetBuildIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(2,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetLayPathIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(5,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetPlaceFenceIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = FUN_0041e720(0xe,*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTeleportIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(1,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashDynamiteIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0xd,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashMountIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0x18,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTrainIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0x39,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTrainDriverIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0x3a,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTrainPilotIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0x3d,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTrainSailorIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0x3e,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashDismountIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0x19,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGetToolIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0x30,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashDropSonicBlasterIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0x21,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGetLaserIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0x35,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGetPusherIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0x36,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGetSonicBlasterIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0x38,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashDigIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0xb,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashBuildIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(2,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashLayPathIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(5,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashPlaceFenceIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = FUN_00455630(0xe,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRandom(int *stack)
{
	ushort uVar1;
	
	uVar1 = math::Maths_Rand();
	return uVar1 & 0xfff;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRandomTrueFalse(int *stack)
{
	ushort uVar1;
	
	uVar1 = math::Maths_Rand();
	return uVar1 & 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRandom10(int *stack)
{
	short sVar1;
	
	sVar1 = math::Maths_Rand();
	return (int)sVar1 % 10;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRandom100(int *stack)
{
	short sVar1;
	
	sVar1 = math::Maths_Rand();
	return (int)sVar1 % 100;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetCrystalsPickedUp(int *stack)
{
	return (globals::g_Game.level)->field_94;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetCrystalsCurrentlyStored(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetCrystalCount(1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__False(int *stack)
{
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetOrePickedUp(int *stack)
{
	return (globals::g_Game.level)->field_a8;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetOreCurrentlyStored(int *stack)
{
	return (globals::g_Game.level)->numOre;
}



// NOTE: For the sake of Ghidra auto-completion, the return type
// will be `TutorialFlags`, rather than the required `int` type.

TutorialFlags __cdecl lego::nerps::funcs::NERPFunc__GetTutorialFlags(int *stack)
{
	return globals::nerps::g_NERPs_TutorialFlags;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR0(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[0];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR1(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[1];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR2(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[2];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR3(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[3];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR4(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[4];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR5(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[5];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR6(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[6];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR7(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[7];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR0(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[0] = globals::nerps::g_NERPs_REGISTERS_TABLE[0] + *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[0];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR1(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[1] = globals::nerps::g_NERPs_REGISTERS_TABLE[1] + *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[1];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR2(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[2] = globals::nerps::g_NERPs_REGISTERS_TABLE[2] + *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[2];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR3(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[3] = globals::nerps::g_NERPs_REGISTERS_TABLE[3] + *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[3];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR4(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[4] = globals::nerps::g_NERPs_REGISTERS_TABLE[4] + *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[4];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR5(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[5] = globals::nerps::g_NERPs_REGISTERS_TABLE[5] + *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[5];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR6(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[6] = globals::nerps::g_NERPs_REGISTERS_TABLE[6] + *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[6];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR7(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[7] = globals::nerps::g_NERPs_REGISTERS_TABLE[7] + *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[7];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR0(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[0] = globals::nerps::g_NERPs_REGISTERS_TABLE[0] - *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[0];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR1(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[1] = globals::nerps::g_NERPs_REGISTERS_TABLE[1] - *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[1];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR2(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[2] = globals::nerps::g_NERPs_REGISTERS_TABLE[2] - *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[2];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR3(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[3] = globals::nerps::g_NERPs_REGISTERS_TABLE[3] - *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[3];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR4(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[4] = globals::nerps::g_NERPs_REGISTERS_TABLE[4] - *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[4];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR5(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[5] = globals::nerps::g_NERPs_REGISTERS_TABLE[5] - *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[5];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR6(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[6] = globals::nerps::g_NERPs_REGISTERS_TABLE[6] - *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[6];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR7(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[7] = globals::nerps::g_NERPs_REGISTERS_TABLE[7] - *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[7];
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR0(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[0] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR1(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[1] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR2(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[2] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR3(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[3] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR4(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[4] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR5(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[5] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR6(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[6] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR7(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[7] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialFlags(int *stack)
{
	globals::nerps::g_NERPs_TutorialFlags = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTrainFlags(int *stack)
{
	return globals::nerps::g_NERPs_TrainFlags;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTrainFlags(int *stack)
{
	globals::nerps::g_NERPs_TrainFlags = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMonstersOnLevel(int *stack)
{
	int iVar1;
	int iVar2;
	int iVar3;
	
	iVar1 = game::Level_GetObjectsOfLevel("LavaMonster",0);
	iVar2 = game::Level_GetObjectsOfLevel("RockMonster",0);
	iVar3 = game::Level_GetObjectsOfLevel("IceMonster",0);
	return iVar3 + iVar1 + iVar2;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetBuildingsTeleported(int *stack)
{
	return globals::g_BuildingsTeleported;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetBuildingsTeleported(int *stack)
{
	game::Game_SetNumBuildingsTeleported(*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMessagePermit(int *stack)
{
	globals::nerps::g_NERPs_IsLoaded = *stack;
	if (*stack == 1) {
		game::Game_SetFlags2_40_And_2_unkCamera(0,1);
		game::Game_SetFlags2_80(0);
	}
	FLAGS_00504610 = 0;
	DAT_00504614 = 0;
	return *stack;
}



BOOL __cdecl lego::nerps::NERPs_IsLoaded(void)
{
	return globals::nerps::g_NERPs_IsLoaded;
}



int __cdecl lego::nerps::NERPs_GetMessageWait(void)
{
	return globals::nerps::g_NERPs_MessageWait;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMessageWait(int *stack)
{
	globals::nerps::g_NERPs_MessageWait = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMessageTimerValues(int *stack)
{
	globals::nerps::g_NERPs_MessageTimerValues[0] = (float)(ulonglong)(uint)*stack;
	globals::nerps::g_NERPs_MessageTimerValues[1] = (float)(ulonglong)(uint)stack[1];
	globals::nerps::g_NERPs_MessageTimerValues[2] = (float)(ulonglong)(uint)stack[2];
	return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __cdecl lego::nerps::funcs::NERPFunc__GetMessageTimer(int *stack)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)_DAT_0050098c);
	return (int)lVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMessage(int *stack)
{
	BOOL BVar1;
	char *pcVar2;
	int iVar3;
	uint lineIndex;
	
	BVar1 = NERPs_IsLoaded();
	if (BVar1 != 0) {
		return 0;
	}
	lineIndex = *stack;
	if (lineIndex != 0) {
		lineIndex = lineIndex - 1;
	}
	pcVar2 = NERPs_GetMessageLine(lineIndex);
	if (lineIndex != (&globals::nerps::g_NERPMessageSounds_UNKCOUNT)[UINT_00556de0]) {
		if (UINT_00556de0 == 8) {
			DAT_00556dc0 = DAT_00556dd0;
			DAT_00556dc4 = DAT_00556dd4;
			DAT_00556dcc = DAT_00556ddc;
			DAT_00556dc8 = DAT_00556dd8;
			UINT_00556de0 = 4;
		}
		(&DAT_00556dc0)[UINT_00556de0] = lineIndex;
		UINT_00556de0 = UINT_00556de0 + 1;
		if (UINT_00556de0 != 0) {
			game::Game_SetFlags2_80(1);
		}
		if (UINT_00556de4 != 0) {
			UINT_00556de4 = UINT_00556de4 + 1;
		}
	}
	FUN_0046aee0(pcVar2,stack[1]);
	DAT_00500988 = stack[1];
	BOOL_004a7740 = 1;
	iVar3 = NERPs_GetMessageWait();
	if (iVar3 != 0) {
		ddraw::DirectDraw_Flip();
		while ((globs::INPUT.Key_Map[28] == false ||
					 (globs::INPUT.prevKey_Map[28] == globs::INPUT.Key_Map[28]))) {
			input::Input_ReadKeys();
		}
	}
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetObjectiveSwitch(int *stack)
{
	globals::g_NERPs_ObjectiveSwitch = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetObjectiveSwitch(int *stack)
{
	if (globals::g_NERPs_ObjectiveSwitch != 0) {
		globals::g_NERPs_ObjectiveSwitch = 0;
		return 1;
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetObjectiveShowing(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::Level_IsObjectiveFinished();
	return (uint)(BVar1 != 0);
}



void __cdecl FUN_00456ad0(void)
{
	if (lego::globals::nerps::g_NERPs_UnkSampleIndex != -1) {
		lego::snd::Sound3D_Play2
							(SOUND3D_PLAY_NORMAL,(IDirect3DRMFrame3 *)0x0,
							 lego::globals::nerps::g_NERPs_UnkSampleIndex,0,(Vector3F *)0x0);
	}
	return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl lego::game::Level_NERPMessage_Parse(char *param_1,undefined4 *param_2,BOOL param_3)
{
	char cVar1;
	bool bVar2;
	byte bVar3;
	BOOL BVar4;
	TutorialFlags TVar5;
	int iVar6;
	uint uVar7;
	uint uVar8;
	undefined4 *puVar9;
	char *pcVar10;
	ImageBMP **ppIVar11;
	float10 fVar12;
	Point2F local_164;
	uint local_15c;
	undefined4 uStack344;
	float local_154;
	ImageBMP *local_150 [20];
	char local_100 [256];
	
	ppIVar11 = local_150;
	local_150[0] = (ImageBMP *)0x0;
	local_15c = local_15c & 0xffffff00;
	for (iVar6 = 0x13; ppIVar11 = ppIVar11 + 1, iVar6 != 0; iVar6 = iVar6 + -1) {
		*ppIVar11 = (ImageBMP *)0x0;
	}
	local_154 = globals::nerps::g_NERPs_MessageTimerValues[2];
	if (((globals::nerps::g_NERPMessages_COUNT == 0) &&
			(globals::nerps::g_NERPMessageSounds_COUNT == 0)) && (param_2 != (undefined4 *)0x0)) {
		uVar7 = 0xffffffff;
		do {
			pcVar10 = param_1;
			if (uVar7 == 0) break;
			uVar7 = uVar7 - 1;
			pcVar10 = param_1 + 1;
			cVar1 = *param_1;
			param_1 = pcVar10;
		} while (cVar1 != '\0');
		uVar7 = ~uVar7;
		puVar9 = (undefined4 *)(pcVar10 + -uVar7);
		for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {
			*param_2 = *puVar9;
			puVar9 = puVar9 + 1;
			param_2 = param_2 + 1;
		}
		for (uVar7 = uVar7 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {
			*(undefined *)param_2 = *(undefined *)puVar9;
			puVar9 = (undefined4 *)((int)puVar9 + 1);
			param_2 = (undefined4 *)((int)param_2 + 1);
		}
	}
	else {
		cVar1 = *param_1;
		local_164.x = (float)param_2;
		while (cVar1 != '\0') {
			cVar1 = *param_1;
			if (cVar1 == '<') {
				cVar1 = param_1[1];
				param_1 = param_1 + 1;
				bVar2 = false;
				pcVar10 = local_100;
				while ((cVar1 != '\0' && (!bVar2))) {
					if (cVar1 == '>') {
						*pcVar10 = '\0';
						bVar3 = 0;
						if (globals::nerps::g_NERPMessages_COUNT != 0) {
							uVar7 = 0;
							do {
								iVar6 = std::_stricmp(*(char **)((int)globals::nerps::g_NERPMessages_TABLE +
																								uVar7 * 8),local_100);
								if (iVar6 == 0) {
									bVar2 = true;
									local_150[local_15c & 0xff] =
											 *(ImageBMP **)
												((int)globals::nerps::g_NERPMessages_TABLE + (uint)bVar3 * 8 + 4);
									local_15c = local_15c & 0xffffff00 | (uint)(byte)((char)local_15c + 1);
									break;
								}
								bVar3 = bVar3 + 1;
								uVar7 = (uint)bVar3;
							} while (uVar7 < (uint)globals::nerps::g_NERPMessages_COUNT);
						}
					}
					else {
						*pcVar10 = cVar1;
					}
					pcVar10 = pcVar10 + 1;
					param_1 = param_1 + 1;
					cVar1 = *param_1;
				}
			}
			else {
				if (cVar1 == '#') {
					cVar1 = param_1[1];
					param_1 = param_1 + 1;
					bVar2 = false;
					pcVar10 = local_100;
					while ((cVar1 != '\0' && (!bVar2))) {
						if (cVar1 == '#') {
							*pcVar10 = '\0';
							bVar3 = 0;
							if (globals::nerps::g_NERPMessageSounds_COUNT != 0) {
								uVar7 = 0;
								do {
									iVar6 = std::_stricmp(globals::nerps::g_NERPMessageSounds_TABLE[uVar7].key,
																				local_100);
									if (iVar6 == 0) {
										uVar7 = (uint)bVar3;
										iVar6 = globals::nerps::g_NERPMessageSounds_TABLE[uVar7].sampleIndex;
										if (globals::nerps::g_NERPMessageSounds_UNKCOUNT != uVar7) {
											globals::nerps::g_NERPMessageSounds_UNKCOUNT = uVar7;
											fVar12 = snd::Sound3D_GetSamplePlayTime(iVar6);
											local_154 = (float)(fVar12 * (float10)globals::nerps::
																														g_NERPs_MessageTimerValues[0] +
																				 (float10)globals::nerps::g_NERPs_MessageTimerValues[1]);
											BVar4 = snd::Audio_IsSoundOn();
											if (BVar4 != 0) {
												snd::Audio_FUN_00465140();
												fVar12 = snd::Sound3D_GetSamplePlayTime(iVar6);
												snd::Audio_FUN_00465180((float)(fVar12 * (float10)25.0));
												snd::Sound3D_Play2(SOUND3D_PLAY_NORMAL,(IDirect3DRMFrame3 *)0x0,iVar6,0,
																					 (Vector3F *)0x0);
												globals::nerps::g_NERPs_UnkSampleIndex = iVar6;
												TVar5 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
												if (TVar5 == TUTORIAL_NONE) {
													front::Advisor_SetCurrentAdvisor(ADVISOR_TALKINGAME,1);
													DAT_00556df0 = 1;
												}
											}
										}
										break;
									}
									bVar3 = bVar3 + 1;
									uVar7 = (uint)bVar3;
								} while (uVar7 < (uint)globals::nerps::g_NERPMessageSounds_COUNT);
							}
							bVar2 = true;
						}
						else {
							*pcVar10 = cVar1;
						}
						pcVar10 = pcVar10 + 1;
						param_1 = param_1 + 1;
						cVar1 = *param_1;
					}
				}
				else {
					if (param_2 != (undefined4 *)0x0) {
						*(char *)local_164.x = cVar1;
						local_164.x = (float)((int)local_164.x + 1);
					}
					param_1 = param_1 + 1;
				}
			}
			cVar1 = *param_1;
		}
		if (param_2 != (undefined4 *)0x0) {
			*(char *)local_164.x = '\0';
		}
		if ((char)local_15c != '\0') {
			ppIVar11 = local_150;
			uVar8 = local_15c & 0xff;
			iVar6 = 0;
			uVar7 = uVar8;
			do {
				local_15c = globals::nerps::g_NERPs_IconWidth * uVar8;
				local_164.y = globals::nerps::g_NERPs_IconPos.y;
				uStack344 = 0;
				local_164.x = (float)(ulonglong)(uint)(globals::nerps::g_NERPs_IconSpace * iVar6) +
											(globals::nerps::g_NERPs_IconPos.x - (float)(ulonglong)local_15c);
				image::Image_DisplayScaled(*ppIVar11,(Rect2F *)0x0,&local_164,(Size2F *)0x0);
				iVar6 = iVar6 + 1;
				ppIVar11 = ppIVar11 + 1;
				uVar7 = uVar7 - 1;
			} while (uVar7 != 0);
		}
	}
	if (param_3 != 0) {
		_DAT_0050098c = local_154;
	}
	return;
}



void __cdecl lego::game::Level_InitBlockPointersTable(LevelData *level)
{
	BlockPointer *pBVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	BlockPointer **ppBVar5;
	uint uVar6;
	
	uVar4 = 0;
	ppBVar5 = level->blockPointers;
	for (iVar2 = 0x37; iVar2 != 0; iVar2 = iVar2 + -1) {
		*ppBVar5 = (BlockPointer *)0x0;
		ppBVar5 = ppBVar5 + 1;
	}
	if ((level->dimensions).width != 0) {
		do {
			uVar6 = 0;
			if ((level->dimensions).height != 0) {
				do {
					if (level->blocks[uVar6 * (level->dimensions).width + uVar4].blockpointer != 0) {
						pBVar1 = (BlockPointer *)std::malloc(0xc);
						uVar3 = (uint)level->blocks[uVar6 * (level->dimensions).width + uVar4].blockpointer;
						(pBVar1->position).x = uVar4;
						(pBVar1->position).y = uVar6;
						pBVar1->id = (uint)level->blockPointers[uVar3];
						level->blockPointers[uVar3] = pBVar1;
						level->blocks[uVar6 * (level->dimensions).width + uVar4].blockpointer = 0;
					}
					uVar6 = uVar6 + 1;
				} while (uVar6 < (uint)(level->dimensions).height);
			}
			uVar4 = uVar4 + 1;
		} while (uVar4 < (uint)(level->dimensions).width);
	}
	return;
}



BlockPointer * __cdecl lego::game::Level_GetBlockPointer(LevelData *level,int blockPointerIdx)
{
	if (((-1 < blockPointerIdx) && (blockPointerIdx < 0x37)) &&
		 (level->blockPointers[blockPointerIdx] != (BlockPointer *)0x0)) {
		return level->blockPointers[blockPointerIdx];
	}
	return (BlockPointer *)0x0;
}



void __cdecl lego::game::Level_BlockPointers_FUN_00456f20(void)
{
	BlockPointer *pBVar1;
	LevelData *level;
	BlockPointer *buffer;
	BlockPointer **ppBVar2;
	int blockPointerIdx;
	
	level = GetLevel();
	blockPointerIdx = 0;
	ppBVar2 = level->blockPointers;
	do {
		buffer = Level_GetBlockPointer(level,blockPointerIdx);
		while (buffer != (BlockPointer *)0x0) {
			pBVar1 = (BlockPointer *)buffer->id;
			std::free(buffer);
			buffer = pBVar1;
		}
		*ppBVar2 = (BlockPointer *)0x0;
		blockPointerIdx = blockPointerIdx + 1;
		ppBVar2 = ppBVar2 + 1;
	} while (blockPointerIdx < 0x37);
	return;
}



void __cdecl
lego::game::Level_BlockPointers_FUN_00456f70
					(int blockPointerIdx,undefined *callback,void *lpContext)
{
	LevelData *level;
	BlockPointer *pBVar1;
	int iVar2;
	
	level = GetLevel();
	pBVar1 = Level_GetBlockPointer(level,blockPointerIdx);
	while ((pBVar1 != (BlockPointer *)0x0 &&
				 (iVar2 = (*(code *)callback)(pBVar1,(pBVar1->position).x,(pBVar1->position).y,lpContext),
				 iVar2 != 0))) {
		pBVar1 = (BlockPointer *)pBVar1->id;
	}
	return;
}



BOOL __cdecl
lego::game::Game_UnkTutorialBlock_DoAction(undefined4 unused,int x,int y,undefined4 *param_4)
{
	LiveObject *liveObj1;
	LevelData *level;
	BOOL BVar1;
	uint uVar2;
	uint *puVar3;
	int iVar4;
	char **ppcVar5;
	Point2I local_48;
	uint local_40;
	uint local_3c;
	Vector3F local_38;
	char *local_2c [5];
	CreatureData *local_18;
	BuildingData *local_14;
	Container *local_10;
	UpgradeData *local_c;
	LiveObject *local_8;
	uint local_4;
	
	level = GetLevel();
	local_48.x = x;
	local_48.y = y;
	switch(*param_4) {
	case 1:
		param_4[2] = param_4[2] +
								 (level->blocks[(level->dimensions).width * y + x].flags1 & BLOCK1_UNK_8);
		return 1;
	case 2:
		BVar1 = 0;
		level = GetLevel();
		Level_DestroyWall(level,x,y,BVar1);
		return 1;
	case 3:
		BVar1 = Level_IsBlockPowerPath(&local_48);
		param_4[2] = param_4[2] + BVar1;
		return 1;
	case 4:
		iVar4 = (level->dimensions).width * y + x;
		level->blocks[iVar4].flags1 = level->blocks[iVar4].flags1 & ~BLOCK1_RUBBLE_FULL;
		FUN_00432bc0(&local_48);
		FUN_00432530(&local_48);
		return 1;
	case 5:
		LiveObject_FUN_0042dd70((LiveObject *)0x0,(uint *)&local_48,1);
		return 1;
	case 6:
		res::Container_GetPosition((globals::g_Game.cameraMain)->resData3,(Container *)0x0,&local_38);
		SurfaceMap_ToBlockCoordinatesNoZ
							(level->surfaceMap,local_38.x,local_38.y,(int *)&local_40,(int *)&local_3c);
		if ((local_48.x == local_40) && (local_48.y == local_3c)) {
			param_4[2] = 1;
			return 1;
		}
		break;
	case 7:
		uVar2 = Level_GetEmergeCreature();
		puVar3 = FUN_0043b1f0((int **)(globals::g_Game.RockMonsterData_TABLE + uVar2),4.203895e-45,uVar2
													,local_48.x,local_48.y);
		if (puVar3 != (uint *)0x0) {
			*(undefined4 *)(puVar3[0xcd] + 0xe8) = 0x42700000;
			return 1;
		}
		break;
	case 8:
		ai::AITask_DoGoto_Congregate(&local_48);
		return 1;
	case 9:
		ai::AITask_FUN_00403360(&local_48);
		return 1;
	case 10:
		ppcVar5 = local_2c;
		for (iVar4 = 0xb; iVar4 != 0; iVar4 = iVar4 + -1) {
			*ppcVar5 = (char *)0x0;
			ppcVar5 = ppcVar5 + 1;
		}
		local_18 = (CreatureData *)x;
		local_14 = (BuildingData *)y;
		unk::DoLiveObjCallbacks_True_FUN_00437a70
							(LiveObject_CallbackCheck_FUN_00457320,(LiveObject *)local_2c);
		param_4[2] = local_2c[2] + param_4[2];
		return 1;
	case 0xb:
		ppcVar5 = local_2c;
		for (iVar4 = 0xb; iVar4 != 0; iVar4 = iVar4 + -1) {
			*ppcVar5 = (char *)0x0;
			ppcVar5 = ppcVar5 + 1;
		}
		local_18 = (CreatureData *)x;
		local_14 = (BuildingData *)y;
		local_10 = (Container *)0x1;
		unk::DoLiveObjCallbacks_True_FUN_00437a70
							(LiveObject_Callback_SetField3f8_FUN_00457390,(LiveObject *)local_2c);
		return 1;
	case 0xc:
		ppcVar5 = local_2c;
		for (iVar4 = 0xb; iVar4 != 0; iVar4 = iVar4 + -1) {
			*ppcVar5 = (char *)0x0;
			ppcVar5 = ppcVar5 + 1;
		}
		local_18 = (CreatureData *)x;
		local_14 = (BuildingData *)y;
		local_c = (UpgradeData *)0x1;
		local_4 = 2;
		unk::DoLiveObjCallbacks_True_FUN_00437a70
							(LiveObject_CallbackCheck_FUN_00457320,(LiveObject *)local_2c);
		liveObj1 = local_8;
		if (local_2c[2] != (char *)0x0) {
			local_4 = 6;
			unk::DoLiveObjCallbacks_True_FUN_00437a70
								(LiveObject_CallbackCheck_FUN_00457320,(LiveObject *)local_2c);
			if (local_2c[2] != (char *)0x0) {
				FUN_00439ce0(liveObj1,local_8);
				return 1;
			}
		}
		break;
	case 0xd:
		ppcVar5 = local_2c;
		for (iVar4 = 0xb; iVar4 != 0; iVar4 = iVar4 + -1) {
			*ppcVar5 = (char *)0x0;
			ppcVar5 = ppcVar5 + 1;
		}
		local_18 = (CreatureData *)x;
		local_14 = (BuildingData *)y;
		unk::DoLiveObjCallbacks_True_FUN_00437a70
							(LiveObject_CallbackCheck_FUN_00457320,(LiveObject *)local_2c);
		param_4[2] = local_2c[2] + param_4[2];
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_CallbackCheck_FUN_00457320(LiveObject *liveObj,int level)
{
	int local_8;
	int local_4;
	
	if (liveObj != (LiveObject *)0x0) {
		LiveObject_GetBlockCoordinates(liveObj,&local_8,&local_4);
		if ((local_8 == *(int *)(level + 0x14)) && (local_4 == *(int *)(level + 0x18))) {
			if ((*(int *)(level + 0x20) != 0) && (liveObj->objType == *(ObjectType *)(level + 0x28))) {
				*(LiveObject **)(level + 0x24) = liveObj;
				*(undefined4 *)(level + 8) = 1;
				return 1;
			}
			*(int *)(level + 8) = *(int *)(level + 8) + 1;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_Callback_SetField3f8_FUN_00457390(LiveObject *liveObj,int param_2)
{
	int local_8;
	int local_4;
	
	if (liveObj != (LiveObject *)0x0) {
		LiveObject_GetBlockCoordinates(liveObj,&local_8,&local_4);
		if ((local_8 == *(int *)(param_2 + 0x14)) && (local_4 == *(int *)(param_2 + 0x18))) {
			liveObj->field_3f8 = 1;
			return 0;
		}
		liveObj->field_3f8 = 0;
	}
	return 0;
}



int __cdecl
lego::nerps::funcs::NERPFunc__MakeSomeoneOnThisBlockPickUpSomethingOnThisBlock(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_24 = 0;
	local_28 = *stack;
	local_2c = 0xc;
	game::Level_BlockPointers_FUN_00456f70
						(local_28,PTR_Game_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



void __cdecl FUN_00457430(int blockPointerIdx,int unkMode0_1)
{
	LevelData *level;
	BlockPointer *pBVar1;
	BOOL BVar2;
	int local_34;
	int local_30;
	undefined4 local_2c;
	int local_28;
	undefined4 local_24;
	int local_18;
	int local_14;
	
	level = lego::game::GetLevel();
	for (pBVar1 = lego::game::Level_GetBlockPointer(level,blockPointerIdx);
			pBVar1 != (BlockPointer *)0x0; pBVar1 = (BlockPointer *)pBVar1->id) {
		if (unkMode0_1 == 1) {
			level->blocks[(level->dimensions).width * (pBVar1->position).y + (pBVar1->position).x].
			blockpointer = (byte)blockPointerIdx;
			local_28 = blockPointerIdx;
			local_24 = 0;
			local_2c = 0xb;
			lego::game::Level_BlockPointers_FUN_00456f70
								(blockPointerIdx,PTR_Game_UnkTutorialBlock_DoAction_004a776c,&local_2c);
		}
		if (unkMode0_1 == 0) {
			level->blocks[(level->dimensions).width * (pBVar1->position).y + (pBVar1->position).x].
			blockpointer = 0;
		}
	}
	if ((INT_00556dec != 0) && (BVar2 = FUN_0042df20(INT_00556dec - 1,&unkMode0_1), BVar2 != 0)) {
		lego::game::LiveObject_GetBlockCoordinates((LiveObject *)unkMode0_1,&local_34,&local_30);
		local_18 = local_34;
		local_14 = local_30;
		lego::game::LiveObject_Callback_SetField3f8_FUN_00457390
							((LiveObject *)unkMode0_1,(int)&local_2c);
	}
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetCongregationAtTutorial(int *stack)
{
	int local_2c;
	int local_28;
	int local_24;
	
	local_24 = 0;
	local_28 = *stack;
	local_2c = 9 - (uint)(stack[1] != 0);
	game::Level_BlockPointers_FUN_00456f70
						(local_28,PTR_Game_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetRockMonsterAtTutorial(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 7;
	local_28 = *stack;
	local_24 = 0;
	game::Level_BlockPointers_FUN_00456f70
						(local_28,PTR_Game_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetCameraGotoTutorial(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 5;
	local_28 = *stack;
	local_24 = 0;
	game::Level_BlockPointers_FUN_00456f70
						(local_28,PTR_Game_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetCameraAtTutorial(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 6;
	local_28 = *stack;
	local_24 = 0;
	game::Level_BlockPointers_FUN_00456f70
						(local_28,PTR_Game_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTutorialBlockIsGround(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 1;
	local_28 = *stack;
	local_24 = 0;
	game::Level_BlockPointers_FUN_00456f70
						(local_28,PTR_Game_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTutorialBlockIsPath(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 3;
	local_28 = *stack;
	local_24 = 0;
	game::Level_BlockPointers_FUN_00456f70
						(local_28,PTR_Game_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialBlockIsGround(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 2;
	local_28 = *stack;
	local_24 = 0;
	game::Level_BlockPointers_FUN_00456f70
						(local_28,PTR_Game_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialBlockIsPath(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 4;
	local_28 = *stack;
	local_24 = 0;
	game::Level_BlockPointers_FUN_00456f70
						(local_28,PTR_Game_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetUnitAtBlock(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 10;
	local_28 = *stack;
	local_24 = 0;
	game::Level_BlockPointers_FUN_00456f70
						(local_28,PTR_Game_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMonsterAtTutorial(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 0xd;
	local_28 = *stack;
	local_24 = 0;
	game::Level_BlockPointers_FUN_00456f70
						(local_28,PTR_Game_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



void __cdecl
lego::game::Level_LoadObjectiveText
					(CFGProperty *root,undefined4 param_2,char *param_3,LevelData *level,char *filename)
{
	char cVar1;
	TextWindow *textWnd;
	uint uVar2;
	char *pcVar3;
	uint uVar4;
	char *pcVar5;
	int iVar6;
	int iVar7;
	TextWindow **ppTVar8;
	void **ppvVar9;
	undefined4 *puVar10;
	undefined4 *puVar11;
	char *pcVar12;
	bool bVar13;
	longlong lVar14;
	size_t _MaxCount;
	size_t local_cc8;
	int local_cc0;
	Rect2F local_cbc;
	int local_cac;
	int local_ca8;
	Rect2F local_ca4;
	char *local_c94;
	Rect2F local_c90;
	char local_c80 [126];
	char acStack3074 [1026];
	undefined4 local_800 [256];
	char local_400 [1024];
	
	local_ca4.x = (level->objective).ObjectiveImagePosition.x - -60.0;
	local_c90.y = (level->objective).ObjectiveImagePosition.y - -220.0;
	local_ca4.y = (level->objective).ObjectiveImagePosition.y - -60.0;
	local_cbc.x = (level->objective).ObjectiveImagePosition.x - -40.0;
	local_cbc.y = (level->objective).ObjectiveImagePosition.y - -34.0;
	local_c90.width = 320.0;
	local_c90.height = 20.0;
	local_ca4.width = 390.0;
	local_cac = 0;
	local_ca4.height = 180.0;
	local_cbc.width = 422.0;
	local_cbc.height = 21.0;
	local_cc0 = 0;
	iVar6 = 0;
	local_ca8 = 0;
	local_c90.x = local_ca4.x;
	std::sprintf(CHAR_ARRAY_00500bc8,"%s",filename);
	if (PTR_ARRAY_00500e08[0] != (TextWindow *)0x0) {
		front::TextWindow_Remove(PTR_ARRAY_00500e08[0]);
	}
	if (PTRTextWindow_00500e18 != (TextWindow *)0x0) {
		front::TextWindow_Remove(PTRTextWindow_00500e18);
	}
	if (PTRTextWindow_00500e1c != (TextWindow *)0x0) {
		front::TextWindow_Remove(PTRTextWindow_00500e1c);
	}
	if (PTRTextWindow_00500e20 != (TextWindow *)0x0) {
		front::TextWindow_Remove(PTRTextWindow_00500e20);
	}
	if (PTRTextWindow_00500e24 != (TextWindow *)0x0) {
		front::TextWindow_Remove(PTRTextWindow_00500e24);
	}
	ppTVar8 = PTR_ARRAY_00500e08;
	do {
		textWnd = front::TextWindow_Create(globals::g_Game.bmpMbriefFONT,&local_ca4,0x400);
		*ppTVar8 = textWnd;
		front::TextWindow_EnableCentering(textWnd,0);
		ppTVar8 = ppTVar8 + 1;
	} while (ppTVar8 < &PTRTextWindow_00500e18);
	PTRTextWindow_00500e24 = front::TextWindow_Create(globals::g_Game.bmpMbriefFONT2,&local_c90,0x400)
	;
	BOOL_00500e2c = 0;
	PTRFileStream_00500bc4 = lego::file::File_Open(CHAR_ARRAY_00500bc8,"r");
	ppvVar9 = (void **)&DAT_00500c48;
	do {
		if (*ppvVar9 != (void *)0x0) {
			std::free(*ppvVar9);
			*ppvVar9 = (void *)0x0;
		}
		ppvVar9[0x6c] = (void *)0x0;
		ppvVar9[0x68] = (void *)0x0;
		ppvVar9[100] = (void *)0x0;
		ppvVar9 = ppvVar9 + 1;
	} while (ppvVar9 < &DAT_00500c58);
	if (PTRFileStream_00500bc4 != (FileStream *)0x0) {
		lego::file::File_Seek(PTRFileStream_00500bc4,0,0);
		uVar4 = 0xffffffff;
		pcVar3 = param_3;
		do {
			if (uVar4 == 0) break;
			uVar4 = uVar4 - 1;
			cVar1 = *pcVar3;
			pcVar3 = pcVar3 + 1;
		} while (cVar1 != '\0');
		uVar2 = 0;
		if (~uVar4 != 1) {
			do {
				if (iVar6 == 2) {
					local_c94 = param_3 + uVar2;
					local_ca8 = 1;
					break;
				}
				if (param_3[uVar2] == ':') {
					iVar6 = iVar6 + 1;
				}
				uVar2 = uVar2 + 1;
			} while (uVar2 < ~uVar4 - 1);
		}
		pcVar3 = lego::file::File_GetS(acStack3074 + 2,0x400,PTRFileStream_00500bc4);
		while (pcVar3 != (char *)0x0) {
			if (local_ca8 != 0) {
				uVar4 = 0xffffffff;
				pcVar3 = local_c94;
				do {
					pcVar5 = pcVar3;
					if (uVar4 == 0) break;
					uVar4 = uVar4 - 1;
					pcVar5 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar5;
				} while (cVar1 != '\0');
				uVar4 = ~uVar4;
				puVar10 = (undefined4 *)(pcVar5 + -uVar4);
				puVar11 = local_800;
				for (uVar2 = uVar4 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
					*puVar11 = *puVar10;
					puVar10 = puVar10 + 1;
					puVar11 = puVar11 + 1;
				}
				for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
					*(undefined *)puVar11 = *(undefined *)puVar10;
					puVar10 = (undefined4 *)((int)puVar10 + 1);
					puVar11 = (undefined4 *)((int)puVar11 + 1);
				}
				local_cc8 = std::sprintf(local_400,"[%s]",local_800);
				if (acStack3074[2] == '[') {
					local_cac = 0;
					local_cc0 = 0;
				}
				if (local_cac != 0) {
					uVar4 = 0xffffffff;
					uVar2 = 10;
					pcVar3 = acStack3074 + 2;
					do {
						if (uVar4 == 0) break;
						uVar4 = uVar4 - 1;
						cVar1 = *pcVar3;
						pcVar3 = pcVar3 + 1;
					} while (cVar1 != '\0');
					_MaxCount = 10;
					iVar7 = 4;
					acStack3074[~uVar4] = '\0';
					iVar6 = std::_strnicmp(acStack3074 + 2,"Objective:",_MaxCount);
					if (iVar6 == 0) {
						iVar7 = 0;
					}
					else {
						uVar2 = 0xb;
						iVar6 = std::_strnicmp(acStack3074 + 2,"Completion:",0xb);
						if (iVar6 == 0) {
							iVar7 = 1;
						}
						else {
							uVar2 = 8;
							iVar6 = std::_strnicmp(acStack3074 + 2,"Failure:",8);
							if (iVar6 == 0) {
								iVar7 = 2;
							}
							else {
								uVar2 = 0xf;
								iVar6 = std::_strnicmp(acStack3074 + 2,"CrystalFailure:",0xf);
								if (iVar6 == 0) {
									iVar7 = 3;
								}
							}
						}
					}
					if (iVar7 != 4) {
						uVar4 = 0xffffffff;
						pcVar3 = acStack3074 + 2;
						do {
							if (uVar4 == 0) break;
							uVar4 = uVar4 - 1;
							cVar1 = *pcVar3;
							pcVar3 = pcVar3 + 1;
						} while (cVar1 != '\0');
						if (uVar2 < ~uVar4 - 1) {
							do {
								if ((acStack3074[uVar2 + 2] != ' ') && (acStack3074[uVar2 + 2] != '\t')) break;
								uVar4 = 0xffffffff;
								uVar2 = uVar2 + 1;
								pcVar3 = acStack3074 + 2;
								do {
									if (uVar4 == 0) break;
									uVar4 = uVar4 - 1;
									cVar1 = *pcVar3;
									pcVar3 = pcVar3 + 1;
								} while (cVar1 != '\0');
							} while (uVar2 < ~uVar4 - 1);
						}
						bVar13 = false;
						pcVar3 = acStack3074 + 2;
						cVar1 = acStack3074[2];
						while (cVar1 != '\0') {
							if ((bVar13) && ((*pcVar3 == 'a' || (*pcVar3 == 'n')))) {
								pcVar3[-1] = ' ';
								if (*pcVar3 == 'a') {
									iVar6 = (&DAT_00500df8)[iVar7];
									*pcVar3 = '\a';
									(&DAT_00500df8)[iVar7] = iVar6 + 1;
									bVar13 = false;
								}
								else {
									*pcVar3 = '\n';
									bVar13 = false;
								}
							}
							else {
								bVar13 = *pcVar3 == '\\';
							}
							pcVar5 = pcVar3 + 1;
							pcVar3 = pcVar3 + 1;
							cVar1 = *pcVar5;
						}
						front::TextWindow_PrintF(PTR_ARRAY_00500e08[iVar7],"%s",acStack3074 + uVar2 + 2);
						pcVar3 = std::_strdup(acStack3074 + uVar2 + 2);
						(&DAT_00500c48)[iVar7] = pcVar3;
					}
				}
				if (local_cc0 != 0) {
					uVar4 = 0xffffffff;
					pcVar3 = acStack3074 + 2;
					pcVar5 = acStack3074 + 2;
					do {
						if (uVar4 == 0) break;
						uVar4 = uVar4 - 1;
						cVar1 = *pcVar5;
						pcVar5 = pcVar5 + 1;
					} while (cVar1 != '\0');
					acStack3074[~uVar4] = '\0';
					front::TextWindow_PrintF(PTRTextWindow_00500e24,"%s",pcVar3);
					local_cc0 = 0;
					BOOL_00500e2c = 1;
				}
				iVar6 = std::_strnicmp(local_400,acStack3074 + 2,local_cc8);
				if (iVar6 == 0) {
					local_cac = 1;
				}
				iVar6 = std::_strnicmp(acStack3074 + 2,"[BEGIN]",7);
				if (iVar6 == 0) {
					local_cc0 = 1;
				}
			}
			pcVar3 = lego::file::File_GetS(acStack3074 + 2,0x400,PTRFileStream_00500bc4);
		}
		lego::file::File_Close(PTRFileStream_00500bc4);
	}
	pcVar3 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MissionBriefingText",0);
	pcVar3 = cfg::CFG_ReadString(root,pcVar3);
	if (pcVar3 != (char *)0x0) {
		uVar4 = image::FontX_GetStringWidth(globals::g_Game.bmpMbriefFONT2,pcVar3);
		local_cbc.x = (local_cbc.width * 0.5 - (float)(uVar4 >> 1)) + local_cbc.x;
		local_cbc.width = (float)(ulonglong)uVar4;
		PTRTextWindow_00500e18 =
				 front::TextWindow_Create(globals::g_Game.bmpMbriefFONT2,&local_cbc,0x400);
		if (PTRTextWindow_00500e18 != (TextWindow *)0x0) {
			iVar6 = -1;
			uVar4 = 0;
			pcVar5 = pcVar3;
			do {
				if (iVar6 == 0) break;
				iVar6 = iVar6 + -1;
				cVar1 = *pcVar5;
				pcVar5 = pcVar5 + 1;
			} while (cVar1 != '\0');
			if (iVar6 != -1) {
				pcVar5 = pcVar3;
				do {
					cVar1 = *pcVar5;
					if (cVar1 == '_') {
						cVar1 = ' ';
					}
					pcVar5[(int)(local_c80 + -(int)pcVar3)] = cVar1;
					uVar4 = uVar4 + 1;
					uVar2 = 0xffffffff;
					pcVar5 = pcVar5 + 1;
					pcVar12 = pcVar3;
					do {
						if (uVar2 == 0) break;
						uVar2 = uVar2 - 1;
						cVar1 = *pcVar12;
						pcVar12 = pcVar12 + 1;
					} while (cVar1 != '\0');
				} while (uVar4 < ~uVar2);
			}
			front::TextWindow_Clear(PTRTextWindow_00500e18);
			front::TextWindow_PrintF(PTRTextWindow_00500e18,"%s",local_c80);
		}
	}
	pcVar3 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MissionCompletedText",0);
	pcVar3 = cfg::CFG_ReadString(root,pcVar3);
	if (pcVar3 != (char *)0x0) {
		uVar4 = image::FontX_GetStringWidth(globals::g_Game.bmpMbriefFONT2,pcVar3);
		local_cbc.x = (local_cbc.width * 0.5 - (float)(uVar4 >> 1)) + local_cbc.x;
		local_cbc.width = (float)(ulonglong)uVar4;
		PTRTextWindow_00500e1c =
				 front::TextWindow_Create(globals::g_Game.bmpMbriefFONT2,&local_cbc,0x400);
		if (PTRTextWindow_00500e1c != (TextWindow *)0x0) {
			iVar6 = -1;
			uVar4 = 0;
			pcVar5 = pcVar3;
			do {
				if (iVar6 == 0) break;
				iVar6 = iVar6 + -1;
				cVar1 = *pcVar5;
				pcVar5 = pcVar5 + 1;
			} while (cVar1 != '\0');
			if (iVar6 != -1) {
				pcVar5 = pcVar3;
				do {
					cVar1 = *pcVar5;
					if (cVar1 == '_') {
						cVar1 = ' ';
					}
					pcVar5[(int)(local_c80 + -(int)pcVar3)] = cVar1;
					uVar4 = uVar4 + 1;
					uVar2 = 0xffffffff;
					pcVar5 = pcVar5 + 1;
					pcVar12 = pcVar3;
					do {
						if (uVar2 == 0) break;
						uVar2 = uVar2 - 1;
						cVar1 = *pcVar12;
						pcVar12 = pcVar12 + 1;
					} while (cVar1 != '\0');
				} while (uVar4 < ~uVar2);
			}
			front::TextWindow_Clear(PTRTextWindow_00500e1c);
			front::TextWindow_PrintF(PTRTextWindow_00500e1c,"%s",local_c80);
		}
	}
	pcVar3 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,"Main","MissionFailedText",0);
	pcVar3 = cfg::CFG_ReadString(root,pcVar3);
	if (pcVar3 != (char *)0x0) {
		uVar4 = image::FontX_GetStringWidth(globals::g_Game.bmpMbriefFONT2,pcVar3);
		local_cbc.x = (local_cbc.width * 0.5 - (float)(uVar4 >> 1)) + local_cbc.x;
		local_cbc.width = (float)(ulonglong)uVar4;
		PTRTextWindow_00500e20 =
				 front::TextWindow_Create(globals::g_Game.bmpMbriefFONT2,&local_cbc,0x400);
		if (PTRTextWindow_00500e20 != (TextWindow *)0x0) {
			iVar6 = -1;
			uVar4 = 0;
			pcVar5 = pcVar3;
			do {
				if (iVar6 == 0) break;
				iVar6 = iVar6 + -1;
				cVar1 = *pcVar5;
				pcVar5 = pcVar5 + 1;
			} while (cVar1 != '\0');
			if (iVar6 != -1) {
				pcVar5 = pcVar3;
				do {
					cVar1 = *pcVar5;
					if (cVar1 == '_') {
						cVar1 = ' ';
					}
					pcVar5[(int)(local_c80 + -(int)pcVar3)] = cVar1;
					uVar4 = uVar4 + 1;
					uVar2 = 0xffffffff;
					pcVar5 = pcVar5 + 1;
					pcVar12 = pcVar3;
					do {
						if (uVar2 == 0) break;
						uVar2 = uVar2 - 1;
						cVar1 = *pcVar12;
						pcVar12 = pcVar12 + 1;
					} while (cVar1 != '\0');
				} while (uVar4 < ~uVar2);
			}
			front::TextWindow_Clear(PTRTextWindow_00500e20);
			front::TextWindow_PrintF(PTRTextWindow_00500e20,"%s",local_c80);
		}
	}
	if (BOOL_00500e2c == 0) {
		local_ca4.height = local_ca4.height + local_c90.height;
		ppTVar8 = PTR_ARRAY_00500e08;
		do {
			lVar14 = __ftol((float10)local_ca4.height);
			uVar4 = (uint)lVar14;
			lVar14 = __ftol((float10)local_ca4.width);
			front::TextWindow_ChangeSize(*ppTVar8,(uint)lVar14,uVar4);
			ppTVar8 = ppTVar8 + 1;
		} while (ppTVar8 < PTR_ARRAY_00500e08 + 3);
	}
	return;
}



void __cdecl
lego::game::Level_LoadObjectiveInfo
					(CFGProperty *root,char *rootPath,char *levelName,LevelData *level,int screenWidth,
					int screenHeight)
{
	ObjectiveData *pOVar1;
	char *pcVar2;
	BOOL3 BVar3;
	ImageBMP *pIVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	char *pcVar9;
	BOOL BVar10;
	int iVar11;
	ObjectiveData *pOVar12;
	int local_500;
	ObjectType local_4fc;
	Point2I local_4f8;
	char *local_4f0;
	char *local_4ec;
	char *local_4e8;
	char *local_4e4;
	char *local_4e0;
	char *local_4dc;
	char local_400 [1024];
	
	pOVar1 = &level->objective;
	pOVar12 = pOVar1;
	for (iVar11 = 0x15; iVar11 != 0; iVar11 = iVar11 + -1) {
		pOVar12->ObjectiveImage = (ImageBMP *)0x0;
		pOVar12 = (ObjectiveData *)&pOVar12->ObjectiveImagePosition;
	}
	globals::g_ObjectiveFlags = OBJECTIVE_NONE;
	globals::g_ObjectiveSwitch = 1;
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"DontShowObjectiveAdvisor",0);
	BVar3 = cfg::CFG_ReadBool(root,pcVar2);
	if (BVar3 != BOOL3_TRUE) {
		globals::g_ObjectiveFlags = globals::g_ObjectiveFlags | OBJECTIVE_SHOWADVISOR;
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"DontShowObjectiveAcheiveAdvisor",0);
	BVar3 = cfg::CFG_ReadBool(root,pcVar2);
	if (BVar3 != BOOL3_TRUE) {
		globals::g_ObjectiveFlags = globals::g_ObjectiveFlags | OBJECTIVE_SHOWACHEIVEADVISOR;
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"DontShowObjectiveFailedAdvisor",0);
	BVar3 = cfg::CFG_ReadBool(root,pcVar2);
	if (BVar3 != BOOL3_TRUE) {
		globals::g_ObjectiveFlags = globals::g_ObjectiveFlags | OBJECTIVE_SHOWFAILEDADVISOR;
	}
	std::sprintf(local_400,"ObjectiveImage%ix%i",screenWidth,screenHeight);
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,local_400,0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar2 = std::_strdup(pcVar2);
		iVar11 = util::Util_Tokenise(pcVar2,&local_4f0,",");
		if (pOVar1->ObjectiveImage != (ImageBMP *)0x0) {
			image::Image_Remove(pOVar1->ObjectiveImage);
		}
		pIVar4 = image::Image_LoadBMPScaled(local_4f0,0,0);
		pOVar1->ObjectiveImage = pIVar4;
		if (pIVar4 != (ImageBMP *)0x0) {
			image::Image_SetPenZeroTrans(pIVar4);
		}
		iVar5 = std::atoi(local_4ec);
		(level->objective).ObjectiveImagePosition.x = (float)iVar5;
		iVar5 = std::atoi(local_4e8);
		(level->objective).ObjectiveImagePosition.y = (float)iVar5;
		if ((iVar11 == 6) && (pOVar1->ObjectiveImage != (ImageBMP *)0x0)) {
			uVar6 = std::atoi(local_4e4);
			uVar7 = std::atoi(local_4e0);
			uVar8 = std::atoi(local_4dc);
			image::Image_SetupTrans
								(pOVar1->ObjectiveImage,(float)(ulonglong)(uVar6 / 0xff),
								 (float)(ulonglong)(uVar7 / 0xff),(float)(ulonglong)(uVar8 / 0xff),
								 (float)(ulonglong)(uVar6 / 0xff),(float)(ulonglong)(uVar7 / 0xff),
								 (float)(ulonglong)(uVar8 / 0xff));
		}
		std::free(pcVar2);
	}
	std::sprintf(local_400,"ObjectiveAcheivedImage%ix%i",screenWidth,screenHeight);
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,local_400,0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar2 = std::_strdup(pcVar2);
		iVar11 = util::Util_Tokenise(pcVar2,&local_4f0,",");
		pIVar4 = (level->objective).ObjectiveAcheivedImage;
		if (pIVar4 != (ImageBMP *)0x0) {
			image::Image_Remove(pIVar4);
		}
		pIVar4 = image::Image_LoadBMPScaled(local_4f0,0,0);
		(level->objective).ObjectiveAcheivedImage = pIVar4;
		if (pIVar4 != (ImageBMP *)0x0) {
			image::Image_SetPenZeroTrans(pIVar4);
		}
		iVar5 = std::atoi(local_4ec);
		(level->objective).ObjectiveAcheivedImagePosition.x = (float)iVar5;
		iVar5 = std::atoi(local_4e8);
		(level->objective).ObjectiveAcheivedImagePosition.y = (float)iVar5;
		if ((iVar11 == 6) && ((level->objective).ObjectiveAcheivedImage != (ImageBMP *)0x0)) {
			uVar6 = std::atoi(local_4e4);
			uVar7 = std::atoi(local_4e0);
			uVar8 = std::atoi(local_4dc);
			image::Image_SetupTrans
								(pOVar1->ObjectiveImage,(float)(ulonglong)(uVar6 / 0xff),
								 (float)(ulonglong)(uVar7 / 0xff),(float)(ulonglong)(uVar8 / 0xff),
								 (float)(ulonglong)(uVar6 / 0xff),(float)(ulonglong)(uVar7 / 0xff),
								 (float)(ulonglong)(uVar8 / 0xff));
		}
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"ObjectiveAcheivedAVI",0);
	pcVar2 = cfg::CFG_CopyString(root,pcVar2);
	if (pcVar2 != (char *)0x0) {
		iVar11 = util::Util_Tokenise(pcVar2,&local_4f0,",");
		pcVar9 = std::_strdup(local_4f0);
		(level->objective).ObjectiveAcheivedAVIFilename = pcVar9;
		if (iVar11 == 3) {
			iVar11 = std::atoi(local_4ec);
			(level->objective).ObjectiveAcheivedAVIPosition.x = (float)iVar11;
			iVar11 = std::atoi(local_4e8);
			(level->objective).ObjectiveAcheivedAVIPosition.y = (float)iVar11;
			std::free(pcVar2);
		}
		else {
			(level->objective).field_30 = 1;
			std::free(pcVar2);
		}
	}
	std::sprintf(local_400,"ObjectiveFailedImage%ix%i",screenWidth,screenHeight);
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,local_400,0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar2 = std::_strdup(pcVar2);
		util::Util_Tokenise(pcVar2,&local_4f0,",");
		pIVar4 = (level->objective).ObjectiveFailedImage;
		if (pIVar4 != (ImageBMP *)0x0) {
			image::Image_Remove(pIVar4);
		}
		pIVar4 = image::Image_LoadBMPScaled(local_4f0,0,0);
		(level->objective).ObjectiveFailedImage = pIVar4;
		if (pIVar4 != (ImageBMP *)0x0) {
			image::Image_SetPenZeroTrans(pIVar4);
		}
		iVar11 = std::atoi(local_4ec);
		(level->objective).ObjectiveFailedImagePosition.x = (float)iVar11;
		iVar11 = std::atoi(local_4e8);
		(level->objective).ObjectiveFailedImagePosition.y = (float)iVar11;
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"CrystalObjective",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 == (char *)0x0) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"CrystalObjective",0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	}
	iVar11 = std::atoi(pcVar2);
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"OreObjective",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 == (char *)0x0) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"OreObjective",0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	}
	iVar5 = std::atoi(pcVar2);
	Level_SetCryOreObjectives(level,iVar11,iVar5);
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"TimerObjective",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar2 = std::_strdup(pcVar2);
		util::Util_Tokenise(pcVar2,&local_4f0,":");
		iVar11 = std::atoi(local_4f0);
		iVar5 = std::_stricmp(local_4ec,"HitTimeFailObjective");
		Level_SetTimerObjective(level,(float)iVar11 * 25.0,(uint)(iVar5 == 0));
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"ConstructionObjective",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if ((pcVar2 != (char *)0x0) &&
		 (BVar10 = Object_GetObjectByName(pcVar2,&local_4fc,&local_500,(Container **)0x0), BVar10 != 0))
	{
		Level_SetConstructionObjective(level,local_4fc,local_500);
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"BlockObjective",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != (char *)0x0) {
		pcVar2 = std::_strdup(pcVar2);
		util::Util_Tokenise(pcVar2,&local_4f0,",");
		local_4f8.x = std::atoi(local_4f0);
		local_4f8.y = std::atoi(local_4ec);
		Level_SetBlockObjective(level,&local_4f8);
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"ObjectiveText",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != (char *)0x0) {
		Level_LoadObjectiveText(root,rootPath,levelName,level,pcVar2);
	}
	if (globals::g_ObjectiveFlags == OBJECTIVE_NONE) {
		globals::g_ObjectiveFlags = OBJECTIVE_SHOWADVISOR;
	}
	return;
}



void __cdecl
lego::game::Level_SetCryOreObjectives(LevelData *level,int crystalObjective,int oreObjective)
{
	if (crystalObjective != 0) {
		globals::g_ObjectiveFlags = globals::g_ObjectiveFlags | OBJECTIVE_CRYSTAL;
		(level->objective).CrystalObjective = crystalObjective;
	}
	if (oreObjective != 0) {
		globals::g_ObjectiveFlags = globals::g_ObjectiveFlags | OBJECTIVE_ORE;
		(level->objective).OreObjective = oreObjective;
	}
	return;
}



void __cdecl lego::game::Level_SetBlockObjective(LevelData *level,Point2I *position)
{
	globals::g_ObjectiveFlags = globals::g_ObjectiveFlags | OBJECTIVE_BLOCK;
	(level->objective).BlockObjective.x = position->x;
	(level->objective).BlockObjective.y = position->y;
	return;
}



void __cdecl
lego::game::Level_SetTimerObjective(LevelData *level,float timerObjective,BOOL hitTimeFailObjective)
{
	globals::g_ObjectiveFlags = globals::g_ObjectiveFlags | OBJECTIVE_TIMER;
	(level->objective).TimerObjective = timerObjective;
	if (hitTimeFailObjective != 0) {
		globals::g_ObjectiveFlags = globals::g_ObjectiveFlags | OBJECTIVE_SHOWACHEIVEADVISOR;
	}
	return;
}



void __cdecl lego::game::Level_SetConstructionObjective(LevelData *level,int objType,int objIndex)
{
	globals::g_ObjectiveFlags = globals::g_ObjectiveFlags | OBJECTIVE_CONSTRUCTION;
	(level->objective).ConstructionObjectiveObjType = objType;
	(level->objective).ConstructionObjectiveObjIndex = objIndex;
	return;
}



BOOL __cdecl lego::game::Game_IsLevelComplete(void)
{
	return globals::g_LevelIsComplete;
}



void __cdecl lego::game::Game_SetEndTeleportEnabled(BOOL endTeleportEnabled)
{
	globals::g_IsEndTeleportEnabled = endTeleportEnabled;
	return;
}



void __cdecl lego::game::Level_SetCompleteStatus(LevelCompleteStatus status)
{
	bool bVar1;
	bool bVar2;
	LevelData *pLVar3;
	TutorialFlags TVar4;
	char *pcVar5;
	char *pcVar6;
	uint uVar7;
	char *pcVar8;
	char local_100 [256];
	
	pLVar3 = GetLevel();
	pcVar8 = (char *)0x0;
	bVar1 = true;
	bVar2 = true;
	TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
	if (TVar4 == TUTORIAL_NONE) {
		globals::g_Game.flags2 = globals::g_Game.flags2 | GAME2_INMENU;
	}
	DAT_00500dd8 = 0;
	DAT_00500ddc = 0;
	DAT_00500de0 = 0;
	DAT_00500de4 = 0;
	if ((globals::g_ObjectiveFlags & (OBJECTIVE_UNK_1|OBJECTIVE_COMPLETE|OBJECTIVE_FAILED)) !=
			OBJECTIVE_NONE) {
		DAT_00500dd8 = 0;
		DAT_00500ddc = 0;
		DAT_00500de0 = 0;
		DAT_00500de4 = 0;
		return;
	}
	if ((globals::g_ObjectiveFlags & OBJECTIVE_CRYSTAL) != OBJECTIVE_NONE) {
		DAT_00500dd8 = 0;
		DAT_00500ddc = 0;
		DAT_00500de0 = 0;
		DAT_00500de4 = 0;
		return;
	}
	while ((((globs::INPUT.mslb != 0 || (globs::INPUT.msrb != 0)) || (globs::INPUT.mslbheld != 0)) ||
				 (globs::INPUT.lClicked != 0))) {
		globs::INPUT.lClicked = 0;
		main::Main_LoopUpdate(1);
	}
	if (status == LEVELSTATUS_NONE) {
		pcVar8 = ____EMPTYSTR__;
		globals::g_ObjectiveFlags = globals::g_ObjectiveFlags | OBJECTIVE_UNK_1;
		bVar1 = false;
		pLVar3->status = LEVELSTATUS_NONE;
	}
	else {
		if (status == LEVELSTATUS_COMPLETE) {
			globals::g_LevelIsComplete = 1;
			globals::g_ObjectiveFlags = globals::g_ObjectiveFlags | OBJECTIVE_COMPLETE;
			pLVar3->status = LEVELSTATUS_COMPLETE;
			pcVar8 = "Acheived";
			image::Image_GetScreenshot
								(&globals::g_Save_CaptureBMP,globals::g_Menu_SaveImage_BigSize.width,
								 globals::g_Menu_SaveImage_BigSize.height);
			globals::g_Save_HasCapture = 1;
		}
		else {
			if (status == LEVELSTATUS_FAILED) {
				globals::g_LevelIsComplete = 0;
				globals::g_ObjectiveFlags = globals::g_ObjectiveFlags | OBJECTIVE_FAILED;
				pcVar8 = "Failed";
				pLVar3->status = LEVELSTATUS_FAILED;
			}
			else {
				if (status != LEVELSTATUS_FAILED_CRYSTALS) goto LAB_00458a9a;
				globals::g_LevelIsComplete = 0;
				globals::g_ObjectiveFlags = globals::g_ObjectiveFlags | (OBJECTIVE_FAILED|OBJECTIVE_CRYSTAL)
				;
				pcVar8 = "FailedCrystals";
				pLVar3->status = LEVELSTATUS_FAILED;
				bVar2 = false;
			}
		}
		FUN_004262f0();
		unk::Lego_UnkLevelImportantPilot___004604e0();
	}
LAB_00458a9a:
	globals::g_ObjectiveFlags = globals::g_ObjectiveFlags | OBJECTIVE_UNK_8;
	if (bVar1) {
										// (globals::g_IsEndTeleportEnabled ? 5 : 4)
		uVar7 = (-(uint)(globals::g_IsEndTeleportEnabled != 0) & 0xfffffffe) + 4;
		FUN_0046a7d0(1,2,uVar7);
		FUN_0046a7d0(2,2,uVar7);
		FUN_0046a7d0(8,2,uVar7);
		FUN_0046a7d0(0x400,2,uVar7);
		unk::Lego_SetBool_004b9a54(1);
		LiveManager_SetFlag20(1);
	}
	if ((pcVar8 != (char *)0x0) && (((byte)globals::g_Game.flags1 & GAME1_SOUNDON) != 0)) {
		if (bVar2) {
			pcVar6 = pLVar3->levelName;
		}
		else {
			pcVar6 = ____EMPTYSTR__;
		}
		pcVar5 = "_";
		if (!bVar2) {
			pcVar5 = ____EMPTYSTR__;
		}
		std::sprintf(local_100,"Stream_Objective%s%s%s",pcVar8,pcVar5,pcVar6);
		if (globals::g_StreamObjective_Sample != (char *)0x0) {
			std::free(globals::g_StreamObjective_Sample);
		}
		globals::g_StreamObjective_Sample = std::_strdup(local_100);
		INT_00500e3c = -1;
		BOOL_00500e44 = 0;
		return;
	}
	globals::g_StreamObjective_Sample = (char *)0x0;
	return;
}



void __cdecl FUN_00458ba0(void)
{
	TutorialFlags TVar1;
	
	if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_UNK_1) == OBJECTIVE_NONE) {
		if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_COMPLETE) == OBJECTIVE_NONE) {
			if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_FAILED) != OBJECTIVE_NONE) {
				lego::globals::g_ObjectiveFlags =
						 lego::globals::g_ObjectiveFlags & ~(OBJECTIVE_FAILED|OBJECTIVE_CRYSTAL);
			}
		}
		else {
			lego::globals::g_ObjectiveFlags = lego::globals::g_ObjectiveFlags & ~OBJECTIVE_COMPLETE;
		}
	}
	else {
		lego::nerps::funcs::NERPFunc__SetObjectiveSwitch(&lego::globals::g_ObjectiveSwitch);
		lego::globals::g_ObjectiveFlags = lego::globals::g_ObjectiveFlags & ~OBJECTIVE_UNK_1;
		lego::globals::g_ObjectiveSwitch = 0;
		if ((lego::globals::g_Game.flags2 & GAME2_MUSICON) != GAME2_NONE) {
			lego::snd::Music_PlayNext(1);
			lego::globals::g_Game.flags2 = lego::globals::g_Game.flags2 & ~GAME2_MUSICON;
		}
	}
	lego::front::Advisor_ClearFlag2();
	if (INT_00500e3c != -1) {
		lego::snd::Sound3D_Stream_Stop(0);
		INT_00500e3c = -1;
	}
	FUN_00425b60(0,0);
	lego::snd::Audio_FUN_00465580_true(0);
	TVar1 = lego::nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
	if (TVar1 == TUTORIAL_NONE) {
		lego::globals::g_Game.flags2 = lego::globals::g_Game.flags2 & ~GAME2_INMENU;
	}
	return;
}



BOOL __cdecl lego::game::Level_IsObjectiveFinished(void)
{
	if (((byte)globals::g_ObjectiveFlags & 7) == 0) {
		return 0;
	}
	return 1;
}



void __cdecl FUN_00458c80(int param_1,int param_2,uint *param_3)
{
	int iVar1;
	BOOL BVar2;
	uint uVar3;
	
	uVar3 = 4;
	if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_UNK_1) == OBJECTIVE_NONE) {
		if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_COMPLETE) == OBJECTIVE_NONE) {
			if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_FAILED) != OBJECTIVE_NONE) {
				uVar3 = (uint)((byte)(lego::globals::g_ObjectiveFlags >> 8) & 1 | 2);
			}
		}
		else {
			uVar3 = 1;
		}
	}
	else {
		uVar3 = 0;
	}
	*param_3 = 0;
	if (((param_1 != 0) || (param_2 != 0)) && ((&DAT_00500dd8)[uVar3] == (&DAT_00500df8)[uVar3])) {
		if (((lego::globs::INPUT.msx < 0x82) ||
				((int)((lego::globals::g_Game.BackButton)->width + 0x82) <= lego::globs::INPUT.msx)) ||
			 ((lego::globs::INPUT.msy < 0x13b ||
				((int)((lego::globals::g_Game.BackButton)->height + 0x13b) <= lego::globs::INPUT.msy)))) {
			if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_UNK_1) == OBJECTIVE_NONE) {
				if ((lego::globals::g_ObjectiveFlags & (OBJECTIVE_COMPLETE|OBJECTIVE_FAILED)) !=
						OBJECTIVE_NONE) {
					BVar2 = FUN_0046a780(0x40b);
					if (BVar2 != 0) {
						FUN_00458ba0();
						BVar2 = FUN_00435870();
						*param_3 = (uint)(BVar2 == 0);
					}
				}
			}
			else {
				FUN_00458ba0();
				lego::game::Game_SetMenuNextPosition((Point2F *)0x0);
				lego::game::Game_SetMenuPreviousPosition((Point2F *)0x0);
				FUN_00425b60(0,0);
				lego::input::Input_SetCursorPos
									((int)lego::globs::mainGlobs.appWidth / 2,
									 (int)lego::globs::mainGlobs.appHeight / 2);
				iVar1 = FUN_00407290();
				if (iVar1 != 0) {
					lego::game::Game_ToggleObjectUIsAlwaysVisible();
				}
			}
		}
	}
	if (uVar3 == 4) goto LAB_00458e8c;
	if ((uint)(&DAT_00500dd8)[uVar3] < (uint)(&DAT_00500df8)[uVar3]) {
		if (((lego::globs::INPUT.msx < 0x1d6) ||
				((int)((lego::globals::g_Game.NextButton)->width + 0x1d6) <= lego::globs::INPUT.msx)) ||
			 ((lego::globs::INPUT.msy < 0x13b ||
				((int)((lego::globals::g_Game.NextButton)->height + 0x13b) <= lego::globs::INPUT.msy)))) {
LAB_00458e07:
			if (param_1 == 0) goto LAB_00458e20;
			if (param_2 != 0) goto LAB_00458e0f;
		}
		else {
			lego::front::ToolTip_AddFlag4(0x21);
			if (param_2 == 0) goto LAB_00458e07;
LAB_00458e0f:
			lego::snd::Audio_FUN_00428730(0);
		}
		(&DAT_00500dd8)[uVar3] = (&DAT_00500dd8)[uVar3] + 1;
	}
LAB_00458e20:
	if (((((&DAT_00500dd8)[uVar3] != 0) && (0x81 < lego::globs::INPUT.msx)) &&
			(lego::globs::INPUT.msx < (int)((lego::globals::g_Game.BackButton)->width + 0x82))) &&
		 ((0x13a < lego::globs::INPUT.msy &&
			(lego::globs::INPUT.msy < (int)((lego::globals::g_Game.BackButton)->height + 0x13b))))) {
		lego::front::ToolTip_AddFlag4(0x22);
		if (param_2 != 0) {
			lego::snd::Audio_FUN_00428730(0);
			(&DAT_00500dd8)[uVar3] = (&DAT_00500dd8)[uVar3] + -1;
		}
	}
LAB_00458e8c:
	lego::game::Level_IsObjectiveFinished();
	return;
}



void __cdecl FUN_00458ea0(TextWindow *param_1,LevelData *level,float param_3,float param_4)
{
	ImageBMP *image;
	bool bVar1;
	bool bVar2;
	TextWindow *textWnd;
	BOOL BVar3;
	int iVar4;
	BOOL BVar5;
	float10 fVar6;
	Point2F *pPVar7;
	int local_10;
	Point2F local_c;
	int local_4;
	
	bVar1 = false;
	bVar2 = false;
	BVar5 = 0;
	local_c.x = 0.0;
	if (PROGRAMMER_MODE_3 < lego::globs::mainGlobs.programmerLevel) {
		FUN_00458ba0();
	}
	if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_UNK_1) == OBJECTIVE_NONE) {
		if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_COMPLETE) == OBJECTIVE_NONE) {
			if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_FAILED) == OBJECTIVE_NONE) {
				BVar3 = lego::game::Level_FUN_00459310(level,&local_4,param_3);
				if (BVar3 == 0) {
					lego::unk::Lego_AddToFloat_00556738__DecFloat_0055673c(param_3);
				}
				else {
					if (local_4 == 0) {
						lego::game::Level_SetCompleteStatus(LEVELSTATUS_FAILED);
					}
					else {
						lego::game::Level_SetCompleteStatus(LEVELSTATUS_COMPLETE);
					}
				}
			}
			else {
				BVar3 = FUN_0046a780(0x40b);
				if (BVar3 != 0) {
					local_10 = 2;
					FUN_00459620();
					if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_CRYSTAL) != OBJECTIVE_NONE) {
						local_10 = 3;
					}
					FUN_00425b60(0,1);
					bVar2 = true;
					if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_UNK_8) != OBJECTIVE_NONE) {
						if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_SHOWFAILEDADVISOR) != OBJECTIVE_NONE) {
							lego::front::Advisor_SetCurrentAdvisor(ADVISOR_OBJECTIVE,1);
						}
						lego::globals::g_ObjectiveFlags = lego::globals::g_ObjectiveFlags & ~OBJECTIVE_UNK_8;
					}
					lego::front::Text_DisplayMessage(TEXT_SPACETOCONTINUE,0,0);
					BVar5 = 1;
					bVar1 = true;
				}
			}
		}
		else {
			BVar3 = FUN_0046a780(0x40b);
			if (BVar3 != 0) {
				bVar1 = true;
				FUN_00425b60(0,1);
				lego::unk::Lego_Unk_SORRFile__004595a0();
				if ((level->objective).field_34 == 0) {
					if ((level->objective).field_30 == 0) {
						pPVar7 = &(level->objective).ObjectiveAcheivedAVIPosition;
					}
					else {
						pPVar7 = (Point2F *)0x0;
					}
					lego::video::VideoPlayer_OpenAndPlay
										((level->objective).ObjectiveAcheivedAVIFilename,pPVar7);
					(level->objective).field_34 = 1;
				}
				local_10 = 1;
				bVar2 = true;
				lego::front::Text_DisplayMessage(TEXT_SPACETOCONTINUE,0,0);
				if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_UNK_8) != OBJECTIVE_NONE) {
					if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_SHOWACHEIVEADVISOR) != OBJECTIVE_NONE) {
						lego::front::Advisor_SetCurrentAdvisor(ADVISOR_OBJECTIVE,1);
					}
					lego::globals::g_ObjectiveFlags = lego::globals::g_ObjectiveFlags & ~OBJECTIVE_UNK_8;
				}
				BVar5 = 1;
			}
		}
	}
	else {
		BVar5 = 1;
		FUN_00425b60(0,1);
		local_10 = 0;
		bVar2 = true;
		if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_UNK_8) != OBJECTIVE_NONE) {
			if ((lego::globals::g_ObjectiveFlags & OBJECTIVE_SHOWADVISOR) != OBJECTIVE_NONE) {
				lego::front::Advisor_SetCurrentAdvisor(ADVISOR_OBJECTIVE,1);
			}
			lego::globals::g_ObjectiveFlags = lego::globals::g_ObjectiveFlags & ~OBJECTIVE_UNK_8;
		}
		local_c.x = 1.401298e-45;
		lego::front::Text_DisplayMessage(TEXT_SPACETOCONTINUE,0,0);
	}
	if ((INT_00500e3c != -1) &&
		 (FLOAT_00500e40 = FLOAT_00500e40 - param_4,
		 (ushort)((ushort)(FLOAT_00500e40 < 0.0) << 8 | (ushort)(FLOAT_00500e40 == 0.0) << 0xe) != 0)) {
		lego::front::Advisor_ClearFlag2();
		INT_00500e3c = -1;
	}
	if (((bVar1) && ((lego::globals::g_Game.flags2 & GAME2_MUSICON) == GAME2_NONE)) &&
		 (((byte)lego::globals::g_Game.flags1 & GAME1_MUSICON) != 0)) {
		lego::globals::g_Game.flags2 = lego::globals::g_Game.flags2 | GAME2_MUSICON;
		lego::snd::Music_PlayNext(FALSE);
	}
	if ((BOOL_00500e44 != 0) && (lego::globals::g_StreamObjective_Sample != (char *)0x0)) {
		BVar3 = lego::snd::SFX_GetType(lego::globals::g_StreamObjective_Sample,(SFXType *)&param_4);
		if (BVar3 != 0) {
			iVar4 = lego::snd::Audio_GetFlag8();
			lego::snd::Audio_FUN_00465590(0,0);
			lego::snd::Audio_Play_FUN_00465260((SFXType)param_4,0);
			INT_00500e3c = iVar4;
			fVar6 = lego::snd::Sample_GetRandomDuration((int)param_4);
			FLOAT_00500e40 = (float)((fVar6 - (float10)1.5) * (float10)25.0);
			lego::snd::Audio_FUN_00465580_true(1);
		}
		std::free(lego::globals::g_StreamObjective_Sample);
		lego::globals::g_StreamObjective_Sample = (char *)0x0;
	}
	BOOL_00500e44 = BVar5;
	if (local_c.x != 0.0) {
		lego::snd::Audio_FUN_00465580_true(1);
	}
	if (bVar2) {
		if ((uint)(&DAT_00500dd8)[local_10] < (uint)(&DAT_00500df8)[local_10]) {
			pPVar7 = &local_c;
			local_c.x = 470.0;
			local_c.y = 315.0;
		}
		else {
			pPVar7 = (Point2F *)0x0;
		}
		lego::game::Game_SetMenuNextPosition(pPVar7);
		if ((&DAT_00500dd8)[local_10] == 0) {
			pPVar7 = (Point2F *)0x0;
		}
		else {
			pPVar7 = &local_c;
			local_c.x = 130.0;
			local_c.y = 315.0;
		}
		lego::game::Game_SetMenuPreviousPosition(pPVar7);
		if ((&DAT_00500dd8)[local_10] != (&DAT_00500de8)[local_10]) {
			lego::front::TextWindow_Clear(PTR_ARRAY_00500e08[local_10]);
			lego::front::TextWindow_PagePrintF
								(PTR_ARRAY_00500e08[local_10],(&DAT_00500dd8)[local_10],"%s",
								 (&DAT_00500c48)[local_10]);
			(&DAT_00500de8)[local_10] = (&DAT_00500dd8)[local_10];
		}
		image = (level->objective).ObjectiveImage;
		if (image != (ImageBMP *)0x0) {
			lego::image::Image_DisplayScaled
								(image,(Rect2F *)0x0,&(level->objective).ObjectiveImagePosition,(Size2F *)0x0);
		}
		textWnd = PTRTextWindow_00500e1c;
		if ((level->status != LEVELSTATUS_COMPLETE) &&
			 (textWnd = PTRTextWindow_00500e20, level->status != LEVELSTATUS_FAILED)) {
			textWnd = PTRTextWindow_00500e18;
		}
		if (textWnd != (TextWindow *)0x0) {
			lego::front::TextWindow_Update(textWnd,0,param_3,(int *)0x0);
		}
		if (PTR_ARRAY_00500e08[local_10] != (TextWindow *)0x0) {
			lego::front::TextWindow_Update(PTR_ARRAY_00500e08[local_10],0,param_3,(int *)0x0);
		}
		if (PTRTextWindow_00500e24 != (TextWindow *)0x0) {
			lego::front::TextWindow_Update(PTRTextWindow_00500e24,0,param_3,(int *)0x0);
		}
	}
	return;
}



BOOL __cdecl lego::game::Level_FUN_00459310(LevelData *level,BOOL *out_bool,float elapsed)
{
	float fVar1;
	BOOL BVar2;
	
	if ((globals::g_ObjectiveFlags & OBJECTIVE_SHOWADVISOR) != OBJECTIVE_NONE) {
		return 0;
	}
	*out_bool = 1;
	if ((globals::g_ObjectiveFlags & OBJECTIVE_TIMER) != OBJECTIVE_NONE) {
		fVar1 = (level->objective).TimerObjective - elapsed;
		(level->objective).TimerObjective = fVar1;
		if ((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) != 0) {
			if ((globals::g_ObjectiveFlags & OBJECTIVE_SHOWACHEIVEADVISOR) != OBJECTIVE_NONE) {
				*out_bool = 0;
			}
			return 1;
		}
	}
	if (((globals::g_ObjectiveFlags & OBJECTIVE_CRYSTAL) != OBJECTIVE_NONE) &&
		 ((uint)level->numCrystals < (uint)(level->objective).CrystalObjective)) {
		return 0;
	}
	if (((globals::g_ObjectiveFlags & OBJECTIVE_ORE) != OBJECTIVE_NONE) &&
		 ((uint)level->numOre < (uint)(level->objective).OreObjective)) {
		return 0;
	}
	BVar2 = unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_004593c0,(LiveObject *)&level->objective);
	return (uint)(BVar2 != 0);
}



BOOL __cdecl FUN_004593c0(int *param_1,int param_2)
{
	int local_8;
	int local_4;
	
	if (((lego::globals::g_ObjectiveFlags & OBJECTIVE_BLOCK) != OBJECTIVE_NONE) &&
		 ((*param_1 == 2 || (*param_1 == 1)))) {
		lego::game::LiveObject_GetBlockCoordinates((LiveObject *)param_1,&local_8,&local_4);
		if ((local_8 == *(int *)(param_2 + 0x40)) && (local_4 == *(int *)(param_2 + 0x44))) {
			return 1;
		}
	}
	if ((((lego::globals::g_ObjectiveFlags & OBJECTIVE_CONSTRUCTION) != OBJECTIVE_NONE) &&
			(*(int *)(param_2 + 0x4c) == *param_1)) && (*(int *)(param_2 + 0x50) == param_1[1])) {
		return 1;
	}
	return 0;
}



void __cdecl lego::game::LiveObject_UnkRecallMiniFigureName(LiveObject *liveObj)
{
	LiveFlags5 *pLVar1;
	
	if ((liveObj->objType == OBJECT_MINIFIGURE) &&
		 (((liveObj->flags5_3f0 != LIVEOBJ5_NONE || (liveObj->objLevel != 0)) ||
			(liveObj->customName != (char *)0x0)))) {
		if (UINT_00500e54 == UINT_00500e58) {
			UINT_00500e58 = UINT_00500e58 + 10;
			PTR_00500e50 = std::realloc(PTR_00500e50,UINT_00500e58 * 0x14);
		}
		pLVar1 = (LiveFlags5 *)((int)PTR_00500e50 + UINT_00500e54 * 0x14);
		UINT_00500e54 = UINT_00500e54 + 1;
		*pLVar1 = liveObj->flags5_3f0;
		pLVar1[1] = liveObj->objLevel;
		pLVar1[2] = LIVEOBJ5_NONE;
		pLVar1[3] = LIVEOBJ5_NONE;
		pLVar1[4] = LIVEOBJ5_NONE;
		if (liveObj->customName != (char *)0x0) {
			std::_strncpy((char *)(pLVar1 + 2),liveObj->customName,0xb);
		}
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_RecallMiniFigure(LiveObject *liveObj)
{
	void *pvVar1;
	
	if ((liveObj->objType == OBJECT_MINIFIGURE) && (UINT_00500e54 != 0)) {
		UINT_00500e54 = UINT_00500e54 - 1;
		pvVar1 = (void *)((int)PTR_00500e50 + UINT_00500e54 * 0x14);
		liveObj->flags5_3f0 = *(LiveFlags5 *)((int)PTR_00500e50 + UINT_00500e54 * 0x14);
		LiveObject_SetLevel(liveObj,*(uint *)((int)pvVar1 + 4));
		LiveObject_SetCustomName(liveObj,(char *)((int)pvVar1 + 8));
		return 1;
	}
	return 0;
}



void __cdecl FUN_00459560(void)
{
	UINT_00500e54 = 0;
	UINT_00500e58 = 0;
	if (PTR_00500e50 != (void *)0x0) {
		std::free(PTR_00500e50);
	}
	PTR_00500e50 = (void *)0x0;
	return;
}



void __cdecl lego::unk::Lego_Unk_SORRFile__004595a0(void)
{
	uint uVar1;
	int iVar2;
	undefined4 *puVar3;
	undefined4 *puVar4;
	
	if ((UINT_00500e54 != 0) && (PTR_00500e50 != (void *)0x0)) {
		if (DAT_00500e5c != (undefined4 *)0x0) {
			std::free(DAT_00500e5c);
		}
		DAT_00500e5c = (undefined4 *)std::malloc(UINT_00500e54 * 0x14);
		puVar3 = (undefined4 *)PTR_00500e50;
		puVar4 = DAT_00500e5c;
		for (uVar1 = UINT_00500e54 * 5 & 0x3fffffff; uVar1 != 0; uVar1 = uVar1 - 1) {
			*puVar4 = *puVar3;
			puVar3 = puVar3 + 1;
			puVar4 = puVar4 + 1;
		}
		for (iVar2 = 0; iVar2 != 0; iVar2 = iVar2 + -1) {
			*(undefined *)puVar4 = *(undefined *)puVar3;
			puVar3 = (undefined4 *)((int)puVar3 + 1);
			puVar4 = (undefined4 *)((int)puVar4 + 1);
		}
		UINT_00500e60 = UINT_00500e54;
		DAT_00500e64 = 1;
	}
	return;
}



BOOL __cdecl FUN_00459620(void)
{
	uint uVar1;
	int iVar2;
	undefined4 *puVar3;
	undefined4 *puVar4;
	
	FUN_00459560();
	if ((DAT_00500e5c != (undefined4 *)0x0) && (UINT_00500e60 != 0)) {
		PTR_00500e50 = std::malloc(UINT_00500e60 * 0x14);
		puVar3 = DAT_00500e5c;
		puVar4 = (undefined4 *)PTR_00500e50;
		for (uVar1 = UINT_00500e60 * 5 & 0x3fffffff; uVar1 != 0; uVar1 = uVar1 - 1) {
			*puVar4 = *puVar3;
			puVar3 = puVar3 + 1;
			puVar4 = puVar4 + 1;
		}
		for (iVar2 = 0; iVar2 != 0; iVar2 = iVar2 + -1) {
			*(undefined *)puVar4 = *(undefined *)puVar3;
			puVar3 = (undefined4 *)((int)puVar3 + 1);
			puVar4 = (undefined4 *)((int)puVar4 + 1);
		}
		UINT_00500e54 = UINT_00500e60;
		UINT_00500e58 = UINT_00500e60;
		return 1;
	}
	return 0;
}



undefined4 __cdecl lego::unk::Lego_GetDat_00500e64(void)
{
	return DAT_00500e64;
}



BOOL __cdecl lego::unk::Lego_Write_SORRFile__004596a0(char *filename)
{
	FileStream *f;
	undefined4 local_8;
	uint local_4;
	
	f = lego::file::File_Open(filename,"wb");
	if (f != (FileStream *)0x0) {
		local_8 = 1397707346;
		local_4 = UINT_00500e54;
		lego::file::File_Write(&local_8,4,2,f);
		lego::file::File_Write(PTR_00500e50,0x14,UINT_00500e54,f);
		lego::file::File_Close(f);
		Lego_Unk_SORRFile__004595a0();
		DAT_00500e64 = 0;
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::unk::Lego_Read_SORRFile__00459730(char *filename)
{
	FileStream *f;
	int iVar1;
	BOOL BVar2;
	int local_8;
	uint local_4;
	
	BVar2 = 0;
	FUN_00459560();
	f = lego::file::File_Open(filename,"rb");
	if (f != (FileStream *)0x0) {
		iVar1 = lego::file::File_Length(f);
		lego::file::File_Read(&local_8,4,2,f);
		if (local_8 == 1397707346) {
			if (iVar1 - 8U == local_4 * 0x14) {
				UINT_00500e54 = local_4;
				UINT_00500e58 = local_4;
				PTR_00500e50 = std::malloc(local_4 * 0x14);
				lego::file::File_Read(PTR_00500e50,0x14,UINT_00500e54,f);
				Lego_Unk_SORRFile__004595a0();
				DAT_00500e64 = 0;
			}
		}
		lego::file::File_Close(f);
		BVar2 = 1;
	}
	return BVar2;
}



void __cdecl lego::main::Main_Load_ObjInfo(CFGProperty *root,char *keyBasePath)
{
	Main_Load_ObjInfo_HealthBar(root,keyBasePath);
	Main_Load_ObjInfo_Hunger(root,keyBasePath);
	Main_Load_ObjInfo_Bubble(root,keyBasePath);
	return;
}



BOOL __cdecl lego::main::Main_Load_ObjInfo_HealthBar(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	int iVar2;
	BOOL BVar3;
	BOOL3 BVar4;
	float *pfVar5;
	ColourRGBF *pCVar6;
	float *pfVar7;
	float *out_b;
	char *local_28;
	char *local_24;
	
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarPosition",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 == (char *)0x0) {
		return 0;
	}
	iVar2 = util::Util_Tokenise(pcVar1,&local_28,":");
	if (iVar2 == 2) {
		iVar2 = std::atoi(local_28);
		DAT_00500e6c = (float)iVar2;
		iVar2 = std::atoi(local_24);
		DAT_00500e70 = (float)iVar2;
		std::free(pcVar1);
		pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarWidthHeight",0);
		pcVar1 = cfg::CFG_CopyString(root,pcVar1);
		if (pcVar1 == (char *)0x0) {
			return 0;
		}
		iVar2 = util::Util_Tokenise(pcVar1,&local_28,":");
		if (iVar2 == 2) {
			iVar2 = std::atoi(local_28);
			globals::g_HealthBarWidthHeight_width = (float)iVar2;
			iVar2 = std::atoi(local_24);
			globals::g_HealthBarWidthHeight_height = (float)iVar2;
			std::free(pcVar1);
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarBorderSize",0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 == (char *)0x0) {
				pcVar1 = ____EMPTYSTR__;
			}
			else {
				pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarBorderSize",0);
				pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			}
			globals::g_HealthBarBorderSize = std::atoi(pcVar1);
			out_b = &globals::g_HealthBarBorderRGB_blue;
			pfVar7 = &globals::g_HealthBarBorderRGB_green;
			pfVar5 = &globals::g_HealthBarBorderRGB_red;
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarBorderRGB",0);
			BVar3 = cfg::CFG_ReadRGBF(root,pcVar1,pfVar5,pfVar7,out_b);
			if (BVar3 == 0) {
				return 0;
			}
			globals::g_HealthBarBorderRGB_red_bright =
					 globals::g_HealthBarBorderRGB_red + globals::g_HealthBarBorderRGB_red * 0.4;
			globals::g_HealthBarBorderRGB_red_dark =
					 globals::g_HealthBarBorderRGB_red - globals::g_HealthBarBorderRGB_red * 0.4;
			globals::g_HealthBarBorderRGB_green_bright =
					 globals::g_HealthBarBorderRGB_green + globals::g_HealthBarBorderRGB_green * 0.4;
			globals::g_HealthBarBorderRGB_green_dark =
					 globals::g_HealthBarBorderRGB_green - globals::g_HealthBarBorderRGB_green * 0.4;
			globals::g_HealthBarBorderRGB_blue_bright =
					 globals::g_HealthBarBorderRGB_blue + globals::g_HealthBarBorderRGB_blue * 0.4;
			globals::g_HealthBarBorderRGB_blue_dark =
					 globals::g_HealthBarBorderRGB_blue - globals::g_HealthBarBorderRGB_blue * 0.4;
			pfVar5 = &globals::g_HealthBarBorderRGB_green;
			do {
				if ((ushort)((ushort)(pfVar5[-3] < 1.0) << 8 | (ushort)(pfVar5[-3] == 1.0) << 0xe) == 0) {
					pfVar5[-3] = 1.0;
				}
				if ((ushort)((ushort)(*pfVar5 < 1.0) << 8 | (ushort)(*pfVar5 == 1.0) << 0xe) == 0) {
					*pfVar5 = 1.0;
				}
				if ((ushort)((ushort)(pfVar5[3] < 1.0) << 8 | (ushort)(pfVar5[3] == 1.0) << 0xe) == 0) {
					pfVar5[3] = 1.0;
				}
				if (pfVar5[-3] < 0.0) {
					pfVar5[-3] = 0.0;
				}
				if (*pfVar5 < 0.0) {
					*pfVar5 = 0.0;
				}
				if (pfVar5[3] < 0.0) {
					pfVar5[3] = 0.0;
				}
				pfVar5 = pfVar5 + 1;
			} while (pfVar5 < &globals::g_HealthBarBorderRGB_blue);
			pfVar7 = &globals::g_HealthBarBackgroundRGB.blue;
			pfVar5 = &globals::g_HealthBarBackgroundRGB.green;
			pCVar6 = &globals::g_HealthBarBackgroundRGB;
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarBackgroundRGB",0);
			BVar3 = cfg::CFG_ReadRGBF(root,pcVar1,(float *)pCVar6,pfVar5,pfVar7);
			if (BVar3 == 0) {
				return 0;
			}
			pfVar7 = &globals::g_HealthBarRGB.blue;
			pfVar5 = &globals::g_HealthBarRGB.green;
			pCVar6 = &globals::g_HealthBarRGB;
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarRGB",0);
			BVar3 = cfg::CFG_ReadRGBF(root,pcVar1,(float *)pCVar6,pfVar5,pfVar7);
			if (BVar3 == 0) {
				return 0;
			}
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarVertical",0);
			BVar4 = cfg::CFG_ReadBool(root,pcVar1);
			if (BVar4 == BOOL3_TRUE) {
				globals::g_ObjInfoFlags__00500e68 = globals::g_ObjInfoFlags__00500e68 | 8;
			}
			globals::g_ObjInfoFlags__00500e68 = globals::g_ObjInfoFlags__00500e68 | 2;
			return 1;
		}
	}
	std::free(pcVar1);
	return 0;
}



BOOL __cdecl lego::main::Main_Load_ObjInfo_Hunger(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	int iVar2;
	char *local_28;
	char *local_24;
	
	Main_Load_ObjInfo_HungerImages(root,keyBasePath);
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HungerImagesPosition",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		iVar2 = util::Util_Tokenise(pcVar1,&local_28,":");
		if (iVar2 == 2) {
			iVar2 = std::atoi(local_28);
			globals::g_HungerImagesPosition_x = (float)iVar2;
			iVar2 = std::atoi(local_24);
			globals::g_HungerImagesPosition_y = (float)iVar2;
			std::free(pcVar1);
			globals::g_ObjInfoFlags__00500e68 = globals::g_ObjInfoFlags__00500e68 | 1;
			return 1;
		}
		std::free(pcVar1);
	}
	return 0;
}



void __cdecl lego::main::Main_Load_ObjInfo_HungerImages(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	ImageBMP *image;
	ImageBMP **ppIVar2;
	int iVar3;
	uint width;
	uint height;
	char local_40 [64];
	
	iVar3 = 0;
	ppIVar2 = (ImageBMP **)&DAT_00500ec4;
	do {
		std::sprintf(local_40,"HungerImage%i",iVar3);
		height = 0;
		width = 0;
		pcVar1 = cfg::CFG_JoinPath(rootPath,"ObjInfo","HungerImages",local_40,0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		image = lego::image::Image_LoadBMPScaled(pcVar1,width,height);
		*ppIVar2 = image;
		if (image != (ImageBMP *)0x0) {
			lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
		}
		ppIVar2 = ppIVar2 + 1;
		iVar3 = iVar3 + 1;
	} while (ppIVar2 < &globals::g_BubbleImagesPosition_x);
	return;
}



BOOL __cdecl lego::main::Main_Load_ObjInfo_Bubble(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	int iVar2;
	char *local_28;
	char *local_24;
	
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","BubbleImagesPosition",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		iVar2 = util::Util_Tokenise(pcVar1,&local_28,":");
		if (iVar2 == 2) {
			iVar2 = std::atoi(local_28);
			globals::g_BubbleImagesPosition_x = (float)iVar2;
			iVar2 = std::atoi(local_24);
			globals::g_BubbleImagesPosition_y = (float)iVar2;
			std::free(pcVar1);
			globals::g_ObjInfoFlags__00500e68 = globals::g_ObjInfoFlags__00500e68 | 0x10;
			return 1;
		}
		std::free(pcVar1);
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_00459dc0(LiveObject *liveObj,int param_2,int param_3)
{
	undefined *puVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	BOOL BVar6;
	Point2F *pPVar7;
	float fVar8;
	Point2F *pPVar9;
	float *pfVar10;
	uint uVar11;
	float *pfVar12;
	uint count;
	Point2F *pPVar13;
	float *pfVar14;
	float fVar15;
	float fVar16;
	Rect2F local_17c;
	float *local_16c;
	uint local_168;
	Point2F *local_164;
	uint local_160;
	float local_15c;
	undefined4 uStack344;
	float local_154;
	float local_150;
	float local_14c;
	uint local_148;
	undefined4 uStack324;
	Point2F local_140;
	float local_138 [18];
	Point2F local_f0;
	float afStack232 [18];
	Point2F local_a0;
	float local_98 [18];
	Point2F local_50;
	float local_48 [18];
	
	count = 0;
	local_168 = 0;
	if ((((byte)globals::g_ObjInfoFlags__00500e68 & 2) != 0) &&
		 (BVar6 = LiveObject_FUN_0040aa10(liveObj), BVar6 != 0)) {
		uStack344 = 0;
		local_15c = (float)(globals::g_HealthBarBorderSize * 2);
		fVar8 = globals::g_HealthBarWidthHeight_width + (float)(ulonglong)(uint)local_15c;
		fVar15 = globals::g_HealthBarWidthHeight_height + (float)(ulonglong)(uint)local_15c;
		local_17c.x = (float)param_2 + DAT_00500e6c;
		local_17c.y = (float)param_3 + DAT_00500e70;
		local_160 = 0;
		uVar11 = local_160;
		if (globals::g_HealthBarBorderSize != 0) {
			local_164 = &local_f0;
			local_16c = &local_f0.y;
			local_150 = (local_17c.y + fVar15) - 2.0;
			local_15c = (local_17c.x + fVar8) - 2.0;
			local_14c = (local_17c.x + fVar8) - 1.0;
			local_154 = (local_17c.y + fVar15) - 1.0;
			pPVar9 = &local_50;
			pfVar14 = &local_50.y;
			pfVar12 = &local_140.y;
			pPVar13 = &local_140;
			pfVar10 = &local_a0.y;
			pPVar7 = &local_a0;
			do {
				local_160 = uVar11;
				uStack324 = 0;
				fVar4 = (float)(ulonglong)local_160;
				fVar2 = local_17c.x + fVar4;
				fVar3 = local_17c.y + fVar4;
				fVar5 = local_154 - fVar4;
				pPVar7->x = fVar2;
				*pfVar10 = fVar3;
				fVar16 = pPVar7->x;
				pPVar9->x = fVar2;
				*pfVar12 = local_150 - fVar4;
				*pfVar14 = fVar5;
				pPVar7[1].x = local_14c - fVar4;
				pPVar13->x = fVar16;
				local_164->x = local_15c - fVar4;
				pfVar10[2] = fVar3;
				*local_16c = fVar5;
				pPVar9[1].x = local_14c - fVar4;
				pPVar13[1].x = fVar2 - -1.0;
				pfVar14[2] = fVar5;
				fVar16 = pPVar9[1].x;
				pfVar12[2] = fVar3;
				pPVar7 = pPVar7 + 2;
				pfVar10 = pfVar10 + 4;
				pPVar13 = pPVar13 + 2;
				pfVar14 = pfVar14 + 4;
				local_16c[2] = fVar3 - -1.0;
				pPVar9 = pPVar9 + 2;
				local_164[1].x = fVar16;
				count = local_168 + 2;
				local_164 = local_164 + 2;
				pfVar12 = pfVar12 + 4;
				local_16c = local_16c + 4;
				uVar11 = local_160 + 1;
				local_168 = count;
				local_148 = local_160;
			} while (uVar11 < globals::g_HealthBarBorderSize);
		}
		local_160 = uVar11;
		puVar1 = (undefined *)liveObj->health;
		if (0.0 <= (float)puVar1) {
			if ((ushort)((ushort)((float)puVar1 < 100.0) << 8 | (ushort)((float)puVar1 == 100.0) << 0xe)
					== 0) {
				puVar1 = &DAT_42c80000;
			}
		}
		else {
			puVar1 = (undefined *)0x0;
		}
		if (((byte)globals::g_ObjInfoFlags__00500e68 & 8) == 0) {
			local_17c.width = (float)puVar1 * fVar8 * 0.01;
			local_17c.height = fVar15;
			draw::Draw_RectListEx
								(&local_17c,1,globals::g_HealthBarRGB.red,globals::g_HealthBarRGB.green,
								 globals::g_HealthBarRGB.blue,DrawEffect_None);
			local_17c.x = local_17c.x + local_17c.width;
			local_17c.width = fVar8 - local_17c.width;
			fVar8 = globals::g_HealthBarBackgroundRGB.red;
			fVar15 = globals::g_HealthBarBackgroundRGB.green;
			fVar16 = globals::g_HealthBarBackgroundRGB.blue;
		}
		else {
			local_17c.height = (1.0 - (float)puVar1 * 0.01) * fVar15;
			local_17c.width = fVar8;
			draw::Draw_RectListEx
								(&local_17c,1,globals::g_HealthBarBackgroundRGB.red,
								 globals::g_HealthBarBackgroundRGB.green,globals::g_HealthBarBackgroundRGB.blue,
								 DrawEffect_None);
			local_17c.y = local_17c.y + local_17c.height;
			local_17c.height = fVar15 - local_17c.height;
			fVar8 = globals::g_HealthBarRGB.red;
			fVar15 = globals::g_HealthBarRGB.green;
			fVar16 = globals::g_HealthBarRGB.blue;
		}
		draw::Draw_RectListEx(&local_17c,1,fVar8,fVar15,fVar16,DrawEffect_None);
		draw::Draw_LineListEx
							(&local_a0,&local_140,count,globals::g_HealthBarBorderRGB_red_bright,
							 globals::g_HealthBarBorderRGB_green_bright,globals::g_HealthBarBorderRGB_blue_bright,
							 DrawEffect_None);
		draw::Draw_LineListEx
							(&local_50,&local_f0,count,globals::g_HealthBarBorderRGB_red_dark,
							 globals::g_HealthBarBorderRGB_green_dark,globals::g_HealthBarBorderRGB_blue_dark,
							 DrawEffect_None);
	}
	return;
}



void __cdecl FUN_0045a210(int param_1,int param_2,int param_3)
{
	uint uVar1;
	longlong lVar2;
	Point2F local_8;
	
	if (((byte)lego::globals::g_ObjInfoFlags__00500e68 & 1) != 0) {
		lVar2 = __ftol((float10)*(float *)(param_1 + 0x344) * (float10)0.01 * (float10)5.0);
		uVar1 = (uint)lVar2;
		if (4 < uVar1) {
			uVar1 = 4;
		}
		if ((ImageBMP *)(&DAT_00500ec4)[uVar1] != (ImageBMP *)0x0) {
			local_8.x = (float)param_2 + lego::globals::g_HungerImagesPosition_x;
			local_8.y = (float)param_3 + lego::globals::g_HungerImagesPosition_y;
			lego::image::Image_DisplayScaled
								((ImageBMP *)(&DAT_00500ec4)[uVar1],(Rect2F *)0x0,&local_8,(Size2F *)0x0);
		}
	}
	return;
}



void __cdecl FUN_0045a290(ImageBMP *image,int param_2,int param_3)
{
	Point2F local_8;
	
	if (((byte)lego::globals::g_ObjInfoFlags__00500e68 & 0x10) != 0) {
		local_8.x = (float)param_2 + lego::globals::g_BubbleImagesPosition_x;
		local_8.y = (float)param_3 + lego::globals::g_BubbleImagesPosition_y;
		lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,&local_8,(Size2F *)0x0);
	}
	return;
}



void __cdecl lego::main::Main_InitPanelButtons(void)
{
	globals::g_PanelTypes_TABLE[0] = "Panel_Radar";
	globals::g_PanelTypes_TABLE[1] = "Panel_RadarFill";
	globals::g_PanelTypes_TABLE[2] = "Panel_RadarOverlay";
	globals::g_PanelTypes_TABLE[3] = "Panel_Messages";
	globals::g_PanelTypes_TABLE[4] = "Panel_MessagesSide";
	globals::g_PanelTypes_TABLE[5] = "Panel_CrystalSideBar";
	globals::g_PanelTypes_TABLE[6] = "Panel_TopPanel";
	globals::g_PanelTypes_TABLE[7] = "Panel_Information";
	globals::g_PanelTypes_TABLE[8] = "Panel_PriorityList";
	globals::g_PanelTypes_TABLE[9] = "Panel_CameraControl";
	globals::g_PanelTypes_TABLE[10] = "Panel_InfoDock";
	globals::g_PanelTypes_TABLE[11] = "Panel_Encyclopedia";
	globals::g_PanelButtons_Radar_TABLE[0] = "PanelButton_Radar_Toggle";
	globals::g_PanelButtons_Radar_TABLE[1] = "PanelButton_Radar_TaggedObjectView";
	globals::g_PanelButtons_Radar_TABLE[2] = "PanelButton_Radar_ZoomIn";
	globals::g_PanelButtons_Radar_TABLE[3] = "PanelButton_Radar_ZoomOut";
	globals::g_PanelButtons_Radar_TABLE[4] = "PanelButton_Radar_MapView";
	globals::g_PanelButtons_CrystalSideBar_TABLE[0] = "PanelButton_CrystalSideBar_Ore";
	globals::g_PanelButtons_CrystalSideBar_TABLE[1] = "PanelButton_CrystalSideBar_Crystals";
	globals::g_PanelButtons_TopPanel_TABLE[0] = "PanelButton_TopPanel_Options";
	globals::g_PanelButtons_TopPanel_TABLE[1] = "PanelButton_TopPanel_Priorities";
	globals::g_PanelButtons_TopPanel_TABLE[2] = "PanelButton_TopPanel_CallToArms";
	globals::g_PanelButtons_Information_TABLE[0] = "PanelButton_Information_Toggle";
	globals::g_PanelButtons_Information_TABLE[1] = "PanelButton_Information_Function";
	globals::g_PanelButtons_PriorityList_TABLE[0] = "PanelButton_PriorityList_Disable1";
	globals::g_PanelButtons_PriorityList_TABLE[1] = "PanelButton_PriorityList_Disable2";
	globals::g_PanelButtons_PriorityList_TABLE[2] = "PanelButton_PriorityList_Disable3";
	globals::g_PanelButtons_PriorityList_TABLE[3] = "PanelButton_PriorityList_Disable4";
	globals::g_PanelButtons_PriorityList_TABLE[4] = "PanelButton_PriorityList_Disable5";
	globals::g_PanelButtons_PriorityList_TABLE[5] = "PanelButton_PriorityList_Disable6";
	globals::g_PanelButtons_PriorityList_TABLE[6] = "PanelButton_PriorityList_Disable7";
	globals::g_PanelButtons_PriorityList_TABLE[7] = "PanelButton_PriorityList_Disable8";
	globals::g_PanelButtons_PriorityList_TABLE[8] = "PanelButton_PriorityList_Disable9";
	globals::g_PanelButtons_PriorityList_TABLE[9] = "PanelButton_PriorityList_UpOne1";
	globals::g_PanelButtons_PriorityList_TABLE[10] = "PanelButton_PriorityList_UpOne2";
	globals::g_PanelButtons_PriorityList_TABLE[11] = "PanelButton_PriorityList_UpOne3";
	globals::g_PanelButtons_PriorityList_TABLE[12] = "PanelButton_PriorityList_UpOne4";
	globals::g_PanelButtons_PriorityList_TABLE[13] = "PanelButton_PriorityList_UpOne5";
	globals::g_PanelButtons_PriorityList_TABLE[14] = "PanelButton_PriorityList_UpOne6";
	globals::g_PanelButtons_PriorityList_TABLE[15] = "PanelButton_PriorityList_UpOne7";
	globals::g_PanelButtons_PriorityList_TABLE[16] = "PanelButton_PriorityList_UpOne8";
	globals::g_PanelButtons_PriorityList_TABLE[17] = "PanelButton_PriorityList_Close";
	globals::g_PanelButtons_PriorityList_TABLE[18] = "PanelButton_PriorityList_Reset";
	globals::g_PanelButtons_CameraControl_TABLE[0] = "PanelButton_CameraControl_ZoomIn";
	globals::g_PanelButtons_CameraControl_TABLE[1] = "PanelButton_CameraControl_ZoomOut";
	globals::g_PanelButtons_CameraControl_TABLE[2] = "PanelButton_CameraControl_CycleBuildings";
	globals::g_PanelButtons_CameraControl_TABLE[3] = "PanelButton_CameraControl_Rotate";
	globals::g_PanelButtons_InfoDock_TABLE[0] = "PanelButton_InfoDock_Goto";
	globals::g_PanelButtons_InfoDock_TABLE[1] = "PanelButton_InfoDock_Close";
	globals::g_PanelButtons_Encyclopedia_TABLE[0] = "PanelButton_Encyclopedia_Close";
	UINT_005017d0 = 0xc;
	UINT_005017d4 = 0x18;
	return;
}



void __cdecl lego::main::Main_LoadInterfaceButtons_ScrollInfo(void)
{
	Main_LoadInterfaceButtons_ScrollInfo__internal();
	front::Panel_InitUnkRenderSurfacePtr_FUN_0045bb10();
	FUN_0045ae70(6,1,1);
	FUN_0045ae70(6,2,1);
	return;
}



void __cdecl FUN_0045a530(void)
{
	char *pcVar1;
	char **ppcVar2;
	char *pcVar3;
	int iVar4;
	
	ppcVar2 = (char **)&PanelData_ARRAY_00501110[0].flags;
	do {
		ppcVar2[-5] = ppcVar2[-7];
		pcVar3 = (char *)0x0;
		*ppcVar2 = (char *)((uint)*ppcVar2 & 0xfffffff5 | 4);
		ppcVar2[-4] = ppcVar2[-6];
		if (ppcVar2[-1] != (char *)0x0) {
			iVar4 = 0;
			do {
				pcVar1 = ppcVar2[-2];
				*(undefined4 *)(pcVar1 + iVar4 + 0x24) = 0;
				pcVar1 = pcVar1 + iVar4;
				iVar4 = iVar4 + 0x2c;
				pcVar3 = pcVar3 + 1;
				*(uint *)(pcVar1 + 0x28) = *(uint *)(pcVar1 + 0x28) & 0xffffffb7;
			} while (pcVar3 < ppcVar2[-1]);
		}
		ppcVar2 = ppcVar2 + 0xc;
	} while (ppcVar2 < lego::globals::g_PanelButtons_Radar_TABLE + 0xb);
	FLOAT_00501820 = 0.0;
	return;
}



void __cdecl lego::front::Panel_LoadImage(char *filename,PanelType panelType,uint flags)
{
	uint uVar1;
	ImageBMP *image;
	BOOL BVar2;
	
	PanelData_ARRAY_00501110[panelType].field_28 = 0;
	PanelData_ARRAY_00501110[panelType].flags = flags;
	image = lego::image::Image_LoadBMPScaled(filename,0,0);
	PanelData_ARRAY_00501110[panelType].imageOrFlic = image;
	if (image != (ImageBMP *)0x0) {
		PanelData_ARRAY_00501110[panelType].isFlic = 0;
		lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
		PanelData_ARRAY_00501110[panelType].flags = PanelData_ARRAY_00501110[panelType].flags | 1;
		return;
	}
	BVar2 = lego::image::Flic_Setup
										(filename,(ImageFlic **)(PanelData_ARRAY_00501110 + panelType),
										 FLICMEMORY|FLICLOOPINGON);
	if (BVar2 != 0) {
		uVar1 = PanelData_ARRAY_00501110[panelType].flags;
		PanelData_ARRAY_00501110[panelType].isFlic = 1;
		PanelData_ARRAY_00501110[panelType].flags = uVar1 | 1;
	}
	return;
}



BOOL __cdecl lego::front::Panel_GetPanelType(char *panelName,PanelType *out_panelType)
{
	int iVar1;
	char **ppcVar2;
	int index;
	
	index = 0;
	ppcVar2 = globals::g_PanelTypes_TABLE;
	do {
		iVar1 = std::_stricmp(panelName,(char *)*(ImageBMP **)ppcVar2);
		if (iVar1 == 0) {
			*out_panelType = index;
			return 1;
		}
		ppcVar2 = (char **)((int)ppcVar2 + 4);
										// index++
		index = index + PANEL_RADARFILL;
										// index < PANEL__COUNT (12)
	} while (ppcVar2 < PanelData_ARRAY_00501110);
	return 0;
}



BOOL __cdecl FUN_0045a670(int param_1,int param_2,int param_3)
{
	int iVar1;
	BOOL BVar2;
	uint y;
	PanelData *pPVar3;
	longlong lVar4;
	uint *out_colour;
	
	iVar1 = param_1;
	pPVar3 = PanelData_ARRAY_00501110 + param_1;
	if (PanelData_ARRAY_00501110[param_1].isFlic == 0) {
		out_colour = (uint *)&param_1;
		lVar4 = __ftol((float10)PanelData_ARRAY_00501110[param_1].xyOutIn.y);
		y = param_3 - (int)lVar4;
		lVar4 = __ftol((float10)PanelData_ARRAY_00501110[iVar1].xyOutIn.x);
		BVar2 = lego::image::Image_GetPixel(pPVar3->imageOrFlic,param_2 - (int)lVar4,y,out_colour);
		if (BVar2 != 0) {
			return (uint)(param_1 == 0);
		}
	}
	return 1;
}



BOOL __cdecl lego::front::Panel_GetButtonType(PanelType panelType,char *name,uint *out_buttonType)
{
	int iVar1;
	char **ppcVar2;
	uint uVar3;
	
	ppcVar2 = globals::g_PanelButtons_Radar_TABLE + panelType * 0x18;
	uVar3 = 0;
	do {
		if (*ppcVar2 != (char *)0x0) {
			iVar1 = std::_stricmp(name,*ppcVar2);
			if (iVar1 == 0) {
				*out_buttonType = uVar3;
				return 1;
			}
		}
		uVar3 = uVar3 + 1;
		ppcVar2 = ppcVar2 + 1;
	} while (uVar3 < 0x18);
	return 0;
}



void __cdecl
FUN_0045a720(uint param_1,ImageFont *font,int param_3,int param_4,int param_5,char *format,...)
{
	uint uVar1;
	ImageFont *font_00;
	int y;
	float10 fVar2;
	longlong lVar3;
	char *msg;
	va_list argptr;
	
	font_00 = font;
	uVar1 = param_1;
	if (param_5 != 0) {
		lego::image::Font_VGetStringInfo(font,&param_1,(uint *)0x0,format,&stack0x0000001c);
		param_3 = param_3 - (param_1 >> 1);
	}
	argptr = &stack0x0000001c;
	msg = format;
	fVar2 = __floor((double)((float)param_4 + PanelData_ARRAY_00501110[uVar1].xyOutIn.y));
	lVar3 = __ftol(fVar2);
	y = (int)lVar3;
	fVar2 = __floor((double)((float)param_3 + PanelData_ARRAY_00501110[uVar1].xyOutIn.x));
	lVar3 = __ftol(fVar2);
	lego::image::Font_VPrintF(font_00,(int)lVar3,y,msg,argptr);
	return;
}



TextWindow * __cdecl
lego::unk::Lego_CreatureStruct830_Unk_FUN_0045a7c0
					(int param_1,ImageFont *font,Rect2F *rect,uint size)
{
	TextWindow *pTVar1;
	ImageFont *pIVar2;
	longlong lVar3;
	Rect2F local_10;
	
	local_10.x = 0.0;
	local_10.y = 0.0;
	local_10.width = rect->width;
	local_10.height = rect->height;
	pTVar1 = (TextWindow *)std::malloc(0x10);
	if (pTVar1 != (TextWindow *)0x0) {
		pTVar1->font = (ImageFont *)0x0;
		(pTVar1->windowSize).x = 0.0;
		(pTVar1->windowSize).y = 0.0;
		(pTVar1->windowSize).width = 0.0;
		pIVar2 = (ImageFont *)front::TextWindow_Create(font,&local_10,size);
		pTVar1->font = pIVar2;
		lVar3 = __ftol((float10)rect->x);
		(pTVar1->windowSize).x = (float)lVar3;
		lVar3 = __ftol((float10)rect->y);
		(pTVar1->windowSize).y = (float)lVar3;
		(pTVar1->windowSize).width = (float)(PanelData_ARRAY_00501110 + param_1);
	}
	return pTVar1;
}



void __cdecl FUN_0045a850(TextWindow *param_1,char *format,...)
{
	lego::front::TextWindow_VPrintF((TextWindow *)param_1->font,0,format,&stack0x0000000c);
	return;
}



void __cdecl FUN_0045a870(int **param_1,uint param_2,float param_3)
{
	int ypos;
	float10 fVar1;
	longlong lVar2;
	
	fVar1 = __floor((double)((float)(int)param_1[2] + (float)param_1[3][7]));
	lVar2 = __ftol(fVar1);
	ypos = (int)lVar2;
	fVar1 = __floor((double)((float)(int)param_1[1] + (float)param_1[3][6]));
	lVar2 = __ftol(fVar1);
	lego::front::TextWindow_ChangePosition((TextWindow *)*param_1,(int)lVar2,ypos);
	lego::front::TextWindow_Update((TextWindow *)*param_1,param_2,param_3,(int *)0x0);
	return;
}



void __cdecl lego::image::Struct830_FUN_0045a8e0(TextWindow **param_1)
{
	front::TextWindow_Clear(*param_1);
	return;
}



void __cdecl
lego::image::Struct830_FUN_0045a8f0
					(TextWindow **lpParam_1,undefined4 *out_param_2,undefined4 *out_param_3)
{
	front::TextWindow_GetInfo(*lpParam_1,out_param_2,out_param_3);
	return;
}



void __cdecl lego::front::Panel_SetArea(PanelType panelType,int xOut,int yOut,int xIn,int yIn)
{
	byte bVar1;
	
	PanelData_ARRAY_00501110[panelType].xyOut.x = (float)xOut;
	PanelData_ARRAY_00501110[panelType].xyIn.x = (float)xIn;
	bVar1 = *(byte *)&PanelData_ARRAY_00501110[panelType].flags;
	PanelData_ARRAY_00501110[panelType].xyOut.y = (float)yOut;
	PanelData_ARRAY_00501110[panelType].xyIn.y = (float)yIn;
	PanelData_ARRAY_00501110[panelType].field_20 = 0;
	if ((bVar1 & 2) != 0) {
		PanelData_ARRAY_00501110[panelType].xyOutIn.x = (float)xOut;
		PanelData_ARRAY_00501110[panelType].xyOutIn.y = (float)yOut;
		return;
	}
	PanelData_ARRAY_00501110[panelType].xyOutIn.x = (float)xIn;
	PanelData_ARRAY_00501110[panelType].xyOutIn.y = (float)yIn;
	return;
}



void __cdecl lego::front::Panel_SetXYField3(PanelType panelType,float x,float y)
{
	PanelData_ARRAY_00501110[panelType].xyOutIn.x = x;
	PanelData_ARRAY_00501110[panelType].xyOutIn.y = y;
	return;
}



void __cdecl lego::front::Panel_GetXYField3(PanelType panelType,float *out_x,float *out_y)
{
	*out_x = PanelData_ARRAY_00501110[panelType].xyOutIn.x;
	*out_y = PanelData_ARRAY_00501110[panelType].xyOutIn.y;
	return;
}



void __cdecl lego::front::Panel_FUN_0045a9f0(PanelType panelType,float param_2)
{
	float fVar1;
	uint uVar2;
	PanelData *pPVar3;
	float10 fVar4;
	longlong lVar5;
	ulonglong uVar6;
	float local_28;
	float local_24;
	Point2F local_20;
	uint local_18;
	undefined4 uStack20;
	Rect2F local_10;
	
	pPVar3 = PanelData_ARRAY_00501110 + panelType;
	if ((*(byte *)&PanelData_ARRAY_00501110[panelType].flags & 4) == 0) {
		local_28 = PanelData_ARRAY_00501110[panelType].xyOut.x;
		local_24 = PanelData_ARRAY_00501110[panelType].xyOut.y;
	}
	else {
		local_28 = PanelData_ARRAY_00501110[panelType].xyIn.x;
		local_24 = PanelData_ARRAY_00501110[panelType].xyIn.y;
	}
	if (param_2 != 0.0) {
		fVar1 = ABS(PanelData_ARRAY_00501110[panelType].xyOutIn.x - local_28);
		if ((ushort)((ushort)(fVar1 < 1.0) << 8 | (ushort)(fVar1 == 1.0) << 0xe) == 0) {
			PanelData_ARRAY_00501110[panelType].xyOutIn.x =
					 ((4.0 / param_2) * PanelData_ARRAY_00501110[panelType].xyOutIn.x + local_28) /
					 (4.0 / param_2 - -1.0);
		}
		else {
			PanelData_ARRAY_00501110[panelType].xyOutIn.x = local_28;
		}
		fVar1 = ABS(PanelData_ARRAY_00501110[panelType].xyOutIn.y - local_24);
		if ((ushort)((ushort)(fVar1 < 1.0) << 8 | (ushort)(fVar1 == 1.0) << 0xe) == 0) {
			PanelData_ARRAY_00501110[panelType].xyOutIn.y =
					 ((4.0 / param_2) * PanelData_ARRAY_00501110[panelType].xyOutIn.y + local_24) /
					 (4.0 / param_2 - -1.0);
		}
		else {
			PanelData_ARRAY_00501110[panelType].xyOutIn.y = local_24;
		}
	}
	fVar4 = __floor((double)PanelData_ARRAY_00501110[panelType].xyOutIn.x);
	local_20.x = (float)fVar4;
	local_10.x = (float)fVar4;
	fVar4 = __floor((double)PanelData_ARRAY_00501110[panelType].xyOutIn.y);
	local_20.y = (float)fVar4;
	local_10.y = (float)fVar4;
	if (PanelData_ARRAY_00501110[panelType].isFlic == 0) {
		image::Image_DisplayScaled(pPVar3->imageOrFlic,(Rect2F *)0x0,&local_20,(Size2F *)0x0);
	}
	else {
		if (PanelData_ARRAY_00501110[panelType].isFlic == 1) {
			local_18 = res::AnimClone_IsLws((AnimClone *)pPVar3->imageOrFlic);
			uStack20 = 0;
			local_10.width = (float)(ulonglong)local_18;
			local_18 = image::Flic_GetHeight((ImageFlic *)pPVar3->imageOrFlic);
			uStack20 = 0;
			local_10.height = (float)(ulonglong)local_18;
			uVar6 = CONCAT44(1,~globals::g_Game.flags1 >> 0x14) & 0xffffffff00000001;
			image::Flic_Animate((ImageFlic *)pPVar3->imageOrFlic,&local_10,(BOOL)uVar6,
													(BOOL)(uVar6 >> 0x20));
		}
	}
	if (panelType == PANEL_CAMERACONTROL) {
		if ((FLAGS_00501860 & 0x10) != 0) {
			image::Image_DisplayScaled
								(globals::g_PanelRotationControl_UpImage_bmp,(Rect2F *)0x0,
								 &g_PanelRotationControl_UpImage_position,(Size2F *)0x0);
			FLAGS_00501860 = FLAGS_00501860 & 0xffffffef;
		}
		if ((FLAGS_00501860 & 0x20) != 0) {
			image::Image_DisplayScaled
								(globals::g_PanelRotationControl_DownImage_bmp,(Rect2F *)0x0,
								 &g_PanelRotationControl_DownImage_position,(Size2F *)0x0);
			FLAGS_00501860 = FLAGS_00501860 & 0xffffffdf;
		}
		if ((FLAGS_00501860 & 0x40) != 0) {
			image::Image_DisplayScaled
								(globals::g_PanelRotationControl_LeftImage_bmp,(Rect2F *)0x0,
								 &g_PanelRotationControl_LeftImage_position,(Size2F *)0x0);
			FLAGS_00501860 = FLAGS_00501860 & 0xffffffbf;
		}
		if ((FLAGS_00501860 & 0x80) != 0) {
			image::Image_DisplayScaled
								(globals::g_PanelRotationControl_RightImage_bmp,(Rect2F *)0x0,
								 &g_PanelRotationControl_RightImage_position,(Size2F *)0x0);
			FLAGS_00501860 = FLAGS_00501860 & 0xffffff7f;
		}
	}
	lVar5 = __ftol((float10)PanelData_ARRAY_00501110[panelType].xyOutIn.x - (float10)local_28);
	uVar2 = (int)(uint)lVar5 >> 0x1f;
	if (((int)(((uint)lVar5 ^ uVar2) - uVar2) < 2) &&
		 (lVar5 = __ftol((float10)PanelData_ARRAY_00501110[panelType].xyOutIn.y - (float10)local_24),
		 uVar2 = (int)(uint)lVar5 >> 0x1f, (int)(((uint)lVar5 ^ uVar2) - uVar2) < 2)) {
		PanelData_ARRAY_00501110[panelType].flags =
				 PanelData_ARRAY_00501110[panelType].flags & 0xfffffff7;
	}
	Panel_FUN_0045ac80(panelType);
	return;
}



void __cdecl lego::front::Panel_FUN_0045ac80(PanelType panelType)
{
	float fVar1;
	ImageBMP *image;
	int iVar2;
	uint uVar3;
	int iVar4;
	uint uVar5;
	float *pfVar6;
	Point2F local_8;
	
	uVar5 = 0;
	if (PanelData_ARRAY_00501110[panelType].field_28 != 0) {
		iVar4 = 0;
		do {
			pfVar6 = (float *)(PanelData_ARRAY_00501110[panelType].field_24 + iVar4);
			local_8.x = *pfVar6 + PanelData_ARRAY_00501110[panelType].xyOutIn.x;
			local_8.y = pfVar6[1] + PanelData_ARRAY_00501110[panelType].xyOutIn.y;
			fVar1 = pfVar6[10];
			if (((uint)fVar1 & 0x10) == 0) {
				uVar3 = (uint)fVar1 & 0x40;
				if ((((uint)fVar1 & 8) == 0) && (((uint)fVar1 & 2) != 0)) {
					if (uVar3 == 0) {
LAB_0045ad31:
						image = (ImageBMP *)pfVar6[4];
					}
					else {
						iVar2 = unk::Lego_GetDat_004ded1c();
						if (iVar2 == 0) goto LAB_0045ad5a;
						image = (ImageBMP *)pfVar6[4];
					}
				}
				else {
					if ((((uint)fVar1 & 4) == 0) && (((uint)fVar1 & 8) == 0)) {
						if ((uVar3 == 0) || (iVar2 = unk::Lego_GetDat_004ded1c(), iVar2 == 0)) {
							image = (ImageBMP *)pfVar6[6];
						}
						else {
							image = (ImageBMP *)pfVar6[4];
						}
					}
					else {
						if ((uVar3 != 0) && (iVar2 = unk::Lego_GetDat_004ded1c(), iVar2 != 0))
						goto LAB_0045ad31;
						image = (ImageBMP *)pfVar6[5];
					}
				}
				if (image != (ImageBMP *)0x0) {
					lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,&local_8,(Size2F *)0x0);
				}
			}
LAB_0045ad5a:
			uVar5 = uVar5 + 1;
			iVar4 = iVar4 + 0x2c;
		} while (uVar5 < (uint)PanelData_ARRAY_00501110[panelType].field_28);
	}
	return;
}



void __cdecl lego::front::Panel_FUN_0045ad80(PanelType panelType,int buttonType,BOOL param_3)
{
	uint *puVar1;
	uint uVar2;
	
	puVar1 = (uint *)(PanelData_ARRAY_00501110[panelType].field_24 + 0x28 + buttonType * 0x2c);
	uVar2 = *(uint *)(PanelData_ARRAY_00501110[panelType].field_24 + 0x28 + buttonType * 0x2c);
	if (param_3 != 0) {
		*puVar1 = uVar2 | 0x10;
		return;
	}
	*puVar1 = uVar2 & 0xffffffef;
	return;
}



void __cdecl FUN_0045adc0(int param_1)
{
	uint uVar1;
	
	uVar1 = PanelData_ARRAY_00501110[param_1].flags;
	if ((uVar1 & 2) != 0) {
		PanelData_ARRAY_00501110[param_1].flags = uVar1 & 0xfffffffd | 0xc;
		return;
	}
	PanelData_ARRAY_00501110[param_1].flags = uVar1 & 0xfffffffb | 10;
	return;
}



BOOL __cdecl FUN_0045adf0(int param_1)
{
	if (((PanelData_ARRAY_00501110[param_1].flags & 4) != 0) &&
		 ((PanelData_ARRAY_00501110[param_1].flags & 8) == 0)) {
		return 1;
	}
	return 0;
}



undefined4 __cdecl FUN_0045ae20(int param_1)
{
	if (((PanelData_ARRAY_00501110[param_1].flags & 2) != 0) &&
		 ((PanelData_ARRAY_00501110[param_1].flags & 8) == 0)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl FUN_0045ae50(int param_1)
{
	return PanelData_ARRAY_00501110[param_1].flags & 8;
}



void __cdecl FUN_0045ae70(int param_1,int param_2,int param_3)
{
	int iVar1;
	
	iVar1 = PanelData_ARRAY_00501110[param_1].field_24 + param_2 * 0x2c;
	if (param_3 != 0) {
		*(uint *)(iVar1 + 0x28) = *(uint *)(iVar1 + 0x28) | 0x20;
		return;
	}
	*(uint *)(iVar1 + 0x28) = *(uint *)(iVar1 + 0x28) & 0xffffffdf;
	return;
}



void __cdecl FUN_0045aeb0(int param_1,int param_2,int param_3)
{
	int iVar1;
	uint uVar2;
	
	iVar1 = PanelData_ARRAY_00501110[param_1].field_24 + param_2 * 0x2c;
	uVar2 = *(uint *)(iVar1 + 0x28);
	if ((uVar2 & 0x20) != 0) {
		if (param_3 != 0) {
			*(uint *)(iVar1 + 0x28) = uVar2 | 8;
			return;
		}
		*(uint *)(iVar1 + 0x28) = uVar2 & 0xfffffff3;
	}
	return;
}



void __cdecl
FUN_0045aef0(int param_1,int param_2,int param_3,int param_4,int *param_5,int param_6,int param_7,
						int param_8)
{
	float *pfVar1;
	float fVar2;
	float fVar3;
	char *pcVar4;
	void *pvVar5;
	ImageBMP *pIVar6;
	float *pfVar7;
	char **ppcVar8;
	float *pfVar9;
	
	if (param_2 != 0) {
		pvVar5 = std::malloc(param_2 * 0x2c);
		PanelData_ARRAY_00501110[param_1].field_24 = pvVar5;
		PanelData_ARRAY_00501110[param_1].field_28 = param_2;
		if (param_2 != 0) {
			pfVar9 = (float *)(param_4 + 4);
			ppcVar8 = (char **)param_5;
			do {
				pfVar7 = (float *)((param_8 - (int)param_5) + (int)ppcVar8);
				pfVar1 = (float *)(PanelData_ARRAY_00501110[param_1].field_24 +
													*(int *)((int)pfVar7 + (param_3 - param_8)) * 0x2c);
				*pfVar1 = pfVar9[-1];
				pfVar1[1] = *pfVar9;
				pfVar1[2] = pfVar9[1] + pfVar9[-1];
				fVar2 = pfVar9[2];
				fVar3 = *pfVar9;
				pfVar1[6] = 0.0;
				pfVar1[4] = 0.0;
				pfVar1[5] = 0.0;
				pfVar1[3] = fVar2 + fVar3;
				pfVar1[8] = *pfVar7;
				if ((param_5 != (int *)0x0) && (*ppcVar8 != (char *)0x0)) {
					pIVar6 = lego::image::Image_LoadBMPScaled(*ppcVar8,0,0);
					pfVar1[6] = (float)pIVar6;
					if (pIVar6 != (ImageBMP *)0x0) {
						lego::image::Image_SetupTrans(pIVar6,0.0,0.0,0.0,0.0,0.0,0.0);
					}
				}
				if ((param_6 != 0) &&
					 (pcVar4 = *(char **)((param_6 - (int)param_5) + (int)ppcVar8), pcVar4 != (char *)0x0)) {
					pIVar6 = lego::image::Image_LoadBMPScaled(pcVar4,0,0);
					pfVar1[4] = (float)pIVar6;
					if (pIVar6 != (ImageBMP *)0x0) {
						lego::image::Image_SetupTrans(pIVar6,0.0,0.0,0.0,0.0,0.0,0.0);
					}
				}
				if ((param_7 != 0) &&
					 (pcVar4 = *(char **)((param_7 - (int)param_5) + (int)ppcVar8), pcVar4 != (char *)0x0)) {
					pIVar6 = lego::image::Image_LoadBMPScaled(pcVar4,0,0);
					pfVar1[5] = (float)pIVar6;
					if (pIVar6 != (ImageBMP *)0x0) {
						lego::image::Image_SetupTrans(pIVar6,0.0,0.0,0.0,0.0,0.0,0.0);
					}
				}
				pfVar9 = pfVar9 + 4;
				ppcVar8 = ppcVar8 + 1;
				param_2 = param_2 + -1;
				pfVar1[10] = 0.0;
			} while (param_2 != 0);
		}
	}
	return;
}



BOOL __cdecl
FUN_0045b070(float param_1,uint param_2,uint param_3,uint param_4,int param_5,undefined4 *param_6)
{
	int *piVar1;
	uint uVar2;
	uint uVar3;
	int iVar4;
	BOOL BVar5;
	TutorialFlags TVar6;
	LevelData *pLVar7;
	
	iVar4 = param_5;
	uVar3 = param_4;
	uVar2 = param_3;
	if (param_4 == 0) {
		FLAGS_00501860 = FLAGS_00501860 & 0xfffffffe;
	}
	BVar5 = FUN_0045b5d0((uint *)&param_6,&param_4,param_2,param_3,param_4,param_5,&param_5,param_6);
	if (BVar5 == 0) {
		BVar5 = FUN_00463b60((int *)&param_3,param_2,uVar2,uVar3,iVar4);
		if (BVar5 == 0) {
			return (BOOL)(undefined4 *)0x0;
		}
		if (param_3 == 0) {
			FUN_0041a1c0();
		}
		if (param_5 == 0) {
			return (BOOL)(undefined4 *)0x1;
		}
	}
	else {
		lego::globals::g_Game.flags1 = lego::globals::g_Game.flags1 | GAME1_UNK_200;
		if ((param_6 == (undefined4 *)&DAT_0000000c) || (param_4 == 0x18)) {
			return (BOOL)param_6;
		}
		TVar6 = lego::nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
		if (param_5 != 0) {
			piVar1 = (int *)(PanelData_ARRAY_00501110[(int)param_6].field_24 + 0x24 + param_4 * 0x2c);
			*piVar1 = *piVar1 + 1;
			if (((TVar6 & TUTORIAL_UNK_10) != TUTORIAL_NONE) && (param_6 == (undefined4 *)0x0)) {
				lego::snd::Audio_FUN_00428730(1);
				return (BOOL)(undefined4 *)0x1;
			}
			if ((((TVar6 & TUTORIAL_UNK_20) != TUTORIAL_NONE) && (param_6 == (undefined4 *)0x6)) &&
				 (param_4 == 0)) {
				FUN_0045aeb0(6,0,0);
				lego::snd::Audio_FUN_00428730(1);
				return (BOOL)(undefined4 *)0x1;
			}
			if ((((TVar6 & TUTORIAL_UNK_40) != TUTORIAL_NONE) && (param_6 == (undefined4 *)0x6)) &&
				 (param_4 == 1)) {
				FUN_0045aeb0(6,1,0);
				lego::snd::Audio_FUN_00428730(1);
				return (BOOL)(undefined4 *)0x1;
			}
			if ((((TVar6 & TUTORIAL_UNK_80) != TUTORIAL_NONE) && (param_6 == (undefined4 *)0x6)) &&
				 (param_4 == 2)) {
				FUN_0045aeb0(6,2,0);
				lego::snd::Audio_FUN_00428730(1);
				return (BOOL)(undefined4 *)0x1;
			}
			if ((((TVar6 & TUTORIAL_UNK_400) != TUTORIAL_NONE) && (param_6 == (undefined4 *)&DAT_00000009)
					) && (param_4 == 2)) {
				lego::snd::Audio_FUN_00428730(1);
				return (BOOL)(undefined4 *)0x1;
			}
			if (((TVar6 & TUTORIAL_UNK_1000) != TUTORIAL_NONE) && (param_6 == (undefined4 *)&DAT_00000009)
				 ) {
				if ((param_4 == 0) || (param_4 == 1)) goto LAB_0045b57a;
				if (param_4 == 3) {
					lego::snd::Audio_FUN_00428730(1);
					return (BOOL)(undefined4 *)0x1;
				}
			}
		}
		if (uVar3 != 0) {
			if (param_6 == (undefined4 *)0x0) {
				if ((lego::globals::g_Game.flags1 & GAME1_RADAR_MAPVIEW) != GAME1_NONE) {
					if (param_4 == 2) {
						if (lego::globals::g_Game.tvTiltOrZoom_334 < 20.0) {
							lego::globals::g_Game.tvTiltOrZoom_334 =
									 param_1 + lego::globals::g_Game.tvTiltOrZoom_334;
						}
						if ((ushort)((ushort)(lego::globals::g_Game.tvTiltOrZoom_334 < 20.0) << 8 |
												(ushort)(lego::globals::g_Game.tvTiltOrZoom_334 == 20.0) << 0xe) == 0) {
							lego::globals::g_Game.tvTiltOrZoom_334 = 20.0;
						}
					}
					else {
						if (param_4 == 3) {
							if ((ushort)((ushort)(lego::globals::g_Game.tvTiltOrZoom_334 < 10.0) << 8 |
													(ushort)(lego::globals::g_Game.tvTiltOrZoom_334 == 10.0) << 0xe) == 0) {
								lego::globals::g_Game.tvTiltOrZoom_334 =
										 lego::globals::g_Game.tvTiltOrZoom_334 - param_1;
							}
							if (lego::globals::g_Game.tvTiltOrZoom_334 < 10.0) {
								lego::globals::g_Game.tvTiltOrZoom_334 = 10.0;
							}
						}
					}
				}
			}
			else {
				if (((param_6 == (undefined4 *)&DAT_00000009) &&
						(TVar6 = lego::nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0),
						(TVar6 & TUTORIAL_UNK_1000) == TUTORIAL_NONE)) &&
					 (lego::view::Camera_MoveGame_Cam24_Float90(param_4,param_1), param_4 == 3)) {
					lego::front::Panel_RotationControl_FUN_0045bf90(param_2,uVar2,param_1);
				}
			}
		}
		if (param_5 == 0) {
			return (BOOL)(undefined4 *)0x1;
		}
		pLVar7 = lego::game::GetLevel();
		if (pLVar7->status == LEVELSTATUS_NONE) {
			lego::snd::Audio_FUN_00428730(0);
			switch(param_6) {
			case (undefined4 *)0x0:
				if (param_4 == 0) {
					FUN_0045adc0(0);
					FUN_0045adc0(1);
					return (BOOL)(undefined4 *)0x1;
				}
				if (param_4 != 1) {
					if (param_4 != 4) {
						return (BOOL)(undefined4 *)0x1;
					}
					lego::globals::g_Game.flags1 =
							 lego::globals::g_Game.flags1 & ~GAME1_RADAR_TRACKOBJECTVIEW | GAME1_RADAR_MAPVIEW;
					lego::front::Panel_FUN_0045ad80(PANEL_RADAR,2,0);
					lego::front::Panel_FUN_0045ad80(PANEL_RADAR,3,0);
					return (BOOL)(undefined4 *)0x1;
				}
				lego::globals::g_Game.flags1 =
						 lego::globals::g_Game.flags1 &
						 (GAME1_HIGHFOGCOLOURRGB|GAME1_UNK_20000|GAME1_UNK_40000|GAME1_DYNAMICPM|
							GAME1_CAMERADISABLED|GAME1_UNK_200000|GAME1_ONLYBUILDONPATHS|GAME1_ALWAYSROCKFALL|
							GAME1_DEBUG_NONERPS|GAME1_PAUSED|GAME1_STREAMNERPSSPEACH|GAME1_UNK_8000000|
							GAME1_LASERTRACKER|GAME1_UNK_20000000|GAME1_DEBUG_NOCLIP_FPS|GAME1_UNK_80000000) |
						 (ushort)((ushort)lego::globals::g_Game.flags1 | 0x2000) & ~GAME1_RADAR_MAPVIEW;
				lego::front::Panel_FUN_0045ad80(PANEL_RADAR,2,1);
				lego::front::Panel_FUN_0045ad80(PANEL_RADAR,3,1);
				return (BOOL)(undefined4 *)0x1;
			default:
				return (BOOL)(undefined4 *)0x1;
			case (undefined4 *)0x6:
				goto switchD_0045b34e_caseD_6;
			case (undefined4 *)0x8:
				if (param_4 == 0x12) {
					FUN_0045d1c0();
					return (BOOL)(undefined4 *)0x1;
				}
				if (param_4 == 0x11) {
					if (((byte)PanelData_ARRAY_00501110[8].flags & 4) != 0) {
						return (BOOL)(undefined4 *)0x1;
					}
					FUN_0041e680();
					return (BOOL)(undefined4 *)0x1;
				}
				FUN_0045b8e0(param_4);
				return (BOOL)(undefined4 *)0x1;
			case (undefined4 *)0x9:
				if (param_4 != 2) {
					return (BOOL)(undefined4 *)0x1;
				}
				FUN_0044c810();
				return (BOOL)(undefined4 *)0x1;
			case (undefined4 *)0xa:
				if (param_4 == 1) {
					FUN_00419d90();
					return (BOOL)(undefined4 *)0x1;
				}
				if (param_4 != 0) {
					return (BOOL)(undefined4 *)0x1;
				}
				FUN_00419d10(0);
				FUN_00419cd0();
				return (BOOL)(undefined4 *)0x1;
			case (undefined4 *)0xb:
				if (param_4 != 0) {
					return (BOOL)(undefined4 *)0x1;
				}
				if (((byte)PanelData_ARRAY_00501110[11].flags & 4) != 0) {
					return (BOOL)(undefined4 *)0x1;
				}
				FUN_0041e680();
				return (BOOL)(undefined4 *)0x1;
			}
		}
	}
LAB_0045b57a:
	lego::snd::Audio_FUN_00428730(1);
	return (BOOL)(undefined4 *)0x1;
switchD_0045b34e_caseD_6:
	if ((lego::globals::g_Game.viewMode != VIEW_FIRSTPERSON) && (param_4 == 1)) {
		if (((byte)PanelData_ARRAY_00501110[8].flags & 4) == 0) {
			FUN_0041e680();
		}
		else {
			lego::game::Level_AddMessageAction(MESSAGE_CLEARSELECT,0,0,(Point2I *)0x0);
			FUN_0041b200(0x16,(Point2I *)0x0);
		}
	}
	if (param_4 == 0) {
		FUN_00425b60(1,0);
		lego::globals::g_Game.flags2 = lego::globals::g_Game.flags2 ^ GAME2_INOPTIONSMENU;
		return (BOOL)(undefined4 *)0x1;
	}
	if (param_4 != 2) {
		return (BOOL)(undefined4 *)0x1;
	}
	if ((lego::globals::g_Game.flags2 & GAME2_CALLTOARMS) == GAME2_NONE) {
		lego::game::Game_SetCallToArmsOn(1);
		return (BOOL)(undefined4 *)0x1;
	}
	lego::game::Game_SetCallToArmsOn(0);
	return (BOOL)(undefined4 *)0x1;
}



BOOL __cdecl
FUN_0045b5d0(uint *param_1,uint *param_2,int param_3,int param_4,int param_5,int param_6,
						undefined4 *param_7,undefined4 *param_8)
{
	Vector3F *pVVar1;
	BOOL BVar2;
	int iVar3;
	BOOL BVar4;
	uint uVar5;
	float fVar6;
	uint local_4;
	
	BVar4 = 0;
	if (param_7 != (undefined4 *)0x0) {
		*param_7 = 0;
	}
	*param_2 = 0x18;
	*param_1 = 0xc;
	if (((byte)FLAGS_00501860 & 1) != 0) {
		*param_1 = 9;
		*param_2 = 3;
		return 1;
	}
	local_4 = 0;
	do {
		if ((*(byte *)&PanelData_ARRAY_00501110[local_4].flags & 1) != 0) {
			if ((((param_8 != (undefined4 *)0x0) && (local_4 != 1)) && (local_4 != 2)) &&
				 (BVar2 = FUN_0045a670(local_4,param_3,param_4), BVar2 == 0)) {
				*param_8 = 1;
			}
			uVar5 = 0;
			if (PanelData_ARRAY_00501110[local_4].field_28 != 0) {
				do {
					pVVar1 = (Vector3F *)(PanelData_ARRAY_00501110[local_4].field_24 + uVar5 * 0x2c);
					if (BVar4 == 0) {
						if ((local_4 == 9) && (uVar5 == 3)) {
							iVar3 = FUN_0045bb60(param_3,param_4,
																	 lego::globals::g_PanelRotationControl_CenterPosition.x,
																	 lego::globals::g_PanelRotationControl_CenterPosition.y,
																	 lego::globals::g_PanelRotationControl_Radius);
						}
						else {
							iVar3 = FUN_0045b850(PanelData_ARRAY_00501110 + local_4,pVVar1,param_3,param_4);
						}
						if (iVar3 == 0) goto LAB_0045b7eb;
						*param_1 = local_4;
						if (param_5 == 0) {
							fVar6 = pVVar1[2].z;
							if (((fVar6 == 3.643376e-44) && (DAT_004ebbc8 == 0)) &&
								 (((byte)lego::pool::globals::ReservedPool_LiveObject___g_INITFLAGS & 0x40) != 0)) {
								fVar6 = 4.904545e-44;
							}
							lego::front::ToolTip_AddFlag4((int)fVar6);
							if (UINT_005017d4 != 0x18) {
								if ((local_4 == UINT_005017d0) && (uVar5 == UINT_005017d4)) {
									*param_2 = uVar5;
									fVar6 = pVVar1[3].y;
									if (((uint)fVar6 & 0x20) != 0) {
										if (((uint)fVar6 & 8) == 0) {
											fVar6 = (float)((uint)fVar6 | 8);
										}
										else {
											fVar6 = (float)((uint)fVar6 & 0xfffffff7);
										}
										pVVar1[3].y = fVar6;
									}
									if (param_7 != (undefined4 *)0x0) {
										*param_7 = 1;
									}
									pVVar1[3].y = (float)((uint)pVVar1[3].y & 0xfffffffb | 2);
								}
								goto LAB_0045b7e4;
							}
							BVar4 = 1;
							*param_2 = uVar5;
							pVVar1[3].y = (float)((uint)pVVar1[3].y & 0xfffffffb | 2);
						}
						else {
							if (UINT_005017d4 == 0x18) {
								if (param_6 == 0) {
									UINT_005017d0 = local_4;
									BVar4 = 1;
									UINT_005017d4 = uVar5;
									*param_2 = uVar5;
									pVVar1[3].y = (float)((uint)pVVar1[3].y & 0xfffffffd | 4);
								}
								else {
LAB_0045b7e4:
									BVar4 = 1;
								}
							}
							else {
								if ((local_4 != UINT_005017d0) || (uVar5 != UINT_005017d4)) goto LAB_0045b7e4;
								BVar4 = 1;
								*param_2 = uVar5;
								pVVar1[3].y = (float)((uint)pVVar1[3].y & 0xfffffffd | 4);
							}
						}
					}
					else {
LAB_0045b7eb:
						fVar6 = pVVar1[3].y;
						pVVar1[3].y = (float)((uint)fVar6 & 0xfffffffd);
						if (((uint)fVar6 & 8) == 0) {
							fVar6 = (float)((uint)fVar6 & 0xfffffff9);
						}
						else {
							fVar6 = (float)((uint)fVar6 & 0xfffffffd | 4);
						}
						pVVar1[3].y = fVar6;
					}
					uVar5 = uVar5 + 1;
				} while (uVar5 < (uint)PanelData_ARRAY_00501110[local_4].field_28);
			}
		}
		local_4 = local_4 + 1;
		if (0xb < local_4) {
			if (param_5 == 0) {
				UINT_005017d0 = 0xc;
				UINT_005017d4 = 0x18;
			}
			return BVar4;
		}
	} while( true );
}



BOOL __cdecl FUN_0045b850(int param_1,Vector3F *param_2,int param_3,int param_4)
{
	float fVar1;
	float fVar2;
	longlong lVar3;
	longlong lVar4;
	
	lVar3 = __ftol((float10)*(float *)(param_1 + 0x18));
	lVar4 = __ftol((float10)*(float *)(param_1 + 0x1c));
	fVar1 = (float)(param_3 - (int)lVar3);
	if ((((param_2->x <= fVar1) && (fVar2 = (float)(param_4 - (int)lVar4), fVar2 < param_2[1].x)) &&
			(param_2->y <= fVar2)) && (fVar1 < param_2->z)) {
		return 1;
	}
	return 0;
}



void __cdecl lego::unk::Lego_UnsetFlag6_00501860(void)
{
	FLAGS_00501860 = FLAGS_00501860 & 0xfffffff9;
	return;
}



void __cdecl FUN_0045b8e0(undefined4 param_1)
{
	switch(param_1) {
	case 0:
		FUN_0045d7b0(0);
		return;
	case 1:
		FUN_0045d7b0(1);
		return;
	case 2:
		FUN_0045d7b0(2);
		return;
	case 3:
		FUN_0045d7b0(3);
		return;
	case 4:
		FUN_0045d7b0(4);
		return;
	case 5:
		FUN_0045d7b0(5);
		return;
	case 6:
		FUN_0045d7b0(6);
		return;
	case 7:
		FUN_0045d7b0(7);
		return;
	case 8:
		FUN_0045d7b0(8);
		return;
	case 9:
		FUN_0045d730(1);
		return;
	case 10:
		FUN_0045d730(2);
		return;
	case 0xb:
		FUN_0045d730(3);
		return;
	case 0xc:
		FUN_0045d730(4);
		return;
	case 0xd:
		FUN_0045d730(5);
		return;
	case 0xe:
		FUN_0045d730(6);
		return;
	case 0xf:
		FUN_0045d730(7);
		return;
	case 0x10:
		FUN_0045d730(8);
	}
	return;
}



void __cdecl lego::main::Main_LoadInterfaceButtons_ScrollInfo__internal(void)
{
	Rect2F rect;
	
	unk::Lego_LoadScrollInfoPanel__00463970("Interface\\InfoPanel\\scrollInfo.bmp",0,0,7,0);
	FUN_004639f0(0,8,0x21);
	rect.x = 0.0;
	rect.y = 0.0;
	rect.width = 18.0;
	rect.height = 11.0;
	FUN_00463a30(0,1,&rect,(char *)0x0,(char *)0x0);
	rect.x = 0.0;
	rect.y = 11.0;
	rect.width = 18.0;
	rect.height = 11.0;
	FUN_00463a30(0,0,&rect,(char *)0x0,(char *)0x0);
	rect.x = 0.0;
	rect.y = 0.0;
	rect.width = 0.0;
	rect.height = 0.0;
	FUN_00463ad0(0,(float *)&rect,1,0,"Interface\\Buttons\\scrollInfoSld.bmp");
	rect.x = 40.0;
	rect.y = 12.0;
	rect.width = 180.0;
	rect.height = 43.0;
	PTR_005017d8 = (TextWindow **)
								 unk::Lego_CreatureStruct830_Unk_FUN_0045a7c0
													 (7,globals::g_Game.bmpFONT5_HI,&rect,0x100);
	return;
}



void __cdecl lego::front::Panel_InitUnkRenderSurfacePtr_FUN_0045bb10(void)
{
	Rect2F rect;
	
	rect.x = 21.0;
	rect.y = 11.0;
	rect.width = 221.0;
	rect.height = 227.0;
	PTR_005017dc = unk::Lego_CreatureStruct830_Unk_FUN_0045a7c0
													 (0xb,globals::g_Game.bmpFONT5_HI,&rect,0x400);
	return;
}



BOOL __cdecl FUN_0045bb60(int param_1,int param_2,int param_3,int param_4,int param_5)
{
	float fVar1;
	
	fVar1 = SQRT((float)(param_4 - param_2) * (float)(param_4 - param_2) +
							 (float)(param_3 - param_1) * (float)(param_3 - param_1));
	if ((ushort)((ushort)((float)param_5 < fVar1) << 8 | (ushort)((float)param_5 == fVar1) << 0xe) ==
			0) {
		return 1;
	}
	return 0;
}



void __cdecl lego::math::Math_XY_Div_Radius(int x,int y,int radius,float *out_x,float *out_y)
{
	*out_x = (float)x / (float)radius;
	*out_y = (float)y / (float)radius;
	return;
}



void __cdecl
lego::front::Panel_GetMouseXY_FUN_0045bbf0
					(int *out_mouseX,int *out_mouseY,int param_3,int param_4,int param_5)
{
	float fVar1;
	float10 extraout_ST0;
	float10 extraout_ST1;
	longlong lVar2;
	
	fVar1 = (float)((float10)*out_mouseX - (float10)param_3);
	lVar2 = __ftol(((float10)1.0 /
								 SQRT(((float10)*out_mouseY - (float10)param_4) *
											(float10)(float)((float10)*out_mouseY - (float10)param_4) +
											((float10)*out_mouseX - (float10)param_3) * (float10)fVar1)) * (float10)fVar1
								 * (float10)((float)param_5 - 1.0) + (float10)param_3);
	*out_mouseX = (int)lVar2;
	lVar2 = __ftol(extraout_ST0 + extraout_ST1);
	*out_mouseY = (int)lVar2;
	return;
}



void __cdecl lego::main::Main_LoadPanelRotationControl(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	float10 fVar2;
	char *local_28;
	char *local_24;
	char *local_20;
	
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"PanelRotationControl","CenterPositionX",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == (char *)0x0) {
		globals::g_PanelRotationControl_CenterPosition.x = 1;
	}
	else {
		globals::g_PanelRotationControl_CenterPosition.x = std::atoi(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"PanelRotationControl","CenterPositionY",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == (char *)0x0) {
		globals::g_PanelRotationControl_CenterPosition.y = 1;
	}
	else {
		globals::g_PanelRotationControl_CenterPosition.y = std::atoi(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"PanelRotationControl","Radius",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == (char *)0x0) {
		globals::g_PanelRotationControl_Radius = 1;
	}
	else {
		globals::g_PanelRotationControl_Radius = std::atoi(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"PanelRotationControl","LeftImage",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 == (char *)0x0) {
		globals::g_PanelRotationControl_LeftImage_bmp = (ImageBMP *)0x0;
	}
	else {
		util::Util_Tokenise(pcVar1,&local_28,",");
		globals::g_PanelRotationControl_LeftImage_bmp = image::Image_LoadBMPScaled(local_28,0,0);
		image::Image_SetPenZeroTrans(globals::g_PanelRotationControl_LeftImage_bmp);
		fVar2 = std::atof(local_24);
		g_PanelRotationControl_LeftImage_position.x = (float)fVar2;
		fVar2 = std::atof(local_20);
		g_PanelRotationControl_LeftImage_position.y = (float)fVar2;
		std::free(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"PanelRotationControl","RightImage",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 == (char *)0x0) {
		globals::g_PanelRotationControl_RightImage_bmp = (ImageBMP *)0x0;
	}
	else {
		util::Util_Tokenise(pcVar1,&local_28,",");
		globals::g_PanelRotationControl_RightImage_bmp = image::Image_LoadBMPScaled(local_28,0,0);
		image::Image_SetPenZeroTrans(globals::g_PanelRotationControl_RightImage_bmp);
		fVar2 = std::atof(local_24);
		g_PanelRotationControl_RightImage_position.x = (float)fVar2;
		fVar2 = std::atof(local_20);
		g_PanelRotationControl_RightImage_position.y = (float)fVar2;
		std::free(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"PanelRotationControl","UpImage",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 == (char *)0x0) {
		globals::g_PanelRotationControl_UpImage_bmp = (ImageBMP *)0x0;
	}
	else {
		util::Util_Tokenise(pcVar1,&local_28,",");
		globals::g_PanelRotationControl_UpImage_bmp = image::Image_LoadBMPScaled(local_28,0,0);
		image::Image_SetPenZeroTrans(globals::g_PanelRotationControl_UpImage_bmp);
		fVar2 = std::atof(local_24);
		g_PanelRotationControl_UpImage_position.x = (float)fVar2;
		fVar2 = std::atof(local_20);
		g_PanelRotationControl_UpImage_position.y = (float)fVar2;
		std::free(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"PanelRotationControl","DownImage",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		util::Util_Tokenise(pcVar1,&local_28,",");
		globals::g_PanelRotationControl_DownImage_bmp = image::Image_LoadBMPScaled(local_28,0,0);
		image::Image_SetPenZeroTrans(globals::g_PanelRotationControl_DownImage_bmp);
		fVar2 = std::atof(local_24);
		g_PanelRotationControl_DownImage_position.x = (float)fVar2;
		fVar2 = std::atof(local_20);
		g_PanelRotationControl_DownImage_position.y = (float)fVar2;
		std::free(pcVar1);
		return;
	}
	globals::g_PanelRotationControl_DownImage_bmp = (ImageBMP *)0x0;
	return;
}



BOOL __cdecl lego::front::Panel_RotationControl_FUN_0045bf90(int param_1,int param_2,float param_3)
{
	float yawAmount;
	BOOL BVar1;
	float local_8;
	float local_4;
	
	BVar1 = FUN_0045bb60(param_1,param_2,globals::g_PanelRotationControl_CenterPosition.x,
											 globals::g_PanelRotationControl_CenterPosition.y,
											 globals::g_PanelRotationControl_Radius);
	if (BVar1 == 0) {
		if ((FLAGS_00501860 & 1) == 0) {
			return 0;
		}
		Panel_GetMouseXY_FUN_0045bbf0
							(&param_1,&param_2,globals::g_PanelRotationControl_CenterPosition.x,
							 globals::g_PanelRotationControl_CenterPosition.y,
							 globals::g_PanelRotationControl_Radius);
		input::Input_SetCursorPos(param_1,param_2);
	}
	else {
		BVar1 = FUN_0045bb60(param_1,param_2,globals::g_PanelRotationControl_CenterPosition.x,
												 globals::g_PanelRotationControl_CenterPosition.y,4);
		if (BVar1 != 0) {
			return 1;
		}
	}
	FLAGS_00501860 = FLAGS_00501860 | 1;
	math::Math_XY_Div_Radius
						(globals::g_PanelRotationControl_CenterPosition.x - param_1,
						 param_2 - globals::g_PanelRotationControl_CenterPosition.y,
						 globals::g_PanelRotationControl_Radius,&local_4,&local_8);
	BVar1 = FUN_0045bb60(param_1,globals::g_PanelRotationControl_CenterPosition.y,
											 globals::g_PanelRotationControl_CenterPosition.x,
											 globals::g_PanelRotationControl_CenterPosition.y,3);
	if (BVar1 == 0) {
		BVar1 = FUN_0045bb60(globals::g_PanelRotationControl_CenterPosition.x,param_2,
												 globals::g_PanelRotationControl_CenterPosition.x,
												 globals::g_PanelRotationControl_CenterPosition.y,3);
		yawAmount = local_4 * param_3 * 0.04;
		if (BVar1 == 0) {
			lego::view::Camera_AddYaw(globals::g_Game.cameraMain,yawAmount);
			lego::view::Camera_AddTilt(globals::g_Game.cameraMain,local_8 * param_3 * 0.04);
			if (0.0 <= local_8) {
				FLAGS_00501860 = FLAGS_00501860 | 0x20;
			}
			else {
				FLAGS_00501860 = FLAGS_00501860 | 0x10;
			}
			if (local_4 < 0.0) {
				FLAGS_00501860 = FLAGS_00501860 | 0x80;
				return 1;
			}
		}
		else {
			lego::view::Camera_AddYaw(globals::g_Game.cameraMain,yawAmount);
			if (local_4 < 0.0) {
				FLAGS_00501860 = FLAGS_00501860 | 0x80;
				return 1;
			}
		}
		FLAGS_00501860 = FLAGS_00501860 | 0x40;
		return 1;
	}
	lego::view::Camera_AddTilt(globals::g_Game.cameraMain,local_8 * param_3 * 0.04);
	if (local_8 < 0.0) {
		FLAGS_00501860 = FLAGS_00501860 | 0x10;
		return 1;
	}
	FLAGS_00501860 = FLAGS_00501860 | 0x20;
	return 1;
}



void __cdecl lego::view::Camera_MoveGame_Cam24_Float90(BOOL doAdd,float amount)
{
	if (doAdd == 0) {
		AddDist(globals::g_Game.cameraMain,amount * -3.0);
		return;
	}
	if (doAdd == 1) {
		AddDist(globals::g_Game.cameraMain,amount * 3.0);
	}
	return;
}



void __cdecl lego::front::Panel_FUN_0045c230(int param_1,int param_2,undefined4 *param_3)
{
	float *pfVar1;
	
	pfVar1 = (float *)(PanelData_ARRAY_00501110[param_1].field_24 + param_2 * 0x2c);
	*param_3 = *(undefined4 *)(PanelData_ARRAY_00501110[param_1].field_24 + param_2 * 0x2c);
	param_3[1] = pfVar1[1];
	param_3[2] = pfVar1[2] - *pfVar1;
	param_3[3] = pfVar1[3] - pfVar1[1];
	return;
}



void __cdecl
lego::main::Main_LoadRightPanelCrystals(char *smallCrystal,char *usedCrystal,char *noSmallCrystal)
{
	globals::g_RightPanel_SmallCrystal_bmp = image::Image_LoadBMPScaled(smallCrystal,0,0);
	if (globals::g_RightPanel_SmallCrystal_bmp != (ImageBMP *)0x0) {
		image::Image_SetupTrans(globals::g_RightPanel_SmallCrystal_bmp,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	globals::g_RightPanel_UsedCrystal_bmp = image::Image_LoadBMPScaled(usedCrystal,0,0);
	if (globals::g_RightPanel_UsedCrystal_bmp != (ImageBMP *)0x0) {
		image::Image_SetupTrans(globals::g_RightPanel_UsedCrystal_bmp,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	globals::g_RightPanel_NoSmallCrystal_bmp = image::Image_LoadBMPScaled(noSmallCrystal,0,0);
	if (globals::g_RightPanel_NoSmallCrystal_bmp != (ImageBMP *)0x0) {
		image::Image_SetupTrans(globals::g_RightPanel_NoSmallCrystal_bmp,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	return;
}



void __cdecl
lego::game::Level_LoadRewardQuotaCrystals(CFGProperty *root,char *keyBasePath,char *levelName)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,levelName,"Reward","Quota","Crystals",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == (char *)0x0) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(keyBasePath,levelName,"Reward","Quota","Crystals",0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	}
	globals::g_RewardsQuotaCrystals = std::atoi(pcVar1);
	if ((26 < globals::g_RewardsQuotaCrystals) || (globals::g_RewardsQuotaCrystals == 0)) {
		globals::g_RewardsQuotaCrystals = 26;
	}
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_0045c390(uint param_1,uint param_2,undefined4 param_3)
{
	undefined4 *puVar1;
	uint uVar2;
	int iVar3;
	uint *puVar4;
	undefined4 *puVar5;
	uint uVar6;
	uint *puVar7;
	uint uVar8;
	uint uVar9;
	ImageBMP *image;
	Point2F local_70;
	uint local_68 [26];
	
	local_68[2] = 0;
	local_68[0] = 0;
	puVar4 = local_68 + 3;
	for (iVar3 = 0x17; iVar3 != 0; iVar3 = iVar3 + -1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	local_68[1] = 0;
	puVar5 = &DAT_00501868;
	do {
		iVar3 = 2;
		puVar1 = puVar5;
		do {
			*puVar1 = puVar1[1];
			puVar1 = puVar1 + 6;
			iVar3 = iVar3 + -1;
		} while (iVar3 != 0);
		puVar5 = puVar5 + 1;
	} while (puVar5 < &DAT_0050187c);
	_DAT_0050187c = param_1;
	local_70.x = (float)(local_68 + 2);
	_DAT_00501894 = param_2;
	uVar6 = 0;
	puVar4 = local_68;
	do {
		uVar8 = 0;
		do {
			uVar9 = *puVar4;
			uVar2 = 0;
			if (uVar9 != 0) {
				puVar7 = (uint *)local_70.x;
				do {
					if (*puVar7 == (&DAT_00501868)[uVar8 + uVar6]) {
						local_68[(uVar2 + uVar6) * 2 + 3] = local_68[(uVar2 + uVar6) * 2 + 3] + 1;
						break;
					}
					uVar2 = uVar2 + 1;
					puVar7 = puVar7 + 2;
				} while (uVar2 < uVar9);
			}
			if (uVar2 == uVar9) {
				local_68[(uVar2 + uVar6) * 2 + 2] = (&DAT_00501868)[uVar8 + uVar6];
				local_68[(uVar2 + uVar6) * 2 + 3] = 1;
				*puVar4 = uVar9 + 1;
			}
			uVar8 = uVar8 + 1;
		} while (uVar8 < 6);
		uVar6 = uVar6 + 6;
		local_70.x = (float)((int)local_70.x + 0x30);
		puVar4 = puVar4 + 1;
		if (0xb < uVar6) {
			uVar6 = 0;
			do {
				uVar8 = local_68[uVar6];
				uVar9 = 0;
				if (uVar8 != 0) {
					puVar7 = local_68;
					puVar4 = local_68 + uVar6 * 0xc + 3;
					do {
						puVar7 = puVar7 + 2;
						uVar2 = *puVar4;
						if (uVar9 < uVar2) {
							uVar9 = uVar2;
							if (uVar6 == 0) {
								param_1 = *puVar7;
							}
							else {
								param_2 = puVar4[-1];
							}
						}
						puVar4 = puVar4 + 2;
						uVar8 = uVar8 - 1;
					} while (uVar8 != 0);
				}
				uVar6 = uVar6 + 1;
			} while (uVar6 < 2);
			FUN_0045a720(5,lego::globals::g_Game.bmpToolTipFont,0x29,0x1d5,1,"%i",param_1);
			if (lego::globals::g_RightPanel_NoSmallCrystal_bmp != (ImageBMP *)0x0) {
				local_70.x = 624.0;
				local_70.y = 429.0;
				for (uVar6 = lego::globals::g_RewardsQuotaCrystals; uVar6 != 0; uVar6 = uVar6 - 1) {
					lego::image::Image_DisplayScaled
										(lego::globals::g_RightPanel_NoSmallCrystal_bmp,(Rect2F *)0x0,&local_70,
										 (Size2F *)0x0);
					local_70.y = local_70.y - 17.0;
				}
			}
			if (lego::globals::g_RightPanel_SmallCrystal_bmp != (ImageBMP *)0x0) {
				uVar6 = 0;
				if (lego::globals::g_RewardsQuotaCrystals < param_1) {
					param_1 = lego::globals::g_RewardsQuotaCrystals;
				}
				if (lego::globals::g_RewardsQuotaCrystals < param_2) {
					param_2 = lego::globals::g_RewardsQuotaCrystals;
				}
				local_70.x = 624.0;
				local_70.y = 429.0;
				image = lego::globals::g_RightPanel_SmallCrystal_bmp;
				uVar8 = param_2;
				if (lego::globals::g_RightPanel_UsedCrystal_bmp != (ImageBMP *)0x0) {
					for (; image = lego::globals::g_RightPanel_UsedCrystal_bmp,
							lego::globals::g_RightPanel_UsedCrystal_bmp = image, uVar8 != 0; uVar8 = uVar8 - 1) {
						lego::image::Image_DisplayScaled
											(lego::globals::g_RightPanel_SmallCrystal_bmp,(Rect2F *)0x0,&local_70,
											 (Size2F *)0x0);
						local_70.y = local_70.y - 17.0;
						uVar6 = param_2;
					}
				}
				if (uVar6 < param_1) {
					iVar3 = param_1 - uVar6;
					do {
						lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,&local_70,(Size2F *)0x0);
						local_70.y = local_70.y - 17.0;
						iVar3 = iVar3 + -1;
					} while (iVar3 != 0);
				}
			}
			return;
		}
	} while( true );
}



void __cdecl
lego::front::AirMeter_Load
					(char *airJuice,uint value85,uint value6,uint meterLength,char *noAir,uint value21,
					uint value0)
{
	globals::g_AirMeter_JuiceImage = image::Image_LoadBMPScaled(airJuice,0,0);
	globals::g_AirMeter_JuiceOffset.x = (float)(ulonglong)value85;
	globals::g_AirMeter_JuiceOffset.y = (float)(ulonglong)value6;
	globals::g_AirMeter_JuiceLength = meterLength;
	globals::g_AirMeter_NoAirImage = image::Image_LoadBMPScaled(noAir,0,0);
	if (globals::g_AirMeter_NoAirImage != (ImageBMP *)0x0) {
		image::Image_SetupTrans(globals::g_AirMeter_NoAirImage,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	globals::g_AirMeter_NoAirOffset.x = (float)(ulonglong)value21;
	globals::g_AirMeter_NoAirOffset.y = (float)(ulonglong)value0;
	return;
}



void __cdecl lego::front::AirMeter_FUN_0045c6b0(PanelType panelType,float param_2)
{
	Point2F local_10;
	Size2F local_8;
	
	if ((globals::g_AirMeter_JuiceImage != (ImageBMP *)0x0) &&
		 ((ushort)((ushort)(param_2 < 0.0) << 8 | (ushort)(param_2 == 0.0) << 0xe) == 0)) {
		local_8.height = (float)globals::g_AirMeter_JuiceImage->height;
		if ((ushort)((ushort)(param_2 < 100.0) << 8 | (ushort)(param_2 == 100.0) << 0xe) == 0) {
			param_2 = (float)&DAT_42c80000;
		}
		local_8.width = (float)(ulonglong)globals::g_AirMeter_JuiceLength * 0.01 * param_2;
		local_10.x = PanelData_ARRAY_00501110[panelType].xyOutIn.x + globals::g_AirMeter_JuiceOffset.x;
		local_10.y = PanelData_ARRAY_00501110[panelType].xyOutIn.y + globals::g_AirMeter_JuiceOffset.y;
		image::Image_DisplayScaled(globals::g_AirMeter_JuiceImage,(Rect2F *)0x0,&local_10,&local_8);
	}
	return;
}



void __cdecl lego::front::AirMeter_SetAirBeat_UnkBool(BOOL state)
{
	globals::g_AirMeter_BeatUnkBool = state;
	return;
}



void __cdecl lego::front::AirMeter_FUN_0045c770(PanelType panelType)
{
	ImageBMP *image;
	int iVar1;
	Point2F local_8;
	
	image = globals::g_AirMeter_NoAirImage;
	if (globals::g_AirMeter_NoAirImage != (ImageBMP *)0x0) {
		local_8.x = PanelData_ARRAY_00501110[panelType].xyOutIn.x + globals::g_AirMeter_NoAirOffset.x;
		local_8.y = PanelData_ARRAY_00501110[panelType].xyOutIn.y + globals::g_AirMeter_NoAirOffset.y;
		if (globals::g_AirMeter_BeatUnkBool != 0) {
			iVar1 = unk::Lego_GetDat_004ded1c();
			if (iVar1 != 0) {
				lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,&local_8,(Size2F *)0x0);
			}
		}
	}
	return;
}



void __cdecl
lego::main::Main_LoadRightPanel_CryOreSidebar(char *sidebar,uint param_2,uint param_3,uint param_4)
{
	PTR_00501810 = image::Image_LoadBMPScaled(sidebar,0,0);
	globals::g_RightPanel_CryOreSideBar_positionORsize.x = (float)(ulonglong)param_2;
	globals::g_RightPanel_CryOreSideBar_positionORsize.y = (float)(ulonglong)param_3;
	UINT_0050181c = param_4;
	return;
}



void __cdecl FUN_0045c840(int param_1,int param_2)
{
	if (param_1 == 0) {
		if (param_2 != 0) {
			do {
				param_2 = param_2 + -1;
				FLOAT_00501820 = (FLOAT_00501820 - 0.05) * 20.0 * 0.05263158;
			} while (param_2 != 0);
		}
	}
	else {
		if (param_2 != 0) {
			do {
				param_2 = param_2 + -1;
				FLOAT_00501820 = FLOAT_00501820 - (1.0 - FLOAT_00501820) * -0.05;
			} while (param_2 != 0);
		}
	}
	if (FLOAT_00501820 < 0.0) {
		FLOAT_00501820 = 0.0;
	}
	return;
}



void __cdecl lego::front::Panel_CryOreSidebar_Draw(void)
{
	Size2F local_10;
	Point2F local_8;
	
	if ((PTR_00501810 != (void *)0x0) &&
		 ((ushort)((ushort)(FLOAT_00501820 < 0.0) << 8 | (ushort)(FLOAT_00501820 == 0.0) << 0xe) == 0))
	{
		local_10.width = (float)*(int *)((int)PTR_00501810 + 4);
		local_8.x = globals::g_RightPanel_CryOreSideBar_positionORsize.x;
		local_10.height = (float)(ulonglong)UINT_0050181c * FLOAT_00501820;
		local_8.y = globals::g_RightPanel_CryOreSideBar_positionORsize.y - local_10.height;
		image::Image_DisplayScaled((ImageBMP *)PTR_00501810,(Rect2F *)0x0,&local_8,&local_10);
	}
	return;
}



BOOL __cdecl
lego::front::Panel_SetCurrentAdvisorFromButton(PanelType panelType,int buttonType,BOOL setFlag2)
{
	BOOL BVar1;
	
	BVar1 = Panel_GetAdvisorTypeFromButton(panelType,buttonType,(AdvisorType *)&buttonType);
	if (BVar1 != 0) {
		Advisor_SetCurrentAdvisor(buttonType,setFlag2);
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::front::Panel_GetAdvisorTypeFromButton
					(PanelType panelType,int buttonType,AdvisorType *out_advisorType)
{
										// max value is used as "invalid"
	*out_advisorType = ADVISOR__COUNT;
	switch(panelType) {
	case PANEL_RADAR:
										// PANELBUTTON_RADAR_TOGGLE (0x0)
		if (buttonType == 0) {
			*out_advisorType = ADVISOR_PANELPOINT_RADARTOGGLE;
			return (uint)(*out_advisorType != ADVISOR__COUNT);
		}
										// PANELBUTTON_RADAR_TAGGEDOBJECTVIEW (0x1)
		if (buttonType == 1) {
			*out_advisorType = ADVISOR_PANELPOINT_RADARTOGGLEOBJECTVIEW;
			return (uint)(*out_advisorType != ADVISOR__COUNT);
		}
										// PANELBUTTON_RADAR_ZOOMIN (0x2)
		if (buttonType == 2) {
			*out_advisorType = ADVISOR_PANELPOINT_RADARZOOMIN;
			return (uint)(*out_advisorType != ADVISOR__COUNT);
		}
										// PANELBUTTON_RADAR_ZOOMOUT (0x3)
		if (buttonType == 3) {
			*out_advisorType = ADVISOR_PANELPOINT_RADARZOOMOUT;
			return (uint)(*out_advisorType != ADVISOR__COUNT);
		}
										// PANELBUTTON_RADAR_MAPVIEW (0x4)
		if (buttonType == 4) {
			*out_advisorType = ADVISOR_PANELPOINT_RADARMAPVIEW;
			return (uint)(*out_advisorType != ADVISOR__COUNT);
		}
		break;
	case PANEL_TOPPANEL:
										// PANELBUTTON_TOPPANEL_OPTIONS (0x0)
		if (buttonType == 0) {
			*out_advisorType = ADVISOR_PANELPOINT_TOPPANELOPTIONS;
			return (uint)(*out_advisorType != ADVISOR__COUNT);
		}
										// PANELBUTTON_TOPPANEL_PRIORITIES (0x1)
		if (buttonType == 1) {
			*out_advisorType = ADVISOR_PANELPOINT_TOPPANELPRIORITIES;
			return (uint)(*out_advisorType != ADVISOR__COUNT);
		}
										// PANELBUTTON_TOPPANEL_CALLTOARMS (0x2)
		if (buttonType == 2) {
			*out_advisorType = ADVISOR_PANELPOINT_TOPPANELCALLTOARMS;
			return (uint)(*out_advisorType != ADVISOR__COUNT);
		}
		break;
	case PANEL_CAMERACONTROL:
		if (buttonType == 0) {
			*out_advisorType = ADVISOR_PANELPOINT_CONTROLZOOMIN;
			return (uint)(*out_advisorType != ADVISOR__COUNT);
		}
		if (buttonType == 1) {
			*out_advisorType = ADVISOR_PANELPOINT_CONTROLZOOMOUT;
		}
		break;
	case PANEL_INFODOCK:
		if (buttonType == 0) {
			*out_advisorType = ADVISOR_PANELPOINT_INFODOCKGOTO;
			return (uint)(*out_advisorType != ADVISOR__COUNT);
		}
		if (buttonType == 1) {
			*out_advisorType = ADVISOR_PANELPOINT_INFODOCKCLOSE;
			return (uint)(*out_advisorType != ADVISOR__COUNT);
		}
	}
	return (uint)(*out_advisorType != ADVISOR__COUNT);
}



void __cdecl lego::main::Main_InitPointers(void)
{
	globals::g_Pointers_TABLE[0] = "Pointer_Standard";
	globals::g_Pointers_TABLE[1] = "Pointer_Blank";
	globals::g_Pointers_TABLE[2] = "Pointer_Selected";
	globals::g_Pointers_TABLE[3] = "Pointer_Drill";
	globals::g_Pointers_TABLE[4] = "Pointer_CantDrill";
	globals::g_Pointers_TABLE[5] = "Pointer_Clear";
	globals::g_Pointers_TABLE[6] = "Pointer_Go";
	globals::g_Pointers_TABLE[7] = "Pointer_CantGo";
	globals::g_Pointers_TABLE[8] = "Pointer_Teleport";
	globals::g_Pointers_TABLE[9] = "Pointer_CantTeleport";
	globals::g_Pointers_TABLE[10] = "Pointer_Reinforce";
	globals::g_Pointers_TABLE[11] = "Pointer_CantReinforce";
	globals::g_Pointers_TABLE[12] = "Pointer_RadarPan";
	globals::g_Pointers_TABLE[13] = "Pointer_TrackObject";
	globals::g_Pointers_TABLE[14] = "Pointer_Help";
	globals::g_Pointers_TABLE[15] = "Pointer_CantHelp";
	globals::g_Pointers_TABLE[16] = "Pointer_PutDown";
	globals::g_Pointers_TABLE[17] = "Pointer_GetIn";
	globals::g_Pointers_TABLE[18] = "Pointer_GetOut";
	globals::g_Pointers_TABLE[19] = "Pointer_TutorialBlockInfo";
	globals::g_Pointers_TABLE[20] = "Pointer_Okay";
	globals::g_Pointers_TABLE[21] = "Pointer_NotOkay";
	globals::g_Pointers_TABLE[22] = "Pointer_CanBuild";
	globals::g_Pointers_TABLE[23] = "Pointer_CannotBuild";
	globals::g_Pointers_TABLE[24] = "Pointer_Dynamite";
	globals::g_Pointers_TABLE[25] = "Pointer_CantDynamite";
	globals::g_Pointers_TABLE[26] = "Pointer_PickUp";
	globals::g_Pointers_TABLE[27] = "Pointer_CantPickUp";
	globals::g_Pointers_TABLE[28] = "Pointer_PickUpOre";
	globals::g_Pointers_TABLE[29] = "Pointer_LegoManCantDig";
	globals::g_Pointers_TABLE[30] = "Pointer_VehicleCantDig";
	globals::g_Pointers_TABLE[31] = "Pointer_LegoManDig";
	globals::g_Pointers_TABLE[32] = "Pointer_VehicleDig";
	globals::g_Pointers_TABLE[33] = "Pointer_LegoManCantPickUp";
	globals::g_Pointers_TABLE[34] = "Pointer_VehicleCantPickUp";
	globals::g_Pointers_TABLE[35] = "Pointer_LegoManPickUp";
	globals::g_Pointers_TABLE[36] = "Pointer_VehiclePickUp";
	globals::g_Pointers_TABLE[37] = "Pointer_LegoManCantGo";
	globals::g_Pointers_TABLE[38] = "Pointer_VehicleCantGo";
	globals::g_Pointers_TABLE[39] = "Pointer_LegoManGo";
	globals::g_Pointers_TABLE[40] = "Pointer_VehicleGo";
	globals::g_Pointers_TABLE[41] = "Pointer_LegoManClear";
	globals::g_Pointers_TABLE[42] = "Pointer_VehicleClear";
	globals::g_Pointers_TABLE[43] = "Pointer_SurfaceType_Immovable";
	globals::g_Pointers_TABLE[44] = "Pointer_SurfaceType_Hard";
	globals::g_Pointers_TABLE[45] = "Pointer_SurfaceType_Medium";
	globals::g_Pointers_TABLE[46] = "Pointer_SurfaceType_Loose";
	globals::g_Pointers_TABLE[47] = "Pointer_SurfaceType_Soil";
	globals::g_Pointers_TABLE[48] = "Pointer_SurfaceType_Lava";
	globals::g_Pointers_TABLE[49] = "Pointer_SurfaceType_Water";
	globals::g_Pointers_TABLE[50] = "Pointer_SurfaceType_OreSeam";
	globals::g_Pointers_TABLE[51] = "Pointer_SurfaceType_Lake";
	globals::g_Pointers_TABLE[52] = "Pointer_SurfaceType_CrystalSeam";
	globals::g_Pointers_TABLE[53] = "Pointer_SurfaceType_RechargeSeam";
	globals::g_Pointers_TABLE[54] = "Pointer_CantZoom";
	globals::g_Pointers_TABLE[55] = "Pointer_Zoom";
	return;
}



// Load all Pointers in the CFG block (prop is the first child in the block)
// 
// USAGE: <PointerType><bmpPath>
// USAGE: <PointerType><flicPath>,<num1>,<num2>

void __cdecl lego::front::Pointer_LoadPointers(CFGProperty *prop)
{
	char cVar1;
	bool bVar2;
	PointerType PVar3;
	BOOL BVar4;
	int iVar;
	ImageBMP *pIVar5;
	char *pointerName;
	char *pcVar6;
	PointerType pointerType;
	char *stringParts [10];
	char local_400 [1024];
	
	if (prop != (CFGProperty *)0x0) {
		do {
			pointerName = prop->key;
			bVar2 = true;
			if (pointerName != (char *)0x0) {
				iVar = -1;
				pcVar6 = pointerName;
				do {
					if (iVar == 0) break;
					iVar = iVar + -1;
					cVar1 = *pcVar6;
					pcVar6 = pcVar6 + 1;
				} while (cVar1 != '\0');
				if ((iVar != -2) && (*pointerName == '!')) {
					if ((globs::mainGlobs.flags & CMD_REDUCEIMAGES) == CMD_NONE) {
						pointerName = pointerName + 1;
					}
					else {
						bVar2 = false;
					}
				}
			}
			if ((bVar2) && (BVar4 = Pointer_GetType(pointerName,&pointerType), BVar4 != 0)) {
				std::sprintf(local_400,"%s",prop->value);
				iVar = util::Util_Tokenise(local_400,stringParts,",");
				PVar3 = pointerType;
				if (iVar == 1) {
					pIVar5 = image::Image_LoadBMPScaled(stringParts[0],0,0);
					globals::g_PointerImages_TABLE[PVar3] = pIVar5;
					globals::g_PointerIsFlics_Table[PVar3] = 0;
				}
				else {
					image::Flic_Setup(stringParts[0],
														(ImageFlic **)(globals::g_PointerImages_TABLE + pointerType),
														FLICMEMORY|FLICLOOPINGON);
					globals::g_PointerIsFlics_Table[pointerType] = 1;
					iVar = std::atoi(stringParts[1]);
					globals::g_PointerFlicPoints_Table[pointerType].x = iVar;
					iVar = std::atoi(stringParts[2]);
					globals::g_PointerFlicPoints_Table[pointerType].y = iVar;
				}
				if (globals::g_PointerIsFlics_Table[pointerType] == 0) {
					image::Image_SetupTrans
										(globals::g_PointerImages_TABLE[pointerType],0.0,0.0,0.0,0.0,0.0,0.0);
				}
			}
			prop = cfg::CFG_NextFlat(prop);
		} while (prop != (CFGProperty *)0x0);
	}
	return;
}



BOOL __cdecl lego::front::Pointer_GetType(char *pointerName,PointerType *out_pointerType)
{
	int iVar1;
	char **ppcVar2;
	PointerType PVar3;
	
	PVar3 = POINTER_STANDARD;
	ppcVar2 = globals::g_Pointers_TABLE;
	do {
		iVar1 = std::_stricmp(*ppcVar2,pointerName);
		if (iVar1 == 0) {
			*out_pointerType = PVar3;
			return 1;
		}
		ppcVar2 = ppcVar2 + 1;
		PVar3 = PVar3 + POINTER_BLANK;
	} while (ppcVar2 < &globals::g_Pointer_UnkFloat);
	return 0;
}



ImageBMP * __cdecl lego::front::Pointers_GetImage(PointerType pointerType)
{
	return globals::g_PointerImages_TABLE[pointerType];
}



void __cdecl lego::front::Pointer_SetType_IfUnkFloatLessThan0(PointerType pointerType)
{
	if ((ushort)((ushort)(globals::g_Pointer_UnkFloat < 0.0) << 8 |
							(ushort)(globals::g_Pointer_UnkFloat == 0.0) << 0xe) != 0) {
		globals::g_PointerType = pointerType;
	}
	return;
}



void __cdecl lego::front::Pointer_SetTypeAndUnkFloat(PointerType pointerType,float unkFloat)
{
	globals::g_PointerType = pointerType;
	globals::g_Pointer_UnkFloat = unkFloat;
	return;
}



PointerType __cdecl lego::front::Pointer_GetCurrentType(void)
{
	return globals::g_PointerType;
}



void __cdecl lego::front::Pointer_DrawPointer(uint param_1,uint param_2)
{
	ImageBMP *image;
	Point2F local_20;
	uint local_18;
	undefined4 uStack20;
	Rect2F local_10;
	
	local_20.x = (float)(ulonglong)param_1;
	local_20.y = (float)(ulonglong)param_2;
	if (globals::g_PointerIsFlics_Table[globals::g_PointerType] != 1) {
										// Draw a BMP image pointer
		image = globals::g_PointerImages_TABLE[globals::g_PointerType];
		if (globals::g_PointerImages_TABLE[globals::g_PointerType] == (ImageBMP *)0x0) {
			image = globals::g_PointerImages_TABLE[0];
		}
		lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,&local_20,(Size2F *)0x0);
		return;
	}
										// Draw a FLIC image pointer
	local_10.x = (float)globals::g_PointerFlicPoints_Table[globals::g_PointerType].x + local_20.x;
	local_10.y = (float)globals::g_PointerFlicPoints_Table[globals::g_PointerType].y + local_20.y;
	local_18 = res::AnimClone_IsLws
											 ((AnimClone *)globals::g_PointerImages_TABLE[globals::g_PointerType]);
	uStack20 = 0;
	local_10.width = (float)(ulonglong)local_18;
	local_18 = lego::image::Flic_GetHeight
											 ((ImageFlic *)globals::g_PointerImages_TABLE[globals::g_PointerType]);
	uStack20 = 0;
	local_10.height = (float)(ulonglong)local_18;
	lego::image::Image_DisplayScaled
						(globals::g_PointerImages_TABLE[1],(Rect2F *)0x0,&local_20,(Size2F *)0x0);
	lego::image::Flic_Animate
						((ImageFlic *)globals::g_PointerImages_TABLE[globals::g_PointerType],&local_10,
						 ~globals::g_Game.flags1 >> 0x14 & 1,1);
	return;
}



void __cdecl lego::front::Pointer_SubUnkFloat_IfGreaterThan0(float value)
{
	if ((ushort)((ushort)(globals::g_Pointer_UnkFloat < 0.0) << 8 |
							(ushort)(globals::g_Pointer_UnkFloat == 0.0) << 0xe) == 0) {
		globals::g_Pointer_UnkFloat = globals::g_Pointer_UnkFloat - value;
	}
	return;
}



void __cdecl lego::main::Main_LoadPriorityImages(CFGProperty *root,char *keyBasePath)
{
	int iVar1;
	char *pcVar2;
	CFGProperty *prop;
	BOOL BVar3;
	int iVar4;
	ImageBMP *pIVar5;
	AIPriorityType local_254;
	char *local_250;
	char *local_24c;
	char *local_248;
	char *local_244;
	char *local_228;
	char *local_224;
	char local_200 [512];
	
	pcVar2 = cfg::CFG_JoinPath(keyBasePath,"PriorityImages",0);
	for (prop = cfg::CFG_GetChildren(root,pcVar2); prop != (CFGProperty *)0x0;
			prop = cfg::CFG_NextFlat(prop)) {
		BVar3 = ai::AIPriority_GetType(prop->key,&local_254);
		if (BVar3 != 0) {
			std::sprintf(local_200,"%s",prop->value);
			util::Util_Tokenise(local_200,&local_250,":");
			iVar4 = util::Util_Tokenise(local_250,&local_228,"|");
			iVar1 = local_254 * 4;
			pcVar2 = std::_strdup(local_228);
			*(char **)(&DAT_00501f00 + iVar1) = pcVar2;
			if (iVar4 == 2) {
				snd::SFX_GetType(local_224,(SFXType *)(&DAT_005020b0 + iVar1));
			}
			pIVar5 = image::Image_LoadBMPScaled(local_24c,0,0);
			*(ImageBMP **)(&DAT_00501f6c + local_254 * 4) = pIVar5;
			pIVar5 = image::Image_LoadBMPScaled(local_248,0,0);
			*(ImageBMP **)(&DAT_00501fd8 + local_254 * 4) = pIVar5;
			pIVar5 = image::Image_LoadBMPScaled(local_244,0,0);
			*(ImageBMP **)(&DAT_00502044 + local_254 * 4) = pIVar5;
		}
	}
	return;
}



void __cdecl FUN_0045d1c0(void)
{
	undefined4 *puVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (lego::globals::g_LevelPriorities_COUNT != 0) {
		puVar1 = lego::globals::g_Priorities_unk_TABLE;
		do {
			puVar1[-0x6c] = puVar1[-0x1b];
			lego::game::Game_SetAITaskValue2(puVar1[-0x1b],*puVar1);
			lego::game::Game_SetIsPriorityDisabled(puVar1[-0x6c],puVar1[0x1b]);
			uVar2 = uVar2 + 1;
			puVar1 = puVar1 + 1;
		} while (uVar2 < lego::globals::g_LevelPriorities_COUNT);
	}
	return;
}



BOOL __cdecl lego::game::Level_LoadPriorities(CFGProperty *root,char *keyBasePath,char *keyName)
{
	char *keyPath;
	CFGProperty *prop;
	BOOL BVar1;
	BOOL3 BVar2;
	
	globals::g_LevelPriorities_COUNT = 0;
	keyPath = cfg::CFG_JoinPath(keyBasePath,keyName,"Priorities",0);
	for (prop = cfg::CFG_GetChildren(root,keyPath); prop != (CFGProperty *)0x0;
			prop = cfg::CFG_NextFlat(prop)) {
		BVar1 = ai::AIPriority_GetType(prop->key,(AIPriorityType *)&keyName);
		if (BVar1 != 0) {
			globals::g_PriorityNames_a_TABLE[globals::g_LevelPriorities_COUNT] = keyName;
			globals::g_PriorityNames_b_TABLE[globals::g_LevelPriorities_COUNT] = keyName;
			globals::g_Priorities_unk_TABLE[globals::g_LevelPriorities_COUNT] =
					 globals::g_LevelPriorities_COUNT * -5 + 0x50;
			Game_SetAITaskValue2
								((int)keyName,globals::g_Priorities_unk_TABLE[globals::g_LevelPriorities_COUNT]);
			BVar2 = util::Util_GetBoolFromString(prop->value);
			if (BVar2 == BOOL3_TRUE) {
				Game_SetIsPriorityDisabled((int)keyName,0);
				globals::g_Priorities_bool1_TABLE[globals::g_LevelPriorities_COUNT] = 0;
			}
			else {
				Game_SetIsPriorityDisabled((int)keyName,1);
				globals::g_Priorities_bool1_TABLE[globals::g_LevelPriorities_COUNT] = 1;
			}
			globals::g_LevelPriorities_COUNT = globals::g_LevelPriorities_COUNT + 1;
		}
	}
	return 1;
}



void __cdecl lego::main::Main_LoadPrioritiesImagePositions(CFGProperty *root,char *keyBasePath)
{
	char *keyPath1;
	char *pcVar1;
	int iVar2;
	int value;
	char **ppcVar3;
	char *local_40;
	char *local_3c;
	
	keyPath1 = keyBasePath;
	value = 0;
	ppcVar3 = (char **)&globals::g_PrioritiesImagePositions_TABLE[0].y;
	do {
		value = value + 1;
		std::itoa(value,(char *)&keyBasePath,10);
		pcVar1 = cfg::CFG_JoinPath(keyPath1,"PrioritiesImagePositions",&keyBasePath,0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		if (pcVar1 != (char *)0x0) {
			util::Util_Tokenise(pcVar1,&local_40,",");
			iVar2 = std::atoi(local_40);
			ppcVar3[-1] = (char *)(float)iVar2;
			iVar2 = std::atoi(local_3c);
			*ppcVar3 = (char *)(float)iVar2;
		}
		ppcVar3 = ppcVar3 + 2;
	} while (ppcVar3 < globals::g_PriorityNames_b_TABLE + 1);
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOL __cdecl FUN_0045d3d0(uint param_1,uint param_2,int param_3,int param_4,int param_5)
{
	char *pcVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	float fVar5;
	BOOL BVar6;
	float *pfVar7;
	char **ppcVar8;
	uint uVar9;
	Point2F local_30;
	float local_28;
	float local_24;
	uint local_20;
	undefined4 uStack28;
	uint local_18;
	undefined4 uStack20;
	uint local_10;
	undefined4 uStack12;
	uint local_8;
	undefined4 uStack4;
	
	BVar6 = FUN_0045adf0(8);
	if ((BVar6 == 0) && (BVar6 = FUN_0045ae50(8), BVar6 == 0)) {
		lego::front::Panel_GetXYField3(PANEL_PRIORITYLIST,&local_28,&local_24);
		uVar9 = 0;
		if (lego::globals::g_LevelPriorities_COUNT != 0) {
			pfVar7 = &lego::globals::g_PrioritiesImagePositions_TABLE[0].y;
			ppcVar8 = lego::globals::g_PriorityNames_a_TABLE;
			do {
				pcVar1 = *ppcVar8;
				iVar2 = *(int *)(&DAT_00501f6c + (int)pcVar1 * 4);
				if (iVar2 != 0) {
					uStack28 = 0;
					local_30.x = pfVar7[-1] + local_28;
					local_20 = param_1;
					uVar3 = *(uint *)(iVar2 + 8);
					fVar5 = (float)(ulonglong)param_1;
					uVar4 = *(uint *)(iVar2 + 4);
					local_30.y = local_24 + *pfVar7;
					if ((local_30.x <= fVar5) &&
						 (uStack20 = 0, local_18 = uVar4,
						 (ushort)((ushort)(fVar5 < (float)(ulonglong)uVar4 + local_30.x) << 8 |
										 (ushort)(fVar5 == (float)(ulonglong)uVar4 + local_30.x) << 0xe) != 0)) {
						uStack12 = 0;
						local_10 = param_2;
						fVar5 = (float)(ulonglong)param_2;
						if ((local_30.y <= fVar5) &&
							 (uStack4 = 0, local_8 = uVar3,
							 (ushort)((ushort)(fVar5 < (float)(ulonglong)uVar3 + local_30.y) << 8 |
											 (ushort)(fVar5 == (float)(ulonglong)uVar3 + local_30.y) << 0xe) != 0)) {
							DAT_005023bc = DAT_005023bc | 1;
							FUN_0045d630(&local_30,uVar4 - 1,uVar3 - 1);
							if (param_3 == 0) {
								if ((_DAT_004a9ee8 == uVar9) && (_DAT_004a9eec == pcVar1)) {
									lego::front::ToolTip_Load_HasNLEscape
														(7,*(char **)(&DAT_00501f00 + (int)pcVar1 * 4));
									lego::front::ToolTip_AddFlag4(7);
									lego::unk::Lego_SetDat_004df1f4(*(undefined4 *)(&DAT_005020b0 + (int)pcVar1 * 4));
								}
								else {
									lego::front::ToolTip_AddFlag4(0);
									_DAT_004a9ee8 = uVar9;
									_DAT_004a9eec = pcVar1;
								}
							}
							BVar6 = FUN_0045d5c0(uVar9,param_3,param_4);
							if ((BVar6 != 0) && (param_5 != 0)) {
								FUN_0045d680(uVar9);
							}
							return 1;
						}
					}
				}
				uVar9 = uVar9 + 1;
				ppcVar8 = ppcVar8 + 1;
				pfVar7 = pfVar7 + 2;
			} while (uVar9 < lego::globals::g_LevelPriorities_COUNT);
		}
		FUN_0045d5c0(0x1b,param_3,param_4);
	}
	return 0;
}



BOOL __cdecl FUN_0045d5c0(int param_1,int param_2,int param_3)
{
	int iVar1;
	
	iVar1 = DAT_005023b8;
	if (param_2 == 0) {
		DAT_005023b8 = 0x1b;
	}
	else {
		if (DAT_005023b8 == 0x1b) {
			if (param_3 == 0) {
				DAT_005023b8 = param_1;
				DAT_005023bc = DAT_005023bc | 2;
				return (uint)(param_1 == 0x1b);
			}
		}
		else {
			if (DAT_005023b8 == param_1) {
				DAT_005023bc = DAT_005023bc | 2;
				return (uint)(DAT_005023b8 == param_1);
			}
		}
	}
	return (uint)(iVar1 == param_1);
}



void __cdecl FUN_0045d630(Point2F *param_1,uint param_2,uint param_3)
{
	FLOAT_005023a8 = param_1->x;
	FLOAT_005023ac = param_1->y;
	FLOAT_005023b0 = (float)(ulonglong)param_2;
	FLOAT_005023b4 = (float)(ulonglong)param_3;
	return;
}



void __cdecl FUN_0045d680(uint param_1)
{
	if (((byte)FLAGS_00501860 & 2) != 0) {
		FUN_0045d6b0(param_1);
		return;
	}
	if (((byte)FLAGS_00501860 & 4) != 0) {
		FUN_0045d730(param_1);
	}
	return;
}



void __cdecl FUN_0045d6b0(uint param_1)
{
	char *index;
	char *index_00;
	uint uVar1;
	int iVar2;
	int iVar3;
	
	if ((param_1 != 0) && (param_1 < lego::globals::g_LevelPriorities_COUNT)) {
		index = lego::globals::g_PriorityNames_a_TABLE[param_1];
		iVar3 = 0;
		if (param_1 != 0) {
			iVar2 = 0x50;
			uVar1 = param_1;
			do {
				index_00 = *(char **)(&DAT_00502118 + uVar1 * 4);
				lego::globals::g_PriorityNames_a_TABLE[uVar1] = index_00;
				lego::game::Game_SetAITaskValue2((int)index_00,iVar2 + param_1 * -5);
				iVar3 = iVar3 + 1;
				iVar2 = iVar2 + 5;
				uVar1 = param_1 - iVar3;
			} while (uVar1 != 0);
		}
		lego::globals::g_PriorityNames_a_TABLE[0] = index;
		lego::game::Game_SetAITaskValue2((int)index,0x50);
	}
	lego::snd::Audio_FUN_00428730(3);
	return;
}



void __cdecl FUN_0045d730(uint param_1)
{
	char *pcVar1;
	
	if ((param_1 != 0) && (param_1 < lego::globals::g_LevelPriorities_COUNT)) {
		pcVar1 = lego::globals::g_PriorityNames_a_TABLE[param_1];
		lego::globals::g_PriorityNames_a_TABLE[param_1] = *(char **)(&DAT_00502118 + param_1 * 4);
		*(char **)(&DAT_00502118 + param_1 * 4) = pcVar1;
		lego::game::Game_SetAITaskValue2
							((int)lego::globals::g_PriorityNames_a_TABLE[param_1],param_1 * -5 + 0x50);
		lego::game::Game_SetAITaskValue2(*(int *)(&DAT_00502118 + param_1 * 4),param_1 * -5 + 0x55);
		FUN_0045d810(param_1 - 1);
	}
	lego::snd::Audio_FUN_00428730(0);
	return;
}



void __cdecl FUN_0045d7b0(uint param_1)
{
	BOOL BVar1;
	
	if (param_1 < lego::globals::g_LevelPriorities_COUNT) {
		BVar1 = lego::game::Game_IsPriorityDisabled
											((int)lego::globals::g_PriorityNames_a_TABLE[param_1]);
		lego::game::Game_SetIsPriorityDisabled
							((int)lego::globals::g_PriorityNames_a_TABLE[param_1],(uint)(BVar1 == 0));
		if (((BVar1 == 0) != 0) &&
			 ((lego::globals::g_PriorityNames_a_TABLE[param_1] == (char *)0x0 ||
				(lego::globals::g_PriorityNames_a_TABLE[param_1] == (char *)0x1)))) {
			lego::front::Text_DisplayMessage(TEXT_CRYSTALOREDISABLED,1,0);
		}
	}
	return;
}



void __cdecl FUN_0045d810(undefined4 param_1)
{
	int iVar1;
	longlong lVar2;
	float local_18;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	switch(param_1) {
	case 0:
		FUN_0045d900(0);
		return;
	case 1:
		iVar1 = 9;
		break;
	case 2:
		iVar1 = 10;
		break;
	case 3:
		iVar1 = 0xb;
		break;
	case 4:
		iVar1 = 0xc;
		break;
	case 5:
		iVar1 = 0xd;
		break;
	case 6:
		iVar1 = 0xe;
		break;
	case 7:
		iVar1 = 0xf;
		break;
	case 8:
		iVar1 = 0x10;
		break;
	default:
		goto switchD_0045d821_caseD_9;
	}
	lego::front::Panel_GetXYField3(PANEL_PRIORITYLIST,&local_18,&local_14);
	lego::front::Panel_FUN_0045c230(8,iVar1,&local_10);
	lVar2 = __ftol((float10)local_4 * (float10)0.5 + (float10)local_c + (float10)local_14);
	iVar1 = (int)lVar2;
	lVar2 = __ftol((float10)local_8 * (float10)0.5 + (float10)local_10 + (float10)local_18);
	lego::input::Input_SetCursorPos((int)lVar2,iVar1);
switchD_0045d821_caseD_9:
	return;
}



void __cdecl FUN_0045d900(int priorityIndex)
{
	char *pcVar1;
	int iVar2;
	int y;
	longlong lVar3;
	float local_10;
	float local_c;
	uint local_8;
	undefined4 local_4;
	
	pcVar1 = lego::globals::g_PriorityNames_a_TABLE[priorityIndex];
	if (*(int *)(&DAT_00501f6c + (int)pcVar1 * 4) != 0) {
		lego::front::Panel_GetXYField3(PANEL_PRIORITYLIST,&local_10,&local_c);
		iVar2 = *(int *)(&DAT_00501f6c + (int)pcVar1 * 4);
		local_4 = 0;
		local_8 = *(uint *)(iVar2 + 8) >> 1;
		lVar3 = __ftol((float10)lego::globals::g_PrioritiesImagePositions_TABLE[priorityIndex].y +
									 (float10)local_c + (float10)local_8);
		y = (int)lVar3;
		local_8 = *(uint *)(iVar2 + 4) >> 1;
		local_4 = 0;
		lVar3 = __ftol((float10)lego::globals::g_PrioritiesImagePositions_TABLE[priorityIndex].x +
									 (float10)local_10 + (float10)local_8);
		lego::input::Input_SetCursorPos((int)lVar3,y);
	}
	return;
}



void __cdecl FUN_0045d990(void)
{
	char *priorityIndex;
	ImageBMP *image;
	BOOL BVar1;
	uint uVar2;
	char **ppcVar3;
	float *pfVar4;
	Point2F local_10;
	float local_8;
	float local_4;
	
	BVar1 = FUN_0045adf0(8);
	if (BVar1 == 0) {
		lego::front::Panel_GetXYField3(PANEL_PRIORITYLIST,&local_8,&local_4);
		uVar2 = 0;
		if (lego::globals::g_LevelPriorities_COUNT != 0) {
			pfVar4 = &lego::globals::g_PrioritiesImagePositions_TABLE[0].y;
			ppcVar3 = lego::globals::g_PriorityNames_a_TABLE;
			do {
				local_10.x = pfVar4[-1] + local_8;
				local_10.y = local_4 + *pfVar4;
				priorityIndex = *ppcVar3;
				BVar1 = lego::game::Game_IsPriorityDisabled((int)priorityIndex);
				if (BVar1 == 0) {
					if (((DAT_005023bc & 2) == 0) || (DAT_005023b8 != uVar2)) {
						image = *(ImageBMP **)(&DAT_00501f6c + (int)priorityIndex * 4);
					}
					else {
						image = *(ImageBMP **)(&DAT_00501fd8 + (int)priorityIndex * 4);
					}
				}
				else {
					image = *(ImageBMP **)(&DAT_00502044 + (int)priorityIndex * 4);
				}
				if (image != (ImageBMP *)0x0) {
					lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,&local_10,(Size2F *)0x0);
				}
				uVar2 = uVar2 + 1;
				ppcVar3 = ppcVar3 + 1;
				pfVar4 = pfVar4 + 2;
			} while (uVar2 < lego::globals::g_LevelPriorities_COUNT);
		}
		if ((DAT_005023bc & 1) != 0) {
			FUN_0041cc60((Rect2F *)&FLOAT_005023a8);
			DAT_005023bc = DAT_005023bc & 0xfffffffe;
		}
		DAT_005023bc = DAT_005023bc & 0xfffffffd;
	}
	return;
}



BOOL __cdecl lego::main::Main_loadPTLCFG__0045daa0(char *filename,char *keyBlockPath)
{
	uint uVar1;
	CFGProperty *prop;
	CFGProperty *prop_00;
	MessageType MVar2;
	
	globals::g_LEVEL_PTLEVENTS_COUNT = 0;
	prop = cfg::CFG_Open(filename);
	if (prop != (CFGProperty *)0x0) {
		prop_00 = cfg::CFG_GetChildren(prop,keyBlockPath);
		uVar1 = globals::g_LEVEL_PTLEVENTS_COUNT;
		while (prop_00 != (CFGProperty *)0x0) {
			globals::g_LEVEL_PTLEVENTS_COUNT = uVar1 + 1;
			MVar2 = game::Game_LookupPTLEventIndex(prop_00->key);
			globals::g_LEVEL_PTLEVENTS_TABLE[uVar1].eventIndex = MVar2;
			MVar2 = game::Game_LookupPTLEventIndex(prop_00->value);
			globals::g_LEVEL_PTLEVENTS_TABLE[uVar1].actionIndex = MVar2;
			prop_00 = cfg::CFG_NextFlat(prop_00);
			uVar1 = globals::g_LEVEL_PTLEVENTS_COUNT;
		}
		globals::g_LEVEL_PTLEVENTS_COUNT = uVar1;
		cfg::CFG_Close(prop);
		return 1;
	}
	return 0;
}



void __cdecl lego::game::Game_PTLEventToAction__0045db30(MessageAction *out_message)
{
	uint uVar1;
	PTLProperty *pPVar2;
	
	uVar1 = 0;
	if (globals::g_LEVEL_PTLEVENTS_COUNT != 0) {
		pPVar2 = globals::g_LEVEL_PTLEVENTS_TABLE;
		while (out_message->event != pPVar2->eventIndex) {
			uVar1 = uVar1 + 1;
			pPVar2 = pPVar2 + 1;
			if (globals::g_LEVEL_PTLEVENTS_COUNT <= uVar1) {
				return;
			}
		}
		out_message->event = pPVar2->actionIndex;
	}
	return;
}



void __cdecl lego::game::LevelStruct3C_SetFloat14(LevelStruct_3c *param_1,float param_2)
{
	param_1->float_14 = param_2;
	return;
}



void __cdecl lego::main::Main_InitUnkVectorTables(void)
{
	Vector3F *pVVar1;
	Vector3F *pVVar2;
	float *pfVar3;
	int iVar4;
	int iVar5;
	uint uVar6;
	float *pfVar7;
	
	pVVar1 = globals::g_UnkVector3F_30_TABLE;
	do {
		iVar5 = 3;
		pVVar2 = pVVar1;
		do {
			pVVar1 = (Vector3F *)&pVVar2->y;
			iVar5 = iVar5 + -1;
			pVVar2->x = pVVar2->x * 0.003921569;
			pVVar2 = pVVar1;
		} while (iVar5 != 0);
	} while (pVVar1 < &globals::g_UnkStructF_a_INT);
	pfVar3 = &globals::g_UnkStructF10_a_TABLE[0].float_c;
	do {
		pfVar3[0x50] = 1.0;
		*pfVar3 = 1.0;
		pfVar3 = pfVar3 + 4;
	} while (pfVar3 < &globals::g_UnkStructF10_b_TABLE[0].float_c);
	globals::g_UnkStructF10_a_TABLE[0].float_0 = 320.0;
	globals::g_UnkStructF10_a_TABLE[0].float_4 = 40.0;
	globals::g_UnkStructF10_b_TABLE[0].float_0 = 420.0;
	globals::g_UnkStructF10_b_TABLE[0].float_4 = 180.0;
	globals::g_UnkStructF10_a_TABLE[1].float_0 = 420.0;
	globals::g_UnkStructF10_a_TABLE[1].float_4 = 180.0;
	globals::g_UnkStructF10_b_TABLE[1].float_0 = 360.0;
	globals::g_UnkStructF10_b_TABLE[1].float_4 = 180.0;
	globals::g_UnkStructF10_a_TABLE[2].float_0 = 360.0;
	globals::g_UnkStructF10_a_TABLE[2].float_4 = 180.0;
	globals::g_UnkStructF10_b_TABLE[2].float_0 = 360.0;
	globals::g_UnkStructF10_b_TABLE[2].float_4 = 400.0;
	globals::g_UnkStructF10_a_TABLE[3].float_0 = 360.0;
	globals::g_UnkStructF10_a_TABLE[3].float_4 = 400.0;
	globals::g_UnkStructF10_b_TABLE[3].float_0 = 280.0;
	globals::g_UnkStructF10_b_TABLE[3].float_4 = 400.0;
	globals::g_UnkStructF10_a_TABLE[4].float_0 = 280.0;
	globals::g_UnkStructF10_a_TABLE[4].float_4 = 400.0;
	globals::g_UnkStructF10_b_TABLE[4].float_0 = 280.0;
	globals::g_UnkStructF10_b_TABLE[4].float_4 = 180.0;
	globals::g_UnkStructF10_a_TABLE[5].float_0 = 280.0;
	globals::g_UnkStructF10_a_TABLE[5].float_4 = 180.0;
	globals::g_UnkStructF10_b_TABLE[5].float_0 = 220.0;
	globals::g_UnkStructF10_b_TABLE[5].float_4 = 180.0;
	globals::g_UnkStructF10_a_TABLE[6].float_0 = 220.0;
	globals::g_UnkStructF10_a_TABLE[6].float_4 = 180.0;
	globals::g_UnkStructF10_b_TABLE[6].float_0 = 320.0;
	globals::g_UnkStructF10_b_TABLE[6].float_4 = 40.0;
	globals::g_UnkStructF10_a_COUNT = 7;
	uVar6 = 0;
	pfVar3 = &globals::g_UnkStructF10_a_TABLE[0].float_4;
	do {
		iVar5 = 2;
		pfVar7 = pfVar3;
		do {
			iVar4 = GetResolutionWidth();
			pfVar7[-1] = (float)iVar4 * 0.0015625 * pfVar7[-1];
			iVar4 = GetResolutionHeight();
			iVar5 = iVar5 + -1;
			*pfVar7 = (float)iVar4 * 0.002083333 * *pfVar7;
			pfVar7 = pfVar7 + 0x50;
		} while (iVar5 != 0);
		uVar6 = uVar6 + 1;
		pfVar3 = pfVar3 + 4;
	} while (uVar6 < globals::g_UnkStructF10_a_COUNT);
	globals::g_UnkStructF_a_INT = -1;
	globals::g_UnkStructF_b_INT = -1;
	return;
}



LevelStruct_3c * __cdecl
lego::game::SurfaceMap_AllocLevelStruct3C__0045dd50
					(SurfaceMap *surfMap,Rect2F *param_2,float param_3)
{
	float fVar1;
	LevelStruct_3c *pLVar2;
	float10 fVar3;
	
	pLVar2 = (LevelStruct_3c *)std::malloc(0x3c);
	if (pLVar2 != (LevelStruct_3c *)0x0) {
		(pLVar2->rectf_4).x = param_2->x;
		(pLVar2->rectf_4).y = param_2->y;
		(pLVar2->rectf_4).width = param_2->width;
		fVar1 = param_2->height;
		pLVar2->float_14 = param_3;
		(pLVar2->rectf_4).height = fVar1;
		fVar3 = SurfaceMap_GetBlockSize(surfMap);
		pLVar2->float_18 = (float)fVar3;
		pLVar2->surfMap = surfMap;
		return pLVar2;
	}
	return (LevelStruct_3c *)0x0;
}



// Multiple-use function to free data

void __cdecl lego::game::LevelStruct3C_Free_Unwind(LevelStruct_3c *param_1)
{
	std::free(param_1);
	return;
}



void __cdecl
lego::game::LevelStruct3C_FUN_0045ddc0
					(LevelStruct_3c *param_1,Point2F *param_2,float param_3,float param_4)
{
	float b;
	longlong lVar1;
	Rect2F local_20;
	Rect2F local_10;
	
	local_20.height = 0.0;
	local_20.x = param_2->x;
	local_20.y = param_2->y;
	local_20.width = param_3;
	draw::Draw_GetClipWindow(&local_10);
	draw::Draw_SetClipWindow(&param_1->rectf_4);
	LevelStruct3C_FUN_0045ec00(param_1,&local_20);
	b = param_4 * 0.7 - -0.3;
	lVar1 = __ftol((float10)local_20.width);
	draw::Draw_DotCircle
						((Point2F *)&local_20,(uint)lVar1,(uint)lVar1 * 2,b * 0.7,b * 0.9,b,DrawEffect_None);
	draw::Draw_SetClipWindow(&local_10);
	return;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

void __cdecl lego::game::LevelStruct3C_FUN_0045de80(LevelStruct_3c *param_1,Point2F *param_2)
{
	float fVar1;
	float fVar2;
	BOOL BVar3;
	int iVar4;
	uint uVar5;
	SurfaceMap *pSVar6;
	uint uVar7;
	float *pfVar8;
	Point2F *pPVar9;
	uint uVar10;
	Vector4F *transform4d;
	undefined4 *puVar11;
	float *pfVar12;
	float *pfVar13;
	Point2F *pPVar14;
	Vector3F *pVVar15;
	float *pfVar16;
	uint uStack46860;
	uint uStack46856;
	uint uStack46852;
	uint uStack46848;
	float *pfStack46844;
	Vector3F VStack46840;
	uint uStack46828;
	uint uStack46824;
	int iStack46820;
	int iStack46816;
	Rect2F RStack46812;
	Vector3F VStack46796;
	Vector3F VStack46784;
	Vector3F VStack46772;
	Vector4F VStack46760;
	float fStack46744;
	undefined4 uStack46740;
	undefined4 uStack46736;
	undefined4 uStack46732;
	float fStack46728;
	float fStack46724;
	undefined4 uStack46720;
	undefined4 uStack46716;
	undefined4 uStack46712;
	float fStack46708;
	undefined4 uStack46704;
	undefined4 uStack46700;
	undefined4 uStack46696;
	undefined4 uStack46692;
	undefined4 uStack46688;
	undefined4 uStack46684;
	float fStack46680;
	undefined4 uStack46676;
	undefined4 uStack46672;
	undefined4 uStack46668;
	float fStack46664;
	float fStack46660;
	undefined4 uStack46656;
	undefined4 uStack46652;
	undefined4 uStack46648;
	float fStack46644;
	undefined4 uStack46640;
	undefined4 uStack46636;
	Point2F PStack46632;
	Point2F aPStack46624 [3];
	float fStack46600;
	float fStack46596;
	Rect2F RStack46592;
	Vector3F aVStack46576 [8];
	Point2F aPStack46480 [20];
	Point2F aPStack46320 [20];
	float afStack46156 [59];
	Vector3F aVStack45920 [60];
	Point2F aPStack45200 [200];
	Point2F aPStack43600 [200];
	Draw_Rect aDStack42000 [1499];
	undefined4 uStack4;
	
	uStack4 = 0x45de8a;
	fVar1 = (param_1->rectf_4).width;
	param_1->float_1c = param_2->x;
	param_1->float_20 = param_2->y;
	uVar10 = 0;
	uVar7 = 0;
	uStack46856 = 0;
	uStack46860 = 0;
	uStack46824 = 0;
	uStack46828 = 0;
	VStack46840.x = ((fVar1 * 0.5) / param_1->float_14) * param_1->float_18;
	VStack46840.y = (((param_1->rectf_4).height * 0.5) / param_1->float_14) * param_1->float_18;
	SurfaceMap_FUN_0044fad0
						(param_1->surfMap,param_2->x - VStack46840.x,VStack46840.y + param_2->y,
						 (int *)&uStack46828,(int *)&uStack46824);
	SurfaceMap_FUN_0044fad0
						(param_1->surfMap,param_2->x + VStack46840.x,param_2->y - VStack46840.y,&iStack46820,
						 &iStack46816);
	draw::Draw_GetClipWindow(&RStack46592);
	draw::Draw_SetClipWindow(&param_1->rectf_4);
	uStack46852 = uStack46824;
	uStack46848 = uStack46828;
	iVar4 = iStack46820;
	if ((int)uStack46824 <= iStack46816) {
		do {
			uVar5 = uStack46848;
			if ((int)uStack46848 <= iVar4) {
				pfStack46844 = &aPStack45200[uVar7].y;
				pPVar9 = aPStack45200 + uVar7;
				pfVar8 = &aPStack43600[uVar7].y;
				pPVar14 = aPStack43600 + uVar7;
				pfVar13 = &aDStack42000[uVar10].rect.width;
				do {
					BVar3 = FUN_0045eca0((int)(pfVar13 + -2),uStack46848,uStack46852);
					if (BVar3 != 0) {
						iVar4 = unk::Lego_GetDat_004ded1c();
						if (((iVar4 != 0) && (uStack46848 == globals::g_UnkStructF_a_INT)) &&
							 (uStack46852 == globals::g_UnkStructF_b_INT)) {
							pfVar13[2] = 1.0;
							pfVar13[3] = 0.0;
							pfVar13[4] = 0.0;
						}
						pSVar6 = param_1->surfMap;
						fVar1 = param_1->float_18;
						fVar2 = param_1->float_18;
						((Rect2F *)(pfVar13 + -2))->x =
								 (float)uStack46848 * param_1->float_18 + (pSVar6->blockDimensions_neg).width;
						pfVar13[-1] = -((float)uStack46852 * fVar2) + (pSVar6->blockDimensions_neg).height;
						pfVar13[1] = fVar1;
						*pfVar13 = fVar1;
						LevelStruct3C_FUN_0045ec00(param_1,(Rect2F *)(pfVar13 + -2));
						*pfVar13 = *pfVar13 - 1.0;
						pfVar13[1] = pfVar13[1] - 1.0;
						BVar3 = Level_GetBlockFlags1_20(uStack46848,uStack46852);
						if ((BVar3 != 0) && (uStack46860 < 200)) {
							fVar1 = *pfVar13;
							fVar2 = pfVar13[-1];
							pPVar14->x = pfVar13[-2];
							*pfVar8 = fVar2;
							fVar1 = (fVar1 - 1.0) + pfVar13[-2];
							pPVar9->x = fVar1;
							pPVar14[1].x = fVar1;
							*pfStack46844 = fVar2;
							pfVar8[2] = fVar2;
							pPVar9[1].x = fVar1;
							fVar2 = (pfVar13[1] - 1.0) + pfVar13[-1];
							pfStack46844[2] = fVar2;
							pPVar14[2].x = fVar1;
							pfVar8[4] = fVar2;
							pPVar9[2].x = pfVar13[-2];
							pfStack46844[4] = fVar2;
							pPVar14[3].x = pfVar13[-2];
							pfVar8[6] = fVar2;
							pPVar9[3].x = pfVar13[-2];
							pfStack46844[6] = pfVar13[-1];
							uStack46860 = uStack46860 + 4;
							pPVar14 = pPVar14 + 4;
							pfVar8 = pfVar8 + 8;
							pPVar9 = pPVar9 + 4;
							pfStack46844 = pfStack46844 + 8;
						}
						uStack46856 = uStack46856 + 1;
						pfVar13 = pfVar13 + 7;
					}
					uStack46848 = uStack46848 + 1;
					uVar5 = uStack46828;
					iVar4 = iStack46820;
					uVar7 = uStack46860;
					uVar10 = uStack46856;
				} while ((int)uStack46848 <= iStack46820);
			}
			uStack46852 = uStack46852 + 1;
			uStack46848 = uVar5;
		} while ((int)uStack46852 <= iStack46816);
	}
	ddraw::DirectDraw_Clear(&param_1->rectf_4,0);
	draw::Draw_RectList2Ex(aDStack42000,uVar10,DrawEffect_None);
	draw::Draw_LineListEx
						(aPStack43600,aPStack45200,uVar7,globals::g_UnkVector3F_30_TABLE[0].x,
						 globals::g_UnkVector3F_30_TABLE[0].y,globals::g_UnkVector3F_30_TABLE[0].z,
						 DrawEffect_None);
	param_1->field_24 = param_2->x - VStack46840.x;
	param_1->field_28 = param_2->y - VStack46840.y;
	param_1->field_2c = param_2->x + VStack46840.x;
	fVar1 = param_2->y;
	param_1->field_34 = aDStack42000;
	param_1->field_38 = 0;
	param_1->field_30 = VStack46840.y + fVar1;
	unk::DoLiveObjCallbacks_True_FUN_00437a70(LiveObject_FUN_0045e720,(LiveObject *)param_1);
	draw::Draw_RectList2Ex((Draw_Rect *)param_1->field_34,param_1->field_38,DrawEffect_None);
	if (globals::g_Game.viewMode == VIEW_TOPDOWN) {
		VStack46760.x = 0.0;
		VStack46760.y = 0.0;
		VStack46760.z = 0.0;
		VStack46760.w = 1.0;
		iVar4 = main::GetResolutionWidth();
		uStack46740 = 0;
		fStack46744 = (float)iVar4;
		uStack46736 = 0;
		uStack46732 = 0x3f800000;
		iVar4 = main::GetResolutionWidth();
		fStack46728 = (float)iVar4;
		iVar4 = main::GetResolutionHeight();
		uStack46720 = 0;
		fStack46724 = (float)iVar4;
		uStack46716 = 0x3f800000;
		uStack46712 = 0;
		iVar4 = main::GetResolutionHeight();
		uStack46704 = 0;
		fStack46708 = (float)iVar4;
		uStack46700 = 0x3f800000;
		uStack46696 = 0;
		uStack46692 = 0;
		uStack46688 = 0x3f800000;
		uStack46684 = 0x3f800000;
		iVar4 = main::GetResolutionWidth();
		uStack46676 = 0;
		fStack46680 = (float)iVar4;
		uStack46672 = 0x3f800000;
		uStack46668 = 0x3f800000;
		iVar4 = main::GetResolutionWidth();
		fStack46664 = (float)iVar4;
		iVar4 = main::GetResolutionHeight();
		uStack46656 = 0x3f800000;
		fStack46660 = (float)iVar4;
		uStack46652 = 0x3f800000;
		uStack46648 = 0;
		iVar4 = main::GetResolutionHeight();
		uStack46640 = 0x3f800000;
		fStack46644 = (float)iVar4;
		uStack46636 = 0x3f800000;
		VStack46784.x = 0.0;
		VStack46784.y = 0.0;
		pSVar6 = GetSurfaceMap();
		VStack46772.x = 0.0;
		pVVar15 = aVStack46576;
		VStack46784.z = pSVar6->float_20 * 0.5;
		VStack46772.y = 0.0;
		VStack46772.z = -1.0;
		transform4d = &VStack46760;
		iVar4 = 8;
		do {
			lego::view::Viewport_InverseTransform(globals::g_Game.viewMain,pVVar15,transform4d);
			transform4d = transform4d + 1;
			pVVar15 = pVVar15 + 1;
			iVar4 = iVar4 + -1;
		} while (iVar4 != 0);
		uStack46856 = 0;
		uVar7 = globals::g_UnkStructF10_a_COUNT;
		do {
			uVar10 = 0;
			if (uVar7 != 0) {
				puVar11 = &globals::g_UnkStructF10_a_TABLE[0].field_8;
				pVVar15 = aVStack45920 + uStack46856 * 0x28;
				do {
					if (uStack46856 == 0) {
						puVar11[0x50] = 0;
						*puVar11 = 0;
					}
					else {
						puVar11[0x50] = 0x3f800000;
						*puVar11 = 0x3f800000;
					}
					lego::view::Viewport_InverseTransform
										(globals::g_Game.viewMain,pVVar15 + -0x14,(Vector4F *)(puVar11 + -2));
					lego::view::Viewport_InverseTransform
										(globals::g_Game.viewMain,pVVar15,(Vector4F *)(puVar11 + 0x4e));
					uVar10 = uVar10 + 1;
					pVVar15 = pVVar15 + 1;
					puVar11 = puVar11 + 4;
					uVar7 = globals::g_UnkStructF10_a_COUNT;
				} while (uVar10 < globals::g_UnkStructF10_a_COUNT);
			}
			uStack46856 = uStack46856 + 1;
		} while (uStack46856 < 2);
		pfVar8 = afStack46156;
		pfVar13 = &aPStack46480[0].y;
		uStack46860 = 2;
		do {
			uVar10 = 0;
			pfVar12 = pfVar8;
			pfVar16 = pfVar13;
			if (uVar7 != 0) {
				do {
					VStack46840.x = pfVar12[0x77] - pfVar12[-1];
					VStack46840.y = pfVar12[0x78] - *pfVar12;
					VStack46840.z = pfVar12[0x79] - pfVar12[1];
					math::Maths_RayPlaneIntersection
										(&VStack46796,(Vector3F *)(pfVar12 + -1),&VStack46840,&VStack46784,&VStack46772)
					;
					RStack46812.x = VStack46796.x;
					RStack46812.y = VStack46796.y;
					LevelStruct3C_FUN_0045ec00(param_1,&RStack46812);
					pfVar16[-1] = RStack46812.x;
					*pfVar16 = RStack46812.y;
					uVar10 = uVar10 + 1;
					pfVar12 = pfVar12 + 3;
					pfVar16 = pfVar16 + 2;
					uVar7 = globals::g_UnkStructF10_a_COUNT;
				} while (uVar10 < globals::g_UnkStructF10_a_COUNT);
			}
			pfVar13 = pfVar13 + 0x28;
			pfVar8 = pfVar8 + 0x3c;
			uStack46860 = uStack46860 + -1;
		} while (uStack46860 != 0);
		draw::Draw_LineListEx(aPStack46480,aPStack46320,uVar7,1.0,1.0,1.0,DrawEffect_HalfTrans);
		pfVar8 = &PStack46632.y;
		pfVar13 = &aVStack46576[0].y;
		iVar4 = 4;
		do {
			VStack46840.x = pfVar13[0xb] - pfVar13[-1];
			VStack46840.y = pfVar13[0xc] - *pfVar13;
			VStack46840.z = pfVar13[0xd] - pfVar13[1];
			math::Maths_RayPlaneIntersection
								(&VStack46796,(Vector3F *)(pfVar13 + -1),&VStack46840,&VStack46784,&VStack46772);
			RStack46812.x = VStack46796.x;
			RStack46812.y = VStack46796.y;
			LevelStruct3C_FUN_0045ec00(param_1,&RStack46812);
			pfVar8[-1] = RStack46812.x;
			*pfVar8 = RStack46812.y;
			pfVar13 = pfVar13 + 3;
			pfVar8 = pfVar8 + 2;
			iVar4 = iVar4 + -1;
		} while (iVar4 != 0);
		fStack46600 = PStack46632.x;
		fStack46596 = PStack46632.y;
		draw::Draw_LineListEx(&PStack46632,aPStack46624,4,0.7,0.7,0.7,DrawEffect_HalfTrans);
	}
	draw::Draw_SetClipWindow(&RStack46592);
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_0045e6c0(LiveObject *liveObj)
{
	ObjectType OVar1;
	ObjectStatsFlags2 OVar2;
	
	OVar1 = liveObj->objType;
	if ((((((OVar1 != OBJECT_ELECTRICFENCESTUD) && (OVar1 != OBJECT_BOULDER)) &&
				(OVar1 != OBJECT_DYNAMITE)) && ((OVar1 != OBJECT_OOHSCARY && (OVar1 != OBJECT_PUSHER)))) &&
			((OVar1 != OBJECT_FREEZER && ((OVar1 != OBJECT_LASERSHOT && (OVar1 != OBJECT_BARRIER)))))) &&
		 ((OVar1 != OBJECT_ICECUBE && ((OVar1 != OBJECT_BUILDING && (OVar1 != OBJECT_SPIDERWEB)))))) {
		OVar2 = LiveObject_GetStatsFlags2(liveObj);
		return ~OVar2 >> 0x1d & 1;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_0045e720(LiveObject *liveObj,int param_2)
{
	ObjectType OVar1;
	float fVar2;
	BOOL BVar3;
	float local_8;
	float local_4;
	
	BVar3 = LiveObject_FUN_0045e6c0(liveObj);
	if (BVar3 == 0) {
		return 0;
	}
	LiveObject_GetPosition(liveObj,&local_8,&local_4);
	if ((((*(float *)(param_2 + 0x24) <= local_8) &&
			 ((ushort)((ushort)(local_8 < *(float *)(param_2 + 0x2c)) << 8 |
								(ushort)(local_8 == *(float *)(param_2 + 0x2c)) << 0xe) != 0)) &&
			(*(float *)(param_2 + 0x28) <= local_4)) &&
		 ((ushort)((ushort)(local_4 < *(float *)(param_2 + 0x30)) << 8 |
							(ushort)(local_4 == *(float *)(param_2 + 0x30)) << 0xe) != 0)) {
		OVar1 = liveObj->objType;
		if (OVar1 == OBJECT_ROCKMONSTER) {
			*(float *)(*(int *)(param_2 + 0x34) + 0x10 + *(int *)(param_2 + 0x38) * 0x1c) =
					 globals::g_UnkVector3F_30_TABLE[15].x;
			*(float *)(*(int *)(param_2 + 0x34) + 0x14 + *(int *)(param_2 + 0x38) * 0x1c) =
					 globals::g_UnkVector3F_30_TABLE[15].y;
			*(float *)(*(int *)(param_2 + 0x34) + 0x18 + *(int *)(param_2 + 0x38) * 0x1c) =
					 globals::g_UnkVector3F_30_TABLE[15].z;
			fVar2 = 0.3333333;
		}
		else {
			if ((OVar1 == OBJECT_POWERCRYSTAL) || (OVar1 == OBJECT_ORE)) {
				*(float *)(*(int *)(param_2 + 0x34) + 0x10 + *(int *)(param_2 + 0x38) * 0x1c) =
						 globals::g_UnkVector3F_30_TABLE[16].x;
				*(float *)(*(int *)(param_2 + 0x34) + 0x14 + *(int *)(param_2 + 0x38) * 0x1c) =
						 globals::g_UnkVector3F_30_TABLE[16].y;
				*(float *)(*(int *)(param_2 + 0x34) + 0x18 + *(int *)(param_2 + 0x38) * 0x1c) =
						 globals::g_UnkVector3F_30_TABLE[16].z;
				fVar2 = 0.25;
			}
			else {
				*(float *)(*(int *)(param_2 + 0x34) + 0x10 + *(int *)(param_2 + 0x38) * 0x1c) =
						 globals::g_UnkVector3F_30_TABLE[14].x;
				*(float *)(*(int *)(param_2 + 0x34) + 0x14 + *(int *)(param_2 + 0x38) * 0x1c) =
						 globals::g_UnkVector3F_30_TABLE[14].y;
				*(float *)(*(int *)(param_2 + 0x34) + 0x18 + *(int *)(param_2 + 0x38) * 0x1c) =
						 globals::g_UnkVector3F_30_TABLE[14].z;
				fVar2 = 0.3333333;
			}
		}
		*(float *)(*(int *)(param_2 + 0x34) + *(int *)(param_2 + 0x38) * 0x1c) =
				 local_8 - fVar2 * 0.5 * *(float *)(param_2 + 0x18);
		*(float *)(*(int *)(param_2 + 0x34) + 4 + *(int *)(param_2 + 0x38) * 0x1c) =
				 fVar2 * 0.5 * *(float *)(param_2 + 0x18) + local_4;
		*(float *)(*(int *)(param_2 + 0x34) + 8 + *(int *)(param_2 + 0x38) * 0x1c) =
				 fVar2 * *(float *)(param_2 + 0x18);
		*(float *)(*(int *)(param_2 + 0x34) + 0xc + *(int *)(param_2 + 0x38) * 0x1c) =
				 fVar2 * *(float *)(param_2 + 0x18);
		LevelStruct3C_FUN_0045ec00
							((LevelStruct_3c *)param_2,
							 (Rect2F *)(*(int *)(param_2 + 0x34) + *(int *)(param_2 + 0x38) * 0x1c));
		*(int *)(param_2 + 0x38) = *(int *)(param_2 + 0x38) + 1;
	}
	return 0;
}



BOOL __cdecl
lego::game::LevelStruct3C_FUN_0045e920(LevelStruct_3c *param_1,uint param_2,uint param_3)
{
	if (((((param_1->rectf_4).x <= (float)(ulonglong)param_2) &&
			 ((float)(ulonglong)param_2 < (param_1->rectf_4).width + (param_1->rectf_4).x)) &&
			((param_1->rectf_4).y <= (float)(ulonglong)param_3)) &&
		 ((float)(ulonglong)param_3 < (param_1->rectf_4).height + (param_1->rectf_4).y)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::game::LevelStruct3C_FUN_0045e990
					(LevelStruct_3c *param_1,uint x,uint y,Point2F *out_pointf,int *out_blockx,int *out_blocky
					)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	BOOL BVar5;
	
	fVar1 = (float)(ulonglong)x;
	if (((param_1->rectf_4).x <= fVar1) &&
		 (fVar2 = (param_1->rectf_4).width + (param_1->rectf_4).x,
		 (ushort)((ushort)(fVar2 < fVar1) << 8 | (ushort)(fVar2 == fVar1) << 0xe) == 0)) {
		fVar2 = (float)(ulonglong)y;
		if (((param_1->rectf_4).y <= fVar2) &&
			 (fVar3 = (param_1->rectf_4).height + (param_1->rectf_4).y,
			 (ushort)((ushort)(fVar3 < fVar2) << 8 | (ushort)(fVar3 == fVar2) << 0xe) == 0)) {
			fVar3 = 1.0 / param_1->float_14;
			fVar4 = (param_1->rectf_4).width * 0.5;
			fVar2 = param_1->float_18 * (((param_1->rectf_4).y + fVar4) - fVar2) * fVar3 +
							param_1->float_20;
			fVar1 = param_1->float_1c +
							-(param_1->float_18 * (((param_1->rectf_4).x + fVar4) - fVar1) * fVar3);
			BVar5 = SurfaceMap_ToBlockCoordinatesNoZ(param_1->surfMap,fVar1,fVar2,out_blockx,out_blocky);
			if (BVar5 != 0) {
				if (out_pointf != (Point2F *)0x0) {
					out_pointf->x = fVar1;
					out_pointf->y = fVar2;
				}
				return 1;
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LevelStruct3C_FUN_0045eae0
					(LevelStruct_3c *param_1,uint x,uint y,undefined4 *param_4,undefined4 *param_5)
{
	BOOL BVar1;
	int local_18;
	int local_14;
	LiveObject *local_10;
	Point2F local_c;
	VehicleData *local_4;
	
	local_c.x = 0.0;
	local_c.y = 0.0;
	local_4 = (VehicleData *)0x0;
	local_10 = (LiveObject *)0x0;
	BVar1 = LevelStruct3C_FUN_0045e990(param_1,x,y,&local_c,&local_18,&local_14);
	if (BVar1 != 0) {
		BVar1 = Level_BlockCheck_FUN_004329d0(local_18,local_14,1);
		if (BVar1 == 0) {
			local_4 = (VehicleData *)(param_1->float_18 * 0.1666667);
		}
		else {
			local_4 = (VehicleData *)param_1->float_18;
		}
		BVar1 = unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_0045eba0,(LiveObject *)&local_10);
		if (BVar1 != 0) {
			*param_4 = local_10;
			if (param_5 != (undefined4 *)0x0) {
				LiveObject_GetPosition(local_10,(float *)param_5,(float *)(param_5 + 1));
			}
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl FUN_0045eba0(LiveObject *liveObj,LiveObject **param_2)
{
	float local_8;
	float local_4;
	
	lego::game::LiveObject_GetPosition(liveObj,&local_8,&local_4);
	if ((ABS(local_8 - (float)param_2[1]) <= (float)param_2[3]) &&
		 (ABS(local_4 - (float)param_2[2]) <= (float)param_2[3])) {
		*param_2 = liveObj;
		return 1;
	}
	return 0;
}



void __cdecl lego::game::LevelStruct3C_FUN_0045ec00(LevelStruct_3c *param_1,Rect2F *ref_param_2)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	
	fVar1 = (param_1->rectf_4).width;
	fVar2 = (param_1->rectf_4).height;
	fVar3 = (param_1->rectf_4).x;
	fVar4 = (param_1->rectf_4).y;
	ref_param_2->x = ref_param_2->x - param_1->float_1c;
	ref_param_2->y = ref_param_2->y - param_1->float_20;
	ref_param_2->x = (param_1->float_14 / param_1->float_18) * ref_param_2->x;
	ref_param_2->y = (param_1->float_14 / param_1->float_18) * ref_param_2->y;
	ref_param_2->width = (param_1->float_14 / param_1->float_18) * ref_param_2->width;
	fVar5 = param_1->float_14;
	fVar6 = param_1->float_18;
	ref_param_2->x = ref_param_2->x + fVar1 * 0.5 + fVar3;
	ref_param_2->y = (fVar2 * 0.5 + fVar4) - ref_param_2->y;
	ref_param_2->height = (fVar5 / fVar6) * ref_param_2->height;
	return;
}



BOOL __cdecl FUN_0045eca0(int param_1,uint param_2,uint param_3)
{
	uint y;
	BOOL BVar1;
	uint uVar2;
	Point2I local_8;
	
	y = param_3;
	uVar2 = param_2;
	local_8.x = param_2;
	local_8.y = param_3;
	FUN_00433260(param_2,param_3,&param_2);
	BVar1 = lego::game::Level_GetBlockFlags1_10Not8(uVar2,y);
	if (BVar1 == 0) {
		BVar1 = FUN_00432e70(uVar2,y);
		if ((BVar1 != 0) && (BVar1 = FUN_00432ec0(uVar2,y), BVar1 != 0)) {
			if (((lego::globals::g_Game.level)->blocks
					 [((lego::globals::g_Game.level)->dimensions).width * y + uVar2].flags1 & BLOCK1_HIDDEN)
					!= BLOCK1_NONE) {
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[29].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[29].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[29].z;
				return 1;
			}
			switch(param_2) {
			case 1:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[8].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[8].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[8].z;
				return 1;
			case 2:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[7].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[7].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[7].z;
				return 1;
			case 3:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[6].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[6].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[6].z;
				return 1;
			case 4:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[5].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[5].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[5].z;
				return 1;
			case 5:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[4].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[4].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[4].z;
				return 1;
			case 6:
				goto switchD_0045ef37_caseD_6;
			case 7:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[2].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[2].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[2].z;
				return 1;
			case 8:
switchD_0045ef37_caseD_8:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[24].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[24].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[24].z;
				return 1;
			case 9:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[27].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[27].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[27].z;
				return 1;
			case 10:
switchD_0045ef37_caseD_a:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[25].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[25].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[25].z;
				return 1;
			case 0xb:
switchD_0045ef37_caseD_b:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[26].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[26].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[26].z;
				return 1;
			default:
				goto switchD_0045ef37_caseD_b;
			}
		}
		BVar1 = lego::game::Level_GetBlockFlags1_8(uVar2,y);
		if (BVar1 == 0) {
			return 0;
		}
		if (param_2 != 6) {
			if (param_2 == 7) {
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[2].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[2].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[2].z;
				return 1;
			}
			if (param_2 == 9) {
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[27].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[27].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[27].z;
				return 1;
			}
			if (((lego::globals::g_Game.level)->blocks
					 [((lego::globals::g_Game.level)->dimensions).width * y + uVar2].flags1 &
					BLOCK1_UNK_100000) != BLOCK1_NONE) {
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[28].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[28].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[28].z;
				return 1;
			}
			BVar1 = lego::game::Level_IsBlockPowerPath(&local_8);
			if (BVar1 == 0) {
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[1].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[1].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[1].z;
				return 1;
			}
			BVar1 = lego::game::Level_BlockHasFlag2_100(&local_8);
			if (BVar1 == 0) {
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[23].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[23].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[23].z;
				return 1;
			}
			*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[22].x;
			*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[22].y;
			*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[22].z;
			return 1;
		}
switchD_0045ef37_caseD_6:
		*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[3].x;
		*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[3].y;
		*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[3].z;
	}
	else {
		uVar2 = FUN_00432b50(uVar2,y);
		if (uVar2 == 0) {
			switch(param_2) {
			case 1:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[13].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[13].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[13].z;
				return 1;
			case 2:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[12].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[12].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[12].z;
				return 1;
			case 3:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[11].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[11].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[11].z;
				return 1;
			case 4:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[10].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[10].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[10].z;
				return 1;
			case 5:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[9].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[9].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[9].z;
				return 1;
			case 8:
				goto switchD_0045ef37_caseD_8;
			case 10:
				goto switchD_0045ef37_caseD_a;
			case 0xb:
				goto switchD_0045ef37_caseD_b;
			}
		}
		else {
			switch(param_2) {
			case 1:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[21].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[21].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[21].z;
				return 1;
			case 2:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[20].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[20].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[20].z;
				return 1;
			case 3:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[19].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[19].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[19].z;
				return 1;
			case 4:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[18].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[18].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[18].z;
				return 1;
			case 5:
				*(float *)(param_1 + 0x10) = lego::globals::g_UnkVector3F_30_TABLE[17].x;
				*(float *)(param_1 + 0x14) = lego::globals::g_UnkVector3F_30_TABLE[17].y;
				*(float *)(param_1 + 0x18) = lego::globals::g_UnkVector3F_30_TABLE[17].z;
				return 1;
			}
		}
	}
switchD_0045ef37_caseD_b:
	return 1;
}



BOOL __cdecl lego::reward::Reward_LoadBaseFrontEnd(void)
{
	int iVar1;
	uint uVar2;
	RewardFrontEnd *pRVar3;
	char **ppcVar4;
	char *ITEM_NAMES [10];
	
	ITEM_NAMES[0] = "Crystals";
	ITEM_NAMES[1] = "Ore";
	ITEM_NAMES[2] = "Diggable";
	ITEM_NAMES[3] = "Constructions";
	ITEM_NAMES[4] = "Caverns";
	ITEM_NAMES[5] = "Figures";
	ITEM_NAMES[6] = "RockMonsters";
	ITEM_NAMES[7] = "Oxygen";
	ITEM_NAMES[8] = "Timer";
	ITEM_NAMES[9] = "Score";
	globals::g_RewardFrontBase = (RewardFrontEnd *)std::malloc(0x318c);
	pRVar3 = globals::g_RewardFrontBase;
										// std::memset(_, 0, 0x318c);
	for (iVar1 = 0xc63; iVar1 != 0; iVar1 = iVar1 + -1) {
		pRVar3->Enabled = 0;
		pRVar3 = (RewardFrontEnd *)&pRVar3->field_0x4;
	}
	uVar2 = 0;
	ppcVar4 = ITEM_NAMES;
	globals::g_RewardFrontBase->items_PTR = globals::g_RewardFrontBase->items_TABLE;
	globals::g_RewardFrontBase->items_COUNT = 10;
	do {
		std::sprintf(globals::g_RewardFrontBase->items_PTR->name + uVar2,"%s",*ppcVar4);
		uVar2 = uVar2 + 0x210;
		ppcVar4 = ppcVar4 + 1;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		RewardItem_LoadBaseImages
							((RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar2 - 4)));
		uVar2 = uVar2 + 0x210;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		RewardItem_LoadBaseText
							((RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar2 - 4)));
		uVar2 = uVar2 + 0x210;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		RewardItem_LoadBaseFlics
							((RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar2 - 4)));
		uVar2 = uVar2 + 0x210;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		RewardItem_LoadBaseFonts
							((RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar2 - 4)));
		uVar2 = uVar2 + 0x210;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		RewardItem_LoadBaseSounds
							((RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar2 - 4)));
		uVar2 = uVar2 + 0x210;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		RewardItem_LoadBaseBoxImages
							((RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar2 - 4)));
		uVar2 = uVar2 + 0x210;
	} while (uVar2 < 0x14a0);
	return 1;
}



void __cdecl lego::reward::RewardItem_LoadBaseSounds(RewardFrontEndItem *rewardItem)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Sounds",rewardItem->name,0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
	rewardItem->SoundName = pcVar1;
	return;
}



void __cdecl lego::reward::RewardItem_LoadBaseFonts(RewardFrontEndItem *rewardItem)
{
	char *pcVar1;
	ImageFont *pIVar2;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Fonts",rewardItem->name,0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 != (char *)0x0) {
		pIVar2 = image::Font_Load(pcVar1);
		rewardItem->Font = pIVar2;
		if (pIVar2 != (ImageFont *)0x0) {
			return;
		}
	}
	rewardItem->Font = globals::g_Reward_Font;
	return;
}



void __cdecl lego::reward::RewardItem_LoadBaseBoxImages(RewardFrontEndItem *rewardItem)
{
	char *pcVar1;
	int iVar2;
	ImageBMP *image;
	char reduceName [64];
	char valueBuffer [128];
	char *stringParts [100];
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","BoxImages",rewardItem->name,0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 == (char *)0x0) {
		if ((globs::mainGlobs.flags & CMD_REDUCEIMAGES) == CMD_NONE) {
			std::sprintf(reduceName,"!%s",rewardItem->name);
			pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Images",reduceName,0);
			pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
		}
		if (pcVar1 == (char *)0x0) {
			return;
		}
	}
	util::Util_Tokenise(pcVar1,stringParts,"|");
	std::sprintf(valueBuffer,"%s",stringParts[0]);
	iVar2 = std::atoi(stringParts[1]);
	(rewardItem->BoxImagePosition).x = iVar2;
	iVar2 = std::atoi(stringParts[2]);
	(rewardItem->BoxImagePosition).y = iVar2;
	image = lego::image::Image_LoadBMPScaled(valueBuffer,0,0);
	rewardItem->BoxImage = image;
	if (image != (ImageBMP *)0x0) {
		lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
		rewardItem->flags = rewardItem->flags | REWARDITEM_BOXIMAGES;
		std::free(pcVar1);
	}
	return;
}



void __cdecl lego::reward::RewardItem_LoadBaseImages(RewardFrontEndItem *rewardItem)
{
	char *pcVar1;
	int iVar2;
	ImageBMP *image;
	char local_250 [64];
	char local_210 [128];
	char *local_190;
	char *local_18c;
	char *local_188;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Images",rewardItem->name,0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 == (char *)0x0) {
		if ((globs::mainGlobs.flags & CMD_REDUCEIMAGES) == CMD_NONE) {
			std::sprintf(local_250,"!%s",rewardItem->name);
			pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Images",local_250,0);
			pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
		}
		if (pcVar1 == (char *)0x0) {
			return;
		}
	}
	util::Util_Tokenise(pcVar1,&local_190,"|");
	std::sprintf(local_210,"%s",local_190);
	iVar2 = std::atoi(local_18c);
	(rewardItem->ImagePosition).x = iVar2;
	iVar2 = std::atoi(local_188);
	(rewardItem->ImagePosition).y = iVar2;
	image = lego::image::Image_LoadBMPScaled(local_210,0,0);
	rewardItem->Image = image;
	if (image != (ImageBMP *)0x0) {
		lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
		rewardItem->flags = rewardItem->flags | REWARDITEM_IMAGES;
		std::free(pcVar1);
	}
	return;
}



void __cdecl lego::reward::RewardItem_LoadBaseText(RewardFrontEndItem *rewardItem)
{
	RewardItemFlags RVar1;
	char *pcVar2;
	int iVar3;
	char *stringParts [100];
	
	pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Text",rewardItem->name,0);
	pcVar2 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar2);
	if (pcVar2 != (char *)0x0) {
		util::Util_Tokenise(pcVar2,stringParts,"|");
		std::sprintf(rewardItem->Text,"%s",stringParts[0]);
		util::stringReplaceChar(rewardItem->Text,'_',' ');
		iVar3 = std::atoi(stringParts[1]);
		(rewardItem->TextPosition).x = iVar3;
		iVar3 = std::atoi(stringParts[2]);
		RVar1 = rewardItem->flags;
		(rewardItem->TextPosition).y = iVar3;
		rewardItem->flags = RVar1 | (REWARDITEM_TEXT_1|REWARDITEM_TEXT_10|REWARDITEM_TEXT_20);
		std::free(pcVar2);
	}
	return;
}



void __cdecl lego::reward::RewardItem_LoadBaseFlics(RewardFrontEndItem *rewardItem)
{
	RewardItemFlags RVar1;
	char *pcVar2;
	int iVar3;
	char reduceName [64];
	char valueBuffer [128];
	char *stringParts [100];
	
	pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Flics",rewardItem->name,0);
	pcVar2 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar2);
	if (pcVar2 == (char *)0x0) {
		if ((globs::mainGlobs.flags & CMD_REDUCEFLICS) == CMD_NONE) {
			std::sprintf(reduceName,"!%s",rewardItem->name);
			pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Flics",reduceName,0);
			pcVar2 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar2);
		}
		if (pcVar2 == (char *)0x0) {
			return;
		}
	}
	util::Util_Tokenise(pcVar2,stringParts,"|");
	std::sprintf(valueBuffer,"%s",stringParts[0]);
	std::sprintf(rewardItem->FlicName,"%s",valueBuffer);
	iVar3 = std::atoi(stringParts[1]);
	(rewardItem->FlicPosition).x = iVar3;
	iVar3 = std::atoi(stringParts[2]);
	(rewardItem->FlicPosition).y = iVar3;
	iVar3 = std::atoi(stringParts[3]);
	(rewardItem->FlicSize).width = iVar3;
	iVar3 = std::atoi(stringParts[4]);
	RVar1 = rewardItem->flags;
	(rewardItem->FlicSize).height = iVar3;
	rewardItem->flags = RVar1 | REWARDITEM_UNK_4;
	std::free(pcVar2);
	return;
}



void __cdecl lego::reward::Reward_CleanupBase(void)
{
	RewardFrontEndItem *rewardItem;
	uint uVar1;
	
	uVar1 = 0;
	do {
		if ((globals::g_RewardFrontBase->items_PTR->name[uVar1 - 4] & REWARDITEM_IMAGES) != 0) {
			RewardItem_CleanupBaseImage
								((RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar1 - 4)));
		}
		rewardItem = (RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar1 - 4));
		if ((*(byte *)&rewardItem->flags & REWARDITEM_TEXT_1) != 0) {
			Reward_CleanupBaseFont(rewardItem);
		}
		uVar1 = uVar1 + 0x210;
	} while (uVar1 < 0x14a0);
	std::free(globals::g_RewardFrontBase);
	return;
}



void __cdecl lego::reward::RewardItem_CleanupBaseImage(RewardFrontEndItem *rewardItem)
{
	image::Image_Remove(rewardItem->Image);
	return;
}



void __cdecl lego::reward::Reward_CleanupBaseFont(RewardFrontEndItem *rewardItem)
{
	image::Font_Remove(rewardItem->Font);
	return;
}



BOOL __cdecl lego::front::Reward_LoadBaseGraphics(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	float10 fVar2;
	uint width;
	uint height;
	char *stringParts [100];
	
	game::GetLevel();
	height = 0;
	width = 0;
	globals::g_Reward_LegoCfgRoot = root;
	globals::g_Reward_CfgRootName = rootPath;
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","Wallpaper",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Reward_Wallpaper = image::Image_LoadBMPScaled(pcVar1,width,height);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","Display",0);
	globals::g_Reward_Display = cfg::CFG_ReadBool(root,pcVar1);
	if (globals::g_Reward_Display == BOOL3_ERROR) {
		globals::g_Reward_Display = 0;
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","CentreText",0);
	globals::g_Reward_CentreText = cfg::CFG_ReadBool(root,pcVar1);
	if (globals::g_Reward_CentreText == BOOL3_ERROR) {
		globals::g_Reward_CentreText = 0;
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","ScrollSpeed",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == (char *)0x0) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","ScrollSpeed",0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	}
	fVar2 = std::atof(pcVar1);
	globals::g_Reward_ScrollSpeed = (float)fVar2;
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","VertSpacing",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == (char *)0x0) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","VertSpacing",0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	}
	fVar2 = std::atof(pcVar1);
	globals::g_Reward_VertSpacing = (float)fVar2;
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","Font",0);
	globals::g_Reward_Font_filename = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","TitleFont",0);
	globals::g_Reward_TitleFont_filename = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","BackFont",0);
	globals::g_Reward_BackFont_filename = cfg::CFG_CopyString(root,pcVar1);
	globals::g_Reward_Font = image::Font_Load(globals::g_Reward_Font_filename);
	globals::g_Reward_TitleFont = image::Font_Load(globals::g_Reward_TitleFont_filename);
	globals::g_Reward_BackFont = image::Font_Load(globals::g_Reward_BackFont_filename);
	reward::Reward_LoadSaveAdvanceButtons(root,rootPath);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","CompleteText",0);
	globals::g_Reward_CompleteText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","FailedText",0);
	globals::g_Reward_FailedText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","QuitText",0);
	globals::g_Reward_QuitText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","TextPos",0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 != (char *)0x0) {
		util::Util_Tokenise(pcVar1,stringParts,"|");
		globals::g_Reward_TextPos.x = std::atoi(stringParts[0]);
		globals::g_Reward_TextPos.y = std::atoi(stringParts[1]);
	}
	return 1;
}



BOOL __cdecl lego::reward::Reward_LoadSaveAdvanceButtons(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	int iVar2;
	char *parts [100];
	
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","SaveButton",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		util::Util_Tokenise(pcVar1,parts,"|");
		globals::g_Reward_SaveButton = image::Image_LoadBMPScaled(parts[0],0,0);
		if (globals::g_Reward_SaveButton != (ImageBMP *)0x0) {
			globals::g_Reward_SaveButton_hi = image::Image_LoadBMPScaled(parts[1],0,0);
			globals::g_Reward_SaveButton_in = image::Image_LoadBMPScaled(parts[2],0,0);
			globals::g_Reward_SaveButton_dim = image::Image_LoadBMPScaled(parts[3],0,0);
			iVar2 = std::atoi(parts[4]);
			globals::g_Reward_SaveButtonPosition.x = (float)iVar2;
			iVar2 = std::atoi(parts[5]);
			globals::g_Reward_SaveButtonPosition.y = (float)iVar2;
			image::Image_SetupTrans(globals::g_Reward_SaveButton,0.0,0.0,0.0,0.0,0.0,0.0);
			if (globals::g_Reward_SaveButton_hi != (ImageBMP *)0x0) {
				image::Image_SetupTrans(globals::g_Reward_SaveButton_hi,0.0,0.0,0.0,0.0,0.0,0.0);
			}
			if (globals::g_Reward_SaveButton_in != (ImageBMP *)0x0) {
				image::Image_SetupTrans(globals::g_Reward_SaveButton_in,0.0,0.0,0.0,0.0,0.0,0.0);
			}
		}
		std::free(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","AdvanceButton",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != (char *)0x0) {
		util::Util_Tokenise(pcVar1,parts,"|");
		globals::g_Reward_AdvanceButton = image::Image_LoadBMPScaled(parts[0],0,0);
		if (globals::g_Reward_AdvanceButton != (ImageBMP *)0x0) {
			globals::g_Reward_AdvanceButton_hi = image::Image_LoadBMPScaled(parts[1],0,0);
			globals::g_Reward_AdvanceButton_in = image::Image_LoadBMPScaled(parts[2],0,0);
			globals::g_Reward_AdvanceButton_dim = image::Image_LoadBMPScaled(parts[3],0,0);
			iVar2 = std::atoi(parts[4]);
			globals::g_Reward_AdvanceButtonPosition.x = (float)iVar2;
			iVar2 = std::atoi(parts[5]);
			globals::g_Reward_AdvanceButtonPosition.y = (float)iVar2;
			image::Image_SetupTrans(globals::g_Reward_AdvanceButton,0.0,0.0,0.0,0.0,0.0,0.0);
			if (globals::g_Reward_AdvanceButton_hi != (ImageBMP *)0x0) {
				image::Image_SetupTrans(globals::g_Reward_AdvanceButton_hi,0.0,0.0,0.0,0.0,0.0,0.0);
			}
			if (globals::g_Reward_AdvanceButton_in != (ImageBMP *)0x0) {
				image::Image_SetupTrans(globals::g_Reward_AdvanceButton_in,0.0,0.0,0.0,0.0,0.0,0.0);
			}
		}
		std::free(pcVar1);
	}
	if ((globals::g_Reward_SaveButton != (ImageBMP *)0x0) &&
		 (globals::g_Reward_AdvanceButton != (ImageBMP *)0x0)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::reward::Reward_LoadLevelFrontEnd(void)
{
	int iVar1;
	LevelData *pLVar2;
	char *pcVar3;
	BOOL3 BVar4;
	uint uVar5;
	int iVar6;
	int iVar7;
	undefined4 *puVar8;
	RewardFrontEnd *pRVar9;
	undefined4 *puVar10;
	float10 fVar11;
	
	pLVar2 = game::GetLevel();
	globals::g_RewardFrontLevel = (RewardFrontEnd *)std::malloc(0x318c);
	pRVar9 = globals::g_RewardFrontLevel;
										// std:::memset(_, 0, 0x318c);
	for (iVar6 = 0xc63; iVar6 != 0; iVar6 = iVar6 + -1) {
		pRVar9->Enabled = 0;
		pRVar9 = (RewardFrontEnd *)&pRVar9->field_0x4;
	}
	pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,pLVar2->levelName,"Reward","Enable",0);
	BVar4 = cfg::CFG_ReadBool(globals::g_Reward_LegoCfgRoot,pcVar3);
	globals::g_RewardFrontLevel->Enabled = BVar4;
	if (globals::g_RewardFrontLevel->Enabled == 2) {
		globals::g_RewardFrontLevel->Enabled = 0;
	}
	pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,pLVar2->levelName,"Reward","Modifier",0);
	pcVar3 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar3);
	if (pcVar3 == (char *)0x0) {
		pcVar3 = ____EMPTYSTR__;
	}
	else {
		pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,pLVar2->levelName,"Reward","Modifier",0
															);
		pcVar3 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar3);
	}
	iVar6 = std::atoi(pcVar3);
	globals::g_RewardFrontLevel->Modifier = iVar6;
	pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Timer",0);
	pcVar3 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar3);
	if (pcVar3 == (char *)0x0) {
		pcVar3 = ____EMPTYSTR__;
	}
	else {
		pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Timer",0);
		pcVar3 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar3);
	}
	fVar11 = std::atof(pcVar3);
	globals::g_Reward_Timer = (float)fVar11;
	if ((float10)0.0 == fVar11) {
		globals::g_Reward_Timer = 76.9375;
	}
	pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","DisplayText",0);
	globals::g_Reward_DisplayText = cfg::CFG_ReadBool(globals::g_Reward_LegoCfgRoot,pcVar3);
	if (globals::g_Reward_DisplayText == BOOL3_ERROR) {
		globals::g_Reward_DisplayText = 1;
	}
	pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","DisplayImages",0);
	globals::g_Reward_DisplayImages = cfg::CFG_ReadBool(globals::g_Reward_LegoCfgRoot,pcVar3);
	if (globals::g_Reward_DisplayImages == BOOL3_ERROR) {
		globals::g_Reward_DisplayImages = 1;
	}
	pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","DisplayFlics",0);
	globals::g_Reward_DisplayFlics = cfg::CFG_ReadBool(globals::g_Reward_LegoCfgRoot,pcVar3);
	if (globals::g_Reward_DisplayFlics == BOOL3_ERROR) {
		globals::g_Reward_DisplayFlics = 1;
	}
	globals::g_RewardFrontLevel->items_PTR = globals::g_RewardFrontLevel->items_TABLE;
	uVar5 = 0;
	globals::g_RewardFrontLevel->items_COUNT = 10;
	do {
		iVar6 = uVar5 - 4;
		iVar1 = uVar5 - 4;
		uVar5 = uVar5 + 0x210;
		puVar8 = (undefined4 *)(globals::g_RewardFrontBase->items_PTR->name + iVar6);
		puVar10 = (undefined4 *)(globals::g_RewardFrontLevel->items_PTR->name + iVar1);
		for (iVar7 = 0x84; iVar7 != 0; iVar7 = iVar7 + -1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
	} while (uVar5 < 0x14a0);
	uVar5 = 0;
	do {
		RewardItem_LoadLevelImportance
							((RewardFrontEndItem *)(globals::g_RewardFrontLevel->items_PTR->name + (uVar5 - 4)));
		uVar5 = uVar5 + 0x210;
	} while (uVar5 < 0x14a0);
	uVar5 = 0;
	do {
		RewardItem_LoadLevelQuota
							((RewardFrontEndItem *)(globals::g_RewardFrontLevel->items_PTR->name + (uVar5 - 4)));
		uVar5 = uVar5 + 0x210;
	} while (uVar5 < 0x14a0);
										// HARDCODED: Set Caverns::Quota = 1, for Level03 ("Rubble Trouble!")
	iVar6 = std::_stricmp(pLVar2->levelName,"Levels::Level03");
	if (iVar6 == 0) {
		globals::g_RewardFrontLevel->items_PTR[4].Quota = 1;
	}
	return 1;
}



void __cdecl lego::reward::RewardItem_LoadLevelImportance(RewardFrontEndItem *rewardItem)
{
	LevelData *level;
	char *pcVar1;
	float10 fVar2;
	
	level = game::GetLevel();
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,level->levelName,"Reward","Importance",
														 rewardItem->name,0);
	pcVar1 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 != (char *)0x0) {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,level->levelName,"Reward","Importance",
															 rewardItem->name,0);
		pcVar1 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar1);
		fVar2 = std::atof(pcVar1);
		rewardItem->Importance = (float)fVar2;
		return;
	}
	fVar2 = std::atof(____EMPTYSTR__);
	rewardItem->Importance = (float)fVar2;
	return;
}



void __cdecl lego::reward::RewardItem_LoadLevelQuota(RewardFrontEndItem *rewardItem)
{
	LevelData *level;
	char *pcVar1;
	int iVar2;
	
	level = game::GetLevel();
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,level->levelName,"Reward","Quota",
														 rewardItem->name,0);
	pcVar1 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 != (char *)0x0) {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,level->levelName,"Reward","Quota",
															 rewardItem->name,0);
		pcVar1 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar1);
		iVar2 = std::atoi(pcVar1);
		rewardItem->Quota = iVar2;
		return;
	}
	iVar2 = std::atoi(____EMPTYSTR__);
	rewardItem->Quota = iVar2;
	return;
}



void __cdecl lego::reward::RewardFrontEnd_Free(void)
{
	std::free(globals::g_RewardFrontLevel);
	return;
}



RewardFrontEnd * __cdecl lego::reward::GetRewardFrontEnd(undefined4 unused_levelField10)
{
	return globals::g_RewardFrontLevel;
}



// No different from above (GetRewardFrontEnd(undefined4))

RewardFrontEnd * __cdecl lego::reward::GetCurrentRewardFrontEnd(void)
{
	LevelData *pLVar1;
	RewardFrontEnd *pRVar2;
	
	pLVar1 = game::GetLevel();
	if (pLVar1 == (LevelData *)0x0) {
		return (RewardFrontEnd *)0x0;
	}
	pRVar2 = GetRewardFrontEnd(pLVar1->field_10);
	return pRVar2;
}



void __cdecl lego::unk::Lego_UnkLevelImportantPilot___004604e0(void)
{
	LevelData *pLVar1;
	RewardFrontEnd *pRVar2;
	undefined4 *puVar3;
	int iVar4;
	undefined4 *puVar5;
	undefined4 local_198 [102];
	
	pLVar1 = game::GetLevel();
	if (pLVar1 == (LevelData *)0x0) {
		return;
	}
	pRVar2 = reward::GetRewardFrontEnd(pLVar1->field_10);
	if (pRVar2 == (RewardFrontEnd *)0x0) {
		return;
	}
	puVar3 = (undefined4 *)FUN_00460550(local_198);
	puVar5 = UNKSTRUCT_198_005539c4;
	for (iVar4 = 0x66; iVar4 != 0; iVar4 = iVar4 + -1) {
		*puVar5 = *puVar3;
		puVar3 = puVar3 + 1;
		puVar5 = puVar5 + 1;
	}
	UINT_00556118 = game::Game_GetPilotPreviousLevel("Pilot",0);
	return;
}



undefined4 * __cdecl FUN_00460550(undefined4 *param_1)
{
	uint uVar1;
	int iVar2;
	uint objLevel;
	undefined4 *puVar3;
	uint objIndex;
	undefined4 *puVar4;
	undefined4 local_198 [100];
	float local_8;
	float local_4;
	
	local_8 = 0.0;
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
						(lego::unk::Callback_FUN_004605d0,(LiveObject *)local_198);
	local_4 = 0.0;
	objIndex = 0;
	do {
		objLevel = 0;
		do {
			uVar1 = lego::game::LiveObject_GetPreviousLevel(OBJECT_BUILDING,objIndex,objLevel);
			objLevel = objLevel + 1;
			local_4 = (float)((int)local_4 + uVar1);
		} while (objLevel < 0x10);
		objIndex = objIndex + 1;
	} while (objIndex < 0xf);
	puVar3 = local_198;
	puVar4 = param_1;
	for (iVar2 = 0x66; iVar2 != 0; iVar2 = iVar2 + -1) {
		*puVar4 = *puVar3;
		puVar3 = puVar3 + 1;
		puVar4 = puVar4 + 1;
	}
	return param_1;
}



BOOL __cdecl lego::unk::Callback_FUN_004605d0(LiveObject *liveObj,int param_2)
{
	int iVar1;
	char *pcVar2;
	int local_4;
	
	game::LiveObject_GetTypeIndex(liveObj,(int *)&liveObj,&local_4);
	iVar1 = param_2;
	if (liveObj == (LiveObject *)&DAT_00000004) {
		pcVar2 = game::Object_GetTypeName(OBJECT_BUILDING,local_4);
		*(char **)(iVar1 + *(int *)(iVar1 + 400) * 4) = pcVar2;
		*(int *)(iVar1 + 400) = *(int *)(iVar1 + 400) + 1;
	}
	return 0;
}



BOOL __cdecl FUN_00460620(void)
{
	undefined *puVar1;
	TerrainType TVar2;
	float fVar3;
	int iVar4;
	int iVar5;
	LevelData *pLVar6;
	RewardFrontEnd *pRVar7;
	SurfaceMap *pSVar8;
	int iVar9;
	ImageBMP *pIVar10;
	uint uVar11;
	undefined4 *puVar12;
	IDirectDrawSurface4 **ppIVar13;
	undefined4 *puVar14;
	uint uVar15;
	char *pcVar16;
	float10 fVar17;
	ulonglong uVar18;
	uint local_30;
	uint local_28;
	uint local_24;
	int local_20;
	int local_1c;
	Point2I local_18;
	uint local_10;
	undefined4 uStack12;
	uint local_8;
	undefined4 uStack4;
	
	pLVar6 = lego::game::GetLevel();
	if (pLVar6 == (LevelData *)0x0) {
		return 0;
	}
	pRVar7 = lego::reward::GetRewardFrontEnd(pLVar6->field_10);
	if (pRVar7 != (RewardFrontEnd *)0x0) {
		if (lego::globals::g_Save_HasCapture != 0) {
			pIVar10 = &lego::globals::g_Save_CaptureBMP;
			ppIVar13 = (IDirectDrawSurface4 **)&pRVar7->field_0x8;
			for (iVar9 = 8; iVar9 != 0; iVar9 = iVar9 + -1) {
				*ppIVar13 = pIVar10->surface;
				pIVar10 = (ImageBMP *)&pIVar10->width;
				ppIVar13 = ppIVar13 + 1;
			}
			*(undefined4 *)&pRVar7->field_0x4 = 1;
		}
		*(undefined4 *)&pRVar7->items_TABLE[0].field_0x30 = 0;
		*(undefined4 *)&pRVar7->items_TABLE[1].field_0x30 = 0;
		*(float *)&pRVar7->items_TABLE[2].field_0x34 = FLOAT_00555adc;
		*(float *)&pRVar7->items_TABLE[4].field_0x34 = FLOAT_00555efc;
		*(undefined4 *)&pRVar7->items_TABLE[2].field_0x30 = 0;
		*(undefined4 *)&pRVar7->field_0x1b04 = 0;
		*(undefined4 *)&pRVar7->field_0x1b08 = 0;
		iVar9 = FUN_00460bd0("Pilot",0,0);
		*(int *)&pRVar7->items_TABLE[5].field_0x3c = iVar9;
		*(uint *)&pRVar7->items_TABLE[5].field_0x40 = UINT_00556118;
		*(float *)&pRVar7->items_TABLE[5].field_0x48 = FLOAT_00556120;
		uVar15 = UINT_00556324;
		*(uint *)&pRVar7->items_TABLE[6].field_0x3c = UINT_00556324;
		*(int *)&pRVar7->items_TABLE[6].field_0x40 = lego::globals::nerps::g_NERPs_RockMonstersDestroyed
		;
		fVar3 = (float)(ulonglong)(uVar15 * 100);
		if ((ushort)((ushort)(FLOAT_00556330 < fVar3) << 8 | (ushort)(FLOAT_00556330 == fVar3) << 0xe)
				!= 0) {
			fVar3 = FLOAT_00556330;
		}
		*(float *)&pRVar7->items_TABLE[6].field_0x48 = fVar3;
		*(uint *)&pRVar7->items_TABLE[6].field_0x44 = UINT_0055632c;
		puVar12 = UNKSTRUCT_198_005539c4;
		puVar14 = (undefined4 *)&pRVar7->field_0x28;
		for (iVar9 = 0x66; iVar9 != 0; iVar9 = iVar9 + -1) {
			*puVar14 = *puVar12;
			puVar12 = puVar12 + 1;
			puVar14 = puVar14 + 1;
		}
		uVar15 = 0;
		*(undefined4 *)&pRVar7->field_0x1c8 = 0;
		fVar3 = (lego::globals::g_Game.level)->oxygenLevel;
		*(undefined **)&pRVar7->items_TABLE[7].field_0x30 = &DAT_42c80000;
		*(float *)&pRVar7->items_TABLE[7].field_0x34 = fVar3;
		*(float *)&pRVar7->items_TABLE[8].field_0x34 = FLOAT_0055673c;
		*(float *)&pRVar7->items_TABLE[8].field_0x30 =
				 FLOAT_00556738 / *(float *)&pRVar7->items_TABLE[8].field_0x34;
		pSVar8 = pLVar6->surfaceMap;
		if ((pSVar8->smallDimensions).width != 0) {
			do {
				uVar11 = 0;
				if ((pSVar8->smallDimensions).height != 0) {
					do {
						TVar2 = pLVar6->blocks[uVar11 * (pLVar6->dimensions).width + uVar15].terrain;
						*(int *)&pRVar7->field_0x1c8 = *(int *)&pRVar7->field_0x1c8 + 1;
						local_18.x = uVar15;
						local_18.y = uVar11;
						lego::game::Level_GetBlockCryOre
											(&local_18,(int *)&local_28,&local_1c,(int *)&local_24,&local_20);
						local_10 = local_28;
						uStack12 = 0;
						uStack4 = 0;
						*(float *)&pRVar7->items_TABLE[0].field_0x30 =
								 (float)(ulonglong)local_28 + *(float *)&pRVar7->items_TABLE[0].field_0x30;
						local_8 = local_24;
						*(float *)&pRVar7->items_TABLE[1].field_0x30 =
								 (float)(ulonglong)local_24 + *(float *)&pRVar7->items_TABLE[1].field_0x30;
						if ((*(byte *)&pLVar6->blocks[uVar11 * (pLVar6->dimensions).width + uVar15].flags1 & 8)
								== 0) {
							if (TVar2 != TERRAIN_IMMOVABLE) {
								*(float *)&pRVar7->items_TABLE[2].field_0x30 =
										 *(float *)&pRVar7->items_TABLE[2].field_0x30 - -1.0;
								*(float *)&pRVar7->field_0x1b04 = *(float *)&pRVar7->field_0x1b04 - -1.0;
							}
							if (TVar2 == TERRAIN_CRYSTALSEAM) {
								*(float *)&pRVar7->items_TABLE[0].field_0x30 =
										 *(float *)&pRVar7->items_TABLE[0].field_0x30 - -4.0;
							}
						}
						else {
							if ((TVar2 != TERRAIN_WATER_unused) && (TVar2 != TERRAIN_LAVA)) {
								*(float *)&pRVar7->field_0x1b04 = *(float *)&pRVar7->field_0x1b04 - -1.0;
							}
						}
						if ((pLVar6->blocks[uVar11 * (pLVar6->dimensions).width + uVar15].flags1 & 0x61100000)
								!= BLOCK1_NONE) {
							*(float *)&pRVar7->field_0x1b08 = *(float *)&pRVar7->field_0x1b08 - -1.0;
							*(float *)&pRVar7->items_TABLE[2].field_0x30 =
									 *(float *)&pRVar7->items_TABLE[2].field_0x30 - -1.0;
						}
						uVar11 = uVar11 + 1;
					} while (uVar11 < (uint)(pLVar6->surfaceMap->smallDimensions).height);
				}
				pSVar8 = pLVar6->surfaceMap;
				uVar15 = uVar15 + 1;
			} while (uVar15 < (uint)(pSVar8->smallDimensions).width);
		}
		fVar3 = *(float *)&pRVar7->items_TABLE[2].field_0x30;
		iVar9 = *(int *)&pRVar7->field_0x1b8;
		*(int *)&pRVar7->field_0x1cc = iVar9;
		*(undefined4 *)&pRVar7->field_0x1d0 = *(undefined4 *)&pRVar7->field_0x1bc;
		local_30 = 0;
		*(float *)&pRVar7->items_TABLE[1].field_0x30 =
				 *(float *)&pRVar7->items_TABLE[1].field_0x30 - fVar3 * -4.0;
		if (iVar9 != 0) {
			pcVar16 = (char *)&pRVar7->field_0x1d4;
			puVar12 = (undefined4 *)&pRVar7->field_0x28;
			do {
				std::sprintf(pcVar16,"%s",*puVar12);
				local_30 = local_30 + 1;
				puVar12 = puVar12 + 1;
				pcVar16 = pcVar16 + 0x40;
			} while (local_30 < *(uint *)&pRVar7->field_0x1cc);
		}
		uVar15 = *(uint *)&pRVar7->items_TABLE[5].field_0x3c;
		iVar9 = *(int *)&pRVar7->field_0x1d0;
		*(float *)&pRVar7->items_TABLE[0].field_0x34 = (float)(ulonglong)(uint)pLVar6->numCrystals;
		iVar4 = *(int *)&pRVar7->items_TABLE[5].field_0x40;
		*(float *)&pRVar7->items_TABLE[1].field_0x34 = (float)(ulonglong)(uint)pLVar6->numOre;
		iVar5 = *(int *)&pRVar7->items_TABLE[6].field_0x3c;
		*(float *)&pRVar7->items_TABLE[5].field_0x30 = (float)(ulonglong)uVar15;
		*(float *)&pRVar7->items_TABLE[5].field_0x34 = (float)(ulonglong)(uVar15 - iVar4);
		*(undefined4 *)&pRVar7->items_TABLE[6].field_0x34 =
				 *(undefined4 *)&pRVar7->items_TABLE[6].field_0x48;
		uVar15 = *(uint *)&pRVar7->field_0x1cc;
		*(float *)&pRVar7->items_TABLE[6].field_0x30 = (float)(ulonglong)(uint)(iVar5 * 100);
		uVar11 = (uVar15 - iVar9) + 1;
		local_8 = pRVar7->items_TABLE[8].Quota;
		*(float *)&pRVar7->items_TABLE[3].field_0x30 = (float)(ulonglong)uVar15;
		*(float *)&pRVar7->items_TABLE[3].field_0x34 = (float)(ulonglong)uVar11;
		if (local_8 == 0) {
			*(undefined4 *)&pRVar7->items_TABLE[8].field_0x38 = 0;
			local_8 = uVar11;
		}
		else {
			fVar17 = (float10)*(float *)&pRVar7->items_TABLE[8].field_0x34 * (float10)0.04;
			uStack4 = 0;
			if ((float10)(ulonglong)local_8 <= fVar17) {
				*(undefined **)&pRVar7->items_TABLE[8].field_0x38 = &DAT_42c80000;
			}
			else {
				uVar18 = __ftol(((float10)100.0 / (float10)(ulonglong)local_8) * fVar17);
				*(float *)&pRVar7->items_TABLE[8].field_0x38 = (float)(uVar18 & 0xffffffff);
				fVar3 = *(float *)&pRVar7->items_TABLE[8].field_0x38;
				if ((ushort)((ushort)(fVar3 < 100.0) << 8 | (ushort)(fVar3 == 100.0) << 0xe) == 0) {
					puVar1 = &DAT_42c80000;
				}
				else {
					puVar1 = *(undefined **)&pRVar7->items_TABLE[8].field_0x38;
				}
				*(undefined **)&pRVar7->items_TABLE[8].field_0x38 = puVar1;
				if ((float)puVar1 < 0.0) {
					puVar1 = (undefined *)0x0;
				}
				*(undefined **)&pRVar7->items_TABLE[8].field_0x38 = puVar1;
				local_8 = (uint)uVar18;
			}
		}
		uVar15 = pRVar7->items_TABLE[3].Quota;
		if (uVar15 != 0) {
			uVar18 = 100 / (ulonglong)uVar15;
			local_8 = (uint)uVar18;
			*(float *)&pRVar7->items_TABLE[3].field_0x38 =
					 (float)uVar18 * *(float *)&pRVar7->items_TABLE[3].field_0x34;
		}
		uVar15 = pRVar7->items_TABLE[4].Quota;
		if (uVar15 != 0) {
			uVar18 = 100 / (ulonglong)uVar15;
			local_8 = (uint)uVar18;
			*(float *)&pRVar7->items_TABLE[4].field_0x38 =
					 (float)uVar18 * *(float *)&pRVar7->items_TABLE[4].field_0x34;
		}
		uVar15 = pRVar7->items_TABLE[0].Quota;
		if (uVar15 != 0) {
			*(float *)&pRVar7->items_TABLE[0].field_0x30 = (float)(ulonglong)uVar15;
			local_8 = uVar15;
		}
		uStack4 = 0;
		uVar15 = 0;
		do {
			if (uVar15 != 0x1080) {
				pcVar16 = pRVar7->items_PTR->name + (uVar15 - 4);
				if ((ushort)((ushort)(*(float *)(pcVar16 + 0x38) < 100.0) << 8 |
										(ushort)(*(float *)(pcVar16 + 0x38) == 100.0) << 0xe) == 0) {
					puVar1 = &DAT_42c80000;
				}
				else {
					puVar1 = *(undefined **)(pcVar16 + 0x38);
				}
				*(undefined **)(pcVar16 + 0x38) = puVar1;
				if ((float)puVar1 < 0.0) {
					puVar1 = (undefined *)0x0;
				}
				*(undefined **)(pcVar16 + 0x38) = puVar1;
			}
			uVar15 = uVar15 + 0x210;
		} while (uVar15 < 0x14a0);
		FUN_00460c10();
		lego::reward::Reward_FUN_004611c0();
		puVar12 = &DATSTRUCT_318c_0055399c;
		for (iVar9 = 0xc63; iVar9 != 0; iVar9 = iVar9 + -1) {
			*puVar12 = 0;
			puVar12 = puVar12 + 1;
		}
		return 1;
	}
	return 0;
}



int __cdecl FUN_00460bd0(char *param_1,int param_2,int param_3)
{
	BOOL BVar1;
	int iVar2;
	ObjectType local_4;
	
	BVar1 = lego::game::Object_GetObjectByName(param_1,&local_4,(int *)&param_1,(Container **)0x0);
	if (BVar1 != 0) {
		iVar2 = lego::game::LiveObject_GetOrSubLevelsTable(local_4,(int)param_1,param_2,param_3);
		return iVar2;
	}
	return 0;
}



BOOL __cdecl FUN_00460c10(void)
{
	float fVar1;
	float fVar2;
	float fVar3;
	undefined *puVar4;
	LevelData *pLVar5;
	RewardFrontEnd *pRVar6;
	uint uVar7;
	
	pLVar5 = lego::game::GetLevel();
	if (pLVar5 == (LevelData *)0x0) {
		return 0;
	}
	pRVar6 = lego::reward::GetRewardFrontEnd(pLVar5->field_10);
	if (pRVar6 == (RewardFrontEnd *)0x0) {
		return 0;
	}
	*(undefined4 *)&pRVar6->items_TABLE[9].field_0x34 = 0;
	*(undefined4 *)&pRVar6->items_TABLE[9].field_0x30 = 0;
	*(undefined4 *)&pRVar6->items_TABLE[9].field_0x38 = 0;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[0].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[0].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[0].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[0].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[0].field_0x38 = puVar4;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[1].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[1].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[1].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[1].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[1].field_0x38 = puVar4;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[2].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[2].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[2].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[2].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[2].field_0x38 = puVar4;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->field_0x1b04 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->field_0x1b04) * *(float *)&pRVar6->field_0x1b08);
	}
	*(undefined **)&pRVar6->field_0x1b0c = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->field_0x1b0c = puVar4;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[7].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[7].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[7].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[7].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[7].field_0x38 = puVar4;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[3].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[3].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[3].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[3].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[3].field_0x38 = puVar4;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[5].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[5].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[5].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[5].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[5].field_0x38 = puVar4;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[6].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[6].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[6].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[6].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[6].field_0x38 = puVar4;
	uVar7 = 0;
	if (0.0 < pRVar6->items_TABLE[5].Importance) {
		do {
			uVar7 = uVar7 + 1;
			fVar1 = *(float *)&pRVar6->items_TABLE[5].field_0x38;
			fVar2 = pRVar6->items_TABLE[5].Importance;
			fVar3 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
			*(float *)&pRVar6->items_TABLE[9].field_0x30 =
					 *(float *)&pRVar6->items_TABLE[9].field_0x30 - -100.0;
			*(float *)&pRVar6->items_TABLE[9].field_0x34 = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items_TABLE[0].Importance) {
		do {
			uVar7 = uVar7 + 1;
			fVar1 = *(float *)&pRVar6->items_TABLE[0].field_0x38;
			fVar2 = pRVar6->items_TABLE[0].Importance;
			fVar3 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
			*(float *)&pRVar6->items_TABLE[9].field_0x30 =
					 *(float *)&pRVar6->items_TABLE[9].field_0x30 - -100.0;
			*(float *)&pRVar6->items_TABLE[9].field_0x34 = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items_TABLE[7].Importance) {
		do {
			uVar7 = uVar7 + 1;
			fVar1 = *(float *)&pRVar6->items_TABLE[7].field_0x38;
			fVar2 = pRVar6->items_TABLE[7].Importance;
			fVar3 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
			*(float *)&pRVar6->items_TABLE[9].field_0x30 =
					 *(float *)&pRVar6->items_TABLE[9].field_0x30 - -100.0;
			*(float *)&pRVar6->items_TABLE[9].field_0x34 = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items_TABLE[3].Importance) {
		do {
			uVar7 = uVar7 + 1;
			fVar1 = *(float *)&pRVar6->items_TABLE[3].field_0x38;
			fVar2 = pRVar6->items_TABLE[3].Importance;
			fVar3 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
			*(float *)&pRVar6->items_TABLE[9].field_0x30 =
					 *(float *)&pRVar6->items_TABLE[9].field_0x30 - -100.0;
			*(float *)&pRVar6->items_TABLE[9].field_0x34 = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items_TABLE[4].Importance) {
		do {
			uVar7 = uVar7 + 1;
			fVar1 = *(float *)&pRVar6->items_TABLE[4].field_0x38;
			fVar2 = pRVar6->items_TABLE[4].Importance;
			fVar3 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
			*(float *)&pRVar6->items_TABLE[9].field_0x30 =
					 *(float *)&pRVar6->items_TABLE[9].field_0x30 - -100.0;
			*(float *)&pRVar6->items_TABLE[9].field_0x34 = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items_TABLE[8].Importance) {
		fVar1 = *(float *)&pRVar6->items_TABLE[9].field_0x30;
		fVar2 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
		do {
			uVar7 = uVar7 + 1;
			fVar1 = fVar1 - -100.0;
			fVar2 = (100.0 - *(float *)&pRVar6->items_TABLE[8].field_0x38) + fVar2;
		} while ((float)(ulonglong)uVar7 < pRVar6->items_TABLE[8].Importance);
		*(float *)&pRVar6->items_TABLE[9].field_0x34 = fVar2;
		*(float *)&pRVar6->items_TABLE[9].field_0x30 = fVar1;
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items_TABLE[6].Importance) {
		do {
			uVar7 = uVar7 + 1;
			fVar1 = *(float *)&pRVar6->items_TABLE[6].field_0x38;
			fVar2 = pRVar6->items_TABLE[6].Importance;
			fVar3 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
			*(float *)&pRVar6->items_TABLE[9].field_0x30 =
					 *(float *)&pRVar6->items_TABLE[9].field_0x30 - -100.0;
			*(float *)&pRVar6->items_TABLE[9].field_0x34 = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	fVar1 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
	fVar2 = *(float *)&pRVar6->items_TABLE[9].field_0x30;
	if ((ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) == 0) {
		*(undefined4 *)&pRVar6->items_TABLE[9].field_0x34 =
				 *(undefined4 *)&pRVar6->items_TABLE[9].field_0x30;
	}
	if (*(float *)&pRVar6->items_TABLE[9].field_0x34 < 0.0) {
		*(undefined4 *)&pRVar6->items_TABLE[9].field_0x34 = 0;
	}
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[9].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[9].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[9].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[9].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[9].field_0x38 = puVar4;
	puVar4 = (undefined *)
					 ((float)(ulonglong)(uint)pRVar6->Modifier + *(float *)&pRVar6->items_TABLE[9].field_0x38)
	;
	*(undefined **)&pRVar6->items_TABLE[9].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[9].field_0x38 = puVar4;
	return 1;
}



BOOL __cdecl lego::reward::Reward_FUN_004611c0(void)
{
	LevelCompleteStatus LVar1;
	float fVar2;
	float fVar3;
	LevelData *level;
	RewardFrontEnd *rewardFront;
	char *pcVar4;
	
	fVar2 = (float)globs::mainGlobs.appHeight;
	fVar3 = (float)globs::mainGlobs.appWidth;
	level = game::GetLevel();
	if (level == (LevelData *)0x0) {
		return 0;
	}
	rewardFront = GetRewardFrontEnd(level->field_10);
	if (rewardFront != (RewardFrontEnd *)0x0) {
		Reward_FUN_00461330();
		Reward_CreateStruct28
							(&REWARDSTRUCT28_00556b5c,0,fVar2 * 0.05,fVar3,fVar2 - fVar2 * 0.2857143,
							 globals::g_Reward_ScrollSpeed);
		Reward_Struct_SetFloat18(REWARDSTRUCT28_00556b5c,400.0);
		Reward_Struct_OrFlags24(REWARDSTRUCT28_00556b5c,0);
		front::Reward_FUN_00462c90
							(REWARDSTRUCT28_00556b5c,level->FullName,globals::g_Reward_TitleFont,0,
							 (int)((float)globs::mainGlobs.appHeight * 0.04),3);
		LVar1 = level->status;
		pcVar4 = globals::g_Reward_CompleteText;
		if (((LVar1 == LEVELSTATUS_COMPLETE) ||
				(pcVar4 = globals::g_Reward_FailedText, LVar1 == LEVELSTATUS_FAILED)) ||
			 (pcVar4 = globals::g_Reward_QuitText, LVar1 == LEVELSTATUS_FAILED_CRYSTALS)) {
			pcVar4 = util::Util_RemoveUnderscores(pcVar4);
			std::sprintf(globals::g_LevelStatusMessage_text,"%s",pcVar4);
		}
		front::Reward_FUN_00462c90
							(REWARDSTRUCT28_00556b5c,globals::g_LevelStatusMessage_text,globals::g_Reward_Font,0,
							 (int)globals::g_Reward_VertSpacing,1);
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::reward::Reward_FUN_00461330(void)
{
	char cVar1;
	undefined4 uVar2;
	LevelData *pLVar3;
	RewardFrontEnd *pRVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	undefined4 *puVar9;
	char *pcVar10;
	char *pcVar11;
	undefined4 *puVar12;
	float10 fVar13;
	longlong lVar14;
	ulonglong uVar15;
	char *pcVar16;
	undefined **format;
	char local_100 [128];
	char local_80 [128];
	
	pLVar3 = game::GetLevel();
	if (pLVar3 == (LevelData *)0x0) {
		return 0;
	}
	pRVar4 = GetRewardFrontEnd(pLVar3->field_10);
	if (pRVar4 == (RewardFrontEnd *)0x0) {
		return 0;
	}
	lVar14 = __ftol((float10)*(float *)&pRVar4->items_TABLE[0].field_0x38);
	*(int *)&pRVar4->items_TABLE[0].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[0].Text + 0x80,"%d%%%%",(int)lVar14);
	lVar14 = __ftol((float10)*(float *)&pRVar4->items_TABLE[1].field_0x38);
	*(int *)&pRVar4->items_TABLE[1].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[1].Text + 0x80,"%d%%%%",(int)lVar14);
	lVar14 = __ftol((float10)*(float *)&pRVar4->items_TABLE[2].field_0x38);
	*(int *)&pRVar4->items_TABLE[2].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[2].Text + 0x80,"%d%%%%",(int)lVar14);
	lVar14 = __ftol((float10)*(float *)&pRVar4->field_0x1b0c);
	*(int *)&pRVar4->field_0x1b24 = (int)lVar14;
	std::sprintf((char *)&pRVar4->field_0x1ba8,"%d",(int)lVar14);
	uVar2 = *(undefined4 *)&pRVar4->field_0x1cc;
	*(undefined4 *)&pRVar4->items_TABLE[3].field_0x50 = uVar2;
	std::sprintf(pRVar4->items_TABLE[3].Text + 0x80,"%d",uVar2);
	lVar14 = __ftol((float10)*(float *)&pRVar4->items_TABLE[4].field_0x38);
	*(int *)&pRVar4->items_TABLE[4].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[4].Text + 0x80,"%d%%%%",(int)lVar14);
	lVar14 = __ftol((float10)*(float *)&pRVar4->items_TABLE[5].field_0x38);
	*(int *)&pRVar4->items_TABLE[5].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[5].Text + 0x80,"%d%%%%",(int)lVar14);
	if (100.0 <= *(float *)&pRVar4->items_TABLE[6].field_0x48) {
		fVar13 = (float10)100.0;
	}
	else {
		fVar13 = (float10)*(float *)&pRVar4->items_TABLE[6].field_0x48;
	}
	lVar14 = __ftol(fVar13);
	*(int *)&pRVar4->items_TABLE[6].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[6].Text + 0x80,"%d%%%%",(int)lVar14);
	lVar14 = __ftol((float10)*(float *)&pRVar4->items_TABLE[7].field_0x38);
	*(int *)&pRVar4->items_TABLE[7].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[7].Text + 0x80,"%d%%%%",(int)lVar14);
	uVar15 = __ftol((float10)*(float *)&pRVar4->items_TABLE[8].field_0x34 *
									(float10)*(float *)&pRVar4->items_TABLE[8].field_0x30 * (float10)0.04);
	*(int *)&pRVar4->items_TABLE[8].field_0x50 = (int)uVar15;
	uVar6 = (uint)((uVar15 & 0xffffffff) % 359999);
	std::sprintf(local_80,____EMPTYSTR__);
	if (uVar6 < 0xe11) {
		pcVar16 = "00:";
	}
	else {
		uVar7 = (uVar6 - 1) / 0xe10;
		uVar8 = uVar7;
		do {
			uVar6 = uVar6 - 0xe10;
			uVar8 = uVar8 - 1;
		} while (uVar8 != 0);
		if (uVar7 < 10) {
			pcVar16 = "0%d:";
		}
		else {
			pcVar16 = "%d:";
		}
		std::sprintf(local_100,pcVar16,uVar7);
		pcVar16 = local_100;
	}
	uVar8 = 0xffffffff;
	do {
		pcVar10 = pcVar16;
		if (uVar8 == 0) break;
		uVar8 = uVar8 - 1;
		pcVar10 = pcVar16 + 1;
		cVar1 = *pcVar16;
		pcVar16 = pcVar10;
	} while (cVar1 != '\0');
	uVar8 = ~uVar8;
	iVar5 = -1;
	pcVar16 = local_80;
	do {
		pcVar11 = pcVar16;
		if (iVar5 == 0) break;
		iVar5 = iVar5 + -1;
		pcVar11 = pcVar16 + 1;
		cVar1 = *pcVar16;
		pcVar16 = pcVar11;
	} while (cVar1 != '\0');
	puVar9 = (undefined4 *)(pcVar10 + -uVar8);
	puVar12 = (undefined4 *)(pcVar11 + -1);
	for (uVar7 = uVar8 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
		*puVar12 = *puVar9;
		puVar9 = puVar9 + 1;
		puVar12 = puVar12 + 1;
	}
	for (uVar8 = uVar8 & 3; uVar8 != 0; uVar8 = uVar8 - 1) {
		*(undefined *)puVar12 = *(undefined *)puVar9;
		puVar9 = (undefined4 *)((int)puVar9 + 1);
		puVar12 = (undefined4 *)((int)puVar12 + 1);
	}
	if (uVar6 < 0x3d) {
		pcVar16 = "00.";
	}
	else {
		uVar7 = (uVar6 - 1) / 0x3c;
		uVar8 = uVar7;
		do {
			uVar6 = uVar6 - 0x3c;
			uVar8 = uVar8 - 1;
		} while (uVar8 != 0);
		if (uVar7 < 10) {
			pcVar16 = "0%d.";
		}
		else {
			pcVar16 = "%d.";
		}
		std::sprintf(local_100,pcVar16,uVar7);
		pcVar16 = local_100;
	}
	uVar8 = 0xffffffff;
	do {
		pcVar10 = pcVar16;
		if (uVar8 == 0) break;
		uVar8 = uVar8 - 1;
		pcVar10 = pcVar16 + 1;
		cVar1 = *pcVar16;
		pcVar16 = pcVar10;
	} while (cVar1 != '\0');
	uVar8 = ~uVar8;
	iVar5 = -1;
	pcVar16 = local_80;
	do {
		pcVar11 = pcVar16;
		if (iVar5 == 0) break;
		iVar5 = iVar5 + -1;
		pcVar11 = pcVar16 + 1;
		cVar1 = *pcVar16;
		pcVar16 = pcVar11;
	} while (cVar1 != '\0');
	puVar9 = (undefined4 *)(pcVar10 + -uVar8);
	puVar12 = (undefined4 *)(pcVar11 + -1);
	for (uVar7 = uVar8 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
		*puVar12 = *puVar9;
		puVar9 = puVar9 + 1;
		puVar12 = puVar12 + 1;
	}
	for (uVar8 = uVar8 & 3; uVar8 != 0; uVar8 = uVar8 - 1) {
		*(undefined *)puVar12 = *(undefined *)puVar9;
		puVar9 = (undefined4 *)((int)puVar9 + 1);
		puVar12 = (undefined4 *)((int)puVar12 + 1);
	}
	if (uVar6 < 2) {
		pcVar16 = "00";
	}
	else {
		if (uVar6 - 1 < 10) {
			format = &PTR_checkGlobs_loadedList_810__848__004aa4a0;
		}
		else {
			format = (undefined **)"%d";
		}
		std::sprintf(local_100,(char *)format,uVar6 - 1);
		pcVar16 = local_100;
	}
	uVar6 = 0xffffffff;
	do {
		pcVar10 = pcVar16;
		if (uVar6 == 0) break;
		uVar6 = uVar6 - 1;
		pcVar10 = pcVar16 + 1;
		cVar1 = *pcVar16;
		pcVar16 = pcVar10;
	} while (cVar1 != '\0');
	uVar6 = ~uVar6;
	iVar5 = -1;
	pcVar16 = local_80;
	do {
		pcVar11 = pcVar16;
		if (iVar5 == 0) break;
		iVar5 = iVar5 + -1;
		pcVar11 = pcVar16 + 1;
		cVar1 = *pcVar16;
		pcVar16 = pcVar11;
	} while (cVar1 != '\0');
	puVar9 = (undefined4 *)(pcVar10 + -uVar6);
	puVar12 = (undefined4 *)(pcVar11 + -1);
	for (uVar8 = uVar6 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {
		*puVar12 = *puVar9;
		puVar9 = puVar9 + 1;
		puVar12 = puVar12 + 1;
	}
	for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
		*(undefined *)puVar12 = *(undefined *)puVar9;
		puVar9 = (undefined4 *)((int)puVar9 + 1);
		puVar12 = (undefined4 *)((int)puVar12 + 1);
	}
	std::sprintf(pRVar4->items_TABLE[8].Text + 0x80,"%s",local_80);
	lVar14 = __ftol((float10)*(float *)&pRVar4->items_TABLE[9].field_0x38);
	*(int *)&pRVar4->items_TABLE[9].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[9].Text + 0x80,"%d%%%%",(int)lVar14);
	return 1;
}



BOOL __cdecl lego::main::Main_waitFrontEndRewards__004616d0(void)
{
	LevelData *pLVar1;
	RewardFrontEnd *pRVar2;
	BOOL BVar3;
	VideoPlayer_t *videoPlayer;
	uint uVar4;
	int iVar5;
	char *fName;
	int iVar6;
	uint local_34;
	int local_30;
	float local_2c;
	int local_28;
	float local_24;
	float local_20;
	undefined4 local_1c;
	LevelData *local_18;
	undefined4 uStack20;
	uint local_10;
	undefined4 uStack12;
	uint local_8;
	undefined4 uStack4;
	
	local_30 = 0;
	local_28 = 0;
	local_1c = 0;
	local_34 = 0;
	local_18 = (LevelData *)Main_GetTime();
	uStack20 = 0;
	local_2c = globals::g_Reward_Timer;
	local_24 = (float)ZEXT48(local_18);
	pLVar1 = game::GetLevel();
	if (pLVar1 == (LevelData *)0x0) {
		return 0;
	}
	local_18 = pLVar1;
	pRVar2 = reward::GetRewardFrontEnd(pLVar1->field_10);
	if (pRVar2 != (RewardFrontEnd *)0x0) {
		BVar3 = front::Reward_UIUpdate_FUN_00462a40();
		if (BVar3 != 0) {
			while (((local_30 < 4 || (globs::INPUT.mslb != 0)) || (globs::INPUT.lClicked != 0))) {
				local_10 = Main_GetTime();
				uStack12 = 0;
				local_20 = ((float)(ulonglong)local_10 - local_24) * 0.001;
				local_8 = Main_GetTime();
				uStack4 = 0;
				local_24 = (float)(ulonglong)local_8;
				local_2c = local_20 + local_2c;
				FUN_00462760((int *)&local_34,&local_30,&local_2c);
				if ((((globs::INPUT.Key_Map[57] == false) && (globs::INPUT.prevKey_Map[57] != false)) ||
						(globs::INPUT.lClicked != 0)) && (local_30 < 3)) {
					local_30 = local_30 + 1;
					if (local_30 == 3) {
						local_30 = 2;
					}
					if ((local_30 < 2) || (pLVar1->status != LEVELSTATUS_COMPLETE)) {
						local_34 = 9;
					}
					else {
						local_34 = 10;
					}
				}
				if (globals::g_Reward_Wallpaper != (ImageBMP *)0x0) {
					image::Image_DisplayScaled
										(globals::g_Reward_Wallpaper,(Rect2F *)0x0,(Point2F *)0x0,(Size2F *)0x0);
				}
				iVar5 = 0;
				if (0 < (int)local_34) {
					iVar6 = 0;
					do {
						front::Reward_FUN_00461a50((uint *)(pRVar2->items_PTR->name + iVar6 + -4),2,local_34);
						iVar5 = iVar5 + 1;
						iVar6 = iVar6 + 0x210;
					} while (iVar5 < (int)local_34);
				}
				iVar6 = 0;
				iVar5 = 0;
				while( true ) {
					uVar4 = local_34;
					if (9 < (int)local_34) {
						uVar4 = 9;
					}
					if ((int)uVar4 <= iVar6) break;
					front::Reward_FUN_00461a50((uint *)(pRVar2->items_PTR->name + iVar5 + -4),0x40,local_34);
					iVar6 = iVar6 + 1;
					iVar5 = iVar5 + 0x210;
				}
				iVar5 = 0;
				if (0 < (int)local_34) {
					iVar6 = 0;
					do {
						front::Reward_FUN_00461a50((uint *)(pRVar2->items_PTR->name + iVar6 + -4),4,local_34);
						iVar5 = iVar5 + 1;
						iVar6 = iVar6 + 0x210;
					} while (iVar5 < (int)local_34);
				}
				FUN_004628c0(&local_34,&local_28);
				if ((local_28 != 0) && (FUN_00461f50(local_34), local_30 < 3)) {
					front::Reward_FUN_00462090(&local_30,&local_1c);
				}
				FUN_00462d90((float *)REWARDSTRUCT28_00556b5c);
				if (local_30 == 3) {
					local_30 = 4;
				}
				front::Reward_FUN_00462650(&local_34,&local_30,&local_28,&local_2c);
				unk::Lego_UnkUpdateAndRender_004629c0(local_20);
				pLVar1 = local_18;
			}
			front::Reward_FUN_00462c20(&REWARDSTRUCT28_00556b5c);
			iVar5 = 0;
			do {
				if ((pRVar2->items_PTR->name[iVar5 + -4] & 4U) != 0) {
					image::Flic_Close(*(ImageFlic **)(&pRVar2->items_PTR->field_0x1fc + iVar5));
					*(undefined4 *)(&pRVar2->items_PTR->field_0x1fc + iVar5) = 0;
				}
				iVar5 = iVar5 + 0x210;
			} while (iVar5 < 0x14a0);
			snd::Sound3D_Stream_Stop(1);
			if ((pLVar1->status == LEVELSTATUS_COMPLETE) && (globals::g_Game.EndGameAVI1 != (char *)0x0))
			{
				BVar3 = FUN_00418050();
				if ((BVar3 == 0) ||
					 (fName = globals::g_Game.EndGameAVI2, globals::g_Game.EndGameAVI2 == (char *)0x0)) {
					fName = globals::g_Game.EndGameAVI1;
				}
				BVar3 = lego::file::File_Exists(fName);
				if (BVar3 != 0) {
					videoPlayer = video::VideoPlayer_Open(fName);
					video::VideoPlayer_Play(videoPlayer,0);
					video::VideoPlayer_Close(videoPlayer);
				}
				snd::Audio_AddToSoundQueue1(SFX_AMBIENTMUSICLOOP,1);
				front::MainMenuFull_TriggerShowCredits();
				snd::Sound3D_Stream_Stop(1);
			}
			return 1;
		}
		return 0;
	}
	return 0;
}



void __cdecl lego::front::Reward_FUN_00461a50(uint *param_1,uint param_2,uint param_3)
{
	char *pcVar1;
	RewardFrontEndItem *pRVar2;
	ImageFlic *fsp;
	int iVar3;
	uint uVar4;
	Point2F local_3c;
	undefined4 local_34;
	Point2F local_30;
	undefined4 local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	Rect2F local_10;
	
	if (param_3 == 0) {
		iVar3 = 0;
	}
	else {
		iVar3 = param_3 - 1;
	}
	pRVar2 = globals::g_RewardFrontLevel->items_PTR;
	if (((globals::g_Reward_DisplayImages != 0) && ((*(byte *)param_1 & 2) != 0)) &&
		 ((param_2 & 2) != 0)) {
		local_3c.x = (float)param_1[0x58];
		local_30.x = (float)(ulonglong)param_1[0x57];
		local_3c.y = 0.0;
		local_30.y = (float)(ulonglong)(uint)local_3c.x;
		image::Image_DisplayScaled((ImageBMP *)param_1[0x80],(Rect2F *)0x0,&local_30,(Size2F *)0x0);
	}
	if (((globals::g_Reward_DisplayImages != 0) && ((*(byte *)param_1 & 0x40) != 0)) &&
		 ((param_2 & 0x40) != 0)) {
		local_30.x = (float)param_1[0x5a];
		local_3c.x = (float)(ulonglong)param_1[0x59];
		local_30.y = 0.0;
		local_3c.y = (float)(ulonglong)(uint)local_30.x;
		image::Image_DisplayScaled((ImageBMP *)param_1[0x83],(Rect2F *)0x0,&local_3c,(Size2F *)0x0);
	}
	if (((globals::g_Reward_DisplayFlics != 0) && ((*(byte *)param_1 & 4) != 0)) &&
		 ((param_2 & 4) != 0)) {
		if (param_1[0x7f] == 0) {
			image::Flic_Setup((char *)(param_1 + 0x5b),(ImageFlic **)(param_1 + 0x7f),FLICDISK);
		}
		local_10.x = (float)(ulonglong)param_1[0x7d];
		local_30.x = (float)param_1[0x7c];
		local_10.y = (float)(ulonglong)param_1[0x7e];
		local_10.width = (float)(ulonglong)param_1[0x7b];
		fsp = (ImageFlic *)param_1[0x7f];
		local_30.y = 0.0;
		local_10.height = (float)(ulonglong)(uint)local_30.x;
		image::Flic_Animate(fsp,&local_10,(uint)(fsp->currentframe < 0x23),0);
	}
	if (globals::g_Reward_DisplayText != 0) {
		if (((*(byte *)param_1 & 1) != 0) && ((param_2 & 1) != 0)) {
			uVar4 = image::FontX_GetStringWidth((ImageFont *)param_1[0x81],(char *)(param_1 + 0x35));
			image::Font_PrintF((ImageFont *)param_1[0x81],param_1[0x55] - (uVar4 >> 1),param_1[0x56],
												 (char *)(param_1 + 0x35));
			if (param_3 < 10) {
				pcVar1 = pRVar2[iVar3].Text;
				uVar4 = image::FontX_GetStringWidth(globals::g_Reward_TitleFont,pcVar1);
				image::Font_PrintF(globals::g_Reward_TitleFont,globals::g_Reward_TextPos.x - (uVar4 >> 1),
													 globals::g_Reward_TextPos.y,pcVar1);
			}
		}
		if ((globals::g_Reward_DisplayText != 0) &&
			 ((((*param_1 & 0x10) != 0 && ((param_2 & 0x10) != 0)) ||
				(((*param_1 & 0x20) != 0 && ((param_2 & 0x20) != 0)))))) {
			local_1c = 0x3df0f0f1;
			local_18 = 0x3df0f0f1;
			local_14 = 0x3df0f0f1;
			local_28 = 0x3e70f0f1;
			local_24 = 0x3e70f0f1;
			local_20 = 0x3e70f0f1;
			local_3c.x = 0.0;
			local_3c.y = 0.0;
			local_34 = 0;
			uVar4 = image::FontX_GetStringWidth((ImageFont *)param_1[0x81],(char *)(param_1 + 0x35));
			local_30.x = (float)(uVar4 + 0x14);
			local_10.x = (float)(ulonglong)((param_1[0x55] - (uVar4 >> 1)) - 10);
			local_10.y = (float)(ulonglong)param_1[0x56];
			local_30.y = 0.0;
			local_10.width = (float)(ulonglong)(uint)local_30.x;
			local_30.x = (float)image::Font_GetHeight((ImageFont *)param_1[0x81]);
			local_30.y = 0.0;
			local_10.height = (float)(ulonglong)(uint)local_30.x;
			FUN_0046bb70(local_10.x,local_10.y,local_10.width,local_10.height,local_1c,local_18,local_14,
									 local_28,local_24,local_20,local_3c.x,local_3c.y,local_34,param_2 & 0x20);
			image::Font_PrintF((ImageFont *)param_1[0x81],param_1[0x55] - (uVar4 >> 1),param_1[0x56],
												 (char *)(param_1 + 0x35));
			if (param_3 < 10) {
				pcVar1 = pRVar2[iVar3].Text;
				uVar4 = image::FontX_GetStringWidth(globals::g_Reward_TitleFont,pcVar1);
				local_30.x = (float)(uVar4 + 0x14);
				local_10.x = (float)(ulonglong)((globals::g_Reward_TextPos.x - (uVar4 >> 1)) - 10);
				local_10.y = (float)(ulonglong)(uint)globals::g_Reward_TextPos.y;
				local_30.y = 0.0;
				local_10.width = (float)(ulonglong)(uint)local_30.x;
				local_30.x = (float)image::Font_GetHeight(globals::g_Reward_TitleFont);
				local_30.y = 0.0;
				local_10.height = (float)(ulonglong)(uint)local_30.x;
				FUN_0046bb70(local_10.x,local_10.y,local_10.width,local_10.height,local_1c,local_18,local_14
										 ,local_28,local_24,local_20,local_3c.x,local_3c.y,local_34,0);
				image::Font_PrintF(globals::g_Reward_TitleFont,globals::g_Reward_TextPos.x - (uVar4 >> 1),
													 globals::g_Reward_TextPos.y,pcVar1);
			}
		}
	}
	return;
}



int __cdecl FUN_00461f50(uint param_1)
{
	char cVar1;
	LevelData *pLVar2;
	RewardFrontEnd *pRVar3;
	uint uVar4;
	RewardFrontEndItem *pRVar5;
	int iVar6;
	char *pcVar7;
	char local_40 [32];
	char local_20 [32];
	
	pLVar2 = lego::game::GetLevel();
	if (pLVar2 == (LevelData *)0x0) {
		return (int)(RewardFrontEnd *)0x0;
	}
	pRVar3 = lego::reward::GetRewardFrontEnd(pLVar2->field_10);
	if (pRVar3 == (RewardFrontEnd *)0x0) {
		return (int)(RewardFrontEnd *)0x0;
	}
	if (pLVar2->status == LEVELSTATUS_COMPLETE) {
		lego::front::Reward_FUN_00461a50((uint *)(pRVar3->items_PTR + 9),1,param_1);
		std::sprintf(local_40,"%s",pRVar3->items_PTR[9].Text);
		pRVar5 = pRVar3->items_PTR;
		uVar4 = 0xffffffff;
		iVar6 = 0;
		pcVar7 = pRVar5[9].Text;
		do {
			if (uVar4 == 0) break;
			uVar4 = uVar4 - 1;
			cVar1 = *pcVar7;
			pcVar7 = pcVar7 + 1;
		} while (cVar1 != '\0');
		if (0 < (int)(~uVar4 - 1)) {
			do {
				if (pRVar5[9].Text[iVar6] == ' ') {
					local_40[iVar6] = '\0';
					std::sprintf(local_20,"%s",local_40 + iVar6 + 1);
				}
				pRVar5 = pRVar3->items_PTR;
				uVar4 = 0xffffffff;
				iVar6 = iVar6 + 1;
				pcVar7 = pRVar5[9].Text;
				do {
					if (uVar4 == 0) break;
					uVar4 = uVar4 - 1;
					cVar1 = *pcVar7;
					pcVar7 = pcVar7 + 1;
				} while (cVar1 != '\0');
			} while (iVar6 < (int)(~uVar4 - 1));
		}
		pcVar7 = local_40;
		iVar6 = pRVar3->items_PTR[9].TextPosition.y + -0x28;
		uVar4 = lego::image::FontX_GetStringWidth(lego::globals::g_Reward_BackFont,local_40);
		pRVar3 = (RewardFrontEnd *)
						 lego::image::Font_PrintF
											 (lego::globals::g_Reward_BackFont,
												pRVar3->items_PTR[9].TextPosition.x - (uVar4 >> 1),iVar6,pcVar7);
	}
	return (int)pRVar3;
}



int __cdecl lego::front::Reward_FUN_00462090(undefined4 *param_1,undefined4 *param_2)
{
	bool bVar1;
	ImageBMP *pIVar2;
	float fVar3;
	float fVar4;
	bool bVar5;
	LevelData *pLVar6;
	RewardFrontEnd *pRVar7;
	ImageBMP *pIVar8;
	uint uVar9;
	ImageBMP *image;
	
	bVar5 = false;
	pLVar6 = game::GetLevel();
	if (pLVar6 == (LevelData *)0x0) {
		return 0;
	}
	pRVar7 = reward::GetRewardFrontEnd(pLVar6->field_10);
	if (pRVar7 == (RewardFrontEnd *)0x0) {
		return 0;
	}
	if (pLVar6->status == LEVELSTATUS_COMPLETE) {
		fVar3 = (float)globs::INPUT.msx;
		pIVar2 = (ImageBMP *)((uint)pRVar7 & 0xffff0000);
		pIVar8 = pIVar2;
		image = globals::g_Reward_SaveButton;
		if (((((ushort)((ushort)(fVar3 < globals::g_Reward_SaveButtonPosition.x) << 8 |
									 (ushort)(fVar3 == globals::g_Reward_SaveButtonPosition.x) << 0xe) == 0) &&
				 (bVar1 = fVar3 < (float)(ulonglong)globals::g_Reward_SaveButton->width +
													globals::g_Reward_SaveButtonPosition.x,
				 pIVar8 = (ImageBMP *)((uint)CONCAT21((short)((uint)pIVar2 >> 0x10),bVar1) << 8), bVar1)) &&
				(fVar3 = (float)globs::INPUT.msy, pIVar8 = pIVar2,
				(ushort)((ushort)(fVar3 < globals::g_Reward_SaveButtonPosition.y) << 8 |
								(ushort)(fVar3 == globals::g_Reward_SaveButtonPosition.y) << 0xe) == 0)) &&
			 (bVar1 = fVar3 < (float)(ulonglong)globals::g_Reward_SaveButton->height +
												globals::g_Reward_SaveButtonPosition.y,
			 pIVar8 = (ImageBMP *)
								((uint)CONCAT21((short)(globals::g_Reward_SaveButton->height >> 0x10),bVar1) << 8),
			 bVar1)) {
			ToolTip_AddFlag4(0x24);
			if (((globs::INPUT.mslb != 0) &&
					(pIVar8 = globals::g_Reward_SaveButton_in,
					globals::g_Reward_SaveButton_in != (ImageBMP *)0x0)) ||
				 (pIVar8 = globals::g_Reward_SaveButton_hi,
				 globals::g_Reward_SaveButton_hi != (ImageBMP *)0x0)) {
				lego::image::Image_DisplayScaled
									(pIVar8,(Rect2F *)0x0,&globals::g_Reward_SaveButtonPosition,(Size2F *)0x0);
			}
			pIVar8 = (ImageBMP *)unk::Lego_LeftButtonInputUnk_FUN_00435480();
			if (pIVar8 != (ImageBMP *)0x0) {
				bVar5 = true;
				snd::Audio_Play_FUN_00465260(SFX_OKAY,0);
				FUN_004622f0();
				*param_2 = 1;
				snd::Sample_StopSoundBufferInstance(SFX_MUSICLOOP);
				snd::Audio_AddToSoundQueue1(SFX_MUSICLOOP,1);
			}
		}
		else {
LAB_004621d9:
			lego::image::Image_DisplayScaled
								(image,(Rect2F *)0x0,&globals::g_Reward_SaveButtonPosition,(Size2F *)0x0);
		}
	}
	else {
		pIVar8 = globals::g_Reward_SaveButton_dim;
		image = globals::g_Reward_SaveButton_dim;
		if (globals::g_Reward_SaveButton_dim != (ImageBMP *)0x0) goto LAB_004621d9;
	}
	fVar3 = (float)globs::INPUT.msx;
	uVar9 = (uint)(ushort)((ushort)(fVar3 < globals::g_Reward_AdvanceButtonPosition.x) << 8 |
												(ushort)(fVar3 == globals::g_Reward_AdvanceButtonPosition.x) << 0xe);
	if (uVar9 == 0) {
		fVar4 = (float)(ulonglong)globals::g_Reward_AdvanceButton->width +
						globals::g_Reward_AdvanceButtonPosition.x;
		uVar9 = (uint)pIVar8 & 0xffff0000 |
						(uint)(ushort)((ushort)(fVar3 < fVar4) << 8 | (ushort)(fVar3 == fVar4) << 0xe);
		if (fVar3 < fVar4) {
			fVar3 = (float)globs::INPUT.msy;
			uVar9 = (uint)(ushort)((ushort)(fVar3 < globals::g_Reward_AdvanceButtonPosition.y) << 8 |
														(ushort)(fVar3 == globals::g_Reward_AdvanceButtonPosition.y) << 0xe);
			if (uVar9 != 0) goto LAB_004622b4;
			fVar4 = (float)(ulonglong)globals::g_Reward_AdvanceButton->height +
							globals::g_Reward_AdvanceButtonPosition.y;
			uVar9 = globals::g_Reward_AdvanceButton->height & 0xffff0000 |
							(uint)(ushort)((ushort)(fVar3 < fVar4) << 8 | (ushort)(fVar3 == fVar4) << 0xe);
			if (fVar3 < fVar4) {
				ToolTip_AddFlag4(0x25);
				if (((globs::INPUT.mslb != 0) &&
						(pIVar8 = globals::g_Reward_AdvanceButton_in,
						globals::g_Reward_AdvanceButton_in != (ImageBMP *)0x0)) ||
					 (pIVar8 = globals::g_Reward_AdvanceButton_hi,
					 globals::g_Reward_AdvanceButton_hi != (ImageBMP *)0x0)) {
					lego::image::Image_DisplayScaled
										(pIVar8,(Rect2F *)0x0,&globals::g_Reward_AdvanceButtonPosition,(Size2F *)0x0);
				}
				uVar9 = unk::Lego_LeftButtonInputUnk_FUN_00435480();
				if (uVar9 != 0) {
					bVar5 = true;
					*param_1 = 3;
					snd::Audio_Play_FUN_00465260(SFX_OKAY,0);
					uVar9 = FUN_00462530();
				}
				goto LAB_004622c6;
			}
		}
	}
	else {
LAB_004622b4:
		uVar9 = (uint)pIVar8 & 0xffff0000 | uVar9;
	}
	lego::image::Image_DisplayScaled
						(globals::g_Reward_AdvanceButton,(Rect2F *)0x0,&globals::g_Reward_AdvanceButtonPosition,
						 (Size2F *)0x0);
LAB_004622c6:
	if ((!bVar5) && (uVar9 = unk::Lego_LeftButtonInputUnk_FUN_00435480(), uVar9 != 0)) {
		snd::Audio_Play_FUN_00465260(SFX_NOTOKAY,0);
	}
	return uVar9;
}



void __cdecl FUN_004622f0(void)
{
	LevelData *pLVar1;
	BOOL BVar2;
	BOOL BVar3;
	LevelIdentifier *pLVar4;
	int iVar5;
	undefined *puVar6;
	RewardFrontEnd *pRVar7;
	undefined *puVar8;
	LevelData *pLVar9;
	uint uVar10;
	uint unaff_EBX;
	undefined4 unaff_EBP;
	undefined4 unaff_ESI;
	undefined4 unaff_EDI;
	char *pcVar11;
	undefined4 local_d0 [6];
	undefined4 local_b8 [46];
	
	pLVar1 = lego::game::GetLevel();
	lego::unk::Lego_GetIntNotM1__00558020();
	BVar2 = lego::unk::Lego_GetIntNotM1__00558024();
	FUN_00416840();
	BVar3 = lego::main::Config_IsFrontEndEnabled();
	if (BVar3 != 0) {
		pcVar11 = pLVar1->levelName;
		pLVar4 = (LevelIdentifier *)FUN_00416d30();
		iVar5 = lego::unk::Lego_FindNameInTableStruct(pLVar4,pcVar11);
		FUN_00417ec0(iVar5);
		iVar5 = lego::save::Save_GetSaveNumber();
		puVar6 = FUN_00417da0();
		FUN_00417f70(local_b8);
		pRVar7 = lego::reward::GetCurrentRewardFrontEnd();
		if (BVar2 == 0) {
			BVar2 = lego::game::Game_IsLevelComplete();
			if (BVar2 != 0) {
				do {
					lego::front::Menu_Open_FUN_00416bb0(4);
				} while (DAT_00558508 != 0);
				if (lego::globals::g_SaveMenu_IsLoadMode == 1) {
					iVar5 = lego::unk::Lego_GetDat_00558500();
					if (iVar5 != 0) {
						FUN_00417f30(unaff_EDI,unaff_ESI,unaff_EBP,unaff_EBX);
						lego::unk::Lego_SetDat_00558500(0);
					}
					puVar8 = FUN_00417da0();
					if (puVar8 != (undefined *)0x0) {
						puVar8 = FUN_00417da0();
						if ((puVar8 != puVar6) && (puVar6 != (undefined *)0x0)) {
							FUN_00417ff0(local_b8);
							pLVar9 = lego::game::GetLevel();
							pcVar11 = pLVar9->levelName;
							pLVar4 = (LevelIdentifier *)FUN_00416d30();
							uVar10 = lego::unk::Lego_FindNameInTableStruct(pLVar4,pcVar11);
							FUN_00417de0(uVar10);
							pcVar11 = pLVar1->levelName;
							pLVar4 = (LevelIdentifier *)FUN_00416d30();
							iVar5 = lego::unk::Lego_FindNameInTableStruct(pLVar4,pcVar11);
							FUN_00417e70(iVar5,(undefined4 *)pRVar7);
							FUN_00437370(local_d0);
							FUN_00417e50(local_d0);
							FUN_00417ef0();
							return;
						}
						pLVar9 = lego::game::GetLevel();
						pcVar11 = pLVar9->levelName;
						pLVar4 = (LevelIdentifier *)FUN_00416d30();
						uVar10 = lego::unk::Lego_FindNameInTableStruct(pLVar4,pcVar11);
						FUN_00417de0(uVar10);
						pcVar11 = pLVar1->levelName;
						pLVar4 = (LevelIdentifier *)FUN_00416d30();
						iVar5 = lego::unk::Lego_FindNameInTableStruct(pLVar4,pcVar11);
						FUN_00417e70(iVar5,(undefined4 *)pRVar7);
						FUN_00437370(local_d0);
						FUN_00417e50(local_d0);
						FUN_00417ef0();
						return;
					}
					pLVar1 = lego::game::GetLevel();
					pcVar11 = pLVar1->levelName;
					pLVar4 = (LevelIdentifier *)FUN_00416d30();
					lego::unk::Lego_FindNameInTableStruct(pLVar4,pcVar11);
					return;
				}
				lego::save::Save_SetSaveNumber(iVar5);
				puVar6 = FUN_00417da0();
				if (puVar6 != (undefined *)0x0) {
					pLVar9 = lego::game::GetLevel();
					pcVar11 = pLVar9->levelName;
					pLVar4 = (LevelIdentifier *)FUN_00416d30();
					uVar10 = lego::unk::Lego_FindNameInTableStruct(pLVar4,pcVar11);
					FUN_00417de0(uVar10);
					pcVar11 = pLVar1->levelName;
					pLVar4 = (LevelIdentifier *)FUN_00416d30();
					iVar5 = lego::unk::Lego_FindNameInTableStruct(pLVar4,pcVar11);
					FUN_00417e70(iVar5,(undefined4 *)pRVar7);
					FUN_00437370(local_d0);
					FUN_00417e50(local_d0);
				}
			}
		}
	}
	return;
}



void __cdecl FUN_00462530(void)
{
	LevelData *pLVar1;
	LevelIdentifier *pLVar2;
	uint uVar3;
	int iVar4;
	RewardFrontEnd *pRVar5;
	undefined *puVar6;
	uint uVar7;
	undefined4 *puVar8;
	undefined4 uVar9;
	char *pcVar10;
	undefined4 uVar11;
	
	pLVar1 = lego::game::GetLevel();
	pcVar10 = pLVar1->levelName;
	pLVar2 = (LevelIdentifier *)FUN_00416d30();
	uVar3 = lego::unk::Lego_FindNameInTableStruct(pLVar2,pcVar10);
	iVar4 = lego::save::Save_GetSaveNumber();
	if (iVar4 == -1) {
		lego::save::Save_SetSaveNumber(5);
	}
	pLVar1 = lego::game::GetLevel();
	if (pLVar1->status == LEVELSTATUS_COMPLETE) {
		FUN_00417de0(uVar3);
	}
	pRVar5 = lego::reward::GetCurrentRewardFrontEnd();
	FUN_00417e70(uVar3,(undefined4 *)pRVar5);
	if (iVar4 == -1) {
		puVar6 = FUN_00417d80(5);
		if (puVar6 != (undefined *)0x0) {
			puVar8 = (undefined4 *)(*(int *)(puVar6 + 0x34) + 0x3190);
			for (uVar7 = *(int *)(puVar6 + 0x18) * 0x3190 - 0x3190U >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
				*puVar8 = 0;
				puVar8 = puVar8 + 1;
			}
			for (iVar4 = 0; iVar4 != 0; iVar4 = iVar4 + -1) {
				*(undefined *)puVar8 = 0;
				puVar8 = (undefined4 *)((int)puVar8 + 1);
			}
			pLVar1 = lego::game::GetLevel();
			if (pLVar1->status == LEVELSTATUS_COMPLETE) {
				FUN_00417de0(uVar3);
			}
			pRVar5 = lego::reward::GetCurrentRewardFrontEnd();
			FUN_00417e70(uVar3,(undefined4 *)pRVar5);
		}
		FUN_00417ef0();
		lego::game::Game_UnkLoadSaveSlot__004179c0
							(5,(undefined4 *)(lego::globals::g_Struct_b8_TABLE__00558080 + 5),0);
	}
	uVar11 = 0;
	uVar9 = *(undefined4 *)(lego::globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
	pLVar2 = &LevelIdentifier_00557fe4;
	puVar6 = FUN_00417da0();
	FUN_00417310(DAT_00557ff8,*(int *)(puVar6 + 0x34),pLVar2,uVar9,uVar11);
	lego::unk::Lego_SetDat_0055881c(0);
	return;
}



void __cdecl
lego::front::Reward_FUN_00462650
					(undefined4 *param_1,undefined4 *param_2,undefined4 *param_3,undefined4 *param_4)
{
	LevelData *pLVar1;
	RewardFrontEnd *pRVar2;
	int iVar3;
	
	pLVar1 = game::GetLevel();
	if (pLVar1 == (LevelData *)0x0) {
		return;
	}
	pRVar2 = reward::GetRewardFrontEnd(pLVar1->field_10);
	if (pRVar2 == (RewardFrontEnd *)0x0) {
		return;
	}
	if (((byte)globals::g_Game.flags2 & GAME2_ALLOWDEBUGKEYS) != 0) {
										// IsKeyDown(KEY_SPACE) (57) && IsKeyPressed(KEY_ESCAPE) (1)
		if (((globs::INPUT.Key_Map[57] != false) && (globs::INPUT.Key_Map[1] != false)) &&
			 (globs::INPUT.prevKey_Map[1] != globs::INPUT.Key_Map[1])) {
			main::Game_Exit();
		}
										// IsKeyPressed(KEY_R) (19)
		if ((globs::INPUT.Key_Map[19] != false) &&
			 (globs::INPUT.prevKey_Map[19] != globs::INPUT.Key_Map[19])) {
			*param_1 = 0;
			*param_2 = 0;
			*param_4 = globals::g_Reward_Timer;
			*param_3 = 0;
			snd::Sample_StopSoundBufferInstance(SFX_MUSICLOOP);
			snd::Audio_AddToSoundQueue1(SFX_MUSICLOOP,1);
			iVar3 = 0;
			do {
				FUN_00462720((byte *)(pRVar2->items_PTR->name + iVar3 + -4));
				iVar3 = iVar3 + 0x210;
			} while (iVar3 < 0x14a0);
		}
	}
	return;
}



void __cdecl FUN_00462720(byte *param_1)
{
	if ((*param_1 & 4) != 0) {
		lego::image::Flic_Close(*(ImageFlic **)(param_1 + 0x1fc));
		lego::image::Flic_Setup((char *)(param_1 + 0x16c),(ImageFlic **)(param_1 + 0x1fc),FLICDISK);
	}
	return;
}



void __cdecl FUN_00462760(int *param_1,int *param_2,float *param_3)
{
	char *sfxName;
	bool bVar1;
	LevelData *pLVar2;
	RewardFrontEnd *pRVar3;
	int iVar4;
	BOOL BVar5;
	bool bVar6;
	SFXType local_4;
	
	bVar1 = false;
	pLVar2 = lego::game::GetLevel();
	if (pLVar2 == (LevelData *)0x0) {
		return;
	}
	pRVar3 = lego::reward::GetRewardFrontEnd(pLVar2->field_10);
	if (pRVar3 == (RewardFrontEnd *)0x0) {
		return;
	}
	if (lego::globals::g_Reward_Timer <= *param_3) {
		bVar6 = *param_2 == 0;
		if (!bVar6) goto LAB_004627c2;
		bVar1 = true;
	}
	bVar6 = *param_2 == 0;
LAB_004627c2:
	if ((!bVar6) && (lego::globals::g_Reward_Timer + lego::globals::g_Reward_Timer <= *param_3)) {
		pLVar2 = lego::game::GetLevel();
		if ((pLVar2->status == LEVELSTATUS_COMPLETE) && (*param_1 < 10)) {
			bVar1 = true;
		}
	}
	if (bVar1) {
		*param_3 = *param_3 - lego::globals::g_Reward_Timer;
		iVar4 = *param_1;
		if (iVar4 < 10) {
			iVar4 = iVar4 + 1;
		}
		*param_1 = iVar4;
		sfxName = pRVar3->items_PTR[iVar4 + -1].SoundName;
		if (sfxName != (char *)0x0) {
			BVar5 = lego::snd::SFX_GetType(sfxName,&local_4);
			if (BVar5 != 0) {
				lego::snd::Audio_AddToSoundQueue1(local_4,0);
			}
		}
		iVar4 = *param_1;
		if (9 < iVar4) {
			if (*param_2 == 0) {
				*param_1 = 9;
				*param_2 = *param_2 + 1;
				return;
			}
			if ((9 < iVar4) && (1 < *param_2)) {
				if (10 < iVar4) {
					*param_1 = 10;
					*param_2 = *param_2 + 1;
					return;
				}
				iVar4 = 0;
				do {
					FUN_00462720((byte *)(pRVar3->items_PTR->name + iVar4 + -4));
					iVar4 = iVar4 + 0x210;
				} while (iVar4 < 0x14a0);
			}
		}
	}
	return;
}



void __cdecl FUN_004628c0(uint *param_1,undefined4 *param_2)
{
	uint uVar1;
	LevelData *pLVar2;
	RewardFrontEnd *pRVar3;
	uint uVar4;
	int iVar5;
	int iVar6;
	
	pLVar2 = lego::game::GetLevel();
	if (pLVar2 == (LevelData *)0x0) {
		return;
	}
	pRVar3 = lego::reward::GetRewardFrontEnd(pLVar2->field_10);
	if (pRVar3 == (RewardFrontEnd *)0x0) {
		return;
	}
	if (((*param_1 == 10) || ((pLVar2->status != LEVELSTATUS_COMPLETE && (*param_1 == 9)))) &&
		 ((*(int *)&pRVar3->items_TABLE[9].field_0x1fc == 0 ||
			(((lego::globals::g_Reward_DisplayFlics == 0 ||
				(0x21 < *(int *)(*(int *)&pRVar3->items_PTR[9].field_0x1fc + 0x624))) ||
			 (pLVar2->status != LEVELSTATUS_COMPLETE)))))) {
		*param_2 = 1;
	}
	iVar6 = 0;
	iVar5 = 0;
	while( true ) {
		uVar1 = *param_1;
		uVar4 = uVar1;
		if (9 < (int)uVar1) {
			uVar4 = 9;
		}
		if ((int)uVar4 <= iVar6) break;
		lego::front::Reward_FUN_00461a50((uint *)(pRVar3->items_PTR->name + iVar5 + -4),1,uVar1);
		iVar6 = iVar6 + 1;
		iVar5 = iVar5 + 0x210;
	}
	lego::image::FontX_GetStringWidth(lego::globals::g_Reward_TitleFont,pLVar2->FullName);
	lego::image::FontX_GetStringWidth
						(lego::globals::g_Reward_TitleFont,lego::globals::g_LevelStatusMessage_text);
	return;
}



void __cdecl lego::unk::Lego_UnkUpdateAndRender_004629c0(float elapsed)
{
	front::Pointer_SubUnkFloat_IfGreaterThan0(1.0);
	front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_STANDARD);
	front::Pointer_DrawPointer(globs::INPUT.msx,globs::INPUT.msy);
	Lego_LeftButtonInputUnk_FUN_00435480();
	globs::INPUT.lClicked = 0;
	snd::Audio_UnkUpdate_FUN_00465460(elapsed);
										// param_1 / 25.0 * 1000.0 (related to milliseconds)
	front::ToolTip_Update_FUN_0046ba80(globs::INPUT.msx,globs::INPUT.msy,elapsed * 0.04 * 1000.0);
	main::Main_LoopUpdate(1);
	return;
}



BOOL __cdecl lego::front::Reward_UIUpdate_FUN_00462a40(void)
{
	LevelData *pLVar1;
	RewardFrontEnd *pRVar2;
	
	pLVar1 = game::GetLevel();
	if ((pLVar1 != (LevelData *)0x0) &&
		 (pRVar2 = reward::GetRewardFrontEnd(pLVar1->field_10), pRVar2 != (RewardFrontEnd *)0x0)) {
		if ((globals::g_Reward_Display != 0) && (pRVar2->Enabled != 0)) {
										// IsKeyUp(KEY_SPACE) && !IsKeyReleased(KEY_SPACE)  (57)
			while ((((globs::INPUT.Key_Map[57] != false &&
							 (globs::INPUT.prevKey_Map[57] != globs::INPUT.Key_Map[57])) ||
							(globs::INPUT.Key_Map[57] != false)) || (globs::INPUT.prevKey_Map[57] != false))) {
				main::Main_LoopUpdate(TRUE);
			}
			globs::INPUT.lClicked = 0;
			snd::Audio_AddToSoundQueue1(SFX_MUSICLOOP,1);
			return 1;
		}
		FUN_00462530();
	}
	return 0;
}



void __cdecl lego::unk::Lego_AddToFloat_00556738__DecFloat_0055673c(float param_1)
{
	FLOAT_00556738 = param_1 + FLOAT_00556738;
	FLOAT_0055673c = FLOAT_0055673c - -1.0;
	return;
}



void __cdecl lego::unk::Lego_DecFloat_00555adc(void)
{
	FLOAT_00555adc = FLOAT_00555adc - -1.0;
	return;
}



void __cdecl lego::unk::Lego_DecFloat_00555efc(void)
{
	FLOAT_00555efc = FLOAT_00555efc - -1.0;
	return;
}



void __cdecl lego::nerps::NERPs_IncInt_00556324(void)
{
	UINT_00556324 = UINT_00556324 + 1;
	return;
}



void __cdecl lego::nerps::NERPs_IncRockMonstersDestroyed(void)
{
	globals::nerps::g_NERPs_RockMonstersDestroyed = globals::nerps::g_NERPs_RockMonstersDestroyed + 1;
	return;
}



void __cdecl lego::nerps::NERPs_IncInt_0055632c(void)
{
	UINT_0055632c = UINT_0055632c + 1;
	return;
}



void __cdecl lego::nerps::NERPs_AddToFloat_00556330(float param_1)
{
	FLOAT_00556330 = param_1 + FLOAT_00556330;
	return;
}



void __cdecl lego::nerps::NERPs_AddToFloat_00556120(float param_1)
{
	FLOAT_00556120 = param_1 + FLOAT_00556120;
	return;
}



RewardStruct_28 * __cdecl
lego::reward::Reward_CreateStruct28
					(RewardStruct_28 **out_struct,undefined4 param_2,float param_3,float param_4,float param_5
					,float scrollSpeed)
{
	RewardStruct_28 *pRVar1;
	RewardSubstruct_20 **ppRVar2;
	RewardSubstruct_20 *pRVar3;
	int iVar4;
	RewardStruct_28 *pRVar5;
	
	pRVar1 = (RewardStruct_28 *)std::malloc(0x28);
	if (pRVar1 != (RewardStruct_28 *)0x0) {
		pRVar5 = pRVar1;
		for (iVar4 = 10; iVar4 != 0; iVar4 = iVar4 + -1) {
			pRVar5->field_0 = 0;
			pRVar5 = (RewardStruct_28 *)&pRVar5->field_4;
		}
		ppRVar2 = (RewardSubstruct_20 **)std::malloc(4);
		pRVar1->substruct_TABLE = ppRVar2;
		pRVar3 = (RewardSubstruct_20 *)std::malloc(0x20);
		*ppRVar2 = pRVar3;
		for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {
			pRVar3->int_0 = 0;
			pRVar3 = (RewardSubstruct_20 *)&pRVar3->field_4;
		}
		pRVar1->scrollSpeed = scrollSpeed;
		pRVar1->field_4 = param_2;
		pRVar1->float_8 = param_3;
		pRVar1->float_c = param_4;
		pRVar1->float_10 = param_5;
		pRVar1->field_0 = param_3;
	}
	*out_struct = pRVar1;
	return pRVar1;
}



BOOL __cdecl lego::front::Reward_FUN_00462c20(RewardStruct_28 **param_1)
{
	char *buffer;
	RewardStruct_28 *pRVar1;
	uint uVar2;
	
	uVar2 = 0;
	pRVar1 = *param_1;
	if (pRVar1->substruct_COUNT != 0) {
		do {
			buffer = pRVar1->substruct_TABLE[uVar2]->text;
			if (buffer != (char *)0x0) {
				std::free(buffer);
			}
			std::free((*param_1)->substruct_TABLE[uVar2]);
			pRVar1 = *param_1;
			uVar2 = uVar2 + 1;
		} while (uVar2 < (uint)pRVar1->substruct_COUNT);
	}
	if ((*param_1)->substruct_TABLE != (RewardSubstruct_20 **)0x0) {
		std::free((*param_1)->substruct_TABLE);
	}
	std::free(*param_1);
	return 1;
}



RewardSubstruct_20 * __cdecl
lego::front::Reward_FUN_00462c90
					(RewardStruct_28 *param_1,char *text,ImageFont *font,undefined4 param_4,int vertSpacing,
					uint unkFlags)
{
	char cVar1;
	int iVar2;
	RewardSubstruct_20 **ppRVar3;
	RewardSubstruct_20 *pRVar4;
	char *pcVar5;
	int iVar6;
	uint uVar7;
	
	if (font == (ImageFont *)0x0) {
		return (RewardSubstruct_20 *)0x0;
	}
	iVar2 = param_1->substruct_COUNT;
	param_1->substruct_COUNT = iVar2 + 1;
	ppRVar3 = (RewardSubstruct_20 **)std::realloc(param_1->substruct_TABLE,(iVar2 + 1) * 4);
	param_1->substruct_TABLE = ppRVar3;
	pRVar4 = (RewardSubstruct_20 *)std::malloc(0x20);
	param_1->substruct_TABLE[iVar2] = pRVar4;
	pRVar4 = param_1->substruct_TABLE[iVar2];
	for (iVar6 = 8; iVar6 != 0; iVar6 = iVar6 + -1) {
		pRVar4->int_0 = 0;
		pRVar4 = (RewardSubstruct_20 *)&pRVar4->field_4;
	}
	param_1->substruct_TABLE[iVar2]->field_4 = param_4;
	param_1->substruct_TABLE[iVar2]->vertSpacing = (float)vertSpacing;
	uVar7 = 0xffffffff;
	pcVar5 = text;
	do {
		if (uVar7 == 0) break;
		uVar7 = uVar7 - 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	pcVar5 = (char *)std::malloc(~uVar7);
	param_1->substruct_TABLE[iVar2]->text = pcVar5;
	std::sprintf(param_1->substruct_TABLE[iVar2]->text,"%s",text);
	param_1->substruct_TABLE[iVar2]->int_0 = 3;
	param_1->substruct_TABLE[iVar2]->font = font;
	param_1->substruct_TABLE[iVar2]->flags = param_1->substruct_TABLE[iVar2]->flags | unkFlags;
	return param_1->substruct_TABLE[iVar2];
}



void __cdecl lego::reward::Reward_Struct_SetFloat18(RewardStruct_28 *param_1,float param_2)
{
	param_1->float_18 = param_2;
	return;
}



void __cdecl lego::reward::Reward_Struct_OrFlags24(RewardStruct_28 *param_1,uint param_2)
{
	param_1->flags = param_1->flags | param_2;
	return;
}



BOOL __cdecl FUN_00462d90(float *param_1)
{
	int iVar1;
	float fVar2;
	float *pfVar3;
	int iVar4;
	int *piVar5;
	uint uVar6;
	float *pfVar7;
	longlong lVar8;
	ulonglong uVar9;
	int local_2c;
	float local_28;
	float *local_24;
	Size2F local_10;
	Point2F local_8;
	
	pfVar3 = param_1;
	local_28 = 0.0;
	if (param_1[7] != 0.0) {
		do {
			iVar4 = (int)local_28 * 4;
			piVar5 = *(int **)(iVar4 + (int)pfVar3[8]);
			lVar8 = __ftol((float10)(float)piVar5[1] + (float10)pfVar3[1]);
			local_2c = (int)lVar8;
			uVar9 = __ftol((float10)(float)piVar5[2] + (float10)pfVar3[2]);
			param_1 = (float *)uVar9;
			if ((*(byte *)(pfVar3 + 9) & 1) != 0) {
				if ((float)(int)param_1 < *pfVar3) {
					lVar8 = __ftol((float10)pfVar3[6] + (float10)pfVar3[4]);
					do {
						param_1 = (float *)((int)param_1 + (int)lVar8);
						uVar9 = ZEXT48(param_1);
					} while ((float)(int)param_1 < *pfVar3);
				}
				pfVar7 = (float *)uVar9;
				fVar2 = pfVar3[6] + *pfVar3 + pfVar3[4];
				if ((ushort)((ushort)((float)(int)param_1 < fVar2) << 8 |
										(ushort)((float)(int)param_1 == fVar2) << 0xe) == 0) {
					lVar8 = __ftol((float10)pfVar3[4]);
					do {
						pfVar7 = (float *)((int)pfVar7 - (int)lVar8);
						uVar9 = ZEXT48(pfVar7);
						param_1 = pfVar7;
					} while ((ushort)((ushort)((float)(int)pfVar7 < fVar2) << 8 |
													 (ushort)((float)(int)pfVar7 == fVar2) << 0xe) == 0);
				}
			}
			iVar1 = *piVar5;
			if (iVar1 == 1) {
				lego::front::TextWindow_ChangePosition((TextWindow *)piVar5[3],local_2c,(int)uVar9);
				lego::front::TextWindow_Update
									(*(TextWindow **)(*(int *)(iVar4 + (int)pfVar3[8]) + 0xc),0,
									 lego::globs::mainGlobs.fixedFrameTiming,(int *)0x0);
LAB_00462e93:
				local_8.x = (float)local_2c;
				piVar5 = (int *)(iVar4 + (int)pfVar3[8]);
				local_8.y = (float)(int)param_1;
				local_10.width = (float)(ulonglong)*(uint *)(*(int *)(*piVar5 + 0x10) + 4);
				local_10.height = (float)(ulonglong)*(uint *)(*(int *)(*piVar5 + 0x10) + 8);
				lego::image::Image_DisplayScaled
									(*(ImageBMP **)(*piVar5 + 0x10),(Rect2F *)0x0,&local_8,&local_10);
LAB_00462ef7:
				iVar1 = *(int *)(iVar4 + (int)pfVar3[8]);
				if ((*(byte *)(iVar1 + 0x1c) & 1) != 0) {
					uVar6 = lego::image::FontX_GetStringWidth
														(*(ImageFont **)(iVar1 + 0x18),*(char **)(iVar1 + 0x14));
					lVar8 = __ftol(((float10)pfVar3[3] - (float10)pfVar3[1]) * (float10)-0.5);
					local_2c = local_2c + (-(int)lVar8 - (uVar6 >> 1));
				}
				uVar9 = uVar9 & 0xffffffff;
				iVar4 = *(int *)(iVar4 + (int)pfVar3[8]);
				uVar6 = *(uint *)(iVar4 + 0x1c) & 2;
				if (uVar6 != 0) {
					uVar9 = __ftol((float10)*(float *)(iVar4 + 8));
					param_1 = (float *)uVar9;
				}
				if ((uVar6 != 0) ||
					 ((fVar2 = (float)(int)param_1, fVar2 < pfVar3[4] + *pfVar3 &&
						((ushort)((ushort)(fVar2 < *pfVar3) << 8 | (ushort)(fVar2 == *pfVar3) << 0xe) == 0)))) {
					lego::image::Font_PrintF
										(*(ImageFont **)(iVar4 + 0x18),local_2c,(int)uVar9,*(char **)(iVar4 + 0x14));
				}
			}
			else {
				if (iVar1 == 2) goto LAB_00462e93;
				if (iVar1 == 3) goto LAB_00462ef7;
			}
			local_28 = (float)((int)local_28 + 1);
		} while ((uint)local_28 < (uint)pfVar3[7]);
	}
	pfVar3[2] = pfVar3[2] - pfVar3[5];
	if (((byte)lego::globals::g_Game.flags2 & 0x10) != 0) {
		if (lego::globs::INPUT.Key_Map[31] != false) {
			pfVar3[5] = 0.0;
		}
		if (lego::globs::INPUT.Key_Map[19] != false) {
			pfVar3[2] = *pfVar3;
		}
		if (lego::globs::INPUT.Key_Map[13] != false) {
			pfVar3[5] = pfVar3[5] - -0.01;
		}
		if (lego::globs::INPUT.Key_Map[12] != false) {
			pfVar3[5] = pfVar3[5] - 0.01;
		}
		param_1 = (float *)0x0;
		local_24 = (float *)0x0;
		do {
			if (*(char *)((int)param_1 + 0x76bb82) != '\0') {
				pfVar7 = param_1;
				if (pfVar3[5] < 0.0) {
					pfVar7 = local_24;
				}
				pfVar3[5] = (float)(int)pfVar7 * 0.1;
			}
			param_1 = (float *)((int)param_1 + 1);
			local_24 = (float *)((int)local_24 + -1);
		} while (-10 < (int)local_24);
	}
	return 1;
}



BOOL __cdecl FUN_00463060(Container *resData,int width,int height)
{
	uint uVar1;
	uint uVar2;
	
	RESDATA_00553180 = lego::res::Container_MakeMesh2(resData,2);
	if (RESDATA_00553180 != (Container *)0x0) {
		DAT_00553194 = 0;
		uVar2 = height * width;
		BOOL_0055318c = 0;
		GRIDPTR_00553198 = std::malloc(uVar2 * 8);
		if (GRIDPTR_00553198 != (void *)0x0) {
			uVar1 = 0;
			if (uVar2 != 0) {
				do {
					*(undefined4 *)((int)GRIDPTR_00553198 + uVar1 * 8) = 0;
					*(undefined *)((int)GRIDPTR_00553198 + uVar1 * 8 + 4) = 1;
					uVar1 = uVar1 + 1;
				} while (uVar1 < uVar2);
			}
			Size2I_00553184.width = width;
			Size2I_00553184.height = height;
			BOOL_00553190 = 1;
			UINT_0055396c = 0;
			return 1;
		}
		lego::res::Container_Remove(RESDATA_00553180);
	}
	return 0;
}



BOOL __cdecl lego::main::Main_LoadRoofTexture(char *filename)
{
	D3DRMGroupIndex DVar1;
	D3DRMGroupIndex groupID;
	
	if (DAT_00553194 != (Container_Texture *)0x0) {
		res::Container_FreeTexture(DAT_00553194);
	}
	DAT_00553194 = res::Container_LoadTexture2(filename,1,(uint *)0x0,(uint *)0x0);
	if (DAT_00553194 != (Container_Texture *)0x0) {
		DVar1 = res::Container_Mesh_GetGroupCount(RESDATA_00553180);
		groupID = D3DRMGROUP_0;
		if (DVar1 != D3DRMGROUP_0) {
			do {
				res::Container_Mesh_SetTexture(RESDATA_00553180,groupID,DAT_00553194);
				groupID = groupID + 1;
			} while (groupID < DVar1);
		}
		return 1;
	}
	return 0;
}



void __cdecl lego::unk::Lego_UnkFreeGridPtr_FUN_00463190(void)
{
	if (GRIDPTR_00553198 != (void *)0x0) {
		std::free(GRIDPTR_00553198);
	}
	GRIDPTR_00553198 = (void *)0x0;
	if (RESDATA_00553180 != (Container *)0x0) {
		res::Container_Remove(RESDATA_00553180);
	}
	RESDATA_00553180 = (Container *)0x0;
	res::Container_FreeTexture(DAT_00553194);
	return;
}



int __cdecl
FUN_004631e0(int x,int y,Vector3F *param_3,Vector3F *param_4,Vector3F *param_5,Vector3F *param_6)
{
	D3DRMGroupIndex *pDVar1;
	ushort uVar2;
	bool bVar3;
	byte bVar4;
	D3DRMGroupIndex groupID;
	uint uVar5;
	D3DRMVertex local_a8;
	float local_84;
	float local_80;
	float local_7c;
	undefined4 local_78;
	undefined4 local_74;
	undefined4 local_70;
	float local_6c;
	undefined4 local_68;
	undefined4 local_64;
	float local_60;
	float local_5c;
	float local_58;
	undefined4 local_54;
	undefined4 local_50;
	undefined4 local_4c;
	float local_48;
	float local_44;
	undefined4 local_40;
	float local_3c;
	float local_38;
	float local_34;
	undefined4 local_30;
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	float local_20;
	undefined4 local_1c;
	uint local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	pDVar1 = (D3DRMGroupIndex *)((int)GRIDPTR_00553198 + (y * Size2I_00553184.width + x) * 8);
	bVar3 = false;
	if ((*(byte *)(pDVar1 + 1) & 1) != 0) {
		local_18 = 0;
		local_10 = 3;
		local_4 = 3;
		local_14 = 1;
		local_c = 1;
		local_8 = 2;
		groupID = lego::res::Container_Mesh_AddGroup(RESDATA_00553180,4,2,3,&local_18);
		*pDVar1 = groupID;
		if (groupID != D3DRMGROUP_ALLGROUPS) {
			lego::res::Container_Mesh_SetTexture(RESDATA_00553180,groupID,DAT_00553194);
			lego::res::Container_Mesh_SetPerspectiveCorrection(RESDATA_00553180,*pDVar1,1);
			lego::res::Container_Mesh_HideGroup(RESDATA_00553180,*pDVar1,1);
			*(byte *)(pDVar1 + 1) = *(byte *)(pDVar1 + 1) & 0xfe;
		}
	}
	BOOL_00553190 = 1;
	*(byte *)(pDVar1 + 1) = *(byte *)(pDVar1 + 1) | 2;
	if (param_5->z <= param_3->z) {
		if ((ushort)((ushort)(param_5->z < param_4->z) << 8 | (ushort)(param_5->z == param_4->z) << 0xe)
				!= 0) {
			uVar2 = (ushort)(param_5->z < param_6->z) << 8 | (ushort)(param_5->z == param_6->z) << 0xe;
			goto joined_r0x0046334a;
		}
	}
	else {
		if ((ushort)((ushort)(param_3->z < param_4->z) << 8 | (ushort)(param_3->z == param_4->z) << 0xe)
				!= 0) {
			uVar2 = (ushort)(param_3->z < param_6->z) << 8 | (ushort)(param_3->z == param_6->z) << 0xe;
joined_r0x0046334a:
			if (uVar2 != 0) goto LAB_00463350;
		}
	}
	bVar3 = true;
LAB_00463350:
	if (bVar3) {
		local_3c = param_4->x;
		local_38 = param_4->y;
		local_34 = param_4->z;
		local_60 = param_5->x;
		local_5c = param_5->y;
		local_58 = param_5->z;
		local_84 = param_6->x;
		local_80 = param_6->y;
		local_7c = param_6->z;
		local_a8.position.x = param_3->x;
		local_a8.position.y = param_3->y;
		local_a8.position.z = param_3->z;
		bVar4 = *(byte *)(pDVar1 + 1) | 4;
	}
	else {
		local_3c = param_3->x;
		local_38 = param_3->y;
		local_34 = param_3->z;
		local_60 = param_4->x;
		local_5c = param_4->y;
		local_58 = param_4->z;
		local_84 = param_5->x;
		local_80 = param_5->y;
		local_7c = param_5->z;
		local_a8.position.x = param_6->x;
		local_a8.position.y = param_6->y;
		local_a8.position.z = param_6->z;
		bVar4 = *(byte *)(pDVar1 + 1) & 0xfb;
	}
	*(byte *)(pDVar1 + 1) = bVar4;
	local_30 = 0;
	local_28 = 0;
	local_54 = 0;
	local_4c = 0;
	local_78 = 0;
	local_70 = 0;
	local_a8.normal.x = 0.0;
	local_a8.normal.z = 0.0;
	local_2c = 0;
	local_50 = 0;
	local_74 = 0;
	local_a8.normal.y = 0.0;
	local_1c = 0xffffffff;
	local_40 = 0xffffffff;
	local_64 = 0xffffffff;
	local_a8.colour = 0xffffffff;
	local_24 = 0;
	local_20 = 1.0;
	local_48 = 1.0;
	local_44 = 1.0;
	local_6c = 1.0;
	local_68 = 0;
	local_a8.tu = 0.0;
	local_a8.tv = 0.0;
	uVar5 = lego::res::Container_Mesh_SetVertices(RESDATA_00553180,*pDVar1,0,4,&local_a8);
	return uVar5;
}



void __cdecl FUN_004634f0(void)
{
	D3DRMGroupIndex *pDVar1;
	float fVar2;
	uint uVar3;
	BOOL BVar4;
	uint uVar5;
	int iVar6;
	float *pfVar7;
	int *piVar8;
	uint local_134;
	uint local_130;
	int local_124;
	Vector3F local_11c;
	int local_110 [4];
	undefined4 local_100;
	undefined4 local_fc;
	undefined4 local_f8;
	undefined4 local_f4;
	undefined4 local_f0;
	undefined4 local_ec;
	undefined4 local_e8;
	undefined4 local_e4;
	undefined4 local_e0;
	undefined4 local_dc;
	undefined4 local_d8;
	undefined4 local_d4;
	undefined4 local_d0;
	undefined4 local_cc;
	undefined4 local_c8;
	undefined4 local_c4;
	undefined4 local_c0;
	undefined4 local_bc;
	undefined4 local_b8;
	undefined4 local_b4;
	undefined4 local_b0;
	undefined4 local_ac;
	undefined4 local_a8;
	undefined4 local_a4;
	undefined4 local_a0;
	undefined4 local_9c;
	undefined4 local_98;
	undefined4 local_94;
	D3DRMVertex local_90 [4];
	
	if (BOOL_00553190 != 0) {
		BOOL_00553190 = 0;
		local_130 = 0;
		uVar5 = Size2I_00553184.width;
		if (Size2I_00553184.height != 0) {
			do {
				local_134 = 0;
				if (uVar5 != 0) {
					do {
						iVar6 = local_130 * uVar5 + local_134;
						pDVar1 = (D3DRMGroupIndex *)((int)GRIDPTR_00553198 + iVar6 * 8);
						if ((*(byte *)((int)GRIDPTR_00553198 + iVar6 * 8 + 4) & 2) != 0) {
							local_fc = 1;
							local_f4 = 1;
							local_e8 = 1;
							local_e0 = 1;
							local_dc = 1;
							local_d4 = 1;
							local_c0 = 1;
							local_b8 = 1;
							local_110[2] = 0xffffffff;
							local_f8 = 0xffffffff;
							local_c4 = 0xffffffff;
							local_bc = 0xffffffff;
							local_a8 = 0xffffffff;
							local_a4 = 0xffffffff;
							local_9c = 0xffffffff;
							local_98 = 0xffffffff;
							local_110[0] = 0;
							local_110[1] = 0;
							local_110[3] = 0;
							local_100 = 0;
							local_f0 = 0;
							local_ec = 0;
							local_e4 = 0;
							local_d8 = 0;
							local_d0 = 0;
							local_cc = 0;
							local_c8 = 0;
							local_b4 = 0;
							local_b0 = 0;
							local_ac = 0;
							local_a0 = 0;
							local_94 = 0;
							lego::res::Container_Mesh_GetVertices(RESDATA_00553180,*pDVar1,0,4,local_90);
							uVar5 = 0;
							pfVar7 = &local_90[0].normal.z;
							do {
								uVar3 = uVar5;
								if ((*(byte *)(pDVar1 + 1) & 4) != 0) {
									uVar3 = uVar5 - 1 & 3;
								}
								local_124 = 4;
								piVar8 = local_110 + uVar3 * 8;
								do {
									BVar4 = FUN_00463850(local_134 + *piVar8,piVar8[1] + local_130,&local_11c);
									if (BVar4 != 0) {
										pfVar7[-2] = local_11c.x + pfVar7[-2];
										pfVar7[-1] = local_11c.y + pfVar7[-1];
										*pfVar7 = local_11c.z + *pfVar7;
									}
									piVar8 = piVar8 + 2;
									local_124 = local_124 + -1;
								} while (local_124 != 0);
								uVar5 = uVar5 + 1;
								fVar2 = 1.0 / SQRT(pfVar7[-2] * pfVar7[-2] +
																	 *pfVar7 * *pfVar7 + pfVar7[-1] * pfVar7[-1]);
								*pfVar7 = fVar2 * *pfVar7;
								pfVar7[-2] = fVar2 * pfVar7[-2];
								pfVar7[-1] = fVar2 * pfVar7[-1];
								pfVar7 = pfVar7 + 9;
							} while (uVar5 < 4);
							lego::res::Container_Mesh_SetVertices(RESDATA_00553180,*pDVar1,0,4,local_90);
							*(byte *)(pDVar1 + 1) = *(byte *)(pDVar1 + 1) & 0xfd;
							uVar5 = Size2I_00553184.width;
						}
						local_134 = local_134 + 1;
					} while (local_134 < uVar5);
				}
				local_130 = local_130 + 1;
			} while (local_130 < (uint)Size2I_00553184.height);
		}
	}
	return;
}



void __cdecl FUN_00463770(BOOL use3rdFrame)
{
	if (BOOL_0055318c != use3rdFrame) {
		BOOL_0055318c = use3rdFrame;
		if (use3rdFrame != 0) {
			lego::res::Container_Hide(RESDATA_00553180,1);
			return;
		}
		lego::res::Container_Hide(RESDATA_00553180,0);
	}
	return;
}



void __cdecl FUN_004637b0(int x,int y)
{
	void *pvVar1;
	int iVar2;
	
	iVar2 = y * Size2I_00553184.width + x;
	pvVar1 = (void *)((int)GRIDPTR_00553198 + iVar2 * 8);
	lego::res::Container_Mesh_HideGroup
						(RESDATA_00553180,*(D3DRMGroupIndex *)((int)GRIDPTR_00553198 + iVar2 * 8),0);
	(&DAT_0055319c)[UINT_0055396c] = pvVar1;
	UINT_0055396c = UINT_0055396c + 1;
	return;
}



void __cdecl FUN_00463800(void)
{
	uint uVar1;
	D3DRMGroupIndex **ppDVar2;
	
	uVar1 = 0;
	if (UINT_0055396c != 0) {
		ppDVar2 = (D3DRMGroupIndex **)&DAT_0055319c;
		do {
			lego::res::Container_Mesh_HideGroup(RESDATA_00553180,**ppDVar2,1);
			uVar1 = uVar1 + 1;
			ppDVar2 = ppDVar2 + 1;
		} while (uVar1 < UINT_0055396c);
	}
	UINT_0055396c = 0;
	return;
}



BOOL __cdecl FUN_00463850(uint x,uint y,Vector3F *out_vector)
{
	D3DRMGroupIndex *pDVar1;
	float fVar2;
	Vector3F local_a8;
	Vector3F local_9c;
	D3DRMVertex local_90;
	Vector3F local_6c [3];
	Vector3F local_48 [3];
	Vector3F local_24 [3];
	
	if (((x < (uint)Size2I_00553184.width) && (y < (uint)Size2I_00553184.height)) &&
		 (pDVar1 = (D3DRMGroupIndex *)((int)GRIDPTR_00553198 + (y * Size2I_00553184.width + x) * 8),
		 (*(byte *)(pDVar1 + 1) & 1) == 0)) {
		lego::res::Container_Mesh_GetVertices(RESDATA_00553180,*pDVar1,0,4,&local_90);
		lego::math::Maths_PlaneNormal(&local_a8,(Vector3F *)&local_90,local_6c,local_48);
		lego::math::Maths_PlaneNormal(&local_9c,local_48,local_24,(Vector3F *)&local_90);
		local_9c.y = local_9c.y + local_a8.y;
		local_9c.z = local_9c.z + local_a8.z;
		local_9c.x = local_9c.x + local_a8.x;
		fVar2 = 1.0 / SQRT(local_9c.x * local_9c.x + local_9c.z * local_9c.z + local_9c.y * local_9c.y);
		out_vector->x = fVar2 * local_9c.x;
		out_vector->y = fVar2 * local_9c.y;
		out_vector->z = fVar2 * local_9c.z;
		return 1;
	}
	return 0;
}



void __cdecl
lego::unk::Lego_LoadScrollInfoPanel__00463970
					(char *filename,int index,int param_3,int param_4,int param_5)
{
	ImageBMP *pIVar1;
	char **ppcVar2;
	int iVar3;
	
	ppcVar2 = (char **)&param_5;
	if (filename != (char *)0x0) {
		do {
			iVar3 = index * 0x20;
			*(undefined4 *)(&DAT_0055315c + iVar3) = 1;
			*(uint *)(&DAT_0055315c + iVar3) = (-(uint)((char *)param_3 != (char *)0x0) & 8) + 9;
			pIVar1 = image::Image_LoadBMPScaled(filename,0,0);
			*(ImageBMP **)(&DAT_00553140 + iVar3) = pIVar1;
			if (pIVar1 != (ImageBMP *)0x0) {
				*(uint *)(&DAT_0055315c + iVar3) = *(uint *)(&DAT_0055315c + iVar3) | 4;
			}
			filename = *ppcVar2;
			(&DAT_00553158)[index * 8] = param_4;
			index = (int)ppcVar2[1];
			param_3 = (int)ppcVar2[2];
			param_4 = (int)ppcVar2[3];
			ppcVar2 = ppcVar2 + 4;
		} while (filename != (char *)0x0);
	}
	return;
}



void __cdecl FUN_004639f0(int index,uint param_2,uint param_3)
{
	(&FLOAT_00553144)[index * 8] = (float)(ulonglong)param_2;
	(&FLOAT_00553148)[index * 8] = (float)(ulonglong)param_3;
	return;
}



void __cdecl
FUN_00463a30(int index,BOOL use50InsteadOf4c,Rect2F *rect,char *opt_filename1,char *opt_filename2)
{
	float fVar1;
	float fVar2;
	float *pfVar3;
	ImageBMP *pIVar4;
	
	if (use50InsteadOf4c == 0) {
		pfVar3 = (float *)std::malloc(0x1c);
		(&PTR_0055314c)[index * 8] = pfVar3;
	}
	else {
		pfVar3 = (float *)std::malloc(0x1c);
		(&PTR_00553150)[index * 8] = pfVar3;
	}
	*pfVar3 = rect->x;
	pfVar3[1] = rect->y;
	pfVar3[2] = rect->width + rect->x;
	fVar1 = rect->height;
	fVar2 = rect->y;
	pfVar3[4] = 0.0;
	pfVar3[5] = 0.0;
	pfVar3[3] = fVar1 + fVar2;
	if (opt_filename1 != (char *)0x0) {
		pIVar4 = lego::image::Image_LoadBMPScaled(opt_filename1,0,0);
		pfVar3[4] = (float)pIVar4;
	}
	if (opt_filename2 != (char *)0x0) {
		pIVar4 = lego::image::Image_LoadBMPScaled(opt_filename2,0,0);
		pfVar3[5] = (float)pIVar4;
	}
	pfVar3[6] = 0.0;
	return;
}



void __cdecl FUN_00463ad0(int param_1,float *param_2,int param_3,undefined4 param_4,char *param_5)
{
	void *pvVar1;
	ImageBMP *pIVar2;
	
	pvVar1 = std::malloc(0x28);
	(&DAT_00553154)[param_1 * 8] = pvVar1;
	pIVar2 = lego::image::Image_LoadBMPScaled(param_5,0,0);
	*(ImageBMP **)((&DAT_00553154)[param_1 * 8] + 0x18) = pIVar2;
	*(float *)(&DAT_00553154)[param_1 * 8] = *param_2;
	*(float *)((&DAT_00553154)[param_1 * 8] + 4) = param_2[1];
	*(float *)((&DAT_00553154)[param_1 * 8] + 8) = param_2[2] + *param_2;
	*(float *)((&DAT_00553154)[param_1 * 8] + 0xc) = param_2[3] + param_2[1];
	*(undefined4 *)((&DAT_00553154)[param_1 * 8] + 0x10) = 0;
	*(undefined4 *)((&DAT_00553154)[param_1 * 8] + 0x14) = 0;
	*(int *)((&DAT_00553154)[param_1 * 8] + 0x1c) = param_3 + -1;
	*(undefined4 *)((&DAT_00553154)[param_1 * 8] + 0x20) = param_4;
	return;
}



BOOL __cdecl FUN_00463b60(int *param_1,uint param_2,uint param_3,int param_4,int param_5)
{
	uint uVar1;
	int iVar2;
	float fVar3;
	float fVar4;
	BOOL BVar5;
	int iVar6;
	BOOL BVar7;
	uint uVar8;
	float *pfVar9;
	longlong lVar10;
	int local_60;
	int *local_5c;
	
	BVar7 = 0;
	local_60 = 0;
	local_5c = &DAT_00553158;
	do {
		if (((*(byte *)(local_5c + 1) & 4) != 0) && (BVar5 = FUN_0045adf0(*local_5c), BVar5 == 0)) {
			uVar8 = 0;
			do {
				if (uVar8 == 0) {
					pfVar9 = (float *)local_5c[-3];
				}
				else {
					pfVar9 = (float *)local_5c[-2];
				}
				if ((BVar7 == 0) && (BVar5 = FUN_00463ec0(local_5c + -6,pfVar9,param_2,param_3), BVar5 != 0)
					 ) {
					*param_1 = local_60;
					if (param_4 == 0) {
						if (INT_00553160 != 3) {
							if (uVar8 != INT_00553160) goto LAB_00463c6b;
							iVar2 = local_5c[-1];
							uVar1 = *(uint *)(iVar2 + 0x20);
							if (uVar8 == 0) {
								if (uVar1 < *(uint *)(iVar2 + 0x1c)) {
									iVar6 = uVar1 + 1;
LAB_00463c54:
									*(int *)(iVar2 + 0x20) = iVar6;
								}
							}
							else {
								if (uVar1 != 0) {
									iVar6 = uVar1 - 1;
									goto LAB_00463c54;
								}
							}
							*(undefined4 *)(local_5c[-1] + 0x24) = 1;
							pfVar9[6] = (float)((uint)pfVar9[6] & 0xfffffffb | 2);
							goto LAB_00463c6b;
						}
						BVar7 = 1;
						pfVar9[6] = (float)((uint)pfVar9[6] & 0xfffffffb | 2);
					}
					else {
						if (INT_00553160 == 3) {
							if (param_5 == 0) {
								BVar7 = 1;
								INT_00553160 = uVar8;
								pfVar9[6] = (float)((uint)pfVar9[6] & 0xfffffffd | 4);
							}
							else {
LAB_00463c6b:
								BVar7 = 1;
							}
						}
						else {
							if (uVar8 != INT_00553160) goto LAB_00463c6b;
							BVar7 = 1;
							pfVar9[6] = (float)((uint)pfVar9[6] & 0xfffffffd | 4);
						}
					}
				}
				else {
					pfVar9[6] = (float)((uint)pfVar9[6] & 0xfffffff9);
				}
				uVar8 = uVar8 + 1;
			} while (uVar8 < 2);
			if ((BVar7 == 0) && (BVar5 = FUN_00463f50((int)(local_5c + -6),param_2,param_3), BVar5 != 0))
			{
				if (param_4 == 0) {
					if (INT_00553160 == 3) {
						INT_00553160 = 2;
					}
					BOOL_005023c0 = 1;
				}
				else {
					if (INT_00553160 == 2) {
						if ((*(byte *)(local_5c + 1) & 8) == 0) {
							pfVar9 = (float *)local_5c[-1];
							fVar3 = (float)(ulonglong)(uint)pfVar9[7] / (pfVar9[2] - *pfVar9);
							fVar4 = (((float)(ulonglong)param_2 - PanelData_ARRAY_00501110[*local_5c].xyOutIn.x) -
											(float)local_5c[-5]) - *pfVar9;
						}
						else {
							iVar2 = local_5c[-1];
							fVar3 = (float)(ulonglong)*(uint *)(iVar2 + 0x1c) /
											(*(float *)(iVar2 + 0xc) - *(float *)(iVar2 + 4));
							fVar4 = (((float)(ulonglong)param_3 - PanelData_ARRAY_00501110[*local_5c].xyOutIn.y) -
											(float)local_5c[-4]) - *(float *)(iVar2 + 4);
						}
						lVar10 = lego::math::MathX_RoundToLL(fVar4 / fVar3);
						BVar7 = 1;
						*(int *)(local_5c[-1] + 0x20) = (int)lVar10;
						*(undefined4 *)(local_5c[-1] + 0x24) = 1;
						*param_1 = local_60;
						goto LAB_00463da4;
					}
				}
				BVar7 = 1;
				*param_1 = local_60;
			}
			else {
				BOOL_005023c0 = 0;
			}
LAB_00463da4:
			pfVar9 = (float *)local_5c[-1];
			if (pfVar9[9] != 0.0) {
				fVar3 = pfVar9[7];
				if ((*(byte *)(local_5c + 1) & 8) == 0) {
					if (fVar3 == 0.0) {
						fVar3 = *pfVar9 - (float)(ulonglong)*(uint *)((int)pfVar9[6] + 4);
					}
					else {
						fVar3 = (float)(ulonglong)(uint)pfVar9[8] *
										((float)(ulonglong)(uint)fVar3 /
										((pfVar9[2] - *pfVar9) - (float)(ulonglong)*(uint *)((int)pfVar9[6] + 4)));
					}
					pfVar9[4] = fVar3;
				}
				else {
					if (fVar3 == 0.0) {
						pfVar9[5] = 0.0;
					}
					else {
						pfVar9[5] = (float)(ulonglong)(uint)pfVar9[8] *
												((float)(ulonglong)(uint)fVar3 /
												((pfVar9[3] - pfVar9[1]) - (float)(ulonglong)*(uint *)((int)pfVar9[6] + 8)))
						;
					}
				}
				*(undefined4 *)(local_5c[-1] + 0x24) = 0;
			}
		}
		local_5c = local_5c + 8;
		local_60 = local_60 + 1;
		if ((int *)0x553177 < local_5c) {
			if ((param_4 == 0) && (BOOL_005023c0 == 0)) {
				INT_00553160 = 3;
			}
			return BVar7;
		}
	} while( true );
}



BOOL __cdecl FUN_00463ec0(int param_1,float *param_2,int param_3,int param_4)
{
	int iVar1;
	float fVar2;
	float fVar3;
	longlong lVar4;
	longlong lVar5;
	
	iVar1 = *(int *)(param_1 + 0x18);
	lVar4 = __ftol((float10)PanelData_ARRAY_00501110[iVar1].xyOutIn.x +
								 (float10)*(float *)(param_1 + 4));
	lVar5 = __ftol((float10)PanelData_ARRAY_00501110[iVar1].xyOutIn.y +
								 (float10)*(float *)(param_1 + 8));
	fVar2 = (float)(param_3 - (int)lVar4);
	if ((((*param_2 <= fVar2) && (fVar3 = (float)(param_4 - (int)lVar5), fVar3 < param_2[3])) &&
			(param_2[1] <= fVar3)) && (fVar2 < param_2[2])) {
		return 1;
	}
	return 0;
}



BOOL __cdecl FUN_00463f50(int param_1,int param_2,int param_3)
{
	int iVar1;
	float *pfVar2;
	float fVar3;
	float fVar4;
	longlong lVar5;
	longlong lVar6;
	
	iVar1 = *(int *)(param_1 + 0x18);
	lVar5 = __ftol((float10)PanelData_ARRAY_00501110[iVar1].xyOutIn.x +
								 (float10)*(float *)(param_1 + 4));
	lVar6 = __ftol((float10)PanelData_ARRAY_00501110[iVar1].xyOutIn.y +
								 (float10)*(float *)(param_1 + 8));
	fVar3 = (float)(param_2 - (int)lVar5);
	pfVar2 = *(float **)(param_1 + 0x14);
	if ((((*pfVar2 <= fVar3) && (fVar4 = (float)(param_3 - (int)lVar6), fVar4 < pfVar2[3])) &&
			(pfVar2[1] <= fVar4)) && (fVar3 < pfVar2[2])) {
		return 1;
	}
	return 0;
}



void __cdecl FUN_00463fe0(int index)
{
	float *pfVar1;
	uint uVar2;
	ImageBMP *image;
	Point2F local_10;
	Point2F local_8;
	
	local_10.x = (&FLOAT_00553144)[index * 8] +
							 PanelData_ARRAY_00501110[(&DAT_00553158)[index * 8]].xyOutIn.x;
	local_10.y = (&FLOAT_00553148)[index * 8] +
							 PanelData_ARRAY_00501110[(&DAT_00553158)[index * 8]].xyOutIn.y;
	lego::image::Image_DisplayScaled
						(*(ImageBMP **)(&DAT_00553140 + index * 0x20),(Rect2F *)0x0,&local_10,(Size2F *)0x0);
	uVar2 = 0;
	do {
		if (uVar2 == 0) {
			pfVar1 = (float *)(&PTR_0055314c)[index * 8];
		}
		else {
			pfVar1 = (float *)(&PTR_00553150)[index * 8];
		}
		if ((((uint)pfVar1[6] & 2) == 0) || (pfVar1[4] == 0.0)) {
			if ((((uint)pfVar1[6] & 4) != 0) && (pfVar1[5] != 0.0)) {
				local_8.x = *pfVar1;
				local_8.y = pfVar1[1];
				image = (ImageBMP *)pfVar1[5];
				goto LAB_004640a7;
			}
		}
		else {
			local_8.x = *pfVar1;
			local_8.y = pfVar1[1];
			image = (ImageBMP *)pfVar1[4];
LAB_004640a7:
			local_8.y = local_8.y + local_10.y;
			local_8.x = local_8.x + local_10.x;
			lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,&local_8,(Size2F *)0x0);
		}
		uVar2 = uVar2 + 1;
		if (1 < uVar2) {
			pfVar1 = (float *)(&DAT_00553154)[index * 8];
			local_8.x = pfVar1[4] + local_10.x + *pfVar1;
			local_8.y = pfVar1[1] + pfVar1[5] + local_10.y;
			lego::image::Image_DisplayScaled((ImageBMP *)pfVar1[6],(Rect2F *)0x0,&local_8,(Size2F *)0x0);
			return;
		}
	} while( true );
}



longlong __cdecl lego::math::MathX_RoundToLL(float x)
{
	float10 fVar1;
	longlong lVar2;
	double x_;
	
	x_ = (double)x;
	fVar1 = __floor(x_);
	if ((float10)x - fVar1 < (float10)0.5) {
		fVar1 = __floor(x_);
		lVar2 = __ftol(fVar1);
		return lVar2;
	}
	fVar1 = std::ceil(x_);
	lVar2 = __ftol(fVar1);
	return lVar2;
}



void __cdecl
lego::draw::Draw_UnkFuncOfInterestTable__00464160
					(int index,undefined4 *out_param_2,undefined4 *out_param_3)
{
	*out_param_2 = *(undefined4 *)((&DAT_00553154)[index * 8] + 0x1c);
	*out_param_3 = *(undefined4 *)((&DAT_00553154)[index * 8] + 0x20);
	return;
}



void __cdecl FUN_00464190(int index,undefined4 param_2,undefined4 param_3)
{
	*(undefined4 *)((&DAT_00553154)[index * 8] + 0x1c) = param_2;
	*(undefined4 *)((&DAT_00553154)[index * 8] + 0x20) = param_3;
	*(undefined4 *)((&DAT_00553154)[index * 8] + 0x24) = 1;
	return;
}



int ** __cdecl lego::res::Res_FUN_004641c0(Container *in_resData,float param_2)
{
	int iVar1;
	DWORD DVar2;
	Container **buffer;
	Container *pCVar3;
	uint *puVar4;
	uint *puVar5;
	DWORD *pDVar6;
	int *piVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	int iVar11;
	DWORD *pDVar12;
	D3DRMGroupIndex local_184;
	DWORD local_17c [4];
	DWORD local_16c [4];
	int local_15c [4];
	undefined4 local_14c;
	undefined4 local_148;
	DWORD local_144;
	undefined4 local_140;
	undefined4 local_13c;
	undefined4 local_138;
	undefined4 local_134;
	undefined4 local_130;
	undefined4 local_12c;
	undefined4 local_128;
	undefined4 local_124;
	undefined4 local_120;
	undefined4 local_11c;
	undefined4 local_118;
	undefined4 local_114;
	undefined4 local_110;
	undefined4 local_10c;
	uint local_108 [30];
	D3DRMVertex local_90 [4];
	
	buffer = (Container **)std::malloc(8);
	if (buffer != (Container **)0x0) {
		*buffer = (Container *)0x0;
		buffer[1] = (Container *)0x0;
		pCVar3 = Container_MakeMesh2(in_resData,3);
		*buffer = pCVar3;
		if (pCVar3 != (Container *)0x0) {
			local_16c[0] = 0;
			local_15c[1] = 1;
			local_15c[3] = 1;
			local_16c[1] = 0x3f800000;
			local_16c[2] = 0x3f800000;
			local_16c[3] = 0;
			local_17c[0] = 0;
			local_17c[1] = 0;
			local_17c[2] = 0x3f800000;
			local_17c[3] = 0x3f800000;
			local_144 = 0;
			local_140 = 0;
			local_13c = 0xbf800000;
			local_138 = 0;
			local_134 = 0x3f800000;
			local_130 = 0;
			local_12c = 0x3f800000;
			local_128 = 0;
			local_124 = 0;
			local_120 = 0;
			local_11c = 0xbf800000;
			local_118 = 0;
			local_114 = 0xbf800000;
			local_110 = 0;
			local_10c = 0;
			local_15c[0] = 0;
			local_15c[2] = 3;
			local_14c = 2;
			local_148 = 3;
			uVar10 = 0;
			puVar4 = local_108;
			do {
				piVar7 = local_15c;
				iVar11 = 6;
				puVar5 = puVar4;
				do {
					puVar4 = puVar5 + 1;
					iVar1 = *piVar7;
					piVar7 = piVar7 + 1;
					iVar11 = iVar11 + -1;
					*puVar5 = uVar10 + iVar1;
					puVar5 = puVar4;
				} while (iVar11 != 0);
				uVar10 = uVar10 + 4;
			} while (uVar10 < 0x14);
			local_184 = D3DRMGROUP_0;
			buffer[1] = (Container *)param_2;
			do {
				Container_Mesh_AddGroup(*buffer,0x14,10,3,local_108);
				uVar10 = 0;
				pDVar12 = &local_144;
				do {
					pDVar6 = &local_90[0].colour;
					uVar8 = 0;
					do {
						uVar9 = uVar8 + 4;
						pDVar6[-5] = *pDVar12;
						pDVar6[-4] = pDVar12[1];
						pDVar6[-3] = pDVar12[2];
						DVar2 = *(DWORD *)((int)local_16c + uVar8);
						*pDVar6 = 0xffffffff;
						pDVar6[-2] = DVar2;
						pDVar6[-1] = *(DWORD *)((int)local_17c + uVar8);
						pDVar6 = pDVar6 + 9;
						uVar8 = uVar9;
					} while (uVar9 < 0x10);
					Container_Mesh_SetVertices(*buffer,local_184,uVar10,4,local_90);
					uVar10 = uVar10 + 4;
					pDVar12 = pDVar12 + 3;
				} while (uVar10 < 0x14);
				Container_Mesh_SetQuality(*buffer,local_184,QUALITY_GOURAUD);
				local_184 = local_184 + 1;
			} while (local_184 < 10);
			Container_Hide(*buffer,1);
			return (int **)buffer;
		}
		std::free(buffer);
	}
	return (int **)(Container **)0x0;
}



// Translate and rotate a set of integer points (max of 20).
// Returns a pointer to a temporary buffer that will be modified when this function is next called.
// 
// DIRECTION_UP is "no rotation"

Point2I * __cdecl
lego::game::Game_TransformShapePoints
					(Point2I *translation,Point2I *shapePoints,int shapeCount,Direction rotation)
{
	Point2I *dstPoint;
	uint signBit;
	int swapPoint_x;
	
	if (shapeCount != 0) {
		signBit = (int)(rotation + 0x8000) >> 0x1f;
		dstPoint = globals::tmp_TransformShapePoints;
		do {
										// POINTER MATH to get shapePoints[i] from dstPoints[i]
										// dstPoint->x = shapePoints[i].x;
										// dstPoint->y = shapePoints[i].y;
			dstPoint->x = *(int *)((int)&dstPoint->x + (int)&shapePoints[-0xa0479].x);
			dstPoint->y = *(int *)((int)((int)shapePoints + -0x5023c4) + (int)dstPoint);
										// apply rotation to dstPoints[i]
										// positive modulus (direction % 4)
										// case DIRECTION_UP: // (x, y)  no change
			switch(((rotation + 0x8000 ^ signBit) - signBit & 3 ^ signBit) - signBit) {
			default:
				goto switchD_0046441a_caseD_0;
			case DIRECTION_RIGHT:
										// (-y, x)
				swapPoint_x = dstPoint->x;
				dstPoint->x = -dstPoint->y;
				goto LAB_00464440;
			case DIRECTION_DOWN:
										// (-x, -y)
				dstPoint->x = -dstPoint->x;
				swapPoint_x = dstPoint->y;
				break;
			case DIRECTION_LEFT:
										// (y, -x)
				swapPoint_x = dstPoint->x;
				dstPoint->x = dstPoint->y;
			}
			swapPoint_x = -swapPoint_x;
LAB_00464440:
			dstPoint->y = swapPoint_x;
switchD_0046441a_caseD_0:
										// apply translation to dstPoints[i]
			dstPoint->x = dstPoint->x + translation->x;
			shapeCount = shapeCount + -1;
			dstPoint->y = dstPoint->y + translation->y;
			dstPoint = dstPoint + 1;
		} while (shapeCount != 0);
	}
	return globals::tmp_TransformShapePoints;
}



uint __cdecl
lego::res::ResLp_UnkSurfaceMap_FUN_00464480
					(Container **pResData,int *param_2,int param_3,uint param_4,Direction direction,
					SurfaceMap *surfMap,int param_7)
{
	int iVar1;
	D3DRMGroupIndex group;
	bool bVar2;
	bool bVar3;
	bool bVar4;
	bool bVar5;
	byte bVar6;
	Point2I *pPVar7;
	BOOL BVar8;
	uint uVar9;
	int iVar10;
	float *pfVar11;
	int *piVar12;
	D3DRMVertex *pDVar13;
	D3DRMVertex *pDVar14;
	uint uVar15;
	int iVar16;
	int *piVar17;
	Point2I *pPVar18;
	Point2I *pPVar19;
	float local_3d8;
	float local_3d4;
	uint local_3d0;
	Point2I *local_3cc;
	Point2I *local_3c8;
	float local_3c4;
	D3DRMGroupIndex local_3c0;
	Point2I local_3ac;
	BOOL local_3a4;
	int local_3a0 [5];
	undefined4 local_38c;
	undefined4 local_388;
	undefined4 local_384;
	int local_380 [4];
	undefined4 local_370;
	undefined4 local_36c;
	undefined4 local_368;
	undefined4 local_364;
	undefined4 local_360;
	undefined4 local_35c;
	undefined4 local_358;
	undefined4 local_354;
	undefined4 local_350;
	undefined4 local_34c;
	undefined4 local_348;
	undefined4 local_344;
	undefined4 local_340;
	undefined4 local_33c;
	undefined4 local_338;
	undefined4 local_334;
	float local_330 [24];
	D3DRMVertex local_2d0 [20];
	
	local_380[2] = 2;
	local_354 = 2;
	local_350 = 2;
	local_380[3] = 3;
	local_368 = 5;
	local_35c = 5;
	local_344 = 3;
	local_340 = 3;
	local_380[1] = 1;
	local_364 = 1;
	local_360 = 1;
	bVar6 = 1;
	local_348 = 7;
	local_33c = 7;
	local_358 = 6;
	local_34c = 6;
	uVar15 = 0;
	local_3c0 = D3DRMGROUP_0;
	local_380[0] = 0;
	local_370 = 0;
	local_36c = 4;
	local_338 = 4;
	local_334 = 0;
	pPVar7 = game::Game_TransformShapePoints((Point2I *)param_2,(Point2I *)param_3,param_4,direction);
	local_3a4 = game::SurfaceMap_FUN_0044eb80
												((globals::g_Game.level)->surfaceMap,(uint *)pPVar7,param_4,
												 (globals::g_Game.level)->BuildingTolerance,
												 (globals::g_Game.level)->BuildingMaxVariation);
	bVar5 = false;
	bVar4 = false;
	bVar3 = false;
	if (param_4 != 0) {
		local_3a0[2] = 1;
		local_38c = 1;
		local_3a0[0] = 0;
		local_3a0[1] = 0xffffffff;
		local_3a0[3] = 0;
		local_3a0[4] = 0;
		local_388 = 0xffffffff;
		local_384 = 0;
		piVar12 = &pPVar7->y;
		pPVar19 = pPVar7;
		pPVar18 = pPVar7;
		do {
			local_3c8 = pPVar18 + 1;
			bVar2 = false;
			piVar17 = local_3a0 + 1;
			local_3cc = (Point2I *)0x4;
			do {
				local_3ac.x = piVar17[-1] + pPVar19->x;
				local_3ac.y = *piVar12 + *piVar17;
				BVar8 = game::Level_IsBlockPowerPath(&local_3ac);
				if ((BVar8 != 0) && (uVar9 = FUN_00432f60((int *)&local_3ac), uVar9 == 0)) {
					bVar4 = true;
					bVar2 = true;
				}
				piVar17 = piVar17 + 2;
				local_3cc = (Point2I *)((int)local_3cc + -1);
			} while (local_3cc != (Point2I *)0x0);
			if (((uVar15 < param_4 - 1) && (pPVar19->x == local_3c8->x)) && (*piVar12 == pPVar18[1].y)) {
				if (bVar2) {
					bVar5 = true;
				}
				uVar15 = uVar15 + 1;
				pPVar19 = pPVar19 + 1;
				piVar12 = piVar12 + 2;
				bVar3 = true;
				local_3c8 = pPVar18 + 2;
			}
			uVar15 = uVar15 + 1;
			pPVar19 = pPVar19 + 1;
			piVar12 = piVar12 + 2;
			pPVar18 = local_3c8;
		} while (uVar15 < param_4);
	}
	if (bVar3) {
		bVar4 = bVar5;
	}
	local_3d0 = 0;
	group = D3DRMGROUP_0;
	if (param_4 != 0) {
		local_3ac.x = param_4 - 1;
		pPVar18 = pPVar7;
		pPVar19 = pPVar7;
		do {
			local_3cc = pPVar19 + 1;
			if (((local_3d0 < (uint)local_3ac.x) && (pPVar18->x == local_3cc->x)) &&
				 (pPVar18->y == pPVar19[1].y)) {
				iVar16 = 1;
				local_3c8 = (Point2I *)0x1;
				if (param_7 + 1 <= local_3c0) goto LAB_0046471f;
			}
			else {
				local_3c8 = (Point2I *)0x0;
LAB_0046471f:
				iVar16 = 0;
			}
			iVar10 = FUN_00431a50(pPVar18->x,pPVar18->y,(int)local_3c8,iVar16);
			if (((iVar10 == 0) || (!bVar4)) ||
				 (local_3d8 = (float)game::Level_BlockPointerCheck((Point2I *)param_2), local_3d8 != 0.0)) {
				bVar6 = 0;
				local_3d8 = 0.6;
				local_3d4 = 0.0;
LAB_004647ee:
				local_3c4 = 0.0;
			}
			else {
				if (iVar16 == 0) {
					if (local_3c8 != (Point2I *)0x0) {
						local_3d8 = 0.7;
						local_3d4 = 0.7;
						goto LAB_004647ee;
					}
					if (local_3a4 == 0) {
						bVar6 = 0;
						local_3d8 = 0.7;
						local_3d4 = 0.0;
						local_3c4 = 0.7;
					}
					else {
						local_3d8 = 0.0;
						local_3d4 = 0.7;
						local_3c4 = 0.1;
					}
				}
				else {
					local_3d4 = 0.7;
					local_3c4 = 0.9;
				}
			}
			Container_Mesh_SetColourAlpha(*pResData,local_3c0,local_3d8,local_3d4,local_3c4,0.2);
			Container_Mesh_SetEmissive
								(*pResData,local_3c0,local_3d8 * 0.5,local_3d4 * 0.5,local_3c4 * 0.5);
			BVar8 = game::SurfaceMap_IsInsideDimensions(surfMap,pPVar18->x,pPVar18->y);
			if (BVar8 == 0) {
				Container_Mesh_HideGroup(*pResData,local_3c0,1);
			}
			else {
				game::SurfaceMap_FillLargeStruct_AtXY_FUN_004504e0(surfMap,pPVar18->x,pPVar18->y,local_330);
				iVar16 = 4;
				pfVar11 = local_330 + 2;
				do {
					iVar16 = iVar16 + -1;
					pfVar11[10] = pfVar11[-2];
					pfVar11[0xb] = pfVar11[-1];
					pfVar11[0xc] = *pfVar11;
					*pfVar11 = *pfVar11 - (float)pResData[1];
					pfVar11 = pfVar11 + 3;
				} while (iVar16 != 0);
				Container_Mesh_GetVertices(*pResData,local_3c0,0,0x14,local_2d0);
				piVar12 = local_380;
				pDVar13 = local_2d0;
				iVar16 = 5;
				do {
					iVar10 = 4;
					pDVar14 = pDVar13;
					do {
						iVar1 = *piVar12;
						piVar12 = piVar12 + 1;
						pDVar13 = pDVar14 + 1;
						iVar10 = iVar10 + -1;
						(pDVar14->position).x = local_330[iVar1 * 3];
						(pDVar14->position).y = local_330[iVar1 * 3 + 1];
						(pDVar14->position).z = local_330[iVar1 * 3 + 2];
						pDVar14 = pDVar13;
					} while (iVar10 != 0);
					iVar16 = iVar16 + -1;
				} while (iVar16 != 0);
				Container_Mesh_SetVertices(*pResData,local_3c0,0,0x14,local_2d0);
				Container_Mesh_HideGroup(*pResData,local_3c0,0);
			}
			local_3c0 = local_3c0 + 1;
			if (local_3c8 != (Point2I *)0x0) {
				local_3d0 = local_3d0 + 1;
				pPVar18 = pPVar18 + 1;
				local_3cc = pPVar19 + 2;
			}
			local_3d0 = local_3d0 + 1;
			pPVar18 = pPVar18 + 1;
			pPVar19 = local_3cc;
			group = local_3c0;
		} while (local_3d0 < param_4);
	}
	for (; group < 10; group = group + 1) {
		Container_Mesh_HideGroup(*pResData,group,1);
	}
	return -(uint)bVar6 & (uint)pPVar7;
}



void __cdecl lego::res::ResLp_UnkSetup3DFrameTransform(Container **pResData,BOOL use3rdFrame)
{
	Container_Hide(*pResData,use3rdFrame);
	return;
}



void __cdecl lego::snd::SFX_InitHashNames(void)
{
	uint uVar1;
	
										// new uint[495]
	globals::g_SFXHashNames_TABLE = (uint *)std::malloc(0x7bc);
	uVar1 = util::Util_HashString("SFX_NULL",0,1);
	*globals::g_SFXHashNames_TABLE = uVar1;
	uVar1 = util::Util_HashString("SFX_Stamp",0,1);
	globals::g_SFXHashNames_TABLE[1] = uVar1;
	uVar1 = util::Util_HashString("SFX_Drill",0,1);
	globals::g_SFXHashNames_TABLE[2] = uVar1;
	uVar1 = util::Util_HashString("SFX_DrillFade",0,1);
	globals::g_SFXHashNames_TABLE[3] = uVar1;
	uVar1 = util::Util_HashString("SFX_RockBreak",0,1);
	globals::g_SFXHashNames_TABLE[4] = uVar1;
	uVar1 = util::Util_HashString("SFX_Drip",0,1);
	globals::g_SFXHashNames_TABLE[5] = uVar1;
	uVar1 = util::Util_HashString("SFX_Ambient",0,1);
	globals::g_SFXHashNames_TABLE[6] = uVar1;
	uVar1 = util::Util_HashString("SFX_AmbientLoop",0,1);
	globals::g_SFXHashNames_TABLE[7] = uVar1;
	uVar1 = util::Util_HashString("SFX_Step",0,1);
	globals::g_SFXHashNames_TABLE[8] = uVar1;
	uVar1 = util::Util_HashString("SFX_RockMonster",0,1);
	globals::g_SFXHashNames_TABLE[9] = uVar1;
	uVar1 = util::Util_HashString("SFX_RockMonster2",0,1);
	globals::g_SFXHashNames_TABLE[10] = uVar1;
	uVar1 = util::Util_HashString("SFX_RockMonsterStep",0,1);
	globals::g_SFXHashNames_TABLE[0xb] = uVar1;
	uVar1 = util::Util_HashString("SFX_MFDeposit",0,1);
	globals::g_SFXHashNames_TABLE[0xc] = uVar1;
	uVar1 = util::Util_HashString("SFX_ButtonPressed",0,1);
	globals::g_SFXHashNames_TABLE[0xd] = uVar1;
	uVar1 = util::Util_HashString("SFX_MFLift",0,1);
	globals::g_SFXHashNames_TABLE[0xe] = uVar1;
	uVar1 = util::Util_HashString("SFX_MFThrow",0,1);
	globals::g_SFXHashNames_TABLE[0xf] = uVar1;
	uVar1 = util::Util_HashString("SFX_Walker",0,1);
	globals::g_SFXHashNames_TABLE[0x10] = uVar1;
	uVar1 = util::Util_HashString("SFX_YesSir",0,1);
	globals::g_SFXHashNames_TABLE[0x11] = uVar1;
	uVar1 = util::Util_HashString("SFX_Build",0,1);
	globals::g_SFXHashNames_TABLE[0x12] = uVar1;
	uVar1 = util::Util_HashString("SFX_Okay",0,1);
	globals::g_SFXHashNames_TABLE[0x13] = uVar1;
	uVar1 = util::Util_HashString("SFX_NotOkay",0,1);
	globals::g_SFXHashNames_TABLE[0x14] = uVar1;
	uVar1 = util::Util_HashString("SFX_InterfaceSlideOnScreen",0,1);
	globals::g_SFXHashNames_TABLE[0x15] = uVar1;
	uVar1 = util::Util_HashString("SFX_InterfaceSlideOffScreen",0,1);
	globals::g_SFXHashNames_TABLE[0x16] = uVar1;
	uVar1 = util::Util_HashString("SFX_PanelSlideOnScreen",0,1);
	globals::g_SFXHashNames_TABLE[0x17] = uVar1;
	uVar1 = util::Util_HashString("SFX_PanelSlideOffScreen",0,1);
	globals::g_SFXHashNames_TABLE[0x18] = uVar1;
	uVar1 = util::Util_HashString("SFX_Siren",0,1);
	globals::g_SFXHashNames_TABLE[0x19] = uVar1;
	uVar1 = util::Util_HashString("SFX_CrystalRecharge",0,1);
	globals::g_SFXHashNames_TABLE[0x1a] = uVar1;
	uVar1 = util::Util_HashString("SFX_Laser",0,1);
	globals::g_SFXHashNames_TABLE[0x1b] = uVar1;
	uVar1 = util::Util_HashString("SFX_LaserHit",0,1);
	globals::g_SFXHashNames_TABLE[0x1c] = uVar1;
	uVar1 = util::Util_HashString("SFX_LazerRecharge",0,1);
	globals::g_SFXHashNames_TABLE[0x1d] = uVar1;
	uVar1 = util::Util_HashString("SFX_TopPriority",0,1);
	globals::g_SFXHashNames_TABLE[0x1e] = uVar1;
	uVar1 = util::Util_HashString("SFX_ImmovableRock",0,1);
	globals::g_SFXHashNames_TABLE[0x1f] = uVar1;
	uVar1 = util::Util_HashString("SFX_Wall",0,1);
	globals::g_SFXHashNames_TABLE[0x20] = uVar1;
	uVar1 = util::Util_HashString("SFX_Floor",0,1);
	globals::g_SFXHashNames_TABLE[0x21] = uVar1;
	uVar1 = util::Util_HashString("SFX_BoulderHit",0,1);
	globals::g_SFXHashNames_TABLE[0x22] = uVar1;
	uVar1 = util::Util_HashString("SFX_Place",0,1);
	globals::g_SFXHashNames_TABLE[0x23] = uVar1;
	uVar1 = util::Util_HashString("SFX_PlaceOre",0,1);
	globals::g_SFXHashNames_TABLE[0x24] = uVar1;
	uVar1 = util::Util_HashString("SFX_PlaceCrystal",0,1);
	globals::g_SFXHashNames_TABLE[0x25] = uVar1;
	uVar1 = util::Util_HashString("SFX_Lava",0,1);
	globals::g_SFXHashNames_TABLE[0x26] = uVar1;
	uVar1 = util::Util_HashString("SFX_RockWipe",0,1);
	globals::g_SFXHashNames_TABLE[0x27] = uVar1;
	uVar1 = util::Util_HashString("SFX_FallIn",0,1);
	globals::g_SFXHashNames_TABLE[0x28] = uVar1;
	uVar1 = util::Util_HashString("SFX_MusicLoop",0,1);
	globals::g_SFXHashNames_TABLE[0x29] = uVar1;
	uVar1 = util::Util_HashString("SFX_CaptainSlide",0,1);
	globals::g_SFXHashNames_TABLE[0x2a] = uVar1;
	uVar1 = util::Util_HashString("SFX_Dynamite",0,1);
	globals::g_SFXHashNames_TABLE[0x2b] = uVar1;
	uVar1 = util::Util_HashString("SFX_AmbientMusicLoop",0,1);
	globals::g_SFXHashNames_TABLE[0x2c] = uVar1;
	res::Container_SetSoundTriggerCallback(res::Res_ResourceSoundCallback,0);
	return;
}



void __cdecl lego::res::Res_ResourceSoundCallback(char *sampleName,Container *resData,void *lpValue)
{
	BOOL BVar1;
	
	BVar1 = snd::SFX_GetType(sampleName,(SFXType *)&sampleName);
	if (BVar1 != 0) {
		Res_PlayResourceSound(resData,(SFXType)sampleName,0,1,(Vector3F *)0x0);
	}
	return;
}



void __cdecl lego::snd::Audio_SetAudioFlag2(BOOL state)
{
	if (state != 0) {
		globals::g_AudioFlags = globals::g_AudioFlags | AUDIO_UNK_2;
		return;
	}
	globals::g_AudioFlags = globals::g_AudioFlags & ~AUDIO_UNK_2;
	return;
}



BOOL __cdecl lego::snd::SFX_GetType(char *sfxName,SFXType *out_sfxType)
{
	SFXType SVar1;
	uint uVar2;
	SFXType SVar3;
	uint *puVar4;
	
	if (sfxName != (char *)0x0) {
										// hash_string(sfxName, false (!bIgnoreBlanks), true (bIgnoreCase))
		uVar2 = util::Util_HashString(sfxName,FALSE,TRUE);
		SVar3 = SFX_NULL;
		SVar1 = globals::g_SFXHashNames_COUNT + 0x2d;
		puVar4 = globals::g_SFXHashNames_TABLE;
		if (SVar1 != SFX_NULL) {
			do {
				if (uVar2 == *puVar4) {
					*out_sfxType = SVar3;
					return 1;
				}
				SVar3 = SVar3 + SFX_STAMP;
				puVar4 = puVar4 + 1;
			} while (SVar3 < SVar1);
		}
										// This flag presumably states the SFX table is still being built
		if (((byte)globals::g_AudioFlags & AUDIO_UNK_2) != 0) {
			*out_sfxType = SVar1;
										// hash_string(sfxName, false (!bIgnoreBlanks), true (bIgnoreCase))
			uVar2 = util::Util_HashString(sfxName,FALSE,TRUE);
			globals::g_SFXHashNames_TABLE[SVar1] = uVar2;
			globals::g_SFXHashNames_COUNT = globals::g_SFXHashNames_COUNT + 1;
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::snd::Sample_LoadProperty(char *value,int index)
{
	char cVar1;
	uint uVar2;
	SampleProperty *pSVar3;
	char cVar4;
	int iVar5;
	char *pcVar6;
	BOOL stream;
	char *pcVar7;
	SampleProperty *pSVar8;
	char **local_1e0;
	int numParts;
	BOOL success;
	SampleProperty *lastItem;
	char pound_buffer [64];
	char *filename_parts [100];
	
	pSVar8 = globals::g_SampleProperties_TABLE + index;
	stream = 0;
	success = 1;
	lastItem = (SampleProperty *)0x0;
	globals::g_SampleProperties_TABLE[index].next = (SampleProperty *)0x0;
	numParts = util::Util_Tokenise(value,filename_parts,",");
	if (numParts != 0) {
		local_1e0 = filename_parts;
		do {
			pcVar7 = *local_1e0;
			cVar1 = *pcVar7;
			if (cVar1 == '*') {
				pcVar7 = pcVar7 + 1;
			}
			iVar5 = 0;
			if (*pcVar7 == '#') {
				cVar4 = pcVar7[1];
				pcVar7 = pcVar7 + 1;
				if (cVar4 != '#') {
					pcVar6 = pound_buffer;
					do {
						*pcVar6 = cVar4;
						cVar4 = pcVar7[1];
						pcVar6 = pcVar6 + 1;
						pcVar7 = pcVar7 + 1;
					} while (cVar4 != '#');
				}
				iVar5 = std::atoi(pound_buffer);
				pcVar7 = pcVar7 + 1;
			}
			if (*pcVar7 == '@') {
				stream = 1;
				pcVar7 = pcVar7 + 1;
			}
			iVar5 = Sound3D_Load(pcVar7,stream,(uint)(cVar1 == '*'),iVar5);
			pSVar8->sampleIndex = iVar5;
			uVar2 = globals::g_SampleGroups_COUNT;
			if (iVar5 == -1) {
				success = 0;
				pSVar3 = lastItem;
			}
			else {
				pSVar3 = pSVar8;
				if (lastItem != (SampleProperty *)0x0) {
					pSVar8 = globals::g_SampleGroups_TABLE + globals::g_SampleGroups_COUNT;
					globals::g_SampleGroups_COUNT = globals::g_SampleGroups_COUNT + 1;
					lastItem->next = pSVar8;
					globals::g_SampleGroups_TABLE[uVar2].next = (SampleProperty *)0x0;
					pSVar3 = pSVar8;
				}
			}
			lastItem = pSVar3;
			local_1e0 = local_1e0 + 1;
			numParts = numParts + -1;
		} while (numParts != 0);
	}
	return success;
}



int __cdecl lego::snd::Sample_ChooseRandomSound(SFXType sfxType)
{
	SampleProperty *pSVar1;
	SampleProperty *pSVar2;
	int iVar3;
	short sVar4;
	uint uVar5;
	
	uVar5 = 0;
	if (sfxType != SFX_NULL) {
		if (globals::g_SampleProperties_TABLE[sfxType].next != (SampleProperty *)0x0) {
			pSVar1 = globals::g_SampleProperties_TABLE + sfxType;
			for (pSVar2 = pSVar1; pSVar2 != (SampleProperty *)0x0; pSVar2 = pSVar2->next) {
				uVar5 = uVar5 + 1;
			}
			sVar4 = math::Maths_Rand();
			pSVar2 = pSVar1;
			for (uVar5 = (uint)(int)sVar4 % uVar5; uVar5 != 0; uVar5 = uVar5 - 1) {
				pSVar2 = pSVar2->next;
			}
			iVar3 = pSVar2->sampleIndex;
			pSVar2->sampleIndex = pSVar1->sampleIndex;
			pSVar1->sampleIndex = iVar3;
		}
		return globals::g_SampleProperties_TABLE[sfxType].sampleIndex;
	}
	return -1;
}



void __cdecl lego::snd::Audio_FUN_00465140(void)
{
	if ((globals::g_GlobalSampleUnkInt != SFX__INVALID) &&
		 ((ushort)((ushort)(globals::g_GlobalSampleDuration < 0.0) << 8 |
							(ushort)(globals::g_GlobalSampleDuration == 0.0) << 0xe) == 0)) {
		Sample_StopSoundBufferInstance(globals::g_GlobalSampleUnkInt);
		globals::g_GlobalSampleUnkInt = SFX__INVALID;
		globals::g_GlobalSampleDuration = 0.0;
	}
	return;
}



BOOL __cdecl lego::snd::Audio_FUN_00465180(float duration)
{
	if ((ushort)((ushort)(globals::g_GlobalSampleDuration < 0.0) << 8 |
							(ushort)(globals::g_GlobalSampleDuration == 0.0) << 0xe) != 0) {
		globals::g_GlobalSampleDuration = duration;
		globals::g_GlobalSampleUnkInt = SFX__INVALID;
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::snd::Audio_FUN_004651b0(SFXType sfxType,int *out_param_2)
{
	uint uVar1;
	uint in_EAX;
	SFXType SVar2;
	float10 fVar3;
	
	uVar1 = (uint)(ushort)((ushort)(globals::g_GlobalSampleDuration < 0.0) << 8 |
												(ushort)(globals::g_GlobalSampleDuration == 0.0) << 0xe);
	SVar2 = in_EAX & 0xffff0000 | uVar1;
	if (uVar1 != 0) {
		Audio_Play_FUN_00465260(sfxType,0);
		globals::g_GlobalSampleUnkInt = SVar2;
		if (SVar2 != SFX__INVALID) {
			fVar3 = Sample_GetRandomDuration(sfxType);
			globals::g_GlobalSampleIndex = sfxType;
			globals::g_GlobalSampleDuration = (float)(fVar3 * (float10)25.0);
			if (out_param_2 != (int *)0x0) {
				*out_param_2 = globals::g_GlobalSampleUnkInt;
			}
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::snd::Audio_AddToSoundQueue1(SFXType sfxType,BOOL mode)
{
	if (globals::g_SoundQueue_Unk1_COUNT < 10) {
		globals::g_SoundQueueIndexes_Unk1_TABLE[globals::g_SoundQueue_Unk1_COUNT] = sfxType;
		globals::g_SoundQueueModes_Unk1_TABLE[globals::g_SoundQueue_Unk1_COUNT] = mode;
		globals::g_SoundQueue_Unk1_COUNT = globals::g_SoundQueue_Unk1_COUNT + 1;
	}
	return;
}



void __cdecl lego::snd::Audio_Play_FUN_00465260(SFXType sfxType,BOOL loop)
{
	Sound3DInstance *pSVar1;
	uint uVar2;
	int soundTableIndex;
	
	uVar2 = globals::g_Sound3DInstances_COUNT;
	if (((byte)globals::g_AudioFlags & AUDIO_UNK_8) == 0) {
		if ((sfxType != SFX_NULL) && (((byte)globals::g_AudioFlags & AUDIO_SOUNDON) != 0)) {
			soundTableIndex = Sample_ChooseRandomSound(sfxType);
			if (soundTableIndex != 0) {
				Sound3D_Play2(SOUND3D_PLAY_NORMAL,(IDirect3DRMFrame3 *)0x0,soundTableIndex,loop,
											(Vector3F *)0x0);
			}
		}
	}
	else {
		if (globals::g_Sound3DInstances_COUNT < 10) {
			pSVar1 = globals::g_Sound3DInstances_TABLE + globals::g_Sound3DInstances_COUNT;
			globals::g_Sound3DInstances_COUNT = globals::g_Sound3DInstances_COUNT + 1;
			pSVar1->sampleIndex = sfxType;
			globals::g_Sound3DInstances_TABLE[uVar2].flags =
					 globals::g_Sound3DInstances_TABLE[uVar2].flags & 0xfffffffe;
			return;
		}
	}
	return;
}



void __cdecl lego::snd::Sample_PlayRandomAtVolume(SFXType sfxType,int volume)
{
	int handle;
	
	handle = Sample_ChooseRandomSound(sfxType);
	Sound3D_SetBufferVolume(handle,volume);
	return;
}



int __cdecl lego::snd::Sample_GetRandomVolume(SFXType sfxType)
{
	int sfxTypeRng;
	
	sfxTypeRng = Sample_ChooseRandomSound(sfxType);
	sfxTypeRng = Sound3D_GetBufferVolume(sfxTypeRng);
	return sfxTypeRng;
}



void __cdecl
lego::res::Res_PlayResourceSound
					(Container *cont,SFXType sfxType,BOOL flag2,BOOL flag4,Vector3F *opt_position)
{
	IDirect3DRMFrame3 *rmFrame3;
	
	if (cont == (Container *)0x0) {
		rmFrame3 = (IDirect3DRMFrame3 *)0x0;
	}
	else {
		rmFrame3 = Container_GetMasterFrame(cont);
	}
	snd::Audio_PlayOrInitSoundUnk(rmFrame3,sfxType,flag2,flag4,opt_position);
	return;
}



int __cdecl
lego::snd::Audio_PlayOrInitSoundUnk
					(IDirect3DRMFrame3 *rmFrame3,SFXType sfxType,BOOL flag2,BOOL flag4,Vector3F *opt_position)
{
	Sound3DInstance *pSVar1;
	uint uVar2;
	int iVar3;
	
	uVar2 = globals::g_Sound3DInstances_COUNT;
	if (((byte)globals::g_AudioFlags & AUDIO_UNK_8) == 0) {
		if ((sfxType != SFX_NULL) && (((byte)globals::g_AudioFlags & AUDIO_SOUNDON) != 0)) {
			iVar3 = Sample_ChooseRandomSound(sfxType);
			if (iVar3 != 0) {
				if (flag4 != 0) {
					iVar3 = Sound3D_Play2(SOUND3D_PLAY_ONFRAME,rmFrame3,iVar3,flag2,(Vector3F *)0x0);
					return iVar3;
				}
				iVar3 = Sound3D_Play2(SOUND3D_PLAY_ONPOS,(IDirect3DRMFrame3 *)0x0,iVar3,flag2,opt_position);
				return iVar3;
			}
		}
	}
	else {
		if (globals::g_Sound3DInstances_COUNT < 10) {
			pSVar1 = globals::g_Sound3DInstances_TABLE + globals::g_Sound3DInstances_COUNT;
			globals::g_Sound3DInstances_COUNT = globals::g_Sound3DInstances_COUNT + 1;
			pSVar1->sampleIndex = sfxType;
			globals::g_Sound3DInstances_TABLE[uVar2].frame = rmFrame3;
			globals::g_Sound3DInstances_TABLE[uVar2].flags =
					 ((flag4 & 1U) << 1 | flag2 & 1U) << 1 |
					 globals::g_Sound3DInstances_TABLE[uVar2].flags & 0xfffffff9 | 1;
			if (opt_position != (Vector3F *)0x0) {
				globals::g_Sound3DInstances_TABLE[uVar2].position.x = opt_position->x;
				globals::g_Sound3DInstances_TABLE[uVar2].position.y = opt_position->y;
				globals::g_Sound3DInstances_TABLE[uVar2].position.z = opt_position->z;
				return 0;
			}
		}
	}
	return 0;
}



float10 __cdecl lego::snd::Sample_GetRandomDuration(int sampleIndex)
{
	int handle;
	float10 fVar1;
	
	handle = Sample_ChooseRandomSound(sampleIndex);
	if (handle != 0) {
		fVar1 = Sound3D_GetSamplePlayTime(handle);
		return fVar1;
	}
	return (float10)0.0;
}



void __cdecl lego::snd::Sample_StopSoundBufferInstance(SFXType sfxType)
{
	Sound3D_StopSound(sfxType);
	return;
}



void __cdecl lego::snd::Audio_UnkUpdate_FUN_00465460(float elapsed)
{
	BOOL BVar1;
	int *piVar2;
	BOOL *pBVar3;
	uint uVar4;
	int *piVar5;
	BOOL *pBVar6;
	
	BVar1 = Audio_GetFlag8();
	globals::g_GlobalSampleDuration = globals::g_GlobalSampleDuration - elapsed;
	Audio_FUN_00465590(0,0);
	uVar4 = 0;
	if (globals::g_SoundQueue_Unk2_COUNT != 0) {
		piVar2 = globals::g_SoundQueueIndexes_Unk2_TABLE;
		do {
			Audio_Play_FUN_00465260(*piVar2,((SFXType *)piVar2)[10]);
			uVar4 = uVar4 + 1;
			piVar2 = (int *)((SFXType *)piVar2 + 1);
		} while (uVar4 < globals::g_SoundQueue_Unk2_COUNT);
	}
	if (BVar1 != 0) {
		Audio_FUN_00465580_true(1);
	}
										// std::memcpy(globals::g_SoundQueueIndexes_Unk2_TABLE,
										//             globals::g_SoundQueueIndexes_Unk1_TABLE,
										//             globals::g_SoundQueue_Unk1_COUNT * sizeof(int));
	piVar2 = globals::g_SoundQueueIndexes_Unk1_TABLE;
	piVar5 = globals::g_SoundQueueIndexes_Unk2_TABLE;
	for (uVar4 = globals::g_SoundQueue_Unk1_COUNT; uVar4 != 0; uVar4 = uVar4 - 1) {
		*piVar5 = *piVar2;
		piVar2 = piVar2 + 1;
		piVar5 = piVar5 + 1;
	}
										// globals::g_SoundQueue_Unk2_COUNT = globals::g_SoundQueue_Unk1_COUNT;
										// 
										// std::memcpy(globals::g_SoundQueueModes_Unk2_TABLE,
										//             globals::g_SoundQueueModes_Unk1_TABLE,
										//             globals::g_SoundQueue_Unk1_COUNT * sizeof(int));
	pBVar3 = globals::g_SoundQueueModes_Unk1_TABLE;
	pBVar6 = globals::g_SoundQueueModes_Unk2_TABLE;
	for (uVar4 = globals::g_SoundQueue_Unk1_COUNT;
			globals::g_SoundQueue_Unk2_COUNT = globals::g_SoundQueue_Unk1_COUNT, uVar4 != 0;
			uVar4 = uVar4 - 1) {
		*pBVar6 = *pBVar3;
		pBVar3 = pBVar3 + 1;
		pBVar6 = pBVar6 + 1;
	}
	globals::g_SoundQueue_Unk1_COUNT = 0;
	Sound3D_Update();
	return;
}



void __cdecl lego::snd::Sound3D_Update(void)
{
	Sound3D_SoundRecord *pSVar1;
	uint in_ECX;
	Sound3D_SoundRecord *pSVar2;
	IDirect3DRMFrame3 **ppIVar3;
	uint uStack4;
	
	pSVar2 = globs::sound3DGlobs.soundRecord;
	ppIVar3 = globs::sound3DGlobs.updateFrameList;
	uStack4 = in_ECX;
	do {
		if (*ppIVar3 != (IDirect3DRMFrame3 *)0x0) {
			Sound3D_SoundCallback(*ppIVar3,(void *)0x0,0.0);
		}
		ppIVar3 = ppIVar3 + 1;
	} while (ppIVar3 < &globs::sound3DGlobs.reserved1);
	if (pSVar2 != (Sound3D_SoundRecord *)0x0) {
		do {
			pSVar1 = pSVar2->next;
			(*(code *)pSVar2->soundBuff->lpVtbl->GetStatus)(pSVar2->soundBuff,&uStack4);
			if ((uStack4 & 1) == 0) {
				Sound3D_RemoveSound(pSVar2->frame,pSVar2->sound3DBuff);
			}
			pSVar2 = pSVar1;
		} while (pSVar1 != (Sound3D_SoundRecord *)0x0);
	}
	Sound3D_Stream_CheckPosition(0);
	Sound3D_Stream_CheckPosition(1);
	return;
}



void __cdecl lego::snd::Audio_SetIsSoundOn_AndOtherFunc(BOOL isSoundOn,BOOL param_2)
{
	if (isSoundOn != 0) {
		globals::g_AudioFlags = globals::g_AudioFlags | AUDIO_SOUNDON;
		return;
	}
	globals::g_AudioFlags = globals::g_AudioFlags & ~AUDIO_SOUNDON;
	if (param_2 != 0) {
		Sound3D_StopAllSounds();
	}
	globals::g_GlobalSampleIndex = 0;
	return;
}



void __cdecl lego::snd::Audio_SetFlag1_AndOtherFunc_true(BOOL isSoundOn)
{
	Audio_SetIsSoundOn_AndOtherFunc(isSoundOn,1);
	return;
}



BOOL __cdecl lego::snd::Audio_GetFlag8(void)
{
	return globals::g_AudioFlags & AUDIO_UNK_8;
}



void __cdecl lego::snd::Audio_FUN_00465580_true(BOOL setFlag8)
{
	Audio_FUN_00465590(setFlag8,1);
	return;
}



void __cdecl lego::snd::Audio_FUN_00465590(BOOL setFlag8,BOOL doSomething)
{
	uint uVar1;
	uint *puVar2;
	uint uVar3;
	
	if (setFlag8 != 0) {
		globals::g_AudioFlags = globals::g_AudioFlags | AUDIO_UNK_8;
		return;
	}
	globals::g_AudioFlags = globals::g_AudioFlags & ~AUDIO_UNK_8;
	if (doSomething != 0) {
		uVar3 = 0;
		if (globals::g_Sound3DInstances_COUNT != 0) {
			puVar2 = &globals::g_Sound3DInstances_TABLE[0].flags;
			do {
				uVar1 = *puVar2;
				if ((uVar1 & 1) == 0) {
					Audio_Play_FUN_00465260(puVar2[-5],(int)(uVar1 << 0x1e) >> 0x1f);
				}
				else {
					Audio_PlayOrInitSoundUnk
										((IDirect3DRMFrame3 *)puVar2[-4],puVar2[-5],(int)(uVar1 << 30) >> 31,
										 (int)(uVar1 << 29) >> 31,(Vector3F *)(puVar2 + -3));
				}
				uVar3 = uVar3 + 1;
				puVar2 = puVar2 + 6;
			} while (uVar3 < globals::g_Sound3DInstances_COUNT);
		}
		globals::g_Sound3DInstances_COUNT = 0;
	}
	return;
}



BOOL __cdecl lego::snd::Audio_IsSoundOn(void)
{
	return globals::g_AudioFlags & AUDIO_SOUNDON;
}



BOOL __cdecl lego::main::Main_InitSmokeAnim_empty(void)
{
	globals::g_SmokeAnimFrames_ptr1_UNK = (void *)0x0;
	globals::g_SmokeAnimFrames_ptr2_UNK = (void *)0x0;
	globals::g_SmokeAnimeFrames_COUNT = 0;
	return TRUE;
}



void __cdecl lego::main::Main_LoadSmokeAnim(char *dirname,char *filebaseName,uint frames)
{
	Container_Texture *pCVar1;
	uint uVar2;
	Container_Texture **ppCVar3;
	char local_208 [260];
	char local_104 [260];
	
	uVar2 = 0;
	globals::g_SmokeAnimeFrames_COUNT = frames;
	if (frames != 0) {
		ppCVar3 = globals::g_SmokeAnimFrames_TABLE;
		do {
			std::sprintf(local_104,"%s\\",dirname);
			std::sprintf(local_208,"%s%i.bmp",filebaseName,uVar2);
			pCVar1 = res::Mesh_LoadTexture(local_104,local_208,0,0);
			*ppCVar3 = pCVar1;
			uVar2 = uVar2 + 1;
			ppCVar3 = ppCVar3 + 1;
		} while (uVar2 < frames);
	}
	return;
}



int * __cdecl
FUN_004656f0(int param_1,uint bx,uint by,Vector3F *param_4,float r,float g,float b,float param_8,
						float param_9,int param_10,uint param_11,int param_12)
{
	float fVar1;
	float fVar2;
	short sVar3;
	int *data;
	SurfaceMap *surfMap;
	Container *pCVar4;
	Mesh *pMVar5;
	D3DRMGroupIndex groupID;
	short extraout_var;
	short extraout_var_00;
	int iVar6;
	int *piVar7;
	uint uVar8;
	uint uVar9;
	float10 fVar10;
	ulonglong uVar11;
	longlong lVar12;
	float local_24;
	float local_20;
	float local_1c;
	uint local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar9 = 0;
	local_18 = 0;
	local_14 = 3;
	local_10 = 2;
	local_c = 2;
	local_8 = 1;
	local_4 = 0;
	data = (int *)std::malloc(0x2a8);
	piVar7 = data;
	for (iVar6 = 0xaa; iVar6 != 0; iVar6 = iVar6 + -1) {
		*piVar7 = 0;
		piVar7 = piVar7 + 1;
	}
	if ((param_10 == 0) || (param_10 == 2)) {
		surfMap = lego::game::GetSurfaceMap();
		pCVar4 = lego::res::GetRoot();
		uVar11 = __ftol((float10)surfMap->BlockSize * (float10)0.6);
		lego::game::SurfaceMap_FUN_0044f900(surfMap,bx,by,&local_24,&local_20);
		fVar1 = (float)(uVar11 & 0xffffffff) * 0.5;
		local_24 = ((float)(((ulonglong)param_11 % 0x109e) % (uVar11 & 0xffffffff)) - fVar1) + local_24;
		local_20 = ((float)(((ulonglong)param_11 % 0x5eb) % (uVar11 & 0xffffffff)) - fVar1) + local_20;
		fVar10 = lego::game::SurfaceMap_GetSurfaceZ(surfMap,local_24,local_20);
		local_1c = (float)fVar10;
		pCVar4 = lego::res::Container_Create(pCVar4);
		data[0xa3] = (int)pCVar4;
		lego::res::Container_SetPosition(pCVar4,(Container *)0x0,local_24,local_20,local_1c);
		data[0xa5] = 2;
		data[0x97] = (int)local_24;
		data[0x98] = (int)local_20;
		data[0x99] = (int)local_1c;
		if ((param_11 & 3) == 0) {
			data[0xa8] = param_12;
		}
	}
	else {
		if (param_10 == 1) {
			data[0xa5] = 4;
			data[0xa3] = param_1;
		}
	}
	data[0x9a] = (int)param_4->x;
	fVar1 = param_4->y;
	data[0x9b] = (int)fVar1;
	fVar2 = param_4->z;
	data[0x9c] = (int)fVar2;
	fVar1 = 1.0 / SQRT((float)data[0x9a] * (float)data[0x9a] + fVar2 * fVar2 + fVar1 * fVar1);
	data[0x9a] = (int)(fVar1 * (float)data[0x9a]);
	data[0x9b] = (int)(fVar1 * (float)data[0x9b]);
	data[0x9c] = (int)(fVar1 * (float)data[0x9c]);
	data[0x9d] = (int)r;
	data[0x9e] = (int)g;
	data[0x9f] = (int)b;
	if (param_10 == 2) {
		data[0xa0] = 4;
		data[0xa1] = 0;
		data[0xa5] = data[0xa5] | 8;
		data[0xa2] = 0x40000000;
	}
	else {
		if (((ushort)((ushort)(param_8 < 0.0) << 8 | (ushort)(param_8 == 0.0) << 0xe) == 0) ||
			 (param_8 < 1.0)) {
			lVar12 = __ftol((float10)param_8 * (float10)10.0);
			data[0xa0] = (int)lVar12;
		}
		else {
			data[0xa0] = 10;
		}
		data[0xa2] = (int)param_9;
	}
	pMVar5 = lego::res::Mesh_CreateOnFrame
										 (*(IDirect3DRMFrame3 **)(data[0xa3] + 4),FUN_004661a0,0x4800,data,0);
	data[0xa4] = (int)pMVar5;
	if (data[0xa0] != 0) {
		do {
			groupID = lego::res::Mesh_AddGroup((Mesh *)data[0xa4],4,2,3,&local_18);
			piVar7 = data + groupID * 0xf;
			lego::res::Mesh_SetGroupTexture
								((Mesh *)data[0xa4],groupID,
								 lego::globals::g_SmokeAnimFrames_TABLE
								 [uVar9 % lego::globals::g_SmokeAnimeFrames_COUNT]);
			lego::res::Mesh_SetGroupColour((Mesh *)data[0xa4],groupID,r,g,b,MATERIAL_DIFFUSE);
			lego::res::Mesh_SetGroupColour
								((Mesh *)data[0xa4],groupID,r * 0.2,g * 0.2,b * 0.2,MATERIAL_EMISSIVE);
			lego::res::Mesh_HideGroup((Mesh *)data[0xa4],groupID,1);
			sVar3 = std::rand();
			uVar8 = (int)extraout_var >> 0xf;
			piVar7[10] = (int)((float)(((CONCAT22(extraout_var,sVar3) ^ uVar8) - uVar8 & 3 ^ uVar8) -
																uVar8) - -6.0);
			sVar3 = std::rand();
			uVar8 = (int)extraout_var_00 >> 0xf;
			fVar1 = ((float)(((CONCAT22(extraout_var_00,sVar3) ^ uVar8) - uVar8 & 3 ^ uVar8) - uVar8) +
							(float)piVar7[10]) - -2.0;
			piVar7[0xb] = (int)fVar1;
			if ((*(byte *)(data + 0xa5) & 8) == 0) {
				piVar7[10] = (int)((float)piVar7[10] * 0.5);
			}
			else {
				piVar7[0xb] = (int)(fVar1 + fVar1);
			}
			uVar9 = uVar9 + 1;
		} while (uVar9 < (uint)data[0xa0]);
	}
	data[0x96] = 0;
	if (param_10 != 2) {
		iVar6 = 10;
		do {
			if ((ushort)((ushort)((float)data[0x96] < 0.0) << 8 |
									(ushort)((float)data[0x96] == 0.0) << 0xe) != 0) {
				uVar9 = 0;
				piVar7 = data;
				if (data[0xa0] != 0) {
					do {
						if (*piVar7 == 0) {
							FUN_00465f10((int)data,uVar9);
							break;
						}
						uVar9 = uVar9 + 1;
						piVar7 = piVar7 + 0xf;
					} while (uVar9 < (uint)data[0xa0]);
				}
			}
			uVar9 = 0;
			data[0x96] = (int)((float)data[0x96] - 5.0);
			piVar7 = data;
			if (data[0xa0] != 0) {
				do {
					if (*piVar7 != 0) {
						FUN_004660c0((int)data,uVar9,5.0);
					}
					uVar9 = uVar9 + 1;
					piVar7 = piVar7 + 0xf;
				} while (uVar9 < (uint)data[0xa0]);
			}
			iVar6 = iVar6 + -1;
		} while (iVar6 != 0);
	}
	data[0xa7] = (int)lego::globals::g_SmokeAnimFrames_ptr2_UNK;
	if (lego::globals::g_SmokeAnimFrames_ptr1_UNK != (void *)0x0) {
		*(int **)((int)lego::globals::g_SmokeAnimFrames_ptr2_UNK + 0x298) = data;
		lego::globals::g_SmokeAnimFrames_ptr2_UNK = data;
		return data;
	}
	lego::globals::g_SmokeAnimFrames_ptr1_UNK = data;
	lego::globals::g_SmokeAnimFrames_ptr2_UNK = data;
	return data;
}



void __cdecl FUN_00465c30(void)
{
	undefined *puVar1;
	undefined *puVar2;
	
	puVar2 = (undefined *)lego::globals::g_SmokeAnimFrames_ptr1_UNK;
	if (lego::globals::g_SmokeAnimFrames_ptr1_UNK != (void *)0x0) {
		do {
			puVar1 = *(undefined **)(puVar2 + 0x298);
			FUN_00465c70(puVar2,*(int *)(puVar2 + 0x28c));
			puVar2 = puVar1;
		} while (puVar1 != (undefined *)0x0);
	}
	lego::globals::g_SmokeAnimFrames_ptr1_UNK = (void *)0x0;
	return;
}



void __cdecl FUN_00465c70(undefined *param_1,int param_2)
{
	if ((param_1[0x294] & 2) == 0) {
		lego::res::Mesh_Remove(*(Mesh **)(param_1 + 0x290),*(IDirect3DRMFrame3 **)(param_2 + 4));
	}
	else {
		lego::res::Mesh_Remove
							(*(Mesh **)(param_1 + 0x290),*(IDirect3DRMFrame3 **)(*(int *)(param_1 + 0x28c) + 4));
		lego::res::Container_Remove(*(Container **)(param_1 + 0x28c));
	}
	if ((undefined *)lego::globals::g_SmokeAnimFrames_ptr2_UNK == param_1) {
		lego::globals::g_SmokeAnimFrames_ptr2_UNK = *(void **)(param_1 + 0x29c);
		if (lego::globals::g_SmokeAnimFrames_ptr2_UNK == (void *)0x0) {
			lego::globals::g_SmokeAnimFrames_ptr1_UNK = lego::globals::g_SmokeAnimFrames_ptr2_UNK;
			std::free(param_1);
			return;
		}
	}
	if (*(int *)(param_1 + 0x298) != 0) {
		*(undefined4 *)(*(int *)(param_1 + 0x298) + 0x29c) = *(undefined4 *)(param_1 + 0x29c);
		if (*(int *)((int)*(void **)(param_1 + 0x298) + 0x29c) == 0) {
			lego::globals::g_SmokeAnimFrames_ptr1_UNK = *(void **)(param_1 + 0x298);
		}
	}
	if (*(int *)(param_1 + 0x29c) != 0) {
		*(undefined4 *)(*(int *)(param_1 + 0x29c) + 0x298) = *(undefined4 *)(param_1 + 0x298);
	}
	if (*(SFXType *)(param_1 + 0x2a4) != SFX_NULL) {
		lego::snd::Sample_StopSoundBufferInstance(*(SFXType *)(param_1 + 0x2a4));
	}
	std::free(param_1);
	return;
}



void __cdecl FUN_00465d50(BOOL param_1)
{
	void **ppvVar1;
	void *pvVar2;
	
	pvVar2 = lego::globals::g_SmokeAnimFrames_ptr1_UNK;
	if (lego::globals::g_SmokeAnimFrames_ptr1_UNK != (void *)0x0) {
		do {
			FUN_00465d80((int)pvVar2,param_1);
			ppvVar1 = (void **)((int)pvVar2 + 0x298);
			pvVar2 = *ppvVar1;
		} while (*ppvVar1 != (void *)0x0);
	}
	return;
}



void __cdecl FUN_00465d80(int param_1,BOOL setFlag1)
{
	lego::res::Mesh_Hide(*(Mesh **)(param_1 + 0x290),setFlag1);
	if (setFlag1 != 0) {
		*(uint *)(param_1 + 0x294) = *(uint *)(param_1 + 0x294) | 1;
		return;
	}
	*(uint *)(param_1 + 0x294) = *(uint *)(param_1 + 0x294) & 0xfffffffe;
	return;
}



void __cdecl FUN_00465dc0(float param_1)
{
	int *piVar1;
	bool bVar2;
	Vector3F *opt_position;
	uint uVar3;
	int *piVar4;
	int *piVar5;
	
	piVar5 = (int *)lego::globals::g_SmokeAnimFrames_ptr1_UNK;
	if (lego::globals::g_SmokeAnimFrames_ptr1_UNK != (void *)0x0) {
		do {
			piVar1 = (int *)piVar5[0xa6];
			bVar2 = true;
			if (((*(byte *)(piVar5 + 0xa5) & 0x20) == 0) && (piVar5[0xa9] == 0)) {
				if (piVar5[0xa8] != 0) {
					opt_position = (Vector3F *)(piVar5 + 0x97);
					lego::res::Res_PlayResourceSound((Container *)0x0,piVar5[0xa8],1,0,opt_position);
					piVar5[0xa9] = (int)opt_position;
				}
				if (piVar5[0xa9] == 0) {
					piVar5[0xa5] = piVar5[0xa5] | 0x20;
				}
			}
			uVar3 = piVar5[0xa5];
			if ((uVar3 & 1) == 0) {
				if (((uVar3 & 8) == 0) || ((uVar3 & 0x10) == 0)) {
					if ((ushort)((ushort)((float)piVar5[0x96] < 0.0) << 8 |
											(ushort)((float)piVar5[0x96] == 0.0) << 0xe) != 0) {
						uVar3 = 0;
						piVar4 = piVar5;
						if (piVar5[0xa0] != 0) {
							do {
								if (*piVar4 == 0) {
									FUN_00465f10((int)piVar5,uVar3);
									break;
								}
								uVar3 = uVar3 + 1;
								piVar4 = piVar4 + 0xf;
							} while (uVar3 < (uint)piVar5[0xa0]);
						}
					}
					piVar5[0x96] = (int)((float)piVar5[0x96] - param_1);
				}
				uVar3 = 0;
				piVar4 = piVar5;
				if (piVar5[0xa0] != 0) {
					do {
						if (*piVar4 != 0) {
							FUN_004660c0((int)piVar5,uVar3,param_1);
							bVar2 = false;
						}
						uVar3 = uVar3 + 1;
						piVar4 = piVar4 + 0xf;
					} while (uVar3 < (uint)piVar5[0xa0]);
				}
				if ((((piVar5[0xa5] & 8U) != 0) && ((piVar5[0xa5] & 0x10U) != 0)) && (bVar2)) {
					FUN_00465c70((undefined *)piVar5,piVar5[0xa3]);
				}
			}
			piVar5 = piVar1;
		} while (piVar1 != (int *)0x0);
	}
	return;
}



int __cdecl FUN_00465f10(int param_1,int param_2)
{
	undefined4 *puVar1;
	longlong lVar2;
	float fVar3;
	short sVar4;
	short extraout_var;
	Vector3F local_18;
	Vector3F local_c;
	
	puVar1 = (undefined4 *)(param_1 + param_2 * 0x3c);
	if ((*(uint *)(param_1 + 0x294) & 8) != 0) {
		if (*(int *)(param_1 + 0x284) == 3) {
			*(uint *)(param_1 + 0x294) = *(uint *)(param_1 + 0x294) | 0x10;
		}
		*(int *)(param_1 + 0x284) = *(int *)(param_1 + 0x284) + 1;
	}
	*puVar1 = 1;
	lego::res::Mesh_HideGroup(*(Mesh **)(param_1 + 0x290),param_2,0);
	lego::math::Maths_Vector3DRandom(&local_18);
	local_18.z = -ABS(local_18.z) * 0.17 - 0.83;
	puVar1[1] = local_18.x * 0.17;
	puVar1[2] = local_18.y * 0.17;
	puVar1[3] = local_18.z;
	local_18.z = *(float *)(param_1 + 0x270) + local_18.z;
	fVar3 = -*(float *)(param_1 + 0x288) / local_18.z;
	local_18.z = fVar3 * local_18.z;
	local_18.x = fVar3 * (*(float *)(param_1 + 0x268) + local_18.x * 0.17);
	local_18.y = fVar3 * (*(float *)(param_1 + 0x26c) + local_18.y * 0.17);
	*(undefined4 *)(param_1 + 0x294) = 4;
	lego::res::Container_GetPosition(*(Container **)(param_1 + 0x28c),(Container *)0x0,&local_c);
	puVar1[7] = local_c.x;
	puVar1[0xc] = 0;
	puVar1[0xe] = 0;
	puVar1[8] = local_c.y;
	puVar1[9] = local_c.z;
	puVar1[4] = local_18.x;
	puVar1[5] = local_18.y;
	puVar1[6] = local_18.z;
	sVar4 = std::rand();
	lVar2 = CONCAT44((int)extraout_var >> 0xf,CONCAT22(extraout_var,sVar4));
	puVar1[0xd] = (int)(lVar2 % 0x1e) + 0x28;
	*(float *)(param_1 + 600) = (0.5 / *(float *)(param_1 + 0x288)) * (float)puVar1[0xb];
	return (int)(lVar2 / 0x1e);
}



void __cdecl FUN_004660c0(int param_1,int param_2,float param_3)
{
	undefined4 *puVar1;
	float fVar2;
	
	fVar2 = *(float *)(param_1 + 0x14 + param_2 * 0x3c);
	puVar1 = (undefined4 *)(param_1 + param_2 * 0x3c);
	puVar1[7] = *(float *)(param_1 + 0x10 + param_2 * 0x3c) * param_3 + (float)puVar1[7];
	puVar1[8] = (float)puVar1[8] + fVar2 * param_3;
	puVar1[9] = (float)puVar1[9] + (float)puVar1[6] * param_3;
	fVar2 = ABS((float)puVar1[6] * param_3) + (float)puVar1[0xe];
	puVar1[0xe] = fVar2;
	if ((float)puVar1[0xd] <= fVar2) {
		*puVar1 = 0;
		lego::res::Mesh_HideGroup(*(Mesh **)(param_1 + 0x290),param_2,1);
		return;
	}
	puVar1[0xc] = param_3 + (float)puVar1[0xc];
	lego::res::Mesh_SetGroupMaterialValues
						(*(Mesh **)(param_1 + 0x290),param_2,0.7 - (fVar2 / (float)puVar1[0xd]) * 0.7,
						 MATERIAL_ALPHA);
	return;
}



void __cdecl FUN_004661a0(Mesh *mesh,int *param_2,Viewport *view)
{
	Container *cont;
	int *piVar1;
	uint uVar2;
	Vector3F position;
	
	cont = lego::game::Game_GetCurrentViewLight();
	lego::res::Container_GetPosition(cont,(Container *)0x0,&position);
	uVar2 = 0;
	piVar1 = param_2;
	if (param_2[0xa0] != 0) {
		do {
			if (*piVar1 != 0) {
				FUN_00466200((int)param_2,uVar2,view,&position);
			}
			uVar2 = uVar2 + 1;
			piVar1 = piVar1 + 0xf;
		} while (uVar2 < (uint)param_2[0xa0]);
	}
	return;
}



void __cdecl FUN_00466200(int param_1,int param_2,Viewport *view,Vector3F *position)
{
	int iVar1;
	float fVar2;
	float fVar3;
	Container *cont;
	Vector3F local_80;
	Vector3F local_74;
	Vector3F vertices [4];
	Vector3F local_38;
	Point2F textCoords [4];
	Vector3F local_c;
	
	textCoords[0].x = 0.0;
	textCoords[0].y = 1.0;
	textCoords[1].x = 0.0;
	textCoords[1].y = 0.0;
	textCoords[2].x = 1.0;
	textCoords[2].y = 0.0;
	textCoords[3].x = 1.0;
	textCoords[3].y = 1.0;
	iVar1 = param_1 + param_2 * 0x3c;
	cont = lego::view::Viewport_GetCamera(view);
	lego::res::Container_GetOrientation(cont,(Container *)0x0,&local_38,&local_c);
	local_74.y = local_38.x * -1.0 - 0.0;
	local_74.x = 0.0 - local_38.y * -1.0;
	local_80.x = 0.0;
	local_80.y = 0.0;
	local_80.z = -1.0;
	local_74.z = 0.0;
	if ((ushort)((ushort)(local_38.z < 0.3) << 8 | (ushort)(local_38.z == 0.3) << 0xe) == 0) {
		lego::math::Maths_Vector3DRotate(&local_80,&local_80,&local_74,0.7);
	}
	fVar3 = *(float *)(iVar1 + 0x38) / (float)*(int *)(iVar1 + 0x34) - -1.0;
	fVar2 = *(float *)(iVar1 + 0x28) * fVar3;
	fVar3 = *(float *)(iVar1 + 0x2c) * fVar3;
	local_74.x = fVar2 * local_74.x;
	local_74.y = fVar2 * local_74.y;
	local_74.z = fVar2 * local_74.z;
	vertices[0].x = *(float *)(iVar1 + 0x1c) + local_74.x;
	vertices[1].x = *(float *)(iVar1 + 0x1c) - local_74.x;
	vertices[0].y = *(float *)(iVar1 + 0x20) + local_74.y;
	vertices[1].y = *(float *)(iVar1 + 0x20) - local_74.y;
	local_80.x = fVar3 * local_80.x;
	vertices[0].z = *(float *)(iVar1 + 0x24) + local_74.z;
	vertices[1].z = *(float *)(iVar1 + 0x24) - local_74.z;
	local_80.y = fVar3 * local_80.y;
	local_80.z = fVar3 * local_80.z;
	vertices[2].x = vertices[1].x - local_80.x;
	vertices[3].x = vertices[0].x - local_80.x;
	vertices[2].y = vertices[1].y - local_80.y;
	vertices[3].y = vertices[0].y - local_80.y;
	vertices[2].z = vertices[1].z - local_80.z;
	vertices[3].z = vertices[0].z - local_80.z;
	lego::res::Mesh_SetVertices_PointNormalAt
						(*(Mesh **)(param_1 + 0x290),param_2,0,4,vertices,position,textCoords);
	return;
}



void __cdecl lego::game::Level_AllocBlocksStruct_c_Table(LevelData *level)
{
	uint uVar1;
	int iVar2;
	undefined4 *puVar3;
	
	globals::g_Level_BlocksStruct_c_TABLE =
			 std::malloc((level->dimensions).width * (level->dimensions).height * 0xc);
	if ((undefined4 *)globals::g_Level_BlocksStruct_c_TABLE != (undefined4 *)0x0) {
		puVar3 = (undefined4 *)globals::g_Level_BlocksStruct_c_TABLE;
		for (uVar1 = (level->dimensions).width * (level->dimensions).height * 3 & 0x3fffffff; uVar1 != 0
				; uVar1 = uVar1 - 1) {
			*puVar3 = 0;
			puVar3 = puVar3 + 1;
		}
		for (iVar2 = 0; iVar2 != 0; iVar2 = iVar2 + -1) {
			*(undefined *)puVar3 = 0;
			puVar3 = (undefined4 *)((int)puVar3 + 1);
		}
	}
	LEVELDATA_005530ec = level;
	return;
}



void __cdecl lego::game::Level_FreeBlocksStruct_c_Table(void)
{
	if (globals::g_Level_BlocksStruct_c_TABLE != (void *)0x0) {
		std::free(globals::g_Level_BlocksStruct_c_TABLE);
		globals::g_Level_BlocksStruct_c_TABLE = (void *)0x0;
	}
	return;
}



void __cdecl lego::game::Level_Start(LevelData *level)
{
	Level_FreeBlocksStruct_c_Table();
	Level_AllocBlocksStruct_c_Table(level);
	return;
}



BOOL __cdecl lego::game::Level_DoSomethingBlockStruct_c__00466510(uint x,uint y)
{
	int iVar1;
	uint y_00;
	BOOL BVar2;
	LiveObject *pLVar3;
	float local_8;
	float local_4;
	
	y_00 = y;
	if ((*(uint *)((int)globals::g_Level_BlocksStruct_c_TABLE +
								((LEVELDATA_005530ec->dimensions).width * y + x) * 0xc + 8) & 0x100) == 0) {
		BVar2 = Level_DoSomethingBlock_004666b0(x,y,(float *)&y);
		if (BVar2 != 0) {
			SurfaceMap_FUN_0044f900(LEVELDATA_005530ec->surfaceMap,x,y_00,&local_8,&local_4);
			pLVar3 = Game_CreateLiveResourceObject
												 (globals::g_Game.RES_SpiderWeb,OBJECT_SPIDERWEB,0,0,local_8,local_4,
													(float)y);
			Level_SetBlockStruct_c_Value(x,y_00,pLVar3);
			iVar1 = *(int *)((int)globals::g_Level_BlocksStruct_c_TABLE +
											((LEVELDATA_005530ec->dimensions).width * y_00 + x) * 0xc);
			*(uint *)(iVar1 + 0x3e0) = *(uint *)(iVar1 + 0x3e0) | 0x100;
			res::Container_SetActivity
								(*(Container **)
									(*(int *)((int)globals::g_Level_BlocksStruct_c_TABLE +
													 ((LEVELDATA_005530ec->dimensions).width * y_00 + x) * 0xc) + 0x1c),
								 "Expand");
			res::Container_SetAnimationTime
								(*(Container **)
									(*(int *)((int)globals::g_Level_BlocksStruct_c_TABLE +
													 ((LEVELDATA_005530ec->dimensions).width * y_00 + x) * 0xc) + 0x1c),0.0);
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::game::Level_SetBlockStruct_c_Value(int x,int y,undefined4 param_3)
{
	uint *puVar1;
	
	*(undefined4 *)
	 ((int)globals::g_Level_BlocksStruct_c_TABLE +
	 ((LEVELDATA_005530ec->dimensions).width * y + x) * 0xc) = param_3;
	puVar1 = (uint *)((int)globals::g_Level_BlocksStruct_c_TABLE +
									 ((LEVELDATA_005530ec->dimensions).width * y + x) * 0xc + 8);
	*puVar1 = *puVar1 | 0x100;
	*(undefined **)
	 ((int)globals::g_Level_BlocksStruct_c_TABLE +
	 ((LEVELDATA_005530ec->dimensions).width * y + x) * 0xc + 4) = &DAT_42c80000;
	return;
}



BOOL __cdecl lego::game::Level_DoSomethingBlock_004666b0(int x,int y,float *out_float)
{
	int iVar1;
	LevelBlock *pLVar2;
	int iVar3;
	
	iVar1 = (LEVELDATA_005530ec->dimensions).width;
	pLVar2 = LEVELDATA_005530ec->blocks;
	iVar3 = y * iVar1 + x;
	if ((*(byte *)&pLVar2[iVar3].flags1 & 8) == 0) {
		return 0;
	}
	if (((*(byte *)&(pLVar2 + iVar3)[1].flags1 & 0x10) == 0) ||
		 ((*(byte *)&(pLVar2 + iVar3)[-1].flags1 & 0x10) == 0)) {
		if ((*(byte *)&pLVar2[(y + 1) * iVar1 + x].flags1 & 0x10) == 0) {
			return 0;
		}
		if ((*(byte *)&pLVar2[(y + -1) * iVar1 + x].flags1 & 0x10) == 0) {
			return 0;
		}
		if (out_float != (float *)0x0) {
			*out_float = 0.0;
		}
	}
	else {
		if (out_float != (float *)0x0) {
			*out_float = 1.570796;
			return 1;
		}
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_FUN_00466750(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	BOOL BVar2;
	int iVar3;
	uint local_24;
	Point2F local_20;
	float local_18;
	float local_14;
	undefined4 local_10;
	float local_c;
	float local_8;
	undefined4 local_4;
	
	pLVar1 = liveObj;
	BVar2 = LiveObject_GetBlockCoordinates(liveObj,(int *)&local_24,(int *)&liveObj);
	if (BVar2 != 0) {
		if ((*(uint *)((int)globals::g_Level_BlocksStruct_c_TABLE +
									((LEVELDATA_005530ec->dimensions).width * (int)liveObj + local_24) * 0xc + 8) &
				0x100) != 0) {
			SurfaceMap_FUN_0044f900
								(LEVELDATA_005530ec->surfaceMap,local_24,(uint)liveObj,&local_c,&local_8);
			LiveObject_GetFaceDirection
								(*(LiveObject **)
									((int)globals::g_Level_BlocksStruct_c_TABLE +
									((LEVELDATA_005530ec->dimensions).width * (int)liveObj + local_24) * 0xc),
								 &local_20);
			local_18 = local_20.x;
			local_14 = local_20.y;
			local_4 = 0;
			local_10 = 0;
			iVar3 = FUN_00470520((undefined4 *)pLVar1,&local_c,&local_18,0);
			if (iVar3 != 0) {
				pLVar1->flags1 = pLVar1->flags1 | 0x2000000;
				iVar3 = *(int *)((int)globals::g_Level_BlocksStruct_c_TABLE +
												((LEVELDATA_005530ec->dimensions).width * (int)liveObj + local_24) * 0xc);
				*(uint *)(iVar3 + 0x3e0) = *(uint *)(iVar3 + 0x3e0) | 0x2000000;
				return 1;
			}
		}
	}
	return 0;
}



BOOL __cdecl FUN_00466880(undefined param_1)
{
	BOOL BVar1;
	
	BVar1 = lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_004668a0,(LiveObject *)&param_1);
	return BVar1;
}



BOOL __cdecl FUN_004668a0(LiveObject *liveObj,float *param_2)
{
	void *pvVar1;
	LiveObject *pLVar2;
	BOOL BVar3;
	int iVar4;
	uint weaponType;
	float10 fVar5;
	LiveObject *liveObj_00;
	int local_4;
	
	pLVar2 = liveObj;
	if (liveObj->objType == OBJECT_SPIDERWEB) {
		lego::game::LiveObject_GetBlockCoordinates(liveObj,&local_4,(int *)&liveObj);
		if (((*(uint *)((int)lego::globals::g_Level_BlocksStruct_c_TABLE +
									 ((LEVELDATA_005530ec->dimensions).width * (int)liveObj + local_4) * 0xc + 8) &
				 0x100) != 0) &&
			 (BVar3 = lego::game::Level_DoSomethingBlock_004666b0(local_4,(int)liveObj,(float *)0x0),
			 BVar3 == 0)) {
			FUN_00466a10(local_4,(int)liveObj);
			return 0;
		}
	}
	else {
		if ((liveObj->flags1 & 0x2000000) != LIVEOBJ1_NONE) {
			lego::game::LiveObject_GetBlockCoordinates(liveObj,&local_4,(int *)&liveObj);
			pvVar1 = lego::globals::g_Level_BlocksStruct_c_TABLE;
			iVar4 = (LEVELDATA_005530ec->dimensions).width * (int)liveObj + local_4;
			if ((*(uint *)((int)lego::globals::g_Level_BlocksStruct_c_TABLE + iVar4 * 0xc + 8) & 0x100) !=
					0) {
				liveObj_00 = pLVar2;
				weaponType = lego::tools::Weapon_GetWeaponTypeByName("SpiderWeb");
				fVar5 = lego::game::Weapon_GetDamageForLiveObject(weaponType,liveObj_00);
				*(float *)((int)lego::globals::g_Level_BlocksStruct_c_TABLE +
									((LEVELDATA_005530ec->dimensions).width * (int)liveObj + local_4) * 0xc + 4) =
						 (float)((float10)*(float *)((int)pvVar1 + iVar4 * 0xc + 4) - fVar5 * (float10)*param_2)
				;
				if (0.0 <= *(float *)((int)lego::globals::g_Level_BlocksStruct_c_TABLE +
														 ((LEVELDATA_005530ec->dimensions).width * (int)liveObj + local_4) * 0xc
														 + 4)) {
					return 0;
				}
				FUN_00466a10(local_4,(int)liveObj);
			}
			pLVar2->flags1 = pLVar2->flags1 & 0xfdffffff;
			return 0;
		}
		lego::game::LiveObject_FUN_00466750(liveObj);
	}
	return 0;
}



void __cdecl FUN_00466a10(int param_1,int param_2)
{
	int iVar1;
	
	iVar1 = *(int *)((int)lego::globals::g_Level_BlocksStruct_c_TABLE +
									((LEVELDATA_005530ec->dimensions).width * param_2 + param_1) * 0xc);
	*(uint *)(iVar1 + 1000) = *(uint *)(iVar1 + 1000) | 0x800000;
	iVar1 = *(int *)((int)lego::globals::g_Level_BlocksStruct_c_TABLE +
									((LEVELDATA_005530ec->dimensions).width * param_2 + param_1) * 0xc);
	*(uint *)(iVar1 + 0x3e0) = *(uint *)(iVar1 + 0x3e0) & 0xfdffffff;
	iVar1 = (LEVELDATA_005530ec->dimensions).width * param_2 + param_1;
	*(uint *)((int)lego::globals::g_Level_BlocksStruct_c_TABLE + iVar1 * 0xc + 8) =
			 *(uint *)((int)lego::globals::g_Level_BlocksStruct_c_TABLE + iVar1 * 0xc + 8) & 0xfffffeff;
	return;
}


/*
Unable to decompile 'Game_ParseStats'
Cause: Exception while decompiling 00466aa0: process: timeout

*/


BOOL __cdecl lego::game::Game_ParseStats(CFGProperty *root,char *baseKeyPath)
{
	uint *puVar1;
	BOOL3 *pBVar2;
	float fVar3;
	char *pcVar4;
	CFGProperty *prop;
	BOOL BVar5;
	uint uVar6;
	ObjectStats **ppOVar7;
	ObjectStats *pOVar8;
	SFXType SVar9;
	BOOL3 BVar10;
	int iVar11;
	char **ppcVar12;
	uint uVar13;
	float10 fVar14;
	SFXType *pSVar15;
	ObjectType local_14c;
	int local_148;
	char *local_144;
	uint local_140;
	BOOL3 local_13c;
	char **local_138;
	char *local_134;
	char *local_130;
	char **local_12c;
	BOOL3 local_128;
	char *local_124;
	float local_120;
	float local_11c;
	char *local_118;
	float local_114;
	float local_110;
	float local_10c;
	float local_108;
	float local_104;
	float local_100;
	float local_fc;
	float local_f8;
	float local_f4;
	float local_f0;
	float local_ec;
	SFXType local_e8;
	SFXType local_e4;
	SFXType local_e0;
	int local_dc;
	int local_d8;
	int local_d4;
	uint local_d0;
	undefined4 uStack204;
	char *local_c8 [32];
	char *local_48;
	char *local_44 [4];
	char *local_34;
	char *local_28;
	char *local_20;
	
	local_48 = NULL;
	ppcVar12 = local_44;
	for (iVar11 = 0x11; iVar11 != 0; iVar11 += -1) {
		*ppcVar12 = NULL;
		ppcVar12 = ppcVar12 + 1;
	}
	pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",0);
	for (prop = cfg::CFG_GetChildren(root,pcVar4); prop != NULL; prop = cfg::CFG_NextFlat(prop)) {
		local_128 = BOOL3_FALSE;
		local_13c = BOOL3_FALSE;
		local_140 = 0;
		pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Levels",0);
		pcVar4 = cfg::CFG_ReadString(root,pcVar4);
		if (pcVar4 == NULL) {
			pcVar4 = ""/*EMPTYSTR*/;
		}
		else {
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Levels",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
		}
		local_134 = (char *)std::atoi(pcVar4);
		BVar5 = Object_GetObjectByName(prop->key,&local_14c,&local_148,NULL);
		if (BVar5 != 0) {
			if (globals::g_ObjectStats_TABLE[local_14c] == NULL) {
				uVar6 = Object_GetTypeCount(local_14c);
				ppOVar7 = (ObjectStats **)std::malloc(uVar6 * 4);
				globals::g_ObjectStats_TABLE[local_14c] = ppOVar7;
				for (uVar6 &= 0x3fffffff; uVar6 != 0; uVar6 -= 1) {
					*ppOVar7 = NULL;
					ppOVar7 = ppOVar7 + 1;
				}
				for (iVar11 = 0; iVar11 != 0; iVar11 += -1) {
					*(undefined *)ppOVar7 = 0;
					ppOVar7 = (ObjectStats **)((int)ppOVar7 + 1);
				}
			}
			globals::g_ObjectLevels_TABLE[local_14c][local_148] = (uint)local_134;
			uVar6 = (int)local_134 * 0x150;
			pOVar8 = (ObjectStats *)std::malloc(uVar6);
			globals::g_ObjectStats_TABLE[local_14c][local_148] = pOVar8;
			pOVar8 = globals::g_ObjectStats_TABLE[local_14c][local_148];
			for (uVar6 >>= 2; uVar6 != 0; uVar6 -= 1) {
				pOVar8->field_0 = 0;
				pOVar8 = (ObjectStats *)&pOVar8->field_4;
			}
			for (iVar11 = 0; iVar11 != 0; iVar11 += -1) {
				*(undefined *)&pOVar8->field_0 = 0;
				pOVar8 = (ObjectStats *)((int)&pOVar8->field_0 + 1);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"RouteSpeed",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_12c = local_c8;
					local_144 = NULL;
					local_130 = local_134;
					do {
						fVar14 = std::atof(*local_12c);
						*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
											(int)local_144 + -4) = (float)fVar14;
						local_144 = (char *)((int)local_144 + 0x150);
						local_12c = local_12c + 1;
						local_130 = local_130 + -1;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"SoilDrillTime",0);
			local_34 = cfg::CFG_CopyString(root,pcVar4);
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"LooseDrillTime",0);
			local_44[3] = cfg::CFG_CopyString(root,pcVar4);
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"MedDrillTime",0);
			local_44[2] = cfg::CFG_CopyString(root,pcVar4);
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"HardDrillTime",0);
			local_44[1] = cfg::CFG_CopyString(root,pcVar4);
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"SeamDrillTime",0);
			local_28 = cfg::CFG_CopyString(root,pcVar4);
			if (local_28 == NULL) {
				local_20 = NULL;
			}
			else {
				local_20 = std::_strdup(local_28);
			}
			local_12c = &local_48;
			local_114 = (float)(0x24 - (int)&local_48);
			local_120 = 2.522337e-44;
			do {
				pcVar4 = *local_12c;
				local_118 = pcVar4;
				if (pcVar4 != NULL) {
					util::Util_Tokenise(pcVar4,local_c8,":");
					if (local_134 != NULL) {
						local_144 = (char *)((int)local_114 + (int)local_12c);
						ppcVar12 = local_c8;
						local_130 = local_134;
						do {
							fVar14 = std::atof(*ppcVar12);
							ppcVar12 = ppcVar12 + 1;
							*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
												(int)local_144 + -0x24) = (float)(fVar14 * (float10)25.0);
							local_144 = (char *)((int)local_144 + 0x150);
							local_130 = local_130 + -1;
							pcVar4 = local_118;
						} while (local_130 != NULL);
					}
					std::free(pcVar4);
				}
				local_12c = local_12c + 1;
				local_120 = (float)((int)local_120 + -1);
			} while (local_120 != 0.0);
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"BuildingBase",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				local_144 = (char *)0xffffffff;
			}
			else {
				local_144 = (char *)Game_GetBuildingBase(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CostCrystal",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CostCrystal",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_d8 = std::atoi(pcVar4);
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CostOre",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CostOre",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_d4 = std::atoi(pcVar4);
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CostRefinedOre",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CostRefinedOre",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_124 = (char *)std::atoi(pcVar4);
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"TrackDist",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"TrackDist",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_120 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"AlertRadius",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"AlertRadius",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_114 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CollHeight",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CollHeight",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_118 = (char *)(float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"HealthDecayRate",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"HealthDecayRate",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_110 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"EnergyDecayRate",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"EnergyDecayRate",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_100 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"PickSphere",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"PickSphere",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_130 = (char *)(float)fVar14;
			pSVar15 = &local_e0;
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"DrillSound",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			BVar5 = snd::SFX_GetType(pcVar4,pSVar15);
			if (BVar5 == 0) {
				local_e0 = SFX_DRILL;
			}
			pSVar15 = &local_e8;
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"DrillFadeSound",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			BVar5 = snd::SFX_GetType(pcVar4,pSVar15);
			if (BVar5 == 0) {
				local_e8 = SFX_DRILLFADE;
			}
			pSVar15 = &local_e4;
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"EngineSound",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			SVar9 = snd::SFX_GetType(pcVar4,pSVar15);
			if (SVar9 == SFX_NULL) {
				local_e4 = SVar9;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"RestPercent",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"RestPercent",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_10c = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CarryMinHealth",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CarryMinHealth",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_104 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"StampRadius",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"StampRadius",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_fc = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"AttackRadius",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"AttackRadius",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_f8 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"WaterEntrances",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"WaterEntrances",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_f4 = (float)std::atoi(pcVar4);
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"RubbleCoef",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"RubbleCoef",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_11c = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"PathCoef",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"PathCoef",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_138 = (char **)(float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"OxygenCoef",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"OxygenCoef",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_108 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Capacity",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Capacity",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_dc = std::atoi(pcVar4);
			if (local_11c == 0.0) {
				local_11c = 1.0;
			}
			if ((float)local_138 == 0.0) {
				local_138 = (char **)0x3f800000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CollRadius",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CollRadius",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_12c = (char **)(float)fVar14;
			if ((float10)0.0 == fVar14) {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CollBox",0);
				pcVar4 = cfg::CFG_CopyString(root,pcVar4);
				if (pcVar4 != NULL) {
					util::Util_Tokenise(pcVar4,local_c8,",");
					fVar14 = std::atof(local_c8[0]);
					local_f0 = (float)fVar14;
					fVar14 = std::atof(local_c8[1]);
					local_ec = (float)fVar14;
					fVar3 = local_ec;
					if ((ushort)((ushort)(local_f0 < local_ec) << 8 | (ushort)(local_f0 == local_ec) << 0xe)
							== 0) {
						fVar3 = local_f0;
					}
					local_12c = (char **)(fVar3 * 0.5);
					local_140 = 0x100;
				}
			}
			else {
				local_140 = 0x80;
			}
			if (local_134 != NULL) {
				iVar11 = 0;
				pcVar4 = local_134;
				do {
					*(char ***)
					 ((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes + iVar11 + 0x48) =
							 local_12c;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x4c) = local_114;
					pOVar8 = globals::g_ObjectStats_TABLE[local_14c][local_148];
					*(float *)((int)pOVar8->DrillTimes + iVar11 + 0x7c) = local_f0;
					*(float *)((int)pOVar8->DrillTimes + iVar11 + 0x80) = local_ec;
					*(char **)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x54) = local_130;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x58) = local_120;
					*(char **)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x50) = local_118;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x5c) = local_110;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x60) = local_100;
					*(char **)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->BuildingBase + iVar11
										) = local_144;
					*(SFXType *)
					 ((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillSound + iVar11) =
							 local_e0;
					*(SFXType *)
					 ((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillFadeSound + iVar11) =
							 local_e8;
					*(SFXType *)
					 ((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->EngineSound + iVar11) =
							 local_e4;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x68) = local_10c;
					pcVar4 = pcVar4 + -1;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x6c) = local_104;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x70) = local_fc;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x74) = local_f8;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->WaterEntrances +
										iVar11) = local_f4;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->RubbleCoef + iVar11)
							 = local_11c;
					*(char ***)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->PathCoef + iVar11) =
							 local_138;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->OxygenCoef + iVar11)
							 = local_108;
					*(int *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Capacity + iVar11) =
							 local_dc;
					*(int *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->CostCrystal + iVar11) =
							 local_d8;
					*(int *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->CostOre + iVar11) =
							 local_d4;
					*(char **)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->CostRefinedOre +
										iVar11) = local_124;
					iVar11 = iVar11 + 0x150;
				} while (pcVar4 != NULL);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"SingleWidthDig",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags1 + iVar11) =
									 *(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags1 +
														iVar11) | 1;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = local_124;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"RepairValue",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						fVar14 = std::atof(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(float *)(local_144 +
											(int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->RepairValue) =
								 (float)fVar14;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"SurveyRadius",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						iVar11 = std::atoi(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(int *)(local_144 +
										(int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->SurveyRadius) = iVar11
						;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"MaxCarry",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						iVar11 = std::atoi(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(int *)(local_144 + (int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->MaxCarry)
								 = iVar11;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CarryStart",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						iVar11 = std::atoi(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(int *)(local_144 +
										(int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->CarryStart) = iVar11;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CrystalDrain",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						iVar11 = std::atoi(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(int *)(local_144 +
										(int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->CrystalDrain) = iVar11
						;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"NumOfToolsCanCarry",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						iVar11 = std::atoi(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(int *)(local_144 +
										(int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->NumOfToolsCanCarry) =
								 iVar11;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"UpgradeTime",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						fVar14 = std::atof(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(float *)(local_144 +
											(int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->UpgradeTime) =
								 (float)(fVar14 * (float10)25.0);
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"FunctionCoef",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						fVar14 = std::atof(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						local_144 = local_144 + 0x150;
						*(float *)(local_144 +
											(int)&globals::g_ObjectStats_TABLE[local_14c][local_148][-1].FunctionCoef) =
								 (float)fVar14;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"UpgradeCostOre",0);
			local_144 = cfg::CFG_CopyString(root,pcVar4);
			if (local_144 != NULL) {
				util::Util_Tokenise(local_144,local_c8,":");
				local_138 = local_c8 + 3;
				uVar6 = 0;
				do {
					iVar11 = std::atoi(*local_138);
					uVar13 = uVar6 + 0x150;
					local_138 = local_138 + -1;
					*(int *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148][1].DrillTimes +
									(uVar6 - 0x78)) = iVar11;
					uVar6 = uVar13;
				} while (uVar13 < 0x540);
				std::free(local_144);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"UpgradeCostStuds",0);
			local_144 = cfg::CFG_CopyString(root,pcVar4);
			if (local_144 != NULL) {
				util::Util_Tokenise(local_144,local_c8,":");
				local_138 = local_c8 + 3;
				uVar6 = 0;
				do {
					iVar11 = std::atoi(*local_138);
					uVar13 = uVar6 + 0x150;
					*(int *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148][1].DrillTimes +
									(uVar6 - 0x74)) = iVar11;
					local_138 = local_138 + -1;
					uVar6 = uVar13;
				} while (uVar13 < 0x540);
				std::free(local_144);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"ProcessOre",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 2;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"ProcessCrystal",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 4;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"StoreObjects",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 8;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"ManTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x80000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"SmallTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x10;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"BigTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x20;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"WaterTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x40;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"SnaxULike",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x4000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"ToolStore",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x100000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CauseSlip",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x200;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"RandomMove",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x400;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CanScare",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x800;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CanScareScorpion",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x40000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"RandomEnterWall",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x1000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"ScaredByPlayer",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x2000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"GrabMinifigure",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x8000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CanBeDriven",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x20000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CanSteal",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x80000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CanClearRubble",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x10000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"RouteAvoidance",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x20000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"BumpDamage",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x40000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x200000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_Debug",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x400000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_Smooth",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x800000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CrossWater",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x1000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CrossLand",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x2000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_OnGround",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x4000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_QuickDestroy",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x8000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_AnimateByPitch",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x10000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"ScaredByBigBangs",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c = BVar10;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"UpgradeBuilding",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= BOOL3_ERROR;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CanBeShotAt",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x40000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"UseBigTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x800;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"UseSmallTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x1000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"UseWaterTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x2000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"UseLegoManTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x400000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"TrainPilot",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 + iVar11) =
									 *(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 +
														iVar11) | 4;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"TrainSailor",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 + iVar11) =
									 *(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 +
														iVar11) | 8;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"TrainDriver",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 + iVar11) =
									 *(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 +
														iVar11) | 0x10;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"TrainDynamite",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 + iVar11) =
									 *(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 +
														iVar11) | 0x20;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"TrainRepair",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 + iVar11) =
									 *(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 +
														iVar11) | 0x40;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"TrainScanner",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 + iVar11) =
									 *(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 +
														iVar11) | 0x80;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Tracker",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x100;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"PowerBuilding",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x600;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"SelfPowered",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x400;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"AttackPaths",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x4000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"SplitOnZeroHealth",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x8000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CanBeHitByFence",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x10000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CanDoubleSelect",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x20000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"DrainPower",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x80000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"UseHoles",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x100000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CrossLava",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x200000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"DamageCausesCallToArms",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x800000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CanFreeze",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x1000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CanLaser",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x2000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CanPush",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x4000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"DontShowDamage",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x8000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"RemoveReinforcement",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x10000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"DontShowOnRadar",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x20000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"InvisibleDriver",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x40000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Unselectable",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x80000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CarryVehicles",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 = BVar10;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"VehicleCanBeCarried",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= BOOL3_ERROR;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"CanStrafe",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 4;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"ClassAsLarge",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 8;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"GetOutAtLand",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x10;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"GetInAtLand",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x20;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"TakeCarryingDrivers",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x40;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"ShowHealthBar",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x80;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"NeedsPilot",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x100;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"EnterToolStore",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x200;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_Turn",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_Turn",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_138 = (char **)(float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_138 = (char **)&DAT_3d75c28f;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_Speed",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_Speed",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_11c = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_11c = 2.0;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_Tightness",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_Tightness",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_12c = (char **)(float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_12c = (char **)0x40000000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_GoalUpdate",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_GoalUpdate",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_108 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_108 = 2.0;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_Height",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_Height",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_f4 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_f4 = 30.0;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_Randomness",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_Randomness",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_f8 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_f8 = 2.0;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_Size",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_Size",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_d0 = std::atoi(pcVar4);
			uStack204 = 0;
			local_114 = (float)local_d0;
			if ((float)(ulonglong)local_d0 == 0.0) {
				local_114 = 7.006492e-45;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_AttackTime",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"Flocks_AttackTime",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_fc = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_fc = 300.0;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"AwarenessRange",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"AwarenessRange",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_104 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_104 = 0.0;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"PainThreshold",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"PainThreshold",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_10c = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_10c = 0.0;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"FreezerTime",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"FreezerTime",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_130 = (char *)(float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_130 = NULL;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"FreezerDamage",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"FreezerDamage",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_120 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_120 = 0.0;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"PusherDist",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"PusherDist",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_110 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_110 = 0.0;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"PusherDamage",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"PusherDamage",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_100 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_100 = 0.0;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"LaserDamage",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"LaserDamage",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_118 = (char *)(float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_118 = NULL;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"WakeRadius",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"WakeRadius",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_144 = (char *)(float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_144 = (char *)0x41a00000;
			}
			pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"RandomMoveTime",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(baseKeyPath,"Stats",prop->key,"RandomMoveTime",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			if (fVar14 == (float10)0.0) {
				fVar14 = (float10)200.0;
			}
			if (local_134 != NULL) {
				iVar11 = 0;
				pcVar4 = local_134;
				do {
					puVar1 = (uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags1 +
													 iVar11);
					*puVar1 = *puVar1 | local_140;
					pBVar2 = (BOOL3 *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 +
														iVar11);
					*pBVar2 = *pBVar2 | local_13c;
					pBVar2 = (BOOL3 *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags3 +
														iVar11);
					*pBVar2 = *pBVar2 | local_128;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->RandomMoveTime +
										iVar11) = (float)fVar14;
					*(char ***)
					 ((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_Turn + iVar11) =
							 local_138;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_Speed + iVar11
										) = local_11c;
					*(char ***)
					 ((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_Tightness + iVar11) =
							 local_12c;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_GoalUpdate +
										iVar11) = local_108;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_Height +
										iVar11) = local_f4;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_Randomness +
										iVar11) = local_f8;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_Size + iVar11)
							 = local_114;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_AttackTime +
										iVar11) = local_fc;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->AwarenessRange +
										iVar11) = local_104;
					pcVar4 = pcVar4 + -1;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->PainThreshold +
										iVar11) = local_10c;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148][1].DrillTimes +
										iVar11 + -0x5c) = local_100;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148][1].DrillTimes +
										iVar11 + -0x60) = local_110;
					*(char **)((int)globals::g_ObjectStats_TABLE[local_14c][local_148][1].DrillTimes +
										iVar11 + -0x58) = local_118;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148][1].DrillTimes +
										iVar11 + -100) = local_120;
					*(char **)((int)globals::g_ObjectStats_TABLE[local_14c][local_148][1].DrillTimes +
										iVar11 + -0x68) = local_130;
					*(char **)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x78) = local_144;
					iVar11 = iVar11 + 0x150;
				} while (pcVar4 != NULL);
			}
		}
	}
	ai::AI_RegisterToolTask(TOOL_DRILL,AITASK_DIG);
	ai::AI_RegisterToolTask(TOOL_SPADE,AITASK_CLEAR);
	ai::AI_RegisterToolTask(TOOL_HAMMER,AITASK_REINFORCE);
	ai::AI_RegisterToolTask(TOOL_SPANNER,AITASK_REPAIR);
	return 1;
}




void __cdecl lego::ai::AI_RegisterToolTask(ToolType toolType,AITaskType taskType)
{
	(&ToolData_ARRAY_005040d8[toolType].taskType)[ToolData_ARRAY_005040d8[toolType].count] = taskType;
	ToolData_ARRAY_005040d8[toolType].count = ToolData_ARRAY_005040d8[toolType].count + 1;
	return;
}



int __cdecl lego::game::Object_GetCostOre(ObjectType objType,int objIndex,int objLevel)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex][objLevel].CostOre;
}



int __cdecl lego::game::Object_GetCostCrystal(ObjectType objType,int objIndex,int objLevel)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex][objLevel].CostCrystal;
}



int __cdecl lego::game::Object_GetCostRefinedOre(ObjectType objType,int objIndex,int objLevel)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex][objLevel].CostRefinedOre;
}



int __cdecl lego::game::LiveObject_GetCrystalDrain(LiveObject *liveObj)
{
	return globals::g_ObjectStats_TABLE[liveObj->objType][liveObj->objIndex][liveObj->objLevel].
				 CrystalDrain;
}



int __cdecl lego::game::LiveObject_GetCapacity(LiveObject *liveObj)
{
	return globals::g_ObjectStats_TABLE[liveObj->objType][liveObj->objIndex][liveObj->objLevel].
				 Capacity;
}



int __cdecl lego::game::LiveObject_GetMaxCarry(LiveObject *liveObj)
{
	return globals::g_ObjectStats_TABLE[liveObj->objType][liveObj->objIndex][liveObj->objLevel].
				 MaxCarry;
}



int __cdecl lego::game::LiveObject_GetCarryStart(LiveObject *liveObj)
{
	return globals::g_ObjectStats_TABLE[liveObj->objType][liveObj->objIndex][liveObj->objLevel].
				 CarryStart;
}



BOOL __cdecl lego::game::LiveObject_SetLevel(LiveObject *liveObj,uint level)
{
	ObjectType OVar1;
	int iVar2;
	uint uVar3;
	
	OVar1 = liveObj->objType;
	iVar2 = liveObj->objIndex;
	if (level < globals::g_ObjectLevels_TABLE[OVar1][iVar2]) {
		uVar3 = liveObj->objLevel;
		if (level != uVar3) {
			globals::g_LiveObjectLevels_Previous_TABLE[OVar1][iVar2][uVar3] =
					 globals::g_LiveObjectLevels_Previous_TABLE[OVar1][iVar2][uVar3] + 1;
			globals::g_LiveObjectLevels_Current_TABLE[liveObj->objType][liveObj->objIndex][level] =
					 globals::g_LiveObjectLevels_Current_TABLE[liveObj->objType][liveObj->objIndex][level] + 1
			;
		}
		liveObj->objLevel = level;
		liveObj->stats = globals::g_ObjectStats_TABLE[liveObj->objType][liveObj->objIndex] + level;
		return 1;
	}
	return 0;
}



float10 __cdecl lego::game::LiveObject_GetRouteSpeed(LiveObject *liveObj)
{
	return (float10)liveObj->stats->RouteSpeed;
}



float10 __cdecl lego::game::LiveObject_GetDrillTimeType(LiveObject *liveObj,SurfaceType surfaceType)
{
	return (float10)liveObj->stats->DrillTimes[surfaceType];
}



float10 __cdecl lego::game::LiveObject_GetRubbleCoef(LiveObject *liveObj)
{
	return (float10)liveObj->stats->RubbleCoef;
}



float10 __cdecl lego::game::LiveObject_GetWakeRadius(LiveObject *liveObj)
{
	return (float10)liveObj->stats->WakeRadius;
}



float10 __cdecl lego::game::LiveObject_GetPathCoef(LiveObject *liveObj)
{
	return (float10)liveObj->stats->PathCoef;
}



float10 __cdecl lego::game::LiveObject_GetCollRadius(LiveObject *liveObj)
{
	return (float10)liveObj->stats->CollRadius;
}



float10 __cdecl lego::game::LiveObject_GetCollHeight(LiveObject *liveObj)
{
	return (float10)liveObj->stats->CollHeight;
}



float10 __cdecl lego::game::LiveObject_GetPickSphere(LiveObject *liveObj)
{
	return (float10)liveObj->stats->PickSphere;
}



float10 __cdecl lego::game::LiveObject_GetPainThreshold(LiveObject *liveObj)
{
	return (float10)liveObj->stats->PainThreshold;
}



float10 __cdecl lego::game::LiveObject_GetAlertRadius(LiveObject *liveObj)
{
	return (float10)liveObj->stats->AlertRadius;
}



int __cdecl lego::game::LiveObject_GetCollBox(LiveObject *liveObj)
{
	return (int)&liveObj->stats->CollBox;
}



float10 __cdecl lego::game::LiveObject_GetTrackDist(LiveObject *liveObj)
{
	return (float10)liveObj->stats->TrackDist;
}



float10 __cdecl lego::game::LiveObject_GetHealthDecayRate(LiveObject *liveObj)
{
	return (float10)liveObj->stats->HealthDecayRate;
}



float10 __cdecl lego::game::LiveObject_GetEnergyDecayRate(LiveObject *liveObj)
{
	return (float10)liveObj->stats->EnergyDecayRate;
}



float10 __cdecl lego::game::Object_GetOxygenCoef(ObjectType objType,int objIndex)
{
	return (float10)globals::g_ObjectStats_TABLE[objType][objIndex]->OxygenCoef;
}



float10 __cdecl lego::game::LiveObject_GetOxygenCoef(LiveObject *liveObj)
{
	return (float10)liveObj->stats->OxygenCoef;
}



int __cdecl lego::game::LiveObject_GetSurveyRadius(LiveObject *liveObj)
{
	return liveObj->stats->SurveyRadius;
}



ObjectStatsFlags1 __cdecl lego::game::LiveObject_GetStatsFlags1(LiveObject *liveObj)
{
	return liveObj->stats->flags1;
}



ObjectStatsFlags2 __cdecl lego::game::LiveObject_GetStatsFlags2(LiveObject *liveObj)
{
	return liveObj->stats->flags2;
}



ObjectStatsFlags3 __cdecl lego::game::LiveObject_GetStatsFlags3(LiveObject *liveObj)
{
	return liveObj->stats->flags3;
}



ObjectStatsFlags1 __cdecl lego::game::Object_GetStatsFlags1(ObjectType objType,int objIndex)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex]->flags1;
}



ObjectStatsFlags2 __cdecl lego::game::Object_GetStatsFlags2(ObjectType objType,int objIndex)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex]->flags2;
}



ObjectStatsFlags3 __cdecl lego::game::Object_GetStatsFlags3(ObjectType objType,int objIndex)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex]->flags3;
}



float10 __cdecl lego::game::LiveObject_GetRepairValue(LiveObject *liveObj)
{
	return (float10)liveObj->stats->RepairValue;
}



int __cdecl lego::game::Object_GetLevels(ObjectType objType,int objIndex)
{
	return globals::g_ObjectLevels_TABLE[objType][objIndex];
}



int __cdecl lego::game::Object_GetWaterEntrances(ObjectType objType,int objIndex,int objLevel)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex][objLevel].WaterEntrances;
}



int __cdecl lego::game::LiveObject_GetDrillSoundType(LiveObject *liveObj,BOOL isFade)
{
	if (isFade != 0) {
		return liveObj->stats->DrillFadeSound;
	}
	return liveObj->stats->DrillSound;
}



int __cdecl lego::game::LiveObject_GetEngineSound(LiveObject *liveObj)
{
	return liveObj->stats->EngineSound;
}



float10 __cdecl lego::game::LiveObject_GetRestPercent(LiveObject *liveObj)
{
	return (float10)liveObj->stats->RestPercent;
}



float10 __cdecl lego::game::LiveObject_GetCarryMinHealth(LiveObject *liveObj)
{
	return (float10)liveObj->stats->CarryMinHealth;
}



float10 __cdecl lego::game::LiveObject_GetAttackRadius(LiveObject *liveObj)
{
	return (float10)liveObj->stats->AttackRadius;
}



float10 __cdecl lego::game::LiveObject_GetStampRadius(LiveObject *liveObj)
{
	return (float10)liveObj->stats->StampRadius;
}



int __cdecl lego::game::LiveObject_GetNumOfToolsCanCarry(LiveObject *liveObj)
{
	return liveObj->stats->NumOfToolsCanCarry;
}



float10 __cdecl lego::game::LiveObject_GetUpgradeTime(LiveObject *liveObj)
{
	return (float10)liveObj->stats->UpgradeTime;
}



float10 __cdecl lego::game::LiveObject_GetFunctionCoef(LiveObject *liveObj)
{
	return (float10)liveObj->stats->FunctionCoef;
}



int __cdecl lego::game::Object_GetUpgradeCostOre(ObjectType objType,int objIndex,int objLevel)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex][objLevel].UpgradeCostOre;
}



int __cdecl lego::game::Object_GetUpgradeCostStuds(ObjectType objType,int objIndex,int objLevel)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex][objLevel].UpgradeCostStuds;
}



BOOL __cdecl lego::ai::AI_GetToolFromTaskType(AITaskType taskType,ToolType *out_toolType)
{
	ToolData *pTVar1;
	uint uVar2;
	ToolData *pTVar3;
	ToolType TVar4;
	
	TVar4 = TOOL_DRILL;
	pTVar1 = ToolData_ARRAY_005040d8;
	do {
		uVar2 = 0;
		pTVar3 = pTVar1;
		if (pTVar1->count != 0) {
			do {
				if (taskType == pTVar3->taskType) {
					*out_toolType = TVar4;
					return 1;
				}
				uVar2 = uVar2 + 1;
				pTVar3 = (ToolData *)&pTVar3->field_4;
			} while (uVar2 < (uint)pTVar1->count);
		}
		pTVar1 = pTVar1 + 1;
		TVar4 = TVar4 + TOOL_SPADE;
	} while (pTVar1 < &BOOL_00504188);
	return 0;
}



float10 __cdecl lego::game::LiveObject_GetFlocks_Height(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_Height;
}



float10 __cdecl lego::game::LiveObject_GetFlocks_Randomness(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_Randomness;
}



float10 __cdecl lego::game::LiveObject_GetFlocks_Turn(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_Turn;
}



float10 __cdecl lego::game::LiveObject_GetFlocks_Tightness(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_Tightness;
}



float10 __cdecl lego::game::LiveObject_GetFlocks_Speed(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_Speed;
}



int __cdecl lego::game::LiveObject_GetFlocks_Size(LiveObject *liveObj)
{
	return liveObj->stats->Flocks_Size;
}



float10 __cdecl lego::game::LiveObject_GetFlocks_GoalUpdate(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_GoalUpdate;
}



float10 __cdecl lego::game::LiveObject_GetFlocks_AttackTime(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_AttackTime;
}



float10 __cdecl lego::game::LiveObject_GetAwarenessRange(LiveObject *liveObj)
{
	return (float10)liveObj->stats->AwarenessRange;
}



float10 __cdecl lego::game::LiveObject_GetPusherDist(LiveObject *liveObj)
{
	return (float10)liveObj->stats->PusherDist;
}



float10 __cdecl lego::game::LiveObject_GetPusherDamage(LiveObject *liveObj)
{
	return (float10)liveObj->stats->PusherDamage;
}



float10 __cdecl lego::game::LiveObject_GetLaserDamage(LiveObject *liveObj)
{
	return (float10)liveObj->stats->LaserDamage;
}



float10 __cdecl lego::game::LiveObject_GetFreezerDamage(LiveObject *liveObj)
{
	return (float10)liveObj->stats->FreezerDamage;
}



float10 __cdecl lego::game::LiveObject_GetFreezerTime(LiveObject *liveObj)
{
	return (float10)liveObj->stats->FreezerTime;
}



void __cdecl lego::game::LiveObject_SetUnkFlags2(LiveObject *liveObj)
{
	ObjectStats *pOVar1;
	ObjectStatsFlags2 OVar2;
	
	pOVar1 = liveObj->stats;
	OVar2 = pOVar1->flags2;
	if ((OVar2 & STATS2_SELFPOWERED) != STATS2_NONE) {
		pOVar1->flags2 =
				 OVar2 & (STATS2_SCAREDBYBIGBANGS|STATS2_UPGRADEBUILDING|STATS2_TRAINPILOT|
									STATS2_TRAINSAILOR|STATS2_TRAINDRIVER|STATS2_TRAINDYNAMITE|STATS2_TRAINREPAIR|
									STATS2_TRAINSCANNER|STATS2_TRACKER|STATS2_GENERATEPOWER|STATS2_USEBIGTELEPORTER|
									STATS2_USESMALLTELEPORTER|STATS2_USEWATERTELEPORTER|STATS2_ATTACKPATHS|
									STATS2_SPLITONZEROHEALTH|STATS2_CANBEHITBYFENCE|STATS2_CANDOUBLESELECT|
									STATS2_CANBESHOTAT|STATS2_DRAINPOWER|STATS2_USEHOLES|STATS2_CROSSLAVA|
									STATS2_USELEGOMANTELEPORTER|STATS2_DAMAGECAUSESCALLTOARMS|STATS2_CANFREEZE|
									STATS2_CANLASER|STATS2_CANPUSH|STATS2_DONTSHOWDAMAGE|STATS2_REMOVEREINFORCEMENT|
									STATS2_DONTSHOWONRADAR|STATS2_INVISIBLEDRIVER|STATS2_UNSELECTABLE);
		FUN_0043c830(liveObj);
		return;
	}
	pOVar1->flags2 = OVar2 | STATS2_SELFPOWERED;
	FUN_0043c830(liveObj);
	return;
}



void __cdecl lego::unk::Lego_FreeLinkedStruct20(undefined *param_1)
{
	if (param_1 != (undefined *)0x0) {
		Lego_FreeLinkedStruct20(*(undefined **)(param_1 + 0x1c));
		std::free(param_1);
	}
	return;
}



void __cdecl lego::unk::Lego_CleanupLinkedStruct20(void)
{
	globals::g_LinkedStruct20_COUNT = 0;
	Lego_FreeLinkedStruct20(globals::g_Linked_Struct20_NEXT);
	globals::g_Linked_Struct20_NEXT = (undefined *)0x0;
	return;
}



BOOL __cdecl FUN_0046a680(int *param_1,int *param_2)
{
	if (*param_1 == *param_2) {
		param_1[0xe4] = param_2[1];
		param_1[0xe5] = param_2[2];
		if ((*(byte *)(param_2 + 1) & 2) != 0) {
			param_1[0xe6] = param_2[3];
			*(int *)(param_2[3] + 0x10) = *(int *)(param_2[3] + 0x10) + 1;
		}
		lego::globals::g_LinkedStruct20_COUNT = lego::globals::g_LinkedStruct20_COUNT + 1;
		param_1[0xfb] = param_1[0xfb] | 8;
	}
	return 0;
}



// This function is weird, it returns EDX:EAX, but what for??

Point2F __cdecl FUN_0046a6e0(void)
{
	SurfaceMap *surfMap;
	CameraData *cam;
	Vector3F *out_surfPosition;
	Vector3F local_c;
	
	cam = lego::globals::g_Game.cameraMain;
	if (lego::globals::g_Game.viewMode != VIEW_TOPDOWN) {
		cam = lego::globals::g_Game.cameraFP;
	}
	out_surfPosition = &local_c;
	surfMap = lego::game::GetSurfaceMap();
	lego::view::Camera_GetSurfacePosition_IfTopdown(cam,surfMap,out_surfPosition);
	return (Point2F)CONCAT44(local_c.y,local_c.x);
}



void __cdecl lego::unk::SetLinkedStruct20_Next(int param_1)
{
	*(int *)(param_1 + 0x1c) = globals::g_Linked_Struct20_NEXT;
	globals::g_Linked_Struct20_NEXT = param_1;
	return;
}



BOOL __cdecl FUN_0046a750(uint *param_1,uint param_2)
{
	uint uVar1;
	
	uVar1 = lego::game::Game_GetFirstObjectiveFlag(param_2);
	if ((*param_1 == uVar1) && (param_1[0xe4] != 0)) {
		BOOL_00504188 = 0;
	}
	return 0;
}



BOOL __cdecl FUN_0046a780(uint param_1)
{
	LiveObject *liveObj;
	uint uVar1;
	
	uVar1 = 0;
	do {
		liveObj = (LiveObject *)(1 << ((byte)uVar1 & 0x1f));
		BOOL_00504188 = 1;
		if ((param_1 & (uint)liveObj) != 0) {
			lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_0046a750,liveObj);
			if (BOOL_00504188 == 0) {
				return 0;
			}
		}
		uVar1 = uVar1 + 1;
	} while (uVar1 < 0x1f);
	return 1;
}



void __cdecl FUN_0046a7d0(uint param_1,uint param_2,uint param_3)
{
	Point2F PVar1;
	ObjectType local_10;
	uint local_c;
	char *local_8;
	VehicleData *local_4;
	
	local_10 = lego::game::Game_GetFirstObjectiveFlag(param_1);
	local_c = param_2;
	local_8 = (char *)param_3;
	if ((param_2 & 2) != 0) {
		local_4 = (VehicleData *)std::malloc(0x20);
		lego::unk::SetLinkedStruct20_Next((int)local_4);
		local_4->WheelMeshes[0] = (Container *)0x0;
		if ((param_3 & 2) != 0) {
			PVar1 = FUN_0046a6e0();
			local_4->objIndex = SUB84(PVar1,0);
			local_4->WheelNullName = (char *)((ulonglong)PVar1 >> 0x20);
			local_4->aeResData1 = (Container *)0x0;
			local_4->aeResData2 = (Container *)FLOAT_004ab45c;
		}
		if ((param_3 & 1) != 0) {
			local_4->WheelMeshes[1] = (Container *)INT_004ab454;
		}
		local_4->WheelMeshes[2] = (Container *)param_3;
	}
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70(FUN_0046a680,(LiveObject *)&local_10);
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_0046a880(LiveObject *liveObj)
{
	uint uVar1;
	float *pfVar2;
	int iVar3;
	short sVar4;
	float local_10;
	float local_c [3];
	
	if ((liveObj->field_390 & 1) != 0) {
		liveObj->health = -1.0;
		liveObj->field_394 = 0;
		liveObj->field_390 = 4;
		globals::g_LinkedStruct20_COUNT = globals::g_LinkedStruct20_COUNT - 1;
		return 0;
	}
	if ((liveObj->field_390 & 2) != 0) {
		uVar1 = liveObj->field_394;
		if ((uVar1 & 2) == 0) {
			if ((uVar1 & 1) == 0) {
				if ((uVar1 & 4) != 0) {
					liveObj->health = -1.0;
					liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
					globals::g_LinkedStruct20_COUNT = globals::g_LinkedStruct20_COUNT - 1;
				}
			}
			else {
				iVar3 = liveObj->field_398;
				sVar4 = math::Maths_Rand();
				if ((int)sVar4 % *(int *)(iVar3 + 0x14) == 0) {
					liveObj->health = -1.0;
					*(int *)(iVar3 + 0x10) = *(int *)(iVar3 + 0x10) + -1;
					goto LAB_0046a960;
				}
			}
		}
		else {
			pfVar2 = (float *)liveObj->field_398;
			LiveObject_GetPosition(liveObj,&local_10,local_c);
			local_10 = local_10 - *pfVar2;
			local_c[0] = local_c[0] - pfVar2[1];
			iVar3 = liveObj->field_398;
			if (SQRT(local_c[0] * local_c[0] + local_10 * local_10) < *(float *)(iVar3 + 8)) {
				liveObj->health = -1.0;
				*(int *)(iVar3 + 0x10) = *(int *)(iVar3 + 0x10) + -1;
LAB_0046a960:
				liveObj->field_390 = 4;
				liveObj->field_398 = 0;
				liveObj->field_394 = 0;
				globals::g_LinkedStruct20_COUNT = globals::g_LinkedStruct20_COUNT - 1;
				return 0;
			}
		}
	}
	return 0;
}



BOOL __cdecl FUN_0046a9c0(int param_1,float param_2)
{
	if (param_1 != 0) {
		do {
			if ((*(int *)(param_1 + 0x10) != 0) && (*(int *)(param_1 + 0x18) == 2)) {
				*(float *)(param_1 + 8) = *(float *)(param_1 + 0xc) * param_2 + *(float *)(param_1 + 8);
			}
			param_1 = *(int *)(param_1 + 0x1c);
		} while (param_1 != 0);
	}
	return param_1;
}



void __cdecl FUN_0046a9f0(float elapsedGame)
{
	FUN_0046a9c0(lego::globals::g_Linked_Struct20_NEXT,elapsedGame);
	if (lego::globals::g_LinkedStruct20_COUNT != 0) {
		lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
							(lego::game::LiveObject_FUN_0046a880,(LiveObject *)0x0);
	}
	return;
}



uint __cdecl lego::game::Game_GetFirstObjectiveFlag(ObjectiveFlags objectiveFlags)
{
	if ((objectiveFlags & OBJECTIVE_UNK_1) != OBJECTIVE_NONE) {
		return 1;
	}
	if ((objectiveFlags & OBJECTIVE_COMPLETE) != OBJECTIVE_NONE) {
		return 2;
	}
	if ((objectiveFlags & OBJECTIVE_FAILED) != OBJECTIVE_NONE) {
		return 3;
	}
	if ((objectiveFlags & OBJECTIVE_UNK_8) != OBJECTIVE_NONE) {
		return 4;
	}
	if ((objectiveFlags & OBJECTIVE_SHOWADVISOR) != OBJECTIVE_NONE) {
		return 5;
	}
	if ((objectiveFlags & OBJECTIVE_SHOWACHEIVEADVISOR) != OBJECTIVE_NONE) {
		return 6;
	}
	if ((objectiveFlags & OBJECTIVE_HITTIMEFAIL) != OBJECTIVE_NONE) {
		return 7;
	}
	if ((objectiveFlags & OBJECTIVE_SHOWFAILEDADVISOR) != OBJECTIVE_NONE) {
		return 8;
	}
	if ((objectiveFlags & OBJECTIVE_CRYSTAL) != OBJECTIVE_NONE) {
		return 9;
	}
	if ((objectiveFlags & OBJECTIVE_ORE) != OBJECTIVE_NONE) {
		return 10;
	}
	if ((objectiveFlags & OBJECTIVE_BLOCK) != OBJECTIVE_NONE) {
		return 0xb;
	}
	if ((objectiveFlags & OBJECTIVE_TIMER) != OBJECTIVE_NONE) {
		return 0xc;
	}
	return -(uint)((objectiveFlags & OBJECTIVE_CONSTRUCTION) != OBJECTIVE_NONE) & 0xd;
}



void __cdecl
lego::front::Text_Load
					(TextWindow *param_1,TextWindow *param_2,int imageX,int imageY,float pauseTime)
{
	if (pauseTime == 0.0) {
		globals::g_TextTypes_TABLE[0] = "Text_Walk";
		globals::g_TextTypes_TABLE[1] = "Text_Drill";
		globals::g_TextTypes_TABLE[2] = "Text_NoDrill";
		globals::g_TextTypes_TABLE[3] = "Text_CantDrill";
		globals::g_TextTypes_TABLE[4] = "Text_Reinforce";
		globals::g_TextTypes_TABLE[5] = "Text_NoReinforce";
		globals::g_TextTypes_TABLE[6] = "Text_CantReinforce";
		globals::g_TextTypes_TABLE[7] = "Text_PickupCrystal";
		globals::g_TextTypes_TABLE[8] = "Text_Encyclopedia";
		globals::g_TextTypes_TABLE[9] = "Text_RadarHelp";
		globals::g_TextTypes_TABLE[10] = "Text_BuildHelp";
		globals::g_TextTypes_TABLE[11] = "Text_SelectionHelp";
		globals::g_TextTypes_TABLE[12] = "Text_Drive";
		globals::g_TextTypes_TABLE[13] = "Text_CantDrive";
		globals::g_TextTypes_TABLE[14] = "Text_MakeTeleporter";
		globals::g_TextTypes_TABLE[15] = "Text_CannotPlaceBuilding";
		globals::g_TextTypes_TABLE[16] = "Text_CrystalOreDisabled";
		globals::g_TextTypes_TABLE[17] = "Text_CrystalFound";
		globals::g_TextTypes_TABLE[18] = "Text_CavernDiscovered";
		globals::g_TextTypes_TABLE[19] = "Text_OreFound";
		globals::g_TextTypes_TABLE[20] = "Text_AirSupplyLow";
		globals::g_TextTypes_TABLE[21] = "Text_AirSupplyRunningOut";
		globals::g_TextTypes_TABLE[22] = "Text_SpaceToContinue";
		globals::g_TextTypes_TABLE[23] = "Text_GameCompleted";
		globals::g_TextTypes_TABLE[24] = "Text_ManTrained";
		globals::g_TextTypes_TABLE[25] = "Text_UnitUpgraded";
		globals::g_TextCurrentType = TEXT__COUNT;
		globals::g_Texts_COUNT = 26;
		PTRTextWindow_0050461c = param_1;
		PTRTextWindow_00504620 = param_2;
		globals::g_TextImagePosition.x = imageX;
		globals::g_TextImagePosition.y = imageY;
		globals::g_TextPauseTime = (float)&DAT_42c80000;
										// 316 (passed from Game_Init)
										// 425 (passed from Game_Init)
										// 100.0
		return;
	}
	globals::g_TextTypes_TABLE[0] = "Text_Walk";
	globals::g_TextTypes_TABLE[1] = "Text_Drill";
	globals::g_TextTypes_TABLE[2] = "Text_NoDrill";
	globals::g_TextTypes_TABLE[3] = "Text_CantDrill";
	globals::g_TextTypes_TABLE[4] = "Text_Reinforce";
	globals::g_TextTypes_TABLE[5] = "Text_NoReinforce";
	globals::g_TextTypes_TABLE[6] = "Text_CantReinforce";
	globals::g_TextTypes_TABLE[7] = "Text_PickupCrystal";
	globals::g_TextTypes_TABLE[8] = "Text_Encyclopedia";
	globals::g_TextTypes_TABLE[9] = "Text_RadarHelp";
	globals::g_TextTypes_TABLE[10] = "Text_BuildHelp";
	globals::g_TextTypes_TABLE[11] = "Text_SelectionHelp";
	globals::g_TextTypes_TABLE[12] = "Text_Drive";
	globals::g_TextTypes_TABLE[13] = "Text_CantDrive";
	globals::g_TextTypes_TABLE[14] = "Text_MakeTeleporter";
	globals::g_TextTypes_TABLE[15] = "Text_CannotPlaceBuilding";
	globals::g_TextTypes_TABLE[16] = "Text_CrystalOreDisabled";
	globals::g_TextTypes_TABLE[17] = "Text_CrystalFound";
	globals::g_TextTypes_TABLE[18] = "Text_CavernDiscovered";
	globals::g_TextTypes_TABLE[19] = "Text_OreFound";
	globals::g_TextTypes_TABLE[20] = "Text_AirSupplyLow";
	globals::g_TextTypes_TABLE[21] = "Text_AirSupplyRunningOut";
	globals::g_TextTypes_TABLE[22] = "Text_SpaceToContinue";
	globals::g_TextTypes_TABLE[23] = "Text_GameCompleted";
	globals::g_TextTypes_TABLE[24] = "Text_ManTrained";
	globals::g_TextTypes_TABLE[25] = "Text_UnitUpgraded";
	globals::g_TextCurrentType = TEXT__COUNT;
	globals::g_Texts_COUNT = 26;
	PTRTextWindow_0050461c = param_1;
	PTRTextWindow_00504620 = param_2;
	globals::g_TextImagePosition.x = imageX;
	globals::g_TextImagePosition.y = imageY;
	globals::g_TextPauseTime = pauseTime;
	return;
}



void __cdecl
lego::main::Main_LoadMsgPanel
					(char *filename,uint param_2,uint param_3,uint unused_int,Rect2F *param_5,
					Rect2F *unused_rect,float param_7)
{
										// 409 (passed from Game_Init)
	UINT_00504628 = param_3;
	globals::g_MsgPanel_Rect1.x = param_5->x;
	globals::g_MsgPanel_Rect1.y = param_5->y;
	globals::g_MsgPanel_Rect1.width = param_5->width;
	globals::g_MsgPanel_Rect1.height = param_5->height;
	FLOAT_0050463c =
			 (globals::g_MsgPanel_Rect1.y + globals::g_MsgPanel_Rect1.height) -
			 (float)PTRTextWindow_0050461c->font->field_be4;
										// 20.0 (passed from Game_Init)
										// 42   (passed from Game_Init)
	globals::g_MsgPanel_Float20 = param_7;
	globals::g_MsgPanel_Float42 = (float)(ulonglong)param_2;
	image::Struct830_FUN_0046aca0();
	return;
}



void __cdecl lego::image::Struct830_FUN_0046aca0(void)
{
	int ypos;
	uint height;
	longlong lVar1;
	
	FLOAT_00504648 = (float)(ulonglong)UINT_00504628;
	lVar1 = __ftol((float10)globals::g_MsgPanel_Rect1.y);
	ypos = (int)lVar1;
	lVar1 = __ftol((float10)globals::g_MsgPanel_Rect1.x);
	front::TextWindow_ChangePosition(PTRTextWindow_0050461c,(int)lVar1,ypos);
	lVar1 = __ftol((float10)globals::g_MsgPanel_Rect1.height);
	height = (uint)lVar1;
	lVar1 = __ftol((float10)globals::g_MsgPanel_Rect1.width);
	front::TextWindow_ChangeSize(PTRTextWindow_0050461c,(uint)lVar1,height);
	Rect2F_0050464c.x = globals::g_MsgPanel_Rect1.x;
	Rect2F_0050464c.y = globals::g_MsgPanel_Rect1.y;
	Rect2F_0050464c.width = globals::g_MsgPanel_Rect1.width;
	Rect2F_0050464c.height = globals::g_MsgPanel_Rect1.height;
	globals::g_TextPanelFlags = globals::g_TextPanelFlags & 0xfffffffe;
	return;
}



void __cdecl FUN_0046ad50(void)
{
	lego::image::Struct830_FUN_0046aca0();
	lego::globals::g_TextCurrentType = TEXT__COUNT;
	FLAGS_00504610 = 0;
	DAT_00504614 = 0;
	lego::globals::g_TextPanelFlags = 0;
	lego::front::TextWindow_Clear(PTRTextWindow_0050461c);
	lego::front::TextWindow_Clear(PTRTextWindow_00504620);
	return;
}



BOOL __cdecl lego::front::Text_GetTextType(char *textName,TextType *out_textType)
{
	int iVar1;
	char **ppcVar2;
	int index;
	
	index = 0;
	ppcVar2 = globals::g_TextTypes_TABLE;
	do {
		iVar1 = std::_stricmp(*ppcVar2,textName);
		if (iVar1 == 0) {
			*out_textType = index;
			return 1;
		}
		ppcVar2 = ppcVar2 + 1;
										// index++
		index = index + TEXT_DRILL;
										// index < TEXT__COUNT (26)
	} while (ppcVar2 < globals::g_TextMessages_TABLE);
	return 0;
}



void __cdecl lego::front::Text_SetMessage(TextType textType,char *textMessage)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	
	if (globals::g_TextMessages_TABLE[textType] != (char *)0x0) {
		std::free(globals::g_TextMessages_TABLE[textType]);
	}
	uVar4 = 0xffffffff;
	pcVar3 = textMessage;
	do {
		if (uVar4 == 0) break;
		uVar4 = uVar4 - 1;
		cVar2 = *pcVar3;
		pcVar3 = pcVar3 + 1;
	} while (cVar2 != '\0');
	pcVar3 = (char *)std::malloc(~uVar4);
	globals::g_TextMessages_TABLE[textType] = pcVar3;
	cVar2 = *textMessage;
	while (cVar2 != '\0') {
		cVar2 = *textMessage;
		if (cVar2 == '_') {
			*pcVar3 = ' ';
		}
		else {
			if ((cVar2 == '\\') && (textMessage[1] == 'n')) {
				*pcVar3 = '\n';
				textMessage = textMessage + 1;
			}
			else {
				*pcVar3 = cVar2;
			}
		}
		pcVar1 = textMessage + 1;
		pcVar3 = pcVar3 + 1;
		textMessage = textMessage + 1;
		cVar2 = *pcVar1;
	}
	*pcVar3 = '\0';
	if (globals::g_TextImages_TABLE[textType] != (ImageBMP *)0x0) {
		image::Image_Remove(globals::g_TextImages_TABLE[textType]);
		globals::g_TextImages_TABLE[textType] = (ImageBMP *)0x0;
	}
	return;
}



void __cdecl
lego::front::Text_SetMessageWithImage(TextType textType,char *message,char *filename,char *sfxName)
{
	ImageBMP *image;
	
	Text_SetMessage(textType,message);
	std::sprintf((char *)globals::g_TextImageSFXs_TABLE[textType],"%s",sfxName);
	image = lego::image::Image_LoadBMPScaled(filename,0,0);
	globals::g_TextImages_TABLE[textType] = image;
	if (image != (ImageBMP *)0x0) {
		lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	return;
}



void __cdecl FUN_0046aee0(char *param_1,uint param_2)
{
	DAT_00504614 = param_1;
	if (param_2 == 0) {
		param_2 = 0x8000;
	}
	FLAGS_00504610 = param_2 | 0x10000;
	lego::game::Level_NERPMessage_Parse(param_1,(undefined4 *)0x0,1);
	lego::globals::g_TextPanelFlags = lego::globals::g_TextPanelFlags | 1;
	return;
}



void __cdecl lego::front::Text_DisplayMessage(TextType textType,BOOL changeTiming,BOOL setFlag4)
{
	TutorialFlags TVar1;
	BOOL BVar2;
	
	if (changeTiming == SFX_NULL) {
		if ((ushort)((ushort)(FLOAT_00504618 < 0.0) << 8 | (ushort)(FLOAT_00504618 == 0.0) << 0xe) != 0)
		{
			globals::g_TextCurrentType = textType;
		}
	}
	else {
		globals::g_TextCurrentType = textType;
		FLOAT_00504618 = globals::g_TextPauseTime;
	}
	TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags((int *)0x0);
	if (TVar1 == TUTORIAL_NONE) {
		BVar2 = snd::SFX_GetType((char *)globals::g_TextImageSFXs_TABLE[textType],
														 (SFXType *)&changeTiming);
		if (BVar2 != 0) {
			snd::Audio_FUN_004651b0(changeTiming,(int *)0x0);
		}
	}
	if ((globals::g_TextCurrentType == textType) && (setFlag4 != 0)) {
		globals::g_TextPanelFlags = globals::g_TextPanelFlags | 4;
		return;
	}
	globals::g_TextPanelFlags = globals::g_TextPanelFlags & 0xfffffffb;
	return;
}



void __cdecl FUN_0046afc0(float elapsed)
{
	char *format;
	float fVar1;
	TextType TVar2;
	int iVar3;
	BOOL BVar4;
	uint uVar5;
	ImageBMP *image;
	TextWindow *pTVar6;
	bool bVar7;
	longlong lVar8;
	int local_20c;
	Point2F local_208;
	undefined4 local_200 [128];
	
	TVar2 = lego::globals::g_TextCurrentType;
	image = (ImageBMP *)0x0;
	bVar7 = true;
	if (FLAGS_00504610 == 0) {
		BVar4 = lego::nerps::NERPs_IsLoaded();
		if ((BVar4 != 0) && (lego::globals::g_TextCurrentType != TEXT__COUNT)) {
			image = lego::globals::g_TextImages_TABLE[lego::globals::g_TextCurrentType];
			format = lego::globals::g_TextMessages_TABLE[lego::globals::g_TextCurrentType];
			bVar7 = image == (ImageBMP *)0x0;
			pTVar6 = PTRTextWindow_0050461c;
			if (!bVar7) {
				local_208.x = (float)(ulonglong)(uint)lego::globals::g_TextImagePosition.x;
				local_208.y = (float)(ulonglong)(uint)lego::globals::g_TextImagePosition.y;
				pTVar6 = PTRTextWindow_00504620;
			}
			if (format != (char *)0x0) {
				iVar3 = 1;
				if ((lego::globals::g_TextPanelFlags & 4) != 0) {
					iVar3 = lego::unk::Lego_GetDat_004ded1c();
				}
				if (iVar3 != 0) {
					lego::front::TextWindow_PrintFOverlay(pTVar6,1,format);
				}
			}
			if ((ushort)((ushort)(FLOAT_00504618 < 0.0) << 8 | (ushort)(FLOAT_00504618 == 0.0) << 0xe) !=
					0) {
				lego::globals::g_TextCurrentType = TEXT__COUNT;
			}
			FLOAT_00504618 = FLOAT_00504618 - elapsed;
		}
	}
	else {
		if (DAT_00504614 == (char *)0x0) {
			FLAGS_00504610 = 0;
		}
		else {
			lego::game::Level_NERPMessage_Parse(DAT_00504614,local_200,0);
			lego::front::TextWindow_PrintFOverlay(PTRTextWindow_0050461c,0,(char *)local_200);
			if ((FLAGS_00504610 & 0x8000) == 0) {
				FLAGS_00504610 = FLAGS_00504610 - 1;
			}
		}
	}
	if (((lego::globals::g_Game.flags1 & GAME1_CAMERADISABLED) != GAME1_NONE) &&
		 (TVar2 != TEXT_SPACETOCONTINUE)) {
		lego::image::Struct830_FUN_0046aca0();
		lego::front::Panel_SetXYField3(PANEL_MESSAGES,lego::globals::g_MsgPanel_Float42,FLOAT_00504648);
		lego::front::Panel_FUN_0045a9f0(PANEL_MESSAGES,0.0);
		lego::front::AirMeter_FUN_0045c6b0(PANEL_MESSAGES,(lego::globals::g_Game.level)->oxygenLevel);
		lego::front::AirMeter_FUN_0045c770(PANEL_MESSAGES);
		return;
	}
	if (!bVar7) {
		lego::image::Struct830_FUN_0046aca0();
		lego::front::Panel_SetXYField3(PANEL_MESSAGES,lego::globals::g_MsgPanel_Float42,FLOAT_00504648);
		lego::front::Panel_FUN_0045a9f0(PANEL_MESSAGES,0.0);
		lego::front::AirMeter_FUN_0045c6b0(PANEL_MESSAGES,(lego::globals::g_Game.level)->oxygenLevel);
		lego::front::AirMeter_FUN_0045c770(PANEL_MESSAGES);
		lego::front::TextWindow_Update(PTRTextWindow_00504620,0,elapsed,(int *)0x0);
		lego::image::Image_DisplayScaled(image,(Rect2F *)0x0,&local_208,(Size2F *)0x0);
		return;
	}
	lego::front::Panel_SetXYField3(PANEL_MESSAGES,lego::globals::g_MsgPanel_Float42,FLOAT_00504648);
	lego::front::Panel_FUN_0045a9f0(PANEL_MESSAGES,0.0);
	lego::front::AirMeter_FUN_0045c6b0(PANEL_MESSAGES,(lego::globals::g_Game.level)->oxygenLevel);
	lego::front::AirMeter_FUN_0045c770(PANEL_MESSAGES);
	BVar4 = lego::front::TextWindow_Update(PTRTextWindow_0050461c,0,elapsed,&local_20c);
	pTVar6 = PTRTextWindow_0050461c;
	if (BVar4 == 0) {
		if ((lego::globals::g_TextPanelFlags & 1) != 0) {
			if (FLOAT_0050463c <= (float)local_20c) {
				lego::globals::g_TextPanelFlags = lego::globals::g_TextPanelFlags & 0xfffffffe;
				return;
			}
			fVar1 = (float)(ulonglong)(uint)PTRTextWindow_0050461c->font->field_be4;
			FLOAT_00504648 = fVar1 + FLOAT_00504648;
			Rect2F_0050464c.y = fVar1 + Rect2F_0050464c.y;
			Rect2F_0050464c.height = Rect2F_0050464c.height - fVar1;
			lVar8 = __ftol((float10)Rect2F_0050464c.y);
			iVar3 = (int)lVar8;
			lVar8 = __ftol((float10)Rect2F_0050464c.x);
			lego::front::TextWindow_ChangePosition(pTVar6,(int)lVar8,iVar3);
			lVar8 = __ftol((float10)Rect2F_0050464c.height);
			uVar5 = (uint)lVar8;
			lVar8 = __ftol((float10)Rect2F_0050464c.width);
			lego::front::TextWindow_ChangeSize(PTRTextWindow_0050461c,(uint)lVar8,uVar5);
			if ((float)(ulonglong)UINT_00504628 <= FLOAT_00504648) {
				FLOAT_00504648 = (float)(ulonglong)UINT_00504628;
				lego::globals::g_TextPanelFlags = lego::globals::g_TextPanelFlags & 0xfffffffe;
				Rect2F_0050464c.x = lego::globals::g_MsgPanel_Rect1.x;
				Rect2F_0050464c.y = lego::globals::g_MsgPanel_Rect1.y;
				Rect2F_0050464c.width = lego::globals::g_MsgPanel_Rect1.width;
				Rect2F_0050464c.height = lego::globals::g_MsgPanel_Rect1.height;
				lVar8 = __ftol((float10)lego::globals::g_MsgPanel_Rect1.y);
				iVar3 = (int)lVar8;
				lVar8 = __ftol((float10)lego::globals::g_MsgPanel_Rect1.x);
				lego::front::TextWindow_ChangePosition(PTRTextWindow_0050461c,(int)lVar8,iVar3);
				lVar8 = __ftol((float10)Rect2F_0050464c.height);
				uVar5 = (uint)lVar8;
				lVar8 = __ftol((float10)Rect2F_0050464c.width);
				lego::front::TextWindow_ChangeSize(PTRTextWindow_0050461c,(uint)lVar8,uVar5);
				return;
			}
		}
		return;
	}
	fVar1 = (float)(ulonglong)(uint)PTRTextWindow_0050461c->font->field_be4;
	FLOAT_00504648 = FLOAT_00504648 - fVar1;
	Rect2F_0050464c.y = Rect2F_0050464c.y - fVar1;
	Rect2F_0050464c.height = fVar1 + Rect2F_0050464c.height;
	lVar8 = __ftol((float10)Rect2F_0050464c.y);
	iVar3 = (int)lVar8;
	lVar8 = __ftol((float10)Rect2F_0050464c.x);
	lego::front::TextWindow_ChangePosition(pTVar6,(int)lVar8,iVar3);
	lVar8 = __ftol((float10)Rect2F_0050464c.height);
	uVar5 = (uint)lVar8;
	lVar8 = __ftol((float10)Rect2F_0050464c.width);
	lego::front::TextWindow_ChangeSize(PTRTextWindow_0050461c,(uint)lVar8,uVar5);
	lego::globals::g_TextPanelFlags = lego::globals::g_TextPanelFlags & 0xfffffffe;
	return;
}



void __cdecl
lego::main::Main_InitToolTips_AndBigStruct
					(ImageFont *font,int param_2,int param_3,float param_4,int screenWidth,int screenHeight,
					int param_7,float param_8,float param_9,float param_10)
{
	float *pfVar1;
	int iVar2;
	ToolTipData *pTVar3;
	
	globals::g_ToolTips_TABLE[0] = "ToolTip_RadarBlock";
	globals::g_ToolTips_TABLE[1] = "ToolTip_UnitSelect";
	globals::g_ToolTips_TABLE[2] = "ToolTip_Construction";
	globals::g_ToolTips_TABLE[3] = "ToolTip_InterfaceMenu";
	globals::g_ToolTips_TABLE[4] = "ToolTip_InterfaceMenuBackButton";
	globals::g_ToolTips_TABLE[5] = "ToolTip_MapBlock";
	globals::g_ToolTips_TABLE[6] = "ToolTip_Priority";
	globals::g_ToolTips_TABLE[7] = "ToolTip_InfoMenuContinue";
	globals::g_ToolTips_TABLE[8] = "ToolTip_InfoMenuDisableFuture";
	globals::g_ToolTips_TABLE[9] = "ToolTip_RadarToggle";
	globals::g_ToolTips_TABLE[10] = "ToolTip_RadarObjectView";
	globals::g_ToolTips_TABLE[11] = "ToolTip_RadarZoomIn";
	globals::g_ToolTips_TABLE[12] = "ToolTip_RadarZoomOut";
	globals::g_ToolTips_TABLE[13] = "ToolTip_RadarMapView";
	globals::g_ToolTips_TABLE[14] = "ToolTip_InfoDockGoto";
	globals::g_ToolTips_TABLE[15] = "ToolTip_InfoDockClose";
	globals::g_ToolTips_TABLE[16] = "ToolTip_TopPanelCallToArms";
	globals::g_ToolTips_TABLE[17] = "ToolTip_TopPanelInfo";
	globals::g_ToolTips_TABLE[18] = "ToolTip_TopPanelOptions";
	globals::g_ToolTips_TABLE[19] = "ToolTip_TopPanelPriorities";
	globals::g_ToolTips_TABLE[20] = "ToolTip_PriorityDisable";
	globals::g_ToolTips_TABLE[21] = "ToolTip_PriorityUpOne";
	globals::g_ToolTips_TABLE[22] = "ToolTip_PriorityReset";
	globals::g_ToolTips_TABLE[23] = "ToolTip_CamControlZoomIn";
	globals::g_ToolTips_TABLE[24] = "ToolTip_CamControlZoomOut";
	globals::g_ToolTips_TABLE[25] = "ToolTip_CamControlCycle";
	globals::g_ToolTips_TABLE[26] = "ToolTip_CamControlRotate";
	globals::g_ToolTips_TABLE[27] = "ToolTip_SideBar_Ore";
	globals::g_ToolTips_TABLE[28] = "ToolTip_SideBar_Crystals";
	globals::g_ToolTips_TABLE[29] = "ToolTip_Close";
	globals::g_ToolTips_TABLE[30] = "ToolTip_PreviousMessage";
	globals::g_ToolTips_TABLE[31] = "ToolTip_NextMessage";
	globals::g_ToolTips_TABLE[32] = "ToolTip_More";
	globals::g_ToolTips_TABLE[33] = "ToolTip_Back";
	globals::g_ToolTips_TABLE[34] = "ToolTip_CamControlCycleMinifigures";
	globals::g_ToolTips_TABLE[35] = "ToolTip_Reward_Save";
	globals::g_ToolTips_TABLE[36] = "ToolTip_Reward_Advance";
	globals::g_ToolTips_TABLE[37] = "ToolTip_FrontEnd_Back";
	FONT_0054cf20 = (ImageFont **)font;
	DAT_0054cf24 = image::Font_GetHeight(font);
	FLOAT_0054cf3c = param_4 * 25.0;
	UINT_0054cf28 = param_2;
	INT_0054cf2c = param_3;
	FLOAT_ARRAY_0054cf40[1] = param_8 + param_8 * 0.4;
	INT_0054cf30 = screenWidth;
	INT_0054cf34 = screenHeight;
	INT_0054cf38 = param_7;
	FLOAT_ARRAY_0054cf40[0] = param_8;
	FLOAT_ARRAY_0054cf40[3] = param_9;
	FLOAT_ARRAY_0054cf40[6] = param_10;
	FLOAT_ARRAY_0054cf40[4] = param_9 + param_9 * 0.4;
	FLOAT_ARRAY_0054cf40[7] = param_10 + param_10 * 0.4;
	FLOAT_ARRAY_0054cf40[2] = param_8 - param_8 * 0.4;
	pfVar1 = FLOAT_ARRAY_0054cf40 + 3;
	FLOAT_ARRAY_0054cf40[5] = param_9 - param_9 * 0.4;
	FLOAT_ARRAY_0054cf40[8] = param_10 - param_10 * 0.4;
	do {
		if ((ushort)((ushort)(pfVar1[-3] < 1.0) << 8 | (ushort)(pfVar1[-3] == 1.0) << 0xe) == 0) {
			pfVar1[-3] = 1.0;
		}
		if ((ushort)((ushort)(*pfVar1 < 1.0) << 8 | (ushort)(*pfVar1 == 1.0) << 0xe) == 0) {
			*pfVar1 = 1.0;
		}
		if ((ushort)((ushort)(pfVar1[3] < 1.0) << 8 | (ushort)(pfVar1[3] == 1.0) << 0xe) == 0) {
			pfVar1[3] = 1.0;
		}
		if (pfVar1[-3] < 0.0) {
			pfVar1[-3] = 0.0;
		}
		if (*pfVar1 < 0.0) {
			*pfVar1 = 0.0;
		}
		if (pfVar1[3] < 0.0) {
			pfVar1[3] = 0.0;
		}
		pfVar1 = pfVar1 + 1;
	} while (pfVar1 < FLOAT_ARRAY_0054cf40 + 6);
	pTVar3 = globals::g_ToolTipsData_TABLE;
	for (iVar2 = 0x1839; iVar2 != 0; iVar2 = iVar2 + -1) {
		pTVar3->float_0 = 0.0;
		pTVar3 = (ToolTipData *)pTVar3->tooltipText;
	}
	return;
}



BOOL __cdecl lego::front::ToolTip_GetType(char *toolTipName,int *out_toolTipType)
{
	int iVar1;
	char **ppcVar2;
	int iVar3;
	
	iVar3 = 1;
	ppcVar2 = globals::g_ToolTips_TABLE;
	do {
		iVar1 = std::_stricmp(toolTipName,*ppcVar2);
		if (iVar1 == 0) {
			*out_toolTipType = iVar3;
			return 1;
		}
		ppcVar2 = (char **)((int)ppcVar2 + 4);
		iVar3 = iVar3 + 1;
	} while (ppcVar2 < globals::g_ToolTipsData_TABLE);
	return 0;
}



void __cdecl lego::front::ToolTip_Load_HasNLEscape(int index,char *format,...)
{
	char *pcVar1;
	char cVar2;
	uint uVar3;
	int iVar4;
	int iVar5;
	ImageBMP *pIVar6;
	char *pcVar7;
	char *pcVar8;
	char filename [260];
	char tooltipText [512];
	
	std::vsprintf(tooltipText,format,&stack0x0000000c);
										// Use @ to denote an image...
	if (tooltipText[0] == '@') {
		iVar5 = 1;
		while (tooltipText[1] != '\0') {
			filename[iVar5 + -1] = tooltipText[1];
			iVar4 = iVar5 + 1;
			iVar5 = iVar5 + 1;
			tooltipText[1] = tooltipText[iVar4];
		}
		filename[iVar5 + -1] = '\0';
		pIVar6 = image::Image_LoadBMPScaled(filename,0,0);
		globals::g_ToolTipsData_TABLE[index].tooltipImage = pIVar6;
		globals::g_ToolTipsData_TABLE[index].flags = globals::g_ToolTipsData_TABLE[index].flags | 8;
	}
	else {
		pcVar7 = tooltipText;
		pcVar8 = globals::g_ToolTipsData_TABLE[index].tooltipText;
		while (tooltipText[0] != '\0') {
			cVar2 = *pcVar7;
										// an \n as a return character...
			if ((cVar2 == '\\') && (pcVar7[1] == 'n')) {
				*pcVar8 = '\n';
				pcVar7 = pcVar7 + 1;
			}
			else {
										// Use underscores as spaces
				if (cVar2 == '_') {
					*pcVar8 = ' ';
				}
				else {
					*pcVar8 = cVar2;
				}
			}
			pcVar1 = pcVar7 + 1;
			pcVar8 = pcVar8 + 1;
			pcVar7 = pcVar7 + 1;
			tooltipText[0] = *pcVar1;
		}
		*pcVar8 = '\0';
		unk::UnkFont_FUN_00401bc0
							((ImageFont *)FONT_0054cf20,(uint *)&globals::g_ToolTipsData_TABLE[index].field_0x204,
							 (uint *)&globals::g_ToolTipsData_TABLE[index].field_0x208,
							 globals::g_ToolTipsData_TABLE[index].tooltipText);
		globals::g_ToolTipsData_TABLE[index].flags =
				 globals::g_ToolTipsData_TABLE[index].flags & 0xfffffff7;
	}
	uVar3 = globals::g_ToolTipsData_TABLE[index].flags;
	globals::g_ToolTipsData_TABLE[index].field_25c = 0;
	globals::g_ToolTipsData_TABLE[index].field_264 = 0;
	globals::g_ToolTipsData_TABLE[index].field_260 = 0;
	globals::g_ToolTipsData_TABLE[index].field_26c = 0;
	globals::g_ToolTipsData_TABLE[index].field_268 = 0;
	globals::g_ToolTipsData_TABLE[index].flags = uVar3 | 3;
	return;
}



void __cdecl lego::front::ToolTip_FUN_0046b920(int toolTipType,undefined4 *param_2)
{
	int iVar1;
	int iVar2;
	
	if (param_2 == (undefined4 *)0x0) {
		globals::g_ToolTipsData_TABLE[toolTipType].field_260 = 0;
		globals::g_ToolTipsData_TABLE[toolTipType].field_268 = 0;
	}
	else {
		if ((int)globals::g_ToolTipsData_TABLE[toolTipType].field_260 < (int)param_2[2]) {
			iVar1 = globals::g_ToolTipsData_TABLE[toolTipType].field_264 -
							globals::g_ToolTipsData_TABLE[toolTipType].field_260;
			globals::g_ToolTipsData_TABLE[toolTipType].field_264 = iVar1;
			iVar2 = param_2[2];
			globals::g_ToolTipsData_TABLE[toolTipType].field_260 = iVar2;
			globals::g_ToolTipsData_TABLE[toolTipType].field_264 = iVar1 + iVar2;
		}
		iVar2 = globals::g_ToolTipsData_TABLE[toolTipType].field_268 + param_2[1];
		globals::g_ToolTipsData_TABLE[toolTipType].field_268 = iVar2;
		if ((int)globals::g_ToolTipsData_TABLE[toolTipType].field_26c < iVar2) {
			globals::g_ToolTipsData_TABLE[toolTipType].field_26c = iVar2;
		}
	}
	*(undefined4 **)
	 (toolTipType * 0x27c + 0x54d20c + globals::g_ToolTipsData_TABLE[toolTipType].field_25c * 4) =
			 param_2;
	globals::g_ToolTipsData_TABLE[toolTipType].field_25c =
			 globals::g_ToolTipsData_TABLE[toolTipType].field_25c + 1;
	return;
}



void __cdecl lego::front::ToolTip_FUN_0046b9c0(int toolTipType,undefined4 field274)
{
	uint uVar1;
	
	uVar1 = globals::g_ToolTipsData_TABLE[toolTipType].flags;
	globals::g_ToolTipsData_TABLE[toolTipType].field_274 = field274;
	globals::g_ToolTipsData_TABLE[toolTipType].flags = uVar1 | 3;
	return;
}



void __cdecl lego::front::ToolTip_SetFlag10(int toolTipType,BOOL state)
{
	if (state != 0) {
		globals::g_ToolTipsData_TABLE[toolTipType].flags =
				 globals::g_ToolTipsData_TABLE[toolTipType].flags | 0x10;
		return;
	}
	globals::g_ToolTipsData_TABLE[toolTipType].flags =
			 globals::g_ToolTipsData_TABLE[toolTipType].flags & 0xffffffef;
	return;
}



void __cdecl lego::front::ToolTip_AddFlag4(int toolTipType)
{
	globals::g_ToolTipsData_TABLE[toolTipType].flags =
			 globals::g_ToolTipsData_TABLE[toolTipType].flags | 4;
	return;
}



void __cdecl lego::front::ToolTip_FUN_0046ba60(int toolTipType)
{
	globals::g_ToolTipsData_TABLE[toolTipType].float_0 = FLOAT_0054cf3c;
	return;
}



void __cdecl lego::front::ToolTip_Update_FUN_0046ba80(uint mousex,uint mousey,float milliseconds)
{
	float *pfVar1;
	bool bVar2;
	BOOL BVar3;
	uint uVar4;
	bool bVar5;
	uint *puVar6;
	
	bVar5 = false;
	bVar2 = false;
	puVar6 = &globals::g_ToolTipsData_TABLE[1].flags;
	uVar4 = BOOL_004ab64c;
	do {
		if ((*puVar6 & 3) != 0) {
			if (((*puVar6 & 4) == 0) || (bVar2)) {
				puVar6[-0x9e] = 0;
			}
			else {
				pfVar1 = (float *)(puVar6 + -0x9e);
				if (((float)puVar6[-0x9e] < FLOAT_0054cf3c) || (bVar5)) {
					uVar4 = 1;
					BOOL_004ab64c = 1;
					bVar2 = true;
					*pfVar1 = milliseconds + *pfVar1;
				}
				else {
					if (((puVar6[-1] != SFX_NULL) && (uVar4 != 0)) &&
						 ((globals::g_Game.flags2 & GAME2_DISABLETOOLTIPSOUND) == GAME2_NONE)) {
						BVar3 = snd::Audio_FUN_004651b0(puVar6[-1],(int *)0x0);
						uVar4 = (uint)(BVar3 == 0);
						BOOL_004ab64c = uVar4;
					}
					if (puVar6 != (uint *)0x274) {
						FUN_0046bef0((int)pfVar1,mousex,mousey);
						uVar4 = BOOL_004ab64c;
					}
					bVar5 = true;
					bVar2 = true;
					*pfVar1 = milliseconds + *pfVar1;
				}
			}
			*puVar6 = *puVar6 & 0xfffffffb;
		}
		puVar6 = puVar6 + 0x9f;
	} while (puVar6 < &DAT_0055335c);
	return;
}



void __cdecl
FUN_0046bb70(float param_1,float param_2,float param_3,float param_4,float param_5,float param_6,
						float param_7,float param_8,float param_9,float param_10,float param_11,float param_12,
						float param_13,int param_14)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	Point2F *pPVar7;
	Point2F *pPVar8;
	float *pfVar9;
	float *pfVar10;
	uint count;
	Point2F *pPVar11;
	float *pfVar12;
	Point2F *local_168;
	float *local_164;
	uint local_160;
	uint local_15c;
	Point2F local_140;
	float local_138 [18];
	Point2F local_f0;
	float afStack232 [18];
	Point2F local_a0;
	float local_98 [18];
	Point2F local_50;
	float local_48 [18];
	
	count = 0;
	local_160 = 0;
	local_15c = 0;
	if (UINT_0054cf28 != 0) {
		local_168 = &local_f0;
		local_164 = &local_f0.y;
		pPVar8 = &local_50;
		pfVar12 = &local_50.y;
		pfVar10 = &local_140.y;
		pPVar11 = &local_140;
		pfVar9 = &local_a0.y;
		pPVar7 = &local_a0;
		do {
			fVar4 = (float)(ulonglong)local_15c;
			fVar2 = param_1 + fVar4;
			fVar3 = param_2 + fVar4;
			fVar6 = ((param_2 + param_4) - 1.0) - fVar4;
			fVar5 = ((param_1 + param_3) - 1.0) - fVar4;
			pPVar7->x = fVar2;
			*pfVar9 = fVar3;
			fVar1 = pPVar7->x;
			pPVar8->x = fVar2;
			*pfVar10 = ((param_2 + param_4) - 2.0) - fVar4;
			*pfVar12 = fVar6;
			pPVar7[1].x = fVar5;
			pPVar11->x = fVar1;
			local_168->x = ((param_1 + param_3) - 2.0) - fVar4;
			pfVar9[2] = fVar3;
			*local_164 = fVar6;
			pPVar8[1].x = fVar5;
			pPVar11[1].x = fVar2 - -1.0;
			pfVar12[2] = fVar6;
			fVar1 = pPVar8[1].x;
			pfVar10[2] = fVar3;
			pPVar7 = pPVar7 + 2;
			pfVar9 = pfVar9 + 4;
			pPVar11 = pPVar11 + 2;
			pfVar12 = pfVar12 + 4;
			local_164[2] = fVar3 - -1.0;
			pPVar8 = pPVar8 + 2;
			local_168[1].x = fVar1;
			count = local_160 + 2;
			local_168 = local_168 + 2;
			pfVar10 = pfVar10 + 4;
			local_164 = local_164 + 4;
			local_15c = local_15c + 1;
			local_160 = count;
		} while (local_15c < UINT_0054cf28);
	}
	if (param_14 == 0) {
		lego::draw::Draw_RectListEx((Rect2F *)&param_1,1,param_5,param_6,param_7,DrawEffect_None);
		lego::draw::Draw_LineListEx(&local_a0,&local_140,count,param_8,param_9,param_10,DrawEffect_None)
		;
		lego::draw::Draw_LineListEx
							(&local_50,&local_f0,count,param_11,param_12,param_13,DrawEffect_None);
		return;
	}
	lego::draw::Draw_RectListEx((Rect2F *)&param_1,1,param_5,param_6,param_7,DrawEffect_HalfTrans);
	lego::draw::Draw_LineListEx(&local_a0,&local_140,count,param_8,param_9,param_10,DrawEffect_None);
	lego::draw::Draw_LineListEx(&local_50,&local_f0,count,param_11,param_12,param_13,DrawEffect_None);
	return;
}



void __cdecl FUN_0046bef0(int param_1,uint param_2,uint param_3)
{
	uint uVar1;
	int iVar2;
	int iVar3;
	uint uVar4;
	ImageBMP **ppIVar5;
	uint uVar6;
	float10 extraout_ST0;
	float10 extraout_ST1;
	longlong lVar7;
	char *msg;
	Point2F local_44;
	uint local_3c;
	undefined4 uStack56;
	float local_34;
	float fStack48;
	float local_2c;
	float local_28;
	float fStack36;
	float local_20;
	float local_1c;
	float fStack24;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	local_34 = FLOAT_ARRAY_0054cf40[0];
	fStack48 = FLOAT_ARRAY_0054cf40[3];
	local_28 = FLOAT_ARRAY_0054cf40[1];
	fStack36 = FLOAT_ARRAY_0054cf40[4];
	local_2c = FLOAT_ARRAY_0054cf40[6];
	local_1c = FLOAT_ARRAY_0054cf40[2];
	fStack24 = FLOAT_ARRAY_0054cf40[5];
	local_20 = FLOAT_ARRAY_0054cf40[7];
	iVar3 = (INT_0054cf2c + UINT_0054cf28) * 2;
	local_14 = FLOAT_ARRAY_0054cf40[8];
	if ((*(uint *)(param_1 + 0x278) & 8) == 0) {
		uVar6 = *(uint *)(param_1 + 0x204);
		if (*(uint *)(param_1 + 0x204) <= *(uint *)(param_1 + 0x26c)) {
			uVar6 = *(uint *)(param_1 + 0x26c);
		}
		iVar2 = *(int *)(param_1 + 0x208) * DAT_0054cf24 + *(int *)(param_1 + 0x264);
	}
	else {
		uVar6 = *(uint *)(*(int *)(param_1 + 0x270) + 4);
		iVar2 = *(int *)(*(int *)(param_1 + 0x270) + 8);
	}
	uVar4 = iVar3 + iVar2;
	local_44.x = (float)(iVar3 + uVar6);
	if ((*(uint *)(param_1 + 0x278) & 0x10) == 0) {
		if ((uint)INT_0054cf30 < (int)local_44.x + param_2) {
			local_10 = (float)(ulonglong)(uint)(INT_0054cf30 - (int)local_44.x);
		}
		else {
			local_10 = (float)(ulonglong)param_2;
		}
	}
	else {
		local_10 = (float)(ulonglong)param_2 - -32.0;
		if ((ushort)((ushort)(local_10 < (float)(ulonglong)(uint)INT_0054cf30) << 8 |
								(ushort)(local_10 == (float)(ulonglong)(uint)INT_0054cf30) << 0xe) == 0) {
			local_10 = (float)(ulonglong)(uint)(INT_0054cf30 - (int)local_44.x);
		}
		else {
			local_10 = local_10 - (float)(ulonglong)(uint)local_44.x;
		}
	}
	local_c = (float)(ulonglong)(INT_0054cf38 + param_3);
	local_4 = (float)(ulonglong)uVar4;
	if ((float)(ulonglong)(uint)INT_0054cf34 < local_c + local_4) {
		local_c = (float)(ulonglong)(param_3 - uVar4) - 1.0;
	}
	local_44.y = 0.0;
	local_8 = (float)(ulonglong)(uint)local_44.x;
	FUN_0046bb70(local_10,local_c,local_8,local_4,FLOAT_ARRAY_0054cf40[0],FLOAT_ARRAY_0054cf40[3],
							 FLOAT_ARRAY_0054cf40[6],FLOAT_ARRAY_0054cf40[1],FLOAT_ARRAY_0054cf40[4],
							 FLOAT_ARRAY_0054cf40[7],FLOAT_ARRAY_0054cf40[2],FLOAT_ARRAY_0054cf40[5],
							 FLOAT_ARRAY_0054cf40[8],0);
	if ((*(byte *)(param_1 + 0x278) & 8) == 0) {
		param_2 = *(int *)(param_1 + 0x208) * DAT_0054cf24;
		local_3c = INT_0054cf2c;
		uStack56 = 0;
		iVar3 = param_1 + 4;
		uVar4 = 0;
		uVar6 = 0;
		msg = "%s";
		lVar7 = __ftol((float10)local_c + (float10)(ulonglong)(uint)INT_0054cf2c +
									 (float10)(ulonglong)UINT_0054cf28);
		iVar2 = (int)lVar7;
		lVar7 = __ftol((float10)local_10 + extraout_ST0 + extraout_ST1);
		lego::image::Font_PrintF((ImageFont *)FONT_0054cf20,(int)lVar7,iVar2,msg,iVar3);
		param_3 = 0;
		if (*(int *)(param_1 + 0x25c) != 0) {
			ppIVar5 = (ImageBMP **)(param_1 + 0x20c);
			do {
				if (*ppIVar5 == (ImageBMP *)0x0) {
					param_2 = param_2 + uVar6;
					uVar6 = 0;
					uVar4 = 0;
				}
				else {
					local_3c = UINT_0054cf28;
					uStack56 = 0;
					local_34 = (float)INT_0054cf2c;
					fStack48 = 0.0;
					fStack36 = 0.0;
					fStack24 = 0.0;
					local_1c = (float)param_2;
					local_44.x = (float)(ulonglong)uVar4 +
											 local_10 + (float)(ulonglong)(uint)INT_0054cf2c +
											 (float)(ulonglong)UINT_0054cf28;
					local_44.y = (float)(ulonglong)param_2 +
											 local_c + (float)(ulonglong)(uint)INT_0054cf2c +
											 (float)(ulonglong)UINT_0054cf28;
					local_28 = (float)uVar4;
					lego::image::Image_DisplayScaled(*ppIVar5,(Rect2F *)0x0,&local_44,(Size2F *)0x0);
					uVar1 = (*ppIVar5)->height;
					if ((int)uVar6 < (int)uVar1) {
						uVar6 = uVar1;
					}
					uVar4 = uVar4 + (*ppIVar5)->width;
				}
				param_3 = param_3 + 1;
				ppIVar5 = ppIVar5 + 1;
			} while (param_3 < *(uint *)(param_1 + 0x25c));
		}
		return;
	}
	local_3c = INT_0054cf2c;
	uStack56 = 0;
	local_44.x = local_10 + (float)(ulonglong)(uint)INT_0054cf2c + (float)(ulonglong)UINT_0054cf28;
	local_44.y = local_c + (float)(ulonglong)(uint)INT_0054cf2c + (float)(ulonglong)UINT_0054cf28;
	lego::image::Image_DisplayScaled
						(*(ImageBMP **)(param_1 + 0x270),(Rect2F *)0x0,&local_44,(Size2F *)0x0);
	return;
}



void __cdecl
lego::res::UnkUpgrade_Init_FUN_0046c2f0
					(UpgradeData *out_upgrade,int index,Container *resRoot,char *filename)
{
	Container *pCVar1;
	
	out_upgrade->objectIndex = 0;
	out_upgrade->aeResData = (Container *)0x0;
	out_upgrade->object_8 = (LiveObject *)0x0;
	out_upgrade->field_c = 0;
	pCVar1 = Container_Load(resRoot,filename,"LWO",1);
	out_upgrade->aeResData = pCVar1;
	if (pCVar1 == (Container *)0x0) {
		pCVar1 = Container_Load(resRoot,filename,"ACT",1);
		out_upgrade->aeResData = pCVar1;
	}
	if (out_upgrade->aeResData == (Container *)0x0) {
		pCVar1 = Container_Load(resRoot,filename,"MESH",1);
		out_upgrade->aeResData = pCVar1;
	}
	out_upgrade->object_8 = (LiveObject *)0x0;
	out_upgrade->objectIndex = index;
	return;
}



void __cdecl lego::res::Upgrade_Duplicate(UpgradeData *in_upgrade,UpgradeData *out_upgrade)
{
	Container *pCVar1;
	
	out_upgrade->objectIndex = in_upgrade->objectIndex;
	out_upgrade->aeResData = in_upgrade->aeResData;
	out_upgrade->object_8 = in_upgrade->object_8;
	out_upgrade->field_c = in_upgrade->field_c;
	pCVar1 = Container_Clone(in_upgrade->aeResData);
	out_upgrade->aeResData = pCVar1;
	return;
}



void __cdecl lego::res::Upgrade_Destroy(UpgradeData *upgrade)
{
	Container_Remove(upgrade->aeResData);
	return;
}



float10 __cdecl
lego::res::Upgrade_DoAnimElapsedCallbacks(UpgradeData *upgrade,float elapsed,BOOL unused_bool)
{
	Container_MoveAnimation(upgrade->aeResData,elapsed);
	return (float10)0.0;
}



BOOL __cdecl lego::res::Upgrade_FUN_0046c3f0(UpgradeData *upgrade,char *activityName)
{
	BOOL BVar1;
	
	BVar1 = Container_SetActivity(upgrade->aeResData,activityName);
	if (BVar1 == 0) {
		BVar1 = Container_SetActivity(upgrade->aeResData,globals::g_Activities_TABLE[0]);
	}
	return BVar1;
}



void __cdecl
lego::res::Res_LoadUpgradeLevels(ObjectUpgradesData *upgrades,CFGProperty *aeRoot,char *rootName)
{
	char cVar1;
	ObjectUpgradePartData *pOVar2;
	char *pcVar3;
	CFGProperty *prop;
	undefined4 *puVar4;
	UpgradeData *pUVar5;
	int iVar6;
	uint uVar7;
	uint uVar8;
	undefined4 *puVar9;
	char *pcVar10;
	uint local_12c;
	char *local_128;
	char *local_124;
	char *local_120;
	char local_100 [256];
	
	upgrades->count = 0;
	pOVar2 = (ObjectUpgradePartData *)std::malloc(4000);
	upgrades->parts = pOVar2;
	for (iVar6 = 1000; iVar6 != 0; iVar6 = iVar6 + -1) {
		pOVar2->level = 0;
		pOVar2 = (ObjectUpgradePartData *)&pOVar2->NullInstance;
	}
	local_12c = 0;
	do {
		std::sprintf(local_100,"Level%i%i%i%i",local_12c >> 3 & 1,local_12c >> 2 & 1,local_12c >> 1 & 1,
								 local_12c & 1);
		pcVar3 = cfg::CFG_JoinPath(rootName,"Upgrades",local_100,0);
		prop = cfg::CFG_GetChildren(aeRoot,pcVar3);
		if (prop != (CFGProperty *)0x0) {
			upgrades->levelsMask = upgrades->levelsMask | local_12c;
			for (; prop != (CFGProperty *)0x0; prop = cfg::CFG_NextFlat(prop)) {
				uVar7 = 0xffffffff;
				pOVar2 = upgrades->parts + upgrades->count;
				pcVar3 = prop->value;
				do {
					pcVar10 = pcVar3;
					if (uVar7 == 0) break;
					uVar7 = uVar7 - 1;
					pcVar10 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar10;
				} while (cVar1 != '\0');
				uVar7 = ~uVar7;
				puVar4 = (undefined4 *)(pcVar10 + -uVar7);
				puVar9 = (undefined4 *)local_100;
				for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {
					*puVar9 = *puVar4;
					puVar4 = puVar4 + 1;
					puVar9 = puVar9 + 1;
				}
				for (uVar7 = uVar7 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {
					*(undefined *)puVar9 = *(undefined *)puVar4;
					puVar4 = (undefined4 *)((int)puVar4 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				iVar6 = util::Util_Tokenise(local_100,&local_128,",");
				if (iVar6 == 3) {
					uVar7 = 0xffffffff;
					pcVar3 = local_120;
					do {
						if (uVar7 == 0) break;
						uVar7 = uVar7 - 1;
						cVar1 = *pcVar3;
						pcVar3 = pcVar3 + 1;
					} while (cVar1 != '\0');
					puVar4 = (undefined4 *)std::malloc(~uVar7);
					uVar7 = 0xffffffff;
					pOVar2->WeaponName = (char *)puVar4;
					pcVar3 = local_120;
					do {
						pcVar10 = pcVar3;
						if (uVar7 == 0) break;
						uVar7 = uVar7 - 1;
						pcVar10 = pcVar3 + 1;
						cVar1 = *pcVar3;
						pcVar3 = pcVar10;
					} while (cVar1 != '\0');
					uVar7 = ~uVar7;
					puVar9 = (undefined4 *)(pcVar10 + -uVar7);
					for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {
						*puVar4 = *puVar9;
						puVar9 = puVar9 + 1;
						puVar4 = puVar4 + 1;
					}
					for (uVar7 = uVar7 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {
						*(undefined *)puVar4 = *(undefined *)puVar9;
						puVar9 = (undefined4 *)((int)puVar9 + 1);
						puVar4 = (undefined4 *)((int)puVar4 + 1);
					}
				}
				pcVar3 = std::_strdup(local_128);
				pOVar2->NullObjectName = pcVar3;
				pOVar2->level = local_12c;
				iVar6 = std::atoi(local_124);
				pOVar2->NullInstance = iVar6 + -1;
				pUVar5 = game::Game_GetUpgradeData(prop->key);
				pOVar2->upgradeData = pUVar5;
				upgrades->count = upgrades->count + 1;
			}
		}
		local_12c = local_12c + 1;
		if (0xf < local_12c) {
			if (upgrades->count == 0) {
				std::free(upgrades->parts);
				upgrades->parts = (ObjectUpgradePartData *)0x0;
			}
			return;
		}
	} while( true );
}



void __cdecl lego::res::ObjectUpgrade_ChangeUpgradeParts(ObjectUpgradesData *upgrades,int objLevel)
{
	LiveObject *pLVar1;
	LiveObject *pLVar2;
	UpgradeData *pUVar3;
	int iVar4;
	uint objIndex;
	
	iVar4 = 0;
	pLVar2 = (LiveObject *)upgrades->upgradeObjs;
	pUVar3 = (UpgradeData *)objLevel;
	while (pLVar2 != (LiveObject *)0x0) {
		pUVar3 = pLVar2->upgrade;
		pLVar1 = pUVar3->object_8;
		pool::ReservedPool_LiveObject___Release(pLVar2);
		pLVar2 = pLVar1;
	}
	objIndex = 0;
	upgrades->currentLevel = objLevel;
	upgrades->upgradeObjs = (LiveObject **)0x0;
	if (upgrades->count != 0) {
		do {
			if (*(int *)((int)&upgrades->parts->level + iVar4) == objLevel) {
				pLVar2 = game::LiveObject__Create
													 (*(int ***)((int)&upgrades->parts->upgradeData + iVar4),
														OBJECT_UPGRADEPART,objIndex);
				if (upgrades->upgradeObjs == (LiveObject **)0x0) {
					upgrades->upgradeObjs = (LiveObject **)pLVar2;
				}
				else {
					pUVar3->object_8 = pLVar2;
				}
				pUVar3 = pLVar2->upgrade;
				pUVar3->field_c = (int)&upgrades->parts->level + iVar4;
			}
			objIndex = objIndex + 1;
			iVar4 = iVar4 + 0x14;
		} while (objIndex < upgrades->count);
	}
	return;
}



BOOL __cdecl lego::res::Vehicle_IsCameraFlipDir(VehicleData *vehicle)
{
	return (uint)(vehicle->CameraFlipDir == BOOL3_TRUE);
}



BOOL __cdecl lego::res::Vehicle_FUN_0046c6b0(VehicleData *vehicle,char *activityName,float elapsed)
{
	uint uVar1;
	uint uVar2;
	BOOL BVar3;
	undefined4 *puVar4;
	
	PolyMesh_FUN_00451ef0(vehicle->subdata_1e0);
	uVar1 = 0;
	vehicle->field_cc = 0;
	vehicle->field_d0 = 0;
	vehicle->resData_d4 = (Container *)0x0;
	if (vehicle->CameraNullFrames != 0) {
		puVar4 = vehicle->cameraFramesTable_10c;
		do {
			*puVar4 = 0;
			uVar1 = uVar1 + 1;
			puVar4 = puVar4 + 1;
		} while (uVar1 < vehicle->CameraNullFrames);
	}
	uVar1 = 0;
	if (vehicle->CarryNullFrames != 0) {
		puVar4 = vehicle->carryFramesTable_e4;
		do {
			*puVar4 = 0;
			uVar1 = uVar1 + 1;
			puVar4 = puVar4 + 1;
		} while (uVar1 < vehicle->CarryNullFrames);
	}
	uVar2 = Container_SetActivity(vehicle->aeResData1,activityName);
	uVar1 = vehicle->flags;
	vehicle->flags = uVar1 & 0xfffffffb;
	if ((uVar2 == 0) && ((uVar1 & 8) != 0)) {
		BVar3 = Container_IsCurrentActivity(vehicle->aeResData1,activityName);
		if (BVar3 == 0) {
			vehicle->flags = vehicle->flags | 4;
		}
	}
	if (vehicle->aeResData2 != (Container *)0x0) {
		uVar1 = Container_SetActivity(vehicle->aeResData2,activityName);
		uVar2 = uVar2 | uVar1;
	}
	if ((*(byte *)&vehicle->flags & 4) == 0) {
		Container_SetAnimationTime(vehicle->aeResData1,elapsed);
	}
	if (vehicle->aeResData2 != (Container *)0x0) {
		Container_SetAnimationTime(vehicle->aeResData2,elapsed);
	}
	Vehicle_Wheels_FUN_0046d520(vehicle);
	Vehicle_UnkUpgrades(vehicle,activityName);
	return uVar2;
}



void __cdecl lego::res::Vehicle_UnkUpgrades(VehicleData *vehicle,char *param_2)
{
	int *opt_instance;
	LiveObject *pLVar1;
	int iVar2;
	VehicleData *vehicle_00;
	undefined4 *puVar3;
	Container *pCVar4;
	Container *in_child;
	char *pcVar5;
	undefined4 *puVar6;
	int iVar7;
	UpgradeData *upgrade;
	uint local_14;
	int local_10;
	int local_c;
	int local_8;
	UpgradeData *local_4;
	
	vehicle_00 = vehicle;
	iVar7 = 3;
	pLVar1 = (LiveObject *)(vehicle->upgrades).upgradeObjs;
	puVar3 = (undefined4 *)&vehicle->field_0x15c;
	puVar6 = (undefined4 *)&vehicle->field_0x138;
	do {
		puVar3[0x1a] = 0;
		*puVar3 = 0;
		puVar3[-3] = 0;
		*puVar6 = 0;
		puVar3 = puVar3 + 1;
		iVar7 = iVar7 + -1;
		puVar6[1] = 0;
		puVar6 = puVar6 + 2;
	} while (iVar7 != 0);
	vehicle->field_1dc = 0;
	do {
		if (pLVar1 == (LiveObject *)0x0) {
			return;
		}
		upgrade = pLVar1->upgrade;
		iVar7 = upgrade->field_c;
		local_8 = iVar7;
		local_4 = upgrade;
		pCVar4 = Vehicle_GetNull(vehicle_00,*(undefined4 *)(iVar7 + 8),*(undefined4 *)(iVar7 + 4));
		in_child = Object_GetAEResource((BasicObjectData *)upgrade);
		Container_SetParent(in_child,pCVar4);
		Container_ClearTransform(in_child);
		if (param_2 == (char *)0x0) {
			Container_SetActivity(upgrade->aeResData,globals::g_Activities_TABLE[0]);
		}
		else {
			Upgrade_FUN_0046c3f0(upgrade,param_2);
		}
		if (*(int *)(iVar7 + 0xc) != 0) {
			iVar7 = vehicle_00->field_1dc;
			local_10 = 0;
			vehicle_00->table6_1c4[iVar7 + -0x15] = 0;
			local_14 = 0;
			opt_instance = vehicle_00->table6_1c4 + iVar7 + -0x15;
			vehicle = (VehicleData *)(vehicle_00->cameraFramesTable_10c + iVar7 * 2 + 0xb);
			local_c = iVar7;
			do {
				vehicle->objIndex = 0;
				pcVar5 = Container_FormatPartName
													 (vehicle_00->aeResData1,vehicle_00->FireNullName,opt_instance);
				pCVar4 = Container_SearchTree
													 (in_child,pcVar5,CONTAINER_SEARCHMODE_FIRSTMATCH,(undefined4 *)0x0);
				vehicle_00->cameraFramesTable_10c[*opt_instance + iVar7 * 2 + 0xb] = pCVar4;
				iVar2 = vehicle_00->cameraFramesTable_10c[iVar7 * 2 + *opt_instance + 0xb];
				*opt_instance = *opt_instance + 1;
				if (iVar2 == 0) break;
				local_14 = local_14 + 1;
				vehicle = (VehicleData *)&vehicle->WheelNullName;
			} while (local_14 < 2);
			pcVar5 = Container_FormatPartName(vehicle_00->aeResData1,vehicle_00->xPivot,&local_10);
			pCVar4 = Container_SearchTree
												 (in_child,pcVar5,CONTAINER_SEARCHMODE_FIRSTMATCH,(undefined4 *)0x0);
			iVar7 = local_c;
			vehicle_00->cameraFramesTable_10c[local_c + 0x11] = pCVar4;
			pcVar5 = Container_FormatPartName(vehicle_00->aeResData1,vehicle_00->yPivot,&local_10);
			pCVar4 = Container_SearchTree
												 (in_child,pcVar5,CONTAINER_SEARCHMODE_FIRSTMATCH,(undefined4 *)0x0);
			vehicle_00->cameraFramesTable_10c[iVar7 + 0x14] = pCVar4;
			vehicle_00->table6_1c4[iVar7] = local_8;
			vehicle_00->field_1dc = vehicle_00->field_1dc + 1;
			upgrade = local_4;
		}
		pLVar1 = upgrade->object_8;
	} while( true );
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

BOOL __cdecl
lego::res::Res_LoadAEFileVehicle
					(VehicleData *vehicle,int index,Container *resRoot,char *aeFilename,char *rootName)
{
	char cVar1;
	int iVar2;
	Container *pCVar3;
	CFGProperty *prop;
	char *pcVar4;
	BOOL3 BVar5;
	PolyMeshData *pPVar6;
	CFGProperty *aeRoot;
	int iVar7;
	uint uVar8;
	uint uVar9;
	int *piVar10;
	undefined4 *puVar11;
	VehicleData *pVVar12;
	Container **ppCVar13;
	char *pcVar14;
	undefined4 *puVar15;
	float10 fVar16;
	char *pcStack4560;
	char *pcStack4556;
	D3DRMBox DStack4520;
	char *pcStack4496;
	int aiStack4492 [99];
	undefined4 auStack4096 [256];
	char acStack3072 [1024];
	undefined4 local_800 [256];
	char local_400 [1020];
	undefined4 uStack4;
	
	uStack4 = 0x46c9ba;
	pVVar12 = vehicle;
	for (iVar7 = 0x7b; iVar7 != 0; iVar7 = iVar7 + -1) {
		pVVar12->objIndex = 0;
		pVVar12 = (VehicleData *)&pVVar12->WheelNullName;
	}
	uVar8 = 0xffffffff;
	do {
		pcVar4 = aeFilename;
		if (uVar8 == 0) break;
		uVar8 = uVar8 - 1;
		pcVar4 = aeFilename + 1;
		cVar1 = *aeFilename;
		aeFilename = pcVar4;
	} while (cVar1 != '\0');
	uVar8 = ~uVar8;
	puVar11 = (undefined4 *)(pcVar4 + -uVar8);
	puVar15 = local_800;
	for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
		*puVar15 = *puVar11;
		puVar11 = puVar11 + 1;
		puVar15 = puVar15 + 1;
	}
	for (uVar8 = uVar8 & 3; uVar8 != 0; uVar8 = uVar8 - 1) {
		*(undefined *)puVar15 = *(undefined *)puVar11;
		puVar11 = (undefined4 *)((int)puVar11 + 1);
		puVar15 = (undefined4 *)((int)puVar15 + 1);
	}
	iVar7 = util::Util_Tokenise((char *)local_800,&pcStack4560,",");
	pCVar3 = Container_Load(resRoot,pcStack4560,"ACT",1);
	vehicle->aeResData1 = pCVar3;
	if (pCVar3 != (Container *)0x0) {
		if (iVar7 == 2) {
			pCVar3 = Container_Load(pCVar3,pcStack4556,"ACT",1);
			vehicle->aeResData2 = pCVar3;
		}
		else {
			vehicle->aeResData2 = (Container *)0x0;
		}
		uVar8 = 0xffffffff;
		pcVar4 = pcStack4560;
		do {
			pcVar14 = pcVar4;
			if (uVar8 == 0) break;
			uVar8 = uVar8 - 1;
			pcVar14 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar14;
		} while (cVar1 != '\0');
		uVar8 = ~uVar8;
		puVar11 = (undefined4 *)(pcVar14 + -uVar8);
		puVar15 = auStack4096;
		for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
			*puVar15 = *puVar11;
			puVar11 = puVar11 + 1;
			puVar15 = puVar15 + 1;
		}
		for (uVar8 = uVar8 & 3; uVar8 != 0; uVar8 = uVar8 - 1) {
			*(undefined *)puVar15 = *(undefined *)puVar11;
			puVar11 = (undefined4 *)((int)puVar11 + 1);
			puVar15 = (undefined4 *)((int)puVar15 + 1);
		}
		uVar8 = util::Util_Tokenise((char *)auStack4096,&pcStack4496,"\\");
		if (1 < uVar8) {
			piVar10 = aiStack4492;
			iVar7 = uVar8 - 1;
			do {
				iVar2 = *piVar10;
				piVar10 = piVar10 + 1;
				iVar7 = iVar7 + -1;
				*(undefined *)(iVar2 + -1) = '\\';
			} while (iVar7 != 0);
		}
		std::sprintf(acStack3072,"%s\\%s.%s",auStack4096,(&DStack4520.max.z)[uVar8],"ae");
		prop = cfg::CFG_Open(acStack3072);
		if (prop != (CFGProperty *)0x0) {
			pcVar4 = cfg::CFG_JoinPath(rootName,"CameraNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->CameraNullName = pcVar4;
			if (pcVar4 == (char *)0x0) {
				vehicle->CameraNullFrames = 0;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 == (char *)0x0) {
					pcVar4 = ____EMPTYSTR__;
				}
				else {
					pcVar4 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
					pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				}
				uVar8 = std::atoi(pcVar4);
				vehicle->CameraNullFrames = uVar8;
				pcVar4 = cfg::CFG_JoinPath(rootName,"CameraFlipDir",0);
				BVar5 = cfg::CFG_ReadBool(prop,pcVar4);
				vehicle->CameraFlipDir = BVar5;
			}
			pcVar4 = cfg::CFG_JoinPath(rootName,"CarryNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->CarryNullName = pcVar4;
			if (pcVar4 == (char *)0x0) {
				vehicle->CarryNullFrames = 0;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"CarryNullFrames",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 == (char *)0x0) {
					uVar8 = std::atoi(____EMPTYSTR__);
					vehicle->CarryNullFrames = uVar8;
				}
				else {
					pcVar4 = cfg::CFG_JoinPath(rootName,"CarryNullFrames",0);
					pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
					uVar8 = std::atoi(pcVar4);
					vehicle->CarryNullFrames = uVar8;
				}
			}
			pcVar4 = cfg::CFG_JoinPath(rootName,"DrillNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->DrillNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"DepositNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->DepositNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"DriverNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->DriverNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"FireNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->FireNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"yPivot",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->yPivot = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"xPivot",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->xPivot = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
			pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
			if (pcVar4 == (char *)0x0) {
				vehicle->PivotMaxZ = 1.0;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 == (char *)0x0) {
					fVar16 = std::atof(____EMPTYSTR__);
					vehicle->PivotMaxZ = (float)fVar16;
				}
				else {
					pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
					pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
					fVar16 = std::atof(pcVar4);
					vehicle->PivotMaxZ = (float)fVar16;
				}
			}
			pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
			pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
			if (pcVar4 == (char *)0x0) {
				vehicle->PivotMinZ = -1.0;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 == (char *)0x0) {
					fVar16 = std::atof(____EMPTYSTR__);
					vehicle->PivotMinZ = (float)fVar16;
				}
				else {
					pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
					pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
					fVar16 = std::atof(pcVar4);
					vehicle->PivotMinZ = (float)fVar16;
				}
			}
			Res_LoadUpgradeLevels(&vehicle->upgrades,prop,rootName);
			pcVar4 = cfg::CFG_JoinPath(rootName,"WheelMesh",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			if (pcVar4 != (char *)0x0) {
				std::sprintf(local_400,"%s\\%s",auStack4096,pcVar4);
				std::free(pcVar4);
				pcVar4 = cfg::CFG_JoinPath(rootName,"WheelNullName",0);
				pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
				vehicle->WheelNullName = pcVar4;
				if (pcVar4 != (char *)0x0) {
					ppCVar13 = vehicle->WheelMeshes;
					for (iVar7 = 6; iVar7 != 0; iVar7 = iVar7 + -1) {
						*ppCVar13 = (Container *)0x0;
						ppCVar13 = ppCVar13 + 1;
					}
					pCVar3 = Container_Load(vehicle->aeResData1,local_400,"LWO",0);
					vehicle->WheelMeshes[0] = pCVar3;
					vehicle->numWheelNulls = 1;
					puVar11 = vehicle->wheel_fields_28;
					for (iVar7 = 6; iVar7 != 0; iVar7 = iVar7 + -1) {
						*puVar11 = 0;
						puVar11 = puVar11 + 1;
					}
					if (vehicle->WheelMeshes[0] == (Container *)0x0) {
						vehicle->WheelRadius = 0.0;
						vehicle->WheelMeshes[1] = (Container *)0x0;
						vehicle->WheelMeshes[2] = (Container *)0x0;
						vehicle->WheelMeshes[3] = (Container *)0x0;
						vehicle->WheelMeshes[4] = (Container *)0x0;
						vehicle->WheelMeshes[5] = (Container *)0x0;
					}
					else {
						pcVar4 = cfg::CFG_JoinPath(rootName,"WheelRadius",0);
						pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
						if (pcVar4 == (char *)0x0) {
							pcVar4 = ____EMPTYSTR__;
						}
						else {
							pcVar4 = cfg::CFG_JoinPath(rootName,"WheelRadius",0);
							pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
						}
						fVar16 = std::atof(pcVar4);
						vehicle->WheelRadius = (float)fVar16;
						if ((float)fVar16 == 0.0) {
							if (vehicle->WheelMeshes[0]->type == RESOURCE_MESH) {
								Container_Mesh_GetBox(vehicle->WheelMeshes[0],&DStack4520);
								vehicle->WheelRadius = (DStack4520.max.y - DStack4520.min.y) * 0.5;
								Container_Mesh_SetQuality(vehicle->WheelMeshes[0],D3DRMGROUP_0,QUALITY_GOURAUD);
							}
							else {
								vehicle->WheelRadius = 3.0;
							}
						}
					}
					pPVar6 = Res_LoadPolyMesh(prop,rootName,pcStack4560,POLY_MEDIUM,1);
					vehicle->subdata_1e0 = pPVar6;
					if (vehicle->aeResData2 != (Container *)0x0) {
						uVar8 = 0xffffffff;
						pcVar4 = pcStack4556;
						do {
							pcVar14 = pcVar4;
							if (uVar8 == 0) break;
							uVar8 = uVar8 - 1;
							pcVar14 = pcVar4 + 1;
							cVar1 = *pcVar4;
							pcVar4 = pcVar14;
						} while (cVar1 != '\0');
						uVar8 = ~uVar8;
						puVar11 = (undefined4 *)(pcVar14 + -uVar8);
						puVar15 = auStack4096;
						for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
							*puVar15 = *puVar11;
							puVar11 = puVar11 + 1;
							puVar15 = puVar15 + 1;
						}
						for (uVar8 = uVar8 & 3; uVar8 != 0; uVar8 = uVar8 - 1) {
							*(undefined *)puVar15 = *(undefined *)puVar11;
							puVar11 = (undefined4 *)((int)puVar11 + 1);
							puVar15 = (undefined4 *)((int)puVar15 + 1);
						}
						uVar8 = util::Util_Tokenise((char *)auStack4096,&pcStack4496,"\\");
						if (1 < uVar8) {
							piVar10 = aiStack4492;
							iVar7 = uVar8 - 1;
							do {
								iVar2 = *piVar10;
								piVar10 = piVar10 + 1;
								iVar7 = iVar7 + -1;
								*(undefined *)(iVar2 + -1) = '\\';
							} while (iVar7 != 0);
						}
						std::sprintf(acStack3072,"%s\\%s.%s",auStack4096,(&DStack4520.max.z)[uVar8],"ae");
						aeRoot = cfg::CFG_Open(acStack3072);
						if (aeRoot != (CFGProperty *)0x0) {
							pPVar6 = Res_LoadPolyMesh(aeRoot,rootName,pcStack4556,POLY_MEDIUM,1);
							vehicle->subdata_1e4 = pPVar6;
						}
					}
					vehicle->flags = 1;
					pcVar4 = cfg::CFG_JoinPath(rootName,"HoldMissing",0);
					BVar5 = cfg::CFG_ReadBool(prop,pcVar4);
					if (BVar5 == BOOL3_TRUE) {
						vehicle->flags = vehicle->flags | 8;
					}
					vehicle->field_60 = 0;
					vehicle->field_5c = 0;
					vehicle->float_64 = -1.0;
					vehicle->objIndex = index;
					cfg::CFG_Close(prop);
					return 1;
				}
			}
			cfg::CFG_Close(prop);
		}
	}
	return 0;
}



void __cdecl lego::res::Vehicle_Destroy(VehicleData *vehicle)
{
	int iVar1;
	Container **ppCVar2;
	
	Vehicle_ChangeUpgradeParts(vehicle,-1);
	if ((*(byte *)&vehicle->flags & 1) != 0) {
		if (vehicle->CameraNullName != (char *)0x0) {
			std::free(vehicle->CameraNullName);
		}
		if (vehicle->WheelNullName != (char *)0x0) {
			std::free(vehicle->WheelNullName);
		}
		if (vehicle->DrillNullName != (char *)0x0) {
			std::free(vehicle->DrillNullName);
		}
		if (vehicle->FireNullName != (char *)0x0) {
			std::free(vehicle->FireNullName);
		}
	}
	ppCVar2 = (Container **)vehicle->wheel_fields_28;
	iVar1 = 6;
	do {
		if (ppCVar2[-6] != (Container *)0x0) {
			Container_Remove(ppCVar2[-6]);
		}
		if (*ppCVar2 != (Container *)0x0) {
			Container_Remove(*ppCVar2);
		}
		ppCVar2 = ppCVar2 + 1;
		iVar1 = iVar1 + -1;
	} while (iVar1 != 0);
	Container_Remove(vehicle->aeResData1);
	if (vehicle->aeResData2 != (Container *)0x0) {
		Container_Remove(vehicle->aeResData2);
	}
	return;
}



void __cdecl lego::res::Vehicle_FUN_0046d190(VehicleData *vehicle,BOOL notCondition)
{
	PolyMesh_FUN_00451e80(vehicle->subdata_1e0,vehicle->aeResData1,(uint)(notCondition == 0),FALSE);
	if ((vehicle->aeResData2 != (Container *)0x0) && (vehicle->subdata_1e4 != (PolyMeshData *)0x0)) {
		PolyMesh_FUN_00451e80(vehicle->subdata_1e4,vehicle->aeResData2,(uint)(notCondition == 0),FALSE);
	}
	return;
}



void __cdecl lego::res::Vehicle_FUN_0046d1e0(VehicleData *vehicle,BOOL param_2)
{
	Vehicle_FUN_0046d190(vehicle,param_2);
	return;
}



BOOL __cdecl lego::res::Vehicle_FUN_0046d200(VehicleData *vehicle,int levelBit,BOOL condition)
{
	uint uVar1;
	uint uVar2;
	
	uVar2 = 1 << ((byte)levelBit & 0x1f);
	if (condition != 0) {
		uVar1 = game::LiveObject_GetVehicle_UpgradesField8(vehicle);
		if ((uVar2 & uVar1) != 0) {
			return 0;
		}
	}
	return (vehicle->upgrades).levelsMask & uVar2;
}



int __cdecl lego::game::LiveObject_GetVehicle_UpgradesField8(VehicleData *vehicle)
{
	return (vehicle->upgrades).currentLevel;
}



void __cdecl lego::res::Vehicle_ChangeUpgradeParts(VehicleData *vehicle,int objLevel)
{
	ObjectUpgrade_ChangeUpgradeParts(&vehicle->upgrades,objLevel);
	Vehicle_UnkUpgrades(vehicle,(char *)0x0);
	return;
}



void __cdecl lego::res::Vehicle_FUN_0046d280(VehicleData *vehicle,BOOL param_2)
{
	Container **ppCVar1;
	int iVar2;
	
	ppCVar1 = vehicle->WheelMeshes;
	iVar2 = 6;
	do {
		if (*ppCVar1 != (Container *)0x0) {
			Container_Hide(*ppCVar1,param_2);
		}
		ppCVar1 = ppCVar1 + 1;
		iVar2 = iVar2 + -1;
	} while (iVar2 != 0);
	return;
}



BOOL __cdecl lego::res::Vehicle_Duplicate(VehicleData *in_vehicle,VehicleData *out_vehicle)
{
	Container *pCVar1;
	PolyMeshData *pPVar2;
	int iVar3;
	VehicleData *pVVar4;
	Container **ppCVar5;
	VehicleData *pVVar6;
	uint uVar7;
	
	pVVar4 = in_vehicle;
	pVVar6 = out_vehicle;
	for (iVar3 = 0x7b; iVar3 != 0; iVar3 = iVar3 + -1) {
		pVVar6->objIndex = pVVar4->objIndex;
		pVVar4 = (VehicleData *)&pVVar4->WheelNullName;
		pVVar6 = (VehicleData *)&pVVar6->WheelNullName;
	}
	out_vehicle->flags = out_vehicle->flags & 0xfffffffe;
	pCVar1 = Container_Clone(in_vehicle->aeResData1);
	out_vehicle->aeResData1 = pCVar1;
	if (pCVar1 != (Container *)0x0) {
		if (in_vehicle->aeResData2 != (Container *)0x0) {
			pCVar1 = Container_Clone(in_vehicle->aeResData2);
			out_vehicle->aeResData2 = pCVar1;
			Container_SetParent(pCVar1,out_vehicle->aeResData1);
			Container_SetPosition(out_vehicle->aeResData2,out_vehicle->aeResData1,0.0,0.0,0.0);
			Container_SetOrientation
								(out_vehicle->aeResData2,out_vehicle->aeResData1,0.0,0.0,1.0,0.0,1.0,0.0);
			Container_SetPerspectiveCorrection(out_vehicle->aeResData2,1);
		}
		pPVar2 = PolyMesh_Duplicate(in_vehicle->subdata_1e0);
		out_vehicle->subdata_1e0 = pPVar2;
		if (in_vehicle->subdata_1e4 != (PolyMeshData *)0x0) {
			pPVar2 = PolyMesh_Duplicate(in_vehicle->subdata_1e4);
			out_vehicle->subdata_1e4 = pPVar2;
		}
		Container_SetPerspectiveCorrection(out_vehicle->aeResData1,1);
		Vehicle_Wheels_FUN_0046d520(out_vehicle);
		if ((in_vehicle->WheelMeshes[0] != (Container *)0x0) &&
			 (uVar7 = 0, out_vehicle->numWheelNulls != 0)) {
			ppCVar5 = out_vehicle->WheelMeshes;
			do {
				pCVar1 = Container_Clone(in_vehicle->WheelMeshes[0]);
				*ppCVar5 = pCVar1;
				if (pCVar1 != (Container *)0x0) {
					Container_SetParent(pCVar1,out_vehicle->aeResData1);
					Container_SetPerspectiveCorrection(*ppCVar5,1);
				}
				uVar7 = uVar7 + 1;
				ppCVar5 = ppCVar5 + 1;
			} while (uVar7 < out_vehicle->numWheelNulls);
		}
		return 1;
	}
	return 0;
}



void __cdecl lego::res::Vehicle_SetOwnerObject(VehicleData *vehicle,void *liveObj)
{
	Container **ppCVar1;
	uint uVar2;
	
	Container_SetUserData(vehicle->aeResData1,liveObj);
	if (vehicle->aeResData2 != (Container *)0x0) {
		Container_SetUserData(vehicle->aeResData2,liveObj);
	}
	uVar2 = 0;
	if (vehicle->numWheelNulls != 0) {
		ppCVar1 = vehicle->WheelMeshes;
		do {
			if (*ppCVar1 != (Container *)0x0) {
				Container_SetUserData(*ppCVar1,liveObj);
			}
			uVar2 = uVar2 + 1;
			ppCVar1 = ppCVar1 + 1;
		} while (uVar2 < vehicle->numWheelNulls);
	}
	return;
}



float10 __cdecl lego::res::Vehicle_GetAnimFloat10(VehicleData *vehicle)
{
	float10 fVar1;
	
	fVar1 = Container_GetAnimationTime(vehicle->aeResData1);
	return fVar1;
}



float10 __cdecl
lego::res::Vehicle_FUN_0046d480(VehicleData *vehicle,float elapsed,float elapsed2,uint param_4)
{
	float fVar1;
	uint uVar2;
	float10 fVar3;
	
	if ((*(byte *)&vehicle->flags & 4) == 0) {
		fVar3 = Container_MoveAnimation(vehicle->aeResData1,elapsed);
	}
	else {
		fVar3 = (float10)0.0;
	}
	if (vehicle->aeResData2 != (Container *)0x0) {
		fVar3 = Container_MoveAnimation(vehicle->aeResData2,elapsed2);
	}
	fVar1 = (float)fVar3;
	if ((1 < param_4) && (fVar1 != 0.0)) {
		uVar2 = Container_GetAnimationFrames(vehicle->aeResData1);
		return (float10)fVar1 - (float10)(ulonglong)(uVar2 * (param_4 - 1));
	}
	return (float10)fVar1;
}



void __cdecl lego::res::Vehicle_Wheels_FUN_0046d520(VehicleData *vehicle)
{
	VehicleData *pVVar1;
	char *name;
	Container *pCVar2;
	
	pVVar1 = vehicle;
	vehicle = (VehicleData *)0x0;
	pVVar1->numWheelNulls = 0;
	do {
		name = Container_FormatPartName(pVVar1->aeResData1,pVVar1->WheelNullName,(int *)&vehicle);
		pCVar2 = Container_SearchTree
											 (pVVar1->aeResData1,name,CONTAINER_SEARCHMODE_FIRSTMATCH,(undefined4 *)0x0);
		pVVar1->wheel_fields_28[(int)vehicle] = pCVar2;
		if (pVVar1->wheel_fields_28[(int)vehicle] != 0) {
			pVVar1->numWheelNulls = pVVar1->numWheelNulls + 1;
		}
		vehicle = (VehicleData *)((int)&vehicle->objIndex + 1);
	} while (vehicle < (VehicleData *)0x6);
	return;
}



void __cdecl lego::res::Vehicle_FUN_0046d580(VehicleData *vehicle,BOOL use3rdFrame)
{
	Container **ppCVar1;
	uint uVar2;
	
	if (use3rdFrame == 0) {
		uVar2 = vehicle->flags & 0xfffffffd;
	}
	else {
		uVar2 = vehicle->flags | 2;
	}
	vehicle->flags = uVar2;
	Container_Hide(vehicle->aeResData1,use3rdFrame);
	if (vehicle->aeResData2 != (Container *)0x0) {
		Container_Hide(vehicle->aeResData2,use3rdFrame);
	}
	uVar2 = 0;
	if (vehicle->numWheelNulls != 0) {
		ppCVar1 = vehicle->WheelMeshes;
		do {
			if (*ppCVar1 != (Container *)0x0) {
				Container_Hide(*ppCVar1,use3rdFrame);
			}
			uVar2 = uVar2 + 1;
			ppCVar1 = ppCVar1 + 1;
		} while (uVar2 < vehicle->numWheelNulls);
	}
	return;
}



BOOL __cdecl lego::res::Vehicle_GetFlag2(VehicleData *vehicle)
{
	return (vehicle->flags & 0xff) >> 1 & 1;
}



void __cdecl lego::res::Vehicle_SetOrientation(VehicleData *vehicle,float x,float y,float z)
{
	Container_SetOrientation(vehicle->aeResData1,(Container *)0x0,x,y,z,0.0,0.0,-1.0);
	return;
}



void __cdecl
lego::res::Vehicle_SetPosition
					(VehicleData *vehicle,float x,float y,GetSurfaceZCallback *getZcallback,
					SurfaceMap *surfMap)
{
	float fVar1;
	int iVar2;
	uint uVar3;
	Container **ppCVar4;
	float *pfVar5;
	Vector3F *pVVar6;
	float10 fVar7;
	Vector3F local_a4;
	float local_98;
	float local_94;
	float local_90;
	float local_8c;
	Vector3F local_88;
	float local_7c;
	float local_78;
	float local_74;
	Vector3F local_70;
	Vector3F local_64;
	uint local_58;
	Vector3F local_54;
	float local_48;
	float local_44;
	float local_40;
	float local_3c;
	float local_38;
	float local_34;
	float local_30;
	float local_2c;
	float local_28;
	Vector3F local_c;
	
	fVar7 = (*getZcallback)(x,y,surfMap);
	Container_SetPosition(vehicle->aeResData1,(Container *)0x0,x,y,(float)fVar7);
	Container_GetOrientation(vehicle->aeResData1,(Container *)0x0,&local_88,&local_c);
	Container_SetOrientation
						(vehicle->aeResData1,(Container *)0x0,local_88.x,local_88.y,local_88.z,0.0,0.0,-1.0);
	if (vehicle->numWheelNulls != 0) {
		uVar3 = 0;
		if (vehicle->numWheelNulls != 0) {
			pVVar6 = &local_54;
			ppCVar4 = (Container **)vehicle->wheel_fields_28;
			do {
				Container_GetPosition(*ppCVar4,(Container *)0x0,pVVar6);
				fVar7 = (*getZcallback)(pVVar6->x,pVVar6->y,surfMap);
				pVVar6->z = (float)fVar7;
				uVar3 = uVar3 + 1;
				ppCVar4 = ppCVar4 + 1;
				pVVar6 = pVVar6 + 1;
			} while (uVar3 < vehicle->numWheelNulls);
		}
		local_98 = local_48 - local_3c;
		local_94 = local_44 - local_38;
		local_90 = local_40 - local_34;
		local_7c = local_48 - local_54.x;
		local_78 = local_44 - local_54.y;
		local_74 = local_40 - local_54.z;
		local_70.x = local_90 * local_78 - local_94 * local_74;
		local_70.y = local_98 * local_74 - local_90 * local_7c;
		local_70.z = local_94 * local_7c - local_98 * local_78;
		math::Vector3_Scale(&local_70,&local_70,
												1.0 / SQRT(local_70.z * local_70.z +
																	 local_70.y * local_70.y + local_70.x * local_70.x));
		local_7c = local_30 - local_3c;
		local_78 = local_2c - local_38;
		local_74 = local_28 - local_34;
		local_98 = local_30 - local_54.x;
		local_94 = local_2c - local_54.y;
		local_64.x = (local_28 - local_54.z) * local_78 - local_94 * local_74;
		local_64.y = local_98 * local_74 - (local_28 - local_54.z) * local_7c;
		local_64.z = local_94 * local_7c - local_98 * local_78;
		math::Vector3_Scale(&local_64,&local_64,
												1.0 / SQRT(local_64.z * local_64.z +
																	 local_64.y * local_64.y + local_64.x * local_64.x));
		local_a4.x = local_64.x + local_70.x;
		local_a4.y = local_64.y + local_70.y;
		local_a4.z = local_64.z + local_70.z;
		math::Vector3_Scale(&local_a4,&local_a4,
												1.0 / SQRT(local_a4.z * local_a4.z +
																	 local_a4.y * local_a4.y + local_a4.x * local_a4.x));
		pfVar5 = (float *)&vehicle->field_5c;
		iVar2 = std::_finite((double)(float)vehicle->field_5c);
		if (((iVar2 == 0) || (iVar2 = std::_finite((double)(float)vehicle->field_60), iVar2 == 0)) ||
			 (iVar2 = std::_finite((double)(float)vehicle->field_60), iVar2 == 0)) {
			*pfVar5 = local_a4.x;
			vehicle->field_60 = local_a4.y;
			vehicle->float_64 = local_a4.z;
		}
		local_a4.x = *pfVar5 * 0.4 + local_a4.x;
		local_a4.y = (float)vehicle->field_60 * 0.4 + local_a4.y;
		local_a4.z = vehicle->float_64 * 0.4 + local_a4.z;
		local_8c = 1.0 / SQRT(local_a4.z * local_a4.z +
													local_a4.y * local_a4.y + local_a4.x * local_a4.x);
		local_a4.x = local_8c * local_a4.x;
		local_a4.y = local_8c * local_a4.y;
		local_a4.z = local_8c * local_a4.z;
		fVar1 = local_88.z * local_a4.z + local_88.y * local_a4.y + local_88.x * local_a4.x;
		*pfVar5 = local_a4.x;
		local_88.x = local_88.x - fVar1 * local_a4.x;
		local_88.y = local_88.y - fVar1 * local_a4.y;
		local_88.z = local_88.z - fVar1 * local_a4.z;
		vehicle->field_60 = local_a4.y;
		vehicle->float_64 = local_a4.z;
		Container_SetOrientation
							(vehicle->aeResData1,(Container *)0x0,local_88.x,local_88.y,local_88.z,-local_a4.x,
							 -local_a4.y,-local_a4.z);
		uVar3 = 0;
		if (vehicle->numWheelNulls != 0) {
			pVVar6 = &local_54;
			ppCVar4 = (Container **)vehicle->wheel_fields_28;
			do {
				Container_GetPosition(*ppCVar4,(Container *)0x0,pVVar6);
				fVar7 = (*getZcallback)(pVVar6->x,pVVar6->y,surfMap);
				Container_AddTranslation
									(*ppCVar4,D3DRMCOMBINE_AFTER,0.0,
									 (float)-((fVar7 - (float10)pVVar6->z) - (float10)vehicle->WheelRadius),0.0);
				uVar3 = uVar3 + 1;
				ppCVar4 = ppCVar4 + 1;
				pVVar6 = pVVar6 + 1;
			} while (uVar3 < vehicle->numWheelNulls);
		}
		uVar3 = 0;
		if (vehicle->numWheelNulls != 0) {
			ppCVar4 = vehicle->WheelMeshes;
			do {
				if (*ppCVar4 != (Container *)0x0) {
					Container_SetPosition(*ppCVar4,ppCVar4[6],0.0,0.0,0.0);
				}
				uVar3 = uVar3 + 1;
				ppCVar4 = ppCVar4 + 1;
			} while (uVar3 < vehicle->numWheelNulls);
		}
		local_58 = 0;
		if (vehicle->numWheelNulls != 0) {
			pVVar6 = &local_54;
			ppCVar4 = vehicle->WheelMeshes;
			pfVar5 = (float *)&vehicle->field_0x74;
			do {
				if (*ppCVar4 != (Container *)0x0) {
					Container_GetPosition(*ppCVar4,(Container *)0x0,pVVar6);
					local_98 = pVVar6->x - pfVar5[-2];
					local_94 = pVVar6->y - pfVar5[-1];
					local_90 = pVVar6->z - *pfVar5;
					local_8c = SQRT(local_90 * local_90 + local_94 * local_94 + local_98 * local_98) /
										 vehicle->WheelRadius;
					if (local_90 * local_88.z + local_94 * local_88.y + local_98 * local_88.x < 0.0) {
						local_8c = -local_8c;
					}
					Container_AddRotation(*ppCVar4,D3DRMCOMBINE_BEFORE,1.0,0.0,0.0,local_8c);
				}
				local_58 = local_58 + 1;
				ppCVar4 = ppCVar4 + 1;
				pfVar5 = pfVar5 + 3;
				pVVar6 = pVVar6 + 1;
			} while (local_58 < vehicle->numWheelNulls);
		}
		uVar3 = 0;
		if (vehicle->numWheelNulls != 0) {
			ppCVar4 = vehicle->WheelMeshes;
			pVVar6 = (Vector3F *)&vehicle->field_0x6c;
			do {
				if (*ppCVar4 != (Container *)0x0) {
					Container_GetPosition(*ppCVar4,(Container *)0x0,pVVar6);
				}
				uVar3 = uVar3 + 1;
				pVVar6 = pVVar6 + 1;
				ppCVar4 = ppCVar4 + 1;
			} while (uVar3 < vehicle->numWheelNulls);
		}
		return;
	}
	return;
}



Container * __cdecl lego::res::Vehicle_GetAEResource(VehicleData *vehicle)
{
	return vehicle->aeResData1;
}



Container * __cdecl lego::res::Vehicle_GetNull(VehicleData *vehicle,char *nullName,int nullIndex)
{
	Container *pCVar1;
	char *pcVar2;
	
	pCVar1 = (Container *)0x0;
	if (vehicle->aeResData2 != (Container *)0x0) {
		pcVar2 = Container_FormatPartName(vehicle->aeResData2,nullName,&nullIndex);
		pCVar1 = Container_SearchTree
											 (vehicle->aeResData2,pcVar2,CONTAINER_SEARCHMODE_FIRSTMATCH,(undefined4 *)0x0
											 );
	}
	if (pCVar1 == (Container *)0x0) {
		pcVar2 = Container_FormatPartName(vehicle->aeResData1,nullName,&nullIndex);
		pCVar1 = Container_SearchTree
											 (vehicle->aeResData1,pcVar2,CONTAINER_SEARCHMODE_FIRSTMATCH,(undefined4 *)0x0
											 );
	}
	return pCVar1;
}



Container * __cdecl lego::res::Vehicle_GetCameraNull(VehicleData *vehicle,int cameraIndex)
{
	Container *pCVar1;
	
	if (vehicle->CameraNullName == (char *)0x0) {
		return (Container *)0x0;
	}
	if ((Container *)vehicle->cameraFramesTable_10c[cameraIndex] != (Container *)0x0) {
		return (Container *)vehicle->cameraFramesTable_10c[cameraIndex];
	}
	pCVar1 = Vehicle_GetNull(vehicle,vehicle->CameraNullName,cameraIndex);
	vehicle->cameraFramesTable_10c[cameraIndex] = pCVar1;
	return pCVar1;
}



Container * __cdecl lego::res::Vehicle_GetDrillNull(VehicleData *vehicle)
{
	Container *pCVar1;
	
	if (vehicle->DrillNullName == (char *)0x0) {
		pCVar1 = (Container *)0x0;
	}
	else {
		pCVar1 = (Container *)vehicle->field_cc;
		if (pCVar1 == (Container *)0x0) {
			pCVar1 = Vehicle_GetNull(vehicle,vehicle->DrillNullName,0);
			vehicle->field_cc = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Vehicle_GetDepositNull(VehicleData *vehicle)
{
	Container *pCVar1;
	
	if (vehicle->DepositNullName == (char *)0x0) {
		pCVar1 = (Container *)0x0;
	}
	else {
		pCVar1 = (Container *)vehicle->field_d0;
		if (pCVar1 == (Container *)0x0) {
			pCVar1 = Vehicle_GetNull(vehicle,vehicle->DepositNullName,0);
			vehicle->field_d0 = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Vehicle_GetDriverNull(VehicleData *vehicle)
{
	Container *pCVar1;
	
	if (vehicle->DriverNullName == (char *)0x0) {
		pCVar1 = (Container *)0x0;
	}
	else {
		pCVar1 = vehicle->resData_d4;
		if (pCVar1 == (Container *)0x0) {
			pCVar1 = Vehicle_GetNull(vehicle,vehicle->DriverNullName,0);
			vehicle->resData_d4 = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Vehicle_GetCarryNull(VehicleData *vehicle,int carryIndex)
{
	Container *pCVar1;
	
	if (vehicle->CarryNullName == (char *)0x0) {
		return (Container *)0x0;
	}
	if ((Container *)vehicle->carryFramesTable_e4[carryIndex] != (Container *)0x0) {
		return (Container *)vehicle->carryFramesTable_e4[carryIndex];
	}
	pCVar1 = Vehicle_GetNull(vehicle,vehicle->CarryNullName,carryIndex);
	vehicle->carryFramesTable_e4[carryIndex] = pCVar1;
	return pCVar1;
}



int __cdecl lego::res::Vehicle_GetCarryNullFrames(VehicleData *vehicle)
{
	return vehicle->CarryNullFrames;
}



float10 __cdecl lego::res::Vehicle_GetFloat14(VehicleData *vehicle)
{
	float10 fVar1;
	
	fVar1 = Container_GetTransCoef(vehicle->aeResData1);
	return fVar1;
}



void __cdecl lego::game::Level_Load_FUN_0046de50(Container *resRoot,LevelData *level)
{
	Struct_428 *pSVar1;
	Struct_428 *pSVar2;
	uint uVar3;
	int iVar4;
	uint *puVar5;
	uint uVar6;
	uint uVar7;
	Struct_428 **ppSVar8;
	uint uVar9;
	Struct_428 *pSVar10;
	uint unkParam_x;
	Point2F *pPVar11;
	uint local_4;
	
	uVar7 = 0;
	Struct_428_COUNT_0054ceb0 = 0;
	PairStruct_428_COUNT_0054cf04 = 0;
	globals::g_LevelUnk_DigDepth = level->DigDepth;
	if ((level->dimensions).height != 0) {
		do {
			uVar9 = 0;
			unkParam_x = 0;
			uVar6 = 0;
			uVar3 = (level->dimensions).width;
			if (uVar3 != 0) {
				do {
					if (level->blocks[uVar7 * uVar3 + uVar6].terrain == TERRAIN_WATER_unused) {
						if (unkParam_x == uVar9) {
							unkParam_x = uVar6;
						}
						uVar9 = uVar6 + 1;
					}
					else {
						if (unkParam_x != uVar9) {
							pSVar2 = Level_LoadSearchStruct428(uVar7,unkParam_x,uVar9);
							if (pSVar2 == (Struct_428 *)0x0) {
								Level_LoadAddFirstStruct428(uVar7,unkParam_x,uVar9);
							}
							else {
								Level_LoadAddStruct428(pSVar2,uVar7,unkParam_x,uVar9);
							}
						}
						uVar9 = 0;
						unkParam_x = 0;
					}
					uVar3 = (level->dimensions).width;
					uVar6 = uVar6 + 1;
				} while (uVar6 < uVar3);
			}
			uVar7 = uVar7 + 1;
		} while (uVar7 < (uint)(level->dimensions).height);
	}
	local_4 = 0;
	if (PairStruct_428_COUNT_0054cf04 != 0) {
		ppSVar8 = &PairStruct_428_ARRAY_0054ceb4[0].second;
		do {
			pSVar2 = *ppSVar8;
			pSVar1 = ppSVar8[-1];
			if (pSVar2->pointsCount != 0) {
				pSVar10 = pSVar2;
				pPVar11 = pSVar1->points + pSVar1->pointsCount;
				for (uVar7 = (pSVar2->pointsCount << 3) >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
					pPVar11->x = pSVar10->points[0].x;
					pSVar10 = (Struct_428 *)&pSVar10->points[0].y;
					pPVar11 = (Point2F *)(&pPVar11->x + 1);
				}
				for (iVar4 = 0; iVar4 != 0; iVar4 = iVar4 + -1) {
					*(undefined *)&pPVar11->x = *(undefined *)&pSVar10->points[0].x;
					pSVar10 = (Struct_428 *)((int)&pSVar10->points[0].x + 1);
					pPVar11 = (Point2F *)((int)&pPVar11->x + 1);
				}
				pSVar1->pointsCount = pSVar1->pointsCount + pSVar2->pointsCount;
				pSVar2->pointsCount = 0;
			}
			local_4 = local_4 + 1;
			ppSVar8 = ppSVar8 + 2;
		} while (local_4 < PairStruct_428_COUNT_0054cf04);
	}
	std::qsort(Struct_428_ARRAY_0054a520,Struct_428_COUNT_0054ceb0,0x428,Struct428_CompareCount);
	uVar7 = 0;
	if (Struct_428_COUNT_0054ceb0 != 0) {
		puVar5 = &Struct_428_ARRAY_0054a520[0].pointsCount;
		uVar9 = Struct_428_COUNT_0054ceb0;
		do {
			if (*puVar5 == 0) {
				uVar9 = uVar7;
				Struct_428_COUNT_0054ceb0 = uVar7;
			}
			uVar7 = uVar7 + 1;
			puVar5 = puVar5 + 0x10a;
		} while (uVar7 < uVar9);
	}
	FUN_0046dfd0(resRoot,level);
	FUN_0046e140(resRoot,level);
	return;
}



void __cdecl FUN_0046dfd0(Container *resData,LevelData *level)
{
	TerrainType TVar1;
	int iVar2;
	int iVar3;
	int iVar4;
	uint uVar5;
	float *pfVar6;
	longlong lVar7;
	Point2F *local_30;
	uint local_2c;
	uint *local_28;
	uint index;
	Point2F DIRECTIONS [4];
	
	DIRECTIONS[0].x = 0.0;
	DIRECTIONS[0].y = -1.0;
	DIRECTIONS[1].x = 1.0;
	DIRECTIONS[1].y = 0.0;
	DIRECTIONS[2].x = 0.0;
	DIRECTIONS[2].y = 1.0;
	DIRECTIONS[3].x = -1.0;
	DIRECTIONS[3].y = 0.0;
	index = 0;
	if (Struct_428_COUNT_0054ceb0 != 0) {
		local_28 = &Struct_428_ARRAY_0054a520[0].pointsCount;
		do {
			local_30 = (Point2F *)(local_28 + -200);
			local_28[0x3d] = 0;
			local_2c = 0;
			if (*local_28 != 0) {
				do {
					uVar5 = 0;
					pfVar6 = &DIRECTIONS[0].y;
					do {
						lVar7 = __ftol((float10)pfVar6[-1] + (float10)local_30->x);
						iVar3 = (int)lVar7;
						lVar7 = __ftol((float10)local_30->y + (float10)*pfVar6);
						iVar4 = (int)lVar7;
						if ((((-1 < iVar3) && (iVar2 = (level->dimensions).width, iVar3 < iVar2)) &&
								(-1 < iVar4)) &&
							 (((iVar4 < (level->dimensions).height &&
								 (TVar1 = level->blocks[iVar4 * iVar2 + iVar3].terrain,
								 TVar1 != TERRAIN_WATER_unused)) && (TVar1 != TERRAIN_IMMOVABLE)))) {
							local_28[local_28[0x3d] * 6 + 1] = local_2c;
							local_28[local_28[0x3d] * 6 + 2] = uVar5;
							local_28[0x3d] = local_28[0x3d] + 1;
							break;
						}
						uVar5 = uVar5 + 1;
						pfVar6 = pfVar6 + 2;
					} while (uVar5 < 4);
					local_30 = local_30 + 1;
					local_2c = local_2c + 1;
				} while (local_2c < *local_28);
			}
			index = index + 1;
			local_28 = local_28 + 0x10a;
		} while (index < Struct_428_COUNT_0054ceb0);
	}
	return;
}



void __cdecl FUN_0046e140(Container *in_resData,LevelData *level)
{
	int iVar1;
	float fVar2;
	uint uVar3;
	Container *cont;
	D3DRMGroupIndex groupID;
	float *pfVar4;
	uint uVar5;
	float *pfVar6;
	float *pfVar7;
	longlong lVar8;
	longlong lVar9;
	undefined4 *puVar10;
	D3DRMGroupIndex local_138;
	D3DRMGroupIndex *local_134;
	float *local_130;
	int local_12c;
	uint local_128;
	float local_118 [4];
	float local_108 [4];
	uint local_f8;
	undefined4 local_f4;
	undefined4 local_f0;
	undefined4 local_ec;
	undefined4 local_e8;
	undefined4 local_e4;
	float local_e0 [5];
	undefined4 local_cc;
	undefined4 local_c8;
	undefined4 local_c4;
	undefined4 local_c0;
	float local_bc;
	float local_b8 [10];
	D3DRMVertex local_90 [4];
	
	local_f4 = 1;
	local_ec = 1;
	local_e0[0] = 0.0;
	local_e0[1] = 0.0;
	local_e0[2] = 1.0;
	local_e0[3] = 0.0;
	local_e0[4] = 1.0;
	local_cc = 1065353216;
	local_c8 = 0;
	local_c4 = 1065353216;
	local_f8 = 0;
	local_f0 = 3;
	local_e8 = 2;
	local_e4 = 3;
	local_118[0] = 0.0;
	local_118[1] = 1.0;
	local_118[2] = 1.0;
	local_118[3] = 0.0;
	local_108[0] = 0.0;
	local_108[1] = 0.0;
	local_108[2] = 1.0;
	local_108[3] = 1.0;
	local_128 = 0;
	if (Struct_428_COUNT_0054ceb0 != 0) {
		local_134 = &Struct_428_ARRAY_0054a520[0].pointsCount;
		do {
			pfVar7 = (float *)(local_134 + -200);
			local_134[0x3e] = 0xc61c4000;
			local_138 = D3DRMGROUP_0;
			pfVar6 = pfVar7;
			if (*local_134 != D3DRMGROUP_0) {
				do {
					puVar10 = &local_c0;
					lVar8 = __ftol((float10)pfVar6[1]);
					uVar3 = (uint)lVar8;
					lVar8 = __ftol((float10)*pfVar6);
					lego::game::SurfaceMap_FillStruct30_FUN_00450390
										(level->surfaceMap,(uint)lVar8,uVar3,puVar10);
					local_130 = local_b8;
					pfVar4 = local_e0;
					local_12c = 4;
					do {
						lVar8 = __ftol((float10)pfVar4[1] + (float10)pfVar6[1]);
						iVar1 = (level->dimensions).width;
						lVar9 = __ftol((float10)*pfVar6 + (float10)*pfVar4);
						if (level->blocks[(int)lVar8 * iVar1 + (int)lVar9].predug == PREDUG_WALL) {
							if ((ushort)((ushort)(*local_130 < (float)local_134[0x3e]) << 8 |
													(ushort)(*local_130 == (float)local_134[0x3e]) << 0xe) == 0) {
								local_134[0x3e] = (D3DRMGroupIndex)*local_130;
							}
						}
						else {
							local_134[0x41] = local_134[0x41] | 1;
						}
						pfVar4 = pfVar4 + 2;
						local_130 = local_130 + 3;
						local_12c = local_12c + -1;
					} while (local_12c != 0);
					local_138 = local_138 + 1;
					pfVar6 = pfVar6 + 2;
				} while (local_138 < *local_134);
			}
			local_134[0x3f] = local_134[0x3e];
			cont = lego::res::Container_MakeMesh2(in_resData,3);
			local_134[0x40] = (D3DRMGroupIndex)cont;
			lego::res::Container_Hide(cont,~local_134[0x41] & 1);
			local_138 = D3DRMGROUP_0;
			if (*local_134 != D3DRMGROUP_0) {
				do {
					groupID = lego::res::Container_Mesh_AddGroup((Container *)local_134[0x40],4,2,3,&local_f8)
					;
					lego::res::Container_Mesh_SetColourAlpha
										((Container *)local_134[0x40],groupID,0.0,0.3,0.8,0.6);
					puVar10 = &local_c0;
					lVar8 = __ftol((float10)pfVar7[1]);
					uVar3 = (uint)lVar8;
					lVar8 = __ftol((float10)*pfVar7);
					lego::game::SurfaceMap_FillStruct30_FUN_00450390
										(level->surfaceMap,(uint)lVar8,uVar3,puVar10);
					pfVar6 = &local_bc;
					pfVar4 = &local_90[0].position.y;
					uVar3 = 0;
					do {
						pfVar4[-1] = pfVar6[-1];
						*pfVar4 = *pfVar6;
						pfVar4[1] = (float)local_134[0x3e];
						uVar5 = uVar3 + 4;
						pfVar6 = pfVar6 + 3;
						pfVar4[2] = 0.0;
						pfVar4[3] = 0.0;
						pfVar4[4] = -1.0;
						fVar2 = *(float *)((int)local_118 + uVar3);
						pfVar4[7] = 0.0;
						pfVar4[5] = fVar2;
						pfVar4[6] = *(float *)((int)local_108 + uVar3);
						pfVar4 = pfVar4 + 9;
						uVar3 = uVar5;
					} while (uVar5 < 0x10);
					lego::res::Container_Mesh_SetVertices((Container *)local_134[0x40],local_138,0,4,local_90)
					;
					local_138 = local_138 + 1;
					pfVar7 = pfVar7 + 2;
				} while (local_138 < *local_134);
			}
			local_128 = local_128 + 1;
			local_134 = local_134 + 0x10a;
		} while (local_128 < Struct_428_COUNT_0054ceb0);
	}
	return;
}



void __cdecl FUN_0046e480(BOOL param_1)
{
	char **ppcVar1;
	uint uVar2;
	char *message;
	undefined4 uVar3;
	undefined4 uVar4;
	
	uVar2 = 0;
	if (Struct_428_COUNT_0054ceb0 != 0) {
		ppcVar1 = (char **)&Struct_428_ARRAY_0054a520[0].field_420;
		do {
			if (param_1 == 0) {
				message = *ppcVar1;
				uVar4 = 0;
				uVar3 = 0;
			}
			else {
				message = *ppcVar1;
				uVar4 = 1050924810;
				uVar3 = 1039516304;
			}
			lego::util::logf_removed(message,0,uVar3,uVar4);
			uVar2 = uVar2 + 1;
			ppcVar1 = ppcVar1 + 0x10a;
		} while (uVar2 < Struct_428_COUNT_0054ceb0);
	}
	return;
}



void __cdecl lego::game::Level_FUN_0046e4e0(LevelData *level,int param_2,uint param_3)
{
	undefined4 *puVar1;
	int iVar2;
	float fVar3;
	undefined4 *puVar4;
	uint y;
	longlong lVar5;
	undefined4 *puVar6;
	int local_50 [4];
	undefined4 local_40;
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	undefined4 local_30 [2];
	float afStack40 [10];
	
	local_50[3] = 2;
	local_40 = 2;
	local_3c = 3;
	local_38 = 3;
	local_50[0] = 0;
	local_50[1] = 1;
	local_50[2] = 1;
	local_34 = 0;
	puVar4 = FUN_0046eb60(param_2,param_3,&param_3);
	if (puVar4 != (undefined4 *)0x0) {
		puVar4[0x109] = puVar4[0x109] & 0xfffffffb | 1;
		res::Container_Hide((Container *)puVar4[0x108],0);
		puVar6 = local_30;
		iVar2 = puVar4[param_3 * 6 + 0xc9];
		puVar1 = puVar4 + param_3 * 6 + 0xc9;
		puVar1[5] = 1;
		puVar1[3] = 0;
		puVar1[4] = 0;
		lVar5 = __ftol((float10)(float)(puVar4 + iVar2 * 2)[1]);
		y = (uint)lVar5;
		lVar5 = __ftol((float10)(float)puVar4[iVar2 * 2]);
		SurfaceMap_FillStruct30_FUN_00450390(level->surfaceMap,(uint)lVar5,y,puVar6);
		fVar3 = -afStack40[local_50[puVar1[1] * 2] * 3];
		if (-afStack40[local_50[puVar1[1] * 2 + 1] * 3] <= -afStack40[local_50[puVar1[1] * 2] * 3]) {
			fVar3 = -afStack40[local_50[puVar1[1] * 2 + 1] * 3];
		}
		puVar1[2] = -fVar3;
	}
	return;
}



void __cdecl FUN_0046e5f0(int param_1,uint param_2)
{
	undefined4 *puVar1;
	
	puVar1 = FUN_0046eb60(param_1,param_2,&param_2);
	if (puVar1 != (undefined4 *)0x0) {
		puVar1[0x109] = puVar1[0x109] & 0xfffffffd | 1;
		lego::res::Container_Hide((Container *)puVar1[0x108],0);
		puVar1[param_2 * 6 + 0xce] = 0;
	}
	return;
}



void __cdecl lego::game::Level_FUN_0046e650(LevelData *level,float param_2)
{
	float fVar1;
	float fVar2;
	float fVar3;
	bool bVar4;
	bool bVar5;
	float *pfVar6;
	int iVar7;
	uint uVar8;
	uint *puVar9;
	D3DRMGroupIndex groupID;
	bool bVar10;
	uint local_a0;
	uint local_9c;
	D3DRMVertex local_90 [4];
	
	local_a0 = 0;
	local_9c = 0;
	if (Struct_428_COUNT_0054ceb0 != 0) {
		puVar9 = &Struct_428_ARRAY_0054a520[0].itemsCount;
		do {
			bVar5 = false;
			fVar1 = (float)puVar9[1];
			bVar10 = (*(byte *)(puVar9 + 4) & 2) == 0;
			uVar8 = 0;
			if (*puVar9 != 0) {
				pfVar6 = (float *)(puVar9 + -0x3a);
				do {
					bVar4 = false;
					if ((pfVar6[3] == 0.0) ||
						 ((ushort)((ushort)((float)puVar9[2] < *pfVar6) << 8 |
											(ushort)((float)puVar9[2] == *pfVar6) << 0xe) == 0)) {
LAB_0046e6eb:
						bVar4 = true;
					}
					else {
						if (fVar1 < *pfVar6) {
							fVar1 = *pfVar6;
						}
						bVar10 = false;
						local_a0 = local_a0 + 1;
						bVar5 = true;
						if ((float)puVar9[2] == *pfVar6) goto LAB_0046e6eb;
					}
					fVar3 = pfVar6[1] + param_2 * 1.5;
					pfVar6[1] = fVar3;
					if (bVar4) {
						pfVar6[2] = param_2 * 0.5 + pfVar6[2];
					}
					if ((ushort)((ushort)(fVar3 < 240.0) << 8 | (ushort)(fVar3 == 240.0) << 0xe) == 0) {
						pfVar6[1] = 240.0;
					}
					if ((ushort)((ushort)(pfVar6[2] < 240.0) << 8 | (ushort)(pfVar6[2] == 240.0) << 0xe) == 0)
					{
						pfVar6[2] = 240.0;
					}
					uVar8 = uVar8 + 1;
					pfVar6 = pfVar6 + 6;
				} while (uVar8 < *puVar9);
			}
			uVar8 = puVar9[4];
			if ((uVar8 & 4) != 0) {
				bVar5 = false;
			}
			if ((bVar5) || (bVar10)) {
				fVar3 = ((float)puVar9[2] - (float)puVar9[1]) / level->DigDepth;
				if (bVar5) {
					puVar9[4] = uVar8 & 0xfffffffd;
					fVar2 = ((float)(ulonglong)local_a0 * param_2 * 0.3) / (fVar3 - -1.0) + (float)puVar9[2];
					puVar9[2] = (uint)fVar2;
					if (fVar1 <= fVar2) {
						puVar9[2] = (uint)fVar1;
						puVar9[4] = uVar8 & 0xfffffffd | 4;
					}
				}
				else {
					puVar9[4] = uVar8 & 0xfffffffb;
					fVar2 = (float)puVar9[2] - param_2 * 0.05;
					puVar9[2] = (uint)fVar2;
					if ((ushort)((ushort)(fVar2 < fVar1) << 8 | (ushort)(fVar2 == fVar1) << 0xe) != 0) {
						puVar9[2] = (uint)fVar1;
						puVar9[4] = uVar8 & 0xfffffffb | 2;
					}
				}
				res::Container_SetColourAlpha((Container *)puVar9[3],0.0,0.3,0.8,0.6 - fVar3 * 0.4);
				groupID = D3DRMGROUP_0;
				if (puVar9[-0x3d] != 0) {
					do {
						res::Container_Mesh_GetVertices((Container *)puVar9[3],groupID,0,4,local_90);
						pfVar6 = &local_90[0].position.z;
						iVar7 = 4;
						do {
							*pfVar6 = (float)puVar9[2];
							pfVar6 = pfVar6 + 9;
							iVar7 = iVar7 + -1;
						} while (iVar7 != 0);
						res::Container_Mesh_SetVertices((Container *)puVar9[3],groupID,0,4,local_90);
						groupID = groupID + 1;
					} while (groupID < puVar9[-0x3d]);
				}
			}
			local_9c = local_9c + 1;
			puVar9 = puVar9 + 0x10a;
		} while (local_9c < Struct_428_COUNT_0054ceb0);
	}
	Level_FUN_0046e8d0(level);
	return;
}



void __cdecl lego::game::Level_FUN_0046e8d0(LevelData *level)
{
	uint uVar1;
	uint uVar2;
	uint *puVar3;
	uint *puVar4;
	longlong lVar5;
	float *pfVar6;
	int *local_9c;
	int *local_98;
	uint local_94;
	uint local_90;
	float local_8c;
	float local_88;
	int local_80 [4];
	undefined4 local_70;
	undefined4 local_6c;
	undefined4 local_68;
	undefined4 local_64;
	float local_60 [4];
	undefined4 local_50;
	undefined4 local_4c;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40;
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	float local_30 [12];
	
	local_80[1] = 1;
	local_80[2] = 1;
	local_60[0] = 0.0;
	local_80[3] = 2;
	local_70 = 2;
	local_60[1] = 1.0;
	local_6c = 3;
	local_68 = 3;
	local_60[2] = 0.0;
	local_60[3] = 1.0;
	local_50 = 0;
	local_4c = 0;
	local_48 = 0;
	local_44 = 0xbf800000;
	local_40 = 0;
	local_3c = 0xbf800000;
	local_38 = 0;
	local_34 = 0;
	local_80[0] = 0;
	local_64 = 0;
	local_94 = 0;
	if (Struct_428_COUNT_0054ceb0 != 0) {
		puVar3 = &Struct_428_ARRAY_0054a520[0].itemsCount;
		do {
			local_90 = 0;
			if (*puVar3 != 0) {
				puVar4 = puVar3 + -0x3b;
				do {
					uVar1 = puVar4[-1];
					pfVar6 = local_30;
					lVar5 = __ftol((float10)(float)puVar3[uVar1 * 2 + -0x104]);
					uVar2 = (uint)lVar5;
					lVar5 = __ftol((float10)(float)puVar3[uVar1 * 2 + -0x105]);
					SurfaceMap_FillStruct30_FUN_00450390(level->surfaceMap,(uint)lVar5,uVar2,pfVar6);
					uVar1 = *puVar4;
					local_8c = (local_30[local_80[uVar1 * 2 + 1] * 3] + local_30[local_80[uVar1 * 2] * 3]) *
										 0.5 + local_60[uVar1 * 3] * (float)puVar4[2];
					local_88 = local_60[uVar1 * 3 + 1] * (float)puVar4[2] +
										 (local_30[local_80[uVar1 * 2] * 3 + 1] +
										 local_30[local_80[uVar1 * 2 + 1] * 3 + 1]) * 0.5;
					SurfaceMap_ToBlockCoordinatesNoZ
										(level->surfaceMap,local_8c,local_88,(int *)&local_98,(int *)&local_9c);
					FUN_0042f210(level,local_98,local_9c,1);
					uVar1 = puVar4[-1];
					pfVar6 = local_30;
					lVar5 = __ftol((float10)(float)puVar3[uVar1 * 2 + -0x104]);
					uVar2 = (uint)lVar5;
					lVar5 = __ftol((float10)(float)puVar3[uVar1 * 2 + -0x105]);
					SurfaceMap_FillStruct30_FUN_00450390(level->surfaceMap,(uint)lVar5,uVar2,pfVar6);
					uVar1 = *puVar4;
					local_8c = (local_30[local_80[uVar1 * 2 + 1] * 3] + local_30[local_80[uVar1 * 2] * 3]) *
										 0.5 + local_60[uVar1 * 3] * (float)puVar4[3];
					local_88 = local_60[uVar1 * 3 + 1] * (float)puVar4[3] +
										 (local_30[local_80[uVar1 * 2] * 3 + 1] +
										 local_30[local_80[uVar1 * 2 + 1] * 3 + 1]) * 0.5;
					SurfaceMap_ToBlockCoordinatesNoZ
										(level->surfaceMap,local_8c,local_88,(int *)&local_98,(int *)&local_9c);
					FUN_0042f210(level,local_98,local_9c,0);
					local_90 = local_90 + 1;
					puVar4 = puVar4 + 6;
				} while (local_90 < *puVar3);
			}
			local_94 = local_94 + 1;
			puVar3 = puVar3 + 0x10a;
		} while (local_94 < Struct_428_COUNT_0054ceb0);
	}
	return;
}



undefined4 * __cdecl FUN_0046eb60(int param_1,int param_2,uint *out_index)
{
	uint uVar1;
	ItemStruct_428 *pIVar2;
	ItemStruct_428 *pIVar3;
	float10 extraout_ST0;
	longlong lVar4;
	uint local_24;
	float local_20 [4];
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_20[0] = 0.0;
	local_20[1] = -1.0;
	local_20[2] = 1.0;
	local_20[3] = 0.0;
	local_10 = 0;
	local_c = 0x3f800000;
	local_8 = 0xbf800000;
	local_4 = 0;
	local_24 = 0;
	if (Struct_428_COUNT_0054ceb0 == 0) {
		return (undefined4 *)0x0;
	}
	pIVar2 = Struct_428_ARRAY_0054a520[0].items;
	do {
		uVar1 = 0;
		pIVar3 = pIVar2;
		if (pIVar2[10].index != 0) {
			do {
				lVar4 = __ftol((float10)(float)(&pIVar2[-0x22].field_c)[pIVar3->index * 2] +
											 (float10)local_20[pIVar3->direction * 2]);
				if ((param_1 == (int)lVar4) && (lVar4 = __ftol(extraout_ST0), param_2 == (int)lVar4)) {
					if (out_index != (uint *)0x0) {
						*out_index = uVar1;
					}
					return &pIVar2[-0x22].field_c;
				}
				uVar1 = uVar1 + 1;
				pIVar3 = pIVar3 + 1;
			} while (uVar1 < pIVar2[10].index);
		}
		local_24 = local_24 + 1;
		pIVar2 = (ItemStruct_428 *)&pIVar2[0x2c].field_8;
		if (Struct_428_COUNT_0054ceb0 <= local_24) {
			return (undefined4 *)0x0;
		}
	} while( true );
}



int __cdecl lego::game::Struct428_CompareCount(Struct_428 *a,Struct_428 *b)
{
	if (b->pointsCount < a->pointsCount) {
		return 0xffffffff;
	}
	return (uint)(a->pointsCount < b->pointsCount);
}



Struct_428 * __cdecl lego::game::Level_LoadSearchStruct428(int y,uint unkParam_x,uint unkParam_xMax)
{
	Struct_428 *pSVar1;
	Struct_428 *pSVar2;
	uint uVar3;
	Struct_428 *pSVar4;
	Struct_428 *pSVar5;
	uint uVar6;
	
	pSVar4 = (Struct_428 *)0x0;
	if ((y != 0) && (unkParam_x < unkParam_xMax)) {
		do {
			uVar3 = 0;
			if (Struct_428_COUNT_0054ceb0 != 0) {
				pSVar1 = Struct_428_ARRAY_0054a520;
				do {
					uVar6 = 0;
					if (pSVar1->pointsCount != 0) {
						pSVar2 = pSVar1;
						pSVar5 = pSVar4;
						do {
							pSVar4 = pSVar5;
							if (((((float)(ulonglong)unkParam_x == pSVar2->points[0].x) &&
									 ((float)(ulonglong)(y - 1) == pSVar2->points[0].y)) &&
									(pSVar4 = pSVar1, pSVar5 != (Struct_428 *)0x0)) &&
								 (pSVar4 = pSVar5, pSVar5 != pSVar1)) {
								PairStruct_428_ARRAY_0054ceb4[PairStruct_428_COUNT_0054cf04].first = pSVar5;
								PairStruct_428_ARRAY_0054ceb4[PairStruct_428_COUNT_0054cf04].second = pSVar1;
								PairStruct_428_COUNT_0054cf04 = PairStruct_428_COUNT_0054cf04 + 1;
							}
							uVar6 = uVar6 + 1;
							pSVar2 = (Struct_428 *)(pSVar2->points + 1);
							pSVar5 = pSVar4;
						} while (uVar6 < pSVar1->pointsCount);
					}
					uVar3 = uVar3 + 1;
					pSVar1 = pSVar1 + 1;
				} while (uVar3 < Struct_428_COUNT_0054ceb0);
			}
			unkParam_x = unkParam_x + 1;
		} while (unkParam_x < unkParam_xMax);
	}
	return pSVar4;
}



void __cdecl
lego::game::Level_LoadAddStruct428(Struct_428 *struct428,uint y,uint unkParam_x,uint unkParam_xMax)
{
	if (unkParam_x < unkParam_xMax) {
		do {
			struct428->points[struct428->pointsCount].x = (float)(ulonglong)unkParam_x;
			struct428->points[struct428->pointsCount].y = (float)(ulonglong)y;
			unkParam_x = unkParam_x + 1;
			struct428->pointsCount = struct428->pointsCount + 1;
		} while (unkParam_x < unkParam_xMax);
	}
	return;
}



void __cdecl lego::game::Level_LoadAddFirstStruct428(uint y,uint unkParam_x,uint unkParam_xMax)
{
	Struct_428 *struct428;
	
	struct428 = Struct_428_ARRAY_0054a520 + Struct_428_COUNT_0054ceb0;
	Struct_428_ARRAY_0054a520[Struct_428_COUNT_0054ceb0].pointsCount = 0;
	Level_LoadAddStruct428(struct428,y,unkParam_x,unkParam_xMax);
	Struct_428_COUNT_0054ceb0 = Struct_428_COUNT_0054ceb0 + 1;
	return;
}



BOOL __cdecl lego::tools::Weapon_LoadWeaponTypes(CFGProperty *root,char *rootPath)
{
	char cVar1;
	CFGProperty *prop;
	char *pcVar2;
	CFGProperty *pCVar3;
	int iVar4;
	BOOL BVar5;
	void *pvVar6;
	uint uVar7;
	int iVar8;
	uint uVar9;
	int iVar10;
	char **ppcVar11;
	int iVar12;
	undefined4 *puVar13;
	uint uVar14;
	undefined4 *puVar15;
	float10 fVar16;
	ObjectType local_d8;
	uint local_d4;
	CFGProperty *local_d0;
	int local_cc;
	int local_c8;
	int local_c4;
	char *local_c0 [16];
	char local_80 [128];
	
	uVar14 = 0;
	globals::g_LegoCfgRoot_WeaponTypes = root;
	globals::g_WeaponTypes_COUNT = 0;
	pcVar2 = cfg::CFG_JoinPath(rootPath,"WeaponTypes",0);
	pCVar3 = cfg::CFG_GetChildren(root,pcVar2);
	if (pCVar3 != (CFGProperty *)0x0) {
		do {
			globals::g_WeaponTypes_COUNT = globals::g_WeaponTypes_COUNT + 1;
			pCVar3 = cfg::CFG_NextFlat(pCVar3);
		} while (pCVar3 != (CFGProperty *)0x0);
		globals::g_WeaponTypes_TABLE = (WeaponStats *)std::malloc(globals::g_WeaponTypes_COUNT * 0x4b68)
		;
		if (globals::g_WeaponTypes_TABLE != (WeaponStats *)0x0) {
			if (globals::g_WeaponTypes_COUNT != 0) {
				iVar12 = 0;
				iVar10 = 0;
				do {
					local_d8 = OBJECT_NONE;
					do {
						local_d4 = 0;
						do {
							uVar9 = 0;
							do {
								uVar7 = uVar9 + 1;
								globals::g_WeaponTypes_TABLE->ObjectRatios[local_d8][local_d4][uVar9 + iVar10] =
										 -1.0;
								uVar9 = uVar7;
							} while (uVar7 < 0x10);
							local_d4 = local_d4 + 1;
						} while (local_d4 < 0xf);
						local_d8 = local_d8 + OBJECT_VEHICLE;
					} while (local_d8 < 0x14);
					*(undefined4 *)((int)globals::g_WeaponTypes_TABLE->WallDestroyTimes + iVar12 + -0x20) = 0;
					*(undefined4 *)((int)globals::g_WeaponTypes_TABLE->WallDestroyTimes + iVar12 + -0x14) = 0;
					*(undefined4 *)((int)globals::g_WeaponTypes_TABLE->WallDestroyTimes + iVar12 + -0x10) = 0;
					iVar8 = 0x12;
										// 150.0
					*(undefined4 *)((int)globals::g_WeaponTypes_TABLE->WallDestroyTimes + iVar12 + -4) =
							 0x43160000;
					iVar4 = iVar12 + 0x4b20;
					do {
						iVar8 = iVar8 + -1;
										// 5.0
						*(undefined4 *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar4) = 1084227584;
						iVar4 = iVar4 + 4;
					} while (iVar8 != 0);
					uVar14 = uVar14 + 1;
					iVar10 = iVar10 + 0x12da;
					iVar12 = iVar12 + 0x4b68;
				} while (uVar14 < globals::g_WeaponTypes_COUNT);
			}
			globals::g_WeaponNames_TABLE = (char **)std::malloc(globals::g_WeaponTypes_COUNT * 4);
			if (globals::g_WeaponNames_TABLE != (char **)0x0) {
				pcVar2 = cfg::CFG_JoinPath(rootPath,"WeaponTypes",0);
				local_d0 = cfg::CFG_GetChildren(root,pcVar2);
				if (local_d0 != (CFGProperty *)0x0) {
					iVar10 = 0x4b04;
					local_c8 = 0;
					local_cc = 0;
					local_c4 = 0x4b04;
LAB_0046f010:
					prop = local_d0;
					pcVar2 = cfg::CFG_JoinPath(rootPath,"WeaponTypes",local_d0->key,0);
					pCVar3 = cfg::CFG_GetChildren(root,pcVar2);
joined_r0x0046f044:
					do {
						if (pCVar3 == (CFGProperty *)0x0) goto LAB_0046f2cb;
						iVar12 = std::_stricmp(pCVar3->key,"SlowDeath");
						if (iVar12 == 0) {
							util::Util_Tokenise(pCVar3->value,local_c0,":");
							*(undefined4 *)
							 ((int)globals::g_WeaponTypes_TABLE->ObjectRatios[-1][0xe] + iVar10 + 0x3c) = 1;
							fVar16 = std::atof(local_c0[0]);
							*(float *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10) = (float)fVar16;
							fVar16 = std::atof(local_c0[1]);
							*(float *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10 + 4) =
									 (float)fVar16;
							goto LAB_0046f2b4;
						}
						iVar12 = std::_stricmp(pCVar3->key,"RechargeTime");
						if (iVar12 == 0) {
							fVar16 = std::atof(pCVar3->value);
							*(float *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10 + 8) =
									 (float)fVar16;
							goto LAB_0046f2b4;
						}
						iVar12 = std::_stricmp(pCVar3->key,"DefaultDamage");
						if (iVar12 == 0) {
							fVar16 = std::atof(pCVar3->value);
							*(float *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10 + 0xc) =
									 (float)fVar16;
							goto LAB_0046f2b4;
						}
						iVar12 = std::_stricmp(pCVar3->key,"DischargeRate");
						if (iVar12 == 0) {
							fVar16 = std::atof(pCVar3->value);
							*(float *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10 + 0x10) =
									 (float)fVar16;
							goto LAB_0046f2b4;
						}
						iVar12 = std::_stricmp(pCVar3->key,"WeaponRange");
						if (iVar12 == 0) {
							fVar16 = std::atof(pCVar3->value);
							*(float *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10 + 0x18) =
									 (float)fVar16;
							goto LAB_0046f2b4;
						}
						iVar12 = 0;
						ppcVar11 = globals::g_Game.SurfaceTypes_TABLE;
						do {
							std::sprintf(local_80,"WallDestroyTime_%s",*ppcVar11 + 0x11);
							iVar4 = std::_stricmp(pCVar3->key,local_80);
							if (iVar4 == 0) {
								fVar16 = std::atof(pCVar3->value);
								globals::g_WeaponTypes_TABLE->WallDestroyTimes[iVar12 + local_cc] = (float)fVar16;
								pCVar3 = cfg::CFG_NextFlat(pCVar3);
								break;
							}
							ppcVar11 = ppcVar11 + 1;
							iVar12 = iVar12 + 1;
						} while (ppcVar11 < globals::g_Game.SurfaceTypeDescriptions_name_TABLE);
						prop = local_d0;
						if (iVar12 == 0x12) {
							iVar12 = std::_stricmp(pCVar3->key,"Ammo");
							if (iVar12 == 0) {
								iVar12 = std::atoi(pCVar3->value);
								*(int *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10 + 0x14) = iVar12;
							}
							else {
								*(undefined4 *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10 + 0x14) = 0
								;
								BVar5 = game::Object_GetObjectByName
																	(pCVar3->key,&local_d8,(int *)&local_d4,(Container **)0x0);
								prop = local_d0;
								if (BVar5 == 0) goto joined_r0x0046f044;
								uVar14 = game::Object_GetLevels(local_d8,local_d4);
								util::Util_Tokenise(pCVar3->value,local_c0,":");
								if (uVar14 != 0) {
									ppcVar11 = local_c0;
									uVar9 = 0;
									do {
										fVar16 = std::atof(*ppcVar11);
										ppcVar11 = ppcVar11 + 1;
										uVar7 = uVar9 + 1;
										globals::g_WeaponTypes_TABLE->ObjectRatios[local_d8][local_d4][uVar9 + local_cc]
												 = (float)fVar16;
										iVar10 = local_c4;
										uVar9 = uVar7;
									} while (uVar7 < uVar14);
								}
							}
LAB_0046f2b4:
							pCVar3 = cfg::CFG_NextFlat(pCVar3);
							prop = local_d0;
						}
					} while( true );
				}
LAB_0046f345:
				if (local_d0 == (CFGProperty *)0x0) {
					return 1;
				}
				std::free(globals::g_WeaponNames_TABLE);
			}
			std::free(globals::g_WeaponTypes_TABLE);
		}
	}
	return 0;
LAB_0046f2cb:
	uVar14 = 0xffffffff;
	pcVar2 = prop->key;
	do {
		if (uVar14 == 0) break;
		uVar14 = uVar14 - 1;
		cVar1 = *pcVar2;
		pcVar2 = pcVar2 + 1;
	} while (cVar1 != '\0');
	pvVar6 = std::malloc(~uVar14);
	iVar10 = iVar10 + 0x4b68;
	*(void **)((int)globals::g_WeaponNames_TABLE + local_c8) = pvVar6;
	uVar14 = 0xffffffff;
	puVar13 = (undefined4 *)prop->key;
	do {
		if (uVar14 == 0) break;
		uVar14 = uVar14 - 1;
		cVar1 = *(char *)puVar13;
		puVar13 = (undefined4 *)((int)puVar13 + 1);
	} while (cVar1 != '\0');
	puVar13 = (undefined4 *)prop->key;
	puVar15 = *(undefined4 **)((int)globals::g_WeaponNames_TABLE + local_c8);
	for (uVar9 = ~uVar14 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
		*puVar15 = *puVar13;
		puVar13 = puVar13 + 1;
		puVar15 = puVar15 + 1;
	}
	local_cc = local_cc + 0x12da;
	for (uVar14 = ~uVar14 & 3; uVar14 != 0; uVar14 = uVar14 - 1) {
		*(undefined *)puVar15 = *(undefined *)puVar13;
		puVar13 = (undefined4 *)((int)puVar13 + 1);
		puVar15 = (undefined4 *)((int)puVar15 + 1);
	}
	local_c8 = local_c8 + 4;
	local_c4 = iVar10;
	local_d0 = cfg::CFG_NextFlat(prop);
	if (local_d0 == (CFGProperty *)0x0) goto LAB_0046f345;
	goto LAB_0046f010;
}



// On failure, returns g_WeaponTypes_COUNT

uint __cdecl lego::tools::Weapon_GetWeaponTypeByName(char *weaponName)
{
	int iVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (globals::g_WeaponTypes_COUNT == 0) {
		return 1;
	}
	do {
		iVar1 = std::_stricmp(globals::g_WeaponNames_TABLE[uVar2],weaponName);
		if (iVar1 == 0) {
			return uVar2;
		}
		uVar2 = uVar2 + 1;
	} while (uVar2 < globals::g_WeaponTypes_COUNT);
	return globals::g_WeaponTypes_COUNT + 1;
}



float10 __cdecl lego::tools::Weapon_GetRechargeTime(int weaponType)
{
	return (float10)globals::g_WeaponTypes_TABLE[weaponType].RechargeTime;
}



float10 __cdecl lego::tools::Weapon_GetDischargeRate(int weaponType)
{
	return (float10)globals::g_WeaponTypes_TABLE[weaponType].DischargeRate;
}



float10 __cdecl lego::tools::Weapon_GetWeaponRange(int weaponType)
{
	return (float10)globals::g_WeaponTypes_TABLE[weaponType].WeaponRange;
}



float10 __cdecl lego::tools::Weapon_GetWallDestroyTime(int weaponType,SurfaceType surfaceType)
{
	return (float10)globals::g_WeaponTypes_TABLE[weaponType].WallDestroyTimes[surfaceType];
}



float10 __cdecl lego::game::Weapon_GetDamageForLiveObject(int weaponType,LiveObject *liveObj)
{
	ObjectType OVar1;
	
	OVar1 = liveObj->objType;
	if (globals::g_WeaponTypes_TABLE[weaponType].ObjectRatios
			[OVar1 * 3 + liveObj->objIndex + OVar1 * 0xc][liveObj->objLevel] == -1.0) {
		return (float10)globals::g_WeaponTypes_TABLE[weaponType].DefaultDamage;
	}
	return (float10)globals::g_WeaponTypes_TABLE[weaponType].ObjectRatios[OVar1][liveObj->objIndex]
									[liveObj->objLevel];
}



void __cdecl
lego::game::LiveObject_FUN_0046f530
					(LiveObject *liveObj,int weaponType,BOOL param_3,float param_4,float *param_5)
{
	float fVar1;
	BOOL BVar2;
	float10 fVar3;
	
	fVar3 = Weapon_GetDamageForLiveObject(weaponType,liveObj);
	fVar1 = (float)fVar3;
	if ((liveObj->flags3 & 0x40000) != LIVEOBJ3_NONE) {
		BVar2 = LiveObject_CheckCondition_FUN_00438870(liveObj,1);
		if (BVar2 != 0) {
			if (globals::g_WeaponTypes_TABLE[weaponType].isSlowDeath != 0) {
				if (param_3 != 0) {
					LiveObject_FUN_0043f960
										(liveObj,globals::g_WeaponTypes_TABLE[weaponType].SlowDeath_initial * fVar1,1,
										 param_4);
					fVar1 = globals::g_WeaponTypes_TABLE[weaponType].SlowDeath_duration;
					liveObj->field_35c = weaponType;
					liveObj->field_358 = fVar1;
					LiveObject_FUN_00447c10(liveObj,(Point2F *)param_5,1);
					return;
				}
				LiveObject_FUN_0043f960(liveObj,fVar1 * param_4,1,param_4);
				return;
			}
			if (liveObj->objType == OBJECT_ROCKMONSTER) {
				nerps::NERPs_IncInt_0055632c();
			}
			LiveObject_FUN_0043f960(liveObj,fVar1,1,param_4);
			if (param_3 != 0) {
				LiveObject_FUN_00447c10(liveObj,(Point2F *)param_5,1);
			}
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_0046f640(LiveObject *liveObj,float param_2,int param_3)
{
	LiveObject_FUN_0043f960(liveObj,param_2,1,1.0);
	LiveObject_FUN_00447c10(liveObj,(Point2F *)0x0,param_3);
	return;
}



void __cdecl lego::res::Struct2B0_FUN_0046f670(Struct_2b0 *param_1)
{
	float10 fVar1;
	float10 fVar2;
	float10 fVar3;
	float10 fVar4;
	float local_30;
	float local_2c;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	LiveObject *local_18;
	float local_14;
	Vector3F *local_10;
	VehicleData *local_c;
	CreatureData *local_8;
	CreatureData *local_4;
	
	if (param_1->object_2a4 != (LiveObject *)0x0) {
		local_4 = *(CreatureData **)&param_1->field_0x2a0;
		local_c = (VehicleData *)&local_24;
		local_18 = (LiveObject *)0x0;
		local_14 = 1.0;
		local_8 = (CreatureData *)0x0;
		local_10 = &param_1->position_280;
		fVar1 = tools::Weapon_GetWeaponRange(param_1->weaponType);
		if (fVar1 != (float10)0.0) {
			fVar2 = (float10)(param_1->vector_268).x - (float10)(param_1->vector_274).x;
			fVar3 = (float10)(param_1->vector_268).y - (float10)(param_1->vector_274).y;
			fVar4 = (float10)(param_1->vector_268).z - (float10)(param_1->vector_274).z;
			local_2c = (float)fVar3;
			local_28 = (float)fVar4;
			if (fVar1 <= SQRT(fVar4 * (float10)local_28 + fVar3 * (float10)local_2c + fVar2 * fVar2)) {
				pool::ReservedPool_LiveObject___Release(param_1->object_2a4);
				param_1->object_2a4 = (LiveObject *)0x0;
				return;
			}
		}
		local_24 = (param_1->vector_274).x - (param_1->position_280).x;
		local_20 = (param_1->vector_274).y - (param_1->position_280).y;
		local_1c = (param_1->vector_274).z - (param_1->position_280).z;
		unk::DoLiveObjCallbacks_True_FUN_00437a70
							(game::LiveObject_Callback_FUN_00471630,(LiveObject *)&local_18);
		FUN_004718f0(&local_18);
		if (local_8 != (CreatureData *)0x0) {
			pool::ReservedPool_LiveObject___Release(param_1->object_2a4);
			param_1->object_2a4 = (LiveObject *)0x0;
			if (local_18 != (LiveObject *)0x0) {
				local_30 = (float)local_c->objIndex * local_14 + local_10->x;
				local_2c = local_10->y + (float)local_c->WheelNullName * local_14;
				local_28 = local_10->z + (float)local_c->aeResData1 * local_14;
				game::LiveObject_FUN_0046fa30
									(local_18,(int **)&param_1->vector_290,&local_30,(int *)param_1->weaponType,
									 param_1->field_2ac);
			}
		}
	}
	return;
}



void __cdecl lego::res::Struct2B0_Table_FUN_0046f810(float elapsedGame)
{
	Struct_2b0 *pSVar1;
	ItemStruct_34 *pIVar2;
	
	pSVar1 = globals::g_Struct2B0Unk_TABLE;
	do {
		if (pSVar1->object_2a4 != (LiveObject *)0x0) {
			Struct2B0_FUN_0046fbe0(pSVar1,elapsedGame);
		}
		pSVar1 = pSVar1 + 1;
	} while (pSVar1 < &globals::g_LegoCfgRoot_WeaponTypes);
	unk::DoLiveObjCallbacks_True_FUN_00437a70
						(game::LiveObject_Callback_FUN_0046f8d0,(LiveObject *)&elapsedGame);
	pSVar1 = globals::g_Struct2B0Unk_TABLE;
	do {
		Struct2B0_FUN_0046f670(pSVar1);
		pSVar1 = pSVar1 + 1;
	} while (pSVar1 < &globals::g_LegoCfgRoot_WeaponTypes);
	pIVar2 = globals::g_ItemStruct34Unk_TABLE;
	do {
		if (*(Mesh **)pIVar2 != (Mesh *)0x0) {
			if (*(float *)&((Struct_2b0 *)pIVar2)->field_0xc < 0.0) {
				Mesh_Remove(*(Mesh **)pIVar2,
										*(IDirect3DRMFrame3 **)(*(int *)&((Struct_2b0 *)pIVar2)->field_0x8 + 4));
				Mesh_Remove(*(Mesh **)&((Struct_2b0 *)pIVar2)->field_0x4,
										*(IDirect3DRMFrame3 **)(*(int *)&((Struct_2b0 *)pIVar2)->field_0x8 + 4));
				*(Mesh **)pIVar2 = (Mesh *)0x0;
			}
			*(float *)&((Struct_2b0 *)pIVar2)->field_0xc =
					 *(float *)&((Struct_2b0 *)pIVar2)->field_0xc - elapsedGame;
		}
		pIVar2 = (ItemStruct_34 *)((int)pIVar2 + 0x10);
	} while (pIVar2 < globals::g_Struct2B0Unk_TABLE);
	return;
}



BOOL __cdecl lego::game::LiveObject_Callback_FUN_0046f8d0(LiveObject *liveObj,float *lpElapsed)
{
	float fVar1;
	void *pvVar2;
	Container *cont;
	uint uVar3;
	float10 fVar4;
	float10 fVar5;
	Container *opt_ref;
	uint uVar6;
	Vector3F *out_pos;
	Vector3F local_c;
	
	if ((ushort)((ushort)((float)liveObj->field_360 < 0.0) << 8 |
							(ushort)((float)liveObj->field_360 == 0.0) << 0xe) == 0) {
		liveObj->field_360 = (float)liveObj->field_360 - *lpElapsed;
	}
	pvVar2 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
	if (pvVar2 != (void *)0x0) {
		uVar3 = 0;
		pvVar2 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
		if (*(int *)((int)pvVar2 + 0xa4) != 0) {
			do {
				fVar4 = LiveObject_PtrGetter_FUN_004715b0(liveObj,uVar3);
				if ((ushort)((ushort)(fVar4 < (float10)0.0) << 8 | (ushort)(fVar4 == (float10)0.0) << 0xe)
						== 0) {
					uVar6 = uVar3;
					fVar5 = LiveObject_PtrGetter_FUN_004715b0(liveObj,uVar3);
					LiveObject_PtrSetter_FUN_004715d0(liveObj,(float)(fVar5 - (float10)*lpElapsed),uVar6);
					fVar5 = snd::Sample_GetRandomDuration(0x1d);
					fVar1 = (float)(fVar5 * (float10)25.0 * (float10)globals::g_Game.gameSpeed);
					fVar5 = LiveObject_PtrGetter_FUN_004715b0(liveObj,uVar3);
					if ((fVar5 < (float10)fVar1) &&
						 ((ushort)((ushort)((float)fVar4 < fVar1) << 8 | (ushort)((float)fVar4 == fVar1) << 0xe)
							== 0)) {
						out_pos = &local_c;
						opt_ref = (Container *)0x0;
						cont = LiveObject_GetResource(liveObj);
						res::Container_GetPosition(cont,opt_ref,out_pos);
						res::Res_PlayResourceSound((Container *)0x0,SFX_LAZERRECHARGE,0,0,&local_c);
					}
				}
				uVar3 = uVar3 + 1;
				pvVar2 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
			} while (uVar3 < *(uint *)((int)pvVar2 + 0xa4));
		}
	}
	if ((ushort)((ushort)((float)liveObj->field_358 < 0.0) << 8 |
							(ushort)((float)liveObj->field_358 == 0.0) << 0xe) == 0) {
		LiveObject_FUN_0046f530(liveObj,liveObj->field_35c,0,*lpElapsed,(float *)0x0);
		liveObj->field_358 = (float)liveObj->field_358 - *lpElapsed;
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_FUN_0046fa30
					(LiveObject *liveObj,int **param_2,undefined4 *param_3,int *param_4,int param_5)
{
	BOOL BVar1;
	ObjectStatsFlags2 OVar2;
	float10 fVar3;
	float10 fVar4;
	Point2F local_8;
	
	local_8.x = (float)*param_2;
	local_8.y = (float)param_2[1];
	BVar1 = LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj);
	if (BVar1 != 0) {
		FUN_0040bd40((Vector3F *)param_3);
	}
	if (param_5 == 1) {
		OVar2 = LiveObject_GetStatsFlags2(liveObj);
		if ((OVar2 & STATS2_CANLASER) != STATS2_NONE) {
			fVar3 = LiveObject_GetLaserDamage(liveObj);
			LiveObject_FUN_0046f640(liveObj,(float)fVar3,1);
		}
		if (param_3 != (undefined4 *)0x0) {
			FUN_0040cc10(0,param_3,(undefined4 *)0x0);
		}
	}
	else {
		if (param_5 == 2) {
			OVar2 = LiveObject_GetStatsFlags2(liveObj);
			if ((OVar2 & STATS2_CANPUSH) != STATS2_NONE) {
				fVar3 = LiveObject_GetPusherDist(liveObj);
				fVar4 = LiveObject_GetPusherDamage(liveObj);
				local_8.x = local_8.x * 1.5;
				local_8.y = local_8.y * 1.5;
				LiveObject_FUN_0046f640(liveObj,(float)fVar4,1);
				LiveObject_Unk_AndSetVector3B4(liveObj,&local_8,(float)fVar3);
			}
			if (param_3 != (undefined4 *)0x0) {
				FUN_0040cc10(1,param_3,(undefined4 *)0x0);
				return;
			}
		}
		else {
			if (param_5 != 3) {
				LiveObject_FUN_0046f530(liveObj,(int)param_4,1,0.0,(float *)&local_8);
				return;
			}
			param_2 = (int **)0x41200000;
			OVar2 = LiveObject_GetStatsFlags2(liveObj);
			if ((OVar2 & STATS2_CANFREEZE) != STATS2_NONE) {
				fVar3 = LiveObject_GetFreezerTime(liveObj);
				if ((ushort)((ushort)(fVar3 < (float10)0.0) << 8 | (ushort)(fVar3 == (float10)0.0) << 0xe)
						== 0) {
					param_2 = (int **)(float)fVar3;
				}
				fVar3 = LiveObject_GetFreezerDamage(liveObj);
				LiveObject_FUN_0046f640(liveObj,(float)fVar3,0);
				FUN_0044c2f0((int *)liveObj,(float)param_2);
			}
			if (param_3 != (undefined4 *)0x0) {
				FUN_0040cc10(2,param_3,(undefined4 *)0x0);
				return;
			}
		}
	}
	return;
}



void __cdecl lego::res::Struct2B0_FUN_0046fbe0(Struct_2b0 *param_1,float elapsed)
{
	float fVar1;
	float dirx;
	Container *cont;
	float fVar2;
	float local_14;
	float local_10;
	float local_8;
	
	cont = game::LiveObject_GetResource(param_1->object_2a4);
	Container_GetPosition(cont,(Container *)0x0,&param_1->position_280);
	fVar2 = param_1->float_28c * elapsed;
	if (*(int *)param_1 == 0) {
		local_8 = (param_1->vector_290).y * fVar2;
		fVar1 = (param_1->vector_290).z;
		(param_1->vector_274).x = (param_1->vector_290).x * fVar2 + (param_1->vector_274).x;
		(param_1->vector_274).y = (param_1->vector_274).y + local_8;
		(param_1->vector_274).z = (param_1->vector_274).z + fVar1 * fVar2;
		Container_SetPosition
							(cont,(Container *)0x0,(param_1->vector_274).x,(param_1->vector_274).y,
							 (param_1->vector_274).z);
		fVar2 = (param_1->vector_290).z;
		fVar1 = (param_1->vector_290).y;
		dirx = (param_1->vector_290).x;
	}
	else {
		fVar2 = fVar2 + param_1->float_264;
		param_1->float_264 = fVar2;
		FUN_004067f0((uint *)&param_1->field_0x4,fVar2,&local_14);
		fVar2 = (param_1->vector_290).y;
		(param_1->vector_274).x = (param_1->vector_290).x * local_14 + (param_1->vector_268).x;
		(param_1->vector_274).y = (param_1->vector_268).y + fVar2 * local_14;
		(param_1->vector_274).z = (param_1->vector_268).z + local_10;
		Container_SetPosition
							(cont,(Container *)0x0,(param_1->vector_274).x,(param_1->vector_274).y,
							 (param_1->vector_274).z);
		fVar2 = ((param_1->vector_274).z - (param_1->position_280).z) * 0.25;
		fVar1 = (param_1->vector_274).y - (param_1->position_280).y;
		dirx = (param_1->vector_274).x - (param_1->position_280).x;
	}
	Container_SetOrientation(cont,(Container *)0x0,dirx,fVar1,fVar2,0.0,0.0,-1.0);
	return;
}



BOOL __cdecl
FUN_0046fdb0(LiveObject *liveObj,float *param_2,float *param_3,uint weaponType,uint param_5)
{
	Vector3F *pVVar1;
	float fVar2;
	float fVar3;
	uint uVar4;
	uint uVar5;
	BOOL BVar6;
	int iVar7;
	LiveObject *pLVar8;
	
	uVar5 = param_5;
	uVar4 = weaponType;
	pLVar8 = liveObj;
	if (param_5 == 1) {
		lego::game::LiveObject_Weapon_FUN_004375c0(liveObj,weaponType,1.0);
	}
	FUN_004701b0(uVar5,&weaponType,(int *)&param_5);
	BVar6 = lego::game::Object_GetTypeResource(weaponType,param_5,(Container **)&liveObj);
	if (BVar6 != 0) {
		iVar7 = lego::unk::Lego_GetNextIndex_Struct2b0_TABLE_00504bc0();
		if (iVar7 != -1) {
			*(undefined4 *)(lego::globals::g_Struct2B0Unk_TABLE + iVar7) = 0;
			lego::globals::g_Struct2B0Unk_TABLE[iVar7].weaponType = uVar4;
			lego::globals::g_Struct2B0Unk_TABLE[iVar7].field_2ac = uVar5;
			lego::globals::g_Struct2B0Unk_TABLE[iVar7].vector_274.x = *param_2;
			lego::globals::g_Struct2B0Unk_TABLE[iVar7].vector_274.y = param_2[1];
			lego::globals::g_Struct2B0Unk_TABLE[iVar7].vector_274.z = param_2[2];
			lego::globals::g_Struct2B0Unk_TABLE[iVar7].vector_268.x = *param_2;
			lego::globals::g_Struct2B0Unk_TABLE[iVar7].vector_268.y = param_2[1];
			fVar3 = param_2[2];
			lego::globals::g_Struct2B0Unk_TABLE[iVar7].float_28c = 5.0;
			lego::globals::g_Struct2B0Unk_TABLE[iVar7].vector_268.z = fVar3;
			pVVar1 = &lego::globals::g_Struct2B0Unk_TABLE[iVar7].vector_290;
			pVVar1->x = *param_3;
			lego::globals::g_Struct2B0Unk_TABLE[iVar7].vector_290.y = param_3[1];
			lego::globals::g_Struct2B0Unk_TABLE[iVar7].vector_290.z = param_3[2];
			fVar3 = lego::globals::g_Struct2B0Unk_TABLE[iVar7].vector_290.y;
			fVar2 = lego::globals::g_Struct2B0Unk_TABLE[iVar7].vector_290.z;
			fVar3 = 1.0 / SQRT(pVVar1->x * pVVar1->x + fVar2 * fVar2 + fVar3 * fVar3);
			pVVar1->x = pVVar1->x * fVar3;
			lego::globals::g_Struct2B0Unk_TABLE[iVar7].vector_290.y =
					 fVar3 * lego::globals::g_Struct2B0Unk_TABLE[iVar7].vector_290.y;
			lego::globals::g_Struct2B0Unk_TABLE[iVar7].vector_290.z =
					 fVar3 * lego::globals::g_Struct2B0Unk_TABLE[iVar7].vector_290.z;
			*(LiveObject **)&lego::globals::g_Struct2B0Unk_TABLE[iVar7].field_0x2a0 = pLVar8;
			*(undefined4 *)&lego::globals::g_Struct2B0Unk_TABLE[iVar7].field_0x29c = 0;
			pLVar8 = lego::game::Game_CreateLiveResourceObject
												 ((Container *)liveObj,weaponType,param_5,0,*param_2,param_2[1],0.0);
			lego::globals::g_Struct2B0Unk_TABLE[iVar7].object_2a4 = pLVar8;
			lego::res::Struct2B0_FUN_0046fbe0(lego::globals::g_Struct2B0Unk_TABLE + iVar7,0.0);
			return 1;
		}
	}
	return 0;
}



undefined4 __cdecl
FUN_0046ff30(undefined4 param_1,float *param_2,float *param_3,int param_4,undefined4 param_5)
{
	float fVar1;
	float fVar2;
	float fVar3;
	BOOL BVar4;
	int iVar5;
	LiveObject *pLVar6;
	float10 fVar7;
	int local_2c;
	ObjectType local_28;
	Container *local_24;
	float local_20;
	undefined4 local_1c;
	float local_18;
	undefined4 local_14;
	float local_10;
	float local_c;
	float local_8;
	undefined4 local_4;
	
	local_8 = 0.0;
	local_4 = 0;
	local_18 = 1.0;
	local_14 = 0xbfa66666;
	local_20 = 0.3;
	local_1c = 0x3f800000;
	FUN_004701b0(param_5,&local_28,&local_2c);
	BVar4 = lego::game::Object_GetTypeResource(local_28,local_2c,&local_24);
	if (BVar4 != 0) {
		iVar5 = lego::unk::Lego_GetNextIndex_Struct2b0_TABLE_00504bc0();
		if (iVar5 != -1) {
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].field_2ac = param_5;
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].weaponType = param_4;
			*(undefined4 *)(lego::globals::g_Struct2B0Unk_TABLE + iVar5) = 1;
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_268.x = *param_2;
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_268.y = param_2[1];
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_268.z = param_2[2];
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_274.x = *param_2;
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_274.y = param_2[1];
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_274.z = param_2[2];
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.x = *param_3 - *param_2;
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.y = param_3[1] - param_2[1];
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.z = param_3[2] - param_2[2];
			fVar1 = lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.y;
			fVar2 = lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.z;
			fVar3 = lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.x;
			fVar2 = 1.0 / SQRT(fVar3 * fVar3 + fVar2 * fVar2 + fVar1 * fVar1);
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.x =
					 lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.x * fVar2;
			fVar1 = lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.z;
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.y =
					 fVar2 * lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.y;
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.z = fVar2 * fVar1;
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].float_28c = 4.0;
			local_c = param_3[2] - param_2[2];
			fVar1 = SQRT((*param_2 - *param_3) * (*param_2 - *param_3) +
									 (param_2[2] - param_3[2]) * (param_2[2] - param_3[2]) +
									 (param_2[1] - param_3[1]) * (param_2[1] - param_3[1]));
			local_10 = fVar1;
			FUN_00406690(&local_18,fVar1 * 0.2);
			FUN_00406690(&local_20,fVar1 * 0.3333333);
			FUN_00406750((uint *)&lego::globals::g_Struct2B0Unk_TABLE[iVar5].field_0x4,&local_8,&local_18,
									 &local_10,&local_20,0x32);
			fVar7 = FUN_004066e0((uint *)&lego::globals::g_Struct2B0Unk_TABLE[iVar5].field_0x4);
			*(float *)&lego::globals::g_Struct2B0Unk_TABLE[iVar5].field_0x260 = (float)fVar7;
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].float_264 = 0.0;
			*(undefined4 *)&lego::globals::g_Struct2B0Unk_TABLE[iVar5].field_0x2a0 = param_1;
			*(undefined4 *)&lego::globals::g_Struct2B0Unk_TABLE[iVar5].field_0x29c = 0;
			pLVar6 = lego::game::Game_CreateLiveResourceObject
												 (local_24,local_28,local_2c,0,*param_2,param_2[1],0.0);
			lego::globals::g_Struct2B0Unk_TABLE[iVar5].object_2a4 = pLVar6;
			lego::res::Struct2B0_FUN_0046fbe0(lego::globals::g_Struct2B0Unk_TABLE + iVar5,0.0);
			return 1;
		}
	}
	return 0;
}



void __cdecl FUN_004701b0(undefined4 param_1,ObjectType *out_objType,int *out_objIndex)
{
	switch(param_1) {
	case 1:
		*out_objType = OBJECT_LASERSHOT;
		*out_objIndex = 0;
		return;
	case 2:
		*out_objType = OBJECT_PUSHER;
		*out_objIndex = 0;
		return;
	case 3:
		*out_objType = OBJECT_FREEZER;
		*out_objIndex = 0;
		return;
	case 4:
		*out_objType = OBJECT_BOULDER;
		*out_objIndex = 0;
	}
	return;
}



int __cdecl lego::unk::Lego_GetNextIndex_Struct2b0_TABLE_00504bc0(void)
{
	int iVar1;
	LiveObject **ppLVar2;
	
	iVar1 = 0;
	ppLVar2 = &globals::g_Struct2B0Unk_TABLE[0].object_2a4;
	do {
		if (*ppLVar2 == (LiveObject *)0x0) {
			return iVar1;
		}
		ppLVar2 = ppLVar2 + 0xac;
		iVar1 = iVar1 + 1;
	} while (ppLVar2 < globs::s_FormatPartName_name + 0x2a0);
	return -1;
}



int __cdecl lego::res::ItemStruct34_GetTableCount(void)
{
	int iVar1;
	ItemStruct_34 *pIVar2;
	
	iVar1 = 0;
	pIVar2 = globals::g_ItemStruct34Unk_TABLE;
	do {
		if (*(int *)pIVar2 == 0) {
			return iVar1;
		}
		pIVar2 = (ItemStruct_34 *)((int)pIVar2 + 0x10);
		iVar1 = iVar1 + 1;
	} while (pIVar2 < globals::g_Struct2B0Unk_TABLE);
	return -1;
}



int ** __cdecl
FUN_00470270(int **param_1,int **param_2,int *param_3,float param_4,float param_5,int param_6,
						float param_7)
{
	TerrainType TVar1;
	int **ppiVar2;
	int *liveObj;
	int weaponType;
	Container *resData;
	SurfaceMap *surfMap;
	BOOL BVar3;
	uint uVar4;
	LevelData *level;
	float10 fVar5;
	float in_x;
	float in_y;
	int *in_x_00;
	Vector3F *opt_position;
	int *in_y_00;
	Point2F *pPVar6;
	Vector3F *vector2;
	float *out_y;
	float local_24;
	Point2F local_20;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	opt_position = (Vector3F *)param_1;
	local_24 = 1.0;
	param_1 = (int **)0x0;
	lego::res::Res_PlayResourceSound((Container *)0x0,SFX_LASER,0,0,opt_position);
	liveObj = param_3;
	ppiVar2 = param_2;
	local_18 = param_5 * (float)*param_2;
	local_14 = param_5 * (float)param_2[1];
	local_10 = (float)param_2[2] * param_5;
	FUN_00471b20(opt_position,&local_18,&param_1,&local_24,param_3);
	local_18 = local_24 * local_18;
	local_14 = local_24 * local_14;
	local_10 = local_24 * local_10;
	local_c.x = local_18 + (float)*(int **)opt_position;
	local_c.y = (float)*(int **)((int)opt_position + 4) + local_14;
	local_c.z = (float)*(int **)((int)opt_position + 8) + local_10;
	vector2 = &local_c;
	resData = lego::game::LiveObject_GetResource((LiveObject *)liveObj);
	lego::res::ItemStruct34_FUN_00470950(resData,opt_position,vector2);
	weaponType = param_6;
	if ((param_1 != (int **)0x0) || (1.0 <= local_24)) {
		if (param_1 != (int **)0x0) {
			FUN_0040cc10(0,(undefined4 *)&local_c,(undefined4 *)0x0);
			lego::res::Res_PlayResourceSound((Container *)0x0,SFX_LASERHIT,0,0,&local_c);
			if (param_1 != (int **)0x0) {
				if ((liveObj == (int *)0x0) || (*liveObj != 2)) {
					pPVar6 = (Point2F *)0x0;
				}
				else {
					local_20.x = (float)*ppiVar2;
					local_20.y = (float)ppiVar2[1];
					pPVar6 = &local_20;
				}
				lego::game::LiveObject_FUN_00447c10((LiveObject *)param_1,pPVar6,1);
			}
		}
	}
	else {
		FUN_0040bd40(&local_c);
		lego::res::Res_PlayResourceSound((Container *)0x0,SFX_LASERHIT,0,0,&local_c);
		out_y = &local_20.y;
		pPVar6 = &local_20;
		in_x = local_c.x;
		in_y = local_c.y;
		surfMap = lego::game::GetSurfaceMap();
		lego::game::SurfaceMap_ToBlockCoordinatesNoZ(surfMap,in_x,in_y,(int *)pPVar6,(int *)out_y);
		BVar3 = lego::game::Level_GetBlockFlags1_10Not8((uint)local_20.x,(uint)local_20.y);
		if (BVar3 != 0) {
			uVar4 = lego::game::Level_IsBlockSolid((Point2I *)&local_20);
			if ((uVar4 == 0) &&
				 (TVar1 = (lego::globals::g_Game.level)->blocks
									[(int)(((lego::globals::g_Game.level)->dimensions).width * (int)local_20.y +
												(int)local_20.x)].terrain, TVar1 != TERRAIN_RECHARGESEAM)) {
				fVar5 = lego::tools::Weapon_GetWallDestroyTime(weaponType,(uint)TVar1);
				param_5 = (float)fVar5;
				BVar3 = lego::game::Level_GetBlockUnkField14Test
													((int)local_20.x,(int)local_20.y,param_5,param_4);
				if (BVar3 != 0) {
					BVar3 = 0;
					in_x_00 = (int *)local_20.x;
					in_y_00 = (int *)local_20.y;
					level = lego::game::GetLevel();
					lego::game::Level_DestroyWall(level,(int)in_x_00,(int)in_y_00,BVar3);
				}
				goto LAB_004704fa;
			}
		}
		BVar3 = lego::game::Level_IsBlockPowerPath((Point2I *)&local_20);
		if (BVar3 != 0) {
			lego::ai::AITask_DoClearTypeAction((Point2I *)&local_20,MESSAGE_CLEARREMOVEPATH_COMPLETE);
			lego::game::Level_UpdateBlockSurfaceUnk
								(lego::globals::g_Game.level,(int)local_20.x,(int)local_20.y);
		}
	}
LAB_004704fa:
	lego::game::LiveObject_Weapon_FUN_004375c0((LiveObject *)liveObj,weaponType,param_7);
	return param_1;
}



void __cdecl FUN_00470520(undefined4 *param_1,float *param_2,float *param_3,int param_4)
{
	ObjectStatsFlags1 OVar1;
	
	OVar1 = lego::game::LiveObject_GetStatsFlags1((LiveObject *)param_1);
	if ((OVar1 & STATS1_COLLBOX) != STATS1_NONE) {
		FUN_00470570(param_1,param_2,param_3,(float *)0x0,param_4);
		return;
	}
	FUN_00470800(param_1,param_2,param_3,param_4);
	return;
}



undefined4 __cdecl
FUN_00470570(undefined4 *param_1,float *param_2,float *param_3,float *param_4,int param_5)
{
	float fVar1;
	ushort uVar2;
	Container *cont;
	int iVar3;
	float *pfVar4;
	Point2F *pPVar5;
	Vector3F *out_vector;
	Point2F *pPVar6;
	uint uVar7;
	Point2F local_78;
	Point2F local_70;
	Point2F local_68;
	Point2F local_60;
	Point2F local_58;
	float local_50 [6];
	float local_38;
	float local_34;
	Vector3F local_30;
	float local_24;
	undefined4 local_20;
	float local_1c;
	float local_18;
	undefined4 local_14;
	float local_10;
	float local_c;
	undefined4 local_8;
	float local_4;
	
	cont = lego::game::LiveObject_GetResource((LiveObject *)param_1);
	local_68.x = *param_2;
	local_68.y = param_2[1];
	local_70.x = *param_3;
	local_70.y = param_3[1];
	if ((param_5 != 0) &&
		 (iVar3 = FUN_004708f0(param_1,(float *)&local_68,(float *)&local_70), iVar3 != 0)) {
		return 0;
	}
	pfVar4 = (float *)lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
	local_30.x = *pfVar4 * -0.5;
	iVar3 = lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
	local_30.z = *(float *)(iVar3 + 4) * 0.5;
	pfVar4 = (float *)lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
	local_24 = *pfVar4 * 0.5;
	iVar3 = lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
	local_1c = *(float *)(iVar3 + 4) * 0.5;
	pfVar4 = (float *)lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
	local_18 = *pfVar4 * 0.5;
	iVar3 = lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
	local_10 = *(float *)(iVar3 + 4) * -0.5;
	pfVar4 = (float *)lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
	local_c = *pfVar4 * -0.5;
	iVar3 = lego::game::LiveObject_GetCollBox((LiveObject *)param_1);
	local_4 = *(float *)(iVar3 + 4) * -0.5;
	local_8 = 0;
	local_14 = 0;
	local_20 = 0;
	local_30.y = 0.0;
	pPVar6 = &local_58;
	out_vector = &local_30;
	iVar3 = 4;
	do {
		lego::res::Container_Transform(cont,out_vector,out_vector);
		fVar1 = out_vector->y;
		pPVar6->x = out_vector->x;
		pPVar6->y = fVar1;
		out_vector = out_vector + 1;
		pPVar6 = pPVar6 + 1;
		iVar3 = iVar3 + -1;
	} while (iVar3 != 0);
	local_38 = local_58.x;
	local_34 = local_58.y;
	uVar7 = 0;
	pPVar6 = &local_58;
	do {
		local_60.x = pPVar6->x - pPVar6[1].x;
		local_60.y = pPVar6->y - pPVar6[1].y;
		pPVar5 = lego::math::Maths_Vector2DIntersection(&local_78,&local_68,&local_70,pPVar6,&local_60);
		if (pPVar5 != (Point2F *)0x0) {
			if (ABS(pPVar6->x - pPVar6[1].x) <= ABS(pPVar6->y - pPVar6[1].y)) {
				if (((ushort)((ushort)(local_78.y < pPVar6->y) << 8 |
										 (ushort)(local_78.y == pPVar6->y) << 0xe) == 0) && (local_78.y < pPVar6[1].y))
				goto LAB_004707ca;
				if (local_78.y < pPVar6->y) {
					uVar2 = (ushort)(local_78.y < pPVar6[1].y) << 8 |
									(ushort)(local_78.y == pPVar6[1].y) << 0xe;
					goto joined_r0x004707b1;
				}
			}
			else {
				if (((ushort)((ushort)(local_78.x < pPVar6->x) << 8 |
										 (ushort)(local_78.x == pPVar6->x) << 0xe) == 0) && (local_78.x < pPVar6[1].x))
				goto LAB_004707ca;
				if (local_78.x < pPVar6->x) {
					uVar2 = (ushort)(local_78.x < pPVar6[1].x) << 8 |
									(ushort)(local_78.x == pPVar6[1].x) << 0xe;
joined_r0x004707b1:
					if (uVar2 == 0) {
LAB_004707ca:
						if (param_4 != (float *)0x0) {
							*param_4 = local_78.x;
							param_4[1] = local_78.y;
						}
						return 1;
					}
				}
			}
		}
		uVar7 = uVar7 + 1;
		pPVar6 = pPVar6 + 1;
		if (3 < uVar7) {
			return 0;
		}
	} while( true );
}



undefined4 __cdecl FUN_00470800(undefined4 *param_1,float *param_2,float *param_3,int param_4)
{
	int iVar1;
	float10 fVar2;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	float local_18;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	local_28 = *param_2;
	local_24 = param_2[1];
	local_20 = *param_3;
	local_1c = param_3[1];
	if ((param_4 != 0) && (iVar1 = FUN_004708f0(param_1,&local_28,&local_20), iVar1 != 0)) {
		return 0;
	}
	local_10 = local_20 + local_28;
	local_c = local_1c + local_24;
	lego::game::LiveObject_GetPosition((LiveObject *)param_1,&local_18,&local_14);
	FUN_00408a90(&local_28,&local_10,&local_18,&local_8);
	fVar2 = lego::game::LiveObject_GetCollRadius((LiveObject *)param_1);
	if (fVar2 <= (float10)SQRT((local_4 - local_14) * (local_4 - local_14) +
														 (local_8 - local_18) * (local_8 - local_18))) {
		return 0;
	}
	return 1;
}



undefined4 __cdecl FUN_004708f0(undefined4 *param_1,float *param_2,float *param_3)
{
	float local_8;
	float local_4;
	
	lego::game::LiveObject_GetPosition((LiveObject *)param_1,&local_8,&local_4);
	if ((local_8 - *param_2) * *param_3 + (local_4 - param_2[1]) * param_3[1] < 0.0) {
		return 1;
	}
	return 0;
}



void __cdecl
lego::res::ItemStruct34_FUN_00470950(Container *resData,Vector3F *vector1,Vector3F *vector2)
{
	int iVar1;
	Mesh *pMVar2;
	
	iVar1 = ItemStruct34_GetTableCount();
	if (iVar1 != -1) {
		pMVar2 = Mesh_CreateOnFrame(resData->activityFrame,(MeshRenderCallback *)0x0,0x4400,(void *)0x0,
																0);
		globals::g_ItemStruct34Unk_TABLE[iVar1].struct34_1 = pMVar2;
		pMVar2 = Mesh_CreateOnFrame(resData->activityFrame,(MeshRenderCallback *)0x0,0x4400,(void *)0x0,
																0);
		globals::g_ItemStruct34Unk_TABLE[iVar1].struct34_2 = pMVar2;
		Struct34_FUN_00470a20
							(globals::g_ItemStruct34Unk_TABLE[iVar1].struct34_1,0.3,vector1,vector2,0.6,0.6,0.6,
							 1.0);
		Struct34_FUN_00470a20
							(globals::g_ItemStruct34Unk_TABLE[iVar1].struct34_2,1.0,vector1,vector2,0.1,0.2,0.5,
							 1.0);
		globals::g_ItemStruct34Unk_TABLE[iVar1].resData = resData;
		globals::g_ItemStruct34Unk_TABLE[iVar1].time = 5.0;
	}
	return;
}



void __cdecl
lego::res::Struct34_FUN_00470a20
					(Mesh *param_1,float scalar,Vector3F *vector1,Vector3F *vector2,float param_5,
					float param_6,float param_7,float param_8)
{
	float *pfVar1;
	float *pfVar2;
	float *pfVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	float fVar9;
	float fVar10;
	float fVar11;
	float fVar12;
	float fVar13;
	Vector3F *pVVar14;
	D3DRMGroupIndex groupID;
	uint uVar15;
	uint uVar16;
	float local_404;
	float local_400;
	uint local_3e0;
	undefined4 local_3dc;
	undefined4 local_3d8;
	undefined4 local_3d4;
	undefined4 local_3d0;
	undefined4 local_3cc;
	undefined4 local_3c8;
	undefined4 local_3c4;
	undefined4 local_3c0;
	undefined4 local_3bc;
	undefined4 local_3b8;
	undefined4 local_3b4;
	undefined4 local_3b0;
	undefined4 local_3ac;
	undefined4 local_3a8;
	undefined4 local_3a4;
	undefined4 local_3a0;
	undefined4 local_39c;
	undefined4 local_398;
	undefined4 local_394;
	undefined4 local_390;
	undefined4 local_38c;
	undefined4 local_388;
	undefined4 local_384;
	undefined4 local_380;
	undefined4 local_37c;
	undefined4 local_378;
	undefined4 local_374;
	undefined4 local_370;
	undefined4 local_36c;
	undefined4 local_368;
	undefined4 local_364;
	undefined4 local_360;
	undefined4 local_35c;
	undefined4 local_358;
	undefined4 local_354;
	undefined4 local_350;
	undefined4 local_34c;
	undefined4 local_348;
	undefined4 local_344;
	undefined4 local_340;
	undefined4 local_33c;
	undefined4 local_338;
	undefined4 local_334;
	undefined4 local_330;
	undefined4 local_32c;
	undefined4 local_328;
	undefined4 local_324;
	Point2F local_320;
	undefined4 local_318;
	undefined4 local_314;
	undefined4 local_310;
	undefined4 local_30c;
	undefined4 local_308;
	undefined4 local_304;
	undefined4 local_300;
	undefined4 local_2fc;
	undefined4 local_2f8;
	undefined4 local_2f4;
	undefined4 local_2f0;
	undefined4 local_2ec;
	undefined4 local_2e8;
	undefined4 local_2e4;
	undefined4 local_2e0;
	undefined4 local_2dc;
	undefined4 local_2d8;
	undefined4 local_2d4;
	undefined4 local_2d0;
	undefined4 local_2cc;
	undefined4 local_2c8;
	undefined4 local_2c4;
	undefined4 local_2c0;
	undefined4 local_2bc;
	undefined4 local_2b8;
	undefined4 local_2b4;
	undefined4 local_2b0;
	undefined4 local_2ac;
	undefined4 local_2a8;
	undefined4 local_2a4;
	undefined4 local_2a0;
	undefined4 local_29c;
	undefined4 local_298;
	undefined4 local_294;
	undefined4 local_290;
	undefined4 local_28c;
	undefined4 local_288;
	undefined4 local_284;
	undefined4 local_280;
	undefined4 local_27c;
	undefined4 local_278;
	undefined4 local_274;
	undefined4 local_270;
	undefined4 local_26c;
	undefined4 local_268;
	undefined4 local_264;
	undefined4 local_260;
	undefined4 local_25c;
	undefined4 local_258;
	undefined4 local_254;
	undefined4 local_250;
	undefined4 local_24c;
	undefined4 local_248;
	undefined4 local_244;
	undefined4 local_240;
	undefined4 local_23c;
	undefined4 local_238;
	undefined4 local_234;
	undefined4 local_230;
	undefined4 local_22c;
	undefined4 local_228;
	undefined4 local_224;
	undefined4 local_220;
	undefined4 local_21c;
	undefined4 local_218;
	undefined4 local_214;
	undefined4 local_210;
	undefined4 local_20c;
	undefined4 local_208;
	undefined4 local_204;
	undefined4 local_200;
	undefined4 local_1fc;
	undefined4 local_1f8;
	undefined4 local_1f4;
	undefined4 local_1f0;
	undefined4 local_1ec;
	undefined4 local_1e8;
	undefined4 local_1e4;
	undefined4 local_1e0;
	undefined4 local_1dc;
	undefined4 local_1d8;
	undefined4 local_1d4;
	undefined4 local_1d0;
	undefined4 local_1cc;
	undefined4 local_1c8;
	undefined4 local_1c4;
	undefined4 local_1c0;
	undefined4 local_1bc;
	undefined4 local_1b8;
	undefined4 local_1b4;
	undefined4 local_1b0;
	undefined4 local_1ac;
	undefined4 local_1a8;
	undefined4 local_1a4;
	undefined4 local_1a0;
	undefined4 local_19c;
	undefined4 local_198;
	undefined4 local_194;
	undefined4 local_190;
	undefined4 local_18c;
	undefined4 local_188;
	undefined4 local_184;
	undefined4 local_180;
	undefined4 local_17c;
	undefined4 local_178;
	undefined4 local_174;
	undefined4 local_170;
	undefined4 local_16c;
	undefined4 local_168;
	undefined4 local_164;
	undefined4 local_160;
	undefined4 local_15c;
	undefined4 local_158;
	undefined4 local_154;
	undefined4 local_150;
	undefined4 local_14c;
	undefined4 local_148;
	undefined4 local_144;
	undefined4 local_140;
	undefined4 local_13c;
	undefined4 local_138;
	undefined4 local_134;
	undefined4 local_130;
	undefined4 local_12c;
	undefined4 local_128;
	undefined4 local_124;
	Vector3F local_120;
	float local_114;
	float local_110;
	float local_10c;
	float local_108;
	float local_104;
	float local_100;
	float local_fc;
	float local_f8;
	float local_f4;
	float local_f0;
	float local_ec;
	float local_e8;
	float local_e4;
	float local_e0;
	float local_dc;
	float local_d8;
	float local_d4;
	float local_d0;
	float local_cc;
	float local_c8;
	float local_c4;
	float afStack192 [24];
	Vector3F local_60 [8];
	
	local_320.y = 1.0;
	local_310 = 0x3f800000;
	local_308 = 0x3f800000;
	local_304 = 0x3f800000;
	local_2fc = 0x3f800000;
	local_2f0 = 0x3f800000;
	local_2e8 = 0x3f800000;
	local_2e4 = 0x3f800000;
	local_2dc = 0x3f800000;
	local_2d0 = 0x3f800000;
	local_2c8 = 0x3f800000;
	local_2c4 = 0x3f800000;
	local_2bc = 0x3f800000;
	local_2b0 = 0x3f800000;
	local_2a8 = 0x3f800000;
	local_2a4 = 0x3f800000;
	local_29c = 0x3f800000;
	local_290 = 0x3f800000;
	local_288 = 0x3f800000;
	local_284 = 0x3f800000;
	local_27c = 0x3f800000;
	local_270 = 0x3f800000;
	local_268 = 0x3f800000;
	local_264 = 0x3f800000;
	local_25c = 0x3f800000;
	local_250 = 0x3f800000;
	local_248 = 0x3f800000;
	local_244 = 0x3f800000;
	local_23c = 0x3f800000;
	local_230 = 0x3f800000;
	local_228 = 0x3f800000;
	local_224 = 0x3f800000;
	local_21c = 0x3f800000;
	local_210 = 0x3f800000;
	local_208 = 0x3f800000;
	local_204 = 0x3f800000;
	local_1fc = 0x3f800000;
	local_320.x = 0.0;
	local_318 = 0;
	local_314 = 0;
	local_30c = 0;
	local_300 = 0;
	local_2f8 = 0;
	local_2f4 = 0;
	local_2ec = 0;
	local_2e0 = 0;
	local_2d8 = 0;
	local_2d4 = 0;
	local_2cc = 0;
	local_2c0 = 0;
	local_2b8 = 0;
	local_2b4 = 0;
	local_2ac = 0;
	local_2a0 = 0;
	local_298 = 0;
	local_294 = 0;
	local_28c = 0;
	local_280 = 0;
	local_278 = 0;
	local_274 = 0;
	local_26c = 0;
	local_260 = 0;
	local_258 = 0;
	local_254 = 0;
	local_24c = 0;
	local_240 = 0;
	local_238 = 0;
	local_234 = 0;
	local_22c = 0;
	local_220 = 0;
	local_218 = 0;
	local_214 = 0;
	local_20c = 0;
	local_200 = 0;
	local_1f8 = 0;
	local_1f4 = 0;
	local_1f0 = 0x3f800000;
	local_1e8 = 0x3f800000;
	local_1e4 = 0x3f800000;
	local_1dc = 0x3f800000;
	local_1d0 = 0x3f800000;
	local_1c8 = 0x3f800000;
	local_1c4 = 0x3f800000;
	local_1bc = 0x3f800000;
	local_1b0 = 0x3f800000;
	local_1a8 = 0x3f800000;
	local_1a4 = 0x3f800000;
	local_19c = 0x3f800000;
	local_190 = 0x3f800000;
	local_188 = 0x3f800000;
	local_184 = 0x3f800000;
	local_17c = 0x3f800000;
	local_170 = 0x3f800000;
	local_168 = 0x3f800000;
	local_164 = 0x3f800000;
	local_15c = 0x3f800000;
	local_150 = 0x3f800000;
	local_148 = 0x3f800000;
	local_144 = 0x3f800000;
	local_13c = 0x3f800000;
	local_130 = 0x3f800000;
	local_128 = 0x3f800000;
	local_124 = 0x3f800000;
	local_3dc = 1;
	local_3d8 = 9;
	local_3d4 = 9;
	local_3c8 = 1;
	local_3c0 = 10;
	local_3bc = 10;
	local_3b8 = 9;
	local_3b4 = 1;
	local_3a0 = 10;
	local_1ec = 0;
	local_1e0 = 0;
	local_1d8 = 0;
	local_1d4 = 0;
	local_1cc = 0;
	local_1c0 = 0;
	local_1b8 = 0;
	local_1b4 = 0;
	local_1ac = 0;
	local_1a0 = 0;
	local_198 = 0;
	local_194 = 0;
	local_18c = 0;
	local_180 = 0;
	local_178 = 0;
	local_174 = 0;
	local_16c = 0;
	local_160 = 0;
	local_158 = 0;
	local_154 = 0;
	local_14c = 0;
	local_140 = 0;
	local_138 = 0;
	local_134 = 0;
	local_12c = 0;
	local_3e0 = 0;
	local_3d0 = 8;
	local_3cc = 0;
	local_3c4 = 2;
	local_3b0 = 2;
	local_3ac = 3;
	local_3a8 = 0xb;
	local_3a4 = 0xb;
	local_39c = 2;
	local_398 = 3;
	local_394 = 4;
	local_384 = 3;
	local_390 = 0xc;
	local_38c = 0xc;
	local_370 = 0xc;
	local_378 = 0xd;
	local_374 = 0xd;
	local_358 = 0xd;
	local_360 = 0xe;
	local_35c = 0xe;
	local_340 = 0xe;
	local_348 = 0xf;
	local_344 = 0xf;
	local_328 = 0xf;
	local_388 = 0xb;
	fVar6 = vector2->x - vector1->x;
	fVar7 = vector2->y - vector1->y;
	fVar5 = vector2->z - vector1->z;
	local_380 = 4;
	local_36c = 4;
	local_37c = 5;
	local_368 = 5;
	local_364 = 6;
	local_354 = 5;
	local_350 = 6;
	local_34c = 7;
	local_33c = 6;
	local_338 = 7;
	local_334 = 0;
	local_330 = 8;
	local_32c = 8;
	local_324 = 7;
	fVar4 = 1.0 / SQRT(fVar5 * fVar5 + fVar7 * fVar7 + fVar6 * fVar6);
	fVar7 = fVar4 * fVar7;
	fVar5 = fVar4 * fVar5;
	if ((fVar7 == 0.0) && (fVar5 == 0.0)) {
		local_400 = 1.0;
		local_404 = 0.0;
	}
	else {
		if (fVar7 == 0.0) {
			local_404 = 1.0;
			local_400 = 0.0;
		}
		else {
			local_400 = SQRT(1.0 / ((fVar5 * fVar5) / (fVar7 * fVar7) - -1.0));
			local_404 = -((fVar5 / fVar7) * local_400);
		}
	}
	fVar8 = local_404 * scalar;
	fVar9 = local_400 * scalar;
	fVar5 = (local_400 * fVar7 - local_404 * fVar5) * scalar;
	fVar7 = -(local_400 * fVar4 * fVar6) * scalar;
	fVar6 = local_404 * fVar4 * fVar6 * scalar;
	fVar12 = fVar8 * 0.4142136;
	fVar4 = fVar5 * 0.4142136;
	fVar10 = fVar7 * 0.4142136;
	fVar11 = fVar6 * 0.4142136;
	fVar13 = fVar9 * 0.4142136;
	local_120.x = fVar4 + 0.0;
	local_120.y = fVar8 + fVar10;
	local_120.z = fVar9 + fVar11;
	local_114 = fVar5 + 0.0;
	local_110 = fVar7 + fVar12;
	local_10c = fVar6 + fVar13;
	local_108 = fVar5 + -0.0;
	local_104 = fVar7 + -fVar12;
	local_100 = fVar6 + -fVar13;
	local_fc = fVar4 - 0.0;
	local_f8 = fVar10 - fVar8;
	local_f4 = fVar11 - fVar9;
	local_f0 = -0.0 - fVar4;
	local_ec = -fVar8 - fVar10;
	local_e8 = -fVar9 - fVar11;
	local_e4 = -0.0 - fVar5;
	local_e0 = -fVar12 - fVar7;
	local_dc = -fVar13 - fVar6;
	local_d8 = 0.0 - fVar5;
	local_d4 = fVar12 - fVar7;
	local_d0 = fVar13 - fVar6;
	local_cc = 0.0 - fVar4;
	local_c8 = fVar8 - fVar10;
	local_c4 = fVar9 - fVar11;
	pVVar14 = &local_120;
	uVar15 = 0;
	do {
		fVar4 = vector2->x;
		pfVar3 = (float *)((int)&local_60[0].z + uVar15);
		fVar5 = pVVar14->x;
		fVar6 = pVVar14->y;
		*(float *)((int)&local_60[0].x + uVar15) = pVVar14->x;
		pfVar1 = &pVVar14->y;
		fVar7 = pVVar14->z;
		uVar16 = uVar15 + 0xc;
		*(float *)((int)&local_60[0].y + uVar15) = fVar6;
		pfVar2 = &pVVar14->z;
		*pfVar3 = fVar7;
		fVar7 = *(float *)((int)&local_60[0].y + uVar15);
		fVar6 = *(float *)((int)&local_60[0].x + uVar15);
		fVar8 = *pfVar3;
		*(float *)((int)afStack192 + uVar15) = fVar4 + fVar5;
		fVar9 = 1.0 / SQRT(fVar6 * fVar6 + fVar8 * fVar8 + fVar7 * fVar7);
		*(float *)((int)afStack192 + uVar15 + 4) = *pfVar1 + vector2->y;
		fVar4 = vector1->x;
		pVVar14[8].z = *pfVar2 + vector2->z;
		fVar5 = *(float *)((int)&local_60[0].x + uVar15);
		pVVar14->x = fVar4 + pVVar14->x;
		fVar4 = *(float *)((int)&local_60[0].y + uVar15);
		fVar6 = *pfVar3;
		*pfVar1 = *pfVar1 + vector1->y;
		fVar7 = *pfVar2;
		fVar8 = vector1->z;
		*(float *)((int)&local_60[0].x + uVar15) = fVar9 * fVar5;
		*(float *)((int)&local_60[0].y + uVar15) = fVar9 * fVar4;
		*pfVar3 = fVar9 * fVar6;
		*pfVar2 = fVar7 + fVar8;
		pVVar14 = pVVar14 + 1;
		uVar15 = uVar16;
	} while (uVar16 < 0x60);
	groupID = Mesh_AddGroup(param_1,0x10,0x10,3,&local_3e0);
	Mesh_SetGroupColour(param_1,groupID,param_5,param_6,param_7,MATERIAL_EMISSIVE);
	Mesh_SetGroupMaterialValues(param_1,groupID,param_8,MATERIAL_ALPHA);
	Mesh_SetVertices_SameNormal(param_1,groupID,0,0x10,&local_120,local_60,&local_320);
	return;
}



void * __cdecl lego::game::LiveObject_GetBuildingVehicleFields_138_a0(LiveObject *liveObj)
{
	if (liveObj->objType == OBJECT_VEHICLE) {
		return (void *)&liveObj->vehicle->field_0x138;
	}
	if (liveObj->objType != OBJECT_BUILDING) {
		return (void *)0x0;
	}
	return (void *)&liveObj->building->field_0xa0;
}



float10 __cdecl lego::game::LiveObject_PtrGetter_FUN_004715b0(LiveObject *liveObj,int param_2)
{
	void *pvVar1;
	
	pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
	return (float10)*(float *)((int)pvVar1 + param_2 * 4 + 0x98);
}



void __cdecl
lego::game::LiveObject_PtrSetter_FUN_004715d0(LiveObject *liveObj,undefined4 param_2,int param_3)
{
	void *pvVar1;
	
	pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
	*(undefined4 *)((int)pvVar1 + param_3 * 4 + 0x98) = param_2;
	return;
}



BOOL __cdecl FUN_004715f0(int param_1,int param_2,float param_3,float param_4,float param_5)
{
	float fVar1;
	
	fVar1 = *(float *)(param_2 + 8) * param_5 + *(float *)(param_1 + 8);
	if (((ushort)((ushort)(fVar1 < param_4) << 8 | (ushort)(fVar1 == param_4) << 0xe) != 0) &&
		 (param_4 - param_3 <= fVar1)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_Callback_FUN_00471630(LiveObject *liveObj,LiveObject *param_2)
{
	float fVar1;
	LiveObject *pLVar2;
	SurfaceMap *surfMap;
	BOOL BVar3;
	float10 fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	LiveObject *pLVar9;
	float local_28;
	char *local_24;
	float local_20;
	float local_1c;
	float local_18;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pLVar2 = param_2;
	local_8 = *(float *)param_2->customName;
	local_4 = *(float *)((int)param_2->customName + 4);
	local_28 = (float)param_2->vehicle->objIndex;
	local_24 = param_2->vehicle->WheelNullName;
	fVar1 = SQRT((float)local_24 * (float)local_24 + local_28 * local_28);
	if ((liveObj != (LiveObject *)param_2->rockMonster) &&
		 (((ushort)((ushort)(fVar1 < -1e-05) << 8 | (ushort)(fVar1 == -1e-05) << 0xe) != 0 ||
			(1e-05 <= fVar1)))) {
		LiveObject_GetPosition(liveObj,&local_18,&local_14);
		fVar5 = local_18;
		fVar7 = local_14;
		surfMap = GetSurfaceMap();
		fVar4 = SurfaceMap_GetSurfaceZ(surfMap,fVar5,fVar7);
		fVar5 = (float)fVar4;
		FUN_00408b20(&local_8,&local_28,&local_18,&local_10);
		local_18 = local_10 - local_18;
		local_14 = local_c - local_14;
		fVar4 = LiveObject_GetCollRadius(liveObj);
		if ((float10)SQRT(local_14 * local_14 + local_18 * local_18) <= fVar4) {
			local_20 = local_10 - local_8;
			local_1c = local_c - local_4;
			fVar7 = SQRT(local_1c * local_1c + local_20 * local_20);
			if (((ushort)((ushort)(fVar7 < -1e-05) << 8 | (ushort)(fVar7 == -1e-05) << 0xe) == 0) &&
				 (fVar7 < 1e-05)) {
				fVar8 = 0.0;
				fVar6 = fVar5;
				fVar4 = LiveObject_GetCollHeight(liveObj);
				BVar3 = FUN_004715f0((int)param_2->customName,(int)param_2->vehicle,(float)fVar4,fVar6,fVar8
														);
				if (BVar3 != 0) {
					param_2->objType = (ObjectType)liveObj;
					param_2->objIndex = 0;
					param_2->miniFigure = (CreatureData *)0x1;
					return 0;
				}
			}
			param_2 = (LiveObject *)(fVar7 / fVar1);
			if (((((ushort)((ushort)(local_28 < -1e-05) << 8 | (ushort)(local_28 == -1e-05) << 0xe) != 0)
					 || (1e-05 <= local_28)) ||
					((ushort)((ushort)(local_20 < -1e-05) << 8 | (ushort)(local_20 == -1e-05) << 0xe) != 0))
				 || (1e-05 <= local_20)) {
				fVar1 = local_28 / local_20;
			}
			else {
				if ((((ushort)((ushort)((float)local_24 < -1e-05) << 8 |
											(ushort)((float)local_24 == -1e-05) << 0xe) == 0) && ((float)local_24 < 1e-05)
						) && (((ushort)((ushort)(local_1c < -1e-05) << 8 | (ushort)(local_1c == -1e-05) << 0xe)
									 == 0 && (local_1c < 1e-05)))) {
					return 0;
				}
				fVar1 = (float)local_24 / local_1c;
			}
			if (fVar1 < 0.0) {
				param_2 = (LiveObject *)((float)param_2 * -1.0);
			}
			if (((ushort)((ushort)((float)param_2 < 0.0) << 8 | (ushort)((float)param_2 == 0.0) << 0xe) ==
					 0) && ((float)param_2 < (float)pLVar2->objIndex)) {
				pLVar9 = param_2;
				fVar4 = LiveObject_GetCollHeight(liveObj);
				BVar3 = FUN_004715f0((int)pLVar2->customName,(int)pLVar2->vehicle,(float)fVar4,fVar5,
														 (float)pLVar9);
				if (BVar3 != 0) {
					pLVar2->objType = (ObjectType)liveObj;
					pLVar2->objIndex = (int)param_2;
					pLVar2->miniFigure = (CreatureData *)0x1;
				}
			}
		}
	}
	return 0;
}



void __cdecl FUN_004718f0(undefined4 *param_1)
{
	float *pfVar1;
	float *pfVar2;
	SurfaceMap *pSVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	uint uVar9;
	float fVar10;
	float fVar11;
	Vector3F *pVVar12;
	uint *puVar13;
	uint *puVar14;
	Vector3F *pVVar15;
	Vector3F *out_vector;
	uint local_34;
	uint local_30;
	uint local_2c;
	uint local_28;
	float local_24;
	float local_20;
	float local_1c;
	Vector3F local_18;
	float local_8;
	float local_4;
	
	lego::game::GetSurfaceMap();
	lego::game::GetSurfaceMap();
	puVar13 = &local_28;
	pfVar1 = (float *)param_1[3];
	pfVar2 = (float *)param_1[2];
	local_18.x = *pfVar1 + *pfVar2;
	local_18.y = pfVar2[1] + pfVar1[1];
	local_18.z = pfVar2[2] + pfVar1[2];
	puVar14 = &local_30;
	fVar11 = pfVar2[1];
	fVar10 = *pfVar2;
	pSVar3 = lego::game::GetSurfaceMap();
	BVar4 = lego::game::SurfaceMap_ToBlockCoordinatesNoZ
										(pSVar3,fVar10,fVar11,(int *)puVar13,(int *)puVar14);
	if (BVar4 == 0) {
		pSVar3 = lego::game::GetSurfaceMap();
		if ((uint)(pSVar3->smallDimensions).width <= local_28) {
			pSVar3 = lego::game::GetSurfaceMap();
			local_28 = (pSVar3->smallDimensions).width - 1;
		}
		pSVar3 = lego::game::GetSurfaceMap();
		if ((uint)(pSVar3->smallDimensions).height <= local_30) {
			pSVar3 = lego::game::GetSurfaceMap();
			local_30 = (pSVar3->smallDimensions).height - 1;
		}
	}
	puVar13 = &local_34;
	puVar14 = &local_2c;
	fVar11 = local_18.x;
	fVar10 = local_18.y;
	pSVar3 = lego::game::GetSurfaceMap();
	BVar4 = lego::game::SurfaceMap_ToBlockCoordinatesNoZ
										(pSVar3,fVar11,fVar10,(int *)puVar14,(int *)puVar13);
	if (BVar4 == 0) {
		pSVar3 = lego::game::GetSurfaceMap();
		if ((uint)(pSVar3->smallDimensions).width <= local_2c) {
			pSVar3 = lego::game::GetSurfaceMap();
			local_2c = (pSVar3->smallDimensions).width - 1;
		}
		pSVar3 = lego::game::GetSurfaceMap();
		if ((uint)(pSVar3->smallDimensions).height <= local_34) {
			pSVar3 = lego::game::GetSurfaceMap();
			local_34 = (pSVar3->smallDimensions).height - 1;
		}
	}
	uVar6 = local_2c;
	uVar5 = local_34;
	if (local_2c < local_28) {
		local_2c = local_28;
		local_28 = uVar6;
	}
	if (local_34 < local_30) {
		local_34 = local_30;
		local_30 = uVar5;
	}
	uVar5 = local_34;
	uVar6 = local_2c;
	uVar7 = local_28;
	uVar8 = local_30;
	if (local_28 <= local_2c) {
		do {
			uVar9 = uVar8;
			if (uVar8 <= uVar5) {
				do {
					pVVar15 = (Vector3F *)param_1[3];
					pVVar12 = (Vector3F *)param_1[2];
					out_vector = &local_18;
					uVar5 = uVar7;
					uVar6 = uVar8;
					pSVar3 = lego::game::GetSurfaceMap();
					BVar4 = lego::game::SurfaceMap_FUN_004518a0(pSVar3,uVar5,uVar6,pVVar12,pVVar15,out_vector)
					;
					if (BVar4 != 0) {
						pfVar1 = (float *)param_1[2];
						pfVar2 = (float *)param_1[3];
						local_8 = local_18.y - pfVar1[1];
						local_4 = local_18.z - pfVar1[2];
						local_24 = pfVar2[2];
						local_20 = *pfVar2;
						local_1c = SQRT(local_20 * local_20 + local_24 * local_24 + pfVar2[1] * pfVar2[1]);
						fVar11 = SQRT(local_4 * local_4 +
													local_8 * local_8 + (local_18.x - *pfVar1) * (local_18.x - *pfVar1)) /
										 local_1c;
						if (fVar11 < (float)param_1[1]) {
							param_1[1] = fVar11;
							param_1[4] = 1;
							*param_1 = 0;
						}
					}
					uVar8 = uVar8 + 1;
					uVar5 = local_34;
					uVar6 = local_2c;
					uVar9 = local_30;
				} while (uVar8 <= local_34);
			}
			uVar7 = uVar7 + 1;
			uVar8 = uVar9;
		} while (uVar7 <= uVar6);
	}
	return;
}



CreatureData * __cdecl
FUN_00471b20(char *param_1,VehicleData *param_2,undefined4 *param_3,undefined4 *param_4,
						CreatureData *param_5)
{
	ObjectType local_18;
	int local_14;
	char *local_10;
	VehicleData *local_c;
	CreatureData *local_8;
	CreatureData *local_4;
	
	local_18 = OBJECT_NONE;
	local_8 = (CreatureData *)0x0;
	local_14 = *param_4;
	local_10 = param_1;
	local_c = param_2;
	local_4 = param_5;
	lego::unk::DoLiveObjCallbacks_True_FUN_00437a70
						(lego::game::LiveObject_Callback_FUN_00471630,(LiveObject *)&local_18);
	FUN_004718f0(&local_18);
	*param_4 = local_14;
	*param_3 = local_18;
	return local_8;
}



BOOL __cdecl lego::game::LiveObject_FUN_00471b90(LiveObject *liveObj1,LiveObject *liveObj2)
{
	LiveObject *pLVar1;
	LiveObject *pLVar2;
	int iVar3;
	undefined4 local_28;
	float local_24;
	float local_20;
	float local_1c;
	float local_18;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pLVar1 = liveObj1;
	local_28 = 0x3f800000;
	LiveObject_GetCollWriteToParam2_FUN_00471f60(liveObj1,(int)&local_24);
	pLVar2 = liveObj2;
	LiveObject_GetCollWriteToParam2_FUN_00471f60(liveObj2,(int)&local_18);
	local_c = local_18 - local_24;
	local_8 = local_14 - local_20;
	local_4 = local_10 - local_1c;
	iVar3 = FUN_00471b20(&local_24,&local_c,&liveObj1,&local_28,pLVar1);
	if ((iVar3 != 0) && (liveObj1 != pLVar2)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_SeeThroughWalls_FUN_00471c20(LiveObject *liveObj,LiveObject *liveObj2)
{
	LevelData *pLVar1;
	BOOL3 BVar2;
	char *pcVar3;
	undefined4 uVar4;
	float local_3c;
	float local_38;
	float local_34;
	float local_30;
	float local_2c;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	float *local_10;
	float *local_c;
	BOOL local_8;
	undefined4 local_4;
	
	local_10 = &local_3c;
	local_c = &local_24;
	uVar4 = 0;
	pcVar3 = "SeeThroughWalls";
	local_18 = 0;
	local_14 = 0x3f800000;
	local_8 = 0;
	local_4 = 0;
	pLVar1 = GetLevel();
	pcVar3 = cfg::CFG_JoinPath(globals::g_Game.CfgRootName,pLVar1->levelName,pcVar3,uVar4);
	BVar2 = cfg::CFG_ReadBool(globals::g_LegoCfgRoot_WeaponTypes,pcVar3);
	if (BVar2 != BOOL3_FALSE) {
		return 0;
	}
	LiveObject_GetCollWriteToParam2_FUN_00471f60(liveObj,(int)&local_3c);
	LiveObject_GetCollWriteToParam2_FUN_00471f60(liveObj2,(int)&local_30);
	local_24 = local_30 - local_3c;
	local_20 = local_2c - local_38;
	local_1c = local_28 - local_34;
	FUN_004718f0(&local_18);
	return local_8;
}



undefined4 __cdecl lego::unk::UnkStruct_Getter_FUN_00471ce0(int param_1,int param_2,int param_3)
{
	return *(undefined4 *)(param_1 + param_2 * 8 + param_3 * 4);
}



undefined4 __cdecl lego::unk::UnkStruct_Getter_FUN_00471d00(int param_1,int param_2)
{
	return *(undefined4 *)(param_1 + 0x18 + param_2 * 4);
}



undefined4 __cdecl lego::unk::UnkStruct_Getter_FUN_00471d10(int param_1,int param_2)
{
	return *(undefined4 *)(param_1 + 0x24 + param_2 * 4);
}



void __cdecl
lego::unk::UnkStruct_FUN_00471d20
					(int param_1,undefined4 *param_2,float param_3,int param_4,int param_5)
{
	int iVar1;
	undefined4 *puVar2;
	float fVar3;
	float fVar4;
	Container *cont;
	Container *cont_00;
	Vector3F local_c;
	
	if (param_4 != 0) {
		puVar2 = (undefined4 *)(param_1 + 0x68 + param_5 * 0xc);
		*puVar2 = *param_2;
		puVar2[1] = param_2[1];
		puVar2[2] = param_2[2];
	}
	cont = (Container *)UnkStruct_Getter_FUN_00471d00(param_1,param_5);
	if ((cont != (Container *)0x0) &&
		 ((ushort)((ushort)(param_3 < 1e-05) << 8 | (ushort)(param_3 == 1e-05) << 0xe) == 0)) {
		res::Container_GetPosition(cont,(Container *)0x0,&local_c);
		fVar3 = 5.0 / param_3;
		iVar1 = param_1 + param_5 * 0xc;
		local_c.x = *(float *)(iVar1 + 0x68) - local_c.x;
		local_c.y = *(float *)(iVar1 + 0x6c) - local_c.y;
		local_c.z = *(float *)(iVar1 + 0x70) - local_c.z;
		fVar4 = 1.0 / SQRT(local_c.z * local_c.z + local_c.y * local_c.y + local_c.x * local_c.x);
		*(float *)(iVar1 + 0x44) = *(float *)(iVar1 + 0x44) * fVar3;
		*(float *)(iVar1 + 0x48) = *(float *)(iVar1 + 0x48) * fVar3;
		*(float *)(iVar1 + 0x4c) = *(float *)(iVar1 + 0x4c) * fVar3;
		*(float *)(iVar1 + 0x44) = fVar4 * local_c.x + *(float *)(iVar1 + 0x44);
		*(float *)(iVar1 + 0x48) = fVar4 * local_c.y + *(float *)(iVar1 + 0x48);
		*(float *)(iVar1 + 0x4c) = fVar4 * local_c.z + *(float *)(iVar1 + 0x4c);
		fVar3 = 1.0 / SQRT(*(float *)(iVar1 + 0x44) * *(float *)(iVar1 + 0x44) +
											 *(float *)(iVar1 + 0x4c) * *(float *)(iVar1 + 0x4c) +
											 *(float *)(iVar1 + 0x48) * *(float *)(iVar1 + 0x48));
		*(float *)(iVar1 + 0x44) = *(float *)(iVar1 + 0x44) * fVar3;
		*(float *)(iVar1 + 0x48) = fVar3 * *(float *)(iVar1 + 0x48);
		*(float *)(iVar1 + 0x4c) = fVar3 * *(float *)(iVar1 + 0x4c);
		if ((ushort)((ushort)(*(float *)(iVar1 + 0x4c) < *(float *)(param_1 + 0x30)) << 8 |
								(ushort)(*(float *)(iVar1 + 0x4c) == *(float *)(param_1 + 0x30)) << 0xe) == 0) {
			*(undefined4 *)(iVar1 + 0x4c) = *(undefined4 *)(param_1 + 0x30);
		}
		cont_00 = (Container *)UnkStruct_Getter_FUN_00471d10(param_1,param_5);
		if (cont_00 != (Container *)0x0) {
			res::Container_SetOrientation
								(cont_00,(Container *)0x0,*(float *)(iVar1 + 0x44),
								 *(float *)(param_1 + (param_5 + 6) * 0xc),0.0,0.0,0.0,-1.0);
		}
		res::Container_SetOrientation
							(cont,(Container *)0x0,*(float *)(iVar1 + 0x44),
							 *(float *)(param_1 + (param_5 + 6) * 0xc),*(float *)(iVar1 + 0x4c),0.0,0.0,-1.0);
	}
	return;
}



void __cdecl FUN_00471f30(int param_1,undefined4 *param_2,int param_3)
{
	undefined4 *puVar1;
	
	puVar1 = (undefined4 *)(param_1 + 0x44 + param_3 * 0xc);
	*param_2 = *puVar1;
	param_2[1] = puVar1[1];
	param_2[2] = puVar1[2];
	return;
}



BOOL __cdecl
lego::game::LiveObject_GetCollWriteToParam2_FUN_00471f60(LiveObject *liveObj,int param_2)
{
	Container *cont;
	float10 fVar1;
	
	cont = LiveObject_GetResource(liveObj);
	res::Container_GetPosition(cont,(Container *)0x0,(Vector3F *)param_2);
	fVar1 = LiveObject_GetCollHeight(liveObj);
	*(float *)(param_2 + 8) = (float)((float10)*(float *)(param_2 + 8) - fVar1 * (float10)0.5);
	return 1;
}



BOOL __cdecl lego::game::LiveObject_UnkTracker_FUN_00471fa0(LiveObject *liveObj)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	
	OVar1 = LiveObject_GetStatsFlags2(liveObj);
	if ((OVar1 & STATS2_TRACKER) != STATS2_NONE) {
		BVar2 = LiveObject_CheckCondition_FUN_00438870
											(liveObj,(uint)(liveObj->objType != OBJECT_BUILDING));
		if (BVar2 != 0) {
			return 1;
		}
	}
	return 0;
}



undefined4 __cdecl FUN_00471fe0(int *param_1,float param_2,float param_3)
{
	int *liveObj;
	float fVar1;
	void *pvVar2;
	uint uVar3;
	uint mouseX;
	Container *cont;
	LiveObject *liveObj_00;
	float10 fVar4;
	Vector3F *pVVar5;
	float fVar6;
	int iVar7;
	int **ppiVar8;
	float fVar9;
	int *piVar10;
	int *local_34;
	float local_30;
	int *local_2c;
	undefined4 local_28;
	int *local_24;
	undefined4 local_20;
	Vector3F local_18;
	Vector3F local_c;
	
	fVar1 = param_3;
	liveObj = param_1;
	lego::game::Game_GetVector_45c(&local_18);
	pVVar5 = &local_18;
	iVar7 = 1;
	fVar6 = param_2;
	fVar9 = param_3;
	pvVar2 = lego::game::LiveObject_GetBuildingVehicleFields_138_a0((LiveObject *)param_1);
	lego::unk::UnkStruct_FUN_00471d20((int)pvVar2,(undefined4 *)pVVar5,fVar6,iVar7,(int)fVar9);
	iVar7 = lego::input::Input_GetBool_0076bb3c();
	if (((iVar7 != 0) && ((lego::globals::g_Game.flags2 & GAME2_MOUSE_INSIDEGAMEVIEW) != GAME2_NONE))
		 && (fVar4 = lego::game::LiveObject_PtrGetter_FUN_004715b0((LiveObject *)param_1,(int)param_3),
				(ushort)((ushort)(fVar4 < (float10)0.0) << 8 | (ushort)(fVar4 == (float10)0.0) << 0xe) != 0)
		 ) {
		ppiVar8 = &local_34;
		uVar3 = lego::input::Input_GetMousePositionY();
		mouseX = lego::input::Input_GetMousePositionX();
		iVar7 = FUN_0043b620(mouseX,uVar3,ppiVar8);
		if ((iVar7 == 0) || (local_34 != param_1)) {
			param_1 = (int *)0x0;
			do {
				iVar7 = lego::game::Level_GetCrystalCount(1);
				if (iVar7 != 0) {
					fVar6 = fVar1;
					piVar10 = param_1;
					pvVar2 = lego::game::LiveObject_GetBuildingVehicleFields_138_a0((LiveObject *)liveObj);
					cont = (Container *)
								 lego::unk::UnkStruct_Getter_FUN_00471ce0((int)pvVar2,(int)fVar6,(int)piVar10);
					if (cont == (Container *)0x0) {
						return 1;
					}
					pvVar2 = lego::game::LiveObject_GetBuildingVehicleFields_138_a0((LiveObject *)liveObj);
					uVar3 = lego::tools::Weapon_GetWeaponTypeByName
														(*(char **)(*(int *)((int)pvVar2 + (int)fVar1 * 4 + 0x8c) + 0xc));
					fVar4 = lego::tools::Weapon_GetWeaponRange(uVar3);
					local_30 = (float)fVar4;
					fVar4 = lego::game::LiveObject_GetFunctionCoef((LiveObject *)liveObj);
					param_3 = (float)fVar4;
					if (fVar4 == (float10)0.0) {
						param_3 = 1.0;
					}
					if (param_1 == (int *)0x0) {
						fVar6 = fVar1;
						fVar4 = lego::tools::Weapon_GetRechargeTime(uVar3);
						lego::game::LiveObject_PtrSetter_FUN_004715d0
											((LiveObject *)liveObj,(float)fVar4,(int)fVar6);
						ppiVar8 = &local_24;
						fVar6 = fVar1;
						pvVar2 = lego::game::LiveObject_GetBuildingVehicleFields_138_a0((LiveObject *)liveObj);
						FUN_00471f30((int)pvVar2,ppiVar8,(int)fVar6);
						lego::snd::Audio_FUN_00428730(0);
					}
					lego::res::Container_GetPosition(cont,(Container *)0x0,&local_c);
					liveObj_00 = (LiveObject *)
											 FUN_00470270((int **)&local_c,&local_24,liveObj,param_2,local_30,uVar3,
																		param_3);
					if (liveObj_00 != (LiveObject *)0x0) {
						local_2c = local_24;
						local_28 = local_20;
						lego::game::LiveObject_FUN_0046f530(liveObj_00,uVar3,1,0.0,(float *)&local_2c);
						liveObj[0xf1] = (int)liveObj_00;
					}
				}
				param_1 = (int *)((int)param_1 + 1);
			} while (param_1 < (int *)0x2);
		}
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_FUN_004721c0(LiveObject *liveObj,float param_2,int param_3)
{
	Container *cont;
	void *pvVar1;
	float *pfVar2;
	int iVar3;
	Vector3F local_30;
	Vector3F local_24;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	cont = LiveObject_GetResource(liveObj);
	if (cont != (Container *)0x0) {
		res::Container_GetOrientation(cont,(Container *)0x0,&local_30,&local_c);
		res::Container_GetPosition(cont,(Container *)0x0,&local_24);
		local_30.x = local_30.x * 10000.0;
		pfVar2 = &local_18;
		local_30.y = local_30.y * 10000.0;
		iVar3 = 1;
		local_30.z = local_30.z * 10000.0;
		local_18 = local_30.x + local_24.x;
		local_14 = local_30.y + local_24.y;
		local_10 = local_30.z + local_24.z;
		pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
		unk::UnkStruct_FUN_00471d20((int)pvVar1,pfVar2,param_2,iVar3,param_3);
	}
	return 1;
}



BOOL __cdecl FUN_00472280(int *param_1,float param_2)
{
	void *pvVar1;
	float fVar2;
	uint uVar3;
	
	if ((*(byte *)(param_1 + 0xfb) & 1) == 0) {
		uVar3 = 0;
		pvVar1 = lego::game::LiveObject_GetBuildingVehicleFields_138_a0((LiveObject *)param_1);
		if (*(int *)((int)pvVar1 + 0xa4) != 0) {
			do {
				lego::game::LiveObject_FUN_004721c0((LiveObject *)param_1,param_2,uVar3);
				uVar3 = uVar3 + 1;
				pvVar1 = lego::game::LiveObject_GetBuildingVehicleFields_138_a0((LiveObject *)param_1);
			} while (uVar3 < *(uint *)((int)pvVar1 + 0xa4));
		}
	}
	else {
		fVar2 = 0.0;
		pvVar1 = lego::game::LiveObject_GetBuildingVehicleFields_138_a0((LiveObject *)param_1);
		if (*(int *)((int)pvVar1 + 0xa4) != 0) {
			do {
				FUN_00471fe0(param_1,param_2,fVar2);
				fVar2 = (float)((int)fVar2 + 1);
				pvVar1 = lego::game::LiveObject_GetBuildingVehicleFields_138_a0((LiveObject *)param_1);
			} while ((uint)fVar2 < (uint)*(float *)((int)pvVar1 + 0xa4));
			return 1;
		}
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_SetField_3c4(LiveObject *liveObj,int field3c4)
{
	if (liveObj->field_3c4 == field3c4) {
		liveObj->field_3c4 = 0;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_00472340(LiveObject *liveObj,undefined4 *param_2)
{
	uint weaponType;
	float10 fVar1;
	float local_18;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	weaponType = LiveObject_GetEquippedBeam(liveObj);
	if (((liveObj != (LiveObject *)0x0) && (param_2 != (undefined4 *)0x0)) && (weaponType != 0)) {
		fVar1 = tools::Weapon_GetWeaponRange(weaponType);
		LiveObject_GetCollWriteToParam2_FUN_00471f60(liveObj,(int)&local_c);
		LiveObject_GetCollWriteToParam2_FUN_00471f60((LiveObject *)param_2,(int)&local_18);
		if (SQRT((local_10 - local_4) * (local_10 - local_4) +
						 (local_14 - local_8) * (local_14 - local_8) +
						 (local_18 - local_c) * (local_18 - local_c)) < (float)fVar1) {
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_004723f0(LiveObject *liveObj,undefined4 *param_2)
{
	uint uVar1;
	float10 fVar2;
	float local_18;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	uVar1 = LiveObject_GetEquippedBeam(liveObj);
	if (((liveObj != (LiveObject *)0x0) && (param_2 != (undefined4 *)0x0)) && (uVar1 != 0)) {
		fVar2 = LiveObject_GetAwarenessRange(liveObj);
		LiveObject_GetCollWriteToParam2_FUN_00471f60(liveObj,(int)&local_c);
		LiveObject_GetCollWriteToParam2_FUN_00471f60((LiveObject *)param_2,(int)&local_18);
		if (SQRT((local_10 - local_4) * (local_10 - local_4) +
						 (local_14 - local_8) * (local_14 - local_8) +
						 (local_18 - local_c) * (local_18 - local_c)) < (float)fVar2) {
			return 1;
		}
	}
	return 0;
}



bool __thiscall
lego::video::VideoPlayer__CreateSampleDDrawStreams
					(VideoPlayer *this,IAMMultiMediaStream *amMediaStream)
{
	IMediaStream **ppIVar1;
	IAMMultiMediaStreamVtbl *pIVar2;
	IDirectDrawMediaStream *This;
	IDirectDrawStreamSample *This_00;
	IDirectDrawSurface *This_01;
	HRESULT HVar3;
	
	pIVar2 = amMediaStream->lpVtbl;
	ppIVar1 = &this->mediaStream;
	HVar3 = (*pIVar2->GetMediaStream)(amMediaStream,&idl::MSPID_PrimaryVideo,ppIVar1);
	this->errorCode = HVar3;
	if (-1 < HVar3) {
		HVar3 = (*(*ppIVar1)->lpVtbl->QueryInterface)
											(*ppIVar1,&idl::IID_IDirectDrawMediaStream,&this->ddMediaStream);
		this->errorCode = HVar3;
		if (-1 < HVar3) {
			This = this->ddMediaStream;
										// IDirectDrawMediaStream->CreateSample(this, IDirectDrawSurface* pSurface,
										// const RECT* pRect, DWORD dwFlags, IDirectDrawStreamSample** ppSample)
			HVar3 = (*(code *)This->lpVtbl->CreateSample)
												(This,(IDirectDrawSurface *)0x0,(RECT *)0x0,0,&this->ddStreamSample);
			this->errorCode = HVar3;
			if (-1 < HVar3) {
				This_00 = this->ddStreamSample;
										// IDirectDrawStreamSample->GetSurface(this, IDirectDrawSurface**
										// ppDirectDrawSurface, RECT* pRect)
				HVar3 = (*(code *)This_00->lpVtbl->GetSurface)(This_00,&this->ddSampleSurface,&this->rect);
				this->errorCode = HVar3;
				if (-1 < HVar3) {
					This_01 = this->ddSampleSurface;
					HVar3 = (*This_01->lpVtbl->QueryInterface)
														(This_01,&idl::IID_IDirectDrawSurface3,(IUnknown **)&this->ddDrawSurface
														);
					this->errorCode = HVar3;
					if (-1 < HVar3) {
										// STREAMSTATE_RUN (0x1)
						HVar3 = (*pIVar2->SetState)(amMediaStream,STREAMSTATE_RUN);
						this->errorCode = HVar3;
						if (-1 < HVar3) {
							return true;
						}
					}
				}
			}
		}
	}
	(*(*ppIVar1)->lpVtbl->Release)(*ppIVar1);
	(*this->ddMediaStream->lpVtbl->Release)(this->ddMediaStream);
	(*this->ddStreamSample->lpVtbl->Release)(this->ddStreamSample);
	(*this->ddSampleSurface->lpVtbl->Release)(this->ddSampleSurface);
	return -1 < this->errorCode;
}



bool __thiscall
lego::video::VideoPlayer__CreateAMMultiMediaStream
					(VideoPlayer *this,char *filename,IAMMultiMediaStream **lplpAMMMStream,
					IDirectDraw2 *ddraw2)
{
	IAMMultiMediaStreamVtbl *pIVar1;
	HRESULT HVar2;
	IAMMultiMediaStream *amMMStream;
	WCHAR wfilenameBuffer [260];
	
										// CLSCTX_INPROC_HANDLER (0x1)
	HVar2 = CoCreateInstance((IID *)&idl::CLSID_AMMultiMediaStream,(LPUNKNOWN)0x0,1,
													 (IID *)&idl::IID_IAMMultiMediaStream,&amMMStream);
	if (-1 < HVar2) {
										//  STREAMTYPE_READ (0x0)
		HVar2 = (*amMMStream->lpVtbl->Initialize)(amMMStream,STREAMTYPE_READ,0,(IGraphBuilder *)0x0);
		if (-1 < HVar2) {
			HVar2 = (*amMMStream->lpVtbl->AddMediaStream)
												(amMMStream,(IUnknown *)ddraw2,&idl::MSPID_PrimaryVideo,0,
												 (IMediaStream **)0x0);
			if (-1 < HVar2) {
										// AMMSF_ADDDEFAULTRENDERER (0x1)
				HVar2 = (*amMMStream->lpVtbl->AddMediaStream)
													(amMMStream,(IUnknown *)0x0,&idl::MSPID_PrimaryAudio,1,
													 (IMediaStream **)0x0);
				if (HVar2 < 0) {
										// failure is just outright ignored here?
					HVar2 = 0;
				}
										// The IAMMultiMediaStream::OpenFile function only supports unicode,
										// so convert our filename to wide chars.
				MultiByteToWideChar(CP_ACP,0,filename,-1,wfilenameBuffer,0x104);
				(*amMMStream->lpVtbl->OpenFile)(amMMStream,wfilenameBuffer,0);
				pIVar1 = amMMStream->lpVtbl;
				*lplpAMMMStream = amMMStream;
				(*pIVar1->AddRef)(amMMStream);
			}
		}
	}
	(*amMMStream->lpVtbl->Release)(amMMStream);
	return -1 < HVar2;
}



VideoPlayer * __thiscall
lego::video::VideoPlayer___ctor
					(VideoPlayer *this,char *filename,IDirectDrawSurface3 *ddSurface3,IDirectDraw2 *ddraw2)
{
	char cVar1;
	bool bVar2;
	undefined4 *puVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	char *pcVar9;
	
	this->mediaStream = (IMediaStream *)0x0;
	this->ddMediaStream = (IDirectDrawMediaStream *)0x0;
	this->ddSampleSurface = (IDirectDrawSurface *)0x0;
	this->ddDrawSurface = (IDirectDrawSurface3 *)0x0;
	this->ddStreamSample = (IDirectDrawStreamSample *)0x0;
	this->ddRenderSurface = ddSurface3;
	this->ddraw2 = ddraw2;
	CoInitialize((LPVOID)0x0);
	if (filename != (char *)0x0) {
										// *(char **)((int)this + 0x30) = std::_strdup(filename);
		iVar4 = -1;
		pcVar8 = filename;
		do {
			if (iVar4 == 0) break;
			iVar4 = iVar4 + -1;
			cVar1 = *pcVar8;
			pcVar8 = pcVar8 + 1;
		} while (cVar1 != '\0');
										// if (std::strlen(filename) != 0)
		if (iVar4 != -2) {
			uVar5 = 0xffffffff;
			pcVar8 = filename;
			do {
				if (uVar5 == 0) break;
				uVar5 = uVar5 - 1;
				cVar1 = *pcVar8;
				pcVar8 = pcVar8 + 1;
			} while (cVar1 != '\0');
			puVar3 = (undefined4 *)std::malloc(~uVar5);
			uVar5 = 0xffffffff;
			this->filename = (char *)puVar3;
			pcVar8 = filename;
			do {
				pcVar9 = pcVar8;
				if (uVar5 == 0) break;
				uVar5 = uVar5 - 1;
				pcVar9 = pcVar8 + 1;
				cVar1 = *pcVar8;
				pcVar8 = pcVar9;
			} while (cVar1 != '\0');
			uVar5 = ~uVar5;
			puVar7 = (undefined4 *)(pcVar9 + -uVar5);
			for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
				*puVar3 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar3 = puVar3 + 1;
			}
			for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
				*(undefined *)puVar3 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar3 = (undefined4 *)((int)puVar3 + 1);
			}
										// end of std::_strdup
			bVar2 = VideoPlayer__CreateAMMultiMediaStream
												(this,filename,(IAMMultiMediaStream **)this,ddraw2);
			if (bVar2 != false) {
				VideoPlayer__CreateSampleDDrawStreams(this,this->amMediaStream);
			}
		}
	}
	return this;
}



void __thiscall lego::video::VideoPlayer___dtor(VideoPlayer *this)
{
	IMediaStream *This;
	IDirectDrawMediaStream *This_00;
	IDirectDrawStreamSample *This_01;
	IDirectDrawSurface *This_02;
	IDirectDrawSurface3 *This_03;
	IDirectDraw2 *This_04;
	IAMMultiMediaStream *This_05;
	
	This = this->mediaStream;
	if (This != (IMediaStream *)0x0) {
		(*This->lpVtbl->Release)((IUnknown *)This);
	}
	This_00 = this->ddMediaStream;
	if (This_00 != (IDirectDrawMediaStream *)0x0) {
		(*This_00->lpVtbl->Release)((IUnknown *)This_00);
	}
	This_01 = this->ddStreamSample;
	if (This_01 != (IDirectDrawStreamSample *)0x0) {
		(*This_01->lpVtbl->Release)((IUnknown *)This_01);
	}
	This_02 = this->ddSampleSurface;
	if (This_02 != (IDirectDrawSurface *)0x0) {
		(*This_02->lpVtbl->Release)((IUnknown *)This_02);
	}
	This_03 = this->ddRenderSurface;
	if (This_03 != (IDirectDrawSurface3 *)0x0) {
		(*This_03->lpVtbl->Release)((IUnknown *)This_03);
	}
	This_04 = this->ddraw2;
	if (This_04 != (IDirectDraw2 *)0x0) {
		(*This_04->lpVtbl->Release)((IUnknown *)This_04);
	}
	This_05 = this->amMediaStream;
	if (This_05 != (IAMMultiMediaStream *)0x0) {
		(*This_05->lpVtbl->Release)((IUnknown *)This_05);
	}
	if (this->filename != (char *)0x0) {
		std::free(this->filename);
	}
	return;
}



bool __thiscall lego::video::VideoPlayer__Update(VideoPlayer *this,float speed,RECT *rect)
{
	IDirectDrawStreamSample *pIVar1;
	IAMMultiMediaStream *pIVar2;
	HRESULT HVar3;
	
	pIVar1 = this->ddStreamSample;
	if (pIVar1 != (IDirectDrawStreamSample *)0x0) {
		HVar3 = (*(code *)pIVar1->lpVtbl->Update)(pIVar1,0,(HANDLE)0x0,(void *)0x0,(DWORD *)0x0);
		if (HVar3 == 0) {
										// DDBLT_WAIT (0x1000000)
			HVar3 = (*(code *)this->ddRenderSurface->lpVtbl->Blt)
												(this->ddRenderSurface,rect,this->ddDrawSurface,(RECT *)0x0,0x1000000,
												 (void *)0x0);
			return HVar3 == 0;
		}
										// On failure... SHUTDOWN EVERYTHING!
		(*this->mediaStream->lpVtbl->Release)(this->mediaStream);
		this->mediaStream = (IMediaStream *)0x0;
		(*this->ddMediaStream->lpVtbl->Release)(this->ddMediaStream);
		this->ddMediaStream = (IDirectDrawMediaStream *)0x0;
		(*this->ddStreamSample->lpVtbl->Release)(this->ddStreamSample);
		this->ddStreamSample = (IDirectDrawStreamSample *)0x0;
		(*this->ddSampleSurface->lpVtbl->Release)(this->ddSampleSurface);
		pIVar2 = this->amMediaStream;
		this->ddSampleSurface = (IDirectDrawSurface *)0x0;
		if (pIVar2 != (IAMMultiMediaStream *)0x0) {
			(*pIVar2->lpVtbl->Release)(pIVar2);
			this->amMediaStream = (IAMMultiMediaStream *)0x0;
			return false;
		}
	}
	return false;
}



// WARNING: Could not reconcile some variable overlaps

longlong __thiscall lego::video::VideoPlayer__GetDuration(VideoPlayer *this)
{
	longlong lVar1;
	longlong duration;
	
	(*this->amMediaStream->lpVtbl->GetDuration)(this->amMediaStream,&duration);
										// __alldiv - 64-bit integer division in 32-bit environments
	lVar1 = __alldiv((uint)duration,duration._4_4_,10000,0);
	return lVar1;
}



VideoPlayer_t * __cdecl lego::video::VideoPlayer_Open(char *filenameNoDataDir)
{
	char *filename;
	IDirectDraw4 *pIVar1;
	IDirectDrawSurface4 *pIVar2;
	FILE *stream;
	BOOL BVar3;
	VideoPlayer *videoPlayer;
	undefined4 *in_FS_OFFSET;
	IDirectDrawSurface3 *ddSurface3;
	IDirectDraw2 *ddraw2;
	VideoPlayer *This;
	char cdFileBuffer [512];
	undefined4 local_c;
	undefined *puStack8;
	undefined4 local_4;
	
										// C++ function start guards (ignore these)
	local_c = *in_FS_OFFSET;
	local_4 = 0xffffffff;
	puStack8 = &LAB_0049e06c;
	*in_FS_OFFSET = &local_c;
										// actual start of C++ function
	filename = lego::file::File_VerifyFilename(filenameNoDataDir);
	videoPlayer = (VideoPlayer *)0x0;
	pIVar1 = draw::Draw_GetDirectDraw();
	(*pIVar1->lpVtbl->QueryInterface)(pIVar1,&idl::IID_IDirectDraw2,(IUnknown **)&ddraw2);
	pIVar2 = draw::Draw_GetDrawingSurface();
	(*pIVar2->lpVtbl->QueryInterface)(pIVar2,&idl::IID_IDirectDrawSurface3,(IUnknown **)&ddSurface3);
	stream = std::fopen(filename,"r");
	if (stream == (FILE *)0x0) {
										// File not found in local Data folder, Try open in CDROM/Data folder
		BVar3 = lego::file::File_GetCDFilePath(cdFileBuffer,filenameNoDataDir);
		if (BVar3 == 0) goto LAB_0047290d;
		This = (VideoPlayer *)std::operator_new(0x38);
		local_4 = 1;
		if (This != (VideoPlayer *)0x0) {
			videoPlayer = VideoPlayer___ctor(This,cdFileBuffer,ddSurface3,ddraw2);
			goto LAB_0047290d;
		}
	}
	else {
										// Open file in local Data folder
		std::fclose(stream);
		This = (VideoPlayer *)std::operator_new(0x38);
		local_4 = 0;
		if (This != (VideoPlayer *)0x0) {
			videoPlayer = VideoPlayer___ctor(This,filename,ddSurface3,ddraw2);
			goto LAB_0047290d;
		}
	}
	videoPlayer = (VideoPlayer *)0x0;
LAB_0047290d:
										// C++ function end guard (ignore this)
	*in_FS_OFFSET = local_c;
	return (VideoPlayer_t *)videoPlayer;
}



void __cdecl
lego::video::VideoPlayer_GetSize(VideoPlayer_t *videoPlayer,uint *out_width,uint *out_height)
{
	DDSURFACEDESC *pDVar1;
	int iVar2;
	DDSURFACEDESC surfDesc;
	
	pDVar1 = &surfDesc;
	for (iVar2 = 0x1b; iVar2 != 0; iVar2 = iVar2 + -1) {
		*(undefined4 *)pDVar1 = 0;
		pDVar1 = (DDSURFACEDESC *)((int)pDVar1 + 4);
	}
	surfDesc.dwSize = 0x6c;
	(*(code *)videoPlayer->ddDrawSurface->lpVtbl->GetSurfaceDesc)
						(videoPlayer->ddDrawSurface,&surfDesc);
	*out_width = surfDesc.dwWidth;
	*out_height = surfDesc.dwHeight;
	return;
}



longlong __cdecl lego::video::VideoPlayer_GetDuration(VideoPlayer_t *videoPlayer)
{
	longlong lVar1;
	
	lVar1 = VideoPlayer__GetDuration((VideoPlayer *)videoPlayer);
	return lVar1;
}



BOOL __cdecl lego::video::VideoPlayer_Update(VideoPlayer_t *videoPlayer,float speed,RECT *rect)
{
	bool bVar1;
	
	bVar1 = VideoPlayer__Update((VideoPlayer *)videoPlayer,speed,rect);
	return (uint)(bVar1 != false);
}



void __cdecl lego::video::VideoPlayer_Close(VideoPlayer_t *videoPlayer)
{
	if (videoPlayer != (VideoPlayer_t *)0x0) {
		VideoPlayer___dtor((VideoPlayer *)videoPlayer);
										// This function is multi-purpose (the linker assigned functions with the same
										// functionality to different areas). So distinguishing is annoying
		game::LevelStruct3C_Free_Unwind((LevelStruct_3c *)videoPlayer);
	}
	return;
}



Container * __cdecl lego::res::Container_Initialise(char *gameName)
{
	Container *pCVar1;
	int iVar2;
	Container_Globs *pCVar3;
	
	pCVar3 = &globs::containerGlobs;
	for (iVar2 = 0x806; iVar2 != 0; iVar2 = iVar2 + -1) {
		pCVar3->listSet[0] = (Container *)0x0;
		pCVar3 = (Container_Globs *)(pCVar3->listSet + 1);
	}
	pCVar3 = &globs::containerGlobs;
	for (iVar2 = 0x14; iVar2 != 0; iVar2 = iVar2 + -1) {
		pCVar3->listSet[0] = (Container *)0x0;
		pCVar3 = (Container_Globs *)(pCVar3->listSet + 1);
	}
	globs::containerGlobs.extensionName[1] = "x";
	globs::containerGlobs.extensionName[2] = "x";
	globs::containerGlobs.extensionName[3] = "x";
	globs::containerGlobs.typeName[0] = "NULL";
	globs::containerGlobs.typeName[1] = "MESH";
	globs::containerGlobs.typeName[2] = "FRAME";
	globs::containerGlobs.typeName[3] = "ANIM";
	globs::containerGlobs.typeName[7] = "LWS";
	globs::containerGlobs.typeName[8] = "LWO";
	globs::containerGlobs.typeName[4] = "ACT";
	globs::containerGlobs.typeName[5] = (char *)0x0;
	globs::containerGlobs.extensionName[0] = ____EMPTYSTR__;
	globs::containerGlobs.extensionName[4] = "ae";
	globs::containerGlobs.extensionName[5] = ____EMPTYSTR__;
	globs::containerGlobs.gameName = gameName;
	globs::containerGlobs.freeList = (Container *)0x0;
	globs::containerGlobs.listCount = 0;
	globs::containerGlobs.flags = RESMANAGER_ISINIT;
	globs::containerGlobs.textureCount = 0;
	globs::containerGlobs.sharedDir = (char *)0x0;
	pCVar1 = Container_Create((Container *)0x0);
										// D3DRMSORT_NONE (0x1)
	globs::containerGlobs.rootContainer = pCVar1;
	(*pCVar1->masterFrame->lpVtbl->SetSortMode)(pCVar1->masterFrame,D3DRMSORT_NONE);
	return pCVar1;
}



void __cdecl lego::res::Container_Shutdown(void)
{
	int iVar1;
	Container *in_cont;
	byte bVar2;
	int iVar3;
	Container_TextureRef *pCVar4;
	Container_Globs *pCVar5;
	uint uVar6;
	
	bVar2 = 0;
	pCVar5 = &globs::containerGlobs;
	do {
		if (pCVar5->listSet[0] != (Container *)0x0) {
			iVar1 = 1 << (bVar2 & 0x1f);
			if (iVar1 != 0) {
				iVar3 = 0;
				do {
					in_cont = (Container *)((int)&pCVar5->listSet[0]->masterFrame + iVar3);
					if ((in_cont != (Container *)0x0) && (in_cont->nextFree == in_cont)) {
						Container_Remove2(in_cont,TRUE);
					}
					iVar3 = iVar3 + 0x2c;
					iVar1 = iVar1 + -1;
				} while (iVar1 != 0);
			}
			std::free(pCVar5->listSet[0]);
		}
		pCVar5 = (Container_Globs *)(pCVar5->listSet + 1);
		bVar2 = bVar2 + 1;
	} while (pCVar5 < (Container_Globs *)&globs::containerGlobs.freeList);
	uVar6 = 0;
	globs::containerGlobs.freeList = (Container *)0x0;
	globs::containerGlobs.flags = RESMANAGER_NONE;
	if (globs::containerGlobs.textureCount != 0) {
		pCVar4 = globs::containerGlobs.textureSet;
		do {
			if (pCVar4->filename != (char *)0x0) {
				std::free(pCVar4->filename);
			}
			uVar6 = uVar6 + 1;
			pCVar4 = pCVar4 + 1;
		} while (uVar6 < globs::containerGlobs.textureCount);
	}
	if (globs::containerGlobs.sharedDir != (char *)0x0) {
		std::free(globs::containerGlobs.sharedDir);
	}
	return;
}



void __cdecl lego::res::Container_SetSharedTextureDirectory(char *path)
{
	globs::containerGlobs.sharedDir = std::_strdup(path);
	return;
}



void __cdecl lego::res::Container_EnableSoundTriggers(BOOL on)
{
	if (on != 0) {
		globs::containerGlobs.flags = globs::containerGlobs.flags | RESMANAGER_SOUNDCALLBACK;
		return;
	}
	globs::containerGlobs.flags = globs::containerGlobs.flags & ~RESMANAGER_SOUNDCALLBACK;
	return;
}



void __cdecl
lego::res::Container_SetTriggerFrameCallback(ContainerTriggerFrameCallback *callback,void *data)
{
	globs::containerGlobs.triggerFrameCallback = callback;
	globs::containerGlobs.triggerFrameData = data;
	return;
}



void __cdecl
lego::res::Container_SetSoundTriggerCallback(ContainerSoundTriggerCallback *callback,void *data)
{
	globs::containerGlobs.soundTriggerCallback = callback;
	globs::containerGlobs.soundTriggerData = data;
	globs::containerGlobs.flags = globs::containerGlobs.flags | RESMANAGER_SOUNDCALLBACK;
	return;
}



// OFFICIAL: Container_GetRoot(void)

Container * __cdecl lego::res::GetRoot(void)
{
	return globs::containerGlobs.rootContainer;
}



Container * __cdecl lego::res::Container_Create(Container *opt_parent)
{
	Container *cont;
	HRESULT HVar1;
	int iVar2;
	IDirect3DRMFrame3 *parentFrame1;
	IDirect3DRMFrame3 *parentFrame3;
	Container *pCVar3;
	
	parentFrame1 = (IDirect3DRMFrame3 *)0x0;
	parentFrame3 = (IDirect3DRMFrame3 *)0x0;
	if (opt_parent != (Container *)0x0) {
		parentFrame1 = opt_parent->masterFrame;
		parentFrame3 = opt_parent->hiddenFrame;
	}
	if (globs::containerGlobs.freeList == (Container *)0x0) {
		Container_AddList();
	}
	cont = globs::containerGlobs.freeList;
	pCVar3 = globs::containerGlobs.freeList;
	globs::containerGlobs.freeList = (globs::containerGlobs.freeList)->nextFree;
	for (iVar2 = 0xb; iVar2 != 0; iVar2 = iVar2 + -1) {
		pCVar3->masterFrame = (IDirect3DRMFrame3 *)0x0;
		pCVar3 = (Container *)&pCVar3->activityFrame;
	}
	cont->nextFree = cont;
	HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
										(globs::mainGlobs.lpD3DRM,parentFrame1,(IDirect3DRMFrame3 **)cont);
	if (HVar1 == 0) {
		HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
											(globs::mainGlobs.lpD3DRM,cont->masterFrame,&cont->activityFrame);
		if (HVar1 == 0) {
			HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
												(globs::mainGlobs.lpD3DRM,parentFrame3,&cont->hiddenFrame);
			if (HVar1 == 0) {
				Container_Frame_SetAppData
									(cont->masterFrame,cont,(AnimClone *)0x0,(char *)0x0,(uint *)0x0,(char *)0x0,
									 (float *)0x0,(float *)0x0,(char *)0x0,(Sound3D_SoundFrameRecord *)0x0,(uint *)0x0
									);
				Container_Frame_SetAppData
									(cont->activityFrame,cont,(AnimClone *)0x0,(char *)0x0,(uint *)0x0,(char *)0x0,
									 (float *)0x0,(float *)0x0,(char *)0x0,(Sound3D_SoundFrameRecord *)0x0,(uint *)0x0
									);
				Container_Frame_SetAppData
									(cont->hiddenFrame,cont,(AnimClone *)0x0,(char *)0x0,(uint *)0x0,(char *)0x0,
									 (float *)0x0,(float *)0x0,(char *)0x0,(Sound3D_SoundFrameRecord *)0x0,(uint *)0x0
									);
				return cont;
			}
		}
	}
	Container_Remove(cont);
	return (Container *)0x0;
}



void __cdecl lego::res::Container_Remove(Container *cont)
{
	Container_Remove2(cont,FALSE);
	return;
}



void __cdecl lego::res::Container_Remove2(Container *in_cont,BOOL kill)
{
	Container_CloneData *pCVar1;
	ResourceType RVar2;
	Container_TypeData *pCVar3;
	IDirect3DRMVisual *pIVar4;
	Container *cont;
	uint uVar5;
	AnimClone **out_acList;
	IDirect3DRMFrame3 **out_frameList;
	void **buffer;
	AnimClone *actFrameRes;
	void *pvVar6;
	AnimClone **buffer_00;
	IDirect3DRMFrame3 **ppIVar7;
	
	cont = in_cont;
	if (in_cont->type != RESOURCE_REFERENCE) {
		Container_SetParent(in_cont,(Container *)0x0);
	}
	if (((cont->type == RESOURCE_ACT) || (cont->type == RESOURCE_ANIM)) &&
		 (pCVar1 = cont->cloneData, pCVar1 != (Container_CloneData *)0x0)) {
		if (kill == 0) {
			pCVar1->used = 0;
			return;
		}
		if (pCVar1->cloneTable != (Container **)0x0) {
			std::free(pCVar1->cloneTable);
		}
		std::free(cont->cloneData);
	}
	RVar2 = cont->type;
	if (RVar2 == RESOURCE_ACT) {
		uVar5 = Container_GetActivities(cont,(IDirect3DRMFrame3 **)0x0,(AnimClone **)0x0,(char **)0x0);
		out_acList = (AnimClone **)std::malloc(uVar5 * 4);
		kill = (BOOL)out_acList;
		out_frameList = (IDirect3DRMFrame3 **)std::malloc(uVar5 * 4);
		Container_GetActivities(cont,out_frameList,out_acList,(char **)0x0);
		buffer_00 = out_acList;
		if (uVar5 != 0) {
			ppIVar7 = out_frameList;
			do {
				AnimClone_Remove(*(AnimClone **)((int)((int)out_acList - (int)out_frameList) + (int)ppIVar7)
												);
				Container_Frame_FreeName(*ppIVar7);
				Container_Frame_RemoveAppData(*ppIVar7);
				(*(*ppIVar7)->lpVtbl->Release)((IUnknown *)*ppIVar7);
				ppIVar7 = ppIVar7 + 1;
				uVar5 = uVar5 - 1;
				buffer_00 = (AnimClone **)kill;
			} while (uVar5 != 0);
		}
		std::free(buffer_00);
		std::free(out_frameList);
	}
	else {
		if (RVar2 == RESOURCE_MESH) {
			pCVar3 = cont->typeData;
			if (pCVar3 != (Container_TypeData *)0x0) {
				if (pCVar3->transMesh == (Mesh *)0x0) {
					buffer = (*pCVar3->mesh->lpVtbl->GetAppData)(pCVar3->mesh);
					if (buffer != (void **)0x0) {
						pvVar6 = (void *)0x0;
						if (buffer[1] != (void *)0x0) {
							do {
								pIVar4 = *(IDirect3DRMVisual **)((int)*buffer + (int)pvVar6 * 4);
								(*cont->activityFrame->lpVtbl->DeleteVisual)(cont->activityFrame,pIVar4);
								(*pIVar4->lpVtbl->Release)(pIVar4);
								pvVar6 = (void *)((int)pvVar6 + 1);
							} while (pvVar6 < buffer[1]);
						}
						std::free(*buffer);
						std::free(buffer);
					}
				}
				else {
					Mesh_Remove(pCVar3->transMesh,cont->activityFrame);
				}
			}
		}
		else {
			if ((RVar2 == RESOURCE_ANIM) &&
				 (actFrameRes = Container_Frame_GetAnimClone(cont->activityFrame),
				 actFrameRes != (AnimClone *)0x0)) {
				AnimClone_Remove(actFrameRes);
			}
		}
	}
	Container_FreeTypeData(cont);
	if ((cont->type != RESOURCE_REFERENCE) || ((*(byte *)&cont->flags & RESDATA_UNK_10) == 0)) {
		Container_Frame_RemoveAppData(cont->masterFrame);
	}
	if (cont->type != RESOURCE_REFERENCE) {
		Container_Frame_RemoveAppData(cont->activityFrame);
	}
	Container_Frame_RemoveAppData(cont->hiddenFrame);
	if (cont->type == RESOURCE_REFERENCE) {
		(*cont->hiddenFrame->lpVtbl->Release)(cont->hiddenFrame);
	}
	else {
		(*cont->masterFrame->lpVtbl->GetParent)(cont->masterFrame,(IDirect3DRMFrame3 **)&in_cont);
		if (in_cont != (Container *)0x0) {
										// IDirect3DRMFrame3->DeleteChild(this, IDirect3DRMFrame3* lpChild)
										//  (this = resData->frame1->GetParent, lpChild = resData->frame1)
			(*(code *)in_cont->masterFrame[0x25].lpVtbl)((IDirect3DRMFrame3 *)in_cont,cont->masterFrame);
										// IDirect3DRMFrame3->Release(this)
										//  (this = resData->frame1->GetParent)
			(*(code *)in_cont->masterFrame[2].lpVtbl)((IDirect3DRMFrame3 *)in_cont);
		}
		(*cont->masterFrame->lpVtbl->Release)(cont->masterFrame);
		(*cont->activityFrame->lpVtbl->Release)(cont->activityFrame);
		(*cont->hiddenFrame->lpVtbl->GetParent)(cont->hiddenFrame,(IDirect3DRMFrame3 **)&in_cont);
		if (in_cont != (Container *)0x0) {
										// IDirect3DRMFrame3->DeleteChild(this, IDirect3DRMFrame3* lpChild)
										//  (this = resData->frame3->GetParent, lpChild = resData->frame3)
			(*(code *)in_cont->masterFrame[0x25].lpVtbl)((IDirect3DRMFrame3 *)in_cont,cont->hiddenFrame);
										// IDirect3DRMFrame3->Release(this)
										//  (this = resData->frame3->GetParent)
			(*(code *)in_cont->masterFrame[2].lpVtbl)((IDirect3DRMFrame3 *)in_cont);
		}
		(*cont->hiddenFrame->lpVtbl->Release)(cont->hiddenFrame);
	}
	cont->nextFree = globs::containerGlobs.freeList;
	globs::containerGlobs.freeList = cont;
	return;
}



Container * __cdecl
lego::res::Container_Load(Container *parent,char *filename,char *typestr,BOOL looping)
{
	char cVar1;
	ResourceType RVar2;
	int iVar3;
	CFGProperty *prop;
	CFGProperty *prop_00;
	char *pcVar4;
	BOOL3 BVar5;
	BOOL3 BVar6;
	char *pcVar7;
	BOOL BVar8;
	Container *pCVar9;
	byte *file_data;
	IDirect3DRMMesh *mesh;
	Mesh *transMesh;
	AnimClone *animClone;
	uint uVar10;
	uint uVar11;
	undefined4 *puVar12;
	undefined4 *puVar13;
	float10 fVar14;
	Container *local_864;
	float local_860;
	char *local_85c;
	BOOL isNoTexture;
	uint local_854;
	char filenameBuffer [512];
	char local_650 [508];
	char *apcStack1108 [21];
	char filenameBuffer2 [512];
	char local_200 [512];
	
	local_864 = (Container *)0x0;
	RVar2 = Container_ParseTypeString(typestr,&isNoTexture);
	uVar10 = 0xffffffff;
	do {
		pcVar4 = filename;
		if (uVar10 == 0) break;
		uVar10 = uVar10 - 1;
		pcVar4 = filename + 1;
		cVar1 = *filename;
		filename = pcVar4;
	} while (cVar1 != '\0');
	uVar10 = ~uVar10;
	puVar12 = (undefined4 *)(pcVar4 + -uVar10);
	puVar13 = (undefined4 *)filenameBuffer2;
	for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
		*puVar13 = *puVar12;
		puVar12 = puVar12 + 1;
		puVar13 = puVar13 + 1;
	}
	for (uVar10 = uVar10 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {
		*(undefined *)puVar13 = *(undefined *)puVar12;
		puVar12 = (undefined4 *)((int)puVar12 + 1);
		puVar13 = (undefined4 *)((int)puVar13 + 1);
	}
	if (RVar2 == RESOURCE_ACT) {
		uVar10 = 0xffffffff;
		pcVar4 = filenameBuffer2;
		do {
			pcVar7 = pcVar4;
			if (uVar10 == 0) break;
			uVar10 = uVar10 - 1;
			pcVar7 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar7;
		} while (cVar1 != '\0');
		uVar10 = ~uVar10;
		puVar12 = (undefined4 *)(pcVar7 + -uVar10);
		puVar13 = (undefined4 *)local_200;
		for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
			*puVar13 = *puVar12;
			puVar12 = puVar12 + 1;
			puVar13 = puVar13 + 1;
		}
		for (uVar10 = uVar10 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {
			*(undefined *)puVar13 = *(undefined *)puVar12;
			puVar12 = (undefined4 *)((int)puVar12 + 1);
			puVar13 = (undefined4 *)((int)puVar13 + 1);
		}
		iVar3 = util::Util_Tokenise(filenameBuffer2,apcStack1108 + 1,"\\");
		std::sprintf(filenameBuffer,"%s\\%s.%s",local_200,apcStack1108[iVar3],
								 globs::containerGlobs.extensionName[4]);
		prop = cfg::CFG_Open(filenameBuffer);
		if (prop != (CFGProperty *)0x0) {
			std::sprintf(filenameBuffer,"%s%s%s",globs::containerGlobs.gameName,"::","Activities");
			prop_00 = cfg::CFG_GetChildren(prop,filenameBuffer);
			if (prop_00 != (CFGProperty *)0x0) {
				local_864 = Container_Create(parent);
				local_864->type = RESOURCE_ACT;
				do {
					local_85c = prop_00->key;
					if (*local_85c == '!') {
						if ((globs::mainGlobs.flags & CMD_REDUCEANIMATION) == CMD_NONE) {
							local_85c = local_85c + 1;
							goto LAB_004730ee;
						}
					}
					else {
LAB_004730ee:
						std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value,
												 "::","FILE");
						pcVar4 = cfg::CFG_ReadString(prop,local_650);
						if (pcVar4 != (char *)0x0) {
							std::sprintf(filenameBuffer,"%s\\%s",local_200,pcVar4);
							std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value
													 ,"::","TRANSCOEF");
							pcVar4 = cfg::CFG_ReadString(prop,local_650);
							if (pcVar4 == (char *)0x0) {
								pcVar4 = ____EMPTYSTR__;
							}
							else {
								pcVar4 = cfg::CFG_ReadString(prop,local_650);
							}
							fVar14 = std::atof(pcVar4);
							local_860 = (float)fVar14;
							std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value
													 ,"::","TRIGGER");
							pcVar4 = cfg::CFG_ReadString(prop,local_650);
							if (pcVar4 == (char *)0x0) {
								pcVar4 = ____EMPTYSTR__;
							}
							else {
								pcVar4 = cfg::CFG_ReadString(prop,local_650);
							}
							local_854 = std::atoi(pcVar4);
							std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value
													 ,"::","LWSFILE");
							BVar5 = cfg::CFG_ReadBool(prop,local_650);
							std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value
													 ,"::","LOOPING");
							BVar6 = cfg::CFG_ReadBool(prop,local_650);
							std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value
													 ,"::","SAMPLE");
							pcVar7 = cfg::CFG_CopyString(prop,local_650);
							pcVar4 = local_85c;
							BVar8 = Container_AddActivity2
																(local_864,filenameBuffer,local_85c,local_860,local_854,pcVar7,
																 (AnimClone *)0x0,(uint)(BVar5 == BOOL3_TRUE),
																 (uint)(BVar6 != BOOL3_FALSE));
							if ((BVar8 != 0) && (local_864->typeData == (Container_TypeData *)0x0)) {
								Container_SetActivity(local_864,pcVar4);
							}
						}
					}
					prop_00 = cfg::CFG_NextFlat(prop_00);
				} while (prop_00 != (CFGProperty *)0x0);
			}
			std::sprintf(filenameBuffer,"%s%s%s",globs::containerGlobs.gameName,"::","SCALE");
			pcVar4 = cfg::CFG_ReadString(prop,filenameBuffer);
			if (pcVar4 == (char *)0x0) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_ReadString(prop,filenameBuffer);
			}
			fVar14 = std::atof(pcVar4);
			local_85c = (char *)(float)fVar14;
			if ((float)local_85c != 0.0) {
				(*local_864->activityFrame->lpVtbl->AddScale)
									(local_864->activityFrame,D3DRMCOMBINE_REPLACE,(float)local_85c,(float)local_85c,
									 (float)local_85c);
			}
			cfg::CFG_Close(prop);
			return local_864;
		}
	}
	else {
		if (RVar2 == RESOURCE_FRAME) {
			pCVar9 = Container_Create(parent);
			pCVar9->type = RESOURCE_FRAME;
			std::sprintf(filenameBuffer,"%s.%s",filenameBuffer2,globs::containerGlobs.extensionName[2]);
			Container_FrameLoad(filenameBuffer,pCVar9->activityFrame);
			return pCVar9;
		}
		if (RVar2 == RESOURCE_MESH) {
			std::sprintf(filenameBuffer,"%s.%s",filenameBuffer2,globs::containerGlobs.extensionName[1]);
			file_data = lego::file::File_LoadBinary(filenameBuffer,(uint *)&local_860);
			if (file_data != (byte *)0x0) {
				pCVar9 = Container_Create(parent);
				pCVar9->type = RESOURCE_MESH;
				mesh = Container_MeshLoad(file_data,(uint)local_860,filenameBuffer,pCVar9->activityFrame,
																	isNoTexture);
				if (mesh != (IDirect3DRMMesh *)0x0) {
					Container_SetTypeData(pCVar9,(char *)0x0,(IDirect3DRMLight *)0x0,mesh,(Mesh *)0x0);
				}
				std::free(file_data);
				return pCVar9;
			}
		}
		else {
			if ((RVar2 == RESOURCE_ANIM) || (RVar2 == RESOURCE_LWS)) {
				pCVar9 = Container_Create(parent);
				pCVar9->type = RESOURCE_ANIM;
				std::sprintf(filenameBuffer,"%s.%s",filenameBuffer2,globs::containerGlobs.extensionName[3]);
				animClone = Container_LoadAnimSet
															(filenameBuffer,pCVar9->activityFrame,(uint *)&local_860,
															 (uint)(RVar2 == RESOURCE_LWS),looping);
				if (animClone != (AnimClone *)0x0) {
					Container_Frame_SetAppData
										(pCVar9->activityFrame,pCVar9,animClone,filenameBuffer2,(uint *)&local_860,
										 (char *)0x0,(float *)0x0,(float *)0x0,(char *)0x0,
										 (Sound3D_SoundFrameRecord *)0x0,(uint *)0x0);
					return pCVar9;
				}
			}
			else {
				if (RVar2 != RESOURCE_LWO) {
					return (Container *)0x0;
				}
				pCVar9 = Container_Create(parent);
				pCVar9->type = RESOURCE_LWO;
				transMesh = Mesh_Load(filenameBuffer2,pCVar9->activityFrame,isNoTexture);
				if (transMesh != (Mesh *)0x0) {
					Container_SetTypeData
										(pCVar9,(char *)0x0,(IDirect3DRMLight *)0x0,(IDirect3DRMMesh *)0x0,transMesh);
					return pCVar9;
				}
			}
			Container_Remove(pCVar9);
		}
	}
	return (Container *)0x0;
}



BOOL __cdecl lego::res::Container_IsCurrentActivity(Container *cont,char *actname)
{
	IDirect3DRMFrame3 *frame;
	
	if (cont->type == RESOURCE_ACT) {
		frame = Container_Frame_Find(cont,actname,0);
		if (frame != (IDirect3DRMFrame3 *)0x0) {
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::res::Container_SetActivity(Container *cont,char *actname)
{
	char cVar1;
	IDirect3DRMFrame3 *child;
	IDirect3DRMFrame3 *child_00;
	undefined4 *name;
	uint uVar2;
	uint uVar3;
	char *buffer;
	BOOL BVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	BVar4 = 0;
	if (cont->type == RESOURCE_ACT) {
		child = Container_Frame_Find(cont,actname,1);
		if (child == (IDirect3DRMFrame3 *)0x0) {
			BVar4 = 0;
		}
		else {
			buffer = (char *)0x0;
			if (((cont->typeData != (Container_TypeData *)0x0) &&
					(pcVar6 = cont->typeData->name, pcVar6 != (char *)0x0)) &&
				 (child_00 = Container_Frame_Find(cont,pcVar6,0), buffer = pcVar6,
				 child_00 != (IDirect3DRMFrame3 *)0x0)) {
				Container_Frame_SafeAddChild(cont->hiddenFrame,child_00);
			}
			Container_Frame_SafeAddChild(cont->activityFrame,child);
			uVar2 = 0xffffffff;
			pcVar6 = actname;
			do {
				if (uVar2 == 0) break;
				uVar2 = uVar2 - 1;
				cVar1 = *pcVar6;
				pcVar6 = pcVar6 + 1;
			} while (cVar1 != '\0');
			name = (undefined4 *)std::malloc(~uVar2);
			uVar2 = 0xffffffff;
			do {
				pcVar6 = actname;
				if (uVar2 == 0) break;
				uVar2 = uVar2 - 1;
				pcVar6 = actname + 1;
				cVar1 = *actname;
				actname = pcVar6;
			} while (cVar1 != '\0');
			uVar2 = ~uVar2;
			puVar5 = (undefined4 *)(pcVar6 + -uVar2);
			puVar7 = name;
			for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
				*puVar7 = *puVar5;
				puVar5 = puVar5 + 1;
				puVar7 = puVar7 + 1;
			}
			for (uVar2 = uVar2 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {
				*(undefined *)puVar7 = *(undefined *)puVar5;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
				puVar7 = (undefined4 *)((int)puVar7 + 1);
			}
			Container_SetTypeData
								(cont,(char *)name,(IDirect3DRMLight *)0x0,(IDirect3DRMMesh *)0x0,(Mesh *)0x0);
			BVar4 = 1;
			cont->flags = cont->flags | RESDATA_UNK_2;
			if (buffer != (char *)0x0) {
				std::free(buffer);
			}
		}
		if ((code *)cont->activityCallback != (code *)0x0) {
			(*(code *)cont->activityCallback)(cont,cont->activityCallbackData);
		}
	}
	return BVar4;
}



BOOL __cdecl lego::res::Container_Light_SetSpotPenumbra(Container *spotlight,float angle)
{
	IDirect3DRMLight *This;
	HRESULT HVar1;
	
	This = spotlight->typeData->light;
	HVar1 = (*This->lpVtbl->SetPenumbra)(This,angle);
	return (uint)(HVar1 == 0);
}



BOOL __cdecl lego::res::Container_Light_SetSpotUmbra(Container *spotlight,float angle)
{
	IDirect3DRMLight *This;
	HRESULT HVar1;
	
	This = spotlight->typeData->light;
	HVar1 = (*This->lpVtbl->SetUmbra)(This,angle);
	return (uint)(HVar1 == 0);
}



BOOL __cdecl lego::res::Container_Light_SetSpotRange(Container *spotlight,float dist)
{
	IDirect3DRMLight *This;
	HRESULT HVar1;
	
	This = spotlight->typeData->light;
	HVar1 = (*This->lpVtbl->SetRange)(This,dist);
	return (uint)(HVar1 == 0);
}



void __cdecl lego::res::Container_Light_SetEnableContainer(Container *light,Container *enable)
{
	IDirect3DRMLight *This;
	
										// IDirect3DRMFrame3->QueryInterface(this, IID_IDirect3DRMFrame,
										// IDirect3DRMFrame** lplpOut)
										//  (downcast: IDirect3DRMFrame3 -> IDirect3DRMFrame)
	(*enable->masterFrame->lpVtbl->QueryInterface)
						((IUnknown *)enable->masterFrame,(IID *)&idl::IID_IDirect3DRMFrame,
						 (IDirect3DRMFrame **)&enable);
	This = light->typeData->light;
										// IDirect3DRMLight->SetEnableFrame(this, IDirect3DRMFrame* lpEnableFrame)
	(*This->lpVtbl->SetEnableFrame)(This,(IDirect3DRMFrame *)enable);
	return;
}



Container * __cdecl
lego::res::Container_MakeLight(Container *parent,D3DRMLightType type,float r,float g,float b)
{
	Container *cont;
	HRESULT HVar1;
	IDirect3DRM3 *light;
	IDirect3DRMLight *lpD3DRMLight;
	
	cont = Container_Create(parent);
	if (cont != (Container *)0x0) {
		cont->type = RESOURCE_LIGHT;
										// IDirect3DRM3->CreateLightRGB(this, TD3DRMLightType ltLightType, float vRed,
										// float vGreen, float vBlue, IDirect3DRMLight** lplpD3DRMLight)
		light = globs::mainGlobs.lpD3DRM;
		lpD3DRMLight = (IDirect3DRMLight *)r;
		HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateLightRGB)
											(globs::mainGlobs.lpD3DRM,type,r,g,b,(IDirect3DRMLight **)&parent);
		if (HVar1 == 0) {
										// IDirect3DRMFrame3->AddLight(this, IDirect3DRMLight* lpD3DRMLight)
			(*cont->activityFrame->lpVtbl->AddLight)(cont->activityFrame,lpD3DRMLight);
			Container_SetTypeData
								(cont,(char *)0x0,(IDirect3DRMLight *)light,(IDirect3DRMMesh *)0x0,(Mesh *)0x0);
		}
	}
	return cont;
}



Container * __cdecl lego::res::Container_MakeMesh2(Container *parent,int unkMode)
{
	int iVar1;
	Container *cont;
	HRESULT HVar2;
	void **data;
	void *pvVar3;
	uint renderFlags;
	Mesh *transMesh;
	IDirect3DRMMesh *unaff_ESI;
	
	cont = Container_Create(parent);
	iVar1 = unkMode;
	if (cont != (Container *)0x0) {
		cont->type = RESOURCE_MESH;
		if (((unkMode == 3) || (unkMode == 2)) || (unkMode == 4)) {
			renderFlags = 0x2000;
			if (unkMode == 3) {
				renderFlags = 0x3000;
			}
			else {
				if (unkMode == 4) {
					renderFlags = 0x2800;
				}
			}
			transMesh = Mesh_CreateOnFrame(cont->activityFrame,(MeshRenderCallback *)0x0,renderFlags,
																		 (void *)0x0,0);
			Container_SetTypeData
								(cont,(char *)0x0,(IDirect3DRMLight *)0x0,(IDirect3DRMMesh *)0x0,transMesh);
		}
		else {
			HVar2 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateMesh)
												(globs::mainGlobs.lpD3DRM,(IDirect3DRMMesh **)&parent);
			if (HVar2 == 0) {
				(*cont->activityFrame->lpVtbl->AddVisual)(cont->activityFrame,(IDirect3DRMVisual *)parent);
				Container_SetTypeData(cont,(char *)0x0,(IDirect3DRMLight *)0x0,unaff_ESI,(Mesh *)0x0);
				if (iVar1 == 1) {
					data = (void **)std::malloc(0x14);
					data[2] = &DAT_00000014;
					data[1] = (void *)0x0;
					pvVar3 = std::malloc(0x50);
					*data = pvVar3;
					data[3] = (void *)0x0;
					data[4] = (void *)0x1;
					(*unaff_ESI->lpVtbl->SetAppData)((IUnknown *)unaff_ESI,(DWORD)data);
					return cont;
				}
				(*unaff_ESI->lpVtbl->SetAppData)((IUnknown *)unaff_ESI,0);
				return cont;
			}
		}
	}
	return cont;
}



IDirect3DRMFrame3 * __cdecl lego::res::Container_GetMasterFrame(Container *cont)
{
	return cont->masterFrame;
}



// WARNING: Type propagation algorithm not settling

Container * __cdecl lego::res::Container_Clone(Container *orig)
{
	char cVar1;
	IDirect3DRMMesh *pIVar2;
	Container_TypeData *pCVar3;
	ResourceType RVar4;
	Container *pCVar5;
	Container *parent;
	Container **ppCVar6;
	Container_TypeData *pCVar7;
	char *pcVar8;
	Container_CloneData *pCVar9;
	float fVar10;
	IDirect3DRMFrame3 **out_frameList;
	char **out_nameList;
	char *pcVar11;
	AnimClone *pAVar12;
	Mesh *pMVar13;
	uint uVar14;
	uint uVar15;
	Container *cont;
	undefined4 *puVar16;
	IDirect3DRMFrame3 **ppIVar17;
	Container *pCVar18;
	undefined4 *puVar19;
	float10 fVar20;
	IDirect3DRMFrame3 *This;
	float fVar21;
	char **ppcVar22;
	char **ppcVar23;
	IDirect3DRMFrame3 **ppIVar24;
	undefined local_54 [52];
	float fStack32;
	int *piStack28;
	IDirect3DRMFrame3 *pIStack4;
	
	cont = orig;
	pCVar18 = (Container *)0x0;
	if (orig->type == RESOURCE_MESH) {
		pIVar2 = orig->typeData->mesh;
		(*pIVar2->lpVtbl->GetAppData)((IUnknown *)pIVar2);
	}
	if ((cont->type == RESOURCE_ACT) || (cont->type == RESOURCE_ANIM)) {
		if ((cont->cloneData != (Container_CloneData *)0x0) &&
			 (pCVar5 = cont->cloneData->clonedFrom, pCVar5 != (Container *)0x0)) {
			cont = pCVar5;
		}
		pCVar9 = cont->cloneData;
		if (pCVar9 == (Container_CloneData *)0x0) {
			pCVar5 = Container_GetParent(cont);
			pCVar5 = Container_Create(pCVar5);
			pCVar9 = (Container_CloneData *)std::malloc(0x14);
			cont->cloneData = pCVar9;
			pCVar9->cloneCount = 1;
			ppCVar6 = (Container **)std::malloc(4);
			cont->cloneData->cloneTable = ppCVar6;
			((Container *)cont->cloneData->cloneTable)->masterFrame = (IDirect3DRMFrame3 *)pCVar5;
			cont->cloneData->clonedFrom = (Container *)0x0;
			cont->cloneData->cloneNumber = (IDirect3DRMFrame3 *)0x0;
			cont->cloneData->used = 1;
		}
		else {
			pCVar5 = cont;
			if (pCVar9->used != 0) {
				uVar14 = 0;
				pCVar5 = pCVar18;
				if (pCVar9->cloneCount != 0) {
					ppCVar6 = pCVar9->cloneTable;
					do {
						pCVar5 = *ppCVar6;
						if ((pCVar5 != (Container *)0x0) && (pCVar5->cloneData->used == 0)) break;
						uVar14 = uVar14 + 1;
						ppCVar6 = ppCVar6 + 1;
						pCVar5 = pCVar18;
					} while (uVar14 < pCVar9->cloneCount);
				}
			}
			pCVar18 = pCVar5;
			if (pCVar5 == (Container *)0x0) {
				pCVar5 = Container_GetParent(cont);
				pCVar5 = Container_Create(pCVar5);
				uVar14 = cont->cloneData->cloneCount;
				cont->cloneData->cloneCount = uVar14 + 1;
				ppCVar6 = (Container **)
									std::realloc(cont->cloneData->cloneTable,cont->cloneData->cloneCount << 2);
				cont->cloneData->cloneTable = ppCVar6;
				cont->cloneData->cloneTable[uVar14] = pCVar5;
			}
			else {
				pCVar5->cloneData->used = 1;
				parent = Container_GetParent(cont);
				Container_SetParent(pCVar5,parent);
				Container_SetAnimationTime(pCVar5,0.0);
			}
		}
	}
	else {
		pCVar5 = Container_GetParent(cont);
		pCVar5 = Container_Create(pCVar5);
	}
	(*cont->activityFrame->lpVtbl->GetParent)(cont->activityFrame,(IDirect3DRMFrame3 **)&orig);
	This = cont->activityFrame;
	(*This->lpVtbl->GetTransform)(This,pIStack4,(Matrix4F *)(local_54 + 0xc));
	(*pCVar5->activityFrame->lpVtbl->AddTransform)
						(pCVar5->activityFrame,D3DRMCOMBINE_REPLACE,(Matrix4F *)local_54);
	(**(code **)(*piStack28 + 8))(piStack28);
	if (pCVar18 == (Container *)0x0) {
		pCVar5->type = cont->type;
		if (cont->typeData == (Container_TypeData *)0x0) {
			pCVar5->typeData = (Container_TypeData *)0x0;
		}
		else {
			pCVar7 = (Container_TypeData *)std::malloc(0x10);
			pCVar5->typeData = pCVar7;
			pCVar3 = cont->typeData;
			pCVar7->name = pCVar3->name;
			pCVar7->light = pCVar3->light;
			pCVar7->mesh = pCVar3->mesh;
			pCVar7->transMesh = pCVar3->transMesh;
			pcVar8 = cont->typeData->name;
			if (pcVar8 != (char *)0x0) {
				uVar14 = 0xffffffff;
				do {
					if (uVar14 == 0) break;
					uVar14 = uVar14 - 1;
					cVar1 = *pcVar8;
					pcVar8 = pcVar8 + 1;
				} while (cVar1 != '\0');
				pcVar8 = (char *)std::malloc(~uVar14);
				pCVar5->typeData->name = pcVar8;
				uVar14 = 0xffffffff;
				pcVar8 = cont->typeData->name;
				do {
					pcVar11 = pcVar8;
					if (uVar14 == 0) break;
					uVar14 = uVar14 - 1;
					pcVar11 = pcVar8 + 1;
					cVar1 = *pcVar8;
					pcVar8 = pcVar11;
				} while (cVar1 != '\0');
				uVar14 = ~uVar14;
				puVar16 = (undefined4 *)(pcVar11 + -uVar14);
				puVar19 = (undefined4 *)pCVar5->typeData->name;
				for (uVar15 = uVar14 >> 2; uVar15 != 0; uVar15 = uVar15 - 1) {
					*puVar19 = *puVar16;
					puVar16 = puVar16 + 1;
					puVar19 = puVar19 + 1;
				}
				for (uVar14 = uVar14 & 3; uVar14 != 0; uVar14 = uVar14 - 1) {
					*(undefined *)puVar19 = *(undefined *)puVar16;
					puVar16 = (undefined4 *)((int)puVar16 + 1);
					puVar19 = (undefined4 *)((int)puVar19 + 1);
				}
			}
		}
		if ((cont->type == RESOURCE_ACT) || (cont->type == RESOURCE_ANIM)) {
			pCVar9 = (Container_CloneData *)std::malloc(0x14);
			pCVar5->cloneData = pCVar9;
			pCVar9->cloneTable = (Container **)0x0;
			pCVar5->cloneData->cloneCount = 0;
			pCVar5->cloneData->clonedFrom = cont;
			pCVar5->cloneData->cloneNumber = This;
			pCVar5->cloneData->used = 1;
		}
		RVar4 = pCVar5->type;
		if (RVar4 == RESOURCE_MESH) {
			pIVar2 = pCVar5->typeData->mesh;
			(*pCVar5->activityFrame->lpVtbl->AddVisual)(pCVar5->activityFrame,(IDirect3DRMVisual *)pIVar2)
			;
			(*pIVar2->lpVtbl->AddRef)((IUnknown *)pIVar2);
			return pCVar5;
		}
		if (RVar4 == RESOURCE_ACT) {
			fVar10 = (float)Container_GetActivities
																(cont,(IDirect3DRMFrame3 **)0x0,(AnimClone **)0x0,(char **)0x0);
			uVar14 = (int)fVar10 * 4;
			out_frameList = (IDirect3DRMFrame3 **)std::malloc(uVar14);
			ppIVar24 = out_frameList;
			out_nameList = (char **)std::malloc(uVar14);
			ppcVar23 = out_nameList;
			Container_GetActivities(cont,out_frameList,(AnimClone **)0x0,out_nameList);
			fStack32 = 0.0;
			if (fVar10 != 0.0) {
				ppIVar17 = out_frameList;
				ppcVar22 = (char **)((int)out_nameList - (int)out_frameList);
				out_nameList = ppcVar23;
				out_frameList = ppIVar24;
				do {
					pcVar8 = Container_Frame_GetAnimSetFileName(*ppIVar17);
					fVar20 = Container_Frame_GetTransCo(*ppIVar17);
					fVar21 = (float)fVar20;
					pcVar11 = Container_Frame_GetSample(*ppIVar17);
					pAVar12 = Container_Frame_GetAnimClone(*ppIVar17);
					uVar14 = Container_Frame_GetTrigger(*ppIVar17);
					Container_Frame_SetAppData
										(*ppIVar17,(Container *)0x0,(AnimClone *)0x0,(char *)0x0,(uint *)0x0,(char *)0x0
										 ,(float *)0x0,(float *)0x0,(char *)0x0,(Sound3D_SoundFrameRecord *)0x0,
										 (uint *)0x0);
					ppcVar23 = ppcVar22;
					Container_AddActivity2
										(pCVar5,pcVar8,(char *)(*(int *)((int)ppcVar22 + (int)ppIVar17) + 9),fVar21,
										 uVar14,pcVar11,pAVar12,0,0);
					std::free(*(void **)((int)ppcVar22 + (int)ppIVar17));
					fVar21 = fStack32;
					if ((uint)fStack32 % 0x19 == 0) {
						snd::Sound3D_Update();
					}
					fStack32 = (float)((int)fVar21 + 1);
					ppIVar17 = ppIVar17 + 1;
					ppcVar22 = ppcVar23;
				} while ((uint)fStack32 < (uint)fVar10);
			}
			std::free(out_frameList);
			std::free(out_nameList);
			if (pCVar5->typeData != (Container_TypeData *)0x0) {
				Container_SetActivity(pCVar5,pCVar5->typeData->name);
				return pCVar5;
			}
		}
		else {
			if (RVar4 == RESOURCE_ANIM) {
				pcVar8 = Container_Frame_GetAnimSetFileName(cont->activityFrame);
				pAVar12 = Container_Frame_GetAnimClone(cont->activityFrame);
				pAVar12 = AnimClone_Make(pAVar12,pCVar5->activityFrame,(uint *)&fStack32);
				Container_Frame_SetAppData
									(pCVar5->activityFrame,pCVar5,pAVar12,pcVar8,(uint *)&fStack32,(char *)0x0,
									 (float *)0x0,(float *)0x0,(char *)0x0,(Sound3D_SoundFrameRecord *)0x0,(uint *)0x0
									);
				return pCVar5;
			}
			if (RVar4 == RESOURCE_LWO) {
				pMVar13 = Mesh_Clone(pCVar5->typeData->transMesh,pCVar5->activityFrame);
				pCVar5->typeData->transMesh = pMVar13;
			}
		}
	}
	return pCVar5;
}



void __cdecl lego::res::Container_Hide2(Container *cont,BOOL hide)
{
	if (hide != 0) {
		cont->flags = cont->flags | RESDATA_UNK_80;
		return;
	}
	cont->flags = cont->flags & ~RESDATA_UNK_80;
	return;
}



void __cdecl lego::res::Container_Hide(Container *cont,BOOL hide)
{
	ResourceDataFlags RVar1;
	
	RVar1 = cont->flags & RESDATA_UNK_8;
	if (hide != 0) {
		if (RVar1 == RESDATA_NONE) {
			Container_Frame_SafeAddChild(cont->hiddenFrame,cont->activityFrame);
			cont->flags = cont->flags | RESDATA_UNK_8;
			return;
		}
		if (hide != 0) {
			return;
		}
	}
	if (RVar1 != RESDATA_NONE) {
		Container_Frame_SafeAddChild(cont->masterFrame,cont->activityFrame);
		cont->flags = cont->flags & ~RESDATA_UNK_8;
	}
	return;
}



BOOL __cdecl lego::res::Container_IsHidden(Container *cont)
{
	return (cont->flags & 0xff) >> 3 & 1;
}



Container * __cdecl
lego::res::Container_SearchTree
					(Container *root,char *name,ContainerSearchMode mode,undefined4 *ref_count)
{
	char cVar1;
	Container *pCVar2;
	uint uVar3;
	Container_SearchData search;
	
	uVar3 = 0xffffffff;
	search.string = name;
	do {
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		cVar1 = *name;
		name = name + 1;
	} while (cVar1 != '\0');
	search.stringLen = ~uVar3 - 1;
	search.caseSensitive = 0;
	search.resultFrame = (IDirect3DRMFrame3 *)0x0;
	search.count = 0;
	search.mode = mode;
	if (ref_count == (undefined4 *)0x0) {
		search.matchNumber = 0;
	}
	else {
		search.matchNumber = *ref_count;
	}
	Container_Frame_WalkTree(root->masterFrame,0,Container_Frame_SearchCallback,&search);
	if ((mode == CONTAINER_SEARCHMODE_FIRSTMATCH) || (mode == CONTAINER_SEARCHMODE_NTHMATCH)) {
		if (search.resultFrame != (IDirect3DRMFrame3 *)0x0) {
			pCVar2 = Container_Frame_GetContainer(search.resultFrame);
			return pCVar2;
		}
	}
	else {
		if (mode == CONTAINER_SEARCHMODE_MATCHCOUNT) {
			*ref_count = search.count;
			return (Container *)0x0;
		}
	}
	return (Container *)0x0;
}



// Returns a temporary buffer that must be used immediately before the next call to this function.

char * __cdecl lego::res::Container_FormatPartName(Container *cont,char *partname,int *opt_instance)
{
	char *pcVar1;
	AnimClone *clone;
	BOOL BVar2;
	char *pcVar3;
	char *pcVar4;
	IDirect3DRMFrame3 *frame;
	char tempString [1024];
	
	if (cont->type == RESOURCE_ACT) {
		frame = Container_Frame_Find(cont,cont->typeData->name,0);
	}
	else {
		if (cont->type == RESOURCE_ANIM) {
			frame = cont->activityFrame;
		}
	}
	clone = Container_Frame_GetAnimClone(frame);
	BVar2 = AnimClone_IsLws(clone);
	if (BVar2 == 0) {
		pcVar3 = Container_Frame_GetAnimSetFileName(frame);
		std::sprintf(tempString,"%s",pcVar3);
		std::_strlwr(tempString);
		pcVar4 = tempString;
		pcVar3 = tempString;
		while (tempString[0] != '\0') {
			if (tempString[0] == '\\') {
				pcVar3 = pcVar4 + 1;
			}
			pcVar1 = pcVar4 + 1;
			pcVar4 = pcVar4 + 1;
			tempString[0] = *pcVar1;
		}
		if (opt_instance != (int *)0x0) {
			std::sprintf(globs::s_FormatPartName_name,"xf_????????_%s_%s_%0.2d_DDc_00",partname,pcVar3,
									 *opt_instance);
			return globs::s_FormatPartName_name;
		}
		pcVar4 = "xf_????????_%s_%s_??_DDc_00";
	}
	else {
		if (opt_instance == (int *)0x0) {
			std::sprintf(globs::s_FormatPartName_name,"%s_??",partname);
			return globs::s_FormatPartName_name;
		}
		pcVar3 = (char *)*opt_instance;
		pcVar4 = "%s_%0.2i";
	}
	std::sprintf(globs::s_FormatPartName_name,pcVar4,partname,pcVar3);
	return globs::s_FormatPartName_name;
}



void __cdecl lego::res::Container_SetUserData(Container *cont,void *data)
{
	cont->userData = data;
	return;
}



void * __cdecl lego::res::Container_GetUserData(Container *cont)
{
	return cont->userData;
}



void __cdecl lego::res::Container_EnableFog(BOOL on)
{
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneFogEnable)
						((globs::containerGlobs.rootContainer)->masterFrame,on);
	if (on != 0) {
		(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneBackground)
							((globs::containerGlobs.rootContainer)->masterFrame,globs::containerGlobs.fogColour);
		return;
	}
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneBackground)
						((globs::containerGlobs.rootContainer)->masterFrame,0);
	return;
}



void __cdecl lego::res::Container_SetFogColour(float r,float g,float b)
{
	longlong lVar1;
	longlong lVar2;
	longlong lVar3;
	
	lVar1 = __ftol((float10)g * (float10)255.0);
	lVar2 = __ftol((float10)r * (float10)255.0);
	lVar3 = __ftol((float10)b * (float10)255.0);
	globs::containerGlobs.fogColour =
			 ((uint)lVar1 | ((uint)lVar2 | 0xffffff00) << 8) << 8 | (uint)lVar3;
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneFogColor)
						((globs::containerGlobs.rootContainer)->masterFrame,globs::containerGlobs.fogColour);
	return;
}



void __cdecl lego::res::Container_SetFogMode(D3DRMSceneFogMethod mode)
{
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneFogMode)
						((globs::containerGlobs.rootContainer)->masterFrame,mode);
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneFogMethod)
						((globs::containerGlobs.rootContainer)->masterFrame,globs::mainGlobs.fogMethod);
	return;
}



void __cdecl lego::res::Container_SetFogParams(float start,float end,float density)
{
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneFogParams)
						((globs::containerGlobs.rootContainer)->masterFrame,start,end,density);
	return;
}



void __cdecl lego::res::Container_SetPerspectiveCorrection(Container *cont,BOOL on)
{
	uint uVar1;
	IDirect3DRMFrame3 **out_frameList;
	D3DRMGroupIndex DVar2;
	IDirect3DRMFrame3 **ppIVar3;
	D3DRMGroupIndex groupID;
	
	if (cont->type == RESOURCE_ACT) {
		uVar1 = Container_GetActivities(cont,(IDirect3DRMFrame3 **)0x0,(AnimClone **)0x0,(char **)0x0);
		out_frameList = (IDirect3DRMFrame3 **)std::malloc(uVar1 * 4);
		Container_GetActivities(cont,out_frameList,(AnimClone **)0x0,(char **)0x0);
		ppIVar3 = out_frameList;
		for (; uVar1 != 0; uVar1 = uVar1 - 1) {
			Container_Frame_WalkTree(*ppIVar3,0,Container_SetPerspectiveCorrectionCallback,&on);
			ppIVar3 = ppIVar3 + 1;
		}
		std::free(out_frameList);
		return;
	}
	if (cont->type == RESOURCE_MESH) {
		DVar2 = Container_Mesh_GetGroupCount(cont);
		groupID = D3DRMGROUP_0;
		if (DVar2 != D3DRMGROUP_0) {
			do {
				Container_Mesh_SetPerspectiveCorrection(cont,groupID,on);
				groupID = groupID + 1;
			} while (groupID < DVar2);
		}
	}
	return;
}



BOOL __cdecl
lego::res::Container_SetPerspectiveCorrectionCallback(IDirect3DRMFrame3 *frame,BOOL *lpArg_on)
{
	BOOL BVar1;
	HRESULT HVar2;
	IDirect3DRMVisual *pIVar3;
	IDirect3DRMVisual **ppIVar4;
	int *unaff_ESI;
	IDirect3DRMVisual *lpD3DRMVisual;
	BOOL *local_8;
	LPVOID local_4;
	
	BVar1 = *lpArg_on;
										// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount,
										// IDirect3DRMVisualArray** lplpVisuals)
										// 
										// First get count of array, to confirm its non-zero
	(*frame->lpVtbl->GetVisuals)(frame,(DWORD *)&lpArg_on,(IDirect3DRMVisualArray **)0x0);
	if (lpArg_on != (BOOL *)0x0) {
										// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount,
										// IDirect3DRMVisualArray** lplpVisuals)
										// 
										// Then get the actual array
		(*frame->lpVtbl->GetVisuals)
							(frame,(DWORD *)&lpArg_on,(IDirect3DRMVisualArray **)globs::containerGlobs.visualArray
							);
		local_8 = (BOOL *)0x0;
		if (lpArg_on != (BOOL *)0x0) {
			ppIVar4 = globs::containerGlobs.visualArray;
			do {
				pIVar3 = *ppIVar4;
				HVar2 = (*pIVar3->lpVtbl->QueryInterface)
													((IUnknown *)pIVar3,(IID *)&idl::IID_IDirect3DRMMeshBuilder2,&local_4);
				if (HVar2 == 0) {
					(**(code **)(*unaff_ESI + 0x7c))(unaff_ESI,BVar1);
				}
				else {
					HVar2 = (*pIVar3->lpVtbl->QueryInterface)
														((IUnknown *)pIVar3,(IID *)&idl::IID_IDirect3DRMMesh,&local_8);
					if (HVar2 == 0) {
						pIVar3 = (IDirect3DRMVisual *)(*frame->lpVtbl->GetMaterialMode)(frame);
						lpD3DRMVisual = (IDirect3DRMVisual *)0x0;
						if (pIVar3 != (IDirect3DRMVisual *)0x0) {
							do {
								(*frame->lpVtbl->AddVisual)(frame,lpD3DRMVisual);
								lpD3DRMVisual =
										 (IDirect3DRMVisual *)((int)&lpD3DRMVisual->lpVtbl + D3DRMMATERIAL_FROMPARENT);
							} while (lpD3DRMVisual < pIVar3);
						}
					}
				}
				local_8 = (BOOL *)((int)local_8 + 1);
				ppIVar4 = ppIVar4 + 1;
			} while (local_8 < lpArg_on);
		}
	}
	return 0;
}



// WARNING: Type propagation algorithm not settling

IDirectDrawSurface4 * __cdecl
lego::res::Container_LoadTextureSurface
					(char *fname,BOOL managed,uint *out_width,uint *out_height,BOOL *out_trans)
{
	BITMAP_FILE_INFO_STRUCT *data;
	HRESULT HVar1;
	BOOL BVar2;
	IDirectDrawSurface4 *pIVar3;
	int iVar4;
	uint uVar5;
	DDSURFACEDESC2 *pDVar6;
	undefined4 *puVar7;
	DDSURFACEDESC2 *pDVar8;
	DDPIXELFORMAT *pDVar9;
	undefined4 *puVar10;
	IDirectDrawSurface4 *ddSurface4;
	uint local_14c;
	DDCOLORKEY local_148;
	IDirectDrawPalette *ddPal2;
	uint length;
	D3DRMImage d3dImage;
	DDSURFACEDESC2 surfDesc;
	DDSURFACEDESC2 local_7c;
	
	ddSurface4 = (IDirectDrawSurface4 *)0x0;
	local_148.dwColorSpaceLowValue = 0;
	data = (BITMAP_FILE_INFO_STRUCT *)lego::file::File_LoadBinary(fname,&length);
	if (data != (BITMAP_FILE_INFO_STRUCT *)0x0) {
		image::BMP_Parse(data,length,&d3dImage);
		if ((d3dImage.rgb == 0) && (d3dImage.depth == 8)) {
			pDVar6 = &surfDesc;
			for (iVar4 = 0x1f; iVar4 != 0; iVar4 = iVar4 + -1) {
				pDVar6->dwSize = 0;
				pDVar6 = (DDSURFACEDESC2 *)&pDVar6->dwFlags;
			}
			surfDesc.dwSize = 0x7c;
										// CMD_NM 0x20
			surfDesc.dwFlags = 0x1007;
			surfDesc.dwWidth = d3dImage.width;
			surfDesc.dwHeight = d3dImage.height;
			surfDesc.ddsCaps.dwCaps = 0x1000;
			if ((((byte)globs::mainGlobs.flags & 0x20) == 0) && (managed != 0)) {
				surfDesc.ddsCaps.dwCaps2 = 0x10;
			}
			else {
				surfDesc.ddsCaps.dwCaps = 0x5000;
			}
			surfDesc.ddpfPixelFormat.dwSize = 0x20;
			HVar1 = (*(globs::mainGlobs.device)->lpVtbl->FindPreferredTextureFormat)
												(globs::mainGlobs.device,0x800,4,&surfDesc.ddpfPixelFormat);
			if (HVar1 != 0) {
				pDVar6 = &surfDesc;
				pDVar8 = &local_7c;
				for (iVar4 = 0x1f; iVar4 != 0; iVar4 = iVar4 + -1) {
					pDVar8->dwSize = pDVar6->dwSize;
					pDVar6 = (DDSURFACEDESC2 *)&pDVar6->dwFlags;
					pDVar8 = (DDSURFACEDESC2 *)&pDVar8->dwFlags;
				}
				pDVar9 = &surfDesc.ddpfPixelFormat;
				for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {
					pDVar9->dwSize = 0;
					pDVar9 = (DDPIXELFORMAT *)&pDVar9->dwFlags;
				}
				surfDesc.ddsCaps.dwCaps2 = surfDesc.ddsCaps.dwCaps2 & 0xffffffef;
				surfDesc.ddsCaps.dwCaps = surfDesc.ddsCaps.dwCaps & 0xffffafff | 0x840;
				surfDesc.ddpfPixelFormat.dwSize = 0x20;
				surfDesc.ddpfPixelFormat.dwFlags = 0x60;
				surfDesc.ddpfPixelFormat.dwRGBBitCount = 8;
				local_148.dwColorSpaceLowValue = 1;
			}
			HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
												(globs::directDrawGlobs.lpDirectDraw,&surfDesc,&ddSurface4,(IUnknown *)0x0);
			if (HVar1 == 0) {
				pDVar6 = &surfDesc;
				for (iVar4 = 0x1f; iVar4 != 0; iVar4 = iVar4 + -1) {
					pDVar6->dwSize = 0;
					pDVar6 = (DDSURFACEDESC2 *)&pDVar6->dwFlags;
				}
				surfDesc.dwSize = 0x7c;
				HVar1 = (*ddSurface4->lpVtbl->Lock)(ddSurface4,(LPRECT)0x0,&surfDesc,1,(HANDLE)0x0);
				if (HVar1 == 0) {
					iVar4 = 0;
					if (0 < d3dImage.height) {
						do {
							puVar7 = (undefined4 *)d3dImage.buffer1;
							puVar10 = (undefined4 *)surfDesc.lpSurface;
							for (uVar5 = (uint)d3dImage.bytes_per_line >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
								*puVar10 = *puVar7;
								puVar7 = puVar7 + 1;
								puVar10 = puVar10 + 1;
							}
							for (uVar5 = d3dImage.bytes_per_line & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
								*(undefined *)puVar10 = *(undefined *)puVar7;
								puVar7 = (undefined4 *)((int)puVar7 + 1);
								puVar10 = (undefined4 *)((int)puVar10 + 1);
							}
							surfDesc.lpSurface = (LPVOID)((int)surfDesc.lpSurface + surfDesc.lPitch);
							d3dImage.buffer1 = (byte *)((int)d3dImage.buffer1 + d3dImage.bytes_per_line);
							iVar4 = iVar4 + 1;
						} while (iVar4 < d3dImage.height);
					}
					(*ddSurface4->lpVtbl->Unlock)(ddSurface4,(LPRECT)0x0);
					HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreatePalette)
														(globs::directDrawGlobs.lpDirectDraw,0x4c,
														 (D3DRMPaletteEntry *)d3dImage.alpha_mask,
														 (IDirectDrawPalette **)&local_148.dwColorSpaceHighValue,(IUnknown *)0x0
														);
					if (HVar1 == 0) {
						HVar1 = (*ddSurface4->lpVtbl->SetPalette)(ddSurface4,ddPal2);
						if (HVar1 == 0) {
							if (local_148.dwColorSpaceLowValue != 0) {
								puVar7 = (undefined4 *)&local_7c.ddpfPixelFormat;
								for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {
									*puVar7 = 0;
									puVar7 = puVar7 + 1;
								}
								local_7c.ddpfPixelFormat.dwSize = 0x20;
								HVar1 = (*(globs::mainGlobs.device)->lpVtbl->FindPreferredTextureFormat)
																	(globs::mainGlobs.device,0x400,0,&local_7c.ddpfPixelFormat);
								pIVar3 = ddSurface4;
								if ((HVar1 == 0) &&
									 (HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
																			(globs::directDrawGlobs.lpDirectDraw,&local_7c,&ddSurface4,
																			 (IUnknown *)0x0), HVar1 == 0)) {
									if (local_7c.ddpfPixelFormat.dwRGBBitCount == 0x10) {
										ddraw::DirectDraw_Blt8To16(ddSurface4,pIVar3,d3dImage.palette);
									}
									(*pIVar3->lpVtbl->Release)(pIVar3);
								}
							}
							if (out_trans != (BOOL *)0x0) {
								BVar2 = Container_GetDecalColour(fname,&local_14c);
								if (BVar2 == 0) {
									*out_trans = 0;
								}
								else {
									if (local_148.dwColorSpaceLowValue != 0) {
										local_14c = ddraw::DirectDraw_GetColour
																					(ddSurface4,
																					 (uint)CONCAT21(CONCAT11(d3dImage.palette[local_14c].red,
																																	 d3dImage.palette[local_14c].green
																																	),d3dImage.palette[local_14c].blue
																												 ));
									}
									local_148.dwColorSpaceLowValue = local_14c;
									local_148.dwColorSpaceHighValue = local_14c;
									(*ddSurface4->lpVtbl->SetColorKey)(ddSurface4,8,&local_148);
									*out_trans = 1;
								}
							}
							if (out_width != (uint *)0x0) {
								*out_width = d3dImage.width;
							}
							if (out_height != (uint *)0x0) {
								*out_height = d3dImage.height;
							}
							(*ddSurface4->lpVtbl->AddRef)((IUnknown *)ddSurface4);
						}
						(*ddPal2->lpVtbl->Release)(ddPal2);
					}
				}
				pIVar3 = (IDirectDrawSurface4 *)(*ddSurface4->lpVtbl->Release)(ddSurface4);
				if (pIVar3 == (IDirectDrawSurface4 *)0x0) {
					ddSurface4 = pIVar3;
				}
			}
		}
		image::BMP_Cleanup(&d3dImage);
		std::free(data);
	}
	return ddSurface4;
}



BOOL __cdecl lego::res::Container_GetDecalColour(char *fname,uint *out_colour)
{
	char *pcVar1;
	byte *str;
	char cVar2;
	uint uVar3;
	char *pcVar4;
	
	cVar2 = *fname;
	pcVar4 = fname;
	while (cVar2 != '\0') {
		if (cVar2 == '\\') {
			pcVar4 = fname + 1;
		}
		pcVar1 = fname + 1;
		fname = fname + 1;
		cVar2 = *pcVar1;
	}
	if ((*pcVar4 == 'a') || (*pcVar4 == 'A')) {
		str = (byte *)(pcVar4 + 1);
										// std::isdigit(c)
		if (std::globals::_pcharwidth < 2) {
			uVar3 = *(byte *)(std::globals::_pctype + *str) & C1_DIGIT;
		}
		else {
			uVar3 = std::_isctype((uint)*str,4);
		}
		if (uVar3 != 0) {
										// std::isdigit(c)
			if (std::globals::_pcharwidth < 2) {
				uVar3 = *(byte *)(std::globals::_pctype + (byte)pcVar4[2]) & C1_DIGIT;
			}
			else {
				uVar3 = std::_isctype((uint)(byte)pcVar4[2],4);
			}
			if (uVar3 != 0) {
										// std::isdigit(c)
				if (std::globals::_pcharwidth < 2) {
					uVar3 = *(byte *)(std::globals::_pctype + (byte)pcVar4[3]) & C1_DIGIT;
				}
				else {
					uVar3 = std::_isctype((uint)(byte)pcVar4[3],4);
				}
				if ((uVar3 != 0) && (pcVar4[4] == '_')) {
					uVar3 = std::atoi((char *)str);
					*out_colour = uVar3;
					return TRUE;
				}
			}
		}
	}
	return 0;
}



// WARNING: Type propagation algorithm not settling

Container_Texture * __cdecl
lego::res::Container_LoadTexture2(char *fname,BOOL immediate,uint *out_width,uint *out_height)
{
	byte bVar1;
	byte bVar2;
	D3DRMPaletteEntry *pDVar3;
	int *piVar4;
	char *fname_00;
	char *lpFileName;
	Container_Texture *buffer;
	IDirectDrawSurface4 *This;
	HRESULT HVar5;
	BOOL BVar6;
	D3DRMImage *pDVar7;
	int *piVar8;
	byte bVar9;
	undefined uVar10;
	ushort uVar11;
	undefined uVar12;
	undefined uVar13;
	undefined2 uVar14;
	IDirect3DRMTexture3 *local_c;
	Container_Texture *local_8;
	undefined4 uStack4;
	
	fname_00 = fname;
	local_c = (IDirect3DRMTexture3 *)0x0;
	lpFileName = lego::file::File_VerifyFilename(fname);
	buffer = (Container_Texture *)std::malloc(0xc);
	if (buffer != (Container_Texture *)0x0) {
		local_8 = buffer;
		if (immediate == 0) {
			HVar5 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->LoadTexture)
												(globs::mainGlobs.lpD3DRM,lpFileName,&local_c);
			if (HVar5 == 0) {
				pDVar7 = (*local_c->lpVtbl->GetImage)(local_c);
				if (pDVar7 != (D3DRMImage *)0x0) {
					BVar6 = Container_GetDecalColour(fname_00,(uint *)&fname);
					if (BVar6 != 0) {
						pDVar3 = pDVar7->palette;
						bVar9 = pDVar3[(int)fname].red;
						bVar1 = pDVar3[(int)fname].blue;
						bVar2 = pDVar3[(int)fname].green;
						(*local_c->lpVtbl->SetDecalTransparency)(local_c,1);
						(*local_c->lpVtbl->SetDecalTransparentColor)
											(local_c,(uint)CONCAT21(CONCAT11(bVar9,bVar2),bVar1));
						buffer = local_8;
					}
					if (out_width != (uint *)0x0) {
						*out_width = pDVar7->width;
					}
					if ((IDirectDrawPalette *)out_height != (IDirectDrawPalette *)0x0) {
						*out_height = (uint)((IDirectDrawPalette *)&pDVar7->height)->lpVtbl;
					}
				}
				buffer->surface = (IDirectDrawSurface4 *)0x0;
				buffer->texture = local_c;
				(*local_c->lpVtbl->SetAppData)((IUnknown *)local_c,(DWORD)buffer);
				return buffer;
			}
		}
		else {
			This = Container_LoadTextureSurface(fname_00,immediate,out_width,out_height,(BOOL *)0x0);
			if (This != (IDirectDrawSurface4 *)0x0) {
				HVar5 = (*This->lpVtbl->QueryInterface)
													((IUnknown *)This,(IID *)&idl::IID_IDirectDrawSurface,&out_width);
				if (HVar5 == 0) {
					HVar5 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateTextureFromSurface)
														(globs::mainGlobs.lpD3DRM,(IDirectDrawSurface4 *)out_width,&local_c);
					if (HVar5 == 0) {
						(**(code **)(*out_width + 8))((IUnknown *)out_width);
						BVar6 = Container_GetDecalColour(fname_00,(uint *)&fname);
						if (BVar6 != 0) {
							(*This->lpVtbl->GetPalette)(This,(IDirectDrawPalette **)&out_height);
							uVar12 = 1;
							uVar13 = 0;
							uVar14 = 0;
							bVar9 = (byte)uStack4;
							uVar10 = (undefined)((uint)uStack4 >> 8);
							uVar11 = (ushort)((uint)uStack4 >> 0x10);
							piVar8 = (int *)0x0;
										// IDirectDrawPalette::GetEntries(THIS_ DWORD dwFlags, DWORD dwBase, DWORD
										// dwNumEntries, D3DRMPALETTEENTRY* lpEntries)
							(**(code **)(*(int *)immediate + 0x10))(immediate,0,bVar9,1,&stack0xfffffff0);
							(*local_c->lpVtbl->Release)((IUnknown *)local_c);
							piVar4 = (int *)CONCAT22(uVar14,CONCAT11(uVar13,uVar12));
							(**(code **)(*piVar4 + 0x50))(piVar4,1);
							(**(code **)(*piVar8 + 0x54))
												(piVar8,((uint)bVar9 << 8 | CONCAT21(uVar11,uVar10) & 0xff) << 8 |
																uVar11 & 0xff);
						}
						buffer->surface = This;
						buffer->texture = local_c;
						(*local_c->lpVtbl->SetAppData)((IUnknown *)local_c,(DWORD)buffer);
						return buffer;
					}
					(**(code **)(*out_width + 8))();
				}
				(*This->lpVtbl->Release)((IUnknown *)This);
				std::free(buffer);
				return (Container_Texture *)0x0;
			}
		}
		std::free(buffer);
	}
	return (Container_Texture *)0x0;
}



void __cdecl lego::res::Container_FreeTexture(Container_Texture *text)
{
	IDirectDrawSurface4 *pIVar1;
	IDirect3DRMTexture3 *pIVar2;
	ULONG UVar3;
	
	if (text != (Container_Texture *)0x0) {
		pIVar1 = text->surface;
		if (pIVar1 != (IDirectDrawSurface4 *)0x0) {
			UVar3 = (*pIVar1->lpVtbl->Release)(pIVar1);
			while (UVar3 != 0) {
				UVar3 = (*text->surface->lpVtbl->Release)(text->surface);
			}
		}
		pIVar2 = text->texture;
		if (pIVar2 != (IDirect3DRMTexture3 *)0x0) {
			UVar3 = (*pIVar2->lpVtbl->Release)(pIVar2);
			while (UVar3 != 0) {
				UVar3 = (*text->texture->lpVtbl->Release)(text->texture);
			}
		}
	}
	return;
}



void __cdecl lego::res::Container_Mesh_Swap(Container *target,Container *origin,BOOL restore)
{
	IDirect3DRMVisual *pIVar1;
	IDirect3DRMMesh *lpD3DRMVisual;
	int unaff_EBX;
	uint uVar2;
	IDirect3DRMVisual **ppIVar3;
	IDirect3DRMFrame3 *This;
	
	if (target->type == RESOURCE_REFERENCE) {
		This = target->masterFrame;
	}
	else {
		This = target->activityFrame;
	}
	if (restore != 0) {
										// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount,
										// IDirect3DRMVisualArray** lplpVisuals)
										// 
										// First get count of array, to confirm its non-zero
		(*This->lpVtbl->GetVisuals)(This,(DWORD *)&restore,(IDirect3DRMVisual **)0x0);
		if (restore != 0) {
										// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount,
										// IDirect3DRMVisualArray** lplpVisuals)
										// 
										// Then get the actual array
			(*This->lpVtbl->GetVisuals)(This,(DWORD *)&restore,globs::containerGlobs.visualArray);
			uVar2 = 0;
			if (restore != 0) {
				ppIVar3 = globs::containerGlobs.visualArray;
				do {
					(*This->lpVtbl->DeleteVisual)(This,*ppIVar3);
					uVar2 = uVar2 + 1;
					ppIVar3 = ppIVar3 + 1;
				} while (uVar2 < (uint)restore);
			}
		}
		(*target->hiddenFrame->lpVtbl->GetVisuals)
							(target->hiddenFrame,(DWORD *)&restore,(IDirect3DRMVisual **)0x0);
		if (restore != 0) {
			(*target->hiddenFrame->lpVtbl->GetVisuals)
								(target->hiddenFrame,(DWORD *)&restore,globs::containerGlobs.visualArray);
			uVar2 = 0;
			if (restore != 0) {
				ppIVar3 = globs::containerGlobs.visualArray;
				do {
					pIVar1 = *ppIVar3;
					(*This->lpVtbl->AddVisual)(This,pIVar1);
					(**(code **)(**(int **)(unaff_EBX + 8) + 0xa0))(*(int **)(unaff_EBX + 8),pIVar1);
					uVar2 = uVar2 + 1;
					ppIVar3 = ppIVar3 + 1;
				} while (uVar2 < (uint)restore);
			}
		}
		target->flags = target->flags & 0xfffffffb;
		return;
	}
	(*This->lpVtbl->GetVisuals)(This,(DWORD *)&restore,(IDirect3DRMVisual **)0x0);
	if (restore != 0) {
		(*This->lpVtbl->GetVisuals)(This,(DWORD *)&restore,(IDirect3DRMVisual **)0x76be24);
		uVar2 = 0;
		if (restore != 0) {
			ppIVar3 = globs::containerGlobs.visualArray;
			do {
				pIVar1 = *ppIVar3;
				(*target->hiddenFrame->lpVtbl->AddVisual)(target->hiddenFrame,pIVar1);
				(*This->lpVtbl->DeleteVisual)(This,pIVar1);
				uVar2 = uVar2 + 1;
				ppIVar3 = ppIVar3 + 1;
			} while (uVar2 < (uint)restore);
		}
	}
	if (origin != (Container *)0x0) {
		lpD3DRMVisual = origin->typeData->mesh;
		if (lpD3DRMVisual == (IDirect3DRMMesh *)0x0) {
			(*This->lpVtbl->AddVisual)(This,(IDirect3DRMVisual *)origin->typeData->transMesh->uv);
			target->flags = target->flags | 4;
			return;
		}
		(*This->lpVtbl->AddVisual)(This,(IDirect3DRMVisual *)lpD3DRMVisual);
	}
	target->flags = target->flags | 4;
	return;
}



uint __cdecl
lego::res::Container_Mesh_AddGroup
					(Container *cont,uint vertexCount,uint faceCount,uint vPerFace,uint *faceData)
{
	Mesh *mesh;
	Container *pCVar1;
	void *pvVar2;
	void **ppvVar3;
	HRESULT HVar4;
	int iVar5;
	int *unaff_EDI;
	IDirect3DRMVisual *local_4;
	
	pCVar1 = cont;
	mesh = cont->typeData->transMesh;
	if (mesh != (Mesh *)0x0) {
		pvVar2 = (void *)Mesh_AddGroup(mesh,vertexCount,faceCount,vPerFace,faceData);
		return (uint)pvVar2;
	}
	cont = (Container *)cont->typeData->mesh;
	ppvVar3 = (void **)(*((IDirect3DRMMeshVtbl *)cont->masterFrame)->GetAppData)((IUnknown *)cont);
	if (ppvVar3 != (void **)0x0) {
		if (ppvVar3[4] == (void *)0x0) {
			if (ppvVar3[1] == ppvVar3[2]) {
				return (uint)(void *)0xffffffff;
			}
			HVar4 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateMesh)
												(globs::mainGlobs.lpD3DRM,(IDirect3DRMMesh **)&cont);
			if (HVar4 != 0) {
				return (uint)(void *)0xffffffff;
			}
			*(IDirect3DRMVisual **)((int)*ppvVar3 + (int)ppvVar3[1] * 4) = local_4;
			ppvVar3[1] = (void *)((int)ppvVar3[1] + 1);
			(*pCVar1->activityFrame->lpVtbl->AddVisual)(pCVar1->activityFrame,local_4);
			(**(code **)(*unaff_EDI + 0x18))(unaff_EDI,(uint)ppvVar3[1] | 0x80000000);
			if ((ppvVar3[1] == ppvVar3[2]) &&
				 (pvVar2 = std::realloc(*ppvVar3,(int)ppvVar3[2] * 4 + 0x50), pvVar2 != (void *)0x0)) {
				*ppvVar3 = pvVar2;
				ppvVar3[2] = (void *)((int)ppvVar3[2] + 0x14);
			}
		}
		else {
			ppvVar3[4] = (void *)0x0;
		}
	}
	iVar5 = (*(code *)cont->masterFrame[0xe].lpVtbl)
										(cont,vertexCount,faceCount,vPerFace,faceData,&local_4);
	if (iVar5 != 0) {
		return (uint)(void *)0xffffffff;
	}
	if (ppvVar3 == (void **)0x0) {
		return (uint)(void *)faceCount;
	}
	return (uint)ppvVar3[1];
}



uint __cdecl lego::res::Container_Mesh_GetGroupCount(Container *cont)
{
	Mesh *mesh;
	IDirect3DRMMesh *pIVar1;
	uint uVar2;
	DWORD DVar3;
	
	mesh = cont->typeData->transMesh;
	if (mesh != (Mesh *)0x0) {
		uVar2 = Mesh_GetGroupCount(mesh);
		return uVar2;
	}
	pIVar1 = cont->typeData->mesh;
	DVar3 = (*pIVar1->lpVtbl->GetAppData)((IUnknown *)pIVar1);
	if (DVar3 != 0) {
		return *(int *)(DVar3 + 4) + 1;
	}
	pIVar1 = cont->typeData->mesh;
	uVar2 = (*pIVar1->lpVtbl->GetGroupCount)(pIVar1);
	return uVar2;
}



void __cdecl
lego::res::Container_Mesh_SetQuality
					(Container *cont,D3DRMGroupIndex groupID,GraphicsQuality quality)
{
	Container *pCVar1;
	D3DRMRenderQuality uVar2;
	
	pCVar1 = cont;
	if (cont->typeData->transMesh == (Mesh *)0x0) {
										// D3DRM render quality, same as seen with Main::Quality
		uVar2 = 0x40;
		if (quality != QUALITY_WIREFRAME) {
			uVar2 = groupID;
		}
		if (quality == QUALITY_UNLITFLAT) {
			uVar2 = D3DRMRENDER_UNLITFLAT;
		}
		if (quality == QUALITY_FLAT) {
			uVar2 = 0x88;
		}
		if (quality == QUALITY_GOURAUD) {
			uVar2 = 0x89;
		}
		cont = (Container *)cont->typeData->mesh;
		Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
		(*pCVar1->typeData->mesh->lpVtbl->SetGroupQuality)((IDirect3DRMMesh *)cont,groupID,uVar2);
	}
	return;
}



BOOL __cdecl lego::res::Container_Mesh_IsGroupHidden(Container *cont,D3DRMGroupIndex group)
{
	Mesh *mesh;
	IDirect3DRMMesh *This;
	Container *pCVar1;
	int *piVar2;
	uint uVar3;
	
	mesh = cont->typeData->transMesh;
	if (mesh != (Mesh *)0x0) {
		pCVar1 = (Container *)Mesh_IsGroupHidden(mesh,group);
		return (BOOL)pCVar1;
	}
	This = cont->typeData->mesh;
	piVar2 = (int *)(*This->lpVtbl->GetAppData)((IUnknown *)This);
	if (piVar2 != (int *)0x0) {
		if (cont != (Container *)0x0) {
			piVar2 = *(int **)(*piVar2 + -4 + (int)cont * 4);
			uVar3 = (**(code **)(*piVar2 + 0x1c))(piVar2);
			return (BOOL)(~uVar3 >> 0x1f);
		}
		return (BOOL)(Container *)piVar2[3];
	}
	return (BOOL)cont;
}



void __cdecl lego::res::Container_Mesh_HideGroup(Container *cont,D3DRMGroupIndex group,BOOL hide)
{
	Mesh *mesh;
	int *piVar1;
	DWORD DVar2;
	uint uVar3;
	IDirect3DRMMesh *This;
	IDirect3DRMMesh *This_00;
	int unaff_retaddr;
	
	mesh = cont->typeData->transMesh;
	if (mesh != (Mesh *)0x0) {
		Mesh_HideGroup(mesh,group,hide);
		return;
	}
	This_00 = cont->typeData->mesh;
	piVar1 = (int *)(*This_00->lpVtbl->GetAppData)((IUnknown *)This_00);
	if (piVar1 == (int *)0x0) {
		return;
	}
	if (cont == (Container *)0x0) {
		uVar3 = piVar1[3];
		This = (IDirect3DRMMesh *)0x0;
	}
	else {
		This = *(IDirect3DRMMesh **)(*piVar1 + -4 + (int)cont * 4);
		DVar2 = (*This->lpVtbl->GetAppData)((IUnknown *)This);
		uVar3 = ~DVar2 >> 0x1f;
		This_00 = This;
	}
	if (group != D3DRMGROUP_0) {
		if (uVar3 == 0) {
			(**(code **)(**(int **)(unaff_retaddr + 4) + 0xa0))(*(int **)(unaff_retaddr + 4),This_00);
			goto LAB_00474e84;
		}
		if (group != D3DRMGROUP_0) goto LAB_00474e84;
	}
	if (uVar3 != 0) {
		(**(code **)(**(int **)(unaff_retaddr + 4) + 0x48))(*(int **)(unaff_retaddr + 4),This_00);
	}
LAB_00474e84:
	if (This == (IDirect3DRMMesh *)0x0) {
		piVar1[3] = group;
		return;
	}
	DVar2 = (*This->lpVtbl->GetAppData)((IUnknown *)This);
	if (group == D3DRMGROUP_0) {
		(*This->lpVtbl->SetAppData)((IUnknown *)This,DVar2 & 0x7fffffff | 0x80000000);
		return;
	}
	(*This->lpVtbl->SetAppData)((IUnknown *)This,DVar2 & 0x7fffffff);
	return;
}



BOOL __cdecl
lego::res::Container_Mesh_HandleSeperateMeshGroups
					(IDirect3DRMMesh **ref_mesh,D3DRMGroupIndex *ref_groupID)
{
	int *piVar1;
	
	piVar1 = (int *)(*(*ref_mesh)->lpVtbl->GetAppData)(*ref_mesh);
	if (piVar1 != (int *)0x0) {
		if (*ref_groupID != D3DRMGROUP_0) {
			*ref_mesh = *(IDirect3DRMMesh **)(*piVar1 + -4 + *ref_groupID * 4);
		}
		*ref_groupID = D3DRMGROUP_0;
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::res::Container_Mesh_GetGroup
					(Container *cont,D3DRMGroupIndex groupID,uint *out_vertexCount,uint *out_faceCount,
					uint *out_vPerFace,uint *out_faceDataSize,uint *out_faceData)
{
	Mesh *mesh;
	Mesh_Group *pMVar1;
	int iVar2;
	
	mesh = cont->typeData->transMesh;
	if (mesh != (Mesh *)0x0) {
		pMVar1 = Mesh_GetGroup(mesh,groupID,out_vertexCount,out_faceCount,out_vPerFace,out_faceDataSize,
													 out_faceData);
		return (BOOL)pMVar1;
	}
	cont = (Container *)cont->typeData->mesh;
	Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
	iVar2 = (*(code *)cont->masterFrame[0x17].lpVtbl)
										(cont,groupID,out_vertexCount,out_faceCount,out_vPerFace,out_faceDataSize,
										 out_faceData);
	return (BOOL)(Mesh_Group *)(uint)(iVar2 == 0);
}



// Returns -1 on failure, and 0 on success

uint __cdecl
lego::res::Container_Mesh_GetVertices
					(Container *cont,D3DRMGroupIndex groupID,uint index,uint count,D3DRMVertex *out_retArray)
{
	Mesh *mesh;
	D3DRMGroupIndex DVar1;
	
	mesh = cont->typeData->transMesh;
	if (mesh != (Mesh *)0x0) {
		Mesh_GetVertices(mesh,groupID,index,count,out_retArray);
		return groupID;
	}
	cont = (Container *)cont->typeData->mesh;
	Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
	DVar1 = (*(code *)cont->masterFrame[0x18].lpVtbl)(cont,groupID,index,count,out_retArray);
	if (DVar1 != D3DRMGROUP_0) {
		DVar1 = D3DRMGROUP_ALLGROUPS;
	}
	return DVar1;
}



uint __cdecl
lego::res::Container_Mesh_SetVertices
					(Container *cont,D3DRMGroupIndex groupID,uint index,uint count,D3DRMVertex *values)
{
	Mesh *mesh;
	D3DRMGroupIndex DVar1;
	
	mesh = cont->typeData->transMesh;
	if (mesh != (Mesh *)0x0) {
		Mesh_SetVertices(mesh,groupID,index,count,values);
		return groupID;
	}
	cont = (Container *)cont->typeData->mesh;
	Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
	DVar1 = (*(code *)cont->masterFrame[0xf].lpVtbl)(cont,groupID,index,count,values);
	if (DVar1 != D3DRMGROUP_0) {
		DVar1 = D3DRMGROUP_ALLGROUPS;
	}
	return DVar1;
}



void __cdecl
lego::res::Container_Mesh_SetTexture
					(Container *cont,D3DRMGroupIndex groupID,Container_Texture *ref_itext)
{
	Mesh *mesh;
	IDirect3DRMTexture3 *This;
	int *unaff_retaddr;
	
	if (ref_itext == (Container_Texture *)0x0) {
		This = (IDirect3DRMTexture3 *)0x0;
	}
	else {
		This = ref_itext->texture;
	}
	mesh = cont->typeData->transMesh;
	if (mesh != (Mesh *)0x0) {
		Mesh_SetGroupTexture(mesh,groupID,ref_itext);
		return;
	}
	cont = (Container *)cont->typeData->mesh;
	Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
	if (This == (IDirect3DRMTexture3 *)0x0) {
		ref_itext = (Container_Texture *)0x0;
	}
	else {
		(*This->lpVtbl->QueryInterface)((IUnknown *)This,(IID *)&idl::IID_IDirect3DRMTexture,&ref_itext)
		;
	}
										// IDirect3DRMMesh->SetGroupTexture(this, D3DRMGroupIndex id,
										// IDirect3DRMTexture* lpTexture)
	(*(code *)cont->masterFrame[0x15].lpVtbl)(cont,groupID,ref_itext);
	if (unaff_retaddr != (int *)0x0) {
		(**(code **)(*unaff_retaddr + 8))(unaff_retaddr);
	}
	return;
}



void __cdecl
lego::res::Container_Mesh_SetPerspectiveCorrection(Container *cont,D3DRMGroupIndex groupID,BOOL on)
{
	if (cont->typeData->transMesh == (Mesh *)0x0) {
		cont = (Container *)cont->typeData->mesh;
		Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
										// IDirect3DRMMesh->SetGroupMapping(this, int id, D3DRMMapping value)
										//   D3DRMMAP_WRAPU        = 0x1,
										//   D3DRMMAP_WRAPV        = 0x2,
										//   D3DRMMAP_PERSPCORRECT = 0x4,
		if (on != 0) {
			(*(code *)cont->masterFrame[0x12].lpVtbl)((IDirect3DRMMesh *)cont,groupID,4);
			return;
		}
		(*(code *)cont->masterFrame[0x12].lpVtbl)((IDirect3DRMMesh *)cont,groupID,0);
	}
	return;
}



BOOL __cdecl lego::res::Container_Mesh_Scale(Container *cont,float x,float y,float z)
{
	Mesh *mesh;
	IDirect3DRMMesh *This;
	int *piVar1;
	int *piVar2;
	undefined4 unaff_ESI;
	uint uVar3;
	
	mesh = cont->typeData->transMesh;
	if (mesh != (Mesh *)0x0) {
		Mesh_Scale(mesh,x,y,z);
		return 0;
	}
	This = cont->typeData->mesh;
	(*This->lpVtbl->Scale)(This,x,y,z);
	piVar2 = (int *)(*This->lpVtbl->GetAppData)((IUnknown *)This);
	if ((piVar2 != (int *)0x0) && (uVar3 = 0, piVar2[1] != 0)) {
		do {
			piVar1 = *(int **)(*piVar2 + uVar3 * 4);
			(**(code **)(*piVar1 + 0x2c))(piVar1,unaff_ESI,y,z);
			uVar3 = uVar3 + 1;
		} while (uVar3 < (uint)piVar2[1]);
	}
	return 0;
}



BOOL __cdecl lego::res::Container_Mesh_GetBox(Container *cont,D3DRMBox *out_box)
{
	float fVar1;
	IDirect3DRMMesh *This;
	int *piVar2;
	int *piVar3;
	float unaff_EBX;
	float unaff_ESI;
	float unaff_EDI;
	uint uVar4;
	float local_18;
	float local_14;
	float local_10;
	
	This = cont->typeData->mesh;
	(*This->lpVtbl->GetBox)(This,out_box);
	piVar3 = (int *)(*This->lpVtbl->GetAppData)((IUnknown *)This);
	if ((piVar3 != (int *)0x0) && (uVar4 = 0, piVar3[1] != 0)) {
		do {
			piVar2 = *(int **)(*piVar3 + uVar4 * 4);
			(**(code **)(*piVar2 + 0x34))(piVar2,&stack0xffffffdc);
			if (unaff_EDI < (out_box->min).x) {
				(out_box->min).x = unaff_EDI;
			}
			if (unaff_ESI < (out_box->min).y) {
				(out_box->min).y = unaff_ESI;
			}
			if (unaff_EBX < (out_box->min).z) {
				(out_box->min).z = unaff_EBX;
			}
			fVar1 = (out_box->max).x;
			if ((ushort)((ushort)(local_18 < fVar1) << 8 | (ushort)(local_18 == fVar1) << 0xe) == 0) {
				(out_box->max).x = local_18;
			}
			fVar1 = (out_box->max).y;
			if ((ushort)((ushort)(local_14 < fVar1) << 8 | (ushort)(local_14 == fVar1) << 0xe) == 0) {
				(out_box->max).y = local_14;
			}
			fVar1 = (out_box->max).z;
			if ((ushort)((ushort)(local_10 < fVar1) << 8 | (ushort)(local_10 == fVar1) << 0xe) == 0) {
				(out_box->max).z = local_10;
			}
			uVar4 = uVar4 + 1;
		} while (uVar4 < (uint)piVar3[1]);
	}
	return 0;
}



void __cdecl
lego::res::Container_Mesh_SetEmissive
					(Container *cont,D3DRMGroupIndex groupID,float r,float g,float b)
{
	Mesh *mesh;
	
	mesh = cont->typeData->transMesh;
	if (mesh != (Mesh *)0x0) {
		Mesh_SetGroupColour(mesh,groupID,r,g,b,MATERIAL_EMISSIVE);
	}
	return;
}



void __cdecl
lego::res::Container_Mesh_SetColourAlpha
					(Container *cont,D3DRMGroupIndex groupID,float r,float g,float b,float a)
{
	Mesh *mesh;
	
	mesh = cont->typeData->transMesh;
	if (mesh != (Mesh *)0x0) {
		Mesh_SetGroupColour(mesh,groupID,r,g,b,MATERIAL_DIFFUSE);
		Mesh_SetGroupMaterialValues(mesh,groupID,a,MATERIAL_ALPHA);
	}
	return;
}



void __cdecl
lego::res::Container_Transform(Container *cont,Vector3F *out_vector,Vector3F *in_vector)
{
	(*(code *)cont->masterFrame->lpVtbl->Transform)(cont->masterFrame,out_vector,in_vector);
	return;
}



void __cdecl
lego::res::Container_InverseTransform(Container *cont,Vector3F *out_vector,Vector3F *in_vector)
{
	(*cont->masterFrame->lpVtbl->InverseTransform)(cont->masterFrame,out_vector,in_vector);
	return;
}



void __cdecl lego::res::Container_SetColourAlpha(Container *cont,float r,float g,float b,float a)
{
	IDirect3DRMLight *This;
	longlong lVar1;
	longlong lVar2;
	longlong lVar3;
	longlong lVar4;
	
	lVar1 = __ftol((float10)r * (float10)255.0);
	lVar2 = __ftol((float10)a * (float10)255.0);
	lVar3 = __ftol((float10)g * (float10)255.0);
	lVar4 = __ftol((float10)b * (float10)255.0);
	if (cont->type == RESOURCE_LIGHT) {
		This = cont->typeData->light;
		(*This->lpVtbl->SetColor)
							(This,(((uint)lVar1 | (int)lVar2 << 8) << 8 | (uint)lVar3) << 8 | (uint)lVar4);
	}
	return;
}



float10 __cdecl lego::res::Container_MoveAnimation(Container *cont,float delta)
{
	float10 fVar1;
	
	fVar1 = Container_GetAnimationTime(cont);
	fVar1 = Container_SetAnimationTime(cont,(float)(fVar1 + (float10)delta));
	return fVar1;
}



float10 __cdecl lego::res::Container_SetAnimationTime(Container *cont,float time)
{
	float fVar1;
	IDirect3DRMFrame3 *frame;
	char *sampleName;
	uint uVar2;
	uint uVar3;
	ResourceDataFlags RVar4;
	float10 fVar5;
	AnimClone *local_14;
	float local_10;
	
	local_14 = (AnimClone *)0x0;
	local_10 = 0.0;
	if (cont->type == RESOURCE_ACT) {
		frame = Container_Frame_Find(cont,cont->typeData->name,0);
		if ((frame != (IDirect3DRMFrame3 *)0x0) &&
			 (local_14 = Container_Frame_GetAnimClone(frame), (*(byte *)&cont->flags & RESDATA_UNK_2) != 0
			 )) {
			sampleName = Container_Frame_GetSample(frame);
			if ((sampleName != (char *)0x0) &&
				 ((globs::containerGlobs.soundTriggerCallback != (ContainerSoundTriggerCallback *)0x0 &&
					(((byte)globs::containerGlobs.flags & RESMANAGER_SOUNDCALLBACK) != 0)))) {
				(*globs::containerGlobs.soundTriggerCallback)
									(sampleName,cont,globs::containerGlobs.soundTriggerData);
			}
			cont->flags = cont->flags & ~RESDATA_UNK_2;
		}
	}
	else {
		frame = (IDirect3DRMFrame3 *)time;
		if (cont->type == RESOURCE_ANIM) {
			local_14 = Container_Frame_GetAnimClone(cont->activityFrame);
			frame = cont->activityFrame;
		}
	}
	if (local_14 != (AnimClone *)0x0) {
		RVar4 = cont->flags & RESDATA_UNK_8;
		fVar5 = Container_GetAnimationTime(cont);
		uVar2 = Container_Frame_GetFrameCount(frame);
		Container_Frame_SetAppData
							(frame,(Container *)0x0,(AnimClone *)0x0,(char *)0x0,(uint *)0x0,(char *)0x0,&time,
							 (float *)0x0,(char *)0x0,(Sound3D_SoundFrameRecord *)0x0,(uint *)0x0);
		if (uVar2 != 0) {
			uVar2 = uVar2 - 1;
			fVar1 = (float)(ulonglong)uVar2;
			if ((ushort)((ushort)(time < fVar1) << 8 | (ushort)(time == fVar1) << 0xe) == 0) {
				local_10 = time - fVar1;
				RVar4 = RESDATA_NONE;
			}
		}
		if (RVar4 == RESDATA_NONE) {
			uVar3 = Container_Frame_GetTrigger(frame);
			fVar1 = (float)(ulonglong)uVar3;
			if ((((uVar2 != 1) &&
					 (AnimClone_SetTime(local_14,time,(float *)0x0),
					 globs::containerGlobs.triggerFrameCallback != (ContainerTriggerFrameCallback *)0x0)) &&
					(fVar1 != 0.0)) && (((float)fVar5 < fVar1 && (fVar1 <= time)))) {
				(*globs::containerGlobs.triggerFrameCallback)(cont,globs::containerGlobs.triggerFrameData);
				return (float10)local_10;
			}
		}
		else {
			cont->flags = cont->flags | RESDATA_UNK_20;
		}
	}
	return (float10)local_10;
}



void __cdecl lego::res::Container_ForceAnimationUpdate(Container *cont)
{
	IDirect3DRMFrame3 *frame;
	Container *pCVar1;
	float10 fVar2;
	
	if ((*(byte *)&cont->flags & RESDATA_UNK_20) != 0) {
		pCVar1 = cont;
		if (cont->type == RESOURCE_ACT) {
			frame = Container_Frame_Find(cont,cont->typeData->name,0);
			if (frame != (IDirect3DRMFrame3 *)0x0) {
				pCVar1 = (Container *)Container_Frame_GetAnimClone(frame);
				fVar2 = Container_Frame_GetCurrTime(frame);
				cont = (Container *)(float)fVar2;
			}
		}
		else {
			if (cont->type == RESOURCE_ANIM) {
				pCVar1 = (Container *)Container_Frame_GetAnimClone(cont->activityFrame);
				fVar2 = Container_Frame_GetCurrTime(cont->activityFrame);
				cont = (Container *)(float)fVar2;
			}
		}
		if (pCVar1 != (Container *)0x0) {
			AnimClone_SetTime((AnimClone *)pCVar1,(float)cont,(float *)0x0);
		}
	}
	return;
}



float10 __cdecl lego::res::Container_GetAnimationTime(Container *cont)
{
	IDirect3DRMFrame3 *frame;
	float10 fVar1;
	
	fVar1 = (float10)0.0;
	if (cont->type == RESOURCE_ACT) {
		frame = Container_Frame_Find(cont,cont->typeData->name,0);
		if (frame != (IDirect3DRMFrame3 *)0x0) {
			fVar1 = Container_Frame_GetCurrTime(frame);
			return fVar1;
		}
		fVar1 = (float10)(float)fVar1;
	}
	else {
		if (cont->type == RESOURCE_ANIM) {
			fVar1 = Container_Frame_GetCurrTime(cont->activityFrame);
			return fVar1;
		}
	}
	return fVar1;
}



uint __cdecl lego::res::Container_GetAnimationFrames(Container *cont)
{
	IDirect3DRMFrame3 *frame;
	uint uVar1;
	
	frame = (IDirect3DRMFrame3 *)0x0;
	if (cont->type == RESOURCE_ACT) {
		frame = Container_Frame_Find(cont,cont->typeData->name,0);
	}
	else {
		if (cont->type == RESOURCE_ANIM) {
			frame = cont->activityFrame;
		}
	}
	if (frame != (IDirect3DRMFrame3 *)0x0) {
		uVar1 = Container_Frame_GetFrameCount(frame);
		return uVar1;
	}
	return 0;
}



void __cdecl
lego::res::Container_SetPosition(Container *cont,Container *opt_ref,float x,float y,float z)
{
										// IDirect3DRMFrame3->SetPosition(this, IDirect3DRMFrame3* lpRef, float rvX,
										// float rvY, float rvZ)
	Container_GetFrames(cont,opt_ref,(IDirect3DRMFrame3 **)&opt_ref,(IDirect3DRMFrame3 **)&cont);
	(*(code *)opt_ref->masterFrame[0x3c].lpVtbl)(opt_ref,cont,x,y,z);
	return;
}



void __cdecl
lego::res::Container_SetOrientation
					(Container *cont,Container *opt_ref,float dirx,float diry,float dirz,float upx,float upy,
					float upz)
{
	Container_GetFrames(cont,opt_ref,(IDirect3DRMFrame3 **)&opt_ref,(IDirect3DRMFrame3 **)&cont);
										// IDirect3DRMFrame3->SetOrientation(this, IDirect3DRMFrame3* lpRef, float rvDx,
										// float rvDy, float rvDz, float rvUx, float rvUy, float rvUz)
	(*(code *)opt_ref->masterFrame[0x3b].lpVtbl)(opt_ref,cont,dirx,diry,dirz,upx,upy,upz);
	return;
}



void __cdecl lego::res::Container_GetPosition(Container *cont,Container *opt_ref,Vector3F *out_pos)
{
	Container_GetFrames(cont,opt_ref,(IDirect3DRMFrame3 **)&opt_ref,(IDirect3DRMFrame3 **)&cont);
										// IDirect3DRMFrame3->GetPosition(this, IDirect3DRMFrame3* lpRef, Vector3F*
										// lprvPos)
	(*(code *)opt_ref->masterFrame[0x18].lpVtbl)(opt_ref,cont,out_pos);
	return;
}



void __cdecl
lego::res::Container_GetOrientation
					(Container *cont,Container *opt_ref,Vector3F *out_dir,Vector3F *out_up)
{
	Vector3F **unaff_retaddr;
	Vector3F *pVVar1;
	Vector3F *pVVar2;
	Vector3F dvector;
	Vector3F uvector;
	
	Container_GetFrames(cont,opt_ref,(IDirect3DRMFrame3 **)&opt_ref,(IDirect3DRMFrame3 **)&cont);
	pVVar1 = &dvector;
	pVVar2 = &uvector;
										// IDirect3DRMFrame3->GetOrientation(this, IDirect3DRMFrame3* lpRef, Vector3F*
										// lprvDir, Vector3F* lprvUp)
	(*(code *)opt_ref->masterFrame[0x1f].lpVtbl)();
	if (uvector.z != 0.0) {
		*(Container **)uvector.z = opt_ref;
		*(Container **)((int)uvector.z + 4) = cont;
		*(Vector3F **)((int)uvector.z + 8) = pVVar1;
	}
	if (unaff_retaddr != (Vector3F **)0x0) {
		*unaff_retaddr = pVVar2;
		unaff_retaddr[1] = (Vector3F *)dvector.x;
		unaff_retaddr[2] = (Vector3F *)dvector.y;
	}
	return;
}



void __cdecl
lego::res::Container_AddRotation
					(Container *cont,D3DRMCombineType combine,float x,float y,float z,float angle)
{
										// enum D3DRMCombineType
										//   D3DRMCOMBINE_REPLACE = 0,
										//   D3DRMCOMBINE_BEFORE  = 1,
										//   D3DRMCOMBINE_AFTER   = 2,
										// 
										// IDirect3DRMFrame3->AddRotation(this, D3DRMCombineType rctCombine, float rvX,
										// float rvY, float rvZ, float rvTheta)
	(*cont->masterFrame->lpVtbl->AddRotation)(cont->masterFrame,combine,x,y,z,angle);
	return;
}



void __cdecl
lego::res::Container_AddScale(Container *cont,D3DRMCombineType combine,float x,float y,float z)
{
										// enum D3DRMCombineType
										//   D3DRMCOMBINE_REPLACE = 0,
										//   D3DRMCOMBINE_BEFORE  = 1,
										//   D3DRMCOMBINE_AFTER   = 2,
										// 
										// IDirect3DRMFrame3->AddScale(this, D3DRMCombineType rctCombine, float rvX,
										// float rvY, float rvZ)
	(*cont->masterFrame->lpVtbl->AddScale)(cont->masterFrame,combine,x,y,z);
	return;
}



void __cdecl
lego::res::Container_AddTranslation
					(Container *cont,D3DRMCombineType combine,float x,float y,float z)
{
										// enum D3DRMCombineType
										//   D3DRMCOMBINE_REPLACE = 0,
										//   D3DRMCOMBINE_BEFORE  = 1,
										//   D3DRMCOMBINE_AFTER   = 2,
										// 
										// IDirect3DRMFrame3->AddTranslation(this, D3DRMCombineType rctCombine, float
										// rvX, float rvY, float rvZ)
	(*cont->masterFrame->lpVtbl->AddTranslation)(cont->masterFrame,combine,x,y,z);
	return;
}



void __cdecl lego::res::Container_ClearTransform(Container *cont)
{
	Matrix4F identity;
	
	identity.values[0][0] = 1.0;
	identity.values[1][0] = 0.0;
	identity.values[2][0] = 0.0;
	identity.values[3][0] = 0.0;
	identity.values[0][1] = 0.0;
	identity.values[1][1] = 1.0;
	identity.values[2][1] = 0.0;
	identity.values[3][1] = 0.0;
	identity.values[0][2] = 0.0;
	identity.values[1][2] = 0.0;
	identity.values[2][2] = 1.0;
	identity.values[3][2] = 0.0;
	identity.values[0][3] = 0.0;
	identity.values[1][3] = 0.0;
	identity.values[2][3] = 0.0;
	identity.values[3][3] = 1.0;
	Container_AddTransform(cont,D3DRMCOMBINE_REPLACE,&identity);
	return;
}



void __cdecl
lego::res::Container_AddTransform(Container *cont,D3DRMCombineType combine,Matrix4F *mat)
{
										// IDirect3DRMFrame3->AddTransform(this, D3DRMCombineType rctCombine,
										// D3DRMMatrix4D* rmMatrix)
	(*cont->masterFrame->lpVtbl->AddTransform)(cont->masterFrame,combine,mat);
	return;
}



float10 __cdecl lego::res::Container_GetZXRatio(Container *cont)
{
	IDirect3DRMFrame3 *pIVar1;
	float unaff_ESI;
	Matrix4F mat;
	
	pIVar1 = cont->masterFrame;
	(*pIVar1->lpVtbl->GetParent)(pIVar1,(IDirect3DRMFrame3 **)&cont);
	(*pIVar1->lpVtbl->GetTransform)(pIVar1,(IDirect3DRMFrame3 *)cont,&mat);
	(*(code *)cont->masterFrame[2].lpVtbl)(cont);
										// Decompile is wrong. This is correct: mat[2][2] / mat[0][0];
	return (float10)mat.values[2][1] / (float10)unaff_ESI;
}



// When resParent is NULL, resChild's current parent will be removed instead.

void __cdecl lego::res::Container_SetParent(Container *in_child,Container *parent)
{
	IDirect3DRMFrame3 *child;
	IDirect3DRMFrame3 *child_00;
	Container *pCVar1;
	
	pCVar1 = parent;
	child = in_child->masterFrame;
	child_00 = in_child->hiddenFrame;
	if (parent == (Container *)0x0) {
										// IDirect3DRMFrame3->GetParent(this, IDirect3DRMFrame3** lplpParent)
										//  (for resData1->frame1)
		(*child->lpVtbl->GetParent)(child,(IDirect3DRMFrame3 **)&in_child);
		if (in_child != (Container *)0x0) {
										// IDirect3DRMFrame3->DeleteChild(this, IDIrect3DRMFrame3* lpChild)
			(*(code *)in_child->masterFrame[0x25].lpVtbl)((IDirect3DRMFrame3 *)in_child,child);
										// IDirect3DRMFrame3->Release(this)
										//  (releasing GetParent frame)
			(*(code *)in_child->masterFrame[2].lpVtbl)((IDirect3DRMFrame3 *)in_child);
		}
										// IDirect3DRMFrame3->GetParent(this, IDirect3DRMFrame3** lplpParent)
										//  (for resData1->frame3)
		(*child->lpVtbl->GetParent)(child_00,(IDirect3DRMFrame3 **)&in_child);
		if (in_child != (Container *)0x0) {
			(*(code *)in_child->masterFrame[0x25].lpVtbl)((IDirect3DRMFrame3 *)in_child,child_00);
			(*(code *)in_child->masterFrame[2].lpVtbl)((IDirect3DRMFrame3 *)in_child);
			return;
		}
	}
	else {
		in_child = (Container *)parent->masterFrame;
		Container_Frame_SafeAddChild((IDirect3DRMFrame3 *)in_child,child);
		in_child = (Container *)pCVar1->hiddenFrame;
		Container_Frame_SafeAddChild((IDirect3DRMFrame3 *)in_child,child_00);
	}
	return;
}



Container * __cdecl lego::res::Container_GetParent(Container *cont)
{
	Container *pCVar1;
	
	if (cont == globs::containerGlobs.rootContainer) {
		return (Container *)0x0;
	}
	(*cont->masterFrame->lpVtbl->GetParent)(cont->masterFrame,(IDirect3DRMFrame3 **)&cont);
	if (cont != (Container *)0x0) {
		pCVar1 = Container_Frame_GetContainer((IDirect3DRMFrame3 *)cont);
		(*(code *)cont->masterFrame[2].lpVtbl)((IDirect3DRMFrame3 *)cont);
		return pCVar1;
	}
	return (Container *)0x0;
}



float10 __cdecl lego::res::Container_GetTransCoef(Container *cont)
{
	char *findName;
	IDirect3DRMFrame3 *frame;
	float10 fVar1;
	
	if (((cont->type == RESOURCE_ACT) && (cont->typeData != (Container_TypeData *)0x0)) &&
		 (findName = cont->typeData->name, findName != (char *)0x0)) {
		frame = Container_Frame_Find(cont,findName,0);
		if (frame != (IDirect3DRMFrame3 *)0x0) {
			fVar1 = Container_Frame_GetTransCo(frame);
			return fVar1;
		}
	}
	return (float10)0.0;
}



Container * __cdecl lego::res::Container_SearchOwner(IDirect3DRMFrame3 *in_frame)
{
	Container *pCVar1;
	IDirect3DRMFrame3 *frame;
	Container *pCVar2;
	
	pCVar2 = (Container *)0x0;
	frame = in_frame;
	do {
		if (frame == (IDirect3DRMFrame3 *)0x0) {
			return pCVar2;
		}
		pCVar1 = Container_Frame_GetOwner(frame);
		if ((pCVar1 != (Container *)0x0) && (pCVar1->type != RESOURCE_REFERENCE)) {
			pCVar2 = pCVar1;
		}
		(*frame->lpVtbl->GetParent)(frame,&in_frame);
		frame = in_frame;
		if (in_frame == (IDirect3DRMFrame3 *)0x0) {
			frame = (IDirect3DRMFrame3 *)0x0;
		}
		else {
			(*in_frame->lpVtbl->Release)(in_frame);
		}
	} while (pCVar2 == (Container *)0x0);
	return pCVar2;
}



Container * __cdecl lego::res::Container_Frame_GetContainer(IDirect3DRMFrame3 *frame)
{
	Container *owner;
	
	owner = Container_Frame_GetOwner(frame);
	if (owner == (Container *)0x0) {
		owner = Container_Create((Container *)0x0);
		if (owner != (Container *)0x0) {
			(*owner->masterFrame->lpVtbl->Release)((IUnknown *)owner->masterFrame);
			(*owner->activityFrame->lpVtbl->Release)((IUnknown *)owner->activityFrame);
			owner->masterFrame = frame;
			owner->activityFrame = (IDirect3DRMFrame3 *)0x0;
			owner->type = RESOURCE_REFERENCE;
			(*frame->lpVtbl->AddDestroyCallback)
								((IUnknown *)frame,Container_Frame_ReferenceDestroyCallback,(LPVOID)0x0);
			Container_Frame_SetAppData
								(frame,owner,(AnimClone *)0x0,(char *)0x0,(uint *)0x0,(char *)0x0,(float *)0x0,
								 (float *)0x0,(char *)0x0,(Sound3D_SoundFrameRecord *)0x0,(uint *)0x0);
		}
	}
	return owner;
}



// #ifndef CONTAINER_MATCHHIDDENHIERARCHY

void __cdecl
lego::res::Container_GetFrames
					(Container *cont,Container *opt_ref,IDirect3DRMFrame3 **out_contFrame,
					IDirect3DRMFrame3 **out_refFrame)
{
	*out_contFrame = cont->masterFrame;
	if (opt_ref == (Container *)0x0) {
		*out_refFrame = (globs::containerGlobs.rootContainer)->masterFrame;
		return;
	}
	*out_refFrame = opt_ref->masterFrame;
	return;
}



ResourceType __cdecl lego::res::Container_ParseTypeString(char *str,BOOL *out_noTexture)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char **ppcVar6;
	char *pcVar7;
	undefined4 *puVar8;
	ResourceType RVar9;
	undefined4 local_50 [10];
	char *local_28;
	char *local_24;
	
	if (str == (char *)0x0) {
		return RESOURCE__INVALID;
	}
	uVar3 = 0xffffffff;
	do {
		pcVar7 = str;
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		pcVar7 = str + 1;
		cVar1 = *str;
		str = pcVar7;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	puVar5 = (undefined4 *)(pcVar7 + -uVar3);
	puVar8 = local_50;
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
		*puVar8 = *puVar5;
		puVar5 = puVar5 + 1;
		puVar8 = puVar8 + 1;
	}
	for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
		*(undefined *)puVar8 = *(undefined *)puVar5;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
		puVar8 = (undefined4 *)((int)puVar8 + 1);
	}
	uVar3 = util::Util_Tokenise((char *)local_50,&local_28,":");
	if (1 < uVar3) {
		iVar2 = std::_stricmp(local_24,"NOTEXTURE");
		if (iVar2 == 0) {
			*out_noTexture = 1;
			goto LAB_00475c6a;
		}
	}
	*out_noTexture = 0;
LAB_00475c6a:
	RVar9 = RESOURCE_NULL;
	ppcVar6 = globs::containerGlobs.typeName;
	do {
		if (*ppcVar6 != (char *)0x0) {
			iVar2 = std::_stricmp(*ppcVar6,(char *)local_50);
			if (iVar2 == 0) {
				return RVar9;
			}
		}
		ppcVar6 = ppcVar6 + 1;
		RVar9 = RVar9 + RESOURCE_MESH;
	} while (ppcVar6 < globs::containerGlobs.extensionName);
	return RESOURCE__INVALID;
}



void __cdecl lego::res::Container_AddList(void)
{
	Container *pCVar1;
	Container *pCVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::containerGlobs.listCount & 0x1f);
	pCVar2 = (Container *)std::malloc(uVar4 * 0x2c);
	globs::containerGlobs.listSet[globs::containerGlobs.listCount] = pCVar2;
	pCVar2 = globs::containerGlobs.listSet[globs::containerGlobs.listCount];
	if (pCVar2 != (Container *)0x0) {
		globs::containerGlobs.listCount = globs::containerGlobs.listCount + 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pCVar1 = pCVar2;
			do {
				pCVar1->nextFree = pCVar1 + 1;
				iVar3 = iVar3 + -1;
				pCVar1 = pCVar1 + 1;
			} while (iVar3 != 0);
		}
		pCVar2[uVar4 - 1].nextFree = globs::containerGlobs.freeList;
		globs::containerGlobs.freeList = pCVar2;
	}
	return;
}



// WARNING: Exceeded maximum restarts with more pending

uint __cdecl
lego::res::Container_GetActivities
					(Container *cont,IDirect3DRMFrame3 **out_frameList,AnimClone **out_acList,
					char **out_nameList)
{
	HRESULT HVar1;
	char *lpName;
	int iVar2;
	AnimClone *pAVar3;
	uint uVar4;
	int unaff_EBP;
	Container *pCVar5;
	AnimClone **ppAVar6;
	IUnknown *pIVar7;
	AnimClone **ppAVar8;
	Container *unaff_retaddr;
	IDirect3DRMFrame3 *frame;
	uint length;
	IDirect3DRMFrameArray *This;
	IUnknown *local_20;
	IDirect3DRMFrame3 *local_1c;
	IDirect3DRMFrameArray *local_18;
	IDirect3DRMFrame3 *local_14;
	AnimClone **local_10;
	AnimClone **local_c;
	DWORD local_8;
	
	pIVar7 = (IUnknown *)0x0;
	local_20 = (IUnknown *)0x0;
	local_1c = (IDirect3DRMFrame3 *)0x0;
	if (cont->type == RESOURCE_ACT) {
		local_c = (AnimClone **)0x0;
		pCVar5 = cont;
		do {
			ppAVar6 = local_c;
			if (local_c == (AnimClone **)0x0) {
				local_14 = pCVar5->activityFrame;
			}
			if (local_c == (AnimClone **)0x1) {
				local_14 = pCVar5->hiddenFrame;
			}
			HVar1 = (*local_14->lpVtbl->GetChildren)(local_14,&local_18);
			if (HVar1 == 0) {
				This = local_18;
				local_8 = (*local_18->lpVtbl->GetSize)();
				uVar4 = 0;
				if (local_8 != 0) {
					local_c = (AnimClone **)((int)out_acList - (int)out_frameList);
					ppAVar8 = (AnimClone **)(out_frameList + (int)pIVar7);
					pCVar5 = unaff_retaddr;
					do {
						frame = local_1c;
						length = uVar4;
						(*local_1c->lpVtbl->AddDestroyCallback)();
						(*local_20->lpVtbl->QueryInterface)
											(local_20,(IID *)&idl::IID_IDirect3DRMFrame3,(LPVOID *)&stack0xffffffcc);
						(*local_20->lpVtbl->Release)(local_20);
						(*This->lpVtbl[1].GetElement)(This,(DWORD)&stack0xffffffcc,(IDirect3DRMFrame **)0x0);
						if (length != 0) {
							lpName = (char *)std::malloc(length);
							(*frame->lpVtbl->GetName)((IUnknown *)frame,(LPDWORD)&stack0xffffffc0,lpName);
							iVar2 = std::_strnicmp(lpName,"ActFrame",8);
							if (iVar2 == 0) {
								if (local_18 != (IDirect3DRMFrameArray *)0x0) {
									*(IDirect3DRMFrame3 **)
									 ((int)&((Container *)((int)cont - (int)out_frameList))->masterFrame +
									 (int)ppAVar8) = frame;
								}
								if (local_14 != (IDirect3DRMFrame3 *)0x0) {
									pAVar3 = Container_Frame_GetAnimClone(frame);
									*ppAVar8 = pAVar3;
								}
								if (local_10 != (AnimClone **)0x0) {
									*(char **)(unaff_EBP + (int)ppAVar8) = lpName;
								}
								ppAVar8 = ppAVar8 + 1;
								if (local_10 != (AnimClone **)0x0) goto LAB_00475e74;
							}
							std::free(lpName);
						}
LAB_00475e74:
						(*frame->lpVtbl->Release)((IUnknown *)frame);
						uVar4 = uVar4 + 1;
						ppAVar6 = local_10;
						pIVar7 = local_20;
						unaff_retaddr = pCVar5;
					} while (uVar4 < local_8);
				}
				(*local_1c->lpVtbl->Release)();
			}
			local_c = (AnimClone **)((int)ppAVar6 + 1);
		} while (local_c < (AnimClone **)0x2);
	}
	return (uint)pIVar7;
}



// If non-null, `name` will be owned by this Resource.

void __cdecl
lego::res::Container_SetTypeData
					(Container *cont,char *name,IDirect3DRMLight *light,IDirect3DRMMesh *mesh,Mesh *transMesh)
{
	Container_TypeData *pCVar1;
	
	if (cont->typeData == (Container_TypeData *)0x0) {
		pCVar1 = (Container_TypeData *)std::malloc(0x10);
		cont->typeData = pCVar1;
		pCVar1->name = name;
		cont->typeData->light = light;
		cont->typeData->mesh = mesh;
		cont->typeData->transMesh = transMesh;
	}
	else {
		if (name != (char *)0x0) {
			cont->typeData->name = name;
		}
		if (light != (IDirect3DRMLight *)0x0) {
			cont->typeData->light = light;
		}
		if (mesh != (IDirect3DRMMesh *)0x0) {
			cont->typeData->mesh = mesh;
		}
		if (transMesh != (Mesh *)0x0) {
			cont->typeData->transMesh = transMesh;
			return;
		}
	}
	return;
}



void __cdecl lego::res::Container_FreeTypeData(Container *cont)
{
	Container_TypeData *pCVar1;
	ResourceType RVar2;
	IDirect3DRMMesh *This;
	
	pCVar1 = cont->typeData;
	if (pCVar1 != (Container_TypeData *)0x0) {
		RVar2 = cont->type;
		if (RVar2 == RESOURCE_ACT) {
			std::free(pCVar1->name);
		}
		else {
			if (RVar2 == RESOURCE_LIGHT) {
				(*pCVar1->light->lpVtbl->Release)((IUnknown *)pCVar1->light);
			}
			else {
				if (RVar2 == RESOURCE_MESH) {
					if (pCVar1->mesh != (IDirect3DRMMesh *)0x0) {
						(*cont->activityFrame->lpVtbl->DeleteVisual)
											(cont->activityFrame,(IDirect3DRMVisual *)pCVar1->mesh);
						This = cont->typeData->mesh;
						(*This->lpVtbl->Release)((IUnknown *)This);
					}
				}
				else {
					if ((RVar2 == RESOURCE_LWO) && (pCVar1->transMesh != (Mesh *)0x0)) {
						Mesh_Remove(pCVar1->transMesh,cont->activityFrame);
					}
				}
			}
		}
		std::free(cont->typeData);
		cont->typeData = (Container_TypeData *)0x0;
	}
	return;
}



// ALSO: Container_AddActivity(<same args>)

BOOL __cdecl
lego::res::Container_AddActivity2
					(Container *cont,char *filename,char *actname,float transCo,uint trigger,char *sample,
					AnimClone *origClone,BOOL lws,BOOL looping)
{
	HRESULT HVar1;
	AnimClone *animClone;
	IDirect3DRMFrame3 *local_208;
	uint local_204;
	char local_200 [512];
	
	std::sprintf(local_200,"%s.%s",filename,globs::containerGlobs.extensionName[3]);
	HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
										(globs::mainGlobs.lpD3DRM,cont->hiddenFrame,&local_208);
	if (HVar1 == 0) {
		Container_Frame_FormatName(local_208,"%s_%s","ActFrame",actname);
		if (origClone == (AnimClone *)0x0) {
			animClone = Container_LoadAnimSet(local_200,local_208,&local_204,lws,looping);
		}
		else {
			animClone = AnimClone_Make(origClone,local_208,&local_204);
		}
		Container_Frame_SetAppData
							(local_208,cont,animClone,filename,&local_204,(char *)0x0,(float *)0x0,&transCo,sample
							 ,(Sound3D_SoundFrameRecord *)0x0,&trigger);
		return TRUE;
	}
	return 0;
}



void __cdecl
lego::res::Container_Frame_ReferenceDestroyCallback(IDirect3DRMFrame3 *lpD3DRMobj,void *lpArg)
{
	Container *pCVar1;
	
	pCVar1 = Container_Frame_GetOwner(lpD3DRMobj);
	if (pCVar1 != (Container *)0x0) {
		pCVar1->flags = pCVar1->flags | RESDATA_UNK_10;
		Container_Frame_RemoveAppData(lpD3DRMobj);
	}
	return;
}



// WARNING: Exceeded maximum restarts with more pending

IDirect3DRMFrame3 * __cdecl
lego::res::Container_Frame_Find(Container *cont,char *findName,BOOL hidden)
{
	IDirect3DRMFrame3 *pIVar1;
	HRESULT HVar2;
	uint uVar3;
	char *lpName;
	int iVar4;
	IDirect3DRMFrame3 *unaff_EBP;
	IDirect3DRMFrame3 *pIVar5;
	uint uVar6;
	uint uVar7;
	IDirect3DRMFrame3 *pIVar8;
	IDirect3DRMFrame3 *rmFrame3;
	IDirect3DRMFrameArray *rmArray;
	IUnknown *rmFrameBase;
	uint dwNameSize;
	uint dwSize;
	char nameBuffer [512];
	
	pIVar5 = (IDirect3DRMFrame3 *)0x0;
	if (hidden == 0) {
		pIVar1 = cont->activityFrame;
	}
	else {
		pIVar1 = cont->hiddenFrame;
	}
										// IDirect3DRMFrame3->GetChildren(this, IDirect3DRMFrameArray** lplpChildren)
	HVar2 = (*pIVar1->lpVtbl->GetChildren)(pIVar1,&rmArray);
	if (HVar2 == 0) {
										// DWORD IDirect3DRMFrameArray->GetSize(this)
		uVar3 = (*rmArray->lpVtbl->GetSize)();
		uVar6 = 0;
		dwNameSize = uVar3;
		if (uVar3 != 0) {
			do {
										// IDirect3DRMFrameArray->GetElement(this, DWORD index, IDirect3DRMFrame**
										// lplpD3DRMFrame)
				pIVar1 = rmFrame3;
				uVar7 = uVar6;
				(*rmFrame3->lpVtbl->AddDestroyCallback)();
										// IDirect3DRMFrame->QueryInterface(this, IID_IDirect3DRMFrame3,
										// IDirect3DRMFrame3** lplpOut)
				pIVar8 = unaff_EBP;
				(*unaff_EBP->lpVtbl->QueryInterface)
									((IUnknown *)unaff_EBP,(IID *)&idl::IID_IDirect3DRMFrame3,
									 (LPVOID *)&stack0xfffffddc);
										// IDirect3DRMFrame->Release(this)
				(*rmArray->lpVtbl->Release)((IUnknown *)rmArray);
										// IDirect3DRMFrame3->GetName(this, DWORD* lpdwSize, LPSTR lpName)
				(*pIVar1->lpVtbl->GetName)((IUnknown *)pIVar1,(LPDWORD)&stack0xfffffdd8,(LPSTR)0x0);
				if (pIVar1 != (IDirect3DRMFrame3 *)0x0) {
					lpName = (char *)std::malloc((int)&pIVar1->lpVtbl + 1);
										// IDirect3DRMFrame3->GetName(this, DWORD* lpdwSize, LPSTR lpName)
					(*unaff_EBP->lpVtbl->GetName)((IUnknown *)unaff_EBP,(LPDWORD)&stack0xfffffdcc,lpName);
					std::sprintf(&stack0xfffffdd4,"%s_%s","ActFrame",cont);
					iVar4 = std::_stricmp(lpName,&stack0xfffffdd4);
					if (iVar4 == 0) {
						pIVar5 = unaff_EBP;
					}
					uVar3 = uVar7;
					std::free(lpName);
				}
										// IDirect3DRMFrame3->Release(this)
				(*unaff_EBP->lpVtbl->Release)((IUnknown *)unaff_EBP);
			} while ((pIVar5 == (IDirect3DRMFrame3 *)0x0) &&
							(uVar6 = uVar6 + 1, unaff_EBP = pIVar8, uVar6 < uVar3));
		}
										// IDirect3DRMFrameArray->Release(this)
		(*rmFrame3->lpVtbl->Release)();
	}
	return pIVar5;
}



void __cdecl
lego::res::Container_Frame_SetAppData
					(IDirect3DRMFrame3 *frame,Container *owner,AnimClone *animClone,char *asfname,
					uint *frameCount,char *frameName,float *currTime,float *transCo,char *actSample,
					Sound3D_SoundFrameRecord *soundRecord,uint *trigger)
{
	char cVar1;
	Container_AppData *appData;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData == (Container_AppData *)0x0) {
		appData = (Container_AppData *)std::malloc(0x28);
		appData->animClone = animClone;
		appData->ownerContainer = owner;
		appData->animSetFileName = (char *)0x0;
		if (frameCount == (uint *)0x0) {
			appData->frameCount = 0;
		}
		else {
			appData->frameCount = *frameCount;
		}
		appData->frameName = frameName;
		if (currTime == (float *)0x0) {
			appData->currTime = 0.0;
		}
		else {
			appData->currTime = *currTime;
		}
		if (transCo == (float *)0x0) {
			appData->transCo = 0.0;
		}
		else {
			appData->transCo = *transCo;
		}
		if (trigger == (uint *)0x0) {
			appData->trigger = 0;
		}
		else {
			appData->trigger = *trigger;
		}
		appData->activitySample = actSample;
		appData->soundList = soundRecord;
		(*frame->lpVtbl->SetAppData)(frame,appData);
	}
	else {
		if (owner != (Container *)0x0) {
			appData->ownerContainer = owner;
		}
		if (animClone != (AnimClone *)0x0) {
			appData->animClone = animClone;
		}
		if ((asfname != (char *)0x0) && (appData->animSetFileName != (char *)0x0)) {
			std::free(appData->animSetFileName);
		}
		if (frameCount != (uint *)0x0) {
			appData->frameCount = *frameCount;
		}
		if (frameName != (char *)0x0) {
			appData->frameName = frameName;
		}
		if (currTime != (float *)0x0) {
			appData->currTime = *currTime;
		}
		if (transCo != (float *)0x0) {
			appData->transCo = *transCo;
		}
		if (actSample != (char *)0x0) {
			appData->activitySample = actSample;
		}
		if (soundRecord != (Sound3D_SoundFrameRecord *)0x0) {
			appData->soundList = soundRecord;
		}
		if (trigger != (uint *)0x0) {
			appData->trigger = *trigger;
		}
	}
	if (asfname != (char *)0x0) {
		uVar3 = 0xffffffff;
		pcVar6 = asfname;
		do {
			if (uVar3 == 0) break;
			uVar3 = uVar3 - 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
		puVar2 = (undefined4 *)std::malloc(~uVar3);
		uVar3 = 0xffffffff;
		appData->animSetFileName = (char *)puVar2;
		do {
			pcVar6 = asfname;
			if (uVar3 == 0) break;
			uVar3 = uVar3 - 1;
			pcVar6 = asfname + 1;
			cVar1 = *asfname;
			asfname = pcVar6;
		} while (cVar1 != '\0');
		uVar3 = ~uVar3;
		puVar5 = (undefined4 *)(pcVar6 + -uVar3);
		for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
			*puVar2 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar2 = puVar2 + 1;
		}
		for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
			*(undefined *)puVar2 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar2 = (undefined4 *)((int)puVar2 + 1);
		}
	}
	return;
}



void __cdecl lego::res::Container_Frame_RemoveAppData(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != (Container_AppData *)0x0) {
		if (appData->animSetFileName != (char *)0x0) {
			std::free(appData->animSetFileName);
		}
		std::free(appData);
	}
	(*frame->lpVtbl->SetAppData)(frame,(Container_AppData *)0x0);
	return;
}



// ACCESSOR: ResourceAppData->resData (field_0)

Container * __cdecl lego::res::Container_Frame_GetOwner(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != (Container_AppData *)0x0) {
		return appData->ownerContainer;
	}
	return (Container *)0x0;
}



// ACCESSOR: ResourceAppData->filename (field_4)

char * __cdecl lego::res::Container_Frame_GetAnimSetFileName(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != (Container_AppData *)0x0) {
		return appData->animSetFileName;
	}
	return (char *)0x0;
}



// ACCESSOR: ResourceAppData->actFrameRes (field_1c)

AnimClone * __cdecl lego::res::Container_Frame_GetAnimClone(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != (Container_AppData *)0x0) {
		return appData->animClone;
	}
	return (AnimClone *)0x0;
}



// ACCESSOR: ResourceAppData->field_c (field_c)

uint __cdecl lego::res::Container_Frame_GetFrameCount(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != (Container_AppData *)0x0) {
		return appData->frameCount;
	}
	return 0;
}



// ACCESSOR: ResourceAppData->float_10 (field_10)

float10 __cdecl lego::res::Container_Frame_GetCurrTime(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != (Container_AppData *)0x0) {
		return (float10)appData->currTime;
	}
	return (float10)0.0;
}



// ACCESSOR: ResourceAppData->float_14 (field_14)

float10 __cdecl lego::res::Container_Frame_GetTransCo(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != (Container_AppData *)0x0) {
		return (float10)appData->transCo;
	}
	return (float10)0.0;
}



// ACCESSOR: ResourceAppData->sampleName (field_18)

char * __cdecl lego::res::Container_Frame_GetSample(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != (Container_AppData *)0x0) {
		return appData->activitySample;
	}
	return (char *)0x0;
}



// ACCESSOR: ResourceAppData->field_20 (field_20)

uint __cdecl lego::res::Container_Frame_GetTrigger(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != (Container_AppData *)0x0) {
		return appData->trigger;
	}
	return 0;
}



void __cdecl
lego::res::Container_Frame_SafeAddChild(IDirect3DRMFrame3 *parent,IDirect3DRMFrame3 *child)
{
	IDirect3DRMFrame3 *lpD3DRMFrameChild;
	Matrix4F matrix;
	
	lpD3DRMFrameChild = child;
										// IDirect3DRMFrame3->GetParent(this, IDirect3DRMFrame3** lplpParent)
	(*child->lpVtbl->GetParent)(child,&child);
										// IDirect3DRMFrame3->GetTransform(this, IDirect3DRMFrame3* lpRefFrame,
										// Matrix4F** rmMatrix)
										// (this = frame2, lpRefFrame = GetParent)
	(*lpD3DRMFrameChild->lpVtbl->GetTransform)(lpD3DRMFrameChild,child,&matrix);
	if (child != (IDirect3DRMFrame3 *)0x0) {
										// IDirect3DRMFrame3->Release(this)
										//  (this = GetParent)
		(*child->lpVtbl->Release)(child);
	}
										// IDirect3DRMFrame3->AddChild(this, IDirect3DRMFrame3* lpD3DRMFrameChild)
										//  (this = frame1, lpChild = frame2)
	(*parent->lpVtbl->AddChild)(parent,lpD3DRMFrameChild);
										// IDirect3DRMFrame3->AddTransform(this, TD3DRMCombineType rctCombine, Matrix4F*
										// rmMatrix)
										//  (this = frame2)
	(*lpD3DRMFrameChild->lpVtbl->AddTransform)(lpD3DRMFrameChild,D3DRMCOMBINE_REPLACE,&matrix);
	return;
}



void __cdecl lego::res::Container_Frame_FormatName(IDirect3DRMFrame3 *frame,char *msg,...)
{
	int iVar1;
	char *buffer;
	char local_400 [1024];
	
	iVar1 = std::vsprintf(local_400,msg,&stack0x0000000c);
	buffer = (char *)std::malloc(iVar1 + 1);
	std::vsprintf(buffer,msg,&stack0x0000000c);
	(*frame->lpVtbl->SetName)((IUnknown *)frame,buffer);
	Container_Frame_SetAppData
						(frame,(Container *)0x0,(AnimClone *)0x0,(char *)0x0,(uint *)0x0,buffer,(float *)0x0,
						 (float *)0x0,(char *)0x0,(Sound3D_SoundFrameRecord *)0x0,(uint *)0x0);
	return;
}



void __cdecl lego::res::Container_Frame_FreeName(IDirect3DRMFrame3 *frame)
{
	char *buffer;
	
	buffer = Container_Frame_GetName(frame);
	if (buffer != (char *)0x0) {
		std::free(buffer);
	}
	return;
}



char * __cdecl lego::res::Container_Frame_GetName(IDirect3DRMFrame3 *frame)
{
	DWORD DVar1;
	
	DVar1 = (*frame->lpVtbl->GetAppData)((IUnknown *)frame);
	if (DVar1 != 0) {
		return *(char **)(DVar1 + 8);
	}
	return (char *)0x0;
}



BOOL __cdecl
lego::res::Container_Frame_WalkTree
					(IDirect3DRMFrame3 *frame,uint level,ContainerWalkTreeCallback *Callback,void *data)
{
	IDirect3DRMFrame3 *This;
	ContainerWalkTreeCallback *Callback_00;
	void *data_00;
	BOOL BVar1;
	uint uVar2;
	code **unaff_EBX;
	uint uVar3;
	IDirect3DRMFrame3 *unaff_EDI;
	int *local_8;
	int *local_4;
	
	data_00 = data;
	Callback_00 = Callback;
	This = frame;
	local_8 = (int *)0x0;
	BVar1 = (*Callback)(frame,data);
	if (BVar1 != 0) {
		return (BOOL)(IDirect3DRMFrame3 *)TRUE;
	}
	(*This->lpVtbl->GetChildren)(This,(IDirect3DRMFrameArray **)&frame);
	uVar2 = (**(code **)(*local_4 + 0xc))(local_4);
	uVar3 = 0;
	if (uVar2 != 0) {
		do {
			(**(code **)(*local_8 + 0x10))(local_8,uVar3,register0x00000010);
			(**(code **)*unaff_EBX)(unaff_EBX,&idl::IID_IDirect3DRMFrame3,&local_8);
			(*unaff_EDI->lpVtbl->Release)((IUnknown *)unaff_EDI);
			BVar1 = Container_Frame_WalkTree(unaff_EDI,(int)local_4 + 1,Callback_00,data_00);
			if (BVar1 != 0) {
				(*unaff_EDI->lpVtbl->Release)((IUnknown *)unaff_EDI);
				break;
			}
			(*unaff_EDI->lpVtbl->Release)((IUnknown *)unaff_EDI);
			uVar3 = uVar3 + 1;
		} while (uVar3 < uVar2);
	}
	(**(code **)(*local_8 + 8))(local_8);
	return (BOOL)unaff_EDI;
}



BOOL __cdecl
lego::res::Container_Frame_SearchCallback(IDirect3DRMFrame3 *frame,Container_SearchData *search)
{
	byte bVar1;
	ContainerSearchMode CVar2;
	IDirect3DRMFrame3 *This;
	Container_SearchData *pCVar3;
	byte *lpName;
	uint uVar4;
	byte *pbVar5;
	int iVar6;
	uint unaff_EBP;
	byte *pbVar7;
	bool bVar8;
	
	This = frame;
	(*frame->lpVtbl->GetName)((IUnknown *)frame,(LPDWORD)&frame,(LPSTR)0x0);
	pCVar3 = search;
	if ((int)&frame[-1].lpVtbl + 3U != search->stringLen) {
		return 0;
	}
	lpName = (byte *)std::malloc((uint)frame);
	*lpName = 0;
	(*This->lpVtbl->GetName)((IUnknown *)This,(LPDWORD)&frame,(LPSTR)lpName);
	uVar4 = 0;
	if (unaff_EBP != 0) {
		do {
			if (pCVar3->string[uVar4] == '?') {
				lpName[uVar4] = 0x3f;
			}
			uVar4 = uVar4 + 1;
		} while (uVar4 < unaff_EBP);
	}
	CVar2 = pCVar3->mode;
	if (CVar2 == CONTAINER_SEARCHMODE_FIRSTMATCH) {
		pCVar3->resultFrame = (IDirect3DRMFrame3 *)0x0;
		if (pCVar3->caseSensitive == 0) {
			iVar6 = std::_stricmp((char *)lpName,pCVar3->string);
		}
		else {
			pbVar7 = (byte *)pCVar3->string;
			pbVar5 = lpName;
			do {
				bVar1 = *pbVar5;
				bVar8 = bVar1 < *pbVar7;
				if (bVar1 != *pbVar7) {
LAB_0047676f:
					if (1 - bVar8 != (uint)(bVar8 != 0)) goto LAB_00476856;
					goto LAB_00476853;
				}
				if (bVar1 == 0) break;
				bVar1 = pbVar5[1];
				bVar8 = bVar1 < pbVar7[1];
				if (bVar1 != pbVar7[1]) goto LAB_0047676f;
				pbVar5 = pbVar5 + 2;
				pbVar7 = pbVar7 + 2;
			} while (bVar1 != 0);
			iVar6 = 0;
		}
		if (iVar6 != 0) goto LAB_00476856;
	}
	else {
		if (CVar2 == CONTAINER_SEARCHMODE_MATCHCOUNT) {
			if (pCVar3->caseSensitive == 0) {
				iVar6 = std::_stricmp((char *)lpName,pCVar3->string);
			}
			else {
				pbVar7 = (byte *)pCVar3->string;
				pbVar5 = lpName;
				do {
					bVar1 = *pbVar5;
					bVar8 = bVar1 < *pbVar7;
					if (bVar1 != *pbVar7) {
LAB_004767d0:
						if (1 - bVar8 == (uint)(bVar8 != 0)) {
							pCVar3->count = pCVar3->count + 1;
						}
						goto LAB_00476856;
					}
					if (bVar1 == 0) break;
					bVar1 = pbVar5[1];
					bVar8 = bVar1 < pbVar7[1];
					if (bVar1 != pbVar7[1]) goto LAB_004767d0;
					pbVar5 = pbVar5 + 2;
					pbVar7 = pbVar7 + 2;
				} while (bVar1 != 0);
				iVar6 = 0;
			}
			if (iVar6 == 0) {
				pCVar3->count = pCVar3->count + 1;
			}
			goto LAB_00476856;
		}
		if (CVar2 != CONTAINER_SEARCHMODE_NTHMATCH) goto LAB_00476856;
		pCVar3->resultFrame = (IDirect3DRMFrame3 *)0x0;
		if (pCVar3->caseSensitive == 0) {
			iVar6 = std::_stricmp((char *)lpName,pCVar3->string);
		}
		else {
			pbVar7 = (byte *)pCVar3->string;
			pbVar5 = lpName;
			do {
				bVar1 = *pbVar5;
				bVar8 = bVar1 < *pbVar7;
				if (bVar1 != *pbVar7) {
LAB_0047682a:
					iVar6 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
					goto joined_r0x00476843;
				}
				if (bVar1 == 0) break;
				bVar1 = pbVar5[1];
				bVar8 = bVar1 < pbVar7[1];
				if (bVar1 != pbVar7[1]) goto LAB_0047682a;
				pbVar5 = pbVar5 + 2;
				pbVar7 = pbVar7 + 2;
			} while (bVar1 != 0);
			iVar6 = 0;
		}
joined_r0x00476843:
		if (iVar6 == 0) {
			pCVar3->count = pCVar3->count + 1;
		}
		if (pCVar3->count != pCVar3->matchNumber + 1) goto LAB_00476856;
	}
LAB_00476853:
	pCVar3->resultFrame = This;
LAB_00476856:
	std::free(lpName);
	if (pCVar3->resultFrame == (IDirect3DRMFrame3 *)0x0) {
		return 0;
	}
	return TRUE;
}



AnimClone * __cdecl
lego::res::Container_LoadAnimSet
					(char *fname,IDirect3DRMFrame3 *frame,uint *out_frameCount,BOOL lws,BOOL looping)
{
	char cVar1;
	Lws_Info *scene;
	HRESULT HVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	IDirect3DRMFrame3 *unaff_EBX;
	AnimClone *pAVar6;
	IDirect3DRMAnimationSet2 *unaff_EBP;
	undefined4 *puVar7;
	undefined4 *puVar8;
	char *pcVar9;
	IDirect3DRMAnimationSet2 *local_11c;
	IDirect3DRMFrame3 *local_118;
	byte *local_114;
	uint local_110 [2];
	char acStack263 [3];
	char local_104 [260];
	
	pAVar6 = (AnimClone *)0x0;
	local_11c = (IDirect3DRMAnimationSet2 *)0x0;
	if (lws == 0) {
		local_114 = lego::file::File_LoadBinary(fname,local_110);
		if (local_114 != (byte *)0x0) {
										// IDirect3DRM3->CreateFrame(this, IDirect3DRMFrame3* lpD3DRMFrame,
										// IDirect3DRMFrame3** lplpD3DRMFrame)
			HVar2 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
												(globs::mainGlobs.lpD3DRM,frame,&local_118);
			if (HVar2 == 0) {
										// IDirect3DRM3->CreateAnimationSet(this, IDirect3DRMAnimationSet2**
										// lplpD3DRMAnimationSet)
				HVar2 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateAnimationSet)
													(globs::mainGlobs.lpD3DRM,&local_11c);
				if (HVar2 == 0) {
					local_114 = (byte *)fname;
					local_110[0] = 0;
										// IDirect3DRMAnimationSet2->Load(this, void* lpvObjSource, void* lpvObjID,
										// TD3DRMLoadOptions drd3mLOFlags, TD3DRMLoadTexture3Callback
										// d3drmLoadTextureProc, void* lpArgLTP, IDirect3DRMFrame3* lpParentFrame)
					iVar3 = (*(code *)unaff_EBP->lpVtbl->Load)
														(unaff_EBP,&local_11c,0,2,Container_TextureLoadCallback,&local_114,
														 unaff_EBX);
					if (iVar3 == 0) {
										// IDirect3DRMAnimationSet2->SetTime(this, float rvTime)
						(*(code *)unaff_EBP->lpVtbl->SetTime)(unaff_EBP,0);
						uVar4 = Container_GetAnimFileFrameCount((char *)local_11c);
						if (fname != (char *)0x0) {
							*(uint *)fname = uVar4;
						}
						pAVar6 = AnimClone_Register(unaff_EBP,unaff_EBX,uVar4);
					}
					std::free(local_11c);
				}
										// IDirect3DRMFrame3->Release(this)
				(*unaff_EBX->lpVtbl->Release)((IUnknown *)unaff_EBX);
			}
		}
	}
	else {
		uVar4 = 0xffffffff;
		do {
			pcVar9 = fname;
			if (uVar4 == 0) break;
			uVar4 = uVar4 - 1;
			pcVar9 = fname + 1;
			cVar1 = *fname;
			fname = pcVar9;
		} while (cVar1 != '\0');
		uVar4 = ~uVar4;
		puVar7 = (undefined4 *)(pcVar9 + -uVar4);
		puVar8 = (undefined4 *)local_104;
		for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
			*puVar8 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar8 = puVar8 + 1;
		}
		for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
			*(undefined *)puVar8 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar8 = (undefined4 *)((int)puVar8 + 1);
		}
		uVar4 = 0xffffffff;
		pcVar9 = local_104;
		do {
			if (uVar4 == 0) break;
			uVar4 = uVar4 - 1;
			cVar1 = *pcVar9;
			pcVar9 = pcVar9 + 1;
		} while (cVar1 != '\0');
		acStack263[~uVar4] = '\0';
		scene = Lws_Parse(local_104,looping);
		if (scene != (Lws_Info *)0x0) {
			Lws_LoadMeshes(scene,frame);
			Lws_SetTime(scene,0.0);
			if (out_frameCount != (uint *)0x0) {
				uVar4 = Lws_GetFrameCount(scene);
				*out_frameCount = uVar4;
			}
			pAVar6 = AnimClone_RegisterLws(scene,frame,*out_frameCount);
			return pAVar6;
		}
	}
	return pAVar6;
}



uint __cdecl lego::res::Container_GetAnimFileFrameCount(char *fileData)
{
	byte *str;
	uint uVar1;
	
	uVar1 = 0;
	str = (byte *)std::strstr(fileData,"DDiScene");
	if (str != (byte *)0x0) {
		while( true ) {
										// int std::isdigit(int c)
			if (std::globals::_pcharwidth < 2) {
										// C1_DIGIT (0x4)
				uVar1 = *(byte *)(std::globals::_pctype + *str) & C1_DIGIT;
			}
			else {
										// C1_DIGIT (0x4)
				uVar1 = std::_isctype((uint)*str,C1_DIGIT);
			}
			if (uVar1 != 0) break;
			str = str + 1;
		}
		uVar1 = std::atoi((char *)str);
	}
	if (uVar1 == 0) {
		uVar1 = 1;
	}
	return uVar1;
}



BOOL __cdecl lego::res::Container_FrameLoad(char *fname,IDirect3DRMFrame3 *frame)
{
	int iVar1;
	uint uVar2;
	void *buffer;
	byte *local_10;
	uint fileSize;
	char *local_8;
	undefined4 local_4;
	
	uVar2 = 0;
	local_10 = lego::file::File_LoadBinary(fname,&fileSize);
	if (local_10 != (byte *)0x0) {
		buffer = (void *)0x0;
		local_8 = fname;
		local_4 = 0;
		iVar1 = (*(code *)frame->lpVtbl->Load)
											(frame,&local_10,0,2,Container_TextureLoadCallback,&local_8);
		uVar2 = (uint)(iVar1 == 0);
		std::free(buffer);
	}
	return uVar2;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

IDirect3DRMMesh * __cdecl
lego::res::Container_MeshLoad
					(void *file_data,uint file_size,char *file_name,IDirect3DRMFrame3 *frame,BOOL noTexture)
{
	int iVar1;
	int *piVar2;
	IDirect3DRMMesh **ppIVar3;
	IDirect3DRMMesh *local_10;
	HRESULT local_c;
	IDirect3DRMMeshBuilder3 *local_8;
	uint local_4;
	
	local_8 = (IDirect3DRMMeshBuilder3 *)file_data;
	local_4 = file_size;
										// IDirect3DRM3->CreateMeshBuilder(this, IDirect3DRMMeshBuilder3**
										// lplpD3DRMMeshBuilder)
	local_c = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateMeshBuilder)
											(globs::mainGlobs.lpD3DRM,(IDirect3DRMMeshBuilder3 **)&file_data);
	ppIVar3 = &local_10;
	if (local_c == 0) {
		local_10 = (IDirect3DRMMesh *)file_name;
		if (noTexture != 0) {
			local_c = 1;
		}
										// WARNING: Load size is inaccurate
		piVar2 = (int *)0x2;
										// IDirect3DRMMeshBuilder3->Load(this, void* lpvObjSource, void* lpvObjID,
										// TD3DRMLoadOptions d3drmLOFlags, TD3DRMLoadTexture3Callback
										// d3drmLoadTextureProc, void* lpvArg)
										//   D3DRMLOAD_FROMMEMORY (0x2)
		iVar1 = (**(code **)((int)*file_data + 0x2c))
											(file_data,&local_8,0,2,Container_TextureLoadCallback);
		if (iVar1 == 0) {
										// IDirect3DRMMeshBuilder3->CreateMesh(this, IDirect3DRMMesh** lplpD3DRMMesh)
			(**(code **)((int)*ppIVar3 + 0xc0))(ppIVar3,&local_10);
			(**(code **)(*piVar2 + 8))(piVar2);
										// IDirect3DRMFrame3->AddVisual(this, IDirect3DRMVisual* lpD3DRMVisual)
			iVar1 = (**(code **)((int)*ppIVar3 + 0x48))(ppIVar3,piVar2);
			if (iVar1 == 0) {
				return local_10;
			}
		}
		(**(code **)((int)*ppIVar3 + 8))(ppIVar3);
	}
	return (IDirect3DRMMesh *)0x0;
}



HRESULT __cdecl
lego::res::Container_TextureLoadCallback
					(char *name,Container_TextureData *textureData,IDirect3DRMTexture3 **texture)
{
	byte bVar1;
	IDirect3DRMTexture3 *pIVar2;
	char cVar3;
	byte *pbVar4;
	Container_Texture *pCVar5;
	char **ppcVar6;
	uint uVar7;
	int iVar8;
	uint uVar9;
	uint uVar10;
	char *pcVar11;
	char *pcVar12;
	Container_TextureRef *pCVar13;
	undefined4 *puVar14;
	byte *pbVar15;
	char **ppcVar16;
	char *pcVar17;
	char *pcVar18;
	char *pcVar19;
	undefined4 *puVar20;
	char **ppcVar21;
	bool bVar22;
	char *local_410;
	char *local_40c;
	int local_408;
	char *local_404;
	char local_400 [1024];
	
	if ((*(byte *)&textureData->flags & 1) == 0) {
		pcVar12 = textureData->xFileName;
		pcVar11 = local_400;
		local_410 = (char *)0x0;
		local_40c = pcVar12;
		local_404 = pcVar11;
		local_408 = 0;
		if ((globs::containerGlobs.sharedDir != (char *)0x0) != 0xffffffff) {
LAB_00476c0f:
			if (local_408 == 0) {
				cVar3 = *pcVar12;
				if (cVar3 != '\0') {
					do {
						if (cVar3 == '\\') {
							if (local_410 != (char *)0x0) {
								*local_410 = '\\';
							}
							*pcVar11 = '\0';
							local_410 = pcVar11;
						}
						else {
							*pcVar11 = cVar3;
						}
						cVar3 = pcVar12[1];
						pcVar12 = pcVar12 + 1;
						pcVar11 = pcVar11 + 1;
					} while (cVar3 != '\0');
					local_404 = pcVar11;
					local_40c = pcVar12;
				}
				if (local_410 == (char *)0x0) {
					uVar7 = 0xffffffff;
					pcVar18 = name;
					do {
						pcVar17 = pcVar18;
						if (uVar7 == 0) break;
						uVar7 = uVar7 - 1;
						pcVar17 = pcVar18 + 1;
						cVar3 = *pcVar18;
						pcVar18 = pcVar17;
					} while (cVar3 != '\0');
					uVar7 = ~uVar7;
					puVar14 = (undefined4 *)(pcVar17 + -uVar7);
					puVar20 = (undefined4 *)local_400;
					for (uVar9 = uVar7 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
						*puVar20 = *puVar14;
						puVar14 = puVar14 + 1;
						puVar20 = puVar20 + 1;
					}
					for (uVar7 = uVar7 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {
						*(undefined *)puVar20 = *(undefined *)puVar14;
						puVar14 = (undefined4 *)((int)puVar14 + 1);
						puVar20 = (undefined4 *)((int)puVar20 + 1);
					}
				}
				else {
					uVar7 = 0xffffffff;
					pcVar18 = "\\";
					do {
						pcVar17 = pcVar18;
						if (uVar7 == 0) break;
						uVar7 = uVar7 - 1;
						pcVar17 = pcVar18 + 1;
						cVar3 = *pcVar18;
						pcVar18 = pcVar17;
					} while (cVar3 != '\0');
					uVar7 = ~uVar7;
					iVar8 = -1;
					puVar14 = (undefined4 *)local_400;
					do {
						puVar20 = puVar14;
						if (iVar8 == 0) break;
						iVar8 = iVar8 + -1;
						puVar20 = (undefined4 *)((int)puVar14 + 1);
						cVar3 = *(char *)puVar14;
						puVar14 = puVar20;
					} while (cVar3 != '\0');
					puVar14 = (undefined4 *)(pcVar17 + -uVar7);
					puVar20 = (undefined4 *)((int)puVar20 + -1);
					for (uVar9 = uVar7 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
						*puVar20 = *puVar14;
						puVar14 = puVar14 + 1;
						puVar20 = puVar20 + 1;
					}
					for (uVar7 = uVar7 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {
						*(undefined *)puVar20 = *(undefined *)puVar14;
						puVar14 = (undefined4 *)((int)puVar14 + 1);
						puVar20 = (undefined4 *)((int)puVar20 + 1);
					}
					uVar7 = 0xffffffff;
					pcVar18 = name;
					do {
						pcVar17 = pcVar18;
						if (uVar7 == 0) break;
						uVar7 = uVar7 - 1;
						pcVar17 = pcVar18 + 1;
						cVar3 = *pcVar18;
						pcVar18 = pcVar17;
					} while (cVar3 != '\0');
					uVar7 = ~uVar7;
					iVar8 = -1;
					pcVar18 = local_400;
					do {
						pcVar19 = pcVar18;
						if (iVar8 == 0) break;
						iVar8 = iVar8 + -1;
						pcVar19 = pcVar18 + 1;
						cVar3 = *pcVar18;
						pcVar18 = pcVar19;
					} while (cVar3 != '\0');
					puVar14 = (undefined4 *)(pcVar17 + -uVar7);
					puVar20 = (undefined4 *)(pcVar19 + -1);
					for (uVar9 = uVar7 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
						*puVar20 = *puVar14;
						puVar14 = puVar14 + 1;
						puVar20 = puVar20 + 1;
					}
					for (uVar7 = uVar7 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {
						*(undefined *)puVar20 = *(undefined *)puVar14;
						puVar14 = (undefined4 *)((int)puVar14 + 1);
						puVar20 = (undefined4 *)((int)puVar20 + 1);
					}
				}
			}
			else {
				std::sprintf(local_400,"%s\\%s",globs::containerGlobs.sharedDir,name);
			}
			uVar7 = 0;
			*texture = (IDirect3DRMTexture3 *)0x0;
			if (globs::containerGlobs.textureCount != 0) {
				pCVar13 = globs::containerGlobs.textureSet;
				do {
					pbVar4 = (byte *)pCVar13->filename;
					if (pbVar4 != (byte *)0x0) {
						pbVar15 = (byte *)local_400;
						do {
							bVar1 = *pbVar4;
							bVar22 = bVar1 < *pbVar15;
							if (bVar1 != *pbVar15) {
LAB_00476d3e:
								iVar8 = (1 - (uint)bVar22) - (uint)(bVar22 != 0);
								goto LAB_00476d43;
							}
							if (bVar1 == 0) break;
							bVar1 = pbVar4[1];
							bVar22 = bVar1 < pbVar15[1];
							if (bVar1 != pbVar15[1]) goto LAB_00476d3e;
							pbVar4 = pbVar4 + 2;
							pbVar15 = pbVar15 + 2;
						} while (bVar1 != 0);
						iVar8 = 0;
LAB_00476d43:
						pcVar11 = local_404;
						if (iVar8 == 0) {
							pIVar2 = globs::containerGlobs.textureSet[uVar7].texture;
							*texture = pIVar2;
							(*pIVar2->lpVtbl->AddRef)((IUnknown *)pIVar2);
							return 0;
						}
					}
					uVar7 = uVar7 + 1;
					pCVar13 = pCVar13 + 1;
					pcVar12 = local_40c;
				} while (uVar7 < globs::containerGlobs.textureCount);
			}
			pCVar5 = Container_LoadTexture2(local_400,0,(uint *)0x0,(uint *)0x0);
			if (pCVar5 == (Container_Texture *)0x0) {
				local_408 = local_408 + 1;
				if ((int)((globs::containerGlobs.sharedDir != (char *)0x0) + 1) <= local_408) {
					return -0x7789fcef;
				}
				goto LAB_00476c0f;
			}
			pIVar2 = pCVar5->texture;
			*texture = pIVar2;
			Container_YFlipTexture(pIVar2);
			if (((byte)globs::mainGlobs.flags & CMD_MIPMAP) != 0) {
				(*(code *)(*texture)->lpVtbl->GenerateMIPMap)(*texture,0);
			}
			if (globs::containerGlobs.textureCount == 1000) {
				std::qsort(globs::containerGlobs.textureSet,1000,8,Container_TextureSetSort);
				while (globs::containerGlobs.visualArray[globs::containerGlobs.textureCount * 2 + 2] ==
							 (IDirect3DRMVisual *)0x0) {
					globs::containerGlobs.textureCount = globs::containerGlobs.textureCount - 1;
				}
			}
			uVar7 = globs::containerGlobs.textureCount;
			if (globs::containerGlobs.textureCount < 1000) {
				pCVar13 = globs::containerGlobs.textureSet + globs::containerGlobs.textureCount;
				(*(*texture)->lpVtbl->AddDestroyCallback)
									((IUnknown *)*texture,Container_TextureDestroyCallback,pCVar13);
				uVar9 = 0xffffffff;
				ppcVar6 = &local_40c;
				do {
					if (uVar9 == 0) break;
					uVar9 = uVar9 - 1;
					cVar3 = *(char *)ppcVar6;
					ppcVar6 = (char **)((int)ppcVar6 + 1);
				} while (cVar3 != '\0');
				ppcVar6 = (char **)std::malloc(~uVar9);
				uVar9 = 0xffffffff;
				pCVar13->filename = (char *)ppcVar6;
				ppcVar16 = &local_40c;
				do {
					ppcVar21 = ppcVar16;
					if (uVar9 == 0) break;
					uVar9 = uVar9 - 1;
					ppcVar21 = (char **)((int)ppcVar16 + 1);
					cVar3 = *(char *)ppcVar16;
					ppcVar16 = ppcVar21;
				} while (cVar3 != '\0');
				uVar9 = ~uVar9;
				ppcVar16 = (char **)((int)ppcVar21 - uVar9);
				for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {
					*ppcVar6 = *ppcVar16;
					ppcVar16 = ppcVar16 + 1;
					ppcVar6 = ppcVar6 + 1;
				}
				for (uVar9 = uVar9 & 3; uVar9 != 0; uVar9 = uVar9 - 1) {
					*(undefined *)ppcVar6 = *(undefined *)ppcVar16;
					ppcVar16 = (char **)((int)ppcVar16 + 1);
					ppcVar6 = (char **)((int)ppcVar6 + 1);
				}
				globs::containerGlobs.textureSet[uVar7].texture = *texture;
				globs::containerGlobs.textureCount = globs::containerGlobs.textureCount + 1;
			}
			return 0;
		}
	}
	return -0x7789fcef;
}



void __cdecl lego::res::Container_YFlipTexture(IDirect3DRMTexture3 *texture)
{
	D3DRMImage *pDVar1;
	int iVar2;
	undefined4 *buffer;
	uint uVar3;
	undefined4 *puVar4;
	undefined4 *puVar5;
	uint length;
	undefined4 *puVar6;
	undefined4 *puVar7;
	int local_c;
	
	pDVar1 = (*texture->lpVtbl->GetImage)(texture);
	if (pDVar1 != (D3DRMImage *)0x0) {
		iVar2 = pDVar1->depth * pDVar1->width;
		length = (int)(iVar2 + (iVar2 >> 0x1f & 7U)) >> 3;
		buffer = (undefined4 *)std::malloc(length);
		if (buffer != (undefined4 *)0x0) {
			puVar4 = (undefined4 *)pDVar1->buffer1;
			local_c = 0;
			puVar5 = (undefined4 *)((pDVar1->height + -1) * pDVar1->bytes_per_line + (int)puVar4);
			if (0 < pDVar1->height / 2) {
				do {
					puVar6 = puVar5;
					puVar7 = buffer;
					for (uVar3 = length >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
						*puVar7 = *puVar6;
						puVar6 = puVar6 + 1;
						puVar7 = puVar7 + 1;
					}
					for (uVar3 = length & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
						*(undefined *)puVar7 = *(undefined *)puVar6;
						puVar6 = (undefined4 *)((int)puVar6 + 1);
						puVar7 = (undefined4 *)((int)puVar7 + 1);
					}
					puVar6 = puVar4;
					puVar7 = puVar5;
					for (uVar3 = length >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
						*puVar7 = *puVar6;
						puVar6 = puVar6 + 1;
						puVar7 = puVar7 + 1;
					}
					for (uVar3 = length & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
						*(undefined *)puVar7 = *(undefined *)puVar6;
						puVar6 = (undefined4 *)((int)puVar6 + 1);
						puVar7 = (undefined4 *)((int)puVar7 + 1);
					}
					puVar6 = buffer;
					puVar7 = puVar4;
					for (uVar3 = length >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
						*puVar7 = *puVar6;
						puVar6 = puVar6 + 1;
						puVar7 = puVar7 + 1;
					}
					for (uVar3 = length & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
						*(undefined *)puVar7 = *(undefined *)puVar6;
						puVar6 = (undefined4 *)((int)puVar6 + 1);
						puVar7 = (undefined4 *)((int)puVar7 + 1);
					}
					puVar4 = (undefined4 *)((int)puVar4 + pDVar1->bytes_per_line);
					puVar5 = (undefined4 *)((int)puVar5 - pDVar1->bytes_per_line);
					local_c = local_c + 1;
				} while (local_c < pDVar1->height / 2);
			}
			std::free(buffer);
		}
	}
	return;
}



// if (*param_1 && !*param_2) return -1;
// if (!*param_1 && *param_2) return  1;
// else                       return  0;

int __cdecl lego::res::Container_TextureSetSort(Container_TextureRef *a,Container_TextureRef *b)
{
	if ((a->filename != (char *)0x0) && (b->filename == (char *)0x0)) {
		return -1;
	}
	if ((a->filename == (char *)0x0) && (b->filename != (char *)0x0)) {
		return 1;
	}
	return 0;
}



void __cdecl
lego::res::Container_TextureDestroyCallback
					(IDirect3DRMTexture3 *lpD3DRMobj,Container_TextureRef *textRef)
{
	void *buffer;
	
	buffer = (*textRef->texture->lpVtbl->GetAppData)(textRef->texture);
	std::free(buffer);
	std::free(textRef->filename);
	textRef->filename = (char *)0x0;
	textRef->texture = (IDirect3DRMTexture3 *)0x0;
	return;
}



void __cdecl lego::view::Viewport_Initialise(void)
{
	int iVar1;
	Viewport_Globs *pVVar2;
	
	pVVar2 = &globs::viewportGlobs;
	for (iVar1 = 0x20; iVar1 != 0; iVar1 = iVar1 + -1) {
		pVVar2->listSet[0] = (Viewport *)0x0;
		pVVar2 = (Viewport_Globs *)(pVVar2->listSet + 1);
	}
	globs::viewportGlobs.freeList = (Viewport *)0x0;
	globs::viewportGlobs.listCount = 0;
	globs::viewportGlobs.flags = 1;
	return;
}



void __cdecl lego::view::Viewport_Shutdown(void)
{
	Viewport_Globs *pVVar1;
	
	Viewport_RemoveAll();
	pVVar1 = &globs::viewportGlobs;
	do {
		if (pVVar1->listSet[0] != (Viewport *)0x0) {
			std::free(pVVar1->listSet[0]);
		}
		pVVar1 = (Viewport_Globs *)(pVVar1->listSet + 1);
	} while (pVVar1 < (Viewport_Globs *)&globs::viewportGlobs.freeList);
	globs::viewportGlobs.freeList = (Viewport *)0x0;
	globs::viewportGlobs.flags = 0;
	return;
}



// Creates a viewport, where the float arguments are positions between 0.0 and 1.0
//  (rather than between 0,0 and rmWidth,rmHeight)

Viewport * __cdecl
lego::view::Viewport_Create(float xposf,float yposf,float widthf,float heightf,Container *resData)
{
	uint uVar1;
	uint uVar2;
	int yPos;
	Viewport *pVVar3;
	float10 extraout_ST0;
	longlong lVar4;
	float unaff_retaddr;
	float fVar5;
	float fStack4;
	
	uVar1 = (*(code *)(globs::mainGlobs.device)->lpVtbl->GetWidth)(globs::mainGlobs.device);
	uVar2 = (*(code *)(globs::mainGlobs.device)->lpVtbl->GetHeight)(globs::mainGlobs.device);
	fVar5 = (float)(ulonglong)uVar1;
	lVar4 = __ftol((float10)yposf * (float10)(ulonglong)uVar2);
	uVar1 = (uint)lVar4;
	lVar4 = __ftol((float10)xposf * (float10)fVar5);
	uVar2 = (uint)lVar4;
	lVar4 = __ftol((float10)unaff_retaddr * extraout_ST0);
	yPos = (int)lVar4;
	lVar4 = __ftol((float10)fStack4 * (float10)fVar5);
	pVVar3 = Viewport_CreatePixel((int)lVar4,yPos,uVar2,uVar1,(Container *)widthf);
	return pVVar3;
}



Viewport * __cdecl
lego::view::Viewport_CreatePixel(int xPos,int yPos,uint width,uint height,Container *resCamera)
{
	IDirect3DRMViewport2 **lplpD3DRMViewport;
	Viewport **ppVVar1;
	IDirect3DRMViewport2 *This;
	Viewport *appData;
	uint uVar2;
	uint uVar3;
	HRESULT HVar4;
	uint unaff_EBX;
	uint unaff_retaddr;
	
	uVar2 = (*(code *)(globs::mainGlobs.device)->lpVtbl->GetWidth)(globs::mainGlobs.device);
	uVar3 = (*(code *)(globs::mainGlobs.device)->lpVtbl->GetHeight)(globs::mainGlobs.device);
	if ((int)unaff_EBX < 0) {
		unaff_EBX = unaff_EBX + uVar2;
	}
	if ((int)unaff_retaddr < 0) {
		unaff_retaddr = unaff_retaddr + uVar3;
	}
	if ((xPos + unaff_EBX <= uVar2) && (yPos + unaff_retaddr <= uVar3)) {
		if (globs::viewportGlobs.freeList == (Viewport *)0x0) {
			Viewport_AddList();
		}
		appData = globs::viewportGlobs.freeList;
		lplpD3DRMViewport = &(globs::viewportGlobs.freeList)->lpVP;
		ppVVar1 = &(globs::viewportGlobs.freeList)->nextFree;
		globs::viewportGlobs.freeList = (globs::viewportGlobs.freeList)->nextFree;
		*ppVVar1 = (Viewport *)0x0;
										// IDirect3DRM3->CreateViewport(this, IDirect3DRMDevice3* lpDev,
										// IDirect3DRMFrame3* lpCamera, DWORD dwXPos, DWORD dwYPos, DWORD dwWidth, DWORD
										// dwHeight, IDirect3DRMViewport2** lplpD3DRMViewport)
		HVar4 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateViewport)
											(globs::mainGlobs.lpD3DRM,globs::mainGlobs.device,*(IDirect3DRMFrame3 **)width
											 ,unaff_EBX,unaff_retaddr,xPos,yPos,lplpD3DRMViewport);
		if (HVar4 == 0) {
			This = *lplpD3DRMViewport;
										// IDirect3DRMViewport2->SetAppData(this, ViewportData* appData)
			(*This->lpVtbl->SetAppData)(This,appData);
			appData->smoothFOV = 0.0;
			return appData;
		}
	}
	return (Viewport *)0x0;
}



void __cdecl lego::view::Viewport_GetSize(Viewport *view,uint *out_width,uint *out_height)
{
	DWORD DVar1;
	
	if (out_width != (uint *)0x0) {
		DVar1 = (*view->lpVP->lpVtbl->GetWidth)(view->lpVP);
		*out_width = DVar1;
	}
	if (out_height != (uint *)0x0) {
		DVar1 = (*view->lpVP->lpVtbl->GetHeight)(view->lpVP);
		*out_height = DVar1;
	}
	return;
}



void __cdecl lego::view::Viewport_SetCamera(Viewport *view,Container *resCamera)
{
	(*view->lpVP->lpVtbl->SetCamera)(view->lpVP,resCamera->masterFrame);
	return;
}



Container * __cdecl lego::view::Viewport_GetCamera(Viewport *view)
{
	HRESULT HVar1;
	Container *pCVar2;
	Container *pCVar3;
	
	pCVar3 = (Container *)0x0;
										// IDirect3DRMViewport2->GetCamera(this, IDirect3DRMFrame3** lplpCamera)
	HVar1 = (*view->lpVP->lpVtbl->GetCamera)(view->lpVP,(IDirect3DRMFrame3 **)&view);
	if (HVar1 == 0) {
										// ResourceData* IDirect3DRMFrame3->GetAppData(this)
		pCVar2 = (**(code **)((int)view->xoffset + 0x1c))((IDirect3DRMFrame3 *)view);
		if (pCVar2 != (Container *)0x0) {
			pCVar3 = (Container *)pCVar2->masterFrame;
		}
										// IDirect3DRMFrame3->Release(this)
		(**(code **)((int)view->xoffset + 8))(view);
	}
	return pCVar3;
}



void __cdecl lego::view::Viewport_SetBackClip(Viewport *view,float dist)
{
	(*view->lpVP->lpVtbl->SetBack)(view->lpVP,dist);
	return;
}



float10 __cdecl lego::view::Viewport_GetBackClip(Viewport *view)
{
	float10 fVar1;
	
										// float IDirect3DRMViewport2->GetBack(this)
	fVar1 = (*view->lpVP->lpVtbl->GetBack)(view->lpVP);
	return fVar1;
}



float10 __cdecl lego::view::Viewport_GetFrontClip(Viewport *view)
{
	float10 fVar1;
	
										// float IDirect3DRMViewport2->GetFront(this)
	fVar1 = (*view->lpVP->lpVtbl->GetFront)(view->lpVP);
	return fVar1;
}



void __cdecl lego::view::Viewport_Clear(Viewport *view,BOOL full)
{
	Viewport *pVVar1;
	IDirect3DRMFrame3 *pIVar2;
	DWORD DVar3;
	longlong lVar4;
	RECT local_20;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pVVar1 = view;
	if ((IDirect3DViewport3 *)full != (IDirect3DViewport3 *)0x0) {
		pIVar2 = Viewport_GetScene(view);
		DVar3 = 0;
		view = (Viewport *)(*pVVar1->lpVP->lpVtbl->GetX)(pVVar1->lpVP);
		local_10 = (float)(int)view;
		view = (Viewport *)(*pVVar1->lpVP->lpVtbl->GetY)(pVVar1->lpVP);
		local_c = (float)(int)view;
		local_20.left = (*pVVar1->lpVP->lpVtbl->GetWidth)(pVVar1->lpVP);
		local_20.top = 0;
		local_8 = (float)(ulonglong)(uint)local_20.left;
		local_20.left = (*pVVar1->lpVP->lpVtbl->GetHeight)(pVVar1->lpVP);
		local_20.top = 0;
		local_4 = (float)(ulonglong)(uint)local_20.left;
		if (pIVar2 != (IDirect3DRMFrame3 *)0x0) {
			DVar3 = (*pIVar2->lpVtbl->GetSceneBackground)(pIVar2);
		}
		lVar4 = __ftol((float10)local_10);
		local_20.left = (LONG)lVar4;
		lVar4 = __ftol((float10)local_c);
		local_20.top = (LONG)lVar4;
		lVar4 = __ftol((float10)local_10 + (float10)local_8);
		local_20.right = (LONG)lVar4;
		lVar4 = __ftol((float10)local_c + (float10)local_4);
		local_20.bottom = (LONG)lVar4;
		(*pVVar1->lpVP->lpVtbl->GetDirect3DViewport)(pVVar1->lpVP,(IDirect3DViewport **)&view);
		(**(code **)view->xoffset)
							((IDirect3DViewport *)view,&idl::IID_IDirect3DViewport3,(IDirect3DViewport3 **)&full);
		(**(code **)((int)view->xoffset + 8))((IDirect3DViewport *)view);
		(**(code **)((int)*(IDirect3DViewport3 *)full + 0x50))
							((IDirect3DViewport3 *)full,1,&local_20,3,DVar3,1.0,0);
		(**(code **)((int)*(IDirect3DViewport3 *)full + 8))((IDirect3DViewport3 *)full);
		return;
	}
	(*view->lpVP->lpVtbl->Clear)(view->lpVP,D3DRMCLEAR_ALL);
	return;
}



void __cdecl lego::view::Viewport_Render(Viewport *view,Container *resRoot,float delta)
{
	float fVar1;
	HRESULT err;
	float10 fVar2;
	
	view->rendering = 1;
	if (view->smoothFOV != 0.0) {
										// float IDirect3DRMViewport2->GetField(this)
		fVar2 = (*view->lpVP->lpVtbl->GetField)(view->lpVP);
		fVar1 = (1.0 / delta) * 4.0;
		fVar1 = (1.0 / (fVar1 - -1.0)) * (float)(fVar2 * (float10)fVar1 + (float10)view->smoothFOV);
										// IDirect3DRMViewport2->SetField(this, float rvField)
		(*view->lpVP->lpVtbl->SetField)(view->lpVP,fVar1);
		if (fVar1 == view->smoothFOV) {
			view->smoothFOV = 0.0;
		}
	}
										// IDirect3DRMViewport2->Render(this, IDirect3DRMFrame3* lpD3DRMFrame)
	err = (*view->lpVP->lpVtbl->Render)(view->lpVP,resRoot->masterFrame);
	if (err == 0) {
		Mesh_PostRenderAll(view);
		view->rendering = 0;
		return;
	}
	debug::Error_SetDXError(err,1,"C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Viewports.c",286);
	view->rendering = 0;
	return;
}



void __cdecl lego::view::Viewport_Remove(Viewport *view)
{
	view->nextFree = globs::viewportGlobs.freeList;
	globs::viewportGlobs.freeList = view;
	(*view->lpVP->lpVtbl->Release)(view->lpVP);
	return;
}



void __cdecl lego::view::Viewport_SmoothSetField(Viewport *view,float fov)
{
	view->smoothFOV = fov;
	return;
}



void __cdecl lego::view::Viewport_SetField(Viewport *view,float fov)
{
	(*view->lpVP->lpVtbl->SetField)(view->lpVP,fov);
	view->smoothFOV = 0.0;
	return;
}



float10 __cdecl lego::view::Viewport_GetField(Viewport *view)
{
	float10 fVar1;
	
	fVar1 = (*view->lpVP->lpVtbl->GetField)(view->lpVP);
	return fVar1;
}



void __cdecl
lego::view::Viewport_InverseTransform(Viewport *view,Vector3F *out_vector,Vector4F *transform4d)
{
										// IDirect3DRMViewport2->InverseTransform(this, Vector3F* out_lprvDst, const
										// Vector4F* lprvSrc)
	(*view->lpVP->lpVtbl->InverseTransform)(view->lpVP,out_vector,transform4d);
	return;
}



void __cdecl
lego::view::Viewport_Transform(Viewport *view,Vector4F *out_transform4d,Vector3F *vector)
{
										// IDirect3DRMViewport2->Transform(this, Vector4F** lplprvDst, Vector3F*
										// lprvSrc)
	(*view->lpVP->lpVtbl->Transform)(view->lpVP,out_transform4d,vector);
	return;
}



Point2F * __cdecl
lego::view::Viewport_WorldToScreen(Viewport *view,Point2F *out_screenPt,Vector3F *in_worldVec)
{
	Vector4F transform4d;
	
										// IDirect3DRMViewport2->Transform(this, Vector4F** lplprvDst, Vector3F*
										// lprvSrc)
	(*view->lpVP->lpVtbl->Transform)(view->lpVP,&transform4d,in_worldVec);
										// out_point.x = (transform4d.x / transform4d.w)
										// out_point.y = (transform4d.y / transform4d.w)
	out_screenPt->x = transform4d.x / transform4d.w;
	out_screenPt->y = transform4d.y / transform4d.w;
	return out_screenPt;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

IDirect3DRMFrame3 * __cdecl lego::view::Viewport_GetScene(Viewport *view)
{
	IDirect3DRMFrame3 *local_8;
	IDirect3DRMFrame3 *local_4;
	
	local_8 = (IDirect3DRMFrame3 *)0x0;
	local_4 = (IDirect3DRMFrame3 *)0x0;
	(*view->lpVP->lpVtbl->GetCamera)(view->lpVP,&local_8);
	if (local_8 != (IDirect3DRMFrame3 *)0x0) {
		(*local_8->lpVtbl->Release)((IUnknown *)local_8);
		(*local_8->lpVtbl->GetScene)((IDirect3DRMViewport2 *)local_8,(IDirect3DRMDevice3 **)&local_4);
		(*local_4->lpVtbl->Release)((IUnknown *)local_4);
	}
	return local_4;
}



void __cdecl lego::view::Viewport_AddList(void)
{
	Viewport *pVVar1;
	Viewport *pVVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::viewportGlobs.listCount & 0x1f);
	pVVar2 = (Viewport *)std::malloc(uVar4 * 0x20);
	globs::viewportGlobs.listSet[globs::viewportGlobs.listCount] = pVVar2;
	pVVar2 = globs::viewportGlobs.listSet[globs::viewportGlobs.listCount];
	if (pVVar2 != (Viewport *)0x0) {
		globs::viewportGlobs.listCount = globs::viewportGlobs.listCount + 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pVVar1 = pVVar2;
			do {
				pVVar1->nextFree = pVVar1 + 1;
				iVar3 = iVar3 + -1;
				pVVar1 = pVVar1 + 1;
			} while (iVar3 != 0);
		}
		pVVar2[uVar4 - 1].nextFree = globs::viewportGlobs.freeList;
		globs::viewportGlobs.freeList = pVVar2;
	}
	return;
}



void __cdecl lego::view::Viewport_RemoveAll(void)
{
	int iVar1;
	int iVar2;
	Viewport_Globs *pVVar3;
	uint uVar4;
	int iVar5;
	
	uVar4 = 0;
	if (globs::viewportGlobs.listCount != 0) {
		pVVar3 = &globs::viewportGlobs;
		do {
			if ((pVVar3->listSet[0] != (Viewport *)0x0) && (iVar1 = 1 << ((byte)uVar4 & 0x1f), iVar1 != 0)
				 ) {
				iVar5 = 0;
				do {
					iVar2 = (int)&pVVar3->listSet[0]->xoffset + iVar5;
					if ((iVar2 != 0) && (*(int *)(iVar2 + 0x1c) == iVar2)) {
										// IDirect3DRMViewport2->Release(this)
						(*(*(IDirect3DRMViewport2 **)(iVar2 + 0x10))->lpVtbl->Release)
											(*(IDirect3DRMViewport2 **)(iVar2 + 0x10));
					}
					iVar5 = iVar5 + 0x20;
					iVar1 = iVar1 + -1;
				} while (iVar1 != 0);
			}
			uVar4 = uVar4 + 1;
			pVVar3 = (Viewport_Globs *)(pVVar3->listSet + 1);
		} while (uVar4 < globs::viewportGlobs.listCount);
	}
	return;
}



int __cdecl lego::util::Util_Tokenise(char *input,char **out_parts,char *delimiter)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	int numParts;
	char *pcVar4;
	char **ppcVar5;
	
	uVar3 = 0xffffffff;
	pcVar4 = delimiter;
	do {
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		cVar1 = *pcVar4;
		pcVar4 = pcVar4 + 1;
	} while (cVar1 != '\0');
	if (*input == '\0') {
		return 0;
	}
	numParts = 1;
	*out_parts = input;
	if (*input != '\0') {
		ppcVar5 = out_parts + 1;
		do {
			iVar2 = std::strncmp(delimiter,input,~uVar3 - 1);
			if (iVar2 == 0) {
				*input = '\0';
				*ppcVar5 = input + (~uVar3 - 1);
				numParts = numParts + 1;
				ppcVar5 = ppcVar5 + 1;
			}
			pcVar4 = input + 1;
			input = input + 1;
		} while (*pcVar4 != '\0');
	}
	return numParts;
}



int __cdecl lego::util::Util_WSTokenise(char *input,char **out_parts)
{
	uint uVar1;
	int iVar2;
	byte **ppbVar3;
	
	if (*input != '\0') {
		*out_parts = input;
		iVar2 = 1;
		if (*input != '\0') {
			ppbVar3 = (byte **)(out_parts + 1);
			do {
										// int std::isspace(int c)
				if (std::globals::_pcharwidth < 2) {
										// C1_SPACE (0x8)
					uVar1 = *(byte *)(std::globals::_pctype + (byte)*input) & C1_SPACE;
				}
				else {
										// C1_SPACE (0x8)
					uVar1 = std::_isctype((uint)(byte)*input,C1_SPACE);
				}
				if (uVar1 == 0) {
					input = (char *)((byte *)input + 1);
				}
				else {
					*input = 0;
					do {
						input = (char *)((byte *)input + 1);
										// int std::isspace(int c)
						if (std::globals::_pcharwidth < 2) {
										// C1_SPACE (0x8)
							uVar1 = *(byte *)(std::globals::_pctype + (byte)*input) & C1_SPACE;
						}
						else {
										// C1_SPACE (0x8)
							uVar1 = std::_isctype((uint)(byte)*input,C1_SPACE);
						}
					} while (uVar1 != 0);
					*ppbVar3 = (byte *)input;
					iVar2 = iVar2 + 1;
					ppbVar3 = ppbVar3 + 1;
				}
			} while (*input != 0);
		}
		return iVar2;
	}
	return 0;
}



// OFFICIAL: Util_StrCpy
// C RUNTIME: ::_strdup

char * __cdecl std::_strdup(char *strSource)
{
	char cVar1;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	uVar3 = 0xffffffff;
	pcVar6 = strSource;
	do {
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		cVar1 = *pcVar6;
		pcVar6 = pcVar6 + 1;
	} while (cVar1 != '\0');
	puVar2 = (undefined4 *)malloc(~uVar3);
	uVar3 = 0xffffffff;
	do {
		pcVar6 = strSource;
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		pcVar6 = strSource + 1;
		cVar1 = *strSource;
		strSource = pcVar6;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	puVar5 = (undefined4 *)(pcVar6 + -uVar3);
	puVar7 = puVar2;
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
		*puVar7 = *puVar5;
		puVar5 = puVar5 + 1;
		puVar7 = puVar7 + 1;
	}
	for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
		*(undefined *)puVar7 = *(undefined *)puVar5;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
		puVar7 = (undefined4 *)((int)puVar7 + 1);
	}
	return (char *)puVar2;
}



char * __cdecl lego::util::Util_RemoveUnderscores(char *text,...)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	char *pcVar4;
	char fmtBuffer [256];
	char replBuffer [256];
	
	std::vsprintf(fmtBuffer,text,&stack0x00000008);
	pcVar3 = fmtBuffer;
	pcVar4 = replBuffer;
	while (fmtBuffer[0] != '\0') {
		cVar2 = *pcVar3;
		if ((cVar2 == '\\') && (pcVar3[1] == 'n')) {
			*pcVar4 = '\n';
			pcVar3 = pcVar3 + 1;
		}
		else {
			if (cVar2 == '_') {
				*pcVar4 = ' ';
			}
			else {
				*pcVar4 = cVar2;
			}
		}
		pcVar1 = pcVar3 + 1;
		pcVar4 = pcVar4 + 1;
		pcVar3 = pcVar3 + 1;
		fmtBuffer[0] = *pcVar1;
	}
	*pcVar4 = '\0';
	pcVar4 = std::_strdup(replBuffer);
	return pcVar4;
}



char * __cdecl lego::util::Util_StrIStr(char *str,char *strSearch)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	char *pcVar5;
	uint uVar6;
	
	uVar3 = 0xffffffff;
	pcVar5 = str;
	do {
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	uVar4 = 0xffffffff;
	pcVar5 = strSearch;
	do {
		if (uVar4 == 0) break;
		uVar4 = uVar4 - 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	if (((uVar3 != 1) && (~uVar4 - 1 != 0)) && (uVar6 = 0, uVar3 != 1)) {
		do {
			iVar2 = std::_strnicmp(str,strSearch,~uVar4 - 1);
			if (iVar2 == 0) {
				return str;
			}
			uVar6 = uVar6 + 1;
			str = str + 1;
		} while (uVar6 < uVar3 - 1);
		return (char *)0x0;
	}
	return (char *)0x0;
}



// https://github.com/microsoft/Windows-classic-samples/blob/master/Samples/Win7Samples/begin/sdkdiff/utils.cpp
// 
// hash_string()

uint __cdecl lego::util::Util_HashString(char *str,BOOL bIgnoreBlanks,BOOL upperCase)
{
	byte bVar1;
	uint uVar2;
	int iVar3;
	int iVar4;
	uint uVar5;
	byte *pbVar6;
	int iVar7;
	
	uVar5 = 0;
	iVar7 = 0x600937;
	iVar4 = 1;
	bVar1 = *str;
	pbVar6 = (byte *)str;
	while (bVar1 != 0) {
		if (bIgnoreBlanks != 0) {
			while( true ) {
										// int std::isspace(int c)
				if (std::globals::_pcharwidth < 2) {
										// C1_SPACE (0x8)
					uVar2 = *(byte *)(std::globals::_pctype + *pbVar6) & C1_SPACE;
				}
				else {
										// C1_SPACE (0x8)
					uVar2 = std::_isctype((uint)*pbVar6,C1_SPACE);
				}
				if (uVar2 == 0) break;
				pbVar6 = pbVar6 + 1;
			}
		}
		bVar1 = *pbVar6;
		pbVar6 = pbVar6 + 1;
		str = (char *)(uint)bVar1;
		if (upperCase != 0) {
			uVar2 = std::toupper((int)str);
			str = (char *)(uVar2 & 0xff);
		}
		iVar3 = iVar4 * iVar7;
		iVar7 = iVar7 * 0x600937;
		uVar5 = uVar5 + iVar3 * (int)str;
		iVar4 = iVar4 + 1;
		bVar1 = *pbVar6;
	}
	return uVar5;
}



BOOL3 __cdecl lego::util::Util_GetBoolFromString(char *str)
{
	int iVar1;
	
	iVar1 = std::_stricmp(str,"YES");
	if (iVar1 == 0) {
		return BOOL3_TRUE;
	}
	iVar1 = std::_stricmp(str,"TRUE");
	if (iVar1 == 0) {
		return BOOL3_TRUE;
	}
	iVar1 = std::_stricmp(str,"ON");
	if (iVar1 == 0) {
		return BOOL3_TRUE;
	}
	iVar1 = std::_stricmp(str,"NO");
	if (iVar1 == 0) {
		return BOOL3_FALSE;
	}
	iVar1 = std::_stricmp(str,"FALSE");
	if (iVar1 == 0) {
		return BOOL3_FALSE;
	}
	iVar1 = std::_stricmp(str,"OFF");
	return -(uint)(iVar1 != 0) & BOOL3_ERROR;
}



int lego::WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nShowCmd)
{
	char cVar1;
	DWORD DVar2;
	LPSTR pCVar3;
	char *pcVar4;
	BOOL BVar5;
	CmdlineFlags CVar6;
	DWORD DVar7;
	uint uVar8;
	uint uVar9;
	int iVar10;
	undefined4 *puVar11;
	char *pcVar12;
	undefined4 *puVar13;
	float fpsSync;
	BOOL insistOnCD;
	BOOL nosound;
	uint local_c88;
	undefined4 uStack3204;
	char mutexName [128];
	char fullCmdLine [1024];
	char errorMessage [1024];
	char standardParameters [1024];
	
	nosound = 0;
	insistOnCD = 0;
	std::sprintf(mutexName,"%s Mutex","Lego Rock Raiders");
	CreateMutexA((LPSECURITY_ATTRIBUTES)0x0,TRUE,mutexName);
	DVar2 = GetLastError();
	if (DVar2 != ERROR_ALREADY_EXISTS) {
		pCVar3 = GetCommandLineA();
		cVar1 = *pCVar3;
		pcVar4 = pCVar3;
		while (cVar1 != '\0') {
			if (cVar1 == '\\') {
				pcVar4 = pCVar3 + 1;
			}
			pcVar12 = pCVar3 + 1;
			pCVar3 = pCVar3 + 1;
			cVar1 = *pcVar12;
		}
		uVar8 = 0xffffffff;
		do {
			pcVar12 = pcVar4;
			if (uVar8 == 0) break;
			uVar8 = uVar8 - 1;
			pcVar12 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar12;
		} while (cVar1 != '\0');
		uVar8 = ~uVar8;
		puVar11 = (undefined4 *)(pcVar12 + -uVar8);
		puVar13 = (undefined4 *)globs::mainGlobs.programName;
		for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
			*puVar13 = *puVar11;
			puVar11 = puVar11 + 1;
			puVar13 = puVar13 + 1;
		}
		pcVar4 = globs::mainGlobs.programName;
		for (uVar8 = uVar8 & 3; cVar1 = globs::mainGlobs.programName[0], uVar8 != 0; uVar8 = uVar8 - 1)
		{
			*(undefined *)puVar13 = *(undefined *)puVar11;
			puVar11 = (undefined4 *)((int)puVar11 + 1);
			puVar13 = (undefined4 *)((int)puVar13 + 1);
		}
		while (cVar1 != '\0') {
			if (*pcVar4 == '\"') {
				*pcVar4 = '\0';
			}
			pcVar12 = pcVar4 + 1;
			pcVar4 = pcVar4 + 1;
			cVar1 = *pcVar12;
		}
		iVar10 = 0x506814;
		pcVar4 = globs::mainGlobs.programName;
		cVar1 = globs::mainGlobs.programName[0];
		while (cVar1 != '\0') {
			if (cVar1 == '.') {
				pcVar4 = (char *)(iVar10 + 1);
			}
			pcVar12 = (char *)(iVar10 + 1);
			iVar10 = iVar10 + 1;
			cVar1 = *pcVar12;
		}
		if (pcVar4 != globs::mainGlobs.programName) {
										// to upper
			std::_strupr(pcVar4);
			pcVar4 = std::strstr(globs::mainGlobs.programName,".EXE");
			if (pcVar4 != (char *)0x0) {
				*pcVar4 = '\0';
			}
		}
		globs::mainGlobs.className = globs::mainGlobs.programName;
		globs::mainGlobs.active = 0;
		globs::mainGlobs.exit = 0;
		globs::mainGlobs.stateSet = 0;
		globs::mainGlobs.hInst = hInstance;
		globs::mainGlobs.fixedFrameTiming = 0.0;
		globs::mainGlobs.flags = CMD_NONE;
		BVar5 = registry::Registry_GetValue
											("SOFTWARE\\LEGO Media\\Games\\Rock Raiders","StandardParameters",
											 REGISTRY_STRING_VALUE,standardParameters,0x400);
		if (BVar5 == 0) {
			std::sprintf(fullCmdLine,"%s",lpCmdLine);
		}
		else {
			std::sprintf(fullCmdLine,"%s %s",lpCmdLine,standardParameters);
		}
		main::Main_ParseCommandLine(fullCmdLine,&nosound,&insistOnCD);
		BVar5 = registry::Registry_GetValue
											("SOFTWARE\\LEGO Media\\Games\\Rock Raiders","NoHALMessage",
											 REGISTRY_STRING_VALUE,errorMessage,0x400);
		if (BVar5 == 0) {
			std::sprintf(errorMessage,"No DirectX 3D accelerator could be found.");
		}
		debug::Error_Initialise();
		file::Mem_Initialise();
		file::File_Initialise
							(globs::mainGlobs.programName,insistOnCD,"SOFTWARE\\LEGO Media\\Games\\Rock Raiders");
		cfg::Config_Initialise();
		input::Input_InitKeysAndDI();
		BVar5 = main::Main_InitApp(hInstance);
		if (BVar5 != 0) {
			ddraw::DirectDraw_Initialise(globs::mainGlobs.hWnd);
			BVar5 = snd::Sound_Initialise(nosound);
			if ((BVar5 != 0) &&
				 (BVar5 = setup::Init_Initialise
														(TRUE,globs::mainGlobs.flags & CMD_DEBUG,
														 globs::mainGlobs.flags & CMD_BEST,globs::mainGlobs.flags & CMD_WINDOW,
														 errorMessage), BVar5 != 0)) {
				video::Animation_Initialise(globs::directDrawGlobs.lpDirectDraw);
				draw::Draw_Initialise((Rect2F *)0x0);
				main::LRR_Go(globs::mainGlobs.programName);
				if (globs::mainGlobs.stateSet != 0) {
					if ((globs::mainGlobs.currState.Initialise != (GameInitFunction *)0x0) &&
						 (BVar5 = (*globs::mainGlobs.currState.Initialise)(), BVar5 == 0)) {
						globs::mainGlobs.currState.Initialise = (GameInitFunction *)0x0;
						globs::mainGlobs.currState.MainLoop = (GameUpdateFunction *)0x0;
						globs::mainGlobs.currState.Shutdown = (GameCleanupFunction *)0x0;
					}
					if (globs::mainGlobs.currState.MainLoop != (GameUpdateFunction *)0x0) {
						fpsSync = 1.0;
						DVar2 = timeGetTime();
						while (globs::mainGlobs.exit == 0) {
							globs::INPUT.lClicked = 0;
							globs::INPUT.rClicked = 0;
							globs::INPUT.lDoubleClicked = 0;
							globs::INPUT.rDoubleClicked = 0;
							main::Main_HandleIO();
							if ((globs::mainGlobs.flags & CMD_FULLSCREEN) != CMD_NONE) {
								globs::mainGlobs.active = TRUE;
							}
							input::Input_ReadKeys();
							input::Input_ReadMouse2();
							BVar5 = (*globs::mainGlobs.currState.MainLoop)(fpsSync);
							if (BVar5 == 0) {
								globs::mainGlobs.exit = TRUE;
							}
							main::Main_Finalise3D();
							ddraw::DirectDraw_Flip();
							CVar6 = globs::mainGlobs.flags & ~CMD_D3DRMUPDATED;
							if ((globs::mainGlobs.flags & CMD_FPSLOCK30) == CMD_NONE) {
								if ((globs::mainGlobs.flags & CMD_NOFPSLOCK) == CMD_NONE) {
									if (globs::mainGlobs.fixedFrameTiming != 0.0) {
										fpsSync = globs::mainGlobs.fixedFrameTiming;
										goto LAB_00477e2a;
									}
									globs::mainGlobs.flags = CVar6;
									DVar7 = timeGetTime();
									uStack3204 = 0;
									local_c88 = DVar7 - DVar2;
									fpsSync = (float)(ulonglong)local_c88 * 0.025;
									DVar2 = DVar7;
									if ((ushort)((ushort)(fpsSync < 3.0) << 8 | (ushort)(fpsSync == 3.0) << 0xe) == 0)
									{
										fpsSync = 3.0;
									}
								}
								else {
									fpsSync = 0.0;
LAB_00477e2a:
									globs::mainGlobs.flags = CVar6;
									DVar2 = timeGetTime();
								}
							}
							else {
								fpsSync = 0.8333333;
								globs::mainGlobs.flags = CVar6;
							}
						}
					}
					if (globs::mainGlobs.currState.Shutdown != (GameCleanupFunction *)0x0) {
						(*globs::mainGlobs.currState.Shutdown)();
					}
				}
			}
			ddraw::DirectDraw_Shutdown();
			DestroyWindow(globs::mainGlobs.hWnd);
		}
		input::Input_ReleaseKeysAndDI();
		cfg::Config_Shutdown();
		util::logf_removed((char *)0x0);
		debug::Error_CloseLog();
		debug::Error_Shutdown();
	}
	return 0;
}



// Sets the "-nm" commandline option only if the "-ftm" option is not set.
//  (The "-ftm" option is intended to be set when running on Voodoo2-based graphics cards, as is
// shown by CLGen.exe)
// This is called when Lego.cfg/Lego*::Main::TextureUsage (units in pixels) is valid and <=
// available video memory.

void __cdecl lego::main::Main_DisableTextureManagement(void)
{
	if ((globs::mainGlobs.flags & CMD_FTM) == CMD_NONE) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_NM;
	}
	return;
}



void __cdecl
lego::main::Main_ParseCommandLine(char *lpszCmdLine,BOOL *out_nosound,BOOL *out_insistOnCD)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	int iVar5;
	
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-insistOnCD");
	if (pcVar3 != (char *)0x0) {
		*out_insistOnCD = 1;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-nosound");
	if (pcVar3 != (char *)0x0) {
		*out_nosound = 1;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-debug");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_DEBUG;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-nm");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_NM;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-ftm");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_FTM;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-fvf");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_FVF;
	}
										// "best fit" for screen mode selection
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-best");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_BEST;
	}
										// Only used when "-best" is specified
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-window");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_WINDOW;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-dualmouse");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_DUALMOUSE;
	}
										// Automatically triggers "-debug" command line option as well
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-debugcomplete");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_DEBUGCOMPLETE;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-testercall");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.programmerLevel = PROGRAMMER_MODE_2;
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_TESTERCALL;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-testlevels");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_TESTLEVELS;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-reducesamples");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_REDUCESAMPLES;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-showversion");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_SHOWVERSION;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-reduceanimation");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_REDUCEANIMATION;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-reducepromeshes");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_REDUCEPROMESHES;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-reduceflics");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_REDUCEFLICS;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-reduceimages");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_REDUCEIMAGES;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-startlevel");
	if (pcVar3 != (char *)0x0) {
		pcVar3 = pcVar3 + 0xb;
		iVar5 = 0;
		cVar2 = *pcVar3;
		while ((cVar2 != '\0' && (cVar2 == ' '))) {
			pcVar1 = pcVar3 + 1;
			pcVar3 = pcVar3 + 1;
			cVar2 = *pcVar1;
		}
		cVar2 = *pcVar3;
		while ((cVar2 != '\0' && (cVar2 != ' '))) {
			globs::mainGlobs.startLevel[iVar5] = cVar2;
			pcVar1 = pcVar3 + 1;
			iVar5 = iVar5 + 1;
			pcVar3 = pcVar3 + 1;
			cVar2 = *pcVar1;
		}
		globs::mainGlobs.startLevel[iVar5] = '\0';
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_STARTLEVEL;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-flags");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.clFlags = std::atoi(pcVar3 + 6);
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-fpslock");
	if ((pcVar3 != (char *)0x0) && (uVar4 = std::atoi(pcVar3 + 8), uVar4 != 0)) {
		globs::mainGlobs.fixedFrameTiming = 25.0 / (float)(ulonglong)uVar4;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-programmer");
	if (pcVar3 == (char *)0x0) {
		globs::mainGlobs.programmerLevel = PROGRAMMER_OFF;
	}
	else {
		globs::mainGlobs.programmerLevel = std::atoi(pcVar3 + 0xb);
		if (globs::mainGlobs.programmerLevel == PROGRAMMER_OFF) {
			globs::mainGlobs.programmerLevel = PROGRAMMER_MODE_1;
		}
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-cleansaves");
	if (pcVar3 != (char *)0x0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_CLEANSAVES;
	}
	return;
}



void __cdecl lego::main::Main_LoopUpdate(BOOL clear)
{
	Main_HandleIO();
	input::Input_ReadKeys();
	input::Input_ReadMouse2();
	Main_Finalise3D();
	ddraw::DirectDraw_Flip();
	if (clear != 0) {
		ddraw::DirectDraw_Clear((Rect2F *)0x0,0);
	}
	globs::mainGlobs.flags = globs::mainGlobs.flags & ~CMD_D3DRMUPDATED;
	return;
}



FeatureFlags __cdecl lego::main::Main_GetCLFlags(void)
{
	return globs::mainGlobs.clFlags;
}



int __cdecl lego::main::Main_GetWindowsBitDepth(void)
{
	HDC hdc;
	int iVar1;
	
	iVar1 = BITSPIXEL;
	hdc = GetDC(globs::mainGlobs.hWnd);
	iVar1 = GetDeviceCaps(hdc,iVar1);
	return iVar1;
}



void __cdecl lego::main::Main_Finalise3D(void)
{
	if ((globs::mainGlobs.flags & CMD_D3DRMUPDATED) == CMD_NONE) {
		(*(code *)(globs::mainGlobs.device)->lpVtbl->Update)(globs::mainGlobs.device);
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_D3DRMUPDATED;
	}
	return;
}



BOOL __cdecl lego::main::Main_SetState(GameFunctions *state)
{
	if (state != (GameFunctions *)0x0) {
		globs::mainGlobs.currState.Initialise = state->Initialise;
		globs::mainGlobs.currState.MainLoop = state->MainLoop;
		globs::mainGlobs.currState.Shutdown = state->Shutdown;
		globs::mainGlobs.stateSet = TRUE;
		return TRUE;
	}
	return 0;
}



uint __cdecl lego::main::Main_GetTime(void)
{
	DWORD DVar1;
	
										// WARNING: Could not recover jumptable at 0x004782c0. Too many branches
										// WARNING: Treating indirect jump as call
	DVar1 = timeGetTime();
	return DVar1;
}



BOOL __cdecl lego::main::Main_DispatchMessage(MSG *msg)
{
	UINT UVar1;
	
	if ((((byte)globs::mainGlobs.flags & CMD_FULLSCREEN) != 0) &&
		 (((UVar1 = msg->message, UVar1 == WM_ACTIVATEAPP || (UVar1 == WM_SYSKEYDOWN)) ||
			(UVar1 == WM_SYSKEYUP)))) {
		return 0;
	}
	return 1;
}



void __cdecl lego::main::Main_HandleIO(void)
{
	int iVar1;
	BOOL BVar2;
	MSG msg;
	
	iVar1 = PeekMessageA((LPMSG)&msg,(HWND)0x0,0,0,1);
	while (iVar1 != 0) {
		BVar2 = Main_DispatchMessage(&msg);
		if (BVar2 != 0) {
			TranslateMessage(&msg);
			DispatchMessageA(&msg);
		}
		iVar1 = PeekMessageA((LPMSG)&msg,(HWND)0x0,0,0,1);
	}
	return;
}



void __cdecl
lego::main::Main_SetupDisplay(BOOL fullScreen,uint xPos,uint yPos,uint width,uint height)
{
	HWND hWnd;
	RECT rect;
	
	globs::mainGlobs.appWidth = width;
	globs::mainGlobs.appHeight = height;
	if (fullScreen != 0) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_FULLSCREEN;
	}
	debug::Error_FullScreen(fullScreen);
	if (fullScreen == 0) {
		rect.left = xPos;
		rect.right = width + xPos;
		rect.bottom = height + yPos;
										// WS_POPUPWINDOW | WS_CAPTION (0x80880000 | 0xc00000)
										// WS_POPUP | WS_BORDER | WS_DLGFRAME | WS_SYSMENU (0x80000000 | 0x800000 |
										// 0x400000 | 0x80000)
		globs::mainGlobs.style = 0x80c80000;
		rect.top = yPos;
		Main_AdjustWindowRect((LPRECT)&rect);
		SetWindowLongA(globs::mainGlobs.hWnd,-0x10,globs::mainGlobs.style);
										// HWND_TOP (0x0) and SWP_NOZORDER (0x4)
										// Then hide system cursor since game draws its own
		SetWindowPos(globs::mainGlobs.hWnd,(HWND)0x0,rect.left,rect.top,rect.right - rect.left,
								 rect.bottom - rect.top,SWP_NOZORDER);
		ShowCursor(0);
	}
	else {
		hWnd = GetDesktopWindow();
		GetWindowRect(hWnd,(LPRECT)&rect);
										// HWND_TOP (0x0) and SWP_NOZORDER (0x4)
										// Then hide system cursor since game draws its own
		SetWindowPos(globs::mainGlobs.hWnd,(HWND)HWND_TOP,rect.left,rect.top,rect.right - rect.left,
								 rect.bottom - rect.top,SWP_NOZORDER);
		SetCursor((HCURSOR)0x0);
	}
	ShowWindow(globs::mainGlobs.hWnd,SW_SHOW);
	SetActiveWindow(globs::mainGlobs.hWnd);
	return;
}



BOOL __cdecl
lego::main::Main_SetupDirect3D
					(DeviceMode *dev,IDirectDraw *ddraw1,IDirectDrawSurface4 *backSurf,BOOL doubleBuffered)
{
	HRESULT HVar1;
	DeviceMode *err;
	DeviceMode *pDVar2;
	code ***ppvObj;
	DeviceMode **ppDVar3;
	IUnknown *local_8;
	code **local_4;
	
	pDVar2 = (DeviceMode *)0x0;
	if ((dev != (DeviceMode *)0x0) &&
		 (pDVar2 = dev, (dev->flags & DEVICEMODE_VIDEOTEXTURE) != DEVICEMODE_NONE)) {
		globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_TEXTUREVIDEOMEMORY;
	}
										// Direct3DRMFrame3::SetSceneFogMethod
										// D3DRMFOGMETHOD_VERTEX = 0x1
										// D3DRMFOGMETHOD_TABLE  = 0x2
										// D3DRMFOGMETHOD_ANY    = 0x4
	if (((globs::mainGlobs.flags & CMD_FVF) != CMD_NONE) ||
		 (globs::mainGlobs.fogMethod = D3DRMFOGMETHOD_TABLE,
		 (dev->flags & DEVICEMODE_HARDWARE) == DEVICEMODE_NONE)) {
		globs::mainGlobs.fogMethod = D3DRMFOGMETHOD_VERTEX;
	}
	HVar1 = Direct3DRMCreate(&local_8);
	err = dev;
	if ((HVar1 == 0) &&
		 (HVar1 = (*local_8->lpVtbl->QueryInterface)
												(local_8,(IID *)&idl::IID_IDirect3DRM3,(void **)0x506914), err = dev,
		 HVar1 == 0)) {
		ppvObj = &local_4;
		(*backSurf->lpVtbl->QueryInterface)
							((IUnknown *)backSurf,(IID *)&idl::IID_IDirectDrawSurface,ppvObj);
		err = (DeviceMode *)
					(*(code *)(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateDeviceFromSurface)
										(globs::mainGlobs.lpD3DRM,pDVar2,local_4,ppvObj,0,0x506918);
		if (err == (DeviceMode *)0x0) {
			ppDVar3 = &dev;
			(*(code *)(globs::mainGlobs.device)->lpVtbl->GetDirect3DDevice2)(globs::mainGlobs.device);
			(**(code **)*local_4)(local_4,&idl::IID_IDirect3DDevice3,0x50691c);
			(**(code **)((*ppDVar3)->guid).Data4)(ppDVar3);
			if (local_8 != (IUnknown *)0x0) {
				(*(code *)(globs::mainGlobs.device)->lpVtbl->SetBufferCount)(globs::mainGlobs.device,2);
			}
			return TRUE;
		}
		debug::Error_SetDXError
							((HRESULT)err,3,"C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Main.c",568);
	}
	if (err != (DeviceMode *)0x0) {
		debug::Error_SetDXError
							((HRESULT)err,1,"C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Main.c",576);
	}
	return 0;
}



void __cdecl lego::main::Main_AdjustWindowRect(LPRECT lpRect)
{
										// Adjust rectangle to client coordinates only in windowed mode
	if (((byte)globs::mainGlobs.flags & CMD_FULLSCREEN) == 0) {
		AdjustWindowRect(lpRect,globs::mainGlobs.style,0);
	}
	return;
}



void __cdecl
lego::main::Main_Setup3D
					(GraphicsQuality renderQuality,BOOL dither,BOOL linearFilter,BOOL mipMap,BOOL mipMapLinear
					,BOOL blendTransparency,BOOL sortTransparency)
{
	char cVar1;
	DWORD quality;
	
										// D3DRMRENDER_WIREFRAME 0x40
										// (D3DRMSHADE_FLAT|D3DRMLIGHT_OFF|D3DRMFILL_WIREFRAME)
	quality = 0x40;
	if (renderQuality == QUALITY_FLAT) {
										// D3DRMRENDER_FLAT 0x88 (D3DRMSHADE_FLAT|D3DRMLIGHT_ON|D3DRMFILL_SOLID)
		quality = 0x88;
	}
	if (renderQuality == QUALITY_UNLITFLAT) {
										// D3DRMRENDER_UNLITFLAT 0x80 (D3DRMSHADE_FLAT|D3DRMLIGHT_OFF|D3DRMFILL_SOLID)
		quality = 0x80;
	}
	if (renderQuality == QUALITY_GOURAUD) {
										// D3DRMRENDER_GOURAUD 0x89 (D3DRMSHADE_GOURAUD|D3DRMLIGHT_ON|D3DRMFILL_SOLID)
		quality = 0x89;
	}
	if (linearFilter == 0) {
										// D3DRMTEXTURE_NEAREST 0
		cVar1 = '\0';
	}
	else {
		if (mipMap == 0) {
										// D3DRMTEXTURE_LINEAR 1
			cVar1 = '\x01';
		}
		else {
										// D3DRMTEXTURE_MIPLINEAR 3 (!linearmipmap), D3DRMTEXTURE_LINEARMIPLINEAR 5
			cVar1 = (-(mipMapLinear != 0) & 2U) + 3;
			globs::mainGlobs.flags = globs::mainGlobs.flags | CMD_MIPMAP;
		}
	}
	if (globs::mainGlobs.device != (IDirect3DRMDevice3 *)0x0) {
										// IDirect3DRMDevice3::SetDither(THIS_ BOOL)
		(*(globs::mainGlobs.device)->lpVtbl->SetDither)(globs::mainGlobs.device,dither);
										// IDirect3DRMDevice3::SetQuality(THIS_ D3DRMRENDERQUALITY)
		(*(globs::mainGlobs.device)->lpVtbl->SetQuality)(globs::mainGlobs.device,quality);
										// IDirect3DRMDevice3::SetTextureQuality(THIS_ D3DRMTEXTUREQUALITY)
		(*(globs::mainGlobs.device)->lpVtbl->SetTextureQuality)(globs::mainGlobs.device,(DWORD)cVar1);
	}
	return;
}



void __cdecl lego::main::Main_SetTitle(char *title)
{
	SetWindowTextA(globs::mainGlobs.hWnd,title);
	return;
}



BOOL __cdecl lego::main::Main_InitApp(HINSTANCE hInstance)
{
	ATOM AVar1;
	WNDCLASSA wndClass;
	
	wndClass.style = CS_DBLCLKS;
	wndClass.lpfnWndProc = Main_WndProc;
	wndClass.cbClsExtra = 0;
	wndClass.cbWndExtra = 0;
	wndClass.hInstance = hInstance;
	wndClass.hIcon = (HICON)0x0;
	wndClass.hCursor = (HCURSOR)0x0;
	wndClass.hbrBackground = (HBRUSH)0x0;
	wndClass.lpszMenuName = (LPCSTR)0x0;
	wndClass.lpszClassName = globs::mainGlobs.className;
	AVar1 = RegisterClassA(&wndClass);
	if (AVar1 == 0) {
		MessageBoxA((HWND)0x0,"Unable to register window class","Fatal Error",0);
		return 0;
	}
										// WS_POPUP | WS_SYSMENU
	globs::mainGlobs.hWnd =
			 CreateWindowExA(WS_EX_APPWINDOW,globs::mainGlobs.className,____EMPTYSTR__,0x80080000,0,0,100,
											 100,(HWND)0x0,(HMENU)0x0,hInstance,(LPVOID)0x0);
	if (globs::mainGlobs.hWnd != (HWND)0x0) {
		SetFocus(globs::mainGlobs.hWnd);
		return TRUE;
	}
	MessageBoxA((HWND)0x0,"Unable to Create Main Window","Fatal Error",0);
	return 0;
}



LRESULT __cdecl
lego::main::Main_WndProc_Fullscreen(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	LRESULT LVar1;
	
	if (message < 0x11) {
		if (message != 0x10) {
			switch(message) {
			default:
				goto switchD_00478830_caseD_207;
			case 2:
				break;
			case 3:
			case 5:
			case 6:
switchD_00478830_caseD_200:
				return 0;
			}
		}
	}
	else {
		if (WM_ACTIVATEAPP < message) {
			if (message < WM_NCACTIVATE + 1) {
				if (message == WM_NCACTIVATE) {
					return 0;
				}
				if (message == WM_WINDOWPOSCHANGING) {
					*(uint *)(lParam + 0x18) = *(uint *)(lParam + 0x18) & 0xfffffdff;
					return 0;
				}
			}
			else {
				switch(message) {
				case 0x200:
				case 0x211:
				case 0x212:
					goto switchD_00478830_caseD_200;
				case 0x201:
				case 0x202:
				case 0x204:
				case 0x205:
					if ((globs::mainGlobs.flags & CMD_DUALMOUSE) == CMD_NONE) {
						switch(message) {
						case 0x201:
						case 0x204:
							if (globs::INPUT.mslb == 0) {
								globs::INPUT.lClicked = 1;
								globs::INPUT.rClicked = 1;
							}
							globs::INPUT.mslb = 1;
							globs::INPUT.msrb = 1;
							globs::INPUT.lDoubleClicked = 1;
							return 0;
						case 0x202:
						case 0x205:
							globs::INPUT.lClicked = 0;
							globs::INPUT.rClicked = 0;
							globs::INPUT.msrb = 0;
							globs::INPUT.mslb = 0;
						}
					}
					else {
						switch(message) {
						case 0x201:
							globs::INPUT.mslb = 1;
							globs::INPUT.lClicked = 1;
							return 0;
						case 0x202:
							globs::INPUT.mslb = 0;
							globs::INPUT.lClicked = 0;
							return 0;
						case 0x204:
							globs::INPUT.msrb = 1;
							globs::INPUT.rClicked = 1;
							return 0;
						case 0x205:
							globs::INPUT.msrb = 0;
							globs::INPUT.rClicked = 0;
							return 0;
						}
					}
				case 0x203:
					globs::INPUT.lDoubleClicked = 1;
					return 0;
				case 0x206:
					globs::INPUT.rDoubleClicked = 1;
					return 0;
				case 0x207:
				case 0x208:
				case 0x209:
				case 0x20a:
				case 0x20b:
				case 0x20c:
				case 0x20d:
				case 0x20e:
				case 0x20f:
				case 0x210:
					break;
				default:
					if (message == WM_SYSKEYDOWN) {
						return 0;
					}
					if ((0xff < message) && (message < 0x102)) {
						return 0;
					}
				}
			}
			goto switchD_00478830_caseD_207;
		}
		if (message == WM_ACTIVATEAPP) {
										// True if this window is being activated
			globs::mainGlobs.active = wParam;
			return 0;
		}
		if (message != WM_QUIT) goto switchD_00478830_caseD_207;
	}
	globs::mainGlobs.exit = 1;
switchD_00478830_caseD_207:
	LVar1 = DefWindowProcA(hWnd,message,wParam,lParam);
	return LVar1;
}



LRESULT __cdecl
lego::main::Main_WndProc_Windowed(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	int iVar1;
	LRESULT LVar2;
	UINT UVar3;
	
	if (message < WM_ACTIVATE + 1) {
		UVar3 = message;
		if (message == WM_ACTIVATE) {
			return 0;
		}
	}
	else {
		if (WM_ACTIVATEAPP < message) {
										// Handle mouse button input (0x201 is WM_LBUTTONDOWN)
			iVar1 = message - 0x201;
			switch(iVar1) {
			case 0:
			case 1:
			case 3:
			case 4:
										// WM_LBUTTONDOWN (0x201) or WM_LBUTTONUP (0x202) or  WM_RBUTTONDOWN (0x204) or
										// WM_RBUTTONUP (0x205)
				if ((globs::mainGlobs.flags & CMD_DUALMOUSE) == CMD_NONE) {
					switch(iVar1) {
					case 0:
					case 3:
										// WM_LBUTTONDOWN (0x201) or WM_RBUTTONDOWN (0x204)
						SetCapture(hWnd);
						if (globs::INPUT.mslb == 0) {
							globs::INPUT.lClicked = 1;
							globs::INPUT.rClicked = 1;
						}
						globs::INPUT.mslb = 1;
						globs::INPUT.msrb = 1;
						globs::INPUT.lDoubleClicked = 1;
						return 0;
					case 1:
					case 4:
										// WM_LBUTTONUP (0x202) or WM_RBUTTONUP (0x205)
						ReleaseCapture();
						globs::INPUT.lClicked = 0;
						globs::INPUT.rClicked = 0;
						globs::INPUT.msrb = 0;
						globs::INPUT.mslb = 0;
					}
				}
				else {
					switch(iVar1) {
					case 0:
										// WM_LBUTTONDOWN (0x201)
						SetCapture(hWnd);
						globs::INPUT.mslb = 1;
						globs::INPUT.lClicked = 1;
						globs::INPUT.lDoubleClicked = 1;
						return 0;
					case 1:
										// WM_LBUTTONUP (0x202)
						ReleaseCapture();
						globs::INPUT.mslb = 0;
						globs::INPUT.lClicked = 0;
						globs::INPUT.lDoubleClicked = 1;
						return 0;
					case 3:
						globs::INPUT.msrb = 1;
						globs::INPUT.rClicked = 1;
						globs::INPUT.lDoubleClicked = 1;
						return 0;
					case 4:
										// WM_RBUTTONUP (0x205)
						globs::INPUT.msrb = 0;
						globs::INPUT.rClicked = 0;
						globs::INPUT.lDoubleClicked = 1;
						return 0;
					}
				}
			case 2:
										// WM_LBUTTONDBLCLK (0x203)
				globs::INPUT.lDoubleClicked = 1;
										// WM_RBUTTONDBLCLK (0x206)
				return 0;
			case 5:
				globs::INPUT.rDoubleClicked = 1;
				return 0;
			}
			goto switchD_004789e8_caseD_6;
		}
		if (message == WM_ACTIVATEAPP) {
										// True if this window is being activated
			globs::mainGlobs.active = wParam;
			return 0;
		}
										// WM_CLOSE (0x10)  -0x10, is closing
		UVar3 = message - 0x10;
		if (message - 0x10 == 0) {
			globs::mainGlobs.exit = 1;
			return 0;
		}
	}
										// WM_QUIT (0x12)
	if (UVar3 == WM_DESTROY) {
		globs::mainGlobs.exit = 1;
		return 0;
	}
switchD_004789e8_caseD_6:
	LVar2 = DefWindowProcA(hWnd,message,wParam,lParam);
	return LVar2;
}



LRESULT lego::main::Main_WndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	LRESULT LVar1;
	
	if (((byte)globs::mainGlobs.flags & CMD_FULLSCREEN) != 0) {
		LVar1 = Main_WndProc_Fullscreen(hWnd,message,wParam,lParam);
		return LVar1;
	}
	LVar1 = Main_WndProc_Windowed(hWnd,message,wParam,lParam);
	return LVar1;
}



void __cdecl
lego::main::Main_ChangeRenderState
					(D3DRenderStateType dwRenderStateType,D3DRenderStateType dwRenderState)
{
	D3DRenderStateType DVar1;
	
	DVar1 = dwRenderStateType;
										// IDirect3DDevice3->GetRenderState(this, D3DRenderStateType dwRenderStateType,
										// DWORD* lpdwRenderState)
	(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetRenderState)
						(globs::mainGlobs.imDevice,dwRenderStateType,&dwRenderStateType);
	if (dwRenderStateType != dwRenderState) {
										// IDirect3DDevice3->SetRenderState(this, D3DRenderStateType dwRenderStateType,
										// DWORD dwRenderState)
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetRenderState)
							(globs::mainGlobs.imDevice,DVar1,dwRenderState);
		if (globs::mainGlobs.renderStateData[DVar1].isUsed == 0) {
			globs::mainGlobs.renderStateData[DVar1].isUsed = 1;
			globs::mainGlobs.renderStateData[DVar1].value = dwRenderStateType;
		}
		else {
			if (globs::mainGlobs.renderStateData[DVar1].value == dwRenderStateType) {
				globs::mainGlobs.renderStateData[DVar1].isUsed = 0;
				return;
			}
		}
	}
	return;
}



void __cdecl lego::main::Main_RestoreStates(void)
{
	CmdlineFlags *pCVar1;
	D3DRenderStateType DVar2;
	
	DVar2 = 0;
	pCVar1 = (CmdlineFlags *)&globs::mainGlobs.renderStateData[0].isUsed;
	do {
		if (*pCVar1 != CMD_NONE) {
										// IDirect3DDevice3->SetRenderState(this, D3DRenderStateType dwRenderStateType,
										// DWORD dwRenderState)
			(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetRenderState)
								(globs::mainGlobs.imDevice,DVar2,pCVar1[-1]);
			*pCVar1 = CMD_NONE;
		}
		pCVar1 = pCVar1 + 2;
		DVar2 = DVar2 + D3DRENDERSTATE_TEXTUREHANDLE;
	} while (pCVar1 < &globs::mainGlobs.flags);
	return;
}



BOOL __cdecl lego::main::Main_SetCDVolume(float leftVolume,float rightVolume)
{
	BOOL BVar1;
	
	BVar1 = Main_CDVolume(&leftVolume,&rightVolume,1);
	return BVar1;
}



BOOL __cdecl lego::snd::lego::main::Main_GetCDVolume(float *out_leftVolume,float *out_rightVolume)
{
	BOOL BVar1;
	
	BVar1 = lego::main::Main_CDVolume(out_leftVolume,out_rightVolume,0);
	return BVar1;
}



BOOL __cdecl lego::main::Main_CDVolume(float *ref_leftVolume,float *ref_rightVolume,BOOL set)
{
	UINT UVar1;
	MMRESULT MVar2;
	LPMIXERCONTROLA buffer;
	uint *buffer_00;
	uint uVar3;
	int iVar4;
	uint *puVar5;
	uint uVar6;
	uint uVar7;
	_union_1085 *p_Var8;
	UINT_PTR uMxId;
	tagMIXERCAPSA *ptVar9;
	tagMIXERLINEA *ptVar10;
	tagMIXERLINECONTROLSA *ptVar11;
	tMIXERCONTROLDETAILS *ptVar12;
	float10 extraout_ST0;
	longlong lVar13;
	HMIXEROBJ local_154;
	BOOL local_150;
	uint local_14c;
	uint local_148;
	uint local_144;
	uint local_140;
	UINT local_13c;
	uint local_138;
	LPMIXERCONTROLA local_134;
	uint local_130;
	undefined4 uStack300;
	int local_128;
	undefined4 local_124;
	tMIXERCONTROLDETAILS local_120;
	int local_108;
	undefined4 local_104;
	uint local_100;
	undefined4 uStack252;
	uint local_f8;
	undefined4 uStack244;
	tagMIXERLINECONTROLSA local_f0;
	tagMIXERLINEA local_d8;
	tagMIXERCAPSA local_30;
	
	UVar1 = mixerGetNumDevs();
	local_150 = 0;
	if (set != 0) {
		if ((ushort)((ushort)(*ref_leftVolume < 1.0) << 8 | (ushort)(*ref_leftVolume == 1.0) << 0xe) ==
				0) {
			*ref_leftVolume = 1.0;
		}
		if (*ref_leftVolume < 0.0) {
			*ref_leftVolume = 0.0;
		}
		if ((ushort)((ushort)(*ref_rightVolume < 1.0) << 8 | (ushort)(*ref_rightVolume == 1.0) << 0xe)
				== 0) {
			*ref_rightVolume = 1.0;
		}
		if (*ref_rightVolume < 0.0) {
			*ref_rightVolume = 0.0;
		}
	}
	local_140 = 0;
	local_13c = UVar1;
	if (UVar1 != 0) {
		do {
			uMxId = local_140;
			MVar2 = mixerOpen((LPHMIXER)&local_154,local_140,0,0,0);
			if (MVar2 == 0) {
				ptVar9 = &local_30;
				for (iVar4 = 0xc; iVar4 != 0; iVar4 = iVar4 + -1) {
					*(undefined4 *)ptVar9 = 0;
					ptVar9 = (tagMIXERCAPSA *)&ptVar9->vDriverVersion;
				}
				mixerGetDevCapsA(uMxId,(LPMIXERCAPSA)&local_30,0x30);
				local_148 = 0;
				if (local_30.cDestinations != 0) {
					do {
						uVar3 = local_148;
						ptVar10 = &local_d8;
						for (iVar4 = 0x2a; iVar4 != 0; iVar4 = iVar4 + -1) {
							ptVar10->cbStruct = 0;
							ptVar10 = (tagMIXERLINEA *)&ptVar10->dwDestination;
						}
						local_d8.cbStruct = 0xa8;
						local_d8.dwDestination = local_148;
						MVar2 = mixerGetLineInfoA(local_154,(LPMIXERLINEA)&local_d8,0);
						if (MVar2 == 0) {
							local_138 = local_d8.cConnections;
							local_144 = 0;
							uMxId = local_140;
							if (local_d8.cConnections != 0) {
								do {
									uVar7 = local_144;
									local_d8.cbStruct = 0xa8;
									local_d8.dwDestination = uVar3;
									local_d8.dwSource = local_144;
									MVar2 = mixerGetLineInfoA(local_154,(LPMIXERLINEA)&local_d8,1);
									if ((MVar2 == 0) && (local_d8.dwComponentType == 0x1005)) {
										ptVar11 = &local_f0;
										for (iVar4 = 6; iVar4 != 0; iVar4 = iVar4 + -1) {
											ptVar11->cbStruct = 0;
											ptVar11 = (tagMIXERLINECONTROLSA *)&ptVar11->dwLineID;
										}
										local_f0.cbStruct = 0x18;
										local_f0.dwLineID = local_d8.dwLineID;
										local_f0.cControls = local_d8.cControls;
										local_f0.cbmxctrl = 0x94;
										buffer = (LPMIXERCONTROLA)std::malloc(local_d8.cControls * 0x94);
										local_134 = buffer;
										local_f0.pamxctrl = buffer;
										MVar2 = mixerGetLineControlsA(local_154,(LPMIXERLINECONTROLSA)&local_f0,0);
										if ((MVar2 == 0) && (local_14c = 0, local_d8.cControls != 0)) {
											p_Var8 = &buffer->Bounds;
											do {
												if (((*(uint *)&p_Var8[-4].field_0x4 & 0x50000000) != 0) &&
													 ((*(uint *)&p_Var8[-4].field_0x4 & 0x50030001) != 0)) {
													local_120.dwControlID = *(DWORD *)(p_Var8 + -4);
													ptVar12 = &local_120;
													for (iVar4 = 6; iVar4 != 0; iVar4 = iVar4 + -1) {
														ptVar12->cbStruct = 0;
														ptVar12 = (tMIXERCONTROLDETAILS *)&ptVar12->dwControlID;
													}
													local_120.cbStruct = 0x18;
													local_120.cChannels = local_d8.cChannels;
													local_120.cbDetails = 4;
													local_120.u = 0;
													buffer_00 = (uint *)std::malloc(local_d8.cChannels << 2);
													local_120.paDetails = buffer_00;
													if (set == 0) {
														MVar2 = mixerGetControlDetailsA
																							(local_154,(LPMIXERCONTROLDETAILS)&local_120,0);
														if (MVar2 == 0) {
															local_100 = *buffer_00 - *(int *)p_Var8;
															uStack252 = 0;
															local_108 = *(int *)&p_Var8->field_0x4 - *(int *)p_Var8;
															local_104 = 0;
															*ref_leftVolume = (float)(ulonglong)local_100 / (float)local_108;
															if (local_d8.cChannels == 2) {
																local_130 = buffer_00[1] - *(int *)p_Var8;
																uStack300 = 0;
																local_128 = *(int *)&p_Var8->field_0x4 - *(int *)p_Var8;
																local_124 = 0;
																local_150 = 1;
																*ref_rightVolume = (float)(ulonglong)local_130 / (float)local_128;
															}
															else {
																local_150 = 1;
																*ref_rightVolume = (float)(ulonglong)local_100 / (float)local_108;
															}
														}
													}
													else {
														iVar4 = *(int *)p_Var8;
														local_f8 = *(int *)&p_Var8->field_0x4 - iVar4;
														uStack244 = 0;
														lVar13 = __ftol((float10)*ref_leftVolume * (float10)(ulonglong)local_f8)
														;
														uVar7 = (int)lVar13 + iVar4;
														lVar13 = __ftol((float10)*ref_rightVolume * extraout_ST0);
														uVar3 = (int)lVar13 + iVar4;
														if (local_d8.cChannels == 2) {
															*buffer_00 = uVar7;
															buffer_00[1] = uVar3;
														}
														else {
															uVar6 = 0;
															if (local_d8.cChannels != 0) {
																puVar5 = buffer_00;
																do {
																	*puVar5 = uVar3 + uVar7 >> 1;
																	uVar6 = uVar6 + 1;
																	puVar5 = puVar5 + 1;
																} while (uVar6 < local_d8.cChannels);
															}
														}
														MVar2 = mixerSetControlDetails
																							(local_154,(LPMIXERCONTROLDETAILS)&local_120,0);
														if (MVar2 == 0) {
															local_150 = 1;
														}
													}
													std::free(buffer_00);
													buffer = local_134;
												}
												local_14c = local_14c + 1;
												p_Var8 = (_union_1085 *)&p_Var8[6].field_0x4;
												uVar3 = local_148;
												uVar7 = local_144;
											} while (local_14c < local_d8.cControls);
										}
										std::free(buffer);
									}
									local_144 = uVar7 + 1;
									uMxId = local_140;
								} while (local_144 < local_138);
							}
						}
						local_148 = uVar3 + 1;
					} while (local_148 < local_30.cDestinations);
				}
				mixerClose((HMIXER)local_154);
				UVar1 = local_13c;
			}
			local_140 = uMxId + 1;
		} while (local_140 < UVar1);
	}
	return local_150;
}



void __cdecl lego::cfg::Config_Initialise(void)
{
	int iVar1;
	CFGProperty **ppCVar2;
	
	ppCVar2 = globs::configGlobs.listSet;
	for (iVar1 = 0x20; iVar1 != 0; iVar1 = iVar1 + -1) {
		*ppCVar2 = (CFGProperty *)0x0;
		ppCVar2 = ppCVar2 + 1;
	}
	globs::configGlobs.freeList = (CFGProperty *)0x0;
	globs::configGlobs.listCount = 0;
	globs::configGlobs.flags = 1;
	return;
}



void __cdecl lego::cfg::Config_Shutdown(void)
{
	CFGProperty **ppCVar1;
	
	ppCVar1 = globs::configGlobs.listSet;
	do {
		if (*ppCVar1 != (CFGProperty *)0x0) {
			std::free(*ppCVar1);
		}
		ppCVar1 = ppCVar1 + 1;
	} while (ppCVar1 < &globs::configGlobs.freeList);
	globs::configGlobs.freeList = (CFGProperty *)0x0;
	globs::configGlobs.flags = 0;
	return;
}



CFGProperty * __cdecl lego::cfg::CFG_Open(char *filename)
{
	char cVar1;
	CFGProperty *current;
	uint uVar2;
	char *pcVar3;
	CFGProperty *root;
	char *text;
	char *pcVar4;
	char *pcVar5;
	bool isComment;
	char c;
	
	root = (CFGProperty *)0x0;
	isComment = false;
	text = (char *)lego::file::File_LoadBinary(filename,(uint *)&filename);
	if ((byte *)text != (byte *)0x0) {
		root = Config_Create((CFGProperty *)0x0);
		pcVar4 = (char *)0x0;
		root->fileData = text;
		if (filename != (char *)0x0) {
			do {
				c = *text;
				if (c == ';') {
					isComment = true;
				}
				else {
					if (c == '\n') {
						isComment = false;
					}
				}
				if ((((isComment) || (c == '\t')) || (c == '\n')) || ((c == '\r' || (c == ' ')))) {
					*text = 0;
				}
				text = (char *)((byte *)text + 1);
				pcVar4 = pcVar4 + 1;
			} while (pcVar4 < filename);
		}
		pcVar4 = root->fileData;
		pcVar5 = (char *)0x0;
		current = root;
		pcVar3 = filename;
		if (filename != (char *)0x0) {
			do {
				if (*pcVar4 == '\0') {
					pcVar4 = pcVar4 + 1;
				}
				else {
					if ((*pcVar4 == '}') && (pcVar4[1] == '\0')) {
						uVar2 = current->depth - 1;
LAB_004791e1:
						current->depth = uVar2;
					}
					else {
						if (current->key == (char *)0x0) {
							current->key = pcVar4;
						}
						else {
							current->value = pcVar4;
							current = Config_Create(current);
							if ((*pcVar4 == '{') && (pcVar4[1] == '\0')) {
								uVar2 = current->depth + 1;
								goto LAB_004791e1;
							}
						}
					}
					while ((pcVar3 = filename, pcVar5 < filename &&
								 (cVar1 = *pcVar4, pcVar4 = pcVar4 + 1, cVar1 != '\0'))) {
						pcVar5 = pcVar5 + 1;
					}
				}
				pcVar5 = pcVar5 + 1;
			} while (pcVar5 < pcVar3);
		}
	}
	return root;
}



// Variadic function to join a path used for all CFGProperty lookup functions
// NULL must be specified as the final argument, to signal the end of path arguments.
// The returned buffer is TEMPORARY, and must be used immediately before the next
// call to this function.

char * __cdecl lego::cfg::CFG_JoinPath(char *keyPath1,...)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	int iVar4;
	char **ppcVar5;
	undefined4 *puVar6;
	char *pcVar7;
	char *pcVar8;
	Config_Globs *pCVar9;
	Config_Globs *pCVar10;
	undefined4 *puVar11;
	char *in_stack_00000008;
	
	uVar2 = 0xffffffff;
	do {
		pcVar8 = keyPath1;
		if (uVar2 == 0) break;
		uVar2 = uVar2 - 1;
		pcVar8 = keyPath1 + 1;
		cVar1 = *keyPath1;
		keyPath1 = pcVar8;
	} while (cVar1 != '\0');
	uVar2 = ~uVar2;
	ppcVar5 = (char **)&stack0x0000000c;
	puVar6 = (undefined4 *)(pcVar8 + -uVar2);
	pCVar9 = &globs::configGlobs;
	for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
		*(undefined4 *)pCVar9->s_JoinPath_string = *puVar6;
		puVar6 = puVar6 + 1;
		pCVar9 = (Config_Globs *)(pCVar9->s_JoinPath_string + 4);
	}
	for (uVar2 = uVar2 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {
		pCVar9->s_JoinPath_string[0] = *(char *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		pCVar9 = (Config_Globs *)(pCVar9->s_JoinPath_string + 1);
	}
	if (in_stack_00000008 != (char *)0x0) {
		do {
			uVar2 = 0xffffffff;
			pcVar8 = "::";
			do {
				pcVar7 = pcVar8;
				if (uVar2 == 0) break;
				uVar2 = uVar2 - 1;
				pcVar7 = pcVar8 + 1;
				cVar1 = *pcVar8;
				pcVar8 = pcVar7;
			} while (cVar1 != '\0');
			uVar2 = ~uVar2;
			iVar4 = -1;
			pCVar9 = &globs::configGlobs;
			do {
				pCVar10 = pCVar9;
				if (iVar4 == 0) break;
				iVar4 = iVar4 + -1;
				pCVar10 = (Config_Globs *)(pCVar9->s_JoinPath_string + 1);
				pcVar8 = pCVar9->s_JoinPath_string;
				pCVar9 = pCVar10;
			} while (*pcVar8 != '\0');
			puVar6 = (undefined4 *)(pcVar7 + -uVar2);
			puVar11 = (undefined4 *)((int)&pCVar10[-1].flags + 3);
			for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
				*puVar11 = *puVar6;
				puVar6 = puVar6 + 1;
				puVar11 = puVar11 + 1;
			}
			for (uVar2 = uVar2 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {
				*(undefined *)puVar11 = *(undefined *)puVar6;
				puVar6 = (undefined4 *)((int)puVar6 + 1);
				puVar11 = (undefined4 *)((int)puVar11 + 1);
			}
			uVar2 = 0xffffffff;
			do {
				pcVar8 = in_stack_00000008;
				if (uVar2 == 0) break;
				uVar2 = uVar2 - 1;
				pcVar8 = in_stack_00000008 + 1;
				cVar1 = *in_stack_00000008;
				in_stack_00000008 = pcVar8;
			} while (cVar1 != '\0');
			uVar2 = ~uVar2;
			iVar4 = -1;
			pCVar9 = &globs::configGlobs;
			do {
				pCVar10 = pCVar9;
				if (iVar4 == 0) break;
				iVar4 = iVar4 + -1;
				pCVar10 = (Config_Globs *)(pCVar9->s_JoinPath_string + 1);
				pcVar7 = pCVar9->s_JoinPath_string;
				pCVar9 = pCVar10;
			} while (*pcVar7 != '\0');
			puVar6 = (undefined4 *)(pcVar8 + -uVar2);
			puVar11 = (undefined4 *)((int)&pCVar10[-1].flags + 3);
			for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
				*puVar11 = *puVar6;
				puVar6 = puVar6 + 1;
				puVar11 = puVar11 + 1;
			}
			in_stack_00000008 = *ppcVar5;
			for (uVar2 = uVar2 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {
				*(undefined *)puVar11 = *(undefined *)puVar6;
				puVar6 = (undefined4 *)((int)puVar6 + 1);
				puVar11 = (undefined4 *)((int)puVar11 + 1);
			}
			ppcVar5 = ppcVar5 + 1;
		} while (in_stack_00000008 != (char *)0x0);
	}
	return (char *)&globs::configGlobs;
}



CFGProperty * __cdecl lego::cfg::CFG_GetChildren(CFGProperty *prop,char *keyPath)
{
	CFGProperty *getProp;
	
	getProp = CFG_GetProperty(prop,keyPath);
	if ((getProp != (CFGProperty *)0x0) && (getProp->depth < getProp->linkNext->depth)) {
		return getProp->linkNext;
	}
	return (CFGProperty *)0x0;
}



// Returns the next CFGProperty in the same block, and at the same depth
// Returns NULL if there are no more properties, or if prop is NULL

CFGProperty * __cdecl lego::cfg::CFG_NextFlat(CFGProperty *prop)
{
	uint nextDepth;
	uint currentDepth;
	
	currentDepth = prop->depth;
	nextDepth = currentDepth;
	if (prop != (CFGProperty *)0x0) {
		do {
			if (nextDepth < currentDepth) {
				return (CFGProperty *)0x0;
			}
			prop = prop->linkNext;
			if (prop->depth == currentDepth) {
				return prop;
			}
			nextDepth = prop->depth;
		} while (prop != (CFGProperty *)0x0);
	}
	return (CFGProperty *)0x0;
}



char * __cdecl lego::cfg::CFG_CopyString(CFGProperty *prop,char *keyPath)
{
	char cVar1;
	CFGProperty *pCVar2;
	undefined4 *puVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	char *pcVar8;
	undefined4 *puVar9;
	
	pCVar2 = CFG_GetProperty(prop,keyPath);
	if ((pCVar2 == (CFGProperty *)0x0) || (pCVar2->value == (char *)0x0)) {
		return (char *)(undefined4 *)0x0;
	}
	uVar4 = 0xffffffff;
	pcVar7 = pCVar2->value;
	do {
		if (uVar4 == 0) break;
		uVar4 = uVar4 - 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar7 + 1;
	} while (cVar1 != '\0');
	puVar3 = (undefined4 *)std::malloc(~uVar4);
	uVar4 = 0xffffffff;
	pcVar7 = pCVar2->value;
	do {
		pcVar8 = pcVar7;
		if (uVar4 == 0) break;
		uVar4 = uVar4 - 1;
		pcVar8 = pcVar7 + 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar8;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar6 = (undefined4 *)(pcVar8 + -uVar4);
	puVar9 = puVar3;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
		*puVar9 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar9 = puVar9 + 1;
	}
	for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
		*(undefined *)puVar9 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar9 = (undefined4 *)((int)puVar9 + 1);
	}
	return (char *)puVar3;
}



char * __cdecl lego::cfg::CFG_ReadString(CFGProperty *prop,char *keyPath)
{
	CFGProperty *getProp;
	
	getProp = CFG_GetProperty(prop,keyPath);
	if (getProp != (CFGProperty *)0x0) {
		return getProp->value;
	}
	return (char *)0x0;
}



BOOL3 __cdecl lego::cfg::CFG_ReadBool(CFGProperty *prop,char *keyPath)
{
	char *str;
	BOOL3 BVar1;
	
	BVar1 = BOOL3_ERROR;
	str = CFG_CopyString(prop,keyPath);
	if (str != (char *)0x0) {
		BVar1 = util::Util_GetBoolFromString(str);
		std::free(str);
	}
	return BVar1;
}



// Reads a CFG float property specified in degrees, and returns the value in radians

float10 __cdecl lego::cfg::CFG_ReadRadians(CFGProperty *prop,char *keyPath)
{
	char *pcVar1;
	float10 fVar2;
	
	pcVar1 = CFG_ReadString(prop,keyPath);
	if (pcVar1 == (char *)0x0) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = CFG_ReadString(prop,keyPath);
	}
	fVar2 = std::atof(pcVar1);
	if (fVar2 != (float10)0.0) {
										// value / 360.0 * (M_PI * 2.0)
		return fVar2 * (float10)0.002777778 * (float10)6.283185;
	}
	return (float10)0.0;
}



BOOL __cdecl
lego::cfg::CFG_ReadRGBF(CFGProperty *prop,char *keyPath,float *out_r,float *out_g,float *out_b)
{
	char *input;
	int numParts;
	int channel;
	uint result;
	char *parts_0;
	char *parts_1;
	char *parts_2;
	
	result = 0;
	input = CFG_CopyString(prop,keyPath);
	if (input != (char *)0x0) {
		numParts = util::Util_Tokenise(input,&parts_0,":");
		if (numParts == 3) {
			channel = std::atoi(parts_0);
										// channel / 255.0
			*out_r = (float)channel * 0.003921569;
			channel = std::atoi(parts_1);
			*out_g = (float)channel * 0.003921569;
			channel = std::atoi(parts_2);
			*out_b = (float)channel * 0.003921569;
		}
		result = (uint)(numParts == 3);
		std::free(input);
	}
	return result;
}



void __cdecl lego::cfg::CFG_Close(CFGProperty *root)
{
	CFGProperty *prop;
	
	std::free(root->fileData);
	if (root != (CFGProperty *)0x0) {
		do {
			prop = root->linkNext;
			Config_Remove(root);
			root = prop;
		} while (prop != (CFGProperty *)0x0);
	}
	return;
}



CFGProperty * __cdecl lego::cfg::Config_Create(CFGProperty *prev)
{
	uint uVar1;
	CFGProperty *pCVar2;
	CFGProperty *pCVar3;
	CFGProperty *next;
	
	if (globs::configGlobs.freeList == (CFGProperty *)0x0) {
		Config_AddList();
	}
	pCVar2 = globs::configGlobs.freeList;
	next = globs::configGlobs.freeList;
	pCVar3 = (globs::configGlobs.freeList)->nextFree;
	(globs::configGlobs.freeList)->nextFree = globs::configGlobs.freeList;
	globs::configGlobs.freeList = pCVar3;
	pCVar2->key = (char *)0x0;
	pCVar2->value = (char *)0x0;
	pCVar2->linkNext = (CFGProperty *)0x0;
	if (prev != (CFGProperty *)0x0) {
		prev->linkNext = pCVar2;
		pCVar2->linkPrev = prev;
		uVar1 = prev->depth;
		pCVar2->fileData = (char *)0x0;
		pCVar2->depth = uVar1;
		return next;
	}
	pCVar2->depth = 0;
	pCVar2->linkPrev = (CFGProperty *)0x0;
	return next;
}



void __cdecl lego::cfg::Config_Remove(CFGProperty *prop)
{
	prop->nextFree = globs::configGlobs.freeList;
	globs::configGlobs.freeList = prop;
	return;
}



CFGProperty * __cdecl lego::cfg::CFG_GetProperty(CFGProperty *prop,char *keyPath)
{
	char *pcVar1;
	int numParts;
	int tmpCmp;
	uint uVar2;
	char *pcVar3;
	uint uVar4;
	undefined4 *puVar5;
	size_t sVar6;
	char *pcVar7;
	undefined4 *puVar8;
	bool isWildcard;
	CFGProperty *result;
	char *input_parts [101];
	char c;
	uint depth;
	CFGProperty *previous;
	
	depth = 0xffffffff;
	pcVar7 = keyPath;
	do {
		if (depth == 0) break;
		depth = depth - 1;
		c = *pcVar7;
		pcVar7 = pcVar7 + 1;
	} while (c != '\0');
	result = (CFGProperty *)0x0;
	input_parts[0] = (char *)std::malloc(~depth);
	depth = 0xffffffff;
	do {
		pcVar7 = keyPath;
		if (depth == 0) break;
		depth = depth - 1;
		pcVar7 = keyPath + 1;
		c = *keyPath;
		keyPath = pcVar7;
	} while (c != '\0');
	depth = ~depth;
	puVar5 = (undefined4 *)(pcVar7 + -depth);
	puVar8 = (undefined4 *)input_parts[0];
	for (uVar2 = depth >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
		*puVar8 = *puVar5;
		puVar5 = puVar5 + 1;
		puVar8 = puVar8 + 1;
	}
	for (depth = depth & 3; depth != 0; depth = depth - 1) {
		*(undefined *)puVar8 = *(undefined *)puVar5;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
		puVar8 = (undefined4 *)((int)puVar8 + 1);
	}
	numParts = util::Util_Tokenise(input_parts[0],input_parts + 1,"::");
	if (prop != (CFGProperty *)0x0) {
		do {
			if (prop->depth == numParts - 1U) {
										// CFG_IsKeyMatch
				isWildcard = false;
				if (numParts == 1) {
					pcVar7 = prop->key;
					sVar6 = 0;
					c = *pcVar7;
					pcVar3 = pcVar7;
					while ((c != '\0' && (c != '*'))) {
						pcVar1 = pcVar3 + 1;
						sVar6 = sVar6 + 1;
						pcVar3 = pcVar3 + 1;
						c = *pcVar1;
					}
					if (*pcVar3 == '*') {
						tmpCmp = std::_strnicmp(input_parts[1],pcVar7,sVar6);
						isWildcard = tmpCmp == 0;
					}
				}
				if ((isWildcard) || (tmpCmp = std::_stricmp(input_parts[numParts],prop->key), tmpCmp == 0))
				{
					isWildcard = false;
					depth = numParts - 1U;
					for (previous = prop; previous != (CFGProperty *)0x0; previous = previous->linkPrev) {
										// CFG_IsKeyMatch
						uVar2 = depth - 1;
						uVar4 = depth;
						if (previous->depth == uVar2) {
							if (depth == 1) {
								pcVar7 = previous->key;
								sVar6 = 0;
								c = *pcVar7;
								pcVar3 = pcVar7;
								while ((c != '\0' && (c != '*'))) {
									pcVar1 = pcVar3 + 1;
									sVar6 = sVar6 + 1;
									pcVar3 = pcVar3 + 1;
									c = *pcVar1;
								}
								if (*pcVar3 == '*') {
									tmpCmp = std::_strnicmp(input_parts[1],pcVar7,sVar6);
									isWildcard = tmpCmp == 0;
								}
							}
							uVar4 = uVar2;
							if ((!isWildcard) &&
								 (tmpCmp = std::_stricmp(input_parts[depth],previous->key), tmpCmp != 0)) break;
						}
						depth = uVar4;
					}
					if ((depth == 0) && (result = prop, !isWildcard)) break;
				}
			}
			prop = prop->linkNext;
		} while (prop != (CFGProperty *)0x0);
	}
	std::free(input_parts[0]);
	return result;
}



void __cdecl lego::cfg::Config_AddList(void)
{
	CFGProperty *pCVar1;
	CFGProperty *pCVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::configGlobs.listCount & 0x1f);
	pCVar2 = (CFGProperty *)std::malloc(uVar4 * 0x20);
	globs::configGlobs.listSet[globs::configGlobs.listCount] = pCVar2;
	pCVar2 = globs::configGlobs.listSet[globs::configGlobs.listCount];
	if (pCVar2 != (CFGProperty *)0x0) {
		globs::configGlobs.listCount = globs::configGlobs.listCount + 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pCVar1 = pCVar2;
			do {
				pCVar1->nextFree = pCVar1 + 1;
				iVar3 = iVar3 + -1;
				pCVar1 = pCVar1 + 1;
			} while (iVar3 != 0);
		}
		pCVar2[uVar4 - 1].nextFree = globs::configGlobs.freeList;
		globs::configGlobs.freeList = pCVar2;
	}
	return;
}



// out_vector = norm({ rand(), rand(), rand() })

Vector3F * __cdecl lego::math::Maths_Vector3DRandom(Vector3F *out_vector)
{
	Vector3F *pVVar1;
	
	pVVar1 = D3DRMVectorRandom(out_vector);
	return pVVar1;
}



// out_vector = ::D3DRMVectorRotate(out_vector, v, axis, theta)

Vector3F * __cdecl
lego::math::Maths_Vector3DRotate(Vector3F *out_vector,Vector3F *v,Vector3F *axis,float theta)
{
	Vector3F *pVVar1;
	
	pVVar1 = D3DRMVectorRotate(out_vector,v,axis,theta);
	return pVVar1;
}



// out_vector = norm(cross_product((c - b), (b - a)))

Vector3F * __cdecl
lego::math::Maths_PlaneNormal(Vector3F *out_vector,Vector3F *p1,Vector3F *p2,Vector3F *p3)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	
	fVar1 = p3->x - p2->x;
	fVar4 = p2->x - p1->x;
	fVar3 = p3->y - p2->y;
	fVar5 = p3->z - p2->z;
	fVar6 = p2->y - p1->y;
	fVar7 = p2->z - p1->z;
	fVar2 = fVar1 * fVar7 - fVar5 * fVar4;
	fVar4 = fVar3 * fVar4 - fVar1 * fVar6;
	fVar3 = fVar5 * fVar6 - fVar3 * fVar7;
	fVar1 = 1.0 / SQRT(fVar3 * fVar3 + fVar4 * fVar4 + fVar2 * fVar2);
	out_vector->x = fVar1 * fVar3;
	out_vector->y = fVar1 * fVar2;
	out_vector->z = fVar1 * fVar4;
	return out_vector;
}



float10 __cdecl lego::math::Maths_TriangleAreaZ(Vector3F *p1,Vector3F *p2,Vector3F *p3,BOOL bfc)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	Vector3F *pVVar5;
	Vector3F *pVVar6;
	int iVar7;
	float *pfVar8;
	Vector3F *pVVar9;
	Vector3F **ppVVar10;
	uint uVar11;
	float10 fVar12;
	float local_8c;
	uint local_88;
	float local_7c;
	Vector3F local_78;
	Vector3F local_6c;
	Vector3F local_60;
	Vector3F *local_54 [5];
	Vector3F *local_40;
	Vector3F local_3c;
	Vector3F local_30 [3];
	
	local_54[0] = &local_78;
	local_54[1] = &local_6c;
	local_54[3] = &local_60;
	local_54[2] = &local_6c;
	local_54[4] = &local_60;
	local_78.x = p1->x;
	local_40 = &local_78;
	local_78.y = p1->y;
	local_6c.x = p2->x;
	local_6c.y = p2->y;
	local_60.x = p3->x;
	local_60.y = p3->y;
	local_7c = 0.0;
	local_8c = 0.0;
	local_78.z = 0.0;
	local_6c.z = 0.0;
	local_60.z = 0.0;
	if (bfc == 0) {
		local_3c.z = -1.0;
	}
	else {
		Maths_PlaneNormal(&local_3c,&local_78,&local_6c,&local_60);
	}
	if (local_3c.z < 0.0) {
		uVar11 = 0;
		pVVar9 = local_30;
		ppVVar10 = local_54 + 1;
		pfVar8 = &local_30[1].z;
		do {
			pVVar5 = *ppVVar10;
			pVVar6 = ppVVar10[-1];
			fVar1 = pVVar5->y;
			fVar2 = pVVar5->z;
			fVar3 = pVVar6->y;
			fVar4 = pVVar6->z;
			pfVar8[-2] = pVVar5->x - pVVar6->x;
			pfVar8[-1] = fVar1 - fVar3;
			*pfVar8 = fVar2 - fVar4;
			fVar2 = SQRT(pfVar8[-2] * pfVar8[-2] + *pfVar8 * *pfVar8 + pfVar8[-1] * pfVar8[-1]);
			fVar3 = 1.0 / fVar2;
			fVar1 = pfVar8[-2];
			pVVar9->x = fVar2;
			fVar2 = pVVar9->x;
			pfVar8[-2] = fVar3 * fVar1;
			pfVar8[-1] = fVar3 * pfVar8[-1];
			*pfVar8 = fVar3 * *pfVar8;
			if ((ushort)((ushort)(fVar2 < local_8c) << 8 | (ushort)(fVar2 == local_8c) << 0xe) == 0) {
				local_8c = pVVar9->x;
				local_88 = uVar11;
			}
			uVar11 = uVar11 + 1;
			ppVVar10 = ppVVar10 + 2;
			pfVar8 = pfVar8 + 3;
			pVVar9 = (Vector3F *)&pVVar9->y;
		} while (uVar11 < 3);
		uVar11 = (local_88 + 1) % 3;
		local_30[local_88 + 1].x = local_30[local_88 + 1].x * -1.0;
		local_30[local_88 + 1].y = local_30[local_88 + 1].y * -1.0;
		local_30[local_88 + 1].z = local_30[local_88 + 1].z * -1.0;
										// Standard library math functions have some nasty ASM in them.
										// I believe the second function is testing against FPU control word results(?)
		fVar12 = std::acos((float10)local_30[uVar11 + 1].x * (float10)local_30[local_88 + 1].x +
											 (float10)local_30[local_88 + 1].z * (float10)local_30[uVar11 + 1].z +
											 (float10)local_30[local_88 + 1].y * (float10)local_30[uVar11 + 1].y);
		iVar7 = std::_finite((double)fVar12);
		if (iVar7 != 0) {
			fVar12 = (float10)fsin((float10)(float)fVar12);
			local_7c = (float)((float10)(&local_30[0].x)[local_88] * (float10)0.5 *
												fVar12 * (float10)(&local_30[0].x)[uVar11]);
		}
	}
	return (float10)local_7c;
}



short __cdecl lego::math::Maths_Rand(void)
{
	globals::g_RAND = globals::g_RAND * 0x343fd + 0x269ec3;
	return (short)((ushort)(globals::g_RAND >> 0x10) & 0x7fff);
}



float10 __cdecl lego::math::Maths_RandRange(float low,float high)
{
	short sVar1;
	
	sVar1 = Maths_Rand();
	return (float10)(int)sVar1 * (float10)3.051851e-05 * ((float10)high - (float10)low) + (float10)low
	;
}



// out_vector = a + (norm(b) * (dot_product((c - a), norm(d)) / dot_product(norm(b), norm(d)))
// CONDITION: dot_product(norm(b), norm(d)) != 0.0

BOOL __cdecl
lego::math::Maths_RayPlaneIntersection
					(Vector3F *out_endPoint,Vector3F *rayOrigin,Vector3F *ray,Vector3F *planePoint,
					Vector3F *planeNormal)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	BOOL BVar8;
	Vector3F norm_b;
	Vector3F norm_d;
	
	fVar1 = planeNormal->x;
	fVar2 = ray->x;
	fVar3 = planeNormal->y;
	fVar4 = ray->y;
	fVar5 = ray->z;
	fVar6 = planeNormal->z;
	fVar7 = 1.0 / SQRT(fVar5 * fVar5 + fVar4 * fVar4 + fVar2 * fVar2);
	ray = (Vector3F *)(1.0 / SQRT(fVar6 * fVar6 + fVar3 * fVar3 + fVar1 * fVar1));
	norm_b.x = fVar7 * fVar2;
	norm_b.y = fVar7 * fVar4;
	norm_b.z = fVar7 * fVar5;
	norm_d.x = (float)ray * fVar1;
	norm_d.y = (float)ray * fVar3;
	norm_d.z = (float)ray * fVar6;
	BVar8 = Maths_RayPlaneDistance((float *)&ray,rayOrigin,&norm_b,planePoint,&norm_d);
	if (BVar8 != 0) {
		Maths_RayEndPoint(out_endPoint,rayOrigin,&norm_b,(float)ray);
		return TRUE;
	}
	return 0;
}



// out_value = dot_product((c - a), d) / dot_product(b, d)
// CONDITION: dot_product(b, d) != 0.0

BOOL __cdecl
lego::math::Maths_RayPlaneDistance
					(float *out_dist,Vector3F *rayOrigin,Vector3F *ray,Vector3F *planePoint,
					Vector3F *planeNormal)
{
	float dot_product;
	
										// Vector3_DotProduct(b, d)
	dot_product = planeNormal->x * ray->x + ray->z * planeNormal->z + ray->y * planeNormal->y;
	if (dot_product != 0.0) {
										// Vector3_Multiply((Vector3_Subtract(c, a), d)
		*out_dist = ((planePoint->x - rayOrigin->x) * planeNormal->x +
								(planePoint->y - rayOrigin->y) * planeNormal->y +
								(planePoint->z - rayOrigin->z) * planeNormal->z) / dot_product;
		return TRUE;
	}
	return 0;
}



// out_vector = a + (b * scalar)

Vector3F * __cdecl
lego::math::Maths_RayEndPoint(Vector3F *out_endPoint,Vector3F *rayOrigin,Vector3F *ray,float dist)
{
	float fVar1;
	float fVar2;
	
	fVar1 = ray->y;
	fVar2 = ray->z;
	out_endPoint->x = dist * ray->x + rayOrigin->x;
	out_endPoint->y = rayOrigin->y + fVar1 * dist;
	out_endPoint->z = rayOrigin->z + fVar2 * dist;
	return out_endPoint;
}



// out_point = a + (b * dot_product((a - c), (perpendicular(d) / dot_product(perpendicular(b), d))))
// CONDITION: dot_product(perpendicular(b), d) != 0.0

Point2F * __cdecl
lego::math::Maths_Vector2DIntersection
					(Point2F *out_intersection,Point2F *start1,Point2F *vector1,Point2F *start2,
					Point2F *vector2)
{
	float fVar1;
	
	fVar1 = -vector1->y * vector2->x - -vector1->x * vector2->y;
	if (fVar1 != 0.0) {
		fVar1 = (start1->x - start2->x) * -(vector2->y / fVar1) +
						(vector2->x / fVar1) * (start1->y - start2->y);
		out_intersection->x = fVar1 * vector1->x;
		out_intersection->y = fVar1 * vector1->y;
		out_intersection->x = start1->x + out_intersection->x;
		out_intersection->y = out_intersection->y + start1->y;
		return out_intersection;
	}
	return (Point2F *)0x0;
}



BOOL __cdecl
lego::math::Maths_PointInsidePoly(Point2F *point,Point2F *fromList,Point2F *toList,uint count)
{
	float fVar1;
	float *pfVar2;
	uint uVar3;
	Point2F *pPVar4;
	
	uVar3 = 0;
	if (count != 0) {
		pfVar2 = &fromList->y;
		pPVar4 = (Point2F *)((int)toList - (int)fromList);
		do {
			if (((((ushort)((ushort)(*pfVar2 < point->y) << 8 | (ushort)(*pfVar2 == point->y) << 0xe) != 0
						) && (point->y <= *(float *)((int)&pPVar4->x + (int)pfVar2))) ||
					((point->y <= *pfVar2 &&
					 (fVar1 = *(float *)((int)&pPVar4->x + (int)pfVar2),
					 (ushort)((ushort)(fVar1 < point->y) << 8 | (ushort)(fVar1 == point->y) << 0xe) != 0))))
				 && (fVar1 = (toList->x - pfVar2[-1]) *
										 ((*(float *)((int)&pPVar4->x + (int)pfVar2) - *pfVar2) / (point->y - *pfVar2))
										 + pfVar2[-1],
						(ushort)((ushort)(fVar1 < point->x) << 8 | (ushort)(fVar1 == point->x) << 0xe) == 0)) {
				uVar3 = uVar3 + 1;
			}
			toList = toList + 1;
			pfVar2 = pfVar2 + 2;
			count = count - 1;
		} while (count != 0);
	}
	return uVar3 & 1;
}



BOOL __cdecl
lego::math::Maths_RaySphereIntersection
					(Vector3F *center,float radius,Vector3F *camera,Vector3F *line)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	
	fVar1 = camera->y - center->y;
	fVar4 = camera->z - center->z;
	fVar3 = camera->x - center->x;
	fVar2 = (line->z + line->z) * fVar4 + (line->y + line->y) * fVar1 + (line->x + line->x) * fVar3;
	fVar1 = fVar2 * fVar2 - ((fVar3 * fVar3 + fVar4 * fVar4 + fVar1 * fVar1) * 4.0 - radius * radius);
	if ((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) == 0) {
		return TRUE;
	}
	return 0;
}



// out_matrix = { {
//                  l[0,0]*r[0,0] + l[0,1]*r[1,0] + l[0,2]*r[2,0] + l[0,3]*r[3,0],
//                  l[0,0]*r[0,1] + l[0,1]*r[1,1] + l[0,2]*r[2,1] + l[0,3]*r[3,1],
//                  l[0,0]*r[0,2] + l[0,1]*r[1,2] + l[0,2]*r[2,2] + l[0,3]*r[3,2],
//                  l[0,0]*r[0,3] + l[0,1]*r[1,3] + l[0,2]*r[2,3] + l[0,3]*r[3,3]
//                },{
//                  l[1,0]*r[0,0] + l[1,1]*r[1,0] + l[1,2]*r[2,0] + l[1,3]*r[3,0],
//                  l[1,0]*r[0,1] + l[1,1]*r[1,1] + l[1,2]*r[2,1] + l[1,3]*r[3,1],
//                  l[1,0]*r[0,2] + l[1,1]*r[1,2] + l[1,2]*r[2,2] + l[1,3]*r[3,2],
//                  l[1,0]*r[0,3] + l[1,1]*r[1,3] + l[1,2]*r[2,3] + l[1,3]*r[3,3]
//                },{
//                  l[2,0]*r[0,0] + l[2,1]*r[1,0] + l[2,2]*r[2,0] + l[2,3]*r[3,0],
//                  l[2,0]*r[0,1] + l[2,1]*r[1,1] + l[2,2]*r[2,1] + l[2,3]*r[3,1],
//                  l[2,0]*r[0,2] + l[2,1]*r[1,2] + l[2,2]*r[2,2] + l[2,3]*r[3,2],
//                  l[2,0]*r[0,3] + l[2,1]*r[1,3] + l[2,2]*r[2,3] + l[2,3]*r[3,3]
//                },{
//                  l[3,0]*r[0,0] + l[3,1]*r[1,0] + l[3,2]*r[2,0] + l[3,3]*r[3,0],
//                  l[3,0]*r[0,1] + l[3,1]*r[1,1] + l[3,2]*r[2,1] + l[3,3]*r[3,1],
//                  l[3,0]*r[0,2] + l[3,1]*r[1,2] + l[3,2]*r[2,2] + l[3,3]*r[3,2],
//                  l[3,0]*r[0,3] + l[3,1]*r[1,3] + l[3,2]*r[2,3] + l[3,3]*r[3,3]
//              } }
// NOTE: right and left operands are ordered in reverse in the parameter list.

void __cdecl lego::math::Matrix_Mult(Matrix4F *out_matrix,Matrix4F *right,Matrix4F *left)
{
	float (*pafVar1) [4];
	float (*pafVar2) [4];
	Matrix4F *pMVar3;
	Matrix4F *pMVar4;
	Matrix4F *pMVar5;
	float *pfVar6;
	int iVar7;
	int iVar8;
	Matrix4F *pMVar9;
	
	Matrix_Zero(out_matrix);
	pMVar5 = (Matrix4F *)((int)out_matrix - (int)left);
	out_matrix = (Matrix4F *)&DAT_00000004;
	do {
		pfVar6 = (float *)((int)pMVar5->values + (int)left->values);
		iVar7 = 4;
		pMVar9 = right;
		do {
			iVar8 = 4;
			pMVar3 = pMVar9;
			pMVar4 = left;
			do {
				pafVar1 = pMVar4->values;
				pafVar2 = pMVar3->values;
				pMVar3 = (Matrix4F *)pMVar3->values[1];
				pMVar4 = (Matrix4F *)(pMVar4->values + 1);
				iVar8 = iVar8 + -1;
				*pfVar6 = (*pafVar1)[0] * (*pafVar2)[0] + *pfVar6;
			} while (iVar8 != 0);
			pfVar6 = pfVar6 + 1;
			pMVar9 = (Matrix4F *)(pMVar9->values + 1);
			iVar7 = iVar7 + -1;
		} while (iVar7 != 0);
		left = (Matrix4F *)left->values[1];
		out_matrix = (Matrix4F *)((int)out_matrix[-1].values[3] + 0xf);
	} while (out_matrix != (Matrix4F *)0x0);
	return;
}



// out_matrix = { { 1,      0,       0, 0 },
//                { 0, cos(t), -sin(t), 0 },
//                { 0, sin(t),  cos(t), 0 },
//                { 0,      0,       0, 1 } }

void __cdecl lego::math::Matrix_RotX(Matrix4F *out_matrix,float rot)
{
	float10 fVar1;
	float10 fVar2;
	
	fVar1 = (float10)fcos((float10)rot);
	fVar2 = (float10)fsin((float10)rot);
	Matrix_Identity(out_matrix);
	out_matrix->values[1][2] = -(float)fVar2;
	out_matrix->values[1][1] = (float)fVar1;
	out_matrix->values[2][2] = (float)fVar1;
	out_matrix->values[2][1] = (float)fVar2;
	return;
}



// out_matrix = { {  cos(t), 0, sin(t), 0 },
//                {       0, 1,      0, 0 },
//                { -sin(t), 0, cos(t), 0 },
//                {       0, 0,      0, 1 } }

void __cdecl lego::math::Matrix_RotY(Matrix4F *out_matrix,float rot)
{
	float10 fVar1;
	float10 fVar2;
	
	fVar1 = (float10)fcos((float10)rot);
	fVar2 = (float10)fsin((float10)rot);
	Matrix_Identity(out_matrix);
	out_matrix->values[2][0] = -(float)fVar2;
	out_matrix->values[0] = (float)fVar1;
	out_matrix->values[2][2] = (float)fVar1;
	out_matrix->values[2] = (float)fVar2;
	return;
}



// out_matrix = { { cos(t), -sin(t), 0, 0 },
//                { sin(t),  cos(t), 0, 0 },
//                {      0,       0, 1, 0 },
//                {      0,       0, 0, 1 } }

void __cdecl lego::math::Matrix_RotZ(Matrix4F *out_matrix,float rot)
{
	float10 fVar1;
	float10 fVar2;
	
	fVar1 = (float10)fcos((float10)rot);
	fVar2 = (float10)fsin((float10)rot);
	Matrix_Identity(out_matrix);
	out_matrix->values[1] = -(float)fVar2;
	out_matrix->values[0] = (float)fVar1;
	out_matrix->values[1][1] = (float)fVar1;
	out_matrix->values[1][0] = (float)fVar2;
	return;
}



// out_matrix = { { 1, 0, 0, 0 },
//                { 0, 1, 0, 0 },
//                { 0, 0, 1, 0 },
//                { x, y, z, 1 } }

void __cdecl lego::math::Matrix_Translate(Matrix4F *out_matrix,Vector3F *trans)
{
	Matrix_Identity(out_matrix);
	out_matrix->values[3][0] = trans->x;
	out_matrix->values[3][1] = trans->y;
	out_matrix->values[3][2] = trans->z;
	return;
}



// out_matrix = { { 1, 0, 0, 0 },
//                { 0, 1, 0, 0 },
//                { 0, 0, 1, 0 },
//                { 0, 0, 0, 1 } }

void __cdecl lego::math::Matrix_Identity(Matrix4F *out_matrix)
{
	float fVar1;
	int iVar2;
	int iVar3;
	
	iVar3 = 0;
	do {
		iVar2 = 0;
		do {
			if (iVar3 == iVar2) {
				fVar1 = 1.0;
			}
			else {
				fVar1 = 0.0;
			}
			out_matrix->values[0] = fVar1;
			iVar2 = iVar2 + 1;
			out_matrix = (Matrix4F *)(out_matrix->values + 1);
		} while (iVar2 < 4);
		iVar3 = iVar3 + 1;
	} while (iVar3 < 4);
	return;
}



// out_matrix = { { 0, 0, 0, 0 },
//                { 0, 0, 0, 0 },
//                { 0, 0, 0, 0 },
//                { 0, 0, 0, 0 } }

void __cdecl lego::math::Matrix_Zero(Matrix4F *out_matrix)
{
	int iVar1;
	
	for (iVar1 = 0x10; iVar1 != 0; iVar1 = iVar1 + -1) {
		out_matrix->values[0] = 0.0;
		out_matrix = (Matrix4F *)(out_matrix->values + 1);
	}
	return;
}



// out_matrix = a

void __cdecl lego::math::Matrix_Copy(Matrix4F *out_matrix,Matrix4F *src)
{
	Matrix4F *pMVar1;
	int iVar2;
	int iVar3;
	
	iVar3 = 4;
	pMVar1 = out_matrix;
	do {
		iVar2 = 4;
		do {
			pMVar1->values[0] =
					 *(float *)((int)((Matrix4F *)((int)src - (int)out_matrix))->values + (int)pMVar1->values)
			;
			pMVar1 = (Matrix4F *)(pMVar1->values + 1);
			iVar2 = iVar2 + -1;
		} while (iVar2 != 0);
		iVar3 = iVar3 + -1;
	} while (iVar3 != 0);
	return;
}



ImageFont * __cdecl lego::image::Font_Load(char *fname)
{
	uint uVar1;
	uint uVar2;
	ImageBMP *image;
	ImageFont *font;
	void *pvVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	float *pfVar7;
	float *pfVar8;
	float10 fVar9;
	float10 fVar10;
	float10 extraout_ST0;
	float10 extraout_ST1;
	longlong lVar11;
	longlong lVar12;
	int local_58;
	uint local_50;
	int local_48;
	uint local_38;
	uint local_34;
	uint local_30;
	uint local_2c;
	uint local_28;
	float *local_24;
	undefined4 uStack32;
	ImageBMP *local_1c;
	uint local_18;
	undefined4 uStack20;
	char *local_10;
	undefined4 uStack12;
	uint local_8;
	undefined4 uStack4;
	
	image = Image_LoadBMPScaled(fname,0,0);
	if (image != (ImageBMP *)0x0) {
		local_1c = image;
		font = Font_Create(image);
		if (font != (ImageFont *)0x0) {
			Image_SetPenZeroTrans(image);
			uVar5 = (int)image->width / 10;
			uVar2 = (int)image->height / 0x13;
			local_28 = uVar5;
			local_2c = Image_GetPen255(image);
			local_30 = Image_GetPixelMask(image);
			pvVar3 = Image_LockSurface(image,&local_34,&local_38);
			if (pvVar3 != (void *)0x0) {
				fVar9 = (float10)(ulonglong)uVar5;
				uStack32 = 0;
				uVar1 = uVar5 - 1;
				pfVar7 = (float *)&font->field_0xc;
				local_50 = 0;
				local_48 = 0x13;
				local_24 = pfVar7;
				do {
					uStack20 = 0;
					fVar10 = (float10)(ulonglong)local_50;
					fname = (char *)0x0;
					local_58 = 10;
					pfVar8 = pfVar7;
					local_18 = local_50;
					do {
						uStack12 = 0;
						local_10 = fname;
						pfVar8[-2] = (float)ZEXT48(fname);
						pfVar8[-1] = (float)fVar10;
						*pfVar8 = (float)fVar9;
						pfVar8[1] = (float)(ulonglong)uVar2;
						if (uVar1 != 0) {
							lVar11 = __ftol(fVar10);
							uVar6 = uVar1;
							do {
								uStack4 = 0;
								local_8 = uVar6;
								lVar12 = __ftol((float10)(ulonglong)uVar6 + (float10)ZEXT48(fname));
								iVar4 = (int)lVar12 * (local_38 >> 3) + local_34 * (int)lVar11;
								uVar5 = local_28;
								fVar10 = extraout_ST0;
								fVar9 = extraout_ST1;
								if ((CONCAT31(CONCAT21(CONCAT11(*(undefined *)(iVar4 + (int)pvVar3),
																								*(undefined *)(iVar4 + 1 + (int)pvVar3)),
																			 *(undefined *)(iVar4 + 2 + (int)pvVar3)),
															*(undefined *)(iVar4 + 3 + (int)pvVar3)) & local_30) != local_2c)
								break;
								uVar6 = uVar6 - 1;
								*pfVar8 = *pfVar8 - 1.0;
							} while (uVar6 != 0);
						}
						pfVar8 = pfVar8 + 0x4c;
						fname = fname + uVar5;
						local_58 = local_58 + -1;
					} while (local_58 != 0);
					local_50 = local_50 + uVar2;
					pfVar7 = pfVar7 + 4;
					local_48 = local_48 + -1;
					if (local_48 == 0) {
						lVar11 = __ftol((float10)*(float *)&font->field_0x10);
						font->field_be4 = (int)lVar11;
						lVar11 = __ftol((float10)*local_24);
						*(int *)&font->field_0xbe8 = (int)lVar11 << 3;
						Image_UnlockSurface(local_1c);
						return font;
					}
				} while( true );
			}
			Font_Remove(font);
		}
		Image_Remove(image);
	}
	return (ImageFont *)0x0;
}



void __cdecl
lego::image::Font_VGetStringInfo
					(ImageFont *font,uint *out_width,uint *out_lineCount,char *msg,va_list argptr)
{
	uint uVar1;
	
	uVar1 = Font_VPrintF2(font,0,0,FALSE,out_lineCount,msg,argptr);
	if (out_width != (uint *)0x0) {
		*out_width = uVar1;
	}
	return;
}



uint __cdecl lego::image::Font_PrintF(ImageFont *font,int x,int y,char *msg,...)
{
	uint uVar1;
	
	uVar1 = Font_VPrintF2(font,x,y,TRUE,(uint *)0x0,msg,&stack0x00000014);
	return uVar1;
}



uint __cdecl lego::image::Font_VPrintF(ImageFont *font,int x,int y,char *msg,va_list argptr)
{
	uint uVar1;
	
	uVar1 = Font_VPrintF2(font,x,y,TRUE,(uint *)0x0,msg,argptr);
	return uVar1;
}



uint __cdecl
lego::image::Font_VPrintF2
					(ImageFont *font,int x,int y,BOOL render,uint *out_lineCount,char *msg,va_list argptr)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	ImageBMP *image;
	byte bVar7;
	uint local_828;
	uint local_824;
	uint local_820;
	uint local_81c;
	uint local_818;
	Point2F local_808;
	char local_800 [12];
	char acStack2036 [1012];
	char local_400 [1024];
	
	cVar2 = *msg;
	local_824 = font->field_be4;
	local_818 = 1;
	local_828 = 0;
	local_81c = 0;
	pcVar3 = local_400;
	while (cVar2 != '\0') {
		if ((*msg == '%') && (msg[1] == 'b')) {
			*pcVar3 = '@';
			pcVar3[1] = '[';
			pcVar3[2] = '0';
			pcVar3[3] = 'x';
			pcVar3[4] = '%';
			pcVar3[5] = '0';
			pcVar3[6] = '.';
			pcVar3[7] = '8';
			pcVar3[8] = 'x';
			pcVar3 = pcVar3 + 9;
			msg = msg + 1;
			*pcVar3 = ']';
		}
		else {
			*pcVar3 = *msg;
		}
		pcVar1 = msg + 1;
		msg = msg + 1;
		pcVar3 = pcVar3 + 1;
		cVar2 = *pcVar1;
	}
	*pcVar3 = '\0';
	uVar4 = std::vsprintf(local_800,local_400,argptr);
	local_820 = 0;
	uVar6 = 0;
	if (uVar4 != 0) {
		do {
			cVar2 = local_800[local_820];
			if (cVar2 == '\n') {
				if (local_81c < local_828) {
					local_81c = local_828;
				}
				y = y + local_824;
				local_824 = font->field_be4;
				local_828 = 0;
				local_818 = local_818 + 1;
			}
			else {
				if (cVar2 == '\t') {
					uVar6 = *(uint *)&font->field_0xbe8 - local_828 % *(uint *)&font->field_0xbe8;
				}
				else {
					if ((((local_820 < uVar4 - 0xc) && (cVar2 == '@')) && (local_800[local_820 + 1] == '['))
						 && (((local_800[local_820 + 2] == '0' && (local_800[local_820 + 3] == 'x')) &&
								 (acStack2036[local_820] == ']')))) {
						image = (ImageBMP *)0x0;
						uVar6 = 0;
						pcVar3 = local_800 + local_820 + 4;
						bVar7 = 0x1c;
						do {
										// int std::isdigit(int c)
							if (std::globals::_pcharwidth < 2) {
								uVar5 = *(byte *)(std::globals::_pctype + (byte)pcVar3[uVar6]) & C1_DIGIT;
							}
							else {
										// C1_DIGIT (0x4)
								uVar5 = std::_isctype((uint)(byte)pcVar3[uVar6],C1_DIGIT);
							}
							image = (ImageBMP *)
											((uint)image |
											(uint)(byte)pcVar3[uVar6] - ((-(uint)(uVar5 != 0) & 0xffffffd9) + 0x57) <<
											(bVar7 & 0x1f));
							uVar6 = uVar6 + 1;
							bVar7 = bVar7 - 4;
						} while (uVar6 < 8);
						if (image != (ImageBMP *)0x0) {
							local_808.x = (float)(ulonglong)(local_828 + x);
							local_808.y = (float)y;
							local_828 = local_828 + image->width;
							if (local_824 < image->height) {
								local_824 = image->height;
							}
							Image_DisplayScaled(image,(Rect2F *)0x0,&local_808,(Size2F *)0x0);
						}
						local_820 = local_820 + 0xc;
						goto LAB_0047a6f3;
					}
					uVar6 = Font_OutputChar(font,local_828 + x,y,cVar2,render);
				}
				local_828 = local_828 + uVar6;
			}
LAB_0047a6f3:
			local_820 = local_820 + 1;
			uVar6 = local_828;
		} while (local_820 < uVar4);
	}
	if (out_lineCount != (uint *)0x0) {
		*out_lineCount = local_818;
	}
	if (local_81c < uVar6) {
		local_81c = uVar6;
	}
	return local_81c;
}



uint __cdecl lego::image::Font_OutputChar(ImageFont *font,int x,int y,char c,BOOL render)
{
	uint uVar1;
	uint uVar2;
	longlong lVar3;
	Point2F local_8;
	
	local_8.x = (float)x;
	local_8.y = (float)y;
	uVar1 = (byte)(c - 0x20) / 10;
	uVar2 = (uint)(byte)(c - 0x20) % 10;
	if (uVar1 < 0x13) {
		if (render != 0) {
			Image_DisplayScaled(font->bitmap,(Rect2F *)(&font->field_0x4 + (uVar1 + uVar2 * 0x13) * 0x10),
													&local_8,(Size2F *)0x0);
		}
		lVar3 = __ftol((float10)*(float *)(&font->field_0xc + (uVar1 + uVar2 * 0x13) * 0x10));
		return (uint)lVar3;
	}
	return 0;
}



uint __cdecl lego::image::Font_GetCharWidth(ImageFont *font,char c)
{
	uint uVar1;
	
	uVar1 = Font_OutputChar(font,0,0,c,FALSE);
	return uVar1;
}



uint __cdecl lego::image::Font_GetHeight(ImageFont *font)
{
	return font->field_be4;
}



void __cdecl lego::image::Font_Remove(ImageFont *font)
{
	Image_Remove(font->bitmap);
	font->pool_m_next = globs::fontGlobs.freeList;
	globs::fontGlobs.freeList = font;
	return;
}



ImageFont * __cdecl lego::image::Font_Create(ImageBMP *image)
{
	int iVar1;
	ImageFont *pIVar2;
	ImageFont *pIVar3;
	
	pIVar2 = globs::fontGlobs.freeList;
	if (globs::fontGlobs.freeList == (ImageFont *)0x0) {
		Font_AddList();
		pIVar2 = globs::fontGlobs.freeList;
	}
	globs::fontGlobs.freeList = pIVar2->pool_m_next;
	pIVar3 = pIVar2;
	for (iVar1 = 0x2fd; iVar1 != 0; iVar1 = iVar1 + -1) {
		pIVar3->bitmap = (ImageBMP *)0x0;
		pIVar3 = (ImageFont *)&pIVar3->field_0x4;
	}
	pIVar2->pool_m_next = pIVar2;
	pIVar2->bitmap = image;
	return pIVar2;
}



void __cdecl lego::image::Font_AddList(void)
{
	ImageFont *pIVar1;
	ImageFont *pIVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::fontGlobs.listCount & 0x1f);
	pIVar2 = (ImageFont *)std::malloc(uVar4 * 0xbf4);
	globs::fontGlobs.listSet[globs::fontGlobs.listCount] = pIVar2;
	pIVar2 = globs::fontGlobs.listSet[globs::fontGlobs.listCount];
	if (pIVar2 != (ImageFont *)0x0) {
		globs::fontGlobs.listCount = globs::fontGlobs.listCount + 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pIVar1 = pIVar2;
			do {
				pIVar1->pool_m_next = pIVar1 + 1;
				iVar3 = iVar3 + -1;
				pIVar1 = pIVar1 + 1;
			} while (iVar3 != 0);
		}
		pIVar2[uVar4 - 1].pool_m_next = globs::fontGlobs.freeList;
		globs::fontGlobs.freeList = pIVar2;
	}
	return;
}



BOOL __cdecl lego::snd::Sound3D_Initialise(HWND hWnd)
{
	HRESULT HVar1;
	WAVEFORMATEX *pWVar2;
	int iVar3;
	WAVEFORMATEX wfx;
	DSBUFFERDESC dsbd;
	
	globs::sound3DGlobs.intialised = 0;
	globs::sound3DGlobs.listenerFrame = (IDirect3DRMFrame3 *)0x0;
	do {
		HVar1 = DirectSoundCreate((LPGUID)0x0,(IDirectSound **)&globs::sound3DGlobs,(IUnknown *)0x0);
		if (HVar1 == 0) {
										// DSSCL_PRIORITY (0x2)
			pWVar2 = (WAVEFORMATEX *)
							 (*(code *)(globs::sound3DGlobs.lpDSnd)->lpVtbl->SetCooperativeLevel)
												 (globs::sound3DGlobs.lpDSnd,hWnd,2);
			if (pWVar2 == (WAVEFORMATEX *)0x0) {
				dsbd.dwSize = 0x14;
										// DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRL3D | DSBCAPS_CTRLVOLUME
				dsbd.dwFlags = 0x91;
				dsbd.dwBufferBytes = (DWORD)pWVar2;
				dsbd.dwReserved = (DWORD)pWVar2;
				dsbd.lpwfxFormat = pWVar2;
				HVar1 = (*(code *)(globs::sound3DGlobs.lpDSnd)->lpVtbl->CreateSoundBuffer)
													(globs::sound3DGlobs.lpDSnd,&dsbd,
													 (IDirectSoundBuffer *)&globs::sound3DGlobs.lpDSBuff,(void *)0x0);
				if (HVar1 == 0) {
					wfx.wFormatTag = 1;
					wfx.nChannels = 2;
					wfx.wBitsPerSample = 0x10;
					wfx.nSamplesPerSec = 22050;
										// wfx.wBitsPerSample / 8 * wfx.nChannels
					wfx.nBlockAlign = 4;
										// wfx.nSamplesPerSec * wfx.nBlockAlign
					wfx.nAvgBytesPerSec = 88200;
					wfx.cbSize = 0;
					(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->SetFormat)
										(globs::sound3DGlobs.lpDSBuff,&wfx);
					HVar1 = (*(globs::sound3DGlobs.lpDSBuff)->lpVtbl->QueryInterface)
														(globs::sound3DGlobs.lpDSBuff,&idl::IID_IDirectSound3DListener,
														 &globs::sound3DGlobs.lp3DListenerInfo);
					if (HVar1 == 0) {
						(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetDopplerFactor)
											(globs::sound3DGlobs.lp3DListenerInfo,(float)&DAT_42c80000,0);
						goto LAB_0047aa15;
					}
					(*(globs::sound3DGlobs.lpDSBuff)->lpVtbl->Release)(globs::sound3DGlobs.lpDSBuff);
					goto LAB_0047aa04;
				}
				(*(globs::sound3DGlobs.lpDSnd)->lpVtbl->Release)(globs::sound3DGlobs.lpDSnd);
			}
			else {
LAB_0047aa04:
				(*(globs::sound3DGlobs.lpDSnd)->lpVtbl->Release)(globs::sound3DGlobs.lpDSnd);
			}
			globs::sound3DGlobs.lpDSnd = (IDirectSound *)0x0;
		}
LAB_0047aa15:
		if (globs::sound3DGlobs.lpDSnd == (IDirectSound *)0x0) {
			iVar3 = 5;
		}
		else {
			iVar3 = 1;
			globs::sound3DGlobs.intialised = 1;
		}
		if (iVar3 != 4) {
			if (globs::sound3DGlobs.intialised != 0) {
										// SET THE PRIMARY BUFFER TO CONTINUOUSLY PLAY - OPTIMISATION FOR FREQUENT
										// STARTING AND STOPPING OF PLAYBACK
										// 
										// DSBPLAY_LOOPING (0x1)
				(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->Play)(globs::sound3DGlobs.lpDSBuff,0,0,1);
										// DEFAULT VALUES
										// 
										// DS3D_DEFERRED (0x1)
				(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetRolloffFactor)
									(globs::sound3DGlobs.lp3DListenerInfo,1.0,1);
										// DISABLE DOPPLER - DONT NEED TO SET VELOCITY ON SOUNDS
										// 
										// DS3D_DEFERRED (0x1)
				(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetDopplerFactor)
									(globs::sound3DGlobs.lp3DListenerInfo,0.0,1);
				(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->CommitDeferredSettings)
									(globs::sound3DGlobs.lp3DListenerInfo);
				globs::sound3DGlobs.minDistanceForAttentuation = 1.0;
				globs::sound3DGlobs.maxDistance = 800.0;
				(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->GetVolume)
									(globs::sound3DGlobs.lpDSBuff,&globs::sound3DGlobs.windowsVolume);
				Sound3D_SetVolumeToDefault();
			}
			return 1;
		}
	} while( true );
}



void __cdecl lego::snd::Sound3D_ShutDown(void)
{
	if (globs::sound3DGlobs.intialised != 0) {
		Sound3D_SetGlobalVolume(globs::sound3DGlobs.windowsVolume);
		(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->Stop)(globs::sound3DGlobs.lpDSBuff);
		(*(globs::sound3DGlobs.lpDSBuff)->lpVtbl->Release)((IUnknown *)globs::sound3DGlobs.lpDSBuff);
		(*(globs::sound3DGlobs.lpDSnd)->lpVtbl->Release)((IUnknown *)globs::sound3DGlobs.lpDSnd);
		globs::sound3DGlobs.lpDSnd = (IDirectSound *)0x0;
		globs::sound3DGlobs.intialised = 0;
	}
	return;
}



BOOL __cdecl lego::snd::Sound3D_CheckVolumeLimits(int vol)
{
										// is volume in range [-10000 to 0], inclusive
	if ((vol < 1) && (-10001 < vol)) {
		return 1;
	}
	return 0;
}



int __cdecl lego::snd::Sound3D_Load(char *fName,BOOL stream,BOOL simultaneous,int volume)
{
	char cVar1;
	BOOL BVar2;
	char *pcVar3;
	FILE *pFVar4;
	uint uVar5;
	uint uVar6;
	LPCSTR finalFilename;
	SampleFlags SVar7;
	undefined4 *puVar8;
	char *pcVar9;
	Sound3D_SoundData *pSVar10;
	uint sfxIndex;
	char wavFilename [260];
	char cdromFilename [260];
	bool success;
	
	success = false;
	if ((globs::sound3DGlobs.intialised != 0) &&
		 (BVar2 = Sound3D_GetFreeSoundIndex(&sfxIndex), BVar2 != 0)) {
		globs::sound3DGlobs.soundTable[sfxIndex].flags = SAMPLE_NONE;
		std::sprintf(wavFilename,"%s.wav",fName);
		if (stream == 0) {
			BVar2 = Sound3D_LoadSample(globs::sound3DGlobs.soundTable + sfxIndex,wavFilename,simultaneous)
			;
			if (BVar2 != 0) {
				SVar7 = globs::sound3DGlobs.soundTable[sfxIndex].flags & ~SAMPLE_STREAMED;
				globs::sound3DGlobs.soundTable[sfxIndex].flags = SVar7;
				if (simultaneous != 0) {
					globs::sound3DGlobs.soundTable[sfxIndex].flags = SVar7 | SAMPLE_MULTIPLE;
				}
				success = true;
			}
		}
		else {
			pcVar3 = lego::file::File_VerifyFilename(wavFilename);
			finalFilename = (LPCSTR)0x0;
			pFVar4 = std::fopen(pcVar3,"r");
			if (pFVar4 == (FILE *)0x0) {
				BVar2 = lego::file::File_GetCDFilePath(cdromFilename,wavFilename);
				if (BVar2 != 0) {
					finalFilename = cdromFilename;
				}
			}
			else {
				std::fclose(pFVar4);
				finalFilename = pcVar3;
			}
			if ((finalFilename != (LPCSTR)0x0) &&
				 (pFVar4 = std::fopen(finalFilename,"r"), pFVar4 != (FILE *)0x0)) {
				std::fseek(pFVar4,0,2);
				uVar5 = std::ftell(pFVar4);
				uVar6 = sfxIndex;
				globs::sound3DGlobs.soundTable[sfxIndex].size = uVar5;
				uVar5 = GetWaveAvgBytesPerSec(finalFilename);
				globs::sound3DGlobs.soundTable[uVar6].avgBytesPerSec = uVar5;
				globs::sound3DGlobs.soundTable[uVar6].flags =
						 globs::sound3DGlobs.soundTable[uVar6].flags | SAMPLE_STREAMED;
				std::fclose(pFVar4);
				success = true;
			}
		}
		if (success) {
			uVar6 = 0xffffffff;
			pcVar3 = wavFilename;
			do {
				pcVar9 = pcVar3;
				if (uVar6 == 0) break;
				uVar6 = uVar6 - 1;
				pcVar9 = pcVar3 + 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar9;
			} while (cVar1 != '\0');
			uVar6 = ~uVar6;
			puVar8 = (undefined4 *)(pcVar9 + -uVar6);
			pSVar10 = globs::sound3DGlobs.soundTable + sfxIndex;
			for (uVar5 = uVar6 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
				*(undefined4 *)pSVar10->filename = *puVar8;
				puVar8 = puVar8 + 1;
				pSVar10 = (Sound3D_SoundData *)(pSVar10->filename + 4);
			}
			for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
				pSVar10->filename[0] = *(char *)puVar8;
				puVar8 = (undefined4 *)((int)puVar8 + 1);
				pSVar10 = (Sound3D_SoundData *)(pSVar10->filename + 1);
			}
			BVar2 = Sound3D_CheckVolumeLimits(volume);
			if (BVar2 == 0) {
				globs::sound3DGlobs.soundTable[sfxIndex].volume = 0;
				globs::sound3DGlobs.soundTable[sfxIndex].flags =
						 globs::sound3DGlobs.soundTable[sfxIndex].flags | (SAMPLE_ISUSED|SAMPLE_VOLUME);
				return sfxIndex;
			}
			globs::sound3DGlobs.soundTable[sfxIndex].volume = volume;
			globs::sound3DGlobs.soundTable[sfxIndex].flags =
					 globs::sound3DGlobs.soundTable[sfxIndex].flags | (SAMPLE_ISUSED|SAMPLE_VOLUME);
			return sfxIndex;
		}
	}
	return -1;
}



BOOL __cdecl lego::snd::Sound3D_GetFreeSoundIndex(uint *out_soundTableIndex)
{
	SampleFlags *pSVar1;
	uint uVar2;
	
	uVar2 = 0;
	pSVar1 = &globs::sound3DGlobs.soundTable[0].flags;
	do {
		if ((*(byte *)pSVar1 & 1) == 0) {
			*out_soundTableIndex = uVar2;
			return 1;
		}
		pSVar1 = pSVar1 + 0x4d;
		uVar2 = uVar2 + 1;
	} while (pSVar1 < globs::fileGlobs.wadBasePath + 8);
	return 0;
}



BOOL __cdecl lego::snd::Sound3D_Remove(int soundTableIndex)
{
	WAVEFORMATEX *hMem;
	IDirectSoundBuffer *This;
	IDirectSoundBuffer **ppIVar1;
	int iVar2;
	
	if ((globs::sound3DGlobs.intialised != 0) && (soundTableIndex != -1)) {
		hMem = globs::sound3DGlobs.soundTable[soundTableIndex].waveFormat;
		globs::sound3DGlobs.soundTable[soundTableIndex].flags =
				 globs::sound3DGlobs.soundTable[soundTableIndex].flags & ~SAMPLE_ISUSED;
		if (hMem != (WAVEFORMATEX *)0x0) {
			GlobalFree(hMem);
			globs::sound3DGlobs.soundTable[soundTableIndex].waveFormat = (WAVEFORMATEX *)0x0;
		}
		ppIVar1 = globs::sound3DGlobs.soundTable[soundTableIndex].dSoundBuffers;
		iVar2 = 3;
		do {
			This = *ppIVar1;
			if (This != (IDirectSoundBuffer *)0x0) {
				(*This->lpVtbl->Release)((IUnknown *)This);
				*ppIVar1 = (IDirectSoundBuffer *)0x0;
			}
			ppIVar1 = ppIVar1 + 1;
			iVar2 = iVar2 + -1;
		} while (iVar2 != 0);
		return 1;
	}
	return 0;
}



void __cdecl lego::snd::Sound3D_MakeListener(IDirect3DRMFrame3 *frame)
{
	if (globs::sound3DGlobs.intialised != 0) {
		globs::sound3DGlobs.listenerFrame = frame;
	}
	return;
}



void __cdecl lego::snd::Sound3D_UpdateListener(void)
{
	if ((globs::sound3DGlobs.intialised != 0) &&
		 (globs::sound3DGlobs.listenerFrame != (IDirect3DRMFrame3 *)0x0)) {
		Sound3D_ListenerCallback(globs::sound3DGlobs.listenerFrame,(void *)0x0,0.0);
	}
	return;
}



void __cdecl lego::snd::Sound3D_ListenerCallback(IDirect3DRMFrame3 *obj,void *arg,float delta)
{
	IDirect3DRMFrame3 *This;
	BOOL BVar1;
	bool bVar2;
	Vector3F local_18;
	Vector3F local_c;
	
	This = obj;
	(*obj->lpVtbl->GetScene)(obj,&obj);
	(*This->lpVtbl->GetPosition)(This,obj,&local_18);
	BVar1 = Sound3D_D3DVectorEqual(&local_18,&globs::sound3DGlobs.s_ListenerCallback_oldPos);
	bVar2 = BVar1 == 0;
	if (bVar2) {
										// IDirectSound3DListener->SetPosition(float x, float y, float z, DWORD dwApply)
		(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetPosition)
							(globs::sound3DGlobs.lp3DListenerInfo,local_18.x,local_18.y,local_18.z,1);
		globs::sound3DGlobs.s_ListenerCallback_oldPos.x = local_18.x;
		globs::sound3DGlobs.s_ListenerCallback_oldPos.y = local_18.y;
		globs::sound3DGlobs.s_ListenerCallback_oldPos.z = local_18.z;
	}
	(*This->lpVtbl->GetOrientation)(This,obj,&local_18,&local_c);
	BVar1 = Sound3D_D3DVectorEqual(&local_18,&globs::sound3DGlobs.s_ListenerCallback_oldOrien);
	if (BVar1 != 0) {
		BVar1 = Sound3D_D3DVectorEqual(&local_c,&globs::sound3DGlobs.s_ListenerCallback_oldOrienUp);
		if (BVar1 != 0) goto LAB_0047afa5;
	}
	(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetOrientation)
						(globs::sound3DGlobs.lp3DListenerInfo,local_18.x,local_18.y,local_18.z,local_c.x,
						 local_c.y,local_c.z,1);
	globs::sound3DGlobs.s_ListenerCallback_oldOrien.x = local_18.x;
	globs::sound3DGlobs.s_ListenerCallback_oldOrien.y = local_18.y;
	globs::sound3DGlobs.s_ListenerCallback_oldOrien.z = local_18.z;
	globs::sound3DGlobs.s_ListenerCallback_oldOrienUp.x = local_c.x;
	globs::sound3DGlobs.s_ListenerCallback_oldOrienUp.y = local_c.y;
	globs::sound3DGlobs.s_ListenerCallback_oldOrienUp.z = local_c.z;
	bVar2 = true;
LAB_0047afa5:
	if (bVar2) {
		(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->CommitDeferredSettings)
							(globs::sound3DGlobs.lp3DListenerInfo);
	}
	(*obj->lpVtbl->Release)(obj);
	return;
}



void __cdecl
lego::snd::Sound3D_SetWorldPos(IDirectSound3DBuffer *sound3DBuff,Vector3F *wPos,Vector3F *vel)
{
										// IDirectSound3DBuffer->SetPosition(float x, float y, float z, DWORD dwApply)
	(*(code *)sound3DBuff->lpVtbl->SetPosition)(sound3DBuff,wPos->x,wPos->y,wPos->z,0);
	return;
}



BOOL __cdecl
lego::snd::Sound3D_CheckAlreadyExists(IDirect3DRMFrame3 *frame,IDirectSound3DBuffer *sound3DBuff)
{
	Sound3D_SoundRecord *pSVar1;
	
	pSVar1 = globs::sound3DGlobs.soundRecord;
	if (globs::sound3DGlobs.soundRecord == (Sound3D_SoundRecord *)0x0) {
		return (BOOL)(Sound3D_SoundRecord *)0x0;
	}
	do {
		if (sound3DBuff == pSVar1->sound3DBuff) {
			Sound3D_RemoveSound(pSVar1->frame,pSVar1->sound3DBuff);
			return (BOOL)(Sound3D_SoundRecord *)0x1;
		}
		pSVar1 = pSVar1->next;
	} while (pSVar1 != (Sound3D_SoundRecord *)0x0);
	return (BOOL)pSVar1;
}



int __cdecl
lego::snd::Sound3D_Play2
					(Sound3DPlayMode mode,IDirect3DRMFrame3 *frame,int soundTableIndex,BOOL loop,
					Vector3F *opt_wPos)
{
	SampleFlags SVar1;
	char *filename;
	FILE *stream;
	BOOL BVar2;
	IDirect3DRMFrame3 *This;
	uint uVar3;
	int *unaff_EBP;
	IDirectSound3DBuffer *unaff_ESI;
	char *fName;
	IDirectSound3DBuffer *soundBuff;
	float rvZ;
	undefined4 uVar4;
	IDirectSound3DBuffer *sound3DBuff;
	IDirectSound3DBuffer *local_118;
	IDirect3DRMFrame3 *local_114;
	Vector3F local_110;
	char local_104 [244];
	IDirect3DRMFrame3 *pIStack16;
	int iStack8;
	
	fName = (char *)0x0;
	if ((globs::sound3DGlobs.intialised != 0) && (soundTableIndex != -1)) {
		SVar1 = globs::sound3DGlobs.soundTable[soundTableIndex].flags;
		if ((SVar1 & SAMPLE_VOLUME) != SAMPLE_NONE) {
			if ((SVar1 & SAMPLE_STREAMED) == SAMPLE_NONE) {
				if ((SVar1 & SAMPLE_MULTIPLE) == SAMPLE_NONE) {
					soundBuff = (IDirectSound3DBuffer *)
											globs::sound3DGlobs.soundTable[soundTableIndex].dSoundBuffers[0];
				}
				else {
					uVar3 = globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex + 1;
					globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex = uVar3;
					if (2 < uVar3) {
						globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex = 0;
					}
					soundBuff = *(IDirectSound3DBuffer **)
											 (soundTableIndex * 0x134 + 0x5077b8 +
											 globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex * 4);
				}
				(*soundBuff->lpVtbl->QueryInterface)
									((IUnknown *)soundBuff,(IID *)&idl::IID_IDirectSound3DBuffer,&local_118);
				This = (IDirect3DRMFrame3 *)globs::sound3DGlobs.soundTable[soundTableIndex].volume;
				if (mode == SOUND3D_PLAY_NORMAL) {
					This = This + -200;
				}
				sound3DBuff = soundBuff;
				(*(code *)soundBuff->lpVtbl->SetConeOutsideVolume)();
				uVar4 = 1;
										// IDirectSound3DBuffer->SetMinDistance(float flMinDistance, DWORD dwApply)
				rvZ = globs::sound3DGlobs.minDistanceForAttentuation;
				(**(code **)(*unaff_EBP + 0x44))(unaff_EBP,globs::sound3DGlobs.minDistanceForAttentuation,1)
				;
										// IDirectSound3DBuffer->SetMaxDistance(float flMaxDistance, DWORD dwApply)
				(*This->lpVtbl->AddScale)
									(This,(D3DRMCombineType)globs::sound3DGlobs.maxDistance,1.401298e-45,
									 (float)unaff_EBP,rvZ);
				if (mode == SOUND3D_PLAY_ONFRAME) {
										// IDirectSound3DBuffer->SetMode(DWORD dwMode, DWORD dwApply)
										//  (dwMode = DS3DMODE_NORMAL (0x0), dwApply = TRUE (0x1))
					(*(code *)unaff_ESI->lpVtbl->SetMode)(unaff_ESI,0,1);
										// IDirect3DRMFrame3->GetScene(this, IDirect3DRMFrame3** lplpRoot)
										//  (this = param_2 (rmFrame3), lplpRoot => local_114)
					(*pIStack16->lpVtbl->GetScene)(pIStack16,(IDirect3DRMFrame3 **)&stack0xfffffed4);
					Sound3D_CheckAlreadyExists(pIStack16,sound3DBuff);
					res::Sound3D_AttachSound(pIStack16,sound3DBuff);
					Sound3D_AddSoundRecord(pIStack16,(IDirectSoundBuffer *)soundBuff,sound3DBuff);
										// IDirect3DRMFrame3->GetPosition(this, IDirect3DRMFrame3* lpRef, Vector3F*
										// lprvPos)
										//  (this = param_2 (rmFrame3), lpRef = GetScene)
					(*pIStack16->lpVtbl->GetPosition)(pIStack16,This,(Vector3F *)&stack0xfffffed8);
										// IDirectSound3DBuffer->SetPosition(float x, float y, float z, DWORD dwApply)
					(**(code **)(*(int *)mode + 0x4c))(mode,uVar4,sound3DBuff,This,1);
										// IDirect3DRMFrame3->Release(this)
										//  (this = GetScene)
					(*pIStack16->lpVtbl->Release)((IUnknown *)pIStack16);
				}
				else {
					if (mode == SOUND3D_PLAY_ONPOS) {
										// IDirectSound3DBuffer->SetMode(DWORD dwMode, DWORD dwApply)
										//  (dwMode = DS3DMODE_NORMAL (0x0), dwApply = TRUE (0x1))
						(*(code *)unaff_ESI->lpVtbl->SetMode)(unaff_ESI,0,1);
						Sound3D_SetWorldPos(unaff_ESI,(Vector3F *)frame,(Vector3F *)0x0);
						Sound3D_CheckAlreadyExists((IDirect3DRMFrame3 *)0x0,unaff_ESI);
					}
					else {
						if (mode != SOUND3D_PLAY_NORMAL) goto LAB_0047b26d;
										// IDirectSound3DBuffer->SetMode(DWORD dwMode, DWORD dwApply)
										//  (dwMode = DS3DMODE_DISABLE (0x2), dwApply = TRUE (0x1))
						(*(code *)unaff_ESI->lpVtbl->SetMode)(unaff_ESI,2,1);
						Sound3D_CheckAlreadyExists((IDirect3DRMFrame3 *)0x0,unaff_ESI);
					}
					Sound3D_AddSoundRecord((IDirect3DRMFrame3 *)0x0,(IDirectSoundBuffer *)soundBuff,unaff_ESI)
					;
				}
LAB_0047b26d:
				(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->CommitDeferredSettings)
									(globs::sound3DGlobs.lp3DListenerInfo);
				(*(code *)soundBuff->lpVtbl->SetConeAngles)(soundBuff,0);
				if (iStack8 != 0) {
					(*(code *)soundBuff->lpVtbl->SetAllParameters)(soundBuff,0,0,1);
					return soundTableIndex * 3 + globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex;
				}
				(*(code *)soundBuff->lpVtbl->SetAllParameters)(soundBuff,0,0,0);
				return soundTableIndex * 3 + globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex;
			}
			filename = lego::file::File_VerifyFilename
													 ((char *)(globs::sound3DGlobs.soundTable + soundTableIndex));
			stream = std::fopen(filename,"r");
			if (stream == (FILE *)0x0) {
				BVar2 = lego::file::File_GetCDFilePath
													(local_104,(char *)(globs::sound3DGlobs.soundTable + soundTableIndex));
				if (BVar2 != 0) {
					fName = local_104;
				}
			}
			else {
				std::fclose(stream);
				fName = filename;
			}
			if (fName != (char *)0x0) {
				Sound3D_Stream_Play(fName,loop,globs::sound3DGlobs.soundTable[soundTableIndex].volume);
				return soundTableIndex * 3;
			}
		}
	}
	return -1;
}



void __cdecl
lego::snd::Sound3D_AddSoundRecord
					(IDirect3DRMFrame3 *frame,IDirectSoundBuffer *soundBuff,IDirectSound3DBuffer *sound3DBuff)
{
	Sound3D_SoundRecord *pSVar1;
	
	pSVar1 = (Sound3D_SoundRecord *)std::malloc(0x10);
	pSVar1->next = globs::sound3DGlobs.soundRecord;
	pSVar1->frame = frame;
	pSVar1->sound3DBuff = sound3DBuff;
	pSVar1->soundBuff = soundBuff;
	globs::sound3DGlobs.soundRecord = pSVar1;
	return;
}



void __cdecl lego::snd::Sound3D_SetBufferVolume(int handle,int newvolume)
{
	byte bVar1;
	IDirectSoundBuffer *pIVar2;
	BOOL BVar3;
	uint uVar4;
	int iVar5;
	IDirectSoundBuffer **ppIVar6;
	
	BVar3 = Sound3D_CheckVolumeLimits(newvolume);
	bVar1 = *(byte *)&globs::sound3DGlobs.soundTable[handle].flags;
	uVar4 = -(uint)(BVar3 != 0) & newvolume;
	globs::sound3DGlobs.soundTable[handle].volume = uVar4;
	if ((bVar1 & 4) != 0) {
		ppIVar6 = globs::sound3DGlobs.soundTable[handle].dSoundBuffers;
		iVar5 = 3;
		do {
			pIVar2 = *ppIVar6;
			if (pIVar2 != (IDirectSoundBuffer *)0x0) {
				(*(code *)pIVar2->lpVtbl->SetVolume)(pIVar2,globs::sound3DGlobs.soundTable[handle].volume);
			}
			ppIVar6 = ppIVar6 + 1;
			iVar5 = iVar5 + -1;
		} while (iVar5 != 0);
		return;
	}
	pIVar2 = globs::sound3DGlobs.soundTable[handle].dSoundBuffers[0];
	if (pIVar2 != (IDirectSoundBuffer *)0x0) {
		(*(code *)pIVar2->lpVtbl->SetVolume)(pIVar2,uVar4);
	}
	return;
}



int __cdecl lego::snd::Sound3D_GetBufferVolume(int handle)
{
	return globs::sound3DGlobs.soundTable[handle].volume;
}



IDirectSoundBuffer * __cdecl lego::snd::Sound3D_GetSoundBuffer(int soundHandle)
{
	if (soundHandle == -1) {
		return (IDirectSoundBuffer *)0x0;
	}
										// globals::g_SampleDatas_TABLE[sfxType / 3].dSoundBuffers[sfxType % 3]
	return *(IDirectSoundBuffer **)
					((soundHandle % 3) * 4 + 0x5077b8 + ((uint)(soundHandle - soundHandle % 3) / 3) * 0x134);
}



void __cdecl lego::snd::Sound3D_StopSound(int soundHandle)
{
	IDirectSoundBuffer *dSoundBuffer;
	
	dSoundBuffer = Sound3D_GetSoundBuffer(soundHandle);
	if (((globs::sound3DGlobs.intialised != 0) && (soundHandle != -1)) &&
		 (dSoundBuffer != (IDirectSoundBuffer *)0x0)) {
		(*(code *)dSoundBuffer->lpVtbl->Stop)(dSoundBuffer);
	}
	return;
}



void __cdecl lego::snd::Sound3D_StopAllSounds(void)
{
	Sound3D_SoundRecord *pSVar1;
	
	pSVar1 = globs::sound3DGlobs.soundRecord;
	if (globs::sound3DGlobs.soundRecord != (Sound3D_SoundRecord *)0x0) {
		do {
			(*(code *)pSVar1->soundBuff->lpVtbl->Stop)(pSVar1->soundBuff);
			pSVar1 = pSVar1->next;
		} while (pSVar1 != (Sound3D_SoundRecord *)0x0);
	}
	Sound3D_Stream_Stop(FALSE);
	Sound3D_Stream_Stop(TRUE);
	return;
}



void __cdecl
lego::res::Sound3D_AttachSound(IDirect3DRMFrame3 *frame,IDirectSound3DBuffer *sound3DBuff)
{
	Container_AppData *appData;
	Sound3D_SoundFrameRecord *soundRecord;
	IDirect3DRMFrame3 **ppIVar1;
	int iVar2;
	
	appData = (Container_AppData *)(*frame->lpVtbl->GetAppData)((IUnknown *)frame);
	soundRecord = (Sound3D_SoundFrameRecord *)std::malloc(0x14);
	if (appData == (Container_AppData *)0x0) {
		soundRecord->next = (Sound3D_SoundFrameRecord *)0x0;
	}
	else {
		soundRecord->next = appData->soundList;
	}
	soundRecord->sound3DBuff = (IDirectSound3DBuffer *)frame;
	(soundRecord->pos).x = 0.0;
	(soundRecord->pos).y = 0.0;
	(soundRecord->pos).z = 0.0;
	Container_Frame_SetAppData
						(frame,(Container *)0x0,(AnimClone *)0x0,(char *)0x0,(uint *)0x0,(char *)0x0,
						 (float *)0x0,(float *)0x0,(char *)0x0,soundRecord,(uint *)0x0);
	iVar2 = 0;
	ppIVar1 = globs::sound3DGlobs.updateFrameList;
	do {
		if (*ppIVar1 == (IDirect3DRMFrame3 *)0x0) {
			globs::sound3DGlobs.updateFrameList[iVar2] = frame;
			return;
		}
		ppIVar1 = ppIVar1 + 1;
		iVar2 = iVar2 + 1;
	} while (ppIVar1 < &globs::sound3DGlobs.reserved1);
	return;
}



void __cdecl
lego::snd::Sound3D_RemoveSound(IDirect3DRMFrame3 *frame,IDirectSound3DBuffer *sound3DBuff)
{
	void *buffer;
	DWORD DVar1;
	BOOL BVar2;
	IDirect3DRMFrame3 **ppIVar3;
	IDirect3DRMFrame3 *unaff_retaddr;
	
	(*sound3DBuff->lpVtbl->Release)((IUnknown *)sound3DBuff);
	if (unaff_retaddr == (IDirect3DRMFrame3 *)0x0) {
		Sound3D_RemoveSoundRecord((IDirect3DRMFrame3 *)0x0,sound3DBuff);
		return;
	}
	DVar1 = (*unaff_retaddr->lpVtbl->GetAppData)((IUnknown *)unaff_retaddr);
	BVar2 = Sound3D_RecurseRemoveSound
										(unaff_retaddr,sound3DBuff,*(Sound3D_SoundFrameRecord **)(DVar1 + 0x24));
	if (BVar2 != 0) {
		Sound3D_RemoveSoundRecord(unaff_retaddr,sound3DBuff);
		buffer = *(void **)(DVar1 + 0x24);
		*(undefined4 *)(DVar1 + 0x24) = *(undefined4 *)((int)buffer + 0x10);
		std::free(buffer);
	}
	ppIVar3 = globs::sound3DGlobs.updateFrameList;
	do {
		if (unaff_retaddr == *ppIVar3) {
			*ppIVar3 = (IDirect3DRMFrame3 *)0x0;
		}
		ppIVar3 = ppIVar3 + 1;
	} while (ppIVar3 < &globs::sound3DGlobs.reserved1);
	return;
}



void __cdecl
lego::snd::Sound3D_RemoveSoundRecord(IDirect3DRMFrame3 *frame,IDirectSound3DBuffer *sound3DBuff)
{
	Sound3D_SoundRecord *buffer;
	BOOL BVar1;
	
	BVar1 = Sound3D_RecurseRemoveSoundRecord(frame,sound3DBuff,globs::sound3DGlobs.soundRecord);
	buffer = globs::sound3DGlobs.soundRecord;
	if (BVar1 != 0) {
		globs::sound3DGlobs.soundRecord = (globs::sound3DGlobs.soundRecord)->next;
		std::free(buffer);
	}
	return;
}



BOOL __cdecl
lego::snd::Sound3D_RecurseRemoveSoundRecord
					(IDirect3DRMFrame3 *owner,IDirectSound3DBuffer *sound3DBuff,Sound3D_SoundRecord *record)
{
	Sound3D_SoundRecord *buffer;
	BOOL BVar1;
	
	if (record == (Sound3D_SoundRecord *)0x0) {
		return 0;
	}
	BVar1 = Sound3D_RecurseRemoveSoundRecord(owner,sound3DBuff,record->next);
	if (BVar1 != 0) {
		buffer = record->next;
		record->next = buffer->next;
		std::free(buffer);
	}
	return (uint)(sound3DBuff == record->sound3DBuff);
}



BOOL __cdecl
lego::snd::Sound3D_RecurseRemoveSound
					(IDirect3DRMFrame3 *owner,IDirectSound3DBuffer *sound3DBuff,
					Sound3D_SoundFrameRecord *record)
{
	Sound3D_SoundFrameRecord *buffer;
	BOOL BVar1;
	
	if (record == (Sound3D_SoundFrameRecord *)0x0) {
		return 0;
	}
	BVar1 = Sound3D_RecurseRemoveSound(owner,sound3DBuff,record->next);
	if (BVar1 != 0) {
		Sound3D_RemoveSoundRecord(owner,sound3DBuff);
		buffer = record->next;
		record->next = buffer->next;
		std::free(buffer);
	}
	return (uint)(sound3DBuff == record->sound3DBuff);
}



void __cdecl lego::snd::Sound3D_Update(void)
{
	Sound3D_SoundRecord *pSVar1;
	uint in_ECX;
	Sound3D_SoundRecord *pSVar2;
	IDirect3DRMFrame3 **lpSndBufFrame;
	uint local_4;
	
	pSVar2 = globs::sound3DGlobs.soundRecord;
	lpSndBufFrame = globs::sound3DGlobs.updateFrameList;
	local_4 = in_ECX;
	do {
										// (inlined) Sound3D_UpdateFrames();
		if (*lpSndBufFrame != (IDirect3DRMFrame3 *)0x0) {
			Sound3D_SoundCallback(*lpSndBufFrame,(void *)0x0,0.0);
		}
		lpSndBufFrame = lpSndBufFrame + 1;
	} while (lpSndBufFrame < &globs::sound3DGlobs.reserved1);
	if (pSVar2 != (Sound3D_SoundRecord *)0x0) {
		do {
			pSVar1 = pSVar2->next;
			(*(code *)pSVar2->soundBuff->lpVtbl->GetStatus)(pSVar2->soundBuff,&local_4);
			if ((local_4 & 1) == 0) {
				Sound3D_RemoveSound(pSVar2->frame,pSVar2->sound3DBuff);
			}
			pSVar2 = pSVar1;
		} while (pSVar1 != (Sound3D_SoundRecord *)0x0);
	}
	Sound3D_Stream_CheckPosition(FALSE);
	Sound3D_Stream_CheckPosition(1);
	return;
}



void __cdecl lego::snd::Sound3D_SoundCallback(IDirect3DRMFrame3 *tFrame,void *arg,float delay)
{
	Container_AppData *appData;
	BOOL BVar1;
	Vector3F position;
	IDirect3DRMFrame3 *rmFrame3_00;
	Sound3D_SoundFrameRecord *sndRes;
	
	rmFrame3_00 = tFrame;
	appData = (*tFrame->lpVtbl->GetAppData)(tFrame);
	sndRes = appData->soundList;
	(*rmFrame3_00->lpVtbl->GetScene)(rmFrame3_00,&tFrame);
	for (; sndRes != (Sound3D_SoundFrameRecord *)0x0; sndRes = sndRes->next) {
		(*rmFrame3_00->lpVtbl->GetPosition)(rmFrame3_00,tFrame,&position);
		BVar1 = Sound3D_D3DVectorEqual(&position,&sndRes->pos);
		if (BVar1 == 0) {
										// IDirectSound3DBuffer->SetPosition(this, float x, float y, float z, DWORD
										// dwApply)
			(*(code *)sndRes->sound3DBuff->lpVtbl->SetPosition)
								(sndRes->sound3DBuff,position.x,position.y,position.z,0);
			(sndRes->pos).x = position.x;
			(sndRes->pos).y = position.y;
			(sndRes->pos).z = position.z;
		}
	}
	(*tFrame->lpVtbl->Release)(tFrame);
	return;
}



void __cdecl lego::snd::Sound3D_SetMinDistForAtten(float dist)
{
	Sound3D_SoundRecord **ppSVar1;
	Sound3D_SoundRecord *pSVar2;
	
	globs::sound3DGlobs.minDistanceForAttentuation = dist;
	pSVar2 = globs::sound3DGlobs.soundRecord;
	if (globs::sound3DGlobs.soundRecord != (Sound3D_SoundRecord *)0x0) {
		do {
			(*(code *)pSVar2->sound3DBuff->lpVtbl->SetMinDistance)(pSVar2->sound3DBuff,dist,0);
			ppSVar1 = &pSVar2->next;
			pSVar2 = *ppSVar1;
		} while (*ppSVar1 != (Sound3D_SoundRecord *)0x0);
	}
	return;
}



void __cdecl lego::snd::Sound3D_SetMaxDist(float dist)
{
	Sound3D_SoundRecord **ppSVar1;
	Sound3D_SoundRecord *pSVar2;
	
	globs::sound3DGlobs.maxDistance = dist;
	pSVar2 = globs::sound3DGlobs.soundRecord;
	if (globs::sound3DGlobs.soundRecord != (Sound3D_SoundRecord *)0x0) {
		do {
			(*(code *)pSVar2->sound3DBuff->lpVtbl->SetMaxDistance)(pSVar2->sound3DBuff,dist,0);
			ppSVar1 = &pSVar2->next;
			pSVar2 = *ppSVar1;
		} while (*ppSVar1 != (Sound3D_SoundRecord *)0x0);
	}
	return;
}



void __cdecl lego::snd::Sound3D_SetGlobalVolume(int vol)
{
	BOOL BVar1;
	
	if (globs::sound3DGlobs.intialised != 0) {
		BVar1 = Sound3D_CheckVolumeLimits(vol);
		if (BVar1 != 0) {
			globs::sound3DGlobs.volume = vol;
			(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->SetVolume)(globs::sound3DGlobs.lpDSBuff,vol)
			;
		}
	}
	return;
}



void __cdecl lego::snd::Sound3D_SetGlobalVolumePrescaled(int vol_0_10)
{
	if ((-1 < vol_0_10) && (vol_0_10 < 0xb)) {
		Sound3D_SetGlobalVolume(globs::s_SetGlobalVolumePrescaled_realVol[vol_0_10]);
	}
	return;
}



void __cdecl lego::snd::Sound3D_SetVolumeToDefault(void)
{
	if (globs::sound3DGlobs.intialised != 0) {
		globs::sound3DGlobs.volume = -300;
		(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->SetVolume)(globs::sound3DGlobs.lpDSBuff,-NAN);
	}
	return;
}



BOOL __cdecl
lego::snd::Sound3D_LoadSample(Sound3D_SoundData *out_sound,char *fName,BOOL simultaneous)
{
	Sound3D_SoundData *sound;
	byte *fileData;
	byte *pbDest;
	BOOL BVar1;
	int iVar2;
	Sound3D_SoundData *pSVar3;
	uint local_2c;
	MMCKINFO local_28;
	MMCKINFO local_14;
	
	sound = out_sound;
	pSVar3 = out_sound;
	for (iVar2 = 0x4d; iVar2 != 0; iVar2 = iVar2 + -1) {
		*(undefined4 *)pSVar3->filename = 0;
		pSVar3 = (Sound3D_SoundData *)(pSVar3->filename + 4);
	}
	fileData = lego::file::File_LoadBinary(fName,(uint *)&fName);
	if (fileData != (byte *)0x0) {
		iVar2 = WaveOpenFile(fileData,(uint)fName,(HMMIO *)&out_sound,&sound->waveFormat,&local_14);
		if (iVar2 == 0) {
			iVar2 = WaveStartDataRead((HMMIO *)&out_sound,&local_28,&local_14);
			if (iVar2 == 0) {
				pbDest = (byte *)GlobalAlloc(0,local_28.cksize);
				sound->data = pbDest;
				if (pbDest != (byte *)0x0) {
					iVar2 = WaveReadFile((HMMIO)out_sound,local_28.cksize,pbDest,&local_28,&local_2c);
					if (iVar2 == 0) {
						sound->size = local_2c;
						if (out_sound != (Sound3D_SoundData *)0x0) {
							mmioClose((HMMIO)out_sound,0);
							out_sound = (Sound3D_SoundData *)0x0;
						}
						BVar1 = Sound3D_CreateSoundBuffer(sound);
						if (BVar1 != 0) {
							BVar1 = Sound3D_SendSoundToBuffer(sound);
							if (BVar1 != 0) {
								if (sound->data != (byte *)0x0) {
									GlobalFree(sound->data);
									sound->data = (byte *)0x0;
								}
								std::free(fileData);
								return 1;
							}
						}
					}
				}
			}
		}
	}
	if (sound->data != (byte *)0x0) {
		GlobalFree(sound->data);
		sound->data = (byte *)0x0;
	}
	return 0;
}



BOOL __cdecl lego::snd::Sound3D_CreateSoundBuffer(Sound3D_SoundData *sound)
{
	int iVar1;
	IDirectSoundBuffer **ppIVar2;
	uint uVar3;
	undefined4 local_14;
	undefined4 local_10;
	uint local_c;
	int local_8;
	WAVEFORMATEX *local_4;
	
	local_4 = sound->waveFormat;
	local_c = sound->size;
	local_8 = 0;
	local_14 = 0x14;
	local_10 = 0x200f2;
	iVar1 = (*(code *)(globs::sound3DGlobs.lpDSnd)->lpVtbl->CreateSoundBuffer)
										(globs::sound3DGlobs.lpDSnd,&local_14,sound->dSoundBuffers,0);
	if (iVar1 != 0) {
		return 0;
	}
	sound->bufferIndex = 0;
	if (local_8 != 0) {
		uVar3 = 1;
		ppIVar2 = sound->dSoundBuffers;
		do {
			ppIVar2 = ppIVar2 + 1;
			iVar1 = (*(code *)(globs::sound3DGlobs.lpDSnd)->lpVtbl->DuplicateSoundBuffer)
												(globs::sound3DGlobs.lpDSnd,sound->dSoundBuffers[0],ppIVar2);
			if (iVar1 != 0) {
				return 0;
			}
			uVar3 = uVar3 + 1;
		} while (uVar3 < 3);
		return TRUE;
	}
	return TRUE;
}



BOOL __cdecl lego::snd::Sound3D_SendSoundToBuffer(Sound3D_SoundData *sound)
{
	Sound3D_SoundData *pSVar1;
	int iVar2;
	uint uVar3;
	Sound3D_SoundData *pSVar4;
	undefined4 *puVar5;
	Sound3D_SoundData **ppSVar6;
	undefined4 *puVar7;
	uint uStack48;
	undefined *puStack44;
	undefined4 *puStack40;
	Sound3D_SoundData **ppSStack36;
	undefined4 *puStack32;
	undefined4 *puStack28;
	undefined4 local_c;
	undefined4 local_8;
	undefined local_4 [4];
	
	pSVar1 = sound;
	puStack32 = &local_8;
	puStack28 = (undefined4 *)0x0;
	ppSStack36 = &sound;
	puStack40 = &local_c;
	local_c = 0;
	puStack44 = local_4;
	uStack48 = sound->size;
	local_8 = 0;
	iVar2 = (*(code *)sound->dSoundBuffers[0]->lpVtbl->Lock)(sound->dSoundBuffers[0],sound->offset);
	if (iVar2 == -0x7787ff6a) {
		(*(code *)pSVar1->dSoundBuffers[0]->lpVtbl->Restore)(pSVar1->dSoundBuffers[0]);
		(*(code *)pSVar1->dSoundBuffers[0]->lpVtbl->Lock)
							(pSVar1->dSoundBuffers[0],pSVar1->offset,pSVar1->size,&puStack40,&uStack48,&puStack32,
							 &puStack44,0);
	}
	else {
		if (iVar2 != 0) {
			return 0;
		}
	}
	pSVar4 = (Sound3D_SoundData *)pSVar1->data;
	ppSVar6 = ppSStack36;
	for (uVar3 = (uint)puStack44 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
		*ppSVar6 = *(Sound3D_SoundData **)pSVar4;
		pSVar4 = (Sound3D_SoundData *)((int)pSVar4 + 4);
		ppSVar6 = ppSVar6 + 1;
	}
	for (uVar3 = (uint)puStack44 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
		*(undefined *)ppSVar6 = *(undefined *)pSVar4;
		pSVar4 = (Sound3D_SoundData *)((int)pSVar4 + 1);
		ppSVar6 = (Sound3D_SoundData **)((int)ppSVar6 + 1);
	}
	if (puStack28 != (undefined4 *)0x0) {
		puVar5 = (undefined4 *)(puStack44 + (int)pSVar1->data);
		puVar7 = puStack28;
		for (uVar3 = (uint)puStack40 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
			*puVar7 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar7 = puVar7 + 1;
		}
		for (uVar3 = (uint)puStack40 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
			*(undefined *)puVar7 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar7 = (undefined4 *)((int)puVar7 + 1);
		}
	}
	iVar2 = (*(code *)pSVar1->dSoundBuffers[0]->lpVtbl->Unlock)
										(pSVar1->dSoundBuffers[0],ppSStack36,puStack44,puStack28,puStack40);
	if (iVar2 == 0) {
		iVar2 = (*(code *)pSVar1->dSoundBuffers[0]->lpVtbl->GetFrequency)
											(pSVar1->dSoundBuffers[0],&pSVar1->frequency);
		if (iVar2 == 0) {
			iVar2 = (*(code *)pSVar1->dSoundBuffers[0]->lpVtbl->GetVolume)
												(pSVar1->dSoundBuffers[0],&pSVar1->volume);
			return (uint)(iVar2 == 0);
		}
		return 0;
	}
	return 0;
}



float10 __cdecl lego::snd::Sound3D_GetSamplePlayTime(int handle)
{
	uint uVar1;
	
	if (handle == -1) {
		return (float10)0.0;
	}
	uVar1 = globs::sound3DGlobs.soundTable[handle].size;
	if ((*(byte *)&globs::sound3DGlobs.soundTable[handle].flags & 8) != 0) {
		return (float10)(ulonglong)uVar1 /
					 (float10)globs::sound3DGlobs.soundTable[handle].avgBytesPerSec;
	}
	return (float10)(ulonglong)uVar1 /
				 (float10)(globs::sound3DGlobs.soundTable[handle].waveFormat)->nAvgBytesPerSec;
}



BOOL __cdecl lego::snd::Sound3D_Stream_Play(char *fName,BOOL loop,int volume)
{
	BOOL BVar1;
	IDirectSoundBuffer *pIVar2;
	Sound3D_StreamData *pSVar3;
	
	pSVar3 = &globs::sound3DGlobs.loopStreamData;
	if (loop == 0) {
		pSVar3 = &globs::sound3DGlobs.streamData;
	}
	if ((pSVar3->playing != 0) || (pSVar3->fileOpen != 0)) {
		Sound3D_Stream_Stop(loop);
	}
	BVar1 = Sound3D_Stream_BufferSetup(fName,loop,volume);
	if (BVar1 != 0) {
		pIVar2 = globs::sound3DGlobs.lpDSStreamBuff;
		if (loop != 0) {
			pIVar2 = globs::sound3DGlobs.lpDSLoopStreamBuff;
		}
		(*(code *)pIVar2->lpVtbl->SetCurrentPosition)(pIVar2,0);
		pIVar2 = globs::sound3DGlobs.lpDSStreamBuff;
		if (loop != 0) {
			pIVar2 = globs::sound3DGlobs.lpDSLoopStreamBuff;
		}
										// DSBPLAY_LOOPING (0x1)
		(*(code *)pIVar2->lpVtbl->Play)(pIVar2,0,0,1);
		pSVar3->playing = 1;
		return TRUE;
	}
	pSVar3->playing = 0;
	return 0;
}



BOOL __cdecl lego::snd::Sound3D_Stream_Stop(BOOL looping)
{
	IDirectSoundBuffer *pIVar1;
	Sound3D_StreamData *pSVar2;
	
	pSVar2 = &globs::sound3DGlobs.loopStreamData;
	if (looping == 0) {
		pSVar2 = &globs::sound3DGlobs.streamData;
	}
	pSVar2->playing = 0;
	if (pSVar2->fileOpen != 0) {
		pIVar1 = globs::sound3DGlobs.lpDSStreamBuff;
		if (looping != 0) {
			pIVar1 = globs::sound3DGlobs.lpDSLoopStreamBuff;
		}
		(*(code *)pIVar1->lpVtbl->Stop)(pIVar1);
		WaveCloseReadFile(&(pSVar2->wiWave).hmmio,(WAVEFORMATEX **)&pSVar2->wiWave);
		pIVar1 = globs::sound3DGlobs.lpDSStreamBuff;
		if (looping != 0) {
			pIVar1 = globs::sound3DGlobs.lpDSLoopStreamBuff;
		}
		(*pIVar1->lpVtbl->Release)((IUnknown *)pIVar1);
		pSVar2->fileOpen = 0;
	}
	return 1;
}



BOOL __cdecl lego::snd::Sound3D_Stream_BufferSetup(char *waveFName,BOOL loop,int volume)
{
	MMCKINFO *out_pckInRIFF;
	Sound3D_WaveData *out_ppwfxInfo;
	HMMIO *out_phmmioIn;
	WAVEFORMATEX *pWVar1;
	DWORD looping;
	int iVar2;
	uint uVar3;
	Sound3D_StreamData *pSVar4;
	DSBUFFERDESC sndBuffer;
	
	pSVar4 = &globs::sound3DGlobs.loopStreamData;
	if (loop == 0) {
		pSVar4 = &globs::sound3DGlobs.streamData;
	}
	out_pckInRIFF = &(pSVar4->wiWave).mmckInRIFF;
	out_ppwfxInfo = &pSVar4->wiWave;
	out_phmmioIn = &(pSVar4->wiWave).hmmio;
	iVar2 = WaveOpenFile2(waveFName,out_phmmioIn,(WAVEFORMATEX **)out_ppwfxInfo,out_pckInRIFF);
	if (iVar2 != 0) {
		return 0;
	}
	if (out_ppwfxInfo->waveFormat->wFormatTag != WAVE_FORMAT_PCM) {
		WaveCloseReadFile(out_phmmioIn,(WAVEFORMATEX **)out_ppwfxInfo);
		return 0;
	}
	iVar2 = WaveStartDataRead(out_phmmioIn,&(pSVar4->wiWave).mmck,out_pckInRIFF);
	if (iVar2 == 0) {
		pWVar1 = out_ppwfxInfo->waveFormat;
		uVar3 = pWVar1->nSamplesPerSec * (uint)pWVar1->nBlockAlign * 3 >> 2;
		(pSVar4->wiWave).dwNotifySize = uVar3;
		uVar3 = uVar3 % (uint)pWVar1->nBlockAlign;
		if (uVar3 != 0) {
			(pSVar4->wiWave).dwNotifySize = (pSVar4->wiWave).dwNotifySize + (pWVar1->nBlockAlign - uVar3);
		}
		sndBuffer.dwSize = 0x14;
		sndBuffer.dwFlags = 0x100e0;
		sndBuffer.dwBufferBytes = (pSVar4->wiWave).dwNotifySize << 2;
		sndBuffer.dwReserved = 0;
		(pSVar4->wiWave).dwBufferSize = sndBuffer.dwBufferBytes;
		sndBuffer.lpwfxFormat = out_ppwfxInfo->waveFormat;
		iVar2 = (*(code *)(globs::sound3DGlobs.lpDSnd)->lpVtbl->CreateSoundBuffer)
											(globs::sound3DGlobs.lpDSnd,&sndBuffer,&waveFName,0);
		looping = sndBuffer.dwReserved;
		if (iVar2 == 0) {
			if (sndBuffer.dwReserved == 0) {
				globs::sound3DGlobs.lpDSStreamBuff = (IDirectSoundBuffer *)sndBuffer.dwBufferBytes;
			}
			else {
				globs::sound3DGlobs.lpDSLoopStreamBuff = (IDirectSoundBuffer *)sndBuffer.dwBufferBytes;
			}
			(**(code **)(*(int *)sndBuffer.dwBufferBytes + 0x3c))
								(sndBuffer.dwBufferBytes,sndBuffer.lpwfxFormat);
			(pSVar4->wiWave).bFoundEnd = 0;
			(pSVar4->wiWave).dwNextWriteOffset = 0;
			(pSVar4->wiWave).dwNextProgressCheck = (pSVar4->wiWave).dwNotifySize << 1;
			(pSVar4->wiWave).bLoopFile = looping;
			Sound3D_Stream_FillDataBuffer(looping);
			(pSVar4->wiWave).bDonePlaying = 0;
			pSVar4->fileOpen = 1;
			return 1;
		}
		return 0;
	}
	WaveCloseReadFile(out_phmmioIn,(WAVEFORMATEX **)out_ppwfxInfo);
	return 0;
}



BOOL __cdecl lego::snd::Sound3D_Stream_FillDataBuffer(BOOL looping)
{
	MMCKINFO *pckIn;
	HMMIO *phmmioIn;
	undefined2 uVar1;
	int iVar2;
	uint uVar3;
	IDirectSoundBuffer *pIVar4;
	undefined *puVar5;
	uint uVar6;
	char cVar7;
	int unaff_EBP;
	int iVar8;
	uint *puVar9;
	undefined *puStack44;
	undefined4 uStack40;
	undefined local_14 [4];
	undefined local_10 [8];
	undefined local_8 [4];
	uint local_4;
	
	iVar8 = 0x507628;
	if (looping == 0) {
		iVar8 = 0x5075cc;
	}
	pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
	if (looping != 0) {
		pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
	}
	puStack44 = local_8;
	uStack40 = 0;
	iVar2 = (*(code *)pIVar4->lpVtbl->Lock)(pIVar4,0,*(undefined4 *)(iVar8 + 0x34),local_10);
	if (iVar2 != 0) {
		return 0;
	}
	pckIn = (MMCKINFO *)(iVar8 + 0xc);
	phmmioIn = (HMMIO *)(iVar8 + 8);
	WaveReadFile(*phmmioIn,(uint)local_14,(byte *)&local_4,pckIn,(uint *)&puStack44);
	if (puStack44 < local_14) {
		puVar5 = puStack44;
		iVar2 = unaff_EBP;
		if (*(int *)(iVar8 + 0x50) == 0) {
			if (puStack44 < *(undefined **)(iVar8 + 0x38)) {
				*(undefined4 *)(iVar8 + 0x54) = 1;
			}
			puVar5 = local_14 + -(int)puStack44;
			cVar7 = (*(short *)(*(int *)(iVar8 + 4) + 0xe) != 8) + -1;
			uVar1 = CONCAT11(cVar7,cVar7);
			uVar3 = CONCAT22(uVar1,uVar1) & 0x80808080;
			puVar9 = (uint *)((int)&local_4 + (int)puStack44);
			for (uVar6 = (uint)puVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
				*puVar9 = uVar3;
				puVar9 = puVar9 + 1;
			}
			for (uVar6 = (uint)puVar5 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
				*(char *)puVar9 = (char)uVar3;
				puVar9 = (uint *)((int)puVar9 + 1);
			}
		}
		else {
			do {
				looping = iVar2;
				WaveStartDataRead(phmmioIn,pckIn,(MMCKINFO *)(iVar8 + 0x20));
				WaveReadFile(*phmmioIn,(uint)(local_14 + -(int)puVar5),puVar5 + (int)&local_4,pckIn,
										 (uint *)&puStack44);
				puVar5 = puVar5 + (int)puStack44;
				iVar2 = looping;
			} while (puVar5 < local_14);
		}
	}
	pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
	if (looping != 0) {
		pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
	}
	iVar2 = 0;
	(*(code *)pIVar4->lpVtbl->Unlock)(pIVar4,&local_4,local_14,0);
	uVar3 = *(uint *)(iVar8 + 0x34);
	uVar6 = *(int *)(iVar8 + 0x3c) + iVar2;
	*(uint *)(iVar8 + 0x3c) = uVar6;
	if (uVar3 <= uVar6) {
		*(uint *)(iVar8 + 0x3c) = uVar6 - uVar3;
		uVar6 = uVar3;
	}
	*(undefined4 *)(iVar8 + 0x40) = 0;
	*(undefined4 *)(iVar8 + 0x48) = 0;
	return uVar6;
}



void __cdecl lego::snd::Sound3D_Stream_CheckPosition(BOOL looping)
{
	MMCKINFO *pckIn;
	HMMIO *phmmioIn;
	byte bVar1;
	void *pvVar2;
	HRESULT HVar3;
	IDirectSoundBuffer *pIVar4;
	uint uVar5;
	uint unaff_EBX;
	uint *unaff_EBP;
	uint unaff_ESI;
	Sound3D_StreamData *pSVar6;
	uint uVar7;
	uint *puVar8;
	DWORD local_18;
	void *local_14;
	undefined4 local_10;
	uint local_c;
	int local_8;
	DWORD local_4;
	
	pSVar6 = &globs::sound3DGlobs.loopStreamData;
	if (looping == 0) {
		pSVar6 = &globs::sound3DGlobs.streamData;
	}
	if ((pSVar6->playing != 0) && (pSVar6->fileOpen != 0)) {
		pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
		if (looping != 0) {
			pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
		}
										// IDirectSoundBuffer->GetCurrentPosition(this, DWORD* pdwCurrentPlayCursor,
										// DWORD* pdwCurrentWriteCursor)
		(*(code *)pIVar4->lpVtbl->GetCurrentPosition)(pIVar4,&local_c,&local_4);
		uVar7 = (pSVar6->wiWave).dwLastPos;
		uVar5 = local_c;
		if (local_c < uVar7) {
			uVar5 = (pSVar6->wiWave).dwBufferSize + local_c;
		}
		uVar7 = (pSVar6->wiWave).dwProgress + (uVar5 - uVar7);
		(pSVar6->wiWave).dwLastPos = local_c;
		(pSVar6->wiWave).dwProgress = uVar7;
		pvVar2 = (void *)0x0;
		if ((pSVar6->wiWave).dwNextProgressCheck < uVar7) {
			while ((local_10 = 0, (pSVar6->wiWave).bDonePlaying == 0 || (pvVar2 != (void *)0x0))) {
				local_8 = 1;
				if ((pSVar6->wiWave).bFoundEnd == 0) {
					pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
					if (looping != 0) {
						pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
					}
										// IDirectSoundBuffer->Lock(this, DWORD dwOffset, DWORD dwBytes, void**
										// ppvAudioPtr1, DWORD* pdwAudioBytes1)
					HVar3 = (*(code *)pIVar4->lpVtbl->Lock)
														(pIVar4,(pSVar6->wiWave).dwNextWriteOffset,(pSVar6->wiWave).dwNotifySize
														 ,&local_14,&local_18);
					if (HVar3 != 0) {
						return;
					}
					pckIn = &(pSVar6->wiWave).mmck;
					phmmioIn = &(pSVar6->wiWave).hmmio;
					WaveReadFile(*phmmioIn,unaff_ESI,(byte *)unaff_EBP,pckIn,(uint *)&stack0xffffffe4);
					uVar7 = unaff_EBX;
					if (unaff_EBX < unaff_ESI) {
						if ((pSVar6->wiWave).bLoopFile == 0) {
							(pSVar6->wiWave).bFoundEnd = 1;
							bVar1 = (((pSVar6->wiWave).waveFormat)->wBitsPerSample != 8) - 1;
							puVar8 = (uint *)(unaff_EBX + (int)unaff_EBP);
							for (uVar5 = unaff_ESI - unaff_EBX >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
								*puVar8 = CONCAT22(CONCAT11(bVar1,bVar1),CONCAT11(bVar1,bVar1)) & 0x80808080;
								puVar8 = puVar8 + 1;
							}
							for (uVar5 = unaff_ESI - unaff_EBX & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
								*(byte *)puVar8 = bVar1 & 0x80;
								puVar8 = (uint *)((int)puVar8 + 1);
							}
						}
						else {
							do {
								WaveStartDataRead(phmmioIn,pckIn,&(pSVar6->wiWave).mmckInRIFF);
								WaveReadFile(*phmmioIn,unaff_ESI - unaff_EBX,(byte *)(unaff_EBX + (int)unaff_EBP),
														 pckIn,(uint *)&stack0xffffffe4);
								unaff_EBX = unaff_EBX + uVar7;
							} while (unaff_EBX < unaff_ESI);
						}
					}
					unaff_EBX = uVar7;
					pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
					if (local_8 != 0) {
						pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
					}
										// IDirectSoundBuffer->Unlock(this, void* pvAudioPtr1, DWORD dwAudioBytes1,
										// void* pvAudioPtr2, DWORD dwAudioBytes2)
					(*(code *)pIVar4->lpVtbl->Unlock)(pIVar4,unaff_EBP,unaff_ESI,(void *)0x0,0);
					uVar5 = (pSVar6->wiWave).dwNextWriteOffset + unaff_ESI;
					uVar7 = (pSVar6->wiWave).dwBufferSize;
					(pSVar6->wiWave).dwNextWriteOffset = uVar5;
					(pSVar6->wiWave).dwNextProgressCheck = (pSVar6->wiWave).dwNextProgressCheck + unaff_ESI;
					looping = local_8;
					if (uVar7 <= uVar5) {
						(pSVar6->wiWave).dwNextWriteOffset = uVar5 - uVar7;
					}
				}
				else {
					pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
					if (looping != 0) {
						pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
					}
					(*(code *)pIVar4->lpVtbl->Lock)
										(pIVar4,(pSVar6->wiWave).dwNextWriteOffset,(pSVar6->wiWave).dwNotifySize,
										 &local_14,&local_18);
					bVar1 = (((pSVar6->wiWave).waveFormat)->wBitsPerSample != 8) - 1;
					puVar8 = unaff_EBP;
					for (uVar7 = unaff_ESI >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
						*puVar8 = CONCAT22(CONCAT11(bVar1,bVar1),CONCAT11(bVar1,bVar1)) & 0x80808080;
						puVar8 = puVar8 + 1;
					}
					for (uVar7 = unaff_ESI & 3; uVar7 != 0; uVar7 = uVar7 - 1) {
						*(byte *)puVar8 = bVar1 & 0x80;
						puVar8 = (uint *)((int)puVar8 + 1);
					}
					pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
					if (looping != 0) {
						pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
					}
					(*(code *)pIVar4->lpVtbl->Unlock)(pIVar4,unaff_EBP,unaff_ESI,(void *)0x0,0);
					uVar7 = (pSVar6->wiWave).mmckInRIFF.cksize;
					uVar5 = (pSVar6->wiWave).dwNotifySize;
					if (((uVar5 < uVar7) && (uVar7 - uVar5 <= (pSVar6->wiWave).dwProgress)) ||
						 (uVar7 <= (pSVar6->wiWave).dwProgress)) {
						(pSVar6->wiWave).bDonePlaying = 1;
					}
					(pSVar6->wiWave).dwNextProgressCheck = (pSVar6->wiWave).dwNextProgressCheck + unaff_ESI;
				}
				pvVar2 = local_14;
				if ((pSVar6->wiWave).dwProgress <= (pSVar6->wiWave).dwNextProgressCheck) {
					return;
				}
			}
			Sound3D_Stream_Stop(looping);
		}
	}
	return;
}



// return (a.x == b.x) && (a.y == b.y) && (a.z == b.z)

BOOL __cdecl lego::snd::Sound3D_D3DVectorEqual(Vector3F *a,Vector3F *b)
{
	if (((a->x == b->x) && (a->y == b->y)) && (a->z == b->z)) {
		return 1;
	}
	return 0;
}



float10 __cdecl lego::snd::Sound3D_SetRollOffFactor(float rollOff)
{
	if (globs::sound3DGlobs.intialised != 0) {
		if (rollOff < 0.0) {
			rollOff = 0.0;
		}
		if ((ushort)((ushort)(rollOff < 10.0) << 8 | (ushort)(rollOff == 10.0) << 0xe) == 0) {
			rollOff = 10.0;
		}
		(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetRolloffFactor)
							(globs::sound3DGlobs.lp3DListenerInfo,rollOff,0);
	}
	return (float10)rollOff;
}



int __cdecl lego::snd::Sound3D_MinVolume(void)
{
	return -10000;
}



void __cdecl lego::ddraw::DirectDraw_Initialise(HWND hWnd)
{
	globs::directDrawGlobs.hWnd = hWnd;
	globs::directDrawGlobs.lpDirectDraw = (IDirectDraw4 *)0x0;
	globs::directDrawGlobs.fSurf = (IDirectDrawSurface4 *)0x0;
	globs::directDrawGlobs.bSurf = (IDirectDrawSurface4 *)0x0;
	globs::directDrawGlobs.zSurf = (IDirectDrawSurface4 *)0x0;
	globs::directDrawGlobs.lpFrontClipper = (IDirectDrawClipper *)0x0;
	globs::directDrawGlobs.driverList = (DriverMode *)0x0;
	globs::directDrawGlobs.deviceList = (DeviceMode *)0x0;
	globs::directDrawGlobs.modeList = (ScreenMode *)0x0;
	globs::directDrawGlobs.driverCount = 0;
	globs::directDrawGlobs.deviceCount = 0;
	globs::directDrawGlobs.modeCount = 0;
	return;
}



BOOL __cdecl lego::ddraw::DirectDraw_EnumDrivers(DriverMode *ref_list,uint *out_count)
{
	globs::directDrawGlobs.driverList = ref_list;
	DirectDrawEnumerateA(DirectDraw_EnumDriverCallback,(LPVOID)0x0);
	*out_count = globs::directDrawGlobs.driverCount;
	return 1;
}



BOOL lego::ddraw::DirectDraw_EnumDriverCallback
							 (LPGUID lpGUID,LPSTR lpDriverDescription,LPSTR lpDriverName,LPVOID lpContext)
{
	DriverMode *pDVar1;
	
	globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].flags = DRIVERMODE_VALID;
	if (lpGUID == (LPGUID)0x0) {
		globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].flags =
				 globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].flags |
				 DRIVERMODE_PRIMARY;
		globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].flags =
				 globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].flags |
				 DRIVERMODE_WINDOWOK;
	}
	else {
		pDVar1 = globs::directDrawGlobs.driverList + globs::directDrawGlobs.driverCount;
		(pDVar1->guid).Data1 = lpGUID->Data1;
		*(undefined4 *)&(pDVar1->guid).Data2 = *(undefined4 *)&lpGUID->Data2;
		*(undefined4 *)(pDVar1->guid).Data4 = *(undefined4 *)lpGUID->Data4;
		*(undefined4 *)((pDVar1->guid).Data4 + 4) = *(undefined4 *)(lpGUID->Data4 + 4);
	}
	std::sprintf(globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].desc,"%s (%s)",
							 lpDriverDescription,lpDriverName);
	globs::directDrawGlobs.driverCount = globs::directDrawGlobs.driverCount + 1;
	return 1;
}



BOOL __cdecl
lego::ddraw::DirectDraw_EnumDevices(DriverMode *driver,DeviceMode *ref_list,uint *out_count)
{
	HRESULT HVar1;
	uint uVar2;
	GUID *pGVar3;
	IUnknown *local_8;
	DeviceMode *local_4;
	
	uVar2 = 0;
	globs::directDrawGlobs.deviceCount = 0;
	HVar1 = DirectDrawCreate((LPGUID)driver,(IDirectDraw **)&local_4,(LPUNKNOWN)0x0);
	if (HVar1 == 0) {
		HVar1 = (**(code **)(local_4->guid).Data1)
											((IUnknown *)local_4,(IID *)&idl::IID_IDirectDraw4,&local_8);
		if (HVar1 == 0) {
			pGVar3 = &idl::IID_IDirect3D3;
			HVar1 = (*local_8->lpVtbl->QueryInterface)(local_8,(IID *)&idl::IID_IDirect3D3,&driver);
			if (HVar1 == 0) {
				globs::directDrawGlobs.deviceList = local_4;
				(*local_8->lpVtbl[1].QueryInterface)
									(local_8,(IID *)DirectDraw_EnumDeviceCallback,(void **)0x0);
				(**(code **)(*(int *)pGVar3 + 8))(pGVar3);
			}
			uVar2 = (uint)(HVar1 == 0);
			(**(code **)(*(int *)pGVar3 + 8))(pGVar3);
		}
		(**(code **)((local_4->guid).Data1 + 8))(local_4);
	}
	*out_count = globs::directDrawGlobs.deviceCount;
	return uVar2;
}



HRESULT lego::ddraw::DirectDraw_EnumDeviceCallback
									(LPGUID lpGuid,LPSTR lpDeviceDescription,LPSTR lpDeviceName,
									D3DDEVICEDESC_V1 *lpHWDesc,D3DDEVICEDESC_V1 *lpHELDesc,LPVOID lpContext)
{
	DeviceMode *pDVar1;
	DeviceModeFlags DVar2;
	
	pDVar1 = globs::directDrawGlobs.deviceList + globs::directDrawGlobs.deviceCount;
	pDVar1->flags = DEVICEMODE_ISUSED;
	if (lpHWDesc->dcmColorModel != 0) {
		pDVar1->flags = DEVICEMODE_ISUSED|DEVICEMODE_HARDWARE;
		lpHELDesc = lpHWDesc;
	}
										// D3DDD_COLORMODEL (0x1) and D3DCOLOR_RGB (0x2)
	if (((*(byte *)&lpHELDesc->dwFlags & 1) != 0) && (lpHELDesc->dcmColorModel == 2)) {
		pDVar1->flags = pDVar1->flags | DEVICEMODE_COLOUR;
	}
										// D3DDD_DEVICERENDERBITDEPTH (0x80)
	if ((*(byte *)&lpHELDesc->dwFlags & 0x80) != 0) {
										// <https://github.com/github/VisualStudio/blob/263aac11f57d53c5f9fe64ba9916f77c058974d7/tools/Debugging%20Tools%20for%20Windows/winext/manifest/ddraw.h#L1421>
										// DDBD_8 (0x800) 8 bpp
		if ((lpHELDesc->dwDeviceRenderBitDepth & 0x800) != 0) {
			pDVar1->flags = pDVar1->flags | DEVICEMODE_DEPTH8;
		}
										// DDBD_16 (0x400) 16 bpp
		if ((lpHELDesc->dwDeviceRenderBitDepth & 0x400) != 0) {
			pDVar1->flags = pDVar1->flags | DEVICEMODE_DEPTH16;
		}
										// DDBD_24 (0x200) 24 bpp
		if ((lpHELDesc->dwDeviceRenderBitDepth & 0x200) != 0) {
			pDVar1->flags = pDVar1->flags | DEVICEMODE_DEPTH24;
		}
										// DDBD_32 (0x100) 32 bpp
		if ((lpHELDesc->dwDeviceRenderBitDepth & 0x100) != 0) {
			pDVar1->flags = pDVar1->flags | DEVICEMODE_DEPTH32;
		}
	}
										// D3DDD_DEVCAPS (0x2)
	if ((*(byte *)&lpHELDesc->dwFlags & 2) != 0) {
										// D3DDEVCAPS_TEXTUREVIDEOMEMORY (0x200)
		if ((lpHELDesc->dwDevCaps & 0x200) == 0) {
										// D3DDEVCAPS_TEXTURESYSTEMMEMORY (0x100)
			if ((lpHELDesc->dwDevCaps & 0x100) == 0) goto LAB_0047c71d;
			DVar2 = pDVar1->flags | DEVICEMODE_SYSTEMTEXTURE;
		}
		else {
			DVar2 = pDVar1->flags | DEVICEMODE_VIDEOTEXTURE;
		}
		pDVar1->flags = DVar2;
	}
LAB_0047c71d:
	(pDVar1->guid).Data1 = lpGuid->Data1;
	*(undefined4 *)&(pDVar1->guid).Data2 = *(undefined4 *)&lpGuid->Data2;
	*(undefined4 *)(pDVar1->guid).Data4 = *(undefined4 *)lpGuid->Data4;
	*(undefined4 *)((pDVar1->guid).Data4 + 4) = *(undefined4 *)(lpGuid->Data4 + 4);
	std::sprintf(pDVar1->desc,"%s (%s)",lpDeviceName,lpDeviceDescription);
										// DIENUM_CONTINUE (0x1)
	globs::directDrawGlobs.deviceCount = globs::directDrawGlobs.deviceCount + 1;
	return 1;
}



BOOL __cdecl
lego::ddraw::DirectDraw_EnumModes
					(DriverMode *driver,BOOL fullScreen,ScreenMode *ref_list,uint *out_count)
{
	HRESULT HVar1;
	uint uVar2;
	IDirectDraw *ddraw1;
	
	uVar2 = 0;
	globs::directDrawGlobs.modeCount = 0;
	if ((driver != (DriverMode *)0x0) && ((driver->flags & DRIVERMODE_VALID) != DRIVERMODE_NONE)) {
		HVar1 = DirectDrawCreate((LPGUID)(~-(uint)((driver->flags & DRIVERMODE_PRIMARY) !=
																							DRIVERMODE_NONE) & (uint)driver),&ddraw1,
														 (LPUNKNOWN)0x0);
		if (HVar1 == 0) {
			HVar1 = (*ddraw1->lpVtbl->QueryInterface)
												(ddraw1,&idl::IID_IDirectDraw4,(IDirectDraw4 **)&driver);
			if (HVar1 == 0) {
				globs::directDrawGlobs.modeList = ref_list;
										// IDirectDraw4->EnumDisplayModes(this, DWORD dwFlags, DDSURFACEDESC2*
										// lpDDSurfaceDesc, void* lpContext, DDENUMMODESCALLBACK2* lpEnumModesCallback)
				(**(code **)((driver->guid).Data1 + 0x20))
									((IDirectDraw4 *)driver,0,(DDSURFACEDESC2 *)0x0,&fullScreen,
									 DirectDraw_EnumModeCallback);
				(**(code **)((driver->guid).Data1 + 8))((IDirectDraw4 *)driver);
			}
			uVar2 = (uint)(HVar1 == 0);
			(*ddraw1->lpVtbl->Release)(ddraw1);
		}
	}
	*out_count = globs::directDrawGlobs.modeCount;
	return uVar2;
}



HRESULT lego::ddraw::DirectDraw_EnumModeCallback(DDSURFACEDESC2 *lpDDSurfaceDesc,LPVOID lpContext)
{
	uint uVar1;
	ScreenMode *pSVar2;
	
	pSVar2 = globs::directDrawGlobs.modeList + globs::directDrawGlobs.modeCount;
	pSVar2->flags = SCREENMODE_ISUSED;
	pSVar2->width = lpDDSurfaceDesc->dwWidth;
	pSVar2->height = lpDDSurfaceDesc->dwHeight;
	pSVar2->bitDepth = (lpDDSurfaceDesc->ddpfPixelFormat).dwRGBBitCount;
										// WARNING: Load size is inaccurate
										// lpContext (BOOL* isFullScreen)
	if (*lpContext == 0) {
		std::sprintf(pSVar2->desc,"%ix%i",lpDDSurfaceDesc->dwWidth,lpDDSurfaceDesc->dwHeight);
	}
	else {
		std::sprintf(pSVar2->desc,"%ix%i (%i bit)",lpDDSurfaceDesc->dwWidth,lpDDSurfaceDesc->dwHeight,
								 (lpDDSurfaceDesc->ddpfPixelFormat).dwRGBBitCount);
	}
										// WARNING: Load size is inaccurate
										// lpContext (BOOL* isFullScreen)
	if ((*lpContext == 0) && (globs::directDrawGlobs.modeCount != 0)) {
		uVar1 = main::Main_GetWindowsBitDepth();
		if (pSVar2->bitDepth != uVar1) {
										// Bit depth doesn't match system, we can't use this in windowed
			pSVar2->flags = pSVar2->flags & 0xfffffffe;
										// DDENUMRET_OK (0x1)
										// skip incrementing COUNT and return
			return 1;
		}
	}
										// DDENUMRET_OK (0x1)
	globs::directDrawGlobs.modeCount = globs::directDrawGlobs.modeCount + 1;
	return 1;
}



BOOL __cdecl
lego::ddraw::DirectDraw_Setup
					(BOOL fullscreen,DriverMode *driver,DeviceMode *device,ScreenMode *screen,uint xPos,
					uint yPos,uint width,uint height)
{
	HRESULT HVar1;
	int iVar2;
	BOOL BVar3;
	LPGUID lpGUID;
	DDSURFACEDESC2 *pDVar4;
	IDirectDraw *ddraw1;
	uint dwBPP;
	DDSCAPS2 caps;
	DDSURFACEDESC2 surf;
	
	lpGUID = (LPGUID)0x0;
	dwBPP = 0x10;
	if ((driver != (DriverMode *)0x0) && ((*(byte *)&driver->flags & DRIVERMODE_VALID) == 0)) {
		driver = (DriverMode *)0x0;
	}
	if ((device != (DeviceMode *)0x0) && ((*(byte *)&device->flags & DEVICEMODE_ISUSED) == 0)) {
		device = (DeviceMode *)0x0;
	}
	if (screen != (ScreenMode *)0x0) {
		if ((*(byte *)&screen->flags & SCREENMODE_ISUSED) == 0) {
			screen = (ScreenMode *)0x0;
		}
		if (screen != (ScreenMode *)0x0) {
			width = screen->width;
			height = screen->height;
			dwBPP = screen->bitDepth;
		}
	}
	globs::directDrawGlobs.fullScreen = fullscreen;
	if (driver != (DriverMode *)0x0) {
		lpGUID = (LPGUID)(~-(uint)((driver->flags & DRIVERMODE_PRIMARY) != DRIVERMODE_NONE) &
										 (uint)driver);
	}
	globs::directDrawGlobs.width = width;
	globs::directDrawGlobs.height = height;
	main::Main_SetupDisplay(fullscreen,xPos,yPos,width,height);
	HVar1 = DirectDrawCreate(lpGUID,&ddraw1,(LPUNKNOWN)0x0);
	if (HVar1 == 0) {
		HVar1 = (*ddraw1->lpVtbl->QueryInterface)
											(ddraw1,&idl::IID_IDirectDraw4,&globs::directDrawGlobs.lpDirectDraw);
		if (HVar1 == 0) {
										// IDirectDraw4->SetCooperativeLevel(this, HWND hWnd, DWORD dwFlags)
										// 
										// FullScreen = DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN (0x11)
										// Windowed   = DDSCL_NORMAL (0x8)
			HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->SetCooperativeLevel)
												(globs::directDrawGlobs.lpDirectDraw,globs::directDrawGlobs.hWnd,
												 (-(uint)(fullscreen != 0) & 9) + 8);
			if (HVar1 == 0) {
				if (fullscreen == 0) {
					iVar2 = 0;
				}
				else {
										// IDirectDraw4->SetDisplayMode(this, DWORD dwWidth, DWORD dwHeight, DWORD
										// dwBPP, DWORD dwRefreshRate, DWORD dwFlags)
					iVar2 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->SetDisplayMode)
														(globs::directDrawGlobs.lpDirectDraw,width,height,dwBPP,0,0);
				}
				if (iVar2 == 0) {
					pDVar4 = &surf;
					for (iVar2 = 0x1f; iVar2 != 0; iVar2 = iVar2 + -1) {
						pDVar4->dwSize = 0;
						pDVar4 = (DDSURFACEDESC2 *)&pDVar4->dwFlags;
					}
					surf.dwSize = 0x7c;
					surf.dwFlags = 1;
					surf.ddsCaps.dwCaps = 0x2200;
					if (fullscreen != 0) {
						surf.dwFlags = 0x21;
						surf.dwBackBufferCount_Depth = 1;
						surf.ddsCaps.dwCaps = 0x2218;
					}
										// IDirectDraw4->CreateSurface(this, DDSURFACEDESC2* lpDDSurfaceDesc,
										// IDirectDrawSurface4** lplpDDSurface, IUnknown* pUnkOuter)
					HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
														(globs::directDrawGlobs.lpDirectDraw,&surf,&globs::directDrawGlobs.fSurf
														 ,(IUnknown *)0x0);
					if (HVar1 == 0) {
						if (fullscreen == 0) {
							surf.ddsCaps.dwCaps = surf.ddsCaps.dwCaps & 0xfffffdff | 0x40;
							surf.dwFlags = surf.dwFlags | 6;
										// IDirectDraw4->CreateSurface(this, DDSURFACEDESC2* lpDDSurfaceDesc,
										// IDirectDrawSurface4** lplpDDSurface, IUnknown* pUnkOuter)
							surf.dwHeight = height;
							surf.dwWidth = width;
							iVar2 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
																(globs::directDrawGlobs.lpDirectDraw,&surf,
																 &globs::directDrawGlobs.bSurf,(IUnknown *)0x0);
						}
						else {
							caps.dwCaps = 4;
							caps.dwCaps2 = 0;
							caps.dwCaps3 = 0;
							caps.dwCaps4_VolumeDepth = 0;
										// IDirectDrawSurface4->GetAttachedSurface(this, DDSCAPS2* lpDDSCaps,
										// IDirectDrawSurface4** lplpDDAttachedSurface)
							iVar2 = (*(globs::directDrawGlobs.fSurf)->lpVtbl->GetAttachedSurface)
																(globs::directDrawGlobs.fSurf,&caps,&globs::directDrawGlobs.bSurf);
						}
						if (iVar2 == 0) {
							BVar3 = DirectDraw_CreateClipper(fullscreen,width,height);
							if ((BVar3 != 0) &&
								 (BVar3 = main::Main_SetupDirect3D
																		(device,ddraw1,globs::directDrawGlobs.bSurf,fullscreen),
								 BVar3 != 0)) {
								(*ddraw1->lpVtbl->Release)(ddraw1);
								if (fullscreen != 0) {
									ShowCursor(0);
								}
								return 1;
							}
							(*(globs::directDrawGlobs.bSurf)->lpVtbl->Release)(globs::directDrawGlobs.bSurf);
							globs::directDrawGlobs.bSurf = (IDirectDrawSurface4 *)0x0;
						}
						(*(globs::directDrawGlobs.fSurf)->lpVtbl->Release)(globs::directDrawGlobs.fSurf);
						globs::directDrawGlobs.fSurf = (IDirectDrawSurface4 *)0x0;
					}
				}
			}
			(*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->Release)(globs::directDrawGlobs.lpDirectDraw)
			;
			globs::directDrawGlobs.lpDirectDraw = (IDirectDraw4 *)0x0;
		}
		(*ddraw1->lpVtbl->Release)(ddraw1);
	}
	return 0;
}



void __cdecl lego::ddraw::DirectDraw_Flip(void)
{
	if (globs::directDrawGlobs.fullScreen != 0) {
										// DDFLIP_WAIT (0x1)
		(*(globs::directDrawGlobs.fSurf)->lpVtbl->Flip)
							(globs::directDrawGlobs.fSurf,(IDirectDrawSurface4 *)0x0,1);
		return;
	}
	DirectDraw_BlitBuffers();
	return;
}



BOOL __cdecl lego::ddraw::DirectDraw_SaveBMP(IDirectDrawSurface4 *surface,char *fname)
{
	uint uVar1;
	char cVar2;
	char cVar3;
	FileStream *f;
	HRESULT HVar4;
	undefined4 *puVar5;
	int iVar6;
	uint uVar7;
	int iVar8;
	byte bVar9;
	BOOL BVar10;
	DDSURFACEDESC2 *pDVar11;
	uint length;
	undefined4 *puVar12;
	int local_e8;
	uint local_d8;
	undefined uStack180;
	undefined auStack179 [9];
	undefined4 local_aa;
	undefined4 local_a6;
	uint local_a2;
	uint local_9e;
	undefined2 local_9a;
	undefined2 uStack152;
	undefined4 local_96;
	undefined4 local_92;
	undefined4 local_8e;
	undefined4 local_8a;
	undefined4 local_86;
	undefined4 uStack130;
	DDSURFACEDESC2 local_7c;
	
	bVar9 = 0;
	uStack180 = 0;
	BVar10 = 0;
	puVar5 = (undefined4 *)auStack179;
	for (iVar6 = 0xd; iVar6 != 0; iVar6 = iVar6 + -1) {
		*puVar5 = 0;
		puVar5 = puVar5 + 1;
	}
	*(undefined *)puVar5 = 0;
	cVar3 = '\0';
	cVar2 = '\0';
	f = lego::file::File_Open(fname,"wb");
	if (f != (FileStream *)0x0) {
		pDVar11 = &local_7c;
		for (iVar6 = 0x1f; iVar6 != 0; iVar6 = iVar6 + -1) {
			pDVar11->dwSize = 0;
			pDVar11 = (DDSURFACEDESC2 *)&pDVar11->dwFlags;
		}
		local_7c.dwSize = 0x7c;
		HVar4 = (*surface->lpVtbl->Lock)(surface,(LPRECT)0x0,&local_7c,1,(HANDLE)0x0);
		if (HVar4 == 0) {
			iVar6 = (-(uint)((local_7c.dwWidth * 3 & 3) != 0) & 4) + (local_7c.dwWidth * 3 & 0xfffffffc);
			length = iVar6 * local_7c.dwHeight;
			puVar5 = (undefined4 *)std::malloc(length);
			if (puVar5 != (undefined4 *)0x0) {
				puVar12 = puVar5;
				for (uVar7 = length >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
					*puVar12 = 0;
					puVar12 = puVar12 + 1;
				}
				for (iVar8 = 0; iVar8 != 0; iVar8 = iVar8 + -1) {
					*(undefined *)puVar12 = 0;
					puVar12 = (undefined4 *)((int)puVar12 + 1);
				}
				uVar7 = 0;
				do {
					if ((local_7c.ddpfPixelFormat.dwRBitMask >> ((byte)uVar7 & 0x1f) & 1) != 0) {
						cVar3 = cVar3 + '\x01';
					}
					uVar7 = uVar7 + 1;
				} while (uVar7 < 0x20);
				uVar7 = 0;
				do {
					if ((local_7c.ddpfPixelFormat.dwGBitMask >> ((byte)uVar7 & 0x1f) & 1) != 0) {
						cVar2 = cVar2 + '\x01';
					}
					uVar7 = uVar7 + 1;
				} while (uVar7 < 0x20);
				uVar7 = 0;
				do {
					if ((local_7c.ddpfPixelFormat.dwBBitMask >> ((byte)uVar7 & 0x1f) & 1) != 0) {
						bVar9 = bVar9 + 1;
					}
					uVar7 = uVar7 + 1;
				} while (uVar7 < 0x20);
				uVar7 = 0;
				if (local_7c.dwHeight != 0) {
					do {
						iVar8 = 0;
						local_d8 = 0;
						if (local_7c.dwWidth != 0) {
							local_e8 = 0;
							do {
								iVar8 = iVar8 + 3;
								uVar1 = *(uint *)((int)local_7c.lpSurface + local_e8 + uVar7 * local_7c.lPitch);
								*(char *)((int)puVar5 + iVar8 + ((local_7c.dwHeight - uVar7) + -1) * iVar6 + -1) =
										 (char)(uVar1 >> (bVar9 + cVar2 & 0x1f)) << (8U - cVar3 & 0x1f);
								*(char *)((int)puVar5 + iVar8 + ((local_7c.dwHeight - uVar7) + -1) * iVar6 + -2) =
										 (char)(uVar1 >> (bVar9 & 0x1f)) << (8U - cVar2 & 0x1f);
								*(char *)((int)puVar5 + iVar8 + ((local_7c.dwHeight - uVar7) + -1) * iVar6 + -3) =
										 (char)uVar1 << (8 - bVar9 & 0x1f);
								local_e8 = local_e8 + (local_7c.ddpfPixelFormat.dwRGBBitCount >> 3);
								local_d8 = local_d8 + 1;
							} while (local_d8 < local_7c.dwWidth);
						}
						uVar7 = uVar7 + 1;
					} while (uVar7 < local_7c.dwHeight);
				}
				BVar10 = 1;
			}
			(*surface->lpVtbl->Unlock)(surface,(LPRECT)0x0);
			auStack179._1_4_ = length + 0x36;
			uStack180 = 0x42;
			auStack179[0] = 0x4d;
			local_aa = 0x36;
			local_a6 = 0x28;
			local_a2 = local_7c.dwWidth;
			local_9e = local_7c.dwHeight;
			local_9a = 1;
			uStack152 = 0x18;
			local_96 = 0;
			local_92 = 0;
			local_8e = 1;
			local_8a = 1;
			local_86 = 0;
			uStack130 = 0;
			if (BVar10 != 0) {
				lego::file::File_Write(&uStack180,0x36,1,f);
				lego::file::File_Write(puVar5,length,1,f);
			}
			std::free(puVar5);
		}
		lego::file::File_Close(f);
	}
	return BVar10;
}



void __cdecl lego::ddraw::DirectDraw_ReturnFrontBuffer(void)
{
	if (globs::directDrawGlobs.fullScreen != 0) {
										// DDBLT_WAIT (0x1000000)
		(*(globs::directDrawGlobs.bSurf)->lpVtbl->Blt)
							(globs::directDrawGlobs.bSurf,(LPRECT)0x0,globs::directDrawGlobs.fSurf,(LPRECT)0x0,
							 0x1000000,(void *)0x0);
	}
	return;
}



void __cdecl lego::ddraw::DirectDraw_BlitBuffers(void)
{
	POINT ptClient;
	RECT dstRect;
	RECT srcRect;
	
	dstRect.right = globs::directDrawGlobs.width;
	ptClient.y = 0;
	ptClient.x = 0;
	dstRect.left = 0;
	dstRect.top = 0;
	dstRect.bottom = globs::directDrawGlobs.height;
	ClientToScreen(globs::directDrawGlobs.hWnd,(LPPOINT)&ptClient);
	OffsetRect((LPRECT)&dstRect,ptClient.x,ptClient.y);
	srcRect.bottom = globs::directDrawGlobs.height;
	srcRect.left = 0;
	srcRect.top = 0;
	srcRect.right = globs::directDrawGlobs.width;
										// DDBLT_WAIT (0x1000000)
	(*(globs::directDrawGlobs.fSurf)->lpVtbl->Blt)
						(globs::directDrawGlobs.fSurf,(LPRECT)&dstRect,globs::directDrawGlobs.bSurf,
						 (LPRECT)&srcRect,0x1000000,(void *)0x0);
	return;
}



void __cdecl lego::ddraw::DirectDraw_Shutdown(void)
{
	if (globs::directDrawGlobs.fSurf != (IDirectDrawSurface4 *)0x0) {
		(*(globs::directDrawGlobs.fSurf)->lpVtbl->Release)((IUnknown *)globs::directDrawGlobs.fSurf);
	}
	if (globs::directDrawGlobs.lpFrontClipper != (IDirectDrawClipper *)0x0) {
		(*(globs::directDrawGlobs.lpFrontClipper)->lpVtbl->Release)
							((IUnknown *)globs::directDrawGlobs.lpFrontClipper);
	}
	if (globs::directDrawGlobs.lpBackClipper != (IDirectDrawClipper *)0x0) {
		(*(globs::directDrawGlobs.lpBackClipper)->lpVtbl->Release)
							((IUnknown *)globs::directDrawGlobs.lpBackClipper);
	}
	if (globs::directDrawGlobs.lpDirectDraw != (IDirectDraw4 *)0x0) {
		if (globs::directDrawGlobs.fullScreen != 0) {
			(*(code *)(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->RestoreDisplayMode)
								(globs::directDrawGlobs.lpDirectDraw);
		}
		if (globs::directDrawGlobs.lpDirectDraw != (IDirectDraw4 *)0x0) {
			(*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->Release)
								((IUnknown *)globs::directDrawGlobs.lpDirectDraw);
		}
	}
	return;
}



void __cdecl lego::ddraw::DirectDraw_AdjustTextureUsage(uint *ref_textureUsage)
{
	HRESULT HVar1;
	int iVar2;
	uint unaff_EDI;
	DDPIXELFORMAT *pDVar3;
	DDPIXELFORMAT pixFmt;
	
	pDVar3 = &pixFmt;
	for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {
		*(undefined4 *)pDVar3 = 0;
		pDVar3 = (DDPIXELFORMAT *)((int)pDVar3 + 4);
	}
	pixFmt.dwSize = 0x20;
										// DDBD_8 (0x800), D3DRMFPTF_PALETTIZED (0x4)
	HVar1 = (*(globs::mainGlobs.device)->lpVtbl->FindPreferredTextureFormat)
										(globs::mainGlobs.device,0x800,4,&pixFmt);
	if (HVar1 != 0) {
		pDVar3 = &pixFmt;
		for (iVar2 = 8; iVar2 != 0; iVar2 = iVar2 + -1) {
			pDVar3->dwSize = 0;
			pDVar3 = (DDPIXELFORMAT *)&pDVar3->dwFlags;
		}
		pixFmt.dwSize = 0x20;
										// DDBD_16 (0x400), <no flags> (0x0)
		HVar1 = (*(globs::mainGlobs.device)->lpVtbl->FindPreferredTextureFormat)
											(globs::mainGlobs.device,0x400,0,&pixFmt);
		if (HVar1 == 0) {
			*(uint *)pixFmt.dwGBitMask = (unaff_EDI >> 3) * *(int *)pixFmt.dwGBitMask;
		}
	}
	return;
}



BOOL __cdecl lego::ddraw::DirectDraw_GetAvailTextureMem(uint *out_total,uint *out_avil)
{
	int iVar1;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_c = 0;
	local_8 = 0;
										// DDSCAPS_TEXTURE (0x1000)
	local_10 = 0x1000;
	local_4 = 0;
	*out_total = 0;
	*out_avil = 0;
	iVar1 = (*(code *)(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->GetAvailableVidMem)
										(globs::directDrawGlobs.lpDirectDraw,&local_10,out_total,out_avil);
	return (uint)(iVar1 == 0);
}



HRESULT __cdecl lego::ddraw::DirectDraw_Clear(Rect2F *window,uint colour)
{
	HRESULT HVar1;
	int iVar2;
	undefined4 *puVar3;
	longlong lVar4;
	tagRECT local_74;
	undefined4 local_64 [20];
	uint local_14;
	
	puVar3 = local_64;
	for (iVar2 = 0x19; iVar2 != 0; iVar2 = iVar2 + -1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	local_64[0] = 100;
	local_14 = DirectDraw_GetColour(globs::directDrawGlobs.bSurf,colour);
	if (window != (Rect2F *)0x0) {
		lVar4 = __ftol((float10)window->x);
		local_74.left = (LONG)lVar4;
		lVar4 = __ftol((float10)window->y);
		local_74.top = (LONG)lVar4;
		lVar4 = __ftol((float10)window->width + (float10)window->x);
		local_74.right = (LONG)lVar4;
		lVar4 = __ftol((float10)window->height + (float10)window->y);
		local_74.bottom = (LONG)lVar4;
										// DDBLT_WAIT | DDBLT_COLORFILL (0x1000000 | 0x400)
		HVar1 = (*(globs::directDrawGlobs.bSurf)->lpVtbl->Blt)
											(globs::directDrawGlobs.bSurf,(LPRECT)&local_74,(IDirectDrawSurface4 *)0x0,
											 (LPRECT)0x0,0x1000400,local_64);
		return HVar1;
	}
										// DDBLT_WAIT | DDBLT_COLORFILL (0x1000000 | 0x400)
	HVar1 = (*(globs::directDrawGlobs.bSurf)->lpVtbl->Blt)
										(globs::directDrawGlobs.bSurf,(LPRECT)0x0,(IDirectDrawSurface4 *)0x0,(LPRECT)0x0
										 ,0x1000400,local_64);
	return HVar1;
}



BOOL __cdecl lego::ddraw::DirectDraw_CreateClipper(BOOL fullscreen,uint width,uint height)
{
	int iVar1;
	HRGN hrgn;
	DWORD length;
	LPRGNDATA lpRgnData;
	int unaff_EBX;
	int unaff_EBP;
	IDirectDraw4 *pIVar2;
	
	pIVar2 = globs::directDrawGlobs.lpDirectDraw;
	iVar1 = (*(code *)(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateClipper)
										(globs::directDrawGlobs.lpDirectDraw,0,0x76bc98,0);
	if (iVar1 == 0) {
		hrgn = CreateRectRgn(0,0,unaff_EBP,unaff_EBX);
		length = GetRegionData(hrgn,0,(LPRGNDATA)0x0);
		lpRgnData = (LPRGNDATA)std::malloc(length);
		GetRegionData(hrgn,length,lpRgnData);
		iVar1 = (*(code *)(globs::directDrawGlobs.lpBackClipper)->lpVtbl->SetClipList)
											(globs::directDrawGlobs.lpBackClipper,lpRgnData,0);
		if (iVar1 == 0) {
			std::free(lpRgnData);
			iVar1 = (*(code *)(globs::directDrawGlobs.bSurf)->lpVtbl->SetClipper)
												(globs::directDrawGlobs.bSurf,globs::directDrawGlobs.lpBackClipper);
			if (iVar1 == 0) {
				if (pIVar2 != (IDirectDraw4 *)0x0) {
					return 1;
				}
				iVar1 = (*(code *)(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateClipper)
													(globs::directDrawGlobs.lpDirectDraw,0,0x76bc94,0);
				if (iVar1 == 0) {
					iVar1 = (*(code *)(globs::directDrawGlobs.lpFrontClipper)->lpVtbl->SetHWnd)
														(globs::directDrawGlobs.lpFrontClipper,0,globs::directDrawGlobs.hWnd);
					if (iVar1 == 0) {
						iVar1 = (*(code *)(globs::directDrawGlobs.fSurf)->lpVtbl->SetClipper)
															(globs::directDrawGlobs.fSurf,globs::directDrawGlobs.lpFrontClipper);
						if (iVar1 == 0) {
							return 1;
						}
					}
				}
			}
			(*(globs::directDrawGlobs.lpBackClipper)->lpVtbl->Release)
								((IUnknown *)globs::directDrawGlobs.lpBackClipper);
			globs::directDrawGlobs.lpBackClipper = (IDirectDrawClipper *)0x0;
		}
		std::free(lpRgnData);
	}
	return 0;
}



// WARNING: Could not reconcile some variable overlaps

void __cdecl
lego::ddraw::DirectDraw_Blt8To16
					(IDirectDrawSurface4 *target,IDirectDrawSurface4 *source,D3DRMPaletteEntry *palette)
{
	uint uVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	bool bVar5;
	HRESULT HVar6;
	int iVar7;
	char cVar8;
	uint uVar9;
	uint uVar10;
	char cVar11;
	byte bVar12;
	DDSURFACEDESC2 *pDVar13;
	uint uStack296;
	int iStack288;
	uint uStack272;
	byte bStack256;
	byte bStack252;
	DDSURFACEDESC2 local_f8;
	DDSURFACEDESC2 local_7c;
	
	pDVar13 = &local_7c;
	for (iVar7 = 0x1f; iVar7 != 0; iVar7 = iVar7 + -1) {
		pDVar13->dwSize = 0;
		pDVar13 = (DDSURFACEDESC2 *)&pDVar13->dwFlags;
	}
	pDVar13 = &local_f8;
	for (iVar7 = 0x1f; iVar7 != 0; iVar7 = iVar7 + -1) {
		pDVar13->dwSize = 0;
		pDVar13 = (DDSURFACEDESC2 *)&pDVar13->dwFlags;
	}
	local_7c.dwSize = 0x7c;
	local_f8.dwSize = 0x7c;
	HVar6 = (*source->lpVtbl->Lock)(source,(RECT *)0x0,&local_f8,1,(HANDLE)0x0);
	if (HVar6 == 0) {
		if ((local_f8.ddpfPixelFormat.dwRGBBitCount == 8) &&
			 (HVar6 = (*target->lpVtbl->Lock)(target,(RECT *)0x0,&local_7c,1,(HANDLE)0x0), HVar6 == 0)) {
			if ((local_7c.ddpfPixelFormat.dwRGBBitCount == 0x10) &&
				 ((local_7c.dwWidth == local_f8.dwWidth && (local_7c.dwHeight == local_f8.dwHeight)))) {
				iVar7 = 0;
				cVar8 = '\0';
				do {
					if ((local_7c.ddpfPixelFormat.dwRBitMask >> ((byte)iVar7 & 0x1f) & 1) != 0) {
						cVar8 = cVar8 + '\x01';
					}
					iVar7 = iVar7 + 1;
				} while (iVar7 < 0x20);
				iVar7 = 0;
				cVar11 = '\0';
				do {
					if ((local_7c.ddpfPixelFormat.dwGBitMask >> ((byte)iVar7 & 0x1f) & 1) != 0) {
						cVar11 = cVar11 + '\x01';
					}
					iVar7 = iVar7 + 1;
				} while (iVar7 < 0x20);
				iVar7 = 0;
				bVar12 = 0;
				do {
					if ((local_7c.ddpfPixelFormat.dwBBitMask >> ((byte)iVar7 & 0x1f) & 1) != 0) {
						bVar12 = bVar12 + 1;
					}
					iVar7 = iVar7 + 1;
				} while (iVar7 < 0x20);
				uStack296 = 0;
				if (local_f8.dwHeight != 0) {
					do {
						uVar10 = 0;
						if (local_f8.dwWidth != 0) {
							bStack256 = 8 - cVar8;
							bStack252 = 8 - cVar11;
							uStack272._0_1_ = 8 - bVar12;
							do {
								iStack288 = 0x18;
								uVar1 = *(uint *)(uStack296 * local_f8.lPitch + uVar10 + (int)local_f8.lpSurface);
								uVar9 = 3;
								bVar5 = true;
								do {
									uVar2 = uVar1 >> ((byte)iStack288 & 0x1f) & 0xff;
									uVar3 = (uint)(palette[uVar2].red >> (bStack256 & 0x1f));
									uVar4 = (uint)(palette[uVar2].green >> (bStack252 & 0x1f));
									uVar2 = (uint)(palette[uVar2].blue >> ((byte)uStack272 & 0x1f));
									if (bVar5) {
										uStack272 = (uVar3 << (bVar12 + cVar11 & 0x1f) | uVar4 << (bVar12 & 0x1f) |
																uVar2) << 0x10;
									}
									else {
										uStack272 = uStack272 |
																uVar3 << (cVar11 + bVar12 & 0x1f) | uVar4 << (bVar12 & 0x1f) | uVar2
										;
										*(uint *)((int)local_7c.lpSurface +
														 (uVar10 + (uVar9 >> 1 & 1) * 2) * 2 + uStack296 * local_7c.lPitch) =
												 uStack272;
									}
									uVar9 = uVar9 - 1;
									bVar5 = (bool)(bVar5 ^ 1);
									iStack288 = iStack288 + -8;
								} while (-1 < iStack288);
								uVar10 = uVar10 + 4;
							} while (uVar10 < local_f8.dwWidth);
						}
						uStack296 = uStack296 + 1;
					} while (uStack296 < local_f8.dwHeight);
				}
			}
			(*target->lpVtbl->Unlock)(target,(RECT *)0x0);
		}
		(*source->lpVtbl->Unlock)(source,(RECT *)0x0);
	}
	return;
}



uint __cdecl lego::ddraw::DirectDraw_GetColour(IDirectDrawSurface4 *surf,uint colour)
{
	IDirectDrawSurface4Vtbl *pIVar1;
	byte bVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	byte *pbVar8;
	uint unaff_EBP;
	int *unaff_ESI;
	DDPIXELFORMAT *pDVar9;
	DWORD *pDVar10;
	uint local_428;
	IDirectDrawPalette *ddPal;
	DDPIXELFORMAT pixFmt;
	D3DRMPaletteEntry palEntries [256];
	
	local_428 = colour >> 0x10 & 0xff;
	uVar6 = colour >> 8 & 0xff;
	pIVar1 = surf->lpVtbl;
	pDVar9 = &pixFmt;
	for (iVar7 = 8; iVar7 != 0; iVar7 = iVar7 + -1) {
		pDVar9->dwSize = 0;
		pDVar9 = (DDPIXELFORMAT *)&pDVar9->dwFlags;
	}
	pixFmt.dwSize = 0x20;
	(*pIVar1->GetPixelFormat)(surf,&pixFmt);
	if (((byte)ddPal & 0x40) == 0) {
		(*surf->lpVtbl->GetPalette)(surf,(IDirectDrawPalette **)&stack0xfffffbd4);
		pDVar10 = &pixFmt.dwRBitMask;
		(**(code **)(*unaff_ESI + 0x10))(unaff_ESI,0,0,0x100);
		uVar3 = 0;
		pbVar8 = (byte *)((int)&ddPal + 1);
		while ((((DWORD *)(uint)pbVar8[-1] != pDVar10 || (*pbVar8 != uVar6)) ||
					 ((uint)pbVar8[1] != (colour & 0xff)))) {
			uVar3 = uVar3 + 1;
			pbVar8 = pbVar8 + 4;
			if (0xff < uVar3) {
				return 0;
			}
		}
		return uVar3;
	}
	uVar3 = DirectDraw_GetNumberOfBits(pixFmt.dwFourCC);
	uVar4 = DirectDraw_GetNumberOfBits(pixFmt.dwRGBBitCount);
	uVar5 = DirectDraw_GetNumberOfBits(pixFmt.dwRBitMask);
	bVar2 = (byte)uVar5;
	return (unaff_EBP >> (8U - (char)uVar3 & 0x1f)) << (bVar2 + (char)uVar4 & 0x1f) |
				 (uVar6 >> (8U - (char)uVar4 & 0x1f)) << (bVar2 & 0x1f) |
				 (colour & 0xff) >> (8 - bVar2 & 0x1f);
}



uint __cdecl lego::ddraw::DirectDraw_GetNumberOfBits(uint mask)
{
	uint uVar1;
	
	uVar1 = 0;
	if (mask != 0) {
		do {
			mask = mask & mask - 1;
			uVar1 = uVar1 + 1;
		} while (mask != 0);
	}
	return uVar1;
}



void __cdecl lego::image::Image_Initialise(void)
{
	int iVar1;
	Image_Globs *pIVar2;
	
	pIVar2 = &globs::imageGlobs;
	for (iVar1 = 0x20; iVar1 != 0; iVar1 = iVar1 + -1) {
		pIVar2->listSet[0] = (ImageBMP *)0x0;
		pIVar2 = (Image_Globs *)(pIVar2->listSet + 1);
	}
	globs::imageGlobs.flags = 1;
	return;
}



void __cdecl lego::image::Image_Shutdown(void)
{
	Image_Globs *pIVar1;
	
	Image_RemoveAll();
	pIVar1 = &globs::imageGlobs;
	do {
		if (pIVar1->listSet[0] != (ImageBMP *)0x0) {
			std::free(pIVar1->listSet[0]);
		}
		pIVar1 = (Image_Globs *)(pIVar1->listSet + 1);
	} while (pIVar1 < (Image_Globs *)&globs::imageGlobs.freeList);
	globs::imageGlobs.freeList = (ImageBMP *)0x0;
	globs::imageGlobs.flags = 0;
	return;
}



void __cdecl lego::image::Image_Remove(ImageBMP *image)
{
	(*image->surface->lpVtbl->Release)((IUnknown *)image->surface);
	image->nextFree = globs::imageGlobs.freeList;
	globs::imageGlobs.freeList = image;
	return;
}



BOOL __cdecl lego::image::Image_CopyToDataToSurface(IDirectDrawSurface4 *surface,D3DRMImage *image)
{
	HRESULT HVar1;
	int iVar2;
	DWORD *pDVar3;
	DDSURFACEDESC2 local_7c;
	
	pDVar3 = &local_7c.dwFlags;
	for (iVar2 = 0x1e; iVar2 != 0; iVar2 = iVar2 + -1) {
		*pDVar3 = 0;
		pDVar3 = pDVar3 + 1;
	}
										// IDirectDrawSurface4::Lock(IDirectDrawSurface4* This, RECT* a, DDSURFACEDESC2*
										// b, DWORD c, HANDLE d)
										// DDLOCK_WRITEONLY | DDLOCK_WAIT (0x20 | 0x1)
	local_7c.dwSize = 0x7c;
	HVar1 = (*surface->lpVtbl->Lock)(surface,(LPRECT)0x0,&local_7c,0x21,(HANDLE)0x0);
	if (HVar1 == 0) {
		iVar2 = image->depth;
		if (7 < iVar2) {
			if (iVar2 == 8) {
				Image_8BitSourceCopy(&local_7c,image);
			}
			else {
				if ((iVar2 != 0x10) && (iVar2 == 0x18)) {
					Image_24BitSourceCopy(&local_7c,image);
				}
			}
		}
										// IDirectDrawSurface4::Unock(IDirectDrawSurface4* This, RECT* a)
		(*surface->lpVtbl->Unlock)(surface,(LPRECT)0x0);
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::image::Image_8BitSourceCopy(DDSURFACEDESC2 *desc,D3DRMImage *image)
{
	DWORD DVar1;
	int iVar2;
	D3DRMPaletteEntry *pDVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	uint uVar11;
	uint uVar12;
	uint uVar13;
	int iVar14;
	undefined2 *puVar15;
	undefined2 *puVar16;
	byte *pbVar17;
	int local_30;
	byte local_2c;
	byte local_18;
	byte local_10;
	
	DVar1 = (desc->ddpfPixelFormat).dwRGBBitCount;
	if (DVar1 == 8) {
		return 0;
	}
	if (DVar1 == 0x10) {
		uVar9 = (desc->ddpfPixelFormat).dwGBitMask;
		puVar16 = (undefined2 *)desc->lpSurface;
		iVar2 = image->bytes_per_line;
		pDVar3 = image->palette;
		uVar4 = desc->lPitch;
		pbVar17 = image->buffer1;
		uVar10 = (desc->ddpfPixelFormat).dwBBitMask;
		uVar8 = (desc->ddpfPixelFormat).dwRBitMask;
		uVar5 = Image_CountMaskBits(uVar8);
		uVar6 = Image_CountMaskBits(uVar9);
		uVar7 = Image_CountMaskBits(uVar10);
		uVar8 = Image_CountMaskBitShift(uVar8);
		uVar9 = Image_CountMaskBitShift(uVar9);
		uVar10 = Image_CountMaskBitShift(uVar10);
		local_30 = 0;
		if (0 < image->height) {
			do {
				iVar14 = 0;
				if (0 < image->width) {
					local_2c = 8 - (char)uVar7;
					local_10 = 8 - (char)uVar6;
					uVar11 = 8 - uVar5;
					uVar13 = uVar7;
					puVar15 = puVar16;
					do {
						uVar12 = (uint)*pbVar17;
						pbVar17 = pbVar17 + 1;
						puVar16 = puVar15 + 1;
						local_18 = (byte)(8 - uVar5);
						uVar13 = (uVar13 & 0xffff0000 | (uint)(pDVar3[uVar12].blue >> (local_2c & 0x1f))) <<
										 ((byte)uVar10 & 0x1f) |
										 ((uint)pDVar3 & 0xffff0000 | (uint)(pDVar3[uVar12].red >> (local_18 & 0x1f)))
										 << ((byte)uVar8 & 0x1f) |
										 (uVar11 & 0xffff0000 | (uint)(pDVar3[uVar12].green >> (local_10 & 0x1f))) <<
										 ((byte)uVar9 & 0x1f);
						iVar14 = iVar14 + 1;
						*puVar15 = (short)uVar13;
						uVar11 = image->width;
						puVar15 = puVar16;
					} while (iVar14 < (int)uVar11);
				}
				pbVar17 = pbVar17 + (iVar2 - image->width);
				puVar16 = puVar16 + ((uVar4 >> 1) - image->width);
				local_30 = local_30 + 1;
			} while (local_30 < image->height);
		}
		Image_FlipSurface(desc);
		return 1;
	}
	if (DVar1 == 0x18) {
		return 0;
	}
	if (DVar1 != 0x20) {
		return 1;
	}
	return 0;
}



uint __cdecl lego::image::Image_CountMaskBits(uint mask)
{
	uint uVar1;
	uint uVar2;
	
	uVar1 = 0;
	uVar2 = 0;
	do {
		if ((mask & 1 << ((byte)uVar2 & 0x1f)) != 0) {
			uVar1 = uVar1 + 1;
		}
		uVar2 = uVar2 + 1;
	} while (uVar2 < 0x20);
	return uVar1;
}



uint __cdecl lego::image::Image_CountMaskBitShift(uint mask)
{
	uint uVar1;
	
	uVar1 = 0;
	do {
		if ((mask & 1 << ((byte)uVar1 & 0x1f)) != 0) {
			return uVar1;
		}
		uVar1 = uVar1 + 1;
	} while (uVar1 < 0x20);
	return 0xffffffff;
}



void __cdecl lego::image::Image_FlipSurface(DDSURFACEDESC2 *desc)
{
	uint length;
	int iVar1;
	undefined4 *buffer;
	uint uVar2;
	undefined4 *puVar3;
	undefined4 *puVar4;
	undefined4 *puVar5;
	undefined4 *local_8;
	uint local_4;
	
	puVar3 = (undefined4 *)desc->lpSurface;
	iVar1 = (int)desc->lPitch / 2;
	length = iVar1 * 2;
	local_8 = (undefined4 *)((int)puVar3 + (desc->dwHeight - 1) * iVar1 * 2);
	buffer = (undefined4 *)std::malloc(length);
	local_4 = 0;
	if ((desc->dwHeight & 0xfffffffe) != 0) {
		do {
			puVar4 = puVar3;
			puVar5 = buffer;
			for (uVar2 = length >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
				*puVar5 = *puVar4;
				puVar4 = puVar4 + 1;
				puVar5 = puVar5 + 1;
			}
			for (uVar2 = length & 3; uVar2 != 0; uVar2 = uVar2 - 1) {
				*(undefined *)puVar5 = *(undefined *)puVar4;
				puVar4 = (undefined4 *)((int)puVar4 + 1);
				puVar5 = (undefined4 *)((int)puVar5 + 1);
			}
			puVar4 = local_8;
			puVar5 = puVar3;
			for (uVar2 = length >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
				*puVar5 = *puVar4;
				puVar4 = puVar4 + 1;
				puVar5 = puVar5 + 1;
			}
			for (uVar2 = length & 3; uVar2 != 0; uVar2 = uVar2 - 1) {
				*(undefined *)puVar5 = *(undefined *)puVar4;
				puVar4 = (undefined4 *)((int)puVar4 + 1);
				puVar5 = (undefined4 *)((int)puVar5 + 1);
			}
			puVar4 = buffer;
			puVar5 = local_8;
			for (uVar2 = length >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
				*puVar5 = *puVar4;
				puVar4 = puVar4 + 1;
				puVar5 = puVar5 + 1;
			}
			for (uVar2 = length & 3; uVar2 != 0; uVar2 = uVar2 - 1) {
				*(undefined *)puVar5 = *(undefined *)puVar4;
				puVar4 = (undefined4 *)((int)puVar4 + 1);
				puVar5 = (undefined4 *)((int)puVar5 + 1);
			}
			local_4 = local_4 + 1;
			puVar3 = (undefined4 *)((int)puVar3 + length);
			local_8 = (undefined4 *)((int)local_8 + iVar1 * -2);
		} while (local_4 < desc->dwHeight >> 1);
	}
	std::free(buffer);
	return;
}



BOOL __cdecl lego::image::Image_24BitSourceCopy(DDSURFACEDESC2 *desc,D3DRMImage *image)
{
	byte *pbVar1;
	byte *pbVar2;
	byte bVar3;
	DWORD DVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	uint uVar11;
	uint uVar12;
	uint uVar13;
	uint uVar14;
	D3DRMImage *pDVar15;
	int iVar16;
	byte *pbVar17;
	undefined2 *puVar18;
	undefined2 *puVar19;
	int local_2c;
	byte local_18;
	byte local_10;
	
	DVar4 = (desc->ddpfPixelFormat).dwRGBBitCount;
	if (DVar4 == 8) {
		return 0;
	}
	if (DVar4 == 0x10) {
		uVar11 = (desc->ddpfPixelFormat).dwGBitMask;
		uVar12 = (desc->ddpfPixelFormat).dwBBitMask;
		puVar19 = (undefined2 *)desc->lpSurface;
		iVar5 = image->bytes_per_line;
		pbVar17 = image->buffer1;
		uVar6 = desc->lPitch;
		uVar10 = (desc->ddpfPixelFormat).dwRBitMask;
		uVar7 = Image_CountMaskBits(uVar10);
		uVar8 = Image_CountMaskBits(uVar11);
		uVar9 = Image_CountMaskBits(uVar12);
		uVar10 = Image_CountMaskBitShift(uVar10);
		uVar11 = Image_CountMaskBitShift(uVar11);
		uVar12 = Image_CountMaskBitShift(uVar12);
		local_2c = 0;
		if (0 < image->height) {
			do {
				iVar16 = 0;
				if (0 < image->width) {
					local_10 = 8 - (char)uVar7;
					local_18 = 8 - (char)uVar9;
					uVar13 = uVar8;
					uVar14 = uVar7;
					pDVar15 = image;
					puVar18 = puVar19;
					do {
						bVar3 = *pbVar17;
						pbVar1 = pbVar17 + 1;
						puVar19 = puVar18 + 1;
						pbVar2 = pbVar17 + 2;
						pbVar17 = pbVar17 + 3;
						uVar14 = (uVar14 & 0xffff0000 | (uint)(bVar3 >> (local_18 & 0x1f))) <<
										 ((byte)uVar12 & 0x1f);
						pDVar15 = (D3DRMImage *)
											(((uint)pDVar15 & 0xffff0000 | (uint)(*pbVar1 >> (8U - (char)uVar8 & 0x1f)))
											 << ((byte)uVar11 & 0x1f) | uVar14 |
											(uVar13 & 0xffff0000 | (uint)(*pbVar2 >> (local_10 & 0x1f))) <<
											((byte)uVar10 & 0x1f));
						iVar16 = iVar16 + 1;
						*puVar18 = (short)pDVar15;
						uVar13 = image->width;
						puVar18 = puVar19;
					} while (iVar16 < (int)uVar13);
				}
				pbVar17 = pbVar17 + iVar5 + image->width * -3;
				local_2c = local_2c + 1;
				puVar19 = puVar19 + ((uVar6 >> 1) - image->width);
			} while (local_2c < image->height);
		}
		Image_FlipSurface(desc);
		return 1;
	}
	if (DVar4 == 0x18) {
		return 0;
	}
	if (DVar4 != 0x20) {
		return 1;
	}
	return 0;
}



ImageBMP * __cdecl lego::image::Image_LoadBMPScaled(char *fileName,uint width,uint height)
{
	COLORREF pen255;
	BITMAP_FILE_INFO_STRUCT *data;
	HRESULT HVar1;
	BOOL BVar2;
	ImageBMP *pIVar3;
	int iVar4;
	uint unaff_EBX;
	COLORREF unaff_ESI;
	IDirectDrawSurface4 *unaff_EDI;
	int *piVar5;
	DWORD *pDVar6;
	DDSURFACEDESC2 *pDVar7;
	IDirectDrawSurface4 *local_4c4;
	COLORREF local_4c0;
	uint length;
	D3DRMImage local_4b8;
	DDSURFACEDESC2 surfaceDesc;
	char local_400 [1024];
	
	local_4b8.width = 0;
	piVar5 = &local_4b8.height;
	for (iVar4 = 0xe; iVar4 != 0; iVar4 = iVar4 + -1) {
		*piVar5 = 0;
		piVar5 = piVar5 + 1;
	}
	surfaceDesc.dwSize = 0;
	pDVar6 = &surfaceDesc.dwFlags;
	for (iVar4 = 0x1e; iVar4 != 0; iVar4 = iVar4 + -1) {
		*pDVar6 = 0;
		pDVar6 = pDVar6 + 1;
	}
	length = 0;
	local_4c4 = (IDirectDrawSurface4 *)0x0;
	pen255 = Image_RGB2CR(0,0,0);
	local_4c0 = pen255;
	data = (BITMAP_FILE_INFO_STRUCT *)lego::file::File_LoadBinary(fileName,&length);
	if (data != (BITMAP_FILE_INFO_STRUCT *)0x0) {
		BMP_Parse(data,length,&local_4b8);
		if (local_4b8.rgb == 0) {
			local_4c0 = Image_RGB2CR((local_4b8.palette)->red,(local_4b8.palette)->green,
															 (local_4b8.palette)->blue);
			if (local_4b8.rgb == 0) {
				pen255 = Image_RGB2CR(local_4b8.palette[0xff].red,local_4b8.palette[0xff].green,
															local_4b8.palette[0xff].blue);
			}
		}
		std::sprintf(local_400,"Data\\%s",fileName);
		pDVar7 = &surfaceDesc;
		for (iVar4 = 0x1f; iVar4 != 0; iVar4 = iVar4 + -1) {
			pDVar7->dwSize = 0;
			pDVar7 = (DDSURFACEDESC2 *)&pDVar7->dwFlags;
		}
		surfaceDesc.dwWidth = local_4b8.width;
		surfaceDesc.dwHeight = local_4b8.height;
		surfaceDesc.dwSize = 0x7c;
		surfaceDesc.dwFlags = 7;
		surfaceDesc.ddsCaps.dwCaps = 0x840;
										// IDirectDraw4::CreateSurface(IDirectDraw4* This, DDSURFACEDESC2*
										// lpDDSurfaceDesc, IDirectDrawSurface4** lplpDDSurface, IUnknown* pUnkOuter)
		HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
											(globs::directDrawGlobs.lpDirectDraw,&surfaceDesc,&local_4c4,(IUnknown *)0x0);
		if (HVar1 == 0) {
			BVar2 = Image_CopyToDataToSurface(unaff_EDI,(D3DRMImage *)&stack0xfffffb38);
			if (BVar2 != 0) {
				pIVar3 = Image_Create(unaff_EDI,unaff_EBX,(uint)local_4c4,unaff_ESI,pen255);
				if (pIVar3 != (ImageBMP *)0x0) {
					BMP_Cleanup((D3DRMImage *)&stack0xfffffb38);
					std::free(data);
					return pIVar3;
				}
			}
		}
		if (unaff_EDI != (IDirectDrawSurface4 *)0x0) {
			(*unaff_EDI->lpVtbl->Release)((IUnknown *)unaff_EDI);
		}
		BMP_Cleanup((D3DRMImage *)&stack0xfffffb38);
		std::free(data);
	}
	return (ImageBMP *)0x0;
}



COLORREF __cdecl lego::image::Image_RGB2CR(byte red,byte green,byte blue)
{
	_red = (uint)CONCAT12(blue,CONCAT11(green,red));
	return _red;
}



void __cdecl lego::image::Image_SetPenZeroTrans(ImageBMP *image)
{
	DDCOLORKEY colorKey;
	
	colorKey.dwColorSpaceLowValue = image->penZero;
	colorKey.dwColorSpaceHighValue = colorKey.dwColorSpaceLowValue;
	(*image->surface->lpVtbl->SetColorKey)(image->surface,8,&colorKey);
	image->flags = image->flags | 2;
	return;
}



void __cdecl
lego::image::Image_SetupTrans
					(ImageBMP *image,float red_low,float green_low,float blue_low,float red_high,
					float green_high,float blue_high)
{
	byte bVar1;
	COLORREF rgb;
	COLORREF rgb_00;
	longlong lVar2;
	byte bVar3;
	DDCOLORKEY colorKey;
	
	lVar2 = __ftol((float10)blue_low * (float10)255.0);
	bVar3 = (byte)lVar2;
	lVar2 = __ftol((float10)green_low * (float10)255.0);
	bVar1 = (byte)lVar2;
	lVar2 = __ftol((float10)red_low * (float10)255.0);
	rgb = Image_RGB2CR((byte)lVar2,bVar1,bVar3);
	lVar2 = __ftol((float10)blue_high * (float10)255.0);
	bVar3 = (byte)lVar2;
	lVar2 = __ftol((float10)green_high * (float10)255.0);
	bVar1 = (byte)lVar2;
	lVar2 = __ftol((float10)red_high * (float10)255.0);
	rgb_00 = Image_RGB2CR((byte)lVar2,bVar1,bVar3);
	colorKey.dwColorSpaceLowValue = Image_DDColorMatch(image->surface,rgb);
	colorKey.dwColorSpaceHighValue = Image_DDColorMatch(image->surface,rgb_00);
										// IDirectDrawSurface4::SetColorKey(DWORD a, LPDDCOLORKEY b)
	(*image->surface->lpVtbl->SetColorKey)(image->surface,8,&colorKey);
	image->flags = image->flags | 2;
	return;
}



// Image_Blt

void __cdecl
lego::image::Image_DisplayScaled(ImageBMP *image,Rect2F *src,Point2F *destPos,Size2F *destSize)
{
	float fVar1;
	float10 fVar2;
	longlong lVar3;
	DWORD DVar4;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if (src != (Rect2F *)0x0) {
		fVar2 = __floor((double)src->x);
		lVar3 = __ftol(fVar2);
		local_10 = (undefined4)lVar3;
		fVar2 = __floor((double)src->y);
		lVar3 = __ftol(fVar2);
		local_c = (undefined4)lVar3;
		fVar2 = __floor((double)(src->width + src->x));
		lVar3 = __ftol(fVar2);
		local_8 = (undefined4)lVar3;
		fVar2 = __floor((double)(src->height + src->y));
		lVar3 = __ftol(fVar2);
		local_4 = (undefined4)lVar3;
	}
	if (destPos != (Point2F *)0x0) {
		fVar2 = __floor((double)destPos->x);
		lVar3 = __ftol(fVar2);
		local_20 = (undefined4)lVar3;
		fVar2 = __floor((double)destPos->y);
		lVar3 = __ftol(fVar2);
		local_1c = (undefined4)lVar3;
		if (destSize == (Size2F *)0x0) {
			if (src == (Rect2F *)0x0) {
				fVar2 = __floor((double)((float)(ulonglong)image->width + destPos->x));
				lVar3 = __ftol(fVar2);
				local_18 = (undefined4)lVar3;
				fVar1 = (float)(ulonglong)image->height;
			}
			else {
				fVar2 = __floor((double)(src->width + destPos->x));
				lVar3 = __ftol(fVar2);
				local_18 = (undefined4)lVar3;
				fVar1 = src->height;
			}
		}
		else {
			fVar2 = __floor((double)(destSize->width + destPos->x));
			lVar3 = __ftol(fVar2);
			local_18 = (undefined4)lVar3;
			fVar1 = destSize->height;
		}
		fVar2 = __floor((double)(fVar1 + destPos->y));
		lVar3 = __ftol(fVar2);
		local_14 = (undefined4)lVar3;
	}
	if ((*(byte *)&image->flags & 2) == 0) {
		DVar4 = 0x1000000;
	}
	else {
		DVar4 = 0x1008000;
	}
	(*(globs::directDrawGlobs.bSurf)->lpVtbl->Blt)
						(globs::directDrawGlobs.bSurf,
						 (LPRECT)(-(uint)(destPos != (Point2F *)0x0) & (uint)&local_20),image->surface,
						 (LPRECT)(-(uint)(src != (Rect2F *)0x0) & (uint)&local_10),DVar4,(void *)0x0);
	return;
}



void * __cdecl lego::image::Image_LockSurface(ImageBMP *image,uint *out_pitch,uint *out_bpp)
{
	DDSURFACEDESC2 *pDVar1;
	HRESULT HVar2;
	int iVar3;
	undefined4 unaff_EDI;
	DDSURFACEDESC2 s;
	
	pDVar1 = &s;
	for (iVar3 = 0x1f; iVar3 != 0; iVar3 = iVar3 + -1) {
		*(undefined4 *)pDVar1 = 0;
		pDVar1 = (DDSURFACEDESC2 *)((int)pDVar1 + 4);
	}
	s.dwSize = 0x7c;
	HVar2 = (*image->surface->lpVtbl->Lock)(image->surface,(LPRECT)0x0,&s,1,(HANDLE)0x0);
	if (HVar2 == 0) {
		*(undefined4 *)s.ddsCaps.dwCaps3 = unaff_EDI;
		*(DWORD *)s.ddsCaps.dwCaps4_VolumeDepth = s.ddckCKSrcBlt.dwColorSpaceLowValue;
		return (void *)s.lPitch;
	}
	return (void *)0x0;
}



void __cdecl lego::image::Image_UnlockSurface(ImageBMP *image)
{
	(*image->surface->lpVtbl->Unlock)(image->surface,(LPRECT)0x0);
	return;
}



// WARNING: Could not reconcile some variable overlaps

uint __cdecl lego::image::Image_GetPen255(ImageBMP *image)
{
	int iVar1;
	DDPIXELFORMAT *pDVar2;
	uint local_24;
	DDPIXELFORMAT pixelFmt;
	
	pDVar2 = &pixelFmt;
	for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {
		pDVar2->dwSize = 0;
		pDVar2 = (DDPIXELFORMAT *)&pDVar2->dwFlags;
	}
	pixelFmt.dwSize = 0x20;
	local_24 = (*image->surface->lpVtbl->GetPixelFormat)(image->surface,&pixelFmt);
	if (local_24 == 0) {
		local_24 = CONCAT13(*(undefined *)&image->pen255,
												CONCAT12(*(undefined *)((int)&image->pen255 + 1),
																 CONCAT11(*(undefined *)((int)&image->pen255 + 2),
																					*(undefined *)((int)&image->pen255 + 3))));
	}
	return local_24;
}



uint __cdecl lego::image::Image_GetPixelMask(ImageBMP *image)
{
	DDPIXELFORMAT *pDVar1;
	HRESULT HVar2;
	int iVar3;
	DDPIXELFORMAT pixelFmt;
	
	pDVar1 = &pixelFmt;
	for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {
		*(undefined4 *)pDVar1 = 0;
		pDVar1 = (DDPIXELFORMAT *)((int)pDVar1 + 4);
	}
	pixelFmt.dwSize = 0x20;
	HVar2 = (*image->surface->lpVtbl->GetPixelFormat)(image->surface,&pixelFmt);
	if (HVar2 == 0) {
		return -1 << (0x20U - (char)pixelFmt.dwRGBBitCount & 0x1f);
	}
	return 0;
}



BOOL __cdecl lego::image::Image_GetPixel(ImageBMP *image,uint x,uint y,uint *out_colour)
{
	HRESULT HVar1;
	int iVar2;
	DDSURFACEDESC2 *pDVar3;
	DDSURFACEDESC2 local_7c;
	
	pDVar3 = &local_7c;
	for (iVar2 = 0x1f; iVar2 != 0; iVar2 = iVar2 + -1) {
		pDVar3->dwSize = 0;
		pDVar3 = (DDSURFACEDESC2 *)&pDVar3->dwFlags;
	}
	local_7c.dwSize = 0x7c;
	if ((x < image->width) && (y < image->height)) {
		HVar1 = (*image->surface->lpVtbl->Lock)(image->surface,(LPRECT)0x0,&local_7c,0x11,(HANDLE)0x0);
		if (HVar1 == 0) {
			*out_colour = *(uint *)((int)local_7c.lpSurface +
														 (local_7c.ddpfPixelFormat.dwRGBBitCount >> 3) * x + local_7c.lPitch * y
														 ) >> (0x20U - (char)local_7c.ddpfPixelFormat.dwRGBBitCount & 0x1f);
			(*image->surface->lpVtbl->Unlock)(image->surface,(LPRECT)0x0);
			return 1;
		}
	}
	return 0;
}



ImageBMP * __cdecl
lego::image::Image_Create
					(IDirectDrawSurface4 *surface,uint width,uint height,COLORREF penZero,COLORREF pen255)
{
	ImageBMP *pIVar1;
	ImageBMP *pIVar2;
	DWORD DVar3;
	
	if (globs::imageGlobs.freeList == (ImageBMP *)0x0) {
		Image_AddList();
	}
	pIVar1 = globs::imageGlobs.freeList;
	pIVar2 = (globs::imageGlobs.freeList)->nextFree;
	(globs::imageGlobs.freeList)->nextFree = globs::imageGlobs.freeList;
	globs::imageGlobs.freeList = pIVar2;
	pIVar1->flags = 0;
	pIVar1->width = width;
	pIVar1->height = height;
	pIVar1->surface = surface;
	pIVar1->penZeroRGB = penZero;
	DVar3 = Image_DDColorMatch(surface,penZero);
	pIVar1->penZero = DVar3;
	DVar3 = Image_DDColorMatch(surface,pen255);
	pIVar1->pen255 = DVar3;
	return pIVar1;
}



void __cdecl lego::image::Image_AddList(void)
{
	ImageBMP *pIVar1;
	ImageBMP *pIVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::imageGlobs.listCount & 0x1f);
	pIVar2 = (ImageBMP *)std::malloc(uVar4 * 0x20);
	globs::imageGlobs.listSet[globs::imageGlobs.listCount] = pIVar2;
	pIVar2 = globs::imageGlobs.listSet[globs::imageGlobs.listCount];
	if (pIVar2 != (ImageBMP *)0x0) {
		globs::imageGlobs.listCount = globs::imageGlobs.listCount + 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pIVar1 = pIVar2;
			do {
				pIVar1->nextFree = pIVar1 + 1;
				iVar3 = iVar3 + -1;
				pIVar1 = pIVar1 + 1;
			} while (iVar3 != 0);
		}
		pIVar2[uVar4 - 1].nextFree = globs::imageGlobs.freeList;
		globs::imageGlobs.freeList = pIVar2;
	}
	return;
}



void __cdecl lego::image::Image_RemoveAll(void)
{
	int iVar1;
	ImageBMP *image;
	Image_Globs *pIVar2;
	uint uVar3;
	int iVar4;
	
	uVar3 = 0;
	if (globs::imageGlobs.listCount != 0) {
		pIVar2 = &globs::imageGlobs;
		do {
			if ((pIVar2->listSet[0] != (ImageBMP *)0x0) && (iVar1 = 1 << ((byte)uVar3 & 0x1f), iVar1 != 0)
				 ) {
				iVar4 = 0;
				do {
					image = (ImageBMP *)((int)&pIVar2->listSet[0]->surface + iVar4);
					if ((image != (ImageBMP *)0x0) && (image->nextFree == image)) {
						Image_Remove(image);
					}
					iVar4 = iVar4 + 0x20;
					iVar1 = iVar1 + -1;
				} while (iVar1 != 0);
			}
			uVar3 = uVar3 + 1;
			pIVar2 = (Image_Globs *)(pIVar2->listSet + 1);
		} while (uVar3 < globs::imageGlobs.listCount);
	}
	return;
}



DWORD __cdecl lego::image::Image_DDColorMatch(IDirectDrawSurface4 *pdds,DWORD rgb)
{
	byte bVar1;
	HRESULT HVar2;
	uint uVar3;
	uint uVar4;
	int iVar6;
	uint unaff_ESI;
	DWORD DVar7;
	DWORD *pDVar8;
	DDSURFACEDESC2 *lpDDSurfaceDesc;
	char cVar9;
	char cVar10;
	byte out_red;
	byte out_blue;
	byte out_green;
	DDSURFACEDESC2 s;
	uint uVar5;
	
	pDVar8 = &s.dwFlags;
	for (iVar6 = 0x1e; iVar6 != 0; iVar6 = iVar6 + -1) {
		*pDVar8 = 0;
		pDVar8 = pDVar8 + 1;
	}
	DVar7 = 0;
	s.dwSize = 0x7c;
	Image_CR2RGB(rgb,&out_red,&out_green,&out_blue);
	lpDDSurfaceDesc = &s;
	HVar2 = (*pdds->lpVtbl->Lock)(pdds,(LPRECT)0x0,lpDDSurfaceDesc,1,(HANDLE)0x0);
	if (HVar2 == 0) {
		uVar3 = Image_CountMaskBits(s.ddckCKSrcBlt.dwColorSpaceHighValue);
		uVar4 = Image_CountMaskBits(s.ddpfPixelFormat.dwSize);
		cVar9 = (char)uVar4;
		uVar4 = Image_CountMaskBits(s.ddpfPixelFormat.dwFlags);
		cVar10 = (char)uVar4;
		uVar4 = Image_CountMaskBitShift(s.ddckCKSrcBlt.dwColorSpaceHighValue);
		uVar5 = Image_CountMaskBitShift(s.ddpfPixelFormat.dwSize);
		bVar1 = (byte)uVar5;
		uVar5 = Image_CountMaskBitShift(s.ddpfPixelFormat.dwFlags);
		DVar7 = ((_out_red & 0xff) >> (8U - cVar9 & 0x1f)) << (bVar1 & 0x1f) |
						(((uint)lpDDSurfaceDesc & 0xff) >> (8U - (char)uVar3 & 0x1f)) << ((byte)uVar4 & 0x1f) |
						((unaff_ESI & 0xff) >> (8U - cVar10 & 0x1f)) << ((byte)uVar5 & 0x1f);
		if (s.ddckCKSrcBlt.dwColorSpaceLowValue < 0x20) {
			DVar7 = DVar7 & (1 << ((byte)s.ddckCKSrcBlt.dwColorSpaceLowValue & 0x1f)) - 1U;
		}
		(**(code **)(*(int *)s.ddsCaps.dwCaps2 + 0x80))(s.ddsCaps.dwCaps2,0);
	}
	return DVar7;
}



void __cdecl lego::image::Image_CR2RGB(COLORREF cr,byte *out_r,byte *out_g,byte *out_b)
{
	if (out_r != (byte *)0x0) {
		*out_r = (byte)cr;
	}
	if (out_g != (byte *)0x0) {
		*out_g = (byte)(cr >> 8);
	}
	if (out_b != (byte *)0x0) {
		*out_b = cr._2_1_;
	}
	return;
}



void __cdecl lego::image::Image_GetScreenshot(ImageBMP *ref_image,uint xsize,uint ysize)
{
	HRESULT err;
	int iVar1;
	DDSURFACEDESC2 *pDVar2;
	IDirectDrawSurface4 *ddSurface4;
	RECT dstRect;
	DDSURFACEDESC2 surfDesc;
	
	pDVar2 = &surfDesc;
	for (iVar1 = 0x1f; iVar1 != 0; iVar1 = iVar1 + -1) {
		pDVar2->dwSize = 0;
		pDVar2 = (DDSURFACEDESC2 *)&pDVar2->dwFlags;
	}
	surfDesc.dwSize = 0x7c;
	surfDesc.dwWidth = xsize;
	surfDesc.dwHeight = ysize;
	surfDesc.ddsCaps.dwCaps = 0x840;
	surfDesc.dwFlags = 7;
	err = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
									(globs::directDrawGlobs.lpDirectDraw,&surfDesc,&ddSurface4,(IUnknown *)0x0);
	if (err != 0) {
		debug::Error_SetDXError(err,3,"C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Images.c",1140);
		return;
	}
	dstRect.left = 0;
	dstRect.top = 0;
	dstRect.right = xsize;
	dstRect.bottom = ysize;
	(*ddSurface4->lpVtbl->Blt)
						(ddSurface4,&dstRect,globs::directDrawGlobs.bSurf,(RECT *)0x0,0,(void *)0x0);
	Image_InitFromSurface(ref_image,ddSurface4,xsize,ysize,0,0);
	return;
}



void __cdecl
lego::image::Image_InitFromSurface
					(ImageBMP *ref_newImage,IDirectDrawSurface4 *surface,uint width,uint height,
					COLORREF penZero,COLORREF pen255)
{
	DWORD DVar1;
	
	if (globs::imageGlobs.freeList == (ImageBMP *)0x0) {
		Image_AddList();
	}
	ref_newImage->width = width;
	ref_newImage->nextFree = ref_newImage;
	ref_newImage->flags = 0;
	ref_newImage->height = height;
	ref_newImage->surface = surface;
	ref_newImage->penZeroRGB = penZero;
	DVar1 = Image_DDColorMatch(surface,penZero);
	ref_newImage->penZero = DVar1;
	DVar1 = Image_DDColorMatch(surface,pen255);
	ref_newImage->pen255 = DVar1;
	return;
}



BOOL __cdecl lego::image::Image_SaveBMP(ImageBMP *image,char *fname)
{
	BOOL BVar1;
	
	BVar1 = ddraw::DirectDraw_SaveBMP(image->surface,fname);
	return BVar1;
}



AVIRenderer * __thiscall lego::video::AVIRenderer___deletor(AVIRenderer *this,byte flag)
{
	AVIRenderer___dtor(this);
	if ((flag & 1) != 0) {
		game::LevelStruct3C_Free_Unwind((LevelStruct_3c *)this);
	}
	return this;
}



void __thiscall lego::video::AVIRenderer___dtor(AVIRenderer *this)
{
	IDirectDrawSurface4 *ddSurface4;
	IDirectDrawPalette *This;
	
	this->vftable = &AVIRenderer___vftable;
	ddSurface4 = this->ddSurface4;
	if (ddSurface4 != (IDirectDrawSurface4 *)0x0) {
		(*ddSurface4->lpVtbl->Release)(ddSurface4);
		this->ddSurface4 = (IDirectDrawSurface4 *)0x0;
	}
	This = this->ddPalette;
	if (This != (IDirectDrawPalette *)0x0) {
		(*This->lpVtbl->Release)((IUnknown *)This);
		this->ddPalette = (IDirectDrawPalette *)0x0;
	}
	return;
}



AVIRenderer * __thiscall
lego::video::AVIRenderer___ctor
					(AVIRenderer *this,int width,int height,int bpp,bool useVideoMemory,int unused)
{
	bool bVar1;
	
	this->field_unused_4 = 0;
	this->bool_unused_15 = false;
	this->isBPP15 = false;
	this->ddSurface4 = (IDirectDrawSurface4 *)0x0;
	this->isOpen = false;
	this->vftable = &AVIRenderer___vftable;
	AVIRenderer__InitSurfaceDesc(this,unused);
	bVar1 = AVIRenderer__InitSurface(this,width,height,bpp,useVideoMemory);
	if (bVar1 != false) {
		this->isOpen = true;
	}
	return this;
}



bool __thiscall
lego::video::AVIRenderer__InitSurface
					(AVIRenderer *this,int width,int height,int bpp,bool useVideoMemory)
{
	IDirectDrawSurface4 *This;
	HRESULT HVar1;
	byte *pbVar2;
	int iVar3;
	int iVar4;
	DWORD DVar5;
	int iVar6;
	uint uVar7;
	D3DRMPaletteEntry palette [256];
	
										// (dwFlags should initially be 0)
										// dwFlags = DDSD_CAPS (0x1)
										// if (width  != 0) dwFlags |= DDSD_WIDTH (0x4)
										// if (height != 0) dwFlags |= DDSD_HEIGHT (0x2)
	uVar7 = (this->surfDesc).dwFlags | -(uint)(height != 0) & 2 | -(uint)(width != 0) & 4 | 1;
	(this->surfDesc).dwFlags = uVar7;
	this->depth = bpp;
	if (width != 0) {
		(this->surfDesc).dwWidth = width;
	}
	if (height != 0) {
		(this->surfDesc).dwHeight = height;
	}
	if ((width == 0) && (height == 0)) {
										// DDSCAPS_PRIMARYSURFACE (0x200)
		(this->surfDesc).ddsCaps.dwCaps = 0x200;
	}
	else {
										// DDSCAPS_OFFSCREENPLAIN (0x40)
		(this->surfDesc).ddsCaps.dwCaps = 0x40;
										// if (useVideoMemory)
										//   DDSCAPS_VIDEOMEMORY | DDSCAPS_OFFSCREENPLAIN (0x4000 | 0x40)
										// else
										//   DDSCAPS_SYSTEMMEMORY | DDSCAPS_OFFSCREENPLAIN (0x800 | 0x40)
		(this->surfDesc).ddsCaps.dwCaps = (-(uint)(useVideoMemory != false) & 0x3800) + 0x840;
	}
	if (bpp != 0) {
										// DDSD_PIXELFORMAT (0x1000)
		(this->surfDesc).dwFlags = uVar7 | 0x1000;
		(this->surfDesc).ddpfPixelFormat.dwSize = 0x20;
										// specify as 16-bpp when proper depth is 15-bpp
		DVar5 = 0x10;
		if (bpp != 0xf) {
			DVar5 = bpp;
		}
		(this->surfDesc).ddpfPixelFormat.dwRGBBitCount = DVar5;
		if (bpp == 24) {
										// 24-bpp
			(this->surfDesc).ddpfPixelFormat.dwRBitMask = 0xff0000;
			(this->surfDesc).ddpfPixelFormat.dwGBitMask = 0xff00;
			(this->surfDesc).ddpfPixelFormat.dwBBitMask = 0xff;
										// DDPF_RGB (0x40)
			(this->surfDesc).ddpfPixelFormat.dwFlags = 0x40;
		}
		else {
			if (bpp == 0x10) {
										// 16-bpp (proper)
				(this->surfDesc).ddpfPixelFormat.dwRBitMask = 0xf800;
				(this->surfDesc).ddpfPixelFormat.dwGBitMask = 0x7e0;
				(this->surfDesc).ddpfPixelFormat.dwBBitMask = 0x1f;
										// DDPF_RGB (0x40)
				(this->surfDesc).ddpfPixelFormat.dwFlags = 0x40;
			}
			else {
				if (bpp == 0xf) {
										// 15-bpp (treated as 16-bpp)
					(this->surfDesc).ddpfPixelFormat.dwRBitMask = 0x7c00;
					(this->surfDesc).ddpfPixelFormat.dwGBitMask = 0x3e0;
					(this->surfDesc).ddpfPixelFormat.dwBBitMask = 0x1f;
										// DDPF_RGB (0x40)
					(this->surfDesc).ddpfPixelFormat.dwFlags = 0x40;
				}
				else {
					if (bpp == 8) {
										// 8-bpp (indexed)
						(this->surfDesc).ddpfPixelFormat.dwRBitMask = 0xff0000;
						(this->surfDesc).ddpfPixelFormat.dwGBitMask = 0xff00;
						(this->surfDesc).ddpfPixelFormat.dwBBitMask = 0xff;
										// DDPF_RGB | DDPF_PALETTEINDEXED8 (0x40 | 0x20)
						(this->surfDesc).ddpfPixelFormat.dwFlags = 0x60;
					}
				}
			}
		}
	}
	HVar1 = (*(globs::animGlobs.ddraw)->lpVtbl->CreateSurface)
										(globs::animGlobs.ddraw,&this->surfDesc,&this->ddSurface4,(IUnknown *)0x0);
	if (HVar1 == 0) {
		AVIRenderer__LockSurface(this);
		AVIRenderer__UnlockSurface(this);
		if ((this->surfDesc).ddpfPixelFormat.dwRGBBitCount != 8) {
LAB_0047e975:
			if ((this->surfDesc).ddpfPixelFormat.dwRGBBitCount == 0x10) {
										// Count number of bits to check if we're actually using 15-bpp handling (when
										// surface considers it as 16-bpp)
				iVar6 = AVIRenderer__countBits(this,(this->surfDesc).ddpfPixelFormat.dwGBitMask);
				iVar3 = AVIRenderer__countBits(this,(this->surfDesc).ddpfPixelFormat.dwBBitMask);
				iVar4 = AVIRenderer__countBits(this,(this->surfDesc).ddpfPixelFormat.dwRBitMask);
				if (iVar6 + iVar3 + iVar4 == 0xf) {
					this->isBPP15 = true;
				}
			}
			return true;
		}
		pbVar2 = &palette[0].green;
		iVar6 = 0x100;
		do {
			pbVar2[-1] = 0;
			*pbVar2 = 0;
			pbVar2[1] = 0;
			pbVar2[2] = 0;
			pbVar2 = pbVar2 + 4;
			iVar6 = iVar6 + -1;
		} while (iVar6 != 0);
										// DDPCAPS_8BIT (0x4)
		HVar1 = (*(globs::animGlobs.ddraw)->lpVtbl->CreatePalette)
											(globs::animGlobs.ddraw,4,palette,&this->ddPalette,(IUnknown *)0x0);
		if (HVar1 == 0) {
			This = this->ddSurface4;
			HVar1 = (*This->lpVtbl->SetPalette)(This,this->ddPalette);
			if (HVar1 == 0) goto LAB_0047e975;
		}
	}
	return false;
}



void __thiscall lego::video::AVIRenderer__InitSurfaceDesc(AVIRenderer *this,int unused)
{
	int iVar1;
	DDSURFACEDESC2 *pDVar2;
	
	pDVar2 = &this->surfDesc;
	for (iVar1 = 0x1f; iVar1 != 0; iVar1 = iVar1 + -1) {
		pDVar2->dwSize = 0;
		pDVar2 = (DDSURFACEDESC2 *)&pDVar2->dwFlags;
	}
	(this->surfDesc).dwSize = 0x7c;
	this->ddSurface4 = (IDirectDrawSurface4 *)0x0;
	this->ddPalette = (IDirectDrawPalette *)0x0;
	this->isLocked = false;
	this->bool_unused_14 = false;
	return;
}



uint __thiscall lego::video::AVIRenderer__GetWidth(AVIRenderer *this)
{
	return (this->surfDesc).dwWidth;
}



uint __thiscall lego::video::AVIRenderer__GetHeight(AVIRenderer *this)
{
	return (this->surfDesc).dwHeight;
}



bool __thiscall lego::video::AVIRenderer__LockSurface(AVIRenderer *this)
{
	DDSURFACEDESC2 *pDVar1;
	IDirectDrawSurface4 *pIVar2;
	IDirectDrawSurface4Vtbl *pIVar3;
	HRESULT HVar4;
	int iVar5;
	DDSURFACEDESC2 *pDVar6;
	
	if (this->isLocked == false) {
		pDVar1 = &this->surfDesc;
		pDVar6 = pDVar1;
		for (iVar5 = 0x1f; iVar5 != 0; iVar5 = iVar5 + -1) {
			pDVar6->dwSize = 0;
			pDVar6 = (DDSURFACEDESC2 *)&pDVar6->dwFlags;
		}
		pIVar2 = this->ddSurface4;
		pIVar3 = pIVar2->lpVtbl;
		pDVar1->dwSize = 0x7c;
		HVar4 = (*pIVar3->Lock)(pIVar2,(LPRECT)0x0,pDVar1,0x801,(HANDLE)0x0);
		if (HVar4 == 0) {
			this->isLocked = true;
			return true;
		}
	}
	return false;
}



bool __thiscall lego::video::AVIRenderer__UnlockSurface(AVIRenderer *this)
{
	HRESULT HVar1;
	
	if (this->isLocked != false) {
		HVar1 = (*this->ddSurface4->lpVtbl->Unlock)(this->ddSurface4,(LPRECT)0x0);
		if (HVar1 == 0) {
			this->isLocked = false;
			return true;
		}
	}
	return false;
}



int __thiscall lego::video::AVIRenderer__countBits(AVIRenderer *this,uint value)
{
	int iVar1;
	uint uVar2;
	
	iVar1 = 0;
	uVar2 = 0;
	do {
		if ((value & 1 << ((byte)uVar2 & 0x1f)) != 0) {
			iVar1 = iVar1 + 1;
		}
		uVar2 = uVar2 + 1;
	} while (uVar2 < 32);
	return iVar1;
}



AVIPlayer * __thiscall lego::video::AVIPlayer___ctor(AVIPlayer *this,char *filename)
{
	IAVIStream **lplpIAVIStream;
	LONG LVar1;
	LONG LVar2;
	LONG LVar3;
	char *szFile;
	HRESULT HVar4;
	IGetFrame *pIVar5;
	DWORD DVar6;
	AVIRenderer *pAVar7;
	int iVar8;
	AVISTREAMINFOA *pAVar9;
	undefined4 *in_FS_OFFSET;
	undefined4 local_c;
	undefined *puStack8;
	undefined4 local_4;
	
	local_c = *in_FS_OFFSET;
	local_4 = 0xffffffff;
	puStack8 = &LAB_0049e08b;
	*in_FS_OFFSET = &local_c;
	this->bool_unused_98 = false;
	this->isOpen = false;
	this->renderer = (AVIRenderer *)0x0;
	this->vftable = &AVIPlayer___vftable;
	szFile = lego::file::File_VerifyFilename(filename);
	lplpIAVIStream = &this->aviStream;
	this->aviFrame = (IGetFrame *)0x0;
	*lplpIAVIStream = (IAVIStream *)0x0;
	pAVar9 = &this->streamInfo;
	for (iVar8 = 0x23; iVar8 != 0; iVar8 = iVar8 + -1) {
		pAVar9->fccType = 0;
		pAVar9 = (AVISTREAMINFOA *)&pAVar9->fccHandler;
	}
	(this->rect).top = 0;
	(this->rect).bottom = 0;
	(this->rect).left = 0;
	(this->rect).right = 0;
	if (globs::animGlobs.g98NoAvis == false) {
										// fccType "sdiv" (as DWORD)
		HVar4 = AVIStreamOpenFromFileA(lplpIAVIStream,szFile,1935960438,0,0,(CLSID *)0x0);
		if (HVar4 == 0) {
										// AVIGETFRAMEF_BESTDISPLAYFMT (0x1)
			pIVar5 = AVIStreamGetFrameOpen(*lplpIAVIStream,(BITMAPINFOHEADER *)0x1);
			this->aviFrame = pIVar5;
			if (pIVar5 != (IGetFrame *)0x0) {
				HVar4 = AVIStreamInfoA(*lplpIAVIStream,&this->streamInfo,0x8c);
				if (HVar4 == 0) {
					DVar6 = timeGetTime();
					LVar1 = (this->streamInfo).rcFrame.bottom;
					LVar2 = (this->streamInfo).rcFrame.left;
					(this->rect).top = (this->streamInfo).rcFrame.top;
					LVar3 = (this->streamInfo).rcFrame.right;
					this->isOpen = true;
					this->position = 0;
					(this->rect).bottom = LVar1;
					(this->rect).left = LVar2;
					(this->rect).right = LVar3;
					this->startTime = (float)(ulonglong)DVar6 * 0.001;
					pAVar7 = (AVIRenderer *)std::operator_new(0x98);
					local_4 = 0;
					if (pAVar7 == (AVIRenderer *)0x0) {
						pAVar7 = (AVIRenderer *)0x0;
					}
					else {
						pAVar7 = AVIRenderer___ctor(pAVar7,(this->rect).right - (this->rect).left,
																				(this->rect).bottom - (this->rect).top,0,false,0);
					}
					this->renderer = pAVar7;
				}
			}
		}
	}
	*in_FS_OFFSET = local_c;
	return this;
}



AVIPlayer * __thiscall lego::video::AVIPlayer___deletor(AVIPlayer *this,byte flag)
{
	AVIPlayer___dtor(this);
	if ((flag & 1) != 0) {
		game::LevelStruct3C_Free_Unwind((LevelStruct_3c *)this);
	}
	return this;
}



void __thiscall lego::video::AVIPlayer___dtor(AVIPlayer *this)
{
	AVIRenderer *This;
	
	this->vftable = &AVIPlayer___vftable;
	if (globs::animGlobs.g98NoAvis == false) {
		if (this->aviStream != (IAVIStream *)0x0) {
			AVIStreamRelease(this->aviStream);
		}
		This = this->renderer;
		if (This != (AVIRenderer *)0x0) {
			(*This->vftable->deletor)(This,1);
		}
	}
	return;
}



bool __thiscall lego::video::AVIPlayer__UpdateFrame(AVIPlayer *this,byte *frameData)
{
	AVIRenderer *this_00;
	AVIRenderer *pAVar1;
	uint uVar2;
	bool bVar3;
	int stride;
	int height;
	uint uVar4;
	DWORD depth;
	undefined4 *puVar5;
	int width;
	undefined4 *puVar6;
	undefined4 *puVar7;
	undefined4 *puVar8;
	bool local_8;
	
	local_8 = false;
	this_00 = this->renderer;
	if ((this_00->isLocked == false) && (bVar3 = AVIRenderer__LockSurface(this_00), bVar3 != false)) {
		local_8 = true;
	}
	puVar6 = (undefined4 *)(this_00->surfDesc).lpSurface;
	width = (this->rect).right - (this->rect).left;
	pAVar1 = this->renderer;
	height = (this->rect).bottom - (this->rect).top;
	stride = (int)(pAVar1->surfDesc).lPitch / 2;
	depth = 0xf;
	if (pAVar1->isBPP15 == false) {
		depth = (pAVar1->surfDesc).ddpfPixelFormat.dwRGBBitCount;
	}
	if (depth == 0xf) {
		puVar5 = (undefined4 *)(frameData + *(int *)frameData + (height + -1) * stride * 2);
		if (0 < height) {
			uVar2 = width * 2;
			do {
				puVar7 = puVar5;
				puVar8 = puVar6;
				for (uVar4 = uVar2 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
					*puVar8 = *puVar7;
					puVar7 = puVar7 + 1;
					puVar8 = puVar8 + 1;
				}
				for (uVar4 = uVar2 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
					*(undefined *)puVar8 = *(undefined *)puVar7;
					puVar7 = (undefined4 *)((int)puVar7 + 1);
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				}
				puVar5 = (undefined4 *)((int)puVar5 + stride * -2);
				puVar6 = (undefined4 *)((int)puVar6 + stride * 2);
				height = height + -1;
			} while (height != 0);
		}
	}
	else {
										// "Corporate needs you to find the differences between these two code blocks."
										// 
										// (swap out the first `depth == 0xf` confition for `depth == 15 || depth ==
										// 16`)
		if (pAVar1->isBPP15 == false) {
			depth = (pAVar1->surfDesc).ddpfPixelFormat.dwRGBBitCount;
		}
		else {
			depth = 0xf;
		}
		if ((depth == 0x10) &&
			 (puVar5 = (undefined4 *)(frameData + *(int *)frameData + (height + -1) * stride * 2),
			 0 < height)) {
			uVar2 = width * 2;
			do {
				puVar7 = puVar5;
				puVar8 = puVar6;
				for (uVar4 = uVar2 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
					*puVar8 = *puVar7;
					puVar7 = puVar7 + 1;
					puVar8 = puVar8 + 1;
				}
				for (uVar4 = uVar2 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
					*(undefined *)puVar8 = *(undefined *)puVar7;
					puVar7 = (undefined4 *)((int)puVar7 + 1);
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				}
				puVar5 = (undefined4 *)((int)puVar5 + stride * -2);
				puVar6 = (undefined4 *)((int)puVar6 + stride * 2);
				height = height + -1;
			} while (height != 0);
		}
	}
	if (local_8 != false) {
		local_8 = AVIRenderer__UnlockSurface(this_00);
	}
	return local_8;
}



bool __thiscall lego::video::AVIPlayer__Update(AVIPlayer *this)
{
	byte *frameData;
	DWORD DVar1;
	float10 fVar2;
	longlong lVar3;
	
	if (this->isOpen == false) {
		return false;
	}
	if (globs::animGlobs.g98NoAvis != false) {
		return false;
	}
	frameData = (byte *)AVIStreamGetFrame(this->aviFrame,this->position);
	if (frameData != (byte *)0x0) {
		AVIPlayer__UpdateFrame(this,frameData);
		DVar1 = timeGetTime();
		fVar2 = (float10)(ulonglong)(this->streamInfo).dwRate /
						(float10)(ulonglong)(this->streamInfo).dwScale;
		this->rate = (float)fVar2;
		this->currentTime = (float)((float10)(ulonglong)DVar1 * (float10)0.001);
		lVar3 = __ftol(((float10)(ulonglong)DVar1 * (float10)0.001 - (float10)this->startTime) * fVar2);
		this->position = (uint)lVar3;
	}
	return true;
}



uint __thiscall lego::video::AVIPlayer__GetLength(AVIPlayer *this)
{
	if (globs::animGlobs.g98NoAvis != false) {
		return 0;
	}
	return (this->streamInfo).dwLength;
}



void __thiscall lego::video::AVIPlayer__SetPosition(AVIPlayer *this,uint newPosition)
{
	DWORD DVar1;
	
	if (globs::animGlobs.g98NoAvis == false) {
		this->position = newPosition;
		DVar1 = timeGetTime();
		this->currentTime = (float)(ulonglong)DVar1 * 0.001;
		this->startTime =
				 (float)(ulonglong)DVar1 * 0.001 - (float)(ulonglong)this->position / this->rate;
	}
	return;
}



uint __thiscall lego::video::AVIPlayer__GetPosition(AVIPlayer *this)
{
	return ~-(uint)(globs::animGlobs.g98NoAvis != false) & this->position;
}



void __cdecl lego::video::Animation_Initialise(IDirectDraw4 *directDraw)
{
	globs::animGlobs.ddraw = directDraw;
										// WARNING: Could not recover jumptable at 0x0049b9ac. Too many branches
										// WARNING: Treating indirect jump as call
	AVIFileInit();
	return;
}



AVIPlayer_t * __cdecl lego::video::Animation_Load(char *fName)
{
	AVIPlayer *pAVar1;
	undefined4 *in_FS_OFFSET;
	undefined4 local_c;
	undefined *puStack8;
	undefined4 local_4;
	
	local_4 = 0xffffffff;
	puStack8 = &LAB_0049e0ab;
	local_c = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_c;
	pAVar1 = (AVIPlayer *)std::operator_new(0xc4);
	local_4 = 0;
	if (pAVar1 != (AVIPlayer *)0x0) {
		pAVar1 = AVIPlayer___ctor(pAVar1,fName);
		*in_FS_OFFSET = local_c;
		return (AVIPlayer_t *)pAVar1;
	}
	*in_FS_OFFSET = local_c;
	return (AVIPlayer_t *)(AVIPlayer *)0x0;
}



BOOL __cdecl lego::video::Animation_Update(AVIPlayer_t *aviPlayer)
{
	bool bVar1;
	
	bVar1 = AVIPlayer__Update((AVIPlayer *)aviPlayer);
	return (uint)bVar1;
}



void __cdecl lego::video::Animation_BlitToBackBuffer(AVIPlayer_t *anim,RECT *dest)
{
	IDirectDrawSurface4 *lpDDSrcSurface;
	IDirectDrawSurface4 *This;
	
	if (anim->isOpen != false) {
		lpDDSrcSurface = anim->renderer->ddSurface4;
		This = draw::Draw_GetDrawingSurface();
										// DDBLT_WAIT (0x1000000)
		(*This->lpVtbl->Blt)(This,(LPRECT)dest,lpDDSrcSurface,(LPRECT)0x0,0x1000000,(void *)0x0);
	}
	return;
}



void __cdecl lego::video::Animation_SetTime(AVIPlayer_t *anim,uint time)
{
	AVIPlayer__SetPosition((AVIPlayer *)anim,time);
	return;
}



uint __cdecl lego::video::Animation_GetTime(AVIPlayer_t *anim)
{
	uint uVar1;
	
	uVar1 = AVIPlayer__GetPosition((AVIPlayer *)anim);
	return uVar1;
}



uint __cdecl lego::video::Animation_GetLength(AVIPlayer_t *anim)
{
	uint uVar1;
	
	uVar1 = AVIPlayer__GetLength((AVIPlayer *)anim);
	return uVar1;
}



void __cdecl lego::video::Animation_Free(AVIPlayer_t *anim)
{
	if (anim != (AVIPlayer_t *)0x0) {
		(*anim->vftable->deletor)((AVIPlayer *)anim,1);
	}
	return;
}



int __cdecl lego::video::Animation_IsOk(AVIPlayer_t *anim)
{
	return (uint)anim->isOpen;
}



BOOL __cdecl lego::input::Input_InitKeysAndDI(void)
{
	HRESULT HVar1;
	int iVar2;
	char *pcVar3;
	int iVar4;
	GUID guidSysKeyboard;
	
										// GUID_SysKeyboard {6F1D2B61-D5A0-11CF-BFC7-444553540000}
	guidSysKeyboard._4_4_ = 0x11cfd5a0;
	guidSysKeyboard._0_4_ = 0x6f1d2b61;
	guidSysKeyboard._8_4_ = 0x4544c7bf;
	guidSysKeyboard._12_4_ = 0x5453;
	HVar1 = DirectInputCreateA(globs::mainGlobs.hInst,0x500,(IUnknown **)&globs::INPUT.lpdi,
														 (IUnknown *)0x0);
	if (HVar1 != 0) {
		iVar4 = 118;
		pcVar3 = "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Input.c";
		iVar2 = 2;
		HVar1 = DirectInputCreateA(globs::mainGlobs.hInst,0x500,(IUnknown **)&globs::INPUT.lpdi,
															 (IUnknown *)0x0);
		debug::Error_SetDXError(HVar1,iVar2,pcVar3,iVar4);
		return 0;
	}
	HVar1 = (*(globs::INPUT.lpdi)->lpVtbl->CreateDevice)
										(globs::INPUT.lpdi,(LPGUID)&guidSysKeyboard,&globs::INPUT.lpdiKeyboard,
										 (IUnknown *)0x0);
	if (HVar1 != 0) {
		iVar4 = 121;
		pcVar3 = "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Input.c";
		iVar2 = 2;
		HVar1 = (*(globs::INPUT.lpdi)->lpVtbl->CreateDevice)
											(globs::INPUT.lpdi,(LPGUID)&guidSysKeyboard,&globs::INPUT.lpdiKeyboard,
											 (IUnknown *)0x0);
		debug::Error_SetDXError(HVar1,iVar2,pcVar3,iVar4);
		return 0;
	}
	HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->SetDataFormat)
										(globs::INPUT.lpdiKeyboard,&idl::c_dfDIKeyboard);
	if (HVar1 != 0) {
		iVar4 = 124;
		pcVar3 = "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Input.c";
		iVar2 = 2;
		HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->SetDataFormat)
											(globs::INPUT.lpdiKeyboard,&idl::c_dfDIKeyboard);
		debug::Error_SetDXError(HVar1,iVar2,pcVar3,iVar4);
		return 0;
	}
										// DISCL_FOREGROUND | DISCL_NONEXCLUSIVE (0x4 | 0x2)
	HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->SetCooperativeLevel)
										(globs::INPUT.lpdiKeyboard,globs::mainGlobs.hWnd,6);
	if (HVar1 != 0) {
		iVar4 = 127;
		pcVar3 = "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Input.c";
		iVar2 = 2;
										// DISCL_FOREGROUND | DISCL_NONEXCLUSIVE (0x4 | 0x2)
		HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->SetCooperativeLevel)
											(globs::INPUT.lpdiKeyboard,globs::mainGlobs.hWnd,6);
		debug::Error_SetDXError(HVar1,iVar2,pcVar3,iVar4);
		return 0;
	}
	HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->Acquire)(globs::INPUT.lpdiKeyboard);
	globs::INPUT.fKeybdAcquired = (uint)(HVar1 == 0);
	return 1;
}



void __cdecl lego::input::Input_ReadKeys(void)
{
	IDirectInputDeviceA *This;
	HRESULT HVar1;
	int iVar2;
	undefined4 *puVar3;
	Input_Globs *pIVar4;
	
	This = globs::INPUT.lpdiKeyboard;
	iVar2 = 1;
	if (((byte)globs::mainGlobs.flags & CMD_FULLSCREEN) == 0) {
		iVar2 = globs::mainGlobs.active;
	}
	if (iVar2 == 0) {
		puVar3 = (undefined4 *)globs::INPUT.Key_Map;
		for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {
			*puVar3 = 0;
			puVar3 = puVar3 + 1;
		}
		pIVar4 = &globs::INPUT;
		for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {
			*(undefined4 *)pIVar4->prevKey_Map = 0;
			pIVar4 = (Input_Globs *)(pIVar4->prevKey_Map + 4);
		}
		(*(globs::INPUT.lpdiKeyboard)->lpVtbl->Unacquire)(globs::INPUT.lpdiKeyboard);
		return;
	}
	if (globs::INPUT.lpdiKeyboard != (IDirectInputDeviceA *)0x0) {
		if (globs::INPUT.fKeybdAcquired == 0) {
			iVar2 = -0x7ff8ffe2;
		}
		else {
			puVar3 = (undefined4 *)globs::INPUT.Key_Map;
			pIVar4 = &globs::INPUT;
			for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {
				*(undefined4 *)pIVar4->prevKey_Map = *puVar3;
				puVar3 = puVar3 + 1;
				pIVar4 = (Input_Globs *)(pIVar4->prevKey_Map + 4);
			}
			puVar3 = (undefined4 *)globs::INPUT.Key_Map;
			for (iVar2 = 0x40; iVar2 != 0; iVar2 = iVar2 + -1) {
				*puVar3 = 0;
				puVar3 = puVar3 + 1;
			}
			iVar2 = (*This->lpVtbl->GetDeviceState)(This,0x100,(LPVOID)0x76bb80);
		}
		if (iVar2 != 0) {
			globs::INPUT.fKeybdAcquired = 0;
			HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->Acquire)(globs::INPUT.lpdiKeyboard);
			if (HVar1 == 0) {
				globs::INPUT.fKeybdAcquired = 1;
			}
		}
	}
	return;
}



uint __cdecl lego::input::Input_AnyKeyPressed(void)
{
	uint uVar1;
	bool *pbVar2;
	int iVar3;
	
	uVar1 = 0;
	pbVar2 = globs::INPUT.Key_Map;
	iVar3 = 0x100;
	do {
		if (*pbVar2 != false) {
			uVar1 = uVar1 + 1;
		}
		pbVar2 = pbVar2 + 1;
		iVar3 = iVar3 + -1;
	} while (iVar3 != 0);
	return uVar1;
}



void __cdecl lego::input::Input_ReleaseKeysAndDI(void)
{
	if (globs::INPUT.fKeybdAcquired != 0) {
		(*(globs::INPUT.lpdiKeyboard)->lpVtbl->Unacquire)(globs::INPUT.lpdiKeyboard);
		globs::INPUT.fKeybdAcquired = 0;
	}
	if (globs::INPUT.lpdiKeyboard != (IDirectInputDeviceA *)0x0) {
		(*(globs::INPUT.lpdiKeyboard)->lpVtbl->Release)((IUnknown *)globs::INPUT.lpdiKeyboard);
	}
	if (globs::INPUT.lpdi != (IDirectInputA *)0x0) {
		(*(globs::INPUT.lpdi)->lpVtbl->Release)((IUnknown *)globs::INPUT.lpdi);
	}
	return;
}



void __cdecl lego::input::Input_ReadMouse2(void)
{
	BOOL BVar1;
	tagPOINT clientPos;
	tagPOINT mousePos;
	tagRECT clientRect;
	
	BVar1 = GetClientRect(globs::mainGlobs.hWnd,(LPRECT)&clientRect);
	if (BVar1 != 0) {
		clientPos.y = 0;
		clientPos.x = 0;
		ClientToScreen(globs::mainGlobs.hWnd,(LPPOINT)&clientPos);
		GetCursorPos((LPPOINT)&mousePos);
		mousePos.x = mousePos.x - clientPos.x;
		mousePos.y = mousePos.y - clientPos.y;
		if ((int)globs::mainGlobs.appWidth <= mousePos.x) {
			mousePos.x = globs::mainGlobs.appWidth - 1;
		}
		if ((int)globs::mainGlobs.appHeight <= mousePos.y) {
			mousePos.y = globs::mainGlobs.appHeight - 1;
		}
		if (mousePos.x < 0) {
			mousePos.x = 0;
		}
		if (mousePos.y < 0) {
			mousePos.y = 0;
		}
		globs::INPUT.diffx = mousePos.x - globs::INPUT.msx;
		globs::INPUT.diffy = mousePos.y - globs::INPUT.msy;
		globs::INPUT.msx = mousePos.x;
		globs::INPUT.msy = mousePos.y;
	}
	return;
}



BOOL __cdecl lego::input::Input_SetCursorPos(int x,int y)
{
	BOOL BVar1;
	tagPOINT client;
	
	client.y = 0;
	client.x = 0;
	ClientToScreen(globs::mainGlobs.hWnd,(LPPOINT)&client);
	globs::INPUT.msy = y;
	globs::INPUT.msx = x;
	globs::INPUT.diffx = 0;
	globs::INPUT.diffy = 0;
	BVar1 = SetCursorPos(client.x + x,client.y + y);
	return BVar1;
}



// WARNING: Could not reconcile some variable overlaps

void __cdecl lego::file::File_Initialise(char *programName,BOOL insistOnCD,char *registryLocation)
{
	char cVar1;
	bool bVar2;
	int iVar3;
	BOOL BVar4;
	HANDLE handle;
	FILE *pFVar5;
	uint uVar6;
	uint uVar7;
	undefined4 *puVar8;
	char *pcVar9;
	char *pcVar10;
	char *pcVar11;
	undefined4 *puVar12;
	BOOL failed;
	char cwd [260];
	_finddata32_t fileinfo;
	char dataDir [260];
	char msgError [1024];
	char fname [1024];
	char msgNoCD [1024];
	
	bVar2 = false;
	failed = 0;
	std::_getcwd(cwd,MAX_PATH);
	uVar6 = 0xffffffff;
	pcVar10 = cwd;
	do {
		if (uVar6 == 0) break;
		uVar6 = uVar6 - 1;
		cVar1 = *pcVar10;
		pcVar10 = pcVar10 + 1;
	} while (cVar1 != '\0');
	if (cwd[~uVar6 - 2] == '\\') {
		uVar6 = 0xffffffff;
		pcVar10 = cwd;
		do {
			if (uVar6 == 0) break;
			uVar6 = uVar6 - 1;
			cVar1 = *pcVar10;
			pcVar10 = pcVar10 + 1;
		} while (cVar1 != '\0');
		cwd[~uVar6 - 2] = '\0';
	}
	std::sprintf(globs::fileGlobs.dataDir,"%s\\%s",cwd,"Data");
	uVar6 = 0;
	do {
		std::sprintf((char *)&fileinfo,"%s%i.wad",programName,uVar6);
		iVar3 = File_LoadWad((char *)&fileinfo);
		if (iVar3 != -1) {
			bVar2 = true;
		}
		uVar6 = uVar6 + 1;
	} while (uVar6 < 10);
	std::_getcwd(dataDir,MAX_PATH);
	uVar6 = 0xffffffff;
	pcVar10 = "\\Data";
	do {
		pcVar9 = pcVar10;
		if (uVar6 == 0) break;
		uVar6 = uVar6 - 1;
		pcVar9 = pcVar10 + 1;
		cVar1 = *pcVar10;
		pcVar10 = pcVar9;
	} while (cVar1 != '\0');
	uVar6 = ~uVar6;
	iVar3 = -1;
	pcVar10 = dataDir;
	do {
		pcVar11 = pcVar10;
		if (iVar3 == 0) break;
		iVar3 = iVar3 + -1;
		pcVar11 = pcVar10 + 1;
		cVar1 = *pcVar10;
		pcVar10 = pcVar11;
	} while (cVar1 != '\0');
	puVar8 = (undefined4 *)(pcVar9 + -uVar6);
	puVar12 = (undefined4 *)(pcVar11 + -1);
	for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
		*puVar12 = *puVar8;
		puVar8 = puVar8 + 1;
		puVar12 = puVar12 + 1;
	}
	for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
		*(undefined *)puVar12 = *(undefined *)puVar8;
		puVar8 = (undefined4 *)((int)puVar8 + 1);
		puVar12 = (undefined4 *)((int)puVar12 + 1);
	}
	File_SetBaseSearchPath(dataDir);
	iVar3 = File_FindDataCD();
	while ((iVar3 == 0 && (insistOnCD != 0))) {
		msgError._0_4_ = 0x6f727245;
		msgError._4_2_ = 0x72;
		puVar8 = (undefined4 *)(msgError + 6);
		for (iVar3 = 0xfe; iVar3 != 0; iVar3 = iVar3 + -1) {
			*puVar8 = 0;
			puVar8 = puVar8 + 1;
		}
		*(undefined2 *)puVar8 = 0;
		BVar4 = registry::Registry_GetValue
											(registryLocation,"CDMissing",REGISTRY_STRING_VALUE,msgNoCD,0x400);
		if (BVar4 == 0) {
LAB_0047f59b:
			std::exit(0);
		}
		else {
			registry::Registry_GetValue
								(registryLocation,"SetupError",REGISTRY_STRING_VALUE,msgError,0x400);
			iVar3 = MessageBoxA((HWND)0x0,msgNoCD,msgError,1);
			if (iVar3 == 2) goto LAB_0047f59b;
		}
		iVar3 = File_FindDataCD();
	}
	if ((iVar3 == 0) && (!bVar2)) {
		failed = 1;
		handle = std::_findfirst32("*.*",&fileinfo);
		if (handle != (HANDLE)0xffffffff) {
			do {
				if ((((byte)fileinfo.attrib & 0x10) != 0) &&
					 (iVar3 = std::_stricmp(fileinfo.name,"Data"), iVar3 == 0)) {
					failed = 0;
					break;
				}
				iVar3 = std::_findnext32(handle,&fileinfo);
			} while (iVar3 == 0);
			std::_findclose(handle);
		}
	}
	if (insistOnCD != 0) {
		std::sprintf(fname,"%s\\%s","Data","cd.key");
		pFVar5 = std::fopen(fname,"r");
		if (pFVar5 != (FILE *)0x0) {
			std::fclose(pFVar5);
			failed = 1;
		}
	}
	if (failed == 0) {
		std::_mkdir("Data");
		std::sprintf(fname,"%s\\%s","Data","delme.dat");
		pFVar5 = std::fopen(fname,"r");
		if (pFVar5 != (FILE *)0x0) {
			std::fclose(pFVar5);
			std::_chmod(fname,FILE_ATTRIBUTE_NORMAL);
			std::remove(fname);
			return;
		}
	}
	else {
		msgError._0_4_ = 0x6f727245;
		msgError._4_2_ = 0x72;
		puVar8 = (undefined4 *)(msgError + 6);
		for (iVar3 = 0xfe; iVar3 != 0; iVar3 = iVar3 + -1) {
			*puVar8 = 0;
			puVar8 = puVar8 + 1;
		}
		*(undefined2 *)puVar8 = 0;
		BVar4 = registry::Registry_GetValue
											(registryLocation,"DataMissing",REGISTRY_STRING_VALUE,msgNoCD,0x400);
		if (BVar4 != 0) {
			registry::Registry_GetValue
								(registryLocation,"SetupError",REGISTRY_STRING_VALUE,msgError,0x400);
			MessageBoxA((HWND)0x0,msgNoCD,msgError,0);
		}
		std::exit(0);
	}
	return;
}



BOOL __cdecl lego::file::File_FindDataCD(void)
{
	UINT driveType;
	FILE *stream;
	char letter;
	uint rootName;
	char buffer [260];
	
	letter = 0x43;
	rootName = 0x5c3a41;
	do {
		rootName = rootName & 0xffffff00 | (uint)(byte)letter;
		driveType = GetDriveTypeA((LPCSTR)&rootName);
		if (driveType == DRIVE_CDROM) {
			std::sprintf(buffer,"%c:\\%s\\%s",letter,"Data","cd.key");
			stream = std::fopen(buffer,"r");
			if (stream != (FILE *)0x0) {
				std::fclose(stream);
				globs::fileGlobs.cdLetter = letter;
				return TRUE;
			}
		}
		letter = letter + 1;
	} while ((byte)letter < 0x5b);
	return 0;
}



// This allows the translation from File paths into Wad names.

BOOL __cdecl lego::file::File_SetBaseSearchPath(char *basePath)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	int iVar4;
	undefined4 *puVar5;
	char *pcVar6;
	File_Globs *pFVar7;
	
	if (basePath != (char *)0x0) {
		uVar2 = 0xffffffff;
		pcVar6 = basePath;
		do {
			if (uVar2 == 0) break;
			uVar2 = uVar2 - 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
										// if (std::strlen(dirname) != 0 && std::strlen(dirname) < 0x400)
		if (((int)(~uVar2 - 1) < 0x401) && (~uVar2 != 1)) {
										// std::strcpy(globals::g_FILEPATH_DATADIR_STRIP, dirname);
			uVar2 = 0xffffffff;
			do {
				pcVar6 = basePath;
				if (uVar2 == 0) break;
				uVar2 = uVar2 - 1;
				pcVar6 = basePath + 1;
				cVar1 = *basePath;
				basePath = pcVar6;
			} while (cVar1 != '\0');
			uVar2 = ~uVar2;
			puVar5 = (undefined4 *)(pcVar6 + -uVar2);
			pFVar7 = &globs::fileGlobs;
			for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
				*(undefined4 *)pFVar7->wadBasePath = *puVar5;
				puVar5 = puVar5 + 1;
				pFVar7 = (File_Globs *)(pFVar7->wadBasePath + 4);
			}
			for (uVar2 = uVar2 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {
				pFVar7->wadBasePath[0] = *(char *)puVar5;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
				pFVar7 = (File_Globs *)(pFVar7->wadBasePath + 1);
			}
			globs::fileGlobs.basePathSet = TRUE;
			return TRUE;
		}
	}
	globs::fileGlobs.basePathSet = 0;
	pFVar7 = &globs::fileGlobs;
	for (iVar4 = 0x100; iVar4 != 0; iVar4 = iVar4 + -1) {
		*(undefined4 *)pFVar7->wadBasePath = 0;
		pFVar7 = (File_Globs *)(pFVar7->wadBasePath + 4);
	}
	return 0;
}



void __cdecl lego::file::File_Error(char *msg,...)
{
	char buffer [1024];
	
	std::vsprintf(buffer,msg,&stack0x00000008);
	OutputDebugStringA(buffer);
	return;
}



int __cdecl lego::file::File_LoadWad(char *fName)
{
	int iVar1;
	
										// File_ErrorFile(0); // Open the wad error log
	util::logf_removed((char *)0x0);
	iVar1 = wad::Wad_Load(fName);
	return iVar1;
}



BOOL __cdecl lego::file::File_GetCDFilePath(char *out_path,char *fname)
{
	if ((char)globs::fileGlobs._2580_4_ != '\0') {
		std::sprintf(out_path,"%c:\\%s\\%s",globs::fileGlobs._2580_4_ & 0xff,"Data",fname);
		return 1;
	}
	return 0;
}



int __cdecl lego::file::File_MakeDir(char *path)
{
	int iVar1;
	char buffer [260];
	
	std::sprintf(buffer,"%s\\%s","Data",path);
	iVar1 = std::_mkdir(buffer);
	return iVar1;
}



FileStream * __cdecl lego::file::File_Open(char *fName,char *mode)
{
	char *pcVar1;
	FileSystemType FVar2;
	FileStream *file;
	FILE *pFVar3;
	char *pcVar4;
	BOOL BVar5;
	char buffer [260];
	
	pcVar1 = File_VerifyFilename(fName);
	FVar2 = _File_CheckSystem(pcVar1,mode);
	if (FVar2 == FILESYSTEM_WAD) {
		file = _File_Alloc(FILESYSTEM_WAD);
		if (file == (FileStream *)0x0) {
			return (FileStream *)0x0;
		}
		pcVar4 = _File_GetWadName(pcVar1);
		BVar5 = _File_OpenWad((FileWADStream *)file->stream,pcVar4);
		if (BVar5 != 0) {
			pcVar1 = _File_GetWadName(pcVar1);
			util::logf_removed("WAD Load %s\n",pcVar1);
			return file;
		}
		pcVar1 = _File_GetWadName(pcVar1);
		pcVar4 = "WAD Fail %s\n";
	}
	else {
		if (FVar2 != FILESYSTEM_STD) {
			File_Error("%s(%i) : Error in call to %s\n",
								 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",330,"File_Open");
			return (FileStream *)0x0;
		}
		file = _File_Alloc(FILESYSTEM_STD);
		if (file == (FileStream *)0x0) {
			return (FileStream *)0x0;
		}
		pFVar3 = std::fopen(pcVar1,mode);
		file->stream = pFVar3;
		if (pFVar3 != (FILE *)0x0) {
			util::logf_removed("STD Load %s\n",pcVar1);
			return file;
		}
		pcVar4 = util::Util_StrIStr(mode,"w");
		if ((pcVar4 == (char *)0x0) && (BVar5 = File_GetCDFilePath(buffer,fName), BVar5 != 0)) {
			pFVar3 = std::fopen(buffer,mode);
			file->stream = pFVar3;
			if (pFVar3 != (FILE *)0x0) {
				return file;
			}
		}
		pcVar4 = "STD Fail %s\n";
	}
	util::logf_removed(pcVar4,pcVar1);
	_File_Dealloc(file);
	return (FileStream *)0x0;
}



int __cdecl lego::file::File_Seek(FileStream *f,int pos,int origin)
{
	int *piVar1;
	FileSystemType FVar2;
	int iVar3;
	
	FVar2 = _File_GetSystem(f);
	if (FVar2 != FILESYSTEM_WAD) {
		if (FVar2 != FILESYSTEM_STD) {
			File_Error("%s(%i) : Unknown file system in call to %s",
								 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",368,"File_Seek");
			return 0;
		}
		iVar3 = std::fseek((FILE *)f->stream,pos,origin);
		return iVar3;
	}
	if (origin == 0) {
		*(int *)(f->stream + 4) = pos;
		piVar1 = (int *)f->stream;
		iVar3 = wad::Wad_hLength(*piVar1);
		if (iVar3 < piVar1[1]) {
			iVar3 = wad::Wad_hLength(*piVar1);
			*(int *)(f->stream + 4) = iVar3;
		}
		if (*(int *)(f->stream + 4) < 0) {
			*(undefined4 *)(f->stream + 4) = 0;
		}
	}
	else {
		if (origin != 1) {
			if (origin != 2) {
				File_Error("Uknown seek mode (%i)",origin);
				return 0;
			}
			iVar3 = wad::Wad_hLength(*(int *)f->stream);
			*(int *)(f->stream + 4) = iVar3 + pos;
			return 0;
		}
		*(int *)(f->stream + 4) = *(int *)(f->stream + 4) + pos;
		piVar1 = (int *)f->stream;
		iVar3 = wad::Wad_hLength(*piVar1);
		if (iVar3 < piVar1[1]) {
			iVar3 = wad::Wad_hLength(*piVar1);
			*(int *)(f->stream + 4) = iVar3;
		}
		if (*(int *)(f->stream + 4) < 0) {
			*(undefined4 *)(f->stream + 4) = 0;
			return 0;
		}
	}
	return 0;
}



int __cdecl lego::file::File_Read(void *out_buffer,int size,int count,FileStream *f)
{
	int iVar1;
	FileSystemType FVar2;
	size_t sVar3;
	int iVar4;
	void *pvVar5;
	uint uVar6;
	uint uVar7;
	undefined4 *puVar8;
	
	FVar2 = _File_GetSystem(f);
	if (FVar2 == FILESYSTEM_WAD) {
		iVar4 = wad::Wad_hLength(*(int *)f->stream);
		uVar6 = count * size;
		iVar1 = ((int *)f->stream)[1];
		if (iVar4 < (int)(iVar1 + uVar6)) {
			uVar6 = iVar4 - iVar1;
		}
		pvVar5 = wad::Wad_hData(*(int *)f->stream);
		puVar8 = (undefined4 *)((int)pvVar5 + *(int *)(f->stream + 4));
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
			*(undefined4 *)out_buffer = *puVar8;
			puVar8 = puVar8 + 1;
			out_buffer = (undefined4 *)((int)out_buffer + 4);
		}
		for (uVar7 = uVar6 & 3; uVar7 != 0; uVar7 = uVar7 - 1) {
			*(undefined *)out_buffer = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			out_buffer = (undefined4 *)((int)out_buffer + 1);
		}
		*(uint *)(f->stream + 4) = *(int *)(f->stream + 4) + uVar6;
		return (int)uVar6 / size;
	}
	if (FVar2 == FILESYSTEM_STD) {
		sVar3 = std::fread(out_buffer,size,count,(FILE *)f->stream);
		return sVar3;
	}
	File_Error("%s(%i) : Unknown file system in call to %s",
						 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",395,____EMPTYSTR__);
	return 0;
}



int __cdecl lego::file::File_Write(void *buffer,int size,int count,FileStream *f)
{
	FileSystemType FVar1;
	size_t sVar2;
	
	FVar1 = _File_GetSystem(f);
	if (FVar1 == FILESYSTEM_WAD) {
		File_Error("Cannot write to a file stored in a Wad!");
		return 0;
	}
	if (FVar1 != FILESYSTEM_STD) {
		File_Error("%s(%i) : Unknown file system in call to %s",
							 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",414,"File_Write");
		return 0;
	}
	sVar2 = std::fwrite(buffer,size,count,(FILE *)f->stream);
	return sVar2;
}



int __cdecl lego::file::File_Close(FileStream *f)
{
	FileSystemType FVar1;
	
	FVar1 = _File_GetSystem(f);
	if ((-1 < (int)FVar1) && ((int)FVar1 < 2)) {
		_File_Dealloc(f);
		return 0;
	}
	File_Error("%s(%i) : Unknown file system in call to %s",
						 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",431,"File_Close");
	return 0;
}



int __cdecl lego::file::File_Tell(FileStream *f)
{
	FileSystemType FVar1;
	int iVar2;
	
	FVar1 = _File_GetSystem(f);
	if (FVar1 == FILESYSTEM_WAD) {
		return *(int *)(f->stream + 4);
	}
	if (FVar1 != FILESYSTEM_STD) {
		File_Error("%s(%i) : Unknown file system in call to %s",
							 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",469,"File_Tell");
		return 0;
	}
	iVar2 = std::ftell((FILE *)f->stream);
	return iVar2;
}



BOOL __cdecl lego::file::File_Exists(char *fName)
{
	char *fName_00;
	FileSystemType FVar1;
	FILE *pFVar2;
	BOOL BVar3;
	char cdName [260];
	
	fName_00 = File_VerifyFilename(fName);
	FVar1 = _File_CheckSystem(fName_00,"r");
	if (FVar1 == FILESYSTEM_STD) {
		pFVar2 = std::fopen(fName_00,"r");
		if (pFVar2 != (FILE *)0x0) {
			std::fclose(pFVar2);
			return TRUE;
		}
		BVar3 = File_GetCDFilePath(cdName,fName);
		if (BVar3 != 0) {
			pFVar2 = std::fopen(cdName,"r");
			if (pFVar2 != (FILE *)0x0) {
				std::fclose(pFVar2);
				return TRUE;
			}
		}
	}
	else {
		if (FVar1 == FILESYSTEM_WAD) {
			BVar3 = wad::Wad_IsFileInWad(fName_00,globs::currWadHandle);
			return BVar3;
		}
	}
	return 0;
}



int __cdecl lego::file::File_GetC(FileStream *f)
{
	int iVar1;
	int iVar2;
	FileSystemType FVar3;
	int iVar4;
	void *pvVar5;
	
	FVar3 = _File_GetSystem(f);
	if (FVar3 == FILESYSTEM_WAD) {
		iVar4 = wad::Wad_hLength(*(int *)f->stream);
		if (iVar4 + -1 <= ((int *)f->stream)[1]) {
			return -1;
		}
		iVar4 = f->stream;
		iVar1 = *(int *)(iVar4 + 4);
		pvVar5 = wad::Wad_hData(*(int *)f->stream);
		iVar2 = *(int *)((int)pvVar5 + iVar1);
		*(int *)(iVar4 + 4) = iVar1 + 1;
		return iVar2;
	}
	if (FVar3 != FILESYSTEM_STD) {
		File_Error("%s(%i) : Unknown file system in call to %s",
							 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",545,"File_GetC");
		return 0;
	}
	iVar4 = std::fgetc((FILE *)f->stream);
	return iVar4;
}



int __cdecl lego::file::File_Length(FileStream *f)
{
	int pos;
	int iVar1;
	
	pos = File_Tell(f);
	File_Seek(f,0,SEEK_END);
	iVar1 = File_Tell(f);
	File_Seek(f,pos,SEEK_SET);
	return iVar1;
}



char * __cdecl lego::file::File_InternalFGetS(char *out_str,int num,FileStream *f)
{
	char cVar1;
	int iVar2;
	int iVar3;
	
	iVar3 = 0;
	iVar2 = File_GetC(f);
	cVar1 = (char)iVar2;
	*out_str = cVar1;
	while ((((cVar1 != '\0' && (out_str[iVar3] != '\n')) && (out_str[iVar3] != -1)) && (iVar3 != num))
				) {
		iVar3 = iVar3 + 1;
		iVar2 = File_GetC(f);
		cVar1 = (char)iVar2;
		out_str[iVar3] = cVar1;
	}
	out_str[iVar3 + 1] = '\0';
	return (char *)(-(uint)(iVar3 != 0) & (uint)out_str);
}



char * __cdecl lego::file::File_GetS(char *out_str,int num,FileStream *f)
{
	FileSystemType FVar1;
	char *pcVar2;
	
	FVar1 = _File_GetSystem(f);
	if (FVar1 == FILESYSTEM_WAD) {
		pcVar2 = File_InternalFGetS(out_str,num,f);
		return pcVar2;
	}
	if (FVar1 != FILESYSTEM_STD) {
		File_Error("%s(%i) : Unknown file system in call to %s",
							 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",587,"File_GetS");
		return (char *)0x0;
	}
	pcVar2 = std::fgets(out_str,num,(FILE *)f->stream);
	return pcVar2;
}



int __cdecl lego::file::File_PrintF(FileStream *f,char *msg,...)
{
	FileSystemType FVar1;
	
	FVar1 = _File_GetSystem(f);
	if (FVar1 == FILESYSTEM_WAD) {
		File_Error("\"fprintf\" is unsupprted for wad files");
		return 0;
	}
	if (FVar1 != FILESYSTEM_STD) {
		File_Error("%s(%i) : Unknown file system in call to %s",
							 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",612,"File_PrintF");
		return 0;
	}
	std::vfprintf((FILE *)f->stream,msg,&stack0x0000000c);
	return 0;
}



FileSystemType __cdecl lego::file::_File_GetSystem(FileStream *f)
{
	return f->location;
}



FileSystemType __cdecl lego::file::_File_CheckSystem(char *fName,char *mode)
{
	char cVar1;
	char *pcVar2;
	int iVar3;
	
	if ((fName != (char *)0x0) && (mode != (char *)0x0)) {
		iVar3 = -1;
		pcVar2 = fName;
		do {
			if (iVar3 == 0) break;
			iVar3 = iVar3 + -1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar2 + 1;
		} while (cVar1 != '\0');
		if (iVar3 != -2) {
			iVar3 = -1;
			pcVar2 = mode;
			do {
				if (iVar3 == 0) break;
				iVar3 = iVar3 + -1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar2 + 1;
			} while (cVar1 != '\0');
			if (iVar3 != -2) {
				if ((*mode != 'w') && (*mode != 'W')) {
					iVar3 = globs::currWadHandle;
					pcVar2 = _File_GetWadName(fName);
					iVar3 = wad::Wad_IsFileInWad(pcVar2,iVar3);
					return (uint)(iVar3 == -1);
				}
				return FILESYSTEM_STD;
			}
		}
	}
	return FILESYSTEM_ERR;
}



BOOL __cdecl lego::file::_File_OpenWad(FileWADStream *wad,char *fName)
{
	int iVar1;
	
	wad->eof = 0;
	wad->streamPos = 0;
	iVar1 = lego::wad::Wad_FileOpen(fName,globs::currWadHandle);
	wad->hFile = iVar1;
	return (uint)(iVar1 != -1);
}



FileStream * __cdecl lego::file::_File_Alloc(FileSystemType fType)
{
	FileStream *pFVar1;
	FileStream *file;
	FileWADStream *wadStream;
	
	if (fType == FILESYSTEM_STD) {
		pFVar1 = (FileStream *)_File_Malloc(8);
		pFVar1->location = FILESYSTEM_STD;
		return pFVar1;
	}
	if (fType == FILESYSTEM_WAD) {
		file = (FileStream *)_File_Malloc(8);
		if (file != (FileStream *)0x0) {
			file->location = FILESYSTEM_WAD;
			wadStream = (FileWADStream *)_File_Malloc(0xc);
			file->stream = wadStream;
			if (wadStream != (FileWADStream *)0x0) {
				return file;
			}
			_File_Free(file);
		}
	}
	return (FileStream *)0x0;
}



// (Change to whatever is required)

void * __cdecl lego::file::_File_Malloc(int size)
{
	void *pvVar1;
	
	pvVar1 = std::malloc(size);
	return pvVar1;
}



// (Change to whatever is required)

void __cdecl lego::file::_File_Free(void *ptr)
{
	std::free(ptr);
	return;
}



void __cdecl lego::file::_File_Dealloc(FileStream *file)
{
	FileSystemType FVar1;
	
	if (file != (FileStream *)0x0) {
		FVar1 = _File_GetSystem(file);
		if (FVar1 == FILESYSTEM_STD) {
			if ((FILE *)file->stream != (FILE *)0x0) {
				std::fclose((FILE *)file->stream);
				_File_Free(file);
				return;
			}
		}
		else {
			FVar1 = _File_GetSystem(file);
			if (FVar1 != FILESYSTEM_WAD) {
				return;
			}
			if ((int *)file->stream != (int *)0x0) {
				wad::Wad_FileClose(*(int *)file->stream);
				_File_Free((void *)file->stream);
			}
		}
		_File_Free(file);
	}
	return;
}



char * __cdecl lego::file::_File_GetWadName(char *fName)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	int iVar5;
	char *pcVar6;
	File_Globs *pFVar7;
	
	if (globs::fileGlobs.basePathSet == 0) {
		return fName;
	}
	uVar3 = 0xffffffff;
	pcVar6 = fName;
	do {
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		cVar1 = *pcVar6;
		pcVar6 = pcVar6 + 1;
	} while (cVar1 != '\0');
	uVar4 = 0xffffffff;
	pFVar7 = &globs::fileGlobs;
	do {
		if (uVar4 == 0) break;
		uVar4 = uVar4 - 1;
		pcVar6 = pFVar7->wadBasePath;
		pFVar7 = (File_Globs *)(pFVar7->wadBasePath + 1);
	} while (*pcVar6 != '\0');
	iVar5 = ~uVar4 - 1;
	if ((int)(~uVar3 - 1) <= iVar5) {
		return fName;
	}
	cVar1 = fName[iVar5];
	fName[iVar5] = '\0';
	iVar2 = std::_stricmp(fName,(char *)&globs::fileGlobs);
	if (iVar2 == 0) {
		std::sprintf(globs::fileGlobs.s_GetWadName_wadedName,"%s",fName + ~uVar4);
		fName[iVar5] = cVar1;
		return globs::fileGlobs.s_GetWadName_wadedName;
	}
	fName[iVar5] = cVar1;
	return fName;
}



char * __cdecl lego::file::File_GetLine(char *out_str,uint size,FileStream *file)
{
	char cVar1;
	char *pcVar2;
	uint uVar3;
	int iVar4;
	char *pcVar5;
	
	pcVar2 = File_GetS(out_str,size,file);
	uVar3 = 0xffffffff;
	pcVar5 = out_str;
	do {
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	iVar4 = uVar3 - 2;
	if (out_str[iVar4] == '\n') {
		out_str[iVar4] = '\0';
	}
	if ((iVar4 != 0) && (out_str[uVar3 - 3] == '\r')) {
		out_str[uVar3 - 3] = '\0';
	}
	return pcVar2;
}



byte * __cdecl lego::file::File_LoadBinary(char *filename,uint *out_size)
{
	byte *buffer;
	
	buffer = (byte *)File_Load(filename,out_size,TRUE);
	return buffer;
}



void * __cdecl lego::file::File_Load(char *filename,uint *out_size,BOOL binary)
{
	char *mode;
	FileStream *file;
	uint length;
	void *out_buffer;
	
	mode = "rb";
	if (binary == 0) {
		mode = "r";
	}
	file = File_Open(filename,mode);
	if (file != (FileStream *)0x0) {
		File_Seek(file,0,SEEK_END);
		length = File_Tell(file);
		if (globs::fileGlobs.loadCallback != (FileLoadCallback *)0x0) {
			(*globs::fileGlobs.loadCallback)(filename,length,globs::fileGlobs.loadCallbackData);
		}
		out_buffer = std::malloc(length);
		if (out_buffer != (void *)0x0) {
			File_Seek(file,0,0);
			File_Read(out_buffer,1,length,file);
			if (out_size != (uint *)0x0) {
				*out_size = length;
			}
			File_Close(file);
			return out_buffer;
		}
		File_Close(file);
	}
	return (void *)0x0;
}



uint __cdecl lego::file::File_LoadBinaryHandle(char *filename,uint *out_size)
{
	FileStream *f;
	uint fileSize;
	int bufferIndex;
	void *out_buffer;
	
	f = File_Open(filename,"rb");
	if (f != (FileStream *)0x0) {
		File_Seek(f,0,SEEK_END);
		fileSize = File_Tell(f);
		if (globs::fileGlobs.loadCallback != (FileLoadCallback *)0x0) {
			(*globs::fileGlobs.loadCallback)(filename,fileSize,globs::fileGlobs.loadCallbackData);
		}
		bufferIndex = Mem_AllocHandle(fileSize);
		if (bufferIndex != -1) {
			out_buffer = Mem_AddressHandle(bufferIndex);
			File_Seek(f,0,SEEK_SET);
			File_Read(out_buffer,1,fileSize,f);
			if (out_size != (uint *)0x0) {
				*out_size = fileSize;
			}
			File_Close(f);
			return bufferIndex;
		}
		File_Close(f);
	}
	return 0xffffffff;
}



char * __cdecl lego::file::File_VerifyFilename(char *filename)
{
	char cVar1;
	char *pcVar2;
	int iVar3;
	uint uVar4;
	char part [260];
	
	if (filename != (char *)0x0) {
		if (*filename == '\\') {
			filename = filename + 1;
		}
		std::sprintf(part,"%s\\%s",0x5352a8,filename);
		pcVar2 = std::_fullpath(globs::fileGlobs.s_VerifyFilename_full,part,MAX_PATH);
		if (pcVar2 != (char *)0x0) {
			uVar4 = 0xffffffff;
			pcVar2 = globs::fileGlobs.dataDir;
			do {
				if (uVar4 == 0) break;
				uVar4 = uVar4 - 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar2 + 1;
			} while (cVar1 != '\0');
			iVar3 = std::strncmp(globs::fileGlobs.s_VerifyFilename_full,globs::fileGlobs.dataDir,
													 ~uVar4 - 1);
			if (iVar3 == 0) {
				return globs::fileGlobs.s_VerifyFilename_full;
			}
		}
	}
	return (char *)0x0;
}



void __cdecl lego::file::File_SetLoadCallback(FileLoadCallback *callback,void *data)
{
	globs::fileGlobs.loadCallback = callback;
	globs::fileGlobs.loadCallbackData = data;
	return;
}



void __cdecl lego::file::File_CheckRedundantFiles(char *logName)
{
	char cVar1;
	FILE *stream;
	int iVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	char *pcVar7;
	char (*pacVar8) [1024];
	char buffer [1024];
	
	stream = (FILE *)File_Open(logName,"r");
	if (stream != (FILE *)0x0) {
		globs::checkGlobs.numInList = 0;
		iVar2 = std::fscanf(stream,"%s",buffer);
		while (iVar2 != -1) {
			uVar3 = 0xffffffff;
			pacVar8 = globs::checkGlobs.loadedList[globs::checkGlobs.numInList];
			globs::checkGlobs.numInList = globs::checkGlobs.numInList + 1;
			pcVar6 = buffer;
			do {
				pcVar7 = pcVar6;
				if (uVar3 == 0) break;
				uVar3 = uVar3 - 1;
				pcVar7 = pcVar6 + 1;
				cVar1 = *pcVar6;
				pcVar6 = pcVar7;
			} while (cVar1 != '\0');
			uVar3 = ~uVar3;
			puVar5 = (undefined4 *)(pcVar7 + -uVar3);
			for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
				*(undefined4 *)*pacVar8 = *puVar5;
				puVar5 = puVar5 + 1;
				pacVar8 = (char (*) [1024])(*pacVar8 + 4);
			}
			for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
				(*pacVar8)[0] = *(char *)puVar5;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
				pacVar8 = (char (*) [1024])(*pacVar8 + 1);
			}
			iVar2 = std::fscanf(stream,"%s",buffer);
		}
		File_CheckDirectory(globs::fileGlobs.dataDir);
		std::fclose(stream);
	}
	return;
}



void __cdecl lego::file::File_CheckDirectory(char *dirName)
{
	char cVar1;
	byte bVar2;
	HANDLE handle;
	byte *pbVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	char *pcVar7;
	undefined4 *puVar8;
	char *pcVar9;
	char *pcVar10;
	undefined4 *puVar11;
	bool bVar12;
	byte local_518;
	char local_504 [260];
	char name [1024];
	
	uVar4 = 0xffffffff;
	pcVar7 = dirName;
	do {
		pcVar9 = pcVar7;
		if (uVar4 == 0) break;
		uVar4 = uVar4 - 1;
		pcVar9 = pcVar7 + 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar9;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar8 = (undefined4 *)(pcVar9 + -uVar4);
	puVar11 = (undefined4 *)name;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
		*puVar11 = *puVar8;
		puVar8 = puVar8 + 1;
		puVar11 = puVar11 + 1;
	}
	for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
		*(undefined *)puVar11 = *(undefined *)puVar8;
		puVar8 = (undefined4 *)((int)puVar8 + 1);
		puVar11 = (undefined4 *)((int)puVar11 + 1);
	}
	uVar4 = 0xffffffff;
	pcVar7 = "\\*.*";
	do {
		pcVar9 = pcVar7;
		if (uVar4 == 0) break;
		uVar4 = uVar4 - 1;
		pcVar9 = pcVar7 + 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar9;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	iVar6 = -1;
	pcVar7 = name;
	do {
		pcVar10 = pcVar7;
		if (iVar6 == 0) break;
		iVar6 = iVar6 + -1;
		pcVar10 = pcVar7 + 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar10;
	} while (cVar1 != '\0');
	puVar8 = (undefined4 *)(pcVar9 + -uVar4);
	puVar11 = (undefined4 *)(pcVar10 + -1);
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
		*puVar11 = *puVar8;
		puVar8 = puVar8 + 1;
		puVar11 = puVar11 + 1;
	}
	for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
		*(undefined *)puVar11 = *(undefined *)puVar8;
		puVar8 = (undefined4 *)((int)puVar8 + 1);
		puVar11 = (undefined4 *)((int)puVar11 + 1);
	}
	handle = std::_findfirst32(name,(_finddata32_t *)&local_518);
	if (handle != (HANDLE)0xffffffff) {
		do {
			pcVar7 = ".";
			pbVar3 = (byte *)local_504;
			do {
				bVar2 = *pbVar3;
				bVar12 = bVar2 < (byte)*pcVar7;
				if (bVar2 != *pcVar7) {
LAB_00480709:
					iVar6 = (1 - (uint)bVar12) - (uint)(bVar12 != 0);
					goto LAB_0048070e;
				}
				if (bVar2 == 0) break;
				bVar2 = pbVar3[1];
				bVar12 = bVar2 < ((byte *)pcVar7)[1];
				if (bVar2 != ((byte *)pcVar7)[1]) goto LAB_00480709;
				pbVar3 = pbVar3 + 2;
				pcVar7 = (char *)((byte *)pcVar7 + 2);
			} while (bVar2 != 0);
			iVar6 = 0;
LAB_0048070e:
			if (iVar6 != 0) {
				pcVar7 = "..";
				pbVar3 = (byte *)local_504;
				do {
					bVar2 = *pbVar3;
					bVar12 = bVar2 < (byte)*pcVar7;
					if (bVar2 != *pcVar7) {
LAB_00480743:
						iVar6 = (1 - (uint)bVar12) - (uint)(bVar12 != 0);
						goto LAB_00480748;
					}
					if (bVar2 == 0) break;
					bVar2 = pbVar3[1];
					bVar12 = bVar2 < ((byte *)pcVar7)[1];
					if (bVar2 != ((byte *)pcVar7)[1]) goto LAB_00480743;
					pbVar3 = pbVar3 + 2;
					pcVar7 = (char *)((byte *)pcVar7 + 2);
				} while (bVar2 != 0);
				iVar6 = 0;
LAB_00480748:
				if (iVar6 != 0) {
					uVar4 = 0xffffffff;
					pcVar7 = dirName;
					do {
						pcVar9 = pcVar7;
						if (uVar4 == 0) break;
						uVar4 = uVar4 - 1;
						pcVar9 = pcVar7 + 1;
						cVar1 = *pcVar7;
						pcVar7 = pcVar9;
					} while (cVar1 != '\0');
					uVar4 = ~uVar4;
					puVar8 = (undefined4 *)(pcVar9 + -uVar4);
					puVar11 = (undefined4 *)name;
					for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
						*puVar11 = *puVar8;
						puVar8 = puVar8 + 1;
						puVar11 = puVar11 + 1;
					}
					for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
						*(undefined *)puVar11 = *(undefined *)puVar8;
						puVar8 = (undefined4 *)((int)puVar8 + 1);
						puVar11 = (undefined4 *)((int)puVar11 + 1);
					}
					uVar4 = 0xffffffff;
					pcVar7 = "\\";
					do {
						pcVar9 = pcVar7;
						if (uVar4 == 0) break;
						uVar4 = uVar4 - 1;
						pcVar9 = pcVar7 + 1;
						cVar1 = *pcVar7;
						pcVar7 = pcVar9;
					} while (cVar1 != '\0');
					uVar4 = ~uVar4;
					iVar6 = -1;
					pcVar7 = name;
					do {
						pcVar10 = pcVar7;
						if (iVar6 == 0) break;
						iVar6 = iVar6 + -1;
						pcVar10 = pcVar7 + 1;
						cVar1 = *pcVar7;
						pcVar7 = pcVar10;
					} while (cVar1 != '\0');
					puVar8 = (undefined4 *)(pcVar9 + -uVar4);
					puVar11 = (undefined4 *)(pcVar10 + -1);
					for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
						*puVar11 = *puVar8;
						puVar8 = puVar8 + 1;
						puVar11 = puVar11 + 1;
					}
					for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
						*(undefined *)puVar11 = *(undefined *)puVar8;
						puVar8 = (undefined4 *)((int)puVar8 + 1);
						puVar11 = (undefined4 *)((int)puVar11 + 1);
					}
					uVar4 = 0xffffffff;
					pcVar7 = local_504;
					do {
						pcVar9 = pcVar7;
						if (uVar4 == 0) break;
						uVar4 = uVar4 - 1;
						pcVar9 = pcVar7 + 1;
						cVar1 = *pcVar7;
						pcVar7 = pcVar9;
					} while (cVar1 != '\0');
					uVar4 = ~uVar4;
					iVar6 = -1;
					pcVar7 = name;
					do {
						pcVar10 = pcVar7;
						if (iVar6 == 0) break;
						iVar6 = iVar6 + -1;
						pcVar10 = pcVar7 + 1;
						cVar1 = *pcVar7;
						pcVar7 = pcVar10;
					} while (cVar1 != '\0');
					puVar8 = (undefined4 *)(pcVar9 + -uVar4);
					puVar11 = (undefined4 *)(pcVar10 + -1);
					for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
						*puVar11 = *puVar8;
						puVar8 = puVar8 + 1;
						puVar11 = puVar11 + 1;
					}
					for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
						*(undefined *)puVar11 = *(undefined *)puVar8;
						puVar8 = (undefined4 *)((int)puVar8 + 1);
						puVar11 = (undefined4 *)((int)puVar11 + 1);
					}
					if ((local_518 & 0x10) == 0) {
						File_CheckFile(name);
					}
					else {
						File_CheckDirectory(name);
					}
				}
			}
			iVar6 = std::_findnext32(handle,(_finddata32_t *)&local_518);
		} while (iVar6 == 0);
		std::_findclose(handle);
	}
	return;
}



void __cdecl lego::file::File_CheckFile(char *fileName)
{
	int iVar1;
	uint uVar2;
	FileCheck_Globs *_Str2;
	
	uVar2 = 0;
	if (globs::checkGlobs.numInList != 0) {
		_Str2 = &globs::checkGlobs;
		do {
			iVar1 = std::_stricmp(fileName,(char *)_Str2);
			if (iVar1 == 0) {
				return;
			}
			uVar2 = uVar2 + 1;
			_Str2 = (FileCheck_Globs *)_Str2->loadedList[1];
		} while (uVar2 < globs::checkGlobs.numInList);
	}
	return;
}



BOOL __cdecl lego::res::Mesh_Initialise(char *sharedTextureDir)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	int iVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	undefined4 *puVar8;
	Mesh **ppMVar9;
	
	globs::meshGlobs.postRenderMeshList = (Mesh_PostRenderInfo *)0x0;
	Mesh_ClearPostRenderList();
	if (sharedTextureDir != (char *)0x0) {
		uVar2 = 0xffffffff;
		pcVar7 = sharedTextureDir;
		do {
			if (uVar2 == 0) break;
			uVar2 = uVar2 - 1;
			cVar1 = *pcVar7;
			pcVar7 = pcVar7 + 1;
		} while (cVar1 != '\0');
		uVar2 = ~uVar2;
		uVar5 = uVar2 - 1;
		if (sharedTextureDir[uVar2 - 2] != '\\') {
			uVar5 = uVar2;
		}
		globs::meshGlobs.sharedTextureDir = (char *)std::malloc(uVar5 + 1);
		uVar2 = 0xffffffff;
		do {
			pcVar7 = sharedTextureDir;
			if (uVar2 == 0) break;
			uVar2 = uVar2 - 1;
			pcVar7 = sharedTextureDir + 1;
			cVar1 = *sharedTextureDir;
			sharedTextureDir = pcVar7;
		} while (cVar1 != '\0');
		uVar2 = ~uVar2;
		puVar6 = (undefined4 *)(pcVar7 + -uVar2);
		puVar8 = (undefined4 *)globs::meshGlobs.sharedTextureDir;
		for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
			*puVar8 = *puVar6;
			puVar6 = puVar6 + 1;
			puVar8 = puVar8 + 1;
		}
		for (uVar2 = uVar2 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {
			*(undefined *)puVar8 = *(undefined *)puVar6;
			puVar6 = (undefined4 *)((int)puVar6 + 1);
			puVar8 = (undefined4 *)((int)puVar8 + 1);
		}
		globs::meshGlobs.sharedTextureDir[uVar5 - 1] = '\\';
		globs::meshGlobs.sharedTextureDir[uVar5] = '\0';
	}
	ppMVar9 = globs::meshGlobs.listSet;
	for (iVar4 = 0x14; iVar4 != 0; iVar4 = iVar4 + -1) {
		*ppMVar9 = (Mesh *)0x0;
		ppMVar9 = ppMVar9 + 1;
	}
	globs::meshGlobs.freeList = (Mesh *)0x0;
	globs::meshGlobs.listCount = 0;
	Mesh_CreateGlobalMaterial();
	return 1;
}



BOOL __cdecl lego::res::Mesh_CreateGlobalMaterial(void)
{
	HRESULT HVar1;
	IDirect3D3 *d3d3;
	D3DMaterial material;
	
	material.dwSize = 0x50;
	material.diffuse.red = 1.0;
	material.diffuse.green = 1.0;
	material.diffuse.blue = 1.0;
	material.diffuse.alpha = 1.0;
	material.ambient.red = 0.0;
	material.ambient.green = 0.0;
	material.ambient.blue = 0.0;
	material.ambient.alpha = 0.0;
	material.specular.red = 0.0;
	material.specular.green = 0.0;
	material.specular.blue = 0.0;
	material.specular.alpha = 0.0;
	material.emissive.red = 0.0;
	material.emissive.green = 0.0;
	material.emissive.blue = 0.0;
	material.emissive.alpha = 0.0;
	material.power = 0.0;
	material.hTexture = 0;
	material.dwRampSize = 0;
										// IDirect3DDevice3->GetDirect3D(this, IDirect3D3** lplpD3D)
	(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetDirect3D)(globs::mainGlobs.imDevice,&d3d3);
										// IDirect3D3->CreateMaterial(this, IDirect3DMaterial3** lplpDirect3DMaterial3,
										// IUnknown* pUnkOuter)
	HVar1 = (**(code **)((int)*d3d3 + 0x14))(d3d3,&globs::meshGlobs.imMat,(void *)0x0);
	if (HVar1 == 0) {
										// IDirect3DMaterial3->GetHandle(this, IDirect3DDevice3* lpDirect3DDevice,
										// DWORD* lpHandle)
		HVar1 = (*(code *)(globs::meshGlobs.imMat)->lpVtbl->GetHandle)
											(globs::meshGlobs.imMat,globs::mainGlobs.imDevice,&globs::meshGlobs.matHandle)
		;
		if (HVar1 == 0) {
			Mesh_SetMaterial(&material);
			if (d3d3 != (IDirect3D3 *)0x0) {
				(**(code **)((int)*d3d3 + 8))(d3d3);
			}
			return 1;
		}
		if (d3d3 != (IDirect3D3 *)0x0) {
			(**(code **)((int)*d3d3 + 8))(d3d3);
		}
	}
	else {
		if (d3d3 != (IDirect3D3 *)0x0) {
			(**(code **)((int)*d3d3 + 8))(d3d3);
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl lego::res::Mesh_SetMaterial(D3DMaterial *newMaterial)
{
	HRESULT HVar1;
	
	HVar1 = (*(code *)(globs::meshGlobs.imMat)->lpVtbl->SetMaterial)
										(globs::meshGlobs.imMat,newMaterial);
	return (uint)(HVar1 == 0);
}



Mesh * __cdecl lego::res::Mesh_ObtainFromList(void)
{
	Mesh *pMVar1;
	int iVar2;
	Mesh *pMVar3;
	
	if (globs::meshGlobs.freeList == (Mesh *)0x0) {
		Mesh_AddList();
	}
	pMVar1 = globs::meshGlobs.freeList;
	pMVar3 = globs::meshGlobs.freeList;
	globs::meshGlobs.freeList = (globs::meshGlobs.freeList)->nextFree;
	for (iVar2 = 0xd; iVar2 != 0; iVar2 = iVar2 + -1) {
		pMVar3->groupCount = 0;
		pMVar3 = (Mesh *)&pMVar3->listSize;
	}
	pMVar1->nextFree = pMVar1;
	return pMVar1;
}



void __cdecl lego::res::Mesh_ReturnToList(Mesh *mesh)
{
	mesh->nextFree = globs::meshGlobs.freeList;
	globs::meshGlobs.freeList = mesh;
	return;
}



void __cdecl lego::res::Mesh_AddList(void)
{
	Mesh *pMVar1;
	Mesh *pMVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::meshGlobs.listCount & 0x1f);
	pMVar2 = (Mesh *)std::malloc(uVar4 * 0x34);
	globs::meshGlobs.listSet[globs::meshGlobs.listCount] = pMVar2;
	pMVar2 = globs::meshGlobs.listSet[globs::meshGlobs.listCount];
	if (pMVar2 != (Mesh *)0x0) {
		globs::meshGlobs.listCount = globs::meshGlobs.listCount + 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pMVar1 = pMVar2;
			do {
				pMVar1->nextFree = pMVar1 + 1;
				iVar3 = iVar3 + -1;
				pMVar1 = pMVar1 + 1;
			} while (iVar3 != 0);
		}
		pMVar2[uVar4 - 1].nextFree = globs::meshGlobs.freeList;
		globs::meshGlobs.freeList = pMVar2;
	}
	return;
}



Mesh * __cdecl
lego::res::Mesh_CreateOnFrame
					(IDirect3DRMFrame3 *frame,MeshRenderCallback *renderFunc,uint renderFlags,void *data,
					int meshType)
{
	IDirect3DRMUserVisual **ppIVar1;
	Mesh *meshData;
	uint unaff_EBX;
	MeshRenderCallback *unaff_ESI;
	void *unaff_retaddr;
	
	meshData = Mesh_ObtainFromList();
	GetRoot();
	ppIVar1 = &meshData->uv;
										// IDirect3DRM3->CreateUserVisual(this, TD3DRMUserVisualCallback fn, void*
										// lpArg, IDirect3DRMUserVisual** lplpD3DRMUV)
	(*(code *)(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateUserVisual)
						(globs::mainGlobs.lpD3DRM,Mesh_RenderCallback,meshData,ppIVar1);
										// IDirect3DRMFrame3->AddVisual(this, IDirect3DRMVisual* lpD3DRMVisual)
	(*frame->lpVtbl->AddVisual)(frame,(IDirect3DRMVisual *)*ppIVar1);
										// IDirect3DRMUserVisual->SetAppData(this, Struct_34* ulData)
	(*(*ppIVar1)->lpVtbl->SetAppData)((IUnknown *)*ppIVar1,(DWORD)meshData);
	(meshData->renderDesc).renderCallbackData = unaff_retaddr;
	meshData->frameCreatedOn = frame;
	(meshData->renderDesc).renderCallback = unaff_ESI;
	(meshData->renderDesc).renderFlags = unaff_EBX;
	if (frame == (IDirect3DRMFrame3 *)0x1) {
		meshData->numOfRefs = 1;
		meshData->flags = meshData->flags | 2;
		return meshData;
	}
	if (frame == (IDirect3DRMFrame3 *)0x2) {
		meshData->flags = meshData->flags | 4;
	}
	meshData->numOfRefs = 1;
	return meshData;
}



Mesh * __cdecl lego::res::Mesh_Clone(Mesh *mesh,IDirect3DRMFrame3 *frame)
{
	IDirect3DRMUserVisual **ppIVar1;
	Mesh *mesh_00;
	Mesh_Group *pMVar2;
	int iVar3;
	uint uVar4;
	IDirect3DRMFrame3 *unaff_EBP;
	Mesh *pMVar5;
	Mesh_Group *pMVar6;
	D3DRMGroupIndex groupID;
	Mesh *pMVar7;
	
	mesh_00 = Mesh_ObtainFromList();
	if (mesh->clonedFrom != (Mesh *)0x0) {
		mesh = mesh->clonedFrom;
	}
	pMVar5 = mesh;
	pMVar7 = mesh_00;
	for (iVar3 = 0xd; iVar3 != 0; iVar3 = iVar3 + -1) {
		pMVar7->groupCount = pMVar5->groupCount;
		pMVar5 = (Mesh *)&pMVar5->listSize;
		pMVar7 = (Mesh *)&pMVar7->listSize;
	}
	mesh_00->clonedFrom = mesh;
	mesh_00->listSize = mesh_00->groupCount;
	pMVar2 = (Mesh_Group *)std::malloc(mesh_00->groupCount * 0x70);
	mesh_00->groupList = pMVar2;
	pMVar6 = mesh->groupList;
	for (uVar4 = mesh_00->groupCount * 0x70 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
		pMVar2->faceDataSize = pMVar6->faceDataSize;
		pMVar6 = (Mesh_Group *)&pMVar6->vertexCount;
		pMVar2 = (Mesh_Group *)&pMVar2->vertexCount;
	}
	for (iVar3 = 0; iVar3 != 0; iVar3 = iVar3 + -1) {
		*(undefined *)&pMVar2->faceDataSize = *(undefined *)&pMVar6->faceDataSize;
		pMVar6 = (Mesh_Group *)((int)&pMVar6->faceDataSize + 1);
		pMVar2 = (Mesh_Group *)((int)&pMVar2->faceDataSize + 1);
	}
	groupID = D3DRMGROUP_0;
	if (mesh_00->groupCount != 0) {
		iVar3 = 0;
		do {
			Mesh_CreateGroupMaterial(mesh_00,groupID);
			Mesh_SetGroupMaterial
								(mesh_00,groupID,(D3DMaterial *)((int)&(mesh->groupList->material).dwSize + iVar3));
			groupID = groupID + 1;
			iVar3 = iVar3 + 0x70;
		} while (groupID < mesh_00->groupCount);
	}
	ppIVar1 = &mesh_00->uv;
										// IDirect3DRM3->CreateUserVisual(this, TD3DRMUserVisualCallback fn, void*
										// lpArg, IDirect3DRMUserVisual** lplpD3DRMUV)
	(*(code *)(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateUserVisual)
						(globs::mainGlobs.lpD3DRM,Mesh_RenderCallback,mesh_00,ppIVar1);
										// IDirect3DRMFrame3->AddVisual(this, IDirect3DRMVisual* lpD3DRMVisual)
	(*unaff_EBP->lpVtbl->AddVisual)(unaff_EBP,(IDirect3DRMVisual *)*ppIVar1);
										// IDirect3DRMUserVisual->SetAppData(this, Struct_3c* ulData)
	(*(*ppIVar1)->lpVtbl->SetAppData)((IUnknown *)*ppIVar1,(DWORD)mesh_00);
	mesh_00->frameCreatedOn = unaff_EBP;
	mesh->numOfRefs = mesh->numOfRefs + 1;
	mesh->flags = mesh->flags | 0x200000;
	mesh_00->numOfRefs = 0;
	return mesh_00;
}



Mesh * __cdecl lego::res::Mesh_Load(char *filename,IDirect3DRMFrame3 *frame,BOOL noTextures)
{
	char *pcVar1;
	char cVar2;
	BOOL BVar3;
	Mesh *mesh;
	uint uVar4;
	uint uVar5;
	char *pcVar6;
	char *pcVar7;
	undefined4 *puVar8;
	undefined4 *puVar9;
	void *struct20;
	char filenameBuffer [260];
	
	uVar4 = 0xffffffff;
	pcVar7 = filename;
	do {
		pcVar6 = pcVar7;
		if (uVar4 == 0) break;
		uVar4 = uVar4 - 1;
		pcVar6 = pcVar7 + 1;
		cVar2 = *pcVar7;
		pcVar7 = pcVar6;
	} while (cVar2 != '\0');
	uVar4 = ~uVar4;
	pcVar7 = filenameBuffer;
	puVar8 = (undefined4 *)(pcVar6 + -uVar4);
	puVar9 = (undefined4 *)filenameBuffer;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
		*puVar9 = *puVar8;
		puVar8 = puVar8 + 1;
		puVar9 = puVar9 + 1;
	}
	for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
		*(undefined *)puVar9 = *(undefined *)puVar8;
		puVar8 = (undefined4 *)((int)puVar8 + 1);
		puVar9 = (undefined4 *)((int)puVar9 + 1);
	}
	pcVar6 = filenameBuffer;
	while (filenameBuffer[0] != '\0') {
		if (filenameBuffer[0] == '\\') {
			pcVar7 = pcVar6;
		}
		pcVar1 = pcVar6 + 1;
		pcVar6 = pcVar6 + 1;
		filenameBuffer[0] = *pcVar1;
	}
	pcVar7[pcVar7 != filenameBuffer] = '\0';
	BVar3 = lw::LoadAppObj(filename,(APPOBJ **)&struct20,0);
	if (BVar3 == 0) {
		return (Mesh *)0x0;
	}
	mesh = Mesh_CreateOnFrame(frame,(MeshRenderCallback *)0x0,0x3000,(void *)0x0,2);
	Mesh_ParseLWO(filenameBuffer,mesh,(APPOBJ *)struct20,noTextures);
	lw::FreeLWOB((APPOBJ *)struct20);
	return mesh;
}



// WARNING: Type propagation algorithm not settling

BOOL __cdecl
lego::res::Mesh_ParseLWO(char *basePath,Mesh *mesh,APPOBJ *lightWaveObject,BOOL noTextures)
{
	float r;
	uint uVar1;
	LWPOLY *pLVar2;
	Vector3F *buffer;
	Vector3F **buffer_00;
	uint *buffer_01;
	undefined4 *buffer_02;
	uint *buffer_03;
	uint *buffer_04;
	void *buffer_05;
	undefined4 *buffer_06;
	Mesh_LightWave_Surface *pMVar3;
	D3DRMGroupIndex groupID;
	char *pcVar4;
	Container_Texture *pCVar5;
	uint uVar6;
	int iVar7;
	float *pfVar8;
	int iVar9;
	float *pfVar10;
	uint *puVar11;
	int iVar12;
	int iVar13;
	int iVar14;
	int iVar15;
	uint uVar16;
	undefined4 *puVar17;
	int iVar18;
	float g;
	float fVar19;
	Point2F *textCoords;
	Point2F *local_ac;
	uint local_a8;
	uint local_a4;
	uint *local_a0;
	int *local_9c;
	Vector3F *local_98;
	uint *local_8c;
	Vector3F **local_88;
	Point2F *local_78;
	Point2F *local_74;
	int local_3c [4];
	undefined4 local_2c;
	undefined4 local_28;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	uVar6 = (lightWaveObject->aoSize).lwVertCount;
	local_3c[2] = 2;
	local_2c = 2;
	uVar1 = (lightWaveObject->aoSize).lwPolyCount;
	iVar12 = uVar6 * 2;
	iVar15 = uVar1 * 6;
	local_3c[0] = 0;
	local_3c[1] = 1;
	local_3c[3] = 0;
	local_28 = 3;
	local_74 = (Point2F *)0x0;
	if (lightWaveObject->aoFileUV == (FileStream *)0x0) {
		local_78 = (Point2F *)std::malloc(uVar6 * 0x10);
	}
	else {
		local_74 = (Point2F *)std::malloc(uVar6 * 0x140);
		Mesh_UViewMesh(lightWaveObject,local_74);
		iVar12 = (lightWaveObject->aoSize).lwVertCount * 2;
		local_78 = (Point2F *)std::malloc((lightWaveObject->aoSize).lwSurfaceCount * iVar12 * 8);
	}
	uVar16 = iVar12 * (lightWaveObject->aoSize).lwSurfaceCount;
	buffer = (Vector3F *)std::malloc(uVar16 * 0xc);
	buffer_00 = (Vector3F **)std::malloc(uVar16 * 4);
	buffer_01 = (uint *)std::malloc((lightWaveObject->aoSize).lwSurfaceCount << 2);
	buffer_02 = (undefined4 *)std::malloc(uVar16 * 4);
	buffer_03 = (uint *)std::malloc(iVar15 * (lightWaveObject->aoSize).lwSurfaceCount * 4);
	buffer_04 = (uint *)std::malloc((lightWaveObject->aoSize).lwSurfaceCount << 2);
	buffer_05 = std::malloc((lightWaveObject->aoSize).lwPolyCount * 0xc);
	buffer_06 = (undefined4 *)std::malloc(iVar12 * 0xc);
	puVar11 = buffer_01;
	for (uVar6 = (lightWaveObject->aoSize).lwSurfaceCount & 0x3fffffff; uVar6 != 0; uVar6 = uVar6 - 1)
	{
		*puVar11 = 0;
		puVar11 = puVar11 + 1;
	}
	for (iVar7 = 0; iVar7 != 0; iVar7 = iVar7 + -1) {
		*(undefined *)puVar11 = 0;
		puVar11 = (uint *)((int)puVar11 + 1);
	}
	puVar17 = buffer_02;
	for (uVar16 = uVar16 & 0x3fffffff; uVar16 != 0; uVar16 = uVar16 - 1) {
		*puVar17 = 0xffffffff;
		puVar17 = puVar17 + 1;
	}
	for (iVar7 = 0; iVar7 != 0; iVar7 = iVar7 + -1) {
		*(undefined *)puVar17 = 0xff;
		puVar17 = (undefined4 *)((int)puVar17 + 1);
	}
	puVar11 = buffer_04;
	for (uVar6 = (lightWaveObject->aoSize).lwSurfaceCount & 0x3fffffff; uVar6 != 0; uVar6 = uVar6 - 1)
	{
		*puVar11 = 0;
		puVar11 = puVar11 + 1;
	}
	for (iVar7 = 0; iVar7 != 0; iVar7 = iVar7 + -1) {
		*(undefined *)puVar11 = 0;
		puVar11 = (uint *)((int)puVar11 + 1);
	}
	puVar17 = buffer_06;
	for (uVar6 = iVar12 * 3 & 0x3fffffff; uVar6 != 0; uVar6 = uVar6 - 1) {
		*puVar17 = 0;
		puVar17 = puVar17 + 1;
	}
	for (iVar7 = 0; iVar7 != 0; iVar7 = iVar7 + -1) {
		*(undefined *)puVar17 = 0;
		puVar17 = (undefined4 *)((int)puVar17 + 1);
	}
	pMVar3 = (Mesh_LightWave_Surface *)std::malloc((lightWaveObject->aoSize).lwSurfaceCount * 0x3c);
	mesh->lightWaveSurf = pMVar3;
	for (uVar6 = (lightWaveObject->aoSize).lwSurfaceCount * 0xf & 0x3fffffff; uVar6 != 0;
			uVar6 = uVar6 - 1) {
		pMVar3->textureSeq = (Container_Texture **)0x0;
		pMVar3 = (Mesh_LightWave_Surface *)&pMVar3->texture;
	}
	for (iVar7 = 0; iVar7 != 0; iVar7 = iVar7 + -1) {
		*(undefined *)&pMVar3->textureSeq = 0;
		pMVar3 = (Mesh_LightWave_Surface *)((int)&pMVar3->textureSeq + 1);
	}
	local_8c = (uint *)0x0;
	if ((lightWaveObject->aoSize).lwPolyCount != 0) {
		local_9c = (int *)0x0;
		do {
			pLVar2 = lightWaveObject->aoPoly;
			pfVar10 = lightWaveObject->aoVerts;
			pfVar8 = &local_24.y;
			uVar6 = 0;
			do {
				uVar16 = uVar6 + 2;
				uVar6 = (uint)*(ushort *)(uVar6 + *(int *)((int)&pLVar2->plyData + (int)local_9c));
				pfVar8[-1] = pfVar10[uVar6 * 3];
				*pfVar8 = pfVar10[uVar6 * 3 + 1];
				pfVar8[1] = pfVar10[uVar6 * 3 + 2];
				pfVar8 = pfVar8 + 3;
				uVar6 = uVar16;
			} while (uVar16 < 6);
			math::Maths_PlaneNormal
								((Vector3F *)((int)buffer_05 + (int)local_9c),&local_24,&local_18,&local_c);
			local_8c = (uint *)((int)local_8c + 1);
			local_9c = (int *)((int)local_9c + 0xc);
		} while (local_8c < (lightWaveObject->aoSize).lwPolyCount);
	}
	Mesh_GetSurfInfo(basePath,lightWaveObject,mesh->lightWaveSurf,noTextures);
	iVar7 = 0;
	local_8c = (uint *)0x0;
	if ((lightWaveObject->aoSize).lwPolyCount != 0) {
		pfVar10 = (float *)((int)buffer_05 + 8);
		do {
			iVar9 = *(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7);
			iVar13 = iVar15 * iVar9;
			iVar9 = iVar12 * iVar9;
			if (*(int *)((int)&lightWaveObject->aoPoly->plyCount + iVar7) == 3) {
				local_a4 = 0;
				do {
					iVar14 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
					uVar6 = (uint)*(ushort *)(*(int *)(iVar14 + 8) + local_a4);
					if (buffer_02[uVar6 + iVar9] == -1) {
						buffer[buffer_01[*(int *)(iVar14 + 4)] + iVar9].x = lightWaveObject->aoVerts[uVar6 * 3];
						buffer[buffer_01[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + iVar9].y
								 = lightWaveObject->aoVerts[uVar6 * 3 + 1];
						buffer[buffer_01[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + iVar9].z
								 = lightWaveObject->aoVerts[uVar6 * 3 + 2];
						if (lightWaveObject->aoFileUV != (FileStream *)0x0) {
							iVar14 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
							uVar16 = (uint)*(ushort *)(*(int *)(iVar14 + 8) + local_a4);
							uVar6 = buffer_01[*(int *)(iVar14 + 4)];
							local_78[uVar6 + iVar9].x = local_74[uVar16].x;
							local_78[uVar6 + iVar9].y = local_74[uVar16].y;
						}
						uVar6 = (uint)*(ushort *)
													 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) + local_a4);
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						*pfVar8 = pfVar10[-2] + (float)buffer_06[uVar6 * 3];
						pfVar8[1] = pfVar8[1] + pfVar10[-1];
						pfVar8[2] = pfVar8[2] + *pfVar10;
						uVar6 = (uint)*(ushort *)
													 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) + local_a4);
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						fVar19 = 1.0 / SQRT(*pfVar8 * *pfVar8 +
																pfVar8[2] * pfVar8[2] +
																(float)buffer_06[uVar6 * 3 + 1] * (float)buffer_06[uVar6 * 3 + 1]);
						*pfVar8 = fVar19 * *pfVar8;
						pfVar8[1] = fVar19 * pfVar8[1];
						pfVar8[2] = fVar19 * pfVar8[2];
						iVar14 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_00[buffer_01[*(int *)(iVar14 + 4)] + iVar9] =
								 (Vector3F *)(buffer_06 + (uint)*(ushort *)(*(int *)(iVar14 + 8) + local_a4) * 3);
						iVar14 = *(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7);
						buffer_03[buffer_04[iVar14] + iVar13] = buffer_01[iVar14];
						buffer_04[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] =
								 buffer_04[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + 1;
						iVar14 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_02[(uint)*(ushort *)(*(int *)(iVar14 + 8) + local_a4) + iVar9] =
								 buffer_01[*(int *)(iVar14 + 4)];
						iVar14 = *(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7);
						puVar11 = buffer_01;
					}
					else {
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						*pfVar8 = pfVar10[-2] + (float)buffer_06[uVar6 * 3];
						pfVar8[1] = pfVar8[1] + pfVar10[-1];
						pfVar8[2] = pfVar8[2] + *pfVar10;
						pfVar8 = (float *)(buffer_06 +
															(uint)*(ushort *)
																		 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) +
																		 local_a4) * 3);
						fVar19 = 1.0 / SQRT(*pfVar8 * *pfVar8 + pfVar8[2] * pfVar8[2] + pfVar8[1] * pfVar8[1]);
						*pfVar8 = fVar19 * *pfVar8;
						pfVar8[1] = fVar19 * pfVar8[1];
						pfVar8[2] = fVar19 * pfVar8[2];
						iVar14 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_03[buffer_04[*(int *)(iVar14 + 4)] + iVar13] =
								 buffer_02[(uint)*(ushort *)(*(int *)(iVar14 + 8) + local_a4) + iVar9];
						iVar14 = *(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7);
						puVar11 = buffer_04;
					}
					local_a4 = local_a4 + 2;
					puVar11[iVar14] = puVar11[iVar14] + 1;
				} while (local_a4 < 6);
			}
			else {
				local_9c = local_3c;
				local_a8 = 6;
				do {
					iVar18 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
					iVar14 = *local_9c * 2;
					uVar6 = (uint)*(ushort *)(*(int *)(iVar18 + 8) + iVar14);
					if (buffer_02[iVar9 + uVar6] == -1) {
						buffer[buffer_01[*(int *)(iVar18 + 4)] + iVar9].x = lightWaveObject->aoVerts[uVar6 * 3];
						buffer[buffer_01[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + iVar9].y
								 = lightWaveObject->aoVerts[uVar6 * 3 + 1];
						buffer[buffer_01[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + iVar9].z
								 = lightWaveObject->aoVerts[uVar6 * 3 + 2];
						if (lightWaveObject->aoFileUV != (FileStream *)0x0) {
							iVar18 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
							uVar16 = (uint)*(ushort *)(*(int *)(iVar18 + 8) + iVar14);
							uVar6 = buffer_01[*(int *)(iVar18 + 4)];
							local_78[uVar6 + iVar9].x = local_74[uVar16].x;
							local_78[uVar6 + iVar9].y = local_74[uVar16].y;
						}
						uVar6 = (uint)*(ushort *)
													 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) + iVar14);
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						*pfVar8 = pfVar10[-2] + (float)buffer_06[uVar6 * 3];
						pfVar8[1] = pfVar8[1] + pfVar10[-1];
						pfVar8[2] = pfVar8[2] + *pfVar10;
						uVar6 = (uint)*(ushort *)
													 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) + iVar14);
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						fVar19 = 1.0 / SQRT(*pfVar8 * *pfVar8 +
																(float)buffer_06[uVar6 * 3 + 2] * (float)buffer_06[uVar6 * 3 + 2] +
																(float)buffer_06[uVar6 * 3 + 1] * (float)buffer_06[uVar6 * 3 + 1]);
						*pfVar8 = fVar19 * *pfVar8;
						pfVar8[1] = fVar19 * pfVar8[1];
						pfVar8[2] = fVar19 * pfVar8[2];
						iVar18 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_00[buffer_01[*(int *)(iVar18 + 4)] + iVar9] =
								 (Vector3F *)(buffer_06 + (uint)*(ushort *)(*(int *)(iVar18 + 8) + iVar14) * 3);
						iVar18 = *(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7);
						buffer_03[buffer_04[iVar18] + iVar13] = buffer_01[iVar18];
						buffer_04[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] =
								 buffer_04[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + 1;
						iVar18 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_02[(uint)*(ushort *)(*(int *)(iVar18 + 8) + iVar14) + iVar9] =
								 buffer_01[*(int *)(iVar18 + 4)];
						puVar11 = buffer_01;
					}
					else {
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						*pfVar8 = pfVar10[-2] + (float)buffer_06[uVar6 * 3];
						pfVar8[1] = pfVar8[1] + pfVar10[-1];
						pfVar8[2] = pfVar8[2] + *pfVar10;
						pfVar8 = (float *)(buffer_06 +
															(uint)*(ushort *)
																		 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) +
																		 iVar14) * 3);
						fVar19 = 1.0 / SQRT(*pfVar8 * *pfVar8 + pfVar8[2] * pfVar8[2] + pfVar8[1] * pfVar8[1]);
						*pfVar8 = *pfVar8 * fVar19;
						pfVar8[1] = fVar19 * pfVar8[1];
						pfVar8[2] = fVar19 * pfVar8[2];
						iVar18 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_03[buffer_04[*(int *)(iVar18 + 4)] + iVar13] =
								 buffer_02[(uint)*(ushort *)(*(int *)(iVar18 + 8) + iVar14) + iVar9];
						puVar11 = buffer_04;
					}
					puVar11[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] =
							 puVar11[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + 1;
					local_9c = local_9c + 1;
					local_a8 = local_a8 + -1;
				} while (local_a8 != 0);
			}
			local_8c = (uint *)((int)local_8c + 1);
			iVar7 = iVar7 + 0xc;
			pfVar10 = pfVar10 + 3;
		} while (local_8c < (lightWaveObject->aoSize).lwPolyCount);
	}
	iVar15 = 0;
	local_a8 = 0;
	if ((lightWaveObject->aoSize).lwSurfaceCount != 0) {
		local_a4 = 0;
		local_ac = local_78;
		local_a0 = buffer_01;
		local_98 = buffer;
		local_8c = buffer_03;
		local_88 = buffer_00;
		do {
			uVar6 = *(uint *)((int)((int)buffer_04 - (int)buffer_01) + (int)local_a0);
			groupID = Mesh_AddGroup(mesh,uVar6,uVar6 / 3,3,local_8c);
			if (lightWaveObject->aoFileUV == (FileStream *)0x0) {
				pcVar4 = lightWaveObject->aoSurface->srfTCLR + local_a4 + -0x10;
				Mesh_GetTextureUVsWrap
									(*local_a0,local_98,local_78,*(float *)(pcVar4 + 0x24),*(float *)(pcVar4 + 0x28),
									 *(float *)(pcVar4 + 0x2c),*(float *)(pcVar4 + 0x30),*(float *)(pcVar4 + 0x34),
									 *(float *)(pcVar4 + 0x38),*(LWTEXFLAGS *)(pcVar4 + 0x14));
				uVar6 = *local_a0;
				textCoords = local_78;
			}
			else {
				uVar6 = *local_a0;
				textCoords = local_ac;
			}
			Mesh_SetVertices_VNT(mesh,groupID,0,uVar6,local_98,local_88,(Point2I *)textCoords);
			if ((*(uint *)((int)&mesh->lightWaveSurf->flags + iVar15) & 0x200) == 0) {
				uVar6 = 0x3000;
			}
			else {
				Mesh_AlterGroupRenderFlags(mesh,groupID,0x2800);
				uVar6 = 0x2800;
			}
			if ((*(uint *)((int)&mesh->lightWaveSurf->flags + iVar15) & 0x100) != 0) {
				uVar6 = uVar6 | 0x4000000;
				Mesh_AlterGroupRenderFlags(mesh,groupID,uVar6);
			}
			if ((*(byte *)((int)&mesh->lightWaveSurf->texFlags + iVar15) & 0x20) == 0) {
				Mesh_AlterGroupRenderFlags(mesh,groupID,uVar6 | 0x800000);
			}
			if ((lightWaveObject->aoSurface->srfTCLR[local_a4 + 4] & 0x80U) == 0) {
				pCVar5 = *(Container_Texture **)((int)&mesh->lightWaveSurf->texture + iVar15);
				if (pCVar5 != (Container_Texture *)0x0) goto LAB_004818c5;
			}
			else {
				pCVar5 = *(Container_Texture **)((int)&mesh->lightWaveSurf->textureSeq + iVar15);
				if (pCVar5 != (Container_Texture *)0x0) {
					pCVar5 = (Container_Texture *)pCVar5->surface;
LAB_004818c5:
					Mesh_SetGroupTexture(mesh,groupID,pCVar5);
				}
			}
			pMVar3 = mesh->lightWaveSurf;
			iVar7 = (int)&pMVar3->textureSeq + iVar15;
			Mesh_SetGroupColour(mesh,groupID,*(float *)(iVar7 + 0xc) * *(float *)(iVar7 + 0x1c),
													*(float *)(iVar7 + 0x10) * *(float *)(iVar7 + 0x1c),
													*(float *)((int)&(pMVar3->colour).blue + iVar15) *
													*(float *)((int)&pMVar3->diffuse + iVar15),MATERIAL_DIFFUSE);
			iVar7 = (int)&mesh->lightWaveSurf->textureSeq + iVar15;
			Mesh_SetGroupColour(mesh,groupID,*(float *)(iVar7 + 0xc) * *(float *)(iVar7 + 0x20),
													*(float *)(iVar7 + 0x10) * *(float *)(iVar7 + 0x20),
													*(float *)(iVar7 + 0x14) * *(float *)(iVar7 + 0x20),MATERIAL_EMISSIVE);
			iVar7 = (int)&mesh->lightWaveSurf->textureSeq + iVar15;
			if ((*(byte *)((int)&mesh->lightWaveSurf->flags + iVar15) & 8) == 0) {
				fVar19 = *(float *)(iVar7 + 0x24);
				g = *(float *)(iVar7 + 0x24);
				r = *(float *)(iVar7 + 0x24);
			}
			else {
				fVar19 = *(float *)(iVar7 + 0x14) * *(float *)(iVar7 + 0x24);
				g = *(float *)(iVar7 + 0x10) * *(float *)(iVar7 + 0x24);
				r = *(float *)(iVar7 + 0xc) * *(float *)(iVar7 + 0x24);
			}
			Mesh_SetGroupColour(mesh,groupID,r,g,fVar19,MATERIAL_SPECULAR);
			Mesh_SetGroupMaterialValues
								(mesh,groupID,*(float *)((int)&mesh->lightWaveSurf->power + iVar15) * 10.0,
								 MATERIAL_POWER);
			Mesh_SetGroupMaterialValues
								(mesh,groupID,1.0 - *(float *)((int)&mesh->lightWaveSurf->transparency + iVar15),
								 MATERIAL_ALPHA);
			pMVar3 = (Mesh_LightWave_Surface *)((int)&mesh->lightWaveSurf->textureSeq + iVar15);
			iVar15 = iVar15 + 0x3c;
			mesh->groupList[groupID].lightWaveSurfaceInfo = pMVar3;
			local_ac = local_ac + iVar12;
			local_88 = local_88 + iVar12;
			local_98 = local_98 + iVar12;
			local_8c = local_8c + uVar1 * 6;
			local_a0 = local_a0 + 1;
			local_a8 = local_a8 + 1;
			local_a4 = local_a4 + 0x54;
		} while (local_a8 < (lightWaveObject->aoSize).lwSurfaceCount);
	}
	std::free(buffer);
	std::free(buffer_00);
	std::free(local_78);
	std::free(buffer_01);
	std::free(buffer_02);
	std::free(buffer_03);
	std::free(buffer_04);
	std::free(buffer_05);
	std::free(buffer_06);
	if (local_74 != (Point2F *)0x0) {
		std::free(local_74);
	}
	return 1;
}



void __cdecl
lego::res::Mesh_GetSurfInfo
					(char *basePath,APPOBJ *param_2,Mesh_LightWave_Surface *lightWaveSurf,BOOL noTextures)
{
	byte bVar1;
	char *path;
	BOOL BVar2;
	void *pvVar3;
	Container_Texture *pCVar4;
	float fVar5;
	ColourRGBAF *pCVar6;
	int iVar7;
	uint local_618;
	uint local_614;
	uint local_610;
	uint local_60c;
	char local_608 [4];
	char local_604 [260];
	char local_500 [256];
	char local_400 [256];
	char local_300 [256];
	char local_200 [256];
	char local_100 [256];
	
	local_614 = 0;
	if ((param_2->aoSize).lwSurfaceCount != 0) {
		pCVar6 = &lightWaveSurf->colour;
		iVar7 = 0;
		do {
			path = *(char **)(param_2->aoSurface->srfTCLR + iVar7 + -8);
			if ((path == (char *)0x0) || (noTextures != 0)) {
				pCVar6->red = (float)(uint)(byte)param_2->aoSurface->srfTCLR[iVar7 + -4] * 0.00390625;
				pCVar6->green = (float)(uint)(byte)param_2->aoSurface->srfTCLR[iVar7 + -3] * 0.00390625;
				bVar1 = param_2->aoSurface->srfTCLR[iVar7 + -2];
LAB_00481d09:
				local_618 = (uint)bVar1;
				pCVar6->blue = (float)local_618 * 0.00390625;
			}
			else {
				std::_splitpath(path,local_608,local_100,local_400,local_500);
				if ((param_2->aoSurface->srfTCLR[iVar7 + 4] & 0x80U) == 0) {
					std::sprintf(local_604,"%s%s",local_400,local_500);
					pCVar4 = Mesh_LoadTexture(basePath,local_604,0,0);
					pCVar6[-1].blue = (float)pCVar4;
				}
				else {
					BVar2 = Mesh_GetTextureSeqInfo(local_400,local_200,(int *)&local_60c,(int *)&local_610);
					if (BVar2 != 0) {
						pvVar3 = std::malloc(400);
						pCVar6[-1].green = (float)pvVar3;
						fVar5 = 0.0;
						do {
							Mesh_GetNextInSequence(local_200,local_300,&local_60c,local_610);
							std::sprintf(local_604,"%s%s",local_300,local_500);
							pCVar4 = Mesh_LoadTexture(basePath,local_604,0,0);
							*(Container_Texture **)((int)pCVar6[-1].green + (int)fVar5 * 4) = pCVar4;
							if (*(int *)((int)pCVar6[-1].green + (int)fVar5 * 4) == 0) break;
							fVar5 = (float)((int)fVar5 + 1);
						} while ((uint)fVar5 < 100);
						pCVar6[-1].alpha = fVar5;
						pvVar3 = std::realloc((void *)pCVar6[-1].green,(int)fVar5 * 4);
						pCVar6[-1].green = (float)pvVar3;
					}
				}
				if ((param_2->aoSurface->srfTCLR[iVar7 + 8] & 0x80U) != 0) {
					pCVar6->red = (float)(uint)(byte)param_2->aoSurface->srfTCLR[iVar7 + -4] * 0.00390625;
					pCVar6->green = (float)(uint)(byte)param_2->aoSurface->srfTCLR[iVar7 + -3] * 0.00390625;
					bVar1 = param_2->aoSurface->srfTCLR[iVar7 + -2];
					goto LAB_00481d09;
				}
				pCVar6->red = 1.0;
				pCVar6->green = 1.0;
				pCVar6->blue = 1.0;
			}
			pCVar6[1].green = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 0x2c);
			pCVar6[2].red = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 0x30);
			pCVar6[1].red = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 0x34);
			pCVar6[1].blue = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 0x3c);
			pCVar6[1].alpha = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 0x40);
			pCVar6[2].green = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 8);
			pCVar6[2].blue = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 4);
			local_614 = local_614 + 1;
			pCVar6 = (ColourRGBAF *)&pCVar6[3].alpha;
			iVar7 = iVar7 + 0x54;
		} while (local_614 < (param_2->aoSize).lwSurfaceCount);
	}
	return;
}



BOOL __cdecl
lego::res::Mesh_GetTextureSeqInfo(char *tname,char *out_tfname,int *out_tstart,int *out_tnumlen)
{
	char cVar1;
	byte bVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	int iVar7;
	undefined4 *puVar8;
	char *pcVar9;
	char *pcVar10;
	undefined4 *puVar11;
	bool bVar12;
	int local_4;
	
	pcVar9 = tname;
	uVar3 = 0xffffffff;
	pcVar10 = tname;
	do {
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		cVar1 = *pcVar10;
		pcVar10 = pcVar10 + 1;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	iVar6 = 1;
	local_4 = 0;
	if ((0x2f < (byte)tname[uVar3 - 2]) && ((byte)tname[uVar3 - 2] < 0x3a)) {
		iVar7 = uVar3 - 2;
		bVar12 = iVar7 == 0;
		if (!bVar12) {
			do {
				bVar2 = pcVar9[iVar7];
				tname = (char *)(uint)bVar2;
				if ((bVar2 < 0x30) || (0x39 < bVar2)) break;
				local_4 = local_4 + (int)(tname + -0x30) * iVar6;
				iVar6 = iVar6 * 10;
				iVar7 = iVar7 + -1;
			} while (iVar7 != 0);
			bVar12 = iVar7 == 0;
		}
		if (!bVar12) {
			uVar4 = 0xffffffff;
			do {
				pcVar10 = pcVar9;
				if (uVar4 == 0) break;
				uVar4 = uVar4 - 1;
				pcVar10 = pcVar9 + 1;
				cVar1 = *pcVar9;
				pcVar9 = pcVar10;
			} while (cVar1 != '\0');
			uVar4 = ~uVar4;
			puVar8 = (undefined4 *)(pcVar10 + -uVar4);
			puVar11 = (undefined4 *)out_tfname;
			for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
				*puVar11 = *puVar8;
				puVar8 = puVar8 + 1;
				puVar11 = puVar11 + 1;
			}
			for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
				*(undefined *)puVar11 = *(undefined *)puVar8;
				puVar8 = (undefined4 *)((int)puVar8 + 1);
				puVar11 = (undefined4 *)((int)puVar11 + 1);
			}
			out_tfname[iVar7 + 1] = '\0';
			*out_tnumlen = (uVar3 - iVar7) + -2;
			*out_tstart = local_4;
			return (BOOL)out_tnumlen;
		}
	}
	return (BOOL)(int *)0x0;
}



void __cdecl
lego::res::Mesh_GetNextInSequence
					(char *baseName,char *out_nextTextName,uint *out_texNum,uint tnumlen)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	int iVar5;
	undefined4 *puVar6;
	char *pcVar7;
	char *pcVar8;
	char *pcVar9;
	undefined4 *puVar10;
	char local_10 [16];
	
	uVar3 = 0xffffffff;
	do {
		pcVar8 = baseName;
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		pcVar8 = baseName + 1;
		cVar1 = *baseName;
		baseName = pcVar8;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	puVar6 = (undefined4 *)(pcVar8 + -uVar3);
	puVar10 = (undefined4 *)out_nextTextName;
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
		*puVar10 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar10 = puVar10 + 1;
	}
	for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
		*(undefined *)puVar10 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar10 = (undefined4 *)((int)puVar10 + 1);
	}
	std::sprintf(local_10,"%d",*out_texNum);
	uVar3 = 0xffffffff;
	pcVar8 = local_10;
	do {
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		cVar1 = *pcVar8;
		pcVar8 = pcVar8 + 1;
	} while (cVar1 != '\0');
	iVar2 = tnumlen - (~uVar3 - 1);
	while (iVar2 != 0) {
		uVar3 = 0xffffffff;
		pcVar8 = "0";
		do {
			pcVar7 = pcVar8;
			if (uVar3 == 0) break;
			uVar3 = uVar3 - 1;
			pcVar7 = pcVar8 + 1;
			cVar1 = *pcVar8;
			pcVar8 = pcVar7;
		} while (cVar1 != '\0');
		uVar3 = ~uVar3;
		iVar5 = -1;
		pcVar8 = out_nextTextName;
		do {
			pcVar9 = pcVar8;
			if (iVar5 == 0) break;
			iVar5 = iVar5 + -1;
			pcVar9 = pcVar8 + 1;
			cVar1 = *pcVar8;
			pcVar8 = pcVar9;
		} while (cVar1 != '\0');
		puVar6 = (undefined4 *)(pcVar7 + -uVar3);
		puVar10 = (undefined4 *)(pcVar9 + -1);
		for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
			*puVar10 = *puVar6;
			puVar6 = puVar6 + 1;
			puVar10 = puVar10 + 1;
		}
		iVar2 = iVar2 + -1;
		for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
			*(undefined *)puVar10 = *(undefined *)puVar6;
			puVar6 = (undefined4 *)((int)puVar6 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	uVar3 = 0xffffffff;
	*out_texNum = *out_texNum + 1;
	pcVar8 = local_10;
	do {
		pcVar7 = pcVar8;
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		pcVar7 = pcVar8 + 1;
		cVar1 = *pcVar8;
		pcVar8 = pcVar7;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	iVar2 = -1;
	do {
		pcVar8 = out_nextTextName;
		if (iVar2 == 0) break;
		iVar2 = iVar2 + -1;
		pcVar8 = out_nextTextName + 1;
		cVar1 = *out_nextTextName;
		out_nextTextName = pcVar8;
	} while (cVar1 != '\0');
	puVar6 = (undefined4 *)(pcVar7 + -uVar3);
	puVar10 = (undefined4 *)(pcVar8 + -1);
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
		*puVar10 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar10 = puVar10 + 1;
	}
	for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
		*(undefined *)puVar10 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar10 = (undefined4 *)((int)puVar10 + 1);
	}
	return;
}



void __cdecl lego::res::Mesh_UViewMesh(APPOBJ *lightWaveObject,Point2F *textCoords)
{
	ushort *puVar1;
	float fVar2;
	float fVar3;
	char cVar4;
	FileStream *file;
	bool bVar5;
	undefined4 *buffer;
	char *pcVar6;
	float *pfVar7;
	uint uVar8;
	int iVar9;
	uint uVar10;
	undefined4 *puVar11;
	char *pcVar12;
	undefined4 *puVar13;
	float10 fVar14;
	int local_840;
	int local_83c;
	int local_838;
	uint local_834;
	int local_830;
	int local_820;
	char *local_814;
	char *local_810;
	char local_800 [1024];
	undefined4 local_400 [256];
	
	file = lightWaveObject->aoFileUV;
	local_838 = -1;
	local_83c = -1;
	local_830 = 0;
	local_840 = -2;
	local_834 = 0;
	buffer = (undefined4 *)std::malloc((lightWaveObject->aoSize).lwVertCount << 3);
	puVar11 = buffer;
	for (uVar8 = ((lightWaveObject->aoSize).lwVertCount << 3) >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {
		*puVar11 = 0;
		puVar11 = puVar11 + 1;
	}
	for (iVar9 = 0; iVar9 != 0; iVar9 = iVar9 + -1) {
		*(undefined *)puVar11 = 0;
		puVar11 = (undefined4 *)((int)puVar11 + 1);
	}
	pcVar6 = lego::file::File_GetLine(local_800,0x400,file);
	do {
		if (pcVar6 == (char *)0x0) {
			std::free(buffer);
			return;
		}
		uVar8 = 0xffffffff;
		pcVar6 = local_800;
		do {
			pcVar12 = pcVar6;
			if (uVar8 == 0) break;
			uVar8 = uVar8 - 1;
			pcVar12 = pcVar6 + 1;
			cVar4 = *pcVar6;
			pcVar6 = pcVar12;
		} while (cVar4 != '\0');
		uVar8 = ~uVar8;
		puVar11 = (undefined4 *)(pcVar12 + -uVar8);
		puVar13 = local_400;
		for (uVar10 = uVar8 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {
			*puVar13 = *puVar11;
			puVar11 = puVar11 + 1;
			puVar13 = puVar13 + 1;
		}
		for (uVar8 = uVar8 & 3; uVar8 != 0; uVar8 = uVar8 - 1) {
			*(undefined *)puVar13 = *(undefined *)puVar11;
			puVar11 = (undefined4 *)((int)puVar11 + 1);
			puVar13 = (undefined4 *)((int)puVar13 + 1);
		}
		iVar9 = util::Util_WSTokenise((char *)local_400,&local_814);
		if (iVar9 != 0) {
			if (local_830 == 2) {
				local_838 = 0;
			}
			if (local_838 != -1) {
				uVar8 = (lightWaveObject->aoSize).lwSurfaceCount;
				if (local_838 < (int)(uVar8 * 2)) {
					if ((int)uVar8 <= local_838) {
						pcVar6 = std::_strdup(local_814);
						lightWaveObject->aoSurface[local_838 - (lightWaveObject->aoSize).lwSurfaceCount].srfPath
								 = pcVar6;
					}
					local_838 = local_838 + 1;
				}
				else {
					local_838 = -1;
					local_840 = -1;
				}
			}
			if (local_840 != -2) {
				if (local_840 == -1) {
					local_840 = 0;
				}
				else {
					uVar8 = (lightWaveObject->aoSize).lwPolyCount;
					if ((int)uVar8 <= local_840) {
						return;
					}
					if ((local_83c == -1) || ((int)lightWaveObject->aoPoly[local_820].plyCount <= local_83c))
					{
						if (local_840 < (int)(uVar8 - 1)) {
							local_820 = std::atoi(local_814);
							if (local_83c != -1) {
								local_840 = local_840 + 1;
							}
							local_83c = 0;
						}
					}
					else {
						fVar14 = std::atof(local_814);
						fVar2 = (float)fVar14;
						fVar14 = std::atof(local_810);
						fVar3 = (float)-fVar14;
						uVar8 = (uint)lightWaveObject->aoPoly[local_820].plyData[local_83c];
						if ((textCoords[uVar8].x == fVar2) && (textCoords[uVar8].y == fVar3)) {
							bVar5 = false;
						}
						else {
							bVar5 = true;
						}
						if (buffer[uVar8] == 0) {
							textCoords[uVar8].x = fVar2;
							textCoords[lightWaveObject->aoPoly[local_820].plyData[local_83c]].y = fVar3;
							puVar1 = lightWaveObject->aoPoly[local_820].plyData + local_83c;
							local_83c = local_83c + 1;
							buffer[*puVar1] = 1;
						}
						else {
							if (bVar5) {
								if (local_834 == 0) {
									pfVar7 = (float *)std::realloc(lightWaveObject->aoVerts,
																								 ((lightWaveObject->aoSize).lwVertCount + 0xb) * 0xc
																								);
									lightWaveObject->aoVerts = pfVar7;
								}
								uVar10 = (uint)lightWaveObject->aoPoly[local_820].plyData[local_83c];
								uVar8 = (lightWaveObject->aoSize).lwVertCount;
								lightWaveObject->aoVerts[uVar8 * 3] = lightWaveObject->aoVerts[uVar10 * 3];
								lightWaveObject->aoVerts[uVar8 * 3 + 1] = lightWaveObject->aoVerts[uVar10 * 3 + 1];
								lightWaveObject->aoVerts[uVar8 * 3 + 2] = lightWaveObject->aoVerts[uVar10 * 3 + 2];
								lightWaveObject->aoPoly[local_820].plyData[local_83c] =
										 *(ushort *)&(lightWaveObject->aoSize).lwVertCount;
								textCoords[lightWaveObject->aoPoly[local_820].plyData[local_83c]].x = fVar2;
								textCoords[lightWaveObject->aoPoly[local_820].plyData[local_83c]].y = fVar3;
								local_834 = local_834 + 1;
								(lightWaveObject->aoSize).lwVertCount = (lightWaveObject->aoSize).lwVertCount + 1;
								if (9 < local_834) {
									local_834 = 0;
								}
							}
							local_83c = local_83c + 1;
						}
					}
				}
			}
			local_830 = local_830 + 1;
		}
		pcVar6 = lego::file::File_GetLine(local_800,0x400,file);
	} while( true );
}



void __cdecl
lego::res::Mesh_GetTextureUVsWrap
					(uint vertexCount,Vector3F *vertices,Point2F *coords,float sx,float sy,float sz,float px,
					float py,float pz,LWTEXFLAGS flags)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float *pfVar4;
	
	if (vertexCount != 0) {
		pfVar4 = &vertices->z;
		do {
			fVar1 = pfVar4[-1];
			fVar2 = *pfVar4;
			if ((flags & TFM_AXIS_X) == 0) {
				fVar3 = (pfVar4[-2] - px) / sx;
			}
			else {
				fVar3 = (fVar2 - pz) / sz;
			}
			coords->x = fVar3 - -0.5;
			if ((flags & TFM_AXIS_Y) == 0) {
				fVar1 = (fVar1 - py) / sy;
			}
			else {
				fVar1 = (fVar2 - pz) / sz;
			}
			pfVar4 = pfVar4 + 3;
			vertexCount = vertexCount - 1;
			coords->y = fVar1 - -0.5;
			coords = coords + 1;
		} while (vertexCount != 0);
	}
	return;
}



BOOL __cdecl lego::res::Mesh_SetTextureTime2(Mesh *mesh,float frame)
{
	int *piVar1;
	int iVar2;
	int iVar3;
	D3DRMGroupIndex groupID;
	float10 fVar4;
	longlong lVar5;
	
	fVar4 = std::fmod((float10)frame,(float10)1.0);
	lVar5 = __ftol((float10)frame - fVar4);
	if ((*(byte *)&mesh->flags & 4) == 0) {
		return 0;
	}
	groupID = D3DRMGROUP_0;
	if (mesh->groupCount != 0) {
		iVar3 = 0;
		do {
			piVar1 = *(int **)((int)&mesh->groupList->lightWaveSurfaceInfo + iVar3);
			if (((*(byte *)(piVar1 + 0xd) & 0x80) != 0) && (piVar1[2] != 0)) {
				iVar2 = (piVar1[0xe] + (int)lVar5) % piVar1[2];
				if (iVar2 < 0) {
					iVar2 = 0;
				}
				Mesh_SetGroupTexture(mesh,groupID,*(Container_Texture **)(*piVar1 + iVar2 * 4));
			}
			groupID = groupID + 1;
			iVar3 = iVar3 + 0x70;
		} while (groupID < mesh->groupCount);
	}
	return 1;
}



void __cdecl lego::res::Mesh_Remove(Mesh *mesh,IDirect3DRMFrame3 *frame)
{
	Mesh *pMVar1;
	IDirect3DRMUserVisual *pIVar2;
	uint uVar3;
	D3DRMGroupIndex groupID;
	int iVar4;
	int iVar5;
	
	(*frame->lpVtbl->DeleteVisual)(frame,(IDirect3DRMVisual *)mesh->uv);
	pMVar1 = mesh->clonedFrom;
	groupID = D3DRMGROUP_0;
	if (pMVar1 != (Mesh *)0x0) {
		pIVar2 = mesh->uv;
		if (pIVar2 != (IDirect3DRMUserVisual *)0x0) {
			(*pIVar2->lpVtbl->Release)((IUnknown *)pIVar2);
			mesh->uv = (IDirect3DRMUserVisual *)0x0;
		}
		std::free(mesh->groupList);
		Mesh_ReturnToList(mesh);
		mesh = pMVar1;
	}
	uVar3 = mesh->numOfRefs - 1;
	mesh->numOfRefs = uVar3;
	if (uVar3 == 0) {
		pIVar2 = mesh->uv;
		if (pIVar2 != (IDirect3DRMUserVisual *)0x0) {
			(*pIVar2->lpVtbl->Release)((IUnknown *)pIVar2);
			mesh->uv = (IDirect3DRMUserVisual *)0x0;
		}
		if (mesh->groupCount != 0) {
			iVar4 = 0;
			do {
				iVar5 = (int)&mesh->groupList->faceDataSize + iVar4;
				Mesh_RemoveGroupTexture(mesh,groupID);
				std::free(*(void **)(iVar5 + 8));
				std::free(*(void **)(iVar5 + 0xc));
				groupID = groupID + 1;
				iVar4 = iVar4 + 0x70;
			} while (groupID < mesh->groupCount);
		}
		if (mesh->lightWaveSurf != (Mesh_LightWave_Surface *)0x0) {
			std::free(mesh->lightWaveSurf);
		}
		std::free(mesh->groupList);
		Mesh_ReturnToList(mesh);
	}
	return;
}



Mesh_Group * __cdecl
lego::res::Mesh_GetGroup
					(Mesh *mesh,D3DRMGroupIndex groupID,uint *out_vertexCount,uint *unused_out_faceCount,
					uint *out_vPerFace,uint *out_faceDataSize,uint *out_faceData)
{
	ushort *puVar1;
	Mesh_Group *pMVar2;
	uint uVar3;
	
	pMVar2 = mesh->groupList + groupID;
	if (out_vertexCount != (uint *)0x0) {
		*out_vertexCount = pMVar2->vertexCount;
	}
	if (out_vPerFace != (uint *)0x0) {
		*out_vPerFace = 3;
	}
	if (out_faceDataSize != (uint *)0x0) {
		*out_faceDataSize = pMVar2->faceDataSize;
	}
	if ((out_faceData != (uint *)0x0) && (uVar3 = 0, pMVar2->faceDataSize != 0)) {
		do {
			puVar1 = pMVar2->faceData + uVar3;
			uVar3 = uVar3 + 1;
			*out_faceData = (uint)*puVar1;
			out_faceData = out_faceData + 1;
		} while (uVar3 < pMVar2->faceDataSize);
	}
	return pMVar2;
}



uint __cdecl lego::res::Mesh_GetGroupCount(Mesh *mesh)
{
	return mesh->groupCount;
}



int __cdecl
lego::res::Mesh_AddGroup
					(Mesh *mesh,uint vertexCount,uint faceCount,uint vPerFace,uint *out_faceData)
{
	ushort uVar1;
	Mesh_Group *pMVar2;
	ushort *puVar3;
	uint uVar4;
	Mesh_Vertex *pMVar5;
	int iVar6;
	Mesh_Group *pMVar7;
	uint uVar8;
	
	if (mesh->groupList == (Mesh_Group *)0x0) {
		mesh->listSize = 10;
		mesh->groupCount = 1;
		pMVar2 = (Mesh_Group *)std::malloc(0x460);
		mesh->groupList = pMVar2;
	}
	else {
		uVar4 = mesh->groupCount;
		mesh->groupCount = uVar4 + 1;
		if (uVar4 == mesh->listSize) {
			uVar4 = (mesh->listSize * 0x96) / 100;
			pMVar2 = (Mesh_Group *)std::realloc(mesh->groupList,uVar4 * 0x70);
			if (pMVar2 == (Mesh_Group *)0x0) {
				return -1;
			}
			mesh->groupList = pMVar2;
			mesh->listSize = uVar4;
		}
	}
	pMVar2 = mesh->groupList + (mesh->groupCount - 1);
	pMVar7 = pMVar2;
	for (iVar6 = 0x1c; iVar6 != 0; iVar6 = iVar6 + -1) {
		pMVar7->faceDataSize = 0;
		pMVar7 = (Mesh_Group *)&pMVar7->vertexCount;
	}
	uVar8 = vPerFace * faceCount;
	puVar3 = (ushort *)std::malloc(uVar8 * 2);
	pMVar2->faceData = puVar3;
	uVar4 = 0;
	pMVar2->faceDataSize = uVar8;
	if (uVar8 != 0) {
		do {
			uVar1 = *(ushort *)out_faceData;
			out_faceData = out_faceData + 1;
			pMVar2->faceData[uVar4] = uVar1;
			uVar4 = uVar4 + 1;
		} while (uVar4 < pMVar2->faceDataSize);
	}
	pMVar5 = (Mesh_Vertex *)std::malloc(vertexCount << 5);
	pMVar2->vertices = pMVar5;
	for (uVar4 = (vertexCount << 5) >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
		(pMVar5->position).x = 0.0;
		pMVar5 = (Mesh_Vertex *)&(pMVar5->position).y;
	}
	for (iVar6 = 0; iVar6 != 0; iVar6 = iVar6 + -1) {
		*(undefined *)&(pMVar5->position).x = 0;
		pMVar5 = (Mesh_Vertex *)((int)&(pMVar5->position).x + 1);
	}
	pMVar2->vertexCount = vertexCount;
	pMVar2->flags = 0;
	Mesh_CreateGroupMaterial(mesh,mesh->groupCount + D3DRMGROUP_ALLGROUPS);
	return mesh->groupCount - 1;
}



void __cdecl lego::res::Mesh_AlterGroupRenderFlags(Mesh *mesh,D3DRMGroupIndex groupID,uint newFlags)
{
	mesh->groupList[groupID].renderFlags = newFlags;
	return;
}



void __cdecl lego::res::Mesh_Scale(Mesh *mesh,float x,float y,float z)
{
	float *pfVar1;
	float *pfVar2;
	Mesh_Group *iVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	
	uVar5 = 0;
	if (mesh->groupCount != 0) {
		iVar7 = 0;
		do {
			uVar6 = 0;
			iVar3 = (Mesh_Group *)((int)&mesh->groupList->faceDataSize + iVar7);
			if (iVar3->vertexCount != 0) {
				iVar4 = 0;
				do {
					uVar6 = uVar6 + 1;
					*(float *)((int)&(iVar3->vertices->position).x + iVar4) =
							 x * *(float *)((int)&(iVar3->vertices->position).x + iVar4);
					*(float *)((int)&(iVar3->vertices->position).y + iVar4) =
							 y * *(float *)((int)&(iVar3->vertices->position).y + iVar4);
					pfVar1 = (float *)((int)&(iVar3->vertices->position).z + iVar4);
					pfVar2 = (float *)((int)&(iVar3->vertices->position).z + iVar4);
					iVar4 = iVar4 + 0x20;
					*pfVar2 = z * *pfVar1;
				} while (uVar6 < iVar3->vertexCount);
			}
			uVar5 = uVar5 + 1;
			iVar7 = iVar7 + 0x70;
		} while (uVar5 < mesh->groupCount);
	}
	return;
}



void __cdecl
lego::res::Mesh_SetVertices
					(Mesh *mesh,D3DRMGroupIndex groupID,uint index,uint count,D3DRMVertex *vertices)
{
	int iVar1;
	float *pfVar2;
	Mesh_Group *pMVar3;
	float *pfVar4;
	
	pMVar3 = mesh->groupList + groupID;
	if (count != 0) {
		iVar1 = index << 5;
		pfVar2 = &vertices->tu;
		do {
			pfVar4 = (float *)((int)&(pMVar3->vertices->position).x + iVar1);
			*pfVar4 = pfVar2[-6];
			pfVar4[1] = pfVar2[-5];
			pfVar4[2] = pfVar2[-4];
			pfVar4 = (float *)((int)&(pMVar3->vertices->normal).x + iVar1);
			count = count - 1;
			*pfVar4 = pfVar2[-3];
			pfVar4[1] = pfVar2[-2];
			pfVar4[2] = pfVar2[-1];
			*(float *)((int)&pMVar3->vertices->tu + iVar1) = *pfVar2;
			*(float *)((int)&pMVar3->vertices->tv + iVar1) = pfVar2[1];
			iVar1 = iVar1 + 0x20;
			pfVar2 = pfVar2 + 9;
		} while (count != 0);
	}
	return;
}



void __cdecl
lego::res::Mesh_GetVertices
					(Mesh *mesh,D3DRMGroupIndex groupID,uint index,uint count,D3DRMVertex *out_vertices)
{
	int iVar1;
	float *pfVar2;
	Mesh_Group *pMVar3;
	float *pfVar4;
	
	pMVar3 = mesh->groupList + groupID;
	if (count != 0) {
		iVar1 = index << 5;
		pfVar2 = &out_vertices->tu;
		do {
			pfVar4 = (float *)((int)&(pMVar3->vertices->position).x + iVar1);
			pfVar2[-6] = *pfVar4;
			pfVar2[-5] = pfVar4[1];
			pfVar2[-4] = pfVar4[2];
			pfVar4 = (float *)((int)&(pMVar3->vertices->normal).x + iVar1);
			count = count - 1;
			pfVar2[-3] = *pfVar4;
			pfVar2[-2] = pfVar4[1];
			pfVar2[-1] = pfVar4[2];
			*pfVar2 = *(float *)((int)&pMVar3->vertices->tu + iVar1);
			pfVar2[1] = *(float *)((int)&pMVar3->vertices->tv + iVar1);
			iVar1 = iVar1 + 0x20;
			pfVar2 = pfVar2 + 9;
		} while (count != 0);
	}
	return;
}



void __cdecl
lego::res::Mesh_SetVertices_PointNormalAt
					(Mesh *mesh,D3DRMGroupIndex groupID,uint index,uint count,Vector3F *vertices,
					Vector3F *position,Point2F *textCoords)
{
	float *pfVar1;
	float fVar2;
	Vector3F *pVVar3;
	int iVar4;
	int iVar5;
	Mesh_Group *pMVar6;
	float *pfVar7;
	
	pVVar3 = position;
	pMVar6 = mesh->groupList + groupID;
	if (count != 0) {
		position = (Vector3F *)count;
		iVar5 = index << 5;
		pfVar7 = &vertices->z;
		do {
			*(float *)((int)&(pMVar6->vertices->position).x + iVar5) = pfVar7[-2];
			*(float *)((int)&(pMVar6->vertices->position).y + iVar5) = pfVar7[-1];
			*(float *)((int)&(pMVar6->vertices->position).z + iVar5) = *pfVar7;
			iVar4 = (int)&(pMVar6->vertices->position).x + iVar5;
			*(float *)(iVar4 + 0xc) = pVVar3->x - *(float *)((int)&(pMVar6->vertices->position).x + iVar5)
			;
			*(float *)(iVar4 + 0x10) = pVVar3->y - *(float *)(iVar4 + 4);
			*(float *)(iVar4 + 0x14) = pVVar3->z - *(float *)(iVar4 + 8);
			fVar2 = *(float *)((int)&(pMVar6->vertices->normal).y + iVar5);
			pfVar1 = (float *)((int)&(pMVar6->vertices->normal).x + iVar5);
			fVar2 = 1.0 / SQRT(*pfVar1 * *pfVar1 + pfVar1[2] * pfVar1[2] + fVar2 * fVar2);
			*pfVar1 = *pfVar1 * fVar2;
			pfVar1[1] = fVar2 * pfVar1[1];
			pfVar1[2] = fVar2 * pfVar1[2];
			*(float *)((int)&pMVar6->vertices->tu + iVar5) = textCoords->x;
			*(float *)((int)&pMVar6->vertices->tv + iVar5) = textCoords->y;
			position = (Vector3F *)((int)&position[-1].z + 3);
			iVar5 = iVar5 + 0x20;
			textCoords = textCoords + 1;
			pfVar7 = pfVar7 + 3;
		} while (position != (Vector3F *)0x0);
	}
	return;
}



void __cdecl
lego::res::Mesh_SetVertices_SameNormal
					(Mesh *mesh,D3DRMGroupIndex groupID,uint index,uint count,Vector3F *vertices,
					Vector3F *normal,Point2F *textCoords)
{
	float *pfVar1;
	int iVar2;
	Mesh_Group *pMVar3;
	float *pfVar4;
	
	pMVar3 = mesh->groupList + groupID;
	if (count != 0) {
		groupID = count;
		iVar2 = index << 5;
		pfVar4 = &vertices->z;
		do {
			*(float *)((int)&(pMVar3->vertices->position).x + iVar2) = pfVar4[-2];
			*(float *)((int)&(pMVar3->vertices->position).y + iVar2) = pfVar4[-1];
			*(float *)((int)&(pMVar3->vertices->position).z + iVar2) = *pfVar4;
			pfVar1 = (float *)((int)&(pMVar3->vertices->normal).x + iVar2);
			*pfVar1 = normal->x;
			pfVar1[1] = normal->y;
			pfVar1[2] = normal->z;
			*(float *)((int)&pMVar3->vertices->tu + iVar2) = textCoords->x;
			*(float *)((int)&pMVar3->vertices->tv + iVar2) = textCoords->y;
			groupID = groupID + D3DRMGROUP_ALLGROUPS;
			iVar2 = iVar2 + 0x20;
			pfVar4 = pfVar4 + 3;
			textCoords = textCoords + 1;
		} while (groupID != D3DRMGROUP_0);
	}
	return;
}



void __cdecl
lego::res::Mesh_SetVertices_VNT
					(Mesh *mesh,D3DRMGroupIndex groupID,uint index,uint count,Vector3F *vertices,
					Vector3F **normal,Point2I *textCoords)
{
	int iVar1;
	Mesh_Group *pMVar2;
	float *pfVar3;
	
	pMVar2 = mesh->groupList + groupID;
	if (count != 0) {
		groupID = count;
		iVar1 = index << 5;
		pfVar3 = &vertices->z;
		do {
			*(float *)((int)&(pMVar2->vertices->position).x + iVar1) = pfVar3[-2];
			*(float *)((int)&(pMVar2->vertices->position).y + iVar1) = pfVar3[-1];
			*(float *)((int)&(pMVar2->vertices->position).z + iVar1) = *pfVar3;
			*(float *)((int)&(pMVar2->vertices->normal).x + iVar1) = (*normal)->x;
			*(float *)((int)&(pMVar2->vertices->normal).y + iVar1) = (*normal)->y;
			*(float *)((int)&(pMVar2->vertices->normal).z + iVar1) = (*normal)->z;
			*(int *)((int)&pMVar2->vertices->tu + iVar1) = textCoords->x;
			*(int *)((int)&pMVar2->vertices->tv + iVar1) = textCoords->y;
			groupID = groupID + D3DRMGROUP_ALLGROUPS;
			iVar1 = iVar1 + 0x20;
			pfVar3 = pfVar3 + 3;
			normal = normal + 1;
			textCoords = textCoords + 1;
		} while (groupID != D3DRMGROUP_0);
	}
	return;
}



BOOL __cdecl lego::res::Mesh_IsGroupHidden(Mesh *mesh,D3DRMGroupIndex groupID)
{
	return mesh->groupList[groupID].flags & 1;
}



void __cdecl lego::res::Mesh_HideGroup(Mesh *mesh,D3DRMGroupIndex groupID,BOOL hide)
{
	Mesh_Group *pMVar1;
	
	pMVar1 = mesh->groupList + groupID;
	if (hide != 0) {
		pMVar1->flags = pMVar1->flags | 1;
		return;
	}
	pMVar1->flags = pMVar1->flags & 0xfffffffe;
	return;
}



void __cdecl lego::res::Mesh_Hide(Mesh *mesh,BOOL hide)
{
	if (hide != 0) {
		mesh->flags = mesh->flags | 1;
		return;
	}
	mesh->flags = mesh->flags & 0xfffffffe;
	return;
}



BOOL __cdecl
lego::res::Mesh_RenderCallback
					(IDirect3DRMUserVisual *lpD3DRMUV,Mesh *lpArg,D3DRMUserVisualReason lpD3DRMUVreason,
					IUnknown *lpD3DRMDev,IDirect3DRMViewport *lpD3DRMview)
{
	Mesh *mesh;
	IDirect3DRMViewport *This;
	Container *pCVar1;
	Viewport *pVVar2;
	Mesh *view;
	BOOL BVar3;
	bool bVar4;
	uint uVar5;
	int iVar6;
	IDirect3DRMViewport2 *unaff_ESI;
	Mesh_Group *pMVar7;
	int unaff_retaddr;
	IDirect3DRMViewport2 *rmView2;
	Matrix4F transform4d;
	
	mesh = lpArg;
	uVar5 = 0;
	if (lpD3DRMUVreason == D3DRMUSERVISUAL_CANSEE) {
		if (((globs::mainGlobs.imDevice != (IDirect3DDevice3 *)0x0) &&
				((*(byte *)&lpArg->flags & 1) == 0)) &&
			 ((pCVar1 = Container_SearchOwner(lpArg->frameCreatedOn), pCVar1 == (Container *)0x0 ||
				((*(byte *)&pCVar1->flags & 0x80) == 0)))) {
			if ((mesh->flags & 0x1000000) == 0) {
				return 1;
			}
			if ((mesh->flags & 0x2000000) != 0) {
				return 1;
			}
										// DWORD IDirect3DRMViewport->GetAppData(this)
										// struct with field_28 -> IDirect3DRMFrame3*
			pVVar2 = (*((IDirect3DRMFrame3Vtbl *)lpD3DRMview->lpVtbl)->GetAppData)(lpD3DRMview);
			if (pVVar2->rendering == 0) {
				return 1;
			}
										// IDirect3DRMFrame3->GetScene(this, IDirect3DRMFrame3** lplpRoot)
			(*mesh->frameCreatedOn->lpVtbl->GetScene)(mesh->frameCreatedOn,(IDirect3DRMFrame3 **)&lpArg);
										// IDirect3DRMViewport2->GetCamera(this, IDirect3DRMFrame3** lplpCamera)
			(*pVVar2->lpVP->lpVtbl->GetCamera)(pVVar2->lpVP,(IDirect3DRMFrame3 **)&lpD3DRMview);
										// IDirect3DRMFrame3->LookAt(this, IDirect3DRMFrame3* lpTarget,
										// IDirect3DRMFrame3* lpRef, TD3DRMFrameConstraint rfcConstraint)
										// 
										//  D3DRMCONSTRAIN_Z (0x0)
			(*mesh->frameCreatedOn->lpVtbl->LookAt)
								(mesh->frameCreatedOn,(IDirect3DRMFrame3 *)lpD3DRMview,(IDirect3DRMFrame3 *)lpArg,
								 D3DRMCONSTRAIN_Z);
			mesh->flags = mesh->flags | 0x2000000;
			return 1;
		}
	}
	else {
		if (lpD3DRMUVreason == D3DRMUSERVISUAL_RENDER) {
			if (globs::mainGlobs.imDevice != (IDirect3DDevice3 *)0x0) {
				lpD3DRMUVreason = D3DRMUSERVISUAL_CANSEE;
				bVar4 = false;
				lpArg->flags = lpArg->flags & 0xfdffffff;
										// IDirect3DDevice3->GetTransform(this, D3DTransformStateType
										// dtstTransformStateType, Matrix4F* lpD3DMatrix)
				(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetTransform)
									(globs::mainGlobs.imDevice,D3DTRANSFORMSTATE_WORLD,&transform4d);
				This = lpD3DRMview;
				Mesh_SetCurrentViewport(lpD3DRMview);
										// IDirect3DRMViewport->QueryInterface(this, IID_IDirect3DRMViewport2,
										// IDirect3DRMViewport2** lplpOut)
				(*((IDirect3DRMFrame3Vtbl *)This->lpVtbl)->QueryInterface)
									((IUnknown *)This,(IID *)&idl::IID_IDirect3DRMViewport2,&rmView2);
										// DWORD IDirect3DRMViewport2->GetAppData(this)
				view = (Mesh *)(*unaff_ESI->lpVtbl->GetAppData)(unaff_ESI);
				lpArg = view;
				if ((*(byte *)&mesh->flags & 2) == 0) {
					if (((mesh->renderDesc).renderFlags & 0x1c00) == 0) {
						Mesh_StoreTextureAndMat();
						Mesh_SetMeshRenderDesc(mesh,(Viewport *)view,(Matrix4F *)&stack0xffffffb4,0);
						bVar4 = true;
						Mesh_RenderMesh(mesh,(Matrix4F *)&stack0xffffffb4,0);
					}
					else {
						if (mesh->groupCount != 0) {
							transform4d.values[3][3] = 0.0;
							do {
								pMVar7 = (Mesh_Group *)
												 ((int)&mesh->groupList->faceDataSize + (int)transform4d.values[3][3]);
								BVar3 = Mesh_CanRenderGroup(pMVar7);
								if (BVar3 != 0) {
									if ((pMVar7->flags & 0x80000) == 0) {
										if (pMVar7->renderFlags == 0) {
											if (!bVar4) {
												Mesh_StoreTextureAndMat();
												Mesh_SetMeshRenderDesc
																	(mesh,(Viewport *)lpArg,(Matrix4F *)&stack0xffffffb4,0);
												bVar4 = true;
											}
											Mesh_RenderGroup(mesh,pMVar7,(Matrix4F *)&stack0xffffffb4,0);
										}
									}
									else {
										unaff_retaddr = 1;
									}
								}
								uVar5 = uVar5 + 1;
								transform4d.values[3][3] = (float)((int)transform4d.values[3][3] + 0x70);
							} while (uVar5 < mesh->groupCount);
						}
						iVar6 = 0;
						transform4d.values[3][3] = 0.0;
						if (mesh->groupCount != 0) {
							do {
								pMVar7 = (Mesh_Group *)((int)&mesh->groupList->faceDataSize + iVar6);
								BVar3 = Mesh_CanRenderGroup(pMVar7);
								if (BVar3 != 0) {
									if ((pMVar7->flags & 0x80000) == 0) {
										if (pMVar7->renderFlags != 0) {
											if (!bVar4) {
												Mesh_StoreTextureAndMat();
												Mesh_SetMeshRenderDesc
																	(mesh,(Viewport *)lpArg,(Matrix4F *)&stack0xffffffb4,0);
												bVar4 = true;
											}
											Mesh_RenderGroup(mesh,pMVar7,(Matrix4F *)&stack0xffffffb4,0);
										}
									}
									else {
										unaff_retaddr = 1;
									}
								}
								transform4d.values[3][3] = (float)((int)transform4d.values[3][3] + 1);
								iVar6 = iVar6 + 0x70;
							} while ((uint)transform4d.values[3][3] < mesh->groupCount);
						}
						if (unaff_retaddr != 0) {
							Mesh_AddToPostRenderList(mesh,(Matrix4F *)&stack0xffffffb4);
						}
					}
				}
				else {
					Mesh_AddToPostRenderList(mesh,(Matrix4F *)&stack0xffffffb4);
				}
				if (bVar4) {
					main::Main_RestoreStates();
					Mesh_RestoreTextureAndMat();
				}
				if (unaff_ESI != (IDirect3DRMViewport2 *)0x0) {
										// IDirect3DRMViewport2->Release(this)
					(*unaff_ESI->lpVtbl->Release)((IUnknown *)unaff_ESI);
				}
			}
			return 1;
		}
	}
	return 0;
}



void __cdecl
lego::res::Mesh_SetMeshRenderDesc(Mesh *mesh,Viewport *view,Matrix4F *matWorld,BOOL alphaBlend)
{
	MeshRenderCallback *pMVar1;
	
	pMVar1 = (mesh->renderDesc).renderCallback;
	if (pMVar1 != (MeshRenderCallback *)0x0) {
		(*pMVar1)(mesh,(mesh->renderDesc).renderCallbackData,view);
	}
										// D3DRENDERSTATE_SPECULARENABLE (0x1d), FALSE (0x0)
	main::Main_ChangeRenderState(D3DRENDERSTATE_SPECULARENABLE,FALSE);
										// D3DRENDERSTATE_SHADEMODE (0x9), D3DSHADE_GOURAUD (0x2)
	main::Main_ChangeRenderState(D3DRENDERSTATE_SHADEMODE,D3DSHADE_GOURAUD);
										// D3DRENDERSTATE_DITHERENABLE (0x1a), TRUE (0x1)
	main::Main_ChangeRenderState(D3DRENDERSTATE_DITHERENABLE,TRUE);
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
										// D3DTSS_COLORARG1 (0x2), D3DTA_TEXTURE (0x2)
		Mesh_ChangeTextureStageState(D3DTSS_COLORARG1,D3DTA_TEXTURE);
										// D3DTSS_COLORARG2 (0x3), D3DTA_DIFFUSE (0x0)
		Mesh_ChangeTextureStageState(D3DTSS_COLORARG2,D3DTA_DIFFUSE);
										// D3DTSS_ALPHAARG1 (0x5), D3DTA_TEXTURE (0x2)
		Mesh_ChangeTextureStageState(D3DTSS_ALPHAARG1,D3DTA_TEXTURE);
										// D3DTSS_ALPHAARG2 (0x6), D3DTA_DIFFUSE (0x0)
		Mesh_ChangeTextureStageState(D3DTSS_ALPHAARG2,D3DTA_DIFFUSE);
	}
	Mesh_SetRenderDesc((mesh->renderDesc).renderFlags,matWorld,alphaBlend);
	return;
}



void __cdecl lego::res::Mesh_SetRenderDesc(uint flags,Matrix4F *matWorld,BOOL alphaBlend)
{
	uint uVar1;
	undefined4 uVar2;
	DWORD dwRenderState;
	Matrix4F identity;
	
	uVar1 = flags & 0x1c00;
	if ((uVar1 != 0) && (alphaBlend != 0)) {
										// D3DRENDERSTATE_FOGENABLE (0x1c), FALSE (0x0)
		main::Main_ChangeRenderState(D3DRENDERSTATE_FOGENABLE,FALSE);
	}
	if ((uVar1 == 0) || (alphaBlend != 0)) {
		if ((flags & 0x400) == 0) {
			if ((flags & 0x800) == 0) {
				if ((flags & 0x1000) == 0) goto LAB_00482e79;
										// D3DBLEND_SRCALPHA (0x5), D3DBLEND_INVSRCALPHA (0x6)
				Mesh_SetAlphaRender(D3DBLEND_SRCALPHA,D3DBLEND_INVSRCALPHA);
			}
			else {
										// D3DBLEND_SRCALPHA (0x5), D3DBLEND_ONE (0x2)
				Mesh_SetAlphaRender(D3DBLEND_SRCALPHA,D3DBLEND_ONE);
			}
		}
		else {
										// D3DBLEND_ONE (0x2), D3DBLEND_ONE (0x2)
			Mesh_SetAlphaRender(D3DBLEND_ONE,D3DBLEND_ONE);
		}
	}
	else {
LAB_00482e79:
										// D3DRENDERSTATE_ALPHABLENDENABLE (0x1b), FALSE (0x0)
		main::Main_ChangeRenderState(D3DRENDERSTATE_ALPHABLENDENABLE,FALSE);
	}
	if ((flags & 0x4000000) == 0) {
										// D3DCULL_CCW (0x3)
		uVar2 = D3DCULL_CCW;
	}
	else {
										// D3DCULL_NONE (0x1)
		uVar2 = D3DCULL_NONE;
	}
										// D3DRENDERSTATE_CULLMODE (0x16), ...
	main::Main_ChangeRenderState(D3DRENDERSTATE_CULLMODE,uVar2);
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
		if ((flags & 0x20000) == 0) {
			if ((flags & 0x40000) == 0) {
										// D3DTOP_MODULATE (0x4)
				dwRenderState = D3DTOP_MODULATE;
			}
			else {
										// D3DTOP_SELECTARG2 (0x3)
				dwRenderState = D3DTOP_SELECTARG2;
			}
		}
		else {
										// D3DTOP_SELECTARG1 (0x2)
			dwRenderState = D3DTOP_SELECTARG1;
		}
										// D3DTSS_ALPHAOP (0x4), ...
		Mesh_ChangeTextureStageState(D3DTSS_ALPHAOP,dwRenderState);
	}
										// D3DRENDERSTATE_ZENABLE (0x7), TRUE (0x1)
	main::Main_ChangeRenderState(D3DRENDERSTATE_ZENABLE,TRUE);
	if ((uVar1 == 0) || (alphaBlend == 0)) {
		uVar2 = TRUE;
	}
	else {
		uVar2 = FALSE;
	}
										// D3DRENDERSTATE_ZWRITEENABLE (0xe), [TRUE (0x1) | FALSE (0x0)]
	main::Main_ChangeRenderState(D3DRENDERSTATE_ZWRITEENABLE,uVar2);
	if ((flags & 0x2000) == 0) {
		if ((flags & 0x4000) == 0) goto LAB_00482f21;
		Mesh_SetIdentityMatrix(&identity);
		matWorld = &identity;
	}
										// D3DTRANSFORMSTATE_WORLD (0x1)
	Mesh_SetTransform(D3DTRANSFORMSTATE_WORLD,matWorld);
LAB_00482f21:
	if ((flags & 0x800000) == 0) {
										// D3DRENDERSTATE_TEXTUREMAG (0x11), D3DFILTER_LINEAR (0x2)
		main::Main_ChangeRenderState(D3DRENDERSTATE_TEXTUREMAG,D3DFILTER_LINEAR);
										// D3DRENDERSTATE_TEXTUREMIN (0x12), D3DFILTER_MIPLINEAR (0x4)
		main::Main_ChangeRenderState(D3DRENDERSTATE_TEXTUREMIN,D3DFILTER_MIPLINEAR);
		return;
	}
										// D3DRENDERSTATE_TEXTUREMAG (0x11), D3DFILTER_NEAREST (0x1)
	main::Main_ChangeRenderState(D3DRENDERSTATE_TEXTUREMAG,D3DFILTER_NEAREST);
										// D3DRENDERSTATE_TEXTUREMIN (0x12), D3DFILTER_NEAREST (0x1)
	main::Main_ChangeRenderState(D3DRENDERSTATE_TEXTUREMIN,D3DFILTER_NEAREST);
	return;
}



void __cdecl lego::res::Mesh_SetAlphaRender(D3DBlend src,D3DBlend dest)
{
										// D3DRENDERSTATE_ALPHABLENDENABLE (0x1b), TRUE (0x1)
	main::Main_ChangeRenderState(D3DRENDERSTATE_ALPHABLENDENABLE,TRUE);
										// D3DRENDERSTATE_SRCBLEND (0x13)
	main::Main_ChangeRenderState(D3DRENDERSTATE_SRCBLEND,src);
										// D3DRENDERSTATE_DSTBLEND (0x20)
	main::Main_ChangeRenderState(D3DRENDERSTATE_DESTBLEND,dest);
	return;
}



void __cdecl lego::res::Mesh_AddToPostRenderList(Mesh *mesh,Matrix4F *matWorld)
{
	Mesh_PostRenderInfo *pMVar1;
	int iVar2;
	Mesh_PostRenderInfo *pMVar3;
	
	pMVar1 = (Mesh_PostRenderInfo *)std::malloc(0x48);
	pMVar3 = pMVar1;
	for (iVar2 = 0x12; iVar2 != 0; iVar2 = iVar2 + -1) {
		pMVar3->mesh = (Mesh *)0x0;
		pMVar3 = (Mesh_PostRenderInfo *)&pMVar3->matWorld;
	}
	pMVar1->mesh = mesh;
	if (matWorld != (Matrix4F *)0x0) {
		pMVar3 = pMVar1;
		for (iVar2 = 0x10; pMVar3 = (Mesh_PostRenderInfo *)&pMVar3->matWorld, iVar2 != 0;
				iVar2 = iVar2 + -1) {
			(*(float (*) [4])&pMVar3->mesh)[0] = matWorld->values[0];
			matWorld = (Matrix4F *)(matWorld->values + 1);
		}
	}
	pMVar1->next = globs::meshGlobs.postRenderMeshList;
	globs::meshGlobs.postRenderMeshList = pMVar1;
	return;
}



void __cdecl lego::res::Mesh_ClearPostRenderList(void)
{
	Mesh_PostRenderInfo *pMVar1;
	Mesh_PostRenderInfo *buffer;
	
	buffer = globs::meshGlobs.postRenderMeshList;
	if (globs::meshGlobs.postRenderMeshList != (Mesh_PostRenderInfo *)0x0) {
		do {
			pMVar1 = buffer->next;
			std::free(buffer);
			buffer = pMVar1;
		} while (pMVar1 != (Mesh_PostRenderInfo *)0x0);
	}
	globs::meshGlobs.postRenderMeshList = (Mesh_PostRenderInfo *)0x0;
	return;
}



void __cdecl lego::view::Mesh_PostRenderAll(Viewport *view)
{
	BOOL BVar1;
	Mesh *pMVar2;
	int iVar3;
	uint uVar4;
	Mesh_PostRenderInfo *pMVar5;
	Mesh_Group *pMVar6;
	
	pMVar5 = globs::meshGlobs.postRenderMeshList;
	if (globs::meshGlobs.postRenderMeshList != (Mesh_PostRenderInfo *)0x0) {
		res::Mesh_SetCurrentGODSViewport(view);
		res::Mesh_StoreTextureAndMat();
		do {
			if ((*(byte *)&pMVar5->mesh->flags & 1) == 0) {
				res::Mesh_SetMeshRenderDesc(pMVar5->mesh,view,&pMVar5->matWorld,1);
				pMVar2 = pMVar5->mesh;
				if ((*(byte *)&pMVar2->flags & 2) == 0) {
					uVar4 = 0;
					if (pMVar2->groupCount != 0) {
						iVar3 = 0;
						do {
							pMVar6 = (Mesh_Group *)((int)&pMVar2->groupList->faceDataSize + iVar3);
							BVar1 = res::Mesh_CanRenderGroup(pMVar6);
							if (((BVar1 != 0) && ((pMVar6->flags & 0x80000) != 0)) && (pMVar6->renderFlags == 0))
							{
								res::Mesh_RenderGroup(pMVar5->mesh,pMVar6,&pMVar5->matWorld,1);
							}
							pMVar2 = pMVar5->mesh;
							uVar4 = uVar4 + 1;
							iVar3 = iVar3 + 0x70;
						} while (uVar4 < pMVar2->groupCount);
					}
					pMVar2 = pMVar5->mesh;
					uVar4 = 0;
					if (pMVar2->groupCount != 0) {
						iVar3 = 0;
						do {
							pMVar6 = (Mesh_Group *)((int)&pMVar2->groupList->faceDataSize + iVar3);
							BVar1 = res::Mesh_CanRenderGroup(pMVar6);
							if (((BVar1 != 0) && ((pMVar6->flags & 0x80000) != 0)) && (pMVar6->renderFlags != 0))
							{
								res::Mesh_RenderGroup(pMVar5->mesh,pMVar6,&pMVar5->matWorld,1);
							}
							pMVar2 = pMVar5->mesh;
							uVar4 = uVar4 + 1;
							iVar3 = iVar3 + 0x70;
						} while (uVar4 < pMVar2->groupCount);
					}
				}
				else {
					res::Mesh_RenderMesh(pMVar2,&pMVar5->matWorld,1);
				}
			}
			pMVar5 = pMVar5->next;
		} while (pMVar5 != (Mesh_PostRenderInfo *)0x0);
		res::Mesh_ClearPostRenderList();
		main::Main_RestoreStates();
		res::Mesh_RestoreTextureAndMat();
	}
	return;
}



Container_Texture * __cdecl
lego::res::Mesh_LoadTexture(char *baseDir,char *name,uint *out_width,uint *out_height)
{
	char cVar1;
	Mesh_TextureReference *pMVar2;
	IDirectDrawSurface4 *surface;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	char *pcVar7;
	undefined4 *puVar8;
	uint *ref_count;
	IDirectDrawSurface4 *local_10c;
	Container_Texture *local_108;
	char filepath [260];
	
	local_108 = (Container_Texture *)std::malloc(0xc);
	if (baseDir == (char *)0x0) {
										// std::strcpy(filepath, filename)
		uVar3 = 0xffffffff;
		pcVar6 = name;
		do {
			pcVar7 = pcVar6;
			if (uVar3 == 0) break;
			uVar3 = uVar3 - 1;
			pcVar7 = pcVar6 + 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar7;
		} while (cVar1 != '\0');
		uVar3 = ~uVar3;
		puVar5 = (undefined4 *)(pcVar7 + -uVar3);
		puVar8 = (undefined4 *)filepath;
		for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
			*puVar8 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar8 = puVar8 + 1;
		}
		for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
			*(undefined *)puVar8 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar8 = (undefined4 *)((int)puVar8 + 1);
		}
	}
	else {
		std::sprintf(filepath,"%s%s",baseDir,name);
	}
	pMVar2 = Mesh_SearchTexturePathList
										 (globs::meshGlobs.textureList,globs::meshGlobs.textureCount,filepath);
	if (pMVar2 != (Mesh_TextureReference *)0x0) {
		surface = pMVar2->surface;
		if (surface != (IDirectDrawSurface4 *)0x0) {
			(*surface->lpVtbl->AddRef)((IUnknown *)surface);
		}
		local_10c = (IDirectDrawSurface4 *)pMVar2->trans;
		goto LAB_004832a8;
	}
	surface = Container_LoadTextureSurface(filepath,1,out_width,out_height,(BOOL *)&local_10c);
	if (surface == (IDirectDrawSurface4 *)0x0) {
		if (globs::meshGlobs.sharedTextureDir == (char *)0x0) goto LAB_004832a8;
		std::sprintf(filepath,"%s%s",globs::meshGlobs.sharedTextureDir,name);
		pMVar2 = Mesh_SearchTexturePathList
											 (globs::meshGlobs.textureListShared,globs::meshGlobs.textureCountShared,
												filepath);
		if (pMVar2 != (Mesh_TextureReference *)0x0) {
			surface = pMVar2->surface;
			if (surface != (IDirectDrawSurface4 *)0x0) {
				(*surface->lpVtbl->AddRef)((IUnknown *)surface);
			}
			local_10c = (IDirectDrawSurface4 *)pMVar2->trans;
			goto LAB_004832a8;
		}
		surface = Container_LoadTextureSurface(filepath,1,out_width,out_height,(BOOL *)&local_10c);
		if (surface == (IDirectDrawSurface4 *)0x0) goto LAB_004832a8;
		ref_count = &globs::meshGlobs.textureCountShared;
		pMVar2 = globs::meshGlobs.textureListShared;
	}
	else {
		ref_count = &globs::meshGlobs.textureCount;
		pMVar2 = globs::meshGlobs.textureList;
	}
	Mesh_AddTexturePathEntry(pMVar2,ref_count,filepath,surface,local_10c);
LAB_004832a8:
	if (surface != (IDirectDrawSurface4 *)0x0) {
		local_108->texture = (IDirect3DRMTexture3 *)0x0;
		local_108->surface = surface;
		local_108->colourKey = (BOOL)local_10c;
		return local_108;
	}
	std::free(local_108);
	return (Container_Texture *)0x0;
}



Mesh_TextureReference * __cdecl
lego::res::Mesh_SearchTexturePathList(Mesh_TextureReference *list,uint count,char *path)
{
	int iVar1;
	uint uVar2;
	char **ppcVar3;
	
	uVar2 = 0;
	if (count == 0) {
		return (Mesh_TextureReference *)0x0;
	}
	ppcVar3 = &list->path;
	do {
		iVar1 = std::_stricmp(path,*ppcVar3);
		if (iVar1 == 0) {
			return list + uVar2;
		}
		uVar2 = uVar2 + 1;
		ppcVar3 = ppcVar3 + 3;
	} while (uVar2 < count);
	return (Mesh_TextureReference *)0x0;
}



void __cdecl
lego::res::Mesh_AddTexturePathEntry
					(Mesh_TextureReference *list,uint *ref_count,char *path,IDirectDrawSurface4 *surface,
					BOOL trans)
{
	char *pcVar1;
	
	pcVar1 = std::_strdup(path);
	list[*ref_count].path = pcVar1;
	list[*ref_count].surface = surface;
	list[*ref_count].trans = trans;
	*ref_count = *ref_count + 1;
	return;
}



void __cdecl
lego::res::Mesh_SetGroupTexture(Mesh *mesh,D3DRMGroupIndex groupID,Container_Texture *mt)
{
	uint *puVar1;
	IDirectDrawSurface4 *This;
	
	if (mt != (Container_Texture *)0x0) {
		This = mt->surface;
		if (This != (IDirectDrawSurface4 *)0x0) {
			(*This->lpVtbl->QueryInterface)
								((IUnknown *)This,(IID *)&idl::IID_IDirect3DTexture2,
								 &mesh->groupList[groupID].imText);
		}
		if (mt->colourKey != 0) {
			puVar1 = &mesh->groupList[groupID].flags;
			*puVar1 = *puVar1 | 0x400000;
			return;
		}
		mesh->groupList[groupID].flags = mesh->groupList[groupID].flags & 0xffbfffff;
	}
	return;
}



void __cdecl lego::res::Mesh_RemoveGroupTexture(Mesh *mesh,D3DRMGroupIndex groupID)
{
	Mesh_Group *pMVar1;
	IDirect3DTexture2 *This;
	
	pMVar1 = mesh->groupList;
	This = pMVar1[groupID].imText;
	if (This != (IDirect3DTexture2 *)0x0) {
		(*This->lpVtbl->Release)((IUnknown *)This);
		pMVar1[groupID].imText = (IDirect3DTexture2 *)0x0;
	}
	return;
}



BOOL __cdecl lego::res::Mesh_CreateGroupMaterial(Mesh *mesh,D3DRMGroupIndex groupID)
{
	int iVar1;
	D3DMaterial *pDVar2;
	D3DMaterial *pDVar3;
	D3DMaterial material;
	
	material.hTexture = 0;
	material.dwRampSize = 0;
	material.dwSize = 0x50;
	material.diffuse.red = 1.0;
	material.diffuse.green = 1.0;
	material.diffuse.blue = 1.0;
	material.diffuse.alpha = 1.0;
	material.ambient.red = 0.0;
	material.ambient.green = 0.0;
	material.ambient.blue = 0.0;
	material.ambient.alpha = 0.0;
	material.specular.red = 0.0;
	material.specular.green = 0.0;
	material.specular.blue = 0.0;
	material.specular.alpha = 0.0;
	material.emissive.red = 0.0;
	material.emissive.green = 0.0;
	material.emissive.blue = 0.0;
	material.emissive.alpha = 0.0;
	material.power = 0.0;
	pDVar2 = &material;
	pDVar3 = &mesh->groupList[groupID].material;
	for (iVar1 = 0x14; iVar1 != 0; iVar1 = iVar1 + -1) {
		pDVar3->dwSize = pDVar2->dwSize;
		pDVar2 = (D3DMaterial *)&pDVar2->diffuse;
		pDVar3 = (D3DMaterial *)&pDVar3->diffuse;
	}
	return 1;
}



BOOL __cdecl lego::res::Mesh_SetGroupMaterial(Mesh *mesh,D3DRMGroupIndex groupID,D3DMaterial *mat)
{
	int iVar1;
	D3DMaterial *pDVar2;
	
	pDVar2 = &mesh->groupList[groupID].material;
	for (iVar1 = 0x14; iVar1 != 0; iVar1 = iVar1 + -1) {
		pDVar2->dwSize = mat->dwSize;
		mat = (D3DMaterial *)&mat->diffuse;
		pDVar2 = (D3DMaterial *)&pDVar2->diffuse;
	}
	return 1;
}



BOOL __cdecl
lego::res::Mesh_SetGroupColour
					(Mesh *mesh,D3DRMGroupIndex groupID,float r,float g,float b,MaterialType matType)
{
	D3DMaterial *pDVar1;
	Mesh_Group *pMVar2;
	
	pMVar2 = mesh->groupList + groupID;
	pDVar1 = Mesh_GetGroupMaterial(mesh,groupID);
	if (r < 0.0) {
		r = 0.0;
	}
	if (g < 0.0) {
		g = 0.0;
	}
	if (b < 0.0) {
		b = 0.0;
	}
	if ((ushort)((ushort)(r < 1.0) << 8 | (ushort)(r == 1.0) << 0xe) == 0) {
		r = 1.0;
	}
	if ((ushort)((ushort)(g < 1.0) << 8 | (ushort)(g == 1.0) << 0xe) == 0) {
		g = 1.0;
	}
	if ((ushort)((ushort)(b < 1.0) << 8 | (ushort)(b == 1.0) << 0xe) == 0) {
		b = 1.0;
	}
	if (matType == MATERIAL_DIFFUSE) {
		(pDVar1->diffuse).red = r;
		(pDVar1->diffuse).green = g;
		(pDVar1->diffuse).blue = b;
		if (((r == 1.0) && (g == 1.0)) && (b == 1.0)) {
			pMVar2->flags = pMVar2->flags | 0x100000;
			return 1;
		}
		pMVar2->flags = pMVar2->flags & 0xffefffff;
		return 1;
	}
	if (matType == MATERIAL_AMBIENT) {
		(pDVar1->ambient).green = g;
		(pDVar1->ambient).red = r;
		(pDVar1->ambient).blue = b;
		return 1;
	}
	if (matType != MATERIAL_EMISSIVE) {
		if (matType != MATERIAL_SPECULAR) {
			return 1;
		}
		(pDVar1->specular).green = g;
		(pDVar1->specular).red = r;
		(pDVar1->specular).blue = b;
		return 1;
	}
	(pDVar1->emissive).green = g;
	(pDVar1->emissive).red = r;
	(pDVar1->emissive).blue = b;
	return 1;
}



D3DMaterial * __cdecl lego::res::Mesh_GetGroupMaterial(Mesh *mesh,D3DRMGroupIndex groupID)
{
	return &mesh->groupList[groupID].material;
}



BOOL __cdecl
lego::res::Mesh_SetGroupMaterialValues
					(Mesh *mesh,D3DRMGroupIndex groupID,float value,MaterialType matType)
{
	D3DMaterial *pDVar1;
	uint uVar2;
	Mesh_Group *pMVar3;
	
	pMVar3 = mesh->groupList + groupID;
	pDVar1 = Mesh_GetGroupMaterial(mesh,groupID);
	if (value < 0.0) {
		value = 0.0;
	}
	if ((ushort)((ushort)(value < 1.0) << 8 | (ushort)(value == 1.0) << 0xe) == 0) {
		value = 1.0;
	}
	if (matType != MATERIAL_ALPHA) {
		if (matType == MATERIAL_POWER) {
			pDVar1->power = value;
			return 1;
		}
		return 1;
	}
	uVar2 = pMVar3->flags & 0xeff7ffff;
	pMVar3->flags = uVar2;
	if (value == 0.0) {
		if (pMVar3->renderFlags == 0) {
			if (((mesh->renderDesc).renderFlags & 0x1c00) == 0) goto LAB_004837a4;
			uVar2 = uVar2 | 0x10000000;
		}
		else {
			uVar2 = uVar2 | 0x10000000;
		}
	}
	else {
		if ((value == 1.0) ||
			 ((pMVar3->renderFlags == 0 && (((mesh->renderDesc).renderFlags & 0x1c00) == 0))))
		goto LAB_004837a4;
		uVar2 = uVar2 | 0x80000;
	}
	pMVar3->flags = uVar2;
LAB_004837a4:
	if (pMVar3->renderFlags == 0) {
		if (((mesh->renderDesc).renderFlags & 0xc00) != 0) {
			pMVar3->flags = pMVar3->flags | 0x80000;
		}
	}
	else {
		if ((pMVar3->renderFlags & 0xc00) != 0) {
			pMVar3->flags = pMVar3->flags | 0x80000;
			(pDVar1->diffuse).alpha = value;
			return 1;
		}
	}
	(pDVar1->diffuse).alpha = value;
	return 1;
}



void __cdecl lego::res::Mesh_SetIdentityMatrix(Matrix4F *out_matrix)
{
	out_matrix->values[1][3] = 0.0;
	out_matrix->values[1][2] = 0.0;
	out_matrix->values[1][0] = 0.0;
	out_matrix->values[3] = 0.0;
	out_matrix->values[2] = 0.0;
	out_matrix->values[1] = 0.0;
	out_matrix->values[3][2] = 0.0;
	out_matrix->values[3][1] = 0.0;
	out_matrix->values[3][0] = 0.0;
	out_matrix->values[2][3] = 0.0;
	out_matrix->values[2][1] = 0.0;
	out_matrix->values[2][0] = 0.0;
	out_matrix->values[3][3] = 1.0;
	out_matrix->values[2][2] = 1.0;
	out_matrix->values[1][1] = 1.0;
	out_matrix->values[0] = 1.0;
	return;
}



BOOL __cdecl lego::res::Mesh_SetCurrentViewport(IDirect3DRMViewport *rmViewport)
{
	HRESULT HVar1;
	int iVar2;
	IDirect3DRMViewport *This;
	IDirect3DViewport *d3dViewport;
	
										// IDirect3DRMViewport->GetDirect3DViewport(this, IDirect3DViewport**
										// lplpD3DViewport)
	HVar1 = (*(code *)rmViewport->lpVtbl->GetDirect3DViewport)
										(rmViewport,(IDirect3DViewport **)&rmViewport);
	if (HVar1 != 0) {
		return 0;
	}
	HVar1 = (*rmViewport->lpVtbl->QueryInterface)
										((IUnknown *)rmViewport,(IID *)&idl::IID_IDirect3DViewport3,&d3dViewport);
	This = rmViewport;
	if (HVar1 == 0) {
		if (rmViewport != (IDirect3DRMViewport *)0x0) {
			(*rmViewport->lpVtbl->Release)((IUnknown *)rmViewport);
			rmViewport = (IDirect3DRMViewport *)0x0;
		}
		iVar2 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetCurrentViewport)
											(globs::mainGlobs.imDevice,d3dViewport);
		This = (IDirect3DRMViewport *)d3dViewport;
		if (iVar2 == 0) {
			if (d3dViewport != (IDirect3DViewport *)0x0) {
				(*d3dViewport->lpVtbl->Release)((IUnknown *)d3dViewport);
			}
			return 1;
		}
	}
	if (This != (IDirect3DRMViewport *)0x0) {
		(*This->lpVtbl->Release)((IUnknown *)This);
	}
	return 0;
}



BOOL __cdecl lego::res::Mesh_SetCurrentGODSViewport(Viewport *view)
{
	HRESULT HVar1;
	Viewport *pVVar2;
	Viewport *local_4;
	
										// IDirect3DRMViewport2->GetDirect3DViewport(this, IDirect3DViewport**
										// lplpD3DViewport)
	HVar1 = (*view->lpVP->lpVtbl->GetDirect3DViewport)(view->lpVP,(IDirect3DViewport **)&view);
	if (HVar1 != 0) {
		return 0;
	}
										// IDirect3DViewport->QueryInterface(this, IID_IDirect3DViewport3,
										// IDirect3DViewport3** lplpOut)
	HVar1 = (**(code **)view->xoffset)
										((IDirect3DViewport *)view,&idl::IID_IDirect3DViewport3,
										 (IDirect3DViewport3 **)&local_4);
	pVVar2 = view;
	if (HVar1 == 0) {
		if (view != (Viewport *)0x0) {
										// IDirect3DViewport->Release(this)
			(**(code **)((int)view->xoffset + 8))((IDirect3DViewport *)view);
			view = (Viewport *)0x0;
		}
										// IDirect3DDevice3->SetCurrentViewport(this, IDirect3DViewport3* lpd3dViewport)
		HVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetCurrentViewport)
											(globs::mainGlobs.imDevice,(IDirect3DViewport3 *)local_4);
		pVVar2 = local_4;
		if (HVar1 == 0) {
			if (local_4 != (Viewport *)0x0) {
										// IDirect3DViewport3->Release(this)
				(**(code **)((int)local_4->xoffset + 8))((IDirect3DViewport3 *)local_4);
			}
			return 1;
		}
	}
	if (pVVar2 != (Viewport *)0x0) {
										// IDirect3DViewport->Release(this)
										//  -or-
										// IDirect3DViewport3->Release(this)
		(*((IDirect3DViewportVtbl *)pVVar2->xoffset)->Release)((IDirect3DViewport *)pVVar2);
	}
	return 0;
}



// Sets g_IDirect3DDevice3->SetTransform
// RESULT: false if the current transform was not the same, and SetTransform failed

BOOL __cdecl lego::res::Mesh_SetTransform(D3DTransformStateType state,Matrix4F *matrix)
{
	int iVar1;
	float unaff_EBX;
	float unaff_ESI;
	Matrix4F *pMVar2;
	float unaff_EDI;
	Matrix4F *pMVar3;
	Matrix4F oldMatrix;
	Matrix4F newMatrix;
	
	pMVar2 = matrix;
	pMVar3 = &newMatrix;
										// std::memcpy(newMatrix, oldMatrix, 0x40)
	for (iVar1 = 0x10; iVar1 != 0; iVar1 = iVar1 + -1) {
		pMVar3->values[0] = pMVar2->values[0];
		pMVar2 = (Matrix4F *)(pMVar2->values + 1);
		pMVar3 = (Matrix4F *)(pMVar3->values + 1);
	}
										// IDirect3DDevice3->GetTransform(this, D3DTransformStateType
										// dtstTransformStateType, Matrix4F* lpD3DMatrix)
	(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetTransform)
						(globs::mainGlobs.imDevice,state,&oldMatrix);
	if (((((unaff_EDI != oldMatrix.values[3][1]) || (unaff_ESI != oldMatrix.values[3][2])) ||
			 (unaff_EBX != oldMatrix.values[3][3])) ||
			(((oldMatrix.values[0][0] != newMatrix.values[0][0] ||
				(oldMatrix.values[0][1] != newMatrix.values[0][1])) ||
			 ((oldMatrix.values[0][2] != newMatrix.values[0][2] ||
				((oldMatrix.values[0][3] != newMatrix.values[0][3] ||
				 (oldMatrix.values[1][0] != newMatrix.values[1][0])))))))) ||
		 ((oldMatrix.values[1][1] != newMatrix.values[1][1] ||
			(((((oldMatrix.values[1][2] != newMatrix.values[1][2] ||
					(oldMatrix.values[1][3] != newMatrix.values[1][3])) ||
				 (oldMatrix.values[2][0] != newMatrix.values[2][0])) ||
				((oldMatrix.values[2][1] != newMatrix.values[2][1] ||
				 (oldMatrix.values[2][2] != newMatrix.values[2][2])))) ||
			 ((oldMatrix.values[2][3] != newMatrix.values[2][3] ||
				(oldMatrix.values[3][0] != newMatrix.values[3][0])))))))) {
										// IDirect3DDevice3->SetTransform(this, D3DTransformStateType
										// dtstTransformStateType, Matrix4F* lpD3DMatrix)
		iVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetTransform)
											(globs::mainGlobs.imDevice,state,matrix);
		if (iVar1 != 0) {
			return 0;
		}
	}
	return 1;
}



BOOL __cdecl
lego::res::Mesh_ChangeTextureStageState
					(D3DTextureStageStateType dwRenderStateType,DWORD dwRenderState)
{
	D3DTextureStageStateType dwState;
	HRESULT HVar1;
	
	dwState = dwRenderStateType;
	HVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetTextureStageState)
										(globs::mainGlobs.imDevice,0,dwRenderStateType,&dwRenderStateType);
	if (HVar1 != 0) {
		dwRenderStateType = ~D3DTSS_TCI_PASSTHRU;
	}
	if (dwRenderStateType != dwRenderState) {
		HVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetTextureStageState)
											(globs::mainGlobs.imDevice,0,dwState,(DWORD *)dwRenderState);
		if (HVar1 != 0) {
			return 0;
		}
		if (globs::meshGlobs.stateData[dwState].isUsed == 0) {
			globs::meshGlobs.stateData[dwState].isUsed = 1;
			globs::meshGlobs.stateData[dwState].value = dwRenderStateType;
		}
		else {
			if (globs::meshGlobs.stateData[dwState].value == dwRenderStateType) {
				globs::meshGlobs.stateData[dwState].isUsed = 0;
				return 1;
			}
		}
	}
	return 1;
}



void __cdecl lego::res::Mesh_StoreTextureAndMat(void)
{
	(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetLightState)
						(globs::mainGlobs.imDevice,1,0x541568);
	globs::meshGlobs.currMatIM = globs::meshGlobs.oldMatIM;
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetTexture)(globs::mainGlobs.imDevice,0,0x54156c)
		;
		globs::meshGlobs.currTextureIM = globs::meshGlobs.oldTextureIM;
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetRenderState)
							(globs::mainGlobs.imDevice,1,0x541564);
		if (globs::meshGlobs.oldTextureRM != 0) {
			(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetRenderState)(globs::mainGlobs.imDevice,1,0);
			return;
		}
	}
	else {
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetRenderState)
							(globs::mainGlobs.imDevice,1,0x541564);
		globs::meshGlobs.currTextureRM = globs::meshGlobs.oldTextureRM;
	}
	return;
}



void __cdecl lego::res::Mesh_RestoreTextureAndMat(void)
{
	if (globs::meshGlobs.currMatIM != globs::meshGlobs.oldMatIM) {
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetLightState)
							(globs::mainGlobs.imDevice,1,globs::meshGlobs.oldMatIM);
	}
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
		if (globs::meshGlobs.currTextureIM != globs::meshGlobs.oldTextureIM) {
			(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetTexture)
								(globs::mainGlobs.imDevice,0,globs::meshGlobs.oldTextureIM);
		}
		if (globs::meshGlobs.oldTextureRM != 0) {
			(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetRenderState)
								(globs::mainGlobs.imDevice,1,globs::meshGlobs.oldTextureRM);
			return;
		}
	}
	else {
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetRenderState)
							(globs::mainGlobs.imDevice,1,globs::meshGlobs.oldTextureRM);
	}
	return;
}



BOOL __cdecl lego::res::Mesh_RenderMesh(Mesh *mesh,Matrix4F *matWorld,BOOL alphaBlend)
{
	BOOL BVar1;
	uint uVar2;
	int iVar3;
	Mesh_Group *pMVar4;
	BOOL local_4;
	
	uVar2 = 0;
	local_4 = 1;
	if (mesh->groupCount != 0) {
		iVar3 = 0;
		do {
			pMVar4 = (Mesh_Group *)((int)&mesh->groupList->faceDataSize + iVar3);
			BVar1 = Mesh_CanRenderGroup(pMVar4);
			if ((BVar1 != 0) && (pMVar4->renderFlags == 0)) {
				BVar1 = Mesh_RenderGroup(mesh,pMVar4,matWorld,alphaBlend);
				if (BVar1 == 0) {
					local_4 = BVar1;
				}
			}
			uVar2 = uVar2 + 1;
			iVar3 = iVar3 + 0x70;
		} while (uVar2 < mesh->groupCount);
	}
	uVar2 = 0;
	if (mesh->groupCount != 0) {
		iVar3 = 0;
		do {
			pMVar4 = (Mesh_Group *)((int)&mesh->groupList->faceDataSize + iVar3);
			BVar1 = Mesh_CanRenderGroup(pMVar4);
			if ((BVar1 != 0) && (pMVar4->renderFlags != 0)) {
				BVar1 = Mesh_RenderGroup(mesh,pMVar4,matWorld,alphaBlend);
				if (BVar1 == 0) {
					local_4 = BVar1;
				}
			}
			uVar2 = uVar2 + 1;
			iVar3 = iVar3 + 0x70;
		} while (uVar2 < mesh->groupCount);
	}
	return local_4;
}



BOOL __cdecl lego::res::Mesh_CanRenderGroup(Mesh_Group *group)
{
	if (((group->flags & 1) == 0) && ((group->flags & 0x10000000) == 0)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::res::Mesh_RenderGroup(Mesh *mesh,Mesh_Group *group,Matrix4F *matWorld,BOOL alphaBlend)
{
	BOOL BVar1;
	uint uVar2;
	
	Mesh_SetGroupRenderDesc(mesh,group,matWorld,alphaBlend);
	BVar1 = Mesh_SetMaterial(&group->material);
	uVar2 = (uint)(BVar1 != 0);
	BVar1 = Mesh_RenderTriangleList
										(globs::meshGlobs.matHandle,group->imText,0x112,group->vertices,
										 group->vertexCount,group->faceData,group->faceDataSize);
	if (BVar1 == 0) {
		uVar2 = 0;
	}
	return uVar2;
}



BOOL __cdecl
lego::res::Mesh_SetGroupRenderDesc(Mesh *mesh,Mesh_Group *group,Matrix4F *matWorld,BOOL alphaBlend)
{
	DWORD dwRenderState;
	
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
		if (((group->flags & 0x100000) == 0) || (group->imText == (IDirect3DTexture2 *)0x0)) {
										// D3DTOP_MODULATE (0x4)
			dwRenderState = D3DTOP_MODULATE;
		}
		else {
										// D3DTOP_SELECTARG1 (0x2)
			dwRenderState = D3DTOP_SELECTARG1;
		}
										// D3DTSS_COLOROP (0x1), ...
		Mesh_ChangeTextureStageState(D3DTSS_COLOROP,dwRenderState);
	}
										// D3DRENDERSTATE_COLORKEYENABLE (0x29), [BOOL]
	main::Main_ChangeRenderState(D3DRENDERSTATE_COLORKEYENABLE,(uint)((group->flags & 0x400000) != 0))
	;
	if (group->renderFlags != 0) {
		Mesh_SetRenderDesc(group->renderFlags,matWorld,alphaBlend);
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::res::Mesh_RenderTriangleList
					(DWORD matHandle,IDirect3DTexture2 *texture,DWORD renderFlags,Mesh_Vertex *vertices,
					DWORD vertexCount,WORD *faceData,DWORD indexCount)
{
	int iVar1;
	HRESULT HVar2;
	DWORD in_ECX;
	BOOL BVar3;
	DWORD local_4;
	
	BVar3 = 1;
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
		local_4 = in_ECX;
		if (texture != globs::meshGlobs.currTextureIM) {
			iVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetTexture)
												(globs::mainGlobs.imDevice,0,texture);
			if (iVar1 == 0) {
				globs::meshGlobs.currTextureIM = texture;
			}
			else {
				BVar3 = 0;
			}
		}
	}
	else {
		local_4 = 0;
		if (texture != (IDirect3DTexture2 *)0x0) {
			(*(globs::mainGlobs.imDevice)->lpVtbl->QueryInterface)
								((IUnknown *)globs::mainGlobs.imDevice,(IID *)&idl::IID_IDirect3DDevice2,&texture);
										// IDirect3DDevice2->GetCaps(this, D3DDEVICEDESC_V1* lpD3DHWDevDesc,
										// D3DDEVICEDESC_V1* lpD3DHELDevDesc)
			(*(code *)texture->lpVtbl->GetHandle)(texture,texture,&local_4);
			if (texture != (IDirect3DTexture2 *)0x0) {
										// IDirect3DDevice2->Release(this)
				(*texture->lpVtbl->Release)((IUnknown *)texture);
			}
		}
		if (local_4 != globs::meshGlobs.currTextureRM) {
										// D3DRENDERSTATE_TEXTUREHANDLE (0x1)
			main::Main_ChangeRenderState(D3DRENDERSTATE_TEXTUREHANDLE,local_4);
			globs::meshGlobs.currTextureRM = local_4;
		}
	}
	if (matHandle != globs::meshGlobs.currMatIM) {
										// D3DLIGHTSTATE_MATERIAL (0x1)
		iVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetLightState)
											(globs::mainGlobs.imDevice,D3DLIGHTSTATE_MATERIAL,matHandle);
		if (iVar1 == 0) {
			globs::meshGlobs.currMatIM = matHandle;
		}
		else {
			BVar3 = 0;
		}
	}
										// IDirect3DDevice3->DrawIndexedPrimitive(this, D3DPrimitiveType
										// dptPrimitiveType, DWORD dwVertexTypeDesc, void* lpvVertices, DWORD
										// dwVertexCount, WORD* lpwIndices, DWORD dwIndexCount, DWORD dwFlags)
										// 
										//  D3DPT_TRIANGLELIST (0x4)
	HVar2 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->DrawIndexedPrimitive)
										(globs::mainGlobs.imDevice,D3DPT_TRIANGLELIST,renderFlags,vertices,vertexCount,
										 faceData,indexCount,0);
	if (HVar2 != 0) {
		BVar3 = 0;
	}
	return BVar3;
}



BOOL __cdecl lego::image::Flic_Setup(char *filename,ImageFlic **out_fsp,FlicUserFlags flags)
{
	char cVar1;
	IDirectDraw4 *pIVar2;
	ImageFlic *flic;
	BOOL BVar3;
	byte *pbVar4;
	FileStream *pFVar5;
	void *pvVar6;
	int iVar7;
	uint uVar8;
	uint uVar9;
	undefined4 *puVar10;
	DDSURFACEDESC2 *pDVar11;
	char *pcVar12;
	char *pcVar13;
	undefined4 *puVar14;
	DDCOLORKEY colorKey;
	char drive [4];
	DDSURFACEDESC2 surfDesc;
	char errorMessage [128];
	char fname [256];
	char ext [256];
	char dir [256];
	
	pIVar2 = globs::directDrawGlobs.lpDirectDraw;
	flic = (ImageFlic *)std::malloc(0x6e8);
	*out_fsp = flic;
	for (iVar7 = 0x1ba; iVar7 != 0; iVar7 = iVar7 + -1) {
		flic->userflags = FLICDISK;
		flic = (ImageFlic *)&flic->fsXc;
	}
	(*out_fsp)->fsDisplayMode = FLICMODE_HICOLOR;
	std::_splitpath(filename,drive,dir,fname,ext);
	BVar3 = Flic_LoadHeader(filename,out_fsp);
	if (BVar3 == 0) {
		return 0;
	}
	flic = *out_fsp;
	pDVar11 = &surfDesc;
	for (iVar7 = 0x1f; iVar7 != 0; iVar7 = iVar7 + -1) {
		pDVar11->dwSize = 0;
		pDVar11 = (DDSURFACEDESC2 *)&pDVar11->dwFlags;
	}
	surfDesc.dwSize = 0x7c;
	surfDesc.dwFlags = 7;
	surfDesc.ddsCaps.dwCaps = 0x840;
	surfDesc.dwWidth = (DWORD)(flic->fsHeader).width;
	surfDesc.dwHeight = (DWORD)(flic->fsHeader).height;
	flic->fsXsize = surfDesc.dwWidth;
	(*out_fsp)->fsYsize = surfDesc.dwHeight;
	(*pIVar2->lpVtbl->CreateSurface)(pIVar2,&surfDesc,&(*out_fsp)->fsSurface,(IUnknown *)0x0);
	colorKey.dwColorSpaceLowValue = 0;
	colorKey.dwColorSpaceHighValue = 0;
										// A GRAPHICAL CRASH(FREEZE?) WAS OBSERVED HERE WHEN RUNNING IN OLLYDBG
										// POINT OF FAILURE (pointer evaluated to -1)
	(*(*out_fsp)->fsSurface->lpVtbl->SetColorKey)((*out_fsp)->fsSurface,8,&colorKey);
	(*out_fsp)->userflags = flags;
	uVar8 = 0xffffffff;
	pcVar12 = filename;
	do {
		pcVar13 = pcVar12;
		if (uVar8 == 0) break;
		uVar8 = uVar8 - 1;
		pcVar13 = pcVar12 + 1;
		cVar1 = *pcVar12;
		pcVar12 = pcVar13;
	} while (cVar1 != '\0');
	uVar8 = ~uVar8;
	puVar10 = (undefined4 *)(pcVar13 + -uVar8);
	puVar14 = (undefined4 *)(*out_fsp)->filename;
	for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
		*puVar14 = *puVar10;
		puVar10 = puVar10 + 1;
		puVar14 = puVar14 + 1;
	}
	for (uVar8 = uVar8 & 3; uVar8 != 0; uVar8 = uVar8 - 1) {
		*(undefined *)puVar14 = *(undefined *)puVar10;
		puVar10 = (undefined4 *)((int)puVar10 + 1);
		puVar14 = (undefined4 *)((int)puVar14 + 1);
	}
	(*out_fsp)->fsXc = 0;
	(*out_fsp)->fsYc = 0;
	(*out_fsp)->currentframe = 0;
	(*out_fsp)->overallframe = 0;
	(*out_fsp)->framerate = 0x190000;
	flic = *out_fsp;
	if (((byte)flic->userflags & 1) == 1) {
		flic->pointerposition = 0;
		pbVar4 = (byte *)std::malloc(((*out_fsp)->fsHeader).size);
		(*out_fsp)->rambufferhandle = pbVar4;
		pFVar5 = lego::file::File_Open(filename,"rb");
		(*out_fsp)->filehandle = pFVar5;
		lego::file::File_Seek((*out_fsp)->filehandle,0x80,0);
		flic = *out_fsp;
		lego::file::File_Read(flic->rambufferhandle,(flic->fsHeader).size,1,flic->filehandle);
		lego::file::File_Close((*out_fsp)->filehandle);
	}
	else {
		flic->pointerposition = 0x80;
		pFVar5 = lego::file::File_Open(filename,"rb");
		(*out_fsp)->filehandle = pFVar5;
		if ((*out_fsp)->filehandle == (FileStream *)0x0) {
			std::sprintf(errorMessage,"Not Enough Memory > %s",filename);
			return 0;
		}
		lego::file::File_Seek((*out_fsp)->filehandle,0x80,0);
	}
	pvVar6 = std::malloc(20000);
	(*out_fsp)->fsLoadBuffer = pvVar6;
	return TRUE;
}



BOOL __cdecl lego::image::Flic_Close(ImageFlic *fsp)
{
	if (fsp == (ImageFlic *)0x0) {
		return 0;
	}
	if (((byte)fsp->userflags & FLICMEMORY) == FLICMEMORY) {
		std::free(fsp->rambufferhandle);
	}
	else {
		lego::file::File_Close(fsp->filehandle);
	}
	if (fsp->fsLoadBuffer != (void *)0x0) {
		std::free(fsp->fsLoadBuffer);
		fsp->fsLoadBuffer = (void *)0x0;
	}
	return TRUE;
}



// see: <https://www.compuphase.com/flic.htm#FLICHEADER>

BOOL __cdecl lego::image::Flic_LoadHeader(char *filename,ImageFlic **fsp)
{
	ushort uVar1;
	ImageFlic *pIVar2;
	FileStream *f;
	int iVar3;
	char *format;
	char errorMessage [128];
	
	f = lego::file::File_Open(filename,"rb");
	if (f == (FileStream *)0x0) {
		format = "Flic File Not Found %s";
	}
	else {
		lego::file::File_Seek(f,0,0);
		lego::file::File_Read(&(*fsp)->fsHeader,0x88,1,f);
		pIVar2 = *fsp;
		iVar3 = lego::file::File_Length(f);
		if ((pIVar2->fsHeader).size != iVar3) {
			lego::file::File_Close(f);
			std::sprintf(errorMessage,"Flic File Invalid",filename);
			return 0;
		}
		uVar1 = (pIVar2->fsHeader).magic;
		if (uVar1 < 0x911a) {
			if ((uVar1 == 0x9119) || (uVar1 == 0x1234)) {
LAB_004842d2:
				lego::file::File_Close(f);
				return TRUE;
			}
		}
		else {
			if (((uVar1 == 0xaf11) || (uVar1 == 0xaf12)) || (uVar1 == 0xaf43)) goto LAB_004842d2;
		}
		lego::file::File_Close(f);
		format = "Flic File Invalid %s";
	}
	std::sprintf(errorMessage,format,filename);
	return 0;
}



BOOL __cdecl lego::image::Flic_Animate(ImageFlic *fsp,Rect2F *destArea,BOOL advance,BOOL trans)
{
	IDirectDrawSurface4 *pIVar1;
	int iVar2;
	FlicError FVar3;
	DDSURFACEDESC2 *pDVar4;
	uint *puVar5;
	longlong lVar6;
	longlong lVar7;
	longlong lVar8;
	RECT dstRect;
	DDSURFACEDESC2 surfDesc;
	uint ddBltFX [25];
	
	pIVar1 = globs::directDrawGlobs.bSurf;
	lVar6 = __ftol((float10)destArea->x);
	dstRect.left = (int)lVar6;
	lVar7 = __ftol((float10)destArea->y);
	dstRect.top = (int)lVar7;
	lVar8 = __ftol((float10)destArea->width);
	dstRect.right = (int)lVar8 + (int)lVar6;
	lVar6 = __ftol((float10)destArea->height);
	dstRect.bottom = (int)lVar6 + (int)lVar7;
	FVar3 = FLICNOERROR;
	pDVar4 = &surfDesc;
	for (iVar2 = 0x1f; iVar2 != 0; iVar2 = iVar2 + -1) {
		pDVar4->dwSize = 0;
		pDVar4 = (DDSURFACEDESC2 *)&pDVar4->dwFlags;
	}
	surfDesc.dwSize = 0x7c;
	(*fsp->fsSurface->lpVtbl->Lock)(fsp->fsSurface,(LPRECT)0x0,&surfDesc,1,(HANDLE)0x0);
	fsp->fsPitch = surfDesc.lPitch;
	fsp->fsSPtr = surfDesc.lpSurface;
	fsp->is15bit = (uint)(surfDesc.ddpfPixelFormat.dwGBitMask == 0x3e0);
	iVar2 = 1;
	if (fsp->currentframe != 0) {
		iVar2 = advance;
	}
	if (iVar2 != 0) {
		if (((byte)fsp->userflags & FLICMEMORY) == FLICMEMORY) {
			FVar3 = Flic_Memory(fsp);
		}
		else {
			FVar3 = Flic_Load(fsp);
		}
	}
	(*fsp->fsSurface->lpVtbl->Unlock)(fsp->fsSurface,(LPRECT)0x0);
	puVar5 = ddBltFX;
	for (iVar2 = 0x19; iVar2 != 0; iVar2 = iVar2 + -1) {
		*puVar5 = 0;
		puVar5 = puVar5 + 1;
	}
	ddBltFX[0] = 100;
	ddBltFX[20] = 0xff00;
										// DDBLT_WAIT | (trans ? DDBLT_KEYSRC : 0)  (0x1000000) (0x8000)
	(*pIVar1->lpVtbl->Blt)
						(pIVar1,(LPRECT)&dstRect,fsp->fsSurface,(LPRECT)0x0,
						 -(uint)(trans != 0) & 0x8000 | 0x1000000,ddBltFX);
	return (uint)(FVar3 == FLICNOERROR);
}



FlicError __cdecl lego::image::Flic_Memory(ImageFlic *fsp)
{
	int iVar1;
	FlicError FVar2;
	
	FVar2 = FLICNOERROR;
	Flic_FindChunk(fsp);
	if (fsp->currentframe == 0) {
		fsp->ringframe = fsp->pointerposition;
	}
	iVar1 = fsp->currentframe + 1;
	fsp->currentframe = iVar1;
	fsp->overallframe = fsp->overallframe + 1;
	if (((byte)fsp->userflags & FLICLOOPINGON) == FLICLOOPINGON) {
		if (iVar1 == (fsp->fsHeader).frames + 1) {
			fsp->currentframe = 1;
			fsp->pointerposition = fsp->ringframe;
			return FLICNOERROR;
		}
	}
	else {
		if (iVar1 == (fsp->fsHeader).frames + 1) {
			FVar2 = FLICFINISHED;
		}
	}
	return FVar2;
}



FlicError __cdecl lego::image::Flic_Load(ImageFlic *fsp)
{
	int iVar1;
	FlicError FVar2;
	
	FVar2 = FLICNOERROR;
	if (fsp->currentframe == 0) {
		fsp->ringframe = fsp->pointerposition;
	}
	lego::file::File_Read(fsp->fsLoadBuffer,0x10,1,fsp->filehandle);
	Flic_FindChunk(fsp);
	iVar1 = fsp->currentframe + 1;
	fsp->currentframe = iVar1;
	fsp->overallframe = fsp->overallframe + 1;
	if (((byte)fsp->userflags & FLICLOOPINGON) == FLICLOOPINGON) {
		if ((int)(uint)(fsp->fsHeader).frames < iVar1) {
			lego::file::File_Seek(fsp->filehandle,fsp->ringframe,0);
			fsp->pointerposition = fsp->ringframe;
			fsp->currentframe = 0;
			return FLICNOERROR;
		}
	}
	else {
		if ((int)(uint)(fsp->fsHeader).frames < iVar1) {
			FVar2 = FLICFINISHED;
		}
	}
	return FVar2;
}



FlicError __cdecl lego::image::Flic_FindChunk(ImageFlic *fsp)
{
	short sVar1;
	int iVar2;
	bool bVar3;
	int iVar4;
	FlicUserFlags FVar5;
	int iVar6;
	int *piVar7;
	
	FVar5 = fsp->userflags & FLICMEMORY;
	if (FVar5 == FLICMEMORY) {
		piVar7 = (int *)fsp->rambufferhandle;
	}
	else {
		piVar7 = (int *)fsp->fsLoadBuffer;
	}
	iVar2 = fsp->pointerposition;
	if (FVar5 == FLICMEMORY) {
		iVar6 = *(int *)((int)piVar7 + iVar2);
		piVar7 = (int *)((int)piVar7 + iVar2);
		bVar3 = false;
		while (fsp->pointerposition < (fsp->fsHeader).size) {
			sVar1 = *(short *)(piVar7 + 1);
			if (sVar1 == 0xb) {
				Flic_LoadPalette64(fsp);
				iVar4 = fsp->pointerposition + *piVar7;
LAB_00484688:
				fsp->pointerposition = iVar4;
LAB_0048468e:
				piVar7 = (int *)((int)piVar7 + *piVar7);
				iVar6 = iVar6 + *piVar7;
			}
			else {
				if (sVar1 == 0x4b4c) {
					Flic_LoadPointers(fsp);
					fsp->pointerposition = fsp->pointerposition + *piVar7;
					goto LAB_0048468e;
				}
				if (sVar1 != -0xe06) {
					iVar4 = *piVar7 + fsp->pointerposition;
					goto LAB_00484688;
				}
				Flic_FrameChunk(fsp);
				bVar3 = true;
			}
			if (bVar3) {
				fsp->pointerposition = iVar2 + iVar6;
				return FLICNOERROR;
			}
		}
	}
	else {
		iVar6 = *piVar7;
		bVar3 = false;
		do {
			if ((fsp->fsHeader).size <= fsp->pointerposition) break;
			sVar1 = *(short *)(piVar7 + 1);
			if (sVar1 == 0xb) {
				Flic_LoadPalette64(fsp);
LAB_00484704:
				iVar4 = fsp->pointerposition + *piVar7;
				fsp->pointerposition = iVar4;
LAB_00484719:
				lego::file::File_Seek(fsp->filehandle,iVar4,0);
				piVar7 = (int *)fsp->fsLoadBuffer;
				lego::file::File_Read(piVar7,0x10,1,fsp->filehandle);
				iVar6 = iVar6 + *piVar7;
			}
			else {
				if (sVar1 == 0x4b4c) {
					Flic_LoadPointers(fsp);
					goto LAB_00484704;
				}
				if (sVar1 != -0xe06) {
					iVar4 = *piVar7 + fsp->pointerposition;
					fsp->pointerposition = iVar4;
					goto LAB_00484719;
				}
				Flic_FrameChunk(fsp);
				bVar3 = true;
			}
		} while (!bVar3);
	}
	fsp->pointerposition = iVar2 + iVar6;
	return FLICNOERROR;
}



BOOL __cdecl lego::image::Flic_FrameChunk(ImageFlic *fsp)
{
	byte bVar1;
	char cVar2;
	uint length;
	int *piVar3;
	char buff [128];
	
	if (((byte)fsp->userflags & FLICMEMORY) == FLICMEMORY) {
		bVar1 = (fsp->rambufferhandle + fsp->pointerposition)[6];
		piVar3 = (int *)(fsp->rambufferhandle + fsp->pointerposition + 0x10);
		fsp->pointerposition = fsp->pointerposition + 0x10;
		if ('\0' < (char)bVar1) {
			while (fsp->pointerposition < (fsp->fsHeader).size) {
				fsp->fsSource = piVar3;
				Flic_DoChunk(fsp);
				fsp->pointerposition = fsp->pointerposition + *piVar3;
				piVar3 = (int *)((int)piVar3 + *piVar3);
				bVar1 = bVar1 - 1;
				if ((char)bVar1 < '\x01') {
					return TRUE;
				}
			}
		}
	}
	else {
		piVar3 = (int *)fsp->fsLoadBuffer;
		cVar2 = *(char *)((int)piVar3 + 6);
		length = *piVar3 - 0x10;
		if (fsp->fsLoadBufferSize < (int)length) {
			if (piVar3 != (int *)0x0) {
				std::free(piVar3);
			}
			fsp->fsLoadBufferSize = length;
			piVar3 = (int *)std::malloc(length);
			fsp->fsLoadBuffer = piVar3;
			if (piVar3 == (int *)0x0) {
				std::sprintf(buff,"Flic Not Enough Memory");
				return 0;
			}
		}
		lego::file::File_Read(piVar3,length,1,fsp->filehandle);
		fsp->pointerposition = fsp->pointerposition + 0x10;
		while (('\0' < cVar2 && (fsp->pointerposition < (fsp->fsHeader).size))) {
			fsp->fsSource = piVar3;
			Flic_DoChunk(fsp);
			fsp->pointerposition = fsp->pointerposition + *piVar3;
			piVar3 = (int *)((int)piVar3 + *piVar3);
			cVar2 = cVar2 + -1;
		}
	}
	return TRUE;
}



// sort out chunk type

FlicError __cdecl lego::image::Flic_DoChunk(ImageFlic *fsp)
{
	FlicError FVar1;
	int iVar2;
	
	FVar1 = FLICNOERROR;
	iVar2 = (int)*(short *)((int)fsp->fsSource + 4);
	if (iVar2 < 8) {
		if (iVar2 == 7) {
switchD_0048492b_caseD_1b:
			Flic_DeltaWord(fsp);
			return FLICFINISHED;
		}
		if (iVar2 == 4) {
			Flic_Palette256(fsp);
			return FLICFINISHED;
		}
	}
	else {
		if (iVar2 < 0x5345) {
			switch(iVar2) {
			case 0xb:
				nerps::funcs::NERPFunc__True((int *)fsp);
				return FLICFINISHED;
			case 0xc:
				nerps::funcs::NERPFunc__True((int *)fsp);
				return FLICFINISHED;
			case 0xd:
				nerps::funcs::NERPFunc__True((int *)fsp);
				return FLICFINISHED;
			case 0xe:
			case 0x11:
			case 0x12:
			case 0x13:
			case 0x14:
			case 0x15:
			case 0x16:
			case 0x17:
			case 0x18:
			case 0x1a:
				goto switchD_0048492b_caseD_e;
			case 0xf:
			case 0x19:
				Flic_BrunDepack(fsp);
				return FLICFINISHED;
			case 0x10:
				Flic_Copy(fsp);
				return FLICFINISHED;
			case 0x1b:
				goto switchD_0048492b_caseD_1b;
			}
		}
		else {
			if (iVar2 != 0x5555) {
				return FLICNOERROR;
			}
			nerps::funcs::NERPFunc__False((int *)fsp);
		}
		FVar1 = FLICFINISHED;
	}
switchD_0048492b_caseD_e:
	return FVar1;
}



// Function to load pointers for each frame of flic.

FlicError __cdecl lego::image::Flic_LoadPointers(ImageFlic *fsp)
{
	uint length;
	uint *buffer;
	char buff [256];
	
	if (((byte)fsp->userflags & FLICMEMORY) != FLICMEMORY) {
		buffer = (uint *)fsp->fsLoadBuffer;
		length = *buffer;
		if (fsp->fsLoadBufferSize < (int)length) {
			if (buffer != (uint *)0x0) {
				std::free(buffer);
			}
			fsp->fsLoadBufferSize = length;
			buffer = (uint *)std::malloc(length);
			fsp->fsLoadBuffer = buffer;
			if (buffer == (uint *)0x0) {
				std::sprintf(buff,"Flic Not Enough Memory");
				return FLICNOERROR;
			}
		}
		lego::file::File_Seek(fsp->filehandle,fsp->pointerposition,0);
		lego::file::File_Read(buffer,length,1,fsp->filehandle);
	}
	return FLICNOERROR;
}



// Function to load an 8 bit palette.

FlicError __cdecl lego::image::Flic_LoadPalette64(ImageFlic *fsp)
{
	uint length;
	uint *buffer;
	char buff [128];
	
	if (((byte)fsp->userflags & FLICMEMORY) != FLICMEMORY) {
		buffer = (uint *)fsp->fsLoadBuffer;
		length = *buffer;
		if (fsp->fsLoadBufferSize < (int)length) {
			if (buffer != (uint *)0x0) {
				std::free(buffer);
			}
			fsp->fsLoadBufferSize = length;
			buffer = (uint *)std::malloc(length);
			fsp->fsLoadBuffer = buffer;
			if (buffer == (uint *)0x0) {
				std::sprintf(buff,"Flic Not Enough Memory");
				return FLICFINISHED;
			}
		}
		lego::file::File_Seek(fsp->filehandle,fsp->pointerposition,0);
		lego::file::File_Read(buffer,length,1,fsp->filehandle);
	}
	return FLICNOERROR;
}



BOOL __cdecl lego::image::Flic_Copy(ImageFlic *fsp)
{
	if (fsp->fsBitPlanes == 0x10) {
										// FlicCopyHiColorFlic(fsp) => return;
		util::logf_removed((char *)fsp);
		return TRUE;
	}
	if (fsp->fsDisplayMode == FLICMODE_BYTEPERPIXEL) {
										// FlicCopyBytePerPixel(fsp) => return;
		util::logf_removed((char *)fsp);
	}
	if (fsp->fsDisplayMode == FLICMODE_HICOLOR) {
										// FlicCopyHiColor(fsp) => return;
		util::logf_removed((char *)fsp);
	}
	return TRUE;
}



BOOL __cdecl lego::image::FlicBRunDepackHiColor(ImageFlic *fsp)
{
	byte n;
	byte bVar1;
	ushort uVar2;
	uint uVar3;
	uint uVar4;
	ushort *puVar5;
	byte *pbVar6;
	byte *pbVar7;
	int local_8;
	uint local_4;
	
	pbVar6 = (byte *)((int)fsp->fsSource + 7);
	if (*(ushort *)&fsp->fsYsize != 0) {
		local_4 = (uint)*(ushort *)&fsp->fsYsize;
		local_8 = 0;
		do {
			uVar2 = *(ushort *)&fsp->fsXsize;
			uVar3 = (uint)uVar2;
			puVar5 = (ushort *)((int)fsp->fsSPtr + (fsp->fsPitch >> 1) * local_8 * 2);
			while (uVar2 != 0) {
				bVar1 = *pbVar6;
				uVar4 = (uint)bVar1;
				pbVar7 = pbVar6 + 1;
				if (bVar1 < 0x80) {
					n = *pbVar7;
					uVar3 = uVar3 - uVar4;
					pbVar7 = pbVar6 + 2;
					if (bVar1 != 0) {
						do {
							uVar2 = getFlicCol(n,fsp);
							*puVar5 = uVar2;
							puVar5 = puVar5 + 1;
							uVar4 = uVar4 - 1;
						} while (uVar4 != 0);
					}
				}
				else {
					uVar4 = 0x100 - uVar4;
					uVar3 = uVar3 - uVar4;
					if ((short)uVar4 != 0) {
						uVar4 = uVar4 & 0xffff;
						do {
							bVar1 = *pbVar7;
							pbVar7 = pbVar7 + 1;
							uVar2 = getFlicCol(bVar1,fsp);
							*puVar5 = uVar2;
							puVar5 = puVar5 + 1;
							uVar4 = uVar4 - 1;
						} while (uVar4 != 0);
					}
				}
				pbVar6 = pbVar7;
				uVar2 = (ushort)uVar3;
			}
			local_8 = local_8 + 1;
			pbVar6 = pbVar6 + 1;
			local_4 = local_4 - 1;
		} while (local_4 != 0);
	}
	return TRUE;
}



BOOL __cdecl lego::image::FlicBRunDepackHiColorFlic32k(ImageFlic *fsp)
{
	ushort uVar1;
	short sVar2;
	ImageFlic *pIVar3;
	ushort uVar4;
	uint uVar5;
	uint uVar6;
	ushort *puVar7;
	ushort *puVar8;
	ushort *puVar9;
	short sVar10;
	
	pIVar3 = fsp;
	fsp = (ImageFlic *)0x0;
	sVar2 = *(short *)&pIVar3->fsYsize;
	puVar8 = (ushort *)((int)pIVar3->fsSource + 7);
	if (0 < sVar2) {
		uVar5 = 0;
		do {
			sVar10 = *(short *)&pIVar3->fsXsize;
			puVar7 = (ushort *)((int)pIVar3->fsSPtr + (pIVar3->fsPitch >> 1) * uVar5 * 2);
			while (0 < sVar10) {
				uVar4 = (ushort)*(byte *)puVar8;
				puVar9 = (ushort *)((int)puVar8 + 1);
				if (uVar4 < 0x80) {
					uVar1 = *puVar9;
					sVar10 = sVar10 - uVar4;
					puVar8 = (ushort *)((int)puVar8 + 3);
					uVar5 = (uVar1 & 0xffe0) << 1;
					if (uVar4 != 0) {
						uVar6 = (uint)uVar4;
						do {
							if (pIVar3->is15bit == 0) {
								uVar4 = (ushort)uVar5;
							}
							else {
								uVar4 = (ushort)((uVar5 & 0xffff) >> 1);
							}
							*puVar7 = uVar4 | uVar1 & 0x1f;
							puVar7 = puVar7 + 1;
							uVar6 = uVar6 - 1;
						} while (uVar6 != 0);
					}
				}
				else {
					uVar4 = 0x100 - uVar4;
					sVar10 = sVar10 - uVar4;
					puVar8 = puVar9;
					if (uVar4 != 0) {
						uVar5 = (uint)uVar4;
						do {
							uVar4 = *puVar9;
							puVar9 = puVar9 + 1;
							uVar6 = (uVar4 & 0xffe0) << 1;
							if (pIVar3->is15bit == 0) {
								uVar1 = (ushort)uVar6;
							}
							else {
								uVar1 = (ushort)((uVar6 & 0xffff) >> 1);
							}
							*puVar7 = uVar1 | uVar4 & 0x1f;
							puVar7 = puVar7 + 1;
							uVar5 = uVar5 - 1;
							puVar8 = puVar9;
						} while (uVar5 != 0);
					}
				}
			}
			puVar8 = (ushort *)((int)puVar8 + 1);
			fsp = (ImageFlic *)((int)&fsp->userflags + 1);
			uVar5 = (uint)fsp & 0xffff;
		} while ((int)uVar5 < (int)sVar2);
	}
	return TRUE;
}



BOOL __cdecl lego::image::Flic_BrunDepack(ImageFlic *fsp)
{
	ushort uVar1;
	
	uVar1 = (fsp->fsHeader).depth;
	if (uVar1 == 8) {
		if (fsp->fsDisplayMode == FLICMODE_BYTEPERPIXEL) {
										// FlicBRunDepackBytePerPixel(fsp) => return TRUE;
			nerps::funcs::NERPFunc__True((int *)fsp);
		}
		if (fsp->fsDisplayMode == FLICMODE_HICOLOR) {
			FlicBRunDepackHiColor(fsp);
			return TRUE;
		}
	}
	else {
		if (uVar1 == 0x10) {
			if ((fsp->fsHeader).magic == 0xaf43) {
				FlicBRunDepackHiColorFlic32k(fsp);
				return TRUE;
			}
										// FlicBRunDepackHiColorFlic(fsp) => return TRUE;
			nerps::funcs::NERPFunc__True((int *)fsp);
		}
	}
	return TRUE;
}



int __cdecl lego::nerps::funcs::NERPFunc__True(int *stack)
{
	return TRUE;
}



void __cdecl lego::image::FlicCreateHiColorTable(ImageFlic *fsp)
{
	ColourRGBPacked *pCVar1;
	ushort *puVar2;
	int iVar3;
	
	iVar3 = 0x100;
	pCVar1 = fsp->fsPalette256;
	puVar2 = fsp->fsPalette64k;
	do {
		iVar3 = iVar3 + -1;
		*puVar2 = (ushort)(((uint)pCVar1->green | (pCVar1->red & 0xffff003e) << 5) << 5) |
							(ushort)(pCVar1->blue >> 1);
		pCVar1 = pCVar1 + 1;
		puVar2 = puVar2 + 1;
	} while (iVar3 != 0);
	fsp->fsPalette64k[0] = 0;
	return;
}



BOOL __cdecl lego::image::Flic_Palette256(ImageFlic *fsp)
{
	byte bVar1;
	byte *pbVar2;
	byte *pbVar3;
	ColourRGBPacked *pCVar4;
	uint uVar5;
	int iVar6;
	short sVar7;
	
	pCVar4 = fsp->fsPalette256;
	pbVar2 = (byte *)((int)fsp->fsSource + 8);
	for (sVar7 = *(short *)((int)fsp->fsSource + 6); sVar7 != 0; sVar7 = sVar7 + -1) {
		pbVar3 = pbVar2 + 2;
		uVar5 = (uint)pbVar2[1];
		pCVar4 = pCVar4 + *pbVar2;
		if (pbVar2[1] == 0) {
			sVar7 = 1;
			uVar5 = 0x100;
			pCVar4 = fsp->fsPalette256;
		}
		iVar6 = uVar5 * 3;
		if ((short)iVar6 != 0) {
			do {
				bVar1 = *pbVar3;
				pbVar3 = pbVar3 + 1;
				pCVar4->red = bVar1 >> 2;
				pCVar4 = (ColourRGBPacked *)&pCVar4->green;
				iVar6 = iVar6 + -1;
			} while (iVar6 != 0);
		}
		pbVar2 = pbVar3;
	}
	if (fsp->fsDisplayMode == FLICMODE_HICOLOR) {
		FlicCreateHiColorTable(fsp);
	}
	return TRUE;
}



void __cdecl lego::util::logf_removed(char *message,...)
{
	return;
}



void __cdecl lego::image::FlicDeltaWordHiColor(ImageFlic *fsp)
{
	void **ppvVar1;
	byte bVar2;
	byte bVar3;
	ushort uVar4;
	ushort uVar5;
	uint uVar6;
	short sVar7;
	short sVar8;
	ushort *puVar9;
	ushort *puVar10;
	ushort *puVar11;
	uint local_10;
	byte local_4;
	ImageFlic *fsp_00;
	
	fsp_00 = fsp;
	ppvVar1 = &fsp->fsSource;
	fsp = (ImageFlic *)0x0;
	sVar8 = *(short *)((int)*ppvVar1 + 6);
	puVar10 = (ushort *)((int)*ppvVar1 + 8);
	sVar7 = sVar8;
	while( true ) {
		while( true ) {
			if (sVar7 == 0) {
				return;
			}
			uVar5 = *puVar10;
			puVar9 = (ushort *)(((uint)fsp & 0xffff) * fsp_00->fsPitch + (int)fsp_00->fsSPtr);
			uVar4 = uVar5 >> 0xc & 0xc;
			if (uVar4 != 0xc) break;
			puVar10 = puVar10 + 1;
			fsp = (ImageFlic *)((int)fsp - (uint)uVar5);
		}
		if (uVar4 == 4) break;
		if (uVar4 == 8) {
			local_4 = *(byte *)puVar10;
			puVar10 = puVar10 + 1;
		}
		uVar5 = *puVar10;
		puVar10 = puVar10 + 1;
		if (uVar5 != 0) {
			local_10 = (uint)uVar5;
			puVar11 = puVar10;
			do {
				bVar3 = *(byte *)((int)puVar11 + 1);
				uVar6 = (uint)bVar3;
				puVar10 = puVar11 + 1;
				puVar9 = puVar9 + *(byte *)puVar11;
				if ((bVar3 & 0x80) == 0) {
					if (bVar3 != 0) {
						do {
							bVar3 = *(byte *)puVar10;
							bVar2 = *(byte *)((int)puVar10 + 1);
							puVar10 = puVar10 + 1;
							uVar5 = getFlicCol(bVar3,fsp_00);
							*puVar9 = uVar5;
							uVar5 = getFlicCol(bVar2,fsp_00);
							puVar9[1] = uVar5;
							puVar9 = puVar9 + 2;
							uVar6 = uVar6 - 1;
						} while (uVar6 != 0);
					}
				}
				else {
					bVar3 = *(byte *)((int)puVar11 + 3);
					bVar2 = *(byte *)puVar10;
					puVar10 = puVar11 + 2;
					if ((short)(0x100 - uVar6) != 0) {
						uVar6 = 0x100 - uVar6 & 0xffff;
						do {
							uVar5 = getFlicCol(bVar2,fsp_00);
							*puVar9 = uVar5;
							uVar5 = getFlicCol(bVar3,fsp_00);
							puVar9[1] = uVar5;
							puVar9 = puVar9 + 2;
							uVar6 = uVar6 - 1;
						} while (uVar6 != 0);
					}
				}
				local_10 = local_10 - 1;
				puVar11 = puVar10;
				sVar7 = sVar8;
			} while (local_10 != 0);
		}
		if (uVar4 == 8) {
			uVar5 = getFlicCol(local_4,fsp_00);
			*puVar9 = uVar5;
		}
		sVar8 = sVar7 + -1;
		fsp = (ImageFlic *)((int)&fsp->userflags + 1);
		sVar7 = sVar8;
	}
	return;
}



// WARNING: Could not reconcile some variable overlaps

void __cdecl lego::image::FlicDeltaWordHiColorFlic32k(ImageFlic *fsp)
{
	void **ppvVar1;
	byte bVar2;
	ushort uVar3;
	bool bVar4;
	short sVar5;
	ImageFlic *pIVar6;
	ushort uVar7;
	uint uVar8;
	short sVar9;
	uint uVar10;
	ushort *puVar11;
	ushort *puVar12;
	ushort *puVar13;
	uint local_10;
	uint local_8;
	
	pIVar6 = fsp;
	ppvVar1 = &fsp->fsSource;
	fsp = (ImageFlic *)0x0;
	sVar9 = *(short *)((int)*ppvVar1 + 6);
	puVar11 = (ushort *)((int)*ppvVar1 + 8);
	sVar5 = sVar9;
	while( true ) {
		while( true ) {
			if (sVar9 == 0) {
				return;
			}
			uVar3 = *puVar11;
			uVar8 = (uint)uVar3;
			puVar13 = (ushort *)(((uint)fsp & 0xffff) * pIVar6->fsPitch + (int)pIVar6->fsSPtr);
			uVar7 = uVar3 >> 0xc & 0xc;
			if (uVar7 != 0xc) break;
			puVar11 = puVar11 + 1;
			fsp = (ImageFlic *)((int)fsp - uVar8);
		}
		if (uVar7 == 4) break;
		bVar4 = false;
		if (uVar7 == 8) {
			if (pIVar6->is15bit != 0) {
				uVar8 = uVar3 >> 1 & 0x7ff0 | uVar8 & 0x1f;
			}
			puVar11 = puVar11 + 1;
			bVar4 = true;
			local_8 = uVar8;
		}
		uVar3 = *puVar11;
		puVar11 = puVar11 + 1;
		if (uVar3 != 0) {
			local_10 = (uint)uVar3;
			puVar12 = puVar11;
			do {
				bVar2 = *(byte *)((int)puVar12 + 1);
				uVar8 = (uint)bVar2;
				puVar11 = puVar12 + 1;
				puVar13 = puVar13 + *(byte *)puVar12;
				if ((bVar2 & 0x80) == 0) {
					if (bVar2 != 0) {
						do {
							uVar3 = *puVar11;
							puVar11 = puVar11 + 1;
							uVar10 = (uVar3 & 0xffe0) << 1;
							if (pIVar6->is15bit == 0) {
								uVar7 = (ushort)uVar10;
							}
							else {
								uVar7 = (ushort)((uVar10 & 0xffff) >> 1);
							}
							*puVar13 = uVar7 | uVar3 & 0x1f;
							puVar13 = puVar13 + 1;
							uVar8 = uVar8 - 1;
						} while (uVar8 != 0);
					}
				}
				else {
					uVar3 = *puVar11;
					puVar11 = puVar12 + 2;
					uVar10 = (uVar3 & 0xffe0) << 1;
					if ((short)(0x100 - uVar8) != 0) {
						uVar8 = 0x100 - uVar8 & 0xffff;
						do {
							if (pIVar6->is15bit == 0) {
								uVar7 = (ushort)uVar10;
							}
							else {
								uVar7 = (ushort)((uVar10 & 0xffff) >> 1);
							}
							*puVar13 = uVar7 | uVar3 & 0x1f;
							puVar13 = puVar13 + 1;
							uVar8 = uVar8 - 1;
						} while (uVar8 != 0);
					}
				}
				local_10 = local_10 - 1;
				puVar12 = puVar11;
				sVar9 = sVar5;
			} while (local_10 != 0);
		}
		if (bVar4) {
			*(undefined *)puVar13 = (undefined)local_8;
		}
		fsp = (ImageFlic *)((int)&fsp->userflags + 1);
		sVar9 = sVar9 + -1;
		sVar5 = sVar9;
	}
	return;
}



BOOL __cdecl lego::image::Flic_DeltaWord(ImageFlic *fsp)
{
	ushort uVar1;
	
	uVar1 = (fsp->fsHeader).depth;
	if (uVar1 == 8) {
		if (fsp->fsDisplayMode == FLICMODE_BYTEPERPIXEL) {
										// FlicDeltaWordBytePerPixel(fsp) => return;
			util::logf_removed((char *)fsp);
		}
		if (fsp->fsDisplayMode == FLICMODE_HICOLOR) {
			FlicDeltaWordHiColor(fsp);
			return TRUE;
		}
	}
	else {
		if (uVar1 == 0x10) {
			uVar1 = (fsp->fsHeader).magic;
			if (uVar1 == 0x1234) {
										// FlicDeltaWordHiColorDZ(fsp) => return;
				util::logf_removed((char *)fsp);
				return TRUE;
			}
			if (uVar1 == 0xaf43) {
				FlicDeltaWordHiColorFlic32k(fsp);
				return TRUE;
			}
										// FlicDeltaWordHiColorFlic(fsp) => return;
			util::logf_removed((char *)fsp);
		}
	}
	return TRUE;
}



// MACRO: #define FHCOL(n)  getFlicCol(n,fsp)

ushort __cdecl lego::image::getFlicCol(byte n,ImageFlic *fsp)
{
	return fsp->fsPalette64k[n];
}



uint __cdecl lego::image::Flic_GetHeight(ImageFlic *fsp)
{
	return fsp->fsYsize;
}



TextWindow * __cdecl lego::front::TextWindow_Create(ImageFont *font,Rect2F *area,uint size)
{
	TextWindow *textWnd;
	void *pvVar1;
	int iVar2;
	TextWindow *pTVar3;
	
	textWnd = (TextWindow *)std::malloc(0x830);
	if (textWnd != (TextWindow *)0x0) {
		pTVar3 = textWnd;
		for (iVar2 = 0x20c; iVar2 != 0; iVar2 = iVar2 + -1) {
			pTVar3->font = (ImageFont *)0x0;
			pTVar3 = (TextWindow *)&pTVar3->windowSize;
		}
		textWnd->font = font;
		(textWnd->windowSize).x = area->x;
		(textWnd->windowSize).y = area->y;
		(textWnd->windowSize).width = area->width;
		(textWnd->windowSize).height = area->height;
		pvVar1 = std::malloc(size);
		textWnd->windowBuffer = pvVar1;
		textWnd->bufferSize = size;
		TextWindow_EnableCentering(textWnd,1);
	}
	return textWnd;
}



void __cdecl lego::front::TextWindow_EnableCentering(TextWindow *textWnd,BOOL enable)
{
	if (enable != 0) {
		textWnd->flags = textWnd->flags | 4;
		return;
	}
	textWnd->flags = textWnd->flags & 0xfffffffb;
	return;
}



void __cdecl lego::front::TextWindow_Remove(TextWindow *textWnd)
{
	std::free(textWnd->windowBuffer);
	std::free(textWnd);
	return;
}



void __cdecl lego::front::TextWindow_ChangePosition(TextWindow *textWnd,int xpos,int ypos)
{
	(textWnd->windowSize).x = (float)xpos;
	(textWnd->windowSize).y = (float)ypos;
	return;
}



void __cdecl lego::front::TextWindow_ChangeSize(TextWindow *textWnd,uint width,uint height)
{
	(textWnd->windowSize).width = (float)(ulonglong)width;
	(textWnd->windowSize).height = (float)(ulonglong)height;
	return;
}



void __cdecl lego::front::TextWindow_PagePrintF(TextWindow *textWnd,int page,char *format,...)
{
	TextWindow_VPrintF(textWnd,page,format,&stack0x00000010);
	return;
}



void __cdecl lego::front::TextWindow_PrintF(TextWindow *textWnd,char *format,...)
{
	TextWindow_VPrintF(textWnd,0,format,&stack0x0000000c);
	return;
}



void __cdecl
lego::front::TextWindow_VPrintF(TextWindow *textWnd,int page,char *format,va_list argptr)
{
	uint uVar1;
	uint uVar2;
	int iVar3;
	uint uVar4;
	char local_400 [1024];
	
	iVar3 = 0;
	uVar1 = std::vsprintf(local_400,format,argptr);
	uVar2 = 0;
	if (uVar1 != 0) {
		do {
			if (iVar3 == page) break;
			if (local_400[uVar2] == '\a') {
				iVar3 = iVar3 + 1;
			}
			uVar2 = uVar2 + 1;
		} while (uVar2 < uVar1);
	}
	if (uVar2 != uVar1) {
		for (; uVar2 < uVar1; uVar2 = uVar2 + 1) {
			*(char *)((int)textWnd->windowBuffer + textWnd->bufferEnd) = local_400[uVar2];
			uVar4 = textWnd->bufferEnd + 1;
			textWnd->bufferEnd = uVar4;
			if (uVar4 == textWnd->bufferSize) {
				textWnd->bufferEnd = 0;
				textWnd->flags = textWnd->flags | 1;
			}
		}
	}
	return;
}



void __cdecl
lego::front::TextWindow_PrintFOverlay(TextWindow *textWnd,BOOL oneFrame,char *format,...)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	undefined4 *puVar4;
	char *pcVar5;
	char *pcVar6;
	undefined4 *puVar7;
	char local_400 [1024];
	
	std::vsprintf(local_400,format,&stack0x00000010);
	uVar2 = 0xffffffff;
	pcVar5 = local_400;
	do {
		pcVar6 = pcVar5;
		if (uVar2 == 0) break;
		uVar2 = uVar2 - 1;
		pcVar6 = pcVar5 + 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar6;
	} while (cVar1 != '\0');
	uVar2 = ~uVar2;
	puVar4 = (undefined4 *)(pcVar6 + -uVar2);
	puVar7 = (undefined4 *)textWnd->secondBuffer;
	for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
		*puVar7 = *puVar4;
		puVar4 = puVar4 + 1;
		puVar7 = puVar7 + 1;
	}
	for (uVar2 = uVar2 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {
		*(undefined *)puVar7 = *(undefined *)puVar4;
		puVar4 = (undefined4 *)((int)puVar4 + 1);
		puVar7 = (undefined4 *)((int)puVar7 + 1);
	}
	if (oneFrame == 0) {
		textWnd->displayDelay = 25.0;
	}
	else {
		textWnd->displayDelay = 0.0;
	}
	textWnd->flags = textWnd->flags | 2;
	return;
}



BOOL __cdecl
lego::front::TextWindow_Update
					(TextWindow *textWnd,uint posFromEnd,float elapsed,int *out_lowestPoint)
{
	float fVar1;
	byte c;
	float fVar2;
	uint uVar3;
	uint uVar4;
	BOOL BVar5;
	uint *puVar6;
	uint uVar7;
	int iVar8;
	ulonglong uVar9;
	longlong lVar10;
	uint local_414;
	uint *local_410;
	uint *local_40c;
	uint auStack1028 [257];
	
	uVar7 = 0;
	local_414 = 0;
	local_410 = (uint *)0x0;
	if (out_lowestPoint != (int *)0x0) {
		*out_lowestPoint = 0;
	}
	uVar9 = __ftol((float10)(textWnd->windowSize).height);
	textWnd->linesCapacity = (int)((uVar9 & 0xffffffff) / (ulonglong)(uint)textWnd->font->field_be4);
	if ((textWnd->flags & 2) != 0) {
		BVar5 = TextWindow_UpdateOverlay(textWnd,elapsed,out_lowestPoint);
		return BVar5;
	}
	uVar4 = textWnd->bufferSize;
	if (((textWnd->flags & 1) != 0) &&
		 (local_40c = (uint *)textWnd->linesCount, local_40c != (uint *)0x0)) {
		puVar6 = textWnd->lines;
		do {
			uVar3 = *puVar6 - textWnd->bufferEnd;
			if ((0 < (int)uVar3) && ((int)uVar3 < (int)uVar4)) {
				uVar4 = uVar3;
				local_414 = *puVar6;
			}
			puVar6 = puVar6 + 1;
			local_40c = (uint *)((int)local_40c - 1);
		} while (local_40c != (uint *)0x0);
	}
	textWnd->linesCount = 0;
	textWnd->lines[0] = local_414;
	textWnd->linesCount = textWnd->linesCount + 1;
	if (local_414 != textWnd->bufferEnd) {
		do {
			c = *(byte *)(local_414 + (int)textWnd->windowBuffer);
			if (c == '\a') break;
			if (c == '\n') {
				textWnd->lines[textWnd->linesCount] = local_414 + 1;
				uVar4 = textWnd->linesCount;
				auStack1028[uVar4] = uVar7;
				textWnd->linesCount = uVar4 + 1;
				local_410 = (uint *)0x0;
				uVar7 = 0;
			}
			else {
										// int std::isspace(int c)
				if (std::globals::_pcharwidth < 2) {
					uVar4 = *(byte *)(std::globals::_pctype + c) & C1_SPACE;
				}
				else {
					uVar4 = std::_isctype((uint)c,C1_SPACE);
				}
				if (uVar4 != 0) {
					local_410 = (uint *)0x0;
					textWnd->lines[textWnd->linesCount] = local_414 + 1;
					auStack1028[textWnd->linesCount] = uVar7;
				}
				uVar4 = image::Font_GetCharWidth(textWnd->font,c);
				local_410 = (uint *)((int)local_410 + uVar4);
				fVar2 = (float)(uVar7 + uVar4);
				fVar1 = (textWnd->windowSize).width;
				uVar7 = uVar7 + uVar4;
				if ((ushort)((ushort)(fVar2 < fVar1) << 8 | (ushort)(fVar2 == fVar1) << 0xe) == 0) {
					textWnd->linesCount = textWnd->linesCount + 1;
					uVar7 = (uint)local_410;
				}
			}
			local_414 = local_414 + 1;
			if (textWnd->bufferSize <= local_414) {
				local_414 = 0;
			}
		} while (local_414 != textWnd->bufferEnd);
	}
	textWnd->lines[textWnd->linesCount] = local_414;
	uVar4 = textWnd->linesCount;
	iVar8 = textWnd->linesCapacity;
	auStack1028[uVar4] = uVar7;
	uVar7 = (uVar4 - iVar8) + 1;
	uVar3 = 0;
	if (uVar7 == 0) {
		posFromEnd = 0;
	}
	else {
		posFromEnd = posFromEnd % uVar7;
	}
	if (uVar4 != 0) {
		local_40c = auStack1028;
		local_410 = textWnd->lines;
		do {
			local_40c = local_40c + 1;
			local_410 = local_410 + 1;
			lVar10 = __ftol((float10)(textWnd->windowSize).x);
			local_414 = (uint)lVar10;
			if ((*(byte *)&textWnd->flags & 4) != 0) {
				auStack1028[0] = 0;
				lVar10 = __ftol(((float10)(textWnd->windowSize).width - (float10)(ulonglong)*local_40c) *
												(float10)0.5);
				local_414 = local_414 + (int)lVar10;
			}
			uVar7 = textWnd->linesCapacity;
			if (uVar7 < uVar4) {
				if ((uVar3 < (uVar4 - posFromEnd) - uVar7) || (uVar4 - posFromEnd <= uVar3)) {
					if (uVar4 <= uVar7) goto LAB_004858e9;
					iVar8 = 0;
				}
				else {
					iVar8 = textWnd->font->field_be4;
					lVar10 = __ftol((float10)(textWnd->windowSize).y);
					iVar8 = ((posFromEnd + uVar3 + uVar7) - uVar4) * iVar8 + (int)lVar10;
				}
			}
			else {
LAB_004858e9:
				iVar8 = textWnd->font->field_be4;
				lVar10 = __ftol((float10)(textWnd->windowSize).y);
				iVar8 = iVar8 * uVar3 + (int)lVar10;
			}
			if ((out_lowestPoint != (int *)0x0) && (*out_lowestPoint < iVar8)) {
				*out_lowestPoint = iVar8;
			}
			if ((iVar8 != 0) && (uVar7 = local_410[-1], uVar7 != *local_410)) {
				do {
					uVar4 = image::Font_OutputChar
														(textWnd->font,local_414,iVar8,
														 *(char *)(uVar7 + (int)textWnd->windowBuffer),1);
					local_414 = local_414 + uVar4;
					uVar7 = uVar7 + 1;
					if (uVar7 == textWnd->bufferSize + 1) {
						uVar7 = 0;
					}
				} while (uVar7 != *local_410);
			}
			uVar4 = textWnd->linesCount;
			uVar3 = uVar3 + 1;
		} while (uVar3 < uVar4);
	}
	if (out_lowestPoint != (int *)0x0) {
		*out_lowestPoint = *out_lowestPoint + textWnd->font->field_be4;
	}
	return 0;
}



BOOL __cdecl
lego::front::TextWindow_UpdateOverlay(TextWindow *textWnd,float elapsed,int *out_lowestPoint)
{
	float fVar1;
	float fVar2;
	byte c;
	uint uVar3;
	int iVar4;
	int iVar5;
	undefined *puVar6;
	int iVar7;
	longlong lVar8;
	int *local_820;
	uint local_81c;
	int local_818;
	uint local_810;
	int *local_80c;
	BOOL local_804;
	int local_800 [255];
	int aiStack1028 [2];
	undefined local_3fc [1020];
	
	iVar4 = 0;
	iVar7 = 0;
	iVar5 = 0;
	c = textWnd->secondBuffer[0];
	local_810 = 0;
	local_804 = 0;
	local_800[0] = 0;
	local_81c = 1;
	if (c != 0) {
		local_80c = local_800 + 1;
		local_820 = (int *)0x1;
		puVar6 = local_3fc;
		do {
			if (c == 10) {
				*(int *)(puVar6 + -4) = iVar7;
				local_81c = local_81c + 1;
				*local_80c = (int)local_820;
				local_80c = local_80c + 1;
				puVar6 = puVar6 + 4;
				iVar5 = 0;
				iVar7 = 0;
			}
			else {
										// int std::isspace(int c)
				if (std::globals::_pcharwidth < 2) {
					uVar3 = *(byte *)(std::globals::_pctype + c) & C1_SPACE;
				}
				else {
					uVar3 = std::_isctype((uint)c,C1_SPACE);
				}
				if (uVar3 != 0) {
					*(int *)(puVar6 + -4) = iVar7;
					iVar5 = 0;
					*local_80c = (int)local_820;
				}
				uVar3 = image::Font_GetCharWidth(textWnd->font,c);
				iVar5 = iVar5 + uVar3;
				fVar2 = (float)(iVar7 + uVar3);
				fVar1 = (textWnd->windowSize).width;
				iVar7 = iVar7 + uVar3;
				if ((ushort)((ushort)(fVar2 < fVar1) << 8 | (ushort)(fVar2 == fVar1) << 0xe) == 0) {
					local_81c = local_81c + 1;
					puVar6 = puVar6 + 4;
					local_80c = local_80c + 1;
					iVar7 = iVar5;
				}
			}
			iVar4 = local_810 + 1;
			local_820 = (int *)((int)local_820 + 1);
			c = textWnd->secondBuffer[local_810 + 1];
			local_810 = iVar4;
		} while (c != 0);
	}
	aiStack1028[local_81c] = iVar7;
	local_800[local_81c] = iVar4;
	local_810 = 0;
	if (local_81c != 0) {
		local_820 = local_800;
		do {
			local_820 = local_820 + 1;
			lVar8 = __ftol((float10)(textWnd->windowSize).x);
			local_818 = (int)lVar8;
			if ((*(byte *)&textWnd->flags & 4) != 0) {
				lVar8 = __ftol(((float10)(textWnd->windowSize).width -
											 (float10)(ulonglong)*(uint *)(local_3fc + local_810 * 4 + -4)) * (float10)0.5
											);
				local_818 = local_818 + (int)lVar8;
			}
			uVar3 = textWnd->linesCapacity;
			if (uVar3 < local_81c) {
				if ((local_810 < local_81c - uVar3) || (local_81c <= local_810)) {
					if (local_81c <= uVar3) goto LAB_00485b9f;
					iVar7 = 0;
				}
				else {
					iVar7 = textWnd->font->field_be4;
					lVar8 = __ftol((float10)(textWnd->windowSize).y);
					iVar7 = ((local_810 - local_81c) + uVar3) * iVar7 + (int)lVar8;
					local_804 = 1;
				}
			}
			else {
LAB_00485b9f:
				iVar7 = textWnd->font->field_be4;
				lVar8 = __ftol((float10)(textWnd->windowSize).y);
				iVar7 = iVar7 * local_810 + (int)lVar8;
			}
			if ((out_lowestPoint != (int *)0x0) && (*out_lowestPoint < iVar7)) {
				*out_lowestPoint = iVar7;
			}
			if (iVar7 != 0) {
				iVar5 = *local_820;
				for (iVar4 = local_800[local_810]; iVar4 != iVar5; iVar4 = iVar4 + 1) {
					uVar3 = image::Font_OutputChar
														(textWnd->font,local_818,iVar7,textWnd->secondBuffer[iVar4],1);
					local_818 = local_818 + uVar3;
				}
			}
			local_810 = local_810 + 1;
		} while (local_810 < local_81c);
	}
	fVar1 = textWnd->displayDelay - elapsed;
	textWnd->displayDelay = fVar1;
	if (fVar1 < 0.0) {
		textWnd->flags = textWnd->flags & 0xfffffffd;
	}
	return local_804;
}



void __cdecl lego::front::TextWindow_Clear(TextWindow *textWnd)
{
	uint uVar1;
	uint uVar2;
	int iVar3;
	undefined4 *puVar4;
	
	uVar2 = textWnd->bufferSize;
	puVar4 = (undefined4 *)textWnd->windowBuffer;
	for (uVar1 = uVar2 >> 2; uVar1 != 0; uVar1 = uVar1 - 1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	for (uVar2 = uVar2 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {
		*(undefined *)puVar4 = 0;
		puVar4 = (undefined4 *)((int)puVar4 + 1);
	}
	puVar4 = (undefined4 *)textWnd->secondBuffer;
	for (iVar3 = 0x100; iVar3 != 0; iVar3 = iVar3 + -1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	textWnd->linesCount = 0;
	textWnd->bufferEnd = 0;
	textWnd->flags = textWnd->flags & 0xfffffffe;
	return;
}



void __cdecl
lego::front::TextWindow_GetInfo(TextWindow *textWnd,uint *out_linesCount,uint *out_linesCapacity)
{
	*out_linesCount = textWnd->linesCount;
	*out_linesCapacity = textWnd->linesCapacity;
	return;
}



void __cdecl lego::input::Keys_Initialise(void)
{
	int iVar1;
	Key_Globs *pKVar2;
	
	pKVar2 = &globs::keyGlobs;
	for (iVar1 = 0x100; iVar1 != 0; iVar1 = iVar1 + -1) {
		pKVar2->keyName[0] = (char *)0x0;
		pKVar2 = (Key_Globs *)(pKVar2->keyName + 1);
	}
	globs::keyGlobs.keyName[1] = "KEY_ESCAPE";
	globs::keyGlobs.keyName[2] = "KEY_ONE";
	globs::keyGlobs.keyName[3] = "KEY_TWO";
	globs::keyGlobs.keyName[4] = "KEY_THREE";
	globs::keyGlobs.keyName[5] = "KEY_FOUR";
	globs::keyGlobs.keyName[6] = "KEY_FIVE";
	globs::keyGlobs.keyName[7] = "KEY_SIX";
	globs::keyGlobs.keyName[8] = "KEY_SEVEN";
	globs::keyGlobs.keyName[9] = "KEY_EIGHT";
	globs::keyGlobs.keyName[10] = "KEY_NINE";
	globs::keyGlobs.keyName[11] = "KEY_ZERO";
	globs::keyGlobs.keyName[12] = "KEY_MINUS";
	globs::keyGlobs.keyName[13] = "KEY_EQUALS";
	globs::keyGlobs.keyName[14] = "KEY_BACKSPACE";
	globs::keyGlobs.keyName[15] = "KEY_TAB";
	globs::keyGlobs.keyName[16] = "KEY_Q";
	globs::keyGlobs.keyName[17] = "KEY_W";
	globs::keyGlobs.keyName[18] = "KEY_E";
	globs::keyGlobs.keyName[19] = "KEY_R";
	globs::keyGlobs.keyName[20] = "KEY_T";
	globs::keyGlobs.keyName[21] = "KEY_Y";
	globs::keyGlobs.keyName[22] = "KEY_U";
	globs::keyGlobs.keyName[23] = "KEY_I";
	globs::keyGlobs.keyName[24] = "KEY_O";
	globs::keyGlobs.keyName[25] = "KEY_P";
	globs::keyGlobs.keyName[26] = "KEY_LEFTBRACE";
	globs::keyGlobs.keyName[27] = "KEY_RIGHTBRACE";
	globs::keyGlobs.keyName[28] = "KEY_RETURN";
	globs::keyGlobs.keyName[29] = "KEY_LEFTCTRL";
	globs::keyGlobs.keyName[30] = "KEY_A";
	globs::keyGlobs.keyName[31] = "KEY_S";
	globs::keyGlobs.keyName[32] = "KEY_D";
	globs::keyGlobs.keyName[33] = "KEY_F";
	globs::keyGlobs.keyName[34] = "KEY_G";
	globs::keyGlobs.keyName[35] = "KEY_H";
	globs::keyGlobs.keyName[36] = "KEY_J";
	globs::keyGlobs.keyName[37] = "KEY_K";
	globs::keyGlobs.keyName[38] = "KEY_L";
	globs::keyGlobs.keyName[39] = "KEY_SEMICOLON";
	globs::keyGlobs.keyName[40] = "KEY_AT";
	globs::keyGlobs.keyName[41] = "KEY_RSINGLEQUOTE";
	globs::keyGlobs.keyName[42] = "KEY_LEFTSHIFT";
	globs::keyGlobs.keyName[43] = "KEY_HASH";
	globs::keyGlobs.keyName[44] = "KEY_Z";
	globs::keyGlobs.keyName[45] = "KEY_X";
	globs::keyGlobs.keyName[46] = "KEY_C";
	globs::keyGlobs.keyName[47] = "KEY_V";
	globs::keyGlobs.keyName[48] = "KEY_B";
	globs::keyGlobs.keyName[49] = "KEY_N";
	globs::keyGlobs.keyName[50] = "KEY_M";
	globs::keyGlobs.keyName[51] = "KEY_LEFTARROW";
	globs::keyGlobs.keyName[52] = "KEY_RIGHTARROW";
	globs::keyGlobs.keyName[53] = "KEY_QUESTIONMARK";
	globs::keyGlobs.keyName[54] = "KEY_RIGHTSHIFT";
	globs::keyGlobs.keyName[55] = "KEYPAD_ASTERISK";
	globs::keyGlobs.keyName[56] = "KEY_ALT";
	globs::keyGlobs.keyName[57] = "KEY_SPACE";
	globs::keyGlobs.keyName[58] = "KEY_CAPLOCK";
	globs::keyGlobs.keyName[59] = "KEY_F1";
	globs::keyGlobs.keyName[60] = "KEY_F2";
	globs::keyGlobs.keyName[61] = "KEY_F3";
	globs::keyGlobs.keyName[62] = "KEY_F4";
	globs::keyGlobs.keyName[63] = "KEY_F5";
	globs::keyGlobs.keyName[64] = "KEY_F6";
	globs::keyGlobs.keyName[65] = "KEY_F7";
	globs::keyGlobs.keyName[66] = "KEY_F8";
	globs::keyGlobs.keyName[67] = "KEY_F9";
	globs::keyGlobs.keyName[68] = "KEY_F10";
	globs::keyGlobs.keyName[69] = "KEYPAD_NUMLOCK";
	globs::keyGlobs.keyName[70] = "KEY_SCROLLLOCK";
	globs::keyGlobs.keyName[71] = "KEYPAD_7";
	globs::keyGlobs.keyName[72] = "KEYPAD_8";
	globs::keyGlobs.keyName[73] = "KEYPAD_9";
	globs::keyGlobs.keyName[74] = "KEYPAD_MINUS";
	globs::keyGlobs.keyName[75] = "KEYPAD_4";
	globs::keyGlobs.keyName[76] = "KEYPAD_5";
	globs::keyGlobs.keyName[77] = "KEYPAD_6";
	globs::keyGlobs.keyName[78] = "KEYPAD_PLUS";
	globs::keyGlobs.keyName[79] = "KEYPAD_1";
	globs::keyGlobs.keyName[80] = "KEYPAD_2";
	globs::keyGlobs.keyName[81] = "KEYPAD_3";
	globs::keyGlobs.keyName[82] = "KEYPAD_0";
	globs::keyGlobs.keyName[83] = "KEYPAD_DELETE";
	globs::keyGlobs.keyName[86] = "KEY_BACKSLASH";
	globs::keyGlobs.keyName[87] = "KEY_F11";
	globs::keyGlobs.keyName[88] = "KEY_F12";
	globs::keyGlobs.keyName[156] = "KEYPAD_ENTER";
	globs::keyGlobs.keyName[157] = "KEY_RIGHTCTRL";
	globs::keyGlobs.keyName[181] = "KEYPAD_FORWARDSLASH";
	globs::keyGlobs.keyName[183] = "KEY_PRINTSCREEN";
	globs::keyGlobs.keyName[184] = "KEY_ALTGR";
	globs::keyGlobs.keyName[199] = "KEY_HOME";
	globs::keyGlobs.keyName[200] = "KEY_CURSORUP";
	globs::keyGlobs.keyName[201] = "KEY_PGUP";
	globs::keyGlobs.keyName[203] = "KEY_CURSORLEFT";
	globs::keyGlobs.keyName[205] = "KEY_CURSORRIGHT";
	globs::keyGlobs.keyName[207] = "KEY_END";
	globs::keyGlobs.keyName[208] = "KEY_CURSORDOWN";
	globs::keyGlobs.keyName[209] = "KEY_PGDN";
	globs::keyGlobs.keyName[210] = "KEY_INSERT";
	globs::keyGlobs.keyName[211] = "KEY_DELETE";
	return;
}



BOOL __cdecl lego::input::Key_Find(char *name,KeysByte *out_keyCode)
{
	char *_Str1;
	int iVar1;
	KeysByte KVar2;
	Key_Globs *pKVar3;
	
	KVar2 = KEY__NONE;
	pKVar3 = &globs::keyGlobs;
	do {
		_Str1 = *(char **)((FileCheck_Globs *)pKVar3)->loadedList;
		if (_Str1 != (char *)0x0) {
			iVar1 = std::_stricmp(_Str1,name);
			if (iVar1 == 0) {
				*out_keyCode = KVar2;
				return 1;
			}
		}
		pKVar3 = (Key_Globs *)(((FileCheck_Globs *)pKVar3)->loadedList + 4);
		KVar2 = KVar2 + KEY_ESCAPE;
	} while (pKVar3 < &globs::checkGlobs);
	return 0;
}



void __cdecl lego::draw::Draw_Initialise(Rect2F *window)
{
	globs::drawGlobs.flags = globs::drawGlobs.flags | 1;
	Draw_SetClipWindow(window);
	return;
}



void __cdecl lego::draw::Draw_SetClipWindow(Rect2F *window)
{
	float fVar1;
	HRESULT HVar2;
	int iVar3;
	DDSURFACEDESC2 *pDVar4;
	DDSURFACEDESC2 desc;
	
	globs::drawGlobs.clipStart.x = 0.0;
	globs::drawGlobs.clipStart.y = 0.0;
	if (window != (Rect2F *)0x0) {
		if ((ushort)((ushort)(window->x < 0.0) << 8 | (ushort)(window->x == 0.0) << 0xe) == 0) {
			globs::drawGlobs.clipStart.x = window->x;
		}
		if ((ushort)((ushort)(window->y < 0.0) << 8 | (ushort)(window->y == 0.0) << 0xe) == 0) {
			globs::drawGlobs.clipStart.y = window->y;
		}
	}
	pDVar4 = &desc;
	for (iVar3 = 0x1f; iVar3 != 0; iVar3 = iVar3 + -1) {
		pDVar4->dwSize = 0;
		pDVar4 = (DDSURFACEDESC2 *)&pDVar4->dwFlags;
	}
	desc.dwSize = 0x7c;
	HVar2 = (*(code *)(globs::directDrawGlobs.bSurf)->lpVtbl->GetSurfaceDesc)
										(globs::directDrawGlobs.bSurf,&desc);
	if (HVar2 == 0) {
		globs::drawGlobs.clipEnd.x = (float)(ulonglong)desc.dwWidth;
		globs::drawGlobs.clipEnd.y = (float)(ulonglong)desc.dwHeight;
		if (window != (Rect2F *)0x0) {
			fVar1 = window->width + window->x;
			if (fVar1 < globs::drawGlobs.clipEnd.x) {
				globs::drawGlobs.clipEnd.x = fVar1;
			}
			fVar1 = window->height + window->y;
			if (fVar1 < globs::drawGlobs.clipEnd.y) {
				globs::drawGlobs.clipEnd.y = fVar1;
				return;
			}
		}
	}
	return;
}



void __cdecl lego::draw::Draw_GetClipWindow(Rect2F *out_window)
{
	out_window->x = globs::drawGlobs.clipStart.x;
	out_window->y = globs::drawGlobs.clipStart.y;
	out_window->width = globs::drawGlobs.clipEnd.x - globs::drawGlobs.clipStart.x;
	out_window->height = globs::drawGlobs.clipEnd.y - globs::drawGlobs.clipStart.y;
	return;
}



void __cdecl
lego::draw::Draw_LineListEx
					(Point2F *fromList,Point2F *toList,uint count,float r,float g,float b,DrawEffect effect)
{
	IDirectDrawSurface4 *surface;
	BOOL BVar1;
	uint uVar2;
	int y2;
	int x2;
	int y1;
	Point2F *pPVar3;
	float *pfVar4;
	longlong lVar5;
	uint colour;
	
	surface = globs::directDrawGlobs.bSurf;
	BVar1 = Draw_LockSurface(globs::directDrawGlobs.bSurf,effect);
	if (BVar1 != 0) {
		uVar2 = Draw_GetColour(r,g,b);
		if (count != 0) {
			pfVar4 = &fromList->y;
			pPVar3 = (Point2F *)((int)toList - (int)fromList);
			do {
				colour = uVar2;
				lVar5 = __ftol((float10)*(float *)((int)&pPVar3->x + (int)pfVar4));
				y2 = (int)lVar5;
				lVar5 = __ftol((float10)toList->x);
				x2 = (int)lVar5;
				lVar5 = __ftol((float10)*pfVar4);
				y1 = (int)lVar5;
				lVar5 = __ftol((float10)pfVar4[-1]);
				Draw_LineActual((int)lVar5,y1,x2,y2,colour);
				pfVar4 = pfVar4 + 2;
				toList = toList + 1;
				count = count - 1;
			} while (count != 0);
		}
		Draw_UnlockSurface(surface);
	}
	return;
}



void __cdecl
lego::draw::Draw_RectListEx(Rect2F *rectList,uint count,float r,float g,float b,DrawEffect effect)
{
	int iVar1;
	IDirectDrawSurface4 *surface;
	BOOL BVar2;
	uint uVar3;
	int iVar4;
	float10 extraout_ST0;
	longlong lVar5;
	longlong lVar6;
	longlong lVar7;
	float local_18;
	float local_10;
	float local_c;
	
	surface = globs::directDrawGlobs.bSurf;
	BVar2 = Draw_LockSurface(globs::directDrawGlobs.bSurf,effect);
	if (BVar2 != 0) {
		uVar3 = Draw_GetColour(r,g,b);
		if (count != 0) {
			effect = (DrawEffect)rectList;
			b = (float)count;
			do {
				local_10 = *(float *)effect;
				local_c = *(float *)(effect + 4);
				local_18 = local_10 + *(float *)(effect + 8);
				if (local_10 < globs::drawGlobs.clipStart.x) {
					local_10 = globs::drawGlobs.clipStart.x;
				}
				if (local_c < globs::drawGlobs.clipStart.y) {
					local_c = globs::drawGlobs.clipStart.y;
				}
				if (globs::drawGlobs.clipEnd.x <= local_18) {
					local_18 = globs::drawGlobs.clipEnd.x - 1.0;
				}
				lVar5 = __ftol((float10)local_18);
				lVar6 = __ftol(extraout_ST0);
				lVar7 = __ftol((float10)local_c);
				iVar4 = (int)lVar7;
				if (iVar4 < (int)lVar6) {
					lVar7 = __ftol((float10)local_10);
					iVar1 = (int)lVar7;
					do {
						for (; iVar1 < (int)lVar5; iVar1 = iVar1 + 1) {
							(*globs::drawGlobs.drawPixelFunc)(iVar1,iVar4,uVar3);
						}
						iVar4 = iVar4 + 1;
						iVar1 = (int)lVar7;
					} while (iVar4 < (int)lVar6);
				}
				effect = effect + 0x10;
				b = (float)((int)b + -1);
			} while (b != 0.0);
		}
		Draw_UnlockSurface(surface);
	}
	return;
}



void __cdecl lego::draw::Draw_RectList2Ex(Draw_Rect *rectList,uint count,DrawEffect effect)
{
	int iVar1;
	IDirectDrawSurface4 *surface;
	BOOL BVar2;
	uint uVar3;
	float *pfVar4;
	int iVar5;
	float10 extraout_ST0;
	longlong lVar6;
	longlong lVar7;
	longlong lVar8;
	float local_18;
	float local_10;
	float local_c;
	
	surface = globs::directDrawGlobs.bSurf;
	BVar2 = Draw_LockSurface(globs::directDrawGlobs.bSurf,effect);
	if (BVar2 != 0) {
		if (count != 0) {
			pfVar4 = &rectList->g;
			rectList = (Draw_Rect *)count;
			do {
				local_10 = pfVar4[-5];
				local_c = pfVar4[-4];
				local_18 = pfVar4[-3];
				uVar3 = Draw_GetColour(pfVar4[-1],*pfVar4,pfVar4[1]);
				local_18 = local_10 + local_18;
				if (local_10 < globs::drawGlobs.clipStart.x) {
					local_10 = globs::drawGlobs.clipStart.x;
				}
				if (local_c < globs::drawGlobs.clipStart.y) {
					local_c = globs::drawGlobs.clipStart.y;
				}
				if (globs::drawGlobs.clipEnd.x <= local_18) {
					local_18 = globs::drawGlobs.clipEnd.x - 1.0;
				}
				lVar6 = __ftol((float10)local_18);
				lVar7 = __ftol(extraout_ST0);
				lVar8 = __ftol((float10)local_c);
				iVar5 = (int)lVar8;
				if (iVar5 < (int)lVar7) {
					lVar8 = __ftol((float10)local_10);
					iVar1 = (int)lVar8;
					do {
						for (; iVar1 < (int)lVar6; iVar1 = iVar1 + 1) {
							(*globs::drawGlobs.drawPixelFunc)(iVar1,iVar5,uVar3);
						}
						iVar5 = iVar5 + 1;
						iVar1 = (int)lVar8;
					} while (iVar5 < (int)lVar7);
				}
				pfVar4 = pfVar4 + 7;
				rectList = (Draw_Rect *)((int)&rectList[-1].b + 3);
			} while (rectList != (Draw_Rect *)0x0);
		}
		Draw_UnlockSurface(surface);
	}
	return;
}



float10 __cdecl
lego::draw::Draw_DotCircle
					(Point2F *pos,uint radius,uint dots,float r,float g,float b,DrawEffect effect)
{
	IDirectDrawSurface4 *surface;
	BOOL BVar1;
	uint uVar2;
	uint uVar3;
	float10 extraout_ST0;
	float10 fVar4;
	unkbyte10 extraout_ST0_00;
	float10 extraout_ST0_01;
	ulonglong uVar5;
	ulonglong uVar6;
	
	surface = globs::directDrawGlobs.bSurf;
	BVar1 = Draw_LockSurface(globs::directDrawGlobs.bSurf,effect);
	fVar4 = extraout_ST0;
	if (BVar1 != 0) {
		uVar2 = Draw_GetColour(r,g,b);
		uVar3 = 0;
		if (dots != 0) {
			do {
				fVar4 = (float10)fsin((float10)(ulonglong)uVar3 *
															(float10)(6.283185 / (float)(ulonglong)dots));
				uVar5 = __ftol(fVar4 * (float10)(ulonglong)radius + (float10)pos->x);
				fVar4 = (float10)fcos(extraout_ST0_00);
				uVar6 = __ftol(fVar4 * (float10)(ulonglong)radius + (float10)pos->y);
				if ((((globs::drawGlobs.clipStart.x <= (float)(uVar5 & 0xffffffff)) &&
						 (globs::drawGlobs.clipStart.y <= (float)(uVar6 & 0xffffffff))) &&
						((float)(uVar5 & 0xffffffff) < globs::drawGlobs.clipEnd.x)) &&
					 ((float)(uVar6 & 0xffffffff) < globs::drawGlobs.clipEnd.y)) {
					(*globs::drawGlobs.drawPixelFunc)((int)uVar5,(int)uVar6,uVar2);
				}
				uVar3 = uVar3 + 1;
			} while (uVar3 < dots);
		}
		Draw_UnlockSurface(surface);
		fVar4 = extraout_ST0_01;
	}
	return fVar4;
}



uint __cdecl lego::draw::Draw_GetColour(float r,float g,float b)
{
	char cVar1;
	char cVar2;
	byte bVar3;
	uint uVar4;
	longlong lVar5;
	longlong lVar6;
	longlong lVar7;
	
	uVar4 = 0;
	if (globs::drawGlobs.bpp != 8) {
		lVar5 = __ftol((float10)r * (float10)255.0);
		cVar1 = (char)globs::drawGlobs.redBits;
		cVar2 = (char)globs::drawGlobs.greenBits;
		bVar3 = (byte)globs::drawGlobs.blueBits;
		lVar6 = __ftol((float10)g * (float10)255.0);
		lVar7 = __ftol((float10)b * (float10)255.0);
		uVar4 = ((uint)lVar5 >> (8U - cVar1 & 0x1f)) << (cVar2 + bVar3 & 0x1f) |
						((uint)lVar6 >> (8U - cVar2 & 0x1f)) << (bVar3 & 0x1f) |
						(uint)lVar7 >> (8 - bVar3 & 0x1f);
	}
	return uVar4;
}



BOOL __cdecl lego::draw::Draw_LockSurface(IDirectDrawSurface4 *surface,DrawEffect effect)
{
	HRESULT HVar1;
	uint uVar2;
	BOOL BVar3;
	int iVar4;
	uint uVar5;
	DDSURFACEDESC2 *pDVar6;
	DDSURFACEDESC2 desc;
	
	pDVar6 = &desc;
	for (iVar4 = 0x1f; iVar4 != 0; iVar4 = iVar4 + -1) {
		pDVar6->dwSize = 0;
		pDVar6 = (DDSURFACEDESC2 *)&pDVar6->dwFlags;
	}
	desc.dwSize = 0x7c;
	HVar1 = (*surface->lpVtbl->Lock)(surface,(LPRECT)0x0,&desc,1,(HANDLE)0x0);
	if (HVar1 == 0) {
		globs::drawGlobs.buffer = desc.lpSurface;
		uVar5 = 0;
		globs::drawGlobs.pitch = desc.lPitch;
		globs::drawGlobs.redMask = desc.ddpfPixelFormat.dwRBitMask;
		globs::drawGlobs.greenMask = desc.ddpfPixelFormat.dwGBitMask;
		globs::drawGlobs.blueMask = desc.ddpfPixelFormat.dwBBitMask;
		globs::drawGlobs.bpp = desc.ddpfPixelFormat.dwRGBBitCount;
		globs::drawGlobs.blueBits = 0;
		globs::drawGlobs.greenBits = 0;
		globs::drawGlobs.redBits = 0;
		if (desc.ddpfPixelFormat.dwRGBBitCount != 0) {
			do {
				uVar2 = 1 << ((byte)uVar5 & 0x1f);
				if ((uVar2 & desc.ddpfPixelFormat.dwRBitMask) != 0) {
					globs::drawGlobs.redBits = globs::drawGlobs.redBits + 1;
				}
				if ((uVar2 & desc.ddpfPixelFormat.dwGBitMask) != 0) {
					globs::drawGlobs.greenBits = globs::drawGlobs.greenBits + 1;
				}
				if ((uVar2 & desc.ddpfPixelFormat.dwBBitMask) != 0) {
					globs::drawGlobs.blueBits = globs::drawGlobs.blueBits + 1;
				}
				uVar5 = uVar5 + 1;
			} while (uVar5 < desc.ddpfPixelFormat.dwRGBBitCount);
		}
		BVar3 = Draw_SetDrawPixelFunc(effect);
		if (BVar3 != 0) {
			return TRUE;
		}
		Draw_UnlockSurface(surface);
	}
	return 0;
}



void __cdecl lego::draw::Draw_UnlockSurface(IDirectDrawSurface4 *surface)
{
	(*surface->lpVtbl->Unlock)(surface,(LPRECT)0x0);
	globs::drawGlobs.drawPixelFunc = (DrawPixelFunction *)0x0;
	globs::drawGlobs.buffer = (void *)0x0;
	globs::drawGlobs.pitch = 0;
	globs::drawGlobs.bpp = 0;
	globs::drawGlobs.redMask = 0;
	globs::drawGlobs.greenMask = 0;
	globs::drawGlobs.blueMask = 0;
	return;
}



BOOL __cdecl lego::draw::Draw_SetDrawPixelFunc(DrawEffect effect)
{
	if (globs::drawGlobs.bpp == 8) {
		globs::drawGlobs.drawPixelFunc = Draw_Pixel8;
		return DrawEffect_XOR;
	}
	if (globs::drawGlobs.bpp != 0x10) {
		if (globs::drawGlobs.bpp == 0x18) {
			globs::drawGlobs.drawPixelFunc = Draw_Pixel24;
			return DrawEffect_XOR;
		}
		if (globs::drawGlobs.bpp == 0x20) {
			globs::drawGlobs.drawPixelFunc = Draw_Pixel32;
			return DrawEffect_XOR;
		}
		globs::drawGlobs.drawPixelFunc = (DrawPixelFunction *)0x0;
		return DrawEffect_None;
	}
	if (effect == DrawEffect_XOR) {
		globs::drawGlobs.drawPixelFunc = Draw_Pixel16XOR;
		return effect;
	}
	if (effect == DrawEffect_HalfTrans) {
		globs::drawGlobs.drawPixelFunc = Draw_Pixel16HalfTrans;
		return DrawEffect_XOR;
	}
	globs::drawGlobs.drawPixelFunc = Draw_Pixel16;
	return DrawEffect_XOR;
}



void __cdecl lego::draw::Draw_LineActual(int x1,int y1,int x2,int y2,uint colour)
{
	bool bVar1;
	uint uVar2;
	int iVar3;
	int iVar4;
	int iVar5;
	int iVar6;
	int iVar7;
	uint uVar8;
	int iVar9;
	uint local_10;
	int local_4;
	
	iVar4 = y1;
	iVar3 = x1;
	uVar8 = x2 - x1 >> 0x1f;
	iVar7 = (x2 - x1 ^ uVar8) - uVar8;
	uVar8 = y2 - y1 >> 0x1f;
	iVar5 = (y2 - y1 ^ uVar8) - uVar8;
	bVar1 = iVar7 < iVar5;
	if (bVar1) {
		iVar6 = iVar7 - iVar5;
		iVar9 = iVar7 * 2 - iVar5;
		local_4 = iVar5;
	}
	else {
		iVar6 = iVar5 - iVar7;
		iVar9 = iVar5 * 2 - iVar7;
		local_4 = iVar7;
		iVar7 = iVar5;
	}
	local_10 = 1;
	y1 = 1;
	x1 = ZEXT14(!bVar1);
	local_4 = local_4 + 1;
	uVar8 = (uint)bVar1;
	if (x2 < iVar3) {
		y1 = -1;
		x1 = -x1;
	}
	if (y2 < iVar4) {
		uVar8 = -uVar8;
		local_10 = 0xffffffff;
	}
	x2 = iVar3;
	y2 = iVar4;
	if (0 < local_4) {
		do {
			if ((((globs::drawGlobs.clipStart.x <= (float)x2) &&
					 (globs::drawGlobs.clipStart.y <= (float)y2)) && ((float)x2 < globs::drawGlobs.clipEnd.x))
				 && ((float)y2 < globs::drawGlobs.clipEnd.y)) {
				(*globs::drawGlobs.drawPixelFunc)(x2,y2,colour);
			}
			uVar2 = local_10;
			iVar3 = y1;
			iVar4 = iVar6;
			if (iVar9 < 0) {
				uVar2 = uVar8;
				iVar3 = x1;
				iVar4 = iVar7;
			}
			x2 = x2 + iVar3;
			iVar9 = iVar9 + iVar4 * 2;
			y2 = y2 + uVar2;
			local_4 = local_4 + -1;
		} while (local_4 != 0);
	}
	return;
}



// 8bit Pixel Routine

void __cdecl lego::draw::Draw_Pixel8(int x,int y,uint value)
{
	*(undefined *)(y * globs::drawGlobs.pitch + x + (int)globs::drawGlobs.buffer) = (undefined)value;
	return;
}



// 16bit (565) Pixel Routine (normal)

void __cdecl lego::draw::Draw_Pixel16(int x,int y,uint value)
{
	*(undefined2 *)((int)globs::drawGlobs.buffer + x * 2 + y * globs::drawGlobs.pitch) =
			 (undefined2)value;
	return;
}



// 16bit (565) Pixel Routine (XOR)

void __cdecl lego::draw::Draw_Pixel16XOR(int x,int y,uint value)
{
	ushort *puVar1;
	
	puVar1 = (ushort *)((int)globs::drawGlobs.buffer + x * 2 + y * globs::drawGlobs.pitch);
	*puVar1 = *puVar1 ^ (ushort)value;
	return;
}



// 16bit (565) Pixel Routine (HalfTrans)

void __cdecl lego::draw::Draw_Pixel16HalfTrans(int x,int y,uint value)
{
	ushort *puVar1;
	ushort uVar2;
	ushort uVar3;
	
	puVar1 = (ushort *)((int)globs::drawGlobs.buffer + x * 2 + y * globs::drawGlobs.pitch);
	uVar2 = *puVar1;
	uVar3 = (ushort)value;
	*puVar1 = (((ushort)globs::drawGlobs.greenMask & uVar2) >> 1 & 0x7fe0) +
						(((ushort)globs::drawGlobs.greenMask & uVar3) >> 1 & 0x7fe0) &
						(ushort)globs::drawGlobs.greenMask |
						((uVar3 & (ushort)globs::drawGlobs.blueMask) >> 1) +
						((uVar2 & (ushort)globs::drawGlobs.blueMask) >> 1) & (ushort)globs::drawGlobs.blueMask |
						(uVar3 >> 1 & 0x7800) + (uVar2 >> 1 & 0x7800) & (ushort)globs::drawGlobs.redMask;
	return;
}



// 24bit Pixel Routine

void __cdecl lego::draw::Draw_Pixel24(int x,int y,uint value)
{
	uint *puVar1;
	
	puVar1 = (uint *)((int)globs::drawGlobs.buffer + x * 3 + y * globs::drawGlobs.pitch);
	*puVar1 = value << 8 | *puVar1 & 0xff;
	return;
}



// 32bit Pixel Routine

void __cdecl lego::draw::Draw_Pixel32(int x,int y,uint value)
{
	*(uint *)((int)globs::drawGlobs.buffer + x * 4 + y * globs::drawGlobs.pitch) = value;
	return;
}



Lws_Info * __cdecl lego::res::Lws_Parse(char *fname,BOOL looping)
{
	char *pcVar1;
	int iVar2;
	float fVar3;
	char cVar4;
	byte bVar5;
	ushort uVar6;
	FileStream *file;
	byte *pbVar7;
	int iVar8;
	byte *pbVar9;
	char *pcVar10;
	Lws_Node *pLVar11;
	int iVar12;
	Lws_KeyInfo *pLVar13;
	float *pfVar14;
	ushort *puVar15;
	uint uVar16;
	uint uVar17;
	Lws_Node *pLVar18;
	Lws_Info *scene;
	char *pcVar19;
	undefined4 *puVar20;
	Lws_Info *pLVar21;
	undefined4 *puVar22;
	bool bVar23;
	float10 fVar24;
	void *local_968;
	uint local_964;
	uint local_960;
	Lws_Node *local_958;
	byte *local_954;
	byte *local_950;
	char *local_94c;
	char *local_948;
	char *local_944;
	char *local_940;
	char *local_93c;
	char *local_938;
	char *local_934;
	char *local_930;
	char local_904 [260];
	char local_800 [1024];
	char local_400 [1024];
	
	scene = (Lws_Info *)0x0;
	std::sprintf(local_904,"%s.%s",fname,"lws");
	file = lego::file::File_Open(local_904,"r");
	if (file != (FileStream *)0x0) {
		lego::file::File_GetLine(local_800,0x400,file);
		uVar16 = 0xffffffff;
		pcVar19 = local_800;
		do {
			if (uVar16 == 0) break;
			uVar16 = uVar16 - 1;
			cVar4 = *pcVar19;
			pcVar19 = pcVar19 + 1;
		} while (cVar4 != '\0');
		pbVar9 = (byte *)(local_800 + (~uVar16 & 0xffff));
		lego::file::File_GetLine((char *)pbVar9,0x400 - (~uVar16 & 0xffff),file);
		pcVar19 = "LWSC";
		pbVar7 = (byte *)local_800;
		do {
			bVar5 = *pbVar7;
			bVar23 = bVar5 < (byte)*pcVar19;
			if (bVar5 != *pcVar19) {
LAB_00486d70:
				iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
				goto LAB_00486d75;
			}
			if (bVar5 == 0) break;
			bVar5 = pbVar7[1];
			bVar23 = bVar5 < ((byte *)pcVar19)[1];
			if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00486d70;
			pbVar7 = pbVar7 + 2;
			pcVar19 = (char *)((byte *)pcVar19 + 2);
		} while (bVar5 != 0);
		iVar8 = 0;
LAB_00486d75:
		if (iVar8 == 0) {
			pcVar19 = "1";
			do {
				bVar5 = *pbVar9;
				bVar23 = bVar5 < (byte)*pcVar19;
				if (bVar5 != *pcVar19) {
LAB_00486da8:
					iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
					goto LAB_00486dad;
				}
				if (bVar5 == 0) break;
				bVar5 = pbVar9[1];
				bVar23 = bVar5 < ((byte *)pcVar19)[1];
				if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00486da8;
				pbVar9 = pbVar9 + 2;
				pcVar19 = (char *)((byte *)pcVar19 + 2);
			} while (bVar5 != 0);
			iVar8 = 0;
LAB_00486dad:
			if (iVar8 == 0) {
				local_964 = 0;
				local_960 = 0;
				pLVar18 = (Lws_Node *)0x0;
				pcVar19 = local_904;
				pcVar10 = local_904;
				cVar4 = local_904[0];
				while (cVar4 != '\0') {
					if (cVar4 == '\\') {
						pcVar19 = pcVar10;
					}
					pcVar1 = pcVar10 + 1;
					pcVar10 = pcVar10 + 1;
					cVar4 = *pcVar1;
				}
				pcVar19[pcVar19 != local_904] = '\0';
				scene = (Lws_Info *)std::malloc(0x38);
				pLVar21 = scene;
				for (iVar8 = 0xe; iVar8 != 0; iVar8 = iVar8 + -1) {
					*(undefined4 *)pLVar21 = 0;
					pLVar21 = (Lws_Info *)&pLVar21->fps;
				}
				if (local_904[0] == '\0') {
					scene->filePath = (char *)0x0;
				}
				else {
					pcVar19 = std::_strdup(local_904);
					scene->filePath = pcVar19;
				}
				scene->nodeListSize = 10;
				scene->referenceCount = 1;
				if (looping != 0) {
					scene->flags = scene->flags | 1;
				}
				pLVar11 = (Lws_Node *)std::malloc(0x208);
				scene->nodeList = pLVar11;
				local_968 = std::malloc((uint)scene->nodeListSize << 1);
				pcVar19 = lego::file::File_GetLine(local_800,0x400,file);
				while (pcVar19 != (char *)0x0) {
					uVar16 = 0xffffffff;
					pcVar19 = local_800;
					do {
						pcVar10 = pcVar19;
						if (uVar16 == 0) break;
						uVar16 = uVar16 - 1;
						pcVar10 = pcVar19 + 1;
						cVar4 = *pcVar19;
						pcVar19 = pcVar10;
					} while (cVar4 != '\0');
					uVar16 = ~uVar16;
					puVar20 = (undefined4 *)(pcVar10 + -uVar16);
					puVar22 = (undefined4 *)local_400;
					for (uVar17 = uVar16 >> 2; uVar17 != 0; uVar17 = uVar17 - 1) {
						*puVar22 = *puVar20;
						puVar20 = puVar20 + 1;
						puVar22 = puVar22 + 1;
					}
					for (uVar16 = uVar16 & 3; uVar16 != 0; uVar16 = uVar16 - 1) {
						*(undefined *)puVar22 = *(undefined *)puVar20;
						puVar20 = (undefined4 *)((int)puVar20 + 1);
						puVar22 = (undefined4 *)((int)puVar22 + 1);
					}
					iVar8 = util::Util_WSTokenise(local_400,(char **)&local_954);
					if (iVar8 != 0) {
						if (pLVar18 == (Lws_Node *)0x0) {
							pcVar19 = "FirstFrame";
							pbVar9 = local_954;
							do {
								bVar5 = *pcVar19;
								bVar23 = bVar5 < *pbVar9;
								if (bVar5 != *pbVar9) {
LAB_00486f0b:
									iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
									goto LAB_00486f10;
								}
								if (bVar5 == 0) break;
								bVar5 = ((byte *)pcVar19)[1];
								bVar23 = bVar5 < pbVar9[1];
								if (bVar5 != pbVar9[1]) goto LAB_00486f0b;
								pcVar19 = (char *)((byte *)pcVar19 + 2);
								pbVar9 = pbVar9 + 2;
							} while (bVar5 != 0);
							iVar8 = 0;
LAB_00486f10:
							if (iVar8 == 0) {
								iVar8 = std::atoi((char *)local_950);
								scene->firstFrame = (ushort)iVar8;
							}
							pcVar19 = "LastFrame";
							pbVar9 = local_954;
							do {
								bVar5 = *pcVar19;
								bVar23 = bVar5 < *pbVar9;
								if (bVar5 != *pbVar9) {
LAB_00486f55:
									iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
									goto LAB_00486f5a;
								}
								if (bVar5 == 0) break;
								bVar5 = ((byte *)pcVar19)[1];
								bVar23 = bVar5 < pbVar9[1];
								if (bVar5 != pbVar9[1]) goto LAB_00486f55;
								pcVar19 = (char *)((byte *)pcVar19 + 2);
								pbVar9 = pbVar9 + 2;
							} while (bVar5 != 0);
							iVar8 = 0;
LAB_00486f5a:
							if (iVar8 == 0) {
								iVar8 = std::atoi((char *)local_950);
								scene->lastFrame = (ushort)iVar8;
							}
							if (scene->lastFrame == 0) {
								scene->lastFrame = 1;
							}
							pcVar19 = "FramesPerSecond";
							pbVar9 = local_954;
							do {
								bVar5 = *pcVar19;
								bVar23 = bVar5 < *pbVar9;
								if (bVar5 != *pbVar9) {
LAB_00486fb3:
									iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
									goto LAB_00486fb8;
								}
								if (bVar5 == 0) break;
								bVar5 = ((byte *)pcVar19)[1];
								bVar23 = bVar5 < pbVar9[1];
								if (bVar5 != pbVar9[1]) goto LAB_00486fb3;
								pcVar19 = (char *)((byte *)pcVar19 + 2);
								pbVar9 = pbVar9 + 2;
							} while (bVar5 != 0);
							iVar8 = 0;
LAB_00486fb8:
							if (iVar8 == 0) {
								fVar24 = std::atof((char *)local_950);
								scene->fps = (float)fVar24;
							}
							pcVar19 = "AddNullObject";
							pbVar9 = local_954;
							do {
								bVar5 = *pcVar19;
								bVar23 = bVar5 < *pbVar9;
								if (bVar5 != *pbVar9) {
LAB_00486fff:
									iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
									goto LAB_00487004;
								}
								if (bVar5 == 0) break;
								bVar5 = ((byte *)pcVar19)[1];
								bVar23 = bVar5 < pbVar9[1];
								if (bVar5 != pbVar9[1]) goto LAB_00486fff;
								pcVar19 = (char *)((byte *)pcVar19 + 2);
								pbVar9 = pbVar9 + 2;
							} while (bVar5 != 0);
							iVar8 = 0;
LAB_00487004:
							if (iVar8 != 0) {
								pcVar19 = "LoadObject";
								pbVar9 = local_954;
								do {
									bVar5 = *pcVar19;
									bVar23 = bVar5 < *pbVar9;
									if (bVar5 != *pbVar9) {
LAB_00487033:
										iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
										goto LAB_00487038;
									}
									if (bVar5 == 0) break;
									bVar5 = ((byte *)pcVar19)[1];
									bVar23 = bVar5 < pbVar9[1];
									if (bVar5 != pbVar9[1]) goto LAB_00487033;
									pcVar19 = (char *)((byte *)pcVar19 + 2);
									pbVar9 = pbVar9 + 2;
								} while (bVar5 != 0);
								iVar8 = 0;
LAB_00487038:
								if (iVar8 != 0) goto LAB_004877aa;
							}
							if (scene->nodeCount == scene->nodeListSize) {
								uVar6 = scene->nodeListSize + 10;
								scene->nodeListSize = uVar6;
								pLVar18 = (Lws_Node *)std::realloc(scene->nodeList,(uint)uVar6 * 0x34);
								scene->nodeList = pLVar18;
								local_968 = std::realloc(local_968,(uint)scene->nodeListSize << 1);
							}
							*(undefined2 *)((int)local_968 + (uint)scene->nodeCount * 2) = 0;
							pLVar18 = scene->nodeList + scene->nodeCount;
							local_958 = pLVar18;
							pLVar11 = pLVar18;
							for (iVar8 = 0xd; iVar8 != 0; iVar8 = iVar8 + -1) {
								pLVar11->name = (char *)0x0;
								pLVar11 = (Lws_Node *)&pLVar11->reference;
							}
							pcVar19 = "AddNullObject";
							pbVar9 = local_954;
							do {
								bVar5 = *pcVar19;
								bVar23 = bVar5 < *pbVar9;
								if (bVar5 != *pbVar9) {
LAB_004870eb:
									iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
									goto LAB_004870f0;
								}
								if (bVar5 == 0) break;
								bVar5 = ((byte *)pcVar19)[1];
								bVar23 = bVar5 < pbVar9[1];
								if (bVar5 != pbVar9[1]) goto LAB_004870eb;
								pcVar19 = (char *)((byte *)pcVar19 + 2);
								pbVar9 = pbVar9 + 2;
							} while (bVar5 != 0);
							iVar8 = 0;
LAB_004870f0:
							if (iVar8 == 0) {
								pLVar18->flags = pLVar18->flags | 1;
								pcVar19 = std::_strdup(local_800 + 0xe);
								pLVar18->name = pcVar19;
								iVar8 = std::_strnicmp(pcVar19,"SFX",3);
								if ((iVar8 == 0) && (iVar8 = std::_strnicmp(pLVar18->name + 3,",",1), iVar8 == 0)) {
									pLVar18->flags = pLVar18->flags | 2;
									scene->triggerCount = scene->triggerCount + 1;
								}
							}
							else {
								uVar16 = 0xffffffff;
								pcVar19 = local_800;
								do {
									pcVar10 = pcVar19;
									if (uVar16 == 0) break;
									uVar16 = uVar16 - 1;
									pcVar10 = pcVar19 + 1;
									cVar4 = *pcVar19;
									pcVar19 = pcVar10;
								} while (cVar4 != '\0');
								uVar16 = ~uVar16;
								puVar20 = (undefined4 *)(pcVar10 + -uVar16);
								puVar22 = (undefined4 *)local_400;
								for (uVar17 = uVar16 >> 2; uVar17 != 0; uVar17 = uVar17 - 1) {
									*puVar22 = *puVar20;
									puVar20 = puVar20 + 1;
									puVar22 = puVar22 + 1;
								}
								for (uVar16 = uVar16 & 3; uVar16 != 0; uVar16 = uVar16 - 1) {
									*(undefined *)puVar22 = *(undefined *)puVar20;
									puVar20 = (undefined4 *)((int)puVar20 + 1);
									puVar22 = (undefined4 *)((int)puVar22 + 1);
								}
								iVar8 = util::Util_Tokenise(local_800,(char **)&local_954,"\\");
								pcVar19 = util::Util_StrIStr((char *)(&local_958)[iVar8],".lwo");
								if (pcVar19 != (char *)0x0) {
									*pcVar19 = '\0';
								}
								pcVar19 = std::_strdup((char *)(&local_958)[iVar8]);
								pLVar18->name = pcVar19;
							}
							iVar8 = scene->nodeCount - 1;
							if (-1 < iVar8) {
								pLVar11 = scene->nodeList + iVar8;
								do {
									bVar5 = pLVar11->flags & 1;
									if (((bVar5 != 0) && ((pLVar18->flags & 1) != 0)) ||
										 ((bVar5 == 0 && ((pLVar18->flags & 1) == 0)))) {
										pbVar9 = (byte *)pLVar11->name;
										pbVar7 = (byte *)pLVar18->name;
										do {
											bVar5 = *pbVar7;
											bVar23 = bVar5 < *pbVar9;
											if (bVar5 != *pbVar9) {
LAB_00487222:
												iVar12 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
												goto LAB_00487227;
											}
											if (bVar5 == 0) break;
											bVar5 = pbVar7[1];
											bVar23 = bVar5 < pbVar9[1];
											if (bVar5 != pbVar9[1]) goto LAB_00487222;
											pbVar7 = pbVar7 + 2;
											pbVar9 = pbVar9 + 2;
										} while (bVar5 != 0);
										iVar12 = 0;
LAB_00487227:
										pLVar18 = local_958;
										if (iVar12 == 0) {
											local_958->reference = scene->nodeList[iVar8].reference + 1;
											break;
										}
									}
									iVar8 = iVar8 + -1;
									pLVar11 = pLVar11 + -1;
								} while (-1 < iVar8);
							}
						}
						else {
							if (local_964 == 0) {
								if (local_960 == 0) {
									pcVar19 = "ObjectMotion";
									pbVar9 = local_954;
									do {
										bVar5 = *pbVar9;
										bVar23 = bVar5 < (byte)*pcVar19;
										if (bVar5 != *pcVar19) {
LAB_00487586:
											iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
											goto LAB_0048758b;
										}
										if (bVar5 == 0) break;
										bVar5 = pbVar9[1];
										bVar23 = bVar5 < ((byte *)pcVar19)[1];
										if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487586;
										pbVar9 = pbVar9 + 2;
										pcVar19 = (char *)((byte *)pcVar19 + 2);
									} while (bVar5 != 0);
									iVar8 = 0;
LAB_0048758b:
									if (iVar8 == 0) {
										local_964 = 1;
									}
									else {
										pcVar19 = "ObjDissolve";
										pbVar9 = local_954;
										do {
											bVar5 = *pbVar9;
											bVar23 = bVar5 < (byte)*pcVar19;
											if (bVar5 != *pcVar19) {
LAB_004875c7:
												iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
												goto LAB_004875cc;
											}
											if (bVar5 == 0) break;
											bVar5 = pbVar9[1];
											bVar23 = bVar5 < ((byte *)pcVar19)[1];
											if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_004875c7;
											pbVar9 = pbVar9 + 2;
											pcVar19 = (char *)((byte *)pcVar19 + 2);
										} while (bVar5 != 0);
										iVar8 = 0;
LAB_004875cc:
										if (iVar8 == 0) {
											pcVar19 = "(envelope)";
											pbVar9 = local_950;
											do {
												bVar5 = *pbVar9;
												bVar23 = bVar5 < (byte)*pcVar19;
												if (bVar5 != *pcVar19) {
LAB_00487603:
													iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
													goto LAB_00487608;
												}
												if (bVar5 == 0) break;
												bVar5 = pbVar9[1];
												bVar23 = bVar5 < ((byte *)pcVar19)[1];
												if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487603;
												pbVar9 = pbVar9 + 2;
												pcVar19 = (char *)((byte *)pcVar19 + 2);
											} while (bVar5 != 0);
											iVar8 = 0;
LAB_00487608:
											if (iVar8 == 0) {
												local_960 = 1;
											}
											else {
												fVar24 = std::atof((char *)local_950);
												globs::lwsGlobs.staticDissolveLevel[globs::lwsGlobs.staticDissolveCount] =
														 (float)fVar24;
												pLVar18->dissolveLevel =
														 globs::lwsGlobs.staticDissolveLevel +
														 globs::lwsGlobs.staticDissolveCount;
												globs::lwsGlobs.staticDissolveCount =
														 globs::lwsGlobs.staticDissolveCount + 1;
												pLVar18->dissolveLevel = (float *)0x0;
											}
										}
										else {
											pcVar19 = "ParentObject";
											pbVar9 = local_954;
											do {
												bVar5 = *pbVar9;
												bVar23 = bVar5 < (byte)*pcVar19;
												if (bVar5 != *pcVar19) {
LAB_00487680:
													iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
													goto LAB_00487685;
												}
												if (bVar5 == 0) break;
												bVar5 = pbVar9[1];
												bVar23 = bVar5 < ((byte *)pcVar19)[1];
												if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487680;
												pbVar9 = pbVar9 + 2;
												pcVar19 = (char *)((byte *)pcVar19 + 2);
											} while (bVar5 != 0);
											iVar8 = 0;
LAB_00487685:
											if (iVar8 == 0) {
												iVar8 = std::atoi((char *)local_950);
												*(short *)((int)local_968 + (uint)scene->nodeCount * 2) = (short)iVar8;
											}
											else {
												pcVar19 = "PivotPoint";
												pbVar9 = local_954;
												do {
													bVar5 = *pbVar9;
													bVar23 = bVar5 < (byte)*pcVar19;
													if (bVar5 != *pcVar19) {
LAB_004876d8:
														iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
														goto LAB_004876dd;
													}
													if (bVar5 == 0) break;
													bVar5 = pbVar9[1];
													bVar23 = bVar5 < ((byte *)pcVar19)[1];
													if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_004876d8;
													pbVar9 = pbVar9 + 2;
													pcVar19 = (char *)((byte *)pcVar19 + 2);
												} while (bVar5 != 0);
												iVar8 = 0;
LAB_004876dd:
												if (iVar8 == 0) {
													fVar24 = std::atof((char *)local_950);
													(pLVar18->pivotVector).x = (float)-fVar24;
													fVar24 = std::atof(local_94c);
													(pLVar18->pivotVector).y = (float)-fVar24;
													fVar24 = std::atof(local_948);
													(pLVar18->pivotVector).z = (float)-fVar24;
												}
												else {
													pcVar19 = "UnseenByCamera";
													pbVar9 = local_954;
													do {
														bVar5 = *pbVar9;
														bVar23 = bVar5 < (byte)*pcVar19;
														if (bVar5 != *pcVar19) {
LAB_00487747:
															iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
															goto LAB_0048774c;
														}
														if (bVar5 == 0) break;
														bVar5 = pbVar9[1];
														bVar23 = bVar5 < ((byte *)pcVar19)[1];
														if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487747;
														pbVar9 = pbVar9 + 2;
														pcVar19 = (char *)((byte *)pcVar19 + 2);
													} while (bVar5 != 0);
													iVar8 = 0;
LAB_0048774c:
													if ((iVar8 == 0) && (iVar8 = std::atoi((char *)local_950), iVar8 == 1)) {
														pLVar18->flags = pLVar18->flags | 4;
													}
													else {
														pcVar19 = "ShadowOptions";
														pbVar9 = local_954;
														do {
															bVar5 = *pbVar9;
															bVar23 = bVar5 < (byte)*pcVar19;
															if (bVar5 != *pcVar19) {
LAB_00487797:
																iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
																goto LAB_0048779c;
															}
															if (bVar5 == 0) break;
															bVar5 = pbVar9[1];
															bVar23 = bVar5 < ((byte *)pcVar19)[1];
															if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487797;
															pbVar9 = pbVar9 + 2;
															pcVar19 = (char *)((byte *)pcVar19 + 2);
														} while (bVar5 != 0);
														iVar8 = 0;
LAB_0048779c:
														if (iVar8 == 0) {
															pLVar18 = (Lws_Node *)0x0;
															scene->nodeCount = scene->nodeCount + 1;
														}
													}
												}
											}
										}
									}
								}
								else {
									if (local_960 != 1) {
										if (local_960 == 2) {
											uVar16 = std::atoi((char *)local_950);
											pLVar18->dissolveCount = (ushort)uVar16;
											pfVar14 = (float *)std::malloc((uVar16 & 0xffff) * 4 + 4);
											pLVar18->dissolveLevel = pfVar14;
											puVar15 = (ushort *)std::malloc((uint)pLVar18->dissolveCount * 2 + 2);
											pLVar18->dissolveFrame = puVar15;
										}
										else {
											uVar16 = (int)(local_960 - 3) / 2;
											if ((ushort)uVar16 < pLVar18->dissolveCount) {
												uVar17 = (int)local_960 >> 0x1f;
												if (((local_960 ^ uVar17) - uVar17 & 1 ^ uVar17) == uVar17) {
													iVar8 = std::atoi((char *)local_950);
													pLVar18->dissolveFrame[uVar16 & 0xffff] = (ushort)iVar8;
												}
												else {
													uVar16 = uVar16 & 0xffff;
													fVar24 = std::atof((char *)local_950);
													pLVar18->dissolveLevel[uVar16] = (float)fVar24;
													if (pLVar18->dissolveLevel[uVar16] < 0.0) {
														pLVar18->dissolveLevel[uVar16] = 0.0;
													}
													fVar3 = pLVar18->dissolveLevel[uVar16];
													if ((ushort)((ushort)(fVar3 < 1.0) << 8 | (ushort)(fVar3 == 1.0) << 0xe)
															== 0) {
														pLVar18->dissolveLevel[uVar16] = 1.0;
													}
													pLVar18->dissolveLevel[uVar16] = 1.0 - pLVar18->dissolveLevel[uVar16];
												}
											}
										}
									}
									pcVar19 = "EndBehavior";
									pbVar9 = local_954;
									do {
										bVar5 = *pbVar9;
										bVar23 = bVar5 < (byte)*pcVar19;
										if (bVar5 != *pcVar19) {
LAB_00487541:
											uVar16 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
											goto LAB_00487546;
										}
										if (bVar5 == 0) break;
										bVar5 = pbVar9[1];
										bVar23 = bVar5 < ((byte *)pcVar19)[1];
										if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487541;
										pbVar9 = pbVar9 + 2;
										pcVar19 = (char *)((byte *)pcVar19 + 2);
									} while (bVar5 != 0);
									uVar16 = 0;
LAB_00487546:
									local_960 = local_960 + 1;
									if (uVar16 == 0) {
										local_960 = uVar16;
									}
								}
							}
							else {
								if (local_964 != 1) {
									if (local_964 == 2) {
										uVar16 = std::atoi((char *)local_950);
										pLVar18->keyCount = (ushort)uVar16;
										pLVar13 = (Lws_KeyInfo *)std::malloc(((uVar16 & 0xffff) + 1) * 0x28);
										pLVar18->keyList = pLVar13;
									}
									else {
										uVar16 = (int)(local_964 - 3) / 2;
										if ((ushort)uVar16 < pLVar18->keyCount) {
											uVar17 = (int)local_964 >> 0x1f;
											if (((local_964 ^ uVar17) - uVar17 & 1 ^ uVar17) == uVar17) {
												iVar8 = std::atoi((char *)local_950);
												pLVar18->keyList[uVar16 & 0xffff].frame = (ushort)iVar8;
											}
											else {
												uVar16 = uVar16 & 0xffff;
												fVar24 = std::atof((char *)local_950);
												pLVar18->keyList[uVar16].position.x = (float)fVar24;
												fVar24 = std::atof(local_94c);
												pLVar18->keyList[uVar16].position.y = (float)fVar24;
												fVar24 = std::atof(local_948);
												pLVar18->keyList[uVar16].position.z = (float)fVar24;
												fVar24 = std::atof(local_944);
												pLVar18->keyList[uVar16].hpb.x =
														 (float)(fVar24 * (float10)0.005555556 * (float10)3.141593);
												fVar24 = std::atof(local_940);
												pLVar18->keyList[uVar16].hpb.y =
														 (float)(fVar24 * (float10)0.005555556 * (float10)3.141593);
												fVar24 = std::atof(local_93c);
												pLVar18->keyList[uVar16].hpb.z =
														 (float)(fVar24 * (float10)0.005555556 * (float10)3.141593);
												fVar24 = std::atof(local_938);
												pLVar18->keyList[uVar16].scale.x = (float)fVar24;
												fVar24 = std::atof(local_934);
												pLVar18->keyList[uVar16].scale.y = (float)fVar24;
												fVar24 = std::atof(local_930);
												pLVar18->keyList[uVar16].scale.z = (float)fVar24;
											}
										}
									}
								}
								pcVar19 = "EndBehavior";
								pbVar9 = local_954;
								do {
									bVar5 = *pbVar9;
									bVar23 = bVar5 < (byte)*pcVar19;
									if (bVar5 != *pcVar19) {
LAB_004873f6:
										uVar16 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
										goto LAB_004873fb;
									}
									if (bVar5 == 0) break;
									bVar5 = pbVar9[1];
									bVar23 = bVar5 < ((byte *)pcVar19)[1];
									if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_004873f6;
									pbVar9 = pbVar9 + 2;
									pcVar19 = (char *)((byte *)pcVar19 + 2);
								} while (bVar5 != 0);
								uVar16 = 0;
LAB_004873fb:
								local_964 = local_964 + 1;
								if (uVar16 == 0) {
									local_964 = uVar16;
								}
							}
						}
					}
LAB_004877aa:
					pcVar19 = lego::file::File_GetLine(local_800,0x400,file);
				}
				iVar8 = 0;
				if (scene->nodeCount != 0) {
					iVar12 = 0;
					do {
						pbVar9 = scene->nodeList->padding1 + iVar12 + -9;
						if (*(ushort *)(pbVar9 + 0x24) != 1) {
							iVar2 = *(int *)(pbVar9 + 0x18) + (uint)*(ushort *)(pbVar9 + 0x24) * 0x28;
							if (*(ushort *)(iVar2 + -4) < scene->lastFrame) {
								*(ushort *)(iVar2 + 0x24) = scene->lastFrame;
								puVar20 = (undefined4 *)
													(*(int *)(pbVar9 + 0x18) + (uint)*(ushort *)(pbVar9 + 0x24) * 0x28);
								*puVar20 = puVar20[-10];
								puVar20[1] = puVar20[-9];
								puVar20[2] = puVar20[-8];
								iVar2 = *(int *)(pbVar9 + 0x18) + (uint)*(ushort *)(pbVar9 + 0x24) * 0x28;
								*(undefined4 *)(iVar2 + 0xc) = *(undefined4 *)(iVar2 + -0x1c);
								*(undefined4 *)(iVar2 + 0x10) = *(undefined4 *)(iVar2 + -0x18);
								*(undefined4 *)(iVar2 + 0x14) = *(undefined4 *)(iVar2 + -0x14);
								iVar2 = *(int *)(pbVar9 + 0x18) + (uint)*(ushort *)(pbVar9 + 0x24) * 0x28;
								*(undefined4 *)(iVar2 + 0x18) = *(undefined4 *)(iVar2 + -0x10);
								*(undefined4 *)(iVar2 + 0x1c) = *(undefined4 *)(iVar2 + -0xc);
								*(undefined4 *)(iVar2 + 0x20) = *(undefined4 *)(iVar2 + -8);
								*(short *)(pbVar9 + 0x24) = *(short *)(pbVar9 + 0x24) + 1;
							}
						}
						iVar8 = iVar8 + 1;
						iVar12 = iVar12 + 0x34;
					} while (iVar8 < (int)(uint)scene->nodeCount);
				}
				iVar8 = 0;
				if (scene->nodeCount != 0) {
					iVar12 = 0;
					do {
						pbVar9 = scene->nodeList->padding1 + iVar12 + -9;
						if (*(ushort *)(pbVar9 + 0x26) != 0) {
							puVar15 = (ushort *)(*(int *)(pbVar9 + 0x20) + (uint)*(ushort *)(pbVar9 + 0x26) * 2);
							if (puVar15[-1] < scene->lastFrame) {
								*puVar15 = scene->lastFrame;
								puVar20 = (undefined4 *)
													(*(int *)(pbVar9 + 0x1c) + (uint)*(ushort *)(pbVar9 + 0x26) * 4);
								*puVar20 = puVar20[-1];
								*(short *)(pbVar9 + 0x26) = *(short *)(pbVar9 + 0x26) + 1;
							}
						}
						iVar8 = iVar8 + 1;
						iVar12 = iVar12 + 0x34;
					} while (iVar8 < (int)(uint)scene->nodeCount);
				}
				uVar16 = (uint)scene->nodeCount;
				iVar8 = uVar16 - 1;
				if (-1 < iVar8) {
					puVar15 = (ushort *)((int)local_968 + iVar8 * 2);
					iVar8 = iVar8 * 0x34;
					do {
						pLVar18 = (Lws_Node *)(scene->nodeList->padding1 + iVar8 + -9);
						if (*puVar15 == 0) {
							pLVar18->next = scene->masterNode;
							scene->masterNode = pLVar18;
						}
						else {
							pLVar11 = scene->nodeList + (*puVar15 - 1);
							pLVar18->next = pLVar11->childList;
							pLVar11->childList = pLVar18;
						}
						iVar8 = iVar8 + -0x34;
						puVar15 = puVar15 + -1;
						uVar16 = uVar16 - 1;
					} while (uVar16 != 0);
				}
				std::free(local_968);
				Lws_SetupSoundTriggers(scene);
			}
		}
		lego::file::File_Close(file);
	}
	return scene;
}



void __cdecl
lego::res::Lws_Initialise
					(char *sharedDir,LwsFindSFXIDFunction *FindSFXID,LwsPlaySample3DFunc *PlaySample3D,
					LwsSoundEnabledFunction *SoundEnabled)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	if (sharedDir != (char *)0x0) {
		uVar2 = 0xffffffff;
		pcVar6 = sharedDir;
		do {
			if (uVar2 == 0) break;
			uVar2 = uVar2 - 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
		uVar3 = ~uVar2 - 1;
		if (sharedDir[(uVar3 & 0xffff) - 1] != '\\') {
			uVar3 = ~uVar2;
		}
		uVar3 = uVar3 & 0xffff;
		globs::lwsGlobs.sharedDir = (char *)std::malloc(uVar3 + 1);
		uVar2 = 0xffffffff;
		do {
			pcVar6 = sharedDir;
			if (uVar2 == 0) break;
			uVar2 = uVar2 - 1;
			pcVar6 = sharedDir + 1;
			cVar1 = *sharedDir;
			sharedDir = pcVar6;
		} while (cVar1 != '\0');
		uVar2 = ~uVar2;
		puVar5 = (undefined4 *)(pcVar6 + -uVar2);
		puVar7 = (undefined4 *)globs::lwsGlobs.sharedDir;
		for (uVar4 = uVar2 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
			*puVar7 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar7 = puVar7 + 1;
		}
		for (uVar2 = uVar2 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {
			*(undefined *)puVar7 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar7 = (undefined4 *)((int)puVar7 + 1);
		}
		globs::lwsGlobs.sharedDir[uVar3 - 1] = '\\';
		globs::lwsGlobs.sharedDir[uVar3] = '\0';
	}
	globs::lwsGlobs.FindSFXIDFunc = FindSFXID;
	globs::lwsGlobs.SoundEnabledFunc = SoundEnabled;
	globs::lwsGlobs.PlaySample3DFunc = PlaySample3D;
	return;
}



void __cdecl lego::res::Lws_Shutdown(void)
{
	uint uVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (globs::lwsGlobs.meshPathCount != 0) {
		uVar1 = 0;
		do {
			std::free(globs::lwsGlobs.meshPathList[uVar1].path);
			uVar2 = uVar2 + 1;
			uVar1 = uVar2 & 0xffff;
		} while (uVar1 < globs::lwsGlobs.meshPathCount);
	}
	uVar2 = 0;
	if (globs::lwsGlobs.meshPathCountShared != 0) {
		uVar1 = 0;
		do {
			std::free(globs::lwsGlobs.meshPathListShared[uVar1].path);
			uVar2 = uVar2 + 1;
			uVar1 = uVar2 & 0xffff;
		} while (uVar1 < globs::lwsGlobs.meshPathCountShared);
	}
	return;
}



uint __cdecl lego::res::Lws_GetFrameCount(Lws_Info *scene)
{
	return (uint)scene->lastFrame;
}



void __cdecl lego::res::Lws_SetupSoundTriggers(Lws_Info *scene)
{
	Lws_Node *pLVar1;
	char cVar2;
	byte bVar3;
	ushort uVar4;
	ushort uVar5;
	Lws_SoundTrigger *pLVar6;
	int iVar7;
	BOOL BVar8;
	char *pcVar9;
	uint uVar10;
	uint uVar11;
	undefined4 *puVar12;
	ushort *puVar13;
	char *pcVar14;
	undefined4 *puVar15;
	char **ppcVar16;
	uint uStack2052;
	char *local_800;
	char *local_7fc;
	char *apcStack2040 [254];
	undefined4 local_400 [256];
	
	if (globs::lwsGlobs.FindSFXIDFunc == (LwsFindSFXIDFunction *)0x0) {
		scene->triggerCount = 0;
	}
	else {
		bVar3 = 0;
		if (scene->triggerCount != 0) {
			pLVar6 = (Lws_SoundTrigger *)std::malloc((uint)scene->triggerCount * 0xd0);
			scene->triggerList = pLVar6;
			uVar5 = 0;
			if (scene->nodeCount != 0) {
				do {
					pLVar1 = scene->nodeList + uVar5;
					if ((scene->nodeList[uVar5].flags & 2) != 0) {
						pLVar6 = scene->triggerList + bVar3;
						pLVar1->triggerIndex = bVar3;
						bVar3 = bVar3 + 1;
						uVar10 = 0xffffffff;
						pcVar9 = pLVar1->name;
						do {
							pcVar14 = pcVar9;
							if (uVar10 == 0) break;
							uVar10 = uVar10 - 1;
							pcVar14 = pcVar9 + 1;
							cVar2 = *pcVar9;
							pcVar9 = pcVar14;
						} while (cVar2 != '\0');
						uVar10 = ~uVar10;
						puVar12 = (undefined4 *)(pcVar14 + -uVar10);
						puVar15 = local_400;
						for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
							*puVar15 = *puVar12;
							puVar12 = puVar12 + 1;
							puVar15 = puVar15 + 1;
						}
						for (uVar10 = uVar10 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {
							*(undefined *)puVar15 = *(undefined *)puVar12;
							puVar12 = (undefined4 *)((int)puVar12 + 1);
							puVar15 = (undefined4 *)((int)puVar15 + 1);
						}
						iVar7 = util::Util_Tokenise((char *)local_400,&local_800,",");
						pLVar6->count = (short)iVar7 - 2;
						BVar8 = (*globs::lwsGlobs.FindSFXIDFunc)(local_7fc,(uint *)pLVar6);
						if (((globs::mainGlobs.flags & CMD_REDUCESAMPLES) != CMD_NONE) && (BVar8 == 0)) {
							pLVar6->sfxID = 0;
						}
						uStack2052 = 0;
						if (pLVar6->count != 0) {
							ppcVar16 = apcStack2040;
							puVar13 = pLVar6->frameEndList;
							do {
								pcVar9 = std::strstr(*ppcVar16,"-");
								iVar7 = std::atoi(*ppcVar16);
								uVar4 = (ushort)iVar7;
								puVar13[-0x19] = uVar4;
								if (pcVar9 != (char *)0x0) {
									iVar7 = std::atoi(pcVar9 + 1);
									uVar4 = (ushort)iVar7;
								}
								*puVar13 = uVar4;
								uStack2052 = uStack2052 + 1;
								puVar13 = puVar13 + 1;
								ppcVar16 = ppcVar16 + 1;
							} while (uStack2052 < pLVar6->count);
						}
					}
					uVar5 = uVar5 + 1;
					if (scene->nodeCount <= uVar5) {
						return;
					}
				} while( true );
			}
		}
	}
	return;
}



void __cdecl lego::res::Lws_LoadMeshes(Lws_Info *scene,IDirect3DRMFrame3 *parent)
{
	Lws_Node *node;
	IDirect3DRMFrame3 *pIVar1;
	undefined4 local_4;
	
	local_4 = 0;
	pIVar1 = (IDirect3DRMFrame3 *)std::malloc((uint)scene->nodeCount << 2);
	node = scene->masterNode;
	scene->frameList = pIVar1;
	for (; node != (Lws_Node *)0x0; node = node->next) {
		Lws_CreateFrames(scene,node,parent,(ushort *)&local_4);
		Lws_LoadNodes(scene,node);
	}
	Lws_SetTime(scene,0.0);
	return;
}



Lws_Info * __cdecl lego::res::Lws_Clone(Lws_Info *scene,IDirect3DRMFrame3 *parent)
{
	Lws_Node *pLVar1;
	Lws_Info *scene_00;
	IDirect3DRMFrame3 *pIVar2;
	uint uVar3;
	Mesh *mesh;
	int iVar4;
	Lws_Info *pLVar5;
	undefined4 unaff_EBP;
	Lws_Info *pLVar6;
	Lws_Info *pLVar7;
	IDirect3DRMFrame3Vtbl *pIVar8;
	int *piVar9;
	int local_50 [2];
	undefined4 local_48;
	undefined auStack68 [40];
	int *piStack28;
	code **ppcStack16;
	undefined auStack4 [4];
	
	scene_00 = (Lws_Info *)std::malloc(0x38);
	local_48 = 0;
	pLVar5 = scene;
	if (scene->clonedFrom != (Lws_Info *)0x0) {
		pLVar5 = scene->clonedFrom;
	}
	pLVar6 = scene_00;
	for (iVar4 = 0xe; iVar4 != 0; iVar4 = iVar4 + -1) {
		*(undefined4 *)pLVar6 = 0;
		pLVar6 = (Lws_Info *)&pLVar6->fps;
	}
	pLVar6 = pLVar5;
	pLVar7 = scene_00;
	for (iVar4 = 0xe; iVar4 != 0; iVar4 = iVar4 + -1) {
		*(undefined4 *)pLVar7 = *(undefined4 *)pLVar6;
		pLVar6 = (Lws_Info *)&pLVar6->fps;
		pLVar7 = (Lws_Info *)&pLVar7->fps;
	}
	scene_00->referenceCount = 1;
	pIVar2 = (IDirect3DRMFrame3 *)std::malloc((uint)scene_00->nodeCount << 2);
	pLVar1 = scene_00->masterNode;
	scene_00->frameList = pIVar2;
	for (; pLVar1 != (Lws_Node *)0x0; pLVar1 = pLVar1->next) {
		Lws_CreateFrames(scene_00,pLVar1,parent,(ushort *)&local_48);
	}
	scene = (Lws_Info *)0x0;
	if (scene_00->nodeCount != 0) {
		do {
			uVar3 = (uint)scene & 0xffff;
			pLVar1 = scene_00->nodeList + uVar3;
			piVar9 = local_50;
			pIVar8 = pLVar5->frameList[uVar3].lpVtbl;
			(**(code **)(pIVar8->QueryInterface + 0x5c))(pIVar8);
			pIVar8 = pLVar5->frameList[uVar3].lpVtbl;
			(**(code **)(pIVar8->QueryInterface + 0x74))(pIVar8,unaff_EBP,&local_48);
			(**(code **)(*piVar9 + 8))(piVar9);
			pIVar8 = scene_00->frameList[uVar3].lpVtbl;
			(**(code **)(pIVar8->QueryInterface + 0x38))(pIVar8,0,&stack0xffffffa8);
			if ((pLVar1->flags & 1) == 0) {
				pIVar8 = pLVar5->frameList[pLVar1->frameIndex].lpVtbl;
				(**(code **)(pIVar8->QueryInterface + 0x80))(pIVar8,auStack68);
				piVar9 = local_50;
				(**(code **)(pIVar8->QueryInterface + 0x80))(pIVar8,piVar9,auStack4);
				(**(code **)*ppcStack16)(ppcStack16,&idl::IID_IDirect3DRMUserVisual,&stack0xffffff9c);
				(**(code **)(*piStack28 + 8))(piStack28);
				mesh = (Mesh *)(**(code **)(*piVar9 + 0x1c))(piVar9);
				(**(code **)(pIVar8->QueryInterface + 8))(pIVar8);
				Mesh_Clone(mesh,(IDirect3DRMFrame3 *)scene_00->frameList[pLVar1->frameIndex].lpVtbl);
			}
			scene = (Lws_Info *)((int)&scene->firstFrame + 1);
		} while ((ushort)scene < scene_00->nodeCount);
	}
	scene_00->clonedFrom = pLVar5;
	pLVar5->referenceCount = pLVar5->referenceCount + 1;
	Lws_SetTime(scene_00,0.0);
	return scene_00;
}



void __cdecl lego::res::Lws_SetTime(Lws_Info *scene,float time)
{
	Lws_Node *node;
	float fVar1;
	Lws_Info *scene_00;
	Lws_Info *pLVar2;
	ushort uVar3;
	float10 fVar4;
	
	scene_00 = scene;
	scene->lastTime = scene->time;
	if ((scene->flags & 1) == 0) {
		pLVar2 = (Lws_Info *)(uint)scene->lastFrame;
		fVar1 = (float)(int)pLVar2;
		if ((ushort)((ushort)(time < fVar1) << 8 | (ushort)(time == fVar1) << 0xe) == 0) {
			scene->time = fVar1;
			scene = pLVar2;
		}
		else {
			scene->time = time;
			scene = pLVar2;
		}
	}
	else {
		fVar4 = (float10)time;
		time = (float)(uint)scene->lastFrame;
		fVar4 = std::fmod(fVar4,(float10)(int)time);
		scene_00->time = (float)fVar4;
	}
	uVar3 = 0;
	if (scene_00->nodeCount != 0) {
		do {
			node = scene_00->nodeList + uVar3;
			if (1 < scene_00->nodeList[uVar3].keyCount) {
				fVar4 = Lws_FindPrevKey(node,scene_00->time,(ushort *)&scene);
				time = (float)fVar4;
				Lws_InterpolateKeys(scene_00,node,(ushort)scene,time);
			}
			if (1 < node->dissolveCount) {
				fVar4 = Lws_FindPrevDissolve(node,scene_00->time,(ushort *)&scene);
				time = (float)fVar4;
				Lws_InterpolateDissolve(scene_00,node,(ushort)scene,time);
			}
			Lws_AnimateTextures(scene_00,node);
			Lws_HandleTrigger(scene_00,node);
			uVar3 = uVar3 + 1;
		} while (uVar3 < scene_00->nodeCount);
	}
	return;
}



float10 __cdecl lego::res::Lws_FindPrevKey(Lws_Node *node,float time,ushort *prev)
{
	float fVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	float10 fVar6;
	
	uVar2 = 0;
	uVar5 = (uint)node->keyCount;
	while( true ) {
		uVar4 = uVar2;
		uVar3 = (uVar5 + uVar4) / 2;
		uVar2 = (uint)node->keyList[uVar3].frame;
		if ((ushort)uVar3 == (ushort)uVar4) break;
		fVar1 = (float)uVar2;
		uVar2 = uVar3;
		if ((ushort)((ushort)(fVar1 < time) << 8 | (ushort)(fVar1 == time) << 0xe) == 0) {
			uVar2 = uVar4;
			uVar5 = uVar3;
		}
	}
	fVar6 = (float10)uVar2;
	*prev = (ushort)uVar3;
	return ((float10)time - fVar6) / ((float10)(uint)node->keyList[uVar3 + 1].frame - fVar6);
}



void __cdecl lego::res::Lws_AnimateTextures(Lws_Info *scene,Lws_Node *node)
{
	Mesh *mesh;
	int **ppiVar1;
	IDirect3DRMFrame3Vtbl *pIVar2;
	int *piVar3;
	int *piStack20;
	code **ppcStack16;
	int local_4;
	
	if ((node->flags & 1) == 0) {
		ppcStack16 = (code **)0x0;
		pIVar2 = scene->frameList[node->frameIndex].lpVtbl;
		piStack20 = &local_4;
		(**(code **)(pIVar2->QueryInterface + 0x80))(pIVar2);
		piVar3 = &local_4;
		(**(code **)(pIVar2->QueryInterface + 0x80))(pIVar2,&ppcStack16);
		ppiVar1 = &piStack20;
		(**(code **)*ppcStack16)(ppcStack16,&idl::IID_IDirect3DRMUserVisual);
		(**(code **)(*piVar3 + 8))(piVar3);
		mesh = (Mesh *)(**(code **)(pIVar2->QueryInterface + 0x1c))(pIVar2);
		(*(code *)(*ppiVar1)[2])(ppiVar1);
		Mesh_SetTextureTime2(mesh,scene->time);
	}
	return;
}



void __cdecl lego::res::Lws_HandleTrigger(Lws_Info *scene,Lws_Node *node)
{
	ushort *puVar1;
	IDirect3DRMFrame3Vtbl *frame;
	Lws_Node *pLVar2;
	BOOL BVar3;
	uint uVar4;
	uint loop;
	Lws_SoundTrigger *pLVar5;
	uint uVar6;
	
	pLVar2 = node;
	if ((node->flags & 2) != 0) {
		puVar1 = &node->frameIndex;
		node = (Lws_Node *)0x0;
		frame = scene->frameList[*puVar1].lpVtbl;
		pLVar5 = scene->triggerList + pLVar2->triggerIndex;
		if (pLVar5->count != 0) {
			do {
				uVar6 = (uint)node & 0xffff;
				loop = (uint)(pLVar5->frameStartList[uVar6] != pLVar5->frameEndList[uVar6]);
				BVar3 = Lws_KeyPassed(scene,(uint)pLVar5->frameStartList[uVar6]);
				if ((BVar3 != 0) && (BVar3 = (*globs::lwsGlobs.SoundEnabledFunc)(), BVar3 != 0)) {
					uVar4 = (*globs::lwsGlobs.PlaySample3DFunc)
														((IDirect3DRMFrame3 *)frame,pLVar5->sfxID,loop,1,(Vector3F *)0x0);
					pLVar5->loopUID[uVar6] = uVar4;
				}
				if ((loop != 0) &&
					 (BVar3 = Lws_KeyPassed(scene,(uint)pLVar5->frameEndList[uVar6]), BVar3 != 0)) {
					snd::Sound3D_StopSound(pLVar5->loopUID[uVar6]);
				}
				node = (Lws_Node *)((int)&node->name + 1);
			} while ((ushort)node < pLVar5->count);
		}
	}
	return;
}



BOOL __cdecl lego::res::Lws_KeyPassed(Lws_Info *scene,uint key)
{
	Lws_Info *pLVar1;
	Lws_Info *pLVar2;
	float fVar3;
	Lws_Info *pLVar4;
	uint uVar5;
	
	pLVar1 = (Lws_Info *)scene->lastTime;
	pLVar2 = (Lws_Info *)scene->time;
	fVar3 = (float)(ulonglong)key;
	uVar5 = Lws_GetFrameCount(scene);
	pLVar4 = pLVar2;
	if ((ushort)((ushort)((float)pLVar1 < (float)pLVar2) << 8 |
							(ushort)((float)pLVar1 == (float)pLVar2) << 0xe) == 0) {
		pLVar4 = pLVar1;
	}
	scene = pLVar2;
	if ((float)pLVar1 < (float)pLVar2) {
		scene = pLVar1;
	}
	if (0.5 <= ((float)pLVar4 - (float)scene) / (float)(ulonglong)uVar5) {
		if ((fVar3 >= (float)pLVar4) ||
			 ((ushort)((ushort)(fVar3 < (float)scene) << 8 | (ushort)(fVar3 == (float)scene) << 0xe) != 0)
			 ) {
			return TRUE;
		}
	}
	else {
		if (((ushort)((ushort)(fVar3 < (float)pLVar4) << 8 | (ushort)(fVar3 == (float)pLVar4) << 0xe) !=
				 0) && ((float)scene <= fVar3)) {
			return TRUE;
		}
	}
	return 0;
}



float10 __cdecl lego::res::Lws_FindPrevDissolve(Lws_Node *node,float time,ushort *prev)
{
	ushort uVar1;
	ushort uVar2;
	ushort uVar3;
	
	uVar1 = node->dissolveCount;
	uVar3 = 1;
	if (uVar1 < 2) {
		*prev = uVar1 - 1;
		return (float10)0.0;
	}
	do {
		uVar2 = node->dissolveFrame[uVar3];
		if (time <= (float)(uint)uVar2) {
			*prev = uVar3 - 1;
			return ((float10)time - (float10)(uint)node->dissolveFrame[(ushort)(uVar3 - 1)]) /
						 ((float10)(uint)uVar2 - (float10)(uint)node->dissolveFrame[(ushort)(uVar3 - 1)]);
		}
		uVar3 = uVar3 + 1;
	} while (uVar3 < uVar1);
	*prev = uVar1 - 1;
	return (float10)0.0;
}



void __cdecl
lego::res::Lws_InterpolateDissolve(Lws_Info *scene,Lws_Node *node,ushort prev,float delta)
{
	float level;
	uint uVar1;
	
	uVar1 = (uint)prev;
	level = node->dissolveLevel[uVar1];
	if (uVar1 == node->dissolveCount - 1) {
		Lws_SetDissolveLevel(scene,node,level);
		return;
	}
	Lws_SetDissolveLevel(scene,node,(node->dissolveLevel[uVar1 + 1] - level) * delta + level);
	return;
}



void __cdecl lego::res::Lws_SetDissolveLevel(Lws_Info *scene,Lws_Node *node,float level)
{
	Mesh *mesh;
	D3DRMGroupIndex DVar1;
	D3DRMGroupIndex groupID;
	code **unaff_EDI;
	IDirect3DRMFrame3Vtbl *pIVar2;
	int *value;
	IDirect3DRMFrame3Vtbl *pIVar3;
	undefined4 uStack20;
	undefined local_4 [4];
	
	pIVar2 = scene->frameList[node->frameIndex].lpVtbl;
	uStack20 = 0;
	pIVar3 = pIVar2;
	(**(code **)(pIVar2->QueryInterface + 0x80))(pIVar2,local_4);
	value = (int *)&stack0xfffffff0;
	(**(code **)(pIVar2->QueryInterface + 0x80))(pIVar2,value,local_4);
	(**(code **)*unaff_EDI)(unaff_EDI,&idl::IID_IDirect3DRMUserVisual,&uStack20);
	(**(code **)(pIVar3->QueryInterface + 8))(pIVar3);
	mesh = (Mesh *)(**(code **)(*value + 0x1c))(value);
	(**(code **)(pIVar2->QueryInterface + 8))(pIVar2);
	DVar1 = Mesh_GetGroupCount(mesh);
	groupID = D3DRMGROUP_0;
	if (DVar1 != D3DRMGROUP_0) {
		do {
			Mesh_SetGroupMaterialValues(mesh,groupID,(float)value,MATERIAL_ALPHA);
			groupID = groupID + 1;
		} while (groupID < DVar1);
	}
	return;
}



void __cdecl lego::res::Lws_InterpolateKeys(Lws_Info *scene,Lws_Node *node,ushort key,float delta)
{
	int iVar1;
	Lws_KeyInfo *pLVar2;
	Lws_KeyInfo *pLVar3;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	pLVar3 = node->keyList;
	iVar1 = key + 1;
	pLVar2 = pLVar3 + key;
	local_18.x = (pLVar2->position).x + (pLVar3[iVar1].position.x - (pLVar2->position).x) * delta;
	local_18.y = (pLVar3[iVar1].position.y - (pLVar2->position).y) * delta + (pLVar2->position).y;
	local_18.z = (pLVar3[iVar1].position.z - (pLVar2->position).z) * delta + (pLVar2->position).z;
	local_24.x = (pLVar2->scale).x + (pLVar2[1].scale.x - (pLVar2->scale).x) * delta;
	local_24.y = (pLVar2[1].scale.y - (pLVar2->scale).y) * delta + (pLVar2->scale).y;
	local_24.z = (pLVar2[1].scale.z - (pLVar2->scale).z) * delta + (pLVar2->scale).z;
	local_c.x = (pLVar2->hpb).x + (pLVar2[1].hpb.x - (pLVar2->hpb).x) * delta;
	local_c.y = (pLVar2[1].hpb.y - (pLVar2->hpb).y) * delta + (pLVar2->hpb).y;
	local_c.z = (pLVar2[1].hpb.z - (pLVar2->hpb).z) * delta + (pLVar2->hpb).z;
	Lws_SetupNodeTransform(scene,node,&local_18,&local_c,&local_24);
	return;
}



void __cdecl
lego::res::Lws_SetupNodeTransform
					(Lws_Info *scene,Lws_Node *node,Vector3F *pos,Vector3F *hpb,Vector3F *scale)
{
	float *pfVar1;
	float fVar2;
	Lws_Node *pLVar3;
	float fVar4;
	IDirect3DRMFrame3Vtbl *pIVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	float fVar9;
	float fVar10;
	float10 fVar11;
	float10 fVar12;
	float10 fVar13;
	float10 fVar14;
	float10 fVar15;
	float10 fVar16;
	undefined4 unaff_retaddr;
	float local_48;
	float local_44;
	float local_40;
	float local_3c;
	float local_38;
	undefined4 local_34;
	float local_30;
	float local_2c;
	float local_28;
	undefined4 local_24;
	float local_20;
	float local_1c;
	float local_18;
	undefined4 local_14;
	float local_10;
	int *local_c;
	float local_8;
	undefined4 local_4;
	
	pIVar5 = scene->frameList[node->frameIndex].lpVtbl;
	if ((node->flags & 4) == 0) {
		fVar11 = (float10)fsin((float10)hpb->z);
		fVar12 = (float10)fsin((float10)hpb->y);
		fVar13 = (float10)fcos((float10)hpb->z);
		fVar14 = (float10)fsin((float10)hpb->x);
		fVar6 = (node->pivotVector).x;
		fVar15 = (float10)fcos((float10)hpb->x);
		fVar16 = (float10)fcos((float10)hpb->y);
		local_3c = scale->x * (float)fVar11;
		fVar9 = scale->x * (float)fVar13;
		fVar2 = (float)fVar14;
		pLVar3 = (Lws_Node *)(float)fVar15;
		local_44 = scale->y * (float)fVar13;
		fVar4 = (float)(fVar12 * (float10)local_3c);
		hpb = (Vector3F *)(float)fVar16;
		local_3c = (float)hpb * local_3c;
		local_48 = (float)fVar12 * local_44;
		fVar7 = (node->pivotVector).y;
		fVar8 = (node->pivotVector).z;
		fVar10 = -(scale->y * (float)fVar11);
		local_40 = (float)((float10)fVar2 * (float10)fVar4 + fVar15 * (float10)fVar9);
		local_38 = (float)((float10)(float)pLVar3 * (float10)fVar4 + -(fVar14 * (float10)fVar9));
		pfVar1 = &scale->z;
		scale = (Vector3F *)(scale->z * (float)hpb);
		local_1c = -(*pfVar1 * (float)fVar12);
		local_20 = fVar2 * (float)scale;
		local_18 = (float)pLVar3 * (float)scale;
		local_2c = (float)hpb * local_44;
		local_30 = fVar2 * local_48 + (float)pLVar3 * fVar10;
		local_28 = -(fVar2 * fVar10) + (float)pLVar3 * local_48;
		local_34 = 0;
		local_24 = 0;
		local_10 = fVar7 * local_30 + fVar6 * local_40 + fVar8 * local_20 + pos->x;
		local_c = (int *)(fVar7 * local_2c + fVar6 * local_3c + fVar8 * local_1c + pos->y);
		local_8 = fVar7 * local_28 + fVar6 * local_38 + fVar8 * local_18 + pos->z;
		local_14 = 0;
		local_4 = 0x3f800000;
		node = pLVar3;
	}
	else {
		(**(code **)(pIVar5->QueryInterface + 0x5c))(pIVar5,&node);
		(**(code **)(pIVar5->QueryInterface + 0x74))(pIVar5,unaff_retaddr,&local_48);
		(**(code **)(*local_c + 8))(local_c);
		node = (Lws_Node *)0x0;
		local_40 = local_40 * scale->x;
		local_2c = scale->y * local_2c;
		local_18 = scale->z * local_18;
		local_10 = pos->x;
		local_c = (int *)pos->y;
		local_8 = pos->z;
	}
	(**(code **)(pIVar5->QueryInterface + 0x38))(pIVar5,0,&local_40);
	return;
}



Mesh * __cdecl
lego::res::Lws_LoadMesh(char *baseDir,char *fname,IDirect3DRMFrame3 *frame,BOOL noTextures)
{
	char cVar1;
	Mesh *pMVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	char *pcVar7;
	undefined4 *puVar8;
	char filenameBuffer [260];
	
	if (baseDir == (char *)0x0) {
		uVar3 = 0xffffffff;
		pcVar6 = fname;
		do {
			pcVar7 = pcVar6;
			if (uVar3 == 0) break;
			uVar3 = uVar3 - 1;
			pcVar7 = pcVar6 + 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar7;
		} while (cVar1 != '\0');
		uVar3 = ~uVar3;
		puVar5 = (undefined4 *)(pcVar7 + -uVar3);
		puVar8 = (undefined4 *)filenameBuffer;
		for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
			*puVar8 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar8 = puVar8 + 1;
		}
		for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
			*(undefined *)puVar8 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar8 = (undefined4 *)((int)puVar8 + 1);
		}
	}
	else {
		std::sprintf(filenameBuffer,"%s%s",baseDir,fname);
	}
	pMVar2 = Lws_SearchMeshPathList
										 ((Lws_MeshPath *)&globs::lwsGlobs,globs::lwsGlobs.meshPathCount,filenameBuffer)
	;
	if (pMVar2 != (Mesh *)0x0) {
		Mesh_Clone(pMVar2,frame);
		return pMVar2;
	}
	pMVar2 = Mesh_Load(filenameBuffer,frame,noTextures);
	if (pMVar2 != (Mesh *)0x0) {
		Lws_AddMeshPathEntry
							((Lws_MeshPath *)&globs::lwsGlobs,&globs::lwsGlobs.meshPathCount,filenameBuffer,pMVar2
							);
		return pMVar2;
	}
	if (globs::lwsGlobs.sharedDir != (char *)0x0) {
		std::sprintf(filenameBuffer,"%s%s",globs::lwsGlobs.sharedDir,fname);
		pMVar2 = Lws_SearchMeshPathList
											 (globs::lwsGlobs.meshPathListShared,globs::lwsGlobs.meshPathCountShared,fname
											 );
		if (pMVar2 != (Mesh *)0x0) {
			Mesh_Clone(pMVar2,frame);
			return pMVar2;
		}
		pMVar2 = Mesh_Load(filenameBuffer,frame,noTextures);
		if (pMVar2 != (Mesh *)0x0) {
			Lws_AddMeshPathEntry
								(globs::lwsGlobs.meshPathListShared,&globs::lwsGlobs.meshPathCountShared,fname,
								 pMVar2);
			return pMVar2;
		}
	}
	return (Mesh *)0x0;
}



Mesh * __cdecl lego::res::Lws_SearchMeshPathList(Lws_MeshPath *list,uint count,char *path)
{
	uint uVar1;
	int iVar2;
	uint uVar3;
	
	uVar3 = 0;
	if (count == 0) {
		return (Mesh *)0x0;
	}
	uVar1 = 0;
	do {
		iVar2 = std::_stricmp(path,list[uVar1].path);
		if (iVar2 == 0) {
			return list[uVar3 & 0xffff].mesh;
		}
		uVar3 = uVar3 + 1;
		uVar1 = uVar3 & 0xffff;
	} while (uVar1 < count);
	return (Mesh *)0x0;
}



void __cdecl
lego::res::Lws_AddMeshPathEntry(Lws_MeshPath *ref_list,uint *ref_count,char *path,Mesh *mesh)
{
	char *pcVar1;
	
	pcVar1 = std::_strdup(path);
	ref_list[*ref_count].path = pcVar1;
	ref_list[*ref_count].mesh = mesh;
	*ref_count = *ref_count + 1;
	return;
}



// WARNING: Type propagation algorithm not settling

void __cdecl
lego::res::Lws_CreateFrames
					(Lws_Info *scene,Lws_Node *node,IDirect3DRMFrame3 *parent,ushort *ref_frameCount)
{
	byte *pbVar1;
	Lws_Node *node_00;
	uint uVar2;
	int iVar3;
	IDirect3DRMFrame3 *unaff_EBP;
	byte *pbVar4;
	undefined4 *puVar5;
	IDirect3DRMFrame3 local_444;
	undefined4 auStack1088 [5];
	undefined4 uStack1068;
	undefined4 uStack1048;
	undefined4 uStack1040;
	undefined4 uStack1036;
	undefined4 uStack1032;
	undefined4 uStack1028;
	byte abStack1024 [1024];
	
	(*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
						(globs::mainGlobs.lpD3DRM,parent,(IDirect3DRMFrame3 **)&local_444);
	if ((node->flags & 4) != 0) {
		puVar5 = auStack1088;
		for (iVar3 = 0x10; iVar3 != 0; iVar3 = iVar3 + -1) {
			*puVar5 = 0;
			puVar5 = puVar5 + 1;
		}
		uStack1032 = 0;
		uStack1036 = 0;
		uStack1040 = 0;
		uStack1028 = 0x3f800000;
		uStack1048 = 0x3f800000;
		uStack1068 = 0x3f800000;
		auStack1088[0] = 0x3f800000;
		(**(code **)(*(int *)local_444 + 0x38))(local_444,0,auStack1088);
	}
	scene->frameList[*ref_frameCount].lpVtbl = local_444;
	node->frameIndex = *ref_frameCount;
	*ref_frameCount = *ref_frameCount + 1;
	std::sprintf((char *)abStack1024,"%s_%0.2i",node->name,(uint)node->reference);
	pbVar4 = abStack1024;
	while (abStack1024[0] != 0) {
										// int std::isgraph(int c)
										//  (or close enough to this?)
		if (std::globals::_pcharwidth < 2) {
										// C1_ALPHA | C1_BLANK | C1_PUNCT | C1_DIGIT | C1_LOWER | C1_UPPER (0x100 | 0x40
										// | 0x10 | 0x4 | 0x2 | 0x1)
			uVar2 = std::globals::_pctype[*pbVar4] & 0x157;
		}
		else {
			uVar2 = std::_isctype((uint)*pbVar4,0x157);
		}
		if (uVar2 == 0) {
			*pbVar4 = 0x5f;
		}
		pbVar1 = pbVar4 + 1;
		pbVar4 = pbVar4 + 1;
		abStack1024[0] = *pbVar1;
	}
	(**(code **)(*(int *)local_444 + 0x20))(local_444,abStack1024);
	for (node_00 = node->childList; node_00 != (Lws_Node *)0x0; node_00 = node_00->next) {
		Lws_CreateFrames(scene,node_00,unaff_EBP,ref_frameCount);
	}
	return;
}



void __cdecl lego::res::Lws_LoadNodes(Lws_Info *scene,Lws_Node *node)
{
	IDirect3DRMFrame3Vtbl *frame;
	Lws_Node *node_00;
	Mesh *pMVar1;
	
	frame = scene->frameList[node->frameIndex].lpVtbl;
	if (node->keyCount == 1) {
		Lws_SetAbsoluteKey(scene,node,0);
	}
	if (((node->flags & 1) == 0) &&
		 (pMVar1 = Lws_LoadMesh(scene->filePath,node->name,(IDirect3DRMFrame3 *)frame,0),
		 pMVar1 != (Mesh *)0x0)) {
		if ((node->flags & 4) != 0) {
			pMVar1->flags = pMVar1->flags | 0x1000000;
		}
		if ((node->dissolveLevel != (float *)0x0) && (node->dissolveCount == 0)) {
			Lws_SetDissolveLevel(scene,node,*node->dissolveLevel);
			node->dissolveLevel = (float *)0x0;
		}
	}
	for (node_00 = node->childList; node_00 != (Lws_Node *)0x0; node_00 = node_00->next) {
		Lws_LoadNodes(scene,node_00);
	}
	return;
}



void __cdecl lego::res::Lws_SetAbsoluteKey(Lws_Info *scene,Lws_Node *node,ushort key)
{
	Lws_KeyInfo *pos;
	
	pos = node->keyList + key;
	Lws_SetupNodeTransform(scene,node,(Vector3F *)pos,&pos->hpb,&pos->scale);
	return;
}



void __cdecl lego::res::Lws_Free(Lws_Info *scene)
{
	Lws_Info *pLVar1;
	uint uVar2;
	ushort uVar3;
	
	do {
		pLVar1 = scene->clonedFrom;
		uVar2 = scene->referenceCount - 1;
		scene->referenceCount = uVar2;
		if (uVar2 == 0) {
			uVar3 = 0;
			if (scene->nodeCount != 0) {
				do {
					Lws_FreeNode(scene,scene->nodeList + uVar3);
					uVar3 = uVar3 + 1;
				} while (uVar3 < scene->nodeCount);
			}
			if (scene->clonedFrom == (Lws_Info *)0x0) {
				std::free(scene->nodeList);
				std::free(scene->filePath);
				if (scene->triggerCount != 0) {
					std::free(scene->triggerList);
				}
			}
			std::free(scene->frameList);
			std::free(scene);
		}
		scene = pLVar1;
	} while (pLVar1 != (Lws_Info *)0x0);
	return;
}



void __cdecl lego::res::Lws_FreeNode(Lws_Info *scene,Lws_Node *node)
{
	Mesh *mesh;
	code **unaff_EDI;
	IDirect3DRMFrame3Vtbl *pIVar1;
	int *piVar2;
	IDirect3DRMFrame3Vtbl *pIVar3;
	undefined local_4 [4];
	
	if ((node->flags & 1) == 0) {
		pIVar1 = scene->frameList[node->frameIndex].lpVtbl;
		pIVar3 = pIVar1;
		(**(code **)(pIVar1->QueryInterface + 0x80))(pIVar1,local_4);
		piVar2 = (int *)&stack0xfffffff0;
		(**(code **)(pIVar1->QueryInterface + 0x80))(pIVar1,piVar2,local_4);
		(**(code **)*unaff_EDI)(unaff_EDI,&idl::IID_IDirect3DRMUserVisual,&stack0xffffffec);
		(**(code **)(pIVar3->QueryInterface + 8))(pIVar3);
		mesh = (Mesh *)(**(code **)(*piVar2 + 0x1c))(piVar2);
		(**(code **)(pIVar1->QueryInterface + 8))(pIVar1);
		Mesh_Remove(mesh,(IDirect3DRMFrame3 *)scene->frameList[node->frameIndex].lpVtbl);
	}
	if ((scene->clonedFrom == (Lws_Info *)0x0) && (scene->referenceCount == 0)) {
		std::free(node->name);
		std::free(node->keyList);
		if (node->dissolveCount != 0) {
			std::free(node->dissolveLevel);
			std::free(node->dissolveFrame);
		}
	}
	return;
}



BOOL __cdecl lego::snd::Sound_Initialise(BOOL nosound)
{
	BOOL BVar1;
	
	globs::soundGlobs.initialised = ZEXT14(nosound == 0);
	globs::soundGlobs.loopCDTrack = -1;
	if (nosound != 0) {
		globs::soundGlobs.loopCDTrack = -1;
		return 1;
	}
	BVar1 = Sound3D_Initialise(globs::mainGlobs.hWnd);
	return (uint)(BVar1 != 0);
}



BOOL __cdecl lego::snd::Sound_IsInitialised(void)
{
	if ((globs::soundGlobs.initialised != 0) && (globs::sound3DGlobs.intialised != 0)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::snd::Sound_PlayCDTrack(uint track,uint mode,CDStopCallback *stopCallback)
{
	BOOL BVar1;
	
	BVar1 = globs::soundGlobs.initialised;
	if (globs::soundGlobs.initialised != 0) {
		if (mode == 1) {
			globs::soundGlobs.loopCDTrack = 1;
		}
		globs::soundGlobs.currTrack = track;
		globs::soundGlobs.CDStopCallback = stopCallback;
		BVar1 = Play_CDTrack(track);
	}
	return BVar1;
}



BOOL __cdecl lego::snd::Sound_StopCD(void)
{
	BOOL BVar1;
	
	if (globs::soundGlobs.initialised != 0) {
		BVar1 = Stop_CDTrack();
		return BVar1;
	}
	return 0;
}



void __cdecl lego::snd::Sound_Update(BOOL cdtrack)
{
	uint uVar1;
	DWORD DVar2;
	BOOL BVar3;
	
	uVar1 = globs::soundGlobs.s_Update_lastUpdate;
	if ((((globs::soundGlobs.initialised != 0) &&
			 (DVar2 = timeGetTime(), uVar1 = globs::soundGlobs.s_Update_lastUpdate,
			 globs::soundGlobs.s_Update_lastUpdate + 4000 < DVar2)) && (uVar1 = DVar2, cdtrack != 0)) &&
		 (BVar3 = Status_CDTrack(globs::soundGlobs.currTrack), BVar3 == 0)) {
		if (globs::soundGlobs.loopCDTrack != 0) {
			Restart_CDTrack(globs::soundGlobs.currTrack);
		}
		if (globs::soundGlobs.CDStopCallback != (CDStopCallback *)0x0) {
			(*globs::soundGlobs.CDStopCallback)();
		}
	}
	globs::soundGlobs.s_Update_lastUpdate = uVar1;
	return;
}



// WARNING: Could not reconcile some variable overlaps
// This function will open a wave input file and prepare it for reading,
// so the data can be easily
// read with WaveReadFile. Returns 0 if successful, the error code if not.
//     pszFileName - Input filename to load.
//     phmmioIn    - Pointer to handle which will be used
//         for further mmio routines.
//     ppwfxInfo   - Ptr to ptr to WaveFormatEx structure
//         with all info about the file. 

int __cdecl
lego::snd::WaveOpenFile
					(void *fileData,uint fileSize,HMMIO *out_phmmioIn,WAVEFORMATEX **out_ppwfxInfo,
					MMCKINFO *out_pckInRIFF)
{
	WAVEFORMATEX **ppWVar1;
	MMCKINFO *pmmckiParent;
	HMMIO hmmio;
	LONG LVar2;
	WAVEFORMATEX *pWVar3;
	uint uVar4;
	int iVar5;
	MMRESULT MVar6;
	_MMIOINFO *p_Var7;
	undefined4 local_6c;
	DWORD local_68;
	DWORD local_64;
	undefined4 local_60;
	_MMCKINFO local_5c;
	_MMIOINFO local_48;
	
	*out_ppwfxInfo = (WAVEFORMATEX *)0x0;
	p_Var7 = &local_48;
	for (iVar5 = 0x12; iVar5 != 0; iVar5 = iVar5 + -1) {
		p_Var7->dwFlags = 0;
		p_Var7 = (_MMIOINFO *)&p_Var7->fccIOProc;
	}
										// "MEM "
	local_48.fccIOProc = 0x204d454d;
	local_48.pchBuffer = (HPSTR)fileData;
	local_48.cchBuffer = fileSize;
	hmmio = mmioOpenA((LPSTR)0x0,(LPMMIOINFO)&local_48,0x10000);
	pmmckiParent = out_pckInRIFF;
	if (hmmio == (HMMIO)0x0) {
		MVar6 = 0xe100;
	}
	else {
		MVar6 = mmioDescend(hmmio,(LPMMCKINFO)out_pckInRIFF,(MMCKINFO *)0x0,0);
		if (MVar6 == 0) {
			if ((pmmckiParent->ckid == 0x46464952) && (pmmckiParent->fccType == 0x45564157)) {
				local_5c.ckid = 0x20746d66;
				MVar6 = mmioDescend(hmmio,(LPMMCKINFO)&local_5c,pmmckiParent,0x10);
				if (MVar6 != 0) goto LAB_004890e9;
				if (0xf < local_5c.cksize) {
					LVar2 = mmioRead(hmmio,(HPSTR)&local_6c,0x10);
					if (LVar2 != 0x10) {
						MVar6 = 0xe102;
						goto LAB_004890e9;
					}
					if ((short)local_6c == 1) {
						fileData = (void *)0x0;
					}
					else {
						LVar2 = mmioRead(hmmio,(HPSTR)&fileData,2);
						if (LVar2 != 2) {
							MVar6 = 0xe102;
							goto LAB_004890e9;
						}
					}
					pWVar3 = (WAVEFORMATEX *)GlobalAlloc(0,((uint)fileData & 0xffff) + 0x12);
					*out_ppwfxInfo = pWVar3;
					if (pWVar3 == (WAVEFORMATEX *)0x0) {
						MVar6 = 0xe000;
						goto LAB_004890e9;
					}
					*(undefined4 *)pWVar3 = local_6c;
					pWVar3->nSamplesPerSec = local_68;
					pWVar3->nAvgBytesPerSec = local_64;
					*(undefined4 *)&pWVar3->nBlockAlign = local_60;
					(*out_ppwfxInfo)->cbSize = (WORD)fileData;
					if (((WORD)fileData == 0) ||
						 (uVar4 = mmioRead(hmmio,(HPSTR)(*out_ppwfxInfo + 1),(uint)fileData & 0xffff),
						 uVar4 == ((uint)fileData & 0xffff))) {
						MVar6 = mmioAscend(hmmio,(LPMMCKINFO)&local_5c,0);
						if (MVar6 == 0) {
							*out_phmmioIn = hmmio;
							return 0;
						}
						goto LAB_004890e9;
					}
				}
			}
			MVar6 = 0xe101;
		}
	}
LAB_004890e9:
	ppWVar1 = out_ppwfxInfo;
	if (*out_ppwfxInfo != (WAVEFORMATEX *)0x0) {
		GlobalFree(*out_ppwfxInfo);
		*ppWVar1 = (WAVEFORMATEX *)0x0;
	}
	if (hmmio != (HMMIO)0x0) {
		mmioClose(hmmio,0);
		hmmio = (HMMIO)0x0;
	}
	*out_phmmioIn = hmmio;
	return MVar6;
}



uint __cdecl lego::snd::GetWaveAvgBytesPerSec(char *pszFileName)
{
	HMMIO hmmio;
	MMRESULT MVar1;
	LONG LVar2;
	uint uVar3;
	PCMWAVEFORMAT local_38;
	_MMCKINFO local_28;
	_MMCKINFO local_14;
	
	uVar3 = 0;
	hmmio = mmioOpenA(pszFileName,(LPMMIOINFO)0x0,0);
	if (hmmio != (HMMIO)0x0) {
		MVar1 = mmioDescend(hmmio,(LPMMCKINFO)&local_28,(MMCKINFO *)0x0,0);
										// "RIFF", "WAVE"
		if (((MVar1 == 0) && (local_28.ckid == 1179011410)) && (local_28.fccType == 1163280727)) {
										// "fmt "
			local_14.ckid = 544501094;
			MVar1 = mmioDescend(hmmio,(LPMMCKINFO)&local_14,(MMCKINFO *)&local_28,0x10);
			if ((MVar1 == 0) && (0xf < local_14.cksize)) {
				LVar2 = mmioRead(hmmio,(HPSTR)&local_38,0x10);
				if (LVar2 == 0x10) {
					uVar3 = local_38.wf.nAvgBytesPerSec;
				}
			}
		}
		if (hmmio != (HMMIO)0x0) {
			mmioClose(hmmio,0);
		}
	}
	return uVar3;
}



// WARNING: Could not reconcile some variable overlaps

int __cdecl
lego::snd::WaveOpenFile2
					(char *pszFileName,HMMIO *out_phmmioIn,WAVEFORMATEX **out_ppwfxInfo,
					MMCKINFO *out_pckInRIFF)
{
	WAVEFORMATEX **ppWVar1;
	MMCKINFO *pmmckiParent;
	HMMIO hmmio;
	LONG LVar2;
	WAVEFORMATEX *pWVar3;
	uint uVar4;
	MMRESULT MVar5;
	undefined4 local_24;
	DWORD local_20;
	DWORD local_1c;
	undefined4 local_18;
	_MMCKINFO local_14;
	
	*out_ppwfxInfo = (WAVEFORMATEX *)0x0;
	hmmio = mmioOpenA(pszFileName,(LPMMIOINFO)0x0,0x10000);
	pmmckiParent = out_pckInRIFF;
	if (hmmio == (HMMIO)0x0) {
		MVar5 = 0xe100;
	}
	else {
		MVar5 = mmioDescend(hmmio,(LPMMCKINFO)out_pckInRIFF,(MMCKINFO *)0x0,0);
		if (MVar5 == 0) {
			if ((pmmckiParent->ckid == 1179011410) && (pmmckiParent->fccType == 1163280727)) {
				local_14.ckid = 544501094;
				MVar5 = mmioDescend(hmmio,(LPMMCKINFO)&local_14,pmmckiParent,0x10);
				if (MVar5 != 0) goto LAB_00489343;
				if (0xf < local_14.cksize) {
					LVar2 = mmioRead(hmmio,(HPSTR)&local_24,0x10);
					if (LVar2 != 0x10) {
						MVar5 = 0xe102;
						goto LAB_00489343;
					}
					if ((short)local_24 == 1) {
						pszFileName = (char *)0x0;
					}
					else {
						LVar2 = mmioRead(hmmio,(HPSTR)&pszFileName,2);
						if (LVar2 != 2) {
							MVar5 = 0xe102;
							goto LAB_00489343;
						}
					}
					pWVar3 = (WAVEFORMATEX *)GlobalAlloc(0,((uint)pszFileName & 0xffff) + 0x12);
					*out_ppwfxInfo = pWVar3;
					if (pWVar3 == (WAVEFORMATEX *)0x0) {
						MVar5 = 0xe000;
						goto LAB_00489343;
					}
					*(undefined4 *)pWVar3 = local_24;
					pWVar3->nSamplesPerSec = local_20;
					pWVar3->nAvgBytesPerSec = local_1c;
					*(undefined4 *)&pWVar3->nBlockAlign = local_18;
					(*out_ppwfxInfo)->cbSize = (WORD)pszFileName;
					if (((WORD)pszFileName == 0) ||
						 (uVar4 = mmioRead(hmmio,(HPSTR)(*out_ppwfxInfo + 1),(uint)pszFileName & 0xffff),
						 uVar4 == ((uint)pszFileName & 0xffff))) {
						MVar5 = mmioAscend(hmmio,(LPMMCKINFO)&local_14,0);
						if (MVar5 == 0) {
							*out_phmmioIn = hmmio;
							return 0;
						}
						goto LAB_00489343;
					}
				}
			}
			MVar5 = 0xe101;
		}
	}
LAB_00489343:
	ppWVar1 = out_ppwfxInfo;
	if (*out_ppwfxInfo != (WAVEFORMATEX *)0x0) {
		GlobalFree(*out_ppwfxInfo);
		*ppWVar1 = (WAVEFORMATEX *)0x0;
	}
	if (hmmio != (HMMIO)0x0) {
		mmioClose(hmmio,0);
		hmmio = (HMMIO)0x0;
	}
	*out_phmmioIn = hmmio;
	return MVar5;
}



// This routine has to be called before WaveReadFile as it searchs for the chunk to descend into for
// reading, that is, the 'data' chunk.  For simplicity, this used to be in the open routine, but was
// taken out and moved to a separate routine so there was more control on the chunks that are before
// the data chunk, such as 'fact', etc...

int __cdecl lego::snd::WaveStartDataRead(HMMIO *phmmioIn,MMCKINFO *pckIn,MMCKINFO *pckInRIFF)
{
	MMRESULT MVar1;
	
	mmioSeek(*phmmioIn,pckInRIFF->dwDataOffset + 4,0);
	pckIn->ckid = 1635017060;
	MVar1 = mmioDescend(*phmmioIn,(LPMMCKINFO)pckIn,pckInRIFF,0x10);
	return MVar1;
}



// This will read wave data from the wave file.  Makre sure we're descended into
// the data chunk, else this will fail bigtime!
// hmmioIn         - Handle to mmio.
// cbRead          - # of bytes to read.   
// pbDest          - Destination buffer to put bytes.
// cbActualRead- # of bytes actually read.

int __cdecl
lego::snd::WaveReadFile(HMMIO hmmioIn,uint cbRead,byte *pbDest,MMCKINFO *pckIn,uint *cbActualRead)
{
	byte bVar1;
	MMRESULT MVar2;
	uint uVar3;
	byte *pbVar4;
	uint uVar5;
	_MMIOINFO local_48;
	
	MVar2 = mmioGetInfo(hmmioIn,(LPMMIOINFO)&local_48,0);
	uVar3 = (uint)(MVar2 != 0);
	if (uVar3 == 0) {
		uVar3 = pckIn->cksize;
		if (uVar3 < cbRead) {
			cbRead = uVar3;
		}
		uVar5 = 0;
		pckIn->cksize = uVar3 - cbRead;
		pbVar4 = (byte *)local_48.pchEndRead;
		if (cbRead != 0) {
			do {
				if ((byte *)local_48.pchNext == pbVar4) {
					uVar3 = mmioAdvance(hmmioIn,(LPMMIOINFO)&local_48,0);
					if (uVar3 != 0) goto LAB_00489456;
					pbVar4 = (byte *)local_48.pchEndRead;
					if (local_48.pchNext == local_48.pchEndRead) {
						*cbActualRead = 0;
						return 0xe103;
					}
				}
				bVar1 = *local_48.pchNext;
				local_48.pchNext = (HPSTR)((byte *)local_48.pchNext + 1);
				pbDest[uVar5] = bVar1;
				uVar5 = uVar5 + 1;
			} while (uVar5 < cbRead);
		}
		uVar3 = mmioSetInfo(hmmioIn,(LPCMMIOINFO)&local_48,0);
		if (uVar3 == 0) {
			*cbActualRead = cbRead;
			return 0;
		}
	}
LAB_00489456:
	*cbActualRead = 0;
	return uVar3;
}



// This will close the wave file openned with WaveOpenFile.  
// phmmioIn - Pointer to the handle to input MMIO.
// ppwfxSrc - Pointer to pointer to WaveFormatEx structure.
// 
// Returns 0 if successful, non-zero if there was a warning.

int __cdecl lego::snd::WaveCloseReadFile(HMMIO *phmmio,WAVEFORMATEX **ppwfxSrc)
{
	if (*ppwfxSrc != (WAVEFORMATEX *)0x0) {
		GlobalFree(*ppwfxSrc);
		*ppwfxSrc = (WAVEFORMATEX *)0x0;
	}
	if (*phmmio != (HMMIO)0x0) {
		mmioClose(*phmmio,0);
		*phmmio = (HMMIO)0x0;
	}
	return 0;
}



BOOL __cdecl lego::snd::Restart_CDTrack(int track)
{
	CHAR local_64 [100];
	
	wsprintfA(local_64,"play cdaudio from %i",track + 1);
	globs::soundGlobs.mciErr = mciSendStringA(local_64,globs::mciReturn,200,(HWND)0x0);
	if (globs::soundGlobs.mciErr != 0) {
		ReportCDError();
		return 0;
	}
	return TRUE;
}



void __cdecl lego::snd::ReportCDError(void)
{
	mciGetErrorStringA(globs::soundGlobs.mciErr,globs::mciReturn,200);
	return;
}



BOOL __cdecl lego::snd::Status_CDTrack(int track)
{
	int iVar1;
	char buff [100];
	
	std::sprintf(buff,"status cdaudio mode");
	globs::soundGlobs.mciErr = mciSendStringA(buff,globs::mciReturn,200,(HWND)0x0);
	iVar1 = std::_stricmp(globs::mciReturn,"stopped");
	if (iVar1 != 0) {
		std::sprintf(buff,"status cdaudio current track");
		globs::soundGlobs.mciErr = mciSendStringA(buff,globs::mciReturn,200,(HWND)0x0);
		iVar1 = std::atoi(globs::mciReturn);
		if (iVar1 <= track + 1) {
			return 1;
		}
	}
	ReportCDError();
	return 0;
}



BOOL __cdecl lego::snd::Play_CDTrack(int track)
{
	globs::soundGlobs.mciErr = mciSendStringA("open cdaudio",globs::mciReturn,200,(HWND)0x0);
	if (globs::soundGlobs.mciErr == 0) {
		globs::soundGlobs.mciErr =
				 mciSendStringA("set cdaudio time format tmsf",globs::mciReturn,200,(HWND)0x0);
		if (globs::soundGlobs.mciErr == 0) {
			Restart_CDTrack(track);
			if (globs::soundGlobs.mciErr == 0) {
				return 1;
			}
		}
	}
	ReportCDError();
	return 0;
}



BOOL __cdecl lego::snd::Stop_CDTrack(void)
{
	globs::soundGlobs.mciErr = mciSendStringA("stop cdaudio",globs::mciReturn,200,(HWND)0x0);
	if (globs::soundGlobs.mciErr == 0) {
		globs::soundGlobs.mciErr = mciSendStringA("close cdaudio",globs::mciReturn,200,(HWND)0x0);
		if (globs::soundGlobs.mciErr == 0) {
			return TRUE;
		}
	}
	ReportCDError();
	return 0;
}



void __cdecl lego::file::Mem_Initialise(void)
{
	MemHandleFlags *pMVar1;
	
	pMVar1 = &globs::memGlobs.handleList[0].flags;
	do {
		pMVar1[-1] = MEMORY_HANDLE_FLAG_NONE;
		*pMVar1 = MEMORY_HANDLE_FLAG_NONE;
		pMVar1 = pMVar1 + 2;
	} while (pMVar1 < &DAT_005498a4);
	return;
}



uint __cdecl lego::file::Mem_AllocHandle(uint size)
{
	MemHandleFlags *pMVar1;
	void *pvVar2;
	uint uVar3;
	
	uVar3 = 0;
	pMVar1 = &globs::memGlobs.handleList[0].flags;
	do {
		if ((*(byte *)pMVar1 & MEMORY_HANDLE_FLAG_USED) == 0) {
			pvVar2 = std::malloc(size);
			globs::memGlobs.handleList[uVar3].addr = pvVar2;
			globs::memGlobs.handleList[uVar3].flags = globs::memGlobs.handleList[uVar3].flags | 1;
			return uVar3;
		}
		pMVar1 = pMVar1 + 2;
		uVar3 = uVar3 + 1;
	} while (pMVar1 < &DAT_005498a4);
	return 0xffffffff;
}



void __cdecl lego::file::Mem_FreeHandle(uint handle)
{
	if ((handle < 2000) && ((*(byte *)&globs::memGlobs.handleList[handle].flags & 1) != 0)) {
		std::free(globs::memGlobs.handleList[handle].addr);
		globs::memGlobs.handleList[handle].addr = (void *)0x0;
		globs::memGlobs.handleList[handle].flags = MEMORY_HANDLE_FLAG_NONE;
	}
	return;
}



void * __cdecl lego::file::Mem_AddressHandle(uint handle)
{
	if ((handle < 2000) && ((*(byte *)&globs::memGlobs.handleList[handle].flags & 1) != 0)) {
		return globs::memGlobs.handleList[handle].addr;
	}
	return (void *)0x0;
}



int * __cdecl
lego::res::UNK_Material_Create
					(float emissiveRed,float emissiveGreen,float emissiveBlue,float param_4,undefined4 param_5
					,undefined4 param_6,undefined4 param_7)
{
	int iVar1;
	int *unaff_retaddr;
	int *piVar2;
	IDirect3DRM3 *pIVar3;
	undefined4 uVar4;
	undefined4 *puVar5;
	
	puVar5 = &param_7;
	pIVar3 = globs::mainGlobs.lpD3DRM;
	uVar4 = param_7;
	iVar1 = (*(code *)(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateMaterial)
										(globs::mainGlobs.lpD3DRM,param_7,puVar5);
	if (iVar1 == 0) {
		piVar2 = unaff_retaddr;
		(**(code **)(*(int *)param_4 + 0x34))(param_4,uVar4,puVar5);
		(**(code **)(*unaff_retaddr + 0x30))(unaff_retaddr,pIVar3,uVar4,puVar5);
		return piVar2;
	}
	return (int *)0x0;
}



AnimClone * __cdecl
lego::res::AnimClone_Register
					(IDirect3DRMAnimationSet2 *rmAnimSet2,IDirect3DRMFrame3 *rmFrame3,int field1c)
{
	uint *puVar1;
	AnimClone *actFrame;
	AnimClone dummyActFrame;
	
	actFrame = (AnimClone *)std::malloc(0x20);
	actFrame->clonedFrom = (AnimClone *)0x0;
	actFrame->animSet = rmAnimSet2;
	actFrame->scene = (Lws_Info *)0x0;
	actFrame->lws = 0;
	actFrame->root = rmFrame3;
	(*rmFrame3->lpVtbl->AddRef)((IUnknown *)rmFrame3);
	puVar1 = &actFrame->partCount;
	*puVar1 = 0;
	actFrame->frameCount = (uint)rmFrame3;
	AnimClone_WalkTree(rmFrame3,0,AnimClone_FrameCountCallback,puVar1);
	dummyActFrame.root = (IDirect3DRMFrame3 *)std::malloc(*puVar1 << 2);
	actFrame->partArray = (IDirect3DRMFrame3 **)dummyActFrame.root;
	dummyActFrame.partArray = (IDirect3DRMFrame3 **)0x0;
	AnimClone_WalkTree(rmFrame3,0,AnimClone_SetupFrameArrayCallback,&stack0xffffffdc);
	return actFrame;
}



AnimClone * __cdecl
lego::res::AnimClone_RegisterLws(void *struct38,IDirect3DRMFrame3 *rmFrame3,undefined4 field1c)
{
	uint *puVar1;
	AnimClone *pAVar2;
	AnimClone dummyActFrame;
	
	pAVar2 = (AnimClone *)std::malloc(0x20);
	pAVar2->clonedFrom = (AnimClone *)0x0;
	pAVar2->animSet = (IDirect3DRMAnimationSet2 *)0x0;
	pAVar2->scene = (Lws_Info *)struct38;
	pAVar2->lws = 1;
	pAVar2->root = rmFrame3;
	(*rmFrame3->lpVtbl->AddRef)((IUnknown *)rmFrame3);
	puVar1 = &pAVar2->partCount;
	*puVar1 = 0;
	pAVar2->frameCount = (uint)rmFrame3;
	AnimClone_WalkTree(rmFrame3,0,AnimClone_FrameCountCallback,puVar1);
	dummyActFrame.root = (IDirect3DRMFrame3 *)std::malloc(*puVar1 << 2);
	pAVar2->partArray = (IDirect3DRMFrame3 **)dummyActFrame.root;
	dummyActFrame.partArray = (IDirect3DRMFrame3 **)0x0;
	AnimClone_WalkTree(rmFrame3,0,AnimClone_SetupFrameArrayCallback,&stack0xffffffdc);
	return pAVar2;
}



AnimClone * __cdecl
lego::res::AnimClone_Make(AnimClone *lastActFrameRes,IDirect3DRMFrame3 *parent,uint *out_frameCount)
{
	IDirect3DRMFrame3 **lplpD3DRMFrame;
	AnimClone *pAVar1;
	Lws_Info *pLVar2;
	IDirect3DRMFrame3 **ppIVar3;
	int iVar4;
	AnimClone *pAVar5;
	AnimClone *pAVar6;
	uint *unaff_retaddr;
	IDirect3DRMFrame3 **ppIStack24;
	undefined4 uStack20;
	
	pAVar1 = (AnimClone *)std::malloc(0x20);
	iVar4 = 8;
	pAVar5 = lastActFrameRes;
	pAVar6 = pAVar1;
	if (lastActFrameRes->lws == 0) {
		for (; iVar4 != 0; iVar4 = iVar4 + -1) {
			pAVar6->clonedFrom = (AnimClone *)0x0;
			pAVar6 = (AnimClone *)&pAVar6->scene;
		}
										// IDirect3DRMAnimationSet2->SetTime(IDirect3DRMAnimationSet2* this, float
										// rvTime)
		(*(code *)lastActFrameRes->animSet->lpVtbl->SetTime)(lastActFrameRes->animSet,0.0);
		pAVar1->animSet = (IDirect3DRMAnimationSet2 *)0x0;
		pAVar1->clonedFrom = lastActFrameRes;
		lplpD3DRMFrame = &pAVar1->root;
										// IDirect3DRM3->CreateFrame(this, IDirect3DRMFrame3* lpD3DRMFrame,
										// IDirect3DRMFrame3** lplpD3DRMFrame)
		(*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
							(globs::mainGlobs.lpD3DRM,parent,lplpD3DRMFrame);
		ppIVar3 = (IDirect3DRMFrame3 **)std::malloc(lastActFrameRes->partCount << 2);
		pAVar1->partArray = ppIVar3;
		AnimClone_CreateCopy(lastActFrameRes->root,(int *)*lplpD3DRMFrame,lastActFrameRes->lws);
		pAVar1->partCount = lastActFrameRes->partCount;
		if (unaff_retaddr != (uint *)0x0) {
			*unaff_retaddr = lastActFrameRes->frameCount;
		}
		ppIStack24 = pAVar1->partArray;
		uStack20 = 0;
		AnimClone_WalkTree(*lplpD3DRMFrame,0,AnimClone_SetupFrameArrayCallback,&stack0xffffffd4);
	}
	else {
		for (; iVar4 != 0; iVar4 = iVar4 + -1) {
			pAVar6->clonedFrom = pAVar5->clonedFrom;
			pAVar5 = (AnimClone *)&pAVar5->scene;
			pAVar6 = (AnimClone *)&pAVar6->scene;
		}
		pLVar2 = Lws_Clone(lastActFrameRes->scene,parent);
		pAVar1->scene = pLVar2;
		pAVar1->clonedFrom = (AnimClone *)0x0;
		if (out_frameCount != (uint *)0x0) {
			*out_frameCount = lastActFrameRes->frameCount;
			return pAVar1;
		}
	}
	return pAVar1;
}



void __cdecl lego::res::AnimClone_Remove(AnimClone *actFrameRes)
{
	uint uVar1;
	
	if (actFrameRes != (AnimClone *)0x0) {
		if (actFrameRes->clonedFrom == (AnimClone *)0x0) {
			if (actFrameRes->lws == 0) {
				(*actFrameRes->animSet->lpVtbl->Release)((IUnknown *)actFrameRes->animSet);
				(*actFrameRes->root->lpVtbl->Release)((IUnknown *)actFrameRes->root);
			}
			else {
				Lws_Free(actFrameRes->scene);
			}
		}
		if (actFrameRes->lws == 0) {
			uVar1 = 0;
			if (actFrameRes->partCount != 0) {
				do {
					(*actFrameRes->partArray[uVar1]->lpVtbl->Release)
										((IUnknown *)actFrameRes->partArray[uVar1]);
					uVar1 = uVar1 + 1;
				} while (uVar1 < actFrameRes->partCount);
			}
			std::free(actFrameRes->partArray);
		}
		std::free(actFrameRes);
	}
	return;
}



// This function seems to double as lego::image::Flic_GetWidth (ImageFlic->dwWidth 0xc)

BOOL __cdecl lego::res::AnimClone_IsLws(AnimClone *clone)
{
	return clone->lws;
}



void __cdecl lego::res::AnimClone_SetTime(AnimClone *clone,float time,float *out_oldTime)
{
	AnimClone *pAVar1;
	uint uVar2;
	Matrix4F local_40;
	
	pAVar1 = clone->clonedFrom;
	if (pAVar1 == (AnimClone *)0x0) {
		if (clone->lws != 0) {
			Lws_SetTime(clone->scene,time);
			return;
		}
		(*(code *)clone->animSet->lpVtbl->SetTime)(clone->animSet,time);
	}
	else {
		if (pAVar1->lws == 0) {
			(*(code *)pAVar1->animSet->lpVtbl->SetTime)(pAVar1->animSet,time);
		}
		else {
			Lws_SetTime(pAVar1->scene,time);
		}
		uVar2 = 0;
		if (clone->partCount != 0) {
			do {
				(*pAVar1->partArray[uVar2]->lpVtbl->GetParent)
									(pAVar1->partArray[uVar2],(IDirect3DRMFrame3 **)&time);
				(*pAVar1->partArray[uVar2]->lpVtbl->GetTransform)
									(pAVar1->partArray[uVar2],(IDirect3DRMFrame3 *)time,&local_40);
				(**(code **)((int)*(IDirect3DRMFrame3 *)time + 8))((IUnknown *)time);
				(*clone->partArray[uVar2]->lpVtbl->AddTransform)
									(clone->partArray[uVar2],D3DRMCOMBINE_REPLACE,&local_40);
				uVar2 = uVar2 + 1;
			} while (uVar2 < clone->partCount);
		}
		if (out_oldTime != (float *)0x0) {
			if (pAVar1->lws != 0) {
				Lws_SetTime(pAVar1->scene,*out_oldTime);
				return;
			}
			(*(code *)pAVar1->animSet->lpVtbl->SetTime)(pAVar1->animSet,*out_oldTime);
			return;
		}
	}
	return;
}



BOOL __cdecl lego::res::AnimClone_FrameCountCallback(IDirect3DRMFrame3 *frame,int *lpFramesCount)
{
	*lpFramesCount = *lpFramesCount + 1;
	return 0;
}



BOOL __cdecl
lego::res::AnimClone_SetupFrameArrayCallback(IDirect3DRMFrame3 *frame,AnimClone *actFrameRes)
{
	actFrameRes->partArray[actFrameRes->partCount] = frame;
	actFrameRes->partCount = actFrameRes->partCount + 1;
	return 0;
}



BOOL __cdecl
lego::res::AnimClone_WalkTree
					(IDirect3DRMFrame3 *rmFrame3,int param_2,undefined *param_3,IDirect3DRMFrame3 *param_4)
{
	IDirect3DRMFrame3 *pIVar1;
	undefined *puVar2;
	IDirect3DRMFrame3 *pIVar3;
	int iVar4;
	HRESULT HVar5;
	uint uVar6;
	BOOL BVar7;
	uint index;
	BOOL local_8;
	
	pIVar3 = param_4;
	puVar2 = param_3;
	pIVar1 = rmFrame3;
	local_8 = 0;
	iVar4 = (*(code *)param_3)(rmFrame3,param_4);
	if (iVar4 != 0) {
		return 1;
	}
										// IDirect3DRMFrame3->GetChildren(this, IDirect3DRMFrameArray** lplpChildren)
	HVar5 = (*pIVar1->lpVtbl->GetChildren)(pIVar1,(IDirect3DRMFrameArray **)&rmFrame3);
	if (HVar5 == 0) {
										// DWORD IDirect3DRMFrameArray->GetSize(this)
		uVar6 = (*rmFrame3->lpVtbl->Clone)((IDirect3DRMFrameArray *)rmFrame3);
		index = 0;
		if (uVar6 != 0) {
			iVar4 = param_2 + 1;
			do {
										// IDirect3DRMFrameArray->GetElement(this, DWORD index, IDirect3DRMFrame**
										// lplpD3DRMFrame)
				(*rmFrame3->lpVtbl->AddDestroyCallback)
									((IDirect3DRMFrameArray *)rmFrame3,index,(IUnknown **)&param_3);
										// IDirect3DRMFrame->QueryInterface(this, IID_IDirect3DRMFrame3,
										// IDirect3DRMFrame3** lplpOut)
				(**(code **)*(IUnknown *)param_3)((IUnknown *)param_3,&idl::IID_IDirect3DRMFrame3,&param_4);
										// IDirect3DRMFrame->Release(this)
				(**(code **)((int)*(IUnknown *)param_3 + 8))((IUnknown *)param_3);
				BVar7 = AnimClone_WalkTree(param_4,iVar4,puVar2,pIVar3);
				if (BVar7 != 0) {
					local_8 = 1;
					(*param_4->lpVtbl->Release)((IUnknown *)param_4);
					break;
				}
				(*param_4->lpVtbl->Release)((IUnknown *)param_4);
				index = index + 1;
			} while (index < uVar6);
		}
		(*rmFrame3->lpVtbl->Release)((IUnknown *)rmFrame3);
	}
	return local_8;
}



void __cdecl lego::res::AnimClone_CreateCopy(IDirect3DRMFrame3 *rmFrame3,int *param_2,BOOL lws)
{
	IDirect3DRMFrame3 *this;
	int *this_00;
	BOOL lws_00;
	LPCSTR lpName;
	HRESULT HVar1;
	uint uVar2;
	IDirect3DRMFrame3 *unaff_EBX;
	DWORD index;
	IDirect3DRMFrame3 *local_4c;
	IDirect3DRMFrame3 *local_48 [2];
	Matrix4F local_40;
	
	lws_00 = lws;
	this_00 = param_2;
	this = rmFrame3;
	if ((IDirect3DRMFrame3 *)lws == (IDirect3DRMFrame3 *)0x0) {
		AnimClone_ReferenceVisuals(rmFrame3,(IDirect3DRMFrame3 *)param_2);
	}
	else {
		AnimClone_CloneLwsMesh(rmFrame3,param_2);
	}
										// IDirect3DRMFrame3->GetName(this, DWORD* lpdwSize, LPSTR lpName)
	(*this->lpVtbl->GetName)(this,(LPDWORD)&rmFrame3,(LPSTR)0x0);
	if (rmFrame3 != (IDirect3DRMFrame3 *)0x0) {
		lpName = (LPCSTR)std::malloc((uint)rmFrame3);
										// IDirect3DRMFrame3->GetName(this, DWORD* lpdwSize, LPSTR lpName)
		(*this->lpVtbl->GetName)(this,(LPDWORD)&rmFrame3,lpName);
										// IDirect3DRMFrame3->SetName(this, LPCSTR lpName)
		(**(code **)(*this_00 + 0x20))((IDirect3DRMFrame3 *)this_00,lpName);
		std::free(lpName);
	}
										// IDirect3DRMFrame3->GetParent(this, IDirect3DRMFrame3** lplpParent)
	(*this->lpVtbl->GetParent)(this,(IDirect3DRMFrame3 **)&lws);
										// IDirect3DRMFrame3->GetTransform(this, IDirect3DRMFrame3* lpRefFrame,
										// Matrix4F** rmMatrix)
	(*this->lpVtbl->GetTransform)(this,(IDirect3DRMFrame3 *)lws,(Matrix4F **)&local_40);
										// IDirect3DRMFrame3->Release(this)
										//  (this = GetParent)
	(**(code **)((int)*(IDirect3DRMFrame3 *)lws + 8))((IDirect3DRMFrame3 *)lws);
										// IDirect3DRMFrame3->AddTransform(this, TD3DRMCombineType rctCombine, Matrix4F*
										// rmMatrix)
	(**(code **)(*this_00 + 0x38))((IDirect3DRMFrame3 *)this_00,D3DRMCOMBINE_REPLACE,&local_40);
										// IDirect3DRMFrame3->GetChildren(this, IDirect3DRMFrameArray** lplpChildren)
	HVar1 = (*this->lpVtbl->GetChildren)(this,(IDirect3DRMFrameArray **)&param_2);
	if (HVar1 == 0) {
										// DWORD IDirect3DRMFrameArray->GetSize(this)
		uVar2 = (**(code **)(*param_2 + 0xc))(param_2);
		index = 0;
		if (uVar2 != 0) {
			do {
										// IDirect3DRMFrameArray->GetElement(this, DWORD index, IDirect3DRMFrame**
										// lplpD3DRMFrame)
				(*rmFrame3->lpVtbl->AddDestroyCallback)
									((IDirect3DRMFrameArray *)rmFrame3,index,(IUnknown **)&stack0xffffffb0);
										// IDirect3DRMFrame->QueryInterface(this, IID_IDirect3DRMFrame3,
										// IDirect3DRMFrame3** lplpOut)
				(*unaff_EBX->lpVtbl->QueryInterface)
									((IUnknown *)unaff_EBX,&idl::IID_IDirect3DRMFrame3,local_48);
										// IDirect3DRMFrame->Release(this)
				(*unaff_EBX->lpVtbl->Release)((IUnknown *)unaff_EBX);
										// IDirect3DRM3->CreateFrame(this, IDirect3DRMFrame3* lpD3DRMFrame,
										// IDirect3DRMFrame3** lplpD3DRMFrame)
				(*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
									(globs::mainGlobs.lpD3DRM,(IDirect3DRMFrame3 *)this_00,
									 (IDirect3DRMFrame3 **)&stack0xffffffb0);
				AnimClone_CreateCopy(local_4c,(int *)unaff_EBX,lws_00);
				(*unaff_EBX->lpVtbl->Release)((IUnknown *)unaff_EBX);
				(*local_4c->lpVtbl->Release)((IUnknown *)local_4c);
				index = index + 1;
			} while (index < uVar2);
		}
		(*rmFrame3->lpVtbl->Release)((IUnknown *)rmFrame3);
	}
	return;
}



void __cdecl
lego::res::AnimClone_CloneLwsMesh(IDirect3DRMFrame3 *rmFrame3,IDirect3DRMFrame3 *param_2)
{
	IDirect3DRMFrame3 *pIVar1;
	HRESULT HVar2;
	Mesh *mesh;
	IDirect3DRMVisual **ppIVar3;
	IDirect3DRMFrame3 *pIVar4;
	IDirect3DRMUserVisual *local_14;
	IDirect3DRMVisual *local_10 [4];
	
	pIVar1 = rmFrame3;
										// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount,
										// IDirect3DRMVisualArray** lplpVisuals)
										//  (NOTE: lightalloy's implementation is missing an argument)
	(*rmFrame3->lpVtbl->GetVisuals)(rmFrame3,(DWORD *)&rmFrame3,(IDirect3DRMVisual **)0x0);
	if (rmFrame3 != (IDirect3DRMFrame3 *)0x0) {
										// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount,
										// IDirect3DRMVisualArray** lplpVisuals)
										//  (NOTE: lightalloy's implementation is missing an argument)
		(*pIVar1->lpVtbl->GetVisuals)(pIVar1,(DWORD *)&rmFrame3,local_10);
		pIVar1 = param_2;
		pIVar4 = (IDirect3DRMFrame3 *)0x0;
		if (rmFrame3 != (IDirect3DRMFrame3 *)0x0) {
			ppIVar3 = local_10;
			do {
				HVar2 = (*(*ppIVar3)->lpVtbl->QueryInterface)
													(*ppIVar3,&idl::IID_IDirect3DRMUserVisual,&local_14);
				if (HVar2 == 0) {
					mesh = (Mesh *)(*local_14->lpVtbl->GetAppData)((IUnknown *)local_14);
					Mesh_Clone(mesh,pIVar1);
				}
				pIVar4 = (IDirect3DRMFrame3 *)((int)&pIVar4->lpVtbl + 1);
				ppIVar3 = ppIVar3 + 1;
			} while (pIVar4 < rmFrame3);
		}
	}
	return;
}



void __cdecl lego::res::AnimClone_ReferenceVisuals(IDirect3DRMFrame3 *orig,IDirect3DRMFrame3 *clone)
{
	IDirect3DRMFrame3 *pIVar1;
	IDirect3DRMFrame3 *pIVar2;
	IDirect3DRMVisual **ppIVar3;
	IDirect3DRMVisual *local_10 [4];
	
	pIVar1 = orig;
	(*orig->lpVtbl->GetVisuals)(orig,(DWORD *)&orig,(IDirect3DRMVisual **)0x0);
	if (orig != (IDirect3DRMFrame3 *)0x0) {
		(*pIVar1->lpVtbl->GetVisuals)(pIVar1,(DWORD *)&orig,local_10);
		pIVar1 = clone;
		pIVar2 = (IDirect3DRMFrame3 *)0x0;
		if (orig != (IDirect3DRMFrame3 *)0x0) {
			ppIVar3 = local_10;
			do {
				(*pIVar1->lpVtbl->AddVisual)(pIVar1,*ppIVar3);
				pIVar2 = (IDirect3DRMFrame3 *)((int)&pIVar2->lpVtbl + 1);
				ppIVar3 = ppIVar3 + 1;
			} while (pIVar2 < orig);
		}
	}
	return;
}



void __cdecl lego::image::BMP_Parse(BITMAP_FILE_INFO_STRUCT *data,uint size,D3DRMImage *istruct)
{
	byte bVar1;
	D3DRMPaletteEntry *pDVar2;
	int iVar3;
	DWORD DVar4;
	D3DRMPaletteEntry *pDVar5;
	uint uVar6;
	DWORD DVar7;
	D3DRMPaletteEntry *pDVar8;
	
	if ((data->bmi).biBitCount == 8) {
		DVar7 = (data->bmi).biClrUsed;
		if (DVar7 == 0) {
			DVar7 = 0x100;
		}
		pDVar2 = (D3DRMPaletteEntry *)std::malloc(0x400);
		pDVar5 = pDVar2;
		for (iVar3 = 0x100; iVar3 != 0; iVar3 = iVar3 + -1) {
			*pDVar5 = (D3DRMPaletteEntry)0x0;
			pDVar5 = pDVar5 + 1;
		}
		pDVar5 = (D3DRMPaletteEntry *)data->bmiColors;
		pDVar8 = pDVar2;
		for (DVar4 = DVar7; DVar4 != 0; DVar4 = DVar4 - 1) {
			*pDVar8 = *pDVar5;
			pDVar5 = pDVar5 + 1;
			pDVar8 = pDVar8 + 1;
		}
		istruct->rgb = 0;
		istruct->red_mask = 0xfc;
		istruct->green_mask = 0xfc;
		istruct->blue_mask = 0xfc;
		istruct->alpha_mask = 0xfc;
		istruct->palette_size = DVar7;
		pDVar5 = pDVar2;
		if (0 < (int)DVar7) {
			do {
				bVar1 = pDVar5->red;
				pDVar5->red = pDVar5->blue;
				pDVar5->blue = bVar1;
				DVar7 = DVar7 - 1;
				pDVar5 = pDVar5 + 1;
			} while (DVar7 != 0);
		}
		istruct->palette = pDVar2;
	}
	else {
		istruct->rgb = 1;
		istruct->palette_size = 0;
		istruct->palette = (D3DRMPaletteEntry *)0x0;
	}
	istruct->width = (data->bmi).biWidth;
	istruct->height = (data->bmi).biHeight;
	uVar6 = (uint)(data->bmi).biBitCount;
	istruct->depth = uVar6;
	switch(uVar6) {
	case 8:
		iVar3 = 1;
		break;
	default:
		iVar3 = 0;
		break;
	case 0xf:
	case 0x10:
		iVar3 = 2;
		break;
	case 0x18:
		iVar3 = 3;
		break;
	case 0x20:
		iVar3 = 4;
	}
	istruct->bytes_per_line = iVar3 * istruct->width + 3U & 0xfffffffc;
	DVar7 = (data->hdr).bfOffBits;
	istruct->aspecty = 1;
	istruct->aspectx = 1;
	istruct->buffer1 = (byte *)((int)data->bmiColors + (DVar7 - 0x36));
	istruct->buffer2 = (byte *)0x0;
	return;
}



void __cdecl lego::image::BMP_Cleanup(D3DRMImage *istruct)
{
	if (istruct->palette != (D3DRMPaletteEntry *)0x0) {
		std::free(istruct->palette);
	}
	return;
}



void __cdecl lego::debug::SE(char *error,char *errorDesc)
{
	std::sprintf(globs::dxbugGlobs.DXErrorString,
							 "A DirectX error was set in module %s at line no %i.\nError : %s (code %i)\nDX Module : %s\nError Description : %s\n"
							 ,globs::dxbugGlobs.file,globs::dxbugGlobs.line,error,globs::dxbugGlobs.errnum,
							 globs::DXModuleName[globs::dxbugGlobs.DXModuleNameNumber],errorDesc);
	return;
}



HRESULT __cdecl lego::debug::Error_SetDXError(HRESULT err,int DXModule,char *File,int Line)
{
	globs::dxbugGlobs.errnum = err;
	if ((DXModule < 1) || (globs::dxbugGlobs.DXModuleNameNumber = DXModule, 7 < DXModule)) {
		globs::dxbugGlobs.DXModuleNameNumber = 0;
	}
	globs::dxbugGlobs.line = Line;
	globs::dxbugGlobs.DXNumErrorsSet = globs::dxbugGlobs.DXNumErrorsSet + 1;
	globs::dxbugGlobs.file = File;
	switch(DXModule) {
	case 2:
		if (err < -0x7fffbffe) {
			if (err == -0x7fffbfff) {
				SE("DIERR_UNSUPPORTED",
					 "The function called is not supported at this time.\nThis value is equal to the E_NOTIMPL\nstandard COM return value."
					);
				return -0x7fffbfff;
			}
			if (err == -0x7ffffff6) {
				SE("E_PENDING","Data is not yet availabe.");
				return -0x7ffffff6;
			}
		}
		else {
			if (err < -0x7fffbffa) {
				if (err == -0x7fffbffb) {
					SE("DIERR_GENERIC",
						 "An undetermined error occurred inside the DirectInput subsystem.\nThis value is equal to the E_FAIL standard\nCOM return value."
						);
					return -0x7fffbffb;
				}
				if (err == -0x7fffbffe) {
					SE("DIERR_NOINTERFACE",
						 "The specified interface is not supported by\nthe object. This value is equal to the E_NOINTERFACE\nstandard COM return value."
						);
					return -0x7fffbffe;
				}
			}
			else {
				if (err < -0x7ffbfeab) {
					if (err == -0x7ffbfeac) {
						SE("DIERR_DEVICENOTREG",
							 "The device or device instance is not registered with\nDirectInput. This value is equal to the\nREGDB_E_CLASSNOTREG standard COM return value."
							);
						return -0x7ffbfeac;
					}
					if (err == -0x7ffbfef0) {
						SE("DIERR_NOAGGREGATION","This object does not support aggregation.");
						return -0x7ffbfef0;
					}
				}
				else {
					if (err < -0x7ff8fffd) {
						if (err == -0x7ff8fffe) {
							SE("DIERR_NOTFOUND","The requested object does not exist.");
							return -0x7ff8fffe;
						}
						switch(err) {
						case -0x7ffbfdff:
							SE("DIERR_DEVICEFULL","The device is full.");
							return err;
						case -0x7ffbfdfe:
							SE("DIERR_MOREDATA","Not all the requested information fitted into the buffer");
							return err;
						case -0x7ffbfdfd:
							SE("DIERR_NOTDOWNLOADED","The effect is not downloaded");
							return err;
						case -0x7ffbfdfc:
							SE("DIERR_HASEFFECTS",
								 "The device cannot be reinitialized because there\nare still effects attached to it"
								);
							return err;
						case -0x7ffbfdfb:
							SE("DIERR_NOTEXCLUSIVEACQUIRED",
								 "The operation cannot be performed unless the device\nis acquired in DISCL_EXCLUSIVE mode."
								);
							return err;
						case -0x7ffbfdfa:
							SE("DIERR_INCOMPLETEEFFECT",
								 "The effect could not be downloaded because essential\ninformation is missing. For example, no axes have\nbeen associated with the effect, or no type-specific\ninformation has been supplied"
								);
							return err;
						case -0x7ffbfdf9:
							SE("DIERR_NOTBUFFERED",
								 "The device is not buffered.\nSet the DIPROP_BUFFERSIZE property to enable buffering"
								);
							return err;
						case -0x7ffbfdf8:
							SE("DIERR_EFFECTPLAYING",
								 "The parameters were updated in memory but were not\ndownloaded to the device because the device does not\nsupport updating an effect while it is still playing."
								);
							return err;
						}
					}
					else {
						if (err < -0x7ff8fff3) {
							if (err == -0x7ff8fff4) {
								SE("DIERR_NOTACQUIRED",
									 "The operation cannot be performed unless\nthe device is acquired.");
								return -0x7ff8fff4;
							}
							if (err == -0x7ff8fffb) {
								SE("DIERR_HANDLEEXISTS",
									 "The device already has an event notification associated\nwith it. This value is equal to the E_ACCESSDENIED\nstandard COM return value."
									);
								return -0x7ff8fffb;
							}
						}
						else {
							if (err < -0x7ff8ffea) {
								if (err == -0x7ff8ffeb) {
									SE("DIERR_NOTINITIALIZED","This object has not been initialized.");
									return -0x7ff8ffeb;
								}
								if (err == -0x7ff8fff2) {
									SE("DIERR_OUTOFMEMORY",
										 "The DirectInput subsystem couldn\'t allocate\nsufficient memory to complete the call.\nThis value is equal to the E_OUTOFMEMORY\nstandard COM return value."
										);
									return -0x7ff8fff2;
								}
							}
							else {
								if (err < -0x7ff8ffa8) {
									if (err == -0x7ff8ffa9) {
										SE("DIERR_INVALIDPARAM",
											 "An invalid parameter was passed to the returning function, or the object was not in a state that permitted the function to be called. This value is equal to the E_INVALIDARG standard COM return value."
											);
										return -0x7ff8ffa9;
									}
									if (err == -0x7ff8ffe2) {
										SE("DIERR_INPUTLOST",
											 "Access to the input device has been lost. It must be reacquired.");
										return -0x7ff8ffe2;
									}
								}
								else {
									if (err < -0x7ff8ff55) {
										if (err == -0x7ff8ff56) {
											SE("DIERR_ACQUIRED",
												 "The operation cannot be performed while\nthe device is acquired.");
											return -0x7ff8ff56;
										}
										if (err == -0x7ff8ff89) {
											SE("DIERR_BADDRIVERVER",
												 "The object could not be created due to an\nincompatible driver version or mismatched or\nincomplete driver components."
												);
											return -0x7ff8ff89;
										}
									}
									else {
										if (err < -0x7ff8fb7e) {
											if (err == -0x7ff8fb7f) {
												SE("DIERR_BETADIRECTINPUTVERSION",
													 "The application was written for an unsupported\nprerelease version of DirectInput."
													);
												return -0x7ff8fb7f;
											}
											if (err == -0x7ff8fb82) {
												SE("DIERR_OLDDIRECTINPUTVERSION",
													 "The application requires a newer version of DirectInput.");
												return -0x7ff8fb82;
											}
										}
										else {
											if (err < 1) {
												if (err == 0) {
													SE("DI_OK",
														 "The operation completed successfully.\nThis value is equal to the S_OK standard\nCOM return value."
														);
													return 0;
												}
												if (err == -0x7ff8fb21) {
													SE("DIERR_ALREADYINITIALIZED","This object is already initialized");
													return -0x7ff8fb21;
												}
											}
											else {
												switch(err) {
												case 1:
													SE("DI_BUFFEROVERFLOW",
														 "The device buffer overflowed and some input was lost.\nThis value is equal to the S_FALSE\nstandard COM return value."
														);
													return err;
												case 2:
													SE("DI_POLLEDDEVICE",
														 "The device is a polled device.\nAs a result, device buffering will not collect\nany data and event notifications will not be signaled\nuntil the IDirectInputDevice2::Poll method is called."
														);
													return err;
												case 3:
													SE("DI_DOWNLOADSKIPPED",
														 "The parameters of the effect were successfully updated,\nbut the effect could not be downloaded because the associated\ndevice was not acquired in exclusive mode."
														);
													return err;
												case 4:
													SE("DI_EFFECTRESTARTED",
														 "The effect was stopped,\nthe parameters were updated,\nand the effect was restarted."
														);
													return err;
												case 8:
													SE("DI_TRUNCATED",
														 "The parameters of the effect were successfully updated,\nbut some of them were beyond the capabilities of the\ndevice and were truncated to the nearest supported value."
														);
													return err;
												case 0xc:
													SE("DI_TRUNCATEDANDRESTARTED","Equal to DI_EFFECTRESTARTED | DI_TRUNCATED"
														);
													return err;
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		break;
	case 3:
		if (err < -0x7fffbffa) {
			if (err == -0x7fffbffb) {
				SE("DDERR_GENERIC","There is an undefined error condition.");
				return -0x7fffbffb;
			}
			if (err == -0x7fffbfff) {
				SE("DDERR_UNSUPPORTED","The operation is not supported.");
				return -0x7fffbfff;
			}
		}
		else {
			if (err < -0x7ff8fff1) {
				if (err == -0x7ff8fff2) {
					SE("DDERR_OUTOFMEMORY","DirectDraw does not have enough\nmemory to perform the operation."
						);
					return -0x7ff8fff2;
				}
				if (err == -0x7ffbfe10) {
					SE("DDERR_NOTINITIALIZED",
						 "An attempt was made to call an interface method\nof a DirectDraw object created by CoCreateInstance before\nthe object was initialized."
						);
					return -0x7ffbfe10;
				}
			}
			else {
				if (err < -0x7789fffa) {
					if (err == -0x7789fffb) {
						SE("DDERR_ALREADYINITIALIZED","The object has already been initialized.");
						return -0x7789fffb;
					}
					if (err == -0x7ff8ffa9) {
						SE("DDERR_INVALIDPARAMS",
							 "One or more of the parameters passed to the\nmethod are incorrect.");
						return -0x7ff8ffa9;
					}
				}
				else {
					if (err < -0x7789ffeb) {
						if (err == -0x7789ffec) {
							SE("DDERR_CANNOTDETACHSURFACE",
								 "A surface cannot be detached from another\nrequested surface.");
							return -0x7789ffec;
						}
						if (err == -0x7789fff6) {
							SE("DDERR_CANNOTATTACHSURFACE",
								 "A surface cannot be attached to\nanother requested surface.");
							return -0x7789fff6;
						}
					}
					else {
						if (err < -0x7789ffc8) {
							if (err == -0x7789ffc9) {
								SE("DDERR_EXCEPTION",
									 "An exception was encountered while performing the requested operation.");
								return -0x7789ffc9;
							}
							if (err == -0x7789ffd8) {
								SE("DDERR_CURRENTLYNOTAVAIL","No support is currently available.");
								return -0x7789ffd8;
							}
						}
						else {
							if (err < -0x7789ffa0) {
								if (err == -0x7789ffa1) {
									SE("DDERR_INCOMPATIBLEPRIMARY",
										 "The primary surface creation request does\nnot match with the existing primary surface."
										);
									return -0x7789ffa1;
								}
								if (err == -0x7789ffa6) {
									SE("DDERR_HEIGHTALIGN",
										 "The height of the provided rectangle is not\na multiple of the required alignment."
										);
									return -0x7789ffa6;
								}
							}
							else {
								if (err < -0x7789ff91) {
									if (err == -0x7789ff92) {
										SE("DDERR_INVALIDCLIPLIST","DirectDraw does not support the provided clip list."
											);
										return -0x7789ff92;
									}
									if (err == -0x7789ff9c) {
										SE("DDERR_INVALIDCAPS",
											 "One or more of the capability bits passed to\nthe callback function are incorrect."
											);
										return -0x7789ff9c;
									}
								}
								else {
									if (err < -0x7789ff7d) {
										if (err == -0x7789ff7e) {
											SE("DDERR_INVALIDOBJECT",
												 "DirectDraw received a pointer that was an\ninvalid DirectDraw object.");
											return -0x7789ff7e;
										}
										if (err == -0x7789ff88) {
											SE("DDERR_INVALIDMODE","DirectDraw does not support the requested mode.");
											return -0x7789ff88;
										}
									}
									else {
										if (err < -0x7789ff69) {
											if (err == -0x7789ff6a) {
												SE("DDERR_INVALIDRECT","The provided rectangle was invalid.");
												return -0x7789ff6a;
											}
											if (err == -0x7789ff6f) {
												SE("DDERR_INVALIDPIXELFORMAT","The pixel format was invalid as specified.");
												return -0x7789ff6f;
											}
										}
										else {
											if (err < -0x7789ff55) {
												if (err == -0x7789ff56) {
													SE("DDERR_NO3D","No 3-D hardware or emulation is present.");
													return -0x7789ff56;
												}
												if (err == -0x7789ff60) {
													SE("DDERR_LOCKEDSURFACES",
														 "One or more surfaces are locked, causing the failure of\nthe requested operation."
														);
													return -0x7789ff60;
												}
											}
											else {
												if (err < -0x7789ff32) {
													if (err == -0x7789ff33) {
														SE("DDERR_NOCLIPLIST","No clip list is available.");
														return -0x7789ff33;
													}
													if (err == -0x7789ff4c) {
														SE("DDERR_NOALPHAHW",
															 "No alpha acceleration hardware is present or\navailable, causing the failure of\nthe requested operation."
															);
														return -0x7789ff4c;
													}
												}
												else {
													if (err < -0x7789ff23) {
														if (err == -0x7789ff24) {
															SE("DDERR_NOCOLORKEYHW",
																 "The operation cannot be carried out because there is\nno hardware support for the destination color key."
																);
															return -0x7789ff24;
														}
														if (err == -0x7789ff2e) {
															SE("DDERR_NOCOLORCONVHW",
																 "The operation cannot be carried out because no\ncolor-conversion hardware is present or available."
																);
															return -0x7789ff2e;
														}
														if (err == -0x7789ff2c) {
															SE("DDERR_NOCOOPERATIVELEVELSET",
																 "A create function is called without the\nIDirectDraw2::SetCooperativeLevel method being called."
																);
															return -0x7789ff2c;
														}
														if (err == -0x7789ff29) {
															SE("DDERR_NOCOLORKEY",
																 "The surface does not currently have a color key.");
															return -0x7789ff29;
														}
													}
													else {
														if (err < -0x7789ff1e) {
															if (err == -0x7789ff1f) {
																SE("DDERR_NOEXCLUSIVEMODE",
																	 "The operation requires the application to have exclusive mode,\nbut the application does not have exclusive mode."
																	);
																return -0x7789ff1f;
															}
															if (err == -0x7789ff22) {
																SE("DDERR_NODIRECTDRAWSUPPORT",
																	 "DirectDraw support is not possible\nwith the current display driver."
																	);
																return -0x7789ff22;
															}
														}
														else {
															if (err < -0x7789ff0f) {
																if (err == -0x7789ff10) {
																	SE("DDERR_NOGDI","No GDI is present.");
																	return -0x7789ff10;
																}
																if (err == -0x7789ff1a) {
																	SE("DDERR_NOFLIPHW","Flipping visible surfaces is not supported.")
																	;
																	return -0x7789ff1a;
																}
															}
															else {
																if (err < -0x7789ff00) {
																	if (err == -0x7789ff01) {
																		SE("DDERR_NOTFOUND","The requested item was not found.");
																		return -0x7789ff01;
																	}
																	if (err == -0x7789ff06) {
																		SE("DDERR_NOMIRRORHW",
																			 "The operation cannot be carried out because no mirroring\nhardware is present or available."
																			);
																		return -0x7789ff06;
																	}
																}
																else {
																	if (err < -0x7789fee7) {
																		if (err == -0x7789fee8) {
																			SE("DDERR_NORASTEROPHW",
																				 "The operation cannot be carried out because no appropriate\nraster operation hardware is present or available."
																				);
																			return -0x7789fee8;
																		}
																		if (err == -0x7789fefc) {
																			SE("DDERR_NOOVERLAYHW",
																				 "The operation cannot be carried out because no\noverlay hardware is present or available."
																				);
																			return -0x7789fefc;
																		}
																	}
																	else {
																		if (err < -0x7789fec9) {
																			if (err == -0x7789feca) {
																				SE("DDERR_NOSTRETCHHW",
																					 "The operation cannot be carried out because\nthere is no hardware support for stretching."
																					);
																				return -0x7789feca;
																			}
																			if (err == -0x7789fede) {
																				SE("DDERR_NOROTATIONHW",
																					 "The operation cannot be carried out because\nno rotation hardware is present or available."
																					);
																				return -0x7789fede;
																			}
																		}
																		else {
																			if (err < -0x7789feb5) {
																				if (err == -0x7789feb6) {
																					SE("DDERR_NOTEXTUREHW",
																						 "The operation cannot be carried out because no\ntexture-mapping hardware is present or available."
																						);
																					return -0x7789feb6;
																				}
																				if (err == -0x7789fec4) {
																					SE("DDERR_NOT4BITCOLOR",
																						 "The DirectDrawSurface object is not using a 4-bit color palette\nand the requested operation requires a 4-bit color palette."
																						);
																					return -0x7789fec4;
																				}
																				if (err == -0x7789fec3) {
																					SE("DDERR_NOT4BITCOLORINDEX",
																						 "The DirectDrawSurface object is not using a 4-bit color index\npalette and the requested operation requires a\n4-bit color index palette."
																						);
																					return -0x7789fec3;
																				}
																				if (err == -0x7789fec0) {
																					SE("DDERR_NOT8BITCOLOR",
																						 "The DirectDrawSurface object is not using an 8-bit color\npalette and the requested operation requires\nan 8-bit color palette."
																						);
																					return -0x7789fec0;
																				}
																			}
																			else {
																				if (err < -0x7789feab) {
																					if (err == -0x7789feac) {
																						SE("DDERR_NOZBUFFERHW",
																							 "The operation to create a z-buffer in display memory\nor to perform a blit using a z-buffer cannot be\ncarried out because there is no hardware support\nfor z-buffers."
																							);
																						return -0x7789feac;
																					}
																					if (err == -0x7789feb1) {
																						SE("DDERR_NOVSYNCHW",
																							 "The operation cannot be carried out because\nthere is no hardware support for vertical\nblank synchronized operations."
																							);
																						return -0x7789feb1;
																					}
																				}
																				else {
																					if (err < -0x7789fe97) {
																						if (err == -0x7789fe98) {
																							SE("DDERR_OUTOFCAPS",
																								 "The hardware needed for the requested\noperation has already been allocated."
																								);
																							return -0x7789fe98;
																						}
																						if (err == -0x7789fea2) {
																							SE("DDERR_NOZOVERLAYHW",
																								 "The overlay surfaces cannot be z-layered based on the\nz-order because the hardware does not support\nz-ordering of overlays."
																								);
																							return -0x7789fea2;
																						}
																					}
																					else {
																						if (err < -0x7789fe6f) {
																							if (err == -0x7789fe70) {
																								SE("DDERR_COLORKEYNOTSET",
																																																			
																									"No source color key is specified for this operation."
																									);
																								return -0x7789fe70;
																							}
																							switch(err) {
																							case -0x7789fe84:
																								SE("DDERR_OUTOFVIDEOMEMORY",
																																																			
																									"DirectDraw does not have enough display\nmemory to perform the operation."
																									);
																								return err;
																							case -0x7789fe82:
																								SE("DDERR_OVERLAYCANTCLIP",
																									 "The hardware does not support clipped overlays."
																									);
																								return err;
																							case -0x7789fe80:
																								SE("DDERR_OVERLAYCOLORKEYONLYONEACTIVE",
																																																			
																									"An attempt was made to have more than one\ncolor key active on an overlay."
																									);
																								return err;
																							case -0x7789fe7d:
																								SE("DDERR_PALETTEBUSY",
																																																			
																									"Access to this palette is refused because\nthe palette is locked by another thread."
																									);
																								return err;
																							}
																						}
																						else {
																							if (err < -0x7789fe5b) {
																								if (err == -0x7789fe5c) {
																									SE("DDERR_SURFACEALREADYDEPENDENT",
																																																					
																									"An attempt was made to make a surface a dependency\nof another surface to which it is\nalready dependent."
																									);
																									return -0x7789fe5c;
																								}
																								if (err == -0x7789fe66) {
																									SE("DDERR_SURFACEALREADYATTACHED",
																																																					
																									"An attempt was made to attach a surface to another\nsurface to which it is already attached."
																									);
																									return -0x7789fe66;
																								}
																							}
																							else {
																								if (err < -0x7789fe4c) {
																									if (err == -0x7789fe4d) {
																										SE("DDERR_CANTLOCKSURFACE",
																																																							
																									"Access to this surface is refused because an\nattempt was made to lock the primary\nsurface without DCI support."
																									);
																									return -0x7789fe4d;
																									}
																									if (err == -0x7789fe52) {
																										SE("DDERR_SURFACEBUSY",
																																																							
																									"Access to the surface is refused because\nthe surface is locked by another thread."
																									);
																									return -0x7789fe52;
																									}
																								}
																								else {
																									if (err < -0x7789fe3d) {
																										if (err == -0x7789fe3e) {
																											SE("DDERR_SURFACELOST",
																																																									
																									"Access to the surface is refused because the surface\nmemory is gone. The DirectDrawSurface object representing this\nsurface should have the IDirectDrawSurface3::Restore\nmethod called on it."
																									);
																									return -0x7789fe3e;
																									}
																									if (err == -0x7789fe48) {
																										SE("DDERR_SURFACEISOBSCURED",
																																																							
																									"Access to the surface is refused\nbecause the surface is obscured."
																									);
																									return -0x7789fe48;
																									}
																									}
																									else {
																										if (err < -0x7789fe29) {
																											if (err == -0x7789fe2a) {
																												SE("DDERR_TOOBIGHEIGHT",
																																																											
																									"The height requested by DirectDraw is too large."
																									);
																									return -0x7789fe2a;
																									}
																									if (err == -0x7789fe34) {
																										SE("DDERR_SURFACENOTATTACHED",
																											 "The requested surface is not attached.");
																										return -0x7789fe34;
																									}
																									}
																									else {
																										if (err < -0x7789fe15) {
																											if (err == -0x7789fe16) {
																												SE("DDERR_TOOBIGWIDTH",
																																																											
																									"The width requested by DirectDraw\nis too large."
																									);
																									return -0x7789fe16;
																									}
																									if (err == -0x7789fe20) {
																										SE("DDERR_TOOBIGSIZE",
																																																							
																									"The size requested by DirectDraw is too large.\nHowever, the individual height and\nwidth are OK."
																									);
																									return -0x7789fe20;
																									}
																									}
																									else {
																										if (err < -0x7789fdf7) {
																											if (err == -0x7789fdf8) {
																												SE("DDERR_UNSUPPORTEDMASK",
																																																											
																									"The bitmask in the pixel format requested\nis not supported by DirectDraw."
																									);
																									return -0x7789fdf8;
																									}
																									if (err == -0x7789fe02) {
																										SE("DDERR_UNSUPPORTEDFORMAT",
																																																							
																									"The FourCC format requested is\nnot supported by DirectDraw."
																									);
																									return -0x7789fe02;
																									}
																									}
																									else {
																										if (err < -0x7789fde3) {
																											if (err == -0x7789fde4) {
																												SE("DDERR_WASSTILLDRAWING",
																																																											
																									"The previous blit operation that is transferring\ninformation to or from this\nsurface is incomplete."
																									);
																									return -0x7789fde4;
																									}
																									if (err == -0x7789fde7) {
																										SE("DDERR_VERTICALBLANKINPROGRESS",
																											 "A vertical blank is in progress.");
																										return -0x7789fde7;
																									}
																									}
																									else {
																										if (err < -0x7789fd89) {
																											switch(err) {
																											case -0x7789fdd0:
																												SE("DDERR_XALIGN",
																																																											
																									"The provided rectangle was not horizontally\naligned on a required boundary."
																									);
																									return err;
																									case -0x7789fdcf:
																										SE("DDERR_INVALIDDIRECTDRAWGUID",
																																																							
																									"The globally unique identifier (GUID) passed to the\nDirectDrawCreate function is not a valid DirectDraw\ndriver identifier."
																									);
																									return err;
																									case -0x7789fdce:
																										SE("DDERR_DIRECTDRAWALREADYCREATED",
																																																							
																									"A DirectDraw object representing this driver\nhas already been created for this process."
																									);
																									return err;
																									case -0x7789fdcd:
																										SE("DDERR_NODIRECTDRAWHW",
																																																							
																									"Hardware-only DirectDraw object creation is not possible;\nthe driver does not support any hardware."
																									);
																									return err;
																									case -0x7789fdcc:
																										SE("DDERR_PRIMARYSURFACEALREADYEXISTS",
																																																							
																									"This process has already created a primary surface."
																									);
																									return err;
																									case -0x7789fdcb:
																										SE("DDERR_NOEMULATION",
																											 "Software emulation is not available.");
																										return err;
																									case -0x7789fdca:
																										SE("DDERR_REGIONTOOSMALL",
																																																							
																									"The region passed to the\nIDirectDrawClipper::GetClipList\nmethod is too small."
																									);
																									return err;
																									case -0x7789fdc9:
																										SE("DDERR_CLIPPERISUSINGHWND",
																																																							
																									"An attempt was made to set a clip list for a\nDirectDrawClipper object that is already monitoring\na window handle."
																									);
																									return err;
																									case -0x7789fdc8:
																										SE("DDERR_NOCLIPPERATTACHED",
																																																							
																									"No DirectDrawClipper object is attached\nto the surface object."
																									);
																									return err;
																									case -0x7789fdc7:
																										SE("DDERR_NOHWND",
																																																							
																									"Clipper notification requires a window handle,\nor no window handle has been previously set as\nthe cooperative level window handle."
																									);
																									return err;
																									case -0x7789fdc6:
																										SE("DDERR_HWNDSUBCLASSED",
																																																							
																									"DirectDraw is prevented from restoring state\nbecause the DirectDraw cooperative level window\nhandle has been subclassed."
																									);
																									return err;
																									case -0x7789fdc5:
																										SE("DDERR_HWNDALREADYSET",
																																																							
																									"The DirectDraw cooperative level window handle\nhas already been set. It cannot be reset while the process\nhas surfaces or palettes created."
																									);
																									return err;
																									case -0x7789fdc4:
																										SE("DDERR_NOPALETTEATTACHED",
																																																							
																									"No palette object is attached to this surface.");
																									return err;
																									case -0x7789fdc3:
																										SE("DDERR_NOPALETTEHW",
																																																							
																									"There is no hardware support for 16- or 256-color palettes."
																									);
																									return err;
																									case -0x7789fdc2:
																										SE("DDERR_BLTFASTCANTCLIP",
																																																							
																									"A DirectDrawClipper object is attached to a source\nsurface that has passed into a call to the\nIDirectDrawSurface3::BltFast method."
																									);
																									return err;
																									case -0x7789fdc1:
																										SE("DDERR_NOBLTHW",
																											 "No blitter hardware is present.");
																										return err;
																									case -0x7789fdc0:
																										SE("DDERR_NODDROPSHW",
																																																							
																									"No DirectDraw raster operation (ROP) hardware is available."
																									);
																									return err;
																									case -0x7789fdbf:
																										SE("DDERR_OVERLAYNOTVISIBLE",
																																																							
																									"The IDirectDrawSurface3::GetOverlayPosition method\nis called on a hidden overlay."
																									);
																									return err;
																									case -0x7789fdbe:
																										SE("DDERR_NOOVERLAYDEST",
																																																							
																									"The IDirectDrawSurface3::GetOverlayPosition method is called\non an overlay that the IDirectDrawSurface3::UpdateOverlay method\nhas not been called on to establish a destination."
																									);
																									return err;
																									case -0x7789fdbd:
																										SE("DDERR_INVALIDPOSITION",
																																																							
																									"The position of the overlay on the destination is no longer legal."
																									);
																									return err;
																									case -0x7789fdbc:
																										SE("DDERR_NOTAOVERLAYSURFACE",
																																																							
																									"An overlay component is called for a non-overlay surface."
																									);
																									return err;
																									case -0x7789fdbb:
																										SE("DDERR_EXCLUSIVEMODEALREADYSET",
																																																							
																									"An attempt was made to set the cooperative level\nwhen it was already set to exclusive."
																									);
																									return err;
																									case -0x7789fdba:
																										SE("DDERR_NOTFLIPPABLE",
																																																							
																									"An attempt has been made to flip\na surface that cannot be flipped."
																									);
																									return err;
																									case -0x7789fdb9:
																										SE("DDERR_CANTDUPLICATE",
																																																							
																									"Primary and 3-D surfaces, or surfaces that\nare implicitly created, cannot be duplicated."
																									);
																									return err;
																									case -0x7789fdb8:
																										SE("DDERR_NOTLOCKED",
																																																							
																									"An attempt is made to unlock a\nsurface that was not locked."
																									);
																									return err;
																									case -0x7789fdb7:
																										SE("DDERR_CANTCREATEDC",
																																																							
																									"Windows cannot create any more device\ncontexts (DCs)."
																									);
																									return err;
																									case -0x7789fdb6:
																										SE("DDERR_NODC",
																																																							
																									"No DC has ever been created for this surface.");
																									return err;
																									case -0x7789fdb5:
																										SE("DDERR_WRONGMODE",
																																																							
																									"This surface cannot be restored because it\nwas created in a different mode."
																									);
																									return err;
																									case -0x7789fdb4:
																										SE("DDERR_IMPLICITLYCREATED",
																																																							
																									"The surface cannot be restored because\nit is an implicitly created surface."
																									);
																									return err;
																									case -0x7789fdb3:
																										SE("DDERR_NOTPALETTIZED",
																																																							
																									"The surface being used is not a\npalette-based surface."
																									);
																									return err;
																									case -0x7789fdb2:
																										SE("DDERR_UNSUPPORTEDMODE",
																																																							
																									"The display is currently in\nan unsupported mode."
																									);
																									return err;
																									case -0x7789fdb1:
																										SE("DDERR_NOMIPMAPHW",
																																																							
																									"The operation cannot be carried out because no mipmap\ntexture mapping hardware is present or available."
																									);
																									return err;
																									case -0x7789fdb0:
																										SE("DDERR_INVALIDSURFACETYPE",
																																																							
																									"The requested operation could not be performed\nbecause the surface was of the wrong type."
																									);
																									return err;
																									case -0x7789fdaf:
																									case -0x7789fdae:
																									case -0x7789fdad:
																									case -0x7789fdac:
																									case -0x7789fdab:
																									case -0x7789fdaa:
																									case -0x7789fda9:
																									case -0x7789fda6:
																									case -0x7789fda5:
																									case -0x7789fda4:
																									case -0x7789fda3:
																									case -0x7789fda2:
																									case -0x7789fda1:
																									case -0x7789fda0:
																									case -0x7789fd9f:
																									case -0x7789fd9e:
																									case -0x7789fd9d:
																									case -0x7789fd9c:
																									case -0x7789fd9b:
																									case -0x7789fd9a:
																									case -0x7789fd99:
																									case -0x7789fd98:
																									case -0x7789fd97:
																									case -0x7789fd96:
																									case -0x7789fd95:
																										goto switchD_0048a659_caseD_5;
																									case -0x7789fda8:
																										SE("DDERR_NOOPTIMIZEH",
																																																							
																									"The device does not support optimized surfaces");
																									return err;
																									case -0x7789fda7:
																										SE("DDERR_NOTLOADE",
																																																							
																									"The surface is an optimized surface,\nbut it has not yet been allocated any memory"
																									);
																									return err;
																									case -0x7789fd94:
																										SE("DDERR_DCALREADYCREATED",
																																																							
																									"A device context (DC) has already been returned\nfor this surface. Only one DC can be retrieved for each surface."
																									);
																									return err;
																									default:
																										SE("DDERR_NONONLOCALVIDME",
																																																							
																									"An attempt was made to allocate non-local video\nmemory from a device that does not support non-local\nvideo memory"
																									);
																									return -0x7789fd8a;
																									}
																									}
																									if (err < -0x7789fd6b) {
																										if (err == -0x7789fd6c) {
																											SE("DDERR_CANTPAGEUNLOCK",
																																																									
																									"An attempt to page unlock a surface failed.\nPage unlock will not work on a display-memory\nsurface or an emulated primary surface."
																									);
																									return -0x7789fd6c;
																									}
																									if (err == -0x7789fd80) {
																										SE("DDERR_CANTPAGELOCK",
																																																							
																									"An attempt to page lock a surface failed.\nPage lock will not work on a display-memory surface or\nan emulated primary surface."
																									);
																									return -0x7789fd80;
																									}
																									}
																									else {
																										if (err < -0x7789fd4d) {
																											if (err == -0x7789fd4e) {
																												SE("DDERR_MOREDAT",
																																																											
																									"There is more data available than the\nspecified buffer size can hold"
																									);
																									return -0x7789fd4e;
																									}
																									if (err == -0x7789fd58) {
																										SE("DDERR_NOTPAGELOCKED",
																																																							
																									"An attempt is made to page unlock a\nsurface with no outstanding page locks."
																									);
																									return -0x7789fd58;
																									}
																									}
																									else {
																										if (err == -0x7789fd49) {
																											SE("DDERR_VIDEONOTACTIV",
																												 "The video port is not active");
																											return -0x7789fd49;
																										}
																										if (err == -0x7789fd45) {
																											SE("DDERR_DEVICEDOESNTOWNSURFAC",
																																																									
																									"Surfaces created by one direct draw device cannot\nbe used directly by another direct draw device"
																									);
																									return -0x7789fd45;
																									}
																									if (err == 0) {
																										SE("DD_OK","The request completed successfully."
																											);
																										return 0;
																									}
																									}
																									}
																									}
																									}
																									}
																									}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		break;
	case 4:
		SE("Unknown","Error handling is unsupported in this module");
	case 5:
		SE("Unknown","Error handling is unsupported in this module");
	case 6:
		SE("Unknown","Error handling is unsupported in this module");
	case 1:
		if (err < 1) {
			if (err == 0) {
				SE("D3DRM_OK","No error.");
				return 0;
			}
			switch(err) {
			case -0x7789fcf3:
				SE("D3DRMERR_BADOBJECT","Object expected in argument.");
				return err;
			case -0x7789fcf2:
				SE("D3DRMERR_BADTYPE","Bad argument type passed.");
				return err;
			case -0x7789fcf1:
				SE("D3DRMERR_BADALLOC","Out of memory.");
				return err;
			case -0x7789fcf0:
				SE("D3DRMERR_FACEUSED","Face already used in a mesh.");
				return err;
			case -0x7789fcef:
				SE("D3DRMERR_NOTFOUND","Object not found in specified place.");
				return err;
			case -0x7789fcee:
				SE("D3DRMERR_NOTDONEYET","Unimplemented.");
				return err;
			case -0x7789fced:
				SE("D3DRMERR_FILENOTFOUND","File cannot be opened.");
				return err;
			case -0x7789fcec:
				SE("D3DRMERR_BADFILE","Data file is corrupt.");
				return err;
			case -0x7789fceb:
				SE("D3DRMERR_BADDEVICE","Device is not compatible with renderer.");
				return err;
			case -0x7789fcea:
				SE("D3DRMERR_BADVALUE","Bad argument value passed.");
				return err;
			case -0x7789fce9:
				SE("D3DRMERR_BADMAJORVERSION","Bad DLL major version.");
				return err;
			case -0x7789fce8:
				SE("D3DRMERR_BADMINORVERSION","Bad DLL minor version.");
				return err;
			case -0x7789fce7:
				SE("D3DRMERR_UNABLETOEXECUTE","Unable to carry out procedure.");
				return err;
			case -0x7789fce4:
				SE("D3DRMERR_PENDING",
					 "The data required to supply the requested\ninformation has not finished loading.");
				return err;
			case -0x7789fce3:
				SE("D3DRMERR_NOTENOUGHDATA",
					 "Not enough data has been loaded to\nperform the requested operation.");
				return err;
			case -0x7789fce2:
				SE("D3DRMERR_REQUESTTOOLARGE",
					 "An attempt was made to set a level\nof detail in a progressive mesh greater than the maximum available."
					);
				return err;
			case -0x7789fce1:
				SE("D3DRMERR_REQUESTTOOSMALL",
					 "An attempt was made to set the minimum\nrendering detail of a progressive mesh smaller than\nthe detail in the base mesh\n(the minimum for rendering)."
					);
				return err;
			case -0x7789fce0:
				SE("D3DRMERR_CONNECTIONLOST","Data connection was lost during a load,\nclone, or duplicate."
					);
				return err;
			case -0x7789fcdc:
				SE("D3DRMERR_BOXNOTSET",
					 "An attempt was made to access a bounding box\n(for example, with IDirect3DRMFrame2::GetBox)\nwhen no bounding box was set on the frame."
					);
				return err;
			case -0x7789fcdb:
				SE("D3DRMERR_BADPMDATA",
					 "The data in the X File is corrupted.\nThe conversion to a progressive mesh succeeded but\nproduced an invalid progressive mesh in\nthe X File."
					);
				return err;
			}
		}
		break;
	case 7:
		SE("QUERY_INTERFACE","The requested interface could not be obtained");
		return err;
	default:
		SE("Unknown","An error in an unknown DirectX module/object was raised");
		return err;
	}
switchD_0048a659_caseD_5:
	SE("UNKNOWN ERROR","Invalid error code specified");
	return err;
}



void __cdecl lego::debug::Error_Initialise(void)
{
	globs::errorGlobs.dumpFile = (FileStream *)0x0;
	globs::errorGlobs.loadLogFile = (FileStream *)0x0;
	globs::errorGlobs.loadErrorLogFile = (FileStream *)0x0;
	globs::errorGlobs.redundantLogFile = (FileStream *)0x0;
	globs::errorGlobs.fullScreen = 0;
	return;
}



void __cdecl lego::debug::Error_FullScreen(BOOL on)
{
	globs::errorGlobs.fullScreen = on;
	return;
}



void __cdecl lego::debug::Error_CloseLog(void)
{
	if (globs::errorGlobs.dumpFile != (FileStream *)0x0) {
		lego::file::File_Close(globs::errorGlobs.dumpFile);
	}
	if (globs::errorGlobs.loadLogFile != (FileStream *)0x0) {
		lego::file::File_Close(globs::errorGlobs.loadLogFile);
	}
	if (globs::errorGlobs.loadErrorLogFile != (FileStream *)0x0) {
		lego::file::File_Close(globs::errorGlobs.loadErrorLogFile);
	}
	globs::errorGlobs.dumpFile = (FileStream *)0x0;
	globs::errorGlobs.loadLogFile = (FileStream *)0x0;
	globs::errorGlobs.loadErrorLogFile = (FileStream *)0x0;
	return;
}



void __cdecl lego::debug::Error_Shutdown(void)
{
	Error_CloseLog();
	globs::errorGlobs.redundantLogFile = lego::file::File_Open(globs::errorGlobs.redundantLogName,"w")
	;
	if (globs::errorGlobs.redundantLogFile != (FileStream *)0x0) {
		lego::file::File_CheckRedundantFiles(globs::errorGlobs.loadLogName);
		lego::file::File_Close(globs::errorGlobs.redundantLogFile);
	}
	return;
}



char * __cdecl lego::registry::Registry_GetKeyFromPath(char *path,char *out_str)
{
	char cVar1;
	
	*out_str = '\0';
	cVar1 = *path;
	while ((cVar1 != '\0' && (cVar1 != '\\'))) {
		path = path + 1;
		*out_str = cVar1;
		out_str = out_str + 1;
		cVar1 = *path;
	}
	if (*path == '\\') {
		path = path + 1;
	}
	*out_str = '\0';
	return path;
}



BOOL __cdecl
lego::registry::Registry_GetValue
					(char *path,char *key,RegistryType dataType,char *out_data,uint dataSize)
{
	BOOL BVar1;
	
	BVar1 = Registry_GetValue_Recursive((HKEY)HKEY_LOCAL_MACHINE,path,key,dataType,out_data,dataSize);
	return BVar1;
}



BOOL __cdecl
lego::registry::Registry_GetValue_Recursive
					(HKEY parent,char *path,char *key,RegistryType dataType,char *out_data,uint dataSize)
{
	char *path_00;
	LSTATUS LVar1;
	HKEY pHVar2;
	HKEY local_68;
	char str [100];
	
	path_00 = Registry_GetKeyFromPath(path,str);
	if (str[0] != '\0') {
										// Open the key and recurse
		RegCreateKeyA(parent,str,(PHKEY)&local_68);
		if (local_68 == (HKEY)0x0) {
			return (BOOL)local_68;
		}
		pHVar2 = (HKEY)Registry_GetValue_Recursive(local_68,path_00,key,dataType,out_data,dataSize);
		RegCloseKey(local_68);
		return (BOOL)pHVar2;
	}
	path = (char *)0x0;
										// REG_NONE (0x0)
	if (dataType != REGISTRY_STRING_VALUE) {
										// REG_SZ (0x1)
		if (dataType != REGISTRY_DWORD_VALUE) {
			return (BOOL)(HKEY)0x0;
		}
		LVar1 = RegQueryValueExA(parent,key,(LPDWORD)0x0,(LPDWORD)&path,(LPBYTE)out_data,&dataSize);
		return (BOOL)(HKEY)(uint)(LVar1 == 0);
	}
	LVar1 = RegQueryValueExA(parent,key,(LPDWORD)0x0,(LPDWORD)&path,(LPBYTE)out_data,&dataSize);
	return (BOOL)(HKEY)(uint)(LVar1 == 0);
}



BOOL __cdecl lego::wad::GetFileName(FILE *f,char *out_str)
{
	char cVar1;
	int iVar2;
	
	iVar2 = std::fgetc(f);
	cVar1 = (char)iVar2;
	while (cVar1 != '\0') {
		*out_str = (char)iVar2;
		out_str = out_str + 1;
		iVar2 = std::fgetc(f);
		cVar1 = (char)iVar2;
	}
	*out_str = '\0';
	return TRUE;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe
// Open the wad and map in the file data.
// Returns a handle to the wad file.

int __cdecl lego::wad::Wad_Load(char *fName)
{
	char cVar1;
	int wadNo;
	FILE *stream;
	WADFile *pWVar2;
	size_t sVar3;
	char **ppcVar4;
	BOOL BVar5;
	char *pcVar6;
	WADEntry *pWVar7;
	int iVar8;
	uint uVar9;
	uint uVar10;
	int iVar11;
	undefined4 *puVar12;
	char *pcVar13;
	undefined4 *puVar14;
	bool bVar15;
	size_t sVar16;
	FILE *pFVar17;
	char acStack4100 [4];
	char acStack4096 [4092];
	undefined4 uStack4;
	
	uStack4 = 0x48b7aa;
	iVar11 = 0;
	wadNo = Wad_GetFreeWadSlot();
	if (wadNo != -1) {
		stream = std::fopen(fName,"rb");
		pWVar2 = Wad_Get(wadNo);
		pWVar2->fWad = stream;
		if (stream != (FILE *)0x0) {
			pWVar2 = Wad_Get(wadNo);
			pWVar2->active = 1;
			sVar3 = std::fread(acStack4100,1,4,stream);
			if (sVar3 != 4) {
				std::fclose(stream);
				return -1;
			}
			iVar8 = 4;
			bVar15 = true;
			pcVar6 = acStack4100;
			pcVar13 = "WWAD";
			do {
				if (iVar8 == 0) break;
				iVar8 = iVar8 + -1;
				bVar15 = *pcVar6 == *pcVar13;
				pcVar6 = pcVar6 + 1;
				pcVar13 = pcVar13 + 1;
			} while (bVar15);
			if (!bVar15) {
				std::fclose(stream);
				return -1;
			}
			sVar16 = 4;
			sVar3 = 1;
			pFVar17 = stream;
			pWVar2 = Wad_Get(wadNo);
			sVar3 = std::fread(&pWVar2->numFiles,sVar3,sVar16,pFVar17);
			if (sVar3 != 4) {
				std::fclose(stream);
				return -1;
			}
			pWVar2 = Wad_Get(wadNo);
			ppcVar4 = (char **)std::malloc(pWVar2->numFiles << 2);
			pWVar2 = Wad_Get(wadNo);
			pWVar2->wadNames = ppcVar4;
			pWVar2 = Wad_Get(wadNo);
			ppcVar4 = (char **)std::malloc(pWVar2->numFiles << 2);
			pWVar2 = Wad_Get(wadNo);
			pWVar2->fileNames = ppcVar4;
			pWVar2 = Wad_Get(wadNo);
			if ((pWVar2->wadNames != (char **)0x0) &&
				 (pWVar2 = Wad_Get(wadNo), pWVar2->fileNames != (char **)0x0)) {
				pWVar2 = Wad_Get(wadNo);
				uVar9 = pWVar2->numFiles;
				pWVar2 = Wad_Get(wadNo);
				ppcVar4 = pWVar2->wadNames;
				for (uVar9 = uVar9 & 0x3fffffff; uVar9 != 0; uVar9 = uVar9 - 1) {
					*ppcVar4 = (char *)0x0;
					ppcVar4 = ppcVar4 + 1;
				}
				for (iVar8 = 0; iVar8 != 0; iVar8 = iVar8 + -1) {
					*(undefined *)ppcVar4 = 0;
					ppcVar4 = (char **)((int)ppcVar4 + 1);
				}
				pWVar2 = Wad_Get(wadNo);
				uVar9 = pWVar2->numFiles;
				pWVar2 = Wad_Get(wadNo);
				ppcVar4 = pWVar2->fileNames;
				for (uVar9 = uVar9 & 0x3fffffff; uVar9 != 0; uVar9 = uVar9 - 1) {
					*ppcVar4 = (char *)0x0;
					ppcVar4 = ppcVar4 + 1;
				}
				for (iVar8 = 0; iVar8 != 0; iVar8 = iVar8 + -1) {
					*(undefined *)ppcVar4 = 0;
					ppcVar4 = (char **)((int)ppcVar4 + 1);
				}
				pWVar2 = Wad_Get(wadNo);
				if (0 < pWVar2->numFiles) {
					do {
						BVar5 = GetFileName(stream,acStack4096);
						if (BVar5 == 0) {
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->wadNames != (char **)0x0) {
								iVar11 = 0;
								pWVar2 = Wad_Get(wadNo);
								if (0 < pWVar2->numFiles) {
									do {
										pWVar2 = Wad_Get(wadNo);
										if (pWVar2->wadNames[iVar11] != (char *)0x0) {
											pWVar2 = Wad_Get(wadNo);
											std::free(pWVar2->wadNames[iVar11]);
										}
										iVar11 = iVar11 + 1;
										pWVar2 = Wad_Get(wadNo);
									} while (iVar11 < pWVar2->numFiles);
								}
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->wadNames);
							}
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->fileNames != (char **)0x0) {
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->fileNames);
							}
							std::fclose(stream);
							return -1;
						}
						uVar9 = 0xffffffff;
						pcVar6 = acStack4096;
						do {
							if (uVar9 == 0) break;
							uVar9 = uVar9 - 1;
							cVar1 = *pcVar6;
							pcVar6 = pcVar6 + 1;
						} while (cVar1 != '\0');
						pcVar6 = (char *)std::malloc(~uVar9);
						pWVar2 = Wad_Get(wadNo);
						pWVar2->wadNames[iVar11] = pcVar6;
						pWVar2 = Wad_Get(wadNo);
						uVar9 = 0xffffffff;
						pcVar6 = acStack4096;
						do {
							pcVar13 = pcVar6;
							if (uVar9 == 0) break;
							uVar9 = uVar9 - 1;
							pcVar13 = pcVar6 + 1;
							cVar1 = *pcVar6;
							pcVar6 = pcVar13;
						} while (cVar1 != '\0');
						uVar9 = ~uVar9;
						puVar12 = (undefined4 *)(pcVar13 + -uVar9);
						puVar14 = (undefined4 *)pWVar2->wadNames[iVar11];
						for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {
							*puVar14 = *puVar12;
							puVar12 = puVar12 + 1;
							puVar14 = puVar14 + 1;
						}
						for (uVar9 = uVar9 & 3; uVar9 != 0; uVar9 = uVar9 - 1) {
							*(undefined *)puVar14 = *(undefined *)puVar12;
							puVar12 = (undefined4 *)((int)puVar12 + 1);
							puVar14 = (undefined4 *)((int)puVar14 + 1);
						}
						pWVar2 = Wad_Get(wadNo);
						lego::file::File_Error("%s\n",pWVar2->wadNames[iVar11]);
						iVar11 = iVar11 + 1;
						pWVar2 = Wad_Get(wadNo);
					} while (iVar11 < pWVar2->numFiles);
				}
				iVar11 = 0;
				pWVar2 = Wad_Get(wadNo);
				if (0 < pWVar2->numFiles) {
					do {
						BVar5 = GetFileName(stream,acStack4096);
						if (BVar5 == 0) {
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->fileNames != (char **)0x0) {
								iVar11 = 0;
								pWVar2 = Wad_Get(wadNo);
								if (0 < pWVar2->numFiles) {
									do {
										pWVar2 = Wad_Get(wadNo);
										if (pWVar2->wadNames[iVar11] != (char *)0x0) {
											pWVar2 = Wad_Get(wadNo);
											std::free(pWVar2->wadNames[iVar11]);
										}
										iVar11 = iVar11 + 1;
										pWVar2 = Wad_Get(wadNo);
									} while (iVar11 < pWVar2->numFiles);
								}
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->wadNames);
							}
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->fileNames != (char **)0x0) {
								iVar11 = 0;
								pWVar2 = Wad_Get(wadNo);
								if (0 < pWVar2->numFiles) {
									do {
										pWVar2 = Wad_Get(wadNo);
										if (pWVar2->fileNames[iVar11] != (char *)0x0) {
											pWVar2 = Wad_Get(wadNo);
											std::free(pWVar2->fileNames[iVar11]);
										}
										iVar11 = iVar11 + 1;
										pWVar2 = Wad_Get(wadNo);
									} while (iVar11 < pWVar2->numFiles);
								}
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->fileNames);
								std::fclose(stream);
								return -1;
							}
							goto LAB_0048be6d;
						}
						uVar9 = 0xffffffff;
						pcVar6 = acStack4096;
						do {
							if (uVar9 == 0) break;
							uVar9 = uVar9 - 1;
							cVar1 = *pcVar6;
							pcVar6 = pcVar6 + 1;
						} while (cVar1 != '\0');
						pcVar6 = (char *)std::malloc(~uVar9);
						pWVar2 = Wad_Get(wadNo);
						pWVar2->fileNames[iVar11] = pcVar6;
						pWVar2 = Wad_Get(wadNo);
						uVar9 = 0xffffffff;
						pcVar6 = acStack4096;
						do {
							pcVar13 = pcVar6;
							if (uVar9 == 0) break;
							uVar9 = uVar9 - 1;
							pcVar13 = pcVar6 + 1;
							cVar1 = *pcVar6;
							pcVar6 = pcVar13;
						} while (cVar1 != '\0');
						uVar9 = ~uVar9;
						puVar12 = (undefined4 *)(pcVar13 + -uVar9);
						puVar14 = (undefined4 *)pWVar2->fileNames[iVar11];
						for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {
							*puVar14 = *puVar12;
							puVar12 = puVar12 + 1;
							puVar14 = puVar14 + 1;
						}
						for (uVar9 = uVar9 & 3; uVar9 != 0; uVar9 = uVar9 - 1) {
							*(undefined *)puVar14 = *(undefined *)puVar12;
							puVar12 = (undefined4 *)((int)puVar12 + 1);
							puVar14 = (undefined4 *)((int)puVar14 + 1);
						}
						pWVar2 = Wad_Get(wadNo);
						lego::file::File_Error("%s\n",pWVar2->fileNames[iVar11]);
						iVar11 = iVar11 + 1;
						pWVar2 = Wad_Get(wadNo);
					} while (iVar11 < pWVar2->numFiles);
				}
				pWVar2 = Wad_Get(wadNo);
				pWVar7 = (WADEntry *)std::malloc(pWVar2->numFiles << 4);
				pWVar2 = Wad_Get(wadNo);
				pWVar2->wadEntries = pWVar7;
				pWVar2 = Wad_Get(wadNo);
				if (pWVar2->wadEntries == (WADEntry *)0x0) {
					pWVar2 = Wad_Get(wadNo);
					if (pWVar2->fileNames != (char **)0x0) {
						iVar11 = 0;
						pWVar2 = Wad_Get(wadNo);
						if (0 < pWVar2->numFiles) {
							do {
								pWVar2 = Wad_Get(wadNo);
								if (pWVar2->wadNames[iVar11] != (char *)0x0) {
									pWVar2 = Wad_Get(wadNo);
									std::free(pWVar2->wadNames[iVar11]);
								}
								iVar11 = iVar11 + 1;
								pWVar2 = Wad_Get(wadNo);
							} while (iVar11 < pWVar2->numFiles);
						}
						pWVar2 = Wad_Get(wadNo);
						std::free(pWVar2->wadNames);
					}
					pWVar2 = Wad_Get(wadNo);
					if (pWVar2->fileNames != (char **)0x0) {
						iVar11 = 0;
						pWVar2 = Wad_Get(wadNo);
						if (0 < pWVar2->numFiles) {
							do {
								pWVar2 = Wad_Get(wadNo);
								if (pWVar2->fileNames[iVar11] != (char *)0x0) {
									pWVar2 = Wad_Get(wadNo);
									std::free(pWVar2->fileNames[iVar11]);
								}
								iVar11 = iVar11 + 1;
								pWVar2 = Wad_Get(wadNo);
							} while (iVar11 < pWVar2->numFiles);
						}
						pWVar2 = Wad_Get(wadNo);
						std::free(pWVar2->fileNames);
					}
					std::fclose(stream);
					return -1;
				}
				pFVar17 = stream;
				pWVar2 = Wad_Get(wadNo);
				sVar3 = pWVar2->numFiles << 4;
				sVar16 = 1;
				pWVar2 = Wad_Get(wadNo);
				sVar3 = std::fread(pWVar2->wadEntries,sVar16,sVar3,pFVar17);
				pWVar2 = Wad_Get(wadNo);
				if (sVar3 == pWVar2->numFiles << 4) {
					return wadNo;
				}
				pWVar2 = Wad_Get(wadNo);
				if (pWVar2->fileNames != (char **)0x0) {
					iVar11 = 0;
					pWVar2 = Wad_Get(wadNo);
					if (0 < pWVar2->numFiles) {
						do {
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->wadNames[iVar11] != (char *)0x0) {
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->wadNames[iVar11]);
							}
							iVar11 = iVar11 + 1;
							pWVar2 = Wad_Get(wadNo);
						} while (iVar11 < pWVar2->numFiles);
					}
					pWVar2 = Wad_Get(wadNo);
					std::free(pWVar2->wadNames);
				}
				pWVar2 = Wad_Get(wadNo);
				if (pWVar2->fileNames != (char **)0x0) {
					iVar11 = 0;
					pWVar2 = Wad_Get(wadNo);
					if (0 < pWVar2->numFiles) {
						do {
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->fileNames[iVar11] != (char *)0x0) {
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->fileNames[iVar11]);
							}
							iVar11 = iVar11 + 1;
							pWVar2 = Wad_Get(wadNo);
						} while (iVar11 < pWVar2->numFiles);
					}
					pWVar2 = Wad_Get(wadNo);
					std::free(pWVar2->fileNames);
				}
				pWVar2 = Wad_Get(wadNo);
				if (pWVar2->wadEntries != (WADEntry *)0x0) {
					pWVar2 = Wad_Get(wadNo);
					std::free(pWVar2->wadEntries);
				}
LAB_0048be6d:
				std::fclose(stream);
				return -1;
			}
			std::fclose(stream);
			pWVar2 = Wad_Get(wadNo);
			if (pWVar2->wadNames != (char **)0x0) {
				pWVar2 = Wad_Get(wadNo);
				std::free(pWVar2->wadNames);
			}
			pWVar2 = Wad_Get(wadNo);
			if (pWVar2->fileNames != (char **)0x0) {
				pWVar2 = Wad_Get(wadNo);
				std::free(pWVar2->fileNames);
			}
		}
	}
	return -1;
}



WADFile * __cdecl lego::wad::Wad_Get(int wadNo)
{
	return globs::wadGlobs.wads + wadNo;
}



int __cdecl lego::wad::Wad_FileLength(int wadNo,int fileNo)
{
	WADFile *pWVar1;
	
	pWVar1 = Wad_Get(wadNo);
	return pWVar1->wadEntries[fileNo].decompressedLength;
}



int __cdecl lego::wad::Wad_FileCompressedLength(int wadNo,int fileNo)
{
	WADFile *pWVar1;
	
	pWVar1 = Wad_Get(wadNo);
	return pWVar1->wadEntries[fileNo].fileLength;
}



int __cdecl lego::wad::Wad_FindFreeFileHandle(void)
{
	int iVar1;
	int *piVar2;
	
	iVar1 = 0;
	piVar2 = &globs::wadGlobs.fileHandles[0].active;
	do {
		if (*piVar2 == 0) {
			return iVar1;
		}
		piVar2 = piVar2 + 4;
		iVar1 = iVar1 + 1;
	} while ((int)piVar2 < 0x576ce4);
	return -1;
}



int __cdecl lego::wad::Wad_IsFileInWad(char *fName,int opt_wadNo)
{
	WADFile *pWVar1;
	int iVar2;
	int iVar3;
	
	if (opt_wadNo != -1) {
		iVar3 = _Wad_IsFileInWad(fName,opt_wadNo);
		return iVar3;
	}
	iVar3 = 9;
	while ((pWVar1 = Wad_Get(iVar3), pWVar1->active == 0 ||
				 (iVar2 = _Wad_IsFileInWad(fName,iVar3), iVar2 == -1))) {
		iVar3 = iVar3 + -1;
		if (iVar3 < 0) {
			return -1;
		}
	}
	return iVar2;
}



int __cdecl lego::wad::_Wad_IsFileInWad(char *fName,int wadNo)
{
	int iVar1;
	int iVar2;
	
	iVar2 = 0;
	if (globs::wadGlobs.wads[wadNo].numFiles < 1) {
		return -1;
	}
	do {
		iVar1 = std::_stricmp(globs::wadGlobs.wads[wadNo].wadNames[iVar2],fName);
		if (iVar1 == 0) {
			return iVar2;
		}
		iVar2 = iVar2 + 1;
	} while (iVar2 < globs::wadGlobs.wads[wadNo].numFiles);
	return -1;
}



int __cdecl lego::wad::Wad_GetFreeWadSlot(void)
{
	int *piVar1;
	int iVar2;
	int iVar3;
	WADFile *pWVar4;
	
	iVar3 = 0;
	piVar1 = &globs::wadGlobs.wads[0].active;
	do {
		if (*piVar1 == 0) {
			pWVar4 = globs::wadGlobs.wads + iVar3;
			for (iVar2 = 9; iVar2 != 0; iVar2 = iVar2 + -1) {
				pWVar4->fName = (char *)0x0;
				pWVar4 = (WADFile *)&pWVar4->active;
			}
			return iVar3;
		}
		piVar1 = piVar1 + 9;
		iVar3 = iVar3 + 1;
	} while ((int)piVar1 < 0x57666c);
	return -1;
}



int __cdecl lego::wad::_Wad_FileOpen(char *fName,int wadNo)
{
	int iVar1;
	int fileNo;
	uint length;
	void *out_buffer;
	WADFile *pWVar2;
	size_t sVar3;
	int offset;
	size_t count;
	int origin;
	FILE *stream;
	int wadNo_00;
	
	iVar1 = Wad_FindFreeFileHandle();
	wadNo_00 = wadNo;
	if (iVar1 == -1) {
		return -1;
	}
	fileNo = Wad_IsFileInWad(fName,wadNo);
	if (fileNo == -1) {
		return -1;
	}
	length = Wad_FileCompressedLength(wadNo_00,fileNo);
	out_buffer = std::malloc(length);
	if (out_buffer == (void *)0x0) {
		return -1;
	}
	origin = 0;
	pWVar2 = Wad_Get(wadNo_00);
	offset = pWVar2->wadEntries[fileNo].addr;
	pWVar2 = Wad_Get(wadNo_00);
	std::fseek(pWVar2->fWad,offset,origin);
	pWVar2 = Wad_Get(wadNo_00);
	stream = pWVar2->fWad;
	count = 1;
	sVar3 = Wad_FileCompressedLength(wadNo_00,fileNo);
	sVar3 = std::fread(out_buffer,sVar3,count,stream);
	if (sVar3 != 1) {
		std::free(out_buffer);
		return -1;
	}
	pWVar2 = Wad_Get(wadNo_00);
	wadNo = (int)out_buffer;
	if ((*(byte *)&pWVar2->wadEntries[fileNo].compression & 2) != 0) {
		wadNo = 0;
		rnc::RNC_Uncompress(out_buffer,(void **)&wadNo);
		std::free(out_buffer);
	}
	globs::wadGlobs.fileHandles[iVar1].data = (void *)wadNo;
	globs::wadGlobs.fileHandles[iVar1].active = 1;
	globs::wadGlobs.fileHandles[iVar1].wadFile = wadNo_00;
	globs::wadGlobs.fileHandles[iVar1].indexOfFileInWad = fileNo;
	return iVar1;
}



int __cdecl lego::wad::Wad_FileOpen(char *fName,int opt_wadNo)
{
	WADFile *pWVar1;
	int iVar2;
	int iVar3;
	
	if (opt_wadNo != -1) {
		iVar3 = _Wad_FileOpen(fName,opt_wadNo);
		return iVar3;
	}
	iVar3 = 9;
	while ((pWVar1 = Wad_Get(iVar3), pWVar1->active == 0 ||
				 (iVar2 = _Wad_FileOpen(fName,iVar3), iVar2 == -1))) {
		iVar3 = iVar3 + -1;
		if (iVar3 < 0) {
			return -1;
		}
	}
	return iVar2;
}



void __cdecl lego::wad::Wad_FileClose(int handle)
{
	if (globs::wadGlobs.fileHandles[handle].active != 0) {
		std::free(globs::wadGlobs.fileHandles[handle].data);
		globs::wadGlobs.fileHandles[handle].active = 0;
	}
	return;
}



void * __cdecl lego::wad::Wad_FileGetPointer(int handle)
{
	if (globs::wadGlobs.fileHandles[handle].active != 0) {
		return globs::wadGlobs.fileHandles[handle].data;
	}
	return (void *)0x0;
}



int __cdecl lego::wad::Wad_hLength(int handle)
{
	int iVar1;
	
	iVar1 = Wad_FileLength(globs::wadGlobs.fileHandles[handle].wadFile,
												 globs::wadGlobs.fileHandles[handle].indexOfFileInWad);
	return iVar1;
}



void * __cdecl lego::wad::Wad_hData(int handle)
{
	void *pvVar1;
	
	pvVar1 = Wad_FileGetPointer(handle);
	return pvVar1;
}



char * __cdecl lego::lw::lwExtractString(char *str1,char *str2,uint *out_pos,uint *out_len)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	size_t _MaxCount;
	char *pcVar5;
	
	uVar3 = 0xffffffff;
	pcVar5 = str1;
	do {
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	uVar4 = 0xffffffff;
	pcVar5 = str2;
	do {
		if (uVar4 == 0) break;
		uVar4 = uVar4 - 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	_MaxCount = ~uVar4 - 1;
	if (((uVar3 != 1) && (_MaxCount != 0)) && (uVar4 = 0, uVar3 != 1)) {
		do {
			iVar2 = std::_strnicmp(str1,str2,_MaxCount);
			if (iVar2 == 0) {
				if (out_pos != (uint *)0x0) {
					*out_pos = uVar4;
				}
				if (out_len != (uint *)0x0) {
					*out_len = _MaxCount;
				}
				return str1;
			}
			uVar4 = uVar4 + 1;
			str1 = str1 + 1;
		} while (uVar4 < uVar3 - 1);
		return (char *)0x0;
	}
	return (char *)0x0;
}



char * __cdecl lego::lw::stringAlloc(char *str)
{
	char cVar1;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	uVar3 = 0xffffffff;
	pcVar6 = str;
	do {
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		cVar1 = *pcVar6;
		pcVar6 = pcVar6 + 1;
	} while (cVar1 != '\0');
	uVar4 = ~uVar3 + (~uVar3 & 1);
	puVar2 = (undefined4 *)std::malloc(uVar4);
	puVar5 = puVar2;
	for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
		*puVar5 = 0;
		puVar5 = puVar5 + 1;
	}
	for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
		*(undefined *)puVar5 = 0;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
	}
	uVar3 = 0xffffffff;
	do {
		pcVar6 = str;
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		pcVar6 = str + 1;
		cVar1 = *str;
		str = pcVar6;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	puVar5 = (undefined4 *)(pcVar6 + -uVar3);
	puVar7 = puVar2;
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
		*puVar7 = *puVar5;
		puVar5 = puVar5 + 1;
		puVar7 = puVar7 + 1;
	}
	for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
		*(undefined *)puVar7 = *(undefined *)puVar5;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
		puVar7 = (undefined4 *)((int)puVar7 + 1);
	}
	return (char *)puVar2;
}



// Defaults to "PLANAR" on failure to parse

uint __cdecl lego::lw::texMapType(char *shapeName)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	char **ppcVar5;
	char *pcVar6;
	char *tTypes [3];
	
	tTypes[0] = "PLANAR";
	tTypes[1] = "CYLINDRICAL";
	tTypes[2] = "SPHERICAL";
	uVar4 = 0;
	ppcVar5 = tTypes;
	do {
		uVar3 = 0xffffffff;
		pcVar6 = *ppcVar5;
		do {
			if (uVar3 == 0) break;
			uVar3 = uVar3 - 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
		iVar2 = std::_strnicmp(shapeName,*ppcVar5,~uVar3 - 1);
		if (iVar2 == 0) break;
		uVar4 = uVar4 + 1;
		ppcVar5 = ppcVar5 + 1;
	} while (uVar4 < 3);
	if (uVar4 == 3) {
		uVar4 = 0;
	}
	return uVar4;
}



void __cdecl lego::lw::surfFree(LWSURFACE *srf,BOOL flag)
{
	if (srf->srfName != (char *)0x0) {
		std::free(srf->srfName);
	}
	if (srf->srfPath != (char *)0x0) {
		std::free(srf->srfPath);
	}
	if (srf->srfNextSurf != (LWSURFACE *)0x0) {
		surfFree(srf->srfNextSurf,1);
	}
	if (flag != 0) {
		std::free(srf);
	}
	return;
}



BOOL __cdecl lego::lw::LWD3D(byte **p,float *f)
{
	byte *pbVar1;
	
	*(byte *)((int)f + 3) = **p;
	pbVar1 = *p;
	*p = pbVar1 + 1;
	*(byte *)((int)f + 2) = pbVar1[1];
	pbVar1 = *p;
	*p = pbVar1 + 1;
	*(byte *)((int)f + 1) = pbVar1[1];
	pbVar1 = *p;
	*p = pbVar1 + 1;
	*(byte *)f = pbVar1[1];
	*p = *p + 1;
	return TRUE;
}



// WARNING: Could not reconcile some variable overlaps

BOOL __cdecl lego::lw::PNTSprc(FileStream *file,LWSIZE *sizeData,int csize,float **verts,BOOL dflag)
{
	float *pfVar1;
	int iVar2;
	float local_120;
	float fStack284;
	undefined uStack280;
	undefined local_117;
	undefined2 uStack278;
	byte *local_114;
	byte *local_110;
	uint local_10c;
	char local_108 [260];
	
	iVar2 = 0;
	local_120 = (float)(uint)local_120._0_1_;
	fStack284 = 0.0;
	uStack280 = 0;
	local_117 = 0;
	local_114 = (byte *)std::malloc(csize + 0x10);
	local_110 = local_114;
	lego::file::File_Read(local_114,csize,1,file);
	sizeData->lwVertCount = csize / 0xc;
	if (verts != (float **)0x0) {
		pfVar1 = (float *)std::malloc(csize + 4);
		*verts = pfVar1;
		if (0 < csize) {
			local_10c = (csize + 0xbU) / 0xc;
			do {
				LWD3D(&local_114,&local_120);
				LWD3D(&local_114,&fStack284);
				LWD3D(&local_114,(float *)&uStack280);
				*pfVar1 = local_120;
				pfVar1[1] = fStack284;
				pfVar1[2] = (float)CONCAT22(uStack278,CONCAT11(local_117,uStack280));
				pfVar1 = pfVar1 + 3;
				if (dflag != 0) {
					std::sprintf(local_108,"Point %d > %f %f %f\n",iVar2,(double)local_120,(double)fStack284);
				}
				iVar2 = iVar2 + 1;
				local_10c = local_10c - 1;
			} while (local_10c != 0);
		}
	}
	std::free(local_110);
	return TRUE;
}



BOOL __cdecl lego::lw::CRVSprc(FileStream *file,int csize,BOOL dflag)
{
	ushort uVar1;
	ushort *out_buffer;
	uint uVar2;
	ushort *puVar3;
	int iVar4;
	
	out_buffer = (ushort *)std::malloc(csize + 0x10);
	lego::file::File_Read(out_buffer,csize,1,file);
	puVar3 = out_buffer;
	if (0 < csize) {
		do {
			uVar1 = *puVar3 * 0x100 + (*puVar3 >> 8);
			puVar3 = puVar3 + 1;
			iVar4 = csize + -2;
			if (uVar1 != 0) {
				uVar2 = (uint)uVar1;
				puVar3 = puVar3 + uVar2;
				do {
					iVar4 = iVar4 + -2;
					uVar2 = uVar2 - 1;
				} while (uVar2 != 0);
			}
			csize = iVar4 + -4;
			puVar3 = puVar3 + 2;
		} while (0 < csize);
	}
	std::free(out_buffer);
	return TRUE;
}



BOOL __cdecl
lego::lw::POLSprc(FileStream *file,LWSIZE *sizeData,LWPOLY **polys,int csize,BOOL dflag)
{
	char cVar1;
	ushort *out_buffer;
	LWPOLY *pLVar2;
	ushort *puVar3;
	uint uVar4;
	int iVar5;
	uint uVar6;
	ushort uVar7;
	ushort uVar8;
	LWPOLY *pLVar9;
	undefined4 *puVar10;
	LWPOLY *pLVar11;
	char *pcVar12;
	char *pcVar13;
	char *pcVar14;
	undefined4 *puVar15;
	ushort *local_150;
	uint local_14c;
	char local_140 [64];
	char local_100 [256];
	
	out_buffer = (ushort *)std::malloc(csize + 0x10);
	lego::file::File_Read(out_buffer,csize,1,file);
	uVar8 = 0;
	local_150 = out_buffer;
	uVar7 = 0;
	if (0 < csize) {
		do {
			uVar7 = *local_150 * 0x100 + (*local_150 >> 8);
			local_150 = local_150 + 1;
			csize = csize + -2;
			if (polys != (LWPOLY **)0x0) {
				if (uVar8 == 0) {
					pLVar2 = (LWPOLY *)std::malloc(0xc);
					*polys = pLVar2;
				}
				else {
					uVar4 = (uint)uVar8;
					pLVar2 = (LWPOLY *)std::malloc((uVar4 + 1) * 0xc);
					pLVar9 = *polys;
					pLVar11 = pLVar2;
					for (iVar5 = uVar4 * 3; iVar5 != 0; iVar5 = iVar5 + -1) {
						pLVar11->plyCount = pLVar9->plyCount;
						pLVar9 = (LWPOLY *)&pLVar9->plySurface;
						pLVar11 = (LWPOLY *)&pLVar11->plySurface;
					}
					for (iVar5 = 0; iVar5 != 0; iVar5 = iVar5 + -1) {
						*(undefined *)&pLVar11->plyCount = *(undefined *)&pLVar9->plyCount;
						pLVar9 = (LWPOLY *)((int)&pLVar9->plyCount + 1);
						pLVar11 = (LWPOLY *)((int)&pLVar11->plyCount + 1);
					}
					std::free(*polys);
					*polys = pLVar2;
					pLVar2 = pLVar2 + uVar4;
				}
				local_14c = (uint)uVar7;
				puVar3 = (ushort *)std::malloc(local_14c * 2);
				if (dflag != 0) {
					std::sprintf(local_100,"Poly %d, Vertex Count %d > ",(uint)uVar8,local_14c);
				}
				pLVar2->plyCount = local_14c;
				pLVar2->plyData = puVar3;
				if (uVar7 != 0) {
					do {
						uVar7 = *local_150 * 0x100 + (*local_150 >> 8);
						if (dflag != 0) {
							std::sprintf(local_140,"%d ",(uint)uVar7);
							uVar4 = 0xffffffff;
							pcVar13 = local_140;
							do {
								pcVar12 = pcVar13;
								if (uVar4 == 0) break;
								uVar4 = uVar4 - 1;
								pcVar12 = pcVar13 + 1;
								cVar1 = *pcVar13;
								pcVar13 = pcVar12;
							} while (cVar1 != '\0');
							uVar4 = ~uVar4;
							iVar5 = -1;
							pcVar13 = local_100;
							do {
								pcVar14 = pcVar13;
								if (iVar5 == 0) break;
								iVar5 = iVar5 + -1;
								pcVar14 = pcVar13 + 1;
								cVar1 = *pcVar13;
								pcVar13 = pcVar14;
							} while (cVar1 != '\0');
							puVar10 = (undefined4 *)(pcVar12 + -uVar4);
							puVar15 = (undefined4 *)(pcVar14 + -1);
							for (uVar6 = uVar4 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
								*puVar15 = *puVar10;
								puVar10 = puVar10 + 1;
								puVar15 = puVar15 + 1;
							}
							for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
								*(undefined *)puVar15 = *(undefined *)puVar10;
								puVar10 = (undefined4 *)((int)puVar10 + 1);
								puVar15 = (undefined4 *)((int)puVar15 + 1);
							}
						}
						*puVar3 = uVar7;
						puVar3 = puVar3 + 1;
						local_150 = local_150 + 1;
						csize = csize + -2;
						local_14c = local_14c - 1;
					} while (local_14c != 0);
				}
				uVar4 = (uint)(byte)*local_150 * 0x100 + -1 + (uint)(*local_150 >> 8) & 0xffff;
				pLVar2->plySurface = uVar4;
				if (dflag != 0) {
					std::sprintf(local_140,"Surface :- %d\n",uVar4);
					uVar4 = 0xffffffff;
					pcVar13 = local_140;
					do {
						pcVar12 = pcVar13;
						if (uVar4 == 0) break;
						uVar4 = uVar4 - 1;
						pcVar12 = pcVar13 + 1;
						cVar1 = *pcVar13;
						pcVar13 = pcVar12;
					} while (cVar1 != '\0');
					uVar4 = ~uVar4;
					iVar5 = -1;
					pcVar13 = local_100;
					do {
						pcVar14 = pcVar13;
						if (iVar5 == 0) break;
						iVar5 = iVar5 + -1;
						pcVar14 = pcVar13 + 1;
						cVar1 = *pcVar13;
						pcVar13 = pcVar14;
					} while (cVar1 != '\0');
					puVar10 = (undefined4 *)(pcVar12 + -uVar4);
					puVar15 = (undefined4 *)(pcVar14 + -1);
					for (uVar6 = uVar4 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
						*puVar15 = *puVar10;
						puVar10 = puVar10 + 1;
						puVar15 = puVar15 + 1;
					}
					for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
						*(undefined *)puVar15 = *(undefined *)puVar10;
						puVar10 = (undefined4 *)((int)puVar10 + 1);
						puVar15 = (undefined4 *)((int)puVar15 + 1);
					}
				}
			}
			csize = csize + -2;
			uVar8 = uVar8 + 1;
			local_150 = local_150 + 1;
			uVar7 = uVar8;
		} while (0 < csize);
	}
	sizeData->lwPolyCount = (uint)uVar7;
	std::free(out_buffer);
	return TRUE;
}



BOOL __cdecl
lego::lw::SRFSprc(FileStream *file,LWSIZE *sizeData,LWSURFLIST **srfl,int csize,uint *srflCount,
								 BOOL dflag)
{
	char cVar1;
	undefined4 *out_buffer;
	undefined4 *puVar2;
	char **ppcVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	uint uVar7;
	undefined4 *puVar8;
	char **ppcVar9;
	undefined4 *puVar10;
	undefined4 *puVar11;
	char **ppcVar12;
	uint local_224;
	LWSURFLIST *local_220;
	char local_200 [512];
	
	uVar7 = 0;
	local_224 = 0;
	out_buffer = (undefined4 *)std::malloc(csize + 0x10);
	lego::file::File_Read(out_buffer,csize,1,file);
	if (srfl != (LWSURFLIST **)0x0) {
		local_220 = (LWSURFLIST *)std::malloc(8);
		local_220->srflCount = 0;
		local_220->srflName = (char **)0x0;
	}
	puVar10 = out_buffer;
	if (0 < csize) {
		do {
			if (dflag != 0) {
				std::sprintf(local_200,"Surface %d > %s\n",local_224,puVar10);
			}
			uVar4 = 0xffffffff;
			puVar8 = puVar10;
			do {
				if (uVar4 == 0) break;
				uVar4 = uVar4 - 1;
				cVar1 = *(char *)puVar8;
				puVar8 = (undefined4 *)((int)puVar8 + 1);
			} while (cVar1 != '\0');
			uVar4 = ~uVar4;
			if ((uVar4 & 1) != 0) {
				uVar4 = uVar4 + 1;
			}
			if (srfl != (LWSURFLIST **)0x0) {
				puVar2 = (undefined4 *)std::malloc(uVar4);
				ppcVar3 = (char **)std::malloc(uVar7 + 4);
				puVar8 = puVar10;
				puVar11 = puVar2;
				for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
					*puVar11 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar11 = puVar11 + 1;
				}
				for (uVar5 = uVar4 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
					*(undefined *)puVar11 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar11 = (undefined4 *)((int)puVar11 + 1);
				}
				if (uVar7 != 0) {
					ppcVar9 = local_220->srflName;
					ppcVar12 = ppcVar3;
					for (uVar5 = uVar7 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
						*ppcVar12 = *ppcVar9;
						ppcVar9 = ppcVar9 + 1;
						ppcVar12 = ppcVar12 + 1;
					}
					for (iVar6 = 0; iVar6 != 0; iVar6 = iVar6 + -1) {
						*(undefined *)ppcVar12 = *(undefined *)ppcVar9;
						ppcVar9 = (char **)((int)ppcVar9 + 1);
						ppcVar12 = (char **)((int)ppcVar12 + 1);
					}
					std::free(local_220->srflName);
				}
				*(undefined4 **)((int)ppcVar3 + uVar7) = puVar2;
				local_220->srflName = ppcVar3;
				*srfl = local_220;
				local_220->srflCount = local_224 + 1;
			}
			local_224 = local_224 + 1;
			uVar7 = uVar7 + 4;
			*srflCount = local_224;
			puVar10 = (undefined4 *)((int)puVar10 + uVar4);
			csize = csize - uVar4;
		} while (0 < csize);
	}
	std::free(out_buffer);
	return TRUE;
}



// WARNING: Could not reconcile some variable overlaps

BOOL __cdecl
lego::lw::SURFprc(FileStream *file,LWSIZE *sizeData,LWSURFACE **surf,int csize,BOOL dflag)
{
	char cVar1;
	float fVar2;
	char *pcVar3;
	LWSURFACE *pLVar4;
	char *pcVar5;
	int iVar6;
	LWTEXMAPTYPE LVar7;
	LWSURFACE *pLVar8;
	int iVar9;
	uint uVar10;
	uint uVar11;
	LWTEXFLAGS LVar12;
	LWSRFFLAGS LVar13;
	char **shapeName;
	char **ppcVar14;
	undefined4 *puVar15;
	int iVar16;
	LWSURFACE *pLVar17;
	char **ppcVar18;
	char *pcVar19;
	char *pcVar20;
	undefined4 *puVar21;
	char **local_50c;
	LWSURFACE *local_508;
	uint local_504;
	char local_500;
	undefined4 local_4ff;
	undefined4 local_4fb;
	undefined local_4f7;
	char **local_4f4;
	int local_4f0;
	char *local_4ec;
	char *local_4e8;
	char *local_4e4;
	char *local_4e0;
	char *local_4dc;
	char *local_4d8;
	char *local_4d4;
	uint local_4d0;
	int local_4cc;
	char *local_4c8 [4];
	char *local_4b8;
	char *local_4b4;
	char *local_4b0;
	char *local_4ac [4];
	char *local_49c;
	char *local_498;
	char *local_494;
	char *local_490;
	char *local_48c;
	char *local_488;
	uint local_484;
	char local_480 [511];
	undefined uStack641;
	char *local_280 [32];
	char local_200 [512];
	
	local_4ff = 0;
	local_4fb = 0;
	local_500 = '\0';
	local_4f7 = 0;
	pcVar3 = (char *)std::malloc(csize + 0x10);
	local_4ec = pcVar3;
	lego::file::File_Read(pcVar3,csize,1,file);
	uVar10 = sizeData->lwSurfaceCount;
	pLVar4 = local_508;
	local_504 = uVar10;
	if (surf != (LWSURFACE **)0x0) {
		if (uVar10 == 0) {
			pLVar4 = (LWSURFACE *)std::malloc(0x54);
			*surf = pLVar4;
			pLVar8 = pLVar4;
			for (iVar9 = 0x15; iVar9 != 0; iVar9 = iVar9 + -1) {
				pLVar8->srfName = (char *)0x0;
				pLVar8 = (LWSURFACE *)&pLVar8->srfNextSurf;
			}
			local_508 = pLVar4;
			pcVar5 = stringAlloc(pcVar3);
			pLVar4->srfName = pcVar5;
		}
		else {
			pLVar4 = (LWSURFACE *)std::malloc((uVar10 + 1) * 0x54);
			pLVar8 = *surf;
			pLVar17 = pLVar4;
			for (uVar11 = uVar10 * 0x15 & 0x3fffffff; uVar11 != 0; uVar11 = uVar11 - 1) {
				pLVar17->srfName = pLVar8->srfName;
				pLVar8 = (LWSURFACE *)&pLVar8->srfNextSurf;
				pLVar17 = (LWSURFACE *)&pLVar17->srfNextSurf;
			}
			for (iVar9 = 0; iVar9 != 0; iVar9 = iVar9 + -1) {
				*(undefined *)&pLVar17->srfName = *(undefined *)&pLVar8->srfName;
				pLVar8 = (LWSURFACE *)((int)&pLVar8->srfName + 1);
				pLVar17 = (LWSURFACE *)((int)&pLVar17->srfName + 1);
			}
			std::free(*surf);
			*surf = pLVar4;
			pLVar4 = pLVar4 + uVar10;
			pLVar8 = pLVar4;
			for (iVar9 = 0x15; iVar9 != 0; iVar9 = iVar9 + -1) {
				pLVar8->srfName = (char *)0x0;
				pLVar8 = (LWSURFACE *)&pLVar8->srfNextSurf;
			}
			local_508 = pLVar4;
			pcVar3 = stringAlloc(local_4ec);
			pLVar4->srfName = pcVar3;
			pcVar3 = local_4ec;
		}
	}
	if (dflag != 0) {
		std::sprintf(local_200,"Surface %d :- %s");
	}
	uVar10 = 0xffffffff;
	pcVar5 = pcVar3;
	do {
		if (uVar10 == 0) break;
		uVar10 = uVar10 - 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	uVar10 = ~uVar10;
	if ((uVar10 & 1) != 0) {
		uVar10 = uVar10 + 1;
	}
	iVar9 = csize - uVar10;
	pcVar3 = pcVar3 + uVar10;
	do {
		if (iVar9 < 1) {
			sizeData->lwSurfaceCount = sizeData->lwSurfaceCount + 1;
			std::free(local_4ec);
			return TRUE;
		}
		std::_strncpy(&local_500,pcVar3,4);
		local_4cc = (*(ushort *)(pcVar3 + 4) & 0xff) * 0x100 + (uint)(*(ushort *)(pcVar3 + 4) >> 8);
		std::sprintf(local_200," %s (%d)");
		shapeName = (char **)(pcVar3 + 6);
		iVar6 = std::_strnicmp(&local_500,"TIMG",4);
		if (iVar6 == 0) {
			uVar10 = 0xffffffff;
			ppcVar14 = shapeName;
			do {
				ppcVar18 = ppcVar14;
				if (uVar10 == 0) break;
				uVar10 = uVar10 - 1;
				ppcVar18 = (char **)((int)ppcVar14 + 1);
				cVar1 = *(char *)ppcVar14;
				ppcVar14 = ppcVar18;
			} while (cVar1 != '\0');
			uVar10 = ~uVar10;
			iVar6 = -1;
			pcVar3 = local_200;
			do {
				pcVar5 = pcVar3;
				if (iVar6 == 0) break;
				iVar6 = iVar6 + -1;
				pcVar5 = pcVar3 + 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar5;
			} while (cVar1 != '\0');
			ppcVar14 = (char **)((int)ppcVar18 - uVar10);
			ppcVar18 = (char **)(pcVar5 + -1);
			for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
				*ppcVar18 = *ppcVar14;
				ppcVar14 = ppcVar14 + 1;
				ppcVar18 = ppcVar18 + 1;
			}
			for (uVar10 = uVar10 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {
				*(undefined *)ppcVar18 = *(undefined *)ppcVar14;
				ppcVar14 = (char **)((int)ppcVar14 + 1);
				ppcVar18 = (char **)((int)ppcVar18 + 1);
			}
			if (surf != (LWSURFACE **)0x0) {
				uVar10 = 0xffffffff;
				ppcVar14 = shapeName;
				do {
					ppcVar18 = ppcVar14;
					if (uVar10 == 0) break;
					uVar10 = uVar10 - 1;
					ppcVar18 = (char **)((int)ppcVar14 + 1);
					cVar1 = *(char *)ppcVar14;
					ppcVar14 = ppcVar18;
				} while (cVar1 != '\0');
				uVar10 = ~uVar10;
				ppcVar14 = (char **)((int)ppcVar18 - uVar10);
				ppcVar18 = local_280;
				for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
					*ppcVar18 = *ppcVar14;
					ppcVar14 = ppcVar14 + 1;
					ppcVar18 = ppcVar18 + 1;
				}
				for (uVar10 = uVar10 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {
					*(undefined *)ppcVar18 = *(undefined *)ppcVar14;
					ppcVar14 = (char **)((int)ppcVar14 + 1);
					ppcVar18 = (char **)((int)ppcVar18 + 1);
				}
				pcVar3 = lwExtractString((char *)local_280,"(sequence)",&local_4d0,&local_484);
				if (pcVar3 != (char *)0x0) {
					LVar12 = pLVar4->srfTexFlags;
					*(undefined *)((int)local_280 + (local_4d0 - 1)) = 0;
					pLVar4->srfTexFlags = LVar12 | TFM_SEQUENCE;
				}
				pcVar3 = stringAlloc((char *)local_280);
				pLVar4->srfPath = pcVar3;
			}
		}
		else {
			iVar6 = std::_strnicmp(&local_500,"COLR",4);
			if (iVar6 == 0) {
				std::sprintf(local_480," RGBA %d,%d,%d,%d");
				uVar10 = 0xffffffff;
				pcVar5 = local_480;
				do {
					pcVar20 = pcVar5;
					if (uVar10 == 0) break;
					uVar10 = uVar10 - 1;
					pcVar20 = pcVar5 + 1;
					cVar1 = *pcVar5;
					pcVar5 = pcVar20;
				} while (cVar1 != '\0');
				uVar10 = ~uVar10;
				iVar6 = -1;
				pcVar5 = local_200;
				do {
					pcVar19 = pcVar5;
					if (iVar6 == 0) break;
					iVar6 = iVar6 + -1;
					pcVar19 = pcVar5 + 1;
					cVar1 = *pcVar5;
					pcVar5 = pcVar19;
				} while (cVar1 != '\0');
				puVar15 = (undefined4 *)(pcVar20 + -uVar10);
				puVar21 = (undefined4 *)(pcVar19 + -1);
				for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
					*puVar21 = *puVar15;
					puVar15 = puVar15 + 1;
					puVar21 = puVar21 + 1;
				}
				for (uVar10 = uVar10 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {
					*(undefined *)puVar21 = *(undefined *)puVar15;
					puVar15 = (undefined4 *)((int)puVar15 + 1);
					puVar21 = (undefined4 *)((int)puVar21 + 1);
				}
				if (surf != (LWSURFACE **)0x0) {
					(pLVar4->srfCol).colRed = *(byte *)shapeName;
					(pLVar4->srfCol).colGreen = pcVar3[7];
					(pLVar4->srfCol).colBlue = pcVar3[8];
					(pLVar4->srfCol).colAlpha = pcVar3[9];
				}
			}
			else {
				iVar6 = std::_strnicmp(&local_500,"CTEX",4);
				if (iVar6 == 0) {
					uVar10 = 0xffffffff;
					ppcVar14 = shapeName;
					do {
						ppcVar18 = ppcVar14;
						if (uVar10 == 0) break;
						uVar10 = uVar10 - 1;
						ppcVar18 = (char **)((int)ppcVar14 + 1);
						cVar1 = *(char *)ppcVar14;
						ppcVar14 = ppcVar18;
					} while (cVar1 != '\0');
					uVar10 = ~uVar10;
					iVar6 = -1;
					pcVar3 = local_200;
					do {
						pcVar5 = pcVar3;
						if (iVar6 == 0) break;
						iVar6 = iVar6 + -1;
						pcVar5 = pcVar3 + 1;
						cVar1 = *pcVar3;
						pcVar3 = pcVar5;
					} while (cVar1 != '\0');
					ppcVar14 = (char **)((int)ppcVar18 - uVar10);
					ppcVar18 = (char **)(pcVar5 + -1);
					for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
						*ppcVar18 = *ppcVar14;
						ppcVar14 = ppcVar14 + 1;
						ppcVar18 = ppcVar18 + 1;
					}
					for (uVar10 = uVar10 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {
						*(undefined *)ppcVar18 = *(undefined *)ppcVar14;
						ppcVar14 = (char **)((int)ppcVar14 + 1);
						ppcVar18 = (char **)((int)ppcVar18 + 1);
					}
					if (surf != (LWSURFACE **)0x0) {
						LVar7 = texMapType((char *)shapeName);
						pLVar4->srfTexType = LVar7;
					}
				}
				else {
					iVar6 = std::_strnicmp(&local_500,"TTEX",4);
					if (iVar6 == 0) {
						uVar10 = 0xffffffff;
						ppcVar14 = shapeName;
						do {
							ppcVar18 = ppcVar14;
							if (uVar10 == 0) break;
							uVar10 = uVar10 - 1;
							ppcVar18 = (char **)((int)ppcVar14 + 1);
							cVar1 = *(char *)ppcVar14;
							ppcVar14 = ppcVar18;
						} while (cVar1 != '\0');
						uVar10 = ~uVar10;
						iVar6 = -1;
						pcVar3 = local_200;
						do {
							pcVar5 = pcVar3;
							if (iVar6 == 0) break;
							iVar6 = iVar6 + -1;
							pcVar5 = pcVar3 + 1;
							cVar1 = *pcVar3;
							pcVar3 = pcVar5;
						} while (cVar1 != '\0');
						ppcVar14 = (char **)((int)ppcVar18 - uVar10);
						ppcVar18 = (char **)(pcVar5 + -1);
						for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
							*ppcVar18 = *ppcVar14;
							ppcVar14 = ppcVar14 + 1;
							ppcVar18 = ppcVar18 + 1;
						}
						for (uVar10 = uVar10 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {
							*(undefined *)ppcVar18 = *(undefined *)ppcVar14;
							ppcVar14 = (char **)((int)ppcVar14 + 1);
							ppcVar18 = (char **)((int)ppcVar18 + 1);
						}
						if (surf != (LWSURFACE **)0x0) {
							pLVar8 = (LWSURFACE *)std::malloc(0x54);
							pLVar4->srfNextSurf = pLVar8;
							pLVar4 = pLVar8;
							for (iVar6 = 0x15; iVar6 != 0; iVar6 = iVar6 + -1) {
								pLVar4->srfName = (char *)0x0;
								pLVar4 = (LWSURFACE *)&pLVar4->srfNextSurf;
							}
							local_508 = pLVar8;
							LVar7 = texMapType((char *)shapeName);
							pLVar8->srfTexType = LVar7;
							pLVar4 = pLVar8;
						}
					}
					else {
						iVar6 = std::_strnicmp(&local_500,"TFLG",4);
						if (iVar6 == 0) {
							local_4f4 = (char **)0x0;
							if (surf != (LWSURFACE **)0x0) {
								LVar12 = (uint)(*(ushort *)shapeName >> 8) + (*(ushort *)shapeName & 0xff) * 0x100 &
												 0xffff;
								local_4c8[0] = "Axis_x";
								local_508->srfTexFlags = local_508->srfTexFlags | LVar12;
								local_4c8[1] = "Axis_y";
								local_4c8[2] = "Axis_z";
								local_4c8[3] = "World Coord";
								local_4b8 = "Negative Image";
								local_4b4 = "Pixel Blending";
								local_4b0 = "Anti Aliasing";
								std::sprintf(local_480,"%xH - ");
								local_50c = local_4c8;
								local_4f0 = 0;
								local_504 = 8;
								do {
									if ((LVar12 & 1 << ((byte)local_4f0 & 0x1f)) != 0) {
										if ((short)local_4f4 != 0) {
											uVar10 = 0xffffffff;
											pcVar3 = ",";
											do {
												pcVar5 = pcVar3;
												if (uVar10 == 0) break;
												uVar10 = uVar10 - 1;
												pcVar5 = pcVar3 + 1;
												cVar1 = *pcVar3;
												pcVar3 = pcVar5;
											} while (cVar1 != '\0');
											uVar10 = ~uVar10;
											iVar6 = -1;
											pcVar3 = local_480;
											do {
												pcVar20 = pcVar3;
												if (iVar6 == 0) break;
												iVar6 = iVar6 + -1;
												pcVar20 = pcVar3 + 1;
												cVar1 = *pcVar3;
												pcVar3 = pcVar20;
											} while (cVar1 != '\0');
											puVar15 = (undefined4 *)(pcVar5 + -uVar10);
											puVar21 = (undefined4 *)(pcVar20 + -1);
											for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
												*puVar21 = *puVar15;
												puVar15 = puVar15 + 1;
												puVar21 = puVar21 + 1;
											}
											for (uVar10 = uVar10 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {
												*(undefined *)puVar21 = *(undefined *)puVar15;
												puVar15 = (undefined4 *)((int)puVar15 + 1);
												puVar21 = (undefined4 *)((int)puVar21 + 1);
											}
										}
										local_4f4 = (char **)((int)local_4f4 + 1);
										uVar10 = 0xffffffff;
										pcVar3 = *local_50c;
										do {
											pcVar5 = pcVar3;
											if (uVar10 == 0) break;
											uVar10 = uVar10 - 1;
											pcVar5 = pcVar3 + 1;
											cVar1 = *pcVar3;
											pcVar3 = pcVar5;
										} while (cVar1 != '\0');
										uVar10 = ~uVar10;
										iVar6 = -1;
										pcVar3 = local_480;
										do {
											pcVar20 = pcVar3;
											if (iVar6 == 0) break;
											iVar6 = iVar6 + -1;
											pcVar20 = pcVar3 + 1;
											cVar1 = *pcVar3;
											pcVar3 = pcVar20;
										} while (cVar1 != '\0');
										puVar15 = (undefined4 *)(pcVar5 + -uVar10);
										puVar21 = (undefined4 *)(pcVar20 + -1);
										for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
											*puVar21 = *puVar15;
											puVar15 = puVar15 + 1;
											puVar21 = puVar21 + 1;
										}
										for (uVar10 = uVar10 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {
											*(undefined *)puVar21 = *(undefined *)puVar15;
											puVar15 = (undefined4 *)((int)puVar15 + 1);
											puVar21 = (undefined4 *)((int)puVar21 + 1);
										}
									}
									local_4f0 = local_4f0 + 1;
									local_50c = local_50c + 1;
									local_504 = local_504 - 1;
								} while (local_504 != 0);
LAB_0048d1d2:
								uVar10 = 0xffffffff;
								pcVar3 = local_480;
								do {
									pcVar5 = pcVar3;
									if (uVar10 == 0) break;
									uVar10 = uVar10 - 1;
									pcVar5 = pcVar3 + 1;
									cVar1 = *pcVar3;
									pcVar3 = pcVar5;
								} while (cVar1 != '\0');
								uVar10 = ~uVar10;
								iVar6 = -1;
								pcVar3 = local_200;
								do {
									pcVar20 = pcVar3;
									if (iVar6 == 0) break;
									iVar6 = iVar6 + -1;
									pcVar20 = pcVar3 + 1;
									cVar1 = *pcVar3;
									pcVar3 = pcVar20;
								} while (cVar1 != '\0');
								puVar15 = (undefined4 *)(pcVar5 + -uVar10);
								puVar21 = (undefined4 *)(pcVar20 + -1);
								for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
									*puVar21 = *puVar15;
									puVar15 = puVar15 + 1;
									puVar21 = puVar21 + 1;
								}
								for (uVar10 = uVar10 & 3; pLVar4 = local_508, uVar10 != 0; uVar10 = uVar10 - 1) {
									*(undefined *)puVar21 = *(undefined *)puVar15;
									puVar15 = (undefined4 *)((int)puVar15 + 1);
									puVar21 = (undefined4 *)((int)puVar21 + 1);
								}
							}
						}
						else {
							iVar6 = std::_strnicmp(&local_500,"FLAG",4);
							if (iVar6 == 0) {
								local_50c = (char **)0x0;
								if (surf != (LWSURFACE **)0x0) {
									local_4ac[0] = "Luminous";
									LVar13 = (uint)(*(ushort *)shapeName >> 8) + (*(ushort *)shapeName & 0xff) * 0x100
													 & 0xffff;
									local_4ac[1] = "Outline";
									local_4ac[2] = "Smoothing";
									local_4ac[3] = "Color Highlights";
									local_49c = "Color Filter";
									local_498 = "Opaque Edge";
									local_494 = "Transparent Edge";
									local_490 = "Sharp Terminator";
									local_48c = "Double Sided";
									local_488 = "Additive";
									local_508->srfFlags = LVar13;
									std::sprintf(local_480,"%xH - ");
									local_4f4 = local_4ac;
									local_504 = 0;
									local_4f0 = 10;
									do {
										if ((LVar13 & 1 << ((byte)local_504 & 0x1f)) != 0) {
											if ((short)local_50c != 0) {
												uVar10 = 0xffffffff;
												pcVar3 = ",";
												do {
													pcVar5 = pcVar3;
													if (uVar10 == 0) break;
													uVar10 = uVar10 - 1;
													pcVar5 = pcVar3 + 1;
													cVar1 = *pcVar3;
													pcVar3 = pcVar5;
												} while (cVar1 != '\0');
												uVar10 = ~uVar10;
												iVar6 = -1;
												pcVar3 = local_480;
												do {
													pcVar20 = pcVar3;
													if (iVar6 == 0) break;
													iVar6 = iVar6 + -1;
													pcVar20 = pcVar3 + 1;
													cVar1 = *pcVar3;
													pcVar3 = pcVar20;
												} while (cVar1 != '\0');
												puVar15 = (undefined4 *)(pcVar5 + -uVar10);
												puVar21 = (undefined4 *)(pcVar20 + -1);
												for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
													*puVar21 = *puVar15;
													puVar15 = puVar15 + 1;
													puVar21 = puVar21 + 1;
												}
												for (uVar10 = uVar10 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {
													*(undefined *)puVar21 = *(undefined *)puVar15;
													puVar15 = (undefined4 *)((int)puVar15 + 1);
													puVar21 = (undefined4 *)((int)puVar21 + 1);
												}
											}
											local_50c = (char **)((int)local_50c + 1);
											uVar10 = 0xffffffff;
											pcVar3 = *local_4f4;
											do {
												pcVar5 = pcVar3;
												if (uVar10 == 0) break;
												uVar10 = uVar10 - 1;
												pcVar5 = pcVar3 + 1;
												cVar1 = *pcVar3;
												pcVar3 = pcVar5;
											} while (cVar1 != '\0');
											uVar10 = ~uVar10;
											iVar6 = -1;
											pcVar3 = local_480;
											do {
												pcVar20 = pcVar3;
												if (iVar6 == 0) break;
												iVar6 = iVar6 + -1;
												pcVar20 = pcVar3 + 1;
												cVar1 = *pcVar3;
												pcVar3 = pcVar20;
											} while (cVar1 != '\0');
											puVar15 = (undefined4 *)(pcVar5 + -uVar10);
											puVar21 = (undefined4 *)(pcVar20 + -1);
											for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
												*puVar21 = *puVar15;
												puVar15 = puVar15 + 1;
												puVar21 = puVar21 + 1;
											}
											for (uVar10 = uVar10 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {
												*(undefined *)puVar21 = *(undefined *)puVar15;
												puVar15 = (undefined4 *)((int)puVar15 + 1);
												puVar21 = (undefined4 *)((int)puVar21 + 1);
											}
										}
										local_504 = local_504 + 1;
										local_4f4 = local_4f4 + 1;
										local_4f0 = local_4f0 + -1;
									} while (local_4f0 != 0);
									goto LAB_0048d1d2;
								}
							}
							else {
								iVar6 = std::_strnicmp(&local_500,"TSIZ",4);
								if (iVar6 == 0) {
									if (surf != (LWSURFACE **)0x0) {
										local_50c = shapeName;
										LWD3D((byte **)&local_50c,(float *)&local_4dc);
										LWD3D((byte **)&local_50c,(float *)&local_4d8);
										LWD3D((byte **)&local_50c,(float *)&local_4d4);
										std::sprintf(local_480," (%f,%f,%f)");
										(pLVar4->srfTexSize).tdX = (float)local_4dc;
										(pLVar4->srfTexSize).tdY = (float)local_4d8;
										(pLVar4->srfTexSize).tdZ = (float)local_4d4;
LAB_0048d369:
										uVar10 = 0xffffffff;
										pcVar3 = local_480;
										do {
											pcVar5 = pcVar3;
											if (uVar10 == 0) break;
											uVar10 = uVar10 - 1;
											pcVar5 = pcVar3 + 1;
											cVar1 = *pcVar3;
											pcVar3 = pcVar5;
										} while (cVar1 != '\0');
										uVar10 = ~uVar10;
										iVar6 = -1;
										pcVar3 = local_200;
										do {
											pcVar20 = pcVar3;
											if (iVar6 == 0) break;
											iVar6 = iVar6 + -1;
											pcVar20 = pcVar3 + 1;
											cVar1 = *pcVar3;
											pcVar3 = pcVar20;
										} while (cVar1 != '\0');
										puVar15 = (undefined4 *)(pcVar5 + -uVar10);
										puVar21 = (undefined4 *)(pcVar20 + -1);
										for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
											*puVar21 = *puVar15;
											puVar15 = puVar15 + 1;
											puVar21 = puVar21 + 1;
										}
										for (uVar10 = uVar10 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {
											*(undefined *)puVar21 = *(undefined *)puVar15;
											puVar15 = (undefined4 *)((int)puVar15 + 1);
											puVar21 = (undefined4 *)((int)puVar21 + 1);
										}
									}
								}
								else {
									iVar6 = std::_strnicmp(&local_500,"TCTR",4);
									if ((iVar6 == 0) && (surf != (LWSURFACE **)0x0)) {
										local_50c = shapeName;
										LWD3D((byte **)&local_50c,(float *)&local_4e8);
										LWD3D((byte **)&local_50c,(float *)&local_4e4);
										LWD3D((byte **)&local_50c,(float *)&local_4e0);
										std::sprintf(local_480," (%f,%f,%f)");
										(pLVar4->srfTexCentre).tdX = (float)local_4e8;
										(pLVar4->srfTexCentre).tdY = (float)local_4e4;
										(pLVar4->srfTexCentre).tdZ = (float)local_4e0;
										goto LAB_0048d369;
									}
								}
							}
						}
					}
				}
			}
		}
		iVar16 = 0;
		iVar6 = std::_strnicmp(&local_500,"TRAN",4);
		if (iVar6 == 0) {
			iVar16 = 1;
		}
		else {
			iVar6 = std::_strnicmp(&local_500,"DIFF",4);
			if (iVar6 == 0) {
				iVar16 = 2;
			}
			else {
				iVar6 = std::_strnicmp(&local_500,"LUMI",4);
				if (iVar6 == 0) {
					iVar16 = 3;
				}
				else {
					iVar6 = std::_strnicmp(&local_500,"REFL",4);
					if (iVar6 == 0) {
						iVar16 = 4;
					}
					else {
						iVar6 = std::_strnicmp(&local_500,"SPEC",4);
						if (iVar6 == 0) {
							iVar16 = 5;
						}
						else {
							iVar6 = std::_strnicmp(&local_500,"GLOS",4);
							if (iVar6 == 0) {
								iVar16 = 6;
							}
						}
					}
				}
			}
		}
		if ((iVar16 != 0) && (surf != (LWSURFACE **)0x0)) {
			local_504 = (uint)(*(ushort *)shapeName >> 8) + (*(ushort *)shapeName & 0xff) * 0x100 & 0xffff
			;
			fVar2 = (float)local_504 * 0.00390625;
			switch(iVar16) {
			case 1:
				pLVar4->srfTransparent = fVar2;
				break;
			case 2:
				pLVar4->srfDiffuse = fVar2;
				break;
			case 3:
				pLVar4->srfLuminous = fVar2;
				break;
			case 4:
				pLVar4->srfReflect = fVar2;
				break;
			case 5:
				pLVar4->srfSpecular = fVar2;
				break;
			case 6:
				pLVar4->srfSpecPower = fVar2;
			}
			std::sprintf(local_480,"%f");
			uVar10 = 0xffffffff;
			pcVar3 = local_480;
			do {
				pcVar5 = pcVar3;
				if (uVar10 == 0) break;
				uVar10 = uVar10 - 1;
				pcVar5 = pcVar3 + 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar5;
			} while (cVar1 != '\0');
			uVar10 = ~uVar10;
			iVar6 = -1;
			pcVar3 = local_200;
			do {
				pcVar20 = pcVar3;
				if (iVar6 == 0) break;
				iVar6 = iVar6 + -1;
				pcVar20 = pcVar3 + 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar20;
			} while (cVar1 != '\0');
			puVar15 = (undefined4 *)(pcVar5 + -uVar10);
			puVar21 = (undefined4 *)(pcVar20 + -1);
			for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 = uVar11 - 1) {
				*puVar21 = *puVar15;
				puVar15 = puVar15 + 1;
				puVar21 = puVar21 + 1;
			}
			for (uVar10 = uVar10 & 3; uVar10 != 0; uVar10 = uVar10 - 1) {
				*(undefined *)puVar21 = *(undefined *)puVar15;
				puVar15 = (undefined4 *)((int)puVar15 + 1);
				puVar21 = (undefined4 *)((int)puVar21 + 1);
			}
		}
		pcVar3 = (char *)((int)shapeName + local_4cc);
		iVar9 = iVar9 + (-6 - local_4cc);
	} while( true );
}



BOOL __cdecl
lego::lw::LoadLWOB(char *fn,LWSIZE *sd,float **verts,LWPOLY **polys,LWSURFACE **surfs,
									FileStream **out_fileUV,BOOL dflag)
{
	FileStream *f;
	LWSIZE *sizeData;
	BOOL BVar1;
	FileStream *pFVar2;
	int iVar3;
	int iVar4;
	char *pcVar5;
	uint uVar6;
	byte *pbVar7;
	LWSURFACE *pLVar8;
	char **ppcVar9;
	uint local_534;
	uint local_530;
	LWSURFLIST *local_52c;
	uint local_528;
	char local_524;
	undefined4 local_523;
	undefined4 local_51f;
	undefined local_51b;
	uint local_518;
	uint local_514;
	char *local_510;
	FileStream *local_50c;
	LWSIZE *local_508;
	LWSURFACE *local_504;
	char filenameLwo [256];
	char buff [1024];
	
	local_523 = 0;
	local_51f = 0;
	local_524 = '\0';
	local_51b = 0;
	local_530 = 0;
	std::sprintf(filenameLwo,"%s.lwo",fn);
	f = lego::file::File_Open(filenameLwo,"rb");
	if (f == (FileStream *)0x0) {
		return 0;
	}
	local_50c = f;
	sizeData = (LWSIZE *)std::malloc(0xc);
	sizeData->lwSurfaceCount = 0;
	sizeData->lwPolyCount = 0;
	sizeData->lwVertCount = 0;
	local_508 = sizeData;
	if (out_fileUV != (FileStream **)0x0) {
		std::sprintf(filenameLwo,"%s.uv",fn);
		BVar1 = lego::file::File_Exists(filenameLwo);
		if (BVar1 == 0) {
			*out_fileUV = (FileStream *)0x0;
		}
		else {
			pFVar2 = lego::file::File_Open(filenameLwo,"rb");
			*out_fileUV = pFVar2;
		}
	}
	lego::file::File_Read(&local_524,4,1,f);
	iVar3 = std::_stricmp(&local_524,"FORM");
	if (iVar3 == 0) {
		lego::file::File_Read(&local_518,4,1,f);
		local_518 = ((local_518 & 0xff00) + (local_518 & 0xff) * 0x10000) * 0x100 +
								(local_518 >> 0x10 & 0xff) * 0x100 + (local_518 >> 0x18);
		lego::file::File_Read(&local_524,4,1,f);
		iVar3 = std::_stricmp(&local_524,"LWOB");
		if (iVar3 == 0) {
			for (iVar3 = local_518 - 4; 0 < iVar3; iVar3 = iVar3 + (-8 - local_534)) {
				lego::file::File_Read(&local_524,4,1,f);
				lego::file::File_Read(&local_534,4,1,f);
				local_534 = ((local_534 & 0xff00) + (local_534 & 0xff) * 0x10000) * 0x100 +
										(local_534 >> 0x10 & 0xff) * 0x100 + (local_534 >> 0x18);
				if (dflag != 0) {
					std::sprintf(buff,"LW OBJECT %s %d\n",&local_524,local_534);
				}
				iVar4 = std::_stricmp(&local_524,"PNTS");
				if (iVar4 == 0) {
					PNTSprc(f,sizeData,local_534,verts,dflag);
				}
				else {
					iVar4 = std::_stricmp(&local_524,"SRFS");
					if (iVar4 == 0) {
						SRFSprc(f,sizeData,&local_52c,local_534,&local_530,dflag);
					}
					else {
						iVar4 = std::_stricmp(&local_524,"SURF");
						if (iVar4 == 0) {
							SURFprc(f,sizeData,surfs,local_534,dflag);
						}
						else {
							iVar4 = std::_stricmp(&local_524,"CRVS");
							if (iVar4 == 0) {
								CRVSprc(f,local_534,dflag);
							}
							else {
								iVar4 = std::_stricmp(&local_524,"POLS");
								if (iVar4 == 0) {
									POLSprc(f,sizeData,polys,local_534,dflag);
								}
								else {
									lego::file::File_Seek(f,local_534,1);
								}
							}
						}
					}
				}
			}
			local_528 = sizeData->lwSurfaceCount;
			if (((surfs != (LWSURFACE **)0x0) && (local_52c != (LWSURFLIST *)0x0)) &&
				 (sizeData != (LWSIZE *)0x0)) {
				local_504 = (LWSURFACE *)std::malloc(local_530 * 0x54);
				pLVar8 = local_504;
				for (uVar6 = local_530 * 0x15 & 0x3fffffff; uVar6 != 0; uVar6 = uVar6 - 1) {
					pLVar8->srfName = (char *)0x0;
					pLVar8 = (LWSURFACE *)&pLVar8->srfNextSurf;
				}
				for (iVar3 = 0; iVar3 != 0; iVar3 = iVar3 + -1) {
					*(undefined *)&pLVar8->srfName = 0;
					pLVar8 = (LWSURFACE *)((int)&pLVar8->srfName + 1);
				}
				local_514 = 0;
				if (local_530 != 0) {
					pbVar7 = &(local_504->srfCol).colGreen;
					do {
						uVar6 = 0;
						local_510 = local_52c->srflName[local_514];
						if (local_528 != 0) {
							iVar3 = 0;
LAB_0048d940:
							iVar4 = std::_stricmp(*(char **)((*surfs)->srfTCLR + iVar3 + -0x10),local_510);
							if (iVar4 != 0) goto code_r0x0048d95e;
							pLVar8 = *surfs + uVar6;
							ppcVar9 = (char **)(pbVar7 + -0xd);
							for (iVar3 = 0x15; f = local_50c, iVar3 != 0; iVar3 = iVar3 + -1) {
								*ppcVar9 = pLVar8->srfName;
								pLVar8 = (LWSURFACE *)&pLVar8->srfNextSurf;
								ppcVar9 = ppcVar9 + 1;
							}
						}
LAB_0048d990:
						if (uVar6 == local_528) {
							pcVar5 = stringAlloc("Default");
							*(char **)(pbVar7 + -0xd) = pcVar5;
							pbVar7[-1] = 0xff;
							*pbVar7 = 0xff;
							pbVar7[1] = 0xff;
							local_528 = local_530;
						}
						pbVar7 = pbVar7 + 0x54;
						local_514 = local_514 + 1;
						sizeData = local_508;
					} while (local_514 < local_530);
				}
				pLVar8 = local_504;
				std::free(*surfs);
				*surfs = pLVar8;
			}
			sizeData->lwSurfaceCount = local_528;
			if (sd != (LWSIZE *)0x0) {
				sd->lwVertCount = sizeData->lwVertCount;
				sd->lwPolyCount = sizeData->lwPolyCount;
				sd->lwSurfaceCount = sizeData->lwSurfaceCount;
			}
			std::free(sizeData);
			if (local_530 != 0) {
				uVar6 = 0;
				if (local_530 != 0) {
					do {
						std::free(local_52c->srflName[uVar6]);
						uVar6 = uVar6 + 1;
					} while (uVar6 < local_530);
				}
				std::free(local_52c->srflName);
				std::free(local_52c);
			}
			lego::file::File_Close(f);
			return TRUE;
		}
	}
	std::free(sizeData);
	lego::file::File_Close(f);
	std::sprintf(buff,"Error in Lightwave file %s",fn);
	return 0;
code_r0x0048d95e:
	uVar6 = uVar6 + 1;
	iVar3 = iVar3 + 0x54;
	if (local_528 <= uVar6) goto LAB_0048d990;
	goto LAB_0048d940;
}



BOOL __cdecl lego::lw::LoadAppObj(char *fn,APPOBJ **out_ao,BOOL flag)
{
	APPOBJ *pAVar1;
	char *pcVar2;
	BOOL BVar3;
	int iVar4;
	char path [128];
	
	pAVar1 = (APPOBJ *)std::malloc(0x20);
	*out_ao = pAVar1;
	for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {
		pAVar1->aoPath = (char *)0x0;
		pAVar1 = (APPOBJ *)&pAVar1->aoSize;
	}
	std::_splitpath(fn,(char *)0x0,path,(char *)0x0,(char *)0x0);
	pcVar2 = stringAlloc(path);
	(*out_ao)->aoPath = pcVar2;
	pAVar1 = *out_ao;
	BVar3 = LoadLWOB(fn,&pAVar1->aoSize,&pAVar1->aoVerts,&pAVar1->aoPoly,&pAVar1->aoSurface,
									 &pAVar1->aoFileUV,flag);
	if (BVar3 != 0) {
		return TRUE;
	}
	std::free((*out_ao)->aoPath);
	std::free(*out_ao);
	return 0;
}



BOOL __cdecl lego::lw::FreeLWOB(APPOBJ *ao)
{
	uint uVar1;
	LWSURFACE *srf;
	int iVar2;
	
	if (ao != (APPOBJ *)0x0) {
		if (ao->aoFileUV != (FileStream *)0x0) {
			lego::file::File_Close(ao->aoFileUV);
		}
		srf = ao->aoSurface;
		if (srf != (LWSURFACE *)0x0) {
			for (uVar1 = (ao->aoSize).lwSurfaceCount; uVar1 != 0; uVar1 = uVar1 - 1) {
				surfFree(srf,0);
				srf = srf + 1;
			}
			std::free(ao->aoSurface);
		}
		if (ao->aoPoly != (LWPOLY *)0x0) {
			uVar1 = (ao->aoSize).lwPolyCount;
			if (uVar1 != 0) {
				iVar2 = 0;
				do {
					std::free(*(void **)((int)&ao->aoPoly->plyData + iVar2));
					iVar2 = iVar2 + 0xc;
					uVar1 = uVar1 - 1;
				} while (uVar1 != 0);
			}
			std::free(ao->aoPoly);
		}
		std::free(ao->aoVerts);
		std::free(ao->aoPath);
		std::free(ao);
		return TRUE;
	}
	return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
// Name: __fpmath
// Library: Visual Studio 1998 Release

void __cdecl __fpmath(int param_1)
{
	std::internal::__fpmath_internal();
	_DAT_0054a0cc = std::internal::__fpmath__00490540();
	__setdefaultprecision();
	return;
}



void std::internal::__fpmath_internal(void)
{
	PTR___std_FUN_004b0f80 = __std_FUN_00490a10;
	PTR___std_FUN_004b0f84 = __fpmath__004905d0;
	PTR___std_FUN_004b0f88 = __std_FUN_00490660;
	PTR___std_FUN_004b0f8c = __fpmath__00490570;
	PTR___std_FUN_004b0f90 = __fpmath_isdouble_ge_0;
	PTR___std_FUN_004b0f94 = __std_FUN_00490a10;
	return;
}



float10 __cdecl std::atof(char *str)
{
	byte bVar1;
	uint uVar2;
	undefined *puVar3;
	int iVar4;
	byte *pbVar5;
	
	while( true ) {
										// int std::isspace(int c)
		if (globals::_pcharwidth < 2) {
			uVar2 = *(byte *)(globals::_pctype + (byte)*str) & C1_SPACE;
		}
		else {
			uVar2 = _isctype((uint)(byte)*str,C1_SPACE);
		}
		if (uVar2 == 0) break;
		str = (char *)((byte *)str + 1);
	}
	iVar4 = -1;
	pbVar5 = (byte *)str;
	do {
		if (iVar4 == 0) break;
		iVar4 = iVar4 + -1;
		bVar1 = *pbVar5;
		pbVar5 = pbVar5 + 1;
	} while (bVar1 != 0);
	puVar3 = internal::__atof_internal(str);
	return (float10)*(double *)(puVar3 + 0x10);
}



int __cdecl std::sprintf(char *out_buffer,char *format,...)
{
	int iVar1;
	FILE dummyFile;
	
	dummyFile._base = out_buffer;
	dummyFile._ptr = out_buffer;
	dummyFile._flag = 0x42;
	dummyFile._cnt = 0x7fffffff;
	iVar1 = internal::__vfprintf_internal(&dummyFile,format,&stack0x0000000c);
	dummyFile._cnt = dummyFile._cnt + -1;
	if (-1 < dummyFile._cnt) {
		*dummyFile._ptr = '\0';
		return iVar1;
	}
	internal::__fafterwrite_00490b60(0,(char **)&dummyFile);
	return iVar1;
}



char * __cdecl std::strstr(char *str,char *strSearch)
{
	char *pcVar1;
	char *pcVar2;
	char cVar3;
	uint uVar4;
	char cVar5;
	uint uVar6;
	char *pcVar7;
	uint uVar8;
	uint *puVar9;
	char *pcVar10;
	
	cVar3 = *strSearch;
	if (cVar3 == '\0') {
		return (char *)(uint *)str;
	}
	if (strSearch[1] == '\0') {
		uVar4 = (uint)str & 3;
		while (uVar4 != 0) {
			if (*str == cVar3) {
				return (char *)(uint *)str;
			}
			if (*str == '\0') {
				return (char *)(uint *)0x0;
			}
			uVar4 = (uint)(uint *)((int)str + 1) & 3;
			str = (char *)(uint *)((int)str + 1);
		}
		while( true ) {
			while( true ) {
				uVar4 = *(uint *)str;
				uVar8 = uVar4 ^ CONCAT22(CONCAT11(cVar3,cVar3),CONCAT11(cVar3,cVar3));
				uVar6 = uVar4 ^ 0xffffffff ^ uVar4 + 0x7efefeff;
				puVar9 = (uint *)((int)str + 4);
				if (((uVar8 ^ 0xffffffff ^ uVar8 + 0x7efefeff) & 0x81010100) != 0) break;
				str = (char *)puVar9;
				if ((uVar6 & 0x81010100) != 0) {
					if ((uVar6 & 0x1010100) != 0) {
						return (char *)(uint *)0x0;
					}
					if ((uVar4 + 0x7efefeff & 0x80000000) == 0) {
						return (char *)(uint *)0x0;
					}
				}
			}
			uVar4 = *(uint *)str;
			if ((char)uVar4 == cVar3) {
				return (char *)(uint *)str;
			}
			if ((char)uVar4 == '\0') {
				return (char *)(uint *)0x0;
			}
			cVar5 = (char)(uVar4 >> 8);
			if (cVar5 == cVar3) {
				return (char *)(uint *)((int)str + 1);
			}
			if (cVar5 == '\0') break;
			cVar5 = (char)(uVar4 >> 0x10);
			if (cVar5 == cVar3) {
				return (char *)(uint *)((int)str + 2);
			}
			if (cVar5 == '\0') {
				return (char *)(uint *)0x0;
			}
			cVar5 = (char)(uVar4 >> 0x18);
			if (cVar5 == cVar3) {
				return (char *)(uint *)((int)str + 3);
			}
			str = (char *)puVar9;
			if (cVar5 == '\0') {
				return (char *)(uint *)0x0;
			}
		}
		return (char *)(uint *)0x0;
	}
	do {
		cVar5 = *str;
		do {
			while (str = str + 1, cVar5 != cVar3) {
				if (cVar5 == '\0') {
					return (char *)(uint *)0x0;
				}
				cVar5 = *str;
			}
			cVar5 = *str;
			pcVar10 = str + 1;
			pcVar7 = strSearch;
		} while (cVar5 != strSearch[1]);
		do {
			if (pcVar7[2] == '\0') {
LAB_0048dd83:
				return (char *)(uint *)(str + -1);
			}
			if (*pcVar10 != pcVar7[2]) break;
			pcVar1 = pcVar7 + 3;
			if (*pcVar1 == '\0') goto LAB_0048dd83;
			pcVar2 = pcVar10 + 1;
			pcVar7 = pcVar7 + 2;
			pcVar10 = pcVar10 + 2;
		} while (*pcVar1 == *pcVar2);
	} while( true );
}



int __cdecl std::internal::__atoi_internal(char *str)
{
	byte bVar1;
	uint uVar2;
	uint uVar3;
	uint c;
	int iVar4;
	byte *pbVar5;
	
	while( true ) {
		if (std::globals::_pcharwidth < 2) {
			uVar2 = *(byte *)(std::globals::_pctype + (byte)*str) & 8;
		}
		else {
			uVar2 = _isctype((uint)(byte)*str,8);
		}
		if (uVar2 == 0) break;
		str = (char *)((byte *)str + 1);
	}
	uVar2 = (uint)(byte)*str;
	pbVar5 = (byte *)str + 1;
	if ((uVar2 == '-') || (c = uVar2, uVar2 == '+')) {
		c = (uint)*pbVar5;
		pbVar5 = (byte *)str + 2;
	}
	iVar4 = 0;
	while( true ) {
		if (std::globals::_pcharwidth < 2) {
			uVar3 = *(byte *)(std::globals::_pctype + c) & 4;
		}
		else {
			uVar3 = _isctype(c,C1_DIGIT);
		}
		if (uVar3 == 0) break;
		bVar1 = *pbVar5;
		pbVar5 = pbVar5 + 1;
		iVar4 = (c - 0x30) + iVar4 * 10;
		c = (uint)bVar1;
	}
	if (uVar2 == '-') {
		iVar4 = -iVar4;
	}
	return iVar4;
}



int __cdecl std::atoi(char *str)
{
	int iVar1;
	
	iVar1 = internal::__atoi_internal(str);
	return iVar1;
}



void __cdecl std::free(void *buffer)
{
	void *lpMem;
	byte *pbVar1;
	int *local_4;
	
	lpMem = buffer;
	if (buffer != (void *)0x0) {
		pbVar1 = (byte *)internal::__realloc_free__00491b00
															 ((undefined *)buffer,&local_4,(uint *)&buffer);
		if (pbVar1 != (byte *)0x0) {
			internal::__free_realloc__00491b60((int)local_4,(int)buffer,pbVar1);
			return;
		}
		HeapFree(DAT_0076eec4,0,lpMem);
	}
	return;
}



void * __cdecl std::malloc(uint length)
{
	void *buffer;
	
	buffer = internal::__malloc_handlermode(length,internal::globals::__g_malloc_handlermode);
	return buffer;
}



void * __cdecl std::internal::__malloc_handlermode(uint length,BOOL new_handlermode)
{
	void *pvVar1;
	BOOL BVar2;
	
	if (length < 0xffffffe1) {
		if (length == 0) {
			length = 1;
		}
		do {
			if (length < 0xffffffe1) {
				pvVar1 = __malloc_2__0048df00(length);
			}
			else {
				pvVar1 = (void *)0x0;
			}
			if (pvVar1 != (void *)0x0) {
				return pvVar1;
			}
			if (new_handlermode == 0) {
				return (void *)0x0;
			}
			BVar2 = __call_new_handler(length);
		} while (BVar2 != 0);
	}
	return (void *)0x0;
}



void * __cdecl std::internal::__malloc_2__0048df00(uint length)
{
	int *piVar1;
	uint dwBytes;
	
	dwBytes = length + 0xf & 0xfffffff0;
	if ((dwBytes <= UINT_004b2fdc) &&
		 (piVar1 = __malloc__00491bc0((int *)(length + 0xf >> 4)), piVar1 != (int *)0x0)) {
		return piVar1;
	}
	piVar1 = (int *)HeapAlloc(DAT_0076eec4,0,dwBytes);
	return piVar1;
}



void * __cdecl std::realloc(void *memblock,uint size)
{
	int *piVar1;
	int **ppiVar2;
	int iVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	int *piVar7;
	int *piVar8;
	int **local_8;
	int *local_4;
	
	if (memblock == (void *)0x0) {
		piVar1 = (int *)malloc(size);
		return piVar1;
	}
	if (size == 0) {
		free(memblock);
		return (int *)0x0;
	}
	if (size < 0xffffffe1) {
		if (size == 0) {
			size = 0x10;
		}
		else {
			size = size + 0xf & 0xfffffff0;
		}
	}
	do {
		piVar1 = (int *)0x0;
		if (size < 0xffffffe1) {
			ppiVar2 = (int **)internal::__realloc_free__00491b00
																	((undefined *)memblock,&local_4,(uint *)&local_8);
			if (ppiVar2 == (int **)0x0) {
				piVar1 = (int *)HeapReAlloc(DAT_0076eec4,0,memblock,size);
				goto LAB_0048e0aa;
			}
			if (size < UINT_004b2fdc) {
				iVar3 = internal::__realloc__00491f80((int)local_4,local_8,ppiVar2,(uint)(int *)(size >> 4))
				;
				piVar1 = (int *)memblock;
				if (iVar3 != 0) goto LAB_0048e03f;
				piVar1 = internal::__malloc__00491bc0((int *)(size >> 4));
				if (piVar1 != (int *)0x0) {
					uVar6 = (uint)*(byte *)ppiVar2 << 4;
					if (size <= (uint)*(byte *)ppiVar2 << 4) {
						uVar6 = size;
					}
					piVar7 = (int *)memblock;
					piVar8 = piVar1;
					for (uVar5 = uVar6 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
						*piVar8 = *piVar7;
						piVar7 = piVar7 + 1;
						piVar8 = piVar8 + 1;
					}
					for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
						*(undefined *)piVar8 = *(undefined *)piVar7;
						piVar7 = (int *)((int)piVar7 + 1);
						piVar8 = (int *)((int)piVar8 + 1);
					}
					internal::__free_realloc__00491b60((int)local_4,(int)local_8,(byte *)ppiVar2);
					goto LAB_0048e03f;
				}
			}
			else {
LAB_0048e03f:
				if (piVar1 != (int *)0x0) {
					return piVar1;
				}
			}
			piVar1 = (int *)HeapAlloc(DAT_0076eec4,0,size);
			if (piVar1 != (int *)0x0) {
				uVar6 = (uint)*(byte *)ppiVar2 << 4;
				if (size <= (uint)*(byte *)ppiVar2 << 4) {
					uVar6 = size;
				}
				piVar7 = (int *)memblock;
				piVar8 = piVar1;
				for (uVar5 = uVar6 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
					*piVar8 = *piVar7;
					piVar7 = piVar7 + 1;
					piVar8 = piVar8 + 1;
				}
				for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
					*(undefined *)piVar8 = *(undefined *)piVar7;
					piVar7 = (int *)((int)piVar7 + 1);
					piVar8 = (int *)((int)piVar8 + 1);
				}
				internal::__free_realloc__00491b60((int)local_4,(int)local_8,(byte *)ppiVar2);
				goto LAB_0048e0aa;
			}
		}
		else {
LAB_0048e0aa:
			if (piVar1 != (int *)0x0) {
				return piVar1;
			}
		}
		if (internal::globals::__g_malloc_handlermode == 0) {
			return piVar1;
		}
		BVar4 = internal::__call_new_handler(size);
		if (BVar4 == 0) {
			return (int *)0x0;
		}
	} while( true );
}



void __cdecl std::qsort(void *base,uint number,uint width,CompareCallback *compare)
{
	uint uVar1;
	int iVar2;
	byte *a;
	byte *b;
	byte *local_100;
	byte **local_fc;
	byte **local_f8;
	int local_f4;
	byte *local_f0 [30];
	byte *local_78 [30];
	
	if ((number < 2) || (width == 0)) {
		return;
	}
	local_100 = (byte *)((number - 1) * width + (int)base);
	local_fc = local_f0;
	local_f8 = local_78;
	local_f4 = 0;
LAB_0048e134:
	uVar1 = (uint)(local_100 + -(int)base) / width + 1;
	if (8 < uVar1) {
		internal::__memswap((byte *)((int)base + (uVar1 >> 1) * width),(byte *)base,width);
		b = local_100 + width;
		a = (byte *)base;
LAB_0048e1ae:
		a = a + width;
		if (a <= local_100) goto code_r0x0048e1b8;
		goto LAB_0048e1c8;
	}
	internal::__qsort((byte *)base,local_100,width,compare);
	goto LAB_0048e155;
code_r0x0048e1b8:
	iVar2 = (*compare)(a,base);
	if (iVar2 < 1) goto LAB_0048e1ae;
LAB_0048e1c8:
	do {
		b = b + -width;
		if (b <= base) break;
		iVar2 = (*compare)(b,base);
	} while (-1 < iVar2);
	if (a <= b) {
		internal::__memswap(a,b,width);
		goto LAB_0048e1ae;
	}
	internal::__memswap((byte *)base,b,width);
	if ((int)(b + (-1 - (int)base)) < (int)(local_100 + -(int)a)) {
		if (a < local_100) {
			*local_f8 = a;
			*local_fc = local_100;
			local_f4 = local_f4 + 1;
			local_f8 = local_f8 + 1;
			local_fc = local_fc + 1;
		}
		if ((byte *)((int)base + width) < b) {
			local_100 = b + -width;
			goto LAB_0048e134;
		}
	}
	else {
		if ((byte *)((int)base + width) < b) {
			*local_f8 = (byte *)base;
			*local_fc = b + -width;
			local_f4 = local_f4 + 1;
			local_f8 = local_f8 + 1;
			local_fc = local_fc + 1;
		}
		base = a;
		if (a < local_100) goto LAB_0048e134;
	}
LAB_0048e155:
	local_f4 = local_f4 + -1;
	local_f8 = local_f8 + -1;
	local_fc = local_fc + -1;
	if (local_f4 < 0) {
		return;
	}
	local_100 = *local_fc;
	base = *local_f8;
	goto LAB_0048e134;
}



void __cdecl std::internal::__qsort(byte *a,byte *b,uint width,CompareCallback *compare)
{
	int result;
	byte *dest;
	byte *item;
	
	if (a < b) {
		item = a + width;
		dest = a;
		do {
			for (; item <= b; item = item + width) {
				result = (*compare)(item,dest);
				if (0 < result) {
					dest = item;
				}
			}
			__memswap(dest,b,width);
			b = b + -width;
			item = a + width;
			dest = a;
		} while (a < b);
	}
	return;
}



void __cdecl std::internal::__memswap(byte *a,byte *b,uint count)
{
	byte bVar1;
	
	if ((a != b) && (count != 0)) {
		do {
			bVar1 = *a;
			*a = *b;
			a = a + 1;
			*b = bVar1;
			b = b + 1;
			count = count - 1;
		} while (count != 0);
	}
	return;
}



// Library Function - Single Match
// Name: __ftol
// Library: Visual Studio

longlong __ftol(float10 param_1)
{
	return (longlong)ROUND(param_1);
}



float10 __cdecl std::acos(float10 x)
{
	float10 fVar1;
	double dVar2;
	
	dVar2 = (double)x;
	internal::__std_FUN_00492328(dVar2);
	fVar1 = internal::__std_FUN_0048e36d(dVar2);
	return fVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

float10 __cdecl std::internal::__std_FUN_0048e36d(double param_1)
{
	uint in_EAX;
	uint in_EDX;
	bool in_ZF;
	float10 in_ST0;
	float10 extraout_ST0;
	float10 extraout_ST0_00;
	float10 fVar1;
	ushort in_FPUControlWord;
	ushort in_FPUStatusWord;
	uint uVar2;
	
	uVar2 = in_EDX & 0xffff0000 | (uint)in_FPUControlWord;
	if (in_ZF) {
		if (((in_EAX & 0xfffff) != 0) || (fVar1 = _DAT_004b2fe0, param_1._0_4_ != 0)) {
			__std_FUN_004922cc(in_EAX);
			fVar1 = extraout_ST0_00;
		}
LAB_0048e3fc:
		if (_DAT_0054a0c8 == 0) {
			fVar1 = (float10)__startOneArgErrorHandling();
			return fVar1;
		}
	}
	else {
		if (in_FPUControlWord != 0x27f) {
			in_EAX = __std_FUN_004922b5(uVar2);
			in_ST0 = extraout_ST0;
		}
		if (in_EAX < 0x3ff00000) {
			fVar1 = (float10)fpatan(SQRT(((float10)1 - in_ST0) * ((float10)1 + in_ST0)),in_ST0);
		}
		else {
			fVar1 = _DAT_004b2fe0;
			if ((0x3ff00000 < in_EAX) || ((param_1._4_4_ & 0xfffff | param_1._0_4_) != 0))
			goto LAB_0048e3fc;
			if (((ulonglong)param_1 & 0x8000000000000000) == 0) {
				fVar1 = (float10)0;
			}
			else {
				fVar1 = (float10)3.141592653589793;
			}
		}
		if (_DAT_0054a0c8 == 0) {
			if ((((short)uVar2 != 0x27f) && ((uVar2 & 0x20) != 0)) && ((in_FPUStatusWord & 0x20) != 0)) {
				fVar1 = (float10)__startOneArgErrorHandling();
				return fVar1;
			}
			return fVar1;
		}
	}
	return fVar1;
}



void __cdecl std::srand(uint seed)
{
	lego::globals::g_RAND = seed;
	return;
}



short __cdecl std::rand(void)
{
	lego::globals::g_RAND = lego::globals::g_RAND * 0x343fd + 0x269ec3;
	return (short)((ushort)(lego::globals::g_RAND >> 0x10) & 0x7fff);
}



float10 __cdecl std::fmod(float10 x,float10 y)
{
	float10 fVar1;
	
	fVar1 = (float10)__cintrindisp2();
	return fVar1;
}



int __cdecl std::vsprintf(char *buffer,char *format,va_list argptr)
{
	int iVar1;
	FILE dummyFile;
	
	dummyFile._base = buffer;
	dummyFile._ptr = buffer;
	dummyFile._flag = 0x42;
	dummyFile._cnt = 0x7fffffff;
	iVar1 = internal::__vfprintf_internal(&dummyFile,format,argptr);
	dummyFile._cnt = dummyFile._cnt + -1;
	if (-1 < dummyFile._cnt) {
		*dummyFile._ptr = '\0';
		return iVar1;
	}
	internal::__fafterwrite_00490b60(0,(char **)&dummyFile);
	return iVar1;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack

void * std::_alloca4k(uint size)
{
	undefined *puVar1;
	void *unaff_retaddr;
	
	puVar1 = &stack0x00000004;
	if (0xfff < size) {
		do {
			puVar1 = puVar1 + -0x1000;
			size = size - 0x1000;
		} while (0xfff < size);
	}
	*(void **)(puVar1 + (-4 - size)) = unaff_retaddr;
	return unaff_retaddr;
}



// (probably)

float10 __cdecl __floor(double x)
{
	double dVar1;
	uint new;
	int iVar2;
	float10 fVar3;
	
	new = std::_control87(0x173f,0xffff);
	if ((x._6_2_ & 0x7ff0) != 0x7ff0) {
		fVar3 = std::internal::__std_unk_round_internal__00493410(x);
		dVar1 = (double)fVar3;
		if ((dVar1 != x) && ((new & 0x20) == 0)) {
			fVar3 = std::internal::__std_FUN_00493480(0x10,0xb,x,dVar1,new);
			return fVar3;
		}
		std::_control87(new,0xffff);
		return (float10)dVar1;
	}
	iVar2 = std::internal::__std_FUN_00493d40(x);
	if (0 < iVar2) {
		if (iVar2 < 3) {
			std::_control87(new,0xffff);
			return (float10)x;
		}
		if (iVar2 == 3) {
			fVar3 = std::internal::__std_unk_math__00493430(0xb,x,new);
			return fVar3;
		}
	}
	fVar3 = std::internal::__std_FUN_00493480(8,0xb,x,x - -1.0,new);
	return fVar3;
}



int __cdecl std::toupper(int c)
{
	int iVar1;
	uint uVar2;
	LPCWSTR pWVar3;
	int iVar4;
	uint local_8 [2];
	
	iVar1 = c;
	if (DAT_0054a180 == 0) {
		if ((0x60 < c) && (c < 0x7b)) {
			return c - 0x20;
		}
	}
	else {
		if (c < 0x100) {
										// int std::islower(int c)
			if (globals::_pcharwidth < 2) {
				uVar2 = *(byte *)(globals::_pctype + c) & C1_LOWER;
			}
			else {
				uVar2 = _isctype(c,C1_LOWER);
			}
			if (uVar2 == 0) {
				return iVar1;
			}
		}
		if ((*(byte *)((int)globals::_pctype + (iVar1 >> 8 & 0xffU) * 2 + 1) & 0x80) == 0) {
			c = c & 0xffff0000U | iVar1 & 0xffU;
			pWVar3 = (LPCWSTR)0x1;
		}
		else {
			c = c & 0xff000000U | (uint)CONCAT11((char)iVar1,(char)((uint)iVar1 >> 8));
			pWVar3 = (LPCWSTR)0x2;
		}
		iVar4 = internal::__uprlwr__00493f60(DAT_0054a180,0x200,(char *)&c,pWVar3,(LPWSTR)local_8,3,0);
		if (iVar4 == 0) {
			return iVar1;
		}
		if (iVar4 == 1) {
			return local_8[0] & 0xff;
		}
		c = (local_8[0] >> 8 & 0xff) << 8 | local_8[0] & 0xff;
	}
	return c;
}



void __cdecl std::internal::__entry__0048e740(void)
{
	if (PTR___fpmath_004b0ca8 != (undefined *)0x0) {
		(*(code *)PTR___fpmath_004b0ca8)();
	}
	__std_FUN_0048e860((undefined **)&DAT_004a2008,(undefined **)&DAT_004a2014);
	__std_FUN_0048e860((undefined **)&DAT_004a2000,(undefined **)&DAT_004a2004);
	return;
}



void __cdecl std::exit(int status)
{
	internal::__std_FUN_0048e7b0(status,0,0);
	return;
}



// Library Function - Single Match
// Name: __exit
// Library: Visual Studio 1998 Release

void __cdecl std::quick_exit(int _Code)
{
	internal::__std_FUN_0048e7b0(_Code,1,0);
	return;
}



void __cdecl std::internal::__std_FUN_0048e7b0(UINT param_1,int param_2,int param_3)
{
	HANDLE hProcess;
	code **ppcVar1;
	code **ppcVar2;
	UINT uExitCode;
	
	if (DAT_0054a118 == 1) {
		uExitCode = param_1;
		hProcess = GetCurrentProcess();
		TerminateProcess(hProcess,uExitCode);
	}
	DAT_0054a114 = 1;
	DAT_0054a110 = (undefined)param_3;
	if (param_2 == 0) {
		if ((DAT_0076eed0 != (code **)0x0) &&
			 (ppcVar2 = (code **)(DAT_0076eecc + -4), ppcVar1 = DAT_0076eed0, DAT_0076eed0 <= ppcVar2)) {
			do {
				if (*ppcVar2 != (code *)0x0) {
					(**ppcVar2)();
					ppcVar1 = DAT_0076eed0;
				}
				ppcVar2 = ppcVar2 + -1;
			} while (ppcVar1 <= ppcVar2);
		}
		__std_FUN_0048e860((undefined **)&DAT_004a2018,(undefined **)&DAT_004a2020);
	}
	__std_FUN_0048e860((undefined **)&DAT_004a2024,(undefined **)&DAT_004a202c);
	if (param_3 == 0) {
		DAT_0054a118 = 1;
		ExitProcess(param_1);
	}
	return;
}



void __cdecl std::internal::__std_FUN_0048e860(undefined **param_1,undefined **param_2)
{
	if (param_1 < param_2) {
		do {
			if ((code *)*param_1 != (code *)0x0) {
				(*(code *)*param_1)();
			}
			param_1 = (code **)param_1 + 1;
		} while (param_1 < param_2);
	}
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

float10 __cdecl std::sqrt(double x)
{
	uint uVar1;
	undefined4 in_ECX;
	uint extraout_EDX;
	undefined in_ZF;
	float10 extraout_ST0;
	float10 extraout_ST0_00;
	float10 fVar2;
	float10 extraout_ST0_01;
	float10 fVar3;
	ushort in_FPUControlWord;
	ushort in_FPUStatusWord;
	uint uVar4;
	
	__fload_withFB(in_ECX,(int)&x);
	uVar4 = extraout_EDX & 0xffff0000 | (uint)in_FPUControlWord;
	fVar2 = extraout_ST0;
	if ((bool)in_ZF) {
		if ((((ulonglong)x & 0xfffff00000000) == 0) && (x._0_4_ == 0)) {
			fVar3 = _DAT_004b2fe0;
			if (((ulonglong)x & 0x8000000000000000) == 0) goto LAB_0048e8be;
		}
		else {
			internal::__std_FUN_004922cc(x._4_4_);
			fVar3 = extraout_ST0_01;
		}
LAB_0048e91b:
		if (_DAT_0054a0c8 == 0) {
			fVar2 = (float10)__startOneArgErrorHandling();
			return fVar2;
		}
	}
	else {
		uVar1 = x._4_4_;
		if (in_FPUControlWord != 0x27f) {
			uVar1 = internal::__std_FUN_004922b5(uVar4);
			fVar2 = extraout_ST0_00;
		}
		if ((uVar1 & 0x80000000) == 0) {
			fVar2 = SQRT(fVar2);
		}
		else {
			fVar3 = _DAT_004b2fe0;
			if ((((uVar1 & 0x7ff00000) != 0) || ((uVar1 & 0xfffff) != 0)) || (x._0_4_ != 0))
			goto LAB_0048e91b;
		}
LAB_0048e8be:
		fVar3 = fVar2;
		if (_DAT_0054a0c8 == 0) {
			if ((((short)uVar4 != 0x27f) && ((uVar4 & 0x20) != 0)) && ((in_FPUStatusWord & 0x20) != 0)) {
				fVar2 = (float10)__startOneArgErrorHandling();
				return fVar2;
			}
			return fVar2;
		}
	}
	return fVar3;
}



// (probably)

float10 __cdecl std::round(double x)
{
	uint new;
	int iVar1;
	float10 fVar2;
	
	new = _control87(0x133f,0xffff);
	if ((x._6_2_ & 0x7ff0) != 0x7ff0) {
		_control87(new,0xffff);
		return (float10)(double)((ulonglong)x & 0x7fffffffffffffff);
	}
	iVar1 = internal::__std_FUN_00493d40(x);
	if (iVar1 == 1) {
		_control87(new,0xffff);
		return (float10)x;
	}
	if (iVar1 == 2) {
		_control87(new,0xffff);
		return -(float10)x;
	}
	if (iVar1 != 3) {
		fVar2 = internal::__std_FUN_00493480(8,0x15,x,x - -1.0,new);
		return fVar2;
	}
	fVar2 = internal::__std_unk_math__00493430(0x15,x,new);
	return fVar2;
}



// Library Function - Single Match
// Name: _strncpy
// Library: Visual Studio 1998 Release

char * __cdecl std::_strncpy(char *_Dest,char *_Source,size_t _Count)
{
	uint uVar1;
	uint uVar2;
	char cVar3;
	uint uVar4;
	uint *puVar5;
	
	if (_Count == 0) {
		return _Dest;
	}
	puVar5 = (uint *)_Dest;
	if (((uint)_Source & 3) != 0) {
		while( true ) {
			cVar3 = *_Source;
			_Source = (char *)((int)_Source + 1);
			*(char *)puVar5 = cVar3;
			puVar5 = (uint *)((int)puVar5 + 1);
			_Count = _Count - 1;
			if (_Count == 0) {
				return _Dest;
			}
			if (cVar3 == '\0') break;
			if (((uint)_Source & 3) == 0) {
				uVar4 = _Count >> 2;
				goto joined_r0x0048ea6e;
			}
		}
		do {
			if (((uint)puVar5 & 3) == 0) {
				uVar4 = _Count >> 2;
				if (uVar4 == 0) goto LAB_0048eaab;
				goto LAB_0048eb19;
			}
			*(undefined *)puVar5 = 0;
			puVar5 = (uint *)((int)puVar5 + 1);
			_Count = _Count - 1;
		} while (_Count != 0);
		return _Dest;
	}
	uVar4 = _Count >> 2;
	if (uVar4 != 0) {
		do {
			uVar1 = *(uint *)_Source;
			uVar2 = *(uint *)_Source;
			_Source = (char *)((int)_Source + 4);
			if (((uVar1 ^ 0xffffffff ^ uVar1 + 0x7efefeff) & 0x81010100) != 0) {
				if ((char)uVar2 == '\0') {
					*puVar5 = 0;
joined_r0x0048eb15:
					while( true ) {
						uVar4 = uVar4 - 1;
						puVar5 = puVar5 + 1;
						if (uVar4 == 0) break;
LAB_0048eb19:
						*puVar5 = 0;
					}
					cVar3 = '\0';
					_Count = _Count & 3;
					if (_Count != 0) goto LAB_0048eaab;
					return _Dest;
				}
				if ((char)(uVar2 >> 8) == '\0') {
					*puVar5 = uVar2 & 0xff;
					goto joined_r0x0048eb15;
				}
				if ((uVar2 & 0xff0000) == 0) {
					*puVar5 = uVar2 & 0xffff;
					goto joined_r0x0048eb15;
				}
				if ((uVar2 & 0xff000000) == 0) {
					*puVar5 = uVar2;
					goto joined_r0x0048eb15;
				}
			}
			*puVar5 = uVar2;
			puVar5 = puVar5 + 1;
			uVar4 = uVar4 - 1;
joined_r0x0048ea6e:
		} while (uVar4 != 0);
		_Count = _Count & 3;
		if (_Count == 0) {
			return _Dest;
		}
	}
	do {
		cVar3 = *_Source;
		_Source = (char *)((int)_Source + 1);
		*(char *)puVar5 = cVar3;
		puVar5 = (uint *)((int)puVar5 + 1);
		if (cVar3 == '\0') {
			while (_Count = _Count - 1, _Count != 0) {
LAB_0048eaab:
				*(char *)puVar5 = cVar3;
				puVar5 = (uint *)((int)puVar5 + 1);
			}
			return _Dest;
		}
		_Count = _Count - 1;
	} while (_Count != 0);
	return _Dest;
}



int __cdecl std::_finite(double x)
{
	return (uint)((x._6_2_ & 0x7ff0) != 0x7ff0);
}



void __cdecl std::sscanf(char *buffer,char *format,...)
{
	char cVar1;
	uint uVar2;
	FILE file;
	
	uVar2 = 0xffffffff;
	file._base = buffer;
	file._ptr = buffer;
	do {
		if (uVar2 == 0) break;
		uVar2 = uVar2 - 1;
		cVar1 = *buffer;
		buffer = buffer + 1;
	} while (cVar1 != '\0');
	file._cnt = ~uVar2 - 1;
	file._flag = 0x49;
	vfscanf(&file,format,&stack0x0000000c);
	return;
}



// (probably)

float10 __cdecl std::ceil(double x)
{
	double dVar1;
	uint new;
	int iVar2;
	float10 fVar3;
	
	new = _control87(0x1b3f,0xffff);
	if ((x._6_2_ & 0x7ff0) != 0x7ff0) {
		fVar3 = internal::__std_unk_round_internal__00493410(x);
		dVar1 = (double)fVar3;
		if ((dVar1 != x) && ((new & 0x20) == 0)) {
			fVar3 = internal::__std_FUN_00493480(0x10,0xc,x,dVar1,new);
			return fVar3;
		}
		_control87(new,0xffff);
		return (float10)dVar1;
	}
	iVar2 = internal::__std_FUN_00493d40(x);
	if (0 < iVar2) {
		if (iVar2 < 3) {
			_control87(new,0xffff);
			return (float10)x;
		}
		if (iVar2 == 3) {
			fVar3 = internal::__std_unk_math__00493430(0xc,x,new);
			return fVar3;
		}
	}
	fVar3 = internal::__std_FUN_00493480(8,0xc,x,x - -1.0,new);
	return fVar3;
}



// Library Function - Single Match
// Name: __alldiv
// Library: Visual Studio

undefined8 __alldiv(uint param_1,uint param_2,uint param_3,uint param_4)
{
	ulonglong uVar1;
	longlong lVar2;
	uint uVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	bool bVar10;
	char cVar11;
	uint uVar9;
	
	cVar11 = (int)param_2 < 0;
	if ((bool)cVar11) {
		bVar10 = param_1 != 0;
		param_1 = -param_1;
		param_2 = -(uint)bVar10 - param_2;
	}
	if ((int)param_4 < 0) {
		cVar11 = cVar11 + '\x01';
		bVar10 = param_3 != 0;
		param_3 = -param_3;
		param_4 = -(uint)bVar10 - param_4;
	}
	uVar3 = param_1;
	uVar5 = param_3;
	uVar6 = param_2;
	uVar9 = param_4;
	if (param_4 == 0) {
		uVar3 = param_2 / param_3;
		iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
								 (ulonglong)param_3);
	}
	else {
		do {
			uVar8 = uVar9 >> 1;
			uVar5 = uVar5 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
			uVar7 = uVar6 >> 1;
			uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
			uVar6 = uVar7;
			uVar9 = uVar8;
		} while (uVar8 != 0);
		uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar5;
		iVar4 = (int)uVar1;
		lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
		uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
		uVar5 = uVar3 + iVar4 * param_4;
		if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar5)) ||
			 ((param_2 <= uVar5 && (param_1 < (uint)lVar2)))) {
			iVar4 = iVar4 + -1;
		}
		uVar3 = 0;
	}
	if (cVar11 == '\x01') {
		bVar10 = iVar4 != 0;
		iVar4 = -iVar4;
		uVar3 = -(uint)bVar10 - uVar3;
	}
	return CONCAT44(uVar3,iVar4);
}



// Library Function - Single Match
// Name: __allmul
// Library: Visual Studio

ulonglong __allmul(uint param_1,uint param_2,uint param_3,uint param_4)
{
	if ((param_4 | param_2) == 0) {
		return (ulonglong)param_1 * (ulonglong)param_3;
	}
	return (ulonglong)param_1 * (ulonglong)param_3 & 0xffffffff |
				 (ulonglong)
				 ((int)((ulonglong)param_1 * (ulonglong)param_3 >> 0x20) +
				 param_2 * param_3 + param_1 * param_4) << 0x20;
}



void * __cdecl std::operator_new(uint length)
{
	void *pvVar1;
	
	pvVar1 = internal::__malloc_handlermode(length,1);
	return pvVar1;
}



int __cdecl std::fclose(FILE *stream)
{
	int iVar1;
	int iVar2;
	
	iVar2 = -1;
	if ((stream->_flag & 0x40U) != 0) {
		stream->_flag = 0;
		return -1;
	}
	if ((stream->_flag & 0x83U) != 0) {
		iVar2 = internal::__std_fflush__0048ffe0(stream);
		internal::__ffree__004950b0(stream);
		iVar1 = internal::__fdclose__00494fd0(stream->_file);
		if (iVar1 < 0) {
			stream->_flag = 0;
			return -1;
		}
		if (stream->_tmpfname != (char *)0x0) {
			free(stream->_tmpfname);
			stream->_tmpfname = (char *)0x0;
		}
	}
	stream->_flag = 0;
	return iVar2;
}



FILE * __cdecl std::_fsopen(LPCSTR filename,char *mode,int shflag)
{
	FILE *stream;
	
	stream = internal::__fsopen__004952c0();
	if (stream == (FILE *)0x0) {
		return (FILE *)0x0;
	}
	stream = internal::__fsopen__004950f0(filename,mode,shflag,stream);
	return stream;
}



FILE * __cdecl std::fopen(LPCSTR filename,char *mode)
{
	FILE *pFVar1;
	
	pFVar1 = _fsopen(filename,mode,SH_DENYNO);
	return pFVar1;
}



void std::internal::__std_FUN_0048ee70(undefined *UNRECOVERED_JUMPTABLE)
{
	undefined4 *in_FS_OFFSET;
	
	*in_FS_OFFSET = *(undefined4 *)*in_FS_OFFSET;
										// WARNING: Could not recover jumptable at 0x0048ee9b. Too many branches
										// WARNING: Treating indirect jump as call
	(*(code *)UNRECOVERED_JUMPTABLE)();
	return;
}



void std::internal::__std_FUN_0048eeb0(undefined4 param_1,undefined *UNRECOVERED_JUMPTABLE)
{
										// WARNING: Could not recover jumptable at 0x0048eeb5. Too many branches
										// WARNING: Treating indirect jump as call
	(*(code *)UNRECOVERED_JUMPTABLE)();
	return;
}



void std::internal::__std_FUN_0048eec0(PVOID param_1,PEXCEPTION_RECORD param_2)
{
	undefined4 *puVar1;
	undefined4 *in_FS_OFFSET;
	
	puVar1 = (undefined4 *)*in_FS_OFFSET;
	RtlUnwind(param_1,(PVOID)0x48eeec,param_2,(PVOID)0x0);
	param_2->ExceptionFlags = param_2->ExceptionFlags & 0xfffffffd;
	*puVar1 = *in_FS_OFFSET;
	*in_FS_OFFSET = puVar1;
	return;
}



undefined4
std::internal::__std_FUN_0048ef20
					(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3,undefined4 param_4)
{
	int *in_EAX;
	undefined4 uVar1;
	
	uVar1 = __std_FUN_00495350(param_1,param_2,param_3,param_4,in_EAX,(PVOID)0x0,(PVOID)0x0,0);
	return uVar1;
}



undefined4 __cdecl
std::internal::__std_FUN_0048ef60
					(undefined4 param_1,undefined4 param_2,undefined4 param_3,int param_4,int param_5)
{
	undefined4 uVar1;
	int **in_FS_OFFSET;
	int *local_18;
	code *local_14;
	undefined4 local_10;
	undefined4 local_c;
	int local_8;
	
	local_8 = param_4 + 1;
	local_14 = __std_FUN_0048efc0;
	local_10 = param_2;
	local_c = param_1;
	local_18 = *in_FS_OFFSET;
	*in_FS_OFFSET = (int *)&local_18;
	uVar1 = __CallSettingFrame_12(param_3,param_1,param_5);
	*in_FS_OFFSET = local_18;
	return uVar1;
}



void __cdecl
std::internal::__std_FUN_0048efc0(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3)
{
	__std_FUN_00495350(param_1,*(PVOID *)((int)param_2 + 0xc),param_3,0,*(int **)((int)param_2 + 8),
										 *(PVOID *)((int)param_2 + 0x10),param_2,0);
	return;
}



undefined4 __cdecl
std::internal::__std_FUN_0048eff0
					(undefined4 *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
					undefined4 param_5,undefined4 param_6,undefined4 param_7)
{
	undefined4 **in_FS_OFFSET;
	undefined4 local_38;
	undefined4 *local_34;
	undefined4 local_30;
	undefined4 *local_2c;
	code *local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined *local_10;
	undefined *local_c;
	int local_8;
	
	local_c = &stack0xfffffffc;
	local_10 = &stack0xffffffbc;
	local_28 = __std_FUN_0048f0c0;
	local_24 = param_5;
	local_20 = param_2;
	local_1c = param_6;
	local_18 = param_7;
	local_8 = 0;
	local_14 = 0x48f08a;
	local_2c = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_2c;
	local_38 = 1;
	local_34 = param_1;
	local_30 = param_3;
	(*DAT_0054a19c)(*param_1,&local_34);
	if (local_8 == 0) {
		*in_FS_OFFSET = local_2c;
	}
	else {
		*local_2c = **in_FS_OFFSET;
		*in_FS_OFFSET = local_2c;
	}
	return 0;
}



undefined4 __cdecl
std::internal::__std_FUN_0048f0c0(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3)
{
	undefined4 uVar1;
	
	if ((param_1->ExceptionFlags & 0x66) != 0) {
		*(undefined4 *)((int)param_2 + 0x24) = 1;
		return 1;
	}
	__std_FUN_00495350(param_1,*(PVOID *)((int)param_2 + 0xc),param_3,0,*(int **)((int)param_2 + 8),
										 *(PVOID *)((int)param_2 + 0x10),*(PVOID *)((int)param_2 + 0x14),1);
	if (*(int *)((int)param_2 + 0x24) == 0) {
		__std_FUN_0048eec0(param_2,param_1);
	}
										// WARNING: Could not recover jumptable at 0x0048f134. Too many branches
										// WARNING: Treating indirect jump as call
	uVar1 = (**(code **)((int)param_2 + 0x18))();
	return uVar1;
}



int __cdecl
std::internal::__std_FUN_0048f150(int param_1,int param_2,int param_3,uint *param_4,uint *param_5)
{
	int iVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	
	iVar2 = *(int *)(param_1 + 0x10);
	uVar3 = *(uint *)(param_1 + 0xc);
	uVar4 = uVar3;
	uVar5 = uVar3;
	if (-1 < param_2) {
		do {
			if (uVar4 == 0xffffffff) {
				__std_FUN_00495e30();
			}
			uVar4 = uVar4 - 1;
			iVar1 = iVar2 + uVar4 * 0x14;
			if (((*(int *)(iVar1 + 4) < param_3) && (param_3 <= *(int *)(iVar1 + 8))) ||
				 (uVar4 == 0xffffffff)) {
				param_2 = param_2 + -1;
				uVar3 = uVar5;
				uVar5 = uVar4;
			}
		} while (-1 < param_2);
	}
	uVar4 = uVar4 + 1;
	*param_4 = uVar4;
	*param_5 = uVar3;
	if ((*(uint *)(param_1 + 0xc) <= uVar3 && uVar3 != *(uint *)(param_1 + 0xc)) || (uVar3 < uVar4)) {
		__std_FUN_00495e30();
	}
	return iVar2 + uVar4 * 0x14;
}



// Library Function - Single Match
// Name: __global_unwind2
// Library: Visual Studio

void __cdecl __global_unwind2(PVOID param_1)
{
	RtlUnwind(param_1,(PVOID)0x48f1e8,(PEXCEPTION_RECORD)0x0,(PVOID)0x0);
	return;
}



// Library Function - Single Match
// Name: __local_unwind2
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __cdecl __local_unwind2(int param_1,int param_2)
{
	int iVar1;
	int iVar2;
	undefined4 *in_FS_OFFSET;
	undefined4 uStack28;
	undefined *puStack24;
	undefined4 local_14;
	int iStack16;
	
	iStack16 = param_1;
	puStack24 = &LAB_0048f1f0;
	uStack28 = *in_FS_OFFSET;
	*in_FS_OFFSET = &uStack28;
	while( true ) {
		iVar1 = *(int *)(param_1 + 8);
		iVar2 = *(int *)(param_1 + 0xc);
		if ((iVar2 == -1) || (iVar2 == param_2)) break;
		local_14 = *(undefined4 *)(iVar1 + iVar2 * 0xc);
		*(undefined4 *)(param_1 + 0xc) = local_14;
		if (*(int *)(iVar1 + 4 + iVar2 * 0xc) == 0) {
			__NLG_Notify(0x101);
			(**(code **)(iVar1 + 8 + iVar2 * 0xc))();
		}
	}
	*in_FS_OFFSET = uStack28;
	return;
}



// Library Function - Single Match
// Name: __abnormal_termination
// Library: Visual Studio

int __cdecl __abnormal_termination(void)
{
	int iVar1;
	int iVar2;
	int *in_FS_OFFSET;
	
	iVar2 = 0;
	iVar1 = *in_FS_OFFSET;
	if ((*(undefined **)(iVar1 + 4) == &LAB_0048f1f0) &&
		 (*(int *)(iVar1 + 8) == *(int *)(*(int *)(iVar1 + 0xc) + 0xc))) {
		iVar2 = 1;
	}
	return iVar2;
}



// Library Function - Single Match
// Name: __NLG_Notify1
// Libraries: Visual Studio 2003 Debug, Visual Studio 2003 Release

void __fastcall __NLG_Notify1(undefined4 param_1)
{
	undefined4 in_EAX;
	undefined4 unaff_EBP;
	
	DAT_004b0d54 = in_EAX;
	DAT_004b0d58 = param_1;
	DAT_004b0d5c = unaff_EBP;
	return;
}



// Library Function - Single Match
// Name: __NLG_Notify
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __NLG_Notify(ulong param_1)
{
	undefined4 in_EAX;
	int unaff_EBP;
	
	DAT_004b0d54 = in_EAX;
	DAT_004b0d58 = *(undefined4 *)(unaff_EBP + 8);
	DAT_004b0d5c = unaff_EBP;
	return;
}



void entry(void)
{
	byte bVar1;
	DWORD DVar2;
	BOOL BVar3;
	uint nShowCmd;
	HINSTANCE hInstance;
	int status;
	LPSTR *ppCVar4;
	undefined4 *in_FS_OFFSET;
	HINSTANCE hPrevInstance;
	LPSTR lpCmdLine;
	STARTUPINFOA startupInfo;
	undefined4 local_14;
	undefined *puStack16;
	undefined *puStack12;
	undefined4 local_8;
	
	local_8 = 0xffffffff;
	puStack12 = &DAT_0049fb20;
	puStack16 = &LAB_00496a98;
	local_14 = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_14;
	DVar2 = GetVersion();
	std::globals::g_dwMajorVersion = DVar2 >> 8 & 0xff;
	std::globals::g_dwMinorVersion = DVar2 & 0xff;
	std::globals::g_dwMajorMinorVersion =
			 std::globals::g_dwMinorVersion * 0x100 + std::globals::g_dwMajorVersion;
	std::globals::g_dwBuildNumber = DVar2 >> 0x10;
	BVar3 = std::internal::__entry__00491820();
	if (BVar3 == 0) {
		__amsg_exit(0x1c);
	}
	local_8 = 0;
	std::internal::__entry__00496890();
	std::internal::__entry__00496880();
	std::globals::_acmdln = (LPSTR *)GetCommandLineA();
	std::globals::__initenv = std::internal::__GetEnvironmentStringsA();
	if ((std::globals::__initenv == (LPSTR)0x0) || (std::globals::_acmdln == (LPSTR *)0x0)) {
		std::exit(-1);
	}
	std::internal::__entry__004961a0();
	std::internal::__entry__004960b0();
	std::internal::__entry__0048e740();
	lpCmdLine = (LPSTR)std::globals::_acmdln;
	if (*(char *)std::globals::_acmdln == '\"') {
		while( true ) {
			ppCVar4 = (LPSTR *)lpCmdLine;
			lpCmdLine = (LPSTR)((int)ppCVar4 + 1);
			bVar1 = *lpCmdLine;
			if ((bVar1 == '\"') || (bVar1 == 0)) break;
			BVar3 = std::internal::__entry_cmdline__00496050((uint)bVar1);
			if (BVar3 != 0) {
				lpCmdLine = (LPSTR)((int)ppCVar4 + 2);
			}
		}
		if (*lpCmdLine == '\"') {
			lpCmdLine = (LPSTR)((int)ppCVar4 + 2);
		}
	}
	else {
		for (; 0x20 < (byte)*lpCmdLine; lpCmdLine = (LPSTR)((int)lpCmdLine + 1)) {
		}
	}
	for (; (*lpCmdLine != 0 && ((byte)*lpCmdLine < 0x21)); lpCmdLine = lpCmdLine + 1) {
	}
	startupInfo.dwFlags = 0;
	GetStartupInfoA((LPSTARTUPINFOA)&startupInfo);
	if ((startupInfo.dwFlags & 1) == 0) {
										// STARTF_USECOUNTCHARS (0x8) | STARTF_USESIZE (0x2)
		nShowCmd = 10;
	}
	else {
										// WORD wShowWindow
		nShowCmd = startupInfo._48_4_ & 0xffff;
	}
	hPrevInstance = (HINSTANCE)0x0;
	hInstance = (HINSTANCE)GetModuleHandleA((LPCSTR)0x0);
	status = lego::WinMain(hInstance,hPrevInstance,lpCmdLine,nShowCmd);
	std::exit(status);
	*in_FS_OFFSET = local_14;
	return;
}



// Library Function - Single Match
// Name: __amsg_exit
// Library: Visual Studio 1998 Release

void __cdecl __amsg_exit(int param_1)
{
	if (DAT_0054a124 == 1) {
		std::internal::__std_FUN_00496b70();
	}
	std::internal::__std_FUN_00496bb0(param_1);
	(*(code *)PTR_quick_exit_004b0d60)(0xff);
	return;
}



BOOL __cdecl std::_isctype(int c,uint desc)
{
	int iVar1;
	LCID LVar2;
	uint local_4;
	
	if (c + 1U < 0x101) {
		return globals::_pctype[c] & desc;
	}
	if ((*(byte *)((int)globals::_pctype + (c >> 8 & 0xffU) * 2 + 1) & 0x80) == 0) {
		c = c & 0xffff00ff;
		iVar1 = 1;
	}
	else {
		c = c & 0xff000000U | (uint)CONCAT11((char)c,(char)((uint)c >> 8));
		iVar1 = 2;
	}
	LVar2 = internal::__ctype_internal(1,(LPCSTR)&c,iVar1,(LPWORD)&local_4,0,0);
	if (LVar2 == 0) {
		return 0;
	}
	return local_4 & 0xffff & desc;
}



// Library Function - Single Match
// Name: _strncmp
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release

int __cdecl std::strncmp(char *_Str1,char *_Str2,size_t _MaxCount)
{
	char cVar1;
	char cVar2;
	byte bVar3;
	size_t sVar4;
	int iVar5;
	uint uVar6;
	char *pcVar7;
	char *pcVar8;
	bool bVar9;
	
	sVar4 = _MaxCount;
	pcVar7 = _Str1;
	if (_MaxCount != 0) {
		do {
			if (sVar4 == 0) break;
			sVar4 = sVar4 - 1;
			cVar1 = *pcVar7;
			pcVar7 = pcVar7 + 1;
		} while (cVar1 != '\0');
		iVar5 = _MaxCount - sVar4;
		do {
			pcVar7 = _Str2;
			pcVar8 = _Str1;
			if (iVar5 == 0) break;
			iVar5 = iVar5 + -1;
			pcVar8 = _Str1 + 1;
			pcVar7 = _Str2 + 1;
			cVar1 = *_Str2;
			cVar2 = *_Str1;
			_Str2 = pcVar7;
			_Str1 = pcVar8;
		} while (cVar1 == cVar2);
		bVar3 = pcVar7[-1];
		uVar6 = 0;
		bVar9 = bVar3 == pcVar8[-1];
		if (bVar3 < (byte)pcVar8[-1] || bVar9) {
			if (bVar9) {
				return 0;
			}
			uVar6 = 0xfffffffe;
		}
		_MaxCount = ~uVar6;
	}
	return _MaxCount;
}



long __cdecl std::ftell(FILE *stream)
{
	uint uVar1;
	uint uVar2;
	int iVar3;
	char *pcVar4;
	char *pcVar5;
	int iVar6;
	char *pcVar7;
	char *local_8;
	char *local_4;
	
	uVar1 = stream->_file;
	if (stream->_cnt < 0) {
		stream->_cnt = 0;
	}
	local_4 = (char *)internal::__fdread__00496ec0(uVar1,0,1);
	if ((int)local_4 < 0) {
		return (long)(char *)0xffffffff;
	}
	uVar2 = stream->_flag;
	if ((uVar2 & 0x108) == 0) {
		return (long)(local_4 + -stream->_cnt);
	}
	pcVar7 = stream->_ptr;
	pcVar4 = stream->_base;
	local_8 = pcVar7 + -(int)pcVar4;
	iVar3 = (int)uVar1 >> 5;
	if ((uVar2 & 3) == 0) {
		if ((uVar2 & 0x80) == 0) {
			globals::g_msvc_errno = 0x16;
			return (long)(char *)0xffffffff;
		}
	}
	else {
		pcVar5 = pcVar4;
		if ((*(byte *)((&DAT_0076edc0)[iVar3] + 4 + (uVar1 & 0x1f) * 8) & 0x80) != 0) {
			for (; pcVar5 < pcVar7; pcVar5 = pcVar5 + 1) {
				if (*pcVar5 == '\n') {
					local_8 = local_8 + 1;
				}
			}
		}
	}
	if (local_4 == (char *)0x0) {
		return (long)local_8;
	}
	if ((*(byte *)&stream->_flag & 1) == 0) goto LAB_0048f6e5;
	if (stream->_cnt == 0) {
		return (long)local_4;
	}
	pcVar7 = pcVar7 + (stream->_cnt - (int)pcVar4);
	iVar6 = (uVar1 & 0x1f) * 8;
	if ((*(byte *)(iVar6 + 4 + (&DAT_0076edc0)[iVar3]) & 0x80) != 0) {
		pcVar4 = (char *)internal::__fdread__00496ec0(uVar1,0,2);
		if (pcVar4 == local_4) {
			pcVar5 = stream->_base;
			pcVar4 = pcVar5 + (int)pcVar7;
			for (; pcVar5 < pcVar4; pcVar5 = pcVar5 + 1) {
				if (*pcVar5 == '\n') {
					pcVar7 = pcVar7 + 1;
				}
			}
			if ((stream->_flag & 0x2000U) != 0) {
LAB_0048f6dc:
				pcVar7 = pcVar7 + 1;
			}
		}
		else {
			internal::__fdread__00496ec0(uVar1,(LONG)local_4,0);
			if (((pcVar7 < (char *)0x201) && ((stream->_flag & 8U) != 0)) &&
				 ((stream->_flag & 0x400U) == 0)) {
				pcVar7 = (char *)0x200;
			}
			else {
				pcVar7 = (char *)stream->_bufsiz;
			}
			if ((*(byte *)(iVar6 + 4 + (&DAT_0076edc0)[iVar3]) & 4) != 0) goto LAB_0048f6dc;
		}
	}
	local_4 = local_4 + -(int)pcVar7;
LAB_0048f6e5:
	return (long)(local_4 + (int)local_8);
}



int __cdecl std::fseek(FILE *stream,long offset,int origin)
{
	uint uVar1;
	long lVar2;
	DWORD DVar3;
	
	if (((stream->_flag & 0x83U) != 0) && (((origin == 0 || (origin == 1)) || (origin == 2)))) {
		stream->_flag = stream->_flag & 0xffffffef;
		if (origin == 1) {
			lVar2 = ftell(stream);
			offset = offset + lVar2;
			origin = 0;
		}
		internal::__std_fflush__0048ffe0(stream);
		uVar1 = stream->_flag;
		if ((uVar1 & 0x80) == 0) {
			if ((((uVar1 & 1) != 0) && ((uVar1 & 8) != 0)) && ((uVar1 & 0x400) == 0)) {
				stream->_bufsiz = 0x200;
			}
		}
		else {
			stream->_flag = uVar1 & 0xfffffffc;
		}
		DVar3 = internal::__fdread__00496ec0(stream->_file,offset,origin);
		return (DVar3 != 0xffffffff) - 1;
	}
	globals::g_msvc_errno = EINVAL;
	return -1;
}



size_t __cdecl std::fwrite(void *out_buffer,size_t size,size_t count,FILE *stream)
{
	FILE *stream_00;
	FILE *pFVar1;
	int iVar2;
	FILE *pFVar3;
	uint uVar4;
	FILE *pFVar5;
	FILE *pFVar6;
	undefined4 *puVar7;
	undefined4 *puVar8;
	
	stream_00 = stream;
	pFVar5 = (FILE *)(count * size);
	if (pFVar5 == (FILE *)0x0) {
		return 0;
	}
	pFVar6 = pFVar5;
	if ((stream->_flag & 0x10cU) == 0) {
		stream = (FILE *)0x1000;
	}
	else {
		stream = (FILE *)stream->_bufsiz;
	}
	do {
		uVar4 = stream_00->_flag & 0x108;
		if ((uVar4 == 0) || (pFVar1 = (FILE *)stream_00->_cnt, pFVar1 == (FILE *)0x0)) {
			if (pFVar6 < stream) {
										// WARNING: Load size is inaccurate
				uVar4 = internal::__fafterwrite_00490b60((int)*out_buffer,(char **)stream_00);
				if (uVar4 == 0xffffffff) goto LAB_0048f8f4;
				stream = (FILE *)stream_00->_bufsiz;
				out_buffer = (void *)((int)out_buffer + 1);
				pFVar6 = (FILE *)((int)&pFVar6[-1]._tmpfname + 3);
				if ((int)stream < 1) {
					stream = (FILE *)0x1;
				}
			}
			else {
				if ((uVar4 != 0) && (iVar2 = internal::__std_fflush__0048ffe0(stream_00), iVar2 != 0)) {
LAB_0048f8f4:
					return (uint)((int)pFVar5 - (int)pFVar6) / size;
				}
				pFVar1 = pFVar6;
				if (stream != (FILE *)0x0) {
					pFVar1 = (FILE *)((int)pFVar6 - (uint)pFVar6 % (uint)stream);
				}
				pFVar3 = (FILE *)internal::__fdwrite__00496f80
																	 (stream_00->_file,(char *)out_buffer,(char *)pFVar1);
				if (pFVar3 == (FILE *)0xffffffff) {
LAB_0048f8d9:
					stream_00->_flag = stream_00->_flag | 0x20;
					return (uint)((int)pFVar5 - (int)pFVar6) / size;
				}
				pFVar6 = (FILE *)((int)pFVar6 - (int)pFVar3);
				out_buffer = (void *)((int)out_buffer + (int)pFVar3);
				if (pFVar3 < pFVar1) goto LAB_0048f8d9;
			}
		}
		else {
			if (pFVar6 < pFVar1) {
				pFVar1 = pFVar6;
			}
			pFVar6 = (FILE *)((int)pFVar6 - (int)pFVar1);
			puVar7 = (undefined4 *)out_buffer;
			puVar8 = (undefined4 *)stream_00->_ptr;
			for (uVar4 = (uint)pFVar1 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
				*puVar8 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar8 = puVar8 + 1;
			}
			for (uVar4 = (uint)pFVar1 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
				*(undefined *)puVar8 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar8 = (undefined4 *)((int)puVar8 + 1);
			}
			out_buffer = (void *)((int)out_buffer + (int)pFVar1);
			stream_00->_cnt = stream_00->_cnt - (int)pFVar1;
			stream_00->_ptr = (char *)((int)&pFVar1->_ptr + (int)stream_00->_ptr);
		}
		if (pFVar6 == (FILE *)0x0) {
			return count;
		}
	} while( true );
}



int __cdecl std::remove(LPCSTR filename)
{
	BOOL BVar1;
	uint error_value;
	
	BVar1 = DeleteFileA(filename);
	if (BVar1 == 0) {
		error_value = GetLastError();
	}
	else {
		error_value = 0;
	}
	if (error_value != 0) {
		internal::__set_doserrno(error_value);
		return -1;
	}
	return 0;
}



int __cdecl std::_chmod(LPCSTR filename,int pmode)
{
	DWORD DVar1;
	BOOL BVar2;
	
	DVar1 = GetFileAttributesA(filename);
	if (DVar1 != INVALID_FILE_ATTRIBUTES) {
		if ((pmode & FILE_ATTRIBUTE_NORMAL) == 0) {
			DVar1 = DVar1 | 1;
		}
		else {
			DVar1 = DVar1 & 0xfffffffe;
		}
		BVar2 = SetFileAttributesA(filename,DVar1);
		if (BVar2 != 0) {
			return 0;
		}
	}
	DVar1 = GetLastError();
	internal::__set_doserrno(DVar1);
	return -1;
}



int __cdecl std::_mkdir(LPCSTR dirname)
{
	BOOL BVar1;
	uint error_value;
	
	BVar1 = CreateDirectoryA(dirname,(LPSECURITY_ATTRIBUTES)0x0);
	if (BVar1 == 0) {
		error_value = GetLastError();
	}
	else {
		error_value = 0;
	}
	if (error_value != 0) {
		internal::__set_doserrno(error_value);
		return -1;
	}
	return 0;
}



HANDLE __cdecl std::_findfirst32(LPCSTR filename,_finddata32_t *fileinfo)
{
	char cVar1;
	HANDLE pvVar2;
	DWORD DVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	char *pcVar9;
	undefined4 *puVar10;
	_WIN32_FIND_DATAA local_140;
	
	pvVar2 = FindFirstFileA(filename,(LPWIN32_FIND_DATAA)&local_140);
	if (pvVar2 == (HANDLE)0xffffffff) {
		DVar3 = GetLastError();
		switch(DVar3) {
		case 2:
		case 3:
		case 0x12:
			globals::g_msvc_errno = 2;
			return (HANDLE)0xffffffff;
		default:
			globals::g_msvc_errno = 0x16;
			return (HANDLE)0xffffffff;
		case 8:
			globals::g_msvc_errno = 0xc;
			return (HANDLE)0xffffffff;
		}
	}
	fileinfo->attrib = -(uint)(local_140.dwFileAttributes != 0x80) & local_140.dwFileAttributes;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftCreationTime);
	fileinfo->time_create = iVar4;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftLastAccessTime);
	fileinfo->time_access = iVar4;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftLastWriteTime);
	fileinfo->time_write = iVar4;
	uVar5 = 0xffffffff;
	pcVar8 = local_140.cFileName;
	do {
		pcVar9 = pcVar8;
		if (uVar5 == 0) break;
		uVar5 = uVar5 - 1;
		pcVar9 = pcVar8 + 1;
		cVar1 = *pcVar8;
		pcVar8 = pcVar9;
	} while (cVar1 != '\0');
	uVar5 = ~uVar5;
	fileinfo->size = local_140.nFileSizeLow;
	puVar7 = (undefined4 *)(pcVar9 + -uVar5);
	puVar10 = (undefined4 *)fileinfo->name;
	for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
		*puVar10 = *puVar7;
		puVar7 = puVar7 + 1;
		puVar10 = puVar10 + 1;
	}
	for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
		*(undefined *)puVar10 = *(undefined *)puVar7;
		puVar7 = (undefined4 *)((int)puVar7 + 1);
		puVar10 = (undefined4 *)((int)puVar10 + 1);
	}
	return pvVar2;
}



int __cdecl std::_findnext32(HANDLE handle,_finddata32_t *fileinfo)
{
	char cVar1;
	BOOL BVar2;
	DWORD DVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	char *pcVar9;
	undefined4 *puVar10;
	_WIN32_FIND_DATAA local_140;
	
	BVar2 = FindNextFileA(handle,(LPWIN32_FIND_DATAA)&local_140);
	if (BVar2 == 0) {
		DVar3 = GetLastError();
		switch(DVar3) {
		case 2:
		case 3:
		case 0x12:
			globals::g_msvc_errno = ENOENT;
			return -1;
		default:
			globals::g_msvc_errno = EINVAL;
			return -1;
		case 8:
			globals::g_msvc_errno = ENOMEM;
			return -1;
		}
	}
	fileinfo->attrib = -(uint)(local_140.dwFileAttributes != 0x80) & local_140.dwFileAttributes;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftCreationTime);
	fileinfo->time_create = iVar4;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftLastAccessTime);
	fileinfo->time_access = iVar4;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftLastWriteTime);
	fileinfo->time_write = iVar4;
	uVar5 = 0xffffffff;
	pcVar8 = local_140.cFileName;
	do {
		pcVar9 = pcVar8;
		if (uVar5 == 0) break;
		uVar5 = uVar5 - 1;
		pcVar9 = pcVar8 + 1;
		cVar1 = *pcVar8;
		pcVar8 = pcVar9;
	} while (cVar1 != '\0');
	uVar5 = ~uVar5;
	fileinfo->size = local_140.nFileSizeLow;
	puVar7 = (undefined4 *)(pcVar9 + -uVar5);
	puVar10 = (undefined4 *)fileinfo->name;
	for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
		*puVar10 = *puVar7;
		puVar7 = puVar7 + 1;
		puVar10 = puVar10 + 1;
	}
	for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
		*(undefined *)puVar10 = *(undefined *)puVar7;
		puVar7 = (undefined4 *)((int)puVar7 + 1);
		puVar10 = (undefined4 *)((int)puVar10 + 1);
	}
	return 0;
}



int __cdecl std::_findclose(HANDLE handle)
{
	BOOL BVar1;
	
	BVar1 = FindClose(handle);
	if (BVar1 == 0) {
		globals::g_msvc_errno = 0x16;
		return -1;
	}
	return 0;
}



int __cdecl std::internal::__unk_ftime__0048fc30(FILETIME *param_1)
{
	BOOL BVar1;
	int iVar2;
	_FILETIME local_18;
	_SYSTEMTIME local_10;
	
	if ((param_1->dwLowDateTime != 0) || (param_1->dwHighDateTime != 0)) {
		BVar1 = FileTimeToLocalFileTime(param_1,(LPFILETIME)&local_18);
		if (BVar1 != 0) {
			BVar1 = FileTimeToSystemTime((FILETIME *)&local_18,(LPSYSTEMTIME)&local_10);
			if (BVar1 != 0) {
				iVar2 = __unkftime__00497210
													((uint)local_10.wYear,(uint)local_10.wMonth,(uint)local_10.wDay,
													 (uint)local_10.wHour,(uint)local_10.wMinute,(uint)local_10.wSecond,-1);
				return iVar2;
			}
		}
	}
	return -1;
}



char * __cdecl std::_getcwd(char *out_buffer,int maxlen)
{
	char *pcVar1;
	
	pcVar1 = _getdcwd(0,out_buffer,maxlen);
	return pcVar1;
}



char * __cdecl std::_getdcwd(int drive,char *out_buffer,int maxlen)
{
	char cVar1;
	BOOL BVar2;
	DWORD DVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	char *pcVar8;
	undefined4 *puVar9;
	char local_10c;
	undefined local_10b;
	undefined local_10a;
	undefined local_109;
	LPSTR local_108;
	CHAR local_104 [260];
	
	if (drive == 0) {
		DVar3 = GetCurrentDirectoryA(MAX_PATH,local_104);
	}
	else {
		BVar2 = internal::__dcwd_exists(drive);
		if (BVar2 == 0) {
			globals::g_msvc_errno = EACCES;
			globals::g_msvc_doserrno = 0xf;
			return (char *)0x0;
		}
		local_10c = (char)drive + '@';
		local_10b = 0x3a;
		local_10a = 0x2e;
		local_109 = 0;
		DVar3 = GetFullPathNameA(&local_10c,MAX_PATH,local_104,&local_108);
	}
	if ((DVar3 == 0) || (uVar4 = DVar3 + 1, MAX_PATH < uVar4)) {
		return (char *)(undefined4 *)0x0;
	}
	if (out_buffer == (char *)0x0) {
		if ((int)uVar4 <= maxlen) {
			uVar4 = maxlen;
		}
		out_buffer = (char *)malloc(uVar4);
		if ((undefined4 *)out_buffer == (undefined4 *)0x0) {
			globals::g_msvc_errno = ENOMEM;
			return (char *)0x0;
		}
	}
	else {
		if (maxlen < (int)uVar4) {
			globals::g_msvc_errno = ERANGE;
			return (char *)(undefined4 *)0x0;
		}
	}
	uVar4 = 0xffffffff;
	pcVar7 = local_104;
	do {
		pcVar8 = pcVar7;
		if (uVar4 == 0) break;
		uVar4 = uVar4 - 1;
		pcVar8 = pcVar7 + 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar8;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar6 = (undefined4 *)(pcVar8 + -uVar4);
	puVar9 = (undefined4 *)out_buffer;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
		*puVar9 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar9 = puVar9 + 1;
	}
	for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
		*(undefined *)puVar9 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar9 = (undefined4 *)((int)puVar9 + 1);
	}
	return (char *)(undefined4 *)out_buffer;
}



BOOL __cdecl std::internal::__dcwd_exists(int drive)
{
	UINT UVar1;
	
	if (drive == 0) {
		return 1;
	}
	drive = ZEXT34(CONCAT12('\\',CONCAT11(':',(char)drive + '@')));
	UVar1 = GetDriveTypeA((LPCSTR)&drive);
	if ((UVar1 != 0) && (UVar1 != DRIVE_NO_ROOT_DIR)) {
		return 1;
	}
	return 0;
}



size_t __cdecl std::fread(void *out_buffer,size_t size,size_t count,FILE *stream)
{
	FILE *file;
	FILE *pFVar1;
	char *pcVar2;
	int iVar3;
	uint uVar4;
	FILE *pFVar5;
	FILE *pFVar6;
	undefined4 *puVar7;
	FILE *pFVar8;
	undefined4 *puVar9;
	
	file = stream;
	pFVar5 = (FILE *)(count * size);
	if (pFVar5 == (FILE *)0x0) {
		return 0;
	}
	pFVar6 = pFVar5;
	if ((stream->_flag & 0x10cU) == 0) {
		stream = (FILE *)0x1000;
		pFVar8 = (FILE *)0x1000;
	}
	else {
		pFVar8 = (FILE *)stream->_bufsiz;
		stream = pFVar8;
	}
	do {
		if (((file->_flag & 0x10cU) == 0) || (pFVar1 = (FILE *)file->_cnt, pFVar1 == (FILE *)0x0)) {
			if (pFVar6 < pFVar8) {
				iVar3 = internal::__fpeekc(file);
				if (iVar3 == -1) {
					return (uint)((int)pFVar5 - (int)pFVar6) / size;
				}
				*(char *)out_buffer = (char)iVar3;
				pFVar8 = (FILE *)file->_bufsiz;
				out_buffer = (void *)((int)out_buffer + 1);
				iVar3 = -1;
				stream = pFVar8;
			}
			else {
				pFVar1 = pFVar6;
				if (pFVar8 != (FILE *)0x0) {
					pFVar1 = (FILE *)((int)pFVar6 - (uint)pFVar6 % (uint)pFVar8);
				}
				pcVar2 = internal::__fdread(file->_file,(char *)out_buffer,(DWORD)pFVar1);
				if (pcVar2 == (char *)0x0) {
					file->_flag = file->_flag | 0x10;
					return (uint)((int)pFVar5 - (int)pFVar6) / size;
				}
				if (pcVar2 == (char *)0xffffffff) {
					file->_flag = file->_flag | 0x20;
					return (uint)((int)pFVar5 - (int)pFVar6) / size;
				}
				iVar3 = -(int)pcVar2;
				out_buffer = (void *)((int)out_buffer + (int)pcVar2);
			}
		}
		else {
			if (pFVar6 < pFVar1) {
				pFVar1 = pFVar6;
			}
			iVar3 = -(int)pFVar1;
			puVar7 = (undefined4 *)file->_ptr;
			puVar9 = (undefined4 *)out_buffer;
			for (uVar4 = (uint)pFVar1 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
				*puVar9 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar9 = puVar9 + 1;
			}
			for (uVar4 = (uint)pFVar1 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
				*(undefined *)puVar9 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar9 = (undefined4 *)((int)puVar9 + 1);
			}
			out_buffer = (void *)((int)out_buffer + (int)pFVar1);
			file->_cnt = file->_cnt - (int)pFVar1;
			file->_ptr = (char *)((int)&pFVar1->_ptr + (int)file->_ptr);
			pFVar8 = stream;
		}
		pFVar6 = (FILE *)((int)&pFVar6->_ptr + iVar3);
		if (pFVar6 == (FILE *)0x0) {
			return count;
		}
	} while( true );
}



int __cdecl std::internal::__std_FUN_0048ff90(FILE *stream)
{
	int iVar1;
	
	if (stream == (FILE *)0x0) {
		iVar1 = __std_FUN_00490060(0);
		return iVar1;
	}
	iVar1 = __std_fflush__0048ffe0(stream);
	if (iVar1 != 0) {
		return -1;
	}
	if ((stream->_flag & 0x4000U) != 0) {
		iVar1 = __std_FUN_00497650(stream->_file);
		return -(uint)(iVar1 != 0);
	}
	return 0;
}



int __cdecl std::internal::__std_fflush__0048ffe0(FILE *stream)
{
	uint uVar1;
	char *pcVar2;
	int iVar3;
	char *pcVar4;
	
	iVar3 = 0;
	if ((((byte)stream->_flag & 3) == 2) && ((stream->_flag & 0x108U) != 0)) {
		pcVar4 = stream->_ptr + -(int)stream->_base;
		if (0 < (int)pcVar4) {
			pcVar2 = (char *)__fdwrite__00496f80(stream->_file,stream->_base,pcVar4);
			uVar1 = stream->_flag;
			if (pcVar2 == pcVar4) {
				if ((uVar1 & 0x80) != 0) {
					stream->_cnt = 0;
					stream->_flag = uVar1 & 0xfffffffd;
					stream->_ptr = stream->_base;
					return 0;
				}
			}
			else {
				iVar3 = -1;
				stream->_flag = uVar1 | 0x20;
			}
		}
	}
	stream->_cnt = 0;
	stream->_ptr = stream->_base;
	return iVar3;
}



void std::internal::__std_FUN_00490050(void)
{
	__std_FUN_00490060(1);
	return;
}



int __cdecl std::internal::__std_FUN_00490060(int param_1)
{
	FILE *stream;
	int iVar1;
	int iVar2;
	int iVar3;
	int iVar4;
	
	iVar2 = 0;
	iVar4 = 0;
	iVar3 = 0;
	if (0 < globals::__filesCount_0076eda0) {
		do {
			stream = globals::__filesTable_0076dd98[iVar3];
			if ((stream != (FILE *)0x0) && ((stream->_flag & 0x83U) != 0)) {
				if (param_1 == 1) {
					iVar1 = __std_FUN_0048ff90(stream);
					if (iVar1 != -1) {
						iVar2 = iVar2 + 1;
					}
				}
				else {
					if ((param_1 == 0) && ((stream->_flag & 2U) != 0)) {
						iVar1 = __std_FUN_0048ff90(stream);
						if (iVar1 == -1) {
							iVar4 = -1;
						}
					}
				}
			}
			iVar3 = iVar3 + 1;
		} while (iVar3 < globals::__filesCount_0076eda0);
	}
	if (param_1 != 1) {
		iVar2 = iVar4;
	}
	return iVar2;
}



int __cdecl std::fgetc(FILE *stream)
{
	byte bVar1;
	int iVar2;
	uint uVar3;
	
	iVar2 = stream->_cnt + -1;
	stream->_cnt = iVar2;
	if (-1 < iVar2) {
		bVar1 = *stream->_ptr;
		stream->_ptr = stream->_ptr + 1;
		return (uint)bVar1;
	}
	uVar3 = internal::__fpeekc(stream);
	return uVar3;
}



char * __cdecl std::fgets(char *str,int numChars,FILE *stream)
{
	int iVar1;
	uint uVar2;
	int iVar3;
	char *pcVar4;
	
	if (numChars < 1) {
		return (char *)0x0;
	}
	iVar3 = numChars + -1;
	pcVar4 = str;
	if (iVar3 != 0) {
		while( true ) {
			iVar1 = stream->_cnt + -1;
			stream->_cnt = iVar1;
			if (iVar1 < 0) {
				uVar2 = internal::__fpeekc(stream);
			}
			else {
				uVar2 = (uint)(byte)*stream->_ptr;
				stream->_ptr = stream->_ptr + 1;
			}
			if (uVar2 == 0xffffffff) break;
			*pcVar4 = (char)uVar2;
			pcVar4 = pcVar4 + 1;
			if ((char)uVar2 == '\n') goto LAB_00490176;
			iVar3 = iVar3 + -1;
			if (iVar3 == 0) {
				*pcVar4 = '\0';
				return str;
			}
		}
		if (pcVar4 == str) {
			return (char *)0x0;
		}
	}
LAB_00490176:
	*pcVar4 = '\0';
	return str;
}



int __cdecl std::vfprintf(FILE *stream,char *format,va_list argptr)
{
	BOOL BVar1;
	int iVar2;
	
	BVar1 = internal::__vfprintf__00497790(stream);
	iVar2 = internal::__vfprintf_internal(stream,format,argptr);
	internal::__vfprintf__00497830(BVar1,stream);
	return iVar2;
}



// Library Function - Single Match
// Name: __strcmpi
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release

int __cdecl std::_stricmp(char *_Str1,char *_Str2)
{
	char cVar1;
	char cVar2;
	byte bVar3;
	byte bVar5;
	uint uVar4;
	uint c;
	
	if (DAT_0054a180 == 0) {
		uVar4 = 0xff;
		do {
			do {
				cVar2 = (char)uVar4;
				if (cVar2 == '\0') goto LAB_0049021e;
				cVar2 = *_Str2;
				_Str2 = _Str2 + 1;
				cVar1 = *_Str1;
				uVar4 = (uint)CONCAT11(cVar1,cVar2);
				_Str1 = _Str1 + 1;
			} while ((char)(uVar4 >> 8) == cVar2);
			bVar3 = cVar1 + 0xbf;
			bVar3 = bVar3 + (-(bVar3 < 0x1a) & 0x20U) + 0x41;
			uVar4 = (uint)CONCAT11(cVar2 + 0xbfU + (-((byte)(cVar2 + 0xbfU) < 0x1a) & 0x20U) + 'A',bVar3);
			bVar5 = (byte)(uVar4 >> 8);
		} while (bVar3 == bVar5);
		cVar2 = (bVar3 < bVar5) * -2 + '\x01';
LAB_0049021e:
		uVar4 = SEXT14(cVar2);
	}
	else {
		c = 0;
		uVar4 = 0xff;
		do {
			do {
				if ((char)uVar4 == '\0') {
					return uVar4;
				}
				bVar3 = *_Str2;
				uVar4 = uVar4 & 0xffffff00 | (uint)bVar3;
				_Str2 = (char *)((byte *)_Str2 + 1);
				bVar5 = *_Str1;
				c = c & 0xffffff00 | (uint)bVar5;
				_Str1 = (char *)((byte *)_Str1 + 1);
			} while (bVar3 == bVar5);
			c = tolower(c);
			uVar4 = tolower(uVar4);
		} while ((byte)c == (byte)uVar4);
		uVar4 = (uint)((byte)c < (byte)uVar4);
		uVar4 = (1 - uVar4) - (uint)(uVar4 != 0);
	}
	return uVar4;
}



char * __cdecl std::_fullpath(char *out_absPath,LPCSTR relPath,uint maxLength)
{
	LPSTR lpBuffer;
	LPSTR pCVar1;
	DWORD error_value;
	char *pcVar2;
	LPSTR nBufferLength;
	
	if ((relPath == (LPCSTR)0x0) || (*relPath == '\0')) {
		pcVar2 = _getcwd(out_absPath,maxLength);
		return pcVar2;
	}
	lpBuffer = out_absPath;
	nBufferLength = (LPSTR)maxLength;
	if (out_absPath == (char *)0x0) {
		lpBuffer = (LPSTR)malloc(MAX_PATH);
		if (lpBuffer == (LPSTR)0x0) {
			globals::g_msvc_errno = ENOMEM;
			return (char *)0x0;
		}
		nBufferLength = (LPSTR)MAX_PATH;
	}
	pCVar1 = (LPSTR)GetFullPathNameA(relPath,(DWORD)nBufferLength,lpBuffer,(LPSTR *)&maxLength);
	if (pCVar1 < nBufferLength) {
		if (pCVar1 != (LPSTR)0x0) {
			return lpBuffer;
		}
		if (out_absPath == (char *)0x0) {
			free(lpBuffer);
		}
		error_value = GetLastError();
		internal::__set_doserrno(error_value);
		return (char *)0x0;
	}
	if (out_absPath == (char *)0x0) {
		free(lpBuffer);
	}
	globals::g_msvc_errno = ERANGE;
	return (char *)0x0;
}



int __cdecl std::fscanf(FILE *stream,char *format,...)
{
	int iVar1;
	
	iVar1 = vfscanf(stream,format,&stack0x0000000c);
	return iVar1;
}



void __cdecl std::_splitpath(char *path,char *drive,char *dir,char *fname,char *ext)
{
	char cVar1;
	byte bVar2;
	byte *pbVar3;
	int iVar4;
	byte *pbVar5;
	char *pcVar6;
	byte *local_4;
	
	iVar4 = -1;
	pcVar6 = path;
	do {
		if (iVar4 == 0) break;
		iVar4 = iVar4 + -1;
		cVar1 = *pcVar6;
		pcVar6 = pcVar6 + 1;
	} while (cVar1 != '\0');
	local_4 = (byte *)0x0;
	if ((iVar4 == -2) || (path[1] != ':')) {
		if (drive != (char *)0x0) {
			*drive = '\0';
		}
	}
	else {
		if (drive != (char *)0x0) {
			strncpy(drive,path,2);
			drive[2] = '\0';
		}
		path = path + 2;
	}
	bVar2 = *path;
	drive = (char *)0x0;
	pbVar5 = (byte *)path;
	while (bVar2 != 0) {
		bVar2 = *pbVar5;
		if ((*(byte *)((int)&DAT_0054a2b8 + bVar2 + 1) & 4) == 0) {
			if ((bVar2 == '/') || (bVar2 == '\\')) {
				drive = (char *)(pbVar5 + 1);
			}
			else {
				if (bVar2 == '.') {
					local_4 = pbVar5;
				}
			}
		}
		else {
			pbVar5 = pbVar5 + 1;
		}
		pbVar3 = pbVar5 + 1;
		pbVar5 = pbVar5 + 1;
		bVar2 = *pbVar3;
	}
	if ((byte *)drive == (byte *)0x0) {
		drive = path;
		if (dir != (char *)0x0) {
			*dir = '\0';
		}
	}
	else {
		if (dir != (char *)0x0) {
			pbVar3 = (byte *)drive + -(int)path;
			if ((byte *)0xfe < pbVar3) {
				pbVar3 = (byte *)0xff;
			}
			strncpy(dir,path,(size_t)pbVar3);
			pbVar3[(int)dir] = 0;
		}
	}
	if ((local_4 == (byte *)0x0) || (local_4 < drive)) {
		if (fname != (char *)0x0) {
			pbVar5 = pbVar5 + -(int)drive;
			if ((byte *)0xfe < pbVar5) {
				pbVar5 = (byte *)0xff;
			}
			strncpy(fname,drive,(size_t)pbVar5);
			pbVar5[(int)fname] = 0;
		}
		if (ext != (char *)0x0) {
			*ext = '\0';
		}
	}
	else {
		if (fname != (char *)0x0) {
			pbVar3 = local_4 + -(int)drive;
			if ((byte *)0xfe < pbVar3) {
				pbVar3 = (byte *)0xff;
			}
			strncpy(fname,drive,(size_t)pbVar3);
			pbVar3[(int)fname] = 0;
		}
		if (ext != (char *)0x0) {
			pbVar5 = pbVar5 + -(int)local_4;
			if ((byte *)0xfe < pbVar5) {
				pbVar5 = (byte *)0xff;
			}
			strncpy(ext,(char *)local_4,(size_t)pbVar5);
			pbVar5[(int)ext] = 0;
			return;
		}
	}
	return;
}



// Library Function - Single Match
// Name: __setdefaultprecision
// Library: Visual Studio 1998 Release

void __setdefaultprecision(void)
{
	std::internal::__std_FUN_00497a70(0x10000,0x30000);
	return;
}



// WARNING: Removing unreachable block (ram,0x00490531)

undefined4 std::internal::__fpmath__004904f0(void)
{
	return 0;
}



void std::internal::__fpmath__00490540(void)
{
	HMODULE hModule;
	FARPROC pFVar1;
	
	hModule = GetModuleHandleA("KERNEL32");
	if (hModule != (HMODULE)0x0) {
		pFVar1 = GetProcAddress(hModule,"IsProcessorFeaturePresent");
		if (pFVar1 != (FARPROC)0x0) {
			(*pFVar1)(0);
			return;
		}
	}
	__fpmath__004904f0();
	return;
}



void __cdecl std::internal::__fpmath__00490570(char *param_1)
{
	char cVar1;
	char cVar2;
	int iVar3;
	uint uVar4;
	
	iVar3 = tolower((int)*param_1);
	if (iVar3 != 0x65) {
		do {
			param_1 = param_1 + 1;
										// int std::isdigit(int c)
			if (std::globals::_pcharwidth < 2) {
				uVar4 = *(byte *)(std::globals::_pctype + *param_1) & C1_DIGIT;
			}
			else {
				uVar4 = _isctype((int)*param_1,C1_DIGIT);
			}
		} while (uVar4 != 0);
	}
	cVar2 = *param_1;
	*param_1 = DAT_004b0f78;
	do {
		param_1 = param_1 + 1;
		cVar1 = *param_1;
		*param_1 = cVar2;
		cVar2 = cVar1;
	} while (*param_1 != '\0');
	return;
}



void __cdecl std::internal::__fpmath__004905d0(char *param_1)
{
	char cVar1;
	char *pcVar2;
	char *pcVar3;
	char *pcVar4;
	
	cVar1 = *param_1;
	while ((cVar1 != '\0' && (cVar1 != DAT_004b0f78))) {
		pcVar2 = param_1 + 1;
		param_1 = param_1 + 1;
		cVar1 = *pcVar2;
	}
	pcVar2 = param_1 + 1;
	if (*param_1 != '\0') {
		cVar1 = *pcVar2;
		while (((cVar1 != '\0' && (cVar1 != 'e')) && (cVar1 != 'E'))) {
			pcVar3 = pcVar2 + 1;
			pcVar2 = pcVar2 + 1;
			cVar1 = *pcVar3;
		}
		cVar1 = pcVar2[-1];
		pcVar3 = pcVar2;
		while (pcVar4 = pcVar3 + -1, cVar1 == '0') {
			cVar1 = pcVar3[-2];
			pcVar3 = pcVar4;
		}
		if (*pcVar4 == DAT_004b0f78) {
			pcVar4 = pcVar3 + -2;
		}
		cVar1 = *pcVar2;
		pcVar4 = pcVar4 + 1;
		*pcVar4 = cVar1;
		while (cVar1 != '\0') {
			pcVar2 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar4 = pcVar4 + 1;
			*pcVar4 = cVar1;
		}
	}
	return;
}



undefined4 __cdecl std::internal::__fpmath_isdouble_ge_0(double *param_1)
{
	if (0.0 <= *param_1) {
		return 1;
	}
	return 0;
}



void __cdecl std::internal::__std_FUN_00490660(int param_1,byte **param_2,byte *param_3)
{
	byte *local_8;
	byte *local_4;
	
	if (param_1 != 0) {
		__std_FUN_00498060((uint *)&local_8,param_3);
		*param_2 = local_8;
		param_2[1] = local_4;
		return;
	}
	__std_FUN_004980a0((uint *)&param_3,param_3);
	*param_2 = param_3;
	return;
}



undefined * __cdecl
std::internal::__std_FUN_004906c0(undefined4 *param_1,undefined *param_2,int param_3,int param_4)
{
	int *piVar1;
	undefined *puVar2;
	int iVar3;
	undefined4 *puVar4;
	
	piVar1 = DAT_0054a128;
	if (DAT_0054a12c == '\0') {
		piVar1 = (int *)__std_FUN_00498180((char)*param_1);
		__std_FUN_004980e0((undefined4 *)(param_2 + (uint)(*piVar1 == 0x2d) + (uint)(0 < param_3)),
											 param_3 + 1,(int)piVar1);
	}
	else {
		__std_FUN_00490a80((undefined4 *)(param_2 + (*DAT_0054a128 == 0x2d)),(uint)(0 < param_3));
	}
	puVar2 = param_2;
	if (*piVar1 == 0x2d) {
		*param_2 = 0x2d;
		puVar2 = param_2 + 1;
	}
	if (0 < param_3) {
		*puVar2 = puVar2[1];
		puVar2 = puVar2 + 1;
		*puVar2 = DAT_004b0f78;
	}
	puVar4 = (undefined4 *)(puVar2 + param_3 + (uint)(DAT_0054a12c == '\0'));
	*puVar4 = 0x30302b65;
	*(undefined2 *)(puVar4 + 1) = 0x30;
	if (param_4 != 0) {
		*(undefined *)puVar4 = 0x45;
	}
	if (*(char *)piVar1[3] != '0') {
		iVar3 = piVar1[1] + -1;
		if (iVar3 < 0) {
			iVar3 = -iVar3;
			*(undefined *)((int)puVar4 + 1) = 0x2d;
		}
		if (99 < iVar3) {
			*(char *)((int)puVar4 + 2) = *(char *)((int)puVar4 + 2) + (char)(iVar3 / 100);
			iVar3 = iVar3 % 100;
		}
		if (9 < iVar3) {
			*(char *)((int)puVar4 + 3) = *(char *)((int)puVar4 + 3) + (char)(iVar3 / 10);
			iVar3 = iVar3 % 10;
		}
		*(char *)(puVar4 + 1) = *(char *)(puVar4 + 1) + (char)iVar3;
	}
	return param_2;
}



undefined4 * __cdecl
std::internal::__std_FUN_00490800(undefined4 *param_1,undefined4 *param_2,uint param_3)
{
	int iVar1;
	undefined *puVar2;
	int *piVar3;
	uint uVar4;
	undefined4 *puVar5;
	
	piVar3 = DAT_0054a128;
	if (DAT_0054a12c == '\0') {
		piVar3 = (int *)__std_FUN_00498180((char)*param_1);
		__std_FUN_004980e0((undefined4 *)((uint)(*piVar3 == 0x2d) + (int)param_2),piVar3[1] + param_3,
											 (int)piVar3);
	}
	else {
		if (DAT_0054a130 == param_3) {
			puVar2 = (undefined *)((int)param_2 + DAT_0054a130 + (*DAT_0054a128 == 0x2d));
			*puVar2 = 0x30;
			puVar2[1] = 0;
		}
	}
	puVar5 = param_2;
	if (*piVar3 == 0x2d) {
		*(undefined *)param_2 = 0x2d;
		puVar5 = (undefined4 *)((int)param_2 + 1);
	}
	if (piVar3[1] < 1) {
		__std_FUN_00490a80(puVar5,1);
		*(undefined *)puVar5 = 0x30;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
	}
	else {
		puVar5 = (undefined4 *)((int)puVar5 + piVar3[1]);
	}
	if (0 < (int)param_3) {
		__std_FUN_00490a80(puVar5,1);
		*(undefined *)puVar5 = DAT_004b0f78;
		iVar1 = piVar3[1];
		if (iVar1 < 0) {
			if ((DAT_0054a12c != '\0') || (SBORROW4(param_3,-iVar1) == (int)(param_3 + iVar1) < 0)) {
				param_3 = -iVar1;
			}
			__std_FUN_00490a80((undefined4 *)((int)puVar5 + 1),param_3);
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			for (uVar4 = param_3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
				*puVar5 = 0x30303030;
				puVar5 = puVar5 + 1;
			}
			for (uVar4 = param_3 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
				*(undefined *)puVar5 = 0x30;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
			}
		}
	}
	return param_2;
}



void __cdecl
std::internal::__std_FUN_00490900(undefined4 *param_1,undefined4 *param_2,uint param_3,int param_4)
{
	char cVar1;
	undefined4 *puVar2;
	
	DAT_0054a128 = (int *)__std_FUN_00498180((char)*param_1);
	DAT_0054a130 = DAT_0054a128[1] + -1;
	puVar2 = (undefined4 *)((uint)(*DAT_0054a128 == 0x2d) + (int)param_2);
	__std_FUN_004980e0(puVar2,param_3,(int)DAT_0054a128);
	DAT_0054a134 = DAT_0054a130 < DAT_0054a128[1] + -1;
	DAT_0054a130 = DAT_0054a128[1] + -1;
	if ((-5 < DAT_0054a130) && (DAT_0054a130 < (int)param_3)) {
		if ((bool)DAT_0054a134) {
			cVar1 = *(char *)puVar2;
			while (cVar1 != '\0') {
				cVar1 = *(char *)(undefined4 *)((int)puVar2 + 1);
				puVar2 = (undefined4 *)((int)puVar2 + 1);
			}
			*(undefined *)((int)puVar2 + -1) = 0;
		}
		__std_FUN_004909e0(param_1,param_2,param_3);
		return;
	}
	__std_FUN_004909b0(param_1,(undefined *)param_2,param_3,param_4);
	return;
}



void __cdecl
std::internal::__std_FUN_004909b0(undefined4 param_1,undefined *param_2,int param_3,int param_4)
{
	DAT_0054a12c = 1;
	__std_FUN_004906c0(param_1,param_2,param_3,param_4);
	DAT_0054a12c = 0;
	return;
}



void __cdecl std::internal::__std_FUN_004909e0(undefined4 param_1,undefined4 *param_2,uint param_3)
{
	DAT_0054a12c = 1;
	__std_FUN_00490800(param_1,param_2,param_3);
	DAT_0054a12c = 0;
	return;
}



void __cdecl
std::internal::__std_FUN_00490a10
					(undefined4 param_1,undefined4 *param_2,int param_3,uint param_4,int param_5)
{
	if ((param_3 != 0x65) && (param_3 != 0x45)) {
		if (param_3 == 0x66) {
			__std_FUN_00490800(param_1,param_2,param_4);
			return;
		}
		__std_FUN_00490900(param_1,param_2,param_4,param_5);
		return;
	}
	__std_FUN_004906c0(param_1,(undefined *)param_2,param_4,param_5);
	return;
}



void __cdecl std::internal::__std_FUN_00490a80(undefined4 *param_1,int param_2)
{
	char cVar1;
	uint uVar2;
	undefined4 *puVar3;
	
	if (param_2 != 0) {
		uVar2 = 0xffffffff;
		puVar3 = param_1;
		do {
			if (uVar2 == 0) break;
			uVar2 = uVar2 - 1;
			cVar1 = *(char *)puVar3;
			puVar3 = (undefined4 *)((int)puVar3 + 1);
		} while (cVar1 != '\0');
		__std_FUN_004982c0((undefined4 *)(param_2 + (int)param_1),param_1,~uVar2);
	}
	return;
}



undefined * __cdecl std::internal::__atof_internal(char *str)
{
	char *pcVar1;
	uint uVar2;
	int iVar3;
	uint uVar4;
	uint local_14;
	undefined4 uStack16;
	ushort local_c [6];
	
	pcVar1 = str;
	uVar4 = 0;
	uVar2 = __std_FUN_00498610(local_c,(byte **)&str,(byte *)str,0,0,0,0);
	if ((uVar2 & 4) == 0) {
		iVar3 = __std_FUN_00498020(local_c,&local_14);
		if (((uVar2 & 2) != 0) || (iVar3 == 1)) {
			uVar4 = 0x80;
		}
		if (((uVar2 & 1) != 0) || (iVar3 == 2)) {
			uVar4 = uVar4 | 0x100;
		}
	}
	else {
		uVar4 = 0x200;
		local_14 = 0;
		uStack16 = 0;
	}
	*(uint *)PTR_DAT_004b0f98 = uVar4;
	*(char **)(PTR_DAT_004b0f98 + 4) = str + -(int)pcVar1;
	*(ulonglong *)(PTR_DAT_004b0f98 + 0x10) = CONCAT44(uStack16,local_14);
	return PTR_DAT_004b0f98;
}



uint __cdecl std::internal::__fafterwrite_00490b60(uint param_1,char **param_2)
{
	char *fd;
	char *pcVar1;
	char **file;
	BOOL BVar2;
	undefined *puVar3;
	char *pcVar4;
	char *pcVar5;
	
	file = param_2;
	pcVar5 = param_2[3];
	fd = param_2[4];
	if ((((uint)pcVar5 & 0x82) == 0) || (((uint)pcVar5 & 0x40) != 0)) {
LAB_00490c80:
		param_2[3] = (char *)((uint)pcVar5 | 0x20);
		return 0xffffffff;
	}
	pcVar4 = (char *)0x0;
	if (((uint)pcVar5 & 1) != 0) {
		param_2[1] = (char *)0x0;
		if (((uint)pcVar5 & 0x10) == 0) goto LAB_00490c80;
		*param_2 = param_2[2];
		param_2[3] = (char *)((uint)pcVar5 & 0xfffffffe);
	}
	pcVar5 = param_2[3];
	param_2[1] = (char *)0x0;
	param_2[3] = (char *)((uint)pcVar5 & 0xffffffef | 2);
	if (((uint)pcVar5 & 0x10c) == 0) {
		if (((FILE *)param_2 == &globals::__FILE_004b3648) ||
			 ((FILE *)param_2 == &globals::__FILE_004b3668)) {
			BVar2 = __std_FUN_00498e00((uint)fd);
			if (BVar2 != 0) goto LAB_00490bd3;
		}
		__fileunk__00498da0((FILE *)file);
	}
LAB_00490bd3:
	if (((uint)file[3] & 0x108) == 0) {
		pcVar5 = (char *)0x1;
		pcVar4 = (char *)__fdwrite__00496f80((uint)fd,(char *)&param_1,(char *)0x1);
	}
	else {
		pcVar1 = file[2];
		pcVar5 = *file + -(int)pcVar1;
		*file = pcVar1 + 1;
		file[1] = file[6] + -1;
		if ((int)pcVar5 < 1) {
			if (fd == (char *)0xffffffff) {
				puVar3 = &DAT_004b3428;
			}
			else {
				puVar3 = (undefined *)((&DAT_0076edc0)[(int)fd >> 5] + ((uint)fd & 0x1f) * 8);
			}
			if ((puVar3[4] & 0x20) != 0) {
				__fdread__00496ec0((uint)fd,0,2);
			}
			*file[2] = (char)param_1;
		}
		else {
			pcVar4 = (char *)__fdwrite__00496f80((uint)fd,pcVar1,pcVar5);
			*file[2] = (char)param_1;
		}
	}
	if (pcVar4 != pcVar5) {
		file[3] = (char *)((uint)file[3] | 0x20);
		return 0xffffffff;
	}
	return param_1 & 0xff;
}



// WARNING: Could not reconcile some variable overlaps

int __cdecl std::internal::__vfprintf_internal(FILE *stream,char *format,va_list argptr,...)
{
	char cVar1;
	FILE *pFVar2;
	uint uVar3;
	short *psVar4;
	int *piVar5;
	undefined4 uVar6;
	LPSTR pCVar7;
	byte bVar8;
	ushort *puVar9;
	ushort *puVar10;
	ushort *puVar11;
	byte *pbVar12;
	char *pcVar13;
	uint uVar14;
	int iVar15;
	ulonglong uVar16;
	undefined8 uVar17;
	ulonglong uVar18;
	uint local_24c;
	ushort *local_248;
	int local_244;
	int local_240;
	char local_23a;
	char local_239;
	int local_238;
	int local_234;
	int local_230;
	uint local_22c;
	int local_228;
	int local_224;
	int local_220;
	uint local_21c;
	undefined4 local_218;
	CHAR local_214 [4];
	undefined4 local_210;
	undefined4 local_20c;
	uint local_204;
	undefined local_200 [512];
	
	local_220 = 0;
	puVar10 = (ushort *)0x0;
	local_240 = 0;
	bVar8 = *format;
	pbVar12 = (byte *)(format + 1);
	local_21c = local_21c & 0xffffff00 | (uint)bVar8;
	do {
		if ((bVar8 == 0) || (local_240 < 0)) {
			return local_240;
		}
		if (((char)bVar8 < ' ') || ('x' < (char)bVar8)) {
			uVar3 = 0;
		}
		else {
			uVar3 = (byte)"IsProcessorFeaturePresent"[(char)bVar8 + 0x18] & 0xf;
		}
		local_220 = (int)(char)(&DAT_0049fb70)[uVar3 * 8 + local_220] >> 4;
		format = (char *)pbVar12;
		switch(local_220) {
		case 0:
switchD_00490d0d_caseD_0:
			local_230 = 0;
			if ((*(byte *)((int)std::globals::_pctype + (local_21c & 0xff) * 2 + 1) & 0x80) != 0) {
				__std_FUN_00491620((int)(char)bVar8,(char **)stream,&local_240);
				bVar8 = *pbVar12;
				format = (char *)(pbVar12 + 1);
			}
			__std_FUN_00491620((int)(char)bVar8,(char **)stream,&local_240);
			break;
		case 1:
			local_218 = 0;
			local_228 = 0;
			local_234 = 0;
			local_238 = 0;
			local_24c = 0;
			local_244 = -1;
			local_230 = 0;
			break;
		case 2:
			switch(bVar8) {
			case 0x20:
				local_24c = local_24c | 2;
				break;
			case 0x23:
				local_24c = local_24c | 0x80;
				break;
			case 0x2b:
				local_24c = local_24c | 1;
				break;
			case 0x2d:
				local_24c = local_24c | 4;
				break;
			case 0x30:
				local_24c = local_24c | 8;
			}
			break;
		case 3:
			if (bVar8 == 0x2a) {
				local_234 = __std_FUN_004916f0((int *)&argptr);
				if (local_234 < 0) {
					local_24c = local_24c | 4;
					local_234 = -local_234;
				}
			}
			else {
				local_234 = (char)bVar8 + -0x30 + local_234 * 10;
			}
			break;
		case 4:
			local_244 = 0;
			break;
		case 5:
			if (bVar8 == 0x2a) {
				local_244 = __std_FUN_004916f0((int *)&argptr);
				if (local_244 < 0) {
					local_244 = -1;
				}
			}
			else {
				local_244 = (char)bVar8 + -0x30 + local_244 * 10;
			}
			break;
		case 6:
			switch(bVar8) {
			case 0x49:
				if ((*pbVar12 != 0x36) || (pbVar12[1] != 0x34)) {
					local_220 = 0;
					goto switchD_00490d0d_caseD_0;
				}
				format = (char *)(pbVar12 + 2);
				local_24c = local_24c | 0x8000;
				break;
			case 0x68:
				local_24c = local_24c | 0x20;
				break;
			case 0x6c:
				local_24c = local_24c | 0x10;
				break;
			case 0x77:
				local_24c = local_24c | 0x800;
			}
			break;
		case 7:
			switch(bVar8) {
			case 0x43:
				if ((local_24c & 0x830) == 0) {
					local_24c = local_24c | 0x800;
				}
			case 99:
				if ((local_24c & 0x810) == 0) {
					uVar6 = __std_FUN_004916f0((int *)&argptr);
					local_200[0] = (char)uVar6;
					puVar10 = (ushort *)0x1;
				}
				else {
					uVar3 = __std_FUN_00491730((ushort **)&argptr);
					puVar10 = (ushort *)__vfprintf__00498e30(local_200,(ushort)uVar3);
					if ((int)puVar10 < 0) {
						local_248 = (ushort *)local_200;
						local_228 = 1;
						break;
					}
				}
				local_248 = (ushort *)local_200;
				break;
			case 0x45:
			case 0x47:
				local_218 = 1;
				bVar8 = bVar8 + 0x20;
			case 0x65:
			case 0x66:
			case 0x67:
				local_248 = (ushort *)local_200;
				if (local_244 < 0) {
					local_244 = 6;
				}
				else {
					if ((local_244 == 0) && (bVar8 == 0x67)) {
						local_244 = 1;
					}
				}
				local_210 = *(undefined4 *)argptr;
				local_20c = *(undefined4 *)((int)argptr + 4);
				argptr = (va_list)((int)argptr + 8);
				(*(code *)PTR___std_FUN_004b0f80)(&local_210,local_200,(int)(char)bVar8,local_244,local_218)
				;
				if (((local_24c & 0x80) != 0) && (local_244 == 0)) {
					(*(code *)PTR___std_FUN_004b0f8c)(local_200);
				}
				if ((bVar8 == 0x67) && ((local_24c & 0x80) == 0)) {
					(*(code *)PTR___std_FUN_004b0f84)(local_200);
				}
				uVar3 = local_24c | 0x40;
				if (local_200[0] == '-') {
					local_248 = (ushort *)(local_200 + 1);
					uVar3 = local_24c | 0x140;
				}
				local_24c = uVar3;
				uVar3 = 0xffffffff;
				puVar10 = local_248;
				do {
					if (uVar3 == 0) break;
					uVar3 = uVar3 - 1;
					cVar1 = *(char *)puVar10;
					puVar10 = (ushort *)((int)puVar10 + 1);
				} while (cVar1 != '\0');
				puVar10 = (ushort *)(~uVar3 - 1);
				break;
			case 0x53:
				if ((local_24c & 0x830) == 0) {
					local_24c = local_24c | 0x800;
				}
			case 0x73:
				iVar15 = 0x7fffffff;
				if (local_244 != -1) {
					iVar15 = local_244;
				}
				local_248 = (ushort *)__std_FUN_004916f0((int *)&argptr);
				if ((local_24c & 0x810) == 0) {
					puVar10 = local_248;
					if (local_248 == (ushort *)0x0) {
						puVar10 = (ushort *)PTR_s__null__004b0f9c;
						local_248 = (ushort *)PTR_s__null__004b0f9c;
					}
					for (; (iVar15 != 0 && (iVar15 = iVar15 + -1, *(char *)puVar10 != '\0'));
							puVar10 = (ushort *)((int)puVar10 + 1)) {
					}
					puVar10 = (ushort *)((int)puVar10 - (int)local_248);
				}
				else {
					if (local_248 == (ushort *)0x0) {
						local_248 = (ushort *)PTR_u__null__004b0fa0;
					}
					local_230 = 1;
					for (puVar10 = local_248; (iVar15 != 0 && (iVar15 = iVar15 + -1, *puVar10 != 0));
							puVar10 = puVar10 + 1) {
					}
					puVar10 = (ushort *)((int)((int)puVar10 - (int)local_248) >> 1);
				}
				break;
			case 0x58:
				goto switchD_00490f21_caseD_58;
			case 0x5a:
				psVar4 = (short *)__std_FUN_004916f0((int *)&argptr);
				if ((psVar4 == (short *)0x0) ||
					 (local_248 = *(ushort **)(psVar4 + 2), local_248 == (ushort *)0x0)) {
					uVar3 = 0xffffffff;
					local_248 = (ushort *)PTR_s__null__004b0f9c;
					pcVar13 = PTR_s__null__004b0f9c;
					do {
						if (uVar3 == 0) break;
						uVar3 = uVar3 - 1;
						cVar1 = *pcVar13;
						pcVar13 = pcVar13 + 1;
					} while (cVar1 != '\0');
					puVar10 = (ushort *)(~uVar3 - 1);
				}
				else {
					if ((local_24c & 0x800) == 0) {
						puVar10 = (ushort *)(int)*psVar4;
						local_230 = 0;
					}
					else {
						local_230 = 1;
						puVar10 = (ushort *)((uint)(int)*psVar4 >> 1);
					}
				}
				break;
			case 100:
			case 0x69:
				local_22c = 10;
				local_24c = local_24c | 0x40;
				goto LAB_00491257;
			case 0x6e:
				piVar5 = (int *)__std_FUN_004916f0((int *)&argptr);
				if ((local_24c & 0x20) == 0) {
					local_228 = 1;
					*piVar5 = local_240;
				}
				else {
					local_228 = 1;
					*(undefined2 *)piVar5 = (undefined2)local_240;
				}
				break;
			case 0x6f:
				local_22c = 8;
				if ((local_24c & 0x80) != 0) {
					local_24c = local_24c | 0x200;
				}
				goto LAB_00491257;
			case 0x70:
				local_244 = 8;
switchD_00490f21_caseD_58:
				local_224 = 7;
LAB_00491212:
				local_22c = 0x10;
				if ((local_24c & 0x80) != 0) {
					local_23a = '0';
					local_239 = (char)local_224 + 'Q';
					local_238 = 2;
				}
				goto LAB_00491257;
			case 0x75:
				local_22c = 10;
LAB_00491257:
				if ((local_24c & 0x8000) == 0) {
					if ((local_24c & 0x20) == 0) {
						if ((local_24c & 0x40) == 0) {
							uVar3 = __std_FUN_004916f0((int *)&argptr);
							uVar16 = (ulonglong)uVar3;
						}
						else {
							iVar15 = __std_FUN_004916f0((int *)&argptr);
							uVar16 = SEXT48(iVar15);
						}
					}
					else {
						if ((local_24c & 0x40) == 0) {
							uVar3 = __std_FUN_004916f0((int *)&argptr);
							uVar16 = (ulonglong)uVar3 & 0xffffffff0000ffff;
						}
						else {
							uVar6 = __std_FUN_004916f0((int *)&argptr);
							uVar16 = SEXT48((int)(short)uVar6);
						}
					}
				}
				else {
					uVar16 = __std_FUN_00491710((int *)&argptr);
				}
				iVar15 = (int)(uVar16 >> 0x20);
				if ((((local_24c & 0x40) != 0) && (iVar15 == 0 || (longlong)uVar16 < 0)) &&
					 ((longlong)uVar16 < 0)) {
					local_24c = local_24c | 0x100;
					uVar16 = CONCAT44(-(iVar15 + (uint)((int)uVar16 != 0)),-(int)uVar16);
				}
				uVar3 = (uint)(uVar16 >> 0x20);
				if ((local_24c & 0x8000) == 0) {
					uVar3 = 0;
				}
				uVar18 = uVar16 & 0xffffffff | (ulonglong)uVar3 << 0x20;
				if (local_244 < 0) {
					local_244 = 1;
				}
				else {
					local_24c = local_24c & 0xfffffff7;
				}
				if (((uint)uVar16 | uVar3) == 0) {
					local_238 = 0;
				}
				puVar9 = (ushort *)(local_200 + 0x1ff);
				iVar15 = local_244;
				while( true ) {
					uVar3 = local_22c;
					uVar14 = (uint)(uVar18 >> 0x20);
					local_244 = iVar15 + -1;
					if ((iVar15 < 1) && (uVar18 == 0)) break;
					local_204 = (int)local_22c >> 0x1f;
					uVar17 = __aullrem((uint)uVar18,uVar14,local_22c,local_204);
					iVar15 = (int)uVar17 + 0x30;
					uVar18 = __aulldiv((uint)uVar18,uVar14,uVar3,local_204);
					if (0x39 < iVar15) {
						iVar15 = iVar15 + local_224;
					}
					*(char *)puVar9 = (char)iVar15;
					puVar9 = (ushort *)((int)puVar9 + -1);
					iVar15 = local_244;
				}
				puVar10 = (ushort *)(local_200 + -(int)puVar9 + 0x1ff);
				local_248 = (ushort *)((int)puVar9 + 1);
				if (((local_24c & 0x200) != 0) &&
					 ((*(char *)local_248 != '0' || (puVar10 == (ushort *)0x0)))) {
					puVar10 = (ushort *)(&stack0x00000000 + -(int)puVar9);
					*(undefined *)puVar9 = 0x30;
					local_248 = puVar9;
				}
				break;
			case 0x78:
				local_224 = 0x27;
				goto LAB_00491212;
			}
			pFVar2 = stream;
			if (local_228 == 0) {
				if ((local_24c & 0x40) != 0) {
					if ((local_24c & 0x100) == 0) {
						if ((local_24c & 1) == 0) {
							if ((local_24c & 2) == 0) goto LAB_004913ef;
							local_23a = ' ';
						}
						else {
							local_23a = '+';
						}
					}
					else {
						local_23a = '-';
					}
					local_238 = 1;
				}
LAB_004913ef:
				iVar15 = (local_234 - local_238) - (int)puVar10;
				if ((local_24c & 0xc) == 0) {
					__std_FUN_00491670(0x20,iVar15,(char **)stream,&local_240);
				}
				__std_FUN_004916b0(&local_23a,local_238,(char **)pFVar2,&local_240);
				if (((local_24c & 8) != 0) && ((local_24c & 4) == 0)) {
					__std_FUN_00491670(0x30,iVar15,(char **)pFVar2,&local_240);
				}
				if ((local_230 == 0) || (puVar11 = local_248, puVar9 = puVar10, (int)puVar10 < 1)) {
					__std_FUN_004916b0((char *)local_248,(int)puVar10,(char **)pFVar2,&local_240);
				}
				else {
					do {
						puVar9 = (ushort *)((int)puVar9 + -1);
						pCVar7 = __vfprintf__00498e30(local_214,*puVar11);
						if ((int)pCVar7 < 1) break;
						__std_FUN_004916b0(local_214,(int)pCVar7,(char **)stream,&local_240);
						puVar11 = puVar11 + 1;
					} while (puVar9 != (ushort *)0x0);
				}
				if ((local_24c & 4) != 0) {
					__std_FUN_00491670(0x20,iVar15,(char **)stream,&local_240);
				}
			}
		}
		bVar8 = *format;
		pbVar12 = (byte *)(format + 1);
		local_21c = local_21c & 0xffffff00 | (uint)bVar8;
	} while( true );
}



void __cdecl std::internal::__std_FUN_00491620(uint param_1,char **param_2,int *param_3)
{
	char *pcVar1;
	uint uVar2;
	
	pcVar1 = param_2[1];
	param_2[1] = pcVar1 + -1;
	if ((int)(pcVar1 + -1) < 0) {
		uVar2 = __fafterwrite_00490b60(param_1,param_2);
	}
	else {
		**param_2 = (char)param_1;
		uVar2 = param_1 & 0xff;
		*param_2 = *param_2 + 1;
	}
	if (uVar2 == 0xffffffff) {
		*param_3 = -1;
		return;
	}
	*param_3 = *param_3 + 1;
	return;
}



void __cdecl std::internal::__std_FUN_00491670(uint param_1,int param_2,char **param_3,int *param_4)
{
	if (0 < param_2) {
		do {
			param_2 = param_2 + -1;
			__std_FUN_00491620(param_1,param_3,param_4);
			if (*param_4 == -1) {
				return;
			}
		} while (0 < param_2);
	}
	return;
}



void __cdecl
std::internal::__std_FUN_004916b0(char *param_1,int param_2,char **param_3,int *param_4)
{
	char cVar1;
	
	if (0 < param_2) {
		do {
			param_2 = param_2 + -1;
			cVar1 = *param_1;
			param_1 = param_1 + 1;
			__std_FUN_00491620((int)cVar1,param_3,param_4);
			if (*param_4 == -1) {
				return;
			}
		} while (0 < param_2);
	}
	return;
}



undefined4 __cdecl std::internal::__std_FUN_004916f0(int *param_1)
{
	undefined4 *puVar1;
	
	puVar1 = (undefined4 *)*param_1;
	*param_1 = (int)(puVar1 + 1);
	return *puVar1;
}



undefined8 __cdecl std::internal::__std_FUN_00491710(int *param_1)
{
	undefined8 *puVar1;
	
	puVar1 = (undefined8 *)*param_1;
	*param_1 = (int)(puVar1 + 1);
	return *puVar1;
}



uint __cdecl std::internal::__std_FUN_00491730(ushort **param_1)
{
	ushort *puVar1;
	ushort *puVar2;
	
	puVar1 = *param_1;
	puVar2 = puVar1 + 2;
	*param_1 = puVar2;
	return (uint)puVar2 & 0xffff0000 | (uint)*puVar1;
}



uint * __cdecl std::internal::__std_FUN_00491760(uint *param_1,char param_2)
{
	uint uVar1;
	char cVar2;
	uint uVar3;
	uint uVar4;
	uint *puVar5;
	
	uVar1 = (uint)param_1 & 3;
	while (uVar1 != 0) {
		if (*(char *)param_1 == param_2) {
			return param_1;
		}
		if (*(char *)param_1 == '\0') {
			return (uint *)0x0;
		}
		uVar1 = (uint)(uint *)((int)param_1 + 1) & 3;
		param_1 = (uint *)((int)param_1 + 1);
	}
	while( true ) {
		while( true ) {
			uVar1 = *param_1;
			uVar4 = uVar1 ^ CONCAT22(CONCAT11(param_2,param_2),CONCAT11(param_2,param_2));
			uVar3 = uVar1 ^ 0xffffffff ^ uVar1 + 0x7efefeff;
			puVar5 = param_1 + 1;
			if (((uVar4 ^ 0xffffffff ^ uVar4 + 0x7efefeff) & 0x81010100) != 0) break;
			param_1 = puVar5;
			if ((uVar3 & 0x81010100) != 0) {
				if ((uVar3 & 0x1010100) != 0) {
					return (uint *)0x0;
				}
				if ((uVar1 + 0x7efefeff & 0x80000000) == 0) {
					return (uint *)0x0;
				}
			}
		}
		uVar1 = *param_1;
		if ((char)uVar1 == param_2) {
			return param_1;
		}
		if ((char)uVar1 == '\0') {
			return (uint *)0x0;
		}
		cVar2 = (char)(uVar1 >> 8);
		if (cVar2 == param_2) {
			return (uint *)((int)param_1 + 1);
		}
		if (cVar2 == '\0') break;
		cVar2 = (char)(uVar1 >> 0x10);
		if (cVar2 == param_2) {
			return (uint *)((int)param_1 + 2);
		}
		if (cVar2 == '\0') {
			return (uint *)0x0;
		}
		cVar2 = (char)(uVar1 >> 0x18);
		if (cVar2 == param_2) {
			return (uint *)((int)param_1 + 3);
		}
		param_1 = puVar5;
		if (cVar2 == '\0') {
			return (uint *)0x0;
		}
	}
	return (uint *)0x0;
}



BOOL std::internal::__entry__00491820(void)
{
	undefined **ppuVar1;
	
	DAT_0076eec4 = HeapCreate(1,0x1000,0);
	if (DAT_0076eec4 == (HANDLE)0x0) {
		return 0;
	}
	ppuVar1 = __std_FUN_00491860();
	if (ppuVar1 == (undefined **)0x0) {
		HeapDestroy(DAT_0076eec4);
		return 0;
	}
	return 1;
}



undefined ** std::internal::__std_FUN_00491860(void)
{
	bool bVar1;
	undefined4 *lpAddress;
	LPVOID pvVar2;
	int iVar3;
	undefined **ppuVar4;
	undefined **lpMem;
	undefined4 *puVar5;
	
	if (DAT_004b0fc8 == -1) {
		lpMem = &PTR_LOOP_004b0fb8;
	}
	else {
		lpMem = (undefined **)HeapAlloc(DAT_0076eec4,0,0x2020);
		if (lpMem == (undefined **)0x0) {
			return (undefined **)0x0;
		}
	}
	lpAddress = (undefined4 *)VirtualAlloc((LPVOID)0x0,0x400000,0x2000,4);
	if (lpAddress != (undefined4 *)0x0) {
		pvVar2 = VirtualAlloc(lpAddress,0x10000,0x1000,4);
		if (pvVar2 != (LPVOID)0x0) {
			if (lpMem == &PTR_LOOP_004b0fb8) {
				if (PTR_LOOP_004b0fb8 == (undefined **)0x0) {
					PTR_LOOP_004b0fb8 = &PTR_LOOP_004b0fb8;
				}
				if (PTR_LOOP_004b0fbc == (undefined **)0x0) {
					PTR_LOOP_004b0fbc = &PTR_LOOP_004b0fb8;
				}
			}
			else {
				*lpMem = (undefined *)&PTR_LOOP_004b0fb8;
				lpMem[1] = (undefined *)PTR_LOOP_004b0fbc;
				PTR_LOOP_004b0fbc = lpMem;
				*(undefined ***)lpMem[1] = lpMem;
			}
			lpMem[5] = (undefined *)(lpAddress + 0x100000);
			lpMem[4] = (undefined *)lpAddress;
			lpMem[2] = (undefined *)(lpMem + 6);
			lpMem[3] = (undefined *)(lpMem + 0x26);
			iVar3 = 0;
			ppuVar4 = lpMem + 6;
			do {
				bVar1 = 0xf < iVar3;
				iVar3 = iVar3 + 1;
				*ppuVar4 = (undefined *)((bVar1 - 1 & 0xf1) - 1);
				ppuVar4[1] = (undefined *)0xf1;
				ppuVar4 = ppuVar4 + 2;
			} while (iVar3 < 0x400);
			puVar5 = lpAddress;
			for (iVar3 = 0x4000; iVar3 != 0; iVar3 = iVar3 + -1) {
				*puVar5 = 0;
				puVar5 = puVar5 + 1;
			}
			if (lpAddress < lpMem[4] + 0x10000) {
				do {
					lpAddress[1] = 0xf0;
					*lpAddress = lpAddress + 2;
					*(undefined *)(lpAddress + 0x3e) = 0xff;
					lpAddress = lpAddress + 0x400;
				} while (lpAddress < lpMem[4] + 0x10000);
			}
			return lpMem;
		}
		VirtualFree(lpAddress,0,0x8000);
	}
	if (lpMem != &PTR_LOOP_004b0fb8) {
		HeapFree(DAT_0076eec4,0,lpMem);
	}
	return (undefined **)0x0;
}



void __cdecl std::internal::__free__realloc__004919d0(undefined **param_1)
{
	VirtualFree(param_1[4],0,0x8000);
	if ((undefined **)PTR_LOOP_004b2fd8 == param_1) {
		PTR_LOOP_004b2fd8 = param_1[1];
	}
	if (param_1 != &PTR_LOOP_004b0fb8) {
		*(undefined **)param_1[1] = *param_1;
		*(undefined **)(*param_1 + 4) = param_1[1];
		HeapFree(DAT_0076eec4,0,param_1);
		return;
	}
	DAT_004b0fc8 = 0xffffffff;
	return;
}



void __cdecl std::internal::__free__realloc__00491a30(int param_1)
{
	BOOL BVar1;
	undefined **ppuVar2;
	int iVar3;
	int iVar4;
	undefined **ppuVar5;
	undefined **ppuVar6;
	
	ppuVar6 = (undefined **)PTR_LOOP_004b0fbc;
	do {
		ppuVar5 = ppuVar6;
		if (ppuVar6[4] != (undefined *)0xffffffff) {
			iVar4 = 0;
			ppuVar5 = ppuVar6 + 0x804;
			iVar3 = 0x3ff000;
			do {
				if (*ppuVar5 == (undefined *)0xf0) {
					BVar1 = VirtualFree(ppuVar6[4] + iVar3,0x1000,0x4000);
					if (BVar1 != 0) {
						*ppuVar5 = (undefined *)0xffffffff;
						DAT_0054a150 = DAT_0054a150 + -1;
						if (((undefined **)ppuVar6[3] == (undefined **)0x0) || (ppuVar5 < ppuVar6[3])) {
							ppuVar6[3] = (undefined *)ppuVar5;
						}
						iVar4 = iVar4 + 1;
						param_1 = param_1 + -1;
						if (param_1 == 0) break;
					}
				}
				iVar3 = iVar3 + -0x1000;
				ppuVar5 = ppuVar5 + -2;
			} while (-1 < iVar3);
			ppuVar5 = (undefined **)ppuVar6[1];
			if ((iVar4 != 0) && (ppuVar6[6] == (undefined *)0xffffffff)) {
				iVar3 = 1;
				ppuVar2 = ppuVar6 + 8;
				do {
					if (*ppuVar2 != (undefined *)0xffffffff) break;
					iVar3 = iVar3 + 1;
					ppuVar2 = ppuVar2 + 2;
				} while (iVar3 < 0x400);
				if (iVar3 == 0x400) {
					__free__realloc__004919d0(ppuVar6);
				}
			}
		}
		if ((ppuVar5 == (undefined **)PTR_LOOP_004b0fbc) || (ppuVar6 = ppuVar5, param_1 < 1)) {
			return;
		}
	} while( true );
}



int __cdecl std::internal::__realloc_free__00491b00(undefined *param_1,int **param_2,uint *param_3)
{
	undefined **ppuVar1;
	uint uVar2;
	
	ppuVar1 = &PTR_LOOP_004b0fb8;
	while ((param_1 < ppuVar1[4] || param_1 == ppuVar1[4] || (ppuVar1[5] <= param_1))) {
		ppuVar1 = (undefined **)*ppuVar1;
		if (ppuVar1 == &PTR_LOOP_004b0fb8) {
			return 0;
		}
	}
	if (((uint)param_1 & 0xf) != 0) {
		return 0;
	}
	if (((uint)param_1 & 0xfff) < 0x100) {
		return 0;
	}
	*param_2 = (int *)ppuVar1;
	uVar2 = (uint)param_1 & 0xfffff000;
	*param_3 = uVar2;
	return ((int)(param_1 + (-0x100 - uVar2)) >> 4) + 8 + uVar2;
}



void __cdecl std::internal::__free_realloc__00491b60(int param_1,int param_2,byte *param_3)
{
	int *piVar1;
	int iVar2;
	
	iVar2 = param_2 - *(int *)(param_1 + 0x10) >> 0xc;
	piVar1 = (int *)(param_1 + 0x18 + iVar2 * 8);
	*piVar1 = *(int *)(param_1 + 0x18 + iVar2 * 8) + (uint)*param_3;
	*param_3 = 0;
	piVar1[1] = 0xf1;
	if ((*piVar1 == 0xf0) && (DAT_0054a150 = DAT_0054a150 + 1, DAT_0054a150 == 0x20)) {
		__free__realloc__00491a30(0x10);
	}
	return;
}



int * __cdecl std::internal::__malloc__00491bc0(int *param_1)
{
	undefined **ppuVar1;
	undefined **ppuVar2;
	undefined *puVar3;
	int *piVar4;
	int *piVar5;
	undefined **ppuVar6;
	undefined **ppuVar7;
	int **ppiVar8;
	int iVar9;
	int **ppiVar10;
	int **ppiVar11;
	bool bVar12;
	int *local_4;
	
	local_4 = (int *)PTR_LOOP_004b2fd8;
	do {
		if (local_4[4] != -1) {
			ppiVar10 = (int **)local_4[2];
			ppiVar8 = (int **)(((int)ppiVar10 + (-0x18 - (int)local_4) >> 3) * 0x1000 + local_4[4]);
			for (; ppiVar10 < local_4 + 0x806; ppiVar10 = ppiVar10 + 2) {
				if (((int)param_1 <= (int)*ppiVar10) && (param_1 <= ppiVar10[1] && ppiVar10[1] != param_1))
				{
					piVar4 = (int *)__std_FUN_00491e00(ppiVar8,*ppiVar10,param_1);
					if (piVar4 != (int *)0x0) {
						PTR_LOOP_004b2fd8 = (undefined *)local_4;
						*ppiVar10 = (int *)((int)*ppiVar10 - (int)param_1);
						local_4[2] = (int)ppiVar10;
						return piVar4;
					}
					ppiVar10[1] = param_1;
				}
				ppiVar8 = ppiVar8 + 0x400;
			}
			ppiVar8 = (int **)local_4[2];
			ppiVar11 = (int **)local_4[4];
			for (ppiVar10 = (int **)(local_4 + 6); ppiVar10 < ppiVar8; ppiVar10 = ppiVar10 + 2) {
				if (((int)param_1 <= (int)*ppiVar10) && (param_1 <= ppiVar10[1] && ppiVar10[1] != param_1))
				{
					piVar4 = (int *)__std_FUN_00491e00(ppiVar11,*ppiVar10,param_1);
					if (piVar4 != (int *)0x0) {
						PTR_LOOP_004b2fd8 = (undefined *)local_4;
						*ppiVar10 = (int *)((int)*ppiVar10 - (int)param_1);
						local_4[2] = (int)ppiVar10;
						return piVar4;
					}
					ppiVar10[1] = param_1;
				}
				ppiVar11 = ppiVar11 + 0x400;
			}
		}
		local_4 = (int *)*local_4;
	} while (local_4 != (int *)PTR_LOOP_004b2fd8);
	ppuVar7 = &PTR_LOOP_004b0fb8;
	while ((ppuVar7[4] == (undefined *)0xffffffff || (ppuVar7[3] == (undefined *)0x0))) {
		ppuVar7 = (undefined **)*ppuVar7;
		if (ppuVar7 == &PTR_LOOP_004b0fb8) {
			ppuVar7 = __std_FUN_00491860();
			if (ppuVar7 == (undefined **)0x0) {
				return (int *)0x0;
			}
			piVar4 = (int *)ppuVar7[4];
			*(char *)(piVar4 + 2) = (char)param_1;
			PTR_LOOP_004b2fd8 = (undefined *)ppuVar7;
			*piVar4 = (int)((int)piVar4 + 8) + (int)param_1;
			piVar4[1] = 0xf0 - (int)param_1;
			ppuVar7[6] = ppuVar7[6] + -((uint)param_1 & 0xff);
			return piVar4 + 0x40;
		}
	}
	ppuVar2 = (undefined **)ppuVar7[3];
	puVar3 = *ppuVar2;
	piVar4 = (int *)(ppuVar7[4] + ((int)ppuVar2 + (-0x18 - (int)ppuVar7) >> 3) * 0x1000);
	ppuVar6 = ppuVar2;
	for (iVar9 = 0; (puVar3 == (undefined *)0xffffffff && (iVar9 < 0x10)); iVar9 = iVar9 + 1) {
		puVar3 = ppuVar6[2];
		ppuVar6 = ppuVar6 + 2;
	}
	piVar5 = (int *)VirtualAlloc(piVar4,iVar9 << 0xc,0x1000,4);
	if (piVar5 != piVar4) {
		return (int *)0x0;
	}
	ppuVar6 = ppuVar2;
	if (0 < iVar9) {
		piVar5 = piVar4 + 1;
		do {
			*piVar5 = 0xf0;
			piVar5[-1] = (int)(piVar5 + 1);
			*(undefined *)(piVar5 + 0x3d) = 0xff;
			*ppuVar6 = (undefined *)0xf0;
			ppuVar6[1] = (undefined *)0xf1;
			piVar5 = piVar5 + 0x400;
			ppuVar6 = ppuVar6 + 2;
			iVar9 = iVar9 + -1;
		} while (iVar9 != 0);
	}
	ppuVar1 = ppuVar7 + 0x806;
	bVar12 = ppuVar6 < ppuVar1;
	if (bVar12) {
		do {
			if (*ppuVar6 == (undefined *)0xffffffff) break;
			ppuVar6 = ppuVar6 + 2;
		} while (ppuVar6 < ppuVar1);
		bVar12 = ppuVar6 < ppuVar1;
	}
	PTR_LOOP_004b2fd8 = (undefined *)ppuVar7;
	ppuVar7[3] = (undefined *)(-(uint)bVar12 & (uint)ppuVar6);
	*(char *)(piVar4 + 2) = (char)param_1;
	ppuVar7[2] = (undefined *)ppuVar2;
	*ppuVar2 = *ppuVar2 + -(int)param_1;
	piVar4[1] = piVar4[1] - (int)param_1;
	*piVar4 = (int)((int)piVar4 + 8) + (int)param_1;
	return piVar4 + 0x40;
}



int __cdecl std::internal::__std_FUN_00491e00(int **param_1,int *param_2,int *param_3)
{
	byte bVar1;
	int **ppiVar2;
	int **ppiVar3;
	int **ppiVar4;
	int *piVar5;
	int **ppiVar6;
	
	ppiVar2 = (int **)*param_1;
	if (param_3 <= param_1[1]) {
		*(byte *)ppiVar2 = (byte)param_3;
		if ((int **)((int)ppiVar2 + (int)param_3) < param_1 + 0x3e) {
			*param_1 = (int *)((int)*param_1 + (int)param_3);
			param_1[1] = (int *)((int)param_1[1] - (int)param_3);
		}
		else {
			param_1[1] = (int *)0x0;
			*param_1 = (int *)(param_1 + 2);
		}
		return (int)(ppiVar2 + 2) * 0x10 + (int)param_1 * -0xf;
	}
	ppiVar3 = (int **)((int)param_1[1] + (int)ppiVar2);
	ppiVar6 = ppiVar2;
	if (*(byte *)ppiVar3 != 0) {
		ppiVar6 = ppiVar3;
	}
	if ((int **)((int)ppiVar6 + (int)param_3) < param_1 + 0x3e) {
		do {
			if (*(byte *)ppiVar6 == 0) {
				ppiVar3 = (int **)((int)ppiVar6 + 1);
				piVar5 = (int *)0x1;
				bVar1 = *(byte *)((int)ppiVar6 + 1);
				while (bVar1 == 0) {
					ppiVar3 = (int **)((int)ppiVar3 + 1);
					piVar5 = (int *)((int)piVar5 + 1);
					bVar1 = *(byte *)ppiVar3;
				}
				if (param_3 <= piVar5) {
					if (param_1 + 0x3e <= (int **)((int)ppiVar6 + (int)param_3)) {
						*param_1 = (int *)(param_1 + 2);
						goto LAB_00491f4f;
					}
					*param_1 = (int *)(int **)((int)ppiVar6 + (int)param_3);
					param_1[1] = (int *)((int)piVar5 - (int)param_3);
					goto LAB_00491f56;
				}
				if (ppiVar6 == ppiVar2) {
					param_1[1] = piVar5;
				}
				else {
					param_2 = (int *)((int)param_2 - (int)piVar5);
					if (param_2 < param_3) {
						return 0;
					}
				}
			}
			else {
				ppiVar3 = (int **)((int)ppiVar6 + (uint)*(byte *)ppiVar6);
			}
			ppiVar6 = ppiVar3;
		} while ((int **)((int)ppiVar3 + (int)param_3) < param_1 + 0x3e);
	}
	ppiVar3 = param_1 + 2;
	ppiVar6 = ppiVar3;
	if (ppiVar3 < ppiVar2) {
		while ((int **)((int)ppiVar6 + (int)param_3) < param_1 + 0x3e) {
			if (*(byte *)ppiVar6 == 0) {
				ppiVar4 = (int **)((int)ppiVar6 + 1);
				piVar5 = (int *)0x1;
				bVar1 = *(byte *)((int)ppiVar6 + 1);
				while (bVar1 == 0) {
					ppiVar4 = (int **)((int)ppiVar4 + 1);
					piVar5 = (int *)((int)piVar5 + 1);
					bVar1 = *(byte *)ppiVar4;
				}
				if (param_3 <= piVar5) {
					if ((int **)((int)ppiVar6 + (int)param_3) < param_1 + 0x3e) {
						*param_1 = (int *)(int **)((int)ppiVar6 + (int)param_3);
						param_1[1] = (int *)((int)piVar5 - (int)param_3);
					}
					else {
						*param_1 = (int *)ppiVar3;
LAB_00491f4f:
						param_1[1] = (int *)0x0;
					}
LAB_00491f56:
					*(byte *)ppiVar6 = (byte)param_3;
					return (int)(ppiVar6 + 2) * 0x10 + (int)param_1 * -0xf;
				}
				param_2 = (int *)((int)param_2 - (int)piVar5);
				if (param_2 < param_3) {
					return 0;
				}
			}
			else {
				ppiVar4 = (int **)((int)ppiVar6 + (uint)*(byte *)ppiVar6);
			}
			ppiVar6 = ppiVar4;
			if (ppiVar2 <= ppiVar4) {
				return 0;
			}
		}
	}
	return 0;
}



undefined4 __cdecl
std::internal::__realloc__00491f80(int param_1,int **param_2,int **param_3,uint param_4)
{
	int **ppiVar1;
	int iVar2;
	int *piVar3;
	char cVar4;
	undefined4 uVar5;
	int *piVar6;
	uint uVar7;
	int **ppiVar8;
	
	uVar5 = 0;
	piVar3 = (int *)(param_1 + 0x18 + ((int)((int)param_2 - *(int *)(param_1 + 0x10)) >> 0xc) * 8);
	uVar7 = (uint)*(byte *)param_3;
	if (uVar7 <= param_4) {
		if ((uVar7 < param_4) && (ppiVar1 = (int **)(param_4 + (int)param_3), ppiVar1 <= param_2 + 0x3e)
			 ) {
			for (ppiVar8 = (int **)(uVar7 + (int)param_3);
					(ppiVar8 < ppiVar1 && (*(char *)ppiVar8 == '\0')); ppiVar8 = (int **)((int)ppiVar8 + 1)) {
			}
			if (ppiVar8 == ppiVar1) {
				*(char *)param_3 = (char)param_4;
				if ((param_3 <= *param_2) && (*param_2 < ppiVar1)) {
					if (ppiVar1 < param_2 + 0x3e) {
						*param_2 = (int *)ppiVar1;
						piVar6 = (int *)0x0;
						cVar4 = *(char *)ppiVar1;
						while (cVar4 == '\0') {
							iVar2 = (int)piVar6 + 1;
							piVar6 = (int *)((int)piVar6 + 1);
							cVar4 = *(char *)(iVar2 + (int)ppiVar1);
						}
						param_2[1] = piVar6;
					}
					else {
						param_2[1] = (int *)0x0;
						*param_2 = (int *)(param_2 + 2);
					}
				}
				*piVar3 = *piVar3 + (uVar7 - param_4);
				uVar5 = 1;
			}
		}
		return uVar5;
	}
	*(char *)param_3 = (char)param_4;
	piVar3[1] = 0xf1;
	*piVar3 = *piVar3 + (uVar7 - param_4);
	return 1;
}



BOOL __cdecl std::internal::__call_new_handler(size_t length)
{
	int iVar1;
	
	if (globals::__g_new_handler != (_PNH)0x0) {
		iVar1 = (*globals::__g_new_handler)(length);
		if (iVar1 != 0) {
			return 1;
		}
	}
	return 0;
}



// Library Function - Single Match
// Name: __trandisp1
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __fastcall __trandisp1(undefined4 param_1,int param_2)
{
	float10 fVar1;
	byte bVar2;
	undefined2 uVar3;
	int unaff_EBP;
	float10 in_ST0;
	
	if (*(char *)(param_2 + 0xe) == '\x05') {
		uVar3 = (undefined2)
						CONCAT31((uint3)((byte)((uint)*(ushort *)(unaff_EBP + -0xa4) >> 8) & 0xfe | 2),0x3f);
	}
	else {
		uVar3 = 0x133f;
	}
	*(undefined2 *)(unaff_EBP + -0xa2) = uVar3;
	fVar1 = (float10)0;
	*(int *)(unaff_EBP + -0x94) = param_2;
	*(ushort *)(unaff_EBP + -0xa0) =
			 (ushort)(in_ST0 < fVar1) << 9 | (ushort)(in_ST0 != fVar1) << 10 |
			 (ushort)(in_ST0 == fVar1) << 0xe;
	*(undefined *)(unaff_EBP + -0x90) = 0;
	bVar2 = (char)(*(char *)(unaff_EBP + -0x9f) << 1) >> 1;
										// WARNING: Could not recover jumptable at 0x004920d5. Too many branches
										// WARNING: Treating indirect jump as call
	(**(code **)(param_2 + (char)(&DAT_004b2ffd)[(byte)((bVar2 & 7) << 1 | (char)bVar2 < '\0')] + 0x10
							))();
	return;
}



// Library Function - Single Match
// Name: __trandisp2
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __fastcall __trandisp2(undefined4 param_1,int param_2)
{
	float10 fVar1;
	char cVar2;
	byte bVar3;
	undefined2 uVar4;
	int unaff_EBP;
	float10 in_ST0;
	float10 in_ST1;
	
	if (*(char *)(param_2 + 0xe) == '\x05') {
		uVar4 = (undefined2)
						CONCAT31((uint3)((byte)((uint)*(ushort *)(unaff_EBP + -0xa4) >> 8) & 0xfe | 2),0x3f);
	}
	else {
		uVar4 = 0x133f;
	}
	*(undefined2 *)(unaff_EBP + -0xa2) = uVar4;
	fVar1 = (float10)0;
	*(int *)(unaff_EBP + -0x94) = param_2;
	*(ushort *)(unaff_EBP + -0xa0) =
			 (ushort)(in_ST0 < fVar1) << 9 | (ushort)(in_ST0 != fVar1) << 10 |
			 (ushort)(in_ST0 == fVar1) << 0xe;
	*(undefined *)(unaff_EBP + -0x90) = 0;
	fVar1 = (float10)0;
	*(ushort *)(unaff_EBP + -0xa0) =
			 (ushort)(in_ST1 < fVar1) << 9 | (ushort)(in_ST1 != fVar1) << 10 |
			 (ushort)(in_ST1 == fVar1) << 0xe;
	bVar3 = (char)(*(char *)(unaff_EBP + -0x9f) << 1) >> 1;
	cVar2 = (char)(*(char *)(unaff_EBP + -0x9f) << 1) >> 1;
										// WARNING: Could not recover jumptable at 0x00492161. Too many branches
										// WARNING: Treating indirect jump as call
	(**(code **)(param_2 + (char)((&DAT_004b2ffd)[(byte)(cVar2 << 1 | cVar2 < '\0') & 0xf] |
															 (&DAT_004b2ffd)[(byte)((bVar3 & 7) << 1 | (char)bVar3 < '\0')] << 2)
							+ 0x10))();
	return;
}



float10 __fastcall
std::internal::__std_FUN_00492240
					(undefined4 param_1_00,uint param_2_00,ushort param_1,undefined4 param_2,
					undefined4 param_3,undefined4 param_4,undefined4 param_5,undefined4 param_6)
{
	float10 in_ST0;
	int local_24 [2];
	undefined4 uStack28;
	undefined4 uStack24;
	undefined4 local_14;
	undefined4 local_10;
	double dStack12;
	
	local_14 = param_5;
	local_10 = param_6;
	dStack12 = (double)in_ST0;
	uStack28 = param_3;
	uStack24 = param_4;
	__std_FUN_00498fa0(param_2_00,local_24,&param_1);
	return (float10)dStack12;
}



// Library Function - Single Match
// Name: __startOneArgErrorHandling
// Library: Visual Studio

float10 __fastcall
__startOneArgErrorHandling
					(undefined4 param_1_00,uint param_2_00,ushort param_1,undefined4 param_2,
					undefined4 param_3,undefined4 param_4)
{
	float10 in_ST0;
	int local_24 [2];
	undefined4 local_1c;
	undefined4 local_18;
	double local_c;
	
	local_c = (double)in_ST0;
	local_1c = param_3;
	local_18 = param_4;
	std::internal::__std_FUN_00498fa0(param_2_00,local_24,&param_1);
	return (float10)local_c;
}



void std::internal::__std_FUN_004922b5(undefined4 param_1)
{
	return;
}



undefined4 std::internal::__std_FUN_004922cc(uint param_1)
{
	if ((param_1 & 0x80000) != 0) {
		return 7;
	}
	return 1;
}



// Library Function - Single Match
// Name: __fload_withFB
// Library: Visual Studio

uint __fastcall __fload_withFB(undefined4 param_1,int param_2)
{
	uint uVar1;
	
	uVar1 = *(uint *)(param_2 + 4) & 0x7ff00000;
	if (uVar1 != 0x7ff00000) {
		return uVar1;
	}
	return *(uint *)(param_2 + 4);
}



uint __cdecl std::internal::__std_FUN_00492328(double param_1)
{
	if ((param_1._4_4_ & 0x7ff00000) != 0x7ff00000) {
		return param_1._4_4_ & 0x7ff00000;
	}
	return param_1._4_4_;
}



// Library Function - Single Match
// Name: __cintrindisp2
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __cintrindisp2(void)
{
	__trandisp2();
	DAT_0054a168 = 1;
	std::internal::__cintrindisp_internal();
	return;
}



// Library Function - Single Match
// Name: __cintrindisp1
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __cintrindisp1(void)
{
	__trandisp1();
	DAT_0054a168 = 1;
	std::internal::__cintrindisp_internal();
	return;
}



// Library Function - Single Match
// Name: __ctrandisp2
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __cdecl __ctrandisp2(uint param_1,int param_2,uint param_3,int param_4)
{
	__fload(param_1,param_2);
	__fload(param_3,param_4);
	__trandisp2();
	std::internal::__std_FUN_004924de();
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void std::internal::__std_FUN_004924de(void)
{
	char cVar1;
	int unaff_EBP;
	float10 in_ST0;
	ushort in_FPUStatusWord;
	
	DAT_0054a168 = '\0';
	if (_DAT_0054a0c8 != 0) {
		DAT_0054a168 = 0;
		return;
	}
										// WARNING: Read-only address (ram,0x0054a160) is written
	DOUBLE_0054a160 = (double)in_ST0;
	cVar1 = *(char *)(unaff_EBP + -0x90);
	if (cVar1 != '\0') {
		if ((cVar1 != -1) && (cVar1 != -2)) {
			if (cVar1 == '\0') {
				DAT_0054a168 = 0;
				return;
			}
			*(int *)(unaff_EBP + -0x8e) = (int)cVar1;
			goto LAB_004925b3;
		}
		if (((ulonglong)DOUBLE_0054a160 & 0x7ff0000000000000) == 0) {
			*(undefined4 *)(unaff_EBP + -0x8e) = 4;
			in_ST0 = (float10)fscale(in_ST0,(float10)1536.0);
			if (ABS(in_ST0) < (float10)2.225073858507201e-308) {
				in_ST0 = in_ST0 * (float10)0.0;
			}
			goto LAB_004925b3;
		}
		if ((DOUBLE_0054a160._6_2_ & 0x7ff0) == 0x7ff0) {
			*(undefined4 *)(unaff_EBP + -0x8e) = 3;
			in_ST0 = (float10)fscale(in_ST0,(float10)-1536.0);
			if ((float10)1.797693134862316e+308 < ABS(in_ST0)) {
				in_ST0 = in_ST0 * (float10)INFINITY;
			}
			goto LAB_004925b3;
		}
	}
	if ((*(ushort *)(unaff_EBP + -0xa4) & 0x20) != 0) {
		DAT_0054a168 = 0;
		return;
	}
	if ((in_FPUStatusWord & 0x20) == 0) {
		DAT_0054a168 = 0;
		return;
	}
	*(undefined4 *)(unaff_EBP + -0x8e) = 8;
LAB_004925b3:
	*(int *)(unaff_EBP + -0x8a) = *(int *)(unaff_EBP + -0x94) + 1;
	if (DAT_0054a168 == '\0') {
		*(undefined4 *)(unaff_EBP + -0x86) = *(undefined4 *)(unaff_EBP + 8);
		*(undefined4 *)(unaff_EBP + -0x82) = *(undefined4 *)(unaff_EBP + 0xc);
		if (*(char *)(*(int *)(unaff_EBP + -0x94) + 0xd) != '\x01') {
			*(undefined4 *)(unaff_EBP + -0x7e) = *(undefined4 *)(unaff_EBP + 0x10);
			*(undefined4 *)(unaff_EBP + -0x7a) = *(undefined4 *)(unaff_EBP + 0x14);
		}
	}
	*(double *)(unaff_EBP + -0x76) = (double)in_ST0;
	__std_FUN_00498fa0((int)*(char *)(*(int *)(unaff_EBP + -0x94) + 0xe),(int *)(unaff_EBP + -0x8e),
										 (ushort *)(unaff_EBP + -0xa4));
										// WARNING: Read-only address (ram,0x0054a160) is written
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void std::internal::__cintrindisp_internal(void)
{
	char cVar1;
	int unaff_EBP;
	float10 in_ST0;
	ushort in_FPUStatusWord;
	
	if (_DAT_0054a0c8 != 0) {
		return;
	}
										// WARNING: Read-only address (ram,0x0054a160) is written
	DOUBLE_0054a160 = (double)in_ST0;
	cVar1 = *(char *)(unaff_EBP + -0x90);
	if (cVar1 != '\0') {
		if ((cVar1 != -1) && (cVar1 != -2)) {
			if (cVar1 == '\0') {
				return;
			}
			*(int *)(unaff_EBP + -0x8e) = (int)cVar1;
			goto LAB_004925b3;
		}
		if (((ulonglong)DOUBLE_0054a160 & 0x7ff0000000000000) == 0) {
			*(undefined4 *)(unaff_EBP + -0x8e) = 4;
			in_ST0 = (float10)fscale(in_ST0,(float10)1536.0);
			if (ABS(in_ST0) < (float10)2.225073858507201e-308) {
				in_ST0 = in_ST0 * (float10)0.0;
			}
			goto LAB_004925b3;
		}
		if ((DOUBLE_0054a160._6_2_ & 0x7ff0) == 0x7ff0) {
			*(undefined4 *)(unaff_EBP + -0x8e) = 3;
			in_ST0 = (float10)fscale(in_ST0,(float10)-1536.0);
			if ((float10)1.797693134862316e+308 < ABS(in_ST0)) {
				in_ST0 = in_ST0 * (float10)INFINITY;
			}
			goto LAB_004925b3;
		}
	}
	if ((*(ushort *)(unaff_EBP + -0xa4) & 0x20) != 0) {
		return;
	}
	if ((in_FPUStatusWord & 0x20) == 0) {
		return;
	}
	*(undefined4 *)(unaff_EBP + -0x8e) = 8;
LAB_004925b3:
	*(int *)(unaff_EBP + -0x8a) = *(int *)(unaff_EBP + -0x94) + 1;
	if (DAT_0054a168 == '\0') {
		*(undefined4 *)(unaff_EBP + -0x86) = *(undefined4 *)(unaff_EBP + 8);
		*(undefined4 *)(unaff_EBP + -0x82) = *(undefined4 *)(unaff_EBP + 0xc);
		if (*(char *)(*(int *)(unaff_EBP + -0x94) + 0xd) != '\x01') {
			*(undefined4 *)(unaff_EBP + -0x7e) = *(undefined4 *)(unaff_EBP + 0x10);
			*(undefined4 *)(unaff_EBP + -0x7a) = *(undefined4 *)(unaff_EBP + 0x14);
		}
	}
	*(double *)(unaff_EBP + -0x76) = (double)in_ST0;
	__std_FUN_00498fa0((int)*(char *)(*(int *)(unaff_EBP + -0x94) + 0xe),(int *)(unaff_EBP + -0x8e),
										 (ushort *)(unaff_EBP + -0xa4));
										// WARNING: Read-only address (ram,0x0054a160) is written
	return;
}



// Library Function - Single Match
// Name: __ctrandisp1
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __cdecl __ctrandisp1(uint param_1,int param_2)
{
	__fload(param_1,param_2);
	__trandisp1();
	std::internal::__std_FUN_004924de();
	return;
}



// Library Function - Single Match
// Name: __fload
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

float10 __cdecl __fload(uint param_1,int param_2)
{
	float10 fVar1;
	
	if ((param_2._2_2_ & 0x7ff0) == 0x7ff0) {
		fVar1 = (float10)(CONCAT28(param_2._2_2_,CONCAT44(param_2 << 0xb | param_1 >> 0x15,param_1)) |
										 0x7fff);
	}
	else {
		fVar1 = (float10)(double)CONCAT26(param_2._2_2_,CONCAT24((undefined2)param_2,param_1));
	}
	return fVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 std::internal::__std_FUN_00492e86(undefined4 param_1,uint param_2,ushort param_3)
{
	undefined4 in_EAX;
	int iVar1;
	float10 fVar2;
	float10 fVar3;
	undefined4 in_stack_0000001c;
	undefined2 uStack00000020;
	uint in_stack_00000020;
	undefined2 uStack00000022;
	ushort in_stack_00000024;
	
	if ((((((CONCAT22(param_3,param_2._2_2_) ^ 0x700) & 0x700) == 0) &&
			 ((&DAT_004b302c)[(param_2._2_2_ & 0x7800) >> 0xb] != '\0')) && ((param_3 & 0x7fff) != 0x7fff)
			) && ((((in_stack_00000024 & 0x7fff) != 0 && ((in_stack_00000024 & 0x7fff) != 0x7fff)) &&
						(((in_stack_00000020 & 0x7fffffff) == 0 && ((param_2 & 0x7fffffff) == 0)))))) {
		if ((ushort)((param_3 & 0x7fff) + 0x3f) < (in_stack_00000024 & 0x7fff)) {
			iVar1 = ((in_stack_00000024 & 0x7fff) - (param_3 & 0x7fff) & 0x3f | 0x20) + 1;
			fVar3 = ABS((float10)CONCAT28(in_stack_00000024 & 0x7fff | param_3 & 0x8000,
																		CONCAT26(param_2._2_2_,CONCAT24((undefined2)param_2,param_1))));
			fVar2 = ABS((float10)CONCAT28(in_stack_00000024,
																		CONCAT26(uStack00000022,
																						 CONCAT24(uStack00000020,in_stack_0000001c))));
			do {
				if (fVar3 <= fVar2) {
					fVar2 = fVar2 - fVar3;
				}
				fVar3 = fVar3 * (float10)_DAT_004b305c;
				iVar1 = iVar1 + -1;
			} while (iVar1 != 0);
		}
		else {
			while (-1 < (int)((in_stack_00000024 & 0x7fff) - ((param_3 & 0x7fff) + 10))) {
				fVar2 = (float10)CONCAT28(in_stack_00000024,
																	CONCAT26(uStack00000022,CONCAT24(uStack00000020,in_stack_0000001c)
																					));
				fVar3 = (float10)CONCAT28((in_stack_00000024 & 0x7fff) -
																	((in_stack_00000024 & 0x7fff) - param_3 & 7 | 4) |
																	param_3 & 0x8000,
																	CONCAT26(param_2._2_2_,CONCAT24((undefined2)param_2,param_1)));
				fVar2 = fVar2 - (fVar2 / fVar3) * fVar3;
				in_stack_0000001c = SUB104(fVar2,0);
				uStack00000020 = (undefined2)((unkuint10)fVar2 >> 0x20);
				uStack00000022 = (undefined2)((unkuint10)fVar2 >> 0x30);
				in_stack_00000024 = (ushort)((unkuint10)fVar2 >> 0x40);
			}
		}
	}
	return in_EAX;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

float10 std::internal::__std_FUN_0049308c(void)
{
	float10 in_ST0;
	float10 fVar1;
	float10 in_ST1;
	
	if (((unkuint10)in_ST1 & 0) != 0) {
		fVar1 = (float10)__std_FUN_00492e86();
		return fVar1;
	}
	if ((SUB104(in_ST1,0) | (uint)((unkuint10)in_ST1 >> 0x20)) != 0) {
		fVar1 = (float10)__std_FUN_00492e86(in_ST1 * (float10)_DAT_004b3044);
		return fVar1;
	}
	return in_ST0 - (in_ST0 / in_ST1) * in_ST1;
}



float10 __cdecl std::internal::__std_unk_round_internal__00493410(double param_1)
{
	return (float10)ROUND(param_1);
}



float10 __cdecl std::internal::__std_unk_math__00493430(int param_1,double param_2,uint new)
{
	float10 fVar1;
	
	if (DAT_004b38e0 == 0) {
		fVar1 = __std_unk_math__00493bb0(1,param_1,param_2,0,0,param_2,new);
		return fVar1;
	}
	std::globals::g_msvc_errno = EDOM;
	_control87(new,0xffff);
	return (float10)param_2;
}



float10 __cdecl
std::internal::__std_FUN_00493480
					(uint param_1,uint param_2,double param_3,double param_4,uint param_5)
{
	uint uVar1;
	int iVar2;
	float10 fVar3;
	uint local_58 [14];
	uint local_20;
	
	uVar1 = __std_FUN_00493880(param_1,&param_4,param_5);
	if (uVar1 == 0) {
		local_20 = local_20 & 0xfffffffe;
		__std_FUN_00493540(local_58,&param_5,(byte)param_1,param_2,(uint *)&param_3,(uint *)&param_4);
	}
	iVar2 = __std_FUN_00493cc0(param_1);
	if ((DAT_004b38e0 == 0) && (iVar2 != 0)) {
		fVar3 = __std_unk_math__00493bb0(iVar2,param_2,param_3,0,0,param_4,param_5);
		return fVar3;
	}
	__std_FUN_00493c60(iVar2);
	_control87(param_5,0xffff);
	return (float10)param_4;
}



void __cdecl
std::internal::__std_FUN_00493540
					(uint *param_1,uint *param_2,byte param_3,uint param_4,uint *param_5,uint *param_6)
{
	uint *puVar1;
	uint *puVar2;
	uint uVar3;
	uint *dwExceptionCode;
	
	puVar1 = param_2;
	param_1[1] = 0;
	param_1[2] = 0;
	param_1[3] = 0;
	dwExceptionCode = param_1;
	if ((param_3 & 0x10) != 0) {
		param_1[1] = param_1[1] | 1;
		dwExceptionCode = (uint *)0xc000008f;
	}
	if ((param_3 & 2) != 0) {
		dwExceptionCode = (uint *)0xc0000093;
		param_1[1] = param_1[1] | 2;
	}
	if ((param_3 & 1) != 0) {
		dwExceptionCode = (uint *)0xc0000091;
		param_1[1] = param_1[1] | 4;
	}
	if ((param_3 & 4) != 0) {
		dwExceptionCode = (uint *)0xc000008e;
		param_1[1] = param_1[1] | 8;
	}
	if ((param_3 & 8) != 0) {
		dwExceptionCode = (uint *)0xc0000090;
		param_1[1] = param_1[1] | 0x10;
	}
	param_1[2] = (~*param_2 & 1) << 4 | param_1[2] & 0xffffffef;
	param_1[2] = (~*param_2 & 4) << 1 | param_1[2] & 0xfffffff7;
	param_1[2] = ~*param_2 >> 1 & 4 | param_1[2] & 0xfffffffb;
	param_1[2] = ~*param_2 >> 3 & 2 | param_1[2] & 0xfffffffd;
	param_1[2] = ~*param_2 >> 5 & 1 | param_1[2] & 0xfffffffe;
	uVar3 = _status87();
	puVar2 = param_6;
	if ((uVar3 & 1) != 0) {
		param_1[3] = param_1[3] | 0x10;
	}
	if ((uVar3 & 4) != 0) {
		param_1[3] = param_1[3] | 8;
	}
	if ((uVar3 & 8) != 0) {
		param_1[3] = param_1[3] | 4;
	}
	if ((uVar3 & 0x10) != 0) {
		param_1[3] = param_1[3] | 2;
	}
	if ((uVar3 & 0x20) != 0) {
		param_1[3] = param_1[3] | 1;
	}
	uVar3 = *puVar1 & 0xc00;
	if (uVar3 < 0x401) {
		if (uVar3 == 0x400) {
			*param_1 = *param_1 & 0xfffffffd | 1;
		}
		else {
			if (uVar3 == 0) {
				*param_1 = *param_1 & 0xfffffffc;
			}
		}
	}
	else {
		if (uVar3 == 0x800) {
			*param_1 = *param_1 & 0xfffffffe | 2;
		}
		else {
			if (uVar3 == 0xc00) {
				*param_1 = *param_1 | 3;
			}
		}
	}
	uVar3 = *puVar1 & 0x300;
	if (uVar3 == 0) {
		*param_1 = *param_1 & 0xffffffeb | 8;
	}
	else {
		if (uVar3 == 0x200) {
			*param_1 = *param_1 & 0xffffffe7 | 4;
		}
		else {
			if (uVar3 == 0x300) {
				*param_1 = *param_1 & 0xffffffe3;
			}
		}
	}
	*param_1 = *param_1 & 0xfffe001f | (param_4 & 0xfff) << 5;
	param_1[8] = param_1[8] | 1;
	param_1[8] = param_1[8] & 0xffffffe3 | 2;
	param_1[4] = *param_5;
	param_1[5] = param_5[1];
	param_1[0x14] = param_1[0x14] | 1;
	param_1[0x14] = param_1[0x14] & 0xffffffe3 | 2;
	param_1[0x10] = *param_6;
	param_1[0x11] = param_6[1];
	_clear87();
	RaiseException((DWORD)dwExceptionCode,0,1,(ULONG_PTR *)&param_1);
	if ((*(byte *)(param_1 + 2) & 0x10) != 0) {
		*puVar1 = *puVar1 & 0xfffffffe;
	}
	if ((*(byte *)(param_1 + 2) & 8) != 0) {
		*puVar1 = *puVar1 & 0xfffffffb;
	}
	if ((*(byte *)(param_1 + 2) & 4) != 0) {
		*puVar1 = *puVar1 & 0xfffffff7;
	}
	if ((*(byte *)(param_1 + 2) & 2) != 0) {
		*puVar1 = *puVar1 & 0xffffffef;
	}
	if ((*(byte *)(param_1 + 2) & 1) != 0) {
		*puVar1 = *puVar1 & 0xffffffdf;
	}
	switch(*param_1 & 3) {
	case 0:
		uVar3 = *puVar1 & 0xfffff3ff;
		break;
	case 1:
		*puVar1 = *puVar1 & 0xfffff7ff | 0x400;
		goto switchD_004937db_caseD_4;
	case 2:
		uVar3 = *puVar1 & 0xfffffbff | 0x800;
		break;
	case 3:
		uVar3 = *puVar1 | 0xc00;
		break;
	default:
		goto switchD_004937db_caseD_4;
	}
	*puVar1 = uVar3;
switchD_004937db_caseD_4:
	uVar3 = *param_1 >> 2 & 7;
	if (uVar3 == 0) {
		*puVar1 = *puVar1 & 0xfffff3ff | 0x300;
	}
	else {
		if (uVar3 == 1) {
			*puVar1 = *puVar1 & 0xfffff3ff | 0x200;
			*puVar2 = param_1[0x10];
			puVar2[1] = param_1[0x11];
			return;
		}
		if (uVar3 == 2) {
			*puVar1 = *puVar1 & 0xfffff3ff;
			*puVar2 = param_1[0x10];
			puVar2[1] = param_1[0x11];
			return;
		}
	}
	*puVar2 = param_1[0x10];
	puVar2[1] = param_1[0x11];
	return;
}



// WARNING: Could not reconcile some variable overlaps

uint __cdecl std::internal::__std_FUN_00493880(uint param_1,double *param_2,uint param_3)
{
	undefined4 uVar1;
	undefined4 uVar2;
	double dVar3;
	uint uVar4;
	bool bVar5;
	float10 fVar6;
	int local_14;
	undefined8 local_10;
	
	uVar4 = param_1 & 0x1f;
	if (((param_1 & 8) == 0) || ((param_3 & 1) == 0)) {
		if (((param_1 & 4) == 0) || ((param_3 & 4) == 0)) {
			if (((param_1 & 1) == 0) || ((param_3 & 8) == 0)) {
				if (((param_1 & 2) != 0) && ((param_3 & 0x10) != 0)) {
					bVar5 = (param_1 & 0x10) != 0;
					local_10 = *param_2;
					if (local_10 == 0.0) {
						bVar5 = true;
					}
					else {
						fVar6 = __std_FUN_00493da0(*param_2,&local_14);
						local_14 = local_14 + -0x600;
						if (local_14 < -0x432) {
							bVar5 = true;
							*(undefined4 *)param_2 = 0;
							local_10 = 0.0;
							*(undefined4 *)((int)param_2 + 4) = 0;
						}
						else {
							local_10 = (double)(ulonglong)
																 (SUB87((double)fVar6,0) & 0xfffffffffffff | 0x10000000000000);
							if (local_14 < -0x3fd) {
								local_14 = -0x3fd - local_14;
								do {
									dVar3 = local_10;
									if ((((ulonglong)local_10 & 1) != 0) && (!bVar5)) {
										bVar5 = true;
									}
									local_10 = (double)((ulonglong)local_10 & 0xffffffff00000000 |
																		 (ulonglong)local_10 >> 1 & 0x7fffffff);
									if (((ulonglong)dVar3 & 0x100000000) != 0) {
										local_10 = (double)((ulonglong)local_10 | 0x80000000);
									}
									local_14 = local_14 + -1;
									local_10 = (double)((ulonglong)local_10 & 0xffffffff |
																		 ((ulonglong)local_10 >> 0x21) << 0x20);
								} while (local_14 != 0);
							}
							if ((double)fVar6 < 0.0) {
								local_10 = -local_10;
							}
							*(undefined4 *)param_2 = (undefined4)local_10;
							*(undefined4 *)((int)param_2 + 4) = local_10._4_4_;
						}
					}
					if (bVar5) {
						__std_FUN_00493f00(0x10);
					}
					uVar4 = param_1 & 0x1d;
				}
			}
			else {
				__std_FUN_00493f00(8);
				uVar2 = DAT_004b325c;
				uVar1 = DAT_004b324c;
				uVar4 = param_3 & 0xc00;
				if (uVar4 < 0x401) {
					if (uVar4 == 0x400) {
						if ((ushort)((ushort)(*param_2 < 0.0) << 8 | (ushort)(*param_2 == 0.0) << 0xe) == 0) {
							*(undefined4 *)param_2 = DAT_004b3258;
							*(undefined4 *)((int)param_2 + 4) = uVar2;
							uVar4 = param_1 & 0x1e;
						}
						else {
							local_10 = -(double)CONCAT44(DAT_004b324c,DAT_004b3248);
							local_10._4_4_ = (undefined4)((ulonglong)local_10 >> 0x20);
							*(undefined4 *)param_2 = (undefined4)local_10;
							*(undefined4 *)((int)param_2 + 4) = local_10._4_4_;
							uVar4 = param_1 & 0x1e;
						}
						goto LAB_00493b8b;
					}
					if (uVar4 == 0) {
						if ((ushort)((ushort)(*param_2 < 0.0) << 8 | (ushort)(*param_2 == 0.0) << 0xe) == 0) {
							*(undefined4 *)param_2 = DAT_004b3248;
							*(undefined4 *)((int)param_2 + 4) = uVar1;
							uVar4 = param_1 & 0x1e;
						}
						else {
							local_10 = -(double)CONCAT44(DAT_004b324c,DAT_004b3248);
							local_10._4_4_ = (undefined4)((ulonglong)local_10 >> 0x20);
							*(undefined4 *)param_2 = (undefined4)local_10;
							*(undefined4 *)((int)param_2 + 4) = local_10._4_4_;
							uVar4 = param_1 & 0x1e;
						}
						goto LAB_00493b8b;
					}
				}
				else {
					if (uVar4 == 0x800) {
						if ((ushort)((ushort)(*param_2 < 0.0) << 8 | (ushort)(*param_2 == 0.0) << 0xe) == 0) {
							*(undefined4 *)param_2 = DAT_004b3248;
							*(undefined4 *)((int)param_2 + 4) = uVar1;
							uVar4 = param_1 & 0x1e;
							goto LAB_00493b8b;
						}
						local_10 = -(double)CONCAT44(DAT_004b325c,DAT_004b3258);
						local_10._4_4_ = (undefined4)((ulonglong)local_10 >> 0x20);
						*(undefined4 *)param_2 = (undefined4)local_10;
						*(undefined4 *)((int)param_2 + 4) = local_10._4_4_;
					}
					else {
						if (uVar4 == 0xc00) {
							if ((ushort)((ushort)(*param_2 < 0.0) << 8 | (ushort)(*param_2 == 0.0) << 0xe) == 0) {
								*(undefined4 *)param_2 = DAT_004b3258;
								*(undefined4 *)((int)param_2 + 4) = uVar2;
								uVar4 = param_1 & 0x1e;
							}
							else {
								local_10 = -(double)CONCAT44(DAT_004b325c,DAT_004b3258);
								local_10._4_4_ = (undefined4)((ulonglong)local_10 >> 0x20);
								*(undefined4 *)param_2 = (undefined4)local_10;
								*(undefined4 *)((int)param_2 + 4) = local_10._4_4_;
								uVar4 = param_1 & 0x1e;
							}
							goto LAB_00493b8b;
						}
					}
				}
				uVar4 = param_1 & 0x1e;
			}
		}
		else {
			__std_FUN_00493f00(4);
			uVar4 = param_1 & 0x1b;
		}
	}
	else {
		__std_FUN_00493f00(1);
		uVar4 = param_1 & 0x17;
	}
LAB_00493b8b:
	if (((param_1 & 0x10) != 0) && ((param_3 & 0x20) != 0)) {
		__std_FUN_00493f00(0x20);
		uVar4 = uVar4 & 0xffffffef;
	}
	return (uint)(uVar4 == 0);
}



// WARNING: Could not reconcile some variable overlaps

float10 __cdecl
std::internal::__std_unk_math__00493bb0
					(int param_1,int param_2,double param_3,undefined4 param_4,undefined4 param_5,
					double param_6,uint param_7)
{
	int iVar1;
	int local_20;
	undefined *local_1c;
	undefined8 local_18;
	undefined4 local_10;
	undefined4 local_c;
	undefined8 local_8;
	
	local_1c = __std_FUN_00493c90(param_2);
	if (local_1c != (undefined *)0x0) {
		local_c = param_5;
		local_10 = param_4;
		local_20 = param_1;
		local_18 = param_3;
		local_8 = param_6;
		_control87(param_7,0xffff);
		iVar1 = lego::nerps::funcs::NERPFunc__False(&local_20);
		if (iVar1 == 0) {
			__std_FUN_00493c60(param_1);
		}
		return (float10)local_8;
	}
	_control87(param_7,0xffff);
	__std_FUN_00493c60(param_1);
	return (float10)param_6;
}



void __cdecl std::internal::__std_FUN_00493c60(int param_1)
{
	if (param_1 == 1) {
		std::globals::g_msvc_errno = 0x21;
	}
	else {
		if ((1 < param_1) && (param_1 < 4)) {
			std::globals::g_msvc_errno = 0x22;
			return;
		}
	}
	return;
}



undefined * __cdecl std::internal::__std_FUN_00493c90(int param_1)
{
	int *piVar1;
	int iVar2;
	
	iVar2 = 0;
	piVar1 = &DAT_004b3170;
	do {
		if (*piVar1 == param_1) {
			return (&PTR_s_exp_004b3174)[iVar2 * 2];
		}
		piVar1 = piVar1 + 2;
		iVar2 = iVar2 + 1;
	} while ((int)piVar1 < 0x4b3248);
	return (undefined *)0x0;
}



int __cdecl std::internal::__std_FUN_00493cc0(uint param_1)
{
	if ((param_1 & 0x20) != 0) {
		return 5;
	}
	if ((param_1 & 8) != 0) {
		return 1;
	}
	if ((param_1 & 4) != 0) {
		return 2;
	}
	if ((param_1 & 1) != 0) {
		return 3;
	}
	return (param_1 & 2) << 1;
}



float10 __cdecl
std::internal::__std_FUN_00493d00(undefined4 param_1,undefined4 param_2,short param_3)
{
	undefined2 uStack4;
	
	uStack4 = (undefined2)param_2;
	return (float10)(double)CONCAT26(param_2._2_2_ & 0x800f | (param_3 + 0x3fe) * 0x10,
																	 CONCAT24(uStack4,param_1));
}



undefined4 __cdecl std::internal::__std_FUN_00493d40(double param_1)
{
	if (param_1 == INFINITY) {
		return 1;
	}
	if (param_1 == -INFINITY) {
		return 2;
	}
	if ((param_1._6_2_ & 0x7ff8) == 0x7ff8) {
										// QNAN
		return 3;
	}
	if (((param_1._6_2_ & 0x7ff8) == 0x7ff0) &&
		 ((((ulonglong)param_1 & 0x7ffff00000000) != 0 || (param_1._0_4_ != 0)))) {
										// SNAN
		return 4;
	}
										// NONE
	return 0;
}



float10 __cdecl std::internal::__std_FUN_00493da0(double param_1,int *param_2)
{
	ushort uVar1;
	bool bVar2;
	uint uVar3;
	uint uVar4;
	int iVar5;
	float10 fVar6;
	
	if (param_1 == 0.0) {
		*param_2 = 0;
		return (float10)0.0;
	}
	if ((((ulonglong)param_1 & 0x7ff0000000000000) == 0) &&
		 ((((ulonglong)param_1 & 0xfffff00000000) != 0 || (param_1._0_4_ != 0)))) {
		bVar2 = param_1 < 0.0;
		iVar5 = -0x3fd;
		if (((ulonglong)param_1 & 0x10000000000000) == 0) {
			do {
				uVar3 = (int)((ulonglong)param_1 >> 0x20) << 1;
				param_1._4_2_ = (undefined2)uVar3;
				param_1._6_1_ = (undefined)(uVar3 >> 0x10);
				param_1._7_1_ = (byte)(uVar3 >> 0x18);
				uVar4 = uVar3;
				if (((ulonglong)param_1 & 0x80000000) != 0) {
					uVar4 = uVar3 | 1;
					param_1._4_2_ = (undefined2)uVar4;
				}
				param_1._0_4_ = SUB84(param_1,0) << 1;
				param_1 = (double)CONCAT44(uVar4,param_1._0_4_);
				iVar5 = iVar5 + -1;
			} while ((uVar3 & 0x100000) == 0);
		}
		uVar1 = CONCAT11(param_1._7_1_,param_1._6_1_) & 0xffef;
		param_1._6_1_ = (undefined)uVar1;
		param_1._7_1_ = (byte)(uVar1 >> 8);
		if (bVar2) {
			param_1._7_1_ = param_1._7_1_ | 0x80;
		}
		fVar6 = __std_FUN_00493d00(param_1._0_4_,
															 CONCAT13(param_1._7_1_,CONCAT12(param_1._6_1_,param_1._4_2_)),0);
		*param_2 = iVar5;
		return (float10)(double)fVar6;
	}
	fVar6 = __std_FUN_00493d00(param_1._0_4_,(int)((ulonglong)param_1 >> 0x20),0);
	*param_2 = (((ushort)((ulonglong)param_1 >> 0x30) & 0x7ff0) >> 4) - 0x3fe;
	return (float10)(double)fVar6;
}



// Another float function guess

uint __cdecl std::_status87(void)
{
	short in_FPUStatusWord;
	
	return (int)in_FPUStatusWord;
}



uint __cdecl std::_clear87(void)
{
	short in_FPUStatusWord;
	
	return (int)in_FPUStatusWord;
}



// Not entirely sure

uint __cdecl std::_control87(uint new,uint mask)
{
	short in_FPUControlWord;
	
	return (int)in_FPUControlWord;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __cdecl std::internal::__std_FUN_00493f00(int param_1)
{
	uint in_EAX;
	ushort in_FPUStatusWord;
	
	if ((param_1 & 8U) != 0) {
		in_EAX = in_EAX & 0xffff0000 | (uint)in_FPUStatusWord;
	}
	return in_EAX;
}



int __cdecl
std::internal::__uprlwr__00493f60
					(LCID param_1,uint param_2,char *param_3,LPCWSTR param_4,LPWSTR param_5,int param_6,
					UINT param_7)
{
	int iVar1;
	LPCWSTR cbMultiByte;
	LPCWSTR lpWideCharStr;
	int iVar2;
	
	if (DAT_0054a170 == 0) {
		iVar1 = LCMapStringA(0,0x100,(LPCSTR)&lpSrcStr_0049fd38,1,(LPSTR)0x0,0);
		if (iVar1 == 0) {
			iVar1 = LCMapStringW(0,0x100,(LPCWSTR)&lpSrcStr_0049fd3c,1,(LPWSTR)0x0,0);
			if (iVar1 == 0) {
				return 0;
			}
			DAT_0054a170 = 1;
		}
		else {
			DAT_0054a170 = 2;
		}
	}
	cbMultiByte = param_4;
	if (0 < (int)param_4) {
		cbMultiByte = (LPCWSTR)__unkftime_uprlwr__00494180(param_3,(int)param_4);
	}
	if (DAT_0054a170 == 2) {
		iVar1 = LCMapStringA(param_1,param_2,param_3,(int)cbMultiByte,(LPSTR)param_5,param_6);
		return iVar1;
	}
	if (DAT_0054a170 != 1) {
		return DAT_0054a170;
	}
	param_4 = (LPCWSTR)0x0;
	if (param_7 == 0) {
		param_7 = DAT_0054a190;
	}
	iVar1 = MultiByteToWideChar(param_7,9,param_3,(int)cbMultiByte,(LPWSTR)0x0,0);
	if (iVar1 == 0) {
		return 0;
	}
	lpWideCharStr = (LPCWSTR)malloc(iVar1 * 2);
	if (lpWideCharStr == (LPCWSTR)0x0) {
		return 0;
	}
	iVar2 = MultiByteToWideChar(param_7,1,param_3,(int)cbMultiByte,lpWideCharStr,iVar1);
	if ((iVar2 != 0) &&
		 (iVar2 = LCMapStringW(param_1,param_2,lpWideCharStr,iVar1,(LPWSTR)0x0,0), iVar2 != 0)) {
		if ((param_2 & 0x400) == 0) {
			param_4 = (LPCWSTR)malloc(iVar2 * 2);
			if ((param_4 == (LPCWSTR)0x0) ||
				 (iVar1 = LCMapStringW(param_1,param_2,lpWideCharStr,iVar1,param_4,iVar2), iVar1 == 0))
			goto LAB_0049415f;
			if (param_6 == 0) {
				iVar2 = WideCharToMultiByte(param_7,0x220,param_4,iVar2,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0
																	 );
				iVar1 = iVar2;
			}
			else {
				iVar2 = WideCharToMultiByte(param_7,0x220,param_4,iVar2,(LPSTR)param_5,param_6,(LPCSTR)0x0,
																		(LPBOOL)0x0);
				iVar1 = iVar2;
			}
		}
		else {
			if (param_6 == 0) goto LAB_004940c4;
			if (param_6 < iVar2) goto LAB_0049415f;
			iVar1 = LCMapStringW(param_1,param_2,lpWideCharStr,iVar1,param_5,param_6);
		}
		if (iVar1 != 0) {
LAB_004940c4:
			free(lpWideCharStr);
			free(param_4);
			return iVar2;
		}
	}
LAB_0049415f:
	free(lpWideCharStr);
	free(param_4);
	return 0;
}



char * __cdecl std::internal::__unkftime_uprlwr__00494180(char *param_1,int param_2)
{
	char *pcVar1;
	int iVar2;
	
	pcVar1 = param_1;
	iVar2 = param_2;
	if (param_2 != 0) {
		do {
			iVar2 = iVar2 + -1;
			if (*pcVar1 == '\0') break;
			pcVar1 = pcVar1 + 1;
		} while (iVar2 != 0);
	}
	if (*pcVar1 == '\0') {
		return pcVar1 + -(int)param_1;
	}
	return (char *)param_2;
}



// WARNING: Could not reconcile some variable overlaps

int __cdecl std::vfscanf(FILE *stream,char *format,va_list argptr)
{
	byte *pbVar1;
	byte bVar2;
	int **ppiVar3;
	va_list *ppcVar4;
	uint uVar5;
	int iVar6;
	uint uVar7;
	int **c;
	uint uVar8;
	byte bVar9;
	byte *pbVar10;
	char *pcVar11;
	va_list *ppcVar12;
	char *pcVar13;
	int iVar14;
	undefined4 *puVar15;
	va_list *ppcVar16;
	va_list pcVar17;
	bool bVar18;
	ulonglong uVar19;
	FILE *file;
	char local_1cd;
	va_list local_1cc;
	char local_1c7;
	char local_1c6;
	char local_1c5;
	int local_1c4;
	char local_1c0;
	char local_1bf;
	char local_1be;
	byte local_1bd;
	uint local_1bc;
	va_list *local_1b8;
	undefined4 local_1b4;
	int local_1b0;
	int local_1ac;
	int local_1a8;
	va_list local_1a4;
	byte local_19e;
	undefined local_19d;
	undefined8 local_19c;
	uint local_194;
	ushort local_18e;
	int **local_18c;
	int local_188;
	uint local_184;
	undefined4 local_180 [2];
	undefined local_175;
	char local_160;
	char local_15f [351];
	
	local_1bf = '\0';
	local_1cc = (va_list)0x0;
	local_1ac = 0;
	bVar2 = *format;
	c = local_18c;
	do {
		if (bVar2 == 0) {
LAB_00494e06:
			if ((c == (int **)0xffffffff) && ((local_1ac == 0 && (local_1bf == '\0')))) {
				local_1ac = -1;
			}
			return local_1ac;
		}
		iVar14 = 0;
		if (globals::_pcharwidth < 2) {
			uVar5 = *(byte *)(globals::_pctype + bVar2) & 8;
		}
		else {
			uVar5 = _isctype((uint)bVar2,8);
		}
		if (uVar5 != 0) {
			local_1cc = local_1cc + -1;
			file = stream;
			iVar6 = internal::__vfscanf__fgetc_skipws((int *)&local_1cc,stream);
			internal::__vfscanf__00494f60(iVar6,file);
			format = format + 1;
			iVar6 = isspace((uint)(byte)*format);
			while (iVar6 != 0) {
				format = (char *)((byte *)format + 1);
				iVar6 = isspace((uint)(byte)*format);
			}
		}
		if (*format != '%') {
			local_1cc = local_1cc + 1;
			c = (int **)internal::__vfscanf__fgetc(stream);
			if ((int **)(uint)(byte)*format != c) goto LAB_00494ded;
			pbVar10 = (byte *)(format + 1);
			if ((*(byte *)((int)globals::_pctype + ((uint)c & 0xff) * 2 + 1) & 0x80) != 0) {
				local_1cc = local_1cc + 1;
				uVar5 = internal::__vfscanf__fgetc(stream);
				if ((byte)format[1] != uVar5) {
					local_1cc = local_1cc + -1;
					internal::__vfscanf__00494f60(uVar5,stream);
					goto LAB_00494ded;
				}
				local_1cc = local_1cc + -1;
				pbVar10 = (byte *)(format + 2);
			}
			goto LAB_00494db3;
		}
		local_1a4 = (va_list)0x0;
		local_1b4 = local_1b4 & 0xffffff00;
		local_1a8 = 0;
		local_1b0 = 0;
		local_1c4 = 0;
		local_1bd = 0;
		local_1be = '\0';
		local_1c5 = '\0';
		local_1cd = '\0';
		local_1c0 = '\0';
		local_1c7 = '\0';
		local_1c6 = '\x01';
		local_188 = 0;
		do {
			pbVar10 = (byte *)(format + 1);
			uVar5 = (uint)*pbVar10;
			if (globals::_pcharwidth < 2) {
				uVar7 = *(byte *)(globals::_pctype + uVar5) & 4;
			}
			else {
				uVar7 = _isctype(uVar5,4);
			}
			if (uVar7 == 0) {
				switch(uVar5) {
				case 0x2a:
					local_1c5 = local_1c5 + '\x01';
					break;
				default:
switchD_00494330_caseD_2b:
					local_1cd = local_1cd + '\x01';
					break;
				case 0x46:
				case 0x4e:
					break;
				case 0x49:
					if ((format[2] != '6') || (format[3] != '4')) goto switchD_00494330_caseD_2b;
					iVar14 = iVar14 + 1;
					local_19c = 0;
					pbVar10 = (byte *)(format + 3);
					break;
				case 0x4c:
					local_1c6 = local_1c6 + '\x01';
					break;
				case 0x68:
					local_1c6 = local_1c6 + -1;
					local_1c7 = local_1c7 + -1;
					break;
				case 0x6c:
					local_1c6 = local_1c6 + '\x01';
				case 0x77:
					local_1c7 = local_1c7 + '\x01';
				}
			}
			else {
				local_1b0 = local_1b0 + 1;
				local_1c4 = (uVar5 - 0x30) + local_1c4 * 10;
			}
			format = (char *)pbVar10;
		} while (local_1cd == '\0');
		ppiVar3 = (int **)argptr;
		if (local_1c5 == '\0') {
			local_1b8 = *(va_list **)argptr;
			ppiVar3 = (int **)((int)argptr + 4);
			local_18c = (int **)argptr;
		}
		argptr = (va_list)ppiVar3;
		bVar18 = false;
		if ((local_1c7 == '\0') && ((*format == 'S' || (local_1c7 = -1, *format == 'C')))) {
			local_1c7 = '\x01';
		}
		local_1bc = (byte)*format | 0x20;
		local_188 = iVar14;
		uVar19 = local_19c;
		if (local_1bc != 0x6e) {
			if ((local_1bc == 99) || (local_1bc == 0x7b)) {
				local_1cc = local_1cc + 1;
				c = (int **)internal::__vfscanf__fgetc(stream);
				uVar19 = local_19c;
			}
			else {
				c = (int **)internal::__vfscanf__fgetc_skipws((int *)&local_1cc,stream);
				uVar19 = local_19c;
			}
		}
		ppcVar12 = local_1b8;
		uVar5 = local_1bc;
		local_19c = uVar19;
		if ((local_1b0 != 0) && (local_1c4 == 0)) {
LAB_00494ded:
			local_1cc = local_1cc + -1;
			internal::__vfscanf__00494f60((int)c,stream);
			goto LAB_00494e06;
		}
		switch(local_1bc) {
		case 99:
			if (local_1b0 == 0) {
				local_1b0 = 1;
				local_1c4 = local_1c4 + 1;
			}
			if ('\0' < local_1c7) {
				local_1c0 = '\x01';
			}
			pcVar11 = &DAT_004b3294;
			goto LAB_004944ae;
		case 100:
		case 0x6f:
		case 0x75:
			goto switchD_00494448_caseD_64;
		case 0x65:
		case 0x66:
		case 0x67:
			pcVar11 = &local_160;
			if (c == (int **)0x2d) {
				local_160 = '-';
				pcVar11 = local_15f;
LAB_00494af3:
				local_1c4 = local_1c4 + -1;
				local_1cc = local_1cc + 1;
				c = (int **)internal::__vfscanf__fgetc(stream);
				uVar19 = local_19c;
			}
			else {
				if (c == (int **)0x2b) goto LAB_00494af3;
			}
			iVar14 = local_1a8;
			if ((local_1b0 == 0) || (0x15d < local_1c4)) {
				local_1c4 = 0x15d;
			}
			while( true ) {
				if (globals::_pcharwidth < 2) {
					uVar5 = *(byte *)(globals::_pctype + (int)c) & 4;
				}
				else {
					local_19c = uVar19;
					uVar5 = _isctype((int)c,4);
					uVar19 = local_19c;
				}
				local_19c = uVar19;
				if ((uVar5 == 0) ||
					 (iVar6 = local_1c4 + -1, bVar18 = local_1c4 == 0, local_1c4 = iVar6, bVar18)) break;
				*pcVar11 = (char)c;
				pcVar11 = pcVar11 + 1;
				local_1cc = local_1cc + 1;
				c = (int **)internal::__vfscanf__fgetc(stream);
				iVar14 = iVar14 + 1;
				uVar19 = local_19c;
			}
			if ((DAT_004b0f78 == (char)c) &&
				 (iVar6 = local_1c4 + -1, bVar18 = local_1c4 != 0, local_1c4 = iVar6, bVar18)) {
				local_1cc = local_1cc + 1;
				c = (int **)internal::__vfscanf__fgetc(stream);
				*pcVar11 = DAT_004b0f78;
				while( true ) {
					pcVar11 = pcVar11 + 1;
					if (globals::_pcharwidth < 2) {
						uVar5 = *(byte *)(globals::_pctype + (int)c) & 4;
						uVar19 = local_19c;
					}
					else {
						uVar5 = _isctype((int)c,4);
						uVar19 = local_19c;
					}
					if ((uVar5 == 0) ||
						 (iVar6 = local_1c4 + -1, bVar18 = local_1c4 == 0, local_1c4 = iVar6, bVar18)) break;
					*pcVar11 = (char)c;
					iVar14 = iVar14 + 1;
					local_1cc = local_1cc + 1;
					local_19c = uVar19;
					c = (int **)internal::__vfscanf__fgetc(stream);
				}
			}
			pcVar13 = pcVar11;
			if ((iVar14 != 0) &&
				 (((c == (int **)0x65 || (c == (int **)0x45)) &&
					(iVar6 = local_1c4 + -1, bVar18 = local_1c4 != 0, local_1c4 = iVar6, bVar18)))) {
				*pcVar11 = 'e';
				pcVar13 = pcVar11 + 1;
				local_1cc = local_1cc + 1;
				local_19c = uVar19;
				c = (int **)internal::__vfscanf__fgetc(stream);
				if (c == (int **)0x2d) {
					*pcVar13 = '-';
					pcVar13 = pcVar11 + 2;
LAB_00494c4e:
					iVar6 = local_1c4 + -1;
					uVar19 = local_19c;
					if (local_1c4 != 0) goto LAB_00494c63;
				}
				else {
					if (c == (int **)0x2b) goto LAB_00494c4e;
				}
				while( true ) {
					if (globals::_pcharwidth < 2) {
						uVar5 = *(byte *)(globals::_pctype + (int)c) & 4;
						uVar19 = local_19c;
					}
					else {
						uVar5 = _isctype((int)c,4);
						uVar19 = local_19c;
					}
					if ((uVar5 == 0) ||
						 (iVar6 = local_1c4 + -1, bVar18 = local_1c4 == 0, local_1c4 = iVar6, bVar18)) break;
					iVar14 = iVar14 + 1;
					*pcVar13 = (char)c;
					pcVar13 = pcVar13 + 1;
LAB_00494c63:
					local_1c4 = iVar6;
					local_1cc = local_1cc + 1;
					local_19c = uVar19;
					c = (int **)internal::__vfscanf__fgetc(stream);
				}
			}
			local_1cc = local_1cc + -1;
			local_19c = uVar19;
			internal::__vfscanf__00494f60((int)c,stream);
			if (iVar14 == 0) goto LAB_00494e06;
			uVar19 = local_19c;
			if (local_1c5 == '\0') {
				local_1ac = local_1ac + 1;
				*pcVar13 = '\0';
				(*(code *)PTR___std_FUN_004b0f88)(local_1c6 + -1,local_1b8,&local_160);
				uVar19 = local_19c;
			}
			break;
		default:
			if ((int **)(uint)(byte)*format != c) goto LAB_00494ded;
			local_1bf = local_1bf + -1;
			if (local_1c5 == '\0') {
				argptr = (va_list)local_18c;
			}
			break;
		case 0x69:
			local_1bc = 100;
		case 0x78:
			uVar5 = local_1bc;
			if (c == (int **)0x2d) {
				local_1be = '\x01';
LAB_00494702:
				local_1c4 = local_1c4 + -1;
				if ((local_1c4 == 0) && (local_1b0 != 0)) {
					bVar18 = true;
				}
				else {
					local_1cc = local_1cc + 1;
					c = (int **)internal::__vfscanf__fgetc(stream);
					uVar19 = local_19c;
				}
			}
			else {
				if (c == (int **)0x2b) goto LAB_00494702;
			}
			if (c == (int **)0x30) {
				local_1cc = local_1cc + 1;
				local_19c = uVar19;
				c = (int **)internal::__vfscanf__fgetc(stream);
				if (((char)c == 'x') || ((char)c == 'X')) {
					local_1cc = local_1cc + 1;
					c = (int **)internal::__vfscanf__fgetc(stream);
					uVar5 = 0x78;
					local_1bc = 0x78;
					uVar19 = local_19c;
				}
				else {
					local_1a8 = 1;
					if (uVar5 == 0x78) {
						local_1cc = local_1cc + -1;
						internal::__vfscanf__00494f60((int)c,stream);
						c = (int **)0x30;
						uVar19 = local_19c;
					}
					else {
						uVar5 = 0x6f;
						local_1bc = 0x6f;
						uVar19 = local_19c;
					}
				}
			}
			goto LAB_004947e4;
		case 0x6e:
			pcVar17 = local_1cc;
			if (local_1c5 != '\0') break;
			goto LAB_00494aa5;
		case 0x70:
			local_1c6 = '\x01';
switchD_00494448_caseD_64:
			if (c == (int **)0x2d) {
				local_1be = '\x01';
LAB_004947ba:
				local_1c4 = local_1c4 + -1;
				if ((local_1c4 == 0) && (local_1b0 != 0)) {
					bVar18 = true;
				}
				else {
					local_1cc = local_1cc + 1;
					c = (int **)internal::__vfscanf__fgetc(stream);
					uVar19 = local_19c;
				}
			}
			else {
				if (c == (int **)0x2b) goto LAB_004947ba;
			}
LAB_004947e4:
			pcVar17 = local_1a4;
			local_19c = uVar19;
			if (iVar14 == 0) {
				while (!bVar18) {
					local_19c = uVar19;
					if ((uVar5 == 0x78) || (uVar5 == 0x70)) {
						if (globals::_pcharwidth < 2) {
										// C1_XDIGIT (0x80)
							uVar7 = *(byte *)(globals::_pctype + (int)c) & C1_XDIGIT;
						}
						else {
										// C1_XDIGIT (0x80)
							uVar7 = _isctype((int)c,C1_XDIGIT);
							uVar19 = local_19c;
						}
						if (uVar7 != 0) {
							pcVar17 = (va_list)((int)pcVar17 << 4);
							local_19c = uVar19;
							c = (int **)internal::__hexdigit_subtractalpha((int)c);
							goto LAB_004949da;
						}
LAB_004949d6:
						bVar18 = true;
						local_19c = uVar19;
					}
					else {
						if (globals::_pcharwidth < 2) {
							uVar7 = *(byte *)(globals::_pctype + (int)c) & 4;
						}
						else {
							uVar7 = _isctype((int)c,4);
							uVar19 = local_19c;
						}
						if (uVar7 == 0) goto LAB_004949d6;
						local_19c = uVar19;
						if (uVar5 == 0x6f) {
							if (0x37 < (int)c) goto LAB_004949d6;
							pcVar17 = (va_list)((int)pcVar17 << 3);
						}
						else {
							pcVar17 = (va_list)((int)pcVar17 * 10);
						}
					}
LAB_004949da:
					if (bVar18) {
						local_1cc = local_1cc + -1;
						internal::__vfscanf__00494f60((int)c,stream);
						uVar19 = local_19c;
					}
					else {
						local_1a8 = local_1a8 + 1;
						pcVar17 = (va_list)((int)c + (int)(pcVar17 + -0x30));
						if ((local_1b0 == 0) || (local_1c4 = local_1c4 + -1, local_1c4 != 0)) {
							local_1cc = local_1cc + 1;
							c = (int **)internal::__vfscanf__fgetc(stream);
							uVar19 = local_19c;
						}
						else {
							bVar18 = true;
							uVar19 = local_19c;
						}
					}
				}
				local_1a4 = pcVar17;
				if (local_1be != '\0') {
					local_1a4 = (va_list)-(int)pcVar17;
				}
			}
			else {
				while( true ) {
					uVar5 = (uint)uVar19;
					uVar7 = (uint)(uVar19 >> 0x20);
					if (bVar18) break;
					if (local_1bc == 0x78) {
						if (globals::_pcharwidth < 2) {
							uVar5 = *(byte *)(globals::_pctype + (int)c) & 0x80;
						}
						else {
							uVar5 = _isctype((int)c,0x80);
						}
						if (uVar5 != 0) {
							uVar19 = internal::__allshl();
							c = (int **)internal::__hexdigit_subtractalpha((int)c);
							goto LAB_004948b1;
						}
LAB_004948ad:
						bVar18 = true;
					}
					else {
						if (globals::_pcharwidth < 2) {
							uVar8 = *(byte *)(globals::_pctype + (int)c) & 4;
						}
						else {
							uVar8 = _isctype((int)c,4);
						}
						if (uVar8 == 0) goto LAB_004948ad;
						if (local_1bc == 0x6f) {
							if (0x37 < (int)c) goto LAB_004948ad;
							uVar19 = internal::__allshl();
						}
						else {
							uVar19 = __allmul(uVar5,uVar7,10,0);
						}
					}
LAB_004948b1:
					if (bVar18) {
						local_1cc = local_1cc + -1;
						internal::__vfscanf__00494f60((int)c,stream);
					}
					else {
						ppiVar3 = c + -0xc;
						local_1a8 = local_1a8 + 1;
						if ((local_1b0 == 0) || (local_1c4 = local_1c4 + -1, local_1c4 != 0)) {
							local_1cc = local_1cc + 1;
							c = (int **)internal::__vfscanf__fgetc(stream);
							uVar19 = uVar19 + (longlong)(int)ppiVar3;
						}
						else {
							bVar18 = true;
							uVar19 = uVar19 + (longlong)(int)ppiVar3;
						}
					}
				}
				if (local_1be != '\0') {
					uVar19 = CONCAT44(-(uVar7 + (uVar5 != 0)),-uVar5);
				}
			}
			iVar14 = local_1a8;
			if (local_1bc == 0x46) {
				iVar14 = 0;
			}
			if (iVar14 == 0) goto LAB_00494e06;
			if (local_1c5 == '\0') {
				local_1ac = local_1ac + 1;
				pcVar17 = local_1a4;
				iVar14 = local_188;
LAB_00494aa5:
				local_19c._4_4_ = (va_list)(uVar19 >> 0x20);
				local_19c._0_4_ = (va_list)uVar19;
				if (iVar14 == 0) {
					if (local_1c6 == '\0') {
						*(short *)local_1b8 = (short)pcVar17;
					}
					else {
						*local_1b8 = pcVar17;
					}
				}
				else {
					*local_1b8 = (va_list)local_19c;
					local_1b8[1] = local_19c._4_4_;
				}
			}
			break;
		case 0x73:
			if ('\0' < local_1c7) {
				local_1c0 = '\x01';
			}
			pcVar11 = " \t-\r]";
LAB_004944ae:
			local_1bd = 0xff;
			pbVar10 = (byte *)format;
LAB_004944b3:
			format = (char *)pbVar10;
			puVar15 = local_180;
			for (iVar14 = 8; iVar14 != 0; iVar14 = iVar14 + -1) {
				*puVar15 = 0;
				puVar15 = puVar15 + 1;
			}
			if ((local_1bc == 0x7b) && (*pcVar11 == 0x5d)) {
				local_1b4 = CONCAT31(local_1b4._1_3_,0x5d);
				pcVar11 = (char *)((byte *)pcVar11 + 1);
				local_175 = 0x20;
			}
			bVar2 = *pcVar11;
			while (bVar2 != 0x5d) {
				pbVar10 = (byte *)pcVar11 + 1;
				local_184 = local_184 & 0xffffff00 | (uint)bVar2;
				if (((bVar2 == 0x2d) && ((byte)local_1b4 != 0)) && (bVar9 = *pbVar10, bVar9 != 0x5d)) {
					pbVar10 = (byte *)pcVar11 + 2;
					if ((byte)local_1b4 < bVar9) {
						local_194 = local_194 & 0xffffff00 | (uint)bVar9;
						bVar9 = (byte)local_1b4;
					}
					else {
						local_194 = local_194 & 0xffffff00 | local_1b4 & 0xff;
						local_1b4 = local_1b4 & 0xffffff00 | (uint)bVar9;
					}
					if (bVar9 <= (byte)local_194) {
						uVar5 = local_1b4 & 0xff;
						iVar14 = ((local_194 & 0xff) - uVar5) + 1;
						do {
							bVar2 = (byte)uVar5;
							pbVar1 = (byte *)((int)local_180 + (uVar5 >> 3));
							uVar5 = uVar5 + 1;
							iVar14 = iVar14 + -1;
							*pbVar1 = *pbVar1 | '\x01' << (bVar2 & 7);
						} while (iVar14 != 0);
					}
					local_1b4 = local_1b4 & 0xffffff00;
				}
				else {
					local_1b4 = local_1b4 & 0xffffff00 | (uint)bVar2;
					pbVar1 = (byte *)((int)local_180 + (uint)(bVar2 >> 3));
					*pbVar1 = *pbVar1 | '\x01' << (bVar2 & 7);
				}
				pcVar11 = (char *)pbVar10;
				bVar2 = *pbVar10;
			}
			if (*pcVar11 == 0) goto LAB_00494e06;
			if (local_1bc == 0x7b) {
				format = pcVar11;
			}
			local_1cc = local_1cc + -1;
			internal::__vfscanf__00494f60((int)c,stream);
			ppcVar16 = ppcVar12;
			while( true ) {
				if ((local_1b0 != 0) &&
					 (iVar14 = local_1c4 + -1, bVar18 = local_1c4 == 0, local_1c4 = iVar14, ppcVar4 = ppcVar16
					 , bVar18)) goto LAB_0049469c;
				local_1cc = local_1cc + 1;
				c = (int **)internal::__vfscanf__fgetc(stream);
				if ((c == (int **)0xffffffff) ||
					 (bVar2 = (byte)c,
					 ((int)(char)(*(byte *)((int)local_180 + ((int)c >> 3)) ^ local_1bd) & 1 << (bVar2 & 7))
					 == 0)) break;
				if (local_1c5 == '\0') {
					if (local_1c0 == '\0') {
						*(byte *)ppcVar16 = bVar2;
						ppcVar16 = (va_list *)((int)ppcVar16 + 1);
					}
					else {
						local_19e = bVar2;
						if ((*(byte *)((int)globals::_pctype + ((uint)c & 0xff) * 2 + 1) & 0x80) != 0) {
							local_1cc = local_1cc + 1;
							iVar14 = internal::__vfscanf__fgetc(stream);
							local_19d = (undefined)iVar14;
						}
						internal::__vfscanf__004990c0(&local_18e,&local_19e,globals::_pcharwidth);
						*(ushort *)ppcVar16 = local_18e;
						ppcVar16 = (va_list *)((int)ppcVar16 + 2);
					}
				}
				else {
					ppcVar12 = (va_list *)((int)ppcVar12 + 1);
				}
			}
			local_1cc = local_1cc + -1;
			local_1b8 = ppcVar16;
			internal::__vfscanf__00494f60((int)c,stream);
			ppcVar4 = local_1b8;
LAB_0049469c:
			local_1b8 = ppcVar4;
			if (ppcVar12 == ppcVar16) goto LAB_00494e06;
			uVar19 = local_19c;
			if ((local_1c5 == '\0') && (local_1ac = local_1ac + 1, local_1bc != 99)) {
				if (local_1c0 == '\0') {
					*(undefined *)local_1b8 = 0;
				}
				else {
					*(undefined2 *)local_1b8 = 0;
				}
			}
			break;
		case 0x7b:
			if ('\0' < local_1c7) {
				local_1c0 = '\x01';
			}
			pbVar10 = (byte *)(format + 1);
			pcVar11 = (char *)pbVar10;
			if (*pbVar10 == 0x5e) {
				pcVar11 = format + 2;
				format = (char *)pbVar10;
				goto LAB_004944ae;
			}
			goto LAB_004944b3;
		}
		local_1bf = local_1bf + '\x01';
		pbVar10 = (byte *)(format + 1);
		local_19c = uVar19;
LAB_00494db3:
		format = (char *)pbVar10;
		if ((c == (int **)0xffffffff) && ((*format != '%' || (format[1] != 'n')))) goto LAB_00494e06;
		bVar2 = *format;
	} while( true );
}



int __cdecl std::internal::__hexdigit_subtractalpha(int c)
{
	uint uVar1;
	
										// int std::isdigit(int c)
	if (std::globals::_pcharwidth < 2) {
										// C1_DIGIT (0x4)
		uVar1 = *(byte *)(std::globals::_pctype + c) & C1_DIGIT;
	}
	else {
										// C1_DIGIT (0x4)
		uVar1 = _isctype(c,C1_DIGIT);
	}
	if (uVar1 == 0) {
		c = (c & 0xffffffdfU) - 7;
	}
	return c;
}



int __cdecl std::internal::__vfscanf__fgetc(FILE *file)
{
	byte bVar1;
	int iVar2;
	uint uVar3;
	
	iVar2 = file->_cnt + -1;
	file->_cnt = iVar2;
	if (-1 < iVar2) {
		bVar1 = *file->_ptr;
		file->_ptr = file->_ptr + 1;
		return (uint)bVar1;
	}
	uVar3 = __fpeekc(file);
	return uVar3;
}



int __cdecl std::internal::__vfscanf__00494f60(int c,FILE *file)
{
	if (c != -1) {
		c = __vfscanf__00499210(c,file);
	}
	return c;
}



int __cdecl std::internal::__vfscanf__fgetc_skipws(int *out_count,FILE *file)
{
	int c;
	int iVar1;
	
	*out_count = *out_count + 1;
	c = __vfscanf__fgetc(file);
	iVar1 = isspace(c);
	while (iVar1 != 0) {
		*out_count = *out_count + 1;
		c = __vfscanf__fgetc(file);
		iVar1 = isspace(c);
	}
	return c;
}



int __cdecl std::internal::__fdclose__00494fd0(uint fd)
{
	int iVar1;
	int iVar2;
	HANDLE hObject;
	BOOL BVar3;
	DWORD error_value;
	int iVar4;
	
	if (globals::__UINT_0076eec0 <= fd) {
		std::globals::g_msvc_errno = 9;
		std::globals::g_msvc_doserrno = 0;
		return -1;
	}
	iVar4 = (fd & 0x1f) * 8;
	if ((*(byte *)((&DAT_0076edc0)[(int)fd >> 5] + 4 + iVar4) & 1) == 0) {
		std::globals::g_msvc_errno = 9;
		std::globals::g_msvc_doserrno = 0;
		return -1;
	}
	iVar1 = __fdunk__004994b0(fd);
	if (iVar1 != -1) {
		if ((fd == 1) || (fd == 2)) {
			iVar1 = __fdunk__004994b0(2);
			iVar2 = __fdunk__004994b0(1);
			if (iVar2 == iVar1) goto LAB_00495057;
		}
		hObject = (HANDLE)__fdunk__004994b0(fd);
		BVar3 = CloseHandle(hObject);
		if (BVar3 == 0) {
			error_value = GetLastError();
			goto LAB_00495059;
		}
	}
LAB_00495057:
	error_value = 0;
LAB_00495059:
	__fdclose__00499410(fd);
	*(undefined *)((&DAT_0076edc0)[(int)fd >> 5] + 4 + iVar4) = 0;
	if (error_value == 0) {
		return 0;
	}
	__set_doserrno(error_value);
	return -1;
}



void __cdecl std::internal::__ffree__004950b0(FILE *file)
{
	if (((file->_flag & 0x83U) != 0) && ((file->_flag & 8U) != 0)) {
		free(file->_base);
		file->_flag = file->_flag & 0xfffffbf7;
		file->_ptr = (char *)0x0;
		file->_base = (char *)0x0;
		file->_cnt = 0;
	}
	return;
}



FILE * __cdecl
std::internal::__fsopen__004950f0(LPCSTR filename,char *mode,uint shflag,FILE *in_stream)
{
	char cVar1;
	bool bVar2;
	bool bVar3;
	bool bVar4;
	uint uVar5;
	char *pcVar6;
	uint uVar7;
	
	cVar1 = *mode;
	bVar3 = false;
	bVar4 = false;
	if (cVar1 == 'a') {
		uVar5 = 0x109;
	}
	else {
		if (cVar1 == 'r') {
			uVar5 = 0;
			uVar7 = DAT_0054a420 | 1;
			goto LAB_0049512d;
		}
		if (cVar1 != 'w') {
			return (FILE *)0x0;
		}
		uVar5 = 0x301;
	}
	uVar7 = DAT_0054a420 | 2;
LAB_0049512d:
	pcVar6 = mode + 1;
	bVar2 = true;
	cVar1 = *pcVar6;
	do {
		if ((cVar1 == '\0') || (!bVar2)) {
			uVar5 = __fsopen__00499500(filename,uVar5,shflag,0x1a4);
			if (-1 < (int)uVar5) {
				globals::__unkCount_0054a3e4 = globals::__unkCount_0054a3e4 + 1;
				in_stream->_flag = uVar7;
				in_stream->_cnt = 0;
				in_stream->_ptr = (char *)0x0;
				in_stream->_base = (char *)0x0;
				in_stream->_tmpfname = (char *)0x0;
				in_stream->_file = uVar5;
				return in_stream;
			}
			return (FILE *)0x0;
		}
		switch(cVar1) {
		case '+':
			if ((uVar5 & 2) != 0) break;
			uVar5 = uVar5 & 0xfffffffe | 2;
			uVar7 = uVar7 & 0xfffffffc | 0x80;
			goto LAB_004951de;
		case 'D':
			if ((uVar5 & 0x40) == 0) {
				uVar5 = uVar5 | 0x40;
				goto LAB_004951de;
			}
			break;
		case 'R':
			if (!bVar4) {
				bVar4 = true;
				uVar5 = uVar5 | 0x10;
				goto LAB_004951de;
			}
			break;
		case 'S':
			if (!bVar4) {
				bVar4 = true;
				uVar5 = uVar5 | 0x20;
				goto LAB_004951de;
			}
			break;
		case 'T':
			if ((uVar5 & 0x1000) == 0) {
				uVar5 = uVar5 | 0x1000;
				goto LAB_004951de;
			}
			break;
		case 'b':
			if ((uVar5 & 0xc000) == 0) {
				uVar5 = uVar5 | 0x8000;
				goto LAB_004951de;
			}
			break;
		case 'c':
			if (!bVar3) {
				bVar3 = true;
				uVar7 = uVar7 | 0x4000;
				goto LAB_004951de;
			}
			break;
		case 'n':
			if (!bVar3) {
				bVar3 = true;
				uVar7 = uVar7 & 0xffffbfff;
				goto LAB_004951de;
			}
			break;
		case 't':
			if ((uVar5 & 0xc000) == 0) {
				uVar5 = uVar5 | 0x4000;
				goto LAB_004951de;
			}
		}
		bVar2 = false;
LAB_004951de:
		pcVar6 = pcVar6 + 1;
		cVar1 = *pcVar6;
	} while( true );
}



FILE * __cdecl std::internal::__fsopen__004952c0(void)
{
	FILE *pFVar1;
	int iVar2;
	FILE **ppFVar3;
	FILE *pFVar4;
	
	pFVar4 = (FILE *)0x0;
	iVar2 = 0;
	ppFVar3 = globals::__filesTable_0076dd98;
	if (0 < globals::__filesCount_0076eda0) {
		do {
			if (*ppFVar3 == (FILE *)0x0) {
				pFVar1 = (FILE *)malloc(0x20);
				globals::__filesTable_0076dd98[iVar2] = pFVar1;
				if (globals::__filesTable_0076dd98[iVar2] != (FILE *)0x0) {
					pFVar4 = globals::__filesTable_0076dd98[iVar2];
				}
				break;
			}
			if ((*(byte *)&(*ppFVar3)->_flag & 0x83) == 0) {
				pFVar4 = globals::__filesTable_0076dd98[iVar2];
				break;
			}
			iVar2 = iVar2 + 1;
			ppFVar3 = ppFVar3 + 1;
		} while (iVar2 < globals::__filesCount_0076eda0);
	}
	if (pFVar4 != (FILE *)0x0) {
		pFVar4->_cnt = 0;
		pFVar4->_flag = 0;
		pFVar4->_base = (char *)0x0;
		pFVar4->_ptr = (char *)0x0;
		pFVar4->_tmpfname = (char *)0x0;
		pFVar4->_file = -1;
	}
	return pFVar4;
}



undefined4 __cdecl
std::internal::__std_FUN_00495350
					(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3,undefined4 param_4,
					int *param_5,PVOID param_6,PVOID param_7,undefined4 param_8)
{
	code *pcVar1;
	undefined4 uVar2;
	
	if (*param_5 != 0x19930520) {
		__std_FUN_00495e30();
	}
	if ((*(byte *)&param_1->ExceptionFlags & 0x66) == 0) {
		if (param_5[3] != 0) {
			if (((param_1->ExceptionCode == 0xe06d7363) && (0x19930520 < param_1->ExceptionInformation[0])
					) && (pcVar1 = *(code **)(param_1->ExceptionInformation[2] + 8), pcVar1 != (code *)0x0)) {
				uVar2 = (*pcVar1)(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8);
				return uVar2;
			}
			__std_FUN_00495420(param_1,param_2,param_3,param_4,(int)param_5,(char)param_8,param_6,param_7)
			;
		}
	}
	else {
		if ((param_5[1] != 0) && (param_6 == (PVOID)0x0)) {
			__std_FUN_004957a0((int)param_2,param_4,(int)param_5,-1);
			return 1;
		}
	}
	return 1;
}



void __cdecl
std::internal::__std_FUN_00495420
					(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3,undefined4 param_4,int param_5
					,char param_6,PVOID param_7,PVOID param_8)
{
	byte bVar1;
	int *piVar2;
	PEXCEPTION_RECORD pEVar3;
	uint uVar4;
	byte *pbVar5;
	int iVar6;
	byte **ppbVar7;
	int iVar8;
	byte *pbVar9;
	byte *pbVar10;
	bool bVar11;
	uint local_20;
	int *local_1c;
	int local_18;
	int local_14;
	int local_10;
	uint local_c;
	byte **local_8;
	int local_4;
	
	iVar8 = *(int *)((int)param_2 + 8);
	local_10 = iVar8;
	if ((iVar8 < -1) || (*(int *)(param_5 + 4) <= iVar8)) {
		__std_FUN_00495e30();
	}
	pEVar3 = DAT_0054a194;
	if (param_1->ExceptionCode == 0xe06d7363) {
		if (((param_1->NumberParameters == 3) && (param_1->ExceptionInformation[0] == 0x19930520)) &&
			 (param_1->ExceptionInformation[2] == 0)) {
			if (DAT_0054a194 == (PEXCEPTION_RECORD)0x0) {
				return;
			}
			param_1 = DAT_0054a194;
			param_3 = DAT_0054a198;
			uVar4 = __std_FUN_00499950(DAT_0054a194,1);
			if (uVar4 == 0) {
				__std_FUN_00495e30();
			}
			if (pEVar3->ExceptionCode != 0xe06d7363) goto LAB_0049568b;
			if (((pEVar3->NumberParameters == 3) && (pEVar3->ExceptionInformation[0] == 0x19930520)) &&
				 (pEVar3->ExceptionInformation[2] == 0)) {
				__std_FUN_00495e30();
			}
		}
		if (((param_1->ExceptionCode == 0xe06d7363) && (param_1->NumberParameters == 3)) &&
			 (param_1->ExceptionInformation[0] == 0x19930520)) {
			local_1c = (int *)__std_FUN_0048f150(param_5,(int)param_7,iVar8,&local_20,&local_c);
			if (local_20 < local_c) {
				do {
					if ((*local_1c == iVar8 || *local_1c < iVar8) && (iVar8 <= local_1c[1])) {
						local_14 = local_1c[3];
						pbVar10 = (byte *)local_1c[4];
						if (0 < local_14) {
							piVar2 = *(int **)(param_1->ExceptionInformation[2] + 0xc);
							local_8 = (byte **)(piVar2 + 1);
							local_4 = *piVar2;
							do {
								local_18 = local_4;
								if (0 < local_4) {
									iVar8 = *(int *)(pbVar10 + 4);
									ppbVar7 = local_8;
									do {
										if ((iVar8 == 0) || (pbVar5 = (byte *)(iVar8 + 8), *(char *)(iVar8 + 8) == '\0')
											 ) {
LAB_004955e4:
											bVar11 = true;
										}
										else {
											iVar6 = *(int *)(*ppbVar7 + 4);
											if (iVar8 == iVar6) {
LAB_004955bf:
												if (((((**ppbVar7 & 2) == 0) || ((*pbVar10 & 8) != 0)) &&
														(((*(uint *)param_1->ExceptionInformation[2] & 1) == 0 ||
														 ((*pbVar10 & 1) != 0)))) &&
													 (((*(uint *)param_1->ExceptionInformation[2] & 2) == 0 ||
														((*pbVar10 & 2) != 0)))) goto LAB_004955e4;
												bVar11 = false;
											}
											else {
												pbVar9 = (byte *)(iVar6 + 8);
												do {
													bVar1 = *pbVar5;
													bVar11 = bVar1 < *pbVar9;
													if (bVar1 != *pbVar9) {
LAB_004955a2:
														iVar6 = (1 - (uint)bVar11) - (uint)(bVar11 != 0);
														goto LAB_004955a7;
													}
													if (bVar1 == 0) break;
													bVar1 = pbVar5[1];
													bVar11 = bVar1 < pbVar9[1];
													if (bVar1 != pbVar9[1]) goto LAB_004955a2;
													pbVar5 = pbVar5 + 2;
													pbVar9 = pbVar9 + 2;
												} while (bVar1 != 0);
												iVar6 = 0;
LAB_004955a7:
												if (iVar6 == 0) goto LAB_004955bf;
												bVar11 = false;
											}
										}
										if (bVar11) {
											__std_FUN_00495880(param_1,param_2,param_3,param_4,param_5,pbVar10,*ppbVar7,
																				 local_1c,(int)param_7,param_8);
											iVar8 = local_10;
											goto LAB_00495654;
										}
										ppbVar7 = ppbVar7 + 1;
										local_18 = local_18 + -1;
									} while (0 < local_18);
								}
								local_14 = local_14 + -1;
								pbVar10 = pbVar10 + 0x10;
								iVar8 = local_10;
							} while (0 < local_14);
						}
					}
LAB_00495654:
					local_20 = local_20 + 1;
					local_1c = local_1c + 5;
				} while (local_20 < local_c);
			}
			if (param_6 == '\0') {
				return;
			}
			__std_FUN_00495ca0((int)param_1);
			return;
		}
	}
LAB_0049568b:
	if (param_6 != '\0') {
		__std_FUN_00495da0();
		return;
	}
	__std_FUN_004956d0(param_1,param_2,param_3,param_4,param_5,iVar8,param_7,param_8);
	return;
}



void __cdecl
std::internal::__std_FUN_004956d0
					(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3,undefined4 param_4,int param_5
					,int param_6,PVOID param_7,PVOID param_8)
{
	PVOID pvVar1;
	PVOID pvVar2;
	int iVar3;
	int *piVar4;
	int iVar5;
	
	pvVar2 = param_8;
	pvVar1 = param_7;
	if ((DAT_0054a19c != 0) &&
		 (iVar3 = __std_FUN_0048eff0((undefined4 *)param_1,param_2,param_3,param_4,param_5,param_7,
																 param_8), iVar3 != 0)) {
		return;
	}
	piVar4 = (int *)__std_FUN_0048f150(param_5,(int)pvVar1,param_6,(uint *)&param_8,(uint *)&param_7);
	if (param_8 < param_7) {
		do {
			if ((*piVar4 <= param_6) && (param_6 <= piVar4[1])) {
				iVar5 = piVar4[4] + piVar4[3] * 0x10;
				iVar3 = *(int *)(iVar5 + -0xc);
				if ((iVar3 == 0) || (*(char *)(iVar3 + 8) == '\0')) {
					__std_FUN_00495880(param_1,param_2,param_3,param_4,param_5,(byte *)(iVar5 + -0x10),
														 (byte *)0x0,piVar4,(int)pvVar1,pvVar2);
				}
			}
			param_8 = (PVOID)((int)param_8 + 1);
			piVar4 = piVar4 + 5;
		} while (param_8 < param_7);
	}
	return;
}



void __cdecl
std::internal::__std_FUN_004957a0(int param_1,undefined4 param_2,int param_3,int param_4)
{
	int iVar1;
	int iVar2;
	undefined4 *in_FS_OFFSET;
	int local_20;
	undefined *local_1c;
	undefined4 local_14;
	undefined *puStack16;
	undefined *puStack12;
	undefined4 local_8;
	
	puStack12 = &DAT_0049fd50;
	puStack16 = &LAB_00496a98;
	local_14 = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_14;
	local_1c = &stack0xffffffd4;
	for (iVar2 = *(int *)(param_1 + 8); local_8 = 0xffffffff, iVar2 != param_4;
			iVar2 = *(int *)(*(int *)(param_3 + 8) + iVar2 * 8)) {
		local_20 = iVar2;
		if ((iVar2 < 0) || (*(int *)(param_3 + 4) <= iVar2)) {
			__std_FUN_00495e30();
		}
		local_8 = 0;
		iVar1 = *(int *)(*(int *)(param_3 + 8) + 4 + iVar2 * 8);
		if (iVar1 != 0) {
			__CallSettingFrame_12(iVar1,param_1,0x103);
		}
	}
	*(int *)(param_1 + 8) = iVar2;
	*in_FS_OFFSET = local_14;
	return;
}



undefined4 __cdecl std::internal::__std_FUN_00495860(int **param_1)
{
	if (**param_1 == -0x1f928c9d) {
		__std_FUN_00495da0();
	}
	return 0;
}



void __cdecl
std::internal::__std_FUN_00495880
					(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3,undefined4 param_4,int param_5
					,byte *param_6,byte *param_7,int *param_8,int param_9,PVOID param_10)
{
	undefined *UNRECOVERED_JUMPTABLE;
	
	if (param_7 != (byte *)0x0) {
		__std_FUN_00495a90((int)param_1,(int)param_2,param_6,param_7);
	}
	if (param_10 == (PVOID)0x0) {
		param_10 = param_2;
	}
	__std_FUN_0048eec0(param_10,param_1);
	__std_FUN_004957a0((int)param_2,param_4,param_5,*param_8);
	*(int *)((int)param_2 + 8) = param_8[1] + 1;
	UNRECOVERED_JUMPTABLE =
			 (undefined *)
			 __std_FUN_00495910(param_1,(int)param_2,param_3,param_5,*(undefined4 *)(param_6 + 0xc),
													param_9,0x100);
	if (UNRECOVERED_JUMPTABLE != (undefined *)0x0) {
		__std_FUN_0048ee70(UNRECOVERED_JUMPTABLE);
	}
	return;
}



undefined4 __cdecl
std::internal::__std_FUN_00495910
					(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
					int param_6,int param_7)
{
	undefined4 uVar1;
	undefined4 *in_FS_OFFSET;
	undefined4 local_30;
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined *local_1c;
	undefined4 local_14;
	undefined *puStack16;
	undefined *puStack12;
	undefined4 local_8;
	
	puStack12 = &DAT_0049fd60;
	puStack16 = &LAB_00496a98;
	local_14 = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_14;
	local_1c = &stack0xffffffc4;
	local_30 = param_5;
	local_28 = 0;
	local_2c = *(undefined4 *)(param_2 + -4);
	local_20 = DAT_0054a194;
	local_24 = DAT_0054a198;
	DAT_0054a194 = param_1;
	DAT_0054a198 = param_3;
	local_8 = 1;
	uVar1 = __std_FUN_0048ef60(param_2,param_4,param_5,param_6,param_7);
	local_8 = 0xffffffff;
	local_30 = uVar1;
	__std_FUN_004959fa();
	*in_FS_OFFSET = local_14;
	return uVar1;
}



void std::internal::__std_FUN_004959fa(void)
{
	int unaff_EBX;
	int unaff_EBP;
	int unaff_ESI;
	int *unaff_EDI;
	
	*(undefined4 *)(unaff_ESI + -4) = *(undefined4 *)(unaff_EBP + -0x28);
	DAT_0054a194 = *(undefined4 *)(unaff_EBP + -0x1c);
	DAT_0054a198 = *(undefined4 *)(unaff_EBP + -0x20);
	if ((((*unaff_EDI == -0x1f928c9d) && (unaff_EDI[4] == 3)) && (unaff_EDI[5] == 0x19930520)) &&
		 ((*(int *)(unaff_EBP + -0x24) == 0 && (unaff_EBX != 0)))) {
		__abnormal_termination();
		__std_FUN_00495ca0((int)unaff_EDI);
	}
	return;
}



undefined4 __cdecl std::internal::__std_FUN_00495a60(int **param_1)
{
	int *piVar1;
	
	piVar1 = *param_1;
	if ((((*piVar1 == -0x1f928c9d) && (piVar1[4] == 3)) && (piVar1[5] == 0x19930520)) &&
		 (piVar1[7] == 0)) {
		return 1;
	}
	return 0;
}



void __cdecl std::internal::__std_FUN_00495a90(int param_1,int param_2,byte *param_3,byte *param_4)
{
	int *piVar1;
	uint uVar2;
	int iVar3;
	undefined4 *puVar4;
	undefined4 *in_FS_OFFSET;
	undefined *local_1c;
	undefined4 local_14;
	undefined *puStack16;
	undefined *puStack12;
	undefined4 local_8;
	
	puStack12 = &DAT_0049fd78;
	puStack16 = &LAB_00496a98;
	local_14 = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_14;
	local_1c = &stack0xffffffd4;
	if (((*(int *)(param_3 + 4) != 0) && (*(char *)(*(int *)(param_3 + 4) + 8) != '\0')) &&
		 (*(int *)(param_3 + 8) != 0)) {
		piVar1 = (int *)(param_2 + 0xc + *(int *)(param_3 + 8));
		local_8 = 0;
		if ((*param_3 & 8) == 0) {
			if ((*param_4 & 1) == 0) {
				if (*(int *)(param_4 + 0x18) == 0) {
					local_1c = &stack0xffffffd4;
					uVar2 = __std_FUN_00499950(*(void **)(param_1 + 0x18),1);
					if ((uVar2 != 0) && (uVar2 = __std_FUN_00499970(piVar1,1), uVar2 != 0)) {
						uVar2 = *(uint *)(param_4 + 0x14);
						puVar4 = (undefined4 *)__std_FUN_00495d20(*(int *)(param_1 + 0x18),(int *)(param_4 + 8))
						;
						__std_FUN_004982c0(piVar1,puVar4,uVar2);
						goto LAB_00495c80;
					}
				}
				else {
					uVar2 = __std_FUN_00499950(*(void **)(param_1 + 0x18),1);
					if (((uVar2 != 0) && (uVar2 = __std_FUN_00499970(piVar1,1), uVar2 != 0)) &&
						 (uVar2 = __std_FUN_00499990(*(FARPROC *)(param_4 + 0x18)), uVar2 != 0)) {
						if ((*param_4 & 4) == 0) {
							__std_FUN_00495d20(*(int *)(param_1 + 0x18),(int *)(param_4 + 8));
							__std_FUN_0048eeb0(piVar1,*(undefined **)(param_4 + 0x18));
						}
						else {
							__std_FUN_00495d20(*(int *)(param_1 + 0x18),(int *)(param_4 + 8));
							__std_FUN_0048eeb0(piVar1,*(undefined **)(param_4 + 0x18));
						}
						goto LAB_00495c80;
					}
				}
			}
			else {
				local_1c = &stack0xffffffd4;
				uVar2 = __std_FUN_00499950(*(void **)(param_1 + 0x18),1);
				if ((uVar2 != 0) && (uVar2 = __std_FUN_00499970(piVar1,1), uVar2 != 0)) {
					__std_FUN_004982c0(piVar1,*(undefined4 **)(param_1 + 0x18),*(uint *)(param_4 + 0x14));
					if ((*(int *)(param_4 + 0x14) == 4) && (*piVar1 != 0)) {
						iVar3 = __std_FUN_00495d20(*piVar1,(int *)(param_4 + 8));
						*piVar1 = iVar3;
					}
					goto LAB_00495c80;
				}
			}
		}
		else {
			local_1c = &stack0xffffffd4;
			uVar2 = __std_FUN_00499950(*(void **)(param_1 + 0x18),1);
			if ((uVar2 != 0) && (uVar2 = __std_FUN_00499970(piVar1,1), uVar2 != 0)) {
				iVar3 = *(int *)(param_1 + 0x18);
				*piVar1 = iVar3;
				iVar3 = __std_FUN_00495d20(iVar3,(int *)(param_4 + 8));
				*piVar1 = iVar3;
				goto LAB_00495c80;
			}
		}
		__std_FUN_00495e30();
	}
LAB_00495c80:
	*in_FS_OFFSET = local_14;
	return;
}



void __cdecl std::internal::__std_FUN_00495ca0(int param_1)
{
	undefined *UNRECOVERED_JUMPTABLE;
	undefined4 *in_FS_OFFSET;
	undefined *local_1c;
	undefined4 local_14;
	undefined *puStack16;
	undefined *puStack12;
	undefined4 local_8;
	
	puStack12 = &DAT_0049fd88;
	puStack16 = &LAB_00496a98;
	local_14 = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_14;
	local_1c = &stack0xffffffd8;
	if ((param_1 != 0) &&
		 (UNRECOVERED_JUMPTABLE = *(undefined **)(*(int *)(param_1 + 0x1c) + 4),
		 UNRECOVERED_JUMPTABLE != (undefined *)0x0)) {
		local_8 = 0;
		__std_FUN_0048eeb0(*(undefined4 *)(param_1 + 0x18),UNRECOVERED_JUMPTABLE);
	}
	*in_FS_OFFSET = local_14;
	return;
}



int __cdecl std::internal::__std_FUN_00495d20(int param_1,int *param_2)
{
	int iVar1;
	int iVar2;
	
	iVar2 = param_1 + *param_2;
	iVar1 = param_2[1];
	if (-1 < iVar1) {
		iVar2 = iVar2 + *(int *)(*(int *)(param_1 + iVar1) + param_2[2]) + iVar1;
	}
	return iVar2;
}



// WARNING: Restarted to delay deadcode elimination for space: stack
// Library Function - Single Match
// Name: __CallSettingFrame@12
// Libraries: Visual Studio 2003 Debug, Visual Studio 2003 Release

void __CallSettingFrame_12(undefined4 param_1,undefined4 param_2,int param_3)
{
	code *pcVar1;
	
	pcVar1 = (code *)__NLG_Notify1(param_3);
	(*pcVar1)();
	if (param_3 == 0x100) {
		param_3 = 2;
	}
	__NLG_Notify1(param_3);
	return;
}



void std::internal::__std_FUN_00495da0(void)
{
	undefined *puVar1;
	undefined4 *in_FS_OFFSET;
	undefined *local_1c;
	undefined4 local_14;
	undefined *puStack16;
	undefined *puStack12;
	undefined4 local_8;
	
	puStack12 = &DAT_0049fd98;
	puStack16 = &LAB_00496a98;
	local_14 = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_14;
	local_1c = &stack0xffffffd8;
	puVar1 = &stack0xffffffd8;
	if (DAT_0054a1a0 != (code *)0x0) {
		local_8 = 1;
		(*DAT_0054a1a0)();
		puVar1 = local_1c;
	}
	local_1c = puVar1;
	local_8 = 0xffffffff;
	__std_calls_abort_FUN_00495e0e();
	*in_FS_OFFSET = local_14;
	return;
}



void std::internal::__std_calls_abort_FUN_00495e0e(void)
{
	abort();
	return;
}



void std::internal::__std_FUN_00495e30(void)
{
	undefined *puVar1;
	undefined4 *in_FS_OFFSET;
	undefined *local_1c;
	undefined4 local_14;
	undefined *puStack16;
	undefined *puStack12;
	undefined4 local_8;
	
	puStack12 = &DAT_0049fdb0;
	puStack16 = &LAB_00496a98;
	local_14 = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_14;
	local_1c = &stack0xffffffd8;
	puVar1 = &stack0xffffffd8;
	if (PTR___std_FUN_004b32a4 != (undefined *)0x0) {
		local_8 = 1;
		(*(code *)PTR___std_FUN_004b32a4)();
		puVar1 = local_1c;
	}
	local_1c = puVar1;
	local_8 = 0xffffffff;
	__std_FUN_00495e9e();
	*in_FS_OFFSET = local_14;
	return;
}



void std::internal::__std_FUN_00495e9e(void)
{
	__std_FUN_00495da0();
	return;
}



BOOL __cdecl std::internal::__entry_cmdline__00496050(int c)
{
	BOOL BVar1;
	
	BVar1 = __entry_cmdline_2__00496070(c,0,4);
	return BVar1;
}



BOOL __cdecl std::internal::__entry_cmdline_2__00496070(int c,uint param_2,byte param_3)
{
	uint uVar1;
	
	if ((*(byte *)((int)&DAT_0054a2b8 + (c & 0xffU) + 1) & param_3) == 0) {
		if (param_2 == 0) {
			uVar1 = 0;
		}
		else {
			uVar1 = std::globals::_wctype[c & 0xffU] & param_2;
		}
		if (uVar1 == 0) {
			return 0;
		}
	}
	return 1;
}



void std::internal::__entry__004960b0(void)
{
	char cVar1;
	char cVar2;
	void **ppvVar3;
	void *pvVar4;
	uint uVar5;
	uint uVar6;
	uint uVar7;
	char *pcVar8;
	int iVar9;
	undefined4 *puVar10;
	char *pcVar11;
	char *pcVar12;
	undefined4 *puVar13;
	void **local_4;
	
	iVar9 = 0;
	cVar2 = *std::globals::__initenv;
	pcVar8 = std::globals::__initenv;
	while (cVar2 != '\0') {
		if (cVar2 != '=') {
			iVar9 = iVar9 + 1;
		}
		uVar5 = 0xffffffff;
		pcVar11 = pcVar8;
		do {
			if (uVar5 == 0) break;
			uVar5 = uVar5 - 1;
			cVar2 = *pcVar11;
			pcVar11 = pcVar11 + 1;
		} while (cVar2 != '\0');
		pcVar11 = pcVar8 + ~uVar5;
		pcVar8 = pcVar8 + ~uVar5;
		cVar2 = *pcVar11;
	}
	ppvVar3 = (void **)malloc(iVar9 * 4 + 4);
	DAT_0054a0f8 = ppvVar3;
	if (ppvVar3 == (void **)0x0) {
		__amsg_exit(9);
	}
	cVar2 = *std::globals::__initenv;
	local_4 = ppvVar3;
	pcVar8 = std::globals::__initenv;
	do {
		if (cVar2 == '\0') {
			free(std::globals::__initenv);
			std::globals::__initenv = (LPSTR)0x0;
			*ppvVar3 = (void *)0x0;
			return;
		}
		uVar5 = 0xffffffff;
		pcVar11 = pcVar8;
		do {
			if (uVar5 == 0) break;
			uVar5 = uVar5 - 1;
			cVar1 = *pcVar11;
			pcVar11 = pcVar11 + 1;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		if (cVar2 != '=') {
			pvVar4 = malloc(uVar5);
			*ppvVar3 = pvVar4;
			if (pvVar4 == (void *)0x0) {
				__amsg_exit(9);
			}
			uVar6 = 0xffffffff;
			pcVar11 = pcVar8;
			do {
				pcVar12 = pcVar11;
				if (uVar6 == 0) break;
				uVar6 = uVar6 - 1;
				pcVar12 = pcVar11 + 1;
				cVar2 = *pcVar11;
				pcVar11 = pcVar12;
			} while (cVar2 != '\0');
			uVar6 = ~uVar6;
			puVar10 = (undefined4 *)(pcVar12 + -uVar6);
			puVar13 = (undefined4 *)*local_4;
			for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
				*puVar13 = *puVar10;
				puVar10 = puVar10 + 1;
				puVar13 = puVar13 + 1;
			}
			ppvVar3 = local_4 + 1;
			for (uVar6 = uVar6 & 3; local_4 = ppvVar3, uVar6 != 0; uVar6 = uVar6 - 1) {
				*(undefined *)puVar13 = *(undefined *)puVar10;
				puVar10 = (undefined4 *)((int)puVar10 + 1);
				puVar13 = (undefined4 *)((int)puVar13 + 1);
			}
		}
		cVar2 = pcVar8[uVar5];
		pcVar8 = pcVar8 + uVar5;
	} while( true );
}



void std::internal::__entry__004961a0(void)
{
	byte **ppbVar1;
	LPSTR *ppCVar2;
	int local_8;
	int local_4;
	
	GetModuleFileNameA((HMODULE)0x0,(LPSTR)&lpFilename_0054a1a8,0x104);
	LPSTR_0054a108 = &lpFilename_0054a1a8;
	ppCVar2 = std::globals::_acmdln;
	if (*(char *)std::globals::_acmdln == '\0') {
		ppCVar2 = &lpFilename_0054a1a8;
	}
	__entry__00496240((byte *)ppCVar2,(byte **)0x0,(byte *)0x0,&local_8,&local_4);
	ppbVar1 = (byte **)malloc(local_4 + local_8 * 4);
	if (ppbVar1 == (byte **)0x0) {
		__amsg_exit(8);
	}
	__entry__00496240((byte *)ppCVar2,ppbVar1,(byte *)(ppbVar1 + local_8),&local_8,&local_4);
	DAT_0054a0ec = local_8 + -1;
	DAT_0054a0f0 = ppbVar1;
	return;
}



void __cdecl
std::internal::__entry__00496240
					(byte *param_1,byte **param_2,byte *param_3,int *param_4,int *param_5)
{
	byte *pbVar1;
	byte bVar2;
	bool bVar3;
	bool bVar4;
	bool bVar5;
	int *piVar6;
	byte *pbVar7;
	uint uVar8;
	
	piVar6 = param_5;
	*param_5 = 0;
	*param_4 = 1;
	if (param_2 != (byte **)0x0) {
		*param_2 = param_3;
		param_2 = param_2 + 1;
	}
	if (*param_1 == 0x22) {
		pbVar7 = param_1 + 1;
		bVar2 = param_1[1];
		while ((bVar2 != 0x22 && (bVar2 != 0))) {
			if (((*(byte *)((int)&DAT_0054a2b8 + bVar2 + 1) & 4) != 0) &&
				 (*param_5 = *param_5 + 1, param_3 != (byte *)0x0)) {
				*param_3 = *pbVar7;
				param_3 = param_3 + 1;
				pbVar7 = pbVar7 + 1;
			}
			*param_5 = *param_5 + 1;
			if (param_3 != (byte *)0x0) {
				*param_3 = *pbVar7;
				param_3 = param_3 + 1;
			}
			pbVar1 = pbVar7 + 1;
			pbVar7 = pbVar7 + 1;
			bVar2 = *pbVar1;
		}
		*param_5 = *param_5 + 1;
		if (param_3 != (byte *)0x0) {
			*param_3 = 0;
			param_3 = param_3 + 1;
		}
		if (*pbVar7 == 0x22) {
			pbVar7 = pbVar7 + 1;
		}
	}
	else {
		do {
			*piVar6 = *piVar6 + 1;
			if (param_3 != (byte *)0x0) {
				*param_3 = *param_1;
				param_3 = param_3 + 1;
			}
			bVar2 = *param_1;
			pbVar7 = param_1 + 1;
			param_5 = (int *)(uint)bVar2;
			if ((*(byte *)((int)param_5 + 0x54a2b9) & 4) != 0) {
				*piVar6 = *piVar6 + 1;
				if (param_3 != (byte *)0x0) {
					*param_3 = *pbVar7;
					param_3 = param_3 + 1;
				}
				pbVar7 = param_1 + 2;
			}
			if (bVar2 == 0x20) break;
			if (bVar2 == 0) goto LAB_00496319;
			param_1 = pbVar7;
		} while (bVar2 != 9);
		if (bVar2 == 0) {
LAB_00496319:
			pbVar7 = pbVar7 + -1;
		}
		else {
			if (param_3 != (byte *)0x0) {
				param_3[-1] = 0;
			}
		}
	}
	bVar4 = false;
	bVar5 = false;
	while (*pbVar7 != 0) {
		for (; (*pbVar7 == 0x20 || (*pbVar7 == 9)); pbVar7 = pbVar7 + 1) {
		}
		if (*pbVar7 == 0) break;
		if (param_2 != (byte **)0x0) {
			*param_2 = param_3;
			param_2 = param_2 + 1;
		}
		*param_4 = *param_4 + 1;
		while( true ) {
			uVar8 = 0;
			bVar3 = true;
			bVar2 = *pbVar7;
			while (bVar2 == 0x5c) {
				pbVar1 = pbVar7 + 1;
				pbVar7 = pbVar7 + 1;
				uVar8 = uVar8 + 1;
				bVar2 = *pbVar1;
			}
			if (*pbVar7 == 0x22) {
				if ((uVar8 & 1) == 0) {
					if ((bVar4) && (pbVar7[1] == 0x22)) {
						pbVar7 = pbVar7 + 1;
					}
					else {
						bVar3 = false;
					}
					bVar4 = !bVar5;
					bVar5 = bVar4;
				}
				uVar8 = uVar8 >> 1;
			}
			for (; uVar8 != 0; uVar8 = uVar8 - 1) {
				if (param_3 != (byte *)0x0) {
					*param_3 = 0x5c;
					param_3 = param_3 + 1;
				}
				*piVar6 = *piVar6 + 1;
			}
			bVar2 = *pbVar7;
			if ((bVar2 == 0) || ((!bVar4 && ((bVar2 == 0x20 || (bVar2 == 9)))))) break;
			if (bVar3) {
				if (param_3 == (byte *)0x0) {
					if ((*(byte *)((int)&DAT_0054a2b8 + bVar2 + 1) & 4) != 0) {
						pbVar7 = pbVar7 + 1;
						*piVar6 = *piVar6 + 1;
					}
					*piVar6 = *piVar6 + 1;
					goto LAB_00496415;
				}
				if ((*(byte *)((int)&DAT_0054a2b8 + bVar2 + 1) & 4) != 0) {
					*param_3 = bVar2;
					param_3 = param_3 + 1;
					pbVar7 = pbVar7 + 1;
					*piVar6 = *piVar6 + 1;
				}
				*param_3 = *pbVar7;
				param_3 = param_3 + 1;
				*piVar6 = *piVar6 + 1;
				pbVar7 = pbVar7 + 1;
			}
			else {
LAB_00496415:
				pbVar7 = pbVar7 + 1;
			}
		}
		if (param_3 != (byte *)0x0) {
			*param_3 = 0;
			param_3 = param_3 + 1;
		}
		*piVar6 = *piVar6 + 1;
	}
	if (param_2 != (byte **)0x0) {
		*param_2 = (byte *)0x0;
	}
	*param_4 = *param_4 + 1;
	return;
}



LPSTR std::internal::__GetEnvironmentStringsA(void)
{
	char cVar1;
	WCHAR WVar2;
	WCHAR *pWVar3;
	int iVar5;
	uint uVar6;
	undefined4 *puVar7;
	uint uVar8;
	undefined4 *puVar9;
	LPWCH lpWideCharStr;
	undefined4 *puVar10;
	undefined4 *puVar11;
	WCHAR *pWVar4;
	
	lpWideCharStr = (LPWCH)0x0;
	puVar9 = (undefined4 *)0x0;
	if (INT_0054a2b0 == 0) {
		lpWideCharStr = GetEnvironmentStringsW();
		if (lpWideCharStr == (LPWCH)0x0) {
			puVar9 = (undefined4 *)GetEnvironmentStrings();
			if (puVar9 == (undefined4 *)0x0) {
				return (LPSTR)(undefined4 *)0x0;
			}
			INT_0054a2b0 = 2;
		}
		else {
			INT_0054a2b0 = 1;
		}
	}
	if (INT_0054a2b0 == 1) {
		if ((lpWideCharStr != (LPWCH)0x0) ||
			 (lpWideCharStr = GetEnvironmentStringsW(), lpWideCharStr != (LPWCH)0x0)) {
			WVar2 = *lpWideCharStr;
			pWVar3 = lpWideCharStr;
			while (WVar2 != L'\0') {
				do {
					pWVar4 = pWVar3;
					pWVar3 = pWVar4 + 1;
				} while (*pWVar3 != L'\0');
				pWVar3 = pWVar4 + 2;
				WVar2 = *pWVar3;
			}
			iVar5 = ((int)((int)pWVar3 - (int)lpWideCharStr) >> 1) + 1;
			uVar6 = WideCharToMultiByte(0,0,lpWideCharStr,iVar5,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0);
			if ((uVar6 != 0) && (puVar9 = (undefined4 *)malloc(uVar6), puVar9 != (undefined4 *)0x0)) {
				iVar5 = WideCharToMultiByte(0,0,lpWideCharStr,iVar5,(LPSTR)puVar9,uVar6,(LPCSTR)0x0,
																		(LPBOOL)0x0);
				if (iVar5 == 0) {
					free(puVar9);
					puVar9 = (undefined4 *)0x0;
				}
				FreeEnvironmentStringsW(lpWideCharStr);
				return (LPSTR)puVar9;
			}
			FreeEnvironmentStringsW(lpWideCharStr);
			return (LPSTR)(undefined4 *)0x0;
		}
	}
	else {
		if ((INT_0054a2b0 == 2) &&
			 ((puVar9 != (undefined4 *)0x0 ||
				(puVar9 = (undefined4 *)GetEnvironmentStrings(), puVar9 != (undefined4 *)0x0)))) {
			cVar1 = *(char *)puVar9;
			puVar7 = puVar9;
			while (cVar1 != '\0') {
				do {
					puVar10 = puVar7;
					puVar7 = (undefined4 *)((int)puVar10 + 1);
				} while (*(char *)((int)puVar10 + 1) != '\0');
				puVar7 = (undefined4 *)((int)puVar10 + 2);
				cVar1 = *(char *)((int)puVar10 + 2);
			}
			uVar6 = (int)puVar7 + (1 - (int)puVar9);
			puVar7 = (undefined4 *)malloc(uVar6);
			if (puVar7 != (undefined4 *)0x0) {
				puVar10 = puVar9;
				puVar11 = puVar7;
				for (uVar8 = uVar6 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {
					*puVar11 = *puVar10;
					puVar10 = puVar10 + 1;
					puVar11 = puVar11 + 1;
				}
				for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
					*(undefined *)puVar11 = *(undefined *)puVar10;
					puVar10 = (undefined4 *)((int)puVar10 + 1);
					puVar11 = (undefined4 *)((int)puVar11 + 1);
				}
				FreeEnvironmentStringsA((LPCH)puVar9);
				return (LPSTR)puVar7;
			}
			FreeEnvironmentStringsA((LPCH)puVar9);
			return (LPSTR)(undefined4 *)0x0;
		}
	}
	return (LPSTR)(undefined4 *)0x0;
}



int __cdecl std::internal::__entry__004965b0(int param_1)
{
	byte *pbVar1;
	byte bVar2;
	byte bVar3;
	UINT CodePage;
	UINT *pUVar4;
	BOOL BVar5;
	uint uVar6;
	uint uVar7;
	int iVar8;
	int iVar9;
	byte *pbVar10;
	byte *pbVar11;
	undefined4 *puVar12;
	_cpinfo local_14;
	
	CodePage = __entry_codepage__004967a0(param_1);
	if (CodePage == DAT_0054a3bc) {
		return 0;
	}
	if (CodePage == 0) {
		__entry__00496850();
		return 0;
	}
	iVar9 = 0;
	pUVar4 = &DAT_004b3338;
	do {
		if (*pUVar4 == CodePage) {
			puVar12 = &DAT_0054a2b8;
			for (iVar8 = 0x40; iVar8 != 0; iVar8 = iVar8 + -1) {
				*puVar12 = 0;
				puVar12 = puVar12 + 1;
			}
			*(undefined *)puVar12 = 0;
			uVar6 = 0;
			pbVar10 = &DAT_004b3348 + iVar9 * 0x30;
			do {
				bVar2 = *pbVar10;
				for (pbVar11 = pbVar10; (bVar2 != 0 && (bVar2 = pbVar11[1], bVar2 != 0));
						pbVar11 = pbVar11 + 2) {
					uVar7 = (uint)*pbVar11;
					if (uVar7 <= bVar2) {
						bVar3 = (&DAT_004b3330)[uVar6];
						do {
							pbVar1 = (byte *)((int)&DAT_0054a2b8 + uVar7 + 1);
							*pbVar1 = *pbVar1 | bVar3;
							uVar7 = uVar7 + 1;
						} while (uVar7 <= bVar2);
					}
					bVar2 = pbVar11[2];
				}
				uVar6 = uVar6 + 1;
				pbVar10 = pbVar10 + 8;
			} while (uVar6 < 4);
			DAT_0054a3bc = CodePage;
			DAT_0054a3c0 = __entry__004967f0(CodePage);
			DAT_0054a3c8 = (&DAT_004b333c)[iVar9 * 0xc];
			DAT_0054a3cc = (&DAT_004b3340)[iVar9 * 0xc];
			DAT_0054a3d0 = (&DAT_004b3344)[iVar9 * 0xc];
			return 0;
		}
		pUVar4 = pUVar4 + 0xc;
		iVar9 = iVar9 + 1;
	} while (pUVar4 < &DAT_004b3428);
	BVar5 = GetCPInfo(CodePage,(LPCPINFO)&local_14);
	if (BVar5 != 1) {
		if (DAT_0054a3d4 == 0) {
			return -1;
		}
		__entry__00496850();
		return 0;
	}
	puVar12 = &DAT_0054a2b8;
	for (iVar9 = 0x40; iVar9 != 0; iVar9 = iVar9 + -1) {
		*puVar12 = 0;
		puVar12 = puVar12 + 1;
	}
	*(undefined *)puVar12 = 0;
	if (local_14.MaxCharSize < 2) {
		DAT_0054a3bc = 0;
		DAT_0054a3c0 = 0;
	}
	else {
		if (local_14.LeadByte[0] != '\0') {
			pbVar10 = local_14.LeadByte + 1;
			do {
				bVar2 = *pbVar10;
				if (bVar2 == 0) break;
				for (uVar6 = (uint)pbVar10[-1]; uVar6 <= bVar2; uVar6 = uVar6 + 1) {
					*(byte *)((int)&DAT_0054a2b8 + uVar6 + 1) = *(byte *)((int)&DAT_0054a2b8 + uVar6 + 1) | 4;
				}
				pbVar11 = pbVar10 + 1;
				pbVar10 = pbVar10 + 2;
			} while (*pbVar11 != 0);
		}
		uVar6 = 1;
		do {
			*(byte *)((int)&DAT_0054a2b8 + uVar6 + 1) = *(byte *)((int)&DAT_0054a2b8 + uVar6 + 1) | 8;
			uVar6 = uVar6 + 1;
		} while (uVar6 < 0xff);
		DAT_0054a3bc = CodePage;
		DAT_0054a3c0 = __entry__004967f0(CodePage);
	}
	DAT_0054a3c8 = 0;
	DAT_0054a3cc = 0;
	DAT_0054a3d0 = 0;
	return 0;
}



UINT __cdecl std::internal::__entry_codepage__004967a0(int param_1)
{
	UINT UVar1;
	bool bVar2;
	
	if (param_1 == -2) {
		DAT_0054a3d4 = 1;
										// WARNING: Could not recover jumptable at 0x004967bd. Too many branches
										// WARNING: Treating indirect jump as call
		UVar1 = GetOEMCP();
		return UVar1;
	}
	if (param_1 == -3) {
		DAT_0054a3d4 = 1;
										// WARNING: Could not recover jumptable at 0x004967d2. Too many branches
										// WARNING: Treating indirect jump as call
		UVar1 = GetACP();
		return UVar1;
	}
	bVar2 = param_1 == -4;
	if (bVar2) {
		param_1 = DAT_0054a190;
	}
	DAT_0054a3d4 = (uint)bVar2;
	return param_1;
}



undefined4 __cdecl std::internal::__entry__004967f0(undefined4 param_1)
{
	switch(param_1) {
	case 0x3a4:
		return 0x411;
	default:
		return 0;
	case 0x3a8:
		return 0x804;
	case 0x3b5:
		return 0x412;
	case 0x3b6:
		return 0x404;
	}
}



void std::internal::__entry__00496850(void)
{
	int iVar1;
	undefined4 *puVar2;
	
	puVar2 = &DAT_0054a2b8;
	for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {
		*puVar2 = 0;
		puVar2 = puVar2 + 1;
	}
	*(undefined *)puVar2 = 0;
	DAT_0054a3bc = 0;
	DAT_0054a3c0 = 0;
	DAT_0054a3c8 = 0;
	DAT_0054a3cc = 0;
	DAT_0054a3d0 = 0;
	return;
}



int std::internal::__entry__00496880(void)
{
	int iVar1;
	
	iVar1 = __entry__004965b0(-3);
	return iVar1;
}



void std::internal::__entry__00496890(void)
{
	byte bVar1;
	undefined4 *puVar2;
	DWORD DVar3;
	HANDLE hFile;
	int iVar4;
	HANDLE *ppvVar5;
	int *piVar6;
	uint uVar7;
	uint local_48;
	_STARTUPINFOA local_44;
	
	puVar2 = (undefined4 *)malloc(0x100);
	if (puVar2 == (undefined4 *)0x0) {
		__amsg_exit(0x1b);
	}
	globals::__UINT_0076eec0 = 0x20;
	DAT_0076edc0 = puVar2;
	if (puVar2 < puVar2 + 0x40) {
		do {
			*(undefined *)(puVar2 + 1) = 0;
			*puVar2 = 0xffffffff;
			*(undefined *)((int)puVar2 + 5) = 10;
			puVar2 = puVar2 + 2;
		} while (puVar2 < DAT_0076edc0 + 0x40);
	}
	GetStartupInfoA((LPSTARTUPINFOA)&local_44);
	if ((local_44.cbReserved2 != 0) && ((uint *)local_44.lpReserved2 != (uint *)0x0)) {
		local_48 = *(uint *)local_44.lpReserved2;
		local_44.lpReserved2 = (LPBYTE)((int)local_44.lpReserved2 + 4);
		ppvVar5 = (HANDLE *)((int)local_44.lpReserved2 + local_48);
		if (0x7ff < (int)local_48) {
			local_48 = 0x800;
		}
		if ((int)globals::__UINT_0076eec0 < (int)local_48) {
			piVar6 = &DAT_0076edc4;
			do {
				puVar2 = (undefined4 *)malloc(0x100);
				if (puVar2 == (undefined4 *)0x0) {
					local_48 = globals::__UINT_0076eec0;
					break;
				}
				*piVar6 = (int)puVar2;
				globals::__UINT_0076eec0 = globals::__UINT_0076eec0 + 0x20;
				if (puVar2 < puVar2 + 0x40) {
					do {
						*(undefined *)(puVar2 + 1) = 0;
						*puVar2 = 0xffffffff;
						*(undefined *)((int)puVar2 + 5) = 10;
						puVar2 = puVar2 + 2;
					} while (puVar2 < (undefined4 *)(*piVar6 + 0x100));
				}
				piVar6 = piVar6 + 1;
			} while ((int)globals::__UINT_0076eec0 < (int)local_48);
		}
		uVar7 = 0;
		if (0 < (int)local_48) {
			do {
				if (((*ppvVar5 != (HANDLE)0xffffffff) && ((*local_44.lpReserved2 & 1) != 0)) &&
					 (((*local_44.lpReserved2 & 8) != 0 || (DVar3 = GetFileType(*ppvVar5), DVar3 != 0)))) {
					iVar4 = (int)(&DAT_0076edc0)[(int)uVar7 >> 5];
					*(HANDLE *)(iVar4 + (uVar7 & 0x1f) * 8) = *ppvVar5;
					*(BYTE *)(iVar4 + (uVar7 & 0x1f) * 8 + 4) = *local_44.lpReserved2;
				}
				uVar7 = uVar7 + 1;
				local_44.lpReserved2 = (LPBYTE)((int)local_44.lpReserved2 + 1);
				ppvVar5 = ppvVar5 + 1;
			} while ((int)uVar7 < (int)local_48);
		}
	}
	iVar4 = 0;
	do {
		ppvVar5 = (HANDLE *)(DAT_0076edc0 + iVar4 * 2);
		if (DAT_0076edc0[iVar4 * 2] == -1) {
			*(undefined *)(ppvVar5 + 1) = 0x81;
			if (iVar4 == 0) {
				DVar3 = 0xfffffff6;
			}
			else {
				DVar3 = 0xfffffff5 - (iVar4 != 1);
			}
			hFile = GetStdHandle(DVar3);
			if ((hFile == (HANDLE)0xffffffff) || (DVar3 = GetFileType(hFile), DVar3 == 0)) {
				bVar1 = *(byte *)(ppvVar5 + 1) | 0x40;
				goto LAB_00496a6b;
			}
			*ppvVar5 = hFile;
			if ((DVar3 & 0xff) == 2) {
				bVar1 = *(byte *)(ppvVar5 + 1) | 0x40;
				goto LAB_00496a6b;
			}
			if ((DVar3 & 0xff) == 3) {
				bVar1 = *(byte *)(ppvVar5 + 1) | 8;
				goto LAB_00496a6b;
			}
		}
		else {
			bVar1 = *(byte *)(ppvVar5 + 1) | 0x80;
LAB_00496a6b:
			*(byte *)(ppvVar5 + 1) = bVar1;
		}
		iVar4 = iVar4 + 1;
		if (2 < iVar4) {
			SetHandleCount(globals::__UINT_0076eec0);
			return;
		}
	} while( true );
}



void std::internal::__std_FUN_00496b55(int param_1)
{
	__local_unwind2(*(int *)(param_1 + 0x18),*(int *)(param_1 + 0x1c));
	return;
}



void std::internal::__std_FUN_00496b70(void)
{
	if ((DAT_0054a124 == 1) || ((DAT_0054a124 == 0 && (DAT_004b0d64 == 1)))) {
		__std_FUN_00496bb0(0xfc);
		if (DAT_0054a3d8 != (code *)0x0) {
			(*DAT_0054a3d8)();
		}
		__std_FUN_00496bb0(0xff);
	}
	return;
}



void __cdecl std::internal::__std_FUN_00496bb0(int param_1)
{
	char cVar1;
	uint (*pauVar2) [2];
	DWORD DVar3;
	HANDLE hFile;
	int iVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	int iVar8;
	undefined4 *puVar9;
	undefined4 *puVar10;
	char *pcVar11;
	char *pcVar12;
	DWORD local_1a8;
	undefined4 local_1a4 [25];
	undefined4 auStack320 [15];
	undefined4 local_104;
	
	pauVar2 = (uint (*) [2])&DAT_004b3430;
	iVar8 = 0;
	do {
		if (param_1 == (*pauVar2)[0]) break;
		pauVar2 = pauVar2[1];
		iVar8 = iVar8 + 1;
	} while (pauVar2 < globals::__errorArray_004b34c0);
	if (param_1 == (&DAT_004b3430)[iVar8 * 2]) {
		if ((DAT_0054a124 == 1) || ((DAT_0054a124 == 0 && (DAT_004b0d64 == 1)))) {
			if ((DAT_0076edc0 == 0) ||
				 (hFile = *(HANDLE *)(DAT_0076edc0 + 0x10), hFile == (HANDLE)0xffffffff)) {
				hFile = GetStdHandle(0xfffffff4);
			}
			pcVar11 = *(char **)(iVar8 * 8 + 0x4b3434);
			uVar5 = 0xffffffff;
			pcVar12 = pcVar11;
			do {
				if (uVar5 == 0) break;
				uVar5 = uVar5 - 1;
				cVar1 = *pcVar12;
				pcVar12 = pcVar12 + 1;
			} while (cVar1 != '\0');
			WriteFile(hFile,pcVar11,~uVar5 - 1,&local_1a8,(LPOVERLAPPED)0x0);
		}
		else {
			if (param_1 != 0xfc) {
				DVar3 = GetModuleFileNameA((HMODULE)0x0,(LPSTR)&local_104,0x104);
				if (DVar3 == 0) {
					puVar7 = (undefined4 *)"<program name unknown>";
					puVar9 = &local_104;
					for (iVar4 = 5; iVar4 != 0; iVar4 = iVar4 + -1) {
						*puVar9 = *puVar7;
						puVar7 = puVar7 + 1;
						puVar9 = puVar9 + 1;
					}
					*(undefined2 *)puVar9 = *(undefined2 *)puVar7;
					*(undefined *)((int)puVar9 + 2) = *(undefined *)((int)puVar7 + 2);
				}
				uVar5 = 0xffffffff;
				puVar7 = &local_104;
				puVar9 = &local_104;
				do {
					if (uVar5 == 0) break;
					uVar5 = uVar5 - 1;
					cVar1 = *(char *)puVar9;
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				} while (cVar1 != '\0');
				if (0x3c < ~uVar5) {
					uVar5 = 0xffffffff;
					puVar7 = &local_104;
					do {
						if (uVar5 == 0) break;
						uVar5 = uVar5 - 1;
						cVar1 = *(char *)puVar7;
						puVar7 = (undefined4 *)((int)puVar7 + 1);
					} while (cVar1 != '\0');
					puVar7 = (undefined4 *)((int)auStack320 + ~uVar5);
					_strncpy((char *)puVar7,"...",3);
				}
				puVar9 = (undefined4 *)"Runtime Error!\n\nProgram: ";
				puVar10 = local_1a4;
				for (iVar4 = 6; iVar4 != 0; iVar4 = iVar4 + -1) {
					*puVar10 = *puVar9;
					puVar9 = puVar9 + 1;
					puVar10 = puVar10 + 1;
				}
				*(undefined2 *)puVar10 = *(undefined2 *)puVar9;
				uVar5 = 0xffffffff;
				do {
					puVar9 = puVar7;
					if (uVar5 == 0) break;
					uVar5 = uVar5 - 1;
					puVar9 = (undefined4 *)((int)puVar7 + 1);
					cVar1 = *(char *)puVar7;
					puVar7 = puVar9;
				} while (cVar1 != '\0');
				uVar5 = ~uVar5;
				iVar4 = -1;
				puVar7 = local_1a4;
				do {
					puVar10 = puVar7;
					if (iVar4 == 0) break;
					iVar4 = iVar4 + -1;
					puVar10 = (undefined4 *)((int)puVar7 + 1);
					cVar1 = *(char *)puVar7;
					puVar7 = puVar10;
				} while (cVar1 != '\0');
				puVar7 = (undefined4 *)((int)puVar9 - uVar5);
				puVar9 = (undefined4 *)((int)puVar10 + -1);
				for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
					*puVar9 = *puVar7;
					puVar7 = puVar7 + 1;
					puVar9 = puVar9 + 1;
				}
				for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
					*(undefined *)puVar9 = *(undefined *)puVar7;
					puVar7 = (undefined4 *)((int)puVar7 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				uVar5 = 0xffffffff;
				pcVar11 = "\n\n";
				do {
					pcVar12 = pcVar11;
					if (uVar5 == 0) break;
					uVar5 = uVar5 - 1;
					pcVar12 = pcVar11 + 1;
					cVar1 = *pcVar11;
					pcVar11 = pcVar12;
				} while (cVar1 != '\0');
				uVar5 = ~uVar5;
				iVar4 = -1;
				puVar7 = local_1a4;
				do {
					puVar9 = puVar7;
					if (iVar4 == 0) break;
					iVar4 = iVar4 + -1;
					puVar9 = (undefined4 *)((int)puVar7 + 1);
					cVar1 = *(char *)puVar7;
					puVar7 = puVar9;
				} while (cVar1 != '\0');
				puVar7 = (undefined4 *)(pcVar12 + -uVar5);
				puVar9 = (undefined4 *)((int)puVar9 + -1);
				for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
					*puVar9 = *puVar7;
					puVar7 = puVar7 + 1;
					puVar9 = puVar9 + 1;
				}
				for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
					*(undefined *)puVar9 = *(undefined *)puVar7;
					puVar7 = (undefined4 *)((int)puVar7 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				uVar5 = 0xffffffff;
				pcVar11 = *(char **)(iVar8 * 8 + 0x4b3434);
				do {
					pcVar12 = pcVar11;
					if (uVar5 == 0) break;
					uVar5 = uVar5 - 1;
					pcVar12 = pcVar11 + 1;
					cVar1 = *pcVar11;
					pcVar11 = pcVar12;
				} while (cVar1 != '\0');
				uVar5 = ~uVar5;
				iVar8 = -1;
				puVar7 = local_1a4;
				do {
					puVar9 = puVar7;
					if (iVar8 == 0) break;
					iVar8 = iVar8 + -1;
					puVar9 = (undefined4 *)((int)puVar7 + 1);
					cVar1 = *(char *)puVar7;
					puVar7 = puVar9;
				} while (cVar1 != '\0');
				puVar7 = (undefined4 *)(pcVar12 + -uVar5);
				puVar9 = (undefined4 *)((int)puVar9 + -1);
				for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
					*puVar9 = *puVar7;
					puVar7 = puVar7 + 1;
					puVar9 = puVar9 + 1;
				}
				for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
					*(undefined *)puVar9 = *(undefined *)puVar7;
					puVar7 = (undefined4 *)((int)puVar7 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				__std_FUN_004999f0(local_1a4,"Microsoft Visual C++ Runtime Library",0x12010);
				return;
			}
		}
	}
	return;
}



LCID __cdecl
std::internal::__ctype_internal
					(DWORD param_1,LPCSTR param_2,int param_3,LPWORD param_4,UINT param_5,LCID param_6)
{
	BOOL BVar1;
	LCID LVar2;
	int iVar3;
	int *lpWideCharStr;
	WORD local_2;
	
	lpWideCharStr = (int *)0x0;
	if (DAT_0054a3e0 == 0) {
		BVar1 = GetStringTypeA(0,1,(LPCSTR)&lpSrcStr_0049fd38,1,&local_2);
		if (BVar1 == 0) {
			BVar1 = GetStringTypeW(1,(LPCWSTR)&lpSrcStr_0049fd3c,1,&local_2);
			if (BVar1 == 0) {
				return 0;
			}
			DAT_0054a3e0 = 1;
		}
		else {
			DAT_0054a3e0 = 2;
		}
	}
	if (DAT_0054a3e0 == 2) {
		if (param_6 == 0) {
			param_6 = DAT_0054a180;
		}
		LVar2 = GetStringTypeA(param_6,param_1,param_2,param_3,param_4);
		return LVar2;
	}
	param_6 = DAT_0054a3e0;
	if (DAT_0054a3e0 == 1) {
		param_6 = 0;
		if (param_5 == 0) {
			param_5 = DAT_0054a190;
		}
		iVar3 = MultiByteToWideChar(param_5,9,param_2,param_3,(LPWSTR)0x0,0);
		if (iVar3 != 0) {
			lpWideCharStr = __std_FUN_00499a80(2,iVar3);
			if (lpWideCharStr != (int *)0x0) {
				iVar3 = MultiByteToWideChar(param_5,1,param_2,param_3,(LPWSTR)lpWideCharStr,iVar3);
				if (iVar3 != 0) {
					LVar2 = GetStringTypeW(param_1,(LPCWSTR)lpWideCharStr,iVar3,param_4);
					free(lpWideCharStr);
					return LVar2;
				}
			}
		}
		free(lpWideCharStr);
	}
	return param_6;
}



DWORD __cdecl std::internal::__fdread__00496ec0(uint param_1,LONG param_2,DWORD param_3)
{
	HANDLE hFile;
	DWORD DVar1;
	uint error_value;
	int iVar2;
	
	if (param_1 < globals::__UINT_0076eec0) {
		iVar2 = (param_1 & 0x1f) * 8;
		if ((*(byte *)((&DAT_0076edc0)[(int)param_1 >> 5] + 4 + iVar2) & 1) != 0) {
			hFile = (HANDLE)__fdunk__004994b0(param_1);
			if (hFile == (HANDLE)0xffffffff) {
				std::globals::g_msvc_errno = 9;
				return 0xffffffff;
			}
			DVar1 = SetFilePointer(hFile,param_2,(PLONG)0x0,param_3);
			if (DVar1 == 0xffffffff) {
				error_value = GetLastError();
			}
			else {
				error_value = 0;
			}
			if (error_value != 0) {
				__set_doserrno(error_value);
				return 0xffffffff;
			}
			*(byte *)((&DAT_0076edc0)[(int)param_1 >> 5] + 4 + iVar2) =
					 *(byte *)((&DAT_0076edc0)[(int)param_1 >> 5] + 4 + iVar2) & 0xfd;
			return DVar1;
		}
	}
	std::globals::g_msvc_errno = 9;
	std::globals::g_msvc_doserrno = 0;
	return 0xffffffff;
}



int __cdecl std::internal::__fdwrite__00496f80(uint param_1,char *param_2,char *param_3)
{
	int *piVar1;
	byte bVar2;
	char cVar3;
	char *pcVar4;
	BOOL BVar5;
	int iVar6;
	char *pcVar7;
	DWORD local_41c;
	DWORD local_414;
	DWORD local_410;
	int local_40c;
	int *local_408;
	char local_404 [1028];
	
	if (param_1 < globals::__UINT_0076eec0) {
		piVar1 = &DAT_0076edc0 + ((int)param_1 >> 5);
		iVar6 = (param_1 & 0x1f) * 8;
		bVar2 = *(byte *)(iVar6 + 4 + (&DAT_0076edc0)[(int)param_1 >> 5]);
		if ((bVar2 & 1) != 0) {
			local_41c = 0;
			local_40c = 0;
			if (param_3 == (char *)0x0) {
				return 0;
			}
			local_408 = piVar1;
			if ((bVar2 & 0x20) != 0) {
				__fdread__00496ec0(param_1,0,2);
			}
			if ((*(byte *)((HANDLE *)(*piVar1 + iVar6) + 1) & 0x80) == 0) {
				BVar5 = WriteFile(*(HANDLE *)(*piVar1 + iVar6),param_2,(DWORD)param_3,&local_410,
													(LPOVERLAPPED)0x0);
				if (BVar5 == 0) {
					local_414 = GetLastError();
				}
				else {
					local_41c = local_410;
					local_414 = 0;
				}
			}
			else {
				local_414 = 0;
				pcVar7 = param_2;
				if (param_3 != (char *)0x0) {
					do {
						pcVar4 = local_404;
						do {
							if (param_3 <= pcVar7 + -(int)param_2) break;
							cVar3 = *pcVar7;
							pcVar7 = pcVar7 + 1;
							if (cVar3 == '\n') {
								*pcVar4 = '\r';
								local_40c = local_40c + 1;
								pcVar4 = pcVar4 + 1;
							}
							*pcVar4 = cVar3;
							pcVar4 = pcVar4 + 1;
						} while ((int)(pcVar4 + -(int)local_404) < 0x400);
						BVar5 = WriteFile(*(HANDLE *)(iVar6 + *local_408),local_404,
															(DWORD)(pcVar4 + -(int)local_404),&local_410,(LPOVERLAPPED)0x0);
						if (BVar5 == 0) {
							local_414 = GetLastError();
							break;
						}
						local_41c = local_41c + local_410;
						if (((int)local_410 < (int)(pcVar4 + -(int)local_404)) ||
							 (param_3 <= pcVar7 + -(int)param_2)) break;
					} while( true );
				}
			}
			if (local_41c != 0) {
				return local_41c - local_40c;
			}
			if (local_414 == 0) {
				if (((*(byte *)(iVar6 + 4 + *local_408) & 0x40) != 0) && (*param_2 == '\x1a')) {
					return 0;
				}
				std::globals::g_msvc_errno = 0x1c;
				std::globals::g_msvc_doserrno = 0;
				return -1;
			}
			if (local_414 == 5) {
				std::globals::g_msvc_errno = 9;
				std::globals::g_msvc_doserrno = local_414;
				return -1;
			}
			__set_doserrno(local_414);
			return -1;
		}
	}
	std::globals::g_msvc_errno = 9;
	std::globals::g_msvc_doserrno = 0;
	return -1;
}



void __cdecl std::internal::__set_doserrno(uint error_value)
{
	uint (*pauVar1) [2];
	int iVar2;
	
	iVar2 = 0;
	pauVar1 = globals::__errorArray_004b34c0;
	do {
		if (error_value == (*pauVar1)[0]) {
			std::globals::g_msvc_errno = globals::__errorArray_004b34c0[iVar2][1];
			std::globals::g_msvc_doserrno = error_value;
			return;
		}
		pauVar1 = pauVar1[1];
		iVar2 = iVar2 + 1;
	} while (pauVar1 < &PTR_DAT_004b3628);
	if ((0x12 < error_value) && (error_value < 0x25)) {
		std::globals::g_msvc_errno = EACCES;
		std::globals::g_msvc_doserrno = error_value;
		return;
	}
	if ((error_value < 0xbc) || (std::globals::g_msvc_errno = ENOEXEC, 0xca < error_value)) {
		std::globals::g_msvc_errno = EINVAL;
	}
	std::globals::g_msvc_doserrno = error_value;
	return;
}



int __cdecl
std::internal::__unkftime__00497210
					(int param_1,int param_2,int param_3,int param_4,int param_5,int param_6,int param_7)
{
	int iVar1;
	uint uVar2;
	int local_24 [2];
	int local_1c;
	int local_14;
	uint local_10;
	int local_8;
	
	local_10 = param_1 - 0x76c;
	if (((int)local_10 < 0x46) || (0x8a < (int)local_10)) {
		return -1;
	}
	local_8 = *(int *)(&DAT_004b39dc + param_2 * 4) + param_3;
	if (((local_10 & 3) == 0) && (2 < param_2)) {
		local_8 = local_8 + 1;
	}
	__unkftime__00499b20();
	local_1c = param_4;
	local_14 = param_2 + -1;
	iVar1 = param_6 + (param_5 +
										(param_4 + ((param_1 + -0x76d >> 2) + local_10 * 0x16d + local_8) * 0x18) * 0x3c
										) * 0x3c + 0x7c558180 + DAT_004b38f0;
	if (param_7 != 1) {
		if (param_7 != -1) {
			return iVar1;
		}
		if (DAT_004b38f4 == 0) {
			return iVar1;
		}
		uVar2 = __unkftime__00499df0(local_24);
		if (uVar2 == 0) {
			return iVar1;
		}
	}
	return iVar1 + DAT_004b38f8;
}



int __cdecl std::internal::__fpeekc(FILE *file)
{
	byte bVar1;
	uint uVar2;
	char *pcVar3;
	undefined *puVar4;
	
	uVar2 = file->_flag;
	if (((uVar2 & 0x83) != 0) && ((uVar2 & 0x40) == 0)) {
		if ((uVar2 & 2) != 0) {
			file->_flag = uVar2 | 0x20;
			return 0xffffffff;
		}
		file->_flag = uVar2 | 1;
		if ((uVar2 & 0x10c) == 0) {
			__fileunk__00498da0(file);
		}
		else {
			file->_ptr = file->_base;
		}
		pcVar3 = __fdread(file->_file,file->_base,file->_bufsiz);
		file->_cnt = (int)pcVar3;
		if ((pcVar3 != (char *)0x0) && (pcVar3 != (char *)0xffffffff)) {
			if ((file->_flag & 0x82U) == 0) {
				uVar2 = file->_file;
				if (uVar2 == 0xffffffff) {
					puVar4 = &DAT_004b3428;
				}
				else {
					puVar4 = (undefined *)((&DAT_0076edc0)[(int)uVar2 >> 5] + (uVar2 & 0x1f) * 8);
				}
				if ((puVar4[4] & 0x82) == 0x82) {
					file->_flag = file->_flag | 0x2000;
				}
			}
			if (((file->_bufsiz == 0x200) && ((file->_flag & 8U) != 0)) && ((file->_flag & 0x400U) == 0))
			{
				file->_bufsiz = 0x1000;
			}
			file->_cnt = (int)(pcVar3 + -1);
			bVar1 = *file->_ptr;
			file->_ptr = file->_ptr + 1;
			return (uint)bVar1;
		}
		file->_cnt = 0;
		file->_flag = file->_flag | (-(uint)(pcVar3 != (char *)0x0) & 0x10) + 0x10;
	}
	return 0xffffffff;
}



char * __cdecl std::internal::__fdread(uint fd,char *param_2,DWORD param_3)
{
	int *piVar1;
	char cVar2;
	byte bVar3;
	BOOL BVar4;
	DWORD DVar5;
	int iVar6;
	int iVar7;
	char *pcVar8;
	char *pcVar9;
	DWORD local_c;
	int *local_8;
	char *local_4;
	
	if (fd < globals::__UINT_0076eec0) {
		iVar6 = (fd & 0x1f) * 8;
		piVar1 = &DAT_0076edc0 + ((int)fd >> 5);
		local_c = iVar6 + (&DAT_0076edc0)[(int)fd >> 5];
		bVar3 = *(byte *)(local_c + 4);
		if ((bVar3 & 1) != 0) {
			iVar7 = 0;
			if ((param_3 == 0) || ((bVar3 & 2) != 0)) {
				return (char *)0x0;
			}
			pcVar8 = param_2;
			DVar5 = param_3;
			if (((bVar3 & 0x48) != 0) && (*(char *)(local_c + 5) != '\n')) {
				*param_2 = *(char *)(local_c + 5);
				pcVar8 = param_2 + 1;
				iVar7 = 1;
				DVar5 = param_3 - 1;
				*(undefined *)(iVar6 + 5 + *piVar1) = 10;
			}
			local_8 = piVar1;
			BVar4 = ReadFile(*(HANDLE *)(iVar6 + *piVar1),pcVar8,DVar5,&local_c,(LPOVERLAPPED)0x0);
			if (BVar4 == 0) {
				DVar5 = GetLastError();
				if (DVar5 == 5) {
					std::globals::g_msvc_errno = 9;
					std::globals::g_msvc_doserrno = DVar5;
					return (char *)0xffffffff;
				}
				if (DVar5 == 0x6d) {
					return (char *)0x0;
				}
				__set_doserrno(DVar5);
				return (char *)0xffffffff;
			}
			local_4 = (char *)(iVar7 + local_c);
			bVar3 = *(byte *)(iVar6 + 4 + *piVar1);
			if ((bVar3 & 0x80) != 0) {
				if ((local_c == 0) || (*param_2 != '\n')) {
					bVar3 = bVar3 & 0xfb;
				}
				else {
					bVar3 = bVar3 | 4;
				}
				*(byte *)(iVar6 + 4 + *piVar1) = bVar3;
				local_4 = local_4 + (int)param_2;
				pcVar8 = param_2;
				pcVar9 = param_2;
				if (param_2 < local_4) {
					while (cVar2 = *pcVar9, cVar2 != '\x1a') {
						if (cVar2 == '\r') {
							if (pcVar9 < local_4 + -1) {
								if (pcVar9[1] == '\n') {
									pcVar9 = pcVar9 + 2;
									*pcVar8 = '\n';
									goto LAB_004975d8;
								}
								*pcVar8 = '\r';
								pcVar8 = pcVar8 + 1;
								pcVar9 = pcVar9 + 1;
							}
							else {
								DVar5 = 0;
								pcVar9 = pcVar9 + 1;
								BVar4 = ReadFile(*(HANDLE *)(iVar6 + *local_8),&param_3,1,&local_c,(LPOVERLAPPED)0x0
																);
								if (BVar4 == 0) {
									DVar5 = GetLastError();
								}
								if ((DVar5 == 0) && (local_c != 0)) {
									if ((*(byte *)(iVar6 + 4 + *local_8) & 0x48) == 0) {
										if ((pcVar8 == param_2) && ((char)param_3 == '\n')) {
											*pcVar8 = '\n';
											goto LAB_004975d8;
										}
										__fdread__00496ec0(fd,-1,1);
										if ((char)param_3 != '\n') goto LAB_004975d5;
									}
									else {
										if ((char)param_3 == '\n') {
											*pcVar8 = '\n';
											goto LAB_004975d8;
										}
										*pcVar8 = '\r';
										pcVar8 = pcVar8 + 1;
										*(char *)(iVar6 + 5 + *local_8) = (char)param_3;
									}
								}
								else {
LAB_004975d5:
									*pcVar8 = '\r';
LAB_004975d8:
									pcVar8 = pcVar8 + 1;
								}
							}
						}
						else {
							*pcVar8 = cVar2;
							pcVar8 = pcVar8 + 1;
							pcVar9 = pcVar9 + 1;
						}
						if (local_4 <= pcVar9) {
							return pcVar8 + -(int)param_2;
						}
					}
					bVar3 = *(byte *)(iVar6 + 4 + *local_8);
					if ((bVar3 & 0x40) == 0) {
						*(byte *)(iVar6 + 4 + *local_8) = bVar3 | 2;
					}
				}
				local_4 = pcVar8 + -(int)param_2;
			}
			return local_4;
		}
	}
	std::globals::g_msvc_errno = 9;
	std::globals::g_msvc_doserrno = 0;
	return (char *)0xffffffff;
}



int __cdecl std::internal::__std_FUN_00497650(uint param_1)
{
	HANDLE hFile;
	BOOL BVar1;
	uint uVar2;
	
	uVar2 = std::globals::g_msvc_doserrno;
	if ((param_1 < globals::__UINT_0076eec0) &&
		 ((*(byte *)((&DAT_0076edc0)[(int)param_1 >> 5] + 4 + (param_1 & 0x1f) * 8) & 1) != 0)) {
		hFile = (HANDLE)__fdunk__004994b0(param_1);
		BVar1 = FlushFileBuffers(hFile);
		if (BVar1 == 0) {
			uVar2 = GetLastError();
		}
		else {
			uVar2 = 0;
		}
		if (uVar2 == 0) {
			return 0;
		}
	}
	std::globals::g_msvc_doserrno = uVar2;
	std::globals::g_msvc_errno = 9;
	return -1;
}



void std::internal::__std_FUN_004976b0(void)
{
	uint uVar1;
	undefined **ppuVar2;
	int iVar3;
	undefined4 *puVar4;
	
	if (globals::__filesCount_0076eda0 == 0) {
		globals::__filesCount_0076eda0 = 0x200;
	}
	else {
		if (globals::__filesCount_0076eda0 < 0x14) {
			globals::__filesCount_0076eda0 = 0x14;
		}
	}
	globals::__filesTable_0076dd98 = (FILE **)__std_FUN_00499a80(globals::__filesCount_0076eda0,4);
	if (globals::__filesTable_0076dd98 == (FILE **)0x0) {
		globals::__filesCount_0076eda0 = 0x14;
		globals::__filesTable_0076dd98 = (FILE **)__std_FUN_00499a80(0x14,4);
		if (globals::__filesTable_0076dd98 == (FILE **)0x0) {
			__amsg_exit(0x1a);
		}
	}
	iVar3 = 0;
	ppuVar2 = &PTR_DAT_004b3628;
	do {
		*(undefined ***)((int)globals::__filesTable_0076dd98 + iVar3) = ppuVar2;
		ppuVar2 = ppuVar2 + 8;
		iVar3 = iVar3 + 4;
	} while ((int)ppuVar2 < 0x4b38a8);
	uVar1 = 0;
	puVar4 = &DAT_004b3638;
	do {
		iVar3 = *(int *)((&DAT_0076edc0)[(int)uVar1 >> 5] + (uVar1 & 0x1f) * 8);
		if ((iVar3 == -1) || (iVar3 == 0)) {
			*puVar4 = 0xffffffff;
		}
		puVar4 = puVar4 + 8;
		uVar1 = uVar1 + 1;
	} while ((int)puVar4 < 0x4b3698);
	return;
}



uint std::internal::__std_FUN_00497770(void)
{
	FILE *stream;
	uint uVar1;
	int iVar2;
	int iVar3;
	
	uVar1 = __std_FUN_00490050();
	if (DAT_0054a110 == 0) {
		return uVar1 & 0xffffff00 | (uint)DAT_0054a110;
	}
	iVar3 = 3;
	uVar1 = 0;
	if (3 < globals::__filesCount_0076eda0) {
		do {
			stream = globals::__filesTable_0076dd98[iVar3];
			if (stream != (FILE *)0x0) {
				if (((*(byte *)&stream->_flag & 0x83) != 0) && (iVar2 = fclose(stream), iVar2 != -1)) {
					uVar1 = uVar1 + 1;
				}
				if (0x13 < iVar3) {
					free(globals::__filesTable_0076dd98[iVar3]);
					globals::__filesTable_0076dd98[iVar3] = (FILE *)0x0;
				}
			}
			iVar3 = iVar3 + 1;
		} while (iVar3 < globals::__filesCount_0076eda0);
	}
	return uVar1;
}



BOOL __cdecl std::internal::__vfprintf__00497790(FILE *stream)
{
	BOOL BVar1;
	char *pcVar2;
	int iVar3;
	
	BVar1 = __std_FUN_00498e00(stream->_file);
	if (BVar1 != 0) {
		if (stream == &globals::__FILE_004b3648) {
			iVar3 = 0;
		}
		else {
			if (stream != &globals::__FILE_004b3668) {
				return 0;
			}
			iVar3 = 1;
		}
		globals::__unkCount_0054a3e4 = globals::__unkCount_0054a3e4 + 1;
		if ((stream->_flag & 0x10cU) == 0) {
			if (globals::__tmpFileBuffers_0054a3e8[iVar3] == (char *)0x0) {
				pcVar2 = (char *)malloc(0x1000);
				globals::__tmpFileBuffers_0054a3e8[iVar3] = pcVar2;
				if (pcVar2 == (char *)0x0) {
					return 0;
				}
			}
			pcVar2 = globals::__tmpFileBuffers_0054a3e8[iVar3];
			stream->_bufsiz = 0x1000;
			stream->_base = pcVar2;
			stream->_ptr = pcVar2;
			stream->_cnt = 0x1000;
			stream->_flag = stream->_flag | 0x1102;
			return 1;
		}
	}
	return 0;
}



void __cdecl std::internal::__vfprintf__00497830(BOOL param_1,FILE *stream)
{
	if (param_1 == 0) {
		if ((stream->_flag & 0x1000U) != 0) {
			__std_fflush__0048ffe0(stream);
		}
	}
	else {
		if ((stream->_flag & 0x1000U) != 0) {
			__std_fflush__0048ffe0(stream);
			stream->_bufsiz = 0;
			stream->_flag = stream->_flag & 0xffffeeff;
			stream->_ptr = (char *)0x0;
			stream->_base = (char *)0x0;
			return;
		}
	}
	return;
}



int __cdecl std::tolower(int c)
{
	int iVar1;
	uint uVar2;
	LPCWSTR pWVar3;
	int iVar4;
	uint local_8 [2];
	
	iVar1 = c;
	if (DAT_0054a180 == 0) {
		if ((0x40 < c) && (c < 0x5b)) {
			return c + 0x20;
		}
	}
	else {
		if (c < 0x100) {
										// int std::isupper(int c)
			if (globals::_pcharwidth < 2) {
				uVar2 = *(byte *)(globals::_pctype + c) & C1_UPPER;
			}
			else {
				uVar2 = _isctype(c,C1_UPPER);
			}
			if (uVar2 == 0) {
				return iVar1;
			}
		}
		if ((*(byte *)((int)globals::_pctype + (iVar1 >> 8 & 0xffU) * 2 + 1) & 0x80) == 0) {
			c = c & 0xffff0000U | iVar1 & 0xffU;
			pWVar3 = (LPCWSTR)0x1;
		}
		else {
			c = c & 0xff000000U | (uint)CONCAT11((char)iVar1,(char)((uint)iVar1 >> 8));
			pWVar3 = (LPCWSTR)0x2;
		}
		iVar4 = internal::__uprlwr__00493f60(DAT_0054a180,0x100,(char *)&c,pWVar3,(LPWSTR)local_8,3,0);
		if (iVar4 == 0) {
			return iVar1;
		}
		if (iVar4 == 1) {
			return local_8[0] & 0xff;
		}
		c = (local_8[0] >> 8 & 0xff) << 8 | local_8[0] & 0xff;
	}
	return c;
}



char * __cdecl std::strncpy(char *strDest,char *strSource,size_t count)
{
	byte bVar1;
	byte bVar2;
	char *pcVar3;
	uint uVar4;
	undefined4 *puVar5;
	undefined4 *puVar6;
	
	if (DAT_0054a3bc == 0) {
		pcVar3 = _strncpy(strDest,strSource,count);
		return pcVar3;
	}
	uVar4 = count;
	puVar6 = (undefined4 *)strDest;
	puVar5 = (undefined4 *)strDest;
	if (count != 0) {
		do {
			bVar1 = *strSource;
			count = uVar4 - 1;
			bVar2 = *(byte *)((int)&DAT_0054a2b8 + bVar1 + 1);
			*(byte *)puVar5 = bVar1;
			if ((bVar2 & 4) == 0) {
				puVar6 = (undefined4 *)((int)puVar5 + 1);
				strSource = (char *)((byte *)strSource + 1);
				if (bVar1 == 0) break;
			}
			else {
				puVar6 = (undefined4 *)((int)puVar5 + 1);
				if (count == 0) {
					*(undefined *)puVar5 = 0;
					break;
				}
				bVar1 = ((byte *)strSource)[1];
				count = uVar4 - 2;
				*(byte *)puVar6 = bVar1;
				puVar6 = (undefined4 *)((int)puVar5 + 2);
				strSource = (char *)((byte *)strSource + 2);
				if (bVar1 == 0) {
					*(undefined *)puVar5 = 0;
					break;
				}
			}
			uVar4 = count;
			puVar5 = puVar6;
		} while (count != 0);
	}
	if (count != 0) {
		for (uVar4 = count >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
			*puVar6 = 0;
			puVar6 = puVar6 + 1;
		}
		for (uVar4 = count & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
			*(undefined *)puVar6 = 0;
			puVar6 = (undefined4 *)((int)puVar6 + 1);
		}
	}
	return strDest;
}



uint std::internal::__std_FUN_00497a30(uint param_1,uint param_2)
{
	uint uVar1;
	ushort in_FPUControlWord;
	
	uVar1 = __std_FUN_00497a90((uint)in_FPUControlWord);
	uVar1 = param_2 & param_1 | ~param_2 & uVar1;
	__std_FUN_00497b30(uVar1);
	return uVar1;
}



void __cdecl std::internal::__std_FUN_00497a70(undefined4 param_1,uint param_2)
{
	__std_FUN_00497a30(param_1,param_2 & 0xfff7ffff);
	return;
}



uint __cdecl std::internal::__std_FUN_00497a90(uint param_1)
{
	uint uVar1;
	uint uVar2;
	
	uVar1 = 0;
	if ((param_1 & 1) != 0) {
		uVar1 = 0x10;
	}
	if ((param_1 & 4) != 0) {
		uVar1 = uVar1 | 8;
	}
	if ((param_1 & 8) != 0) {
		uVar1 = uVar1 | 4;
	}
	if ((param_1 & 0x10) != 0) {
		uVar1 = uVar1 | 2;
	}
	if ((param_1 & 0x20) != 0) {
		uVar1 = uVar1 | 1;
	}
	if ((param_1 & 2) != 0) {
		uVar1 = uVar1 | 0x80000;
	}
	uVar2 = param_1 & 0xc00;
	if (uVar2 < 0x401) {
		if (uVar2 == 0x400) {
			uVar1 = uVar1 | 0x100;
		}
	}
	else {
		if (uVar2 == 0x800) {
			uVar1 = uVar1 | 0x200;
		}
		else {
			if (uVar2 == 0xc00) {
				uVar1 = uVar1 | 0x300;
			}
		}
	}
	if ((param_1 & 0x300) == 0) {
		uVar1 = uVar1 | 0x20000;
	}
	else {
		if ((param_1 & 0x300) == 0x200) {
			uVar1 = uVar1 | 0x10000;
		}
	}
	if ((param_1 & 0x1000) != 0) {
		uVar1 = uVar1 | 0x40000;
	}
	return uVar1;
}



uint __cdecl std::internal::__std_FUN_00497b30(uint param_1)
{
	uint uVar1;
	uint uVar2;
	byte bVar3;
	
	bVar3 = (param_1 & 0x10) != 0;
	if ((param_1 & 8) != 0) {
		bVar3 = bVar3 | 4;
	}
	if ((param_1 & 4) != 0) {
		bVar3 = bVar3 | 8;
	}
	if ((param_1 & 2) != 0) {
		bVar3 = bVar3 | 0x10;
	}
	if ((param_1 & 1) != 0) {
		bVar3 = bVar3 | 0x20;
	}
	if ((param_1 & 0x80000) != 0) {
		bVar3 = bVar3 | 2;
	}
	uVar1 = (uint)bVar3;
	uVar2 = param_1 & 0x300;
	if (uVar2 < 0x101) {
		if (uVar2 == 0x100) {
			uVar1 = bVar3 | 0x400;
		}
	}
	else {
		if (uVar2 == 0x200) {
			uVar1 = (uint)CONCAT11(8,bVar3);
		}
		else {
			if (uVar2 == 0x300) {
				uVar1 = (uint)CONCAT11(0xc,bVar3);
			}
		}
	}
	if ((param_1 & 0x30000) == 0) {
		uVar1 = uVar1 | 0x300;
	}
	else {
		if ((param_1 & 0x30000) == 0x10000) {
			uVar1 = uVar1 | 0x200;
		}
	}
	if ((param_1 & 0x40000) != 0) {
		uVar1 = uVar1 | 0x1000;
	}
	return uVar1;
}



undefined4 __cdecl std::internal::__std_FUN_00497bc0(int param_1,int param_2)
{
	byte bVar1;
	int *piVar2;
	int iVar3;
	
	bVar1 = (byte)(param_2 >> 0x1f);
	iVar3 = (int)(param_2 + (param_2 >> 0x1f & 0x1fU)) >> 5;
	if ((*(uint *)(param_1 + iVar3 * 4) &
			~(-1 << (0x1f - ((((byte)param_2 ^ bVar1) - bVar1 & 0x1f ^ bVar1) - bVar1) & 0x1f))) != 0) {
		return 0;
	}
	iVar3 = iVar3 + 1;
	if (iVar3 < 3) {
		piVar2 = (int *)(param_1 + iVar3 * 4);
		do {
			if (*piVar2 != 0) {
				return 0;
			}
			iVar3 = iVar3 + 1;
			piVar2 = piVar2 + 1;
		} while (iVar3 < 3);
		return 1;
	}
	return 1;
}



void __cdecl std::internal::__std_FUN_00497c30(int param_1,int param_2)
{
	byte bVar1;
	int iVar2;
	int iVar3;
	uint *puVar4;
	
	bVar1 = (byte)(param_2 >> 0x1f);
	iVar3 = (int)(param_2 + (param_2 >> 0x1f & 0x1fU)) >> 5;
	iVar2 = __std_FUN_0049a270(*(uint *)(param_1 + iVar3 * 4),
														 1 << (0x1f - ((((byte)param_2 ^ bVar1) - bVar1 & 0x1f ^ bVar1) - bVar1)
																	& 0x1f),(uint *)(param_1 + iVar3 * 4));
	iVar3 = iVar3 + -1;
	if (-1 < iVar3) {
		puVar4 = (uint *)(param_1 + iVar3 * 4);
		do {
			if (iVar2 == 0) {
				return;
			}
			iVar2 = __std_FUN_0049a270(*puVar4,1,puVar4);
			iVar3 = iVar3 + -1;
			puVar4 = puVar4 + -1;
		} while (-1 < iVar3);
	}
	return;
}



undefined4 __cdecl std::internal::__std_FUN_00497ca0(int param_1,int param_2)
{
	int iVar1;
	byte bVar2;
	int iVar3;
	undefined4 *puVar4;
	undefined4 local_4;
	
	local_4 = 0;
	bVar2 = (byte)(param_2 >> 0x1f);
	bVar2 = 0x1f - ((((byte)param_2 ^ bVar2) - bVar2 & 0x1f ^ bVar2) - bVar2);
	iVar3 = (int)(param_2 + (param_2 >> 0x1f & 0x1fU)) >> 5;
	if (((*(uint *)(param_1 + iVar3 * 4) & 1 << (bVar2 & 0x1f)) != 0) &&
		 (iVar1 = __std_FUN_00497bc0(param_1,param_2 + 1), iVar1 == 0)) {
		local_4 = __std_FUN_00497c30(param_1,param_2 + -1);
	}
	*(uint *)(param_1 + iVar3 * 4) = *(uint *)(param_1 + iVar3 * 4) & -1 << (bVar2 & 0x1f);
	iVar3 = iVar3 + 1;
	if (iVar3 < 3) {
		puVar4 = (undefined4 *)(param_1 + iVar3 * 4);
		for (iVar1 = 3 - iVar3; iVar1 != 0; iVar1 = iVar1 + -1) {
			*puVar4 = 0;
			puVar4 = puVar4 + 1;
		}
	}
	return local_4;
}



void __cdecl std::internal::__std_FUN_00497d40(int param_1,undefined4 *param_2)
{
	int iVar1;
	int iVar2;
	
	iVar1 = param_1 - (int)param_2;
	iVar2 = 3;
	do {
		*(undefined4 *)((int)param_2 + iVar1) = *param_2;
		param_2 = param_2 + 1;
		iVar2 = iVar2 + -1;
	} while (iVar2 != 0);
	return;
}



void __cdecl std::internal::__std_FUN_00497d60(undefined4 *param_1)
{
	*param_1 = 0;
	param_1[1] = 0;
	param_1[2] = 0;
	return;
}



undefined4 __cdecl std::internal::__std_FUN_00497d70(int *param_1)
{
	int iVar1;
	
	iVar1 = 0;
	do {
		if (*param_1 != 0) {
			return 0;
		}
		iVar1 = iVar1 + 1;
		param_1 = param_1 + 1;
	} while (iVar1 < 3);
	return 1;
}



void __cdecl std::internal::__std_FUN_00497d90(uint *param_1,int param_2)
{
	int iVar1;
	byte bVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	uint *puVar6;
	int iVar7;
	
	iVar1 = (int)(param_2 + (param_2 >> 0x1f & 0x1fU)) >> 5;
	bVar2 = (byte)(param_2 >> 0x1f);
	uVar5 = 0;
	bVar2 = (((byte)param_2 ^ bVar2) - bVar2 & 0x1f ^ bVar2) - bVar2;
	param_2 = 3;
	puVar6 = param_1;
	do {
		uVar4 = *puVar6 >> (bVar2 & 0x1f) | uVar5;
		uVar5 = (~(-1 << (bVar2 & 0x1f)) & *puVar6) << (0x20 - bVar2 & 0x1f);
		*puVar6 = uVar4;
		param_2 = param_2 + -1;
		puVar6 = puVar6 + 1;
	} while (param_2 != 0);
	iVar7 = 2;
	iVar3 = 8;
	do {
		if (iVar7 < iVar1) {
			*(undefined4 *)((int)param_1 + iVar3) = 0;
		}
		else {
			*(undefined4 *)((int)param_1 + iVar3) = *(undefined4 *)((int)param_1 + iVar3 + iVar1 * -4);
		}
		iVar7 = iVar7 + -1;
		iVar3 = iVar3 + -4;
	} while (-1 < iVar3);
	return;
}



undefined4 __cdecl std::internal::__std_FUN_00497e50(ushort *param_1,uint *param_2,int *param_3)
{
	ushort uVar1;
	int iVar2;
	undefined4 uVar3;
	uint uVar4;
	int iVar5;
	uint local_18;
	uint local_14;
	int local_10;
	undefined4 local_c [3];
	
	uVar1 = param_1[5];
	local_14 = *(uint *)(param_1 + 1);
	local_18 = *(uint *)(param_1 + 3);
	uVar4 = uVar1 & 0x7fff;
	iVar5 = uVar4 - 0x3fff;
	local_10 = (uint)*param_1 << 0x10;
	if (iVar5 == -0x3fff) {
		iVar5 = 0;
		iVar2 = __std_FUN_00497d70((int *)&local_18);
		if (iVar2 == 0) {
			__std_FUN_00497d60(&local_18);
			uVar3 = 2;
			goto LAB_00497fd1;
		}
	}
	else {
		__std_FUN_00497d40((int)local_c,&local_18);
		iVar2 = __std_FUN_00497ca0((int)&local_18,param_3[2]);
		if (iVar2 != 0) {
			iVar5 = uVar4 - 0x3ffe;
		}
		iVar2 = param_3[1];
		if (iVar5 < iVar2 - param_3[2]) {
			__std_FUN_00497d60(&local_18);
			iVar5 = 0;
			uVar3 = 2;
			goto LAB_00497fd1;
		}
		if (iVar5 <= iVar2) {
			__std_FUN_00497d40((int)&local_18,local_c);
			__std_FUN_00497d90(&local_18,iVar2 - iVar5);
			__std_FUN_00497ca0((int)&local_18,param_3[2]);
			__std_FUN_00497d90(&local_18,param_3[3] + 1);
			iVar5 = 0;
			uVar3 = 2;
			goto LAB_00497fd1;
		}
		if (*param_3 <= iVar5) {
			__std_FUN_00497d60(&local_18);
			local_18 = local_18 | 0x80000000;
			__std_FUN_00497d90(&local_18,param_3[3]);
			iVar5 = param_3[5] + *param_3;
			uVar3 = 1;
			goto LAB_00497fd1;
		}
		iVar5 = param_3[5] + iVar5;
		local_18 = local_18 & 0x7fffffff;
		__std_FUN_00497d90(&local_18,param_3[3]);
	}
	uVar3 = 0;
LAB_00497fd1:
	local_18 = iVar5 << (0x1fU - (char)param_3[3] & 0x1f) |
						 -(uint)((uVar1 & 0x8000) != 0) & 0x80000000 | local_18;
	if (param_3[4] == 0x40) {
		param_2[1] = local_18;
		*param_2 = local_14;
		return uVar3;
	}
	if (param_3[4] == 0x20) {
		*param_2 = local_18;
	}
	return uVar3;
}



void __cdecl std::internal::__std_FUN_00498020(ushort *param_1,uint *param_2)
{
	__std_FUN_00497e50(param_1,param_2,(int *)&DAT_004b38a8);
	return;
}



void __cdecl std::internal::__std_FUN_00498040(ushort *param_1,uint *param_2)
{
	__std_FUN_00497e50(param_1,param_2,(int *)&DAT_004b38c0);
	return;
}



void __cdecl std::internal::__std_FUN_00498060(uint *param_1,byte *param_2)
{
	ushort local_c [6];
	
	__std_FUN_00498610(local_c,&param_2,param_2,0,0,0,0);
	__std_FUN_00498020(local_c,param_1);
	return;
}



void __cdecl std::internal::__std_FUN_004980a0(uint *param_1,byte *param_2)
{
	ushort local_c [6];
	
	__std_FUN_00498610(local_c,&param_2,param_2,0,0,0,0);
	__std_FUN_00498040(local_c,param_1);
	return;
}



void __cdecl std::internal::__std_FUN_004980e0(undefined4 *param_1,int param_2,int param_3)
{
	char *pcVar1;
	char cVar2;
	uint uVar3;
	uint uVar4;
	char *pcVar5;
	int iVar6;
	undefined4 *puVar7;
	char *pcVar8;
	
	pcVar5 = *(char **)(param_3 + 0xc);
	pcVar8 = (char *)((int)param_1 + 1);
	*(undefined *)param_1 = 0x30;
	pcVar1 = pcVar8;
	iVar6 = param_2;
	if (0 < param_2) {
		do {
			cVar2 = *pcVar5;
			if (cVar2 == '\0') {
				cVar2 = '0';
			}
			else {
				pcVar5 = pcVar5 + 1;
			}
			*pcVar1 = cVar2;
			pcVar1 = pcVar1 + 1;
			iVar6 = iVar6 + -1;
			param_2 = param_2 + -1;
		} while (param_2 != 0);
	}
	*pcVar1 = '\0';
	if ((-1 < iVar6) && ('4' < *pcVar5)) {
		cVar2 = pcVar1[-1];
		while (pcVar5 = pcVar1 + -1, cVar2 == '9') {
			*pcVar5 = '0';
			cVar2 = pcVar1[-2];
			pcVar1 = pcVar5;
		}
		*pcVar5 = *pcVar5 + '\x01';
	}
	if (*(char *)param_1 == '1') {
		*(int *)(param_3 + 4) = *(int *)(param_3 + 4) + 1;
		return;
	}
	uVar3 = 0xffffffff;
	do {
		pcVar5 = pcVar8;
		if (uVar3 == 0) break;
		uVar3 = uVar3 - 1;
		pcVar5 = pcVar8 + 1;
		cVar2 = *pcVar8;
		pcVar8 = pcVar5;
	} while (cVar2 != '\0');
	uVar3 = ~uVar3;
	puVar7 = (undefined4 *)(pcVar5 + -uVar3);
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
		*param_1 = *puVar7;
		puVar7 = puVar7 + 1;
		param_1 = param_1 + 1;
	}
	for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
		*(undefined *)param_1 = *(undefined *)puVar7;
		puVar7 = (undefined4 *)((int)puVar7 + 1);
		param_1 = (undefined4 *)((int)param_1 + 1);
	}
	return;
}



undefined * std::internal::__std_FUN_00498180(undefined param_1)
{
	undefined4 in_stack_ffffffe4;
	undefined2 uVar1;
	uint local_c;
	uint local_8;
	undefined2 local_4;
	
	uVar1 = (undefined2)((uint)in_stack_ffffffe4 >> 0x10);
	__std_FUN_00498200(&local_c,(uint *)&param_1);
	DAT_0054a418 = __std_FUN_0049a470(local_c,local_8,CONCAT22(uVar1,local_4),0x11,0,&DAT_0054a3f0);
	DAT_0054a410 = (int)DAT_0054a3f2;
	DAT_0054a414 = (int)DAT_0054a3f0;
	DAT_0054a41c = &DAT_0054a3f4;
	return (undefined *)&DAT_0054a410;
}



void __cdecl std::internal::__std_FUN_00498200(uint *param_1,uint *param_2)
{
	ushort uVar1;
	uint uVar2;
	ushort uVar3;
	ushort uVar4;
	uint uVar5;
	uint uVar6;
	
	uVar6 = 0x80000000;
	uVar1 = *(ushort *)((int)param_2 + 6);
	uVar2 = *param_2;
	uVar3 = uVar1 >> 4;
	uVar4 = uVar3 & 0x7ff;
	if ((uVar3 & 0x7ff) == 0) {
		uVar6 = 0;
		if (((param_2[1] & 0xfffff) == 0) && (uVar2 == 0)) {
			param_1[1] = 0;
			*param_1 = 0;
			*(undefined2 *)(param_1 + 2) = 0;
			return;
		}
		uVar4 = 0x3c01;
	}
	else {
		if (uVar4 == 0x7ff) {
			uVar4 = 0x7fff;
		}
		else {
			uVar4 = uVar4 + 0x3c00;
		}
	}
	uVar5 = uVar2 >> 0x15 | (param_2[1] & 0xfffff) << 0xb | uVar6;
	param_1[1] = uVar5;
	*param_1 = uVar2 << 0xb;
	for (; uVar6 == 0; uVar6 = uVar6 & 0x80000000) {
		uVar6 = uVar5 * 2;
		uVar5 = *param_1 >> 0x1f | uVar6;
		uVar4 = uVar4 - 1;
		param_1[1] = uVar5;
		*param_1 = *param_1 * 2;
	}
	*(ushort *)(param_1 + 2) = uVar4 | uVar1 & 0x8000;
	return;
}



undefined4 * __cdecl
std::internal::__std_FUN_004982c0(undefined4 *param_1,undefined4 *param_2,uint param_3)
{
	undefined4 *puVar1;
	uint uVar2;
	uint uVar3;
	undefined4 *puVar4;
	
	if ((param_2 < param_1) && (param_1 < (undefined4 *)(param_3 + (int)param_2))) {
		puVar1 = (undefined4 *)((param_3 - 4) + (int)param_2);
		puVar4 = (undefined4 *)((param_3 - 4) + (int)param_1);
		if (((uint)puVar4 & 3) == 0) {
			uVar2 = param_3 >> 2;
			if (uVar2 < 8) goto LAB_00498480;
			for (; uVar2 != 0; uVar2 = uVar2 - 1) {
				*puVar4 = *puVar1;
				puVar1 = puVar1 + -1;
				puVar4 = puVar4 + -1;
			}
			switch(param_3 & 3) {
			case 1:
				goto switchD_004984a4_caseD_1;
			case 2:
				goto switchD_004984a4_caseD_2;
			case 3:
				goto switchD_004984a4_caseD_3;
			}
		}
		else {
			switch(param_3) {
			case 0:
				break;
			case 1:
switchD_004984a4_caseD_1:
				*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
				return param_1;
			case 2:
switchD_004984a4_caseD_2:
				*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
				*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
				return param_1;
			case 3:
switchD_004984a4_caseD_3:
				*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
				*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
				*(undefined *)((int)puVar4 + 1) = *(undefined *)((int)puVar1 + 1);
				return param_1;
			default:
				uVar3 = param_3 - ((uint)puVar4 & 3);
				switch((uint)puVar4 & 3) {
				case 1:
					*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
					puVar1 = (undefined4 *)((int)puVar1 + -1);
					uVar2 = uVar3 >> 2;
					puVar4 = (undefined4 *)((int)puVar4 - 1);
					if (uVar2 < 8) {
LAB_00498480:
										// WARNING: Could not recover jumptable at 0x00498482. Too many branches
										// WARNING: Treating indirect jump as call
						puVar1 = (undefined4 *)(*(code *)(&PTR_LAB_00498550)[-uVar2])();
						return puVar1;
					}
					for (; uVar2 != 0; uVar2 = uVar2 - 1) {
						*puVar4 = *puVar1;
						puVar1 = puVar1 + -1;
						puVar4 = puVar4 + -1;
					}
					switch(uVar3 & 3) {
					case 1:
						goto switchD_004984a4_caseD_1;
					case 2:
						goto switchD_004984a4_caseD_2;
					case 3:
						goto switchD_004984a4_caseD_3;
					}
					break;
				case 2:
					*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
					uVar2 = uVar3 >> 2;
					*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
					puVar1 = (undefined4 *)((int)puVar1 + -2);
					puVar4 = (undefined4 *)((int)puVar4 - 2);
					if (uVar2 < 8) goto LAB_00498480;
					for (; uVar2 != 0; uVar2 = uVar2 - 1) {
						*puVar4 = *puVar1;
						puVar1 = puVar1 + -1;
						puVar4 = puVar4 + -1;
					}
					switch(uVar3 & 3) {
					case 1:
						goto switchD_004984a4_caseD_1;
					case 2:
						goto switchD_004984a4_caseD_2;
					case 3:
						goto switchD_004984a4_caseD_3;
					}
					break;
				case 3:
					*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
					*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
					uVar2 = uVar3 >> 2;
					*(undefined *)((int)puVar4 + 1) = *(undefined *)((int)puVar1 + 1);
					puVar1 = (undefined4 *)((int)puVar1 + -3);
					puVar4 = (undefined4 *)((int)puVar4 - 3);
					if (uVar2 < 8) goto LAB_00498480;
					for (; uVar2 != 0; uVar2 = uVar2 - 1) {
						*puVar4 = *puVar1;
						puVar1 = puVar1 + -1;
						puVar4 = puVar4 + -1;
					}
					switch(uVar3 & 3) {
					case 1:
						goto switchD_004984a4_caseD_1;
					case 2:
						goto switchD_004984a4_caseD_2;
					case 3:
						goto switchD_004984a4_caseD_3;
					}
				}
			}
		}
		return param_1;
	}
	puVar1 = param_1;
	if (((uint)param_1 & 3) == 0) {
		uVar2 = param_3 >> 2;
		if (uVar2 < 8) goto LAB_0049831c;
		for (; uVar2 != 0; uVar2 = uVar2 - 1) {
			*puVar1 = *param_2;
			param_2 = param_2 + 1;
			puVar1 = puVar1 + 1;
		}
		switch(param_3 & 3) {
		case 1:
			goto switchD_00498314_caseD_1;
		case 2:
			goto switchD_00498314_caseD_2;
		case 3:
			goto switchD_00498314_caseD_3;
		}
	}
	else {
		switch(param_3) {
		case 0:
			break;
		case 1:
switchD_00498314_caseD_1:
			*(undefined *)puVar1 = *(undefined *)param_2;
			return param_1;
		case 2:
switchD_00498314_caseD_2:
			*(undefined *)puVar1 = *(undefined *)param_2;
			*(undefined *)((int)puVar1 + 1) = *(undefined *)((int)param_2 + 1);
			return param_1;
		case 3:
switchD_00498314_caseD_3:
			*(undefined *)puVar1 = *(undefined *)param_2;
			*(undefined *)((int)puVar1 + 1) = *(undefined *)((int)param_2 + 1);
			*(undefined *)((int)puVar1 + 2) = *(undefined *)((int)param_2 + 2);
			return param_1;
		default:
			uVar3 = (param_3 - 4) + ((uint)param_1 & 3);
			switch((uint)param_1 & 3) {
			case 1:
				*(undefined *)param_1 = *(undefined *)param_2;
				*(undefined *)((int)param_1 + 1) = *(undefined *)((int)param_2 + 1);
				uVar2 = uVar3 >> 2;
				*(undefined *)((int)param_1 + 2) = *(undefined *)((int)param_2 + 2);
				param_2 = (undefined4 *)((int)param_2 + 3);
				puVar1 = (undefined4 *)((int)param_1 + 3);
				if (uVar2 < 8) {
LAB_0049831c:
										// WARNING: Could not recover jumptable at 0x0049831c. Too many branches
										// WARNING: Treating indirect jump as call
					puVar1 = (undefined4 *)(*(code *)(&PTR_LAB_0049839c)[uVar2])();
					return puVar1;
				}
				for (; uVar2 != 0; uVar2 = uVar2 - 1) {
					*puVar1 = *param_2;
					param_2 = param_2 + 1;
					puVar1 = puVar1 + 1;
				}
				switch(uVar3 & 3) {
				case 1:
					goto switchD_00498314_caseD_1;
				case 2:
					goto switchD_00498314_caseD_2;
				case 3:
					goto switchD_00498314_caseD_3;
				}
				break;
			case 2:
				*(undefined *)param_1 = *(undefined *)param_2;
				uVar2 = uVar3 >> 2;
				*(undefined *)((int)param_1 + 1) = *(undefined *)((int)param_2 + 1);
				param_2 = (undefined4 *)((int)param_2 + 2);
				puVar1 = (undefined4 *)((int)param_1 + 2);
				if (uVar2 < 8) goto LAB_0049831c;
				for (; uVar2 != 0; uVar2 = uVar2 - 1) {
					*puVar1 = *param_2;
					param_2 = param_2 + 1;
					puVar1 = puVar1 + 1;
				}
				switch(uVar3 & 3) {
				case 1:
					goto switchD_00498314_caseD_1;
				case 2:
					goto switchD_00498314_caseD_2;
				case 3:
					goto switchD_00498314_caseD_3;
				}
				break;
			case 3:
				*(undefined *)param_1 = *(undefined *)param_2;
				uVar2 = uVar3 >> 2;
				param_2 = (undefined4 *)((int)param_2 + 1);
				puVar1 = (undefined4 *)((int)param_1 + 1);
				if (uVar2 < 8) goto LAB_0049831c;
				for (; uVar2 != 0; uVar2 = uVar2 - 1) {
					*puVar1 = *param_2;
					param_2 = param_2 + 1;
					puVar1 = puVar1 + 1;
				}
				switch(uVar3 & 3) {
				case 1:
					goto switchD_00498314_caseD_1;
				case 2:
					goto switchD_00498314_caseD_2;
				case 3:
					goto switchD_00498314_caseD_3;
				}
			}
		}
	}
	return param_1;
}



void std::internal::__std_FUN_00498600(void)
{
	__amsg_exit(2);
	return;
}



// WARNING: Could not reconcile some variable overlaps

undefined4 __cdecl
std::internal::__std_FUN_00498610
					(ushort *param_1,byte **param_2,byte *param_3,int param_4,int param_5,int param_6,
					int param_7)
{
	char cVar1;
	bool bVar2;
	bool bVar3;
	bool bVar4;
	bool bVar5;
	bool bVar6;
	ushort uVar7;
	int iVar8;
	uint uVar9;
	byte bVar10;
	byte *pbVar11;
	byte *pbVar12;
	uint uVar13;
	byte *pbVar14;
	int local_60;
	char *local_5c;
	uint local_54;
	byte *local_50;
	int local_4c;
	int local_48;
	undefined4 local_30;
	ushort local_2c;
	undefined2 uStack42;
	undefined2 uStack40;
	byte *local_26;
	undefined4 local_22;
	char local_1c [23];
	char local_5;
	
	local_5c = local_1c;
	iVar8 = 0;
	uVar13 = 0;
	uVar7 = 0;
	local_4c = 1;
	local_54 = 0;
	bVar2 = false;
	bVar4 = false;
	bVar3 = false;
	bVar5 = false;
	bVar6 = false;
	local_48 = 0;
	local_60 = 0;
	local_30 = 0;
	local_50 = param_3;
	for (pbVar11 = param_3;
			(((bVar10 = *pbVar11, bVar10 == 0x20 || (bVar10 == 9)) || (bVar10 == 10)) ||
			(pbVar14 = param_3, bVar10 == 0xd)); pbVar11 = pbVar11 + 1) {
	}
	do {
		bVar10 = *pbVar11;
		pbVar12 = pbVar11 + 1;
		uVar9 = (uint)bVar10;
		param_3 = (byte *)((uint)param_3 & 0xffffff00 | uVar9);
		switch(iVar8) {
		case 0:
			if (('0' < (char)bVar10) && ((char)bVar10 < ':')) {
				iVar8 = 3;
				goto LAB_00498ae2;
			}
			if (bVar10 == DAT_004b0f78) {
				iVar8 = 5;
			}
			else {
				if (bVar10 == 0x2b) {
					iVar8 = 2;
					uVar7 = 0;
				}
				else {
					if (bVar10 == 0x2d) {
						iVar8 = 2;
						uVar7 = 0x8000;
					}
					else {
						if (bVar10 != 0x30) goto switchD_00498746_caseD_2c;
						iVar8 = 1;
					}
				}
			}
			break;
		case 1:
			bVar2 = true;
			if (('0' < (char)bVar10) && ((char)bVar10 < ':')) {
				iVar8 = 3;
				goto LAB_00498ae2;
			}
			if (bVar10 == DAT_004b0f78) {
				iVar8 = 4;
			}
			else {
				switch(bVar10) {
				case 0x2b:
				case 0x2d:
					goto switchD_00498746_caseD_2b;
				default:
					goto switchD_00498746_caseD_2c;
				case 0x30:
switchD_00498746_caseD_30:
					iVar8 = 1;
					break;
				case 0x44:
				case 0x45:
				case 100:
				case 0x65:
					goto switchD_00498746_caseD_44;
				}
			}
			break;
		case 2:
			if (('0' < (char)bVar10) && ((char)bVar10 < ':')) {
				iVar8 = 3;
				goto LAB_00498ae2;
			}
			if (bVar10 == DAT_004b0f78) {
				iVar8 = 5;
			}
			else {
				if (bVar10 == 0x30) goto switchD_00498746_caseD_30;
				iVar8 = 10;
				pbVar12 = pbVar14;
			}
			break;
		case 3:
			while( true ) {
				bVar2 = true;
										// int std::isdigit(int c)
				if (std::globals::_pcharwidth < 2) {
					uVar9 = *(byte *)(std::globals::_pctype + ((uint)param_3 & 0xff)) & C1_DIGIT;
				}
				else {
					uVar9 = _isctype((uint)param_3 & 0xff,C1_DIGIT);
				}
				if (uVar9 == 0) break;
				if (uVar13 < 0x19) {
					uVar13 = uVar13 + 1;
					*local_5c = bVar10 - 0x30;
					bVar10 = *pbVar12;
					local_5c = local_5c + 1;
					param_3 = (byte *)((uint)param_3 & 0xffffff00 | (uint)bVar10);
					pbVar12 = pbVar12 + 1;
				}
				else {
					bVar10 = *pbVar12;
					local_60 = local_60 + 1;
					param_3 = (byte *)((uint)param_3 & 0xffffff00 | (uint)bVar10);
					pbVar12 = pbVar12 + 1;
				}
			}
			local_54 = uVar13;
			if (bVar10 != DAT_004b0f78) {
				switch(bVar10) {
				case 0x2b:
				case 0x2d:
					goto switchD_00498746_caseD_2b;
				case 0x44:
				case 0x45:
				case 100:
				case 0x65:
					goto switchD_00498746_caseD_44;
				}
switchD_00498746_caseD_2c:
				iVar8 = 10;
				goto LAB_00498ae2;
			}
			iVar8 = 4;
			break;
		case 4:
			bVar4 = true;
			if (uVar13 == 0) {
				while (bVar10 == 0x30) {
					bVar10 = *pbVar12;
					local_60 = local_60 + -1;
					pbVar12 = pbVar12 + 1;
					param_3 = (byte *)((uint)param_3 & 0xffffff00 | (uint)bVar10);
				}
			}
			while( true ) {
				bVar2 = true;
										// int std::isdigit(int c)
				if (std::globals::_pcharwidth < 2) {
					uVar9 = *(byte *)(std::globals::_pctype + ((uint)param_3 & 0xff)) & C1_DIGIT;
				}
				else {
					uVar9 = _isctype((uint)param_3 & 0xff,C1_DIGIT);
				}
				if (uVar9 == 0) break;
				if (uVar13 < 0x19) {
					uVar13 = uVar13 + 1;
					*local_5c = bVar10 - 0x30;
					local_5c = local_5c + 1;
					local_60 = local_60 + -1;
				}
				bVar10 = *pbVar12;
				pbVar12 = pbVar12 + 1;
				param_3 = (byte *)((uint)param_3 & 0xffffff00 | (uint)bVar10);
			}
			local_54 = uVar13;
			switch(bVar10) {
			case 0x2b:
			case 0x2d:
switchD_00498746_caseD_2b:
				bVar2 = true;
				pbVar12 = pbVar12 + -1;
				iVar8 = 0xb;
				break;
			default:
				goto switchD_00498746_caseD_2c;
			case 0x44:
			case 0x45:
			case 100:
			case 0x65:
switchD_00498746_caseD_44:
				bVar2 = true;
				iVar8 = 6;
			}
			break;
		case 5:
			bVar4 = true;
										// int std::isdigit(int c)
			if (std::globals::_pcharwidth < 2) {
				uVar9 = *(byte *)(std::globals::_pctype + uVar9) & C1_DIGIT;
			}
			else {
				uVar9 = _isctype(uVar9,C1_DIGIT);
			}
			if (uVar9 == 0) {
				iVar8 = 10;
				pbVar12 = pbVar14;
			}
			else {
				iVar8 = 4;
				pbVar12 = pbVar11;
			}
			break;
		case 6:
			pbVar11 = pbVar11 + -1;
			pbVar14 = pbVar11;
			local_50 = pbVar11;
			if (('0' < (char)bVar10) && ((char)bVar10 < ':')) {
				iVar8 = 9;
				goto LAB_00498ae2;
			}
			if (bVar10 == 0x2b) {
LAB_00498ad6:
				iVar8 = 7;
				pbVar14 = pbVar11;
				local_50 = pbVar11;
			}
			else {
				if (bVar10 != 0x2d) goto LAB_004989c6;
LAB_00498ac7:
				iVar8 = 7;
				local_4c = -1;
				pbVar14 = pbVar11;
				local_50 = pbVar11;
			}
			break;
		case 7:
			if (('0' < (char)bVar10) && ((char)bVar10 < ':')) {
				iVar8 = 9;
				goto LAB_00498ae2;
			}
LAB_004989c6:
			if (bVar10 == 0x30) {
				iVar8 = 8;
			}
			else {
				iVar8 = 10;
				pbVar12 = pbVar14;
			}
			break;
		case 8:
			bVar3 = true;
			while (bVar10 == 0x30) {
				bVar10 = *pbVar12;
				pbVar12 = pbVar12 + 1;
			}
			if (((char)bVar10 < '1') || ('9' < (char)bVar10)) goto switchD_00498746_caseD_2c;
			iVar8 = 9;
LAB_00498ae2:
			pbVar12 = pbVar12 + -1;
			break;
		case 9:
			bVar3 = true;
			local_48 = 0;
			while( true ) {
										// int std::isdigit(int c)
				if (std::globals::_pcharwidth < 2) {
					uVar13 = *(byte *)(std::globals::_pctype + ((uint)param_3 & 0xff)) & C1_DIGIT;
				}
				else {
					uVar13 = _isctype((uint)param_3 & 0xff,C1_DIGIT);
				}
				if (uVar13 == 0) goto LAB_00498a4a;
				local_48 = (char)bVar10 + -0x30 + local_48 * 10;
				if (0x1450 < local_48) break;
				bVar10 = *pbVar12;
				pbVar12 = pbVar12 + 1;
				param_3 = (byte *)((uint)param_3 & 0xffffff00 | (uint)bVar10);
			}
			local_48 = 0x1451;
LAB_00498a4a:
			while( true ) {
				if (std::globals::_pcharwidth < 2) {
					uVar13 = *(byte *)(std::globals::_pctype + ((uint)param_3 & 0xff)) & 4;
				}
				else {
					uVar13 = _isctype((uint)param_3 & 0xff,4);
				}
				if (uVar13 == 0) break;
				bVar10 = *pbVar12;
				pbVar12 = pbVar12 + 1;
				param_3 = (byte *)((uint)param_3 & 0xffffff00 | (uint)bVar10);
			}
			iVar8 = 10;
			pbVar12 = pbVar12 + -1;
			uVar13 = local_54;
			pbVar14 = local_50;
			break;
		case 0xb:
			if (param_7 == 0) goto switchD_00498746_caseD_2c;
			if (bVar10 == 0x2b) goto LAB_00498ad6;
			if (bVar10 == 0x2d) goto LAB_00498ac7;
			iVar8 = 10;
			pbVar12 = pbVar11;
			pbVar14 = pbVar11;
			local_50 = pbVar11;
		}
		pbVar11 = pbVar12;
	} while (iVar8 != 10);
	*param_2 = pbVar12;
	if (bVar2) {
		if (0x18 < uVar13) {
			if ('\x04' < local_5) {
				local_5 = local_5 + '\x01';
			}
			local_5c = local_5c + -1;
			local_60 = local_60 + 1;
			uVar13 = 0x18;
		}
		if (uVar13 == 0) {
			local_2c = 0;
			local_22._0_2_ = 0;
			param_3 = (byte *)0x0;
			pbVar11 = (byte *)0x0;
			goto LAB_00498bb4;
		}
		cVar1 = local_5c[-1];
		while (cVar1 == '\0') {
			uVar13 = uVar13 - 1;
			local_60 = local_60 + 1;
			cVar1 = local_5c[-2];
			local_5c = local_5c + -1;
		}
		__std_FUN_0049a370(local_1c,uVar13,(uint *)&local_2c);
		if (local_4c < 0) {
			local_48 = -local_48;
		}
		uVar13 = local_48 + local_60;
		if (!bVar3) {
			uVar13 = uVar13 + param_5;
		}
		if (!bVar4) {
			uVar13 = uVar13 - param_6;
		}
		if ((int)uVar13 < 0x1451) {
			if (-0x1451 < (int)uVar13) {
				__std_FUN_0049aac0((int *)&local_2c,uVar13,param_4);
				pbVar11 = (byte *)CONCAT22(uStack40,uStack42);
				param_3 = local_26;
				goto LAB_00498bb4;
			}
			bVar6 = true;
		}
		else {
			bVar5 = true;
		}
	}
	local_2c = (ushort)param_3;
	pbVar11 = param_3;
	local_22._0_2_ = local_2c;
LAB_00498bb4:
	if (bVar2) {
		if (bVar5) {
			pbVar11 = (byte *)0x0;
			local_22._0_2_ = 0x7fff;
			param_3 = (byte *)0x80000000;
			local_2c = 0;
			local_30 = 2;
		}
		else {
			if (bVar6) {
				local_2c = 0;
				local_22._0_2_ = 0;
				param_3 = (byte *)0x0;
				pbVar11 = (byte *)0x0;
				local_30 = 1;
			}
		}
	}
	else {
		local_2c = 0;
		local_22._0_2_ = 0;
		param_3 = (byte *)0x0;
		pbVar11 = (byte *)0x0;
		local_30 = 4;
	}
	*param_1 = local_2c;
	*(byte **)(param_1 + 1) = pbVar11;
	*(byte **)(param_1 + 3) = param_3;
	param_1[5] = (ushort)local_22 | uVar7;
	return local_30;
}



void __cdecl std::internal::__fileunk__00498da0(FILE *file)
{
	char *pcVar1;
	
	globals::__unkCount_0054a3e4 = globals::__unkCount_0054a3e4 + 1;
	pcVar1 = (char *)malloc(0x1000);
	file->_base = pcVar1;
	if (pcVar1 != (char *)0x0) {
		file->_flag = file->_flag | 8;
		file->_bufsiz = 0x1000;
		file->_ptr = file->_base;
		file->_cnt = 0;
		return;
	}
	file->_bufsiz = 2;
	file->_flag = file->_flag | 4;
	file->_base = (char *)&file->_charbuf;
	file->_ptr = (char *)&file->_charbuf;
	file->_cnt = 0;
	return;
}



BOOL __cdecl std::internal::__std_FUN_00498e00(uint fd)
{
	if (globals::__UINT_0076eec0 <= fd) {
		return 0;
	}
	return *(byte *)((&DAT_0076edc0)[(int)fd >> 5] + 4 + (fd & 0x1f) * 8) & 0x40;
}



LPSTR __cdecl std::internal::__vfprintf__00498e30(LPSTR param_1,ushort param_2)
{
	LPSTR pCVar1;
	
	pCVar1 = param_1;
	if (param_1 == (LPSTR)0x0) {
		return param_1;
	}
	if (DAT_0054a180 == 0) {
		if (param_2 < 0x100) {
			*param_1 = (CHAR)param_2;
			return (LPSTR)0x1;
		}
	}
	else {
		param_1 = (LPSTR)0x0;
		pCVar1 = (LPSTR)WideCharToMultiByte(DAT_0054a190,0x220,(LPCWSTR)&param_2,1,pCVar1,
																				std::globals::_pcharwidth,(LPCSTR)0x0,(LPBOOL)&param_1);
		if ((pCVar1 != (LPSTR)0x0) && (param_1 == (LPSTR)0x0)) {
			return pCVar1;
		}
	}
	std::globals::g_msvc_errno = 0x2a;
	return (LPSTR)0xffffffff;
}



// Library Function - Single Match
// Name: __aulldiv
// Library: Visual Studio

undefined8 std::internal::__aulldiv(uint param_1,uint param_2,uint param_3,uint param_4)
{
	ulonglong uVar1;
	longlong lVar2;
	uint uVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	uint uVar9;
	
	uVar3 = param_1;
	uVar8 = param_4;
	uVar6 = param_2;
	uVar9 = param_3;
	if (param_4 == 0) {
		uVar3 = param_2 / param_3;
		iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
								 (ulonglong)param_3);
	}
	else {
		do {
			uVar5 = uVar8 >> 1;
			uVar9 = uVar9 >> 1 | (uint)((uVar8 & 1) != 0) << 0x1f;
			uVar7 = uVar6 >> 1;
			uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
			uVar8 = uVar5;
			uVar6 = uVar7;
		} while (uVar5 != 0);
		uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar9;
		iVar4 = (int)uVar1;
		lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
		uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
		uVar8 = uVar3 + iVar4 * param_4;
		if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar8)) ||
			 ((param_2 <= uVar8 && (param_1 < (uint)lVar2)))) {
			iVar4 = iVar4 + -1;
		}
		uVar3 = 0;
	}
	return CONCAT44(uVar3,iVar4);
}



// Library Function - Single Match
// Name: __aullrem
// Library: Visual Studio

undefined8 std::internal::__aullrem(uint param_1,uint param_2,uint param_3,uint param_4)
{
	ulonglong uVar1;
	longlong lVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	int iVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	bool bVar11;
	
	uVar3 = param_1;
	uVar4 = param_4;
	uVar9 = param_2;
	uVar10 = param_3;
	if (param_4 == 0) {
		iVar6 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) %
								 (ulonglong)param_3);
		iVar7 = 0;
	}
	else {
		do {
			uVar5 = uVar4 >> 1;
			uVar10 = uVar10 >> 1 | (uint)((uVar4 & 1) != 0) << 0x1f;
			uVar8 = uVar9 >> 1;
			uVar3 = uVar3 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
			uVar4 = uVar5;
			uVar9 = uVar8;
		} while (uVar5 != 0);
		uVar1 = CONCAT44(uVar8,uVar3) / (ulonglong)uVar10;
		uVar3 = (int)uVar1 * param_4;
		lVar2 = (uVar1 & 0xffffffff) * (ulonglong)param_3;
		uVar9 = (uint)((ulonglong)lVar2 >> 0x20);
		uVar4 = (uint)lVar2;
		uVar10 = uVar9 + uVar3;
		if (((CARRY4(uVar9,uVar3)) || (param_2 < uVar10)) || ((param_2 <= uVar10 && (param_1 < uVar4))))
		{
			bVar11 = uVar4 < param_3;
			uVar4 = uVar4 - param_3;
			uVar10 = (uVar10 - param_4) - (uint)bVar11;
		}
		iVar6 = -(uVar4 - param_1);
		iVar7 = -(uint)(uVar4 - param_1 != 0) - ((uVar10 - param_2) - (uint)(uVar4 < param_1));
	}
	return CONCAT44(iVar7,iVar6);
}



void __cdecl std::internal::__std_FUN_00498fa0(uint param_1,int *param_2,ushort *param_3)
{
	uint uVar1;
	int iVar2;
	uint uVar3;
	uint local_58 [10];
	int local_30;
	int local_2c;
	uint local_20;
	
	param_3 = (ushort *)(uint)*param_3;
	switch(*param_2) {
	case 1:
	case 5:
		uVar3 = 8;
		break;
	case 2:
		uVar3 = 4;
		break;
	case 3:
		uVar3 = 0x11;
		break;
	case 4:
		uVar3 = 0x12;
		break;
	default:
		goto switchD_00498fbf_caseD_6;
	case 7:
		*param_2 = 1;
		goto switchD_00498fbf_caseD_6;
	case 8:
		uVar3 = 0x10;
	}
	uVar1 = __std_FUN_00493880(uVar3,(double *)(param_2 + 6),(uint)param_3);
	if (uVar1 == 0) {
		if (((param_1 == 0x10) || (param_1 == 0x16)) || (param_1 == 0x1d)) {
			local_30 = param_2[4];
			local_20 = local_20 & 0xffffffe3 | 3;
			local_2c = param_2[5];
		}
		else {
			local_20 = local_20 & 0xfffffffe;
		}
		__std_FUN_00493540(local_58,(uint *)&param_3,(byte)uVar3,param_1,(uint *)(param_2 + 2),
											 (uint *)(param_2 + 6));
	}
switchD_00498fbf_caseD_6:
	_control87((uint)param_3,0xffff);
	iVar2 = 0;
	if ((*param_2 != 8) && (DAT_004b38e0 == 0)) {
		iVar2 = lego::nerps::funcs::NERPFunc__False(param_2);
	}
	if (iVar2 == 0) {
		__std_FUN_00493c60(*param_2);
	}
	return;
}



uint __cdecl std::internal::__vfscanf__004990c0(ushort *param_1,byte *param_2,uint param_3)
{
	byte bVar1;
	int iVar2;
	
	if ((param_2 != (byte *)0x0) && (param_3 != 0)) {
		bVar1 = *param_2;
		if (bVar1 != 0) {
			if (DAT_0054a180 == 0) {
				if (param_1 == (ushort *)0x0) {
					return 1;
				}
				*param_1 = (ushort)bVar1;
				return 1;
			}
			if ((*(byte *)((int)std::globals::_pctype + (uint)bVar1 * 2 + 1) & 0x80) == 0) {
				iVar2 = MultiByteToWideChar(DAT_0054a190,9,(LPCSTR)param_2,1,(LPWSTR)param_1,
																		(uint)(param_1 != (ushort *)0x0));
				if (iVar2 != 0) {
					return 1;
				}
				std::globals::g_msvc_errno = 0x2a;
				return 0xffffffff;
			}
			if (((1 < std::globals::_pcharwidth) && (std::globals::_pcharwidth <= (int)param_3)) &&
				 (iVar2 = MultiByteToWideChar(DAT_0054a190,9,(LPCSTR)param_2,std::globals::_pcharwidth,
																			(LPWSTR)param_1,(uint)(param_1 != (ushort *)0x0)), iVar2 != 0)
				 ) {
				return std::globals::_pcharwidth;
			}
			if (param_3 < (uint)std::globals::_pcharwidth) {
				std::globals::g_msvc_errno = 0x2a;
				return 0xffffffff;
			}
			if (param_2[1] != 0) {
				return std::globals::_pcharwidth;
			}
			std::globals::g_msvc_errno = 0x2a;
			return 0xffffffff;
		}
		if (param_1 != (ushort *)0x0) {
			*param_1 = 0;
			return 0;
		}
	}
	return 0;
}



int __cdecl std::isspace(int c)
{
	uint uVar1;
	
	if (1 < globals::_pcharwidth) {
										// C1_SPACE (0x8)
		uVar1 = _isctype(c,C1_SPACE);
		return uVar1;
	}
										// C1_SPACE (0x8)
	return *(byte *)(globals::_pctype + c) & C1_SPACE;
}



// Library Function - Single Match
// Name: __allshl
// Library: Visual Studio

longlong __fastcall std::internal::__allshl(byte param_1,int param_2)
{
	uint in_EAX;
	
	if (0x3f < param_1) {
		return 0;
	}
	if (param_1 < 0x20) {
		return CONCAT44(param_2 << (param_1 & 0x1f) | in_EAX >> 0x20 - (param_1 & 0x1f),
										in_EAX << (param_1 & 0x1f));
	}
	return (ulonglong)(in_EAX << (param_1 & 0x1f)) << 0x20;
}



int __cdecl std::internal::__vfscanf__00499210(int c,FILE *file)
{
	uint uVar1;
	char *pcVar2;
	char *pcVar3;
	
	if ((c != -1) &&
		 ((uVar1 = file->_flag, (uVar1 & 1) != 0 || (((uVar1 & 0x80) != 0 && ((uVar1 & 2) == 0)))))) {
		if (file->_base == (char *)0x0) {
			__fileunk__00498da0(file);
		}
		if (file->_ptr == file->_base) {
			if (file->_cnt != 0) {
				return 0xffffffff;
			}
			file->_ptr = file->_ptr + 1;
		}
		if ((*(byte *)&file->_flag & 0x40) == 0) {
			pcVar2 = file->_ptr;
			file->_ptr = pcVar2 + -1;
			pcVar2[-1] = (char)c;
		}
		else {
			pcVar2 = file->_ptr;
			pcVar3 = pcVar2 + -1;
			file->_ptr = pcVar3;
			if (*pcVar3 != (char)c) {
				file->_ptr = pcVar2;
				return 0xffffffff;
			}
		}
		file->_cnt = file->_cnt + 1;
		file->_flag = file->_flag & 0xffffffefU | 1;
		return c & 0xff;
	}
	return 0xffffffff;
}



int std::internal::__std_FUN_004992a0(void)
{
	undefined4 *puVar1;
	undefined4 *puVar2;
	int *piVar3;
	int iVar4;
	int iVar5;
	int iVar6;
	
	iVar4 = -1;
	iVar5 = 0;
	iVar6 = 0;
	piVar3 = &DAT_0076edc0;
	do {
		puVar2 = (undefined4 *)*piVar3;
		if (puVar2 == (undefined4 *)0x0) {
			puVar2 = (undefined4 *)malloc(0x100);
			if (puVar2 != (undefined4 *)0x0) {
				globals::__UINT_0076eec0 = globals::__UINT_0076eec0 + 0x20;
				(&DAT_0076edc0)[iVar5] = puVar2;
				if (puVar2 < puVar2 + 0x40) {
					do {
						*(undefined *)(puVar2 + 1) = 0;
						*puVar2 = 0xffffffff;
						*(undefined *)((int)puVar2 + 5) = 10;
						puVar2 = puVar2 + 2;
					} while (puVar2 < (undefined4 *)((&DAT_0076edc0)[iVar5] + 0x100));
				}
				iVar4 = iVar5 << 5;
			}
			return iVar4;
		}
		puVar1 = puVar2 + 0x40;
		for (; puVar2 < puVar1; puVar2 = puVar2 + 2) {
			if ((*(byte *)(puVar2 + 1) & 1) == 0) {
				*puVar2 = 0xffffffff;
				iVar4 = ((int)((int)puVar2 - *piVar3) >> 3) + iVar6;
				break;
			}
		}
		if (iVar4 != -1) {
			return iVar4;
		}
		piVar3 = piVar3 + 1;
		iVar5 = iVar5 + 1;
		iVar6 = iVar6 + 0x20;
		if (0x76eebf < (int)piVar3) {
			return -1;
		}
	} while( true );
}



undefined4 __cdecl std::internal::__std_FUN_00499360(uint param_1,HANDLE param_2)
{
	int *piVar1;
	int iVar2;
	
	if (param_1 < globals::__UINT_0076eec0) {
		piVar1 = &DAT_0076edc0 + ((int)param_1 >> 5);
		iVar2 = (param_1 & 0x1f) * 8;
		if (*(int *)((&DAT_0076edc0)[(int)param_1 >> 5] + iVar2) == -1) {
			if (DAT_004b0d64 == 1) {
				if (param_1 == 0) {
					SetStdHandle(0xfffffff6,param_2);
				}
				else {
					if (param_1 == 1) {
						SetStdHandle(0xfffffff5,param_2);
						*(HANDLE *)(*piVar1 + iVar2) = param_2;
						return 0;
					}
					if (param_1 == 2) {
						SetStdHandle(0xfffffff4,param_2);
						*(HANDLE *)(*piVar1 + iVar2) = param_2;
						return 0;
					}
				}
			}
			*(HANDLE *)(*piVar1 + iVar2) = param_2;
			return 0;
		}
	}
	std::globals::g_msvc_errno = 9;
	std::globals::g_msvc_doserrno = 0;
	return 0xffffffff;
}



int __cdecl std::internal::__fdclose__00499410(uint fd)
{
	int iVar1;
	DWORD nStdHandle;
	
	if (fd < globals::__UINT_0076eec0) {
		iVar1 = (fd & 0x1f) * 8;
		if (((*(byte *)((&DAT_0076edc0)[(int)fd >> 5] + 4 + iVar1) & 1) != 0) &&
			 (*(int *)((&DAT_0076edc0)[(int)fd >> 5] + iVar1) != -1)) {
			if (DAT_004b0d64 == 1) {
				if (fd == 0) {
					nStdHandle = STD_INPUT_HANDLE;
				}
				else {
					if (fd == 1) {
						nStdHandle = STD_OUTPUT_HANDLE;
					}
					else {
						if (fd != 2) goto LAB_0049947a;
						nStdHandle = STD_ERROR_HANDLE;
					}
				}
				SetStdHandle(nStdHandle,(HANDLE)0x0);
			}
LAB_0049947a:
			*(undefined4 *)((&DAT_0076edc0)[(int)fd >> 5] + iVar1) = 0xffffffff;
			return 0;
		}
	}
	std::globals::g_msvc_errno = 9;
	std::globals::g_msvc_doserrno = 0;
	return -1;
}



int __cdecl std::internal::__fdunk__004994b0(uint fd)
{
	if ((fd < globals::__UINT_0076eec0) &&
		 ((*(byte *)((&DAT_0076edc0)[(int)fd >> 5] + 4 + (fd & 0x1f) * 8) & 1) != 0)) {
		return *(int *)((&DAT_0076edc0)[(int)fd >> 5] + (fd & 0x1f) * 8);
	}
	std::globals::g_msvc_errno = 9;
	std::globals::g_msvc_doserrno = 0;
	return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __cdecl
std::internal::__fsopen__00499500(LPCSTR filename,uint param_2,uint shflag,undefined4 param_4)
{
	uint uVar1;
	HANDLE hFile;
	char *pcVar2;
	int iVar3;
	DWORD DVar4;
	DWORD dwCreationDisposition;
	DWORD dwFlagsAndAttributes;
	int iVar5;
	bool bVar6;
	byte local_11;
	uint local_10;
	_SECURITY_ATTRIBUTES local_c;
	
	bVar6 = (param_2 & 0x80) == 0;
	local_c.nLength = 0xc;
	local_c.lpSecurityDescriptor = (LPVOID)0x0;
	if (bVar6) {
		local_11 = 0;
	}
	else {
		local_11 = 0x10;
	}
	local_c.bInheritHandle = ZEXT14(bVar6);
	if (((param_2 & 0x8000) == 0) && (((param_2 & 0x4000) != 0 || (_DAT_0054a4f4 != 0x8000)))) {
		local_11 = local_11 | 0x80;
	}
	uVar1 = param_2 & 3;
	if (uVar1 == 0) {
		local_10 = 0x80000000;
	}
	else {
		if (uVar1 == 1) {
			local_10 = 0x40000000;
		}
		else {
			if (uVar1 != 2) {
				std::globals::g_msvc_errno = 0x16;
				std::globals::g_msvc_doserrno = 0;
				return 0xffffffff;
			}
			local_10 = 0xc0000000;
		}
	}
	switch(shflag) {
	case 0x10:
		DVar4 = 0;
		break;
	default:
		goto switchD_00499598_caseD_11;
	case 0x20:
		DVar4 = 1;
		break;
	case 0x30:
		DVar4 = 2;
		break;
	case 0x40:
		DVar4 = 3;
	}
	uVar1 = param_2 & 0x700;
	if (uVar1 < 0x101) {
		if (uVar1 == 0x100) {
			dwCreationDisposition = 4;
			goto LAB_0049962b;
		}
		if (uVar1 != 0) {
			std::globals::g_msvc_errno = 0x16;
			std::globals::g_msvc_doserrno = 0;
			return 0xffffffff;
		}
LAB_00499606:
		dwCreationDisposition = 3;
		goto LAB_0049962b;
	}
	if (uVar1 < 0x301) {
		if (uVar1 == 0x300) {
			dwCreationDisposition = 2;
			goto LAB_0049962b;
		}
		if (uVar1 != 0x200) {
			std::globals::g_msvc_errno = 0x16;
			std::globals::g_msvc_doserrno = 0;
			return 0xffffffff;
		}
LAB_00499626:
		dwCreationDisposition = 5;
	}
	else {
		if (uVar1 < 0x501) {
			if (uVar1 != 0x500) {
				if (uVar1 != 0x400) {
switchD_00499598_caseD_11:
					std::globals::g_msvc_errno = 0x16;
					std::globals::g_msvc_doserrno = 0;
					return 0xffffffff;
				}
				goto LAB_00499606;
			}
		}
		else {
			if (uVar1 == 0x600) goto LAB_00499626;
			if (uVar1 != 0x700) {
				std::globals::g_msvc_errno = 0x16;
				std::globals::g_msvc_doserrno = 0;
				return 0xffffffff;
			}
		}
		dwCreationDisposition = 1;
	}
LAB_0049962b:
	dwFlagsAndAttributes = 0x80;
	if (((param_2 & 0x100) != 0) && (((byte)param_4 & ~(byte)DAT_0054a0d8 & 0x80) == 0)) {
		dwFlagsAndAttributes = 1;
	}
	if ((param_2 & 0x40) != 0) {
		dwFlagsAndAttributes = dwFlagsAndAttributes | 0x4000000;
		local_10 = local_10 | 0x10000;
	}
	if ((param_2 & 0x1000) != 0) {
		dwFlagsAndAttributes = dwFlagsAndAttributes | 0x100;
	}
	if ((param_2 & 0x20) == 0) {
		if ((param_2 & 0x10) != 0) {
			dwFlagsAndAttributes = dwFlagsAndAttributes | 0x10000000;
		}
	}
	else {
		dwFlagsAndAttributes = dwFlagsAndAttributes | 0x8000000;
	}
	uVar1 = __std_FUN_004992a0();
	if (uVar1 == 0xffffffff) {
		std::globals::g_msvc_errno = 0x18;
		std::globals::g_msvc_doserrno = 0;
		return 0xffffffff;
	}
	hFile = CreateFileA(filename,local_10,DVar4,(LPSECURITY_ATTRIBUTES)&local_c,dwCreationDisposition,
											dwFlagsAndAttributes,(HANDLE)0x0);
	if (hFile == (HANDLE)0xffffffff) {
		DVar4 = GetLastError();
		__set_doserrno(DVar4);
		return 0xffffffff;
	}
	DVar4 = GetFileType(hFile);
	if (DVar4 != 0) {
		if (DVar4 == 2) {
			local_11 = local_11 | 0x40;
		}
		else {
			if (DVar4 == 3) {
				local_11 = local_11 | 8;
			}
		}
		__std_FUN_00499360(uVar1,hFile);
		iVar5 = (uVar1 & 0x1f) * 8;
		*(byte *)(iVar5 + 4 + (&DAT_0076edc0)[(int)uVar1 >> 5]) = local_11 | 1;
		if ((((local_11 & 0x48) == 0) && ((local_11 & 0x80) != 0)) && ((param_2 & 2) != 0)) {
			DVar4 = __fdread__00496ec0(uVar1,-1,2);
			if (DVar4 == 0xffffffff) {
				if (std::globals::g_msvc_doserrno != 0x83) {
					__fdclose__00494fd0(uVar1);
					return 0xffffffff;
				}
			}
			else {
				shflag = shflag & 0xffffff00;
				pcVar2 = __fdread(uVar1,(char *)&shflag,1);
				if (((pcVar2 == (char *)0x0) && ((char)shflag == '\x1a')) &&
					 (iVar3 = __fsunk__0049ab50((char)uVar1), iVar3 == -1)) {
					__fdclose__00494fd0(uVar1);
					return 0xffffffff;
				}
				DVar4 = __fdread__00496ec0(uVar1,0,0);
				if (DVar4 == 0xffffffff) {
					__fdclose__00494fd0(uVar1);
					return 0xffffffff;
				}
			}
		}
		if (((local_11 & 0x48) == 0) && ((param_2 & 8) != 0)) {
			*(byte *)(iVar5 + 4 + (&DAT_0076edc0)[(int)uVar1 >> 5]) =
					 *(byte *)(iVar5 + 4 + (&DAT_0076edc0)[(int)uVar1 >> 5]) | 0x20;
		}
		return uVar1;
	}
	CloseHandle(hFile);
	DVar4 = GetLastError();
	__set_doserrno(DVar4);
	return 0xffffffff;
}



void std::internal::__std_FUN_00499920(void)
{
	DAT_0054a424 = SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)&LAB_004998c0);
	return;
}



void std::internal::__std_FUN_00499940(void)
{
	SetUnhandledExceptionFilter(DAT_0054a424);
	return;
}



uint __cdecl std::internal::__std_FUN_00499950(void *param_1,UINT_PTR param_2)
{
	BOOL BVar1;
	
	BVar1 = IsBadReadPtr(param_1,param_2);
	return (uint)(BVar1 == 0);
}



uint __cdecl std::internal::__std_FUN_00499970(LPVOID param_1,UINT_PTR param_2)
{
	BOOL BVar1;
	
	BVar1 = IsBadWritePtr(param_1,param_2);
	return (uint)(BVar1 == 0);
}



uint __cdecl std::internal::__std_FUN_00499990(FARPROC param_1)
{
	BOOL BVar1;
	
	BVar1 = IsBadCodePtr(param_1);
	return (uint)(BVar1 == 0);
}



// Library Function - Single Match
// Name: _abort
// Library: Visual Studio 1998 Release

void __cdecl std::abort(void)
{
	internal::__std_FUN_00496bb0(10);
	internal::__std_FUN_0049acd0(0x16);
	quick_exit(3);
	return;
}



int __cdecl std::internal::__unkftime__004999d0(short *param_1)
{
	short sVar1;
	short *psVar2;
	
	sVar1 = *param_1;
	psVar2 = param_1 + 1;
	while (sVar1 != 0) {
		sVar1 = *psVar2;
		psVar2 = psVar2 + 1;
	}
	return ((int)((int)psVar2 - (int)param_1) >> 1) + -1;
}



int __cdecl
std::internal::__std_FUN_004999f0(undefined4 param_1,undefined4 param_2,undefined4 param_3)
{
	HMODULE hModule;
	int iVar1;
	
	iVar1 = 0;
	if (DAT_0054a428 != (FARPROC)0x0) {
LAB_00499a40:
		if (DAT_0054a42c != (FARPROC)0x0) {
			iVar1 = (*DAT_0054a42c)();
		}
		if ((iVar1 != 0) && (DAT_0054a430 != (FARPROC)0x0)) {
			iVar1 = (*DAT_0054a430)(iVar1);
		}
		iVar1 = (*DAT_0054a428)(iVar1,param_1,param_2,param_3);
		return iVar1;
	}
	hModule = LoadLibraryA("user32.dll");
	if (hModule != (HMODULE)0x0) {
		DAT_0054a428 = GetProcAddress(hModule,"MessageBoxA");
		if (DAT_0054a428 != (FARPROC)0x0) {
			DAT_0054a42c = GetProcAddress(hModule,"GetActiveWindow");
			DAT_0054a430 = GetProcAddress(hModule,"GetLastActivePopup");
			goto LAB_00499a40;
		}
	}
	return 0;
}



int * __cdecl std::internal::__std_FUN_00499a80(int param_1,int param_2)
{
	BOOL BVar1;
	uint uVar2;
	int *piVar3;
	uint dwBytes;
	int *piVar4;
	
	dwBytes = param_2 * param_1;
	if (dwBytes < 0xffffffe1) {
		if (dwBytes == 0) {
			dwBytes = 0x10;
		}
		else {
			dwBytes = dwBytes + 0xf & 0xfffffff0;
		}
	}
	do {
		piVar3 = (int *)0x0;
		if (dwBytes < 0xffffffe1) {
			if (UINT_004b2fdc < dwBytes) {
LAB_00499ae0:
				if (piVar3 != (int *)0x0) {
					return piVar3;
				}
			}
			else {
				piVar3 = __malloc__00491bc0((int *)(dwBytes >> 4));
				if (piVar3 != (int *)0x0) {
					piVar4 = piVar3;
					for (uVar2 = dwBytes >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
						*piVar4 = 0;
						piVar4 = piVar4 + 1;
					}
					for (uVar2 = dwBytes & 3; uVar2 != 0; uVar2 = uVar2 - 1) {
						*(undefined *)piVar4 = 0;
						piVar4 = (int *)((int)piVar4 + 1);
					}
					goto LAB_00499ae0;
				}
			}
			piVar3 = (int *)HeapAlloc(DAT_0076eec4,8,dwBytes);
		}
		if ((piVar3 != (int *)0x0) || (globals::__g_malloc_handlermode == 0)) {
			return piVar3;
		}
		BVar1 = __call_new_handler(dwBytes);
		if (BVar1 == 0) {
			return (int *)0x0;
		}
	} while( true );
}



void std::internal::__unkftime__00499b20(void)
{
	if (DAT_0054a4f0 == 0) {
		__unkftime__00499b40();
		DAT_0054a4f0 = DAT_0054a4f0 + 1;
	}
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void std::internal::__unkftime__00499b40(void)
{
	byte bVar1;
	byte bVar2;
	byte *pbVar3;
	DWORD DVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	byte *pbVar8;
	undefined4 *puVar9;
	byte *pbVar10;
	undefined4 *puVar11;
	bool bVar12;
	
	DAT_0054a438 = 0;
	_DAT_004b3998 = 0xffffffff;
	DAT_004b3988 = 0xffffffff;
	pbVar3 = __unkftime__0049b0d0((byte *)"TZ");
	if (pbVar3 == (byte *)0x0) {
		DVar4 = GetTimeZoneInformation((LPTIME_ZONE_INFORMATION)&lpTimeZoneInformation_0054a440);
		if (DVar4 != 0xffffffff) {
			DAT_0054a438 = 1;
			DAT_004b38f0 = (int)lpTimeZoneInformation_0054a440 * 0x3c;
			if (DAT_0054a486 != 0) {
				DAT_004b38f0 = DAT_004b38f0 + DAT_0054a494 * 0x3c;
			}
			if ((DAT_0054a4da == 0) || (DAT_0054a4e8 == 0)) {
				DAT_004b38f4 = 0;
				DAT_004b38f8 = 0;
			}
			else {
				DAT_004b38f4 = 1;
				DAT_004b38f8 = (DAT_0054a4e8 - DAT_0054a494) * 0x3c;
			}
			__unkftime__0049aea0(PTR_DAT_004b3980,(ushort *)&DAT_0054a444,0x40);
			__unkftime__0049aea0(PTR_DAT_004b3984,(ushort *)&DAT_0054a498,0x40);
			PTR_DAT_004b3984[0x3f] = 0;
			PTR_DAT_004b3980[0x3f] = 0;
			return;
		}
	}
	else {
		if (*pbVar3 != 0) {
			pbVar8 = pbVar3;
			puVar9 = DAT_0054a4ec;
			if (DAT_0054a4ec != (undefined4 *)0x0) {
				do {
					bVar1 = *pbVar8;
					bVar12 = bVar1 < *(byte *)puVar9;
					if (bVar1 != *(byte *)puVar9) {
LAB_00499c83:
						iVar5 = (1 - (uint)bVar12) - (uint)(bVar12 != 0);
						goto LAB_00499c88;
					}
					if (bVar1 == 0) break;
					bVar1 = pbVar8[1];
					bVar12 = bVar1 < *(byte *)((int)puVar9 + 1);
					if (bVar1 != *(byte *)((int)puVar9 + 1)) goto LAB_00499c83;
					pbVar8 = pbVar8 + 2;
					puVar9 = (undefined4 *)((int)puVar9 + 2);
				} while (bVar1 != 0);
				iVar5 = 0;
LAB_00499c88:
				if (iVar5 == 0) {
					return;
				}
			}
			free(DAT_0054a4ec);
			uVar6 = 0xffffffff;
			pbVar8 = pbVar3;
			do {
				if (uVar6 == 0) break;
				uVar6 = uVar6 - 1;
				bVar1 = *pbVar8;
				pbVar8 = pbVar8 + 1;
			} while (bVar1 != 0);
			DAT_0054a4ec = (undefined4 *)malloc(~uVar6);
			if (DAT_0054a4ec != (undefined4 *)0x0) {
				uVar6 = 0xffffffff;
				pbVar8 = pbVar3;
				do {
					pbVar10 = pbVar8;
					if (uVar6 == 0) break;
					uVar6 = uVar6 - 1;
					pbVar10 = pbVar8 + 1;
					bVar1 = *pbVar8;
					pbVar8 = pbVar10;
				} while (bVar1 != 0);
				uVar6 = ~uVar6;
				puVar9 = (undefined4 *)(pbVar10 + -uVar6);
				puVar11 = DAT_0054a4ec;
				for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
					*puVar11 = *puVar9;
					puVar9 = puVar9 + 1;
					puVar11 = puVar11 + 1;
				}
				for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
					*(undefined *)puVar11 = *(undefined *)puVar9;
					puVar9 = (undefined4 *)((int)puVar9 + 1);
					puVar11 = (undefined4 *)((int)puVar11 + 1);
				}
				_strncpy(PTR_DAT_004b3980,(char *)pbVar3,3);
				pbVar8 = pbVar3 + 3;
				PTR_DAT_004b3980[3] = 0;
				bVar1 = *pbVar8;
				if (bVar1 == 0x2d) {
					pbVar8 = pbVar3 + 4;
				}
				iVar5 = __atoi_internal((char *)pbVar8);
				DAT_004b38f0 = iVar5 * 0xe10;
				for (; (bVar2 = *pbVar8, bVar2 == 0x2b || (('/' < (char)bVar2 && ((char)bVar2 < ':'))));
						pbVar8 = pbVar8 + 1) {
				}
				if (*pbVar8 == 0x3a) {
					pbVar8 = pbVar8 + 1;
					iVar5 = __atoi_internal((char *)pbVar8);
					DAT_004b38f0 = DAT_004b38f0 + iVar5 * 0x3c;
					bVar2 = *pbVar8;
					while (('/' < (char)bVar2 && ((char)bVar2 < ':'))) {
						pbVar3 = pbVar8 + 1;
						pbVar8 = pbVar8 + 1;
						bVar2 = *pbVar3;
					}
					if (*pbVar8 == 0x3a) {
						pbVar8 = pbVar8 + 1;
						iVar5 = __atoi_internal((char *)pbVar8);
						DAT_004b38f0 = DAT_004b38f0 + iVar5;
						bVar2 = *pbVar8;
						while (('/' < (char)bVar2 && ((char)bVar2 < ':'))) {
							pbVar3 = pbVar8 + 1;
							pbVar8 = pbVar8 + 1;
							bVar2 = *pbVar3;
						}
					}
				}
				if (bVar1 == 0x2d) {
					DAT_004b38f0 = -DAT_004b38f0;
				}
				DAT_004b38f4 = (int)(char)*pbVar8;
				if (DAT_004b38f4 != 0) {
					_strncpy(PTR_DAT_004b3984,(char *)pbVar8,3);
					PTR_DAT_004b3984[3] = 0;
					return;
				}
				*PTR_DAT_004b3984 = 0;
			}
		}
	}
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __cdecl std::internal::__unkftime__00499df0(int *param_1)
{
	uint uVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	uint uVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	uint uVar11;
	
	if (DAT_004b38f4 == 0) {
		return 0;
	}
	uVar7 = param_1[5];
	if ((uVar7 == DAT_004b3988) && (uVar7 == _DAT_004b3998)) goto LAB_00499fc4;
	if (DAT_0054a438 == 0) {
		__unkftime__0049a060(1,1,uVar7,4,1,0,0,2,0,0,0);
		uVar7 = param_1[5];
		uVar11 = 0;
		uVar3 = 0;
		uVar10 = 0;
		uVar4 = 2;
		uVar1 = 0;
		uVar9 = 5;
		uVar8 = 10;
LAB_00499fb8:
		uVar5 = 0;
		iVar6 = 1;
	}
	else {
		if (_DAT_0054a4d8 != 0) {
			uVar10 = (uint)DAT_0054a4dc._2_2_;
			uVar3 = 0;
			uVar1 = 0;
		}
		else {
			uVar3 = DAT_0054a4dc & 0xffff;
			uVar10 = 0;
			uVar1 = (uint)DAT_0054a4dc._2_2_;
		}
		__unkftime__0049a060
							(1,(uint)(_DAT_0054a4d8 == 0),uVar7,(uint)DAT_0054a4da,uVar1,uVar3,uVar10,
							 _DAT_0054a4e0 & 0xffff,_DAT_0054a4e0 >> 0x10,DAT_0054a4e4 & 0xffff,
							 DAT_0054a4e4 >> 0x10);
		if (_DAT_0054a484 == 0) {
			uVar11 = (uint)DAT_0054a490._2_2_;
			uVar3 = DAT_0054a490 & 0xffff;
			uVar10 = (uint)DAT_0054a48c._2_2_;
			uVar4 = DAT_0054a48c & 0xffff;
			uVar1 = DAT_0054a488 & 0xffff;
			uVar9 = (uint)DAT_0054a488._2_2_;
			uVar8 = (uint)DAT_0054a486;
			uVar7 = param_1[5];
			goto LAB_00499fb8;
		}
		uVar11 = (uint)DAT_0054a490._2_2_;
		uVar3 = DAT_0054a490 & 0xffff;
		uVar10 = (uint)DAT_0054a48c._2_2_;
		uVar5 = (uint)DAT_0054a488._2_2_;
		uVar4 = DAT_0054a48c & 0xffff;
		uVar7 = param_1[5];
		uVar8 = (uint)DAT_0054a486;
		uVar1 = 0;
		uVar9 = 0;
		iVar6 = 0;
	}
	__unkftime__0049a060(0,iVar6,uVar7,uVar8,uVar9,uVar1,uVar5,uVar4,uVar10,uVar3,uVar11);
LAB_00499fc4:
	iVar6 = param_1[7];
	if (DAT_004b398c < DAT_004b399c) {
		if ((iVar6 < DAT_004b398c) || (DAT_004b399c < iVar6)) {
			return 0;
		}
		if ((DAT_004b398c < iVar6) && (iVar6 < DAT_004b399c)) {
			return 1;
		}
	}
	else {
		if ((iVar6 < DAT_004b399c) || (DAT_004b398c < iVar6)) {
			return 1;
		}
		if ((DAT_004b399c < iVar6) && (iVar6 < DAT_004b398c)) {
			return 0;
		}
	}
	iVar2 = (*param_1 + (param_1[1] + param_1[2] * 0x3c) * 0x3c) * 1000;
	if (iVar6 != DAT_004b398c) {
		return (uint)(iVar2 < DAT_004b39a0);
	}
	return (uint)(DAT_004b3990 <= iVar2);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl
std::internal::__unkftime__0049a060
					(int param_1,int param_2,uint param_3,int param_4,int param_5,int param_6,int param_7,
					int param_8,int param_9,int param_10,int param_11)
{
	int iVar1;
	int iVar2;
	
	if (param_2 == 1) {
		if ((param_3 & 3) == 0) {
			iVar1 = *(int *)(&DAT_004b39a4 + param_4 * 4);
		}
		else {
			iVar1 = *(int *)(&DAT_004b39dc + param_4 * 4);
		}
		iVar2 = (int)(((int)(param_3 - 1) >> 2) + -0x63db + param_3 * 0x16d + iVar1 + 1) % 7;
		if (iVar2 < param_6) {
			iVar1 = iVar1 + -6 + (param_5 * 7 - iVar2) + param_6;
		}
		else {
			iVar1 = iVar1 + 1 + (param_5 * 7 - iVar2) + param_6;
		}
		if (param_5 == 5) {
			if ((param_3 & 3) == 0) {
				iVar2 = *(int *)(&DAT_004b39a8 + param_4 * 4);
			}
			else {
				iVar2 = *(int *)(&DAT_004b39e0 + param_4 * 4);
			}
			if (iVar2 < iVar1) {
				iVar1 = iVar1 + -7;
			}
		}
	}
	else {
		if ((param_3 & 3) == 0) {
			iVar1 = *(int *)(&DAT_004b39a4 + param_4 * 4);
		}
		else {
			iVar1 = *(int *)(&DAT_004b39dc + param_4 * 4);
		}
		iVar1 = iVar1 + param_7;
	}
	if (param_1 == 1) {
		DAT_004b3988 = param_3;
		DAT_004b398c = iVar1;
		DAT_004b3990 = param_11 + (param_10 + (param_9 + param_8 * 0x3c) * 0x3c) * 1000;
		return;
	}
	DAT_004b39a0 = param_11 + (param_10 + (param_9 + param_8 * 0x3c) * 0x3c + DAT_004b38f8) * 1000;
	if (DAT_004b39a0 < 0) {
		_DAT_004b3998 = param_3;
		DAT_004b399c = iVar1;
		DAT_004b39a0 = DAT_004b39a0 + 86399999;
		return;
	}
	if (86399999 < DAT_004b39a0) {
		DAT_004b39a0 = DAT_004b39a0 + -86399999;
	}
	_DAT_004b3998 = param_3;
	DAT_004b399c = iVar1;
	return;
}



undefined4 __cdecl std::internal::__std_FUN_0049a270(uint param_1,uint param_2,uint *param_3)
{
	uint uVar1;
	undefined4 uVar2;
	
	uVar2 = 0;
	uVar1 = param_2 + param_1;
	if ((uVar1 < param_1) || (uVar1 < param_2)) {
		uVar2 = 1;
	}
	*param_3 = uVar1;
	return uVar2;
}



void __cdecl std::internal::__std_FUN_0049a2a0(uint *param_1,uint *param_2)
{
	int iVar1;
	
	iVar1 = __std_FUN_0049a270(*param_1,*param_2,param_1);
	if (iVar1 != 0) {
		iVar1 = __std_FUN_0049a270(param_1[1],1,param_1 + 1);
		if (iVar1 != 0) {
			param_1[2] = param_1[2] + 1;
		}
	}
	iVar1 = __std_FUN_0049a270(param_1[1],param_2[1],param_1 + 1);
	if (iVar1 != 0) {
		param_1[2] = param_1[2] + 1;
	}
	__std_FUN_0049a270(param_1[2],param_2[2],param_1 + 2);
	return;
}



void __cdecl std::internal::__std_FUN_0049a310(uint *param_1)
{
	uint uVar1;
	uint uVar2;
	
	uVar1 = *param_1;
	uVar2 = param_1[1];
	*param_1 = uVar1 * 2;
	param_1[1] = uVar2 * 2 | uVar1 >> 0x1f;
	param_1[2] = param_1[2] << 1 | uVar2 >> 0x1f;
	return;
}



void __cdecl std::internal::__std_FUN_0049a340(uint *param_1)
{
	uint uVar1;
	
	uVar1 = param_1[1];
	param_1[1] = uVar1 >> 1 | param_1[2] << 0x1f;
	param_1[2] = param_1[2] >> 1;
	*param_1 = *param_1 >> 1 | uVar1 << 0x1f;
	return;
}



void __cdecl std::internal::__std_FUN_0049a370(char *param_1,int param_2,uint *param_3)
{
	uint uVar1;
	uint *puVar2;
	short sVar3;
	uint local_c;
	uint local_8;
	uint local_4;
	
	puVar2 = param_3;
	sVar3 = 0x404e;
	*param_3 = 0;
	param_3[1] = 0;
	param_3[2] = 0;
	if (param_2 != 0) {
		param_3 = (uint *)param_2;
		do {
			local_c = *puVar2;
			local_8 = puVar2[1];
			local_4 = puVar2[2];
			__std_FUN_0049a310(puVar2);
			__std_FUN_0049a310(puVar2);
			__std_FUN_0049a2a0(puVar2,&local_c);
			__std_FUN_0049a310(puVar2);
			local_c = SEXT14(*param_1);
			local_8 = 0;
			local_4 = 0;
			__std_FUN_0049a2a0(puVar2,&local_c);
			param_1 = param_1 + 1;
			param_3 = (uint *)((int)param_3 + -1);
		} while (param_3 != (uint *)0x0);
	}
	uVar1 = puVar2[2];
	while (uVar1 == 0) {
		sVar3 = sVar3 + -0x10;
		puVar2[2] = puVar2[1] >> 0x10;
		uVar1 = puVar2[2];
		puVar2[1] = *puVar2 >> 0x10 | puVar2[1] << 0x10;
		*puVar2 = *puVar2 << 0x10;
	}
	uVar1 = puVar2[2];
	while ((uVar1 & 0x8000) == 0) {
		__std_FUN_0049a310(puVar2);
		sVar3 = sVar3 + -1;
		uVar1 = puVar2[2];
	}
	*(short *)((int)puVar2 + 10) = sVar3;
	return;
}



// WARNING: Could not reconcile some variable overlaps

undefined4 __cdecl
std::internal::__std_FUN_0049a470
					(uint param_1,uint param_2,uint param_3,int param_4,byte param_5,short *param_6)
{
	short *psVar1;
	ushort uVar2;
	char cVar3;
	uint uVar4;
	int iVar5;
	short *psVar6;
	short *psVar7;
	int iVar8;
	short sVar9;
	int iVar10;
	undefined local_1c;
	undefined local_1b;
	undefined local_1a;
	undefined local_19;
	undefined local_18;
	undefined local_17;
	undefined local_16;
	undefined local_15;
	undefined local_14;
	undefined local_13;
	undefined local_12;
	undefined local_11;
	undefined2 local_10;
	undefined4 uStack14;
	undefined4 uStack10;
	undefined local_6;
	char cStack5;
	
	psVar1 = param_6;
	local_1c = 0xcc;
	local_1b = 0xcc;
	local_1a = 0xcc;
	local_19 = 0xcc;
	local_18 = 0xcc;
	local_17 = 0xcc;
	local_16 = 0xcc;
	local_15 = 0xcc;
	local_14 = 0xcc;
	local_13 = 0xcc;
	uVar4 = param_3 & 0x7fff;
	local_12 = 0xfb;
	local_11 = 0x3f;
	if ((param_3 & 0x8000) == 0) {
		*(undefined *)(param_6 + 1) = 0x20;
	}
	else {
		*(undefined *)(param_6 + 1) = 0x2d;
	}
	if ((((short)uVar4 == 0) && (param_2 == 0)) && (param_1 == 0)) {
		*param_6 = 0;
LAB_0049a67f:
		*(undefined *)(psVar1 + 1) = 0x20;
		*(undefined *)((int)psVar1 + 3) = 1;
		*(undefined *)(psVar1 + 2) = 0x30;
		*(undefined *)((int)psVar1 + 5) = 0;
		return 1;
	}
	if ((short)uVar4 == 0x7fff) {
		*param_6 = 1;
		if (((param_2 != 0x80000000) || (param_1 != 0)) && ((param_2 & 0x40000000) == 0)) {
			*(undefined4 *)(param_6 + 2) = 0x4e532331;
			param_6[4] = 0x4e41;
			*(undefined *)((int)param_6 + 3) = 6;
			*(undefined *)(param_6 + 5) = 0;
			return 0;
		}
		if ((((param_3 & 0x8000) != 0) && (param_2 == 0xc0000000)) && (param_1 == 0)) {
			*(undefined4 *)(param_6 + 2) = 0x4e492331;
			*(undefined *)((int)param_6 + 3) = 5;
			param_6[4] = 0x44;
			return 0;
		}
		if ((param_2 == 0x80000000) && (param_1 == 0)) {
			*(undefined4 *)(param_6 + 2) = 0x4e492331;
			*(undefined *)((int)param_6 + 3) = 5;
			param_6[4] = 0x46;
			return 0;
		}
		*(undefined4 *)(param_6 + 2) = 0x4e512331;
		param_6[4] = 0x4e41;
		*(undefined *)((int)param_6 + 3) = 6;
		*(undefined *)(param_6 + 5) = 0;
		return 0;
	}
	local_6 = (undefined)uVar4;
	cStack5 = (char)(uVar4 >> 8);
	local_10 = 0;
	sVar9 = (short)(((uVar4 >> 8) + (param_2 >> 0x18) * 2) * 0x4d + -0x134312f4 + uVar4 * 0x4d10 >>
								 0x10);
	uStack10 = param_2;
	uStack14 = param_1;
	__std_FUN_0049aac0((int *)&local_10,-(int)sVar9,1);
	if (0x3ffe < CONCAT11(cStack5,local_6)) {
		sVar9 = sVar9 + 1;
		__std_FUN_0049a800((int *)&local_10,(int *)&local_1c);
	}
	*psVar1 = sVar9;
	iVar8 = param_4;
	if (((param_5 & 1) != 0) && (iVar8 = param_4 + sVar9, param_4 + sVar9 < 1)) {
		*psVar1 = 0;
		goto LAB_0049a67f;
	}
	if (0x15 < iVar8) {
		iVar8 = 0x15;
	}
	uVar2 = CONCAT11(cStack5,local_6);
	local_6 = 0;
	cStack5 = '\0';
	iVar5 = 8;
	iVar10 = uVar2 - 0x3ffe;
	do {
		__std_FUN_0049a310((uint *)&local_10);
		iVar5 = iVar5 + -1;
	} while (iVar5 != 0);
	if (iVar10 < 0) {
		for (uVar4 = -iVar10 & 0xff; uVar4 != 0; uVar4 = uVar4 - 1) {
			__std_FUN_0049a340((uint *)&local_10);
		}
	}
	psVar1 = psVar1 + 2;
	iVar8 = iVar8 + 1;
	psVar6 = psVar1;
	if (0 < iVar8) {
		do {
			uStack10._2_2_ = (undefined2)(uStack10 >> 0x10);
			uStack14._2_2_ = (undefined2)(uStack14 >> 0x10);
			param_1 = CONCAT22((undefined2)uStack14,local_10);
			param_2 = CONCAT22((undefined2)uStack10,uStack14._2_2_);
			param_3 = CONCAT13(cStack5,CONCAT12(local_6,uStack10._2_2_));
			__std_FUN_0049a310((uint *)&local_10);
			__std_FUN_0049a310((uint *)&local_10);
			__std_FUN_0049a2a0((uint *)&local_10,&param_1);
			__std_FUN_0049a310((uint *)&local_10);
			cVar3 = cStack5 + '0';
			cStack5 = '\0';
			*(char *)psVar6 = cVar3;
			psVar6 = (short *)((int)psVar6 + 1);
			iVar8 = iVar8 + -1;
		} while (iVar8 != 0);
	}
	psVar7 = psVar6 + -1;
	if (*(char *)((int)psVar6 + -1) < '5') {
		if (psVar1 <= psVar7) {
			do {
				if (*(char *)psVar7 != '0') break;
				psVar7 = (short *)((int)psVar7 + -1);
			} while (psVar1 <= psVar7);
			if (psVar1 <= psVar7) goto LAB_0049a7d6;
		}
		*(char *)psVar1 = '0';
		*param_6 = 0;
		*(undefined *)(param_6 + 1) = 0x20;
		*(undefined *)((int)param_6 + 3) = 1;
		*(undefined *)((int)param_6 + 5) = 0;
		return 1;
	}
	if (psVar1 <= psVar7) {
		do {
			if (*(char *)psVar7 != '9') break;
			*(char *)psVar7 = '0';
			psVar7 = (short *)((int)psVar7 + -1);
		} while (psVar1 <= psVar7);
		if (psVar1 <= psVar7) {
			*(char *)psVar7 = *(char *)psVar7 + '\x01';
			goto LAB_0049a7d6;
		}
	}
	psVar7 = (short *)((int)psVar7 + 1);
	*param_6 = *param_6 + 1;
	*(char *)psVar7 = *(char *)psVar7 + '\x01';
LAB_0049a7d6:
	cVar3 = ((char)psVar7 - (char)param_6) + -3;
	*(char *)((int)param_6 + 3) = cVar3;
	*(undefined *)((int)param_6 + cVar3 + 4) = 0;
	return 1;
}



void __cdecl std::internal::__std_FUN_0049a800(int *param_1,int *param_2)
{
	ushort uVar1;
	int iVar2;
	ushort uVar3;
	ushort uVar4;
	int iVar5;
	ushort uVar6;
	int *piVar7;
	int *piVar8;
	short *local_20;
	int local_18;
	int local_14;
	int local_10;
	byte local_c;
	undefined uStack11;
	undefined2 uStack10;
	short local_8;
	undefined2 uStack6;
	undefined2 local_4;
	ushort uStack2;
	
	local_14 = 0;
	local_c = 0;
	uStack11 = 0;
	uStack10 = 0;
	local_8 = 0;
	uStack6 = 0;
	uVar3 = *(ushort *)((int)param_2 + 10) & 0x7fff;
	uVar1 = *(ushort *)((int)param_1 + 10) & 0x7fff;
	uVar6 = (*(ushort *)((int)param_2 + 10) ^ *(ushort *)((int)param_1 + 10)) & 0x8000;
	uVar4 = uVar3 + uVar1;
	local_4 = 0;
	uStack2 = 0;
	if (((0x7ffe < uVar1) || (0x7ffe < uVar3)) || (0xbffd < uVar4)) {
		param_1[1] = 0;
		*param_1 = 0;
		param_1[2] = (-(uint)(uVar6 != 0) & 0x80000000) + 0x7fff8000;
		return;
	}
	if (uVar4 < 0x3fc0) {
		param_1[2] = 0;
		param_1[1] = 0;
		*param_1 = 0;
		return;
	}
	if (((uVar1 == 0) && (uVar4 = uVar4 + 1, (param_1[2] & 0x7fffffffU) == 0)) &&
		 ((param_1[1] == 0 && (*param_1 == 0)))) {
		*(undefined2 *)((int)param_1 + 10) = 0;
		return;
	}
	if (((uVar3 == 0) && (uVar4 = uVar4 + 1, (param_2[2] & 0x7fffffffU) == 0)) &&
		 ((param_2[1] == 0 && (*param_2 == 0)))) {
		param_1[2] = 0;
		param_1[1] = 0;
		*param_1 = 0;
		return;
	}
	local_20 = &local_8;
	local_18 = 0;
	iVar5 = 5;
	do {
		if (0 < iVar5) {
			piVar8 = param_2 + 2;
			piVar7 = (int *)(local_18 * 2 + (int)param_1);
			local_10 = iVar5;
			do {
				iVar2 = __std_FUN_0049a270(*(uint *)(local_20 + -2),
																	 (uint)*(ushort *)piVar8 * (uint)*(ushort *)piVar7,
																	 (uint *)(local_20 + -2));
				if (iVar2 != 0) {
					*local_20 = *local_20 + 1;
				}
				piVar7 = (int *)((int)piVar7 + 2);
				piVar8 = (int *)((int)piVar8 + -2);
				local_10 = local_10 + -1;
			} while (local_10 != 0);
		}
		local_20 = local_20 + 1;
		local_18 = local_18 + 1;
		iVar5 = iVar5 + -1;
	} while (0 < iVar5);
	uVar4 = uVar4 + 0xc002;
	while ((0 < (short)uVar4 && ((uStack2 & 0x8000) == 0))) {
		__std_FUN_0049a310((uint *)&local_c);
		uVar4 = uVar4 - 1;
	}
	if ((short)uVar4 < 1) {
		uVar4 = uVar4 - 1;
		if ((short)uVar4 < 0) {
			iVar5 = -(int)(short)uVar4;
			uVar4 = uVar4 + (short)iVar5;
			do {
				if ((local_c & 1) != 0) {
					local_14 = local_14 + 1;
				}
				__std_FUN_0049a340((uint *)&local_c);
				iVar5 = iVar5 + -1;
			} while (iVar5 != 0);
		}
		if (local_14 != 0) {
			local_c = local_c | 1;
		}
	}
	if ((0x8000 < CONCAT11(uStack11,local_c)) ||
		 ((CONCAT22(uStack10,CONCAT11(uStack11,local_c)) & 0x1ffff) == 0x18000)) {
		if (CONCAT22(local_8,uStack10) == -1) {
			uStack10 = 0;
			local_8 = 0;
			if (CONCAT22(local_4,uStack6) == -1) {
				uStack6 = 0;
				local_4 = 0;
				if (uStack2 == 0xffff) {
					uStack2 = 0x8000;
					uVar4 = uVar4 + 1;
				}
				else {
					uStack2 = uStack2 + 1;
				}
			}
			else {
				iVar5 = CONCAT22(local_4,uStack6) + 1;
				uStack6 = (undefined2)iVar5;
				local_4 = (undefined2)((uint)iVar5 >> 0x10);
			}
		}
		else {
			iVar5 = CONCAT22(local_8,uStack10) + 1;
			uStack10 = (undefined2)iVar5;
			local_8 = (short)((uint)iVar5 >> 0x10);
		}
	}
	if (0x7ffe < uVar4) {
		param_1[1] = 0;
		*param_1 = 0;
		param_1[2] = (-(uint)(uVar6 != 0) & 0x80000000) + 0x7fff8000;
		return;
	}
	*(undefined2 *)param_1 = uStack10;
	*(uint *)((int)param_1 + 2) = CONCAT22(uStack6,local_8);
	*(uint *)((int)param_1 + 6) = CONCAT22(uStack2,local_4);
	*(ushort *)((int)param_1 + 10) = uVar4 | uVar6;
	return;
}



void __cdecl std::internal::__std_FUN_0049aac0(int *param_1,uint param_2,int param_3)
{
	uint uVar1;
	int iVar2;
	int *piVar3;
	int iVar4;
	undefined2 local_c;
	undefined2 uStack10;
	undefined2 local_8;
	undefined2 uStack6;
	int local_4;
	
	iVar4 = 0x4b39b8;
	if (param_2 != 0) {
		if ((int)param_2 < 0) {
			param_2 = -param_2;
			iVar4 = 0x4b3b18;
		}
		if (param_3 == 0) {
			*(undefined2 *)param_1 = 0;
		}
		while (param_2 != 0) {
			iVar4 = iVar4 + 0x54;
			uVar1 = param_2 & 7;
			param_2 = (int)param_2 >> 3;
			if (uVar1 != 0) {
				piVar3 = (int *)(iVar4 + uVar1 * 0xc);
				if (0x7fff < *(ushort *)(iVar4 + uVar1 * 0xc)) {
					local_c = (undefined2)*piVar3;
					uStack10 = (undefined2)((uint)*piVar3 >> 0x10);
					local_8 = (undefined2)piVar3[1];
					uStack6 = (undefined2)((uint)piVar3[1] >> 0x10);
					local_4 = piVar3[2];
					iVar2 = CONCAT22(local_8,uStack10) + -1;
					uStack10 = (undefined2)iVar2;
					local_8 = (undefined2)((uint)iVar2 >> 0x10);
					piVar3 = (int *)&local_c;
				}
				__std_FUN_0049a800(param_1,piVar3);
			}
		}
	}
	return;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

int std::internal::__fsunk__0049ab50(byte param_1)
{
	DWORD DVar1;
	DWORD DVar2;
	char *pcVar3;
	int iVar4;
	HANDLE hFile;
	BOOL BVar5;
	int iVar6;
	int iVar7;
	char *pcVar8;
	undefined4 *puVar9;
	undefined3 in_stack_00000005;
	int in_stack_00000008;
	undefined4 auStack4096 [1023];
	undefined4 uStack4;
	
	uStack4 = 0x49ab5a;
	iVar7 = 0;
	if ((_param_1 < globals::__UINT_0076eec0) &&
		 ((*(byte *)((&DAT_0076edc0)[(int)_param_1 >> 5] + 4 + (param_1 & 0x1f) * 8) & 1) != 0)) {
		DVar1 = __fdread__00496ec0(_param_1,0,1);
		if ((DVar1 != 0xffffffff) && (DVar2 = __fdread__00496ec0(_param_1,0,2), DVar2 != 0xffffffff)) {
			pcVar8 = (char *)(in_stack_00000008 - DVar2);
			if ((int)pcVar8 < 1) {
				if ((int)pcVar8 < 0) {
					__fdread__00496ec0(_param_1,in_stack_00000008,0);
					hFile = (HANDLE)__fdunk__004994b0(_param_1);
					BVar5 = SetEndOfFile(hFile);
					iVar7 = (BVar5 != 0) - 1;
					if (iVar7 == -1) {
						std::globals::g_msvc_errno = 0xd;
						std::globals::g_msvc_doserrno = GetLastError();
					}
				}
				__fdread__00496ec0(_param_1,DVar1,0);
				return iVar7;
			}
			puVar9 = auStack4096;
			for (iVar6 = 0x400; iVar6 != 0; iVar6 = iVar6 + -1) {
				*puVar9 = 0;
				puVar9 = puVar9 + 1;
			}
			iVar6 = __fsunk__0049b160(_param_1,0x8000);
			while( true ) {
				pcVar3 = (char *)0x1000;
				if ((int)pcVar8 < 0x1000) {
					pcVar3 = pcVar8;
				}
				iVar4 = __fdwrite__00496f80(_param_1,(char *)auStack4096,pcVar3);
				if (iVar4 == -1) break;
				pcVar8 = pcVar8 + -iVar4;
				if ((int)pcVar8 < 1) {
LAB_0049ac31:
					__fsunk__0049b160(_param_1,iVar6);
					__fdread__00496ec0(_param_1,DVar1,0);
					return iVar7;
				}
			}
			if (std::globals::g_msvc_doserrno == 5) {
				std::globals::g_msvc_errno = 0xd;
			}
			iVar7 = -1;
			goto LAB_0049ac31;
		}
	}
	else {
		std::globals::g_msvc_errno = 9;
	}
	return -1;
}



undefined4 __cdecl std::internal::__std_FUN_0049acd0(int param_1)
{
	int iVar1;
	int iVar2;
	undefined *puVar3;
	undefined4 *puVar4;
	int iVar5;
	code *pcVar6;
	int iVar7;
	code **ppcVar8;
	
	iVar2 = param_1;
	switch(param_1) {
	case 2:
		ppcVar8 = &DAT_0054a4f8;
		pcVar6 = DAT_0054a4f8;
		break;
	default:
		return 0xffffffff;
	case 4:
	case 8:
	case 0xb:
		puVar3 = __std_FUN_0049ae50(param_1);
		ppcVar8 = (code **)(puVar3 + 8);
		pcVar6 = *ppcVar8;
		break;
	case 0xf:
		ppcVar8 = &DAT_0054a504;
		pcVar6 = DAT_0054a504;
		break;
	case 0x15:
		ppcVar8 = &DAT_0054a4fc;
		pcVar6 = DAT_0054a4fc;
		break;
	case 0x16:
		ppcVar8 = &DAT_0054a500;
		pcVar6 = DAT_0054a500;
	}
	if (pcVar6 == (code *)0x1) {
		return 0;
	}
	if (pcVar6 == (code *)0x0) {
		quick_exit(3);
	}
	iVar1 = DAT_0054a1a4;
	iVar5 = DAT_004b332c;
	if (((param_1 == 8) || (param_1 == 0xb)) || (iVar7 = param_1, param_1 == 4)) {
		DAT_0054a1a4 = 0;
		iVar7 = iVar1;
		if (param_1 == 8) {
			DAT_004b332c = 0x8c;
			param_1 = iVar5;
			goto LAB_0049ad8f;
		}
	}
	else {
LAB_0049ad8f:
		if (iVar2 == 8) {
			if (DAT_004b3320 < DAT_004b3324 + DAT_004b3320) {
				iVar5 = (DAT_004b3324 + DAT_004b3320) - DAT_004b3320;
				puVar4 = (undefined4 *)(DAT_004b3320 * 0xc + 0x4b32b0);
				do {
					*puVar4 = 0;
					puVar4 = puVar4 + 3;
					iVar5 = iVar5 + -1;
				} while (iVar5 != 0);
			}
			goto LAB_0049adc6;
		}
	}
	*ppcVar8 = (code *)0x0;
LAB_0049adc6:
	if (iVar2 == 8) {
		(*pcVar6)(8,DAT_004b332c);
	}
	else {
		(*pcVar6)(iVar2);
		if ((iVar2 != 0xb) && (iVar2 != 4)) {
			return 0;
		}
	}
	if (iVar2 == 8) {
		DAT_004b332c = param_1;
	}
	DAT_0054a1a4 = iVar7;
	return 0;
}



undefined * __cdecl std::internal::__std_FUN_0049ae50(int param_1)
{
	int *piVar1;
	undefined *puVar2;
	undefined *puVar3;
	
	puVar2 = &DAT_004b32a8;
	if (DAT_004b32ac != param_1) {
		puVar3 = puVar2;
		do {
			puVar2 = puVar3 + 0xc;
			if (&DAT_004b32a8 + DAT_004b3328 * 0xc <= puVar2) break;
			piVar1 = (int *)(puVar3 + 0x10);
			puVar3 = puVar2;
		} while (*piVar1 != param_1);
	}
	if ((&DAT_004b32a8 + DAT_004b3328 * 0xc <= puVar2) || (*(int *)(puVar2 + 4) != param_1)) {
		puVar2 = (undefined *)0x0;
	}
	return puVar2;
}



uint __cdecl std::internal::__unkftime__0049aea0(LPSTR param_1,ushort *param_2,uint param_3)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	DWORD DVar4;
	int iVar5;
	int iVar6;
	ushort *lpWideCharStr;
	int local_4;
	
	uVar3 = param_3;
	lpWideCharStr = param_2;
	uVar2 = 0;
	local_4 = 0;
	if ((param_1 != (LPSTR)0x0) && (param_3 == 0)) {
		return uVar2;
	}
	if (param_1 == (LPSTR)0x0) {
		if (DAT_0054a180 == 0) {
			uVar3 = __unkftime__004999d0((short *)param_2);
			return uVar3;
		}
		iVar5 = WideCharToMultiByte(DAT_0054a190,0x220,(LPCWSTR)param_2,-1,(LPSTR)0x0,0,(LPCSTR)0x0,
																&local_4);
		if ((iVar5 != 0) && (local_4 == 0)) {
			return iVar5 - 1;
		}
	}
	else {
		if (DAT_0054a180 == 0) {
			if (param_3 == 0) {
				return 0;
			}
			while (*param_2 < 0x100) {
				param_1[uVar2] = *(CHAR *)param_2;
				if (*param_2 == 0) {
					return uVar2;
				}
				uVar2 = uVar2 + 1;
				param_2 = param_2 + 1;
				if (param_3 <= uVar2) {
					return uVar2;
				}
			}
		}
		else {
			if (std::globals::_pcharwidth == 1) {
				if (param_3 != 0) {
					uVar3 = __unkftime__0049b090((short *)param_2,param_3);
				}
				uVar3 = WideCharToMultiByte(DAT_0054a190,0x220,(LPCWSTR)lpWideCharStr,uVar3,param_1,uVar3,
																		(LPCSTR)0x0,&local_4);
				if ((uVar3 != 0) && (local_4 == 0)) {
					if (param_1[uVar3 - 1] == '\0') {
						return uVar3 - 1;
					}
					return uVar3;
				}
			}
			else {
				uVar2 = WideCharToMultiByte(DAT_0054a190,0x220,(LPCWSTR)param_2,-1,param_1,param_3,
																		(LPCSTR)0x0,&local_4);
				if (uVar2 == 0) {
					if ((local_4 == 0) && (DVar4 = GetLastError(), DVar4 == 0x7a)) {
						if (uVar3 != 0) {
							do {
								iVar5 = WideCharToMultiByte(DAT_0054a190,0,(LPCWSTR)lpWideCharStr,1,(LPSTR)&param_2,
																						std::globals::_pcharwidth,(LPCSTR)0x0,&local_4);
								if (iVar5 == 0) {
									std::globals::g_msvc_errno = 0x2a;
									return 0xffffffff;
								}
								if (local_4 != 0) {
									std::globals::g_msvc_errno = 0x2a;
									return 0xffffffff;
								}
								if (uVar3 < iVar5 + uVar2) {
									return uVar2;
								}
								iVar6 = 0;
								if (0 < iVar5) {
									do {
										cVar1 = *(char *)((int)&param_2 + iVar6);
										param_1[uVar2] = cVar1;
										if (cVar1 == '\0') {
											return uVar2;
										}
										iVar6 = iVar6 + 1;
										uVar2 = uVar2 + 1;
									} while (iVar6 < iVar5);
								}
								lpWideCharStr = lpWideCharStr + 1;
							} while (uVar2 < uVar3);
						}
						return uVar2;
					}
				}
				else {
					if (local_4 == 0) {
						return uVar2 - 1;
					}
				}
			}
		}
	}
	std::globals::g_msvc_errno = 0x2a;
	return 0xffffffff;
}



int __cdecl std::internal::__unkftime__0049b090(short *param_1,int param_2)
{
	short *psVar1;
	int iVar2;
	
	psVar1 = param_1;
	iVar2 = param_2;
	if (param_2 != 0) {
		do {
			if (*psVar1 == 0) break;
			psVar1 = psVar1 + 1;
			iVar2 = iVar2 + -1;
		} while (iVar2 != 0);
		if ((iVar2 != 0) && (*psVar1 == 0)) {
			return ((int)((int)psVar1 - (int)param_1) >> 1) + 1;
		}
	}
	return param_2;
}



byte * __cdecl std::internal::__unkftime__0049b0d0(byte *param_1)
{
	byte bVar1;
	LPCWSTR pWVar2;
	LPWSTR pWVar3;
	uint uVar4;
	LPWSTR pWVar5;
	uint uVar6;
	byte *pbVar7;
	byte **ppbVar8;
	byte *pbVar9;
	
	if (((DAT_0054a0f8 != (byte **)0x0) ||
			(((DAT_0054a100 == 0 || (pWVar2 = __unkftime__0049b220(), pWVar2 == (LPCWSTR)0x0)) &&
			 (DAT_0054a0f8 != (byte **)0x0)))) && (param_1 != (byte *)0x0)) {
		uVar4 = 0xffffffff;
		pbVar7 = *DAT_0054a0f8;
		pbVar9 = param_1;
		do {
			if (uVar4 == 0) break;
			uVar4 = uVar4 - 1;
			bVar1 = *pbVar9;
			pbVar9 = pbVar9 + 1;
		} while (bVar1 != 0);
		pWVar5 = (LPWSTR)(~uVar4 - 1);
		ppbVar8 = DAT_0054a0f8;
		if (pbVar7 != (byte *)0x0) {
			do {
				uVar6 = 0xffffffff;
				pbVar9 = pbVar7;
				do {
					if (uVar6 == 0) break;
					uVar6 = uVar6 - 1;
					bVar1 = *pbVar9;
					pbVar9 = pbVar9 + 1;
				} while (bVar1 != 0);
				if (((pWVar5 < (LPWSTR)(~uVar6 - 1)) && (*(char *)((int)pWVar5 + (int)pbVar7) == '=')) &&
					 (pWVar3 = __unkftime__0049b1e0(pbVar7,param_1,pWVar5), pWVar3 == (LPWSTR)0x0)) {
					return *ppbVar8 + ~uVar4;
				}
				pbVar7 = ppbVar8[1];
				ppbVar8 = ppbVar8 + 1;
				if (pbVar7 == (byte *)0x0) {
					return (byte *)0x0;
				}
			} while( true );
		}
	}
	return (byte *)0x0;
}



int __cdecl std::internal::__fsunk__0049b160(uint param_1,int param_2)
{
	byte bVar1;
	byte bVar2;
	
	if (param_1 < globals::__UINT_0076eec0) {
		bVar1 = *(byte *)((&DAT_0076edc0)[(int)param_1 >> 5] + 4 + (param_1 & 0x1f) * 8);
		if ((bVar1 & 1) != 0) {
			if (param_2 == 0x8000) {
				bVar2 = bVar1 & 0x7f;
			}
			else {
				if (param_2 != 0x4000) {
					std::globals::g_msvc_errno = 0x16;
					return -1;
				}
				bVar2 = bVar1 | 0x80;
			}
			*(byte *)((&DAT_0076edc0)[(int)param_1 >> 5] + 4 + (param_1 & 0x1f) * 8) = bVar2;
			return (-(uint)((bVar1 & 0x80) != 0) & 0xffffc000) + 0x8000;
		}
	}
	std::globals::g_msvc_errno = 9;
	return -1;
}



LPWSTR __cdecl std::internal::__unkftime__0049b1e0(byte *param_1,byte *param_2,LPWSTR param_3)
{
	int iVar1;
	
	if (param_3 == (LPWSTR)0x0) {
		return param_3;
	}
	iVar1 = __unkftime__0049b2a0(DAT_0054a3c0,1,param_1,param_3,param_2,(char *)param_3,DAT_0054a3bc);
	if (iVar1 == 0) {
		return (LPWSTR)0x7fffffff;
	}
	return (LPWSTR)(iVar1 + -2);
}



LPCWSTR std::internal::__unkftime__0049b220(void)
{
	LPCWSTR lpWideCharStr;
	uint length;
	uint *lpMultiByteStr;
	int iVar1;
	LPCWSTR *ppWVar2;
	
	lpWideCharStr = *DAT_0054a100;
	ppWVar2 = DAT_0054a100;
	if (lpWideCharStr == (LPCWSTR)0x0) {
		return (LPCWSTR)0x0;
	}
	while (((length = WideCharToMultiByte(1,0,lpWideCharStr,-1,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0),
					length != 0 && (lpMultiByteStr = (uint *)malloc(length), lpMultiByteStr != (uint *)0x0))
				 && (iVar1 = WideCharToMultiByte(1,0,*ppWVar2,-1,(LPSTR)lpMultiByteStr,length,(LPCSTR)0x0,
																				 (LPBOOL)0x0), iVar1 != 0))) {
		__unkftime__0049b570(lpMultiByteStr,0);
		lpWideCharStr = ppWVar2[1];
		ppWVar2 = ppWVar2 + 1;
		if (lpWideCharStr == (LPCWSTR)0x0) {
			return lpWideCharStr;
		}
	}
	return (LPCWSTR)0xffffffff;
}



int __cdecl
std::internal::__unkftime__0049b2a0
					(LCID param_1,DWORD param_2,byte *param_3,LPWSTR param_4,byte *param_5,char *param_6,
					UINT param_7)
{
	int iVar1;
	LPWSTR cbMultiByte;
	BOOL BVar2;
	byte *pbVar3;
	PCNZWCH lpWideCharStr;
	int iVar4;
	int iVar5;
	int local_18;
	_cpinfo local_14;
	
	if (DAT_0054a510 == 0) {
		iVar1 = CompareStringA(0,0,(PCNZCH)&lpSrcStr_0049fd38,1,(PCNZCH)&lpSrcStr_0049fd38,1);
		if (iVar1 == 0) {
			iVar1 = CompareStringW(0,0,(PCNZWCH)&lpSrcStr_0049fd3c,1,(PCNZWCH)&lpSrcStr_0049fd3c,1);
			if (iVar1 == 0) {
				return 0;
			}
			DAT_0054a510 = 1;
		}
		else {
			DAT_0054a510 = 2;
		}
	}
	cbMultiByte = param_4;
	if (0 < (int)param_4) {
		cbMultiByte = (LPWSTR)__unkftime_uprlwr__00494180((char *)param_3,(int)param_4);
	}
	if (0 < (int)param_6) {
		param_6 = __unkftime_uprlwr__00494180((char *)param_5,(int)param_6);
	}
	if (DAT_0054a510 == 2) {
		iVar1 = CompareStringA(param_1,param_2,(PCNZCH)param_3,(int)cbMultiByte,(PCNZCH)param_5,
													 (int)param_6);
		return iVar1;
	}
	local_18 = DAT_0054a510;
	if (DAT_0054a510 == 1) {
		local_18 = 0;
		param_4 = (LPWSTR)0x0;
		if (param_7 == 0) {
			param_7 = DAT_0054a190;
		}
		if ((cbMultiByte == (LPWSTR)0x0) || (param_6 == (char *)0x0)) {
			if (cbMultiByte == (LPWSTR)param_6) {
				return 2;
			}
			if (1 < (int)param_6) {
				return 1;
			}
			if (1 < (int)cbMultiByte) {
				return 3;
			}
			BVar2 = GetCPInfo(param_7,(LPCPINFO)&local_14);
			if (BVar2 == 0) {
				return 0;
			}
			if (0 < (int)cbMultiByte) {
				if (local_14.MaxCharSize < 2) {
					return 3;
				}
				pbVar3 = local_14.LeadByte;
				while( true ) {
					if ((local_14.LeadByte[0] == 0) || (pbVar3[1] == 0)) {
						return 3;
					}
					if ((*pbVar3 <= *param_3) && (*param_3 <= pbVar3[1])) break;
					local_14.LeadByte[0] = pbVar3[2];
					pbVar3 = pbVar3 + 2;
				}
				return 2;
			}
			if (0 < (int)param_6) {
				if (local_14.MaxCharSize < 2) {
					return 1;
				}
				pbVar3 = local_14.LeadByte;
				while( true ) {
					if ((local_14.LeadByte[0] == 0) || (pbVar3[1] == 0)) {
						return 1;
					}
					if ((*pbVar3 <= *param_5) && (*param_5 <= pbVar3[1])) break;
					local_14.LeadByte[0] = pbVar3[2];
					pbVar3 = pbVar3 + 2;
				}
				return 2;
			}
		}
		iVar1 = MultiByteToWideChar(param_7,9,(LPCSTR)param_3,(int)cbMultiByte,(LPWSTR)0x0,0);
		if (iVar1 == 0) {
			return 0;
		}
		lpWideCharStr = (PCNZWCH)malloc(iVar1 * 2);
		if (lpWideCharStr == (PCNZWCH)0x0) {
			return 0;
		}
		iVar4 = MultiByteToWideChar(param_7,1,(LPCSTR)param_3,(int)cbMultiByte,lpWideCharStr,iVar1);
		if ((((iVar4 != 0) &&
				 (iVar4 = MultiByteToWideChar(param_7,9,(LPCSTR)param_5,(int)param_6,(LPWSTR)0x0,0),
				 iVar4 != 0)) && (param_4 = (LPWSTR)malloc(iVar4 * 2), param_4 != (LPWSTR)0x0)) &&
			 (iVar5 = MultiByteToWideChar(param_7,1,(LPCSTR)param_5,(int)param_6,param_4,iVar4),
			 iVar5 != 0)) {
			local_18 = CompareStringW(param_1,param_2,lpWideCharStr,iVar1,param_4,iVar4);
		}
		free(lpWideCharStr);
		free(param_4);
	}
	return local_18;
}



int __cdecl std::internal::__unkftime__0049b570(uint *param_1,int param_2)
{
	char cVar1;
	char *pcVar2;
	char **ppcVar3;
	uint *puVar4;
	LPCWSTR pWVar5;
	int iVar6;
	char **ppcVar7;
	uint *puVar8;
	uint uVar9;
	uint uVar10;
	uint *puVar11;
	uint *puVar12;
	bool bVar13;
	
	if (param_1 == (uint *)0x0) {
		return -1;
	}
	puVar4 = __unkftime__0049b870(param_1,0x3d);
	if (puVar4 == (uint *)0x0) {
		return -1;
	}
	if (param_1 == puVar4) {
		return -1;
	}
	bVar13 = *(char *)((int)puVar4 + 1) == '\0';
	if (DAT_0054a0f8 == DAT_0054a0fc) {
		DAT_0054a0f8 = (char **)__unkftime__0049b800(DAT_0054a0f8);
	}
	if (DAT_0054a0f8 == (char **)0x0) {
		if ((param_2 == 0) || (DAT_0054a100 == (undefined4 *)0x0)) {
			if (bVar13) {
				return 0;
			}
			DAT_0054a0f8 = (char **)malloc(4);
			if (DAT_0054a0f8 == (char **)0x0) {
				return -1;
			}
			*DAT_0054a0f8 = (char *)0x0;
			if (DAT_0054a100 == (undefined4 *)0x0) {
				DAT_0054a100 = (undefined4 *)malloc(4);
				if (DAT_0054a100 == (undefined4 *)0x0) {
					return -1;
				}
				*DAT_0054a100 = 0;
			}
		}
		else {
			pWVar5 = __unkftime__0049b220();
			if (pWVar5 != (LPCWSTR)0x0) {
				return -1;
			}
		}
	}
	ppcVar7 = DAT_0054a0f8;
	puVar4 = (uint *)((int)puVar4 - (int)param_1);
	iVar6 = __unkftime__0049b780((byte *)param_1,(LPWSTR)puVar4);
	if ((iVar6 < 0) || (*ppcVar7 == (char *)0x0)) {
		if (bVar13) {
			return 0;
		}
		if (iVar6 < 0) {
			iVar6 = -iVar6;
		}
		ppcVar7 = (char **)realloc(ppcVar7,iVar6 * 4 + 8);
		if (ppcVar7 == (char **)0x0) {
			return -1;
		}
		ppcVar7[iVar6] = (char *)param_1;
		ppcVar7[iVar6 + 1] = (char *)0x0;
		DAT_0054a0f8 = ppcVar7;
	}
	else {
		if (bVar13) {
			free(ppcVar7[iVar6]);
			pcVar2 = ppcVar7[iVar6];
			ppcVar3 = ppcVar7 + iVar6;
			while (pcVar2 != (char *)0x0) {
				*ppcVar3 = ppcVar3[1];
				iVar6 = iVar6 + 1;
				pcVar2 = ppcVar3[1];
				ppcVar3 = ppcVar3 + 1;
			}
			ppcVar7 = (char **)realloc(ppcVar7,iVar6 * 4);
			if (ppcVar7 != (char **)0x0) {
				DAT_0054a0f8 = ppcVar7;
			}
		}
		else {
			ppcVar7[iVar6] = (char *)param_1;
		}
	}
	if (param_2 != 0) {
		uVar9 = 0xffffffff;
		puVar8 = param_1;
		do {
			if (uVar9 == 0) break;
			uVar9 = uVar9 - 1;
			cVar1 = *(char *)puVar8;
			puVar8 = (uint *)((int)puVar8 + 1);
		} while (cVar1 != '\0');
		puVar8 = (uint *)malloc(~uVar9 + 1);
		if (puVar8 != (uint *)0x0) {
			uVar9 = 0xffffffff;
			do {
				puVar11 = param_1;
				if (uVar9 == 0) break;
				uVar9 = uVar9 - 1;
				puVar11 = (uint *)((int)param_1 + 1);
				cVar1 = *(char *)param_1;
				param_1 = puVar11;
			} while (cVar1 != '\0');
			uVar9 = ~uVar9;
			puVar11 = (uint *)((int)puVar11 - uVar9);
			puVar12 = puVar8;
			for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {
				*puVar12 = *puVar11;
				puVar11 = puVar11 + 1;
				puVar12 = puVar12 + 1;
			}
			for (uVar9 = uVar9 & 3; uVar9 != 0; uVar9 = uVar9 - 1) {
				*(undefined *)puVar12 = *(undefined *)puVar11;
				puVar11 = (uint *)((int)puVar11 + 1);
				puVar12 = (uint *)((int)puVar12 + 1);
			}
			*(undefined *)((int)puVar8 + (int)puVar4) = 0;
			SetEnvironmentVariableA
								((LPCSTR)puVar8,(LPCSTR)(~-(uint)bVar13 & (int)puVar8 + 1 + (int)puVar4));
			free(puVar8);
			return 0;
		}
	}
	return 0;
}



int __cdecl std::internal::__unkftime__0049b780(byte *param_1,LPWSTR param_2)
{
	byte *pbVar1;
	LPWSTR pWVar2;
	byte **ppbVar3;
	
	pbVar1 = *DAT_0054a0f8;
	ppbVar3 = DAT_0054a0f8;
	if (pbVar1 == (byte *)0x0) {
		return 0;
	}
	while ((pWVar2 = __unkftime__0049b1e0(param_1,pbVar1,param_2), pWVar2 != (LPWSTR)0x0 ||
				 (((*ppbVar3)[(int)param_2] != 0x3d && ((*ppbVar3)[(int)param_2] != 0))))) {
		pbVar1 = ppbVar3[1];
		ppbVar3 = ppbVar3 + 1;
		if (pbVar1 == (byte *)0x0) {
			return -((int)((int)ppbVar3 - (int)DAT_0054a0f8) >> 2);
		}
	}
	return (int)((int)ppbVar3 - (int)DAT_0054a0f8) >> 2;
}



undefined4 * __cdecl std::internal::__unkftime__0049b800(char **param_1)
{
	char *pcVar1;
	char **ppcVar2;
	undefined4 *puVar3;
	undefined4 *puVar4;
	int iVar5;
	undefined4 *puVar6;
	
	iVar5 = 0;
	if (param_1 != (char **)0x0) {
		pcVar1 = *param_1;
		ppcVar2 = param_1;
		while (pcVar1 != (char *)0x0) {
			ppcVar2 = ppcVar2 + 1;
			iVar5 = iVar5 + 1;
			pcVar1 = *ppcVar2;
		}
		puVar3 = (undefined4 *)malloc(iVar5 * 4 + 4);
		if (puVar3 == (undefined4 *)0x0) {
			__amsg_exit(9);
		}
		pcVar1 = *param_1;
		puVar6 = puVar3;
		while (pcVar1 != (char *)0x0) {
			param_1 = param_1 + 1;
			puVar4 = __unkftime__0049b920(pcVar1);
			*puVar6 = puVar4;
			puVar6 = puVar6 + 1;
			pcVar1 = *param_1;
		}
		*puVar6 = 0;
		return puVar3;
	}
	return (undefined4 *)0x0;
}



uint * __cdecl std::internal::__unkftime__0049b870(uint *param_1,uint param_2)
{
	uint *puVar1;
	uint uVar2;
	
	if (DAT_0054a3bc == 0) {
		puVar1 = __std_FUN_00491760(param_1,(char)param_2);
		return puVar1;
	}
	uVar2 = (uint)*(byte *)param_1;
	if (*(byte *)param_1 == 0) {
LAB_0049b907:
		return (uint *)((param_2 != uVar2) - 1 & (uint)param_1);
	}
	do {
		if ((*(byte *)((int)&DAT_0054a2b8 + uVar2 + 1) & 4) == 0) {
			puVar1 = param_1;
			if (param_2 == uVar2) goto LAB_0049b907;
		}
		else {
			puVar1 = (uint *)((int)param_1 + 1);
			if (*(byte *)((int)param_1 + 1) == 0) {
				return (uint *)0x0;
			}
			if (param_2 == (uVar2 << 8 | (uint)*(byte *)((int)param_1 + 1))) {
				return param_1;
			}
		}
		uVar2 = (uint)*(byte *)((int)puVar1 + 1);
		param_1 = (uint *)((int)puVar1 + 1);
		if (*(byte *)((int)puVar1 + 1) == 0) {
			return (uint *)((param_2 != uVar2) - 1 & (uint)param_1);
		}
	} while( true );
}



undefined4 * __cdecl std::internal::__unkftime__0049b920(char *param_1)
{
	char cVar1;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	if (param_1 != (char *)0x0) {
		uVar3 = 0xffffffff;
		pcVar6 = param_1;
		do {
			if (uVar3 == 0) break;
			uVar3 = uVar3 - 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
		puVar2 = (undefined4 *)malloc(~uVar3);
		if (puVar2 != (undefined4 *)0x0) {
			uVar3 = 0xffffffff;
			do {
				pcVar6 = param_1;
				if (uVar3 == 0) break;
				uVar3 = uVar3 - 1;
				pcVar6 = param_1 + 1;
				cVar1 = *param_1;
				param_1 = pcVar6;
			} while (cVar1 != '\0');
			uVar3 = ~uVar3;
			puVar5 = (undefined4 *)(pcVar6 + -uVar3);
			puVar7 = puVar2;
			for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
				*puVar7 = *puVar5;
				puVar5 = puVar5 + 1;
				puVar7 = puVar7 + 1;
			}
			for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
				*(undefined *)puVar7 = *(undefined *)puVar5;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
				puVar7 = (undefined4 *)((int)puVar7 + 1);
			}
			return puVar2;
		}
	}
	return (undefined4 *)0x0;
}



HRESULT Direct3DRMCreate(IUnknown **lplpIDirect3DRM)
{
	HRESULT HVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b970. Too many branches
										// WARNING: Treating indirect jump as call
	HVar1 = Direct3DRMCreate(lplpIDirect3DRM);
	return HVar1;
}



Vector3F * D3DRMVectorRandom(Vector3F *d)
{
	Vector3F *pVVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b976. Too many branches
										// WARNING: Treating indirect jump as call
	pVVar1 = D3DRMVectorRandom(d);
	return pVVar1;
}



Vector3F * D3DRMVectorRotate(Vector3F *r,Vector3F *v,Vector3F *axis,float theta)
{
	Vector3F *pVVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b97c. Too many branches
										// WARNING: Treating indirect jump as call
	pVVar1 = D3DRMVectorRotate(r,v,axis,theta);
	return pVVar1;
}



HRESULT DirectDrawEnumerateA(DDENUMCALLBACKA *lpCallback,LPVOID lpContext)
{
	HRESULT HVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b982. Too many branches
										// WARNING: Treating indirect jump as call
	HVar1 = DirectDrawEnumerateA(lpCallback,lpContext);
	return HVar1;
}



HRESULT DirectDrawCreate(LPGUID lpGUID,IDirectDraw **lplpIDirectDraw,LPUNKNOWN pUnkOuter)
{
	HRESULT HVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b988. Too many branches
										// WARNING: Treating indirect jump as call
	HVar1 = DirectDrawCreate(lpGUID,lplpIDirectDraw,pUnkOuter);
	return HVar1;
}



HRESULT AVIStreamInfoA(IAVIStream *pIAVIStream,AVISTREAMINFOA *pAVIStreamInfoA,LONG lSize)
{
	HRESULT HVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b98e. Too many branches
										// WARNING: Treating indirect jump as call
	HVar1 = AVIStreamInfoA(pIAVIStream,pAVIStreamInfoA,lSize);
	return HVar1;
}



IGetFrame * AVIStreamGetFrameOpen(IAVIStream *pIAVIStream,BITMAPINFOHEADER *lpbiWanted)
{
	IGetFrame *pIVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b994. Too many branches
										// WARNING: Treating indirect jump as call
	pIVar1 = AVIStreamGetFrameOpen(pIAVIStream,lpbiWanted);
	return pIVar1;
}



HRESULT AVIStreamOpenFromFileA
									(IAVIStream **lplpIAVIStream,LPCSTR szFile,DWORD fccType,LONG lParam,UINT mode,
									CLSID *pclsidHandler)
{
	HRESULT HVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b99a. Too many branches
										// WARNING: Treating indirect jump as call
	HVar1 = AVIStreamOpenFromFileA(lplpIAVIStream,szFile,fccType,lParam,mode,pclsidHandler);
	return HVar1;
}



ULONG AVIStreamRelease(IAVIStream *pIAVIStream)
{
	ULONG UVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b9a0. Too many branches
										// WARNING: Treating indirect jump as call
	UVar1 = AVIStreamRelease(pIAVIStream);
	return UVar1;
}



LPVOID AVIStreamGetFrame(IGetFrame *pIGetFrame,LONG lPos)
{
	LPVOID pvVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b9a6. Too many branches
										// WARNING: Treating indirect jump as call
	pvVar1 = AVIStreamGetFrame(pIGetFrame,lPos);
	return pvVar1;
}



HRESULT DirectInputCreateA(HINSTANCE hInst,DWORD dwVersion,IUnknown **lplpIDirectInput,
													IUnknown *pUnkOuter)
{
	HRESULT HVar1;
	
										// WARNING: Could not recover jumptable at 0x0049ca68. Too many branches
										// WARNING: Treating indirect jump as call
	HVar1 = DirectInputCreateA(hInst,dwVersion,lplpIDirectInput,pUnkOuter);
	return HVar1;
}



HRESULT DirectSoundCreate(LPGUID lpGuid,IDirectSound **lplpIDirectSound,IUnknown *pUnkOuter)
{
	HRESULT HVar1;
	
										// WARNING: Could not recover jumptable at 0x0049ca6e. Too many branches
										// WARNING: Treating indirect jump as call
	HVar1 = DirectSoundCreate(lpGuid,lplpIDirectSound,pUnkOuter);
	return HVar1;
}



void RtlUnwind(PVOID TargetFrame,PVOID TargetIp,PEXCEPTION_RECORD ExceptionRecord,PVOID ReturnValue)
{
										// WARNING: Could not recover jumptable at 0x0049ca74. Too many branches
										// WARNING: Treating indirect jump as call
	RtlUnwind(TargetFrame,TargetIp,ExceptionRecord,ReturnValue);
	return;
}



// RNC (Rob Northern Compression)
// https://moddingwiki.shikadi.net/wiki/Rob_Northern_Compression

uint __cdecl rnc::RNC_Uncompress(void *bufferIn,void **out_bufferOut)
{
	short sVar1;
	byte *dstBuffer;
	uint uVar2;
	
	uVar2 = *(uint *)((int)bufferIn + 4);
	uVar2 = ((uVar2 & 0xff00) + uVar2 * 0x10000) * 0x100 + (uVar2 >> 0x10 & 0xff) * 0x100 +
					(uVar2 >> 0x18);
	if (out_bufferOut == (void **)0x0) {
		return uVar2;
	}
	dstBuffer = (byte *)std::malloc(uVar2);
	if (dstBuffer != (byte *)0x0) {
		sVar1 = Rnc_Decompress__internal((byte *)bufferIn,dstBuffer);
		if (sVar1 != 0) {
			std::free(dstBuffer);
			return 0;
		}
		*out_bufferOut = dstBuffer;
		return uVar2;
	}
	return 0;
}



short __cdecl rnc::Rnc_Decompress__internal(byte *srcBuffer,byte *dstBuffer)
{
	byte bVar1;
	short sVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	
	iVar3 = std::strncmp((char *)srcBuffer,const::s_RNC,3);
	if (iVar3 != 0) {
		return -1;
	}
	bVar1 = srcBuffer[3];
	if (bVar1 == 0) {
		uVar5 = *(uint *)(srcBuffer + 4);
		uVar4 = (((uVar5 >> 8 & 0xff) + uVar5 * 0x100) * 0x100 + (uVar5 >> 0x10 & 0xff)) * 0x100 +
						(uVar5 >> 0x18);
		puVar6 = (undefined4 *)(srcBuffer + 0x12);
		for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
			*(undefined4 *)dstBuffer = *puVar6;
			puVar6 = puVar6 + 1;
			dstBuffer = (byte *)((int)dstBuffer + 4);
		}
		for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
			*dstBuffer = *(undefined *)puVar6;
			puVar6 = (undefined4 *)((int)puVar6 + 1);
			dstBuffer = (byte *)((int)dstBuffer + 1);
		}
		return 0;
	}
	if (bVar1 == 1) {
		sVar2 = Rnc_Decompress_Method1(srcBuffer,dstBuffer);
		return sVar2;
	}
	if (bVar1 != 2) {
		return -2;
	}
	sVar2 = Rnc_Decompress_Method2(srcBuffer,dstBuffer);
	return sVar2;
}



short __cdecl rnc::Rnc_Decompress_Method1(byte *srcBuffer,byte *dstBuffer)
{
	uint uVar1;
	uint uVar2;
	int iVar3;
	byte *pbVar4;
	
	Rnc_BitStreamInit(srcBuffer,dstBuffer);
	Rnc_BitStreamAdvance(2);
	if (globals::g_RncOutput < globals::g_RncOutputEnd) {
		do {
			Rnc_ReadHuffmanTable(globals::g_RncHuffmanTable_Raw,0x10);
			Rnc_ReadHuffmanTable(globals::g_RncHuffmanTable_Dst,0x10);
			Rnc_ReadHuffmanTable(globals::g_RncHuffmanTable_Len,0x10);
			uVar1 = Rnc_BitStreamAdvance(0x10);
			while( true ) {
				uVar2 = Rnc_ReadHuffman(globals::g_RncHuffmanTable_Raw);
				if ((short)uVar2 != 0) {
					iVar3 = (uVar2 + 0xffff & 0xffff) + 1;
					do {
						*globals::g_RncOutput = *globals::g_RncInput;
						globals::g_RncOutput = globals::g_RncOutput + 1;
						globals::g_RncInput = globals::g_RncInput + 1;
						iVar3 = iVar3 + -1;
					} while (iVar3 != 0);
				}
				uVar1 = uVar1 + 0xffff;
				globals::g_RncBitBuffer =
						 (((uint)globals::g_RncInput[1] + (uint)globals::g_RncInput[2] * 0x100) * 0x100 +
							(uint)*globals::g_RncInput << (globals::g_RncBitCount & 0x1f)) +
						 ((1 << (globals::g_RncBitCount & 0x1f)) - 1U & globals::g_RncBitBuffer);
				if ((short)uVar1 == 0) break;
				uVar2 = Rnc_ReadHuffman(globals::g_RncHuffmanTable_Dst);
				pbVar4 = globals::g_RncOutput + (-1 - (uVar2 & 0xffff));
				uVar2 = Rnc_ReadHuffman(globals::g_RncHuffmanTable_Len);
				if ((short)uVar2 != -2) {
					iVar3 = (uVar2 + 0x10001 & 0xffff) + 1;
					do {
						*globals::g_RncOutput = *pbVar4;
						globals::g_RncOutput = globals::g_RncOutput + 1;
						pbVar4 = pbVar4 + 1;
						iVar3 = iVar3 + -1;
					} while (iVar3 != 0);
				}
			}
		} while (globals::g_RncOutput < globals::g_RncOutputEnd);
	}
	return 0;
}



short __cdecl rnc::Rnc_Decompress_Method2(byte *srcBuffer,byte *dstBuffer)
{
	short sVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	byte *pbVar5;
	
	Rnc_BitStreamInit(srcBuffer,dstBuffer);
	Rnc_FUN_0049cff0(2);
	if (globals::g_RncOutput < globals::g_RncOutputEnd) {
		do {
			while( true ) {
				while( true ) {
					iVar2 = Rnc_FUN_0049cff0(1);
					sVar1 = (short)iVar2;
					while (sVar1 == 0) {
						*globals::g_RncOutput = *globals::g_RncInput;
						globals::g_RncOutput = globals::g_RncOutput + 1;
						globals::g_RncInput = globals::g_RncInput + 1;
						iVar2 = Rnc_FUN_0049cff0(1);
						sVar1 = (short)iVar2;
					}
					iVar2 = Rnc_FUN_0049cff0(1);
					if ((short)iVar2 != 0) break;
					uVar3 = Rnc_FUN_0049d130();
					if ((short)uVar3 == 9) {
						iVar2 = Rnc_FUN_0049cff0(4);
						if ((short)(iVar2 * 4) != -0xc) {
							iVar2 = (iVar2 * 4 + 0x1000bU & 0xffff) + 1;
							do {
								*globals::g_RncOutput = *globals::g_RncInput;
								globals::g_RncOutput = globals::g_RncOutput + 1;
								globals::g_RncInput = globals::g_RncInput + 1;
								iVar2 = iVar2 + -1;
							} while (iVar2 != 0);
						}
					}
					else {
						uVar4 = Rnc_FUN_0049d170();
						pbVar5 = globals::g_RncOutput + -(uVar4 & 0xffff);
						if ((short)uVar3 != 0) {
							iVar2 = (uVar3 + 0xffff & 0xffff) + 1;
							do {
								*globals::g_RncOutput = *pbVar5;
								globals::g_RncOutput = globals::g_RncOutput + 1;
								pbVar5 = pbVar5 + 1;
								iVar2 = iVar2 + -1;
							} while (iVar2 != 0);
						}
					}
				}
				iVar2 = Rnc_FUN_0049cff0(1);
				if ((short)iVar2 != 0) break;
				sVar1 = 2;
				uVar3 = *globals::g_RncInput + 1;
				globals::g_RncInput = globals::g_RncInput + 1;
LAB_0049ce07:
				pbVar5 = globals::g_RncOutput + -(uVar3 & 0xffff);
				if (sVar1 != 0) {
					iVar2 = (ushort)(sVar1 - 1) + 1;
					do {
						*globals::g_RncOutput = *pbVar5;
						globals::g_RncOutput = globals::g_RncOutput + 1;
						pbVar5 = pbVar5 + 1;
						iVar2 = iVar2 + -1;
					} while (iVar2 != 0);
				}
			}
			iVar2 = Rnc_FUN_0049cff0(1);
			if ((short)iVar2 == 0) {
				sVar1 = 3;
LAB_0049ce02:
				uVar3 = Rnc_FUN_0049d170();
				goto LAB_0049ce07;
			}
			sVar1 = *globals::g_RncInput + 8;
			globals::g_RncInput = globals::g_RncInput + 1;
			if (sVar1 != 8) goto LAB_0049ce02;
			Rnc_FUN_0049cff0(1);
		} while (globals::g_RncOutput < globals::g_RncOutputEnd);
	}
	return 0;
}



byte * __cdecl rnc::Rnc_BitStreamInit(byte *srcBuffer,byte *dstBuffer)
{
	uint uVar1;
	
	uVar1 = *(uint *)(srcBuffer + 4);
	globals::g_RncBitCount = 0;
	globals::g_RncInput = srcBuffer + 0x12;
	globals::g_RncOutput = dstBuffer;
	globals::g_RncOutputEnd =
			 dstBuffer +
			 (uVar1 >> 0x18) +
			 (((uVar1 >> 8 & 0xff) + uVar1 * 0x100) * 0x100 + (uVar1 >> 0x10 & 0xff)) * 0x100;
	return dstBuffer +
				 (uVar1 >> 0x18) +
				 (((uVar1 >> 8 & 0xff) + uVar1 * 0x100) * 0x100 + (uVar1 >> 0x10 & 0xff)) * 0x100;
}



uint __cdecl rnc::Rnc_BitStreamAdvance(byte bits)
{
	uint uVar1;
	int iVar2;
	uint *puVar3;
	uint uVar4;
	
	uVar1 = 0;
	uVar4 = 1;
	_bits = (uint)(byte)(bits - 1);
	if (bits != 0) {
		iVar2 = _bits + 1;
		puVar3 = (uint *)globals::g_RncInput;
		do {
			if (globals::g_RncBitCount == 0) {
				globals::g_RncBitBuffer = *puVar3;
				puVar3 = (uint *)((int)puVar3 + 2);
				globals::g_RncBitCount = 0x10;
				globals::g_RncInput = (byte *)puVar3;
			}
			if ((globals::g_RncBitBuffer & 1) != 0) {
				uVar1 = uVar1 | uVar4;
			}
			uVar4 = uVar4 << 1;
			globals::g_RncBitBuffer = globals::g_RncBitBuffer >> 1;
			globals::g_RncBitCount = globals::g_RncBitCount - 1;
			iVar2 = iVar2 + -1;
		} while (iVar2 != 0);
	}
	return uVar1;
}



int __cdecl rnc::Rnc_FUN_0049cff0(byte bits)
{
	int iVar1;
	byte *pbVar2;
	int iVar3;
	
	iVar1 = 0;
	_bits = (uint)(byte)(bits - 1);
	if (bits != 0) {
		iVar3 = _bits + 1;
		pbVar2 = globals::g_RncInput;
		do {
			if (globals::g_RncBitCount == 0) {
				globals::g_Rnc_BYTE_00559088 = *pbVar2;
				pbVar2 = pbVar2 + 1;
				globals::g_RncBitCount = 8;
				globals::g_RncInput = pbVar2;
			}
			iVar1 = iVar1 * 2;
			if ((globals::g_Rnc_BYTE_00559088 & 0x80) != 0) {
				iVar1 = iVar1 + 1;
			}
			globals::g_Rnc_BYTE_00559088 = globals::g_Rnc_BYTE_00559088 << 1;
			globals::g_RncBitCount = globals::g_RncBitCount - 1;
			iVar3 = iVar3 + -1;
		} while (iVar3 != 0);
	}
	return iVar1;
}



void __cdecl rnc::Rnc_ReadHuffmanTable(HuffmanLeaf *table,byte bits)
{
	byte bits_00;
	uint uVar1;
	uint uVar2;
	ushort *puVar3;
	
	Rnc_FUN_0049d210(table,bits);
	uVar1 = Rnc_BitStreamAdvance(5);
	bits_00 = (byte)uVar1;
	if (bits_00 != 0) {
		if (0x10 < bits_00) {
			bits_00 = 0x10;
		}
		if (bits_00 != 0) {
			puVar3 = &table->count_2;
			uVar1 = (uint)bits_00;
			do {
				uVar2 = Rnc_BitStreamAdvance(4);
				*puVar3 = (ushort)uVar2;
				puVar3 = puVar3 + 8;
				uVar1 = uVar1 - 1;
			} while (uVar1 != 0);
		}
		Rnc_FUN_0049d250(table,bits_00);
	}
	return;
}



uint __cdecl rnc::Rnc_ReadHuffman(HuffmanLeaf *table)
{
	uint uVar1;
	byte bVar2;
	
	bVar2 = 0;
	for (; (table->count_2 == 0 ||
				 (((1 << ((byte)table->count_2 & 0x1f)) - 1U & globals::g_RncBitBuffer) != table->value_2));
			table = table + 1) {
		bVar2 = bVar2 + 1;
	}
	uVar1 = Rnc_BitStreamAdvance(*(byte *)&table->count_2);
	if (bVar2 < 2) {
		return uVar1 & 0xffff0000 | (uint)bVar2;
	}
	uVar1 = Rnc_BitStreamAdvance(bVar2 - 1);
	return uVar1 | 1 << (bVar2 - 1 & 0x1f);
}



uint __cdecl rnc::Rnc_FUN_0049d130(void)
{
	uint uVar1;
	int iVar2;
	uint unaff_ESI;
	uint uVar3;
	
	uVar1 = Rnc_FUN_0049cff0(1);
	uVar3 = (unaff_ESI & 0xffff0000 | uVar1 & 0xffff) + 4;
	uVar1 = Rnc_FUN_0049cff0(1);
	if ((short)uVar1 == 0) {
		return uVar1 & 0xffff0000 | uVar3 & 0xffff;
	}
	iVar2 = Rnc_FUN_0049cff0(1);
	return iVar2 + -2 + uVar3 * 2;
}



int __cdecl rnc::Rnc_FUN_0049d170(void)
{
	byte bVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	
	uVar4 = 0;
	iVar2 = Rnc_FUN_0049cff0(1);
	if ((short)iVar2 != 0) {
		uVar4 = Rnc_FUN_0049cff0(1);
		iVar2 = Rnc_FUN_0049cff0(1);
		if ((short)iVar2 == 0) {
			if ((short)uVar4 == 0) {
				uVar3 = Rnc_FUN_0049cff0(1);
				uVar4 = (uVar4 & 0xffff0000 | uVar3 & 0xffff) + 2;
			}
		}
		else {
			iVar2 = Rnc_FUN_0049cff0(1);
			uVar4 = iVar2 + uVar4 * 2 | 4;
			iVar2 = Rnc_FUN_0049cff0(1);
			if ((short)iVar2 == 0) {
				iVar2 = Rnc_FUN_0049cff0(1);
				uVar4 = iVar2 + uVar4 * 2;
			}
		}
	}
	bVar1 = *globals::g_RncInput;
	globals::g_RncInput = globals::g_RncInput + 1;
	return uVar4 * 0x100 + 1 + (uint)bVar1;
}



void __cdecl rnc::Rnc_FUN_0049d210(HuffmanLeaf *table,byte bits)
{
	int iVar1;
	
	_bits = (uint)(byte)(bits - 1);
	if (bits != 0) {
		iVar1 = _bits + 1;
		do {
			table->value_1 = 0;
			table->count_1 = 0xffff;
			table->value_2 = 0;
			table->count_2 = 0;
			table = table + 1;
			iVar1 = iVar1 + -1;
		} while (iVar1 != 0);
	}
	return;
}



void __cdecl rnc::Rnc_FUN_0049d250(HuffmanLeaf *table,byte bits)
{
	uint uVar1;
	ushort uVar2;
	uint uVar3;
	uint *puVar4;
	uint uVar5;
	uint local_4;
	
	uVar2 = 1;
	local_4 = 0;
	uVar3 = 0x80000000;
	do {
		uVar5 = (uint)bits;
		if (bits != 0) {
			puVar4 = &table->value_2;
			do {
				if (*(ushort *)(puVar4 + 1) == uVar2) {
					uVar1 = Rnc_MirrorBits(local_4 / uVar3,(byte)uVar2);
					*puVar4 = uVar1;
					local_4 = local_4 + uVar3;
				}
				puVar4 = puVar4 + 4;
				uVar5 = uVar5 - 1;
			} while (uVar5 != 0);
		}
		uVar2 = uVar2 + 1;
		uVar3 = uVar3 >> 1;
	} while (uVar2 < 0x11);
	return;
}



uint __cdecl rnc::Rnc_MirrorBits(uint value,byte bits)
{
	uint uVar1;
	int iVar2;
	
	uVar1 = 0;
	_bits = (uint)(byte)(bits - 1);
	if (bits != 0) {
		iVar2 = _bits + 1;
		do {
			uVar1 = uVar1 << 1;
			if ((value & 1) != 0) {
				uVar1 = uVar1 | 1;
			}
			value = value >> 1;
			iVar2 = iVar2 + -1;
		} while (iVar2 != 0);
	}
	return uVar1;
}



// (ChooseScreenMode)

BOOL __cdecl
lego::setup::Init_Initialise(BOOL setup,BOOL debug,BOOL best,BOOL window,char *noHALMsg)
{
	bool bVar1;
	BOOL BVar2;
	DeviceModeFlags *pDVar3;
	int iVar4;
	int iVar5;
	uint modeIndex;
	DriverMode *driver;
	INT_PTR local_4;
	
	local_4 = 1;
	globs::initGlobs.selDriver = (DriverMode *)0x0;
	globs::initGlobs.selDevice = (DeviceMode *)0x0;
	globs::initGlobs.selMode = (ScreenMode *)0x0;
	globs::initGlobs.wasFullScreen = 1;
	globs::initGlobs.selFullScreen = 1;
	globs::initGlobs.validModeCount = 0;
	Init_AddValidMode(640,480,0x10);
	if (debug != 0) {
		Init_AddValidMode(800,600,0x10);
		Init_AddValidMode(1024,768,0x10);
	}
	ddraw::DirectDraw_EnumDrivers(globs::initGlobs.drivers,(uint *)&globs::initGlobs);
	if (globs::initGlobs.driverCount != 0) {
		globs::initGlobs.selDriver = globs::initGlobs.drivers;
		if (best == 0) {
			if (setup != 0) {
				local_4 = DialogBoxParamA(globs::mainGlobs.hInst,(LPCSTR)LEGORR_MODESELECTION_DIALOG,
																	globs::mainGlobs.hWnd,Init_DialogProc,0);
			}
		}
		else {
			bVar1 = false;
			iVar5 = globs::initGlobs.driverCount - 1;
			local_4 = 1;
			globs::initGlobs.selFullScreen = ZEXT14(window == 0);
			if (-1 < iVar5) {
				driver = (DriverMode *)((int)&globs::initGlobs + iVar5 * 0x114 + 0xc);
LAB_0049d3d2:
				BVar2 = ddraw::DirectDraw_EnumDevices
													(driver,globs::initGlobs.devices,&globs::initGlobs.deviceCount);
				if (BVar2 == 0) {
					MessageBoxA((HWND)0x0,"Please install DirectX version 6 or later","Error",0);
					return 0;
				}
				ddraw::DirectDraw_EnumModes
									(driver,globs::initGlobs.selFullScreen,globs::initGlobs.modes,
									 &globs::initGlobs.modeCount);
				modeIndex = 0;
				if (globs::initGlobs.modeCount != 0) {
					do {
						BVar2 = Init_IsValidMode(modeIndex);
						if (BVar2 != 0) {
							iVar4 = globs::initGlobs.deviceCount - 1;
							if (-1 < iVar4) {
								pDVar3 = &globs::initGlobs.devices[globs::initGlobs.deviceCount - 1].flags;
								goto LAB_0049d447;
							}
							break;
						}
						modeIndex = modeIndex + 1;
					} while (modeIndex < globs::initGlobs.modeCount);
				}
				goto LAB_0049d48f;
			}
LAB_0049d4a8:
			if (!bVar1) {
				MessageBoxA((HWND)0x0,noHALMsg,"Error",0);
				return 0;
			}
		}
		if (local_4 == 1) {
			if (globs::initGlobs.selFullScreen != 0) {
				BVar2 = ddraw::DirectDraw_Setup
													(1,globs::initGlobs.selDriver,globs::initGlobs.selDevice,
													 globs::initGlobs.selMode,0,0,320,200);
				return BVar2;
			}
			if (globs::initGlobs.selMode == (ScreenMode *)0x0) {
				BVar2 = ddraw::DirectDraw_Setup
													(0,(DriverMode *)0x0,globs::initGlobs.selDevice,(ScreenMode *)0x0,40,40,
													 640,480);
				return BVar2;
			}
			BVar2 = ddraw::DirectDraw_Setup
												(0,(DriverMode *)0x0,globs::initGlobs.selDevice,(ScreenMode *)0x0,100,100,
												 (globs::initGlobs.selMode)->width,(globs::initGlobs.selMode)->height);
			return BVar2;
		}
	}
	return 0;
	while( true ) {
		iVar4 = iVar4 + -1;
		pDVar3 = pDVar3 + -0x45;
		if (iVar4 < 0) break;
LAB_0049d447:
		if ((*pDVar3 & DEVICEMODE_HARDWARE) != DEVICEMODE_NONE) {
			globs::initGlobs.selMode = globs::initGlobs.modes + modeIndex;
			bVar1 = true;
			globs::initGlobs.selDevice = globs::initGlobs.devices + iVar4;
			globs::initGlobs.selDriver = driver;
			break;
		}
	}
LAB_0049d48f:
	if (bVar1) goto LAB_0049d4a8;
	iVar5 = iVar5 + -1;
	driver = driver + -1;
	if (iVar5 < 0) goto LAB_0049d4a8;
	goto LAB_0049d3d2;
}



INT_PTR lego::setup::Init_DialogProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
	short sVar1;
	HWND pHVar2;
	LRESULT LVar3;
	WPARAM wParam2;
	BOOL BVar4;
	short sVar5;
	uint uVar6;
	int iVar7;
	uint outIndex;
	tagRECT dlgRect;
	tagRECT desktopRect;
	char screenModeText [1024];
	
	if (message == WM_INITDIALOG) {
		pHVar2 = GetDesktopWindow();
		GetWindowRect(pHVar2,(LPRECT)&desktopRect);
		GetWindowRect(hDlg,(LPRECT)&dlgRect);
		MoveWindow(hDlg,desktopRect.right / 2 - (dlgRect.right - dlgRect.left) / 2,
							 desktopRect.bottom / 2 - (dlgRect.bottom - dlgRect.top) / 2,
							 dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,1);
		if (globs::initGlobs.selFullScreen == 0) {
			iVar7 = LEGORR_ID_WINDOW_RADIOBUTTON;
		}
		else {
			iVar7 = LEGORR_ID_FULLSCREEN_RADIOBUTTON;
		}
		pHVar2 = GetDlgItem(hDlg,iVar7);
		SendMessageA(pHVar2,BM_SETCHECK,BST_CHECKED,0);
		pHVar2 = GetDlgItem(hDlg,LEGORR_ID_DRIVER_LISTBOX);
		uVar6 = 0;
		if (globs::initGlobs.driverCount != 0) {
			iVar7 = 0x5590bc;
			do {
				SendMessageA(pHVar2,LB_ADDSTRING,0,iVar7);
				uVar6 = uVar6 + 1;
				iVar7 = iVar7 + 0x114;
			} while (uVar6 < globs::initGlobs.driverCount);
		}
		SendMessageA(pHVar2,LB_SETCURSEL,0,0);
		SetFocus(pHVar2);
		Init_HandleWindowButton(hDlg);
		Init_SetDeviceList(hDlg);
		Init_SetModeList(hDlg);
		return 0;
	}
	if (message != WM_COMMAND) {
		return 0;
	}
	sVar1 = (short)(wParam >> 0x10);
	sVar5 = (short)wParam;
	if (sVar1 == 1) {
		if (sVar5 == LEGORR_ID_DEVICE_LISTBOX) {
			LVar3 = SendMessageA((HWND)lParam,LB_GETCURSEL,0,0);
			globs::initGlobs.selDevice = globs::initGlobs.devices + LVar3;
			return 1;
		}
		if (sVar5 == LEGORR_ID_SCREENMODES_LISTBOX) {
			wParam2 = SendMessageA((HWND)lParam,LB_GETCURSEL,0,0);
			SendMessageA((HWND)lParam,LB_GETTEXT,wParam2,(LPARAM)screenModeText);
			BVar4 = Init_GetMode(screenModeText,&outIndex);
			if (BVar4 != 0) {
				globs::initGlobs.selMode = globs::initGlobs.modes + outIndex;
				return 1;
			}
		}
		else {
			if (sVar5 == LEGORR_ID_DRIVER_LISTBOX) {
				LVar3 = SendMessageA((HWND)lParam,LB_GETCURSEL,0,0);
				globs::initGlobs.selDriver = globs::initGlobs.drivers + LVar3;
				Init_HandleWindowButton(hDlg);
				Init_SetModeList(hDlg);
				Init_SetDeviceList(hDlg);
				return 1;
			}
		}
	}
	else {
		if (sVar1 == 0) {
			if (sVar5 == LEGORR_ID_WINDOW_RADIOBUTTON) {
				Init_SetFullScreen(hDlg,0);
			}
			if (sVar5 == LEGORR_ID_FULLSCREEN_RADIOBUTTON) {
				Init_SetFullScreen(hDlg,1);
				return 1;
			}
			if ((sVar5 == IDOK) || (sVar5 == IDCANCEL)) {
				EndDialog(hDlg,wParam);
			}
		}
	}
	return 1;
}



void __cdecl lego::setup::Init_SetFullScreen(HWND hDlg,BOOL on)
{
	HWND hWnd;
	
	globs::initGlobs.selFullScreen = on;
	Init_SetModeList(hDlg);
	hWnd = GetDlgItem(hDlg,LEGORR_ID_SCREENMODES_LABEL);
	if (on != 0) {
		SendMessageA(hWnd,WM_SETTEXT,0,(LPARAM)"Screen Mode");
		return;
	}
	SendMessageA(hWnd,WM_SETTEXT,0,(LPARAM)"Window Size");
	return;
}



void __cdecl lego::setup::Init_SetModeList(HWND hDlg)
{
	bool bVar1;
	HWND hCtrl_Screens;
	int iVar2;
	BOOL BVar3;
	HWND hCtrl_OK;
	ScreenMode *pSVar4;
	uint local_104;
	char unsupportedMessage [256];
	
	bVar1 = true;
	hCtrl_Screens = GetDlgItem(hDlg,LEGORR_ID_SCREENMODES_LISTBOX);
	iVar2 = SendMessageA(hCtrl_Screens,LB_DELETESTRING,0,0);
	while (iVar2 != -1) {
		iVar2 = SendMessageA(hCtrl_Screens,LB_DELETESTRING,0,0);
	}
	ddraw::DirectDraw_EnumModes
						(globs::initGlobs.selDriver,globs::initGlobs.selFullScreen,globs::initGlobs.modes,
						 &globs::initGlobs.modeCount);
	local_104 = 0;
	if (globs::initGlobs.modeCount != 0) {
		pSVar4 = globs::initGlobs.modes;
		do {
			BVar3 = Init_IsValidMode(local_104);
			if ((BVar3 != 0) && (SendMessageA(hCtrl_Screens,LB_ADDSTRING,0,(LPARAM)pSVar4->desc), bVar1))
			{
				bVar1 = false;
				globs::initGlobs.selMode = pSVar4;
			}
			local_104 = local_104 + 1;
			pSVar4 = pSVar4 + 1;
		} while (local_104 < globs::initGlobs.modeCount);
	}
	hCtrl_OK = GetDlgItem(hDlg,IDOK);
	if (bVar1) {
		if (globs::initGlobs.selFullScreen == 0) {
			iVar2 = main::Main_GetWindowsBitDepth();
			std::sprintf(unsupportedMessage,"No supported %i bit modes found",iVar2);
		}
		else {
			std::sprintf(unsupportedMessage,"No supported screen modes found");
		}
		SendMessageA(hCtrl_Screens,LB_ADDSTRING,0,(LPARAM)unsupportedMessage);
		BVar3 = 0;
	}
	else {
		BVar3 = 1;
	}
	EnableWindow(hCtrl_OK,BVar3);
	SendMessageA(hCtrl_Screens,LB_SETCURSEL,0,0);
	return;
}



void __cdecl lego::setup::Init_SetDeviceList(HWND hDlg)
{
	HWND hWnd;
	int iVar1;
	BOOL BVar2;
	WPARAM wParam;
	WPARAM WVar3;
	WPARAM local_4;
	
	local_4 = 0;
	hWnd = GetDlgItem(hDlg,LEGORR_ID_DEVICE_LISTBOX);
	iVar1 = SendMessageA(hWnd,LB_DELETESTRING,0,0);
	while (iVar1 != -1) {
		iVar1 = SendMessageA(hWnd,LB_DELETESTRING,0,0);
	}
	BVar2 = ddraw::DirectDraw_EnumDevices
										(globs::initGlobs.selDriver,globs::initGlobs.devices,
										 &globs::initGlobs.deviceCount);
	if (BVar2 != 0) {
		WVar3 = 0;
		wParam = 0;
		if (globs::initGlobs.deviceCount != 0) {
			iVar1 = 0x55a64c;
			do {
				if ((*(uint *)(iVar1 + 0x100) & 0x2000) != 0) {
					local_4 = WVar3;
				}
				SendMessageA(hWnd,LB_ADDSTRING,0,iVar1);
				WVar3 = WVar3 + 1;
				iVar1 = iVar1 + 0x114;
				wParam = local_4;
			} while (WVar3 < globs::initGlobs.deviceCount);
		}
		globs::initGlobs.selDevice = globs::initGlobs.devices + wParam;
		SendMessageA(hWnd,LB_SETCURSEL,wParam,0);
		return;
	}
	SendMessageA(hWnd,LB_ADDSTRING,0,(LPARAM)"Error: DirectX6 not installed.");
	SendMessageA(hWnd,LB_SETCURSEL,0,0);
	return;
}



void __cdecl lego::setup::Init_AddValidMode(uint width,uint height,uint depth)
{
	globs::initGlobs.validModes[globs::initGlobs.validModeCount].width = width;
	globs::initGlobs.validModes[globs::initGlobs.validModeCount].height = height;
	globs::initGlobs.validModes[globs::initGlobs.validModeCount].bitDepth = depth;
	globs::initGlobs.validModeCount = globs::initGlobs.validModeCount + 1;
	return;
}



BOOL __cdecl lego::setup::Init_IsValidMode(uint modeIndex)
{
	uint *puVar1;
	uint uVar2;
	
	if (globs::initGlobs.validModeCount == 0) {
		return 1;
	}
	uVar2 = 0;
	if (globs::initGlobs.validModeCount != 0) {
		puVar1 = &globs::initGlobs.validModes[0].height;
		do {
			if (((puVar1[-1] == 0) || (puVar1[-1] == globs::initGlobs.modes[modeIndex].width)) &&
				 ((*puVar1 == 0 || (*puVar1 == globs::initGlobs.modes[modeIndex].height)))) {
				if (puVar1[1] == 0) {
					return 1;
				}
				if (puVar1[1] == globs::initGlobs.modes[modeIndex].bitDepth) {
					return 1;
				}
			}
			uVar2 = uVar2 + 1;
			puVar1 = puVar1 + 0x44;
		} while (uVar2 < globs::initGlobs.validModeCount);
	}
	return 0;
}



BOOL __cdecl lego::setup::Init_GetMode(char *name,uint *out_modeIndex)
{
	byte bVar1;
	byte *pbVar2;
	int iVar3;
	uint uVar4;
	byte *pbVar5;
	byte *pbVar6;
	bool bVar7;
	
	uVar4 = 0;
	if (globs::initGlobs.modeCount == 0) {
		return 0;
	}
	pbVar2 = (byte *)globs::initGlobs.modes[0].desc;
	pbVar5 = (byte *)name;
	pbVar6 = pbVar2;
LAB_0049dc2b:
	do {
		bVar1 = *pbVar2;
		bVar7 = bVar1 < *pbVar5;
		if (bVar1 == *pbVar5) {
			if (bVar1 != 0) {
				bVar1 = pbVar2[1];
				bVar7 = bVar1 < pbVar5[1];
				if (bVar1 != pbVar5[1]) goto LAB_0049dc4f;
				pbVar2 = pbVar2 + 2;
				pbVar5 = pbVar5 + 2;
				if (bVar1 != 0) goto LAB_0049dc2b;
			}
			iVar3 = 0;
		}
		else {
LAB_0049dc4f:
			iVar3 = (1 - (uint)bVar7) - (uint)(bVar7 != 0);
		}
		if (iVar3 == 0) {
			*out_modeIndex = uVar4;
			return 1;
		}
		uVar4 = uVar4 + 1;
		pbVar2 = pbVar6 + 0x110;
		pbVar5 = (byte *)name;
		pbVar6 = pbVar2;
		if (globs::initGlobs.modeCount <= uVar4) {
			return 0;
		}
	} while( true );
}



void __cdecl lego::setup::Init_HandleWindowButton(HWND hDlg)
{
	HWND pHVar1;
	
	if ((*(byte *)&(globs::initGlobs.selDriver)->flags & DRIVERMODE_WINDOWOK) == 0) {
		globs::initGlobs.wasFullScreen = globs::initGlobs.selFullScreen;
		Init_SetFullScreen(hDlg,1);
		pHVar1 = GetDlgItem(hDlg,LEGORR_ID_WINDOW_RADIOBUTTON);
		SendMessageA(pHVar1,BM_SETCHECK,0,0);
		EnableWindow(pHVar1,0);
		pHVar1 = GetDlgItem(hDlg,LEGORR_ID_FULLSCREEN_RADIOBUTTON);
		SendMessageA(pHVar1,BM_SETCHECK,1,0);
	}
	else {
		pHVar1 = GetDlgItem(hDlg,LEGORR_ID_WINDOW_RADIOBUTTON);
		EnableWindow(pHVar1,1);
		if (globs::initGlobs.wasFullScreen == 0) {
			Init_SetFullScreen(hDlg,0);
			pHVar1 = GetDlgItem(hDlg,LEGORR_ID_FULLSCREEN_RADIOBUTTON);
			SendMessageA(pHVar1,BM_SETCHECK,0,0);
			pHVar1 = GetDlgItem(hDlg,LEGORR_ID_WINDOW_RADIOBUTTON);
			SendMessageA(pHVar1,BM_SETCHECK,1,0);
			return;
		}
	}
	return;
}



// Library Function - Single Match
// Name: __strnicmp
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release

int __cdecl std::_strnicmp(char *_Str1,char *_Str2,size_t _MaxCount)
{
	byte bVar1;
	byte bVar2;
	uint c;
	uint c_00;
	bool bVar3;
	
	if (_MaxCount != 0) {
		if (DAT_0054a180 == 0) {
			do {
				bVar2 = *_Str1;
				bVar1 = *_Str2;
				if ((bVar2 == 0) || (bVar1 == 0)) break;
				_Str1 = (char *)((byte *)_Str1 + 1);
				_Str2 = (char *)((byte *)_Str2 + 1);
				if ((0x40 < bVar2) && (bVar2 < 0x5b)) {
					bVar2 = bVar2 + 0x20;
				}
				if ((0x40 < bVar1) && (bVar1 < 0x5b)) {
					bVar1 = bVar1 + 0x20;
				}
				bVar3 = bVar2 < bVar1;
				if (bVar2 != bVar1) goto LAB_0049ddcb;
				_MaxCount = _MaxCount - 1;
			} while (_MaxCount != 0);
			_MaxCount = 0;
			bVar3 = bVar2 < bVar1;
			if (bVar2 != bVar1) {
LAB_0049ddcb:
				_MaxCount = 0xffffffff;
				if (!bVar3) {
					_MaxCount = 1;
				}
			}
		}
		else {
			c_00 = 0;
			c = 0;
			do {
				c = c & 0xffffff00 | (uint)(byte)*_Str1;
				c_00 = c_00 & 0xffffff00 | (uint)(byte)*_Str2;
				if ((c == 0) || (c_00 == 0)) break;
				_Str1 = (char *)((byte *)_Str1 + 1);
				_Str2 = (char *)((byte *)_Str2 + 1);
				c_00 = tolower(c_00);
				c = tolower(c);
				bVar3 = c < c_00;
				if (c != c_00) goto LAB_0049de0d;
				_MaxCount = _MaxCount - 1;
			} while (_MaxCount != 0);
			_MaxCount = 0;
			bVar3 = c < c_00;
			if (c != c_00) {
LAB_0049de0d:
				_MaxCount = 0xffffffff;
				if (!bVar3) {
					_MaxCount = 1;
				}
			}
		}
	}
	return _MaxCount;
}



char * __cdecl std::itoa(int value,char *buffer,int radix)
{
	if ((radix == 10) && (value < 0)) {
		internal::__itoa__internal(value,buffer,10,1);
		return buffer;
	}
	internal::__itoa__internal(value,buffer,radix,0);
	return buffer;
}



void __cdecl std::internal::__itoa__internal(int value,char *buffer,int radix,BOOL isNegative)
{
	ulonglong uVar1;
	char *pcVar2;
	char cVar3;
	char *pcVar4;
	
	pcVar2 = buffer;
	if (isNegative != 0) {
		*buffer = '-';
		buffer = buffer + 1;
		value = -value;
		pcVar2 = buffer;
	}
	do {
		pcVar4 = pcVar2;
		uVar1 = (ulonglong)(uint)value;
		value = (uint)value / (uint)radix;
		cVar3 = (char)(uVar1 % (ulonglong)(uint)radix);
		if ((uint)(uVar1 % (ulonglong)(uint)radix) < 10) {
			cVar3 = cVar3 + '0';
		}
		else {
			cVar3 = cVar3 + 'W';
		}
		*pcVar4 = cVar3;
		pcVar2 = pcVar4 + 1;
	} while (value != 0);
	pcVar4[1] = '\0';
	do {
		cVar3 = *pcVar4;
		*pcVar4 = *buffer;
		*buffer = cVar3;
		pcVar4 = pcVar4 + -1;
		buffer = buffer + 1;
	} while (buffer < pcVar4);
	return;
}



char * __cdecl std::_strlwr(char *str)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	int iVar5;
	uint uVar6;
	LPWSTR buffer;
	undefined4 *puVar7;
	LPWSTR pWVar8;
	LPWSTR pWVar9;
	undefined4 *puVar10;
	
	buffer = (LPWSTR)0x0;
	if (DAT_0054a180 == 0) {
		pcVar3 = str;
		if (*str != '\0') {
			do {
				cVar2 = *str;
				if (('@' < cVar2) && (cVar2 < '[')) {
					*str = cVar2 + ' ';
				}
				pcVar1 = str + 1;
				str = str + 1;
			} while (*pcVar1 != '\0');
			return pcVar3;
		}
	}
	else {
		uVar4 = internal::__uprlwr__00493f60(DAT_0054a180,0x100,str,(LPCWSTR)0xffffffff,(LPWSTR)0x0,0,0)
		;
		if (((uVar4 != 0) && (buffer = (LPWSTR)malloc(uVar4), buffer != (LPWSTR)0x0)) &&
			 (iVar5 = internal::__uprlwr__00493f60
													(DAT_0054a180,0x100,str,(LPCWSTR)0xffffffff,buffer,uVar4,0), iVar5 != 0))
		{
			uVar4 = 0xffffffff;
			pWVar8 = buffer;
			do {
				pWVar9 = pWVar8;
				if (uVar4 == 0) break;
				uVar4 = uVar4 - 1;
				pWVar9 = (LPWSTR)((int)pWVar8 + 1);
				cVar2 = *(char *)pWVar8;
				pWVar8 = pWVar9;
			} while (cVar2 != '\0');
			uVar4 = ~uVar4;
			puVar7 = (undefined4 *)((int)pWVar9 - uVar4);
			puVar10 = (undefined4 *)str;
			for (uVar6 = uVar4 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
				*puVar10 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar10 = puVar10 + 1;
			}
			for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
				*(undefined *)puVar10 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar10 = (undefined4 *)((int)puVar10 + 1);
			}
		}
		free(buffer);
	}
	return str;
}



char * __cdecl std::_strupr(char *str)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	int iVar5;
	uint uVar6;
	LPWSTR buffer;
	undefined4 *puVar7;
	LPWSTR pWVar8;
	LPWSTR pWVar9;
	undefined4 *puVar10;
	
	buffer = (LPWSTR)0x0;
	if (DAT_0054a180 == 0) {
		pcVar3 = str;
		if (*str != '\0') {
			do {
				cVar2 = *str;
				if (('`' < cVar2) && (cVar2 < '{')) {
					*str = cVar2 + -0x20;
				}
				pcVar1 = str + 1;
				str = str + 1;
			} while (*pcVar1 != '\0');
			return pcVar3;
		}
	}
	else {
		uVar4 = internal::__uprlwr__00493f60(DAT_0054a180,0x200,str,(LPCWSTR)0xffffffff,(LPWSTR)0x0,0,0)
		;
		if (((uVar4 != 0) && (buffer = (LPWSTR)malloc(uVar4), buffer != (LPWSTR)0x0)) &&
			 (iVar5 = internal::__uprlwr__00493f60
													(DAT_0054a180,0x200,str,(LPCWSTR)0xffffffff,buffer,uVar4,0), iVar5 != 0))
		{
			uVar4 = 0xffffffff;
			pWVar8 = buffer;
			do {
				pWVar9 = pWVar8;
				if (uVar4 == 0) break;
				uVar4 = uVar4 - 1;
				pWVar9 = (LPWSTR)((int)pWVar8 + 1);
				cVar2 = *(char *)pWVar8;
				pWVar8 = pWVar9;
			} while (cVar2 != '\0');
			uVar4 = ~uVar4;
			puVar7 = (undefined4 *)((int)pWVar9 - uVar4);
			puVar10 = (undefined4 *)str;
			for (uVar6 = uVar4 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
				*puVar10 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar10 = puVar10 + 1;
			}
			for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
				*(undefined *)puVar10 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar10 = (undefined4 *)((int)puVar10 + 1);
			}
		}
		free(buffer);
	}
	return str;
}



void Unwind_0049e050(void)
{
	int unaff_EBP;
	
	lego::game::LevelStruct3C_Free_Unwind(*(LevelStruct_3c **)(unaff_EBP + -0x210));
	return;
}



void Unwind_0049e05e(void)
{
	int unaff_EBP;
	
	lego::game::LevelStruct3C_Free_Unwind(*(LevelStruct_3c **)(unaff_EBP + -0x210));
	return;
}



void Unwind_0049e080(void)
{
	int unaff_EBP;
	
	lego::game::LevelStruct3C_Free_Unwind(*(LevelStruct_3c **)(unaff_EBP + 4));
	return;
}



void Unwind_0049e0a0(void)
{
	int unaff_EBP;
	
	lego::game::LevelStruct3C_Free_Unwind(*(LevelStruct_3c **)(unaff_EBP + -0x10));
	return;
}


