#include "source_unfiltered_updated.h"
#include "datatypes_unfiltered_updated.h"
//#include "functypes.h"
//#include "globals.h"



void __cdecl lego::front::Advisor_Init(char *keyRoot,CameraData *structbc,void *ptr_1c)
{
	globals::g_AdvisorTypes_TABLE[0] = "Advisor_Objective";
	globals::g_AdvisorTypes_TABLE[1] = "Advisor_ObjectiveAcheived";
	globals::g_AdvisorTypes_TABLE[2] = "Advisor_ObjectiveFailed";
	globals::g_AdvisorTypes_TABLE[3] = "Advisor_IconPoint_Normal";
	globals::g_AdvisorTypes_TABLE[4] = "Advisor_IconPoint_BackButton";
	globals::g_AdvisorTypes_TABLE[5] = "Advisor_IconPoint_TopButtons";
	globals::g_AdvisorTypes_TABLE[6] = "Advisor_PanelPoint_RadarToggle";
	globals::g_AdvisorTypes_TABLE[7] = "Advisor_PanelPoint_RadarTaggedObjectView";
	globals::g_AdvisorTypes_TABLE[8] = "Advisor_PanelPoint_RadarZoomIn";
	globals::g_AdvisorTypes_TABLE[9] = "Advisor_PanelPoint_RadarZoomOut";
	globals::g_AdvisorTypes_TABLE[10] = "Advisor_PanelPoint_RadarMapView";
	globals::g_AdvisorTypes_TABLE[11] = "Advisor_PanelPoint_InfoDockGoto";
	globals::g_AdvisorTypes_TABLE[12] = "Advisor_PanelPoint_InfoDockClose";
	globals::g_AdvisorTypes_TABLE[13] = "Advisor_PanelPoint_TopPanelInfo";
	globals::g_AdvisorTypes_TABLE[14] = "Advisor_PanelPoint_TopPanelOptions";
	globals::g_AdvisorTypes_TABLE[15] = "Advisor_PanelPoint_TopPanelPriorities";
	globals::g_AdvisorTypes_TABLE[16] = "Advisor_PanelPoint_TopPanelCallToArms";
	globals::g_AdvisorTypes_TABLE[17] = "Advisor_PanelPoint_TopPanelGoBack";
	globals::g_AdvisorTypes_TABLE[18] = "Advisor_PanelPoint_ControlZoomIn";
	globals::g_AdvisorTypes_TABLE[19] = "Advisor_PanelPoint_ControlZoomOut";
	globals::g_AdvisorTypes_TABLE[20] = "Advisor_TalkInGame";
	globals::g_AdvisorAnimTypes_TABLE[0] = "Advisor_Anim_PointToMap";
	globals::g_AdvisorAnimTypes_TABLE[1] = "Advisor_Anim_Point_N";
	globals::g_AdvisorAnimTypes_TABLE[2] = "Advisor_Anim_Point_NE";
	globals::g_AdvisorAnimTypes_TABLE[3] = "Advisor_Anim_Point_E";
	globals::g_AdvisorAnimTypes_TABLE[4] = "Advisor_Anim_Point_SE";
	globals::g_AdvisorAnimTypes_TABLE[5] = "Advisor_Anim_Point_S";
	globals::g_AdvisorAnimTypes_TABLE[6] = "Advisor_Anim_Point_SW";
	globals::g_AdvisorAnimTypes_TABLE[7] = "Advisor_Anim_Point_W";
	globals::g_AdvisorAnimTypes_TABLE[8] = "Advisor_Anim_Point_NW";
	globals::g_AdvisorAnimTypes_TABLE[9] = "Advisor_Anim_Point_Up";
	globals::g_AdvisorAnimTypes_TABLE[10] = "Advisor_Anim_Talk_Top";
	globals::g_Advisor_ResRoot = structbc->resData1;
	globals::g_Advisor_ptr1c = ptr_1c;
	globals::g_Advisor_ResLight =
			 res::Container_MakeLight(structbc->resData1,D3DRMLIGHT_DIRECTIONAL,1.0,1.0,1.0);
	res::Container_SetOrientation
						(globals::g_Advisor_ResLight,structbc->resData1,0.0,0.0,-1.0,0.0,1.0,0.0);
	res::Container_Hide(globals::g_Advisor_ResLight,1);
	globals::g_Advisor_CurrentFlags = ADVISORSTATE_NONE;
	return;
}



void __cdecl lego::front::Advisor_Cleanup(void)
{
	if (globals::g_AdvisorAnimsData_TABLE
			[globals::g_AdvisorPositions_TABLE[globals::g_Advisor_CurrentType].animType].resData != NULL)
	{
		res::Container_Hide(globals::g_AdvisorAnimsData_TABLE
												[globals::g_AdvisorPositions_TABLE[globals::g_Advisor_CurrentType].animType]
												.resData,1);
	}
	globals::g_Advisor_CurrentFlags &= ~ADVISORSTATE_UNK_1;
	res::Container_Hide(globals::g_Advisor_ResLight,1);
	return;
}



void __cdecl lego::front::Advisor_InitViewport(float param_unused)
{
	lego::view::Viewport_GetBackClip((Viewport *)globals::g_Advisor_ptr1c);
	lego::view::Viewport_GetFrontClip((Viewport *)globals::g_Advisor_ptr1c);
	globals::g_AdvisorPosition_Z = 0.96;
	return;
}



// sqrt(((a.x - b.x)*(a.x - b.x)) + ((a.y - b.y)*(a.y - b.y)))

float10 __cdecl lego::math::Maths_Vector2DDistance(Point2F *a,Point2F *b)
{
	float10 fVar1;
	float10 fVar2;
	
	fVar1 = (float10)a->y - (float10)b->y;
	fVar2 = (float10)a->x - (float10)b->x;
	return SQRT(fVar2 * fVar2 + fVar1 * (float10)(float)fVar1);
}



// <advisorType><animFileName>,<loopStart(seconds)>,<loopEnd(seconds)>
// NOTE last two parameters can be set to any value if the anim is not made to loop e.g. 0,0
// 
// Advisor_Anim_Point_Up  Mini-Figures\Captain\NEW_Captain_Point_CALL_T_ARMS,1.04,4.0
// Advisor_Anim_Talk_Top  Mini-Figures\Captain\NEW_Captain_Point_QTalk,1.04,2.4

void __cdecl lego::front::Advisor_LoadAdvisorAnims(CFGProperty *root,char *keyRoot)
{
	char *pcVar1;
	Container *cont;
	char **ppcVar2;
	AdvisorAnimData *pAVar3;
	float10 fVar4;
	char *stringParts [3];
	char buffer [64];
	
	pAVar3 = globals::g_AdvisorAnimsData_TABLE;
	ppcVar2 = globals::g_AdvisorAnimTypes_TABLE;
	do {
		pcVar1 = cfg::CFG_JoinPath(keyRoot,"Advisor",*ppcVar2,0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		if (pcVar1 == NULL) {
			if ((globs::mainGlobs.flags & CMD_REDUCEANIMATION) == CMD_NONE) {
				std::sprintf(buffer,"!%s",*ppcVar2);
				pcVar1 = cfg::CFG_JoinPath(keyRoot,"Advisor",*ppcVar2,0);
				pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			}
			if (pcVar1 != NULL) goto LAB_004012f0;
		}
		else {
LAB_004012f0:
			util::Util_Tokenise(pcVar1,stringParts,",");
			cont = res::Container_Load(globals::g_Advisor_ResRoot,stringParts[0],"LWS",1);
			pAVar3->resData = cont;
			if (cont != NULL) {
				res::Container_SetOrientation(cont,globals::g_Advisor_ResRoot,0.0,0.0,1.0,0.0,1.0,0.0);
				res::Container_Hide(pAVar3->resData,1);
			}
			fVar4 = std::atof(stringParts[1]);
			pAVar3->loopStartTime = (float)(fVar4 * (float10)25.0);
			fVar4 = std::atof(stringParts[2]);
			pAVar3->loopEndTime = (float)(fVar4 * (float10)25.0);
		}
		ppcVar2 = ppcVar2 + 1;
		pAVar3 = pAVar3 + 1;
		if ((char **)((int)globals::g_AdvisorAnimTypes_TABLE + 0x2b) < ppcVar2) {
			return;
		}
	} while( true );
}



BOOL __cdecl lego::front::Advisor_GetAdvisorType(char *advisorName,AdvisorType *out_advisorType)
{
	int iVar1;
	char **ppcVar2;
	int index;
	
	index = 0;
	ppcVar2 = globals::g_AdvisorTypes_TABLE;
	do {
		iVar1 = std::_stricmp(*ppcVar2,advisorName);
		if (iVar1 == 0) {
			*out_advisorType = index;
			return 1;
		}
		ppcVar2 = (char **)((int)ppcVar2 + 4);
										// index++
		index += ADVISOR_OBJECTIVEACHIEVED;
										// index < ADVISOR__COUNT (21)
	} while (ppcVar2 < globals::g_AdvisorPositions_TABLE);
	return 0;
}



// out_vector = { (a.y * b.z) - (a.z * b.y),
//                (a.z * b.x) - (a.x * b.z),
//                (a.x * b.y) - (a.y * b.x) }

Vector3F * __cdecl
lego::math::Maths_Vector3DCrossProduct(Vector3F *out_vector,Vector3F *a,Vector3F *b)
{
	out_vector->x = b->z * a->y - a->z * b->y;
	out_vector->y = a->z * b->x - b->z * a->x;
	out_vector->z = b->y * a->x - a->y * b->x;
	return out_vector;
}



BOOL __cdecl lego::front::Advisor_GetAnimType(char *animName,AdvisorAnimType *out_animType)
{
	int iVar1;
	char **ppcVar2;
	int index;
	
	index = 0;
	ppcVar2 = globals::g_AdvisorAnimTypes_TABLE;
	do {
		iVar1 = std::_stricmp((char *)*(Container **)ppcVar2,animName);
		if (iVar1 == 0) {
			*out_animType = index;
			return 1;
		}
		ppcVar2 = (char **)((int)ppcVar2 + 4);
										// index++
		index += ADVISORANIM_POINT_N;
										// index < ADVISORANIM__COUNT (11)
	} while (ppcVar2 < globals::g_AdvisorAnimsData_TABLE);
	return 0;
}



// out_vector = a + b

Vector3F * __cdecl lego::math::Maths_Vector3DAdd(Vector3F *out_vector,Vector3F *a,Vector3F *b)
{
	out_vector->x = b->x + a->x;
	out_vector->y = a->y + b->y;
	out_vector->z = a->z + b->z;
	return out_vector;
}



// <positionType><animName>,<textName|NULL>,<sfxName|SFX_NULL>,<x(float)>,<y(float)>,<panelName|NULL>
// 
// Advisor_IconPoint_TopButtons    Advisor_Anim_Point_NE,NULL,SFX_NULL,-25,25,NULL
// Advisor_PanelPoint_RadarToggle  Advisor_Anim_Point_N,NULL,SFX_NULL,220,65,Panel_Radar

void __cdecl
lego::front::Advisor_LoadAdvisorPositions
					(CFGProperty *root,char *keyRoot,int screenWidth,int screenHeight)
{
	char *keyPath;
	CFGProperty *prop;
	BOOL BVar1;
	int iVar2;
	float10 fVar3;
	float10 fVar4;
	PanelType panelType;
	TextType textType;
	AdvisorAnimType animType;
	float x;
	float y;
	int sfxIndex;
	AdvisorType advisorIndex;
	char *stringParts [6];
	char advisorKeyPath [128];
	
	std::sprintf(advisorKeyPath,"AdvisorPositions%ix%i",screenWidth,screenHeight);
	keyPath = cfg::CFG_JoinPath(keyRoot,advisorKeyPath,0);
	for (prop = cfg::CFG_GetChildren(root,keyPath); prop != NULL; prop = cfg::CFG_NextFlat(prop)) {
										// TEXT__COUNT (26)  treated as NULL
		textType = TEXT__COUNT;
										// PANEL__COUNT (12)  treated as NULL
		panelType = PANEL__COUNT;
		BVar1 = Advisor_GetAdvisorType(prop->key,&advisorIndex);
		if (BVar1 != 0) {
			util::Util_Tokenise(prop->value,stringParts,",");
			BVar1 = Advisor_GetAnimType(stringParts[0],&animType);
			if ((BVar1 != 0) &&
				 (((iVar2 = std::_stricmp("NULL",stringParts[1]), iVar2 == 0 ||
					 (BVar1 = Text_GetTextType(stringParts[1],&textType), BVar1 != 0)) &&
					(BVar1 = snd::SFX_GetType(stringParts[2],(SFXType *)&sfxIndex), BVar1 != 0)))) {
				fVar3 = std::atof(stringParts[3]);
				fVar4 = std::atof(stringParts[4]);
				iVar2 = std::_stricmp("NULL",stringParts[5]);
				if ((iVar2 == 0) || (BVar1 = Panel_GetPanelType(stringParts[5],&panelType), BVar1 != 0)) {
					Advisor_AddAdvisorPosition
										(advisorIndex,animType,textType,sfxIndex,panelType,(float)fVar3,(float)fVar4);
				}
			}
		}
	}
	return;
}



// out_vector = a - b

Vector3F * __cdecl lego::math::Maths_Vector3DSubtract(Vector3F *out_vector,Vector3F *a,Vector3F *b)
{
	out_vector->x = a->x - b->x;
	out_vector->y = a->y - b->y;
	out_vector->z = a->z - b->z;
	return out_vector;
}



// out_vector = a * scalar

Vector3F * __cdecl lego::math::Maths_Vector3DScale(Vector3F *out_vector,Vector3F *a,float scalar)
{
	out_vector->x = scalar * a->x;
	out_vector->y = a->y * scalar;
	out_vector->z = a->z * scalar;
	return out_vector;
}



// ref_vector = ref_vector * (1.0 / modulus(ref_vector))
// REFERENCE: modulus(ref_vector) -> sqrt(dot_product(ref_vector, ref_vector))

Vector3F * __cdecl lego::math::Maths_Vector3DNormalize(Vector3F *ref_vector)
{
	float fVar1;
	
										// Vector3_Modulus (without 1.0 / _)
	fVar1 = 1.0 / SQRT(ref_vector->x * ref_vector->x +
										 ref_vector->z * ref_vector->z + ref_vector->y * ref_vector->y);
	ref_vector->x = fVar1 * ref_vector->x;
	ref_vector->y = fVar1 * ref_vector->y;
	ref_vector->z = fVar1 * ref_vector->z;
	return ref_vector;
}



void __cdecl
lego::front::Advisor_AddAdvisorPosition
					(AdvisorType advisorType,AdvisorAnimType animType,TextType textType,int sfxIndex,
					PanelType panelType,float x,float y)
{
	globals::g_AdvisorPositions_TABLE[advisorType].flags = ADVISORPOS_DEFAULT;
	globals::g_AdvisorPositions_TABLE[advisorType].animType = animType;
	globals::g_AdvisorPositions_TABLE[advisorType].textType = textType;
	globals::g_AdvisorPositions_TABLE[advisorType].sfxIndex = sfxIndex;
	globals::g_AdvisorPositions_TABLE[advisorType].point1.x = x;
	globals::g_AdvisorPositions_TABLE[advisorType].point1.y = y;
	globals::g_AdvisorPositions_TABLE[advisorType].point2.x = x;
	globals::g_AdvisorPositions_TABLE[advisorType].point2.y = y;
	globals::g_AdvisorPositions_TABLE[advisorType].panelType = panelType;
										// NULL panel
	if (panelType == PANEL__COUNT) {
		globals::g_AdvisorPositions_TABLE[advisorType].flags =
				 globals::g_AdvisorPositions_TABLE[advisorType].flags | ADVISORPOS_NOPANEL;
	}
										// non-NULL text
	if (textType != TEXT__COUNT) {
		globals::g_AdvisorPositions_TABLE[advisorType].flags =
				 globals::g_AdvisorPositions_TABLE[advisorType].flags | ADVISORPOS_HASTEXT;
	}
	return;
}



void __cdecl
lego::front::Advisor_SetParameters(AdvisorType advisorType,PanelType panelType,float x1,float y1)
{
	globals::g_AdvisorPositions_TABLE[advisorType].point1.x = x1;
	globals::g_AdvisorPositions_TABLE[advisorType].point1.y = y1;
	globals::g_AdvisorPositions_TABLE[advisorType].panelType = panelType;
										// NULL panel
	if (panelType == PANEL__COUNT) {
		globals::g_AdvisorPositions_TABLE[advisorType].flags =
				 globals::g_AdvisorPositions_TABLE[advisorType].flags | ADVISORPOS_NOPANEL;
		return;
	}
	globals::g_AdvisorPositions_TABLE[advisorType].flags =
			 globals::g_AdvisorPositions_TABLE[advisorType].flags & ~ADVISORPOS_NOPANEL;
	return;
}



void __cdecl lego::front::Advisor_GetPoint2(AdvisorType advisorType,float *out_x2,float *out_y2)
{
	*out_x2 = globals::g_AdvisorPositions_TABLE[advisorType].point2.x;
	*out_y2 = globals::g_AdvisorPositions_TABLE[advisorType].point2.y;
	return;
}



BOOL __cdecl lego::front::Advisor_SetCurrentAdvisor(AdvisorType advisorType,BOOL setFlag2)
{
	if ((((globals::g_AdvisorPositions_TABLE[advisorType].flags & ADVISORPOS_DEFAULT) !=
				ADVISORPOS_NONE) && (globs::gameGlobs.viewMode != VIEW_FIRSTPERSON)) &&
		 ((globals::g_Advisor_CurrentFlags & ADVISORSTATE_UNK_1) == ADVISORSTATE_NONE)) {
		globals::g_Advisor_CurrentType = advisorType;
		Advisor_SetCurrentSound(advisorType);
		if (setFlag2 != 0) {
			globals::g_Advisor_CurrentFlags =
					 globals::g_Advisor_CurrentFlags | (ADVISORSTATE_UNK_1|ADVISORSTATE_UNK_2);
			return 1;
		}
		globals::g_Advisor_CurrentFlags =
				 globals::g_Advisor_CurrentFlags & ~ADVISORSTATE_UNK_2 | ADVISORSTATE_UNK_1;
		return 1;
	}
	return 0;
}



void __cdecl lego::front::Advisor_SetCurrentSound(AdvisorType advisorType)
{
	Container *cont;
	
	cont = globals::g_AdvisorAnimsData_TABLE[globals::g_AdvisorPositions_TABLE[advisorType].animType].
				 resData;
	if (cont != NULL) {
		res::Container_Hide(cont,0);
		res::Container_SetAnimationTime(cont,0.0);
		snd::SFX_Sample_Random_Play_OrAddToQueue
							(globals::g_AdvisorPositions_TABLE[advisorType].sfxIndex,0);
		snd::SFX_Sample_AddToQueue(SFX_CAPTAINSLIDE,0);
	}
	return;
}



void __cdecl lego::front::Advisor_Update(float elapsed)
{
	Container *cont;
	BOOL BVar1;
	AdvisorType advisorType;
	
	advisorType = globals::g_Advisor_CurrentType;
	cont = globals::g_AdvisorAnimsData_TABLE
				 [globals::g_AdvisorPositions_TABLE[globals::g_Advisor_CurrentType].animType].resData;
	if (cont != NULL) {
		if (((globals::g_Advisor_CurrentFlags & ADVISORSTATE_UNK_1) != ADVISORSTATE_NONE) &&
			 (globs::gameGlobs.viewMode != VIEW_FIRSTPERSON)) {
			if ((globals::g_AdvisorPositions_TABLE[globals::g_Advisor_CurrentType].flags &
					ADVISORPOS_HASTEXT) != ADVISORPOS_NONE) {
				Text_DisplayMessage(globals::g_AdvisorPositions_TABLE[globals::g_Advisor_CurrentType].
														textType,1,0);
			}
			res::Container_Hide(cont,0);
			res::Container_Hide(globals::g_Advisor_ResLight,0);
			res::Container_Light_SetEnableContainer(globals::g_Advisor_ResLight,cont);
			Advisor_FUN_00401a70(advisorType);
			BVar1 = Advisor_FUN_004019b0(globals::g_AdvisorPositions_TABLE[advisorType].animType,elapsed);
			if (BVar1 != 0) {
				return;
			}
			globals::g_Advisor_CurrentFlags &= ~ADVISORSTATE_UNK_1;
		}
		res::Container_Hide(cont,1);
	}
	res::Container_Hide(globals::g_Advisor_ResLight,1);
	return;
}



BOOL __cdecl lego::front::Advisor_FUN_004019b0(AdvisorAnimType animType,float elapsed)
{
	Container *cont;
	float10 fVar1;
	
	cont = globals::g_AdvisorAnimsData_TABLE[animType].resData;
	fVar1 = res::Container_MoveAnimation(cont,elapsed);
	if (((byte)globals::g_Advisor_CurrentFlags & ADVISORSTATE_UNK_2) == 0) {
		if ((ushort)((ushort)(fVar1 < (float10)0.0) << 8 | (ushort)(fVar1 == (float10)0.0) << 0xe) == 0)
		{
			return 0;
		}
	}
	else {
		if ((ushort)((ushort)(fVar1 < (float10)0.0) << 8 | (ushort)(fVar1 == (float10)0.0) << 0xe) == 0)
		{
			res::Container_SetAnimationTime
								(cont,(float)((float10)globals::g_AdvisorAnimsData_TABLE[animType].loopStartTime +
														 fVar1));
			return 1;
		}
		fVar1 = res::Container_GetAnimationTime(cont);
		if ((float10)globals::g_AdvisorAnimsData_TABLE[animType].loopEndTime <= fVar1) {
			res::Container_SetAnimationTime
								(cont,(float)((fVar1 - (float10)globals::g_AdvisorAnimsData_TABLE[animType].
																								loopEndTime) +
														 (float10)globals::g_AdvisorAnimsData_TABLE[animType].loopStartTime));
			return 1;
		}
	}
	return 1;
}



void __cdecl lego::front::Advisor_ClearFlag2(void)
{
	globals::g_Advisor_CurrentFlags = globals::g_Advisor_CurrentFlags & ~ADVISORSTATE_UNK_2;
	return;
}



void __cdecl lego::front::Advisor_FUN_00401a70(AdvisorType advisorType)
{
	Container *cont;
	AdvisorType AVar1;
	float y;
	Vector3F vector;
	Vector4F transform4d;
	
	AVar1 = advisorType;
	cont = globals::g_AdvisorAnimsData_TABLE[globals::g_AdvisorPositions_TABLE[advisorType].animType].
				 resData;
	if ((globals::g_AdvisorPositions_TABLE[advisorType].flags & ADVISORPOS_NOPANEL) == ADVISORPOS_NONE
		 ) {
										// output -> x, y (get panel position?)
		Panel_GetXYField3(globals::g_AdvisorPositions_TABLE[advisorType].panelType,(float *)&advisorType
											,&y);
	}
	else {
		advisorType = ADVISOR_OBJECTIVE;
		y = 0.0;
	}
	transform4d.x = globals::g_AdvisorPositions_TABLE[AVar1].point1.x + (float)advisorType;
	transform4d.z = globals::g_AdvisorPosition_Z;
	transform4d.y = globals::g_AdvisorPositions_TABLE[AVar1].point1.y + y;
	transform4d.w = 1.0;
	lego::view::Viewport_InverseTransform((Viewport *)globals::g_Advisor_ptr1c,&vector,&transform4d);
	res::Container_SetPosition(cont,NULL,vector.x,vector.y,vector.z);
	return;
}



ProgrammerMode __cdecl lego::main::Main_ProgrammerMode(void)
{
	return globs::mainGlobs.programmerLevel;
}



char * __cdecl lego::main::Main_GetStartLevel(void)
{
	return (char *)(-(uint)((globs::mainGlobs.flags & CMD_STARTLEVEL) != CMD_NONE) & 0x506f8c);
}



BOOL __cdecl lego::front::Advisor_GetFlag1(void)
{
	return globals::g_Advisor_CurrentFlags & ADVISORSTATE_UNK_1;
}



int __cdecl lego::main::appWidth(void)
{
	return globs::mainGlobs.appWidth;
}



int __cdecl lego::main::appHeight(void)
{
	return globs::mainGlobs.appHeight;
}



uint __cdecl lego::image::Font_GetStringWidth(ImageFont *font,char *msg,...)
{
	Font_VGetStringInfo(font,(uint *)&font,NULL,msg,&stack0x0000000c);
	return (uint)font;
}



void __cdecl
lego::image::Font_GetStringInfo(ImageFont *font,uint *out_width,uint *out_lineCount,char *msg,...)
{
	Font_VGetStringInfo(font,out_width,out_lineCount,msg,&stack0x00000014);
	return;
}



BOOL __cdecl lego::ai::AIPriority_GetType(char *aiPriorityName,AIPriorityType *out_priorityType)
{
	int iVar1;
	char **ppcVar2;
	AIPriorityType AVar3;
	
	AVar3 = AIPRIORITY_CRYSTAL;
	ppcVar2 = globals::g_AIPriorities_TABLE;
	do {
		iVar1 = std::_stricmp(aiPriorityName,*ppcVar2);
		if (iVar1 == 0) {
			*out_priorityType = AVar3;
			return TRUE;
		}
		ppcVar2 = ppcVar2 + 1;
		AVar3 += AIPRIORITY_ORE;
	} while (ppcVar2 < globals::g_AIPriorityValues_TABLE);
	return 0;
}



void __cdecl lego::ai::AITask_Initialise(void)
{
	int iVar1;
	AITaskData **ppAVar2;
	uint *puVar3;
	
	ppAVar2 = pool::globals::ReservedPool_AITask___g_TABLE;
	for (iVar1 = 0xc; iVar1 != 0; iVar1 += -1) {
		*ppAVar2 = NULL;
		ppAVar2 = ppAVar2 + 1;
	}
	globals::g_AITaskTypes_TABLE[0] = "AITask_Type_Goto";
	globals::g_AITaskTypes_TABLE[1] = "AITask_Type_Follow";
	globals::g_AITaskTypes_TABLE[2] = "AITask_Type_FollowAttack";
	globals::g_AITaskTypes_TABLE[3] = "AITask_Type_Collect";
	globals::g_AITaskTypes_TABLE[4] = "AITask_Type_Gather";
	globals::g_AITaskTypes_TABLE[12] = "AITask_Type_Clear";
	globals::g_AITaskTypes_TABLE[5] = "AITask_Type_Deposit";
	globals::g_AITaskTypes_TABLE[6] = "AITask_Type_Dump";
	globals::g_AITaskTypes_TABLE[7] = "AITask_Type_Request";
	globals::g_AITaskTypes_TABLE[10] = "AITask_Type_Repair";
	globals::g_AITaskTypes_TABLE[8] = "AITask_Type_Dig";
	globals::g_AITaskTypes_TABLE[9] = "AITask_Type_Dynamite";
	globals::g_AITaskTypes_TABLE[11] = "AITask_Type_Reinforce";
	globals::g_AITaskTypes_TABLE[13] = "AITask_Type_Wait";
	globals::g_AITaskTypes_TABLE[14] = "AITask_Type_AnimationWait";
	globals::g_AITaskTypes_TABLE[15] = "AITask_Type_ElecFence";
	globals::g_AITaskTypes_TABLE[16] = "AITask_Type_Eat";
	globals::g_AITaskTypes_TABLE[17] = "AITask_Type_GotoEat";
	globals::g_AITaskTypes_TABLE[18] = "AITask_Type_FindDriver";
	globals::g_AITaskTypes_TABLE[19] = "AITask_Type_GetTool";
	globals::g_AITaskTypes_TABLE[20] = "AITask_Type_BirdScarer";
	globals::g_AITaskTypes_TABLE[21] = "AITask_Type_Upgrade";
	globals::g_AITaskTypes_TABLE[22] = "AITask_Type_BuildPath";
	globals::g_AITaskTypes_TABLE[23] = "AITask_Type_Train";
	globals::g_AITaskTypes_TABLE[24] = "AITask_Type_Depart";
	globals::g_AITaskTypes_TABLE[25] = "AITask_Type_AttackPath";
	globals::g_AITaskTypes_TABLE[26] = "AITask_Type_AttackRockMonster";
	globals::g_AITaskTypes_TABLE[27] = "AITask_Type_Recharge";
	globals::g_AITaskTypes_TABLE[28] = "AITask_Type_Dock";
	globals::g_AITaskTypes_TABLE[29] = "AITask_Type_AttackObject";
	globals::g_AITaskTypes_TABLE[30] = "AITask_Type_FindLoad";
	globals::g_AIPriorities_TABLE[0] = "AI_Priority_Crystal";
	globals::g_AIPriorities_TABLE[1] = "AI_Priority_Ore";
	globals::g_AIPriorities_TABLE[2] = "AI_Priority_DefaultCollect";
	globals::g_AIPriorities_TABLE[3] = "AI_Priority_Destruction";
	globals::g_AIPriorities_TABLE[4] = "AI_Priority_Construction";
	globals::g_AIPriorities_TABLE[5] = "AI_Priority_Request";
	globals::g_AIPriorities_TABLE[6] = "AI_Priority_Reinforce";
	globals::g_AIPriorities_TABLE[7] = "AI_Priority_Repair";
	globals::g_AIPriorities_TABLE[8] = "AI_Priority_Clearing";
	globals::g_AIPriorities_TABLE[9] = "AI_Priority_Storage";
	globals::g_AIPriorities_TABLE[10] = "AI_Priority_Refining";
	globals::g_AIPriorities_TABLE[11] = "AI_Priority_HealthLow";
	globals::g_AIPriorities_TABLE[12] = "AI_Priority_GetIn";
	globals::g_AIPriorities_TABLE[13] = "AI_Priority_Upgrade";
	globals::g_AIPriorities_TABLE[14] = "AI_Priority_BuildPath";
	globals::g_AIPriorities_TABLE[15] = "AI_Priority_AttackRockMonster";
	globals::g_AIPriorities_TABLE[16] = "AI_Priority_Barrier";
	globals::g_AIPriorities_TABLE[17] = "AI_Priority_FindLoad";
	globals::g_AIPriorities_TABLE[18] = "AI_Priority_Recharge";
	globals::g_AIPriorities_TABLE[19] = "AI_Priority_UpgradeBuilding";
	globals::g_AIPriorities_TABLE[20] = "AI_Priority_Gather";
	globals::g_AIPriorities_TABLE[21] = "AI_Priority_Steal";
	globals::g_AIPriorities_TABLE[22] = "AI_Priority_Punch";
	globals::g_AIPriorities_TABLE[23] = "AI_Priority_Depart";
	globals::g_AIPriorities_TABLE[24] = "AI_Priority_AttackPath";
	globals::g_AIPriorities_TABLE[26] = "AI_Priority_Congregate";
	globals::g_AIPriorities_TABLE[25] = "AI_Priority_AttackObject";
	puVar3 = globals::g_AIPriorityValues_TABLE;
	for (iVar1 = 0x1b; iVar1 != 0; iVar1 += -1) {
		*puVar3 = 0x31;
		puVar3 = puVar3 + 1;
	}
	pool::globals::ReservedPool_AITask___g_NEXT = NULL;
	pool::globals::ReservedPool_AITask___g_COUNT = 0;
	globals::g_AIPriorityValues_TABLE[0] = 0x37;
	globals::g_AIPriorityValues_TABLE[3] = 0x28;
	globals::g_AIPriorityValues_TABLE[4] = 0x3c;
	globals::g_AIPriorityValues_TABLE[5] = 0x14;
	globals::g_AIPriorityValues_TABLE[6] = 0x46;
	globals::g_AIPriorityValues_TABLE[8] = 0x14;
	globals::g_AIPriorityValues_TABLE[9] = 5;
	globals::g_AIPriorityValues_TABLE[10] = 0xf;
	globals::g_AIPriorityValues_TABLE[15] = 0x38;
	globals::g_AIPriorityValues_TABLE[19] = 99;
	globals::g_AIPriorityValues_TABLE[20] = 0x31;
	globals::g_AIPriorityValues_TABLE[21] = 0x5a;
	globals::g_AIPriorityValues_TABLE[22] = 0x31;
	globals::g_AIPriorityValues_TABLE[23] = 0;
	globals::g_AIPriorityValues_TABLE[24] = 0x14;
	globals::g_AIPriorityValues_TABLE[25] = 0x1e;
	globals::g_AIPriorityValues_TABLE[26] = 99;
	pool::globals::ReservedPool_AITask___g_INITFLAGS = 1;
	return;
}



void __cdecl
lego::ai::AITask_FUN_00401f40(AITaskType taskType,LiveObject *liveObj,Point2I *opt_position)
{
	AITaskData **ppAVar1;
	AITaskData *pAVar2;
	
	pAVar2 = globals::g_AITaskUnkPtr;
	if (globals::g_AITaskUnkPtr != NULL) {
		do {
			if (pAVar2->taskType == taskType) {
				if ((liveObj != NULL) && (liveObj == pAVar2->object_10)) {
					pAVar2->flags_5c = pAVar2->flags_5c | 0x10000;
				}
				if (((opt_position != NULL) && (opt_position->x == (pAVar2->position).x)) &&
					 (opt_position->y == (pAVar2->position).y)) {
					pAVar2->flags_5c = pAVar2->flags_5c | 0x10000;
				}
			}
			ppAVar1 = &pAVar2->next;
			pAVar2 = *ppAVar1;
		} while (*ppAVar1 != NULL);
	}
	return;
}



void __cdecl lego::ai::AITask_SetPriorityType(AITaskData *aiTask,AIPriorityType priorityType)
{
	uint uVar1;
	
	if ((aiTask->flags_5c & 0x30000) == 0) {
		uVar1 = globals::g_AIPriorityValues_TABLE[priorityType];
		aiTask->priorityType = priorityType;
		aiTask->priorityValue = uVar1;
		return;
	}
	aiTask->priorityValue = 99;
	aiTask->priorityType = priorityType;
	return;
}



void __cdecl lego::ai::AITask_Game_SetAITaskValue2(int index,uint aiTaskValue)
{
	globals::g_AIPriorityValues_TABLE[index] = aiTaskValue;
	return;
}



void __cdecl lego::ai::AITask_Game_SetIsPriorityDisabled(int priorityIndex,BOOL isDisabled)
{
	globals::g_Priorities_bool2_TABLE[priorityIndex] = isDisabled;
	return;
}



BOOL __cdecl lego::ai::AITask_Game_IsPriorityDisabled(int priorityIndex)
{
	return globals::g_Priorities_bool2_TABLE[priorityIndex];
}



void __cdecl lego::ai::AITask_Shutdown(void)
{
	AITaskData **ppAVar1;
	
	ppAVar1 = pool::globals::ReservedPool_AITask___g_TABLE;
	do {
		if (*ppAVar1 != NULL) {
			std::free(*ppAVar1);
		}
		ppAVar1 = ppAVar1 + 1;
	} while (ppAVar1 < &pool::globals::ReservedPool_AITask___g_NEXT);
	pool::globals::ReservedPool_AITask___g_NEXT = NULL;
	pool::globals::ReservedPool_AITask___g_INITFLAGS = 0;
	return;
}



void __cdecl lego::ai::AITask_FUN_00402040(BOOL param_1)
{
	int iVar1;
	undefined4 *puVar2;
	BOOL *pBVar3;
	
	if (param_1 != 0) {
		pool::globals::ReservedPool_AITask___g_INITFLAGS =
				 pool::globals::ReservedPool_AITask___g_INITFLAGS & 0xfffffffd;
		return;
	}
	AITask_DoUnkCallbacks(AITask_Release_0,NULL);
	pool::globals::ReservedPool_AITask___g_INITFLAGS |= 2;
	globals::g_AITaskUnkPtr = NULL;
	globals::g_AITaskDataNext = NULL;
	puVar2 = &DAT_004b44f4;
	for (iVar1 = 0x12c0; iVar1 != 0; iVar1 += -1) {
		*puVar2 = 0;
		puVar2 = puVar2 + 1;
	}
	pBVar3 = globals::g_Priorities_bool2_TABLE;
	for (iVar1 = 0x1b; iVar1 != 0; iVar1 += -1) {
		*pBVar3 = 0;
		pBVar3 = pBVar3 + 1;
	}
	return;
}



void __cdecl lego::ai::AITask_Game_SetNoGather(BOOL noGather)
{
	AITaskData *pAVar1;
	
	if (noGather == 0) {
		AITask_DoGather_Count(0);
	}
	pAVar1 = AITask_Create(AITASK_DEPART);
	AITask_SetPriorityType(pAVar1,AIPRIORITY_DEPART);
	pAVar1->flags_5c = pAVar1->flags_5c | 0x40;
	pAVar1->next = globals::g_AITaskDataNext;
	globals::g_AITaskDataNext = pAVar1;
	pAVar1 = AITask_Create(AITASK_RECHARGE);
	AITask_InitTask_1(pAVar1,AIPRIORITY_CRYSTAL);
	pAVar1->flags_5c = pAVar1->flags_5c & 0xffffffef | 0x440;
	return;
}



BOOL __cdecl lego::ai::AITask_Release_0(AITaskData *aiTask)
{
	AITask_Remove(aiTask,1);
	return 0;
}



void __cdecl lego::util::free2(undefined *param_1)
{
	std::free(param_1);
	return;
}



void __cdecl lego::ai::AITask_Update(float elapsedGame)
{
	float fVar1;
	AITaskData *pAVar2;
	uint uVar3;
	uint uVar4;
	
	uVar4 = globals::g_AIPriorityValues_TABLE[1];
	if ((int)globals::g_AIPriorityValues_TABLE[1] <= (int)globals::g_AIPriorityValues_TABLE[0]) {
		uVar4 = globals::g_AIPriorityValues_TABLE[0];
	}
	uVar3 = globals::g_AIPriorityValues_TABLE[4];
	if (((int)globals::g_AIPriorityValues_TABLE[4] < (int)uVar4) &&
		 (uVar3 = globals::g_AIPriorityValues_TABLE[0],
		 (int)globals::g_AIPriorityValues_TABLE[0] < (int)globals::g_AIPriorityValues_TABLE[1])) {
		uVar3 = globals::g_AIPriorityValues_TABLE[1];
	}
	globals::g_AIPriorityValues_TABLE[16] = uVar3 + 1;
	if ((pool::globals::ReservedPool_AITask___g_INITFLAGS & 0x80000000) == 0) {
		AITask_DoUnkCallbacks(AITask_Callback_FUN_00404180,(LiveObject *)&elapsedGame);
		for (pAVar2 = globals::g_AITaskUnkPtr; pAVar2 != NULL; pAVar2 = pAVar2->next) {
			if (((pAVar2->taskType == AITASK_REPAIR) && ((pAVar2->flags_5c & 0x200000) == 0)) &&
				 ((fVar1 = pAVar2->object_10->health,
					(ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) != 0 ||
					(100.0 <= pAVar2->object_10->health)))) {
				pAVar2->flags_5c = pAVar2->flags_5c | 0x20;
			}
		}
		AITask_FUN_00402240(&globals::g_AITaskUnkPtr);
		AITask_FUN_00402240(&globals::g_AITaskDataNext);
		INT_004b4424 = 0;
		UINT_004b44f0 = 0;
		game::Search_LiveObjects_SkipIgnoreMes(AITask_LiveObject_Callback_DoAITask,&elapsedGame);
		AITask_FUN_00405b40();
		AITask_FUN_00405880();
	}
	return;
}



void __cdecl lego::ai::AITask_FUN_00402240(AITaskData **ref_aiTask)
{
	AITaskData **ppAVar1;
	AITaskData *pAVar2;
	AITaskData *pAVar3;
	uint uVar4;
	bool bVar5;
	AITaskData **ppAVar6;
	BOOL BVar7;
	int iVar8;
	int iVar9;
	int iVar10;
	AITaskData *pAVar11;
	uint number;
	int *piVar12;
	AITaskData *local_4dc;
	int local_4d0 [5];
	undefined4 local_4bc;
	undefined4 local_4b8;
	undefined4 local_4b4;
	AITaskData *local_4b0 [300];
	
	local_4dc = NULL;
	pAVar2 = *ref_aiTask;
	pAVar11 = NULL;
	while (pAVar3 = pAVar11, pAVar11 = pAVar2, pAVar11 != NULL) {
		pAVar2 = pAVar11->next;
		if ((*(byte *)&pAVar11->flags_5c & 0x20) != 0) {
			if (pAVar3 == NULL) {
				*ref_aiTask = pAVar2;
				AITask_Remove(pAVar11,0);
				pAVar11 = pAVar3;
			}
			else {
				pAVar3->next = pAVar2;
				AITask_Remove(pAVar11,0);
				pAVar11 = pAVar3;
			}
		}
	}
	number = 0;
	pAVar2 = local_4dc;
	if (*ref_aiTask != NULL) {
		ppAVar6 = local_4b0;
		pAVar11 = *ref_aiTask;
		do {
			pAVar3 = pAVar11->next;
			pAVar2 = pAVar11;
			if (number == 300) break;
			*ppAVar6 = pAVar11;
			ppAVar6 = ppAVar6 + 1;
			number += 1;
			if ((globals::g_Priorities_bool2_TABLE[pAVar11->priorityType] == 0) ||
				 ((pAVar11->flags_5c & 0x10000) != 0)) {
				uVar4 = pAVar11->flags_5c;
				pAVar11->flags_5c = uVar4 & 0xfff7ffff;
				if ((uVar4 & 0x30000) == 0) {
					pAVar11->priorityValue = globals::g_AIPriorityValues_TABLE[pAVar11->priorityType];
				}
				else {
					pAVar11->priorityValue = 99;
				}
			}
			else {
				pAVar11->flags_5c = pAVar11->flags_5c | 0x80000;
			}
			if (pAVar11->taskType == AITASK_DIG) {
				if ((*(byte *)&pAVar11->flags_5c & 8) == 0) {
					BVar7 = game::Level_BlockIsNotFlags1_18((pAVar11->position).x,(pAVar11->position).y);
					if (BVar7 != 0) {
						pAVar11->priorityValue = 0;
					}
				}
				else {
					local_4d0[0] = 0;
					local_4d0[1] = 0;
					local_4d0[2] = 0;
					local_4b4 = 0;
					local_4d0[3] = 0xffffffff;
					local_4d0[4] = 0xffffffff;
					local_4bc = 0xffffffff;
					local_4b8 = 0xffffffff;
					bVar5 = false;
					piVar12 = local_4d0;
					iVar10 = 4;
					do {
						BVar7 = game::Level_GetBlockFlags1_10Not8
															(*piVar12 + (pAVar11->position).x,piVar12[1] + (pAVar11->position).y);
						if (BVar7 != 0) {
							bVar5 = true;
						}
						piVar12 = piVar12 + 2;
						iVar10 += -1;
					} while (iVar10 != 0);
					if (bVar5) {
						if (pAVar11->priorityValue == 0) {
							pAVar11->float_18 = (float)&DAT_42c80000;
						}
					}
					else {
						pAVar11->priorityValue = 0;
					}
				}
			}
			pAVar11 = pAVar3;
			pAVar2 = local_4dc;
		} while (pAVar3 != NULL);
	}
	local_4dc = pAVar2;
	if (number != 0) {
		std::qsort(local_4b0,number,4,AITask_QSortCompare);
		iVar10 = number - 1;
		iVar9 = 0;
		if (iVar10 != 0) {
			ppAVar6 = local_4b0;
			iVar8 = iVar10;
			do {
				pAVar2 = *ppAVar6;
				ppAVar1 = ppAVar6 + 1;
				ppAVar6 = ppAVar6 + 1;
				iVar8 += -1;
				pAVar2->next = *ppAVar1;
				iVar9 = iVar10;
			} while (iVar8 != 0);
		}
		local_4b0[iVar9]->next = local_4dc;
		*ref_aiTask = local_4b0[0];
	}
	return;
}



void __cdecl lego::ai::AITask_DoDig_AtBlockPos(Point2I *blockPos,BOOL param_2,BOOL param_3)
{
	uint uVar1;
	LevelData *pLVar2;
	BOOL BVar3;
	AITaskData *aiTask;
	int iVar4;
	
	pLVar2 = game::GetLevel();
	BVar3 = game::Level_Block_IsImmovable(blockPos);
	if (BVar3 == 0) {
		BVar3 = game::Level_Block_IsLava(blockPos);
		if (BVar3 == 0) {
			BVar3 = FUN_00432ec0(blockPos->x,blockPos->y);
			if (BVar3 != 0) {
				aiTask = AITask_Create(AITASK_DIG);
				(aiTask->position).x = blockPos->x;
				(aiTask->position).y = blockPos->y;
				if (param_2 != 0) {
					aiTask->flags_5c = aiTask->flags_5c | 8;
				}
				AITask_UnkInitRouting_FUN_00402530(aiTask,1);
				AITask_InitTask_1(aiTask,AIPRIORITY_DESTRUCTION);
				uVar1 = aiTask->flags_5c;
				aiTask->flags_5c = uVar1 | 0x80;
				if (param_3 != 0) {
					aiTask->flags_5c = uVar1 | 0x20080;
				}
				if (param_2 == 0) {
					game::Map3D_Block_SetHighlightType
										(pLVar2->surfaceMap,blockPos->x,blockPos->y,WALLHIGHLIGHT_DIG);
					iVar4 = (pLVar2->dimensions).width * blockPos->y + blockPos->x;
					pLVar2->blocks[iVar4].flags1 = pLVar2->blocks[iVar4].flags1 | BLOCK1_UNK_800000;
				}
			}
		}
	}
	return;
}



void __cdecl lego::ai::AITask_UnkInitRouting_FUN_00402530(AITaskData *aiTask,BOOL param_2)
{
	uint *out_unitsCount;
	LiveObject **out_unitsTable;
	BOOL BVar1;
	uint uVar2;
	
	BVar1 = game::Message_IsAnyUnitsSelected();
	if (BVar1 != 0) {
		out_unitsCount = &aiTask->field_44;
		out_unitsTable = (LiveObject **)&aiTask->ptr_40;
		aiTask->flags_5c = aiTask->flags_5c | 0x140;
		game::Message_CopySelectedUnits(out_unitsTable,out_unitsCount);
		uVar2 = 0;
		if (*out_unitsCount != 0) {
			do {
				game::LiveObject_UnkDoRouting_FUN_00441c00
									(*(LiveObject **)((int)(*out_unitsTable)->routing_points_4 + uVar2 * 4 + -0x34),0)
				;
				if (param_2 != 0) {
					game::LiveObject_FUN_0043a130
										(*(LiveObject **)((int)(*out_unitsTable)->routing_points_4 + uVar2 * 4 + -0x34),
										 0);
				}
				uVar2 += 1;
			} while (uVar2 < *out_unitsCount);
		}
	}
	return;
}



void __cdecl lego::ai::AITask_DoAttackRockMonster_Target(LiveObject *targetObj)
{
	BOOL BVar1;
	AITaskData *aiTask;
	
	game::GetLevel();
	if (targetObj != NULL) {
		BVar1 = game::LiveObject_CanShootObject(targetObj);
		if (BVar1 != 0) {
			aiTask = AITask_Create(AITASK_ATTACKROCKMONSTER);
			AITask_InitTask_1(aiTask,AIPRIORITY_ATTACKROCKMONSTER);
			aiTask->object_10 = targetObj;
			aiTask->flags_5c = aiTask->flags_5c & 0xffffffef | 0x40040;
		}
	}
	return;
}



void __cdecl lego::ai::AITask_LiveObject_FUN_004025f0(LiveObject *liveObj)
{
	BOOL BVar1;
	
	if ((liveObj->carryingThisObject == NULL) && ((liveObj->flags4 & 0x100) == LIVEOBJ4_NONE)) {
		BVar1 = AITask_DoUnkCallbacks(AITask_IsCollectAndSameTarget,liveObj);
		if (BVar1 == 0) {
			AITask_DoCollect(liveObj,0.0);
		}
	}
	return;
}



BOOL __cdecl lego::ai::AITask_IsCollectAndSameTarget(AITaskData *aiTask,LiveObject *liveObj)
{
	if ((aiTask->taskType == AITASK_COLLECT) && (aiTask->object_10 == liveObj)) {
		return 1;
	}
	return 0;
}



void __cdecl lego::ai::AITask_DoCollect(LiveObject *liveObj,float param_2)
{
	ObjectType OVar1;
	AITaskData *aiTask;
	AIPriorityType priorityType;
	
	priorityType = AIPRIORITY_DEFAULTCOLLECT;
	aiTask = AITask_Create(AITASK_COLLECT);
	aiTask->object_10 = liveObj;
	aiTask->float_18 = param_2;
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_POWERCRYSTAL) {
		priorityType = -(uint)((liveObj->flags3 & LIVEOBJ3_POWEROFF) != LIVEOBJ3_NONE) & 0x12;
	}
	else {
		if (OVar1 == OBJECT_ORE) {
			priorityType = AIPRIORITY_ORE;
		}
		else {
			if (OVar1 == OBJECT_BARRIER) {
				priorityType = AIPRIORITY_BARRIER;
			}
			else {
				if (OVar1 == OBJECT_DYNAMITE) {
					aiTask->mode_3c = 8;
					priorityType = AIPRIORITY_DESTRUCTION;
				}
			}
		}
	}
	AITask_InitTask_1(aiTask,priorityType);
	AITask_DoCollect_Target(liveObj);
	return;
}



void __cdecl lego::ai::AITask_DoBuildPath_AtPosition(Point2I *position)
{
	BOOL BVar1;
	int iVar2;
	AITaskData *aiTask;
	
	BVar1 = game::Level_Block_IsPowerPath(position);
	if (BVar1 == 0) {
		iVar2 = game::Level_GetBlockRubbleLevel_OrFlag200000(position);
		if (iVar2 == 0) {
			BVar1 = game::Dependencies_Object_FUN_0040add0(OBJECT_PATH,0,0);
			if (BVar1 != 0) {
				aiTask = AITask_Create(AITASK_BUILDPATH);
				(aiTask->position).x = position->x;
				(aiTask->position).y = position->y;
				AITask_InitTask_1(aiTask,AIPRIORITY_BUILDPATH);
			}
		}
	}
	return;
}



void __cdecl lego::ai::AITask_DoGather_Count(int count)
{
	AITaskData *aiTask;
	bool bVar1;
	
	bVar1 = count == 0;
	if (bVar1) {
		count = 1;
	}
	if (true) {
		do {
			aiTask = AITask_Create(AITASK_GATHER);
			AITask_SetPriorityType(aiTask,AIPRIORITY_GATHER);
			if (bVar1) {
				aiTask->flags_5c = aiTask->flags_5c | 0x40;
			}
			AITask_Init_2_NoPriority(aiTask);
			count += -1;
		} while (count != 0);
	}
	return;
}



void __cdecl lego::ai::AITask_DoCollect_Target(LiveObject *targetObj)
{
	AITaskData *aiTask;
	
	if (targetObj->objType == OBJECT_POWERCRYSTAL) {
		aiTask = AITask_Create(AITASK_COLLECT);
		aiTask->object_10 = targetObj;
		AITask_SetPriorityType(aiTask,AIPRIORITY_STEAL);
		AITask_Init_2_NoPriority(aiTask);
		aiTask->flags_5c = aiTask->flags_5c | 0x2000;
	}
	return;
}



void __cdecl
lego::ai::AITask_DoTrain_Target(LiveObject *targetObj,TrainedFlags training,BOOL param_3)
{
	BOOL BVar1;
	AITaskData *aiTask;
	AIPriorityType priorityType;
	
	BVar1 = game::LiveObject_HasTraining(targetObj,training);
	if (BVar1 == 0) {
		return;
	}
	aiTask = AITask_Create(AITASK_TRAIN);
	aiTask->object_10 = targetObj;
	aiTask->mode_3c = training;
	if (false) {
switchD_004027fb_caseD_3:
		priorityType = AIPRIORITY_UPGRADE;
	}
	else {
		switch(training) {
		case TRAINED_PILOT:
		case TRAINED_SAILOR:
		case TRAINED_DRIVER:
			priorityType = AIPRIORITY_GETIN;
			break;
		default:
			goto switchD_004027fb_caseD_3;
		case TRAINED_DYNAMITE:
			priorityType = AIPRIORITY_DESTRUCTION;
			break;
		case TRAINED_REPAIR:
			priorityType = AIPRIORITY_REPAIR;
			break;
		case TRAINED_SCANNER:
			priorityType = AIPRIORITY_CONSTRUCTION;
		}
	}
	if (param_3 != 0) {
		AITask_UnkInitRouting_FUN_00402530(aiTask,1);
	}
	AITask_InitTask_1(aiTask,priorityType);
	aiTask->flags_5c = aiTask->flags_5c & 0xffffffbf;
	return;
}



void __cdecl lego::ai::AITask_DoFindDriver_Target(LiveObject *targetObj)
{
	AITaskData *aiTask;
	ObjectStatsFlags3 OVar1;
	ObjectStatsFlags1 OVar2;
	
	if ((*(byte *)&targetObj->flags2 & LIVEOBJ2_UNK_10) == 0) {
		aiTask = AITask_Create(AITASK_FINDDRIVER);
		aiTask->object_10 = targetObj;
		targetObj->flags2 = targetObj->flags2 | LIVEOBJ2_UNK_10;
		OVar1 = game::LiveObject_GetStatsFlags3(targetObj);
		if ((OVar1 & STATS3_NEEDSPILOT) == STATS3_NONE) {
			OVar2 = game::LiveObject_GetStatsFlags1(targetObj);
			if ((OVar2 & STATS1_CROSSLAND) == STATS1_NONE) {
				OVar2 = game::LiveObject_GetStatsFlags1(targetObj);
				if ((OVar2 & STATS1_CROSSWATER) != STATS1_NONE) {
					aiTask->mode_3c = 2;
				}
			}
			else {
				OVar2 = game::LiveObject_GetStatsFlags1(targetObj);
				if ((OVar2 & STATS1_CROSSWATER) == STATS1_NONE) {
					aiTask->mode_3c = 4;
				}
				else {
					aiTask->mode_3c = 1;
				}
			}
		}
		else {
			aiTask->mode_3c = 1;
		}
		OVar1 = game::LiveObject_GetStatsFlags3(targetObj);
		if (((OVar1 & STATS3_TAKECARRYINGDRIVERS) != STATS3_NONE) &&
			 ((targetObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE)) {
			aiTask->flags_5c = aiTask->flags_5c | 0x100000;
		}
		AITask_UnkInitRouting_FUN_00402530(aiTask,~aiTask->flags_5c >> 0x14 & 1);
		aiTask->flags_5c = aiTask->flags_5c & 0xffffffbf;
		AITask_InitTask_1(aiTask,AIPRIORITY_GETIN);
	}
	return;
}



BOOL __cdecl lego::ai::AITask_DoCallbacks_IfAttackPath_FUN_00402970(Point2I *blockPos)
{
	BOOL BVar1;
	Point2I *local_8;
	int local_4;
	
	local_8 = blockPos;
	local_4 = 0;
	BVar1 = AITask_DoUnkCallbacks(AITask_Callback_IfAttackPath_FUN_004029a0,(LiveObject *)&local_8);
	return BVar1;
}



BOOL __cdecl
lego::ai::AITask_Callback_IfAttackPath_FUN_004029a0(AITaskData *aiTask,Point2I **param_2)
{
	if (((aiTask->taskType == AITASK_ATTACKPATH) && ((*param_2)->x == (aiTask->position).x)) &&
		 ((*param_2)->y == (aiTask->position).y)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



BOOL __cdecl lego::ai::AITask_LiveObject_DoCallbacks_FUN_004029d0(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = AITask_DoUnkCallbacks(AITask_Callback_FUN_004029f0,liveObj);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_004029f0(AITaskData *aiTask,LiveObject *liveObj)
{
	if ((aiTask->taskType == AITASK_ATTACKROCKMONSTER) && (aiTask->object_10 == liveObj)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



void __cdecl lego::ai::AITask_Block_FUN_00402a10(Point2I *blockPos,int param_2)
{
	LevelData *level;
	Point2I *local_8;
	int local_4;
	
	level = game::GetLevel();
	local_8 = blockPos;
	local_4 = param_2;
	AITask_DoUnkCallbacks(AITask_Callback_FUN_00402ae0,(LiveObject *)&local_8);
	game::Map3D_Block_ClearHighlight(level->surfaceMap,blockPos->x,blockPos->y);
	return;
}



BOOL __cdecl lego::ai::AITask_Block_FUN_00402a60(Point2I *blockPos)
{
	BOOL BVar1;
	Point2I *local_8;
	int local_4;
	
	local_8 = blockPos;
	local_4 = 0;
	BVar1 = AITask_DoUnkCallbacks(AITask_Callback_FUN_00402b50,(LiveObject *)&local_8);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_DoCallbacks_Block_FUN_00402a90(Point2I *blockPos,BOOL param_2)
{
	BOOL BVar1;
	Point2I *local_8;
	int local_4;
	
	local_4 = 0;
	local_8 = blockPos;
	if (param_2 != 0) {
		BVar1 = AITask_DoUnkCallbacks(AITask_Callback_FUN_00402bd0,(LiveObject *)&local_8);
		return BVar1;
	}
	BVar1 = AITask_DoUnkCallbacks(AITask_Callback_FUN_00402ba0,(LiveObject *)&local_8);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00402ae0(AITaskData *aiTask,Point2I **param_2)
{
	AITaskType AVar1;
	bool bVar2;
	
	bVar2 = false;
	AVar1 = aiTask->taskType;
	if (AVar1 == AITASK_DIG) {
		if (param_2[1] != NULL) {
			if ((*(byte *)&aiTask->flags_5c & 8) != 0) goto LAB_00402b16;
			if (param_2[1] != NULL) goto LAB_00402b1b;
		}
		if ((*(byte *)&aiTask->flags_5c & 8) != 0) goto LAB_00402b1b;
	}
	else {
		if ((AVar1 != AITASK_DYNAMITE) && (AVar1 != AITASK_REINFORCE)) goto LAB_00402b1b;
	}
LAB_00402b16:
	bVar2 = true;
LAB_00402b1b:
	if (((bVar2) && ((*param_2)->x == (aiTask->position).x)) &&
		 ((*param_2)->y == (aiTask->position).y)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
		game::Level_Block_SetFlags1_8000000(*param_2,0);
	}
	return 0;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00402b50(AITaskData *aiTask,Point2I **param_2)
{
	SurfaceMap *surfMap;
	int bx;
	int by;
	
	if (((aiTask->taskType == AITASK_REINFORCE) && ((*param_2)->x == (aiTask->position).x)) &&
		 ((*param_2)->y == (aiTask->position).y)) {
		by = (aiTask->position).y;
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
		bx = (aiTask->position).x;
		surfMap = game::GetSurfaceMap();
		game::Map3D_Block_ClearHighlight(surfMap,bx,by);
	}
	return 0;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00402ba0(AITaskData *aiTask,Point2I **param_2)
{
	if (((aiTask->taskType == AITASK_CLEAR) && ((*param_2)->x == (aiTask->position).x)) &&
		 ((*param_2)->y == (aiTask->position).y)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00402bd0(AITaskData *aiTask,Point2I **param_2)
{
	if (((aiTask->taskType == AITASK_CLEAR) && ((*param_2)->x == (aiTask->position).x)) &&
		 ((*param_2)->y == (aiTask->position).y)) {
		aiTask->float_18 = 500.0;
	}
	return 0;
}



void __cdecl lego::ai::AITask_Release_2(AITaskData *aiTask)
{
	AITaskData **ppAVar1;
	AITaskData *pAVar2;
	
	if (aiTask->taskType == AITASK_GETTOOL) {
		if (aiTask->aiTask_58 != NULL) {
			AITask_DoUnkCallbacks(AITask_IsSameTaskAsField58,(LiveObject *)&aiTask);
			return;
		}
	}
	else {
		if ((aiTask->aiTask_58 != NULL) &&
			 (pAVar2 = globals::g_AITaskUnkPtr, globals::g_AITaskUnkPtr != NULL)) {
			do {
				if ((pAVar2->taskType == AITASK_GETTOOL) && (aiTask->aiTask_58 == pAVar2)) {
					pAVar2->flags_5c = pAVar2->flags_5c | 0x20;
				}
				ppAVar1 = &pAVar2->next;
				pAVar2 = *ppAVar1;
			} while (*ppAVar1 != NULL);
		}
	}
	return;
}



BOOL __cdecl lego::ai::AITask_IsSameTaskAsField58(AITaskData *aiTask,AITaskData *otherTask)
{
	return (uint)(aiTask->aiTask_58 == otherTask);
}



BOOL __cdecl lego::ai::AITask_DoDynamite_AtBlockPos(Point2I *blockPos,BOOL param_2)
{
	BOOL BVar1;
	uint uVar2;
	AITaskData *aiTask;
	SurfaceMap *surfMap;
	int bx;
	int by;
	WallHighlightType highlightType;
	
	if ((globs::gameGlobs.level)->blocks
			[((globs::gameGlobs.level)->dimensions).width * blockPos->y + blockPos->x].terrain !=
			TERRAIN_IMMOVABLE) {
		BVar1 = game::Level_GetBlockFlags1_10Not8(blockPos->x,blockPos->y);
		if (BVar1 != 0) {
			uVar2 = game::Level_GetBlockFlags1_8000000(blockPos);
			if (uVar2 == 0) {
				aiTask = AITask_Create(AITASK_DYNAMITE);
				(aiTask->position).x = blockPos->x;
				uVar2 = aiTask->flags_5c;
				(aiTask->position).y = blockPos->y;
				aiTask->objType = OBJECT_DYNAMITE;
				aiTask->objIndex = -1;
				aiTask->objLevel = 0;
				aiTask->flags_5c = uVar2 | 0x400;
				if (param_2 == 0) {
					AITask_UnkInitRouting_FUN_00402530(aiTask,1);
				}
				AITask_InitTask_1(aiTask,AIPRIORITY_DESTRUCTION);
				AITask_PlaceRequestObject(blockPos,OBJECT_DYNAMITE,0,0);
				game::Level_Block_SetFlags1_8000000(blockPos,1);
				by = blockPos->y;
				bx = blockPos->x;
				highlightType = WALLHIGHLIGHT_DYNAMITE;
				surfMap = game::GetSurfaceMap();
				game::Map3D_Block_SetHighlightType(surfMap,bx,by,highlightType);
				return TRUE;
			}
		}
	}
	return 0;
}



void __cdecl lego::ai::AITask_DoBirdScarer_AtPosition(Point2I *position)
{
	uint uVar1;
	BOOL BVar2;
	AITaskData *aiTask;
	
	BVar2 = game::Level_BlockIsFlags1_8(position->x,position->y);
	if (BVar2 != 0) {
		aiTask = AITask_Create(AITASK_BIRDSCARER);
		uVar1 = aiTask->flags_5c;
		(aiTask->position).x = position->x;
		(aiTask->position).y = position->y;
		aiTask->objType = OBJECT_OOHSCARY;
		aiTask->objIndex = -1;
		aiTask->objLevel = 0;
		aiTask->flags_5c = uVar1 | 0x400;
		AITask_UnkInitRouting_FUN_00402530(aiTask,1);
		AITask_InitTask_1(aiTask,AIPRIORITY_DESTRUCTION);
		AITask_PlaceRequestObject(position,OBJECT_OOHSCARY,0,0);
	}
	return;
}



void __cdecl lego::ai::AITask_DoFindLoad(LiveObject *targetObj)
{
	ObjectStatsFlags3 OVar1;
	AITaskData *aiTask;
	
	OVar1 = game::LiveObject_GetStatsFlags3(targetObj);
	if ((((OVar1 & STATS3_CARRYVEHICLES) != STATS3_NONE) &&
			((targetObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE)) &&
		 ((targetObj->flags4 & LIVEOBJ4_UNK_10000) == LIVEOBJ4_NONE)) {
		aiTask = AITask_Create(AITASK_FINDLOAD);
		aiTask->object_10 = targetObj;
		targetObj->flags4 = targetObj->flags4 | LIVEOBJ4_UNK_10000;
		AITask_InitTask_1(aiTask,AIPRIORITY_FINDLOAD);
		aiTask->flags_5c = aiTask->flags_5c & 0xffffffbf | 0x100010;
	}
	return;
}



void __cdecl lego::ai::AITask_DoRepair_Target(LiveObject *targetObj,BOOL condition)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_REPAIR);
	aiTask->object_10 = targetObj;
	aiTask->mode_3c = 0x10;
	if (condition != 0) {
		aiTask->flags_5c = aiTask->flags_5c | 0x200000;
	}
	AITask_InitTask_1(aiTask,(-(uint)(condition != 0) & 0xc) + AIPRIORITY_REPAIR);
	return;
}



void __cdecl lego::ai::AITask_DoGotoEat_Target(LiveObject *liveObj,LiveObject *targetObj)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	pAVar1 = AITask_Create(AITASK_GOTOEAT);
	pAVar1->object_10 = targetObj;
	pAVar2 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
	if (pAVar2 != NULL) {
		pAVar2->next = pAVar1;
		return;
	}
	liveObj->aitask_2f0 = pAVar1;
	return;
}



void __cdecl lego::ai::AITask_DoElecFence(Point2I *position)
{
	uint uVar1;
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_ELECFENCE);
	uVar1 = aiTask->flags_5c;
	(aiTask->position).x = position->x;
	(aiTask->position).y = position->y;
	aiTask->objType = OBJECT_ELECTRICFENCE;
	aiTask->objIndex = -1;
	aiTask->objLevel = 0;
	aiTask->flags_5c = uVar1 | 0x400;
	AITask_UnkInitRouting_FUN_00402530(aiTask,1);
	AITask_InitTask_1(aiTask,AIPRIORITY_CONSTRUCTION);
	AITask_PlaceRequestObject(position,OBJECT_ELECTRICFENCE,0,0);
	game::Level_SetBlockFlag8(position->x,position->y,1);
	return;
}



void __cdecl lego::ai::AITask_DoReinforce_AtBlockPos(Point2I *blockPos)
{
	BOOL BVar1;
	AITaskData *aiTask;
	SurfaceMap *surfMap;
	int bx;
	int by;
	WallHighlightType highlightType;
	
	BVar1 = game::Level_GetBlockFlags1_10Not8(blockPos->x,blockPos->y);
	if (BVar1 != 0) {
		BVar1 = game::Level_Block_IsReinforced(blockPos->x,blockPos->y);
		if (BVar1 == 0) {
			aiTask = AITask_Create(AITASK_REINFORCE);
			(aiTask->position).x = blockPos->x;
			(aiTask->position).y = blockPos->y;
			AITask_UnkInitRouting_FUN_00402530(aiTask,TRUE);
			AITask_InitTask_1(aiTask,AIPRIORITY_REINFORCE);
			by = blockPos->y;
			bx = blockPos->x;
			highlightType = WALLHIGHLIGHT_REINFORCE;
			surfMap = game::GetSurfaceMap();
			game::Map3D_Block_SetHighlightType(surfMap,bx,by,highlightType);
		}
	}
	return;
}



void __cdecl lego::ai::AITask_DoClear_AtPosition(Point2I *position,MessageType completeAction)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_CLEAR);
	(aiTask->position).x = position->x;
	(aiTask->position).y = position->y;
	aiTask->completeAction = completeAction;
	AITask_InitTask_1(aiTask,AIPRIORITY_CLEARING);
	return;
}



void __cdecl lego::ai::AITask_DoGetTool_FromTask(AITaskData *in_aiTask)
{
	AITaskData *pAVar1;
	BOOL BVar2;
	AITaskData *aiTask;
	undefined4 *puVar3;
	uint uVar4;
	int iVar5;
	undefined4 *puVar6;
	
	pAVar1 = in_aiTask;
	BVar2 = AI_GetToolFromTaskType(in_aiTask->taskType,(ToolType *)&in_aiTask);
	if (BVar2 != 0) {
		pAVar1->flags_5c = pAVar1->flags_5c | 0x1000;
		aiTask = AITask_Create(AITASK_GETTOOL);
		if ((pAVar1->flags_5c & 0x100) != 0) {
			puVar3 = (undefined4 *)std::malloc(pAVar1->field_44 << 2);
			aiTask->ptr_40 = puVar3;
			puVar6 = (undefined4 *)pAVar1->ptr_40;
			for (uVar4 = pAVar1->field_44 & 0x3fffffff; uVar4 != 0; uVar4 -= 1) {
				*puVar3 = *puVar6;
				puVar6 = puVar6 + 1;
				puVar3 = puVar3 + 1;
			}
			for (iVar5 = 0; iVar5 != 0; iVar5 += -1) {
				*(undefined *)puVar3 = *(undefined *)puVar6;
				puVar6 = (undefined4 *)((int)puVar6 + 1);
				puVar3 = (undefined4 *)((int)puVar3 + 1);
			}
			aiTask->field_44 = pAVar1->field_44;
			aiTask->flags_5c = aiTask->flags_5c | 0x100;
		}
		aiTask->flags_5c = aiTask->flags_5c | 0x10;
		aiTask->toolType = (ToolType)in_aiTask;
		aiTask->aiTask_58 = pAVar1;
		pAVar1->aiTask_58 = aiTask;
		AITask_InitTask_1(aiTask,pAVar1->priorityType);
	}
	return;
}



BOOL __cdecl lego::ai::AITask_DoGetTool(ToolType toolType)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_GETTOOL);
	aiTask->toolType = toolType;
	aiTask->aiTask_58 = NULL;
	AITask_UnkInitRouting_FUN_00402530(aiTask,1);
	aiTask->flags_5c = aiTask->flags_5c & 0xffffffbf | 0x10;
	AITask_InitTask_1(aiTask,AIPRIORITY_DEFAULTCOLLECT);
	return 1;
}



BOOL __cdecl lego::ai::AITask_Game_SelectedUnits_UnkEquippedTool_FUN_00403110(ToolType toolType)
{
	BOOL BVar1;
	uint uVar2;
	LiveObject **ppLVar3;
	uint uVar4;
	
	BVar1 = game::Message_IsAnyUnitsSelected();
	if (BVar1 == 0) {
		uVar2 = 0;
		if (INT_004b4424 != 0) {
			ppLVar3 = (LiveObject **)&DAT_004b435c;
			while ((*ppLVar3 == NULL ||
						 (BVar1 = game::LiveObject_HasToolEquipped(*ppLVar3,toolType), BVar1 == 0))) {
				uVar2 += 1;
				ppLVar3 = ppLVar3 + 1;
				if ((uint)INT_004b4424 <= uVar2) {
					return 0;
				}
			}
			return 1;
		}
	}
	else {
		uVar2 = game::Message_GetNumSelectedUnits();
		ppLVar3 = game::Message_GetSelectedUnits();
		uVar4 = 0;
		if (uVar2 != 0) {
			do {
				BVar1 = game::LiveObject_HasToolEquipped(*ppLVar3,toolType);
				if (BVar1 != 0) {
					return 1;
				}
				uVar4 += 1;
				ppLVar3 = ppLVar3 + 1;
			} while (uVar4 < uVar2);
			return 0;
		}
	}
	return 0;
}



void __cdecl
lego::ai::AITask_Game_PTL_UserGoto
					(LiveObject **liveObjsTable,int count,Point2I *position,BOOL param_4)
{
	LiveObject *liveObj;
	AITaskData *pAVar1;
	ObjectStatsFlags1 OVar2;
	AITaskData *pAVar3;
	
	if ((count != 0) && (count != 0)) {
		do {
			pAVar1 = AITask_Create(AITASK_GOTO);
			(pAVar1->position).x = position->x;
			(pAVar1->position).y = position->y;
			pAVar1->flags_5c = 4;
			liveObj = *liveObjsTable;
			OVar2 = game::LiveObject_GetStatsFlags1(liveObj);
			if ((((OVar2 & STATS1_CANBEDRIVEN) == STATS1_NONE) || (liveObj->drivenObject != NULL)) &&
				 ((liveObj->carryingThisObject == NULL &&
					((*(byte *)&liveObj->flags3 & LIVEOBJ3_UNK_80) != 0)))) {
				if (param_4 != 0) {
					AITask_LiveObject_FUN_00404030(liveObj);
				}
				pAVar3 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
				if (pAVar3 == NULL) {
					liveObj->aitask_2f0 = pAVar1;
				}
				else {
					pAVar3->next = pAVar1;
				}
			}
			liveObjsTable = liveObjsTable + 1;
			count += -1;
		} while (count != 0);
	}
	return;
}



void __cdecl lego::ai::AITask_DoUpgrade(LiveObject *liveObj,int newObjLevel)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	LiveObject *pLVar3;
	Point2F local_8;
	
	pLVar3 = NULL;
	if ((liveObj->objType == OBJECT_MINIFIGURE) &&
		 ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE)) {
		game::LiveObject_GetPosition(liveObj,(float *)&local_8,&local_8.y);
		pLVar3 = game::Level_GetBuildingAtPosition(&local_8);
	}
	else {
		if (liveObj->objType == OBJECT_VEHICLE) {
			pLVar3 = (LiveObject *)FUN_00438eb0(liveObj);
		}
	}
	if (pLVar3 != NULL) {
		pAVar1 = AITask_Create(AITASK_UPGRADE);
		pAVar1->object_10 = pLVar3;
		pAVar1->objLevel = newObjLevel;
		AITask_LiveObject_FUN_00404030(liveObj);
		pAVar2 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
		if (pAVar2 != NULL) {
			pAVar2->next = pAVar1;
			return;
		}
		liveObj->aitask_2f0 = pAVar1;
	}
	return;
}



void __cdecl lego::ai::AITask_DoDock(LiveObject *liveObj)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	pAVar1 = AITask_Create(AITASK_DOCK);
	pAVar2 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
	if (pAVar2 != NULL) {
		pAVar2->next = pAVar1;
		return;
	}
	liveObj->aitask_2f0 = pAVar1;
	return;
}



void __cdecl lego::ai::AITask_DoGoto_Congregate(Point2I *position)
{
	uint uVar1;
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_GOTO);
	(aiTask->position).x = position->x;
	uVar1 = aiTask->flags_5c;
	(aiTask->position).y = position->y;
	aiTask->flags_5c = uVar1 & 0xffffffef | 0x40;
	AITask_SetPriorityType(aiTask,AIPRIORITY_CONGREGATE);
	AITask_Init_2_NoPriority(aiTask);
	return;
}



void __cdecl lego::ai::AITask_FUN_00403360(Point2I *position)
{
	AITaskData *pAVar1;
	AITaskData *aiTask;
	AITaskData *pAVar2;
	
	pAVar1 = globals::g_AITaskDataNext;
	pAVar2 = NULL;
	if (globals::g_AITaskDataNext != NULL) {
		do {
			aiTask = pAVar1;
			pAVar1 = aiTask->next;
			if (((aiTask->taskType == AITASK_GOTO) && ((aiTask->position).x == position->x)) &&
				 ((aiTask->position).y == position->y)) {
				if (pAVar2 == NULL) {
					globals::g_AITaskDataNext = pAVar1;
					AITask_Remove(aiTask,0);
					return;
				}
				pAVar2->next = pAVar1;
				AITask_Remove(aiTask,0);
				return;
			}
			pAVar2 = aiTask;
		} while (pAVar1 != NULL);
	}
	return;
}



void __cdecl lego::ai::AITask_DoAttackObject(LiveObject *liveObj)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_ATTACKOBJECT);
	aiTask->object_10 = liveObj;
	AITask_SetPriorityType(aiTask,AIPRIORITY_ATTACKOBJECT);
	AITask_Init_2_NoPriority(aiTask);
	aiTask->flags_5c = aiTask->flags_5c | 0x40;
	return;
}



void __cdecl lego::ai::AITask_DoAttackPath(Point2I *position)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_ATTACKPATH);
	(aiTask->position).x = position->x;
	(aiTask->position).y = position->y;
	AITask_SetPriorityType(aiTask,AIPRIORITY_ATTACKPATH);
	AITask_Init_2_NoPriority(aiTask);
	return;
}



void __cdecl lego::ai::AITask_DoRepair(LiveObject *liveObj)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_REPAIR);
	aiTask->object_10 = liveObj;
	AITask_SetPriorityType(aiTask,AIPRIORITY_PUNCH);
	AITask_Init_2_NoPriority(aiTask);
	aiTask->flags_5c = aiTask->flags_5c | 0x40;
	return;
}



void __cdecl lego::ai::AITask_LiveObject_FUN_00403490(LiveObject *liveObj)
{
	AITaskData *pAVar1;
	AITaskData *aiTask;
	AITaskData *pAVar2;
	AITaskData *pAVar3;
	
	pAVar2 = NULL;
	aiTask = globals::g_AITaskDataNext;
	if (globals::g_AITaskDataNext != NULL) {
		do {
			pAVar1 = aiTask->next;
			pAVar3 = aiTask;
			if ((aiTask->taskType == AITASK_REPAIR) && (liveObj == aiTask->object_10)) {
				pAVar3 = pAVar2;
				if (pAVar2 == NULL) {
					globals::g_AITaskDataNext = pAVar1;
					AITask_Remove(aiTask,0);
				}
				else {
					pAVar2->next = pAVar1;
					AITask_Remove(aiTask,0);
				}
			}
			aiTask = pAVar1;
			pAVar2 = pAVar3;
		} while (pAVar1 != NULL);
	}
	return;
}



void __cdecl
lego::ai::AITask_Game_PTL_GotoOrRMGoto(LiveObject *liveObj,Point2I *position,undefined4 param_3)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	pAVar1 = AITask_Create(AITASK_GOTO);
	(pAVar1->position).x = position->x;
	(pAVar1->position).y = position->y;
	pAVar1->field_4 = param_3;
	pAVar2 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
	if (pAVar2 != NULL) {
		pAVar2->next = pAVar1;
		return;
	}
	liveObj->aitask_2f0 = pAVar1;
	front::Bubble_LiveObject_MiniFigure_FUN_00407380(liveObj);
	return;
}



void __cdecl lego::ai::AITask_Game_PTL_CrystalToRefinery(LiveObject *liveObj,LiveObject *targetObj)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		pAVar1 = AITask_Create(AITASK_DEPOSITE);
		pAVar1->object_10 = targetObj;
		pAVar2 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
		if (pAVar2 != NULL) {
			pAVar2->next = pAVar1;
			return;
		}
		liveObj->aitask_2f0 = pAVar1;
	}
	return;
}



void __cdecl
lego::ai::AITask_DoFollow_Group(LiveObject **liveObjsTable,int count,LiveObject *targetObj)
{
	LiveObject *liveObj;
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	if ((count != 0) && (count != 0)) {
		do {
			pAVar1 = AITask_Create(AITASK_FOLLOW);
			pAVar1->object_10 = targetObj;
			pAVar1->unkExpiryTime = 0.0;
			liveObj = *liveObjsTable;
			AITask_LiveObject_FUN_00404030(liveObj);
			pAVar2 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
			if (pAVar2 == NULL) {
				liveObj->aitask_2f0 = pAVar1;
			}
			else {
				pAVar2->next = pAVar1;
			}
			liveObjsTable = liveObjsTable + 1;
			count += -1;
		} while (count != 0);
	}
	return;
}



void __cdecl lego::ai::AITask_Game_PTL_FollowAttack(LiveObject *liveObj,LiveObject *targetObj)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	pAVar1 = AITask_Create(AITASK_FOLLOWATTACK);
	pAVar1->object_10 = targetObj;
	pAVar1->unkExpiryTime = 0.0;
	pAVar2 = AITask_LiveObject_AITask2F0_GetLast(liveObj);
	if (pAVar2 != NULL) {
		pAVar2->next = pAVar1;
		return;
	}
	liveObj->aitask_2f0 = pAVar1;
	return;
}



void __cdecl lego::ai::AITask_FUN_00403630(int param_1,int param_2,int param_3,int param_4)
{
	AITaskData **ppAVar1;
	AITaskData *pAVar2;
	
	pAVar2 = globals::g_AITaskUnkPtr;
	if (globals::g_AITaskUnkPtr != NULL) {
		do {
			if (((pAVar2->taskType == AITASK_REQUEST) && (pAVar2->field_2c == param_1)) &&
				 ((param_2 == 0 || ((param_3 == pAVar2->objType && (param_4 == pAVar2->objIndex)))))) {
				pAVar2->flags_5c = pAVar2->flags_5c | 0x20;
			}
			ppAVar1 = &pAVar2->next;
			pAVar2 = *ppAVar1;
		} while (*ppAVar1 != NULL);
	}
	return;
}



void __cdecl
lego::ai::AITask_DoRequest_ObjectType
					(ObjectType objType,int objLevel,int objIndex,Point2I *blockPos,undefined4 param_5,
					Point2F *pointFloat,BOOL param_7)
{
	int iVar1;
	AITaskData *aiTask;
	float10 fVar2;
	
	aiTask = AITask_Create(AITASK_REQUEST);
	aiTask->objType = objType;
	aiTask->objIndex = objLevel;
	aiTask->objLevel = objIndex;
	(aiTask->position).x = blockPos->x;
	iVar1 = blockPos->y;
	aiTask->field_2c = param_5;
	(aiTask->position).y = iVar1;
	if (pointFloat == NULL) {
		fVar2 = math::Maths_RandRange(0.4,0.6);
		(aiTask->pointf_30).x = (float)fVar2;
		fVar2 = math::Maths_RandRange(0.4,0.6);
		(aiTask->pointf_30).y = (float)fVar2;
	}
	else {
		(aiTask->pointf_30).x = pointFloat->x;
		(aiTask->pointf_30).y = pointFloat->y;
	}
	if (param_7 != 0) {
		aiTask->flags_5c = aiTask->flags_5c | 0x800;
	}
	aiTask->object_10 = NULL;
	aiTask->unkExpiryTime = 0.0;
	AITask_InitTask_1(aiTask,AIPRIORITY_REQUEST);
	aiTask->flags_5c = aiTask->flags_5c | 0x400;
	AITask_PlaceRequestObject(blockPos,objType,objLevel,objIndex);
	return;
}



void __cdecl
lego::ai::AITask_PlaceRequestObject(Point2I *blockPos,ObjectType objType,int objIndex,int objLevel)
{
	LiveObject *pLVar1;
	int iVar2;
	LiveObject *liveObj;
	
	pLVar1 = FUN_00438d20(blockPos,objType,objIndex,objLevel);
	if (pLVar1 == NULL) {
		if (((objIndex != 0) && (objType == OBJECT_ORE)) &&
			 (pLVar1 = FUN_00438d20(blockPos,OBJECT_ORE,0,objLevel), pLVar1 != NULL)) {
			liveObj = game::LiveObject_FUN_00438da0(NULL,blockPos,OBJECT_ORE,0);
			iVar2 = game::LiveObject_GetMaxCarry(liveObj);
			if (iVar2 == 0) {
				return;
			}
			do {
				FUN_0043a910(pLVar1,OBJECT_ORE,0,objLevel);
				iVar2 += -1;
			} while (iVar2 != 0);
			return;
		}
	}
	else {
		iVar2 = FUN_0043a910(pLVar1,objType,objIndex,objLevel);
		if (iVar2 != 0) {
			return;
		}
	}
	iVar2 = objIndex * 0x10 + objType * 0xf0 + objLevel;
	(&DAT_004b44f4)[iVar2] = (&DAT_004b44f4)[iVar2] + 1;
	return;
}



AITaskData * __cdecl
lego::ai::AITask_DoDeposit_ObjectType
					(LiveObject *liveObj,ObjectType objType,int objIndex,int objLevel)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_DEPOSITE);
	aiTask->object_10 = liveObj;
	aiTask->unkExpiryTime = 0.0;
	aiTask->objType = objType;
	aiTask->objIndex = objIndex;
	aiTask->objLevel = objLevel;
	AITask_InitTask_1(aiTask,AIPRIORITY_REFINING);
	aiTask->flags_5c = aiTask->flags_5c & 0xffffffef | 0x4c0;
	return aiTask;
}



void __cdecl lego::ai::AITask_LiveObject_FUN_00403840(LiveObject *liveObj)
{
	BOOL BVar1;
	int iVar2;
	uint objIndex;
	ObjectType objType;
	uint objLevel;
	uint *puVar3;
	int local_8;
	uint local_4;
	
	objType = OBJECT_NONE;
	puVar3 = &DAT_004b44f4;
	do {
		objIndex = 0;
		do {
			objLevel = 0;
			do {
				local_8 = 0;
				local_4 = 0;
				if (*puVar3 != 0) {
					do {
						BVar1 = AITask_FUN_00404e40(objType,objIndex,objLevel);
						if ((BVar1 == 0) ||
							 (iVar2 = FUN_0043a910(liveObj,objType,objIndex,objLevel), iVar2 != 0)) {
							local_8 += 1;
						}
						local_4 += 1;
					} while (local_4 < *puVar3);
				}
				objLevel += 1;
				*puVar3 = *puVar3 - local_8;
				puVar3 = puVar3 + 1;
			} while (objLevel < 0x10);
			objIndex += 1;
		} while (objIndex < 0xf);
		objType += OBJECT_VEHICLE;
	} while (puVar3 < globals::g_Priorities_bool2_TABLE);
	return;
}



void __cdecl lego::ai::AITask_LiveObject_FUN_004038d0(LiveObject *liveObj)
{
	AITaskData *aiTask;
	
	aiTask = AITask_DoDeposit_ObjectType(liveObj,OBJECT_NONE,-1,0);
	AITask_SetPriorityType(aiTask,AIPRIORITY_STORAGE);
	AITask_LiveObject_FUN_00403840(liveObj);
	return;
}



void __cdecl lego::ai::AITask_DoGotoEat(LiveObject *liveObj)
{
	AITaskData *aiTask;
	
	aiTask = AITask_Create(AITASK_GOTOEAT);
	aiTask->object_10 = liveObj;
	aiTask->unkExpiryTime = 0.0;
	AITask_InitTask_1(aiTask,AIPRIORITY_CRYSTAL);
	aiTask->flags_5c = aiTask->flags_5c & 0xffffffef | 0xc0;
	return;
}



BOOL __cdecl lego::ai::AITask_LiveObject_FUN_00403940(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = AITask_DoUnkCallbacks(AITask_Callback_FUN_00403960,liveObj);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00403960(AITaskData *aiTask,LiveObject *liveObj)
{
	if ((aiTask->taskType == AITASK_DEPOSITE) && (liveObj == aiTask->object_10)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



void __cdecl lego::ai::AITask_LiveObject_FUN_00403980(LiveObject *liveObj)
{
	uint uVar1;
	AITaskData *pAVar2;
	AITaskData *aiTask;
	
	if (((byte)pool::globals::ReservedPool_AITask___g_INITFLAGS & 2) == 0) {
		aiTask = liveObj->aitask_2f0;
		while (aiTask != NULL) {
			uVar1 = aiTask->flags_5c;
			pAVar2 = aiTask->next;
			if (((uVar1 & 0x10) == 0) || ((uVar1 & 0x20) != 0)) {
				if (((uVar1 & 0x2000) == 0) || ((uVar1 & 0x20) != 0)) {
					AITask_Remove(aiTask,0);
					aiTask = pAVar2;
				}
				else {
					AITask_Init_2_NoPriority(aiTask);
					aiTask = pAVar2;
				}
			}
			else {
				AITask_InitTask_1(aiTask,aiTask->priorityType);
				aiTask = pAVar2;
			}
		}
		liveObj->aitask_2f0 = NULL;
		AITask_DoUnkCallbacks(AITask_Callback_FUN_00403a00,liveObj);
	}
	return;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00403a00(AITaskData *aiTask,LiveObject *liveObj)
{
	if (liveObj == aiTask->object_10) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



void __cdecl lego::ai::AITask_LiveObject_FUN_00403a20(LiveObject *liveObj,BOOL param_2)
{
	AITaskData *pAVar1;
	
	pAVar1 = liveObj->aitask_2f0;
	if (pAVar1 != NULL) {
		if (param_2 == 0) {
			pAVar1->flags_5c = pAVar1->flags_5c & 0xfffffffe;
		}
		else {
			if (pAVar1->taskType == AITASK_GOTO) {
				AITask_LiveObject_FUN_00404110(liveObj);
				if (liveObj->objType == OBJECT_ROCKMONSTER) {
					game::Message_AddMessageAction(MESSAGE_ROCKMONSTERGOTO_COMPLETE,liveObj,0,NULL);
					return;
				}
			}
		}
	}
	return;
}



void __cdecl lego::ai::AITask_LiveObject_FUN_00403a70(LiveObject *liveObj)
{
	uint *puVar1;
	
	if (liveObj->aitask_2f0 != NULL) {
		puVar1 = &liveObj->aitask_2f0->flags_5c;
		*puVar1 = *puVar1 & 0xfffffffe;
	}
	return;
}



void __cdecl lego::ai::AITask_VariousGatherTasks_FUN_00403a90(LiveObject *liveObj)
{
	LiveObject *carriedObj;
	uint uVar1;
	LiveObject **ppLVar2;
	
	if ((((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
			((liveObj->flags1 & LIVEOBJ1_UNK_2000) == LIVEOBJ1_NONE)) &&
		 (uVar1 = 0, liveObj->numCarriedObjects != 0)) {
		ppLVar2 = liveObj->carriedObjects;
		do {
			carriedObj = *ppLVar2;
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_DEPOSITE,carriedObj);
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_DUMP,carriedObj);
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_DYNAMITE,carriedObj);
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_ELECFENCE,carriedObj);
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_REQUEST,carriedObj);
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_GATHER,NULL);
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_BIRDSCARER,carriedObj);
			uVar1 += 1;
			ppLVar2 = ppLVar2 + 1;
		} while (uVar1 < liveObj->numCarriedObjects);
	}
	return;
}



void __cdecl
lego::ai::AITask_LiveObject_FUN_00403b30
					(LiveObject *holderObj,AITaskType taskType,LiveObject *carriedObj)
{
	AITaskData **ppAVar1;
	AITaskType AVar2;
	SurfaceMap *surfMap;
	AITaskData *pAVar3;
	AITaskData *aiTask;
	int bx;
	int by;
	
	if (((byte)pool::globals::ReservedPool_AITask___g_INITFLAGS & 2) != 0) {
		return;
	}
	pAVar3 = NULL;
	aiTask = holderObj->aitask_2f0;
	if (aiTask == NULL) {
		return;
	}
	while (taskType != aiTask->taskType) {
		ppAVar1 = &aiTask->next;
		pAVar3 = aiTask;
		aiTask = *ppAVar1;
		if (*ppAVar1 == NULL) {
			return;
		}
	}
	AVar2 = aiTask->taskType;
	if (AVar2 == AITASK_DEPOSITE) {
LAB_00403b90:
		if (AVar2 == AITASK_REQUEST) goto LAB_00403b95;
	}
	else {
		if (AVar2 != AITASK_REQUEST) {
			if ((((AVar2 != AITASK_DUMP) && (AVar2 != AITASK_COLLECT)) && (AVar2 != AITASK_DYNAMITE)) &&
				 ((AVar2 != AITASK_ELECFENCE && (AVar2 != AITASK_BIRDSCARER)))) goto LAB_00403c01;
			goto LAB_00403b90;
		}
LAB_00403b95:
		AITask_DoRequest_ObjectType
							(aiTask->objType,aiTask->objIndex,aiTask->objLevel,&aiTask->position,aiTask->field_2c,
							 &aiTask->pointf_30,aiTask->flags_5c & 0x800);
	}
	if (aiTask->taskType == AITASK_DYNAMITE) {
		game::Level_Block_SetFlags1_8000000(&aiTask->position,0);
		by = (aiTask->position).y;
		bx = (aiTask->position).x;
		surfMap = game::GetSurfaceMap();
		game::Map3D_Block_ClearHighlight(surfMap,bx,by);
	}
	AITask_DoCollect(carriedObj,150.0);
	AITask_DoCollect_Target(carriedObj);
LAB_00403c01:
	if (pAVar3 == NULL) {
		holderObj->aitask_2f0 = aiTask->next;
		AITask_Remove(aiTask,0);
		return;
	}
	pAVar3->next = aiTask->next;
	AITask_Remove(aiTask,0);
	return;
}



void __cdecl
lego::ai::AITask_LiveObject_SetAITaskUnk
					(LiveObject *liveObj1,AITaskType taskType,LiveObject *liveObj2,BOOL param_4)
{
	Point2I *blockPos;
	bool bVar1;
	LiveObject *liveObj;
	AITaskData *pAVar2;
	LiveObject *argument2;
	BOOL BVar3;
	LevelBlockFlags1 LVar4;
	AITaskData *aiTask;
	AITaskData *pAVar5;
	AITaskType AVar6;
	
	liveObj = liveObj1;
	if (((byte)pool::globals::ReservedPool_AITask___g_INITFLAGS & 2) == 0) {
		if ((taskType == AITASK_COLLECT) &&
			 (argument2 = game::LiveObject_FUN_00438da0
															(liveObj1,NULL,liveObj2->objType,liveObj2->objLevel),
			 argument2 != NULL)) {
			game::Message_AddMessageAction(MESSAGE_COLLECTCRYSTAL_COMPLETE,liveObj1,argument2,NULL);
		}
		pAVar2 = liveObj1->aitask_2f0;
		pAVar5 = NULL;
		if (liveObj1->aitask_2f0 != NULL) {
LAB_00403c9a:
			aiTask = pAVar2;
			if (taskType != aiTask->taskType) goto code_r0x00403ca4;
			liveObj1 = NULL;
			bVar1 = false;
			if (param_4 != 0) {
				if (pAVar5 == NULL) {
					liveObj->aitask_2f0 = aiTask->next;
				}
				else {
					pAVar5->next = aiTask->next;
				}
			}
			if (aiTask->taskType == AITASK_REQUEST) {
				AVar6 = aiTask->field_2c;
				bVar1 = true;
				liveObj1 = liveObj2;
				BVar3 = game::Construction_FUN_00408ca0(AVar6,liveObj2->objType,liveObj2->objIndex);
				if (BVar3 == 0) {
					AITask_FUN_00403630(AVar6,1,liveObj2->objType,liveObj2->objIndex);
					bVar1 = false;
				}
			}
			else {
				AVar6 = taskType;
				if (aiTask->taskType == AITASK_CLEAR) {
					if (liveObj->objType == OBJECT_VEHICLE) {
						for (LVar4 = (globs::gameGlobs.level)->blocks
												 [(aiTask->position).y * ((globs::gameGlobs.level)->dimensions).width +
													(aiTask->position).x].flags1 & BLOCK1_RUBBLE_FULL; LVar4 != BLOCK1_NONE;
								LVar4 += ~BLOCK1_NONE) {
							game::Level_BlockProc_FUN_00432bc0(&aiTask->position);
							game::Message_AddMessageAction(aiTask->completeAction,0,0,&aiTask->position);
						}
					}
					blockPos = &aiTask->position;
					game::Level_BlockProc_FUN_00432bc0(blockPos);
					game::Message_AddMessageAction(aiTask->completeAction,0,0,blockPos);
					game::Level_BlockSetter_FUN_00432640(blockPos,FALSE);
					game::Level_BlockSetFlags1_10000000(blockPos,FALSE);
				}
				else {
					if (taskType == AITASK_TRAIN) {
						game::LiveObject_TrainMiniFigure_instantunk(liveObj,aiTask->mode_3c);
						front::Text_DisplayMessage(TEXT_MANTRAINED,1,0);
					}
				}
			}
			if (param_4 != 0) {
				AITask_Remove(aiTask,FALSE);
			}
			if (bVar1) {
				game::Construction_FUN_00408c10(AVar6,liveObj1);
			}
		}
LAB_00403dfc:
		if (taskType == AITASK_COLLECT) {
			AITask_LiveObject_FUN_00403e20(liveObj2);
		}
	}
	return;
code_r0x00403ca4:
	pAVar2 = aiTask->next;
	pAVar5 = aiTask;
	if (aiTask->next == NULL) goto LAB_00403dfc;
	goto LAB_00403c9a;
}



BOOL __cdecl lego::ai::AITask_LiveObject_FUN_00403e20(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = AITask_DoUnkCallbacks(AITask_Callback_FUN_00403e40,liveObj);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00403e40(AITaskData *aiTask,LiveObject *liveObj)
{
	if ((aiTask->taskType == AITASK_COLLECT) && (aiTask->object_10 == liveObj)) {
		aiTask->flags_5c = aiTask->flags_5c | 0x20;
	}
	return 0;
}



void __cdecl lego::ai::AITask_DoAnimationWait(LiveObject *liveObj)
{
	AITaskData *pAVar1;
	
	if ((liveObj->aitask_2f0 == NULL) || (liveObj->aitask_2f0->taskType != AITASK_ANIMATIONWAIT)) {
		pAVar1 = AITask_Create(AITASK_ANIMATIONWAIT);
		pAVar1->next = liveObj->aitask_2f0;
		liveObj->aitask_2f0 = pAVar1;
	}
	return;
}



void __cdecl lego::ai::AITask_LiveObject_Unk_UpdateAITask_AnimationWait(LiveObject *liveObj)
{
	if ((liveObj->aitask_2f0 != NULL) && (liveObj->aitask_2f0->taskType == AITASK_ANIMATIONWAIT)) {
		AITask_LiveObject_FUN_00404110(liveObj);
	}
	return;
}



int __cdecl lego::ai::AITask_QSortCompare(AITaskData **task_a,AITaskData **task_b)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	uint uVar3;
	uint uVar4;
	
	pAVar1 = *task_a;
	pAVar2 = *task_b;
	uVar3 = pAVar1->flags_5c & 0x100;
	if ((uVar3 != 0) && ((pAVar2->flags_5c & 0x100) == 0)) {
		return 0xffffffff;
	}
	uVar4 = pAVar2->flags_5c & 0x100;
	if (uVar4 == 0) {
		if (uVar3 == 0) goto LAB_00403f0c;
	}
	else {
		if (uVar3 == 0) {
			return 1;
		}
	}
	if (uVar4 != 0) {
		if (pAVar2->taskStartTime < pAVar1->taskStartTime) {
			return 0xffffffff;
		}
		if (pAVar1->taskStartTime < pAVar2->taskStartTime) {
			return 1;
		}
	}
LAB_00403f0c:
	if ((int)pAVar1->priorityValue < 0) {
		pAVar1->priorityValue = 0;
	}
	if ((int)pAVar2->priorityValue < 0) {
		pAVar2->priorityValue = 0;
	}
	if (99 < (int)pAVar1->priorityValue) {
		pAVar1->priorityValue = 99;
	}
	if (99 < (int)pAVar2->priorityValue) {
		pAVar2->priorityValue = 99;
	}
	if ((int)pAVar2->priorityValue < (int)pAVar1->priorityValue) {
		return 0xffffffff;
	}
	return (uint)((int)pAVar1->priorityValue < (int)pAVar2->priorityValue);
}



AITaskData * __cdecl lego::ai::AITask_InitTask_1(AITaskData *aiTask,AIPriorityType priorityType)
{
	aiTask->next = globals::g_AITaskUnkPtr;
	globals::g_AITaskUnkPtr = aiTask;
	aiTask->unkExpiryTime = 1500.0;
	aiTask->flags_5c = aiTask->flags_5c & 0xfffffffe | 0x10;
	aiTask->priorityValue = globals::g_AIPriorityValues_TABLE[priorityType];
	aiTask->priorityType = priorityType;
	return aiTask;
}



void __cdecl lego::ai::AITask_Init_2_NoPriority(AITaskData *aiTask)
{
	aiTask->next = globals::g_AITaskDataNext;
	globals::g_AITaskDataNext = aiTask;
	aiTask->unkExpiryTime = 1500.0;
	aiTask->flags_5c = aiTask->flags_5c & 0xffffffee;
	return;
}



void __cdecl lego::ai::AITask_Game_UnkLiveObjectHandleDynamite(LiveObject *liveObj)
{
	if (((byte)pool::globals::ReservedPool_AITask___g_INITFLAGS & 6) == 0) {
		AITask_LiveObject_FUN_00403b30(liveObj,AITASK_GOTO,NULL);
		if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
			 (liveObj->carriedObjects[0]->objType == OBJECT_DYNAMITE)) {
			AITask_LiveObject_FUN_00403b30(liveObj,AITASK_DYNAMITE,liveObj->carriedObjects[0]);
		}
		AITask_LiveObject_FUN_00404030(liveObj);
		AITask_LiveObject_ReleaseTaskReferences(liveObj);
	}
	return;
}



void __cdecl lego::ai::AITask_LiveObject_FUN_00404030(LiveObject *liveObj)
{
	uint uVar1;
	AITaskData *pAVar2;
	AITaskData *pAVar3;
	AITaskData *aiTask;
	
	pAVar3 = NULL;
	pAVar2 = liveObj->aitask_2f0;
	while (aiTask = pAVar2, aiTask != NULL) {
		uVar1 = aiTask->flags_5c;
		pAVar2 = aiTask->next;
		if ((uVar1 & 4) == 0) {
			if (((uVar1 & 0x10) == 0) || ((uVar1 & 0x20) != 0)) {
				if (((uVar1 & 0x2000) == 0) || ((uVar1 & 0x20) != 0)) {
					if (pAVar3 == NULL) {
						aiTask->next = NULL;
						pAVar3 = aiTask;
					}
					else {
						pAVar3->next = aiTask;
						aiTask->next = NULL;
					}
				}
				else {
					aiTask->next = globals::g_AITaskDataNext;
					globals::g_AITaskDataNext = aiTask;
				}
			}
			else {
				aiTask->next = globals::g_AITaskUnkPtr;
				globals::g_AITaskUnkPtr = aiTask;
			}
		}
		else {
			AITask_Remove(aiTask,0);
		}
	}
	liveObj->aitask_2f0 = pAVar3;
	return;
}



AITaskData * __cdecl lego::ai::AITask_LiveObject_AITask2F0_GetLast(LiveObject *liveObj)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	
	pAVar2 = liveObj->aitask_2f0;
	if (pAVar2 != NULL) {
		for (pAVar1 = pAVar2->next; pAVar1 != NULL; pAVar1 = pAVar1->next) {
			pAVar2 = pAVar1;
		}
	}
	return pAVar2;
}



BOOL __cdecl lego::ai::AITask_LiveObject_IsCurrentTaskType(LiveObject *liveObj,AITaskType taskType)
{
	AITaskData *pAVar1;
	
	pAVar1 = liveObj->aitask_2f0;
	if (pAVar1 == NULL) {
		return (BOOL)NULL;
	}
	do {
		if (taskType == pAVar1->taskType) {
			return (BOOL)(AITaskData *)0x1;
		}
		pAVar1 = pAVar1->next;
	} while (pAVar1 != NULL);
	return (BOOL)pAVar1;
}



AITaskData * __cdecl lego::ai::AITask_LiveObject_FUN_00404110(LiveObject *liveObj)
{
	AITaskData *aiTask;
	uint uVar1;
	
	aiTask = liveObj->aitask_2f0;
	if (aiTask != NULL) {
		liveObj->aitask_2f0 = aiTask->next;
		uVar1 = aiTask->flags_5c;
		if (((uVar1 & 0x10) != 0) && ((uVar1 & 0x20) == 0)) {
			aiTask->next = globals::g_AITaskUnkPtr;
			globals::g_AITaskUnkPtr = aiTask;
			return liveObj->aitask_2f0;
		}
		if (((uVar1 & 0x2000) != 0) && ((uVar1 & 0x20) == 0)) {
			aiTask->next = globals::g_AITaskDataNext;
			globals::g_AITaskDataNext = aiTask;
			return liveObj->aitask_2f0;
		}
		AITask_Remove(aiTask,FALSE);
	}
	return liveObj->aitask_2f0;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00404180(AITaskData *aiTask,float *param_2)
{
	if ((*(byte *)&aiTask->flags_5c & 0x80) == 0) {
		aiTask->unkExpiryTime = aiTask->unkExpiryTime - *param_2;
	}
	aiTask->float_18 = aiTask->float_18 - *param_2;
	return 0;
}



BOOL __cdecl lego::ai::AITask_LiveObject_Callback_DoAITask(LiveObject *liveObj,float *param_2)
{
	float fVar1;
	AITaskType AVar2;
	LiveObject *pLVar3;
	ObjectType OVar4;
	LiveObject *pLVar5;
	bool bVar6;
	bool bVar7;
	float *pfVar8;
	BOOL BVar9;
	TutorialFlags TVar10;
	ObjectStatsFlags1 OVar11;
	SurfaceMap *surfMap;
	AITaskData *pAVar12;
	float fVar13;
	uint uVar14;
	LiveObject *aiTask;
	float10 fVar15;
	uint x;
	Vector3F *out_vertices4;
	void *local_6c;
	void *local_68;
	undefined local_64 [4];
	Point2I local_60;
	float local_58;
	VehicleData *local_54;
	float local_50;
	VehicleData *local_4c;
	Point2I local_48;
	float local_40;
	float local_3c;
	Point2I local_38;
	Vector3F local_30 [2];
	float local_18;
	float local_14;
	
	pLVar3 = liveObj;
	pool::globals::ReservedPool_AITask___g_INITFLAGS |= 4;
	if (((((((liveObj->flags3 & LIVEOBJ3_UNK_400000) == LIVEOBJ3_NONE) ||
				 ((ushort)((ushort)(liveObj->health < 0.0) << 8 | (ushort)(liveObj->health == 0.0) << 0xe)
					!= 0)) ||
				(BVar9 = game::LiveObject_Check_FUN_004294f0(liveObj), pfVar8 = param_2, BVar9 != 0)) ||
			 ((liveObj->drivenObject != NULL && (liveObj->objType == OBJECT_MINIFIGURE)))) ||
			(liveObj->carryingThisObject != NULL)) ||
		 (((liveObj->flags2 & (LIVEOBJ2_UNK_4000|LIVEOBJ2_UNK_8000000)) != LIVEOBJ2_NONE ||
			((liveObj->flags1 & LIVEOBJ1_UNK_800000) != LIVEOBJ1_NONE)))) goto LAB_00404c90;
	pAVar12 = liveObj->aitask_2f0;
	local_6c = NULL;
	if (pAVar12 == NULL) {
		local_60.x = 0;
		local_60.y = 0;
		liveObj->float_338 = *param_2 + liveObj->float_338;
		game::LiveObject_GetBlockPos(liveObj,(int *)&local_38,&local_38.y);
		if (((liveObj->float_338 == *pfVar8) || ((*(byte *)&liveObj->flags4 & 0xc0) != 0)) ||
			 (BVar9 = game::LiveObject_FUN_004439d0(liveObj,&local_38,&local_60,0), BVar9 == 0)) {
			if ((ushort)((ushort)(liveObj->float_338 < 250.0) << 8 |
									(ushort)(liveObj->float_338 == 250.0) << 0xe) == 0) {
				if ((liveObj->objType == OBJECT_MINIFIGURE) &&
					 (BVar9 = game::LiveObject_Check_FUN_004294f0(liveObj), BVar9 == 0)) {
					game::LiveObject_FUN_00443930(liveObj);
				}
				liveObj->float_338 = 0.0;
			}
			else {
				liveObj = NULL;
				aiTask = (LiveObject *)globals::g_AITaskUnkPtr;
				pLVar5 = (LiveObject *)globals::g_AITaskUnkPtr;
				if (globals::g_AITaskUnkPtr == NULL) {
LAB_00404c21:
					if (aiTask != NULL) {
						AITask_FUN_00406290((AITaskData *)aiTask,(AITaskData *)liveObj,pLVar3);
						goto LAB_00404c90;
					}
				}
				else {
					do {
						aiTask = pLVar5;
						fVar13 = aiTask->routing_points_4[5].x;
						if ((((((uint)fVar13 & 0x80000) == 0) &&
								 ((((uint)fVar13 & 0x100000) != 0 ||
									((BVar9 = game::LiveObject_VehicleMaxCarryChecksTime_FUN_00439c80(pLVar3),
									 BVar9 == 0 &&
									 (fVar13 = aiTask->routing_points_4[5].x, ((uint)fVar13 & 0x400) == 0)))))) &&
								((((uint)fVar13 & 0x100) != 0 ||
								 (BVar9 = game::Message_LiveObject_Check_IsSelected_OrFlags3_200000(pLVar3,NULL),
								 BVar9 == 0)))) &&
							 ((((uint)aiTask->routing_points_4[5].x & 0x100) == 0 ||
								(BVar9 = game::LiveObject_FindIndexOfInTable
																	 ((LiveObject **)aiTask->routing_points_4[1].y,
																		(uint)aiTask->routing_points_4[2].x,pLVar3,NULL), BVar9 != 0))))
						{
							local_58 = (float)((Point2I *)&aiTask->customName)->x;
							local_54 = aiTask->vehicle;
							BVar9 = AITask_FUN_00404ef0((AITaskData *)aiTask,pLVar3,NULL,&local_58,&param_2,1,1);
							if ((BVar9 != 0) && (param_2 == NULL)) {
								if (((uint)aiTask->routing_points_4[5].x & 0x100000) != 0) goto LAB_00404c21;
								game::LiveObject_GetBlockPos(pLVar3,(int *)&local_50,(int *)&local_4c);
								OVar4 = aiTask->objType;
								if ((((OVar4 == OBJECT_UPGRADEPART) || (OVar4 == OBJECT_ELECTRICFENCE)) ||
										(OVar4 == 0x17)) ||
									 ((OVar4 == 0x15 ||
										((OVar4 == OBJECT_DYNAMITE &&
										 ((*(byte *)&aiTask->routing_points_4[5].x & 8) == 0)))))) {
									if (((local_58 == local_50) &&
											(uVar14 = (int)(VehicleData *)((int)local_54 - (int)local_4c) >> 0x1f,
											((uint)(VehicleData *)((int)local_54 - (int)local_4c) ^ uVar14) - uVar14 == 1)
											) || ((local_54 == local_4c &&
														(uVar14 = (int)local_58 - (int)local_50 >> 0x1f,
														((int)local_58 - (int)local_50 ^ uVar14) - uVar14 == 1))))
									goto LAB_00404c21;
								}
								else {
									if ((local_58 == local_50) && (local_54 == local_4c)) goto LAB_00404c21;
								}
							}
						}
						if ((((((uint)aiTask->routing_points_4[5].x & 0x400) != 0) &&
								 (BVar9 = game::LiveObject_VehicleMaxCarryChecksTime_FUN_00439c80(pLVar3),
								 BVar9 != 0)) && ((pLVar3->flags3 & LIVEOBJ3_UNK_200000) == LIVEOBJ3_NONE)) &&
							 (pLVar3->objType != OBJECT_ROCKMONSTER)) {
							pLVar5 = pLVar3->carriedObjects[0];
							if ((pLVar5->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE) {
								if ((aiTask->upgrade == NULL) ||
									 (((pLVar5->objLevel == aiTask->routingBlocksTotal &&
										 ((aiTask->routeptr_24 == (void *)0xffffffff ||
											((void *)pLVar5->objIndex == aiTask->routeptr_24)))) &&
										((UpgradeData *)pLVar5->objType == aiTask->upgrade)))) {
									OVar4 = aiTask->objType;
									bVar6 = false;
									bVar7 = false;
									if (((OVar4 == OBJECT_ORE) || (OVar4 == OBJECT_BARRIER)) ||
										 ((OVar4 == OBJECT_PATH || (OVar4 == 0x14)))) {
LAB_00404b3f:
										bVar6 = true;
									}
									else {
										if (OVar4 == OBJECT_BOULDER) {
											if ((LiveObject *)aiTask->miniFigure == NULL) goto LAB_00404b3f;
											BVar9 = game::LiveObject_CheckCondition_FUN_00438870
																				((LiveObject *)aiTask->miniFigure,0);
											if (BVar9 != 0) {
												BVar9 = game::LiveObject_TryDeposit_FUN_0043a5c0
																					(pLVar3,(LiveObject *)aiTask->miniFigure);
												if (BVar9 != 0) goto LAB_00404c21;
												bVar7 = true;
											}
										}
									}
									if (bVar6) {
										if (aiTask->objType == OBJECT_BARRIER) {
											BVar9 = game::LiveObject_FUN_00431ba0
																				(pLVar3,(Point2I *)&aiTask->customName,&local_48,1);
											if (BVar9 == 0) {
												bVar7 = true;
											}
										}
										else {
											local_48.x = ((Point2I *)&aiTask->customName)->x;
											local_48.y = (int)aiTask->vehicle;
										}
										if (!bVar7) {
											game::LiveObject_GetBlockPos(pLVar3,(int *)&local_40,(int *)&local_3c);
											BVar9 = game::LiveObject_FUN_00440ef0
																				(pLVar3,local_40,local_3c,local_48.x,local_48.y,&local_6c,
																				 &local_68,local_64);
											if (BVar9 == 0) {
												bVar7 = true;
												goto LAB_00404bc6;
											}
											std::free(local_6c);
											std::free(local_68);
											goto LAB_00404c21;
										}
									}
									else {
LAB_00404bc6:
										if (!bVar7) goto LAB_00404bd1;
									}
									aiTask->building = (BuildingData *)0x42960000;
								}
							}
							else {
								if (aiTask->objType == 0x1b) goto LAB_00404c21;
							}
						}
LAB_00404bd1:
						if ((((uint)aiTask->routing_points_4[5].x & 0x100) != 0) &&
							 (BVar9 = game::LiveObject_FindIndexOfInTable
																	((LiveObject **)aiTask->routing_points_4[1].y,
																	 (uint)aiTask->routing_points_4[2].x,pLVar3,NULL), BVar9 != 0)) {
							aiTask = NULL;
							goto LAB_00404c21;
						}
						pLVar5 = (LiveObject *)aiTask->routing_points_4[5].y;
						liveObj = aiTask;
					} while (pLVar5 != NULL);
				}
				BVar9 = game::LiveObject_VehicleMaxCarryChecksTime_FUN_00439c80(pLVar3);
				if (BVar9 == 0) {
					if ((uint)INT_004b4424 < 0x32) {
						(&DAT_004b435c)[INT_004b4424] = pLVar3;
						INT_004b4424 += 1;
					}
					if (((UINT_004b44f0 < 0x32) && (pLVar3->objType == OBJECT_ROCKMONSTER)) &&
						 ((pLVar3->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE)) {
						(&DAT_004b4428)[UINT_004b44f0] = pLVar3;
						UINT_004b44f0 += 1;
					}
				}
			}
		}
		else {
			if ((local_60.x != 0) && (local_60.y != 0)) {
				pAVar12 = AITask_Create(AITASK_GOTO);
				liveObj->aitask_2f0 = pAVar12;
				(pAVar12->position).x = local_60.x;
				(pAVar12->position).y = local_60.y;
			}
		}
		goto LAB_00404c90;
	}
	liveObj->float_338 = 0.0;
	uVar14 = pAVar12->flags_5c;
	if ((uVar14 & 0x20) != 0) {
		AITask_LiveObject_FUN_00404110(liveObj);
		game::LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
		goto LAB_00404c90;
	}
	AVar2 = pAVar12->taskType;
	if ((AVar2 == AITASK_WAIT) &&
		 ((ushort)((ushort)(pAVar12->unkExpiryTime < 0.0) << 8 |
							(ushort)(pAVar12->unkExpiryTime == 0.0) << 0xe) != 0)) {
		AITask_LiveObject_FUN_00404110(liveObj);
	}
	else {
		if (AVar2 == AITASK_FOLLOW) {
			if ((ushort)((ushort)(pAVar12->unkExpiryTime < 0.0) << 8 |
									(ushort)(pAVar12->unkExpiryTime == 0.0) << 0xe) != 0) {
				game::LiveObject_GetBlockPos(liveObj,(int *)&local_48,&local_48.y);
				game::LiveObject_GetBlockPos(pAVar12->object_10,(int *)&local_50,(int *)&local_4c);
				if (((float)local_48.x == local_50) && ((VehicleData *)local_48.y == local_4c))
				goto LAB_0040441c;
LAB_004043f4:
				AITask_LiveObject_FUN_00404d30(liveObj,&local_50,NULL);
				pAVar12->unkExpiryTime = 50.0;
			}
		}
		else {
			if (AVar2 == AITASK_FOLLOWATTACK) {
				if ((ushort)((ushort)(pAVar12->unkExpiryTime < 0.0) << 8 |
										(ushort)(pAVar12->unkExpiryTime == 0.0) << 0xe) != 0) {
					fVar13 = pAVar12->object_10->health;
					fVar1 = pAVar12->object_10->stats->PainThreshold;
					if ((ushort)((ushort)(fVar13 < fVar1) << 8 | (ushort)(fVar13 == fVar1) << 0xe) == 0) {
						game::LiveObject_GetPosition(liveObj,(float *)&local_48,(float *)&local_48.y);
						game::LiveObject_GetPosition(pAVar12->object_10,&local_58,(float *)&local_54);
						fVar13 = SQRT(((float)local_48.y - (float)local_54) *
													((float)local_48.y - (float)local_54) +
													((float)local_48.x - local_58) * ((float)local_48.x - local_58));
						if ((ushort)((ushort)(fVar13 < 130.0) << 8 | (ushort)(fVar13 == 130.0) << 0xe) == 0) {
							game::LiveObject_GetBlockPos(liveObj,(int *)&local_60,&local_60.y);
							game::LiveObject_GetBlockPos(pAVar12->object_10,(int *)&local_50,(int *)&local_4c);
							if (((float)local_60.x != local_50) || ((VehicleData *)local_60.y != local_4c))
							goto LAB_004043f4;
						}
						else {
							BVar9 = game::LiveObject_FUN_00442190(liveObj,pAVar12->object_10,2);
							if (BVar9 == 0) {
								pAVar12->unkExpiryTime = 25.0;
								goto LAB_004047ed;
							}
						}
LAB_0040441c:
						pAVar12->unkExpiryTime = 50.0;
					}
					else {
						pAVar12->flags_5c = uVar14 | 0x20;
					}
				}
			}
			else {
				if (((uVar14 & 1) == 0) && ((liveObj->flags3 & LIVEOBJ3_UNK_200000) == LIVEOBJ3_NONE)) {
					BVar9 = 1;
					if (true) {
						switch(AVar2) {
						case AITASK_GOTO:
							game::LiveObject_GetBlockPos(liveObj,(int *)&local_48,&local_48.y);
							if ((local_48.x == (pAVar12->position).x) &&
								 ((VehicleData *)local_48.y == (VehicleData *)(pAVar12->position).y)) {
								BVar9 = 1;
								AITask_LiveObject_FUN_00404110(liveObj);
							}
							else {
								uVar14 = (pAVar12->position).y;
								x = (pAVar12->position).x;
								out_vertices4 = local_30;
								surfMap = game::GetSurfaceMap();
								game::Map3D_GetBlockVertexPositions(surfMap,x,uVar14,out_vertices4);
								fVar15 = math::Maths_RandRange(local_30[0].x - -6.0,local_18 - 6.0);
								local_40 = (float)fVar15;
								fVar15 = math::Maths_RandRange(local_14 - -6.0,local_30[0].y - 6.0);
								local_3c = (float)fVar15;
								OVar11 = game::LiveObject_GetStatsFlags1(liveObj);
								BVar9 = AITask_LiveObject_FUN_00404d30
																	(liveObj,(float *)&pAVar12->position,
																	 (float *)(-(uint)((OVar11 & STATS1_ROUTEAVOIDANCE) != STATS1_NONE
																										) & (uint)&local_40));
							}
							break;
						case AITASK_COLLECT:
							BVar9 = game::LiveObject_TryCollect_FUN_00439ce0(liveObj,pAVar12->object_10);
							break;
						case AITASK_GATHER:
							BVar9 = game::Game_PTL_GatherRock(liveObj);
							break;
						case AITASK_DEPOSITE:
							BVar9 = game::LiveObject_TryDeposit_FUN_0043a5c0(liveObj,pAVar12->object_10);
							break;
						case AITASK_DUMP:
							BVar9 = game::LiveObject_TryRequestOrDump_FUN_0043a3e0
																(liveObj,&pAVar12->position,&pAVar12->pointf_30,1,uVar14 & 0x800);
							break;
						case AITASK_REQUEST:
							BVar9 = game::LiveObject_TryRequestOrDump_FUN_0043a3e0
																(liveObj,&pAVar12->position,&pAVar12->pointf_30,1,uVar14 & 0x800);
							break;
						case AITASK_DIG:
							if ((((uVar14 & 8) != 0) &&
									(OVar11 = game::LiveObject_GetStatsFlags1(liveObj),
									(OVar11 & STATS1_SINGLEWIDTHDIG) != STATS1_NONE)) ||
								 ((*(byte *)&pAVar12->flags_5c & 8) == 0)) {
								BVar9 = game::LiveObject_FUN_00447100
																	(liveObj,(pAVar12->position).x,(pAVar12->position).y,
																	 pAVar12->flags_5c & 8);
							}
							break;
						case AITASK_DYNAMITE:
							BVar9 = game::LiveObject_TryDynamite_FUN_00448ac0(liveObj,&pAVar12->position);
							break;
						case AITASK_REPAIR:
							BVar9 = game::LiveObject_TryRepair_FUN_00449360
																(liveObj,pAVar12->object_10,TRUE,uVar14 & 0x200000);
							break;
						case AITASK_REINFORCE:
							BVar9 = game::LiveObject_TryReinforce_FUN_00449500(liveObj,&pAVar12->position);
							break;
						case AITASK_CLEAR:
							BVar9 = game::LiveObject_TryClear_FUN_00449570(liveObj,&pAVar12->position);
							break;
						case AITASK_ELECFENCE:
							BVar9 = game::LiveObject_TryElecFence_FUN_00448d20(liveObj,&pAVar12->position);
							break;
						case AITASK_EAT:
							BVar9 = game::LiveObject_TryGoEat_FUN_00449d80(liveObj,pAVar12->object_10);
							break;
						case AITASK_GOTOEAT:
							BVar9 = game::LiveObject_TryGoEat_FUN_00449d80(liveObj,pAVar12->object_10);
							break;
						case AITASK_FINDDRIVER:
							BVar9 = game::LiveObject_TryFindDriver_FUN_00440690(liveObj,pAVar12->object_10);
							break;
						case AITASK_GETTOOL:
							BVar9 = game::LiveObject_DoGetTool(liveObj,pAVar12->toolType);
							front::Bubble_LiveObject_UpdateBubbleImage(liveObj);
							break;
						case AITASK_BIRDSCARER:
							BVar9 = game::LiveObject_DoBirdScarer(liveObj,&pAVar12->position);
							break;
						case AITASK_UPGRADE:
							BVar9 = game::LiveObject_TryUpgrade_FUN_00448f50
																(liveObj,pAVar12->object_10,pAVar12->objLevel);
							break;
						case AITASK_BUILDPATH:
							BVar9 = game::LiveObject_TryBuildPath_FUN_00448f10(liveObj);
							break;
						case AITASK_TRAIN:
							BVar9 = game::LiveObject_TryTrain_FUN_00449170(liveObj,pAVar12->object_10,0);
							break;
						case AITASK_DEPART:
							BVar9 = game::LiveObject_TryDepart_FUN_004499c0(liveObj);
							break;
						case AITASK_ATTACKPATH:
							BVar9 = game::LiveObject_TryAttackPath_FUN_004498d0(liveObj,&pAVar12->position);
							break;
						case AITASK_ATTACKROCKMONSTER:
							pLVar3 = pAVar12->object_10;
							if ((pLVar3 == NULL) || (pLVar3->object_364 == NULL)) {
LAB_0040469f:
								BVar9 = game::LiveObject_TryAttackRockMonster_FUN_004496f0
																	(liveObj,pAVar12->object_10);
							}
							else {
								if ((pLVar3->flags2 & LIVEOBJ2_UNK_8000000) == LIVEOBJ2_NONE) {
									TVar10 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
									if ((TVar10 == TUTORIAL_NONE) ||
										 (pAVar12->object_10->stats->PainThreshold <= pAVar12->object_10->health))
									goto LAB_0040469f;
									BVar9 = 0;
								}
								else {
									BVar9 = 0;
								}
							}
							break;
						case AITASK_RECHARGE:
							BVar9 = game::LiveObject_TryRecharge_FUN_004492d0(liveObj);
							break;
						case AITASK_DOCK:
							BVar9 = game::LiveObject_TryDock_FUN_004402b0(liveObj);
							break;
						case AITASK_ATTACKOBJECT:
							BVar9 = game::LiveObject_TryAttackObject_FUN_004497e0(liveObj,pAVar12->object_10);
							break;
						case AITASK_FINDLOAD:
							BVar9 = game::LiveObject_TryFindLoad_FUN_00440130(liveObj,pAVar12->object_10);
						}
					}
					if (BVar9 == 0) {
						local_6c = (void *)0x1;
					}
					else {
						pAVar12->flags_5c = pAVar12->flags_5c | 1;
					}
				}
			}
		}
	}
LAB_004047ed:
	if (local_6c != NULL) {
		if ((pAVar12->taskType == AITASK_DIG) && ((*(byte *)&pAVar12->flags_5c & 8) != 0)) {
			pAVar12->float_18 = (float)&DAT_42c80000;
		}
		if (((*(byte *)&pAVar12->flags_5c & 0x10) != 0) && (pAVar12->unkExpiryTime < 0.0)) {
			pAVar12->unkExpiryTime = 1500.0;
		}
		AITask_LiveObject_FUN_00404110(liveObj);
	}
LAB_00404c90:
	pool::globals::ReservedPool_AITask___g_INITFLAGS =
			 pool::globals::ReservedPool_AITask___g_INITFLAGS & 0xfffffffb;
	return 0;
}



BOOL __cdecl
lego::ai::AITask_LiveObject_FUN_00404d30(LiveObject *in_liveObj,float *param_2,float *param_3)
{
	LiveObject *liveObj;
	BOOL BVar1;
	float *local_10;
	uint local_c;
	float local_8;
	float local_4;
	
	liveObj = in_liveObj;
	game::LiveObject_GetBlockPos(in_liveObj,(int *)&local_8,(int *)&local_4);
	if ((local_8 == *param_2) && (local_4 == param_2[1])) {
		in_liveObj = (LiveObject *)&local_8;
		local_10 = &local_4;
		local_c = 1;
	}
	else {
		BVar1 = game::LiveObject_FUN_00440ef0
											(liveObj,local_8,local_4,*param_2,param_2[1],&in_liveObj,&local_10,&local_c);
		if (BVar1 == 0) {
			return 0;
		}
	}
	game::LiveObject_FUN_004419c0(liveObj,local_c,(float *)in_liveObj,local_10,param_3);
	if (in_liveObj != (LiveObject *)&local_8) {
		std::free(in_liveObj);
		std::free(local_10);
	}
	return TRUE;
}



BOOL __cdecl lego::ai::AITask_LiveObject_FUN_00404e00(LiveObject *liveObj)
{
	BOOL BVar1;
	
	if ((liveObj->objType == OBJECT_POWERCRYSTAL) &&
		 ((liveObj->flags3 & LIVEOBJ3_POWEROFF) != LIVEOBJ3_NONE)) {
		BVar1 = game::LiveObject_FindRechargeSeam_FUN_0044a690(liveObj,NULL);
		return BVar1;
	}
	BVar1 = AITask_FUN_00404e40(liveObj->objType,liveObj->objIndex,liveObj->objLevel);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_FUN_00404e40(ObjectType objType,int objIndex,int objLevel)
{
	BOOL BVar1;
	ObjectType local_c;
	int local_8;
	char *local_4;
	
	local_c = objType;
	local_8 = objIndex;
	local_4 = (char *)objLevel;
	BVar1 = AITask_DoUnkCallbacks(AITask_Callback_FUN_00404e80,(LiveObject *)&local_c);
	return BVar1;
}



BOOL __cdecl lego::ai::AITask_Callback_FUN_00404e80(AITaskData *aiTask,int *param_2)
{
	AITaskType AVar1;
	BOOL BVar2;
	
	AVar1 = aiTask->taskType;
	if (AVar1 != AITASK_DEPOSITE) {
		if (((AVar1 != AITASK_REQUEST) && (AVar1 != AITASK_DYNAMITE)) && (AVar1 != AITASK_ELECFENCE)) {
			return 0;
		}
		if (((AVar1 != AITASK_DEPOSITE) && (aiTask->object_10 != NULL)) &&
			 (BVar2 = game::LiveObject_CheckCondition_FUN_00438870(aiTask->object_10,0), BVar2 == 0)) {
			return 0;
		}
	}
	if ((aiTask->objType != OBJECT_NONE) &&
		 (((*param_2 != aiTask->objType ||
			 ((aiTask->objIndex != -1 && (param_2[1] != aiTask->objIndex)))) ||
			(param_2[2] != aiTask->objLevel)))) {
		return 0;
	}
	return TRUE;
}



BOOL __cdecl
lego::ai::AITask_FUN_00404ef0
					(AITaskData *aiTask,LiveObject *liveObj_2,float *param_3,float *param_4,
					undefined4 *param_5,int param_6,int param_7)
{
	Point2I *pPVar1;
	AITaskType AVar2;
	ObjectType OVar3;
	LiveFlags5 LVar4;
	ObjectStatsFlags1 OVar5;
	BOOL BVar6;
	Container *pCVar7;
	ObjectStatsFlags3 OVar8;
	SurfaceMap *pSVar9;
	int iVar10;
	LiveObject *pLVar11;
	BOOL BVar12;
	float10 fVar13;
	float fVar14;
	uint uVar15;
	float by;
	uint uVar16;
	float *pfVar17;
	Vector3F local_18;
	Vector3F local_c;
	
	if (param_5 != NULL) {
		*param_5 = 0;
	}
	if (((aiTask->taskType != AITASK_COLLECT) || (aiTask->object_10->objType != OBJECT_DYNAMITE)) &&
		 ((ushort)((ushort)(aiTask->float_18 < 0.0) << 8 | (ushort)(aiTask->float_18 == 0.0) << 0xe) ==
			0)) {
		return 0;
	}
	OVar5 = game::LiveObject_GetStatsFlags1(liveObj_2);
	if (((OVar5 & STATS1_CANBEDRIVEN) != STATS1_NONE) && (liveObj_2->drivenObject == NULL)) {
		return 0;
	}
	if ((liveObj_2->flags1 & LIVEOBJ1_UNK_800000) != LIVEOBJ1_NONE) {
		return 0;
	}
	if ((liveObj_2->flags4 & 0x400) != LIVEOBJ4_NONE) {
		return 0;
	}
	if (((((byte)globs::gameGlobs.flags2 & 1) != 0) &&
			(BVar6 = game::LiveObject_MiniFigureHasBeamEquipped(liveObj_2), BVar6 != 0)) &&
		 (aiTask->taskType != AITASK_ATTACKROCKMONSTER)) {
		return 0;
	}
	AVar2 = aiTask->taskType;
	if (AVar2 == AITASK_ATTACKROCKMONSTER) {
		BVar6 = game::LiveObject_MiniFigureHasBeamEquipped(liveObj_2);
		if (BVar6 == 0) {
			return 0;
		}
		BVar6 = game::LiveObject_FUN_004723f0(liveObj_2,(undefined4 *)aiTask->object_10);
		if (BVar6 == 0) {
			return 0;
		}
		BVar6 = game::LiveObject_SeeThroughWalls_FUN_00471c20(liveObj_2,aiTask->object_10);
		if (BVar6 != 0) {
			return 0;
		}
		BVar6 = game::LiveObject_CheckCondition_FUN_00438870(aiTask->object_10,1);
		if (BVar6 == 0) {
			return 0;
		}
		if (((byte)globs::gameGlobs.flags2 & GAME2_CALLTOARMS) == 0) {
			return 0;
		}
		if (param_3 != NULL) {
			game::LiveObject_GetPosition(aiTask->object_10,param_3,param_3 + 1);
		}
		if (param_4 != NULL) {
			game::LiveObject_GetBlockPos(aiTask->object_10,(int *)param_4,(int *)(param_4 + 1));
			return 1;
		}
	}
	else {
		if (AVar2 == AITASK_FINDLOAD) {
			pCVar7 = game::LiveObject_GetDepositNull(aiTask->object_10);
			if ((pCVar7 == NULL) ||
				 (OVar8 = game::LiveObject_GetStatsFlags3(liveObj_2),
				 (OVar8 & STATS3_VEHICLECANBECARRIED) == STATS3_NONE)) {
				return 0;
			}
			res::Container_GetPosition(pCVar7,NULL,&local_18);
			if (param_3 != NULL) {
				*param_3 = local_18.x;
				param_3[1] = local_18.y;
			}
			if (param_4 != NULL) {
				pfVar17 = param_4 + 1;
				pSVar9 = game::GetSurfaceMap();
				game::Map3D_WorldToBlockPos_NoZ(pSVar9,local_18.x,local_18.y,(int *)param_4,(int *)pfVar17);
				return 1;
			}
		}
		else {
			if (AVar2 == AITASK_COLLECT) {
				if ((*(byte *)&liveObj_2->flags3 & 0x40) == 0) {
					return 0;
				}
				BVar6 = game::LiveObject_FUN_00439e90(liveObj_2,aiTask->object_10,1);
				if (BVar6 == 0) {
					return 0;
				}
				if ((liveObj_2->objType == OBJECT_VEHICLE) &&
					 (iVar10 = game::LiveObject_GetMaxCarry(liveObj_2), iVar10 == 0)) {
					return 0;
				}
				pLVar11 = aiTask->object_10;
				OVar3 = pLVar11->objType;
				if (((OVar3 == OBJECT_DYNAMITE) && ((*(byte *)&liveObj_2->flags5_3f0 & 8) == 0)) &&
					 (param_7 != 0)) {
					return 0;
				}
				if ((liveObj_2->objType == OBJECT_ROCKMONSTER) && (OVar3 != OBJECT_POWERCRYSTAL)) {
					return 0;
				}
				if (liveObj_2->objType == OBJECT_VEHICLE) {
					if (OVar3 == OBJECT_BARRIER) {
						return 0;
					}
					if (true) {
						if ((OVar3 == OBJECT_POWERCRYSTAL) &&
							 ((pLVar11->flags3 & LIVEOBJ3_POWEROFF) != LIVEOBJ3_NONE)) {
							return 0;
						}
						if (((true) && ((liveObj_2->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
							 (liveObj_2->carriedObjects[0]->objType == OBJECT_ELECTRICFENCE)) {
							return 0;
						}
					}
				}
				BVar6 = AITask_LiveObject_FUN_00404e00(pLVar11);
				if (BVar6 == 0) {
					return 0;
				}
				BVar6 = FUN_00439e40(liveObj_2,(undefined4 *)aiTask->object_10);
				if (BVar6 == 0) {
					return 0;
				}
				if (param_3 != NULL) {
					game::LiveObject_GetPosition(aiTask->object_10,param_3,param_3 + 1);
				}
				if (param_4 != NULL) {
					game::LiveObject_GetBlockPos(aiTask->object_10,(int *)param_4,(int *)(param_4 + 1));
					return 1;
				}
			}
			else {
				if (((AVar2 == AITASK_DIG) || (AVar2 == AITASK_GOTO)) ||
					 ((AVar2 == AITASK_REINFORCE || (AVar2 == AITASK_CLEAR)))) {
					BVar6 = 1;
					if (AVar2 == AITASK_DIG) {
						BVar6 = game::LiveObject_Check_FUN_004326a0
															(liveObj_2,(aiTask->position).x,(aiTask->position).y,
															 aiTask->flags_5c & 8,1);
					}
					if (((param_6 != 0) && (AVar2 = aiTask->taskType, AVar2 != AITASK_GOTO)) &&
						 ((AVar2 != AITASK_DYNAMITE &&
							(BVar12 = game::LiveObject_TaskHasTool_FUN_0044b780(liveObj_2,AVar2), BVar12 == 0))))
					{
						return 0;
					}
					if ((aiTask->taskType == AITASK_REINFORCE) && (liveObj_2->objType != OBJECT_MINIFIGURE)) {
						return 0;
					}
					if ((aiTask->taskType == AITASK_CLEAR) &&
						 (OVar5 = game::LiveObject_GetStatsFlags1(liveObj_2),
						 (OVar5 & STATS1_CANCLEARRUBBLE) == STATS1_NONE)) {
						return 0;
					}
					if (aiTask->taskType == AITASK_DIG) {
						if ((*(byte *)&liveObj_2->flags3 & 2) == 0) {
							return 0;
						}
						if (BVar6 == 0) {
							return 0;
						}
						if (((*(byte *)&aiTask->flags_5c & 8) != 0) &&
							 (OVar5 = game::LiveObject_GetStatsFlags1(liveObj_2),
							 (OVar5 & STATS1_SINGLEWIDTHDIG) == STATS1_NONE)) {
							return 0;
						}
					}
					if (param_3 != NULL) {
						uVar16 = (aiTask->position).y;
						pfVar17 = param_3 + 1;
						uVar15 = (aiTask->position).x;
						pSVar9 = game::GetSurfaceMap();
						game::Map3D_BlockToWorldPos(pSVar9,uVar15,uVar16,param_3,pfVar17);
					}
					if (param_4 != NULL) {
						*param_4 = (float)(aiTask->position).x;
						param_4[1] = (float)(aiTask->position).y;
					}
				}
				else {
					if (AVar2 == AITASK_REPAIR) {
						if ((param_6 != 0) &&
							 (BVar6 = game::LiveObject_TaskHasTool_FUN_0044b780(liveObj_2,AITASK_REPAIR),
							 BVar6 == 0)) {
							return 0;
						}
						if (((param_7 != 0) && ((*(byte *)&liveObj_2->flags5_3f0 & 0x10) == 0)) &&
							 ((aiTask->flags_5c & 0x200000) == 0)) {
							return 0;
						}
						if (liveObj_2->objType != OBJECT_MINIFIGURE) {
							return 0;
						}
						if (param_3 != NULL) {
							game::LiveObject_GetPosition(aiTask->object_10,param_3,param_3 + 1);
							if (param_4 == NULL) {
								return 1;
							}
							game::LiveObject_GetBlockPos(aiTask->object_10,(int *)param_4,(int *)(param_4 + 1));
							return 1;
						}
					}
					else {
						if (AVar2 == AITASK_GOTOEAT) {
							BVar6 = game::LiveObject_CheckCondition_FUN_00438870(aiTask->object_10,0);
							if (BVar6 == 0) {
								return 0;
							}
							if (((liveObj_2->objType == OBJECT_MINIFIGURE) &&
									((liveObj_2->flags2 & LIVEOBJ2_UNK_800) == LIVEOBJ2_NONE)) &&
								 (fVar14 = liveObj_2->health * 0.01 * globs::gameGlobs.MinEnergyForEat,
								 (ushort)((ushort)(liveObj_2->energy < fVar14) << 8 |
												 (ushort)(liveObj_2->energy == fVar14) << 0xe) != 0)) {
								if ((liveObj_2->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
									return 1;
								}
								return 0;
							}
							return 0;
						}
						if (AVar2 == AITASK_FINDDRIVER) {
							if ((((liveObj_2->objType != OBJECT_MINIFIGURE) || (liveObj_2->aitask_2f0 != NULL)) ||
									(liveObj_2->drivenObject != NULL)) ||
								 (((aiTask->mode_3c & liveObj_2->flags5_3f0) == LIVEOBJ5_NONE && (param_7 != 0)))) {
								return 0;
							}
							OVar5 = game::LiveObject_GetStatsFlags1(aiTask->object_10);
							if ((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) {
								if ((((*(byte *)&aiTask->object_10->flags4 & 0x40) != 0) &&
										(pLVar11 = aiTask->object_10->object_2fc, pLVar11 != NULL)) &&
									 ((pLVar11->objType == OBJECT_BUILDING &&
										(pCVar7 = res::Building_GetEntranceNull(pLVar11->building), pCVar7 != NULL)))) {
									res::Container_GetPosition(pCVar7,NULL,&local_c);
									if (param_3 != NULL) {
										*param_3 = local_c.x;
										param_3[1] = local_c.y;
									}
									if (param_4 == NULL) {
										return 1;
									}
									pfVar17 = param_4 + 1;
									pSVar9 = game::GetSurfaceMap();
									game::Map3D_WorldToBlockPos_NoZ
														(pSVar9,local_c.x,local_c.y,(int *)param_4,(int *)pfVar17);
									return 1;
								}
								BVar6 = game::LiveObject_CheckUnkGetInAtLand_FUN_0043a100
																	(aiTask->object_10,(Point2I *)&local_18);
								if (BVar6 == 0) {
									return 0;
								}
								if (param_3 != NULL) {
									pfVar17 = param_3 + 1;
									fVar14 = local_18.x;
									by = local_18.y;
									pSVar9 = game::GetSurfaceMap();
									game::Map3D_BlockToWorldPos(pSVar9,(uint)fVar14,(uint)by,param_3,pfVar17);
								}
								if (param_4 == NULL) {
									return 1;
								}
								*param_4 = local_18.x;
								param_4[1] = local_18.y;
								return 1;
							}
							if (param_3 != NULL) {
								game::LiveObject_GetPosition(aiTask->object_10,param_3,param_3 + 1);
								if (param_4 == NULL) {
									return 1;
								}
								game::LiveObject_GetBlockPos(aiTask->object_10,(int *)param_4,(int *)(param_4 + 1));
								return 1;
							}
						}
						else {
							if (AVar2 == AITASK_UPGRADE) {
								if (liveObj_2->objType != OBJECT_VEHICLE) {
									return 0;
								}
								if (liveObj_2->drivenObject != NULL) {
									pCVar7 = game::LiveObject_GetDepositNull(aiTask->object_10);
									res::Container_GetPosition(pCVar7,NULL,&local_c);
									if (param_3 != NULL) {
										*param_3 = local_c.x;
										param_3[1] = local_c.y;
									}
									if (param_4 == NULL) {
										return 1;
									}
									pfVar17 = param_4 + 1;
									pSVar9 = game::GetSurfaceMap();
									game::Map3D_WorldToBlockPos_NoZ
														(pSVar9,local_c.x,local_c.y,(int *)param_4,(int *)pfVar17);
									return 1;
								}
								return 0;
							}
							if (AVar2 != AITASK_TRAIN) {
								if (AVar2 != AITASK_BUILDPATH) {
									if (AVar2 == AITASK_GETTOOL) {
										if (((liveObj_2->objType == OBJECT_MINIFIGURE) &&
												(iVar10 = game::LiveObject_GetNumOfToolsCanCarry(liveObj_2), iVar10 != 0))
											 && (BVar6 = game::LiveObject_HasToolEquipped(liveObj_2,aiTask->toolType),
													BVar6 == 0)) {
											game::LiveObject_GetPosition(liveObj_2,(float *)&local_18,&local_18.y);
											pLVar11 = game::Level_GetBuildingAtPosition((Point2F *)&local_18);
											if (pLVar11 != NULL) {
												if (param_3 == NULL) {
													return 1;
												}
												game::LiveObject_GetPosition(pLVar11,param_3,param_3 + 1);
												return 1;
											}
										}
										return 0;
									}
									if (param_5 == NULL) {
										return 1;
									}
									*param_5 = 1;
									return 1;
								}
								if (liveObj_2->objType != OBJECT_MINIFIGURE) {
									return 0;
								}
								pPVar1 = &aiTask->position;
								iVar10 = util::return_1(pPVar1);
								if (iVar10 != 0) {
									if (param_3 != NULL) {
										uVar16 = (aiTask->position).y;
										pfVar17 = param_3 + 1;
										uVar15 = pPVar1->x;
										pSVar9 = game::GetSurfaceMap();
										game::Map3D_BlockToWorldPos(pSVar9,uVar15,uVar16,param_3,pfVar17);
									}
									if (param_4 == NULL) {
										return 1;
									}
									*param_4 = (float)pPVar1->x;
									param_4[1] = (float)(aiTask->position).y;
									return 1;
								}
								return 0;
							}
							if (liveObj_2->objType != OBJECT_MINIFIGURE) {
								return 0;
							}
							LVar4 = liveObj_2->flags5_3f0;
							if (((LVar4 & LIVEOBJ5_ABILITY_PILOT) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 1)) {
								return 0;
							}
							if (((LVar4 & LIVEOBJ5_ABILITY_SAILOR) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 2)) {
								return 0;
							}
							if (((LVar4 & LIVEOBJ5_ABILITY_DRIVER) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 4)) {
								return 0;
							}
							if (((LVar4 & LIVEOBJ5_ABILITY_DYNAMITE) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 8))
							{
								return 0;
							}
							if (((LVar4 & LIVEOBJ5_ABILITY_REPAIR) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 0x10))
							{
								return 0;
							}
							if (((LVar4 & LIVEOBJ5_ABILITY_SCANNER) != LIVEOBJ5_NONE) && (aiTask->mode_3c == 0x20)
								 ) {
								return 0;
							}
							fVar13 = game::Level_GetTrainTime();
							if ((ushort)((ushort)(fVar13 < (float10)liveObj_2->elapsedTime1) << 8 |
													(ushort)(fVar13 == (float10)liveObj_2->elapsedTime1) << 0xe) == 0) {
								return 0;
							}
							if (param_3 != NULL) {
								game::LiveObject_GetPosition(aiTask->object_10,param_3,param_3 + 1);
							}
						}
					}
					if (param_4 != NULL) {
						game::LiveObject_GetBlockPos(aiTask->object_10,(int *)param_4,(int *)(param_4 + 1));
						return 1;
					}
				}
			}
		}
	}
	return 1;
}



void __cdecl lego::ai::AITask_FUN_00405880(void)
{
	LiveObject *liveObj;
	AITaskType AVar1;
	float fVar2;
	float fVar3;
	bool bVar4;
	BOOL BVar5;
	int iVar6;
	ObjectStatsFlags2 OVar7;
	AITaskData *pAVar8;
	uint uVar9;
	AITaskData *aiTask;
	float10 fVar10;
	LiveObject **local_24;
	AITaskData *local_1c;
	float local_18;
	float local_14;
	float local_10;
	float local_c;
	int local_8;
	int local_4;
	
	local_1c = NULL;
	pAVar8 = globals::g_AITaskDataNext;
	if (globals::g_AITaskDataNext != NULL) {
		do {
			aiTask = pAVar8;
			if ((ushort)((ushort)(aiTask->float_18 < 0.0) << 8 | (ushort)(aiTask->float_18 == 0.0) << 0xe)
					!= 0) {
				bVar4 = false;
				uVar9 = 0;
				if (UINT_004b44f0 != 0) {
					local_24 = (LiveObject **)&DAT_004b4428;
					do {
						liveObj = *local_24;
						game::LiveObject_GetPosition(liveObj,&local_18,&local_14);
						game::LiveObject_GetBlockPos(liveObj,&local_8,&local_4);
						fVar10 = game::LiveObject_GetPainThreshold(liveObj);
						if (fVar10 < (float10)liveObj->health) {
							AVar1 = aiTask->taskType;
							if (AVar1 == AITASK_GATHER) {
								BVar5 = game::LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj);
								if ((BVar5 != 0) &&
									 (iVar6 = game::LiveManager_FUN_004373c0(OBJECT_BUILDING,0), iVar6 != 0)) {
									bVar4 = true;
								}
							}
							else {
								if (AVar1 == AITASK_REPAIR) {
									OVar7 = game::LiveObject_GetStatsFlags2(liveObj);
									if (((OVar7 & STATS2_DRAINPOWER) == STATS2_NONE) ||
										 ((BVar5 = game::LiveObject_CheckCondition_FUN_00438870(aiTask->object_10,0),
											BVar5 != 0 &&
											(OVar7 = game::LiveObject_GetStatsFlags2(aiTask->object_10),
											(OVar7 & STATS2_SELFPOWERED) == STATS2_NONE)))) {
										game::LiveObject_GetPosition(aiTask->object_10,&local_10,&local_c);
										fVar3 = local_18 - local_10;
										fVar2 = local_14 - local_c;
										fVar10 = game::LiveObject_GetAttackRadius(liveObj);
										if ((float10)SQRT(fVar2 * fVar2 + fVar3 * fVar3) < fVar10) {
											bVar4 = true;
											OVar7 = game::LiveObject_GetStatsFlags2(liveObj);
											if ((OVar7 & STATS2_DRAINPOWER) == STATS2_NONE) {
												aiTask->float_18 = 750.0;
											}
										}
									}
								}
								else {
									if (AVar1 == AITASK_COLLECT) {
										iVar6 = FUN_0043c910(liveObj);
joined_r0x00405a76:
										if (iVar6 != 0) {
											bVar4 = true;
											aiTask->float_18 = 250.0;
										}
									}
									else {
										if (AVar1 == AITASK_ATTACKPATH) {
											OVar7 = game::LiveObject_GetStatsFlags2(liveObj);
											if ((OVar7 & STATS2_ATTACKPATHS) != STATS2_NONE) {
												bVar4 = true;
											}
										}
										else {
											if (AVar1 == AITASK_GOTO) {
												BVar5 = game::LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj);
												if ((BVar5 != 0) &&
													 (((aiTask->position).x != local_8 || ((aiTask->position).y != local_4))))
												{
													bVar4 = true;
												}
											}
											else {
												if (AVar1 == AITASK_ATTACKOBJECT) {
													iVar6 = game::LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj);
													goto joined_r0x00405a76;
												}
											}
										}
									}
								}
							}
						}
						if ((aiTask->taskType == AITASK_DEPART) &&
							 ((BVar5 = game::LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj), BVar5 != 0 ||
								(OVar7 = game::LiveObject_GetStatsFlags2(liveObj),
								(OVar7 & STATS2_USEHOLES) != STATS2_NONE)))) {
							bVar4 = true;
						}
						if (bVar4) {
							UINT_004b44f0 -= 1;
							(&DAT_004b4428)[uVar9] = (&DAT_004b4428)[UINT_004b44f0];
							if ((*(byte *)&aiTask->flags_5c & 0x40) == 0) {
								if (local_1c == NULL) {
									globals::g_AITaskDataNext = aiTask->next;
								}
								else {
									local_1c->next = aiTask->next;
								}
								aiTask->next = NULL;
								liveObj->aitask_2f0 = aiTask;
							}
							else {
								pAVar8 = AITask_FUN_00406330(aiTask);
								liveObj->aitask_2f0 = pAVar8;
							}
							break;
						}
						uVar9 += 1;
						local_24 = local_24 + 1;
					} while (uVar9 < UINT_004b44f0);
				}
			}
			pAVar8 = aiTask->next;
			local_1c = aiTask;
		} while (aiTask->next != NULL);
	}
	return;
}



void __cdecl lego::ai::AITask_FUN_00405b40(void)
{
	AITaskType AVar1;
	bool bVar2;
	AITaskData *pAVar3;
	BOOL BVar4;
	SurfaceMap *pSVar5;
	BOOL BVar6;
	uint uVar7;
	LiveObject *pLVar8;
	LiveObject *pLVar9;
	LiveObject **ppLVar10;
	AITaskData *aiTask;
	float fVar11;
	float fVar12;
	Point2I *pPVar13;
	int *out_bx;
	int *piVar14;
	LiveObject *local_94;
	LiveObject *local_90;
	LiveObject **local_8c;
	MessageType local_88;
	uint local_84;
	Point2I local_80;
	MessageType local_78;
	float local_74;
	float local_70;
	Point2I local_6c;
	int local_64;
	int local_60;
	uint local_5c;
	int local_58;
	int local_54;
	AITaskData *local_50;
	float local_4c;
	float local_48;
	float local_44;
	float local_40;
	float local_3c;
	void *local_38;
	int local_34;
	void *local_30;
	Point2F local_2c;
	Point2I local_24;
	float local_18;
	undefined local_14 [4];
	Point2I local_10;
	Point2F local_8;
	
	local_50 = NULL;
	local_44 = 99999.0;
	pAVar3 = globals::g_AITaskUnkPtr;
	if (globals::g_AITaskUnkPtr != NULL) {
		do {
			aiTask = pAVar3;
			if (((ushort)((ushort)(aiTask->float_18 < 0.0) << 8 | (ushort)(aiTask->float_18 == 0.0) << 0xe
									 ) != 0) && ((aiTask->flags_5c & 0x80400) == 0)) {
				pLVar8 = NULL;
				local_90 = NULL;
				local_84 = 0;
				if (INT_004b4424 != 0) {
					local_8c = (LiveObject **)&DAT_004b435c;
					pLVar9 = pLVar8;
					do {
						pLVar8 = *local_8c;
						if (pLVar8 != NULL) {
							if ((aiTask->flags_5c & 0x100) == 0) {
								BVar4 = game::Message_LiveObject_Check_IsSelected_OrFlags3_200000(pLVar8,NULL);
								pLVar9 = local_90;
								if (BVar4 == 0) {
									if ((aiTask->flags_5c & 0x100) != 0) goto LAB_00405bda;
									goto LAB_00405bf5;
								}
							}
							else {
LAB_00405bda:
								BVar4 = game::LiveObject_FindIndexOfInTable
																	((LiveObject **)aiTask->ptr_40,aiTask->field_44,pLVar8,NULL);
								pLVar9 = local_90;
								if (BVar4 != 0) {
LAB_00405bf5:
									game::LiveObject_GetPosition(pLVar8,&local_4c,&local_48);
									BVar4 = AITask_FUN_00404ef0(aiTask,pLVar8,&local_74,NULL,&local_34,1,1);
									if (BVar4 != 0) {
										piVar14 = &local_6c.y;
										pPVar13 = &local_6c;
										fVar11 = local_74;
										fVar12 = local_70;
										pSVar5 = game::GetSurfaceMap();
										BVar6 = game::Map3D_WorldToBlockPos_NoZ
																			(pSVar5,fVar11,fVar12,(int *)pPVar13,piVar14);
										if (BVar6 != 0) {
											piVar14 = &local_60;
											out_bx = &local_64;
											fVar11 = local_4c;
											fVar12 = local_48;
											pSVar5 = game::GetSurfaceMap();
											BVar6 = game::Map3D_WorldToBlockPos_NoZ(pSVar5,fVar11,fVar12,out_bx,piVar14);
											if (BVar6 != 0) {
												AVar1 = aiTask->taskType;
												local_94 = (LiveObject *)0x1;
												if ((((((AVar1 == AITASK_DIG) && ((*(byte *)&aiTask->flags_5c & 8) == 0)) ||
															(AVar1 == AITASK_REPAIR)) ||
														 ((AVar1 == AITASK_REINFORCE || (AVar1 == AITASK_TRAIN)))) ||
														(AVar1 == AITASK_GETTOOL)) &&
													 (((local_64 != local_6c.x ||
														 (uVar7 = local_60 - local_6c.y >> 0x1f,
														 (local_60 - local_6c.y ^ uVar7) - uVar7 != 1)) &&
														((local_60 != local_6c.y ||
														 (uVar7 = local_64 - local_6c.x >> 0x1f,
														 (local_64 - local_6c.x ^ uVar7) - uVar7 != 1)))))) {
													local_24.x = local_6c.x;
													local_24.y = local_6c.y;
													BVar6 = game::LiveObject_FUN_00431ba0(local_90,&local_24,&local_6c,1);
													if (BVar6 == 0) {
														local_94 = (LiveObject *)BVar6;
													}
												}
												if (local_94 != NULL) {
													BVar4 = game::LiveObject_FUN_00440ef0
																						(pLVar8,local_64,local_60,local_6c.x,local_6c.y,
																						 &local_30,&local_38,local_14);
													if (BVar4 == 0) {
														aiTask->float_18 = 75.0;
													}
													else {
														std::free(local_30);
														std::free(local_38);
													}
												}
											}
										}
									}
									if (local_34 != 0) {
										local_5c = local_84;
										local_40 = local_74;
										local_3c = local_70;
										break;
									}
									pLVar9 = local_90;
									if (BVar4 != 0) {
										local_18 = local_70 - local_48;
										fVar11 = SQRT(local_18 * local_18 +
																	(local_74 - local_4c) * (local_74 - local_4c));
										game::LiveObject_GetFaceDirection(pLVar8,&local_8);
										if ((local_90 == NULL) || (fVar11 < local_44)) {
											local_5c = local_84;
											local_40 = local_74;
											local_3c = local_70;
											pLVar9 = pLVar8;
											local_90 = pLVar8;
											local_44 = fVar11;
										}
									}
								}
							}
						}
						pLVar8 = pLVar9;
						local_84 += 1;
						local_8c = local_8c + 1;
						pLVar9 = pLVar8;
					} while (local_84 < (uint)INT_004b4424);
				}
				if (pLVar8 == NULL) {
					if (((aiTask->flags_5c & 0x1000) == 0) && (uVar7 = 0, INT_004b4424 != 0)) {
						ppLVar10 = (LiveObject **)&DAT_004b435c;
						do {
							pLVar8 = *ppLVar10;
							if (pLVar8 != NULL) {
								if ((aiTask->flags_5c & 0x100) == 0) {
									BVar4 = game::Message_LiveObject_Check_IsSelected_OrFlags3_200000(pLVar8,NULL);
									if (BVar4 == 0) {
										if ((aiTask->flags_5c & 0x100) != 0) goto LAB_004060b6;
										goto LAB_004060cd;
									}
								}
								else {
LAB_004060b6:
									BVar4 = game::LiveObject_FindIndexOfInTable
																		((LiveObject **)aiTask->ptr_40,aiTask->field_44,pLVar8,NULL);
									if (BVar4 != 0) {
LAB_004060cd:
										BVar4 = AITask_FUN_00404ef0(aiTask,pLVar8,NULL,NULL,NULL,0,1);
										if (BVar4 != 0) {
											AITask_DoGetTool_FromTask(aiTask);
											break;
										}
									}
								}
							}
							uVar7 += 1;
							ppLVar10 = ppLVar10 + 1;
						} while (uVar7 < (uint)INT_004b4424);
					}
					if (((aiTask->taskType != AITASK_TRAIN) && (aiTask->mode_3c != 0)) &&
						 ((aiTask->flags_5c & 0x8000) == 0)) {
						uVar7 = 0;
						local_94 = NULL;
						bVar2 = false;
						if (INT_004b4424 != 0) {
							ppLVar10 = (LiveObject **)&DAT_004b435c;
							do {
								pLVar8 = *ppLVar10;
								if (pLVar8 != NULL) {
									if ((aiTask->flags_5c & 0x100) == 0) {
										BVar4 = game::Message_LiveObject_Check_IsSelected_OrFlags3_200000(pLVar8,NULL);
										if (BVar4 == 0) {
											if ((aiTask->flags_5c & 0x100) != 0) goto LAB_0040615f;
											goto LAB_00406176;
										}
									}
									else {
LAB_0040615f:
										BVar4 = game::LiveObject_FindIndexOfInTable
																			((LiveObject **)aiTask->ptr_40,aiTask->field_44,pLVar8,NULL);
										if (BVar4 != 0) {
LAB_00406176:
											BVar4 = AITask_FUN_00404ef0(aiTask,pLVar8,(float *)&local_2c,NULL,NULL,0,0);
											if ((BVar4 != 0) &&
												 (BVar4 = AITask_FUN_00404ef0(aiTask,pLVar8,(float *)&local_2c,NULL,NULL,0,1
																										 ), local_94 = pLVar8, BVar4 != 0)) {
												bVar2 = true;
												break;
											}
										}
									}
								}
								uVar7 += 1;
								ppLVar10 = ppLVar10 + 1;
							} while (uVar7 < (uint)INT_004b4424);
						}
						if (((local_94 != NULL) && (!bVar2)) &&
							 (pLVar8 = (LiveObject *)FUN_00439110(NULL,&local_2c,aiTask->mode_3c), pLVar8 != NULL)
							 ) {
							AITask_DoTrain_Target
												(pLVar8,aiTask->mode_3c,(uint)(aiTask->mode_3c != TRAINED_REPAIR));
							aiTask->flags_5c = aiTask->flags_5c | 0x8000;
						}
					}
				}
				else {
					bVar2 = true;
					game::LiveObject_GetBlockPos(pLVar8,&local_58,&local_54);
					piVar14 = &local_80.y;
					pPVar13 = &local_80;
					fVar11 = local_40;
					fVar12 = local_3c;
					pSVar5 = game::GetSurfaceMap();
					game::Map3D_WorldToBlockPos_NoZ(pSVar5,fVar11,fVar12,(int *)pPVar13,piVar14);
					AVar1 = aiTask->taskType;
					if (((((AVar1 == AITASK_CLEAR) || (AVar1 == AITASK_COLLECT)) ||
							 (AVar1 == AITASK_BUILDPATH)) || (AVar1 == AITASK_UPGRADE)) &&
						 ((local_58 != local_80.x || (local_54 != local_80.y)))) {
						if (aiTask->object_48 == NULL) {
							if (true) {
								switch(AVar1) {
								case AITASK_COLLECT:
									local_78 = MESSAGE_COLLECTCRYSTAL;
									break;
								case AITASK_CLEAR:
									local_78 = MESSAGE_CLEAR;
									break;
								case AITASK_UPGRADE:
									local_78 = MESSAGE_UPGRADE;
									break;
								case AITASK_BUILDPATH:
									local_78 = MESSAGE_BUILDPATH;
								}
							}
							game::Message_AddMessageAction(local_78,pLVar8,aiTask,&local_80);
							if ((aiTask->flags_5c & 0x100) == 0) {
								aiTask->object_48 = pLVar8;
							}
							if ((aiTask->taskType == AITASK_CLEAR) && (pLVar8->objType == OBJECT_VEHICLE)) {
								AITask_DoCallbacks_Block_FUN_00402a90(&aiTask->position,TRUE);
								aiTask->float_18 = 0.0;
							}
						}
LAB_00406042:
						bVar2 = false;
					}
					else {
						if ((((AVar1 == AITASK_DIG) && ((*(byte *)&aiTask->flags_5c & 8) == 0)) ||
								(((AVar1 == AITASK_REPAIR || (AVar1 == AITASK_REINFORCE)) ||
								 ((AVar1 == AITASK_TRAIN || (AVar1 == AITASK_GETTOOL)))))) &&
							 (((local_58 != local_80.x ||
								 (uVar7 = local_54 - local_80.y >> 0x1f,
								 (local_54 - local_80.y ^ uVar7) - uVar7 != 1)) &&
								((local_54 != local_80.y ||
								 (uVar7 = local_58 - local_80.x >> 0x1f,
								 (local_58 - local_80.x ^ uVar7) - uVar7 != 1)))))) {
							if (aiTask->object_48 == NULL) {
								if (true) {
									switch(AVar1) {
									case AITASK_DIG:
										local_88 = MESSAGE_DIG;
										break;
									case AITASK_REPAIR:
										local_88 = MESSAGE_REPAIR;
										break;
									case AITASK_REINFORCE:
										local_88 = MESSAGE_REINFORCE;
										break;
									case AITASK_GETTOOL:
										local_88 = MESSAGE_COLLECTTOOL;
										break;
									case AITASK_TRAIN:
										local_88 = MESSAGE_TRAIN;
									}
								}
								BVar4 = game::LiveObject_FUN_00431ba0(pLVar8,&local_80,&local_10,1);
								if (BVar4 == 0) {
									aiTask->priorityValue = aiTask->priorityValue - 1;
								}
								else {
									game::Message_AddMessageAction(local_88,pLVar8,aiTask,&local_10);
									if ((aiTask->flags_5c & 0x100) == 0) {
										aiTask->object_48 = pLVar8;
									}
								}
							}
							goto LAB_00406042;
						}
					}
					if (bVar2) {
						AITask_FUN_00406290(aiTask,local_50,pLVar8);
					}
					INT_004b4424 += -1;
					(&DAT_004b435c)[local_5c] = (&DAT_004b435c)[INT_004b4424];
				}
			}
			pAVar3 = aiTask->next;
			local_50 = aiTask;
		} while (aiTask->next != NULL);
	}
	return;
}



void __cdecl
lego::ai::AITask_FUN_00406290(AITaskData *aiTask1,AITaskData *aiTask2,LiveObject *liveObj)
{
	AITaskData *pAVar1;
	
	if ((*(byte *)&aiTask1->flags_5c & 0x40) == 0) {
		if (aiTask2 == NULL) {
			globals::g_AITaskUnkPtr = aiTask1->next;
		}
		else {
			aiTask2->next = aiTask1->next;
		}
		aiTask1->next = NULL;
		liveObj->aitask_2f0 = aiTask1;
	}
	else {
		pAVar1 = AITask_FUN_00406330(aiTask1);
		liveObj->aitask_2f0 = pAVar1;
		if ((aiTask1->flags_5c & 0x40000) != 0) {
			aiTask1->float_18 = 25.0;
		}
	}
	AITask_LiveObject_ReleaseTaskReferences(liveObj);
	front::Bubble_LiveObject_MiniFigure_FUN_00407380(liveObj);
	return;
}



void __cdecl lego::ai::AITask_LiveObject_ReleaseTaskReferences(LiveObject *liveObj)
{
	AITaskData **ppAVar1;
	AITaskData *pAVar2;
	
	pAVar2 = globals::g_AITaskUnkPtr;
	if (globals::g_AITaskUnkPtr != NULL) {
		do {
			if (pAVar2->object_48 == liveObj) {
				pAVar2->object_48 = NULL;
			}
			ppAVar1 = &pAVar2->next;
			pAVar2 = *ppAVar1;
		} while (*ppAVar1 != NULL);
	}
	return;
}



AITaskData * __cdecl lego::ai::AITask_FUN_00406330(AITaskData *aiTask)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	int iVar3;
	AITaskData *pAVar4;
	
	pAVar2 = AITask_Create(aiTask->taskType);
	pAVar1 = pAVar2->pool_m_next;
	pAVar4 = pAVar2;
	for (iVar3 = 0x1a; iVar3 != 0; iVar3 += -1) {
		pAVar4->taskType = aiTask->taskType;
		aiTask = (AITaskData *)&aiTask->field_4;
		pAVar4 = (AITaskData *)&pAVar4->field_4;
	}
	pAVar2->pool_m_next = pAVar1;
	pAVar2->flags_5c = pAVar2->flags_5c | 0x200;
	pAVar2->next = NULL;
	return pAVar2;
}



AITaskData * __cdecl lego::ai::AITask_Create(AITaskType taskType)
{
	AITaskData *pAVar1;
	uint uVar2;
	int iVar3;
	AITaskData *pAVar4;
	
	if (pool::globals::ReservedPool_AITask___g_NEXT == NULL) {
		AITask_AddList();
	}
	pAVar1 = pool::globals::ReservedPool_AITask___g_NEXT;
	pAVar4 = pool::globals::ReservedPool_AITask___g_NEXT;
	pool::globals::ReservedPool_AITask___g_NEXT =
			 pool::globals::ReservedPool_AITask___g_NEXT->pool_m_next;
	for (iVar3 = 0x1a; iVar3 != 0; iVar3 += -1) {
		pAVar4->taskType = AITASK_GOTO;
		pAVar4 = (AITaskData *)&pAVar4->field_4;
	}
	pAVar1->pool_m_next = pAVar1;
	uVar2 = main::Main_GetTime();
	pAVar1->taskStartTime = uVar2;
	pAVar1->taskType = taskType;
	return pAVar1;
}



void __cdecl lego::ai::AITask_Remove(AITaskData *aiTask,BOOL noRelease2)
{
	if (noRelease2 == 0) {
		AITask_Release_2(aiTask);
	}
	if ((aiTask->ptr_40 != NULL) && ((aiTask->flags_5c & 0x200) == 0)) {
		std::free(aiTask->ptr_40);
	}
	aiTask->pool_m_next = pool::globals::ReservedPool_AITask___g_NEXT;
	pool::globals::ReservedPool_AITask___g_NEXT = aiTask;
	return;
}



void __cdecl lego::ai::AITask_AddList(void)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)pool::globals::ReservedPool_AITask___g_COUNT & 0x1f);
	pAVar2 = (AITaskData *)std::malloc(uVar4 * 0x68);
	pool::globals::ReservedPool_AITask___g_TABLE[pool::globals::ReservedPool_AITask___g_COUNT] =
			 pAVar2;
	pAVar2 = pool::globals::ReservedPool_AITask___g_TABLE
					 [pool::globals::ReservedPool_AITask___g_COUNT];
	if (pAVar2 != NULL) {
		pool::globals::ReservedPool_AITask___g_COUNT += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pAVar1 = pAVar2;
			do {
				pAVar1->pool_m_next = pAVar1 + 1;
				iVar3 += -1;
				pAVar1 = pAVar1 + 1;
			} while (iVar3 != 0);
		}
		pAVar2[uVar4 - 1].pool_m_next = pool::globals::ReservedPool_AITask___g_NEXT;
		pool::globals::ReservedPool_AITask___g_NEXT = pAVar2;
	}
	return;
}



BOOL __cdecl lego::ai::AITask_DoUnkCallbacks(undefined *taskFunction,LiveObject *liveObj)
{
	int iVar1;
	int iVar2;
	AITaskData **ppAVar3;
	uint uVar4;
	uint uVar5;
	uint local_4;
	
	local_4 = 0;
	if (pool::globals::ReservedPool_AITask___g_COUNT == 0) {
		return 0;
	}
	ppAVar3 = pool::globals::ReservedPool_AITask___g_TABLE;
	do {
		if (*ppAVar3 != NULL) {
			uVar5 = 0;
			uVar4 = 1 << ((byte)local_4 & 0x1f);
			if (uVar4 != 0) {
				iVar2 = 0;
				do {
					iVar1 = (int)&(*ppAVar3)->taskType + iVar2;
					if (((iVar1 != 0) && (*(int *)(iVar1 + 100) == iVar1)) &&
						 (iVar1 = (*(code *)taskFunction)(iVar1,liveObj), iVar1 != 0)) {
						return TRUE;
					}
					uVar5 += 1;
					iVar2 += 0x68;
				} while (uVar5 < uVar4);
			}
		}
		local_4 += 1;
		ppAVar3 = ppAVar3 + 1;
		if (pool::globals::ReservedPool_AITask___g_COUNT <= local_4) {
			return 0;
		}
	} while( true );
}



IDirectDraw4 * __cdecl lego::ddraw::DirectDraw(void)
{
	return globs::directDrawGlobs.lpDirectDraw;
}



IDirectDrawSurface4 * __cdecl lego::ddraw::DirectDraw_bSurf(void)
{
	return globs::directDrawGlobs.bSurf;
}



void __cdecl
lego::math::Routing_Maths_Vector2D_FUN_00406520
					(Point2F *out_point,Point2F *param_2,Point2F *param_3,Point2F *param_4,Point2F *param_5,
					float scalar)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	
	fVar1 = param_3->x * 3.0 + param_2->x;
	fVar5 = scalar * scalar;
	fVar4 = (fVar1 - param_2->x) * 3.0;
	fVar3 = ((param_4->x - param_5->x * 3.0) - fVar1) * 3.0 - fVar4;
	fVar1 = param_5->y;
	fVar6 = param_3->y * 3.0 + param_2->y;
	fVar2 = param_4->y;
	out_point->x = fVar4 * scalar +
								 fVar3 * fVar5 + (((param_4->x - param_2->x) - fVar4) - fVar3) * fVar5 * scalar +
								 param_2->x;
	fVar3 = (fVar6 - param_2->y) * 3.0;
	fVar1 = ((fVar2 - fVar1 * 3.0) - fVar6) * 3.0 - fVar3;
	out_point->y = fVar1 * fVar5 +
								 fVar3 * scalar + (((param_4->y - param_2->y) - fVar3) - fVar1) * fVar5 * scalar +
								 param_2->y;
	return;
}



// sqrt(((a.x-b.x)*(a.x-b.x)) + ((a.y-b.y)*(a.y-b.y)))

float10 __cdecl lego::math::Routing_Maths_Vector2DDistance(Point2F *a,Point2F *b)
{
	float10 diff_x;
	float10 diff_y;
	
	diff_x = (float10)a->x - (float10)b->x;
	diff_y = (float10)a->y - (float10)b->y;
	return SQRT(diff_y * diff_y + diff_x * (float10)(float)diff_x);
}



// ref_point = norm(ref_point) * newLength
// NOTE: Unlike `Maths_Vector2DSetLength`, this function modifies the input point.

Point2F * __cdecl lego::math::Routing_Maths_Vector2DChangeLength(Point2F *ref_point,float newLength)
{
	float fVar1;
	
	fVar1 = SQRT(ref_point->x * ref_point->x + ref_point->y * ref_point->y) / newLength;
	ref_point->x = ref_point->x / fVar1;
	ref_point->y = ref_point->y / fVar1;
	return ref_point;
}



float10 __cdecl lego::game::Routing_UpdateDistances_RetTotal(RoutingData *route)
{
	RoutingData *pRVar1;
	uint index;
	float *curValue;
	float10 fVar2;
	float totalDist;
	
	index = 1;
	totalDist = 0.0;
	route->distances[0] = 0.0;
	if (1 < route->count) {
		curValue = route->distances;
		pRVar1 = route;
		do {
			curValue = curValue + 1;
			fVar2 = math::Routing_Maths_Vector2DDistance(pRVar1->points,pRVar1->points + 1);
			*curValue = (float)fVar2;
			index += 1;
			totalDist = (float)(fVar2 + (float10)totalDist);
			pRVar1 = (RoutingData *)&pRVar1->points[0].y;
		} while (index < route->count);
	}
	return (float10)totalDist;
}



void __cdecl
lego::game::Routing_DoMath_FUN_00406750
					(RoutingData *route,Point2F *a,Point2F *b,Point2F *c,Point2F *d,uint count)
{
	uint index;
	Point2F *curPoint;
	
	if (49 < count) {
		count = 50;
	}
	index = 1;
	route->count = count;
	route->points[0].x = a->x;
	route->points[0].y = a->y;
	if (1 < count) {
		curPoint = route->points;
		do {
			curPoint = curPoint + 1;
			math::Routing_Maths_Vector2D_FUN_00406520
								(curPoint,a,b,c,d,(float)(ulonglong)index * (1.0 / (float)(ulonglong)(count - 1)));
			index += 1;
		} while (index < count);
	}
	return;
}



uint __cdecl
lego::game::Routing_Calculate_FUN_004067f0(RoutingData *route,float scalar,Point2F *out_point)
{
	float fVar1;
	float fVar2;
	float fVar3;
	uint index;
	float *pfVar4;
	uint count;
	
	fVar3 = 0.0;
	count = route->count;
	index = 1;
	if (1 < count) {
		pfVar4 = route->distances;
		do {
			pfVar4 = pfVar4 + 1;
			fVar3 = fVar3 + *pfVar4;
			if (scalar < fVar3) break;
			index += 1;
		} while (index < count);
	}
	if (index < count) {
		out_point->x = route->points[index - 1].x;
		out_point->y = route->points[index - 1].y;
		fVar1 = route->points[index].y;
		fVar2 = route->points[index - 1].y;
		fVar3 = (scalar - (fVar3 - route->distances[index])) / route->distances[index];
		out_point->x = (route->points[index].x - route->points[index - 1].x) * fVar3 +
									 route->points[index - 1].x;
		out_point->y = (fVar1 - fVar2) * fVar3 + route->points[index - 1].y;
		return index;
	}
	out_point->x = route->points[index - 1].x;
	out_point->y = route->points[index - 1].y;
	return index;
}



BOOL __cdecl lego::res::Creature_IsCameraFlipDir(CreatureData *creature)
{
	return (uint)(creature->CameraFlipDir == BOOL3_TRUE);
}



BOOL __cdecl
lego::res::Creature_LoadActivityFile
					(CreatureData *creature,int objIndex,Container *resRoot,char *aeFilename,char *rootName)
{
	char cVar1;
	CFGProperty *prop;
	Container *pCVar2;
	char *pcVar3;
	BOOL3 BVar4;
	PolyMeshData *pPVar5;
	uint uVar6;
	uint uVar7;
	char **ppcVar8;
	int iVar9;
	undefined4 *puVar10;
	char *pcVar11;
	undefined4 *puVar12;
	BOOL result;
	char *stringParts [100];
	char buffName [1024];
	char buffPath [1024];
	
	uVar6 = 0xffffffff;
	pcVar3 = aeFilename;
	do {
		pcVar11 = pcVar3;
		if (uVar6 == 0) break;
		uVar6 -= 1;
		pcVar11 = pcVar3 + 1;
		cVar1 = *pcVar3;
		pcVar3 = pcVar11;
	} while (cVar1 != '\0');
	uVar6 = ~uVar6;
	puVar10 = (undefined4 *)(pcVar11 + -uVar6);
	puVar12 = (undefined4 *)buffName;
	for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
		*puVar12 = *puVar10;
		puVar10 = puVar10 + 1;
		puVar12 = puVar12 + 1;
	}
	result = 0;
	for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
		*(undefined *)puVar12 = *(undefined *)puVar10;
		puVar10 = (undefined4 *)((int)puVar10 + 1);
		puVar12 = (undefined4 *)((int)puVar12 + 1);
	}
	uVar6 = util::Util_Tokenise(buffName,stringParts,"\\");
	if (1 < uVar6) {
		ppcVar8 = stringParts;
		iVar9 = uVar6 - 1;
		do {
			ppcVar8 = ppcVar8 + 1;
			iVar9 += -1;
			(*ppcVar8)[-1] = '\\';
		} while (iVar9 != 0);
	}
	std::sprintf(buffPath,"%s\\%s.%s",buffName,stringParts[uVar6 - 1],"ae");
	prop = cfg::CFG_Open(buffPath);
	if (prop != NULL) {
		pCVar2 = Container_Load(resRoot,aeFilename,"ACT",TRUE);
		creature->contAct = pCVar2;
		if (pCVar2 != NULL) {
			pcVar3 = cfg::CFG_JoinPath(rootName,"CameraNullName",0);
			pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
			creature->CameraNullName = pcVar3;
			if (pcVar3 == NULL) {
				creature->CameraNullFrames = 0;
			}
			else {
				pcVar3 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
				pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
				if (pcVar3 == NULL) {
					pcVar3 = ____EMPTYSTR__;
				}
				else {
					pcVar3 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
					pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
				}
				uVar6 = std::atoi(pcVar3);
				creature->CameraNullFrames = uVar6;
				pcVar3 = cfg::CFG_JoinPath(rootName,"CameraFlipDir",0);
				BVar4 = cfg::CFG_ReadBool(prop,pcVar3);
				creature->CameraFlipDir = BVar4;
			}
			pcVar3 = cfg::CFG_JoinPath(rootName,"DrillNullName",0);
			pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
			creature->DrillNullName = pcVar3;
			pcVar3 = cfg::CFG_JoinPath(rootName,"FootStepNullName",0);
			pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
			creature->FootStepNullName = pcVar3;
			pcVar3 = cfg::CFG_JoinPath(rootName,"CarryNullName",0);
			pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
			creature->CarryNullName = pcVar3;
			pcVar3 = cfg::CFG_JoinPath(rootName,"ThrowNullName",0);
			pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
			creature->ThrowNullName = pcVar3;
			pcVar3 = cfg::CFG_JoinPath(rootName,"DepositNullName",0);
			pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
			creature->DepositNullName = pcVar3;
			creature->objIndex = objIndex;
			pPVar5 = Res_LoadPolyMesh(prop,rootName,aeFilename,POLY_MEDIUM,1);
			creature->polyMedium = pPVar5;
			pPVar5 = Res_LoadPolyMesh(prop,rootName,aeFilename,POLY_HIGH,1);
			creature->polyHigh = pPVar5;
			pPVar5 = Res_LoadPolyMesh(prop,rootName,aeFilename,POLY_FP,creature->CameraNullFrames);
			creature->polyFP = pPVar5;
			creature->flags = 1;
			result = 1;
		}
		cfg::CFG_Close(prop);
	}
	return result;
}



void __cdecl lego::res::Creature_SwapPolyMedium(CreatureData *creature,BOOL swap)
{
	MeshPoly_Container_SwapFrame(creature->polyMedium,creature->contAct,(uint)(swap == 0),0);
	return;
}



void __cdecl lego::res::Creature_SwapPolyHigh(CreatureData *creature,BOOL swap)
{
	MeshPoly_Container_SwapFrame(creature->polyHigh,creature->contAct,(uint)(swap == 0),0);
	return;
}



void __cdecl lego::res::Creature_SwapPolyFP(CreatureData *creature,BOOL swap,int cameraFrameIndex)
{
	MeshPoly_Container_SwapFrame
						(creature->polyFP,creature->contAct,(uint)(swap == 0),cameraFrameIndex);
	return;
}



void __cdecl lego::res::Object_HideAll(BasicObjectData *basicObjData,BOOL hide)
{
	Container_Hide(basicObjData->aeResData,hide);
	return;
}



void __cdecl lego::res::Creature_Duplicate(CreatureData *in_creature,CreatureData *out_creature)
{
	PolyMeshData *pPVar1;
	Container *pCVar2;
	int iVar3;
	CreatureData *pCVar4;
	CreatureData *pCVar5;
	
	pCVar4 = in_creature;
	pCVar5 = out_creature;
	for (iVar3 = 0x1d; iVar3 != 0; iVar3 += -1) {
		pCVar5->objIndex = pCVar4->objIndex;
		pCVar4 = (CreatureData *)&pCVar4->contAct;
		pCVar5 = (CreatureData *)&pCVar5->contAct;
	}
	out_creature->flags = out_creature->flags & 0xfffffffe;
	pPVar1 = MeshPoly_Duplicate(in_creature->polyMedium);
	out_creature->polyMedium = pPVar1;
	pPVar1 = MeshPoly_Duplicate(in_creature->polyHigh);
	out_creature->polyHigh = pPVar1;
	pPVar1 = MeshPoly_Duplicate(in_creature->polyFP);
	out_creature->polyFP = pPVar1;
	pCVar2 = Container_Clone(in_creature->contAct);
	out_creature->contAct = pCVar2;
	return;
}



void __cdecl lego::res::Creature_DoCallbacks(CreatureData *creature,float elapsed)
{
	Container_SetAnimationTime(creature->contAct,elapsed);
	return;
}



float10 __cdecl lego::res::Creature_FUN_00406c60(CreatureData *creature,float elapsed,uint param_3)
{
	float fVar1;
	uint uVar2;
	float10 fVar3;
	
	fVar3 = Container_MoveAnimation(creature->contAct,elapsed);
	fVar1 = (float)fVar3;
	if ((1 < param_3) && (fVar1 != 0.0)) {
		uVar2 = Container_GetAnimationFrames(creature->contAct);
		return (float10)fVar1 - (float10)(ulonglong)(uVar2 * (param_3 - 1));
	}
	return (float10)fVar1;
}



float10 __cdecl lego::res::Creature_GetAnimFloat10(CreatureData *creature)
{
	float10 fVar1;
	
	fVar1 = Container_GetAnimationTime(creature->contAct);
	return fVar1;
}



void __cdecl lego::res::Creature_SetOrientation(CreatureData *creature,float x,float y)
{
	Container_SetOrientation(creature->contAct,NULL,x,y,0.0,0.0,0.0,-1.0);
	return;
}



void __cdecl
lego::res::Creature_SetPosition
					(CreatureData *creature,float x,float y,GetSurfaceZCallback *getZcallback,
					SurfaceMap *surfMap)
{
	float10 fVar1;
	
	fVar1 = (*getZcallback)(x,y,surfMap);
	Container_SetPosition(creature->contAct,NULL,x,y,(float)fVar1);
	return;
}



Container * __cdecl lego::res::Object_GetActivityContainer(BasicObjectData *basicObjData)
{
	return basicObjData->aeResData;
}



BOOL __cdecl
lego::res::Creature_SetActivity_AndRemoveCarryCameraFrames
					(CreatureData *creature,char *activityName,float elapsed)
{
	uint uVar1;
	BOOL BVar2;
	Container **ppCVar3;
	
	MeshPoly_FUN_00451ef0(creature->polyMedium);
	MeshPoly_FUN_00451ef0(creature->polyHigh);
	MeshPoly_FUN_00451ef0(creature->polyFP);
	uVar1 = 0;
	creature->field_40 = 0;
	creature->field_44 = 0;
	creature->cont_48 = NULL;
	creature->cont_4c = NULL;
	creature->field_50 = 0;
	if (creature->CameraNullFrames != 0) {
		ppCVar3 = creature->cameraFramesTable_54;
		do {
			*ppCVar3 = NULL;
			uVar1 += 1;
			ppCVar3 = ppCVar3 + 1;
		} while (uVar1 < creature->CameraNullFrames);
	}
	BVar2 = Container_SetActivity(creature->contAct,activityName);
	Container_SetAnimationTime(creature->contAct,elapsed);
	return BVar2;
}



void __cdecl lego::res::Creature_Destroy(CreatureData *creature)
{
	MeshPoly_Destroy(creature->polyMedium);
	MeshPoly_Destroy(creature->polyHigh);
	MeshPoly_Destroy(creature->polyFP);
	if ((*(byte *)&creature->flags & 1) != 0) {
		if (creature->DrillNullName != NULL) {
			std::free(creature->DrillNullName);
		}
		if (creature->FootStepNullName != NULL) {
			std::free(creature->FootStepNullName);
		}
		if (creature->CameraNullName != NULL) {
			std::free(creature->CameraNullName);
		}
		if (creature->CarryNullName != NULL) {
			std::free(creature->CarryNullName);
		}
		if (creature->ThrowNullName != NULL) {
			std::free(creature->ThrowNullName);
		}
	}
	Container_Remove(creature->contAct);
	return;
}



Container * __cdecl
lego::res::Object_SearchForPartName(BasicObjectData *basicObjData,char *name,int instance)
{
	char *name_00;
	Container *pCVar1;
	
	name_00 = Container_FormatPartName(basicObjData->aeResData,name,&instance);
	pCVar1 = Container_SearchTree
										 (basicObjData->aeResData,name_00,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
	return pCVar1;
}



Container * __cdecl lego::res::Creature_GetCameraNull(CreatureData *creature,int cameraIndex)
{
	Container *pCVar1;
	
	pCVar1 = (Container *)creature->CameraNullName;
	if (pCVar1 != NULL) {
		if (creature->cameraFramesTable_54[cameraIndex] == NULL) {
			pCVar1 = Object_SearchForPartName((BasicObjectData *)creature,pCVar1,cameraIndex);
			creature->cameraFramesTable_54[cameraIndex] = pCVar1;
		}
		pCVar1 = creature->cameraFramesTable_54[cameraIndex];
	}
	return pCVar1;
}



Container * __cdecl lego::res::Creature_GetDrillNull(CreatureData *creature)
{
	Container *pCVar1;
	
	pCVar1 = (Container *)creature->field_40;
	if (pCVar1 == NULL) {
		if (creature->DrillNullName != NULL) {
			pCVar1 = Object_SearchForPartName((BasicObjectData *)creature,creature->DrillNullName,0);
			creature->field_40 = pCVar1;
			return pCVar1;
		}
		pCVar1 = NULL;
	}
	return pCVar1;
}



Container * __cdecl lego::res::Creature_GetCarryNull(CreatureData *creature)
{
	Container *pCVar1;
	
	if (creature->CarryNullName == NULL) {
		pCVar1 = NULL;
	}
	else {
		pCVar1 = creature->cont_48;
		if (pCVar1 == NULL) {
			pCVar1 = Object_SearchForPartName((BasicObjectData *)creature,creature->CarryNullName,0);
			creature->cont_48 = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Creature_GetDepositNull(CreatureData *creature)
{
	Container *pCVar1;
	
	if (creature->DepositNullName == NULL) {
		pCVar1 = NULL;
	}
	else {
		pCVar1 = (Container *)creature->field_50;
		if (pCVar1 == NULL) {
			pCVar1 = Object_SearchForPartName((BasicObjectData *)creature,creature->DepositNullName,0);
			creature->field_50 = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



BOOL __cdecl lego::res::Creature_GetThrowNull(CreatureData *creature)
{
	Container *contNull;
	float10 fVar1;
	
	if ((creature->cont_4c == NULL) && (creature->ThrowNullName != NULL)) {
		contNull = Object_SearchForPartName((BasicObjectData *)creature,creature->ThrowNullName,0);
		creature->cont_4c = contNull;
	}
	if (creature->cont_4c != NULL) {
		fVar1 = Container_GetZXRatio(creature->cont_4c);
		if (fVar1 != (float10)1.0) {
			return TRUE;
		}
	}
	return 0;
}



float10 __cdecl lego::game::Creature_GetTransCoef(CreatureData *creature)
{
	float10 fVar1;
	
	fVar1 = res::Container_GetTransCoef(creature->contAct);
	return fVar1;
}



void __cdecl lego::front::Bubble_Initialise(void)
{
	globals::g_Bubbles_TABLE[0] = "Bubble_CantDo";
	globals::g_Bubbles_TABLE[1] = "Bubble_Idle";
	globals::g_Bubbles_TABLE[2] = "Bubble_CollectCrystal";
	globals::g_Bubbles_TABLE[3] = "Bubble_CollectOre";
	globals::g_Bubbles_TABLE[4] = "Bubble_CollectStud";
	globals::g_Bubbles_TABLE[5] = "Bubble_CollectDynamite";
	globals::g_Bubbles_TABLE[6] = "Bubble_CollectBarrier";
	globals::g_Bubbles_TABLE[7] = "Bubble_CollectElecFence";
	globals::g_Bubbles_TABLE[8] = "Bubble_CollectDrill";
	globals::g_Bubbles_TABLE[9] = "Bubble_CollectSpade";
	globals::g_Bubbles_TABLE[10] = "Bubble_CollectHammer";
	globals::g_Bubbles_TABLE[11] = "Bubble_CollectSpanner";
	globals::g_Bubbles_TABLE[12] = "Bubble_CollectLaser";
	globals::g_Bubbles_TABLE[13] = "Bubble_CollectPusher";
	globals::g_Bubbles_TABLE[14] = "Bubble_CollectFreezer";
	globals::g_Bubbles_TABLE[15] = "Bubble_CollectBirdScarer";
	globals::g_Bubbles_TABLE[16] = "Bubble_CarryCrystal";
	globals::g_Bubbles_TABLE[17] = "Bubble_CarryOre";
	globals::g_Bubbles_TABLE[18] = "Bubble_CarryStud";
	globals::g_Bubbles_TABLE[19] = "Bubble_CarryDynamite";
	globals::g_Bubbles_TABLE[20] = "Bubble_CarryBarrier";
	globals::g_Bubbles_TABLE[21] = "Bubble_CarryElecFence";
	globals::g_Bubbles_TABLE[22] = "Bubble_Goto";
	globals::g_Bubbles_TABLE[23] = "Bubble_Dynamite";
	globals::g_Bubbles_TABLE[24] = "Bubble_Reinforce";
	globals::g_Bubbles_TABLE[25] = "Bubble_Drill";
	globals::g_Bubbles_TABLE[26] = "Bubble_Repair";
	globals::g_Bubbles_TABLE[27] = "Bubble_Dig";
	globals::g_Bubbles_TABLE[28] = "Bubble_Flee";
	globals::g_Bubbles_TABLE[29] = "Bubble_PowerOff";
	globals::g_Bubbles_TABLE[30] = "Bubble_CallToArms";
	globals::g_Bubbles_TABLE[31] = "Bubble_ElecFence";
	globals::g_Bubbles_TABLE[32] = "Bubble_Eat";
	globals::g_Bubbles_TABLE[33] = "Bubble_Drive";
	globals::g_Bubbles_TABLE[34] = "Bubble_Upgrade";
	globals::g_Bubbles_TABLE[35] = "Bubble_BuildPath";
	globals::g_Bubbles_TABLE[36] = "Bubble_Train";
	globals::g_Bubbles_TABLE[37] = "Bubble_Recharge";
	globals::g_Bubbles_TABLE[38] = "Bubble_Request";
	return;
}



void __cdecl lego::front::Bubble_LoadBubbles(CFGProperty *root)
{
	char cVar1;
	bool bVar2;
	char *pcVar3;
	CFGProperty *prop;
	BubbleType BVar4;
	ImageBMP *image;
	int iVar5;
	char *pcVar6;
	
	pcVar3 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Bubbles",0);
	prop = cfg::CFG_GetChildren(root,pcVar3);
	do {
		if (prop == NULL) {
			return;
		}
		pcVar3 = prop->key;
		bVar2 = true;
		if (pcVar3 != NULL) {
			iVar5 = -1;
			pcVar6 = pcVar3;
			do {
				if (iVar5 == 0) break;
				iVar5 += -1;
				cVar1 = *pcVar6;
				pcVar6 = pcVar6 + 1;
			} while (cVar1 != '\0');
			if ((iVar5 != -2) && (*pcVar3 == '!')) {
				if ((globs::mainGlobs.flags & CMD_REDUCEIMAGES) == CMD_NONE) {
					pcVar3 = pcVar3 + 1;
				}
				else {
					bVar2 = false;
				}
			}
		}
		if (bVar2) {
			BVar4 = Bubble_GetBubbleType(pcVar3);
			image = lego::image::Image_LoadBMPScaled(prop->value,0,0);
			globals::g_Bubbles_bmp_TABLE[BVar4] = image;
			if (image != NULL) {
				lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
			}
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



BubbleType __cdecl lego::front::Bubble_GetBubbleType(char *bubbleName)
{
	BubbleType BVar1;
	char **ppcVar2;
	BubbleType BVar3;
	
	BVar3 = BUBBLE_CANTDO;
	ppcVar2 = globals::g_Bubbles_TABLE;
	do {
		BVar1 = std::_stricmp(*ppcVar2,bubbleName);
		if (BVar1 == BUBBLE_CANTDO) {
			return BVar3;
		}
		ppcVar2 = ppcVar2 + 1;
		BVar3 += BUBBLE_IDLE;
	} while ((int)ppcVar2 < 0x55899c);
	return BVar1;
}



void __cdecl lego::front::Bubble_ToggleObjectUIsAlwaysVisible(void)
{
	globals::g_ObjectUIsAlwaysVisible = (uint)(globals::g_ObjectUIsAlwaysVisible == 0);
	return;
}



BOOL __cdecl lego::front::Bubble_GetObjectUIsAlwaysVisible(void)
{
	return globals::g_ObjectUIsAlwaysVisible;
}



void __cdecl lego::front::Bubble_LiveObject_UpdateBubbleImage(LiveObject *liveObj)
{
	if (globals::g_ObjectUIsAlwaysVisible != 0) {
		liveObj->field_388 = 0;
		Bubble_LiveObject_GetCurrentBubbleImage(liveObj,&liveObj->bubbleImage_38c);
	}
	return;
}



void __cdecl lego::front::Bubble_LiveObject_FUN_004072d0(LiveObject *liveObj)
{
	Struct_8__00558bc4 *pSVar1;
	
	pSVar1 = TABLE_50__Struct_8__00558bc4__005589e4;
	do {
		if (liveObj == pSVar1->object_0) {
			pSVar1->object_0 = NULL;
		}
		pSVar1 = pSVar1 + 1;
	} while (pSVar1 < TABLE_50__Struct_8__00558bc4__00558a84);
	pSVar1 = TABLE_50__Struct_8__00558bc4__00558a84;
	do {
		if (liveObj == pSVar1->object_0) {
			pSVar1->object_0 = NULL;
		}
		pSVar1 = pSVar1 + 1;
	} while (pSVar1 < TABLE_50__Struct_8__00558bc4__00558b24);
	pSVar1 = TABLE_50__Struct_8__00558bc4__00558b24;
	do {
		if (liveObj == pSVar1->object_0) {
			pSVar1->object_0 = NULL;
		}
		pSVar1 = pSVar1 + 1;
	} while (pSVar1 < TABLE_50__Struct_8__00558bc4__00558bc4);
	pSVar1 = TABLE_50__Struct_8__00558bc4__00558bc4;
	do {
		if (liveObj == pSVar1->object_0) {
			pSVar1->object_0 = NULL;
		}
		pSVar1 = pSVar1 + 1;
	} while (pSVar1 < (Struct_8__00558bc4 *)&DAT_00558d54);
	return;
}



void __cdecl lego::front::Bubble_LiveObject_FUN_00407340(LiveObject *liveObj)
{
	Struct_8__00558bc4 *pSVar1;
	int iVar2;
	
	if (liveObj->objType == OBJECT_BUILDING) {
		iVar2 = 0;
		pSVar1 = TABLE_50__Struct_8__00558bc4__00558b24;
		do {
			if (liveObj == pSVar1->object_0) break;
			pSVar1 = pSVar1 + 1;
			iVar2 += 1;
		} while (pSVar1 < TABLE_50__Struct_8__00558bc4__00558bc4);
		if (iVar2 == 0x14) {
			pSVar1 = TABLE_50__Struct_8__00558bc4__00558b24;
			while (pSVar1->object_0 != NULL) {
				pSVar1 = pSVar1 + 1;
				if ((Struct_8__00558bc4 *)((int)&TABLE_50__Struct_8__00558bc4__00558b24[0x13].float_4 + 3U)
						< pSVar1) {
					return;
				}
			}
			pSVar1->object_0 = liveObj;
		}
	}
	return;
}



void __cdecl lego::front::Bubble_LiveObject_MiniFigure_FUN_00407380(LiveObject *liveObj)
{
	Struct_8__00558bc4 *pSVar1;
	int iVar2;
	Struct_8__00558bc4 *pSVar3;
	
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		iVar2 = 0;
		pSVar1 = TABLE_50__Struct_8__00558bc4__00558a84;
		do {
			pSVar3 = pSVar1;
			if (liveObj == pSVar3->object_0) break;
			iVar2 += 1;
			pSVar1 = pSVar3 + 1;
		} while (pSVar3 + 1 < TABLE_50__Struct_8__00558bc4__00558b24);
		if (iVar2 == 0x14) {
			iVar2 = 0;
			pSVar1 = TABLE_50__Struct_8__00558bc4__00558a84;
			do {
				pSVar3 = pSVar1;
				if (pSVar3->object_0 == NULL) {
					pSVar3->object_0 = liveObj;
					break;
				}
				iVar2 += 1;
				pSVar1 = pSVar3 + 1;
			} while (pSVar3 + 1 < TABLE_50__Struct_8__00558bc4__00558b24);
			if (iVar2 == 0x14) {
				return;
			}
		}
		pSVar3->float_4 = 12.5;
	}
	return;
}



void __cdecl lego::front::Bubble_LiveObject_MiniFIgure_FUN_004073e0(LiveObject *liveObj)
{
	Struct_8__00558bc4 *pSVar1;
	int iVar2;
	Struct_8__00558bc4 *pSVar3;
	
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		iVar2 = 0;
		pSVar1 = TABLE_50__Struct_8__00558bc4__00558bc4;
		do {
			pSVar3 = pSVar1;
			if (liveObj == pSVar3->object_0) break;
			iVar2 += 1;
			pSVar1 = pSVar3 + 1;
		} while (pSVar3 + 1 < (Struct_8__00558bc4 *)&DAT_00558d54);
		if (iVar2 == 50) {
			iVar2 = 0;
			pSVar1 = TABLE_50__Struct_8__00558bc4__00558bc4;
			do {
				pSVar3 = pSVar1;
				if (pSVar3->object_0 == NULL) {
					pSVar3->object_0 = liveObj;
					break;
				}
				iVar2 += 1;
				pSVar1 = pSVar3 + 1;
			} while (pSVar3 + 1 < (Struct_8__00558bc4 *)&DAT_00558d54);
			if (iVar2 == 50) {
				return;
			}
		}
		pSVar3->float_4 = 2250000.0;
	}
	return;
}



void __cdecl
lego::front::Bubble_LiveObject_MiniFigure_FUN_00407440(LiveObject *liveObj,float param_2)
{
	float *pfVar1;
	
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		pfVar1 = &TABLE_50__Struct_8__00558bc4__00558bc4[0].float_4;
		do {
			if (pfVar1[-1] != 0.0) {
				*pfVar1 = param_2;
			}
			pfVar1 = pfVar1 + 2;
		} while (pfVar1 < &DAT_00558d58);
	}
	return;
}



void __cdecl lego::front::Bubble_LiveObject_FUN_00407470(LiveObject *liveObj)
{
	Struct_8__00558bc4 *pSVar1;
	ObjectStatsFlags3 OVar2;
	int iVar3;
	Struct_8__00558bc4 *pSVar4;
	
	OVar2 = game::LiveObject_GetStatsFlags3(liveObj);
	if ((OVar2 & STATS3_SHOWHEALTHBAR) != STATS3_NONE) {
		iVar3 = 0;
		pSVar1 = TABLE_50__Struct_8__00558bc4__005589e4;
		do {
			pSVar4 = pSVar1;
			if (liveObj == pSVar4->object_0) break;
			iVar3 += 1;
			pSVar1 = pSVar4 + 1;
		} while (pSVar4 + 1 < TABLE_50__Struct_8__00558bc4__00558a84);
		if (iVar3 == 0x14) {
			iVar3 = 0;
			pSVar1 = TABLE_50__Struct_8__00558bc4__005589e4;
			do {
				pSVar4 = pSVar1;
				if (pSVar4->object_0 == NULL) {
					pSVar4->object_0 = liveObj;
					break;
				}
				iVar3 += 1;
				pSVar1 = pSVar4 + 1;
			} while (pSVar4 + 1 < TABLE_50__Struct_8__00558bc4__00558a84);
			if (iVar3 == 0x14) {
				return;
			}
		}
		pSVar4->float_4 = 37.5;
	}
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl lego::front::Bubble_Unk_DrawObjectUIs_FUN_004074d0(float elapsedAbs)
{
	LiveObject *pLVar1;
	float fVar2;
	ImageBMP *pIVar3;
	BOOL BVar4;
	Container *pCVar5;
	int iVar6;
	Struct_8__00558bc4 *pSVar7;
	float10 fVar8;
	longlong lVar9;
	Container *pCVar10;
	Vector3F *pVVar11;
	Point2F local_14;
	Vector3F local_c;
	
	if ((globals::g_ObjectUIsAlwaysVisible != 0) &&
		 (BVar4 = game::Game_IsFirstPersonView(), BVar4 == 0)) {
		game::Search_LiveObjects_SkipIgnoreMes(Bubble_LiveObject_CallbackDraw_FUN_00407890,&elapsedAbs);
	}
	pSVar7 = TABLE_50__Struct_8__00558bc4__005589e4;
	do {
		pLVar1 = pSVar7->object_0;
		if (pLVar1 != NULL) {
			if ((((pLVar1->objType != OBJECT_MINIFIGURE) || (globals::g_ObjectUIsAlwaysVisible == 0)) &&
					(BVar4 = game::Game_IsFirstPersonView(), BVar4 == 0)) &&
				 ((pLVar1->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE)) {
				pVVar11 = &local_c;
				pCVar10 = NULL;
				pCVar5 = game::LiveObject_GetContainer(pLVar1);
				res::Container_GetPosition(pCVar5,pCVar10,pVVar11);
				fVar8 = game::LiveObject_GetCollHeight(pLVar1);
				local_c.z = (float)((float10)local_c.z - fVar8);
				lego::view::Viewport_WorldToScreen(globs::gameGlobs.viewMain,&local_14,&local_c);
				lVar9 = __ftol((float10)local_14.y);
				iVar6 = (int)lVar9;
				lVar9 = __ftol((float10)local_14.x);
				ObjInfo_LiveObject_DrawObjInfoHealthBar_FUN_00459dc0(pLVar1,(int)lVar9,iVar6);
			}
			fVar2 = pSVar7->float_4 - elapsedAbs;
			pSVar7->float_4 = fVar2;
			if (fVar2 < 0.0) {
				pSVar7->object_0 = NULL;
			}
		}
		pSVar7 = pSVar7 + 1;
	} while (pSVar7 < TABLE_50__Struct_8__00558bc4__00558a84);
	BVar4 = game::Game_IsFirstPersonView();
	if (BVar4 == 0) {
		if (12.5 <= _DAT_004b9a18) {
			if (25.0 <= _DAT_004b9a18) {
				_DAT_004b9a18 = _DAT_004b9a18 - 25.0;
			}
		}
		else {
			pSVar7 = TABLE_50__Struct_8__00558bc4__00558b24;
			do {
				pIVar3 = globals::g_Bubbles_bmp_TABLE[29];
				pLVar1 = pSVar7->object_0;
				if (pLVar1 != NULL) {
					if ((pLVar1->flags3 & LIVEOBJ3_HASPOWER) == LIVEOBJ3_NONE) {
						pVVar11 = &local_c;
						pCVar10 = NULL;
						pCVar5 = game::LiveObject_GetContainer(pLVar1);
						res::Container_GetPosition(pCVar5,pCVar10,pVVar11);
						fVar8 = game::LiveObject_GetCollHeight(pLVar1);
						local_c.z = (float)((float10)local_c.z - fVar8);
						lego::view::Viewport_WorldToScreen(globs::gameGlobs.viewMain,&local_14,&local_c);
						local_14.y = local_14.y - (float)pIVar3->height;
						local_14.x = local_14.x - (float)pIVar3->width * 0.5;
						lego::image::Image_DisplayScaled(pIVar3,NULL,&local_14,NULL);
					}
					else {
						pSVar7->object_0 = NULL;
					}
				}
				pSVar7 = pSVar7 + 1;
			} while (pSVar7 < TABLE_50__Struct_8__00558bc4__00558bc4);
		}
		_DAT_004b9a18 = _DAT_004b9a18 + elapsedAbs;
	}
	pSVar7 = TABLE_50__Struct_8__00558bc4__00558a84;
	do {
		pLVar1 = pSVar7->object_0;
		if (pLVar1 != NULL) {
			if (((pLVar1->objType != OBJECT_MINIFIGURE) || (globals::g_ObjectUIsAlwaysVisible == 0)) &&
				 (((pLVar1->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE &&
					(BVar4 = game::Game_IsFirstPersonView(), BVar4 == 0)))) {
				local_14.x = 0.0;
				Bubble_LiveObject_GetBubbleImage_FUN_004077f0
									(pLVar1,elapsedAbs,(ImageBMP **)&local_14,&local_c);
				pIVar3 = (ImageBMP *)local_14.x;
				if (((ImageBMP *)local_14.x != NULL) &&
					 ((ImageBMP *)local_14.x != globals::g_Bubbles_bmp_TABLE[1])) {
					lVar9 = __ftol((float10)local_c.y);
					iVar6 = (int)lVar9;
					lVar9 = __ftol((float10)local_c.x);
					ObjInfo_FUN_0045a290(pIVar3,(int)lVar9,iVar6);
				}
			}
			fVar2 = pSVar7->float_4 - elapsedAbs;
			pSVar7->float_4 = fVar2;
			if (fVar2 < 0.0) {
				pSVar7->object_0 = NULL;
			}
		}
		pSVar7 = pSVar7 + 1;
	} while (pSVar7 < TABLE_50__Struct_8__00558bc4__00558b24);
	pSVar7 = TABLE_50__Struct_8__00558bc4__00558bc4;
	do {
		pLVar1 = pSVar7->object_0;
		if (pLVar1 != NULL) {
			if (((globals::g_ObjectUIsAlwaysVisible == 0) &&
					((pLVar1->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE)) &&
				 (BVar4 = game::Game_IsFirstPersonView(), BVar4 == 0)) {
				local_14.x = 0.0;
				Bubble_LiveObject_GetBubbleImage_FUN_004077f0
									(pLVar1,elapsedAbs,(ImageBMP **)&local_14,&local_c);
				pIVar3 = (ImageBMP *)local_14.x;
				if ((ImageBMP *)local_14.x != NULL) {
					lVar9 = __ftol((float10)local_c.y);
					iVar6 = (int)lVar9;
					lVar9 = __ftol((float10)local_c.x);
					ObjInfo_FUN_0045a290(pIVar3,(int)lVar9,iVar6);
				}
			}
			if ((ushort)((ushort)(pSVar7->float_4 < 0.0) << 8 | (ushort)(pSVar7->float_4 == 0.0) << 0xe)
					!= 0) {
				pSVar7->object_0 = NULL;
			}
		}
		pSVar7 = pSVar7 + 1;
	} while (pSVar7 < (Struct_8__00558bc4 *)&DAT_00558d54);
	return;
}



void __cdecl
lego::front::Bubble_LiveObject_GetBubbleImage_FUN_004077f0
					(LiveObject *liveObj,float param_2,ImageBMP **out_bubbleImage,Point2F *param_4)
{
	float fVar1;
	Container *cont;
	float10 fVar2;
	Container *opt_ref;
	Vector3F *out_pos;
	Vector3F local_c;
	
	out_pos = &local_c;
	opt_ref = NULL;
	cont = game::LiveObject_GetContainer(liveObj);
	res::Container_GetPosition(cont,opt_ref,out_pos);
	fVar2 = game::LiveObject_GetCollHeight(liveObj);
	local_c.z = (float)((float10)local_c.z - fVar2);
	lego::view::Viewport_WorldToScreen(globs::gameGlobs.viewMain,param_4,&local_c);
	fVar1 = (float)liveObj->field_388 - param_2;
	liveObj->field_388 = fVar1;
	if ((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) == 0) {
		*out_bubbleImage = liveObj->bubbleImage_38c;
	}
	else {
		Bubble_LiveObject_GetCurrentBubbleImage(liveObj,out_bubbleImage);
	}
	if (*out_bubbleImage == NULL) {
		*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[1];
	}
	return;
}



BOOL __cdecl
lego::front::Bubble_LiveObject_CallbackDraw_FUN_00407890(LiveObject *liveObj,float *param_2)
{
	float *image;
	int iVar1;
	longlong lVar2;
	float local_8;
	float local_4;
	
	local_8 = *param_2;
	if ((liveObj->objType == OBJECT_MINIFIGURE) &&
		 ((liveObj->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE)) {
		param_2 = NULL;
		Bubble_LiveObject_GetBubbleImage_FUN_004077f0(liveObj,local_8,(ImageBMP **)&param_2,&local_8);
		lVar2 = __ftol((float10)local_4);
		iVar1 = (int)lVar2;
		lVar2 = __ftol((float10)local_8);
		ObjInfo_LiveObject_DrawObjInfoHealthBar_FUN_00459dc0(liveObj,(int)lVar2,iVar1);
		lVar2 = __ftol((float10)local_4);
		iVar1 = (int)lVar2;
		lVar2 = __ftol((float10)local_8);
		ObjInfo_FUN_0045a210(liveObj,(int)lVar2,iVar1);
		image = param_2;
		if ((ImageBMP *)param_2 != NULL) {
			lVar2 = __ftol((float10)local_4);
			iVar1 = (int)lVar2;
			lVar2 = __ftol((float10)local_8);
			ObjInfo_FUN_0045a290((ImageBMP *)image,(int)lVar2,iVar1);
		}
	}
	return 0;
}



void __cdecl
lego::front::Bubble_LiveObject_GetCurrentBubbleImage(LiveObject *liveObj,ImageBMP **out_bubbleImage)
{
	AITaskData *pAVar1;
	AITaskData *pAVar2;
	LiveObject *pLVar3;
	ObjectType OVar4;
	ToolType TVar5;
	AITaskType AVar6;
	
	pAVar1 = liveObj->aitask_2f0;
	if ((*(byte *)&liveObj->flags4 & 0x20) != 0) {
		*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[30];
		return;
	}
	if ((liveObj->flags1 & LIVEOBJ1_UNK_800000) != LIVEOBJ1_NONE) {
		*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[28];
		return;
	}
	if ((liveObj->flags1 & LIVEOBJ1_UNK_80000000) != LIVEOBJ1_NONE) {
		*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[0];
		return;
	}
	if (pAVar1 != NULL) {
		AVar6 = pAVar1->taskType;
		while ((AVar6 == AITASK_ANIMATIONWAIT && (pAVar2 = pAVar1->next, pAVar2 != NULL))) {
			AVar6 = pAVar2->taskType;
			pAVar1 = pAVar2;
		}
		if (true) {
			switch(pAVar1->taskType) {
			case AITASK_GOTO:
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[22];
				return;
			case AITASK_COLLECT:
				OVar4 = pAVar1->object_10->objType;
				if (OVar4 == OBJECT_POWERCRYSTAL) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[2];
					return;
				}
				if (OVar4 == OBJECT_ORE) {
					if (pAVar1->object_10->objIndex == 0) {
						*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[3];
						return;
					}
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[4];
					return;
				}
				if (OVar4 == OBJECT_DYNAMITE) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[5];
					return;
				}
				if (OVar4 == OBJECT_BARRIER) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[6];
					return;
				}
				if (OVar4 == OBJECT_ELECTRICFENCE) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[7];
					return;
				}
				break;
			case AITASK_DEPOSITE:
				pLVar3 = liveObj->carriedObjects[0];
				if (pLVar3 != NULL) {
					OVar4 = pLVar3->objType;
					if (OVar4 == OBJECT_POWERCRYSTAL) {
						*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[16];
						return;
					}
					if (OVar4 == OBJECT_ORE) {
						if (pLVar3->objIndex == 0) {
							*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[17];
							return;
						}
						*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[18];
						return;
					}
					if (OVar4 == OBJECT_DYNAMITE) {
						*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[19];
						return;
					}
					if (OVar4 == OBJECT_BARRIER) {
						*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[20];
						return;
					}
					if (OVar4 == OBJECT_ELECTRICFENCE) {
						*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[21];
						return;
					}
				}
				break;
			case AITASK_REQUEST:
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[38];
				break;
			case AITASK_DIG:
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[25];
				return;
			case AITASK_DYNAMITE:
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[23];
				return;
			case AITASK_REPAIR:
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[26];
				return;
			case AITASK_REINFORCE:
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[24];
				return;
			case AITASK_CLEAR:
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[27];
				return;
			case AITASK_ELECFENCE:
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[31];
				return;
			case AITASK_EAT:
			case AITASK_GOTOEAT:
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[32];
				return;
			case AITASK_FINDDRIVER:
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[33];
				return;
			case AITASK_GETTOOL:
				TVar5 = pAVar1->toolType;
				if (TVar5 == TOOL_DRILL) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[8];
					return;
				}
				if (TVar5 == TOOL_SPADE) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[9];
					return;
				}
				if (TVar5 == TOOL_HAMMER) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[10];
					return;
				}
				if (TVar5 == TOOL_SPANNER) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[11];
					return;
				}
				if (TVar5 == TOOL_LASER) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[12];
					return;
				}
				if (TVar5 == TOOL_PUSHERGUN) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[13];
					return;
				}
				if (TVar5 == TOOL_FREEZERGUN) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[14];
					return;
				}
				if (TVar5 == TOOL_BIRDSCARER) {
					*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[15];
					return;
				}
				break;
			case AITASK_UPGRADE:
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[34];
				return;
			case AITASK_BUILDPATH:
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[35];
				return;
			case AITASK_TRAIN:
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[36];
				return;
			case AITASK_RECHARGE:
				*out_bubbleImage = globals::g_Bubbles_bmp_TABLE[37];
				return;
			}
		}
	}
	return;
}



BOOL __cdecl
lego::res::Building_LoadActivityFile
					(BuildingData *building,int objIndex,Container *resData,char *filename,char *rootName)
{
	char cVar1;
	Container *pCVar2;
	CFGProperty *prop;
	char *pcVar3;
	Point2I *pPVar4;
	char *pcVar5;
	int iVar6;
	uint uVar7;
	uint uVar8;
	char **ppcVar9;
	undefined4 *puVar10;
	BuildingData *pBVar11;
	undefined4 *puVar12;
	float10 fVar13;
	char **local_99c;
	int local_998;
	char *stringParts [100];
	char buffName [1024];
	char buffPath [1024];
	
	pBVar11 = building;
	for (iVar6 = 0x53; iVar6 != 0; iVar6 += -1) {
		pBVar11->objIndex = 0;
		pBVar11 = (BuildingData *)&pBVar11->contAct;
	}
	pCVar2 = Container_Load(resData,filename,"ACT",TRUE);
	building->contAct = pCVar2;
	if (pCVar2 == NULL) {
		return 0;
	}
	uVar7 = 0xffffffff;
	do {
		pcVar3 = filename;
		if (uVar7 == 0) break;
		uVar7 -= 1;
		pcVar3 = filename + 1;
		cVar1 = *filename;
		filename = pcVar3;
	} while (cVar1 != '\0');
	uVar7 = ~uVar7;
	puVar10 = (undefined4 *)(pcVar3 + -uVar7);
	puVar12 = (undefined4 *)buffName;
	for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
		*puVar12 = *puVar10;
		puVar10 = puVar10 + 1;
		puVar12 = puVar12 + 1;
	}
	for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
		*(undefined *)puVar12 = *(undefined *)puVar10;
		puVar10 = (undefined4 *)((int)puVar10 + 1);
		puVar12 = (undefined4 *)((int)puVar12 + 1);
	}
	uVar7 = util::Util_Tokenise(buffName,stringParts,"\\");
	if (1 < uVar7) {
		ppcVar9 = stringParts;
		iVar6 = uVar7 - 1;
		do {
			ppcVar9 = ppcVar9 + 1;
			iVar6 += -1;
			(*ppcVar9)[-1] = '\\';
		} while (iVar6 != 0);
	}
	std::sprintf(buffPath,"%s\\%s.%s",buffName,stringParts[uVar7 - 1],"ae");
	prop = cfg::CFG_Open(buffPath);
	if (prop != NULL) {
		pcVar3 = cfg::CFG_JoinPath(rootName,"CarryNullName",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->CarryNullName = pcVar3;
		if (pcVar3 == NULL) {
			building->CarryNullFrames = 0;
		}
		else {
			pcVar3 = cfg::CFG_JoinPath(rootName,"CarryNullFrames",0);
			pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
			if (pcVar3 == NULL) {
				uVar7 = std::atoi(____EMPTYSTR__);
				building->CarryNullFrames = uVar7;
			}
			else {
				pcVar3 = cfg::CFG_JoinPath(rootName,"CarryNullFrames",0);
				pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
				uVar7 = std::atoi(pcVar3);
				building->CarryNullFrames = uVar7;
			}
		}
		pcVar3 = cfg::CFG_JoinPath(rootName,"CameraNullName",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->CameraNullName = pcVar3;
		if (pcVar3 == NULL) {
			building->CameraNullFrames = 0;
		}
		else {
			pcVar3 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
			pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
			if (pcVar3 == NULL) {
				uVar7 = std::atoi(____EMPTYSTR__);
				building->CameraNullFrames = uVar7;
			}
			else {
				pcVar3 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
				pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
				uVar7 = std::atoi(pcVar3);
				building->CameraNullFrames = uVar7;
			}
		}
		pcVar3 = cfg::CFG_JoinPath(rootName,"ToolNullName",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->ToolNullName = pcVar3;
		if (pcVar3 == NULL) {
			building->ToolNullFrames = 0;
		}
		else {
			pcVar3 = cfg::CFG_JoinPath(rootName,"ToolNullFrames",0);
			pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
			if (pcVar3 == NULL) {
				uVar7 = std::atoi(____EMPTYSTR__);
				building->ToolNullFrames = uVar7;
			}
			else {
				pcVar3 = cfg::CFG_JoinPath(rootName,"ToolNullFrames",0);
				pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
				uVar7 = std::atoi(pcVar3);
				building->ToolNullFrames = uVar7;
			}
		}
		pcVar3 = cfg::CFG_JoinPath(rootName,"DepositNullName",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->DepositNullName = pcVar3;
		pcVar3 = cfg::CFG_JoinPath(rootName,"FireNullName",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->FireNullName = pcVar3;
		pcVar3 = cfg::CFG_JoinPath(rootName,"EntranceNullName",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->EntranceNullName = pcVar3;
		pcVar3 = cfg::CFG_JoinPath(rootName,"yPivot",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->yPivot = pcVar3;
		pcVar3 = cfg::CFG_JoinPath(rootName,"xPivot",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		building->xPivot = pcVar3;
		pcVar3 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
		pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
		if (pcVar3 == NULL) {
			building->PivotMaxZ = 1.0;
		}
		else {
			pcVar3 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
			pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
			if (pcVar3 == NULL) {
				fVar13 = std::atof(____EMPTYSTR__);
				building->PivotMaxZ = (float)fVar13;
			}
			else {
				pcVar3 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
				pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
				fVar13 = std::atof(pcVar3);
				building->PivotMaxZ = (float)fVar13;
			}
		}
		pcVar3 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
		pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
		if (pcVar3 == NULL) {
			building->PivotMinZ = -1.0;
		}
		else {
			pcVar3 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
			pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
			if (pcVar3 == NULL) {
				fVar13 = std::atof(____EMPTYSTR__);
				building->PivotMinZ = (float)fVar13;
			}
			else {
				pcVar3 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
				pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
				fVar13 = std::atof(pcVar3);
				building->PivotMinZ = (float)fVar13;
			}
		}
		Upgrade_LoadUpgradeLevels(&building->upgrades,prop,rootName);
		pPVar4 = (Point2I *)std::malloc(0x50);
		building->shapePoints = pPVar4;
		building->shapeCount = 1;
		pPVar4->y = 0;
		building->shapePoints->x = 0;
		pcVar3 = cfg::CFG_JoinPath(rootName,"Shape",0);
		pcVar3 = cfg::CFG_CopyString(prop,pcVar3);
		if (pcVar3 != NULL) {
			local_998 = util::Util_Tokenise(pcVar3,stringParts,":");
			if (local_998 != 0) {
				local_99c = stringParts;
				do {
					uVar7 = building->shapeCount;
					pPVar4 = building->shapePoints;
					pcVar5 = *local_99c;
					building->shapeCount = uVar7 + 1;
					iVar6 = std::atoi(pcVar5);
					pPVar4[uVar7].x = iVar6;
					pcVar5 = std::strstr(pcVar5,",");
					iVar6 = std::atoi(pcVar5 + 1);
					pPVar4[uVar7].y = iVar6;
					local_99c = local_99c + 1;
					local_998 += -1;
				} while (local_998 != 0);
			}
			std::free(pcVar3);
		}
		pcVar3 = cfg::CFG_JoinPath(rootName,"PowerLevelScene",0);
		pcVar3 = cfg::CFG_ReadString(prop,pcVar3);
		if (pcVar3 != NULL) {
			std::sprintf(buffPath,"%s\\%s",buffName,pcVar3);
			pCVar2 = Container_Load(resData,buffPath,"LWS",TRUE);
			building->contPowerLevelScene = pCVar2;
		}
		cfg::CFG_Close(prop);
	}
	Container_Hide(building->contAct,TRUE);
	building->objIndex = objIndex;
	building->flags = 0;
	return TRUE;
}



void __cdecl lego::res::Building_FUN_00408210(BuildingData *building,BOOL unkAddSubInverse)
{
	float fVar1;
	
	if (unkAddSubInverse == 0) {
		fVar1 = ((float)building->field_80 - 0.1) * 10.0 * 0.1111111;
	}
	else {
		fVar1 = (float)building->field_80 - (1.0 - (float)building->field_80) * -0.1;
	}
	building->field_80 = fVar1;
	if ((float)building->field_80 < 0.0) {
		building->field_80 = 0;
	}
	building->flags = building->flags | 2;
	return;
}



Point2I * __cdecl lego::res::Building_GetShapePoints(BuildingData *building,uint *out_shapeCount)
{
	if (out_shapeCount != NULL) {
		*out_shapeCount = building->shapeCount;
	}
	return building->shapePoints;
}



void __cdecl lego::res::Object_SetOwnerObject(BasicObjectData *basicObjData,LiveObject *liveObj)
{
	Container_SetUserData(basicObjData->aeResData,liveObj);
	return;
}



void __cdecl lego::res::Building_UnkUpgrades(BuildingData *building,char *frameName)
{
	int *opt_instance;
	LiveObject *pLVar1;
	uint uVar2;
	BuildingData *basicObjData;
	undefined4 *puVar3;
	Container *pCVar4;
	Container *in_child;
	char *pcVar5;
	undefined4 *puVar6;
	int iVar7;
	UpgradeData *upgrade;
	uint local_14;
	int local_10;
	uint local_c;
	int local_8;
	UpgradeData *local_4;
	
	basicObjData = building;
	iVar7 = 3;
	pLVar1 = (LiveObject *)(building->upgrades).upgradeObjs;
	puVar3 = (undefined4 *)&building->field_0xc4;
	puVar6 = (undefined4 *)&building->field_0xa0;
	do {
		puVar3[0x1a] = 0;
		*puVar3 = 0;
		puVar3[-3] = 0;
		*puVar6 = 0;
		puVar3 = puVar3 + 1;
		iVar7 += -1;
		puVar6[1] = 0;
		puVar6 = puVar6 + 2;
	} while (iVar7 != 0);
	building->count_144 = 0;
	do {
		if (pLVar1 == NULL) {
			return;
		}
		upgrade = pLVar1->upgrade;
		iVar7 = upgrade->field_c;
		local_8 = iVar7;
		local_4 = upgrade;
		pCVar4 = Object_SearchForPartName
											 ((BasicObjectData *)basicObjData,*(undefined4 *)(iVar7 + 8),
												*(undefined4 *)(iVar7 + 4));
		in_child = Object_GetActivityContainer((BasicObjectData *)upgrade);
		Container_SetParent(in_child,pCVar4);
		Container_ClearTransform(in_child);
		if (frameName == NULL) {
			Container_SetActivity(upgrade->aeResData,globs::liveGlobs.Activities_TABLE[0]);
		}
		else {
			Upgrade_FUN_0046c3f0(upgrade,frameName);
		}
		if (*(int *)(iVar7 + 0xc) != 0) {
			uVar2 = basicObjData->count_144;
			local_10 = 0;
			*(undefined4 *)(&basicObjData->field_0xd8 + uVar2 * 4) = 0;
			local_14 = 0;
			opt_instance = (int *)(&basicObjData->field_0xd8 + uVar2 * 4);
			building = (BuildingData *)(basicObjData->cameraFramesTable_40 + uVar2 * 2 + 0x18);
			local_c = uVar2;
			do {
				building->objIndex = 0;
				pcVar5 = Container_FormatPartName
													 (basicObjData->contAct,basicObjData->FireNullName,opt_instance);
				pCVar4 = Container_SearchTree(in_child,pcVar5,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
				basicObjData->cameraFramesTable_40[*opt_instance + uVar2 * 2 + 0x18] = pCVar4;
				pCVar4 = basicObjData->cameraFramesTable_40[uVar2 * 2 + *opt_instance + 0x18];
				*opt_instance = *opt_instance + 1;
				if (pCVar4 == NULL) break;
				local_14 += 1;
				building = (BuildingData *)&building->contAct;
			} while (local_14 < 2);
			pcVar5 = Container_FormatPartName(basicObjData->contAct,basicObjData->xPivot,&local_10);
			pCVar4 = Container_SearchTree(in_child,pcVar5,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
			uVar2 = local_c;
			basicObjData->cameraFramesTable_40[local_c + 0x1e] = pCVar4;
			pcVar5 = Container_FormatPartName(basicObjData->contAct,basicObjData->yPivot,&local_10);
			pCVar4 = Container_SearchTree(in_child,pcVar5,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
			*(Container **)(&basicObjData->field_0xc4 + uVar2 * 4) = pCVar4;
			*(int *)(&basicObjData->field_0x12c + uVar2 * 4) = local_8;
			basicObjData->count_144 = basicObjData->count_144 + 1;
			upgrade = local_4;
		}
		pLVar1 = upgrade->object_8;
	} while( true );
}



BOOL __cdecl
lego::res::Building_SetActivity_AndRemoveCarryCameraFrames
					(BuildingData *building,char *activityName,float elapsed)
{
	uint uVar1;
	BOOL BVar2;
	Container **ppCVar3;
	
	uVar1 = 0;
	if (building->CarryNullFrames != 0) {
		ppCVar3 = building->carryFramesTable_28;
		do {
			*ppCVar3 = NULL;
			uVar1 += 1;
			ppCVar3 = ppCVar3 + 1;
		} while (uVar1 < building->CarryNullFrames);
	}
	uVar1 = 0;
	if (building->CameraNullFrames != 0) {
		ppCVar3 = building->cameraFramesTable_40;
		do {
			*ppCVar3 = NULL;
			uVar1 += 1;
			ppCVar3 = ppCVar3 + 1;
		} while (uVar1 < building->CameraNullFrames);
	}
	building->field_68 = 0;
	building->field_6c = 0;
	BVar2 = Container_SetActivity(building->contAct,activityName);
	Container_SetAnimationTime(building->contAct,elapsed);
	Building_UnkUpgrades(building,activityName);
	return BVar2;
}



Container * __cdecl lego::res::Building_GetCameraNull(BuildingData *building,int cameraIndex)
{
	Container *pCVar1;
	
	pCVar1 = (Container *)building->CameraNullName;
	if (pCVar1 != NULL) {
		if (building->cameraFramesTable_40[cameraIndex] == NULL) {
			pCVar1 = Object_SearchForPartName((BasicObjectData *)building,pCVar1,cameraIndex);
			building->cameraFramesTable_40[cameraIndex] = pCVar1;
		}
		pCVar1 = building->cameraFramesTable_40[cameraIndex];
	}
	return pCVar1;
}



void __cdecl lego::res::Building_Duplicate(BuildingData *in_building,BuildingData *out_building)
{
	Container *pCVar1;
	int iVar2;
	BuildingData *pBVar3;
	BuildingData *pBVar4;
	
	pBVar3 = in_building;
	pBVar4 = out_building;
	for (iVar2 = 0x53; iVar2 != 0; iVar2 += -1) {
		pBVar4->objIndex = pBVar3->objIndex;
		pBVar3 = (BuildingData *)&pBVar3->contAct;
		pBVar4 = (BuildingData *)&pBVar4->contAct;
	}
	out_building->flags = out_building->flags & 0xfffffffe;
	pCVar1 = Container_Clone(in_building->contAct);
	out_building->contAct = pCVar1;
	if (in_building->contPowerLevelScene != NULL) {
		pCVar1 = Container_Clone(in_building->contPowerLevelScene);
		out_building->contPowerLevelScene = pCVar1;
	}
	return;
}



void __cdecl lego::res::Building_HideAll(BuildingData *building,BOOL hide)
{
	Container_Hide(building->contAct,hide);
	if (building->contPowerLevelScene != NULL) {
		Container_Hide(building->contPowerLevelScene,hide);
	}
	return;
}



BOOL __cdecl lego::res::Object_IsHidden(BasicObjectData *basicObjData)
{
	BOOL BVar1;
	
	BVar1 = Container_IsHidden(basicObjData->aeResData);
	return BVar1;
}



void __cdecl lego::res::Building_SetOrientation(BuildingData *building,float x,float y)
{
	Container_SetOrientation(building->contAct,NULL,x,y,0.0,0.0,0.0,-1.0);
	if (building->contPowerLevelScene != NULL) {
		Container_SetOrientation(building->contPowerLevelScene,NULL,x,y,0.0,0.0,0.0,-1.0);
	}
	return;
}



void __cdecl
lego::res::Building_SetPosition
					(BuildingData *building,float x,float y,undefined *getZcallback,SurfaceMap *surfMap)
{
	float10 fVar1;
	
	fVar1 = (float10)(*(code *)getZcallback)(x,y,surfMap);
	Container_SetPosition(building->contAct,NULL,x,y,(float)fVar1);
	if (building->contPowerLevelScene != NULL) {
		Container_SetPosition(building->contPowerLevelScene,NULL,x,y,(float)fVar1);
	}
	return;
}



Container * __cdecl lego::res::Building_GetCarryNull(BuildingData *building,int carryIndex)
{
	Container *pCVar1;
	
	if (building->CarryNullName == NULL) {
		return NULL;
	}
	if (building->carryFramesTable_28[carryIndex] != NULL) {
		return building->carryFramesTable_28[carryIndex];
	}
	pCVar1 = Object_SearchForPartName((BasicObjectData *)building,building->CarryNullName,carryIndex);
	building->carryFramesTable_28[carryIndex] = pCVar1;
	return pCVar1;
}



Container * __cdecl lego::res::Building_GetDepositNull(BuildingData *building)
{
	Container *pCVar1;
	
	if (building->DepositNullName == NULL) {
		pCVar1 = NULL;
	}
	else {
		pCVar1 = (Container *)building->field_68;
		if (pCVar1 == NULL) {
			pCVar1 = Object_SearchForPartName((BasicObjectData *)building,building->DepositNullName,0);
			building->field_68 = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Building_GetEntranceNull(BuildingData *building)
{
	Container *pCVar1;
	
	if (building->EntranceNullName == NULL) {
		pCVar1 = NULL;
	}
	else {
		pCVar1 = (Container *)building->field_6c;
		if (pCVar1 == NULL) {
			pCVar1 = Object_SearchForPartName((BasicObjectData *)building,building->EntranceNullName,0);
			building->field_6c = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Building_GetToolNull(BuildingData *building,int toolIndex)
{
	Container *pCVar1;
	
	if (building->ToolNullName == NULL) {
		return NULL;
	}
	if (building->cameraFramesTable_40[toolIndex + 4] != NULL) {
		return building->cameraFramesTable_40[toolIndex + 4];
	}
	pCVar1 = Object_SearchForPartName((BasicObjectData *)building,building->ToolNullName,toolIndex);
	building->cameraFramesTable_40[toolIndex + 4] = pCVar1;
	return pCVar1;
}



int __cdecl lego::res::Building_GetCarryNullFrames(BuildingData *building)
{
	return building->CarryNullFrames;
}



float10 __cdecl lego::res::Building_FUN_00408790(BuildingData *building,float elapsed,uint param_3)
{
	BuildingData *pBVar1;
	BuildingData *pBVar2;
	uint uVar3;
	float10 fVar4;
	
	pBVar2 = building;
	fVar4 = Container_MoveAnimation(building->contAct,elapsed);
	pBVar1 = (BuildingData *)(float)fVar4;
	if ((1 < param_3) && ((float)pBVar1 != 0.0)) {
		uVar3 = Container_GetAnimationFrames(building->contAct);
		pBVar1 = (BuildingData *)((float)pBVar1 - (float)(ulonglong)(uVar3 * (param_3 - 1)));
	}
	building = pBVar1;
	if ((*(byte *)&pBVar2->flags & 2) != 0) {
		if (pBVar2->contPowerLevelScene != NULL) {
			uVar3 = Container_GetAnimationFrames(pBVar2->contPowerLevelScene);
			Container_SetAnimationTime
								(pBVar2->contPowerLevelScene,(float)(ulonglong)uVar3 * (float)pBVar2->field_80);
		}
		pBVar2->flags = pBVar2->flags & 0xfffffffd;
	}
	return (float10)(float)building;
}



float10 __cdecl lego::res::Building_GetAnimFloat14_zero(BuildingData *building)
{
	return (float10)0.0;
}



void __cdecl lego::res::Building_Destroy(BuildingData *building)
{
	Building_ChangeUpgradeParts(building,-1);
	if (building->contPowerLevelScene != NULL) {
		Container_Remove(building->contPowerLevelScene);
	}
	Container_Remove(building->contAct);
	return;
}



BOOL __cdecl
lego::res::Object_Debug_ChangeUpgradeModel(BuildingData *building,int levelBit,BOOL condition)
{
	uint uVar1;
	
	uVar1 = 1 << ((byte)levelBit & 0x1f);
	if ((condition != 0) && (((building->upgrades).levelsMask & uVar1) != 0)) {
		return 0;
	}
	return (building->upgrades).levelsMask & uVar1;
}



void __cdecl lego::res::Building_ChangeUpgradeParts(BuildingData *building,int objLevel)
{
	Upgrade_ChangeUpgradeParts(&building->upgrades,objLevel);
	Building_UnkUpgrades(building,NULL);
	return;
}



float10 __cdecl
lego::math::Collision_Maths_Sub_FUN_00408900(Point2F *param_1,Point2F *param_2,Point2F *param_3)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float10 fVar6;
	float10 fVar7;
	
	fVar3 = param_3->x - param_2->x;
	fVar5 = param_3->y - param_2->y;
	fVar6 = (float10)param_1->x - (float10)param_3->x;
	fVar7 = (float10)param_1->y - (float10)param_3->y;
	fVar1 = (float)fVar6;
	fVar2 = (float)fVar7;
	fVar6 = SQRT(fVar7 * (float10)fVar2 + fVar6 * (float10)fVar1);
	fVar4 = 1.0 / SQRT(fVar5 * fVar5 + fVar3 * fVar3);
	fVar3 = fVar4 * fVar3;
	fVar4 = fVar4 * fVar5;
	if ((float10)(float)((float10)1.0 / fVar6) * (float10)fVar2 * (float10)fVar4 +
			((float10)1.0 / fVar6) * (float10)fVar1 * (float10)fVar3 < (float10)0.0) {
		fVar5 = param_1->x - param_2->x;
		fVar1 = param_1->y - param_2->y;
		fVar2 = SQRT(fVar1 * fVar1 + fVar5 * fVar5);
		fVar1 = (1.0 / fVar2) * fVar1 * fVar4 + (1.0 / fVar2) * fVar5 * fVar3;
		if ((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) != 0) {
			return (float10)fVar2;
		}
		fVar6 = std::acos((float10)fVar1);
		fVar6 = (float10)fsin(fVar6);
		fVar6 = fVar6 * (float10)fVar2;
	}
	return fVar6;
}



float10 __cdecl
lego::math::Collision_Maths_FUN_00408a30
					(Point2F *point,Point2F *fromList,Point2F *toList,uint count)
{
	Point2F *pPVar1;
	int iVar2;
	Point2F *pPVar3;
	float10 fVar4;
	
	fVar4 = Collision_Maths_Sub_FUN_00408900(point,fromList,toList);
	pPVar1 = (Point2F *)(float)fVar4;
	if (1 < count) {
		pPVar3 = (Point2F *)((int)toList - (int)fromList);
		iVar2 = count - 1;
		toList = (Point2F *)(float)fVar4;
		do {
			fromList = fromList + 1;
			fVar4 = Collision_Maths_Sub_FUN_00408900
												(point,fromList,(Point2F *)((int)&fromList->x + (int)&pPVar3->x));
			if (fVar4 < (float10)(float)toList) {
				toList = (Point2F *)(float)fVar4;
			}
			iVar2 += -1;
			pPVar1 = toList;
		} while (iVar2 != 0);
	}
	toList = pPVar1;
	return (float10)(float)toList;
}



Point2F * __cdecl
lego::game::Collision_Maths_FUN_00408a90
					(Point2F *param_1,Point2F *param_2,Point2F *position,Point2F *out_point)
{
	float fVar1;
	float fVar2;
	float fVar3;
	
	fVar3 = param_2->x - param_1->x;
	fVar1 = param_2->y - param_1->y;
	fVar2 = 1.0 / SQRT(fVar1 * fVar1 + fVar3 * fVar3);
	fVar3 = fVar2 * fVar3;
	fVar2 = fVar2 * fVar1;
	fVar1 = (position->y - param_1->y) * fVar2 + (position->x - param_1->x) * fVar3;
	out_point->x = fVar1 * fVar3 + param_1->x;
	out_point->y = fVar1 * fVar2 + param_1->y;
	return out_point;
}



Point2F * __cdecl
lego::math::Collision_MathUnk_Vector2D_FUN_00408b20
					(Point2F *param_1,Point2F *param_2,Point2F *position,Point2F *out_point)
{
	float fVar1;
	float fVar2;
	float fVar3;
	
	fVar1 = param_2->y;
	fVar2 = param_2->x;
	fVar3 = 1.0 / SQRT(fVar1 * fVar1 + fVar2 * fVar2);
	fVar2 = fVar3 * fVar2;
	fVar3 = fVar3 * fVar1;
	fVar1 = (position->y - param_1->y) * fVar3 + (position->x - param_1->x) * fVar2;
	out_point->x = fVar1 * fVar2 + param_1->x;
	out_point->y = fVar1 * fVar3 + param_1->y;
	return out_point;
}



uint __cdecl lego::game::Construction_GetBuildingBase(char *name)
{
	byte bVar1;
	byte *pbVar2;
	int iVar3;
	uint uVar4;
	byte *pbVar5;
	char **ppcVar6;
	bool bVar7;
	
	uVar4 = 0;
	if (globals::g_BuildingBase_COUNT == 0) {
		return 0;
	}
	ppcVar6 = globals::g_BuildingBase_TABLE;
	do {
		pbVar2 = (byte *)*ppcVar6;
		pbVar5 = (byte *)name;
		do {
			bVar1 = *pbVar2;
			bVar7 = bVar1 < *pbVar5;
			if (bVar1 != *pbVar5) {
LAB_00408bee:
				iVar3 = (1 - (uint)bVar7) - (uint)(bVar7 != 0);
				goto LAB_00408bf3;
			}
			if (bVar1 == 0) break;
			bVar1 = pbVar2[1];
			bVar7 = bVar1 < pbVar5[1];
			if (bVar1 != pbVar5[1]) goto LAB_00408bee;
			pbVar2 = pbVar2 + 2;
			pbVar5 = pbVar5 + 2;
		} while (bVar1 != 0);
		iVar3 = 0;
LAB_00408bf3:
		if (iVar3 == 0) {
			return uVar4;
		}
		uVar4 += 1;
		ppcVar6 = (char **)((byte **)ppcVar6 + 1);
		if (globals::g_BuildingBase_COUNT <= uVar4) {
			return globals::g_BuildingBase_COUNT;
		}
	} while( true );
}



void __cdecl lego::game::Construction_FUN_00408c10(int param_1,LiveObject *liveObj)
{
	BlockStruct_d4 *pBVar1;
	
	pBVar1 = Construction_Block_FUN_00408ff0(NULL,&param_1);
	if (pBVar1 == NULL) {
		if (liveObj->objType == OBJECT_POWERCRYSTAL) {
			Message_AddMessageAction(MESSAGE_GENERATECRYSTAL_COMPLETE,liveObj,0,NULL);
			return;
		}
		Message_AddMessageAction(MESSAGE_GENERATEORE_COMPLETE,liveObj,0,NULL);
	}
	else {
		if (liveObj != NULL) {
			liveObj->flags4 = liveObj->flags4 | 0x100;
			pBVar1->liveObjs_2c[pBVar1->liveObjsCount_cc] = liveObj;
			pBVar1->liveObjsCount_cc = pBVar1->liveObjsCount_cc + 1;
			*(int *)&pBVar1->field_0x20 = *(int *)&pBVar1->field_0x20 + 1;
		}
		if (*(int *)&pBVar1->field_0x1c == *(int *)&pBVar1->field_0x20) {
			*(undefined4 *)&pBVar1->field_0x28 = 0x42fa0000;
			pBVar1->flags = pBVar1->flags | 1;
			return;
		}
	}
	return;
}



BOOL __cdecl lego::game::Construction_FUN_00408ca0(int param_1,int param_2,int param_3)
{
	BlockStruct_d4 *pBVar1;
	uint uVar2;
	ObjectType objType;
	uint uVar3;
	
	pBVar1 = Construction_Block_FUN_00408ff0(NULL,&param_1);
	if (pBVar1 != NULL) {
		uVar2 = Construction_FUN_00408d40(pBVar1,param_2,param_3);
		objType = (-(uint)((pBVar1->flags & 2) != 0) & 0xb) + OBJECT_BUILDING;
		if (param_2 == 6) {
			uVar3 = Object_GetCostCrystal(objType,pBVar1->field_0,0);
		}
		else {
			if (param_2 != 7) {
				return 1;
			}
			if (param_3 == 0) {
				uVar3 = Object_GetCostOre(objType,pBVar1->field_0,0);
			}
			else {
				uVar3 = Object_GetCostRefinedOre(objType,pBVar1->field_0,0);
			}
		}
		if (uVar2 < uVar3) {
			return TRUE;
		}
	}
	return 0;
}



int __cdecl
lego::game::Construction_FUN_00408d40(BlockStruct_d4 *param_1,ObjectType objType,int objIndex)
{
	int iVar1;
	LiveObject **ppLVar2;
	int iVar3;
	
	iVar1 = 0;
										// count of the list field
	iVar3 = *(int *)&param_1->field_0x20;
	if (iVar3 != 0) {
										// a ptr list field
		ppLVar2 = param_1->liveObjs_2c;
		do {
			if ((objType == (*ppLVar2)->objType) && (objIndex == (*ppLVar2)->objIndex)) {
				iVar1 += 1;
			}
			ppLVar2 = ppLVar2 + 1;
			iVar3 += -1;
		} while (iVar3 != 0);
	}
	return iVar1;
}



void __cdecl
lego::game::Construction_SpawnCarryableObject
					(Point2I *blockPos,ObjectType objType,int objIndex,int objLevel,uint count)
{
	BlockStruct_d4 *pBVar1;
	
	pBVar1 = Construction_Block_FUN_00408ff0(blockPos,NULL);
	if ((objType == OBJECT_ORE) && (objIndex == ORE_PROCESSED)) {
		pBVar1->flags = pBVar1->flags | 8;
	}
	if (count != 0) {
		do {
			*(int *)&pBVar1->field_0x1c = *(int *)&pBVar1->field_0x1c + 1;
			ai::AITask_DoRequest_ObjectType(objType,objIndex,objLevel,blockPos,pBVar1->int_8,NULL,0);
			count -= 1;
		} while (count != 0);
	}
	return;
}



void __cdecl lego::game::Construction_FUN_00408df0(Point2I *blockPos,uint *param_2,uint param_3)
{
	uint *puVar1;
	bool bVar2;
	BlockStruct_d4 *pBVar3;
	SurfaceMap *surfMap;
	uint *puVar4;
	uint uVar5;
	uint *puVar6;
	uint *puVar7;
	Point2I *blockPos_00;
	uint *puVar8;
	float10 fVar9;
	uint local_4c;
	int local_40 [5];
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	Point2F local_20;
	float local_18;
	undefined4 local_14;
	undefined4 local_10;
	float local_c;
	float local_8;
	undefined4 local_4;
	
	pBVar3 = Construction_Block_FUN_00408ff0(blockPos,NULL);
	surfMap = GetSurfaceMap();
	fVar9 = Map3D_GetBlockSize(surfMap);
	local_40[2] = 1;
	local_2c = 1;
	local_40[1] = 0xffffffff;
	local_28 = 0xffffffff;
	local_40[0] = 0;
	local_40[3] = 0;
	local_40[4] = 0;
	local_24 = 0;
	local_4c = 0;
	local_20.x = 0.5;
	local_14 = 0x3f000000;
	local_10 = 0x3f000000;
	local_4 = 0x3f000000;
	local_c = (float)((float10)8.8 / fVar9);
	local_20.y = 1.0 - local_c;
	if (param_3 != 0) {
		puVar6 = param_2 + 1;
		puVar8 = param_2 + 2;
		blockPos_00 = (Point2I *)param_2;
		local_18 = local_20.y;
		local_8 = local_c;
		do {
			if (((local_4c == param_3 - 1) || (blockPos_00->x != *puVar8)) || (*puVar6 != puVar8[1])) {
				blockPos = NULL;
				do {
					bVar2 = false;
					uVar5 = 0;
					puVar4 = param_2;
					puVar1 = param_2;
					do {
						puVar7 = puVar1 + 2;
						if (((uVar5 == param_3 - 1) || (*puVar4 != *puVar7)) || (puVar4[1] != puVar1[3])) {
							if ((*puVar4 ==
									 *(int *)((int)((int)register0x00000010 + -0x40) + (int)blockPos) + blockPos_00->x
									) && (puVar4[1] ==
												*puVar6 + *(int *)((int)register0x00000010 + -0x3c + (int)blockPos))) {
								bVar2 = true;
							}
						}
						else {
							uVar5 += 1;
							puVar7 = puVar1 + 4;
							puVar4 = puVar4 + 2;
						}
						uVar5 += 1;
						puVar4 = puVar4 + 2;
						puVar1 = puVar7;
					} while (uVar5 < param_3);
					if (!bVar2) {
						ai::AITask_DoRequest_ObjectType
											(OBJECT_BARRIER,0,0,blockPos_00,pBVar3->int_8,
											 (Point2F *)((int)&blockPos->x + (int)&local_20.x),1);
						*(int *)&pBVar3->field_0x1c = *(int *)&pBVar3->field_0x1c + 1;
					}
					blockPos = blockPos + 1;
				} while (blockPos < (Point2I *)&DAT_00000020);
			}
			else {
				local_4c += 1;
				puVar8 = puVar8 + 2;
				blockPos_00 = blockPos_00 + 1;
				puVar6 = puVar6 + 2;
			}
			local_4c += 1;
			puVar8 = puVar8 + 2;
			blockPos_00 = blockPos_00 + 1;
			puVar6 = puVar6 + 2;
		} while (local_4c < param_3);
	}
	return;
}



BOOL __cdecl lego::game::Construction_Block_FUN_00408fd0(Point2I *blockPos)
{
	BlockStruct_d4 *pBVar1;
	
	pBVar1 = Construction_Block_FUN_00408ff0(blockPos,NULL);
	return (uint)(pBVar1 != NULL);
}



BlockStruct_d4 * __cdecl
lego::game::Construction_Block_FUN_00408ff0(Point2I *blockPos,int *opt_param_2)
{
	BlockStruct_d4 **ppBVar1;
	BlockStruct_d4 *pBVar2;
	
	pBVar2 = STRUCTD4_004b9a24;
	if (STRUCTD4_004b9a24 != NULL) {
		do {
			if (blockPos == NULL) {
				if ((opt_param_2 != NULL) && (*opt_param_2 == pBVar2->int_8)) {
					return pBVar2;
				}
			}
			else {
				if ((blockPos->x == (pBVar2->pointi_c).x) && (blockPos->y == (pBVar2->pointi_c).y)) {
					return pBVar2;
				}
			}
			ppBVar1 = &pBVar2->next_24;
			pBVar2 = *ppBVar1;
		} while (*ppBVar1 != NULL);
	}
	return NULL;
}



void __cdecl lego::game::Construction_Block_FUN_00409040(Point2I *blockPos)
{
	BlockStruct_d4 *pBVar1;
	
	pBVar1 = Construction_Block_FUN_00408ff0(blockPos,NULL);
	if (pBVar1 != NULL) {
		front::Interface_BackToMain_IfSelectedGroundOrConstruction_IsBlockPos(blockPos);
		Construction_FUN_00409970(pBVar1);
		Construction_Free(pBVar1);
	}
	return;
}



void __cdecl lego::game::Construction_Cancel2(Point2I *blockPos)
{
	LiveFlags4 *pLVar1;
	LiveObject *liveObj;
	BlockStruct_d4 *pBVar2;
	uint uVar3;
	LiveObject **ppLVar4;
	
	pBVar2 = Construction_Block_FUN_00408ff0(blockPos,NULL);
	Level_Block_Proc_FUN_00432490(blockPos,0);
	uVar3 = 0;
	if (pBVar2->liveObjsCount_cc != 0) {
		ppLVar4 = pBVar2->liveObjs_2c;
		do {
			liveObj = *ppLVar4;
			pLVar1 = &liveObj->flags4;
			*pLVar1 = *pLVar1 & 0xfffffeff;
			ai::AITask_DoCollect(liveObj,0.0);
			uVar3 += 1;
			ppLVar4 = ppLVar4 + 1;
		} while (uVar3 < pBVar2->liveObjsCount_cc);
	}
	front::Interface_BackToMain_IfSelectedGroundOrConstruction_IsBlockPos(blockPos);
	ai::AITask_FUN_00403630(pBVar2->int_8,0,0,0);
	Construction_Free(pBVar2);
	return;
}



void __cdecl lego::game::Construction_Update(float elapsedGame)
{
	uint uVar1;
	BlockStruct_d4 *pBVar2;
	BOOL BVar3;
	BlockStruct_d4 *pBVar4;
	
	pBVar4 = STRUCTD4_004b9a24;
	if (STRUCTD4_004b9a24 != NULL) {
		do {
			uVar1 = pBVar4->flags;
			pBVar2 = pBVar4->next_24;
			if (((uVar1 & 2) == 0) || ((uVar1 & 4) != 0)) {
				if ((uVar1 & 1) != 0) {
					if ((uVar1 & 2) == 0) {
						BVar3 = Construction_LiveObject_DoBlockStructD4_Callbacks_FUN_004091a0(pBVar4);
						if (BVar3 != 0) {
							Construction_FUN_00409970(pBVar4);
							Construction_FUN_00409a60(pBVar4,1);
							Construction_Free(pBVar4);
						}
					}
					else {
						ai::AITask_DoBuildPath_AtPosition(&pBVar4->pointi_c);
						pBVar4->flags = pBVar4->flags & 0xfffffffe;
					}
				}
			}
			else {
				Construction_FUN_00409480(pBVar4);
			}
			pBVar4 = pBVar2;
		} while (pBVar2 != NULL);
	}
	return;
}



BOOL __cdecl
lego::game::Construction_LiveObject_DoBlockStructD4_Callbacks_FUN_004091a0(BlockStruct_d4 *param_1)
{
	BOOL BVar1;
	
	BVar1 = Search_LiveObjects_SkipIgnoreMes
										(Construction_LiveObject_Callback_FindIn_BlockStructD4Table,
										 (undefined4 *)param_1);
	return (uint)(BVar1 == 0);
}



BOOL __cdecl
lego::game::Construction_LiveObject_Callback_FindIn_BlockStructD4Table
					(LiveObject *liveObj,BlockStruct_d4 *data)
{
	uint index;
	LiveObject **ppLVar1;
	Point2I local_8;
	uint count;
	
	LiveObject_GetBlockPos(liveObj,(int *)&local_8,&local_8.y);
	if (((data->pointi_c).x == local_8.x) && ((data->pointi_c).y == local_8.y)) {
		count = data->liveObjsCount_cc;
		index = 0;
		if (count != 0) {
			ppLVar1 = data->liveObjs_2c;
			do {
				if (liveObj == *ppLVar1) break;
				index += 1;
				ppLVar1 = ppLVar1 + 1;
			} while (index < count);
		}
		if (index == count) {
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Construction_Block_FUN_00409230(Point2I *blockPos)
{
	BOOL BVar1;
	BlockStruct_d4 *pBVar2;
	
	BVar1 = Level_Block_IsPowerPath(blockPos);
	if (BVar1 == 0) {
		pBVar2 = Construction_CreateBlock(blockPos);
		Level_Block_Proc_FUN_00432490(blockPos,TRUE);
		pBVar2->flags = pBVar2->flags | 2;
		front::Interface_BackToMain_IfSelectedGroundOrConstruction_IsBlockPos(blockPos);
		return TRUE;
	}
	return 0;
}



BlockStruct_d4 * __cdecl lego::game::Construction_CreateBlock(Point2I *blockPos)
{
	BlockStruct_d4 *pBVar1;
	int iVar2;
	BlockStruct_d4 *pBVar3;
	
	pBVar1 = (BlockStruct_d4 *)std::malloc(0xd4);
	pBVar3 = pBVar1;
	for (iVar2 = 0x35; iVar2 != 0; iVar2 += -1) {
		pBVar3->field_0 = 0;
		pBVar3 = (BlockStruct_d4 *)&pBVar3->field_4;
	}
	*(undefined4 *)&pBVar1->field_0x20 = 0;
	*(undefined4 *)&pBVar1->field_0x1c = 0;
	pBVar1->int_8 = UINT_004b9a20;
	UINT_004b9a20 += 1;
	(pBVar1->pointi_c).x = blockPos->x;
	(pBVar1->pointi_c).y = blockPos->y;
	pBVar1->next_24 = STRUCTD4_004b9a24;
	STRUCTD4_004b9a24 = pBVar1;
	return pBVar1;
}



void __cdecl lego::game::Construction_Level_Block_FUN_004092e0(Point2I *blockPos)
{
	Point2I *pPVar1;
	BOOL BVar2;
	Point2I *blockPos_00;
	int iVar3;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_20[0] = 0;
	local_20[1] = 0xffffffff;
	local_20[2] = 1;
	local_20[3] = 0;
	local_20[4] = 0;
	local_c = 1;
	local_8 = 0xffffffff;
	local_4 = 0;
	iVar3 = 4;
	pPVar1 = (Point2I *)&stack0xffffffd8;
	do {
		blockPos_00 = pPVar1 + 1;
		blockPos_00->x = blockPos_00->x + blockPos->x;
		pPVar1[1].y = pPVar1[1].y + blockPos->y;
		BVar2 = Level_Block_IsPowerPath(blockPos_00);
		if (BVar2 == 0) {
			BVar2 = Level_BlockIsFlags1_400_AndOptIsFlags2_4(blockPos_00->x,pPVar1[1].y,TRUE);
			if (BVar2 != 0) goto LAB_00409350;
		}
		else {
LAB_00409350:
			BVar2 = Level_BlockHasFlag2_100(blockPos_00);
			if (BVar2 == 0) {
				Level_Block_FUN_00432030(blockPos_00);
				Construction_Level_Block_FUN_004092e0(blockPos_00);
			}
		}
		iVar3 += -1;
		pPVar1 = blockPos_00;
		if (iVar3 == 0) {
			return;
		}
	} while( true );
}



BOOL __cdecl
lego::game::Construction_Level_Blocks_UnkPowerCrystalProc_FUN_00409380
					(Point2I *blockPos,int crystalCount)
{
	BOOL BVar1;
	
	BVar1 = Construction_Level_Block_UnkDrainedPower_FUN_004093a0(blockPos,crystalCount);
	Game_UnkProcessBlockPtsTable_UnsetsFlag2_2();
	return BVar1;
}



BOOL __cdecl
lego::game::Construction_Level_Block_UnkDrainedPower_FUN_004093a0
					(Point2I *blockPos,int crystalCount)
{
	BOOL BVar1;
	LiveObject *liveObj;
	Point2I *blockPos_00;
	uint uVar2;
	Point2I DIRECTIONS [4];
	
	uVar2 = 0;
	DIRECTIONS[0].x = 0;
	DIRECTIONS[0].y = -1;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[2].y = 1;
	DIRECTIONS[3].x = -1;
	DIRECTIONS[3].y = 0;
	blockPos_00 = DIRECTIONS;
	do {
		blockPos_00->x = blockPos_00->x + blockPos->x;
		blockPos_00->y = blockPos_00->y + blockPos->y;
		BVar1 = Level_IsBlockFlag2_1(blockPos_00);
		if (((BVar1 != 0) && (liveObj = Game_Unk_DoSearchCallbacks_Unique(blockPos_00), liveObj != NULL)
				) && (BVar1 = LiveObject_AddThisDrainedCrystals(liveObj,crystalCount), BVar1 != 0)) {
			return 1;
		}
		BVar1 = Level_Block_IsPowerPath(blockPos_00);
		if (((BVar1 != 0) ||
				(BVar1 = Level_BlockIsFlags1_400_AndOptIsFlags2_4(blockPos_00->x,blockPos_00->y,TRUE),
				BVar1 != 0)) && (BVar1 = Level_IsBlockFlag2_2(blockPos_00), BVar1 == 0)) {
			Level_AddBlockToGameTable_AndSetFlag2_2(blockPos_00);
			BVar1 = Construction_Level_Block_UnkDrainedPower_FUN_004093a0(blockPos_00,crystalCount);
			if (BVar1 != 0) {
				return TRUE;
			}
		}
		uVar2 += 1;
		blockPos_00 = blockPos_00 + 1;
	} while (uVar2 < 4);
	return 0;
}



void __cdecl lego::game::Construction_FUN_00409480(BlockStruct_d4 *param_1)
{
	Point2I *blockPos;
	int iVar1;
	LiveObject *pLVar2;
	uint count;
	uint count_00;
	uint uVar3;
	
	blockPos = &param_1->pointi_c;
	iVar1 = util::return_1(blockPos);
	if (iVar1 != 0) {
		pLVar2 = LiveObject_FUN_00438da0(NULL,blockPos,OBJECT_ORE,0);
		count = Object_GetCostCrystal(OBJECT_PATH,0,0);
		count_00 = Object_GetCostOre(OBJECT_PATH,0,0);
		uVar3 = Object_GetCostRefinedOre(OBJECT_PATH,0,0);
		Construction_SpawnCarryableObject(blockPos,OBJECT_POWERCRYSTAL,0,0,count);
		if ((pLVar2 == NULL) || (uVar3 == 0)) {
			iVar1 = 0;
		}
		else {
			iVar1 = 1;
			count_00 = uVar3;
		}
		Construction_SpawnCarryableObject(blockPos,OBJECT_ORE,iVar1,0,count_00);
		param_1->flags = param_1->flags | 4;
	}
	return;
}



void __cdecl lego::game::Construction_Cancel(Point2I *blockPos)
{
	LiveObject *pLVar1;
	LevelData *level;
	BlockStruct_d4 *pBVar2;
	int iVar3;
	int iVar4;
	int *piVar5;
	uint uVar6;
	LiveObject **ppLVar7;
	uint uVar8;
	
	level = globs::gameGlobs.level;
	pBVar2 = Construction_Block_FUN_00408ff0(blockPos,NULL);
	if ((pBVar2 != NULL) && (*(int *)&pBVar2->field_0x1c != *(int *)&pBVar2->field_0x20)) {
		uVar8 = *(uint *)&pBVar2->field_0x18;
		uVar6 = 0;
		if (uVar8 != 0) {
			do {
				if (((uVar6 != uVar8 - 1) &&
						(iVar3 = *(int *)&pBVar2->field_0x14,
						*(int *)(iVar3 + uVar6 * 8) == *(int *)(iVar3 + 8 + uVar6 * 8))) &&
					 (iVar4 = *(int *)(iVar3 + 4 + uVar6 * 8), iVar4 == *(int *)(iVar3 + 0xc + uVar6 * 8))) {
					iVar3 = iVar4 * (level->dimensions).width + *(int *)(iVar3 + uVar6 * 8);
					level->blocks[iVar3].flags1 = level->blocks[iVar3].flags1 & ~BLOCK1_UNK_8000;
				}
				iVar3 = uVar6 * 8;
				iVar4 = *(int *)(iVar3 + 4 + *(int *)&pBVar2->field_0x14) * (level->dimensions).width +
								*(int *)(iVar3 + *(int *)&pBVar2->field_0x14);
				level->blocks[iVar4].flags1 = level->blocks[iVar4].flags1 & ~BLOCK1_UNK_100000;
				level->blocks
				[*(int *)(iVar3 + 4 + *(int *)&pBVar2->field_0x14) * (level->dimensions).width +
				 *(int *)(iVar3 + *(int *)&pBVar2->field_0x14)].ptr_10 = NULL;
				piVar5 = (int *)(*(int *)&pBVar2->field_0x14 + iVar3);
				Level_UpdateBlockSurfaceUnk(level,*piVar5,piVar5[1],0);
				front::Interface_BackToMain_IfSelectedGroundOrConstruction_IsBlockPos
									((Point2I *)(iVar3 + *(int *)&pBVar2->field_0x14));
				uVar8 = *(uint *)&pBVar2->field_0x18;
				uVar6 += 1;
			} while (uVar6 < uVar8);
		}
		uVar8 = 0;
		if (pBVar2->liveObjsCount_cc != 0) {
			ppLVar7 = pBVar2->liveObjs_2c;
			do {
				pLVar1 = *ppLVar7;
				if (pLVar1->objType == OBJECT_BARRIER) {
					pLVar1->flags3 = pLVar1->flags3 | LIVEOBJ3_UNK_800000;
					(*ppLVar7)->health = -1.0;
				}
				else {
					pLVar1->flags4 = pLVar1->flags4 & 0xfffffeff;
					ai::AITask_DoCollect(*ppLVar7,0.0);
				}
				uVar8 += 1;
				ppLVar7 = ppLVar7 + 1;
			} while (uVar8 < pBVar2->liveObjsCount_cc);
		}
		ai::AITask_FUN_00403630(pBVar2->int_8,0,0,0);
		Construction_Free(pBVar2);
	}
	return;
}



int __cdecl
lego::game::Construction_FUN_004096c0
					(int objIndex,Point2I *param_2,Direction direction,Point2I *param_4,uint count)
{
	LevelBlockFlags1 *pLVar1;
	bool bVar2;
	LevelData *level;
	BlockStruct_d4 *pBVar3;
	int *piVar4;
	SurfaceMap *surfMap;
	uint uVar5;
	int iVar6;
	Point2I *pPVar7;
	Point2I *pPVar8;
	uint *puVar9;
	float fVar10;
	
	level = globs::gameGlobs.level;
	pBVar3 = Construction_CreateBlock(param_2);
	pBVar3->field_0 = objIndex;
	pBVar3->field_4 = direction;
	piVar4 = (int *)std::malloc(count * 8);
	*(int **)&pBVar3->field_0x14 = piVar4;
	pPVar7 = param_4;
	for (uVar5 = count * 8 >> 2; uVar5 != 0; uVar5 -= 1) {
		*piVar4 = pPVar7->x;
		pPVar7 = (Point2I *)&pPVar7->y;
		piVar4 = piVar4 + 1;
	}
	fVar10 = 4.0;
	for (iVar6 = 0; iVar6 != 0; iVar6 += -1) {
		*(undefined *)piVar4 = *(undefined *)&pPVar7->x;
		pPVar7 = (Point2I *)((int)&pPVar7->x + 1);
		piVar4 = (int *)((int)piVar4 + 1);
	}
	puVar9 = *(uint **)&pBVar3->field_0x14;
	*(uint *)&pBVar3->field_0x18 = count;
	uVar5 = count;
	surfMap = GetSurfaceMap();
	Map3D_FUN_0044ed90(surfMap,puVar9,uVar5,fVar10);
	param_2 = NULL;
	if (count != 0) {
		pPVar7 = param_4 + 1;
		do {
			if (((param_2 == (Point2I *)(count - 1)) || (param_4->x != pPVar7->x)) ||
				 (param_4->y != pPVar7->y)) {
				bVar2 = false;
			}
			else {
				bVar2 = true;
				pLVar1 = &level->blocks[param_4->y * (level->dimensions).width + param_4->x].flags1;
				*pLVar1 = *pLVar1 | BLOCK1_UNK_8000;
				level->blocks[param_4->y * (level->dimensions).width + param_4->x].ptr_10 = pBVar3;
			}
			iVar6 = param_4->y * (level->dimensions).width + param_4->x;
			level->blocks[iVar6].flags1 = level->blocks[iVar6].flags1 | BLOCK1_UNK_100000;
			level->blocks[param_4->y * (level->dimensions).width + param_4->x].ptr_10 = pBVar3;
			Level_UpdateBlockSurfaceUnk(level,param_4->x,param_4->y,0);
			Construction_FlattenGround(param_4);
			front::Interface_BackToMain_IfSelectedGroundOrConstruction_IsBlockPos(param_4);
			pPVar8 = param_4;
			if (bVar2) {
				param_2 = (Point2I *)((int)&param_2->x + 1);
				pPVar8 = param_4 + 1;
				pPVar7 = pPVar7 + 1;
			}
			param_4 = pPVar7;
			param_2 = (Point2I *)((int)&param_2->x + 1);
			pPVar7 = param_4 + 1;
			param_4 = pPVar8 + 1;
		} while (param_2 < count);
	}
	return pBVar3->int_8;
}



void __cdecl lego::game::Construction_FlattenGround(Point2I *blockPos)
{
	int *piVar1;
	int iVar2;
	Point2I ANGLES [8];
	
	ANGLES[0].x = -1;
	ANGLES[0].y = -1;
	ANGLES[1].x = 0;
	ANGLES[1].y = -1;
	ANGLES[2].x = 1;
	ANGLES[2].y = -1;
	ANGLES[3].x = 1;
	ANGLES[3].y = 0;
	ANGLES[4].x = 1;
	ANGLES[4].y = 1;
	ANGLES[5].x = 0;
	ANGLES[5].y = 1;
	ANGLES[6].x = -1;
	ANGLES[6].y = 1;
	ANGLES[7].x = -1;
	ANGLES[7].y = 0;
	iVar2 = 8;
	piVar1 = (int *)&stack0xffffffb8;
	do {
		Level_Block_LowerDigVertices
							(globs::gameGlobs.level,blockPos->x + piVar1[2],piVar1[3] + blockPos->y);
		iVar2 += -1;
		piVar1 = piVar1 + 2;
	} while (iVar2 != 0);
	return;
}



void __cdecl lego::game::Construction_RemoveAll(void)
{
	BlockStruct_d4 *pBVar1;
	BlockStruct_d4 *pBVar2;
	
	pBVar2 = STRUCTD4_004b9a24;
	if (STRUCTD4_004b9a24 != NULL) {
		do {
			pBVar1 = pBVar2->next_24;
			Construction_Free(pBVar2);
			pBVar2 = pBVar1;
		} while (pBVar1 != NULL);
	}
	return;
}



void __cdecl lego::game::Construction_Free(BlockStruct_d4 *param_1)
{
	BlockStruct_d4 *pBVar1;
	BlockStruct_d4 *pBVar2;
	BlockStruct_d4 *pBVar3;
	
	pBVar1 = STRUCTD4_004b9a24;
	pBVar3 = NULL;
	if (STRUCTD4_004b9a24 != NULL) {
		do {
			pBVar2 = pBVar1;
			if (pBVar2 == param_1) {
				if (pBVar3 == NULL) {
					STRUCTD4_004b9a24 = pBVar2->next_24;
				}
				else {
					pBVar3->next_24 = pBVar2->next_24;
				}
				break;
			}
			pBVar1 = pBVar2->next_24;
			pBVar3 = pBVar2;
		} while (pBVar2->next_24 != NULL);
	}
	std::free(*(void **)&param_1->field_0x14);
	std::free(param_1);
	return;
}



void __cdecl lego::game::Construction_FUN_00409970(BlockStruct_d4 *param_1)
{
	LiveObject *pLVar1;
	uint uVar2;
	LiveObject **ppLVar3;
	
	uVar2 = 0;
	if (param_1->liveObjsCount_cc != 0) {
		ppLVar3 = param_1->liveObjs_2c;
		do {
			pLVar1 = *ppLVar3;
			ppLVar3 = ppLVar3 + 1;
			pLVar1->health = -1.0;
			uVar2 += 1;
			pLVar1->flags3 = pLVar1->flags3 | LIVEOBJ3_UNK_800000;
		} while (uVar2 < param_1->liveObjsCount_cc);
	}
	return;
}



LiveObject * __cdecl
lego::game::Construction_Block_FUN_004099c0
					(uint param_1,Point2I *blockPos,undefined4 param_3,uint *param_4,uint param_5,int param_6)
{
	SurfaceMap *surfMap;
	LiveObject *pLVar1;
	int iVar2;
	BlockStruct_d4 *pBVar3;
	float fVar4;
	BlockStruct_d4 local_d4;
	
	pBVar3 = &local_d4;
	for (iVar2 = 0x35; iVar2 != 0; iVar2 += -1) {
		pBVar3->field_0 = 0;
		pBVar3 = (BlockStruct_d4 *)&pBVar3->field_4;
	}
	local_d4.pointi_c.x = blockPos->x;
	local_d4.pointi_c.y = blockPos->y;
	local_d4.field_0 = param_1;
	local_d4.field_4 = param_3;
	fVar4 = 4.0;
	local_d4._20_4_ = param_4;
	local_d4._24_4_ = param_5;
	surfMap = GetSurfaceMap();
	Map3D_FUN_0044ed90(surfMap,param_4,param_5,fVar4);
	Construction_FlattenGround(blockPos);
	pLVar1 = Construction_FUN_00409a60(&local_d4,param_6);
	return pLVar1;
}



LiveObject * __cdecl lego::game::Construction_FUN_00409a60(BlockStruct_d4 *param_1,int param_2)
{
	int iVar1;
	int iVar2;
	int *piVar3;
	ulonglong uVar4;
	SurfaceMap *surfMap;
	LiveObject *liveObj;
	uint uVar5;
	ObjectStatsFlags1 OVar6;
	ObjectStatsFlags2 OVar7;
	uint uVar8;
	uint bx;
	float *out_x;
	float *out_y;
	float local_c;
	float local_8;
	undefined4 uStack4;
	
	uVar8 = 0;
	uStack4 = 0;
	out_y = &local_c;
	local_8 = (float)param_1->field_4;
	out_x = &local_8;
	uVar5 = (param_1->pointi_c).y;
	uVar4 = (ulonglong)(uint)local_8;
	bx = (param_1->pointi_c).x;
	surfMap = GetSurfaceMap();
	Map3D_BlockToWorldPos(surfMap,bx,uVar5,out_x,out_y);
	liveObj = Game_CreateLiveResourceObject
											((Container *)(globs::gameGlobs.BuildingData_TABLE + param_1->field_0),
											 OBJECT_BUILDING,param_1->field_0,0,local_8,local_c,(float)uVar4 * 1.570796);
	if (param_2 != 0) {
		liveObject_UnkActivityTeleport_FUN_00447dc0(liveObj);
		front::Info_FUN_00419ab0(INFO_CONSTRUCTED,NULL,liveObj,NULL);
	}
	uVar5 = *(uint *)&param_1->field_0x18;
	if (uVar5 != 0) {
		do {
			if (uVar8 == uVar5 - 1) {
LAB_00409b4b:
				OVar6 = LiveObject_GetStatsFlags1(liveObj);
				iVar1 = uVar8 * 8;
				if ((OVar6 & STATS1_TOOLSTORE) == STATS1_NONE) {
					front::Interface_BackToMain_IfSelectedGroundOrConstruction_IsBlockPos
										((Point2I *)(iVar1 + *(int *)&param_1->field_0x14));
					FUN_00432380(*(int **)(iVar1 + *(int *)&param_1->field_0x14),
											 *(int **)(iVar1 + 4 + *(int *)&param_1->field_0x14));
					OVar7 = LiveObject_GetStatsFlags2(liveObj);
					if ((OVar7 & STATS2_GENERATEPOWER) != STATS2_NONE) {
						FUN_00432500((int *)(iVar1 + *(int *)&param_1->field_0x14));
					}
					Construction_Block_FUN_00409c00((Point2I *)(iVar1 + *(int *)&param_1->field_0x14));
				}
				else {
					FUN_00432320((int **)(iVar1 + *(int *)&param_1->field_0x14));
				}
				ElectricFence_UpdateBlockAndSurrounding4Surfaces
									(*(int *)(iVar1 + *(int *)&param_1->field_0x14),
									 *(int *)(iVar1 + 4 + *(int *)&param_1->field_0x14));
			}
			else {
				iVar2 = *(int *)&param_1->field_0x14;
				iVar1 = uVar8 * 8;
				if ((*(int *)(iVar1 + iVar2) != *(int *)(iVar1 + 8 + iVar2)) ||
					 (piVar3 = *(int **)(iVar1 + 4 + iVar2), piVar3 != *(int **)(iVar1 + 0xc + iVar2)))
				goto LAB_00409b4b;
				FUN_004323c0(*(int **)(iVar1 + iVar2),piVar3);
				FUN_004403f0((int)liveObj,(int *)(iVar1 + *(int *)&param_1->field_0x14));
				uVar8 += 1;
			}
			uVar5 = *(uint *)&param_1->field_0x18;
			uVar8 += 1;
		} while (uVar8 < uVar5);
	}
	return liveObj;
}



void __cdecl lego::game::Construction_Block_FUN_00409c00(Point2I *blockPos)
{
	int iVar1;
	Point2I *blockOffPos;
	Point2I DIRECTIONS_I [4];
	
	DIRECTIONS_I[0].x = 0;
	DIRECTIONS_I[0].y = -1;
	DIRECTIONS_I[1].x = 1;
	DIRECTIONS_I[1].y = 0;
	DIRECTIONS_I[2].x = 0;
	DIRECTIONS_I[2].y = 1;
	DIRECTIONS_I[3].x = -1;
	DIRECTIONS_I[3].y = 0;
	blockOffPos = DIRECTIONS_I;
	iVar1 = 4;
	do {
		blockOffPos->x = blockOffPos->x + blockPos->x;
		blockOffPos->y = blockOffPos->y + blockPos->y;
		ai::AITask_Block_FUN_00402a10(blockOffPos,0);
		blockOffPos = blockOffPos + 1;
		iVar1 += -1;
	} while (iVar1 != 0);
	return;
}



void __cdecl lego::game::Game_DisableCryOreDrop(BOOL param_1)
{
	globals::g_Disable_CryOreDrop = param_1;
	return;
}



void __cdecl lego::game::LiveObject_FUN_00409c80(LiveObject *liveObj)
{
	bool bVar1;
	Point2I *pPVar2;
	Point2I *blockPos;
	SurfaceMap *pSVar3;
	Point2I *pPVar4;
	Direction rotation;
	uint uVar5;
	float10 fVar6;
	uint bx;
	uint by;
	Vector3F *out_x;
	float x;
	float *out_y;
	float y;
	uint local_34;
	Point2F local_30;
	Point2I local_28;
	float local_20;
	float local_1c;
	Vector3F local_18;
	Vector3F local_c;
	
	LiveObject_GetFaceDirection(liveObj,&local_30);
	LiveObject_GetBlockPos(liveObj,(int *)&local_28,&local_28.y);
	LiveObject_GetPosition(liveObj,&local_20,&local_1c);
	if (ABS(local_30.x) <= ABS(local_30.y)) {
		if ((ushort)((ushort)(local_30.y < 0.0) << 8 | (ushort)(local_30.y == 0.0) << 0xe) == 0) {
			rotation = DIRECTION_UP;
		}
		else {
			rotation = DIRECTION_DOWN;
		}
	}
	else {
		if ((ushort)((ushort)(local_30.x < 0.0) << 8 | (ushort)(local_30.x == 0.0) << 0xe) == 0) {
			rotation = DIRECTION_RIGHT;
		}
		else {
			rotation = DIRECTION_LEFT;
		}
	}
	pPVar2 = res::Building_GetShapePoints
										 (globs::gameGlobs.BuildingData_TABLE + liveObj->objIndex,&local_34);
	blockPos = Game_TransformShapePoints(&local_28,pPVar2,local_34,rotation);
	uVar5 = 0;
	pPVar2 = blockPos;
	if (local_34 != 0) {
		do {
			pPVar4 = pPVar2 + 1;
			if (((uVar5 == local_34 - 1) || (blockPos->x != pPVar4->x)) || (blockPos->y != pPVar2[1].y)) {
				bVar1 = false;
			}
			else {
				bVar1 = true;
			}
			Level_Block_UnsetFlags1_108400PwrPath_AndUnsetFlags2_4_UpdateSurface(blockPos);
			Level_Block_UnsetFlags2_1(blockPos);
			if ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_8) == 0) {
				by = blockPos->y;
				out_y = &local_18.y;
				out_x = &local_18;
				bx = blockPos->x;
				pSVar3 = GetSurfaceMap();
				Map3D_BlockToWorldPos(pSVar3,bx,by,(float *)out_x,out_y);
				x = local_18.x;
				y = local_18.y;
				pSVar3 = GetSurfaceMap();
				fVar6 = Map3D_GetWorldZ(pSVar3,x,y);
				local_18.z = (float)fVar6;
				math::Maths_Vector3DRandom(&local_c);
				local_c.z = 0.0;
				lego::effect::Effect_Spawn_Particle(MISCOBJECT_PATHDUST,&local_18,&local_c);
				ai::AITask_DoClearTypeAction(blockPos,MESSAGE_CLEARBUILDING_COMPLETE);
			}
			ElectricFence_UpdateBlockAndSurrounding4Surfaces(blockPos->x,blockPos->y);
			if (bVar1) {
				uVar5 += 1;
				pPVar4 = pPVar2 + 2;
				blockPos = blockPos + 1;
			}
			uVar5 += 1;
			blockPos = blockPos + 1;
			pPVar2 = pPVar4;
		} while (uVar5 < local_34);
	}
	LiveObject_FUN_00409e50(liveObj);
	return;
}



void __cdecl lego::game::LiveObject_FUN_00409e50(LiveObject *liveObj)
{
	int iVar1;
	int iVar2;
	Point2I local_8;
	
	if ((liveObj->flags4 & LIVEOBJ4_UNK_800) == LIVEOBJ4_NONE) {
		LiveObject_GetBlockPos(liveObj,(int *)&local_8,&local_8.y);
		iVar1 = Object_GetCostOre(OBJECT_BUILDING,liveObj->objIndex,liveObj->objLevel);
		iVar2 = Object_GetCostCrystal(OBJECT_BUILDING,liveObj->objIndex,liveObj->objLevel);
		Object_GetCostRefinedOre(OBJECT_BUILDING,liveObj->objIndex,liveObj->objLevel);
		if (globals::g_Disable_CryOreDrop == 0) {
			for (; iVar2 != 0; iVar2 += -1) {
				Level_GenerateCrystal(&local_8,0,NULL,FALSE);
			}
			for (; iVar1 != 0; iVar1 += -1) {
				Level_GenerateOre(&local_8,0,NULL,FALSE);
			}
		}
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_800;
	}
	return;
}



void __cdecl lego::game::LiveObject_BuildingDestroy(LiveObject *liveObj)
{
	bool bVar1;
	bool bVar2;
	bool bVar3;
	ObjectStatsFlags1 OVar4;
	Point2F local_8;
	
	bVar3 = false;
	bVar1 = false;
	bVar2 = false;
	LiveObject_GetPosition(liveObj,(float *)&local_8,&local_8.y);
	OVar4 = LiveObject_GetStatsFlags1(liveObj);
	if (((OVar4 & STATS1_SMALLTELEPORTER) != STATS1_NONE) &&
		 (globs::gameGlobs.placeDestSmallTeleporter == liveObj)) {
		bVar1 = true;
	}
	OVar4 = LiveObject_GetStatsFlags1(liveObj);
	if (((OVar4 & STATS1_BIGTELEPORTER) != STATS1_NONE) &&
		 (globs::gameGlobs.placeDestBigTeleporter == liveObj)) {
		bVar2 = true;
	}
	OVar4 = LiveObject_GetStatsFlags1(liveObj);
	if (((OVar4 & STATS1_WATERTELEPORTER) != STATS1_NONE) &&
		 (globs::gameGlobs.placeDestWaterTeleporter == liveObj)) {
		bVar3 = true;
	}
	if (bVar1) {
		globs::gameGlobs.placeDestSmallTeleporter = Game_FindSmallTeleporter(&local_8);
	}
	if (bVar2) {
		globs::gameGlobs.placeDestBigTeleporter = Game_FindBigTeleporter(&local_8);
	}
	if (bVar3) {
		globs::gameGlobs.placeDestWaterTeleporter = Game_FindWaterTeleporter(&local_8);
	}
	pool::ReservedPool_LiveObject___Release(liveObj);
	LiveManager_InitFlagsToggle_AndClearNumDrained();
	return;
}



void __cdecl lego::front::Credits_Play(char *textFile,ImageFont *font,char *aviFile)
{
	char *pcVar1;
	byte *memblock;
	Animation_t *aviPlayer;
	uint uVar2;
	uint uVar3;
	DWORD DVar4;
	BOOL BVar5;
	int iVar6;
	int iVar7;
	int iVar8;
	char **ppcVar9;
	int iVar10;
	int iVar11;
	int local_444;
	uint local_440;
	uint local_43c;
	DWORD local_438;
	int local_434;
	uint local_430;
	char *local_42c;
	int local_428;
	int local_424;
	char **local_420;
	int local_41c;
	Animation_t *local_418;
	BOOL local_414;
	RECT local_410;
	char buffer [1024];
	
	local_434 = 0;
	local_43c = 0;
	local_424 = 0;
	local_438 = timeGetTime();
	local_410.left = 0;
	local_410.top = 0;
	local_410.right = globs::mainGlobs.appWidth;
	local_410.bottom = globs::mainGlobs.appHeight;
	local_430 = lego::image::Font_GetHeight(font);
	iVar10 = globs::mainGlobs.appHeight / local_430 + 1;
	local_41c = (int)globs::mainGlobs.appWidth / 2;
	local_428 = iVar10;
	std::sprintf(buffer,"%s.cconv",textFile);
	memblock = lego::file::File_LoadBinary(buffer,&local_440);
	if ((memblock != NULL) ||
		 (memblock = lego::file::File_LoadBinary(textFile,&local_440), memblock != NULL)) {
		local_42c = (char *)std::realloc(memblock,local_440 + 4);
		local_42c[local_440] = '\0';
		aviPlayer = video::Animation_Load(aviFile);
		if (1 < (int)local_440) {
			iVar6 = local_440 - 1;
			pcVar1 = local_42c;
			do {
				if ((*pcVar1 == '\r') && (pcVar1[1] == '\n')) {
					local_434 += 1;
				}
				iVar6 += -1;
				pcVar1 = pcVar1 + 1;
			} while (iVar6 != 0);
		}
		local_434 += 1;
		local_418 = aviPlayer;
		local_420 = (char **)std::malloc(local_434 * 4);
		util::Util_Tokenise(local_42c,local_420,"\r\n");
		iVar6 = -iVar10;
		iVar7 = 0;
		local_444 = iVar6;
		do {
			uVar2 = input::Input_AnyKeyPressed();
			if ((uVar2 != 0) || ((globs::INPUT.mslb == 0 && (iVar7 != 0)))) {
				local_424 = 1;
			}
			local_414 = globs::INPUT.mslb;
			video::Animation_Update(aviPlayer);
			uVar2 = video::Animation_GetLength(aviPlayer);
			uVar3 = video::Animation_GetTime(aviPlayer);
			if (uVar2 <= uVar3) {
				video::Animation_SetTime(aviPlayer,0);
			}
			video::Animation_BlitToBackBuffer(aviPlayer,&local_410);
			DVar4 = timeGetTime();
			iVar7 = iVar6;
			if (0x21 < DVar4 - local_438) {
				local_43c += 1;
				if (local_43c == local_430) {
					iVar7 = iVar6 + 1;
					local_43c = 0;
					local_444 = iVar7;
					if (iVar6 == local_434) {
						iVar7 = -iVar10;
						local_444 = iVar7;
					}
				}
				uVar2 = local_438 + 0x21;
				local_438 = uVar2;
				DVar4 = timeGetTime();
				if (uVar2 < DVar4) {
					local_438 = timeGetTime();
				}
			}
			iVar6 = iVar7;
			if (iVar7 < local_434) {
				iVar8 = iVar7 * local_430;
				ppcVar9 = local_420 + iVar7;
				iVar11 = iVar8;
				do {
					iVar6 = local_444;
					aviPlayer = local_418;
					iVar10 = local_428;
					if (local_428 < iVar7 - local_444) break;
					if (-1 < iVar7) {
						uVar2 = lego::image::Font_GetStringWidth(font,"%s",*ppcVar9);
						lego::image::Font_PrintF
											(font,local_41c - (int)uVar2 / 2,(iVar11 - iVar8) - local_43c,"%s",*ppcVar9);
					}
					iVar7 += 1;
					iVar11 += local_430;
					ppcVar9 = ppcVar9 + 1;
					aviPlayer = local_418;
					iVar10 = local_428;
				} while (iVar7 < local_434);
			}
			snd::SFX_Update(1.0);
			BVar5 = video::Animation_IsOk(aviPlayer);
			if (BVar5 == 0) {
				main::Main_LoopUpdate(TRUE);
				Sleep(10);
			}
			else {
				main::Main_LoopUpdate(FALSE);
			}
			iVar7 = local_414;
		} while (local_424 == 0);
		if (aviPlayer != NULL) {
			video::Animation_Free(aviPlayer);
		}
		std::free(local_420);
		std::free(local_42c);
	}
	return;
}



void __cdecl lego::effect::DamageFont_Cleanup(void)
{
	uint *puVar1;
	
	puVar1 = &globals::g_HealthFont_Containers[0].flags;
	do {
		if ((*puVar1 & 1) != 0) {
			*puVar1 = *puVar1 & 0xfffffffe;
			res::Container_Hide((Container *)puVar1[-7],TRUE);
		}
		puVar1 = puVar1 + 8;
	} while (puVar1 < &DAT_004b9be0);
	return;
}



void __cdecl lego::effect::DamageFont_LoadFrames(char *dirName,char *fileBaseName)
{
	Container_Texture *pCVar1;
	uint uVar2;
	char filenameBuff [260];
	char baseDirBuff [260];
	
	uVar2 = 0;
	do {
		std::sprintf(baseDirBuff,"%s\\",dirName);
		if (fileBaseName == NULL) {
			std::sprintf(filenameBuff,"%i.bmp",uVar2);
		}
		else {
			std::sprintf(filenameBuff,"%s%i.bmp",fileBaseName);
		}
		if (uVar2 == 10) {
			globals::g_HealthFont_Minus = res::Mesh_LoadTexture(baseDirBuff,filenameBuff,0,0);
		}
		else {
			pCVar1 = res::Mesh_LoadTexture(baseDirBuff,filenameBuff,0,0);
			globals::g_HealthFont_Digits[uVar2] = pCVar1;
		}
		uVar2 += 1;
	} while (uVar2 < 0xb);
	return;
}



void __cdecl
lego::effect::DamageFont_DisplayDamage_OverLiveObject(LiveObject *liveObj,uint displayNumber)
{
	BOOL BVar1;
	HealthFontData *healthFont;
	Container *pCVar2;
	Mesh *pMVar3;
	int iVar4;
	float10 fVar5;
	uint local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_18 = 0;
	local_14 = 2;
	local_10 = 1;
	local_c = 0;
	local_8 = 3;
	local_4 = 2;
	BVar1 = front::DamageFont_LiveObject_CheckCanShowDamage_Unk(liveObj);
	if ((((BVar1 != 0) && (displayNumber != 0)) && (displayNumber < 999)) &&
		 (healthFont = DamageFont_GetNextFree(), healthFont != NULL)) {
		healthFont->timerUp = 0.0;
		healthFont->float_10 = 0.0;
		healthFont->float_c = 0.0;
		fVar5 = game::LiveObject_GetCollHeight(liveObj);
		healthFont->timerDown = (float)-fVar5;
		if (healthFont->ownerCont == NULL) {
			pCVar2 = game::LiveObject_GetContainer(liveObj);
			pCVar2 = res::Container_Create(pCVar2);
			healthFont->ownerCont = pCVar2;
			pMVar3 = res::Mesh_CreateOnFrame
												 (pCVar2->activityFrame,DamageFont_MeshRenderCallback,0x3000,healthFont,
													MESH_TYPE_NORM);
			healthFont->mesh = pMVar3;
			iVar4 = 4;
			do {
				res::Mesh_AddGroup(healthFont->mesh,4,2,3,&local_18);
				iVar4 += -1;
			} while (iVar4 != 0);
		}
		else {
			pCVar2 = game::LiveObject_GetContainer(liveObj);
			res::Container_SetParent(healthFont->ownerCont,pCVar2);
			res::Container_Hide(healthFont->ownerCont,0);
		}
		DamageFont_SetDisplayNumber(healthFont,displayNumber);
	}
	return;
}



HealthFontData * __cdecl lego::effect::DamageFont_GetNextFree(void)
{
	HealthFontData *pHVar1;
	
	pHVar1 = globals::g_HealthFont_Containers;
	do {
		if ((*(byte *)&pHVar1->flags & 1) == 0) {
			pHVar1->flags = pHVar1->flags | 1;
			return pHVar1;
		}
		pHVar1 = pHVar1 + 1;
	} while (pHVar1 < (HealthFontData *)&DAT_004b9bc4);
	return NULL;
}



void __cdecl
lego::effect::DamageFont_SetDisplayNumber(HealthFontData *healthFont,uint displayNumber)
{
	uint uVar1;
	D3DRMGroupIndex DVar2;
	D3DRMGroupIndex groupID;
	Mesh *mesh;
	float r;
	float g;
	D3DRMGroupIndex local_4;
	
	DVar2 = D3DRMGROUP_0;
	local_4 = D3DRMGROUP_0;
	groupID = D3DRMGROUP_0;
	do {
		if (displayNumber < 5) {
			res::Mesh_SetGroupColour(healthFont->mesh,groupID,0.0,1.0,0.0,MATERIAL_DIFFUSE);
			mesh = healthFont->mesh;
			g = 1.0;
			r = 0.0;
		}
		else {
			if (displayNumber < 10) {
				res::Mesh_SetGroupColour(healthFont->mesh,groupID,1.0,1.0,0.0,MATERIAL_DIFFUSE);
				mesh = healthFont->mesh;
				g = 1.0;
				r = 1.0;
			}
			else {
				res::Mesh_SetGroupColour(healthFont->mesh,groupID,1.0,0.25,0.0,MATERIAL_DIFFUSE);
				mesh = healthFont->mesh;
				g = 0.25;
				r = 1.0;
			}
		}
		res::Mesh_SetGroupColour(mesh,groupID,r,g,0.0,MATERIAL_EMISSIVE);
		groupID += 1;
	} while (groupID < 4);
	uVar1 = 1;
	if (displayNumber != 0) {
		do {
			DVar2 += 1;
			uVar1 *= 10;
			local_4 = DVar2;
		} while (uVar1 <= displayNumber);
	}
	DVar2 = D3DRMGROUP_0;
	if (local_4 != D3DRMGROUP_0) {
		do {
			res::Mesh_SetGroupTexture
								(healthFont->mesh,DVar2,globals::g_HealthFont_Digits[displayNumber % 10]);
			res::Mesh_HideGroup(healthFont->mesh,DVar2,FALSE);
			displayNumber = (displayNumber - displayNumber % 10) / 10;
			DVar2 += 1;
		} while (DVar2 < local_4);
	}
	res::Mesh_SetGroupTexture(healthFont->mesh,DVar2,globals::g_HealthFont_Minus);
	for (DVar2 = local_4 + 1; DVar2 < 4; DVar2 += 1) {
		res::Mesh_HideGroup(healthFont->mesh,DVar2,TRUE);
	}
	healthFont->groupCount = local_4 + 1;
	return;
}



void __cdecl
lego::effect::DamageFont_MeshRenderCallback(Mesh *mesh,HealthFontData *healthFont,Viewport *view)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	Container *cont;
	Container *cont_00;
	D3DRMGroupIndex groupID;
	float local_88;
	Vector3F local_80;
	float local_74;
	float local_70;
	float local_6c;
	Vector3F local_68;
	Vector3F local_5c;
	float local_50;
	float local_4c;
	float local_48;
	float local_44;
	float local_40;
	float local_3c;
	float local_38;
	float local_34;
	float local_30;
	Point2F local_2c;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	Vector3F local_c;
	
	local_2c.x = 0.0;
	local_2c.y = 0.0;
	local_24 = 0x3f800000;
	local_20 = 0;
	local_1c = 0x3f800000;
	local_18 = 0x3f800000;
	local_14 = 0;
	local_10 = 0x3f800000;
	cont = game::Game_GetCurrentViewLight();
	fVar1 = healthFont->timerUp * 0.06666667;
	res::Container_SetOrientation(healthFont->ownerCont,NULL,0.0,0.0,1.0,0.0,1.0,0.0);
	cont_00 = lego::view::Viewport_GetCamera(view);
	res::Container_GetOrientation(cont_00,NULL,&local_68,&local_80);
	res::Container_GetPosition(cont,NULL,&local_c);
	fVar2 = local_80.y * local_68.z;
	fVar3 = local_80.z * local_68.y;
	fVar4 = local_80.z * local_68.x;
	local_68.z = local_80.x * local_68.z;
	local_68.y = local_80.x * local_68.y;
	local_68.x = local_80.y * local_68.x;
	local_6c = ((fVar1 + fVar1) - -1.0) * 3.0;
	local_80.x = local_6c * local_80.x;
	local_80.y = local_6c * local_80.y;
	local_88 = 1.0 - (float)(ulonglong)healthFont->groupCount * 0.5;
	local_80.z = local_6c * local_80.z;
	local_74 = local_6c * (fVar2 - fVar3);
	groupID = D3DRMGROUP_0;
	local_70 = local_6c * (fVar4 - local_68.z);
	local_6c = local_6c * (local_68.y - local_68.x);
	if (healthFont->groupCount != 0) {
		do {
			local_5c.x = healthFont->float_c - local_88 * local_74;
			local_5c.y = healthFont->float_10 - local_88 * local_70;
			local_5c.z = healthFont->timerDown - local_88 * local_6c;
			local_50 = local_74 + local_5c.x;
			local_4c = local_70 + local_5c.y;
			local_48 = local_6c + local_5c.z;
			local_38 = local_80.x + local_5c.x;
			local_34 = local_80.y + local_5c.y;
			local_44 = local_80.x + local_50;
			local_30 = local_80.z + local_5c.z;
			local_40 = local_80.y + local_4c;
			local_3c = local_80.z + local_48;
			res::Mesh_SetVertices_PointNormalAt(healthFont->mesh,groupID,0,4,&local_5c,&local_c,&local_2c)
			;
			local_88 = local_88 - -1.0;
			groupID += 1;
		} while (groupID < healthFont->groupCount);
	}
	return;
}



void __cdecl lego::effect::DamageFont_UpdateAll(float elapsedAbs)
{
	HealthFontData *healthFont;
	
	healthFont = globals::g_HealthFont_Containers;
	do {
		if ((*(byte *)&healthFont->flags & 1) != 0) {
			DamageFont_UpdateSingle(healthFont,elapsedAbs);
		}
		healthFont = healthFont + 1;
	} while (healthFont < (HealthFontData *)&DAT_004b9bc4);
	return;
}



void __cdecl lego::effect::DamageFont_UpdateSingle(HealthFontData *healthFont,float elapsedAbs)
{
	float fVar1;
	D3DRMGroupIndex groupID;
	
	if (healthFont->timerUp < 15.0) {
		healthFont->float_c = healthFont->float_c + 0.0;
		groupID = D3DRMGROUP_0;
		healthFont->float_10 = healthFont->float_10 + 0.0;
		healthFont->timerDown = elapsedAbs * -1.0 + healthFont->timerDown;
		fVar1 = healthFont->timerUp;
		if (healthFont->groupCount != 0) {
			do {
				res::Mesh_SetGroupMaterialValues
									(healthFont->mesh,groupID,1.0 - fVar1 * 0.06666667,MATERIAL_ALPHA);
				groupID += 1;
			} while (groupID < healthFont->groupCount);
		}
		healthFont->timerUp = elapsedAbs + healthFont->timerUp;
		return;
	}
	healthFont->flags = healthFont->flags & 0xfffffffe;
	res::Container_Hide(healthFont->ownerCont,TRUE);
	return;
}



BOOL __cdecl lego::front::DamageFont_LiveObject_CheckCanShowDamage_Unk(LiveObject *liveObj)
{
	ObjectStatsFlags2 OVar1;
	
	OVar1 = game::LiveObject_GetStatsFlags2(liveObj);
	if ((((OVar1 & STATS2_DONTSHOWDAMAGE) == STATS2_NONE) && (liveObj->objType != OBJECT_DYNAMITE)) &&
		 (liveObj->objType != OBJECT_OOHSCARY)) {
		return TRUE;
	}
	return 0;
}



void __cdecl lego::debug::Dependencies_Debug_SetBuildingPrerequisits(BOOL on)
{
	globals::g_MiscObjectDependencies_TABLE[19][14].levels_field_44[0] = (uint)(on == 0);
	return;
}



void __cdecl lego::game::Dependencies_Object_FUN_0040aa60(void)
{
	uint *puVar1;
	int iVar2;
	uint *puVar3;
	int iVar4;
	
	puVar3 = globals::g_MiscObjectDependencies_TABLE[0].levels_flags;
	do {
		iVar4 = 0xf;
		do {
			iVar2 = 0x10;
			puVar1 = puVar3;
			do {
				iVar2 += -1;
				*puVar1 = *puVar1 & 0xfffffef3;
				puVar1 = puVar1 + 1;
			} while (iVar2 != 0);
			puVar3 = puVar3 + 0x31;
			iVar4 += -1;
		} while (iVar4 != 0);
	} while (puVar3 < &DAT_004c81fc);
	return;
}



void __cdecl lego::game::Dependencies_Load(CFGProperty *root,char *keyBasePath)
{
	char *keyPath;
	CFGProperty *prop;
	int iVar1;
	BOOL BVar2;
	int iVar3;
	uint *puVar4;
	int iVar5;
	void *pvVar6;
	char **ppcVar7;
	uint length;
	int local_50;
	int local_4c;
	ObjectType local_48;
	int local_44;
	char *local_40;
	char *local_3c;
	char *local_38;
	char *local_34;
	char *local_30;
	char *local_28 [10];
	
	keyPath = cfg::CFG_JoinPath(keyBasePath,"Dependencies",0);
	for (prop = cfg::CFG_GetChildren(root,keyPath); prop != NULL; prop = cfg::CFG_NextFlat(prop)) {
		iVar1 = util::Util_Tokenise(prop->key,&local_40,":");
		BVar2 = Object_GetObjectByName(local_3c,(ObjectType *)&keyBasePath,&local_50,NULL);
		if (BVar2 != 0) {
			iVar3 = std::_stricmp(local_40,"HitOnceStay");
			if (iVar1 == 3) {
				iVar1 = std::atoi(local_38);
				Object_GetLevels((ObjectType)keyBasePath,local_50);
				if (iVar3 == 0) {
					globals::g_MiscObjectDependencies_TABLE[(int)keyBasePath][local_50].levels_flags[iVar1] =
							 globals::g_MiscObjectDependencies_TABLE[(int)keyBasePath][local_50].levels_flags
							 [iVar1] | 1;
				}
				globals::g_MiscObjectDependencies_TABLE[(int)keyBasePath][local_50].field_0 = 1;
			}
			else {
				iVar1 = 0;
				if (iVar3 == 0) {
					iVar3 = 0x10;
					puVar4 = globals::g_MiscObjectDependencies_TABLE[(int)keyBasePath][local_50].levels_flags;
					do {
						iVar3 += -1;
						*puVar4 = *puVar4 | 1;
						puVar4 = puVar4 + 1;
					} while (iVar3 != 0);
				}
				globals::g_MiscObjectDependencies_TABLE[(int)keyBasePath][local_50].field_0 = 0;
			}
			iVar3 = util::Util_Tokenise(prop->value,local_28,",");
			length = iVar3 << 4;
			iVar5 = (iVar1 + (local_50 + (int)keyBasePath * 0xf) * 0x31) * 4;
			pvVar6 = std::malloc(length);
			*(void **)(&DAT_004b9c08 + iVar5) = pvVar6;
			*(int *)(&DAT_004b9bc8 + iVar5) = iVar3;
			if (iVar3 != 0) {
				ppcVar7 = local_28;
				local_44 = iVar3;
				do {
					iVar3 = util::Util_Tokenise(*ppcVar7,&local_34,":");
					BVar2 = Object_GetObjectByName(local_34,&local_48,&local_4c,NULL);
					if (BVar2 != 0) {
						*(ObjectType *)
						 (*(int *)(&DAT_004b9c08 + (iVar1 + (local_50 + (int)keyBasePath * 0xf) * 0x31) * 4) +
							-0x10 + length) = local_48;
						*(int *)(*(int *)(&DAT_004b9c08 +
														 (iVar1 + (local_50 + (int)keyBasePath * 0xf) * 0x31) * 4) + -0xc +
										length) = local_4c;
						if (iVar3 == 2) {
							iVar3 = std::atoi(local_30);
							Object_GetLevels(local_48,local_4c);
							*(int *)(*(int *)(&DAT_004b9c08 +
															 (iVar1 + (local_50 + (int)keyBasePath * 0xf) * 0x31) * 4) + -8 +
											length) = iVar3;
							*(undefined4 *)
							 (*(int *)(&DAT_004b9c08 + (iVar1 + (local_50 + (int)keyBasePath * 0xf) * 0x31) * 4) +
								-4 + length) = 1;
						}
						else {
							*(undefined4 *)
							 (*(int *)(&DAT_004b9c08 + (iVar1 + (local_50 + (int)keyBasePath * 0xf) * 0x31) * 4) +
								-4 + length) = 0;
						}
					}
					ppcVar7 = ppcVar7 + 1;
					length -= 0x10;
					local_44 += -1;
				} while (local_44 != 0);
			}
		}
	}
	Dependencies_Init_MiscObjectDependencies();
	return;
}



BOOL __cdecl
lego::game::Dependencies_Object_FUN_0040add0(ObjectType objType,int objIndex,int objLevel)
{
	uint *puVar1;
	uint uVar2;
	BOOL BVar3;
	int iVar4;
	ObjectType OVar5;
	
	if (globals::g_MiscObjectDependencies_TABLE[19][14].levels_field_44[0] == 0) {
		puVar1 = globals::g_MiscObjectDependencies_TABLE[objType][objIndex].levels_flags + objLevel;
		if ((*(byte *)(globals::g_MiscObjectDependencies_TABLE[objType][objIndex].levels_flags +
									objLevel) & 2) == 0) {
			Dependencies_Object_Getter_FUN_0040aec0(objType,objIndex,objLevel,&objIndex,&objType);
			OVar5 = OBJECT_NONE;
			if (objType != OBJECT_NONE) {
				iVar4 = 0;
				do {
					BVar3 = Search_LiveObjects_SkipIgnoreMes
														(Dependencies_LiveObject_CallbackCheck_FUN_0040ae70,
														 (undefined4 *)(objIndex + iVar4));
					if (BVar3 == 0) {
						return 0;
					}
					OVar5 += OBJECT_VEHICLE;
					iVar4 += 0x10;
				} while (OVar5 < objType);
			}
			uVar2 = *puVar1;
			if ((uVar2 & 1) != 0) {
				*puVar1 = uVar2 | 2;
			}
		}
	}
	return TRUE;
}



BOOL __cdecl
lego::game::Dependencies_LiveObject_CallbackCheck_FUN_0040ae70
					(LiveObject *liveObj,LiveObject *otherObj)
{
	BOOL BVar1;
	
	BVar1 = Game_CanStoredObjectTypeBeSpawned(otherObj->objType);
	if (BVar1 == 0) {
		if (otherObj->objType != liveObj->objType) {
			return 0;
		}
		if (otherObj->objIndex != liveObj->objIndex) {
			return 0;
		}
		if ((otherObj->vehicle != NULL) && ((char *)liveObj->objLevel < otherObj->customName)) {
			return 0;
		}
	}
	return TRUE;
}



void __cdecl
lego::game::Dependencies_Object_Getter_FUN_0040aec0
					(ObjectType objType,int objIndex,int objLevel,undefined4 *out_param_4,
					undefined4 *out_param_5)
{
	int iVar1;
	
	iVar1 = objIndex * 0xc4 + objType * 0xb7c;
	if (globals::g_MiscObjectDependencies_TABLE[objType][objIndex].field_0 != 0) {
		iVar1 = (objLevel + (objIndex + objType * 0xf) * 0x31) * 4;
		*out_param_4 = *(undefined4 *)(&DAT_004b9c08 + iVar1);
		*out_param_5 = *(undefined4 *)(&DAT_004b9bc8 + iVar1);
		return;
	}
	*out_param_4 = *(undefined4 *)(&DAT_004b9c08 + iVar1);
	*out_param_5 = *(undefined4 *)(&DAT_004b9bc8 + iVar1);
	return;
}



void __cdecl
lego::game::Dependencies_Object_FUN_0040af30
					(ObjectType objType,int objIndex,int objLevel,int param_4)
{
	int iVar1;
	int iVar2;
	uint objIndex_00;
	ObjectType objType_00;
	uint uVar3;
	uint local_c;
	ObjectDependencies (*local_8) [15];
	uint local_4;
	
	iVar1 = param_4;
	local_8 = globals::g_MiscObjectDependencies_TABLE;
	objType_00 = OBJECT_NONE;
	*(undefined4 *)(param_4 + 0x200) = 0;
	do {
		objIndex_00 = 0;
		do {
			if ((*local_8)[0].field_0 == 0) {
				Dependencies_Object_Getter_FUN_0040aec0(objType_00,objIndex_00,0,&param_4,&local_c);
				uVar3 = 0;
				if (local_c != 0) {
					iVar2 = 0;
					do {
						if (((*(ObjectType *)(param_4 + iVar2) == objType) &&
								(*(int *)(param_4 + 4 + iVar2) == objIndex)) &&
							 ((*(int *)(param_4 + 0xc + iVar2) == 0 || (*(int *)(param_4 + 8 + iVar2) == objLevel)
								))) {
							*(ObjectType *)(iVar1 + *(int *)(iVar1 + 0x200) * 4) = objType_00;
							*(uint *)(iVar1 + 0x80 + *(int *)(iVar1 + 0x200) * 4) = objIndex_00;
							*(undefined4 *)(iVar1 + 0x180 + *(int *)(iVar1 + 0x200) * 4) = 0;
							*(int *)(iVar1 + 0x200) = *(int *)(iVar1 + 0x200) + 1;
						}
						uVar3 += 1;
						iVar2 += 0x10;
					} while (uVar3 < local_c);
				}
			}
			else {
				uVar3 = 0;
				do {
					Dependencies_Object_Getter_FUN_0040aec0(objType_00,objIndex_00,uVar3,&param_4,&local_c);
					iVar2 = 0;
					local_4 = 0;
					if (local_c != 0) {
						do {
							if (((*(ObjectType *)(param_4 + iVar2) == objType) &&
									(*(int *)(param_4 + 4 + iVar2) == objIndex)) &&
								 ((*(int *)(param_4 + 0xc + iVar2) == 0 ||
									(*(int *)(param_4 + 8 + iVar2) == objLevel)))) {
								*(ObjectType *)(iVar1 + *(int *)(iVar1 + 0x200) * 4) = objType_00;
								*(uint *)(iVar1 + 0x80 + *(int *)(iVar1 + 0x200) * 4) = objIndex_00;
								*(uint *)(iVar1 + 0x100 + *(int *)(iVar1 + 0x200) * 4) = uVar3;
								*(undefined4 *)(iVar1 + 0x180 + *(int *)(iVar1 + 0x200) * 4) = 1;
								*(int *)(iVar1 + 0x200) = *(int *)(iVar1 + 0x200) + 1;
							}
							iVar2 += 0x10;
							local_4 += 1;
						} while (local_4 < local_c);
					}
					uVar3 += 1;
				} while (uVar3 < 0x10);
			}
			objIndex_00 += 1;
			local_8 = (ObjectDependencies (*) [15])(*local_8 + 1);
		} while (objIndex_00 < 0xf);
		objType_00 += OBJECT_VEHICLE;
	} while (local_8 < (ObjectDependencies (*) [15])&DAT_004c81f8);
	return;
}



void __cdecl lego::game::Dependencies_Init_MiscObjectDependencies(void)
{
	uint *puVar1;
	BOOL BVar2;
	uint uVar3;
	uint objIndex;
	uint objNumber;
	uint objLevel;
	ObjectType local_4;
	
	objNumber = 0;
	local_4 = OBJECT_NONE;
	do {
		objIndex = 0;
		do {
			objLevel = 0;
			do {
				if ((objLevel == 1) &&
					 (globals::g_MiscObjectDependencies_TABLE[objIndex + objNumber].field_0 != 0)) break;
				puVar1 = globals::g_MiscObjectDependencies_TABLE[objIndex + objNumber].levels_flags +
								 objLevel;
				if ((*(byte *)(globals::g_MiscObjectDependencies_TABLE[objIndex + objNumber].levels_flags +
											objLevel) & 8) == 0) {
					BVar2 = Dependencies_Object_FUN_0040add0(local_4,objIndex,objLevel);
					uVar3 = *puVar1;
					if (BVar2 == 0) {
						if ((uVar3 & 4) != 0) goto LAB_0040b14c;
					}
					else {
						if ((uVar3 & 4) == 0) {
							uVar3 |= 4;
						}
						else {
LAB_0040b14c:
							uVar3 = uVar3 & 0xfffffffb | 8;
						}
						*puVar1 = uVar3;
					}
				}
				objLevel += 1;
			} while (objLevel < 0x10);
			objIndex += 1;
		} while (objIndex < 0xf);
		objNumber += 0xf;
		local_4 += OBJECT_VEHICLE;
		if (299 < objNumber) {
			return;
		}
	} while( true );
}



BOOL __cdecl
lego::game::Dependencies_Object_IsLevelFlag4(ObjectType objType,int objIndex,int objLevel)
{
	if (globals::g_MiscObjectDependencies_TABLE[objType][objIndex].field_0 != 0) {
		return globals::g_MiscObjectDependencies_TABLE[objType][objIndex].levels_flags[objLevel] & 4;
	}
	return globals::g_MiscObjectDependencies_TABLE[objType][objIndex].levels_flags[0] & 4;
}



void __cdecl
lego::game::Dependencies_SetObjectLevelFlag_100(ObjectType objType,int objIndex,int objLevel)
{
	globals::g_MiscObjectDependencies_TABLE[objType][objIndex].levels_flags[objLevel] =
			 globals::g_MiscObjectDependencies_TABLE[objType][objIndex].levels_flags[objLevel] | 0x100;
	return;
}



uint __cdecl
lego::game::Dependencies_GetObjectLevelFlag_100(ObjectType objType,int objIndex,int objLevel)
{
	return globals::g_MiscObjectDependencies_TABLE[objType][objIndex].levels_flags[objLevel] & 0x100;
}



SurfaceTextureGrid * __cdecl
lego::res::DynamicPM_LoadTextureBaseName(char *textureBaseName,uint width,uint height)
{
	SurfaceTextureGrid *buffer;
	Container_Texture **ppCVar1;
	Container_Texture *pCVar2;
	uint uVar3;
	uint uVar4;
	int iVar5;
	int local_404;
	char buff [1024];
	
	buffer = (SurfaceTextureGrid *)std::malloc(0xc);
	uVar3 = 0;
	if (buffer != NULL) {
		ppCVar1 = (Container_Texture **)std::malloc(height * width * 4);
		buffer->gridSurfaces = ppCVar1;
		if (ppCVar1 == NULL) {
			std::free(buffer);
			buffer = NULL;
		}
		else {
			(buffer->gridSize).width = width;
			(buffer->gridSize).height = height;
			if (height != 0) {
				local_404 = 0;
				do {
					uVar4 = 0;
					iVar5 = local_404;
					if (width != 0) {
						do {
							std::sprintf(buff,"%s%0.1x%0.1x.bmp",textureBaseName,uVar4,uVar3);
							pCVar2 = Container_LoadTexture2(buff,TRUE,NULL,NULL);
							uVar4 += 1;
							*(Container_Texture **)((int)buffer->gridSurfaces + iVar5) = pCVar2;
							iVar5 = iVar5 + 4;
						} while (uVar4 < width);
					}
					uVar3 += 1;
					local_404 += width * 4;
				} while (uVar3 < height);
				return buffer;
			}
		}
	}
	return buffer;
}



void __cdecl lego::res::DynamicPM_Free_SurfaceTextureGrid(SurfaceTextureGrid *surfTextGrid)
{
	uint width;
	uint y;
	uint x;
	
	y = 0;
	if ((surfTextGrid->gridSize).height != 0) {
		do {
			width = (surfTextGrid->gridSize).width;
			x = 0;
			if (width != 0) {
				do {
					Container_FreeTexture(surfTextGrid->gridSurfaces[y * width + x]);
					width = (surfTextGrid->gridSize).width;
					x += 1;
				} while (x < width);
			}
			y += 1;
		} while (y < (uint)(surfTextGrid->gridSize).height);
	}
	std::free(surfTextGrid->gridSurfaces);
	std::free(surfTextGrid);
	return;
}



float10 __cdecl
lego::res::DynamicPM_FUN_0040b3a0(int param_1,Viewport *view,Point2F *param_3,BOOL param_4)
{
	float *pfVar1;
	float *pfVar2;
	int iVar3;
	Vector4F *out_transform4d;
	Vector3F *pVVar4;
	float10 fVar5;
	float10 fVar6;
	float local_78;
	Vector3F local_70;
	Vector3F local_64;
	Vector3F local_58;
	Vector3F local_4c;
	Vector4F local_40 [4];
	
	local_78 = 1.0;
	iVar3 = 4;
	out_transform4d = local_40;
	pVVar4 = &local_70;
	do {
		lego::view::Viewport_Transform
							(view,out_transform4d,(Vector3F *)((param_1 - (int)&local_70) + (int)pVVar4));
		iVar3 += -1;
		pVVar4->x = out_transform4d->x / out_transform4d->w;
		pVVar4->y = out_transform4d->y / out_transform4d->w;
		out_transform4d = out_transform4d + 1;
		pVVar4 = pVVar4 + 1;
	} while (iVar3 != 0);
	if (param_4 == 0) {
		pfVar2 = &local_40[0].z;
		pfVar1 = &local_70.y;
		iVar3 = 4;
		do {
			if (0.0 <= pfVar1[-1]) {
				if (0.0 <= *pfVar1) {
					if ((ushort)((ushort)(pfVar1[-1] < param_3->x) << 8 |
											(ushort)(pfVar1[-1] == param_3->x) << 0xe) == 0) {
						local_78 = local_78 - 0.25;
					}
					else {
						if ((ushort)((ushort)(*pfVar1 < param_3->y) << 8 |
												(ushort)(*pfVar1 == param_3->y) << 0xe) == 0) {
							local_78 = local_78 - 0.25;
						}
						else {
							if (((ushort)((ushort)(*pfVar2 < pfVar2[1]) << 8 |
													 (ushort)(*pfVar2 == pfVar2[1]) << 0xe) == 0) || (*pfVar2 < 0.0)) {
								local_78 = local_78 - 0.25;
							}
						}
					}
				}
				else {
					local_78 = local_78 - 0.25;
				}
			}
			else {
				local_78 = local_78 - 0.25;
			}
			pfVar1 = pfVar1 + 3;
			pfVar2 = pfVar2 + 4;
			iVar3 += -1;
		} while (iVar3 != 0);
	}
	if ((ushort)((ushort)(local_78 < 0.0) << 8 | (ushort)(local_78 == 0.0) << 0xe) != 0) {
		return (float10)0.0;
	}
	fVar5 = math::Maths_TriangleAreaZ(&local_58,&local_64,&local_70,0);
	fVar6 = math::Maths_TriangleAreaZ(&local_70,&local_4c,&local_58,0);
	return (fVar6 + (float10)(float)fVar5) * (float10)local_78;
}



ProMeshData * __cdecl
lego::res::DynamicPM_LoadPromesh_AB
					(Container *resData,char *meshName_a,char *meshName_b,float blockSize,
					SurfaceTextureGrid *surfTextGrid)
{
	ProMeshData *promesh;
	Container *pCVar1;
	D3DRMVertex *out_retArray;
	float *pfVar2;
	int iVar3;
	float fVar4;
	undefined4 (*pauVar5) [100];
	ProMeshData *pPVar6;
	uint uVar7;
	undefined4 (*pauVar8) [100];
	
	if (meshName_b == NULL) {
		meshName_b = meshName_a;
	}
	promesh = (ProMeshData *)std::malloc(0x340);
	if (promesh != NULL) {
		pCVar1 = Container_Load(resData,meshName_a,"LWO:NOTEXTURE",TRUE);
		promesh->promesh_ab[0] = pCVar1;
		if (pCVar1 != NULL) {
			pCVar1 = Container_Load(resData,meshName_b,"LWO:NOTEXTURE",TRUE);
			promesh->promesh_ab[1] = pCVar1;
			if (pCVar1 == NULL) {
				pCVar1 = Container_Load(resData,meshName_a,"LWO:NOTEXTURE",TRUE);
				promesh->promesh_ab[1] = pCVar1;
			}
			fVar4 = blockSize * 0.01;
			promesh->field_32c = 0;
			promesh->BlockSize = blockSize;
			promesh->surfTextGrid = surfTextGrid;
			pauVar5 = promesh->table_ab;
										// = 2
			blockSize = 2.802597e-45;
			pPVar6 = promesh;
			do {
				Container_Mesh_Scale(pPVar6->promesh_ab[0],fVar4,fVar4,fVar4);
				Container_Mesh_SetPerspectiveCorrection(pPVar6->promesh_ab[0],D3DRMGROUP_0,TRUE);
				Container_Hide(pPVar6->promesh_ab[0],TRUE);
				pauVar8 = pauVar5;
				for (iVar3 = 100; iVar3 != 0; iVar3 += -1) {
					(*pauVar8)[0] = 0;
					pauVar8 = (undefined4 (*) [100])(*pauVar8 + 1);
				}
				pPVar6 = (ProMeshData *)(pPVar6->promesh_ab + 1);
				pauVar5 = pauVar5[1];
				blockSize = (float)((int)blockSize + -1);
			} while (blockSize != 0.0);
			uVar7 = 0;
			do {
				Container_Mesh_GetGroup
									(promesh->promesh_ab[uVar7],D3DRMGROUP_0,(uint *)&blockSize,NULL,NULL,NULL,NULL);
				out_retArray = (D3DRMVertex *)std::malloc((int)blockSize * 0x24);
				Container_Mesh_GetVertices
									(promesh->promesh_ab[uVar7],D3DRMGROUP_0,0,(uint)blockSize,out_retArray);
				fVar4 = 0.0;
				if (blockSize != 0.0) {
					pfVar2 = &out_retArray->tv;
					do {
						if (uVar7 != 0) {
							pfVar2[-1] = 1.0 - pfVar2[-1];
							*pfVar2 = 1.0 - *pfVar2;
						}
						fVar4 = (float)((int)fVar4 + 1);
						pfVar2 = pfVar2 + 9;
					} while ((uint)fVar4 < (uint)blockSize);
				}
				Container_Mesh_SetVertices
									(promesh->promesh_ab[uVar7],D3DRMGROUP_0,0,(uint)blockSize,out_retArray);
				std::free(out_retArray);
				uVar7 += 1;
			} while (uVar7 < 2);
			return promesh;
		}
		std::free(promesh);
	}
	return NULL;
}



void __cdecl lego::res::DynamicPM_Free(ProMeshData *promesh)
{
	ProMeshData *pPVar1;
	int i;
	
	if (promesh != NULL) {
		DynamicPM_Remove_FUN_0040b740(promesh);
		i = 2;
		pPVar1 = promesh;
		do {
			Container_Remove(pPVar1->promesh_ab[0]);
			pPVar1 = (ProMeshData *)(pPVar1->promesh_ab + 1);
			i += -1;
		} while (i != 0);
		std::free(promesh);
	}
	return;
}



void __cdecl lego::res::DynamicPM_Remove_FUN_0040b740(ProMeshData *promesh)
{
	int iVar1;
	undefined4 (*pauVar2) [100];
	int iVar3;
	
	promesh->field_32c = 0;
	pauVar2 = promesh->table_ab;
	iVar1 = 2;
	do {
		iVar3 = 100;
		do {
			if ((Container *)(*pauVar2)[0] != NULL) {
				Container_Remove((Container *)(*pauVar2)[0]);
				(*pauVar2)[0] = 0;
			}
			pauVar2 = (undefined4 (*) [100])(*pauVar2 + 1);
			iVar3 += -1;
		} while (iVar3 != 0);
		iVar1 += -1;
	} while (iVar1 != 0);
	return;
}



Container_Texture * __cdecl
lego::res::DynamicPM_SurfaceTextureGrid_GetTexture
					(SurfaceTextureGrid *param_1,SurfaceTexture coord_4X_0Y)
{
	if (param_1 != NULL) {
		return param_1->gridSurfaces
					 [(coord_4X_0Y & 0xf) * (param_1->gridSize).width + (uint)(coord_4X_0Y >> 4)];
	}
	return NULL;
}



void __cdecl
lego::res::DynamicPM_FUN_0040b7b0
					(ProMeshData *promesh,Vector3F *vectPoses4,SurfaceTexture texture,byte param_4,
					undefined4 param_5,undefined4 param_6)
{
	float fVar1;
	Container_Texture *contTexture;
	Container *pCVar2;
	uint uVar3;
	Container **ppCVar4;
	uint uVar5;
	Container *local_38 [2];
	int local_30 [4];
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if (promesh != NULL) {
		fVar1 = promesh->BlockSize;
		local_30[2] = 2;
		local_14 = 2;
		local_c = 2;
		local_30[0] = 3;
		local_1c = 3;
		local_8 = 3;
		local_30[1] = 0;
		local_30[3] = 0;
		local_20 = 1;
		local_18 = 1;
		local_10 = 0;
		local_4 = 1;
		contTexture = DynamicPM_SurfaceTextureGrid_GetTexture(promesh->surfTextGrid,texture);
		ppCVar4 = local_38;
		uVar3 = 0;
		do {
			pCVar2 = Container_Clone(*(Container **)
																((int)((ProMeshData *)((int)promesh - (int)local_38))->promesh_ab +
																(int)ppCVar4));
			promesh->table_ab[uVar3 + promesh->field_32c] = pCVar2;
			uVar5 = uVar3 + 100;
			*ppCVar4 = (Container *)promesh->table_ab[uVar3 + promesh->field_32c];
			ppCVar4 = ppCVar4 + 1;
			uVar3 = uVar5;
		} while (uVar5 < 200);
		uVar3 = (uint)param_4;
		DynamicPM_Sub1_FUN_0040b930
							(local_38[0],fVar1,vectPoses4 + local_30[uVar3 * 3],
							 vectPoses4 + local_30[uVar3 * 3 + 1],vectPoses4 + local_30[uVar3 * 3 + 2],param_5,
							 param_6,contTexture,0);
		uVar3 = uVar3 + 2 & 3;
		DynamicPM_Sub1_FUN_0040b930
							(local_38[1],fVar1,vectPoses4 + local_30[uVar3 * 3],
							 vectPoses4 + local_30[uVar3 * 3 + 1],vectPoses4 + local_30[uVar3 * 3 + 2],param_5,
							 param_6,contTexture,0);
		promesh->field_32c = promesh->field_32c + 1;
	}
	return;
}



void __cdecl
lego::res::DynamicPM_Sub1_FUN_0040b930
					(Container *cont,float param_2,Vector3F *position,Vector3F *dir,Vector3F *up,float scaleZ,
					float brightness,Container_Texture *contTexture,byte unkFlags1to80)
{
	uint uVar1;
	D3DRMGroupIndex DVar2;
	D3DRMGroupIndex groupID;
	
	DynamicPM_Sub2_FUN_0040bac0(cont,param_2,position,dir,up);
	Container_Hide(cont,FALSE);
	groupID = D3DRMGROUP_0;
	uVar1 = Container_Mesh_GetGroupCount(cont);
	if (uVar1 != 0) {
		do {
			Container_Mesh_SetTexture(cont,groupID,contTexture);
			groupID += 1;
			DVar2 = Container_Mesh_GetGroupCount(cont);
		} while (groupID < DVar2);
	}
	Container_AddTranslation(cont,D3DRMCOMBINE_BEFORE,-0.02,-0.02,0.0);
	Container_AddScale(cont,D3DRMCOMBINE_BEFORE,1.015,1.015,scaleZ);
	Container_SetColourAlpha(cont,brightness,brightness,brightness,1.0);
	if ((unkFlags1to80 & 1) != 0) {
		Container_AddRotation(cont,D3DRMCOMBINE_BEFORE,1.0,0.0,0.0,1.570796);
	}
	if ((unkFlags1to80 & 2) != 0) {
		Container_AddRotation(cont,D3DRMCOMBINE_BEFORE,1.0,0.0,0.0,-1.570796);
	}
	if ((unkFlags1to80 & 4) != 0) {
		Container_AddRotation(cont,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,1.570796);
	}
	if ((unkFlags1to80 & 8) != 0) {
		Container_AddRotation(cont,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,-1.570796);
	}
	if ((unkFlags1to80 & 0x10) != 0) {
		Container_AddRotation(cont,D3DRMCOMBINE_BEFORE,0.0,0.0,1.0,1.570796);
	}
	if ((unkFlags1to80 & 0x20) != 0) {
		Container_AddRotation(cont,D3DRMCOMBINE_BEFORE,0.0,0.0,1.0,-1.570796);
	}
	if ((unkFlags1to80 & 0x80) != 0) {
		Container_AddTranslation(cont,D3DRMCOMBINE_AFTER,0.0,-10.0,0.0);
	}
	if ((unkFlags1to80 & 0x40) != 0) {
		Container_AddTranslation(cont,D3DRMCOMBINE_AFTER,0.0,10.0,0.0);
	}
	return;
}



void __cdecl
lego::res::DynamicPM_Sub2_FUN_0040bac0
					(Container *cont,float param_2,Vector3F *position,Vector3F *dir,Vector3F *up)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	Vector3F local_58;
	Vector3F local_4c;
	Matrix4F matrix;
	
	fVar1 = dir->x - position->x;
	local_58.y = dir->y - position->y;
	local_58.z = dir->z - position->z;
	fVar4 = up->x - dir->x;
	fVar2 = up->y - dir->y;
	fVar3 = up->z - dir->z;
	local_4c.x = fVar3 * local_58.y - fVar2 * local_58.z;
	local_4c.y = fVar4 * local_58.z - fVar3 * fVar1;
	local_4c.z = fVar2 * fVar1 - fVar4 * local_58.y;
	fVar3 = 1.0 / SQRT(local_58.z * local_58.z + local_58.y * local_58.y + fVar1 * fVar1);
	fVar2 = 1.0 / SQRT(local_4c.z * local_4c.z + local_4c.y * local_4c.y + local_4c.x * local_4c.x);
	Container_SetOrientation
						(cont,NULL,-(fVar2 * local_4c.x),-(fVar2 * local_4c.y),-(fVar2 * local_4c.z),
						 fVar3 * fVar1,fVar3 * local_58.y,fVar3 * local_58.z);
	Container_SetPosition(cont,NULL,position->x,position->y,position->z);
	Container_InverseTransform(cont,&local_58,dir);
	Container_InverseTransform(cont,&local_4c,up);
	math::DynamicPM_Matrix_FUN_0040bc90(&matrix,param_2,param_2,local_58.y,local_4c.x,local_4c.y);
	Container_AddTransform(cont,D3DRMCOMBINE_BEFORE,&matrix);
	return;
}



void __cdecl
lego::math::DynamicPM_Matrix_FUN_0040bc90
					(Matrix4F *out_matrix,float param_2,float param_3,float param_4,float param_5,
					float param_6)
{
	out_matrix->values[3] = 0.0;
	out_matrix->values[2] = 0.0;
	out_matrix->values[1][3] = 0.0;
	out_matrix->values[1][2] = 0.0;
	out_matrix->values[1][0] = 0.0;
	out_matrix->values[2][3] = 0.0;
	out_matrix->values[2][1] = 0.0;
	out_matrix->values[2][0] = 0.0;
	out_matrix->values[3][2] = 0.0;
	out_matrix->values[3][1] = 0.0;
	out_matrix->values[3][0] = 0.0;
	out_matrix->values[3][3] = 1.0;
	out_matrix->values[2][2] = 1.0;
	out_matrix->values[0] = param_5 / param_2;
	out_matrix->values[1][1] = param_4 / param_3;
	out_matrix->values[1] = (param_6 / param_5) * (param_5 / param_2);
	return;
}



void __cdecl lego::effect::Effect_FUN_0040bcf0(void)
{
	undefined4 local_4;
	
	Effect_MiscObjectUpdateUnk_FUN_0040c2d0(10000.0,&local_4,&local_4);
	return;
}



void __cdecl lego::game::Effect_Spawn_BoulderExplode_AtObject(LiveObject *liveObj)
{
	Vector3F local_c;
	
	res::Container_GetPosition(liveObj->other,NULL,&local_c);
	lego::effect::Effect_Spawn_BoulderExplode_AtWorldPos(&local_c);
	return;
}



void __cdecl lego::effect::Effect_Spawn_BoulderExplode_AtWorldPos(Vector3F *position)
{
	Container **ppCVar1;
	LevelData *level;
	Container *pCVar2;
	int iVar3;
	
	iVar3 = 0;
	ppCVar1 = globals::g_Effects_BoulderExplodes;
	do {
		if (*ppCVar1 == NULL) {
			level = game::GetLevel();
			pCVar2 = globs::gameGlobs.RES_BoulderExplode;
			if (level->BoulderAnimation == TEXTURES_ICE) {
				pCVar2 = globs::gameGlobs.RES_BoulderExplodeIce;
			}
			pCVar2 = res::Container_Clone(pCVar2);
			globals::g_Effects_BoulderExplodes[iVar3] = pCVar2;
			res::Container_SetAnimationTime(pCVar2,0.0);
			res::Container_SetPosition
								(globals::g_Effects_BoulderExplodes[iVar3],NULL,position->x,position->y,position->z)
			;
			res::Container_SetOrientation
								(globals::g_Effects_BoulderExplodes[iVar3],NULL,0.0,1.0,0.0,0.0,0.0,-1.0);
			return;
		}
		ppCVar1 = ppCVar1 + 1;
		iVar3 += 1;
	} while (ppCVar1 < globals::g_Effects_SmashPath);
	return;
}



// Must pass in non-null LiveObject* -OR- Vector3F* 
//  in order to get a position. (LiveObject* has precedence)

void __cdecl
lego::effect::Effect_Spawn_SmashPath(LiveObject *optor_liveObj,Vector3F *optor_position)
{
	Container *pCVar1;
	Container **ppCVar2;
	Vector3F local_c;
	
	if (optor_liveObj == NULL) {
		local_c.x = optor_position->x;
		local_c.y = optor_position->y;
		local_c.z = optor_position->z;
	}
	else {
		pCVar1 = game::LiveObject_GetContainer(optor_liveObj);
		res::Container_GetPosition(pCVar1,NULL,&local_c);
	}
	ppCVar2 = globals::g_Effects_SmashPath;
	do {
		if (*ppCVar2 == NULL) {
			pCVar1 = res::Container_Clone(globs::gameGlobs.RES_SmashPath);
			*ppCVar2 = pCVar1;
			res::Container_SetAnimationTime(pCVar1,0.0);
			res::Container_SetPosition(*ppCVar2,NULL,local_c.x,local_c.y,local_c.z);
			res::Container_SetOrientation(*ppCVar2,NULL,0.0,1.0,0.0,0.0,0.0,-1.0);
		}
		ppCVar2 = ppCVar2 + 1;
	} while (ppCVar2 < &globals::g_MiscObjectResource_ShortElectricFenceBeam);
	return;
}



BOOL __cdecl lego::effect::Effect_GetRockFallStyle(char *name,uint *out_index)
{
	int iVar1;
	uint uVar2;
	char **ppcVar3;
	
	uVar2 = 0;
	if (globals::g_RockFallStyles_COUNT == 0) {
		return 0;
	}
	ppcVar3 = globals::g_RockFallStyles_TABLE;
	do {
		iVar1 = std::_stricmp(*ppcVar3,name);
		if (iVar1 == 0) {
			*out_index = uVar2;
			return 1;
		}
		uVar2 += 1;
		ppcVar3 = ppcVar3 + 1;
	} while (uVar2 < globals::g_RockFallStyles_COUNT);
	return 0;
}



void __cdecl lego::effect::Effect_SetRockFallStyleIndex(int rockFallStyleIndex)
{
	globals::g_RockFallStyleIndex = rockFallStyleIndex;
	return;
}



void __cdecl
lego::effect::Effect_Load_RockFallStyles(CFGProperty *root,char *keyBasePath,Container *resData)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *prop;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	undefined4 *puVar8;
	char *local_428 [10];
	char local_400 [1024];
	
	pcVar2 = cfg::CFG_JoinPath(keyBasePath,"RockFallStyles",0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (prop == NULL) {
			return;
		}
		pcVar2 = std::_strdup(prop->key);
		globals::g_RockFallStyles_TABLE[globals::g_RockFallStyles_COUNT] = pcVar2;
		uVar4 = 0xffffffff;
		pcVar2 = prop->value;
		do {
			pcVar7 = pcVar2;
			if (uVar4 == 0) break;
			uVar4 -= 1;
			pcVar7 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar7;
		} while (cVar1 != '\0');
		uVar4 = ~uVar4;
		puVar6 = (undefined4 *)(pcVar7 + -uVar4);
		puVar8 = (undefined4 *)local_400;
		for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
			*puVar8 = *puVar6;
			puVar6 = puVar6 + 1;
			puVar8 = puVar8 + 1;
		}
		for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
			*(undefined *)puVar8 = *(undefined *)puVar6;
			puVar6 = (undefined4 *)((int)puVar6 + 1);
			puVar8 = (undefined4 *)((int)puVar8 + 1);
		}
		uVar4 = util::Util_Tokenise(local_400,local_428,",");
		uVar5 = 1;
		if (1 < uVar4) {
			uVar3 = 1;
			do {
				Effect_FUN_0040c000(resData,local_428[uVar3],globals::g_RockFallStyles_COUNT,uVar3 - 1,
														local_428[0]);
				uVar5 += 1;
				uVar3 = uVar5 & 0xffff;
			} while (uVar3 < uVar4);
		}
		globals::g_RockFallStyles_COUNT += 1;
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



BOOL __cdecl
lego::effect::Effect_FUN_0040c000
					(Container *resData,char *param_2,int param_3,int param_4,char *param_5)
{
	int iVar1;
	Container **ppCVar2;
	Container *pCVar3;
	char *name;
	int iVar4;
	Container **ppCVar5;
	
	iVar1 = (param_4 + param_3 * 3) * 0xa4;
	ppCVar2 = (Container **)((int)globals::g_MiscObjectDependencies_TABLE[0x13] + iVar1 + 0xb64);
	pCVar3 = res::Container_Load(resData,param_2,"LWS",1);
	*ppCVar2 = pCVar3;
	if (pCVar3 == NULL) {
		pCVar3 = res::Container_Load(resData,param_2,"ANIM",1);
		*ppCVar2 = pCVar3;
	}
	if (*ppCVar2 != NULL) {
		res::Container_Hide(*ppCVar2,1);
		ppCVar5 = (Container **)((int)globals::g_MiscObjectDependencies_TABLE[0x13] + iVar1 + 0xb68);
		iVar4 = 4;
		do {
			pCVar3 = res::Container_Clone(*ppCVar2);
			*ppCVar5 = pCVar3;
			ppCVar5[0xc] = (Container *)0x1;
			ppCVar5[0x24] = NULL;
			res::Container_Hide(*ppCVar5,1);
			ppCVar5 = ppCVar5 + 1;
			iVar4 += -1;
		} while (iVar4 != 0);
		name = res::Container_FormatPartName(*ppCVar2,param_5,NULL);
		res::Container_SearchTree(*ppCVar2,name,CONTAINER_SEARCHMODE_MATCHCOUNT,&param_3);
		*(int *)(&DAT_004c8228 + iVar1) = param_3;
		*(char **)(&DAT_004c8224 + iVar1) = param_5;
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::effect::Effect_LoadMiscObjectResource_ElectricFenceBeam
					(Container *resRoot,char *filename,BOOL isLongBeam)
{
	Container *pCVar1;
	int iVar2;
	Container **ppCVar3;
	
	pCVar1 = res::Container_Load(resRoot,filename,"LWS",1);
	(&globals::g_MiscObjectResource_ShortElectricFenceBeam)[isLongBeam * 0x3d] = pCVar1;
	if (pCVar1 != NULL) {
		res::Container_Hide(pCVar1,1);
		ppCVar3 = (Container **)(&DAT_004c8bfc + isLongBeam * 0x3d);
		iVar2 = 0x1e;
		do {
			pCVar1 = res::Container_Clone
												 ((&globals::g_MiscObjectResource_ShortElectricFenceBeam)[isLongBeam * 0x3d]
												 );
			*ppCVar3 = pCVar1;
			ppCVar3[0x1e] = (Container *)0x1;
			res::Container_Hide(*ppCVar3,1);
			ppCVar3 = ppCVar3 + 1;
			iVar2 += -1;
		} while (iVar2 != 0);
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::effect::Effect_Spawn_RockFall
					(int param_1,int bx,int by,float x,float y,float z,float dirX,float dirY)
{
	int iVar1;
	int *piVar2;
	uint uVar3;
	
	uVar3 = 0;
	iVar1 = (param_1 + globals::g_RockFallStyleIndex * 3) * 0xa4;
	piVar2 = (int *)(&DAT_004c8214 + iVar1);
	do {
		if (*piVar2 != 0) break;
		uVar3 += 1;
		piVar2 = piVar2 + 1;
	} while (uVar3 < 4);
	if (uVar3 < 4) {
		res::Container_Hide(*(Container **)(iVar1 + 0x4c81e4 + uVar3 * 4),FALSE);
		res::Container_SetAnimationTime(*(Container **)(iVar1 + 0x4c81e4 + uVar3 * 4),0.0);
		res::Container_SetPosition(*(Container **)(iVar1 + 0x4c81e4 + uVar3 * 4),NULL,x,y,z);
		res::Container_SetOrientation
							(*(Container **)(iVar1 + 0x4c81e4 + uVar3 * 4),NULL,dirX,dirY,0.0,0.0,0.0,-1.0);
		*(int *)(iVar1 + 0x4c81f4 + uVar3 * 4) = bx;
		*(int *)(&DAT_004c8204 + uVar3 * 4 + iVar1) = by;
		*(undefined4 *)(&DAT_004c8214 + uVar3 * 4 + iVar1) = 0;
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::effect::Effect_Unk_Spawn_FUN_0040c220
					(int param_1,float param_2,float param_3,float param_4,float param_5,float param_6,
					float param_7)
{
	int *piVar1;
	uint uVar2;
	
	uVar2 = 0;
	piVar1 = &DAT_004c8c74 + param_1 * 0x3d;
	do {
		if (*piVar1 != 0) break;
		uVar2 += 1;
		piVar1 = piVar1 + 1;
	} while (uVar2 < 0x1e);
	if (uVar2 < 0x1e) {
		res::Container_Hide((Container *)(&DAT_004c8bfc)[param_1 * 0x3d + uVar2],0);
		res::Container_SetAnimationTime((Container *)(&DAT_004c8bfc)[param_1 * 0x3d + uVar2],0.0);
		res::Container_SetPosition
							((Container *)(&DAT_004c8bfc)[param_1 * 0x3d + uVar2],NULL,param_2,param_3,param_4);
		res::Container_SetOrientation
							((Container *)(&DAT_004c8bfc)[param_1 * 0x3d + uVar2],NULL,param_5,param_6,param_7,0.0
							 ,0.0,-1.0);
		(&DAT_004c8c74)[param_1 * 0x3d + uVar2] = 0;
		return TRUE;
	}
	return 0;
}



int __cdecl
lego::effect::Effect_MiscObjectUpdateUnk_FUN_0040c2d0
					(float elapsedGame,undefined4 *param_2,undefined4 *param_3)
{
	int iVar1;
	uint uVar2;
	int iVar3;
	int *piVar4;
	BlockObject **ppBVar5;
	uint uVar6;
	BlockObject **ppBVar7;
	float10 fVar8;
	
	iVar1 = 0;
	Effect_Update_Explosion(elapsedGame);
	Effect_Update_BoulderExplode(elapsedGame);
	Effect_Update_SmashPath(elapsedGame);
	Effect_Update_AllParticles(elapsedGame);
	uVar2 = 0;
	do {
		iVar3 = uVar2 + globals::g_RockFallStyleIndex * 3;
		if (*(int *)((int)globals::g_MiscObjectDependencies_TABLE[0x13] + iVar3 * 0xa4 + 0xb64) != 0) {
			uVar6 = 0;
			piVar4 = (int *)(&DAT_004c8214 + iVar3 * 0xa4);
			do {
				if (*piVar4 == 0) {
					fVar8 = res::Container_MoveAnimation((Container *)piVar4[-0xc],elapsedGame);
					if ((ushort)((ushort)(fVar8 < (float10)0.0) << 8 | (ushort)(fVar8 == (float10)0.0) << 0xe)
							== 0) {
						res::Container_Hide((Container *)piVar4[-0xc],TRUE);
						*piVar4 = 1;
						piVar4[0x18] = 0;
						globals::g_MiscObjectDependencies_TABLE[0x13][0xe].levels_field_44[iVar1 + 2] = uVar2;
						globals::g_MiscObjectDependencies_TABLE[0x13][0xe].levels_field_44[iVar1 + 0xe] = uVar6;
						iVar1 += 1;
					}
				}
				uVar6 += 1;
				piVar4 = piVar4 + 1;
			} while (uVar6 < 4);
		}
		uVar2 += 1;
	} while (uVar2 < 3);
	ppBVar7 = (BlockObject **)&DAT_004c8c74;
	*param_2 = 0x4c8180;
	*param_3 = 0x4c81b0;
	do {
		iVar3 = 0x1e;
		ppBVar5 = ppBVar7;
		do {
			if (*ppBVar5 == NULL) {
				fVar8 = res::Container_MoveAnimation((Container *)ppBVar5[-0x1e],elapsedGame);
				if ((ushort)((ushort)(fVar8 < (float10)0.0) << 8 | (ushort)(fVar8 == (float10)0.0) << 0xe)
						== 0) {
					res::Container_Hide((Container *)ppBVar5[-0x1e],TRUE);
					*ppBVar5 = (BlockObject *)0x1;
				}
			}
			ppBVar5 = ppBVar5 + 1;
			iVar3 += -1;
		} while (iVar3 != 0);
		ppBVar7 = ppBVar7 + 0x3d;
	} while (ppBVar7 < pool::globals::ReservedPool_BlockObject___g_TABLE + 0x17);
	return iVar1;
}



void __cdecl lego::effect::Effect_Update_BoulderExplode(float elapsedGame)
{
	Container **ppCVar1;
	float10 fVar2;
	
	ppCVar1 = globals::g_Effects_BoulderExplodes;
	do {
		if (*ppCVar1 != NULL) {
			fVar2 = res::Container_MoveAnimation(*ppCVar1,elapsedGame);
			if ((ushort)((ushort)(fVar2 < (float10)0.0) << 8 | (ushort)(fVar2 == (float10)0.0) << 0xe) ==
					0) {
				res::Container_Remove(*ppCVar1);
				*ppCVar1 = NULL;
			}
		}
		ppCVar1 = ppCVar1 + 1;
	} while (ppCVar1 < globals::g_Effects_SmashPath);
	return;
}



void __cdecl lego::effect::Effect_Update_SmashPath(float elapsedGame)
{
	Container **ppCVar1;
	float10 fVar2;
	
	ppCVar1 = globals::g_Effects_SmashPath;
	do {
		if (*ppCVar1 != NULL) {
			fVar2 = res::Container_MoveAnimation(*ppCVar1,elapsedGame);
			if ((ushort)((ushort)(fVar2 < (float10)0.0) << 8 | (ushort)(fVar2 == (float10)0.0) << 0xe) ==
					0) {
				res::Container_Remove(*ppCVar1);
				*ppCVar1 = NULL;
			}
		}
		ppCVar1 = ppCVar1 + 1;
	} while (ppCVar1 < &globals::g_MiscObjectResource_ShortElectricFenceBeam);
	return;
}



void __cdecl lego::effect::Effect_GetXY_RockFall(int param_1,int param_2,int *out_x,int *out_y)
{
	int iVar1;
	
	iVar1 = (param_1 + globals::g_RockFallStyleIndex * 3) * 0xa4;
	*out_x = *(int *)(iVar1 + 0x4c81f4 + param_2 * 4);
	*out_y = *(int *)(&DAT_004c8204 + param_2 * 4 + iVar1);
	return;
}



int ** __cdecl lego::effect::Effect_Unk_RockFall_FUN_0040c4e0(int param_1,uint param_2)
{
	int *piVar1;
	char *name;
	Container *pCVar2;
	uint uVar3;
	uint uVar4;
	int *piVar5;
	
	uVar3 = 0;
	piVar5 = (int *)((int)globals::g_MiscObjectDependencies_TABLE[0x13] +
									globals::g_RockFallStyleIndex * 0x1ec + 0xb64);
	do {
		if (*piVar5 != 0) {
			uVar4 = 0;
			piVar1 = piVar5 + 5;
			do {
				if (((piVar1[8] == 0) && (param_1 == *piVar1)) && (param_2 == piVar1[4])) {
					param_2 = 0;
					if (piVar5[0x12] != 0) goto LAB_0040c546;
					goto LAB_0040c564;
				}
				uVar4 += 1;
				piVar1 = piVar1 + 1;
			} while (uVar4 < 4);
		}
		uVar3 += 1;
		piVar5 = piVar5 + 0x29;
		if (2 < uVar3) {
			return (int **)NULL;
		}
	} while( true );
	while( true ) {
		param_2 += 1;
		if ((uint)piVar5[0x12] <= param_2) break;
LAB_0040c546:
		if ((piVar5[uVar4 + 0x25] & 1 << ((byte)param_2 & 0x1f)) == 0) break;
	}
LAB_0040c564:
	if (param_2 != piVar5[0x12]) {
		piVar5[uVar4 + 0x25] = piVar5[uVar4 + 0x25] | 1 << ((byte)param_2 & 0x1f);
		name = res::Container_FormatPartName
										 ((Container *)piVar5[uVar4 + 1],(char *)piVar5[0x11],(int *)&param_2);
		pCVar2 = res::Container_SearchTree
											 ((Container *)piVar5[uVar4 + 1],name,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
		return (int **)pCVar2;
	}
	return (int **)NULL;
}



void __cdecl lego::effect::Effect_RemoveAll_BoulderExplode(void)
{
	Container **ppCVar1;
	
	ppCVar1 = globals::g_Effects_BoulderExplodes;
	do {
		if (*ppCVar1 != NULL) {
			res::Container_Remove(*ppCVar1);
			*ppCVar1 = NULL;
		}
		ppCVar1 = ppCVar1 + 1;
	} while (ppCVar1 < globals::g_Effects_SmashPath);
	return;
}



void __cdecl lego::effect::Effect_RemoveAll_RockFall(void)
{
	int iVar1;
	uint uVar2;
	Container **ppCVar3;
	int iVar4;
	
	uVar2 = 0;
	iVar1 = globals::g_RockFallStyleIndex;
	do {
		iVar4 = uVar2 + iVar1 * 3;
		if (*(int *)((int)globals::g_MiscObjectDependencies_TABLE[0x13] + iVar4 * 0xa4 + 0xb64) != 0) {
			ppCVar3 = (Container **)
								((int)globals::g_MiscObjectDependencies_TABLE[0x13] + iVar4 * 0xa4 + 0xb68);
			iVar4 = 4;
			do {
				res::Container_Remove(*ppCVar3);
				*ppCVar3 = NULL;
				ppCVar3 = ppCVar3 + 1;
				iVar4 += -1;
				iVar1 = globals::g_RockFallStyleIndex;
			} while (iVar4 != 0);
		}
		uVar2 += 1;
	} while (uVar2 < 3);
	return;
}



void __cdecl lego::effect::Effect_Load_Explosion(Container *resRoot,char *filename)
{
	globals::g_MiscObjectResource_Explosion = res::Container_Load(resRoot,filename,"LWS",TRUE);
	res::Container_Hide(globals::g_MiscObjectResource_Explosion,TRUE);
	return;
}



void __cdecl lego::effect::Effect_Spawn_Explosion(LiveObject *optor_liveObj,Point2F *optor_position)
{
	SurfaceMap *surfMap;
	Container *pCVar1;
	float10 fVar2;
	float x;
	float y;
	Vector3F position;
	
	if (optor_liveObj == NULL) {
		position.x = optor_position->x;
		position.y = optor_position->y;
	}
	else {
		game::LiveObject_GetPosition(optor_liveObj,(float *)&position,&position.y);
	}
	x = position.x;
	y = position.y;
	surfMap = game::GetSurfaceMap();
	fVar2 = game::Map3D_GetWorldZ(surfMap,x,y);
	position.z = (float)(fVar2 - (float10)1.0);
	if ((uint)globals::g_Effects_ExplosionCount < 4) {
		pCVar1 = res::Container_Clone(globals::g_MiscObjectResource_Explosion);
		globals::g_Effects_Explosion[globals::g_Effects_ExplosionCount] = pCVar1;
		pCVar1 = globals::g_Effects_Explosion[globals::g_Effects_ExplosionCount];
		globals::g_Effects_ExplosionCount += 1;
		res::Container_Hide(pCVar1,FALSE);
		res::Container_SetPosition(pCVar1,NULL,position.x,position.y,position.z);
		res::Container_SetOrientation(pCVar1,NULL,0.0,1.0,0.0,0.0,0.0,-1.0);
		res::Container_SetAnimationTime(pCVar1,0.0);
	}
	return;
}



void __cdecl lego::effect::Effect_Update_Explosion(float elapsedGame)
{
	Container *cont;
	int iVar1;
	Container **ppCVar2;
	Container **ppCVar3;
	float10 fVar4;
	
	iVar1 = 0;
	if (0 < globals::g_Effects_ExplosionCount) {
		ppCVar2 = globals::g_Effects_Explosion;
		do {
			cont = *ppCVar2;
			fVar4 = res::Container_MoveAnimation(cont,elapsedGame);
			ppCVar3 = ppCVar2;
			if (fVar4 != (float10)0.0) {
				res::Container_Remove(cont);
				globals::g_Effects_ExplosionCount += -1;
				iVar1 += -1;
				ppCVar3 = ppCVar2 + -1;
				*ppCVar2 = globals::g_Effects_Explosion[globals::g_Effects_ExplosionCount];
			}
			iVar1 += 1;
			ppCVar2 = ppCVar3 + 1;
		} while (iVar1 < globals::g_Effects_ExplosionCount);
	}
	return;
}



MiscEffectData * __cdecl lego::effect::Effect_GetDataByType(MiscEffectType miscEffectType)
{
	switch(miscEffectType) {
	case MISCOBJECT_LAZERHIT:
		return &globals::g_MiscObject_LazerHit;
	case MISCOBJECT_PUSHERHIT:
		return &globals::g_MiscObject_PusherHit;
	case MISCOBJECT_FREEZERHIT:
		return &globals::g_MiscObject_FreezerHit;
	case MISCOBJECT_PATHDUST:
		return &globals::g_MiscObject_PathDust;
	case MISCOBJECT_LAVAEROSIONSMOKE1:
		return &globals::g_MiscObject_LavaErosionSmoke1;
	case MISCOBJECT_LAVAEROSIONSMOKE2:
		return &globals::g_MiscObject_LavaErosionSmoke2;
	case MISCOBJECT_LAVAEROSIONSMOKE3:
		return &globals::g_MiscObject_LavaErosionSmoke3;
	case MISCOBJECT_LAVAEROSIONSMOKE4:
		return &globals::g_MiscObject_LavaErosionSmoke4;
	case MISCOBJECT_BIRDSCARER:
		return &globals::g_MiscObject_BirdScarer;
	case MISCOBJECT_UPGRADEEFFECT:
		return &globals::g_MiscObject_UpgradeEffect;
	default:
		return NULL;
	}
}



BOOL __cdecl
lego::effect::Effect_LoadMiscObjectEffect
					(MiscEffectData *miscObjData,Container *resRoot,char *filename)
{
	Container *pCVar1;
	
	if (filename == NULL) {
		return 0;
	}
	pCVar1 = res::Container_Load(resRoot,filename,"LWS",TRUE);
	miscObjData->resData = pCVar1;
	if (pCVar1 == NULL) {
		pCVar1 = res::Container_Load(resRoot,filename,"LWO",TRUE);
		miscObjData->resData = pCVar1;
		if (pCVar1 == NULL) {
			return 0;
		}
	}
	res::Container_Hide(miscObjData->resData,TRUE);
	return TRUE;
}



void __cdecl
lego::effect::Effect_LoadMiscObjectEffects(CFGProperty *root,char *rootPath,Container *cont)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","LazerHit",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_LoadMiscObjectEffect(&globals::g_MiscObject_LazerHit,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","PusherHit",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_LoadMiscObjectEffect(&globals::g_MiscObject_PusherHit,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","FreezerHit",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_LoadMiscObjectEffect(&globals::g_MiscObject_FreezerHit,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","PathDust",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_LoadMiscObjectEffect(&globals::g_MiscObject_PathDust,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","LavaErosionSmoke1",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_LoadMiscObjectEffect(&globals::g_MiscObject_LavaErosionSmoke1,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","LavaErosionSmoke2",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_LoadMiscObjectEffect(&globals::g_MiscObject_LavaErosionSmoke2,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","LavaErosionSmoke3",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_LoadMiscObjectEffect(&globals::g_MiscObject_LavaErosionSmoke3,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","LavaErosionSmoke4",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_LoadMiscObjectEffect(&globals::g_MiscObject_LavaErosionSmoke4,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","BirdScarer",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_LoadMiscObjectEffect(&globals::g_MiscObject_BirdScarer,cont,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"MiscObjects","UpgradeEffect",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	Effect_LoadMiscObjectEffect(&globals::g_MiscObject_UpgradeEffect,cont,pcVar1);
	return;
}



void __cdecl lego::effect::Effect_Update_Particle(MiscEffectData *miscEffect,float elapsedGame)
{
	Container *cont;
	uint uVar1;
	uint uVar2;
	MiscEffectData *pMVar3;
	uint uVar4;
	float10 fVar5;
	Point2F local_14;
	Vector3F local_c;
	
	uVar4 = 0;
	pMVar3 = miscEffect;
	if (miscEffect->count != 0) {
		do {
			cont = pMVar3->table[0];
			if ((miscEffect == &globals::g_MiscObject_BirdScarer) &&
				 (globals::g_MiscObject_BirdScarer.field_2c =
							 elapsedGame + globals::g_MiscObject_BirdScarer.field_2c,
				 (ushort)((ushort)(globals::g_MiscObject_BirdScarer.field_2c < 12.5) << 8 |
								 (ushort)(globals::g_MiscObject_BirdScarer.field_2c == 12.5) << 0xe) == 0)) {
				res::Container_GetPosition(cont,NULL,&local_c);
				local_14.x = local_c.x;
				local_14.y = local_c.y;
				game::Game_DoBirdScarerRadiusCallbacks_FUN_00440b80
									(NULL,&local_14,globs::gameGlobs.BirdScarerRadius);
				globals::g_MiscObject_BirdScarer.field_2c = 0.0;
			}
			fVar5 = res::Container_MoveAnimation(cont,elapsedGame);
			if (fVar5 != (float10)0.0) {
				res::Container_Remove(cont);
				uVar1 = miscEffect->count;
				uVar2 = uVar1 - 1;
				miscEffect->count = uVar2;
				if (uVar4 == uVar2) {
					pMVar3->table[0] = NULL;
				}
				else {
					pMVar3->table[0] = miscEffect->table[uVar1 - 1];
				}
				uVar4 -= 1;
				pMVar3 = (MiscEffectData *)&pMVar3[-1].field_34;
			}
			uVar4 += 1;
			pMVar3 = (MiscEffectData *)(pMVar3->table + 1);
		} while (uVar4 < miscEffect->count);
	}
	return;
}



void __cdecl lego::effect::Effect_Update_AllParticles(float elapsedGame)
{
	Effect_Update_Particle(&globals::g_MiscObject_LazerHit,elapsedGame);
	Effect_Update_Particle(&globals::g_MiscObject_PusherHit,elapsedGame);
	Effect_Update_Particle(&globals::g_MiscObject_FreezerHit,elapsedGame);
	Effect_Update_Particle(&globals::g_MiscObject_PathDust,elapsedGame);
	Effect_Update_Particle(&globals::g_MiscObject_LavaErosionSmoke1,elapsedGame);
	Effect_Update_Particle(&globals::g_MiscObject_LavaErosionSmoke2,elapsedGame);
	Effect_Update_Particle(&globals::g_MiscObject_LavaErosionSmoke3,elapsedGame);
	Effect_Update_Particle(&globals::g_MiscObject_LavaErosionSmoke4,elapsedGame);
	Effect_Update_Particle(&globals::g_MiscObject_BirdScarer,elapsedGame);
	Effect_Update_Particle(&globals::g_MiscObject_UpgradeEffect,elapsedGame);
	return;
}



BOOL __cdecl
lego::effect::Effect_Spawn_Particle
					(MiscEffectType miscEffectType,Vector3F *position,Vector3F *opt_dir)
{
	MiscEffectData *pMVar1;
	Container *pCVar2;
	float dirx;
	float diry;
	float dirz;
	
	pMVar1 = Effect_GetDataByType(miscEffectType);
	if (((pMVar1->count < 10) && (pMVar1 != NULL)) && (pMVar1->resData != NULL)) {
		pMVar1->field_2c = 0;
		pCVar2 = res::Container_Clone(pMVar1->resData);
		pMVar1->table[pMVar1->count] = pCVar2;
		res::Container_SetAnimationTime(pMVar1->table[pMVar1->count],0.0);
		res::Container_SetPosition
							(pMVar1->table[pMVar1->count],NULL,position->x,position->y,position->z);
		if (opt_dir == NULL) {
			dirz = 0.0;
			diry = 1.0;
			dirx = 0.0;
			pCVar2 = pMVar1->table[pMVar1->count];
		}
		else {
			dirz = opt_dir->z;
			diry = opt_dir->y;
			dirx = opt_dir->x;
			pCVar2 = pMVar1->table[pMVar1->count];
		}
		res::Container_SetOrientation(pCVar2,NULL,dirx,diry,dirz,0.0,0.0,-1.0);
		pMVar1->count = pMVar1->count + 1;
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::ElectricFence_Initialise(LevelData *level)
{
	uint uVar1;
	int iVar2;
	BlockObject *pBVar3;
	BlockObject **ppBVar4;
	
	PTRGRIDBlockObject_004c8df8 =
			 (BlockObject *)std::malloc((level->dimensions).width * (level->dimensions).height * 0x14);
	if (PTRGRIDBlockObject_004c8df8 != NULL) {
		pBVar3 = PTRGRIDBlockObject_004c8df8;
		for (uVar1 = (level->dimensions).width * (level->dimensions).height * 5 & 0x3fffffff; uVar1 != 0
				; uVar1 -= 1) {
			pBVar3->attachedObject = NULL;
			pBVar3 = (BlockObject *)&pBVar3->position;
		}
		for (iVar2 = 0; iVar2 != 0; iVar2 += -1) {
			*(undefined *)&pBVar3->attachedObject = 0;
			pBVar3 = (BlockObject *)((int)&pBVar3->attachedObject + 1);
		}
	}
	globals::g_Level = level;
	ppBVar4 = pool::globals::ReservedPool_BlockObject___g_TABLE;
	for (iVar2 = 0x20; iVar2 != 0; iVar2 += -1) {
		*ppBVar4 = NULL;
		ppBVar4 = ppBVar4 + 1;
	}
	pool::globals::ReservedPool_BlockObject___g_NEXT = NULL;
	pool::globals::ReservedPool_BlockObject___g_COUNT = 0;
	return;
}



void __cdecl lego::game::ElectricFence_Shutdown(void)
{
	BlockObject **ppBVar1;
	
	ppBVar1 = pool::globals::ReservedPool_BlockObject___g_TABLE;
	do {
		if (*ppBVar1 != NULL) {
			std::free(*ppBVar1);
		}
		ppBVar1 = ppBVar1 + 1;
	} while (ppBVar1 < &pool::globals::ReservedPool_BlockObject___g_NEXT);
	pool::globals::ReservedPool_BlockObject___g_NEXT = NULL;
	if (PTRGRIDBlockObject_004c8df8 != NULL) {
		std::free(PTRGRIDBlockObject_004c8df8);
		PTRGRIDBlockObject_004c8df8 = NULL;
	}
	return;
}



void __cdecl lego::game::ElectricFence_ResetAll(LevelData *level)
{
	ElectricFence_Shutdown();
	ElectricFence_Initialise(level);
	return;
}



void __cdecl lego::game::ElectricFence_UpdateBlockAndSurrounding4Surfaces(int bx,int by)
{
	int iVar1;
	int iVar2;
	int iVar3;
	BOOL BVar4;
	int *pDir;
	Point2I DIRECTIONS [4];
	
	iVar3 = by;
	DIRECTIONS[0].y = 1;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[0].x = 0;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[3].y = 0;
	DIRECTIONS[2].y = -1;
	DIRECTIONS[3].x = -1;
	Level_UpdateBlockSurfaceUnk(globals::g_Level,bx,by,0);
	pDir = &DIRECTIONS[0].y;
	by = 4;
	do {
		iVar1 = pDir[-1];
		iVar2 = *pDir;
		BVar4 = Map3D_IsInsideDimensions(globals::g_Level->surfaceMap,iVar1 + bx,iVar3 + iVar2);
		if (BVar4 != 0) {
			Level_UpdateBlockSurfaceUnk(globals::g_Level,iVar1 + bx,iVar3 + iVar2,0);
		}
		pDir = pDir + 2;
		by += -1;
	} while (by != 0);
	return;
}



void __cdecl lego::game::ElectricFence_AssignBlockObject(LiveObject *liveObj)
{
	LiveObject *liveObj_00;
	int local_4;
	
	liveObj_00 = liveObj;
	LiveObject_GetBlockPos(liveObj,&local_4,(int *)&liveObj);
	ElectricFence_Create(liveObj_00,local_4,(int)liveObj);
	return;
}



BlockObject * __cdecl lego::game::ElectricFence_Create(LiveObject *liveObj,int x,int y)
{
	LiveObject **ppLVar1;
	BlockObject *pBVar2;
	
	if (pool::globals::ReservedPool_BlockObject___g_NEXT == NULL) {
		ElectricFence_AddList();
	}
	pBVar2 = pool::globals::ReservedPool_BlockObject___g_NEXT;
	ppLVar1 = &pool::globals::ReservedPool_BlockObject___g_NEXT->attachedObject;
	pool::globals::ReservedPool_BlockObject___g_NEXT =
			 pool::globals::ReservedPool_BlockObject___g_NEXT->pool_m_next;
	*ppLVar1 = NULL;
	(pBVar2->position).x = 0;
	(pBVar2->position).y = 0;
	pBVar2->field_c = 0;
	pBVar2->pool_m_next = NULL;
	pBVar2->pool_m_next = pBVar2;
	pBVar2->attachedObject = liveObj;
	(pBVar2->position).x = x;
	(pBVar2->position).y = y;
	*(undefined4 *)
	 ((int)&PTRGRIDBlockObject_004c8df8->position +
	 ((globals::g_Level->dimensions).width * y + x) * 0xc + 4) = 0;
	(&PTRGRIDBlockObject_004c8df8->attachedObject)[((globals::g_Level->dimensions).width * y + x) * 3]
			 = (LiveObject *)pBVar2;
	liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_2000000;
	ElectricFence_UpdateBlockAndSurrounding4Surfaces(x,y);
	return pBVar2;
}



void __cdecl lego::game::ElectricFence_AddList(void)
{
	BlockObject *pBVar1;
	BlockObject *pBVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)pool::globals::ReservedPool_BlockObject___g_COUNT & 0x1f);
	pBVar2 = (BlockObject *)std::malloc(uVar4 * 0x14);
	pool::globals::ReservedPool_BlockObject___g_TABLE
	[pool::globals::ReservedPool_BlockObject___g_COUNT] = pBVar2;
	pBVar2 = pool::globals::ReservedPool_BlockObject___g_TABLE
					 [pool::globals::ReservedPool_BlockObject___g_COUNT];
	if (pBVar2 != NULL) {
		pool::globals::ReservedPool_BlockObject___g_COUNT += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pBVar1 = pBVar2;
			do {
				pBVar1->pool_m_next = pBVar1 + 1;
				iVar3 += -1;
				pBVar1 = pBVar1 + 1;
			} while (iVar3 != 0);
		}
		pBVar2[uVar4 - 1].pool_m_next = pool::globals::ReservedPool_BlockObject___g_NEXT;
		pool::globals::ReservedPool_BlockObject___g_NEXT = pBVar2;
	}
	return;
}



void __cdecl lego::game::ElectricFence_LiveObject_Destroy(LiveObject *liveObj)
{
	int local_4;
	
	if ((liveObj->flags2 & LIVEOBJ2_UNK_2000000) != LIVEOBJ2_NONE) {
		LiveObject_GetBlockPos(liveObj,&local_4,(int *)&liveObj);
		if ((&PTRGRIDBlockObject_004c8df8->attachedObject)
				[((globals::g_Level->dimensions).width * (int)liveObj + local_4) * 3] != NULL) {
			ElectricFence_Remove
								((BlockObject *)
								 (&PTRGRIDBlockObject_004c8df8->attachedObject)
								 [((globals::g_Level->dimensions).width * (int)liveObj + local_4) * 3],local_4,
								 (int)liveObj);
		}
	}
	return;
}



void __cdecl lego::game::ElectricFence_Remove(BlockObject *block,int x,int y)
{
	block->pool_m_next = pool::globals::ReservedPool_BlockObject___g_NEXT;
	pool::globals::ReservedPool_BlockObject___g_NEXT = block;
	*(undefined4 *)
	 ((int)&PTRGRIDBlockObject_004c8df8->position +
	 ((globals::g_Level->dimensions).width * y + x) * 0xc + 4) = 0;
	(&PTRGRIDBlockObject_004c8df8->attachedObject)[((globals::g_Level->dimensions).width * y + x) * 3]
			 = NULL;
	ElectricFence_UpdateBlockAndSurrounding4Surfaces(x,y);
	return;
}



BOOL __cdecl lego::game::ElectricFence_Block_FUN_0040d0a0(int bx,int by)
{
	BOOL BVar1;
	LiveObject *liveObj;
	Point2F local_8;
	
	BVar1 = ElectricFence_Block_FUN_0040d170(bx,by);
	if (BVar1 != 0) {
		Map3D_BlockToWorldPos(globals::g_Level->surfaceMap,bx,by,(float *)&local_8,&local_8.y);
		liveObj = Game_CreateLiveResourceObject
												(globs::gameGlobs.RES_ElectricFence,OBJECT_ELECTRICFENCE,0,0,local_8.x,
												 local_8.y,0.0);
		ElectricFence_Create(liveObj,bx,by);
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::game::ElectricFence_DestroyAttachedElecFence(int bx,int by)
{
	LiveObject *liveObj;
	
	if ((&PTRGRIDBlockObject_004c8df8->attachedObject)
			[((globals::g_Level->dimensions).width * by + bx) * 3] != NULL) {
		liveObj = (LiveObject *)
							(&PTRGRIDBlockObject_004c8df8->attachedObject)
							[((globals::g_Level->dimensions).width * by + bx) * 3]->objType;
		ElectricFence_LiveObject_Destroy(liveObj);
		pool::ReservedPool_LiveObject___Release(liveObj);
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::game::ElectricFence_Block_FUN_0040d170(int bx,int by)
{
	TerrainType TVar1;
	int iVar2;
	BOOL BVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	int local_40 [16];
	
	local_40[9] = 2;
	local_40[10] = 2;
	local_40[13] = 0xfffffffe;
	local_40[14] = 0xfffffffe;
	local_40[1] = 1;
	local_40[2] = 1;
	local_40[5] = 0xffffffff;
	local_40[6] = 0xffffffff;
	iVar2 = (globals::g_Level->dimensions).width * by + bx;
	local_40[8] = 0;
	local_40[11] = 0;
	local_40[12] = 0;
	local_40[15] = 0;
	local_40[0] = 0;
	local_40[3] = 0;
	local_40[4] = 0;
	local_40[7] = 0;
	if (((((*(byte *)&globals::g_Level->blocks[iVar2].flags1 & 8) == 0) ||
			 (TVar1 = globals::g_Level->blocks[iVar2].terrain, TVar1 == TERRAIN_LAVA)) ||
			(TVar1 == TERRAIN_WATER_unused)) ||
		 (((&PTRGRIDBlockObject_004c8df8->attachedObject)[iVar2 * 3] != NULL ||
			(BVar3 = ElectricFence_Block_FUN_0040d320(globals::g_Level,bx,by,0), BVar3 != 0)))) {
		return 0;
	}
	uVar4 = 0;
	do {
		uVar5 = *(int *)((int)local_40 + uVar4) + bx;
		uVar6 = by + *(int *)((int)local_40 + uVar4 + 4);
		BVar3 = Map3D_IsInsideDimensions(globals::g_Level->surfaceMap,uVar5,uVar6);
		if ((BVar3 != 0) &&
			 (((&PTRGRIDBlockObject_004c8df8->attachedObject)
				 [((globals::g_Level->dimensions).width * uVar6 + uVar5) * 3] != NULL ||
				(BVar3 = ElectricFence_Block_FUN_0040d320(globals::g_Level,uVar5,uVar6,0), BVar3 != 0)))) {
			return TRUE;
		}
		uVar5 = *(int *)((int)local_40 + uVar4 + 0x20) + bx;
		uVar6 = *(int *)((int)local_40 + uVar4 + 0x24) + by;
		BVar3 = Map3D_IsInsideDimensions(globals::g_Level->surfaceMap,uVar5,uVar6);
		if (BVar3 != 0) {
			if ((&PTRGRIDBlockObject_004c8df8->attachedObject)
					[((globals::g_Level->dimensions).width * uVar6 + uVar5) * 3] != NULL) {
				return 1;
			}
			BVar3 = ElectricFence_Block_FUN_0040d320(globals::g_Level,uVar5,uVar6,0);
			if (BVar3 != 0) {
				return 1;
			}
		}
		uVar4 += 8;
		if (0x1f < uVar4) {
			return 0;
		}
	} while( true );
}



BOOL __cdecl
lego::game::ElectricFence_Block_FUN_0040d320(LevelData *level,int bx,int by,BOOL param_4)
{
	BOOL BVar1;
	Point2I blockPos;
	
	blockPos.x = bx;
	blockPos.y = by;
	BVar1 = Level_BlockIsFlags1_400_AndOptIsFlags2_4(bx,by,TRUE);
	if (BVar1 != 0) {
		if (param_4 == 0) {
			return 1;
		}
		BVar1 = Level_BlockHasFlag2_100(&blockPos);
		if (BVar1 != 0) {
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::game::ElectricFence_Update(float elapsedGame)
{
	ElectricFence_FUN_0040d3c0(ElectricFence_FUN_0040d6a0,&elapsedGame);
	Search_LiveObjects_SkipIgnoreMes(ElectricFence_LiveObject_Callback_FUN_0040d650,NULL);
	Search_LiveObjects_SkipIgnoreMes(ElectricFence_FUN_0040d510,&elapsedGame);
	return;
}



void __cdecl lego::game::ElectricFence_FUN_0040d3c0(undefined *param_1,undefined4 param_2)
{
	int iVar1;
	int iVar2;
	BlockObject **ppBVar3;
	uint uVar4;
	int iVar5;
	
	uVar4 = 0;
	if (pool::globals::ReservedPool_BlockObject___g_COUNT != 0) {
		ppBVar3 = pool::globals::ReservedPool_BlockObject___g_TABLE;
		do {
			if ((*ppBVar3 != NULL) && (iVar1 = 1 << ((byte)uVar4 & 0x1f), iVar1 != 0)) {
				iVar5 = 0;
				do {
					iVar2 = (int)&(*ppBVar3)->attachedObject + iVar5;
					if ((iVar2 != 0) && (*(int *)(iVar2 + 0x10) == iVar2)) {
						(*(code *)param_1)(iVar2,param_2);
					}
					iVar5 += 0x14;
					iVar1 += -1;
				} while (iVar1 != 0);
			}
			uVar4 += 1;
			ppBVar3 = ppBVar3 + 1;
		} while (uVar4 < pool::globals::ReservedPool_BlockObject___g_COUNT);
	}
	return;
}



undefined4 __cdecl
lego::game::ElectricFence_FUN_0040d420(undefined4 *param_1,uint param_2,uint param_3)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	float local_8;
	float local_4;
	
	ElectricFence_FUN_0040d3c0(ElectricFence_FUN_0040d6a0,0);
	Search_LiveObjects_SkipIgnoreMes(ElectricFence_LiveObject_Callback_FUN_0040d650,NULL);
	if (param_1 == NULL) {
		if (((&PTRGRIDBlockObject_004c8df8->attachedObject)
				 [((globals::g_Level->dimensions).width * param_3 + param_2) * 3] == NULL) &&
			 (BVar2 = ElectricFence_Block_FUN_0040d320(globals::g_Level,param_2,param_3,0), BVar2 == 0)) {
			return 0;
		}
	}
	else {
		LiveObject_GetPosition((LiveObject *)param_1,&local_8,&local_4);
		Map3D_WorldToBlockPos_NoZ
							(globals::g_Level->surfaceMap,local_8,local_4,(int *)&param_2,(int *)&param_3);
		OVar1 = LiveObject_GetStatsFlags2((LiveObject *)param_1);
		if (((OVar1 & STATS2_SELFPOWERED) == STATS2_NONE) && ((param_1[0xfa] & 0x20000000) == 0)) {
			return 0;
		}
	}
	ElectricFence_Block_FUN_0040d780(param_2,param_3,1,0.0);
	return 1;
}



undefined4 __cdecl lego::game::ElectricFence_FUN_0040d510(LiveObject *param_1,float *param_2)
{
	float fVar1;
	BOOL BVar2;
	Point2I *pPVar3;
	Point2I *pPVar4;
	float *pfVar5;
	Point2I *pPVar6;
	Direction rotation;
	float *pfVar7;
	Point2F local_10;
	Point2I local_8;
	
	fVar1 = *param_2;
	if (param_1->objType == OBJECT_BUILDING) {
		LiveObject_GetBlockPos(param_1,(int *)&local_8,&local_8.y);
		BVar2 = ElectricFence_Block_FUN_0040d320(globals::g_Level,local_8.x,local_8.y,1);
		if (BVar2 != 0) {
			LiveObject_GetFaceDirection(param_1,&local_10);
			if (ABS(local_10.x) <= ABS(local_10.y)) {
				if ((ushort)((ushort)(local_10.y < 0.0) << 8 | (ushort)(local_10.y == 0.0) << 0xe) == 0) {
					rotation = DIRECTION_UP;
				}
				else {
					rotation = DIRECTION_DOWN;
				}
			}
			else {
				if ((ushort)((ushort)(local_10.x < 0.0) << 8 | (ushort)(local_10.x == 0.0) << 0xe) == 0) {
					rotation = DIRECTION_RIGHT;
				}
				else {
					rotation = DIRECTION_LEFT;
				}
			}
			pPVar3 = res::Building_GetShapePoints(param_1->building,(uint *)&param_2);
			pPVar4 = Game_TransformShapePoints(&local_8,pPVar3,(int)param_2,rotation);
			pfVar7 = NULL;
			pfVar5 = param_2;
			pPVar3 = pPVar4;
			if (param_2 != NULL) {
				do {
					pPVar6 = pPVar3 + 1;
					if (((pfVar7 == (float *)((int)pfVar5 - 1U)) || (pPVar4->x != pPVar6->x)) ||
						 (pPVar4->y != pPVar3[1].y)) {
						ElectricFence_Block_FUN_0040d780(pPVar4->x,pPVar4->y,0,fVar1);
						pfVar5 = param_2;
					}
					else {
						pfVar7 = (float *)((int)pfVar7 + 1);
						pPVar6 = pPVar3 + 2;
						pPVar4 = pPVar4 + 1;
					}
					pfVar7 = (float *)((int)pfVar7 + 1);
					pPVar4 = pPVar4 + 1;
					pPVar3 = pPVar6;
				} while (pfVar7 < pfVar5);
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::ElectricFence_LiveObject_Callback_FUN_0040d650(LiveObject *liveObj,void *data)
{
	Point2I blockPos;
	
	if (liveObj->objType == OBJECT_BUILDING) {
		LiveObject_GetBlockPos(liveObj,(int *)&blockPos,&blockPos.y);
		*(undefined4 *)
		 ((int)&PTRGRIDBlockObject_004c8df8->position +
		 ((globals::g_Level->dimensions).width * blockPos.y + blockPos.x) * 0xc + 4) = 0;
	}
	return 0;
}



void __cdecl lego::game::ElectricFence_FUN_0040d6a0(int param_1,float *param_2)
{
	int iVar1;
	BOOL BVar2;
	int *piVar3;
	uint sx;
	uint sy;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	iVar1 = param_1;
	local_20[1] = 1;
	local_20[2] = 1;
	local_c = 0xffffffff;
	local_8 = 0xffffffff;
	local_20[3] = 0;
	local_20[4] = 0;
	local_4 = 0;
	*(undefined4 *)
	 ((int)&PTRGRIDBlockObject_004c8df8->position +
	 ((globals::g_Level->dimensions).width * *(int *)(param_1 + 8) + *(int *)(param_1 + 4)) * 0xc + 4)
			 = 0;
	piVar3 = local_20 + 1;
	param_1 = 4;
	do {
		sx = piVar3[-1] + *(int *)(iVar1 + 4);
		sy = *(int *)(iVar1 + 8) + *piVar3;
		BVar2 = Map3D_IsInsideDimensions(globals::g_Level->surfaceMap,sx,sy);
		if (BVar2 != 0) {
			*(undefined4 *)
			 ((int)&PTRGRIDBlockObject_004c8df8->position +
			 ((globals::g_Level->dimensions).width * sy + sx) * 0xc + 4) = 0;
		}
		piVar3 = piVar3 + 2;
		param_1 += -1;
	} while (param_1 != 0);
	if ((param_2 != NULL) &&
		 ((ushort)((ushort)(*(float *)(iVar1 + 0xc) < 0.0) << 8 |
							(ushort)(*(float *)(iVar1 + 0xc) == 0.0) << 0xe) == 0)) {
		*(float *)(iVar1 + 0xc) = *(float *)(iVar1 + 0xc) - *param_2;
	}
	return;
}



void __cdecl
lego::game::ElectricFence_Block_FUN_0040d780(uint bx,uint by,BOOL param_3,float param_4)
{
	uint sx;
	uint sy;
	uint *puVar1;
	VehicleData *pVVar2;
	bool bVar3;
	short sVar4;
	BOOL BVar5;
	int iVar6;
	int iVar7;
	uint sx_00;
	uint sy_00;
	ulonglong uVar8;
	uint local_5c;
	float local_58;
	int *local_54;
	int local_50;
	uint local_48;
	uint local_44;
	int local_40;
	int local_3c [4];
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	int local_20 [4];
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_20[1] = 2;
	local_20[2] = 2;
	local_c = 0xfffffffe;
	local_8 = 0xfffffffe;
	local_3c[0] = 1;
	local_3c[1] = 1;
	local_2c = 0xffffffff;
	local_28 = 0xffffffff;
	local_20[0] = 0;
	local_20[3] = 0;
	local_10 = 0;
	local_4 = 0;
	local_40 = 0;
	local_3c[2] = 0;
	puVar1 = (uint *)((int)&PTRGRIDBlockObject_004c8df8->position +
									 ((globals::g_Level->dimensions).width * by + bx) * 0xc + 4);
	local_3c[3] = 0;
	local_24 = 0;
	local_5c = 0;
	*puVar1 = *puVar1 | 0x100;
	local_54 = &local_40;
	do {
		bVar3 = false;
		iVar6 = *local_54;
		sx = bx + iVar6;
		sy = local_3c[local_5c * 2] + by;
		BVar5 = Map3D_IsInsideDimensions(globals::g_Level->surfaceMap,sx,sy);
		if ((BVar5 != 0) &&
			 (((&PTRGRIDBlockObject_004c8df8->attachedObject)
				 [((globals::g_Level->dimensions).width * sy + sx) * 3] != NULL ||
				((BVar5 = ElectricFence_Block_FUN_0040d320(globals::g_Level,sx,sy,1), BVar5 != 0 &&
				 (BVar5 = ElectricFence_Block_FUN_0040d320(globals::g_Level,bx,by,0), BVar5 == 0)))))) {
			bVar3 = true;
			local_50 = 1;
			local_48 = sx;
			local_44 = sy;
		}
		if (bVar3) {
LAB_0040d9a4:
			if (local_50 == 0) {
				iVar6 = (globals::g_Level->dimensions).width * sy + bx + iVar6;
				*(uint *)((int)&PTRGRIDBlockObject_004c8df8->position + iVar6 * 0xc + 4) =
						 *(uint *)((int)&PTRGRIDBlockObject_004c8df8->position + iVar6 * 0xc + 4) | 0x100;
			}
			iVar6 = (globals::g_Level->dimensions).width;
			iVar7 = local_44 * iVar6 + local_48;
			if (((&PTRGRIDBlockObject_004c8df8->attachedObject)[iVar7 * 3] == NULL) ||
				 (pVVar2 = (&PTRGRIDBlockObject_004c8df8->attachedObject)[iVar7 * 3]->vehicle,
				 (ushort)((ushort)((float)pVVar2 < 0.0) << 8 | (ushort)((float)pVVar2 == 0.0) << 0xe) != 0))
			{
				if ((*(uint *)((int)&PTRGRIDBlockObject_004c8df8->position + iVar7 * 0xc + 4) &
						1 << ((byte)local_5c & 0x1f)) == 0) {
					puVar1 = (uint *)((int)&PTRGRIDBlockObject_004c8df8->position +
													 (by * iVar6 + bx) * 0xc + 4);
					*puVar1 = *puVar1 | 1 << ((byte)local_5c - 2 & 3);
					local_58 = param_4;
					if ((ushort)((ushort)(param_4 < 200.0) << 8 | (ushort)(param_4 == 200.0) << 0xe) == 0) {
						local_58 = 200.0;
					}
					if (param_3 == 0) {
						if (local_58 != 0.0) {
							sVar4 = math::Maths_Rand();
							uVar8 = __ftol((float10)200.0 / (float10)local_58);
							if ((int)((ulonglong)(uint)(int)sVar4 % (uVar8 & 0xffffffff)) == 0) goto LAB_0040dab9;
						}
					}
					else {
LAB_0040dab9:
						ElectricFence_Block_UnkAreaDistanceBetweenBlocks(bx,by,local_48,local_44);
					}
				}
				BVar5 = ElectricFence_Block_FUN_0040d320(globals::g_Level,local_48,local_44,0);
				if ((BVar5 == 0) &&
					 ((*(uint *)((int)&PTRGRIDBlockObject_004c8df8->position +
											((globals::g_Level->dimensions).width * local_44 + local_48) * 0xc + 4) &
						0x100) == 0)) {
					ElectricFence_Block_FUN_0040d780(local_48,local_44,param_3,param_4);
				}
			}
		}
		else {
			sy_00 = by + local_20[local_5c * 2 + 1];
			sx_00 = local_20[local_5c * 2] + bx;
			BVar5 = Map3D_IsInsideDimensions(globals::g_Level->surfaceMap,sx_00,sy_00);
			if (((BVar5 != 0) &&
					((BVar5 = ElectricFence_Block_FUN_0040d320(globals::g_Level,sx,sy,0), BVar5 == 0 ||
					 (BVar5 = ElectricFence_Block_FUN_0040d320(globals::g_Level,bx,by,0), BVar5 == 0)))) &&
				 (((&PTRGRIDBlockObject_004c8df8->attachedObject)
					 [((globals::g_Level->dimensions).width * sy_00 + sx_00) * 3] != NULL ||
					((BVar5 = ElectricFence_Block_FUN_0040d320(globals::g_Level,sx_00,sy_00,1), BVar5 != 0 &&
					 (BVar5 = ElectricFence_Block_FUN_0040d320(globals::g_Level,bx,by,0), BVar5 == 0)))))) {
				bVar3 = true;
				local_50 = 0;
				local_48 = sx_00;
				local_44 = sy_00;
			}
			if (bVar3) goto LAB_0040d9a4;
		}
		local_5c += 1;
		local_54 = local_54 + 2;
		if (3 < local_5c) {
			return;
		}
	} while( true );
}



BOOL __cdecl
lego::game::ElectricFence_Block_UnkAreaDistanceBetweenBlocks
					(uint bxFrom,uint byFrom,uint bxTo,uint byTo)
{
	bool bVar1;
	uint uVar2;
	uint uVar3;
	float10 fVar4;
	float local_58;
	float local_54;
	float local_50;
	Vector3F local_4c;
	Point2I DISTANCES_SET [2] [4];
	
	DISTANCES_SET[1][0].y = 2;
	DISTANCES_SET[1][1].x = 2;
	DISTANCES_SET[1][2].y = -2;
	DISTANCES_SET[1][3].x = -2;
	DISTANCES_SET[0][0].y = 1;
	DISTANCES_SET[0][1].x = 1;
	DISTANCES_SET[0][2].y = -1;
	DISTANCES_SET[0][3].x = -1;
	DISTANCES_SET[1][0].x = 0;
	DISTANCES_SET[1][1].y = 0;
	DISTANCES_SET[1][2].x = 0;
	DISTANCES_SET[1][3].y = 0;
	DISTANCES_SET[0][0].x = 0;
	DISTANCES_SET[0][1].y = 0;
	DISTANCES_SET[0][2].x = 0;
	DISTANCES_SET[0][3].y = 0;
	bVar1 = false;
	uVar2 = 0;
	do {
		if ((bxTo == *(int *)((int)&DISTANCES_SET[0].x + uVar2) + bxFrom) &&
			 (byTo == byFrom + *(int *)((int)&DISTANCES_SET[0].y + uVar2))) {
			bVar1 = true;
			uVar3 = 1;
			break;
		}
		if ((bxTo == *(int *)((int)&DISTANCES_SET[1][0].x + uVar2) + bxFrom) &&
			 (byTo == *(int *)((int)&DISTANCES_SET[1][0].y + uVar2) + byFrom)) {
			bVar1 = true;
			uVar3 = 0;
			break;
		}
		uVar2 += 8;
		uVar3 = byTo;
	} while (uVar2 < 0x20);
	if (!bVar1) {
		return 0;
	}
	ElectricFence_Block_GetDistanceBetweenBlocks(bxFrom,byFrom,bxTo,byTo,&local_4c);
	Map3D_BlockToWorldPos(globals::g_Level->surfaceMap,bxFrom,byFrom,&local_58,&local_54);
	fVar4 = Map3D_GetWorldZ(globals::g_Level->surfaceMap,local_58,local_54);
	local_50 = (float)fVar4;
	if (uVar3 == 0) {
		lego::effect::Effect_Unk_Spawn_FUN_0040c220
							(1,local_58,local_54,local_50,local_4c.x,local_4c.y,local_4c.z);
		return TRUE;
	}
	lego::effect::Effect_Unk_Spawn_FUN_0040c220
						(0,local_58,local_54,local_50,local_4c.x,local_4c.y,local_4c.z);
	return TRUE;
}



Vector3F * __cdecl
lego::game::ElectricFence_Block_GetDistanceBetweenBlocks
					(uint bxFrom,uint byFrom,uint bxTo,uint byTo,Vector3F *out_vector)
{
	float10 fVar1;
	Vector3F worldPosFrom;
	Vector3F worldPosTo;
	
	Map3D_BlockToWorldPos
						(globals::g_Level->surfaceMap,bxFrom,byFrom,(float *)&worldPosFrom,&worldPosFrom.y);
	fVar1 = Map3D_GetWorldZ(globals::g_Level->surfaceMap,worldPosFrom.x,worldPosFrom.y);
	worldPosFrom.z = (float)fVar1;
	Map3D_BlockToWorldPos(globals::g_Level->surfaceMap,bxTo,byTo,(float *)&worldPosTo,&worldPosTo.y);
	fVar1 = Map3D_GetWorldZ(globals::g_Level->surfaceMap,worldPosTo.x,worldPosTo.y);
	out_vector->x = worldPosTo.x - worldPosFrom.x;
	out_vector->y = worldPosTo.y - worldPosFrom.y;
	out_vector->z = (float)(fVar1 - (float10)worldPosFrom.z);
	return out_vector;
}



BOOL __cdecl lego::game::ElectricFence_LiveObject_FUN_0040dd70(LiveObject *liveObj)
{
	VehicleData *pVVar1;
	float fVar2;
	bool bVar3;
	BOOL BVar4;
	uint weaponType;
	int *piVar5;
	uint uVar6;
	uint uVar7;
	float10 fVar8;
	uint local_4c;
	uint local_48;
	float local_44;
	float local_40;
	uint local_3c;
	uint local_38;
	uint local_34;
	Point2F local_30;
	float local_28;
	float local_24;
	Point2I DIRECTIONS_I [4];
	
	DIRECTIONS_I[0].y = 1;
	DIRECTIONS_I[1].x = 1;
	DIRECTIONS_I[2].y = -1;
	DIRECTIONS_I[3].x = -1;
	DIRECTIONS_I[0].x = 0;
	DIRECTIONS_I[1].y = 0;
	DIRECTIONS_I[2].x = 0;
	DIRECTIONS_I[3].y = 0;
	local_44 = 0.0;
	bVar3 = false;
	LiveObject_GetPosition(liveObj,(float *)&local_30,&local_30.y);
	Map3D_WorldToBlockPos_NoZ
						(globals::g_Level->surfaceMap,local_30.x,local_30.y,(int *)&local_48,(int *)&local_4c);
	uVar7 = local_48;
	uVar6 = local_4c;
	local_3c = local_48;
	local_38 = local_4c;
	if (((*(byte *)((int)&PTRGRIDBlockObject_004c8df8->position +
								 ((globals::g_Level->dimensions).width * local_4c + local_48) * 0xc + 5) & 1) != 0)
		 && (BVar4 = ElectricFence_Block_FUN_0040d320(globals::g_Level,local_48,local_4c,0), BVar4 == 0)
		 ) {
		if ((&PTRGRIDBlockObject_004c8df8->attachedObject)
				[((globals::g_Level->dimensions).width * local_4c + local_48) * 3] == NULL) {
			uVar6 = 0;
			piVar5 = &DIRECTIONS_I[0].y;
			do {
				if (((&PTRGRIDBlockObject_004c8df8->attachedObject)
						 [((globals::g_Level->dimensions).width * (local_4c + *piVar5) + piVar5[-1] + local_48)
							* 3] != NULL) &&
					 (pVVar1 = (&PTRGRIDBlockObject_004c8df8->attachedObject)
										 [((globals::g_Level->dimensions).width * (local_4c + *piVar5) +
											piVar5[-1] + local_48) * 3]->vehicle,
					 (ushort)((ushort)((float)pVVar1 < 0.0) << 8 | (ushort)((float)pVVar1 == 0.0) << 0xe) != 0
					 )) {
					Map3D_BlockToWorldPos
										(globals::g_Level->surfaceMap,piVar5[-1] + local_48,local_4c + *piVar5,&local_28
										 ,&local_24);
					local_40 = local_30.x - local_28;
					fVar2 = SQRT((local_30.y - local_24) * (local_30.y - local_24) + local_40 * local_40);
					if ((fVar2 < local_44) || (local_44 == 0.0)) {
						bVar3 = true;
						local_44 = fVar2;
						local_34 = uVar6;
					}
				}
				uVar6 += 1;
				piVar5 = piVar5 + 2;
			} while (uVar6 < 4);
			uVar6 = local_38;
			uVar7 = local_3c;
			if (bVar3) {
				uVar6 = local_38 + DIRECTIONS_I[local_34].y;
				uVar7 = local_3c + DIRECTIONS_I[local_34].x;
			}
		}
		else {
			pVVar1 = (&PTRGRIDBlockObject_004c8df8->attachedObject)
							 [((globals::g_Level->dimensions).width * local_4c + local_48) * 3]->vehicle;
			if ((ushort)((ushort)((float)pVVar1 < 0.0) << 8 | (ushort)((float)pVVar1 == 0.0) << 0xe) != 0)
			{
				bVar3 = true;
			}
		}
		if (bVar3) {
			ElectricFence_LiveObject_Block_FUN_0040dff0(liveObj,&local_30,local_48,local_4c);
			ElectricFence_FUN_0040d420(NULL,uVar7,uVar6);
			weaponType = tools::Weapon_GetWeaponTypeByName("FenceSpark");
			fVar8 = tools::Weapon_GetRechargeTime(weaponType);
			(&PTRGRIDBlockObject_004c8df8->attachedObject)
			[((globals::g_Level->dimensions).width * uVar6 + uVar7) * 3]->vehicle =
					 (VehicleData *)(float)fVar8;
			return TRUE;
		}
	}
	return 0;
}



void __cdecl
lego::game::ElectricFence_LiveObject_Block_FUN_0040dff0
					(LiveObject *liveObj,Point2F *param_2,uint bx,uint by)
{
	uint weaponType;
	float10 fVar1;
	float10 fVar2;
	BOOL BVar3;
	float fVar4;
	float *pfVar5;
	float local_2c;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	float local_18;
	float local_14;
	float local_c;
	float local_8;
	
	Map3D_BlockToWorldPos(globals::g_Level->surfaceMap,bx,by,&local_24,&local_20);
	fVar1 = Map3D_GetWorldZ(globals::g_Level->surfaceMap,local_24,local_20);
	local_1c = (float)fVar1;
	local_c = param_2->x;
	local_8 = param_2->y;
	fVar1 = Map3D_GetWorldZ(globals::g_Level->surfaceMap,local_c,local_8);
	fVar2 = LiveObject_GetCollHeight(liveObj);
	local_18 = local_c - local_24;
	local_14 = local_8 - local_20;
	lego::effect::Effect_Unk_Spawn_FUN_0040c220
						(0,local_24,local_20,local_1c,local_18,local_14,
						 (float)(((float10)(float)fVar1 - fVar2 * (float10)0.5) - (float10)local_1c));
	pfVar5 = &local_2c;
	local_2c = local_18;
	local_28 = local_14;
	fVar4 = 0.0;
	BVar3 = 1;
	weaponType = tools::Weapon_GetWeaponTypeByName("FenceSpark");
	LiveObject_FUN_0046f530(liveObj,weaponType,BVar3,fVar4,pfVar5);
	LiveObject_UnkActivityCrumble_FUN_004424d0(liveObj);
	return;
}



BOOL __cdecl lego::game::ElectricFence_Block_FUN_0040e110(LevelData *level,uint bx,uint by)
{
	uint uVar1;
	BOOL BVar2;
	uint uVar3;
	int by_01;
	int *piVar4;
	int bx_00;
	int by_00;
	int local_20 [4];
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar1 = by;
	local_20[1] = 1;
	local_20[2] = 1;
	local_20[0] = 0;
	local_20[3] = 0;
	local_10 = 0;
	local_c = 0xffffffff;
	local_8 = 0xffffffff;
	local_4 = 0;
	if (((PTRGRIDBlockObject_004c8df8 == NULL) ||
			((&PTRGRIDBlockObject_004c8df8->attachedObject)
			 [((globals::g_Level->dimensions).width * by + bx) * 3] != NULL)) ||
		 (BVar2 = ElectricFence_Block_FUN_0040d320(level,bx,by,0), BVar2 != 0)) {
		return 0;
	}
	piVar4 = local_20 + 1;
	by = 0;
	do {
		bx_00 = piVar4[-1] + bx;
		by_00 = uVar1 + *piVar4;
		if (((&PTRGRIDBlockObject_004c8df8->attachedObject)
				 [((globals::g_Level->dimensions).width * by_00 + bx_00) * 3] != NULL) ||
			 (BVar2 = ElectricFence_Block_FUN_0040d320(level,bx_00,by_00,0), BVar2 != 0)) {
			uVar3 = by - 2 & 3;
			by_01 = local_20[uVar3 * 2 + 1] + uVar1;
			if (((&PTRGRIDBlockObject_004c8df8->attachedObject)
					 [((globals::g_Level->dimensions).width * by_01 + local_20[uVar3 * 2] + bx) * 3] != NULL)
				 || ((BVar2 = ElectricFence_Block_FUN_0040d320(level,local_20[uVar3 * 2] + bx,by_01,0),
						 BVar2 != 0 &&
						 (BVar2 = ElectricFence_Block_FUN_0040d320(level,bx_00,by_00,0), BVar2 == 0)))) {
				return TRUE;
			}
		}
		piVar4 = piVar4 + 2;
		by += 1;
		if (3 < by) {
			return 0;
		}
	} while( true );
}



void __cdecl
lego::game::ElectricFence_Block_ElecFenceStud_FUN_0040e280
					(LevelData *level,uint bx,uint by,int param_4)
{
	LiveObject *pLVar1;
	float local_8;
	float local_4;
	
	if (PTRGRIDBlockObject_004c8df8 != NULL) {
		if (param_4 == 0) {
			pLVar1 = (LiveObject *)
							 ((Point2I *)
							 ((int)&PTRGRIDBlockObject_004c8df8->position +
							 ((globals::g_Level->dimensions).width * by + bx) * 0xc))->x;
			if (pLVar1 != NULL) {
				pool::ReservedPool_LiveObject___Release(pLVar1);
				((Point2I *)
				((int)&PTRGRIDBlockObject_004c8df8->position +
				((globals::g_Level->dimensions).width * by + bx) * 0xc))->x = 0;
				*(undefined4 *)
				 ((int)&PTRGRIDBlockObject_004c8df8->position +
				 ((globals::g_Level->dimensions).width * by + bx) * 0xc + 4) = 0;
			}
		}
		else {
			if (((Point2I *)
					((int)&PTRGRIDBlockObject_004c8df8->position +
					((globals::g_Level->dimensions).width * by + bx) * 0xc))->x == 0) {
				Map3D_BlockToWorldPos(level->surfaceMap,bx,by,&local_8,&local_4);
				pLVar1 = Game_CreateLiveResourceObject
													 (globs::gameGlobs.RES_ElectricFenceStud,OBJECT_ELECTRICFENCESTUD,0,0,
														local_8,local_4,0.0);
				((Point2I *)
				((int)&PTRGRIDBlockObject_004c8df8->position +
				((globals::g_Level->dimensions).width * by + bx) * 0xc))->x = (int)pLVar1;
				return;
			}
		}
	}
	return;
}



BOOL __cdecl lego::game::ElectricFence_BlockCheck_FUN_0040e390(int bx,int by)
{
	return (uint)((&PTRGRIDBlockObject_004c8df8->attachedObject)
								[((globals::g_Level->dimensions).width * by + bx) * 3] != NULL);
}



void __cdecl lego::front::Encyclopedia_Initialise(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	File *pFVar2;
	uint uVar3;
	File **ppFVar4;
	
	globals::g_Encyclopedia_VehicleTypes_TABLE =
			 (File **)std::malloc(globs::gameGlobs.VehicleTypes_COUNT * 4);
	ppFVar4 = globals::g_Encyclopedia_VehicleTypes_TABLE;
	for (uVar3 = globs::gameGlobs.VehicleTypes_COUNT; uVar3 != 0; uVar3 -= 1) {
		*ppFVar4 = NULL;
		ppFVar4 = ppFVar4 + 1;
	}
	uVar3 = 0;
	if (globs::gameGlobs.VehicleTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia",
																 globs::gameGlobs.VehicleTypes_TABLE[uVar3],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != NULL) {
				pFVar2 = lego::file::File_Open(pcVar1,"r");
				globals::g_Encyclopedia_VehicleTypes_TABLE[uVar3] = pFVar2;
			}
			uVar3 += 1;
		} while (uVar3 < globs::gameGlobs.VehicleTypes_COUNT);
	}
	globals::g_Encyclopedia_MiniFigureTypes_TABLE =
			 (File **)std::malloc(globs::gameGlobs.MiniFigureTypes_COUNT * 4);
	ppFVar4 = globals::g_Encyclopedia_MiniFigureTypes_TABLE;
	for (uVar3 = globs::gameGlobs.MiniFigureTypes_COUNT; uVar3 != 0; uVar3 -= 1) {
		*ppFVar4 = NULL;
		ppFVar4 = ppFVar4 + 1;
	}
	uVar3 = 0;
	if (globs::gameGlobs.MiniFigureTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia",
																 globs::gameGlobs.MiniFigureTypes_TABLE[uVar3],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != NULL) {
				pFVar2 = lego::file::File_Open(pcVar1,"r");
				globals::g_Encyclopedia_MiniFigureTypes_TABLE[uVar3] = pFVar2;
			}
			uVar3 += 1;
		} while (uVar3 < globs::gameGlobs.MiniFigureTypes_COUNT);
	}
	globals::g_Encyclopedia_RockMonsterTypes_TABLE =
			 (File **)std::malloc(globs::gameGlobs.RockMonsterTypes_COUNT * 4);
	ppFVar4 = globals::g_Encyclopedia_RockMonsterTypes_TABLE;
	for (uVar3 = globs::gameGlobs.RockMonsterTypes_COUNT; uVar3 != 0; uVar3 -= 1) {
		*ppFVar4 = NULL;
		ppFVar4 = ppFVar4 + 1;
	}
	uVar3 = 0;
	if (globs::gameGlobs.RockMonsterTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia",
																 globs::gameGlobs.RockMonsterTypes_TABLE[uVar3],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != NULL) {
				pFVar2 = lego::file::File_Open(pcVar1,"r");
				globals::g_Encyclopedia_RockMonsterTypes_TABLE[uVar3] = pFVar2;
			}
			uVar3 += 1;
		} while (uVar3 < globs::gameGlobs.RockMonsterTypes_COUNT);
	}
	globals::g_Encyclopedia_BuildingTypes_TABLE =
			 (File **)std::malloc(globs::gameGlobs.BuildingTypes_COUNT * 4);
	ppFVar4 = globals::g_Encyclopedia_BuildingTypes_TABLE;
	for (uVar3 = globs::gameGlobs.BuildingTypes_COUNT; uVar3 != 0; uVar3 -= 1) {
		*ppFVar4 = NULL;
		ppFVar4 = ppFVar4 + 1;
	}
	uVar3 = 0;
	if (globs::gameGlobs.BuildingTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia",
																 globs::gameGlobs.BuildingTypes_TABLE[uVar3],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != NULL) {
				pFVar2 = lego::file::File_Open(pcVar1,"r");
				globals::g_Encyclopedia_BuildingTypes_TABLE[uVar3] = pFVar2;
			}
			uVar3 += 1;
		} while (uVar3 < globs::gameGlobs.BuildingTypes_COUNT);
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia","PowerCrystal",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globals::g_Encyclopedia_PowerCrystal = lego::file::File_Open(pcVar1,"r");
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"Encyclopedia","Ore",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globals::g_Encyclopedia_Ore = lego::file::File_Open(pcVar1,"r");
	}
	return;
}



void __cdecl lego::front::Encyclopedia_FUN_0040e630(undefined4 *param_1)
{
	undefined4 *puVar1;
	int local_4;
	
	puVar1 = param_1;
	game::LiveObject_GetTypeIndex((LiveObject *)param_1,&local_4,(int *)&param_1);
	if (false) {
switchD_0040e655_caseD_5:
		DAT_004c8ea0 = NULL;
		FLAGS_004c8ea8 = FLAGS_004c8ea8 & 0xfffffffe;
		return;
	}
	switch(local_4) {
	case 1:
		DAT_004c8ea0 = globals::g_Encyclopedia_VehicleTypes_TABLE[(int)param_1];
		break;
	case 2:
		DAT_004c8ea0 = globals::g_Encyclopedia_MiniFigureTypes_TABLE[(int)param_1];
		break;
	case 3:
		DAT_004c8ea0 = globals::g_Encyclopedia_RockMonsterTypes_TABLE[(int)param_1];
		break;
	case 4:
		DAT_004c8ea0 = globals::g_Encyclopedia_BuildingTypes_TABLE[(int)param_1];
		break;
	default:
		goto switchD_0040e655_caseD_5;
	case 6:
		DAT_004c8ea0 = globals::g_Encyclopedia_PowerCrystal;
		break;
	case 7:
		DAT_004c8ea0 = globals::g_Encyclopedia_Ore;
	}
	FLAGS_004c8ea8 |= 3;
	PTR_004c8ea4 = (LiveObject *)puVar1;
	Panel_TextWindow_Clear(PTR_005017dc);
	return;
}



void __cdecl lego::front::Encyclopedia_UnsetFlag1_004c8ea8(void)
{
	FLAGS_004c8ea8 = FLAGS_004c8ea8 & 0xfffffffe;
	return;
}



void __cdecl lego::front::Encyclopedia_FUN_0040e720(float elapsedAbs)
{
	BOOL BVar1;
	char *pcVar2;
	char buff [512];
	
	if (((FLAGS_004c8ea8 & 1) != 0) &&
		 (BVar1 = Panel_IsFlags_4_AndNot8(PANEL_ENCYCLOPEDIA), BVar1 == 0)) {
		if ((FLAGS_004c8ea8 & 2) != 0) {
			if (DAT_004c8ea0 == NULL) {
				Panel_TextWindow_PrintF(PTR_005017dc,"Object has no encyclopedia file.");
			}
			else {
				lego::file::File_Seek(DAT_004c8ea0,0,0);
				pcVar2 = lego::file::File_GetS(buff,0x200,DAT_004c8ea0);
				while (pcVar2 != NULL) {
					Panel_TextWindow_PrintF(PTR_005017dc,"%s",buff);
					pcVar2 = lego::file::File_GetS(buff,0x200,DAT_004c8ea0);
				}
			}
			FLAGS_004c8ea8 &= 0xfffffffd;
		}
		Panel_TextWindow_Update(PTR_005017dc,0,elapsedAbs);
	}
	return;
}



void __cdecl lego::front::Encyclopedia_FUN_0040e800(int param_1)
{
	if (((((byte)FLAGS_004c8ea8 & 1) != 0) && (((byte)globals::g_PanelDatas_TABLE[11].flags & 2) != 0)
			) && (PTR_004c8ea4 != NULL)) {
		game::LiveObject_DrawSelectedBox(PTR_004c8ea4,(Viewport *)param_1,0.0,1.0,0.0);
	}
	return;
}



void __cdecl lego::front::Encyclopedia_LiveObject_ClearPtr_004c8ea4_IfEqual(LiveObject *liveObj)
{
	if (PTR_004c8ea4 == liveObj) {
		PTR_004c8ea4 = NULL;
	}
	return;
}



void __cdecl lego::game::Erode_Initialise(float triggerTime,float erodeTime,float lockTime)
{
	int iVar1;
	BOOL *pBVar2;
	
	globs::erodeGlobs.ErodeTriggerTime = triggerTime * 25.0;
	globs::erodeGlobs.ErodeErodeTime = erodeTime * 25.0 * 0.2;
	globs::erodeGlobs.ErodeLockTime = lockTime * 25.0;
	globs::erodeGlobs.UnkBlocksCount = 0;
	pBVar2 = globs::erodeGlobs.activeStates;
	for (iVar1 = 2000; iVar1 != 0; iVar1 += -1) {
		*pBVar2 = 0;
		pBVar2 = pBVar2 + 1;
	}
	pBVar2 = globs::erodeGlobs.lockedStates;
	for (iVar1 = 1000; iVar1 != 0; iVar1 += -1) {
		*pBVar2 = 0;
		pBVar2 = pBVar2 + 1;
	}
	return;
}



BOOL __cdecl lego::game::Erode_GetFreeActiveIndex(int *out_index)
{
	float *pfVar1;
	int index;
	
	index = 0;
	pfVar1 = (float *)globs::erodeGlobs.activeStates;
	do {
		if (*pfVar1 == 0.0) {
			*out_index = index;
			return TRUE;
		}
		pfVar1 = pfVar1 + 1;
		index += 1;
	} while (pfVar1 < globs::erodeGlobs.activeTimers);
	return 0;
}



// return (float)(6 - block->erodeSpeed) * erodeGlobs.ErodeErodeTime * 25.0f

float10 __cdecl lego::game::Erode_GetBlockErodeRate(Point2I *blockPos)
{
	return (float10)(6 - (uint)(globs::gameGlobs.level)->blocks
														 [((globs::gameGlobs.level)->dimensions).width * blockPos->y +
															blockPos->x].erodeSpeed) * (float10)globs::erodeGlobs.ErodeErodeTime *
				 (float10)25.0;
}



void __cdecl lego::game::Erode_AddActiveBlock(Point2I *position,int unkModulusNum)
{
	LevelData *pLVar1;
	BOOL BVar2;
	float10 fVar3;
	int erodeIndex;
	int local_8;
	undefined4 local_4;
	
	pLVar1 = globs::gameGlobs.level;
	BVar2 = Erode_GetFreeActiveIndex(&erodeIndex);
	if (BVar2 != 0) {
		pLVar1->blocks[position->y * (pLVar1->dimensions).width + position->x].field_7 =
				 (byte)unkModulusNum;
		globs::erodeGlobs.activeBlocks[erodeIndex].x = position->x;
		globs::erodeGlobs.activeBlocks[erodeIndex].y = position->y;
		fVar3 = Erode_GetBlockErodeRate(position);
		local_8 = unkModulusNum + 1;
		local_4 = 0;
		globs::erodeGlobs.activeTimers[erodeIndex] = (float)(fVar3 / (float10)local_8);
		globs::erodeGlobs.activeStates[erodeIndex] = TRUE;
		Erode_Block_FUN_0040ed80(position,TRUE);
	}
	return;
}



void __cdecl lego::game::Erode_Update(float elapsedGame)
{
	float fVar1;
	LevelData *level;
	char cVar2;
	short sVar3;
	BOOL BVar4;
	int iVar5;
	float *pfVar6;
	uint uVar7;
	Point2I *blockPos;
	float10 fVar8;
	longlong lVar9;
	longlong lVar10;
	MiscEffectType miscEffectType;
	int local_24;
	Point2I local_20;
	Vector3F local_18;
	Vector3F local_c;
	
	level = globs::gameGlobs.level;
	sVar3 = math::Maths_Rand();
	globs::erodeGlobs.elapsedTimer = elapsedGame + globs::erodeGlobs.elapsedTimer;
										// if (globals::g_ErodeTimer > globals:g_ErodeTriggerTime) {
	if ((ushort)((ushort)(globs::erodeGlobs.elapsedTimer < globs::erodeGlobs.ErodeTriggerTime) << 8 |
							(ushort)(globs::erodeGlobs.elapsedTimer == globs::erodeGlobs.ErodeTriggerTime) << 0xe)
			== 0) {
		BVar4 = Erode_GetFreeActiveIndex(&local_24);
		if ((BVar4 != 0) && (uVar7 = 0, globs::erodeGlobs.UnkBlocksCount != 0)) {
			do {
				BVar4 = Erode_FUN_0040ef30(globs::erodeGlobs.UnkBlocksList +
																	 ((int)sVar3 + uVar7) % globs::erodeGlobs.UnkBlocksCount,&local_20
																	);
				if (BVar4 != 0) {
					BVar4 = Level_Block_IsPowerPath(&local_20);
					if ((BVar4 == 0) ||
						 ((*(byte *)&level->blocks[local_20.y * (level->dimensions).width + local_20.x].flags2 &
							0x10) != 0)) {
						iVar5 = local_20.y * (level->dimensions).width + local_20.x;
						level->blocks[iVar5].flags2 = level->blocks[iVar5].flags2 & ~BLOCK2_UNK_10;
						globs::erodeGlobs.activeBlocks[local_24].x = local_20.x;
						globs::erodeGlobs.activeBlocks[local_24].y = local_20.y;
						fVar8 = Erode_GetBlockErodeRate(globs::erodeGlobs.activeBlocks + local_24);
						globs::erodeGlobs.activeTimers[local_24] = (float)fVar8;
						globs::erodeGlobs.activeStates[local_24] = 1;
						level->blocks[local_20.y * (level->dimensions).width + local_20.x].field_7 = 0;
						Erode_Block_FUN_0040ed80(&local_20,TRUE);
						front::Info_FUN_00419ab0(INFO_LAVAERODE,NULL,NULL,&local_20);
						break;
					}
					Erode_AddLockedBlock(&local_20);
					iVar5 = local_20.y * (level->dimensions).width + local_20.x;
					level->blocks[iVar5].flags2 = level->blocks[iVar5].flags2 | BLOCK2_UNK_10;
				}
				uVar7 += 1;
			} while (uVar7 < globs::erodeGlobs.UnkBlocksCount);
		}
		globs::erodeGlobs.elapsedTimer = 0.0;
	}
	pfVar6 = globs::erodeGlobs.activeTimers;
	blockPos = globs::erodeGlobs.activeBlocks;
	do {
		if (pfVar6[-2000] != 0.0) {
			fVar8 = Erode_GetBlockErodeRate(blockPos);
			lVar9 = __ftol(((float10)*pfVar6 / fVar8) * (float10)4.0);
			*pfVar6 = *pfVar6 - elapsedGame;
			fVar8 = Erode_GetBlockErodeRate(blockPos);
			lVar10 = __ftol(((float10)*pfVar6 / fVar8) * (float10)4.0);
			cVar2 = (char)lVar10;
			if (cVar2 == (char)lVar9) goto LAB_0040ecc3;
			level->blocks[blockPos->y * (level->dimensions).width + blockPos->x].field_7 = 4 - cVar2;
			Map3D_BlockToWorldPos
								(level->surfaceMap,blockPos->x,blockPos->y,(float *)&local_18,&local_18.y);
			fVar8 = Map3D_GetWorldZ(level->surfaceMap,local_18.x,local_18.y);
			local_18.z = (float)fVar8;
			math::Maths_Vector3DRandom(&local_c);
			local_c.z = 0.0;
			switch(cVar2) {
			case '\0':
				pfVar6[-2000] = 0.0;
				level->blocks[blockPos->y * (level->dimensions).width + blockPos->x].terrain = TERRAIN_LAVA;
				miscEffectType = MISCOBJECT_LAVAEROSIONSMOKE1;
				break;
			case '\x01':
				miscEffectType = MISCOBJECT_LAVAEROSIONSMOKE2;
				break;
			case '\x02':
				miscEffectType = MISCOBJECT_LAVAEROSIONSMOKE3;
				break;
			case '\x03':
				miscEffectType = MISCOBJECT_LAVAEROSIONSMOKE4;
				break;
			default:
				goto switchD_0040ec49_caseD_4;
			}
			lego::effect::Effect_Spawn_Particle(miscEffectType,&local_18,&local_c);
switchD_0040ec49_caseD_4:
			Level_UpdateBlockSurfaceUnk(level,blockPos->x,blockPos->y,0);
		}
LAB_0040ecc3:
		blockPos = blockPos + 1;
		pfVar6 = pfVar6 + 1;
		if ((Point2I *)globs::erodeGlobs.activeStates <= blockPos) {
			pfVar6 = (float *)globs::erodeGlobs.lockedStates;
			do {
				if ((*pfVar6 != 0.0) &&
					 (fVar1 = pfVar6[-1000], pfVar6[-1000] = fVar1 - elapsedGame, fVar1 - elapsedGame < 0.0))
				{
					*pfVar6 = 0.0;
				}
				pfVar6 = pfVar6 + 1;
			} while (pfVar6 < &globs::erodeGlobs.elapsedTimer);
			return;
		}
	} while( true );
}



void __cdecl lego::game::Erode_AddLockedBlock(Point2I *blockPos)
{
	BOOL *pLockState;
	int iVar1;
	
	iVar1 = 0;
	pLockState = globs::erodeGlobs.lockedStates;
	do {
		if (*pLockState == FALSE) {
			globs::erodeGlobs.lockedBlocks[iVar1].x = blockPos->x;
			globs::erodeGlobs.lockedBlocks[iVar1].y = blockPos->y;
			globs::erodeGlobs.lockedTimers[iVar1] = globs::erodeGlobs.ErodeLockTime;
			globs::erodeGlobs.lockedStates[iVar1] = 1;
			return;
		}
		pLockState = pLockState + 1;
		iVar1 += 1;
	} while (pLockState < &globs::erodeGlobs.elapsedTimer);
	return;
}



void __cdecl lego::game::Erode_Block_FUN_0040ed80(Point2I *blockPos,BOOL doState2_else_add3)
{
	uint uVar1;
	int iVar2;
	uint uVar3;
	Point2I *pBlock;
	Erode_Globs *pEVar4;
	LevelData *level;
	
	level = globs::gameGlobs.level;
	uVar1 = globs::erodeGlobs.UnkBlocksCount;
	if (doState2_else_add3 == 0) {
		uVar3 = 0;
		if (globs::erodeGlobs.UnkBlocksCount != 0) {
			pEVar4 = &globs::erodeGlobs;
			do {
				if ((blockPos->x == pEVar4->UnkBlocksList[0].x) &&
					 (blockPos->y == pEVar4->UnkBlocksList[0].y)) {
					iVar2 = globs::erodeGlobs.UnkBlocksCount - 1;
					globs::erodeGlobs.UnkBlocksCount = globs::erodeGlobs.UnkBlocksCount - 1;
					globs::erodeGlobs.UnkBlocksList[uVar3].x = globs::erodeGlobs.UnkBlocksList[iVar2].x;
					globs::erodeGlobs.UnkBlocksList[uVar3].y = globs::erodeGlobs.UnkBlocksList[uVar1 - 1].y;
					iVar2 = (level->dimensions).width * blockPos->y + blockPos->x;
					level->blocks[iVar2].flags1 = level->blocks[iVar2].flags1 & ~BLOCK1_UNK_80000000;
					break;
				}
				uVar3 += 1;
				pEVar4 = (Erode_Globs *)(pEVar4->UnkBlocksList + 1);
			} while (uVar3 < globs::erodeGlobs.UnkBlocksCount);
		}
		iVar2 = 0;
		pBlock = globs::erodeGlobs.activeBlocks;
		do {
			if ((blockPos->x == pBlock->x) && (blockPos->y == pBlock->y)) {
				globs::erodeGlobs.activeStates[iVar2] = 0;
				break;
			}
			pBlock = pBlock + 1;
			iVar2 += 1;
		} while (pBlock <= (Point2I *)((int)&globs::erodeGlobs.activeBlocks[1999].y + 3U));
		Erode_AddLockedBlock(blockPos);
	}
	else {
		if ((((globs::gameGlobs.level)->blocks
					[((globs::gameGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags1 &
				 BLOCK1_UNK_80000000) == BLOCK1_NONE) && (globs::erodeGlobs.UnkBlocksCount < 2000)) {
			globs::erodeGlobs.UnkBlocksList[globs::erodeGlobs.UnkBlocksCount].x = blockPos->x;
			globs::erodeGlobs.UnkBlocksList[globs::erodeGlobs.UnkBlocksCount].y = blockPos->y;
			globs::erodeGlobs.UnkBlocksCount += 1;
			Level_Block_Proc_FUN_004301e0(blockPos);
			iVar2 = (level->dimensions).width * blockPos->y + blockPos->x;
			level->blocks[iVar2].flags1 = level->blocks[iVar2].flags1 | BLOCK1_UNK_80000000;
			return;
		}
	}
	return;
}



BOOL __cdecl lego::game::Erode_IsBlockLocked(Point2I *blockPos)
{
	BOOL *pLockState;
	Point2I *pLockBlock;
	
	pLockBlock = globs::erodeGlobs.lockedBlocks;
	pLockState = globs::erodeGlobs.lockedStates;
	while (((*pLockState == FALSE || (blockPos->x != pLockBlock->x)) || (blockPos->y != pLockBlock->y)
				 )) {
		pLockState = pLockState + 1;
		pLockBlock = pLockBlock + 1;
		if ((BOOL *)((int)globs::erodeGlobs.lockedStates + 3999U) < pLockState) {
			return 0;
		}
	}
	return TRUE;
}



BOOL __cdecl lego::game::Erode_FUN_0040ef30(Point2I *blockPos,Point2I *out_blockPos)
{
	LevelBlock *pLVar1;
	LevelBlockFlags1 LVar2;
	LevelData *pLVar3;
	Point2I *pPVar4;
	BOOL BVar5;
	int iVar6;
	int *piVar7;
	Point2I DIRECTIONS [4];
	
	pPVar4 = blockPos;
	pLVar3 = globs::gameGlobs.level;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[2].y = 1;
	DIRECTIONS[0].y = -1;
	DIRECTIONS[3].x = -1;
	DIRECTIONS[0].x = 0;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[3].y = 0;
	if ((globs::gameGlobs.level)->blocks
			[blockPos->y * ((globs::gameGlobs.level)->dimensions).width + blockPos->x].terrain !=
			TERRAIN_LAVA) {
		return 0;
	}
	blockPos = NULL;
	piVar7 = &DIRECTIONS[0].y;
	do {
		iVar6 = *piVar7;
		out_blockPos->x = piVar7[-1] + pPVar4->x;
		iVar6 = pPVar4->y + iVar6;
		out_blockPos->y = iVar6;
		pLVar1 = pLVar3->blocks + (pLVar3->dimensions).width * iVar6 + out_blockPos->x;
		LVar2 = pLVar1->flags1;
		if ((((LVar2 & BLOCK1_UNK_80000000) == BLOCK1_NONE) && ((LVar2 & BLOCK1_UNK_8) != BLOCK1_NONE))
			 && (pLVar1->erodeSpeed != ERODE_NONE)) {
			BVar5 = Erode_IsBlockLocked(out_blockPos);
			if (BVar5 == 0) {
				return TRUE;
			}
		}
		piVar7 = piVar7 + 2;
		blockPos = (Point2I *)((int)&blockPos->x + 1);
	} while (blockPos < (Point2I *)&DAT_00000004);
	return 0;
}



uint __cdecl lego::game::Fallin_Update(float elapsedGame)
{
	short rng;
	SurfaceMap *surfMap;
	BOOL BVar1;
	uint uVar2;
	uint uVar3;
	Point2I blockPos;
	
	surfMap = GetSurfaceMap();
	globs::s_Fallin_ElapsedTimer = globs::s_Fallin_ElapsedTimer - elapsedGame;
	uVar3 = (uint)(ushort)((ushort)(globs::s_Fallin_ElapsedTimer < 0.0) << 8 |
												(ushort)(globs::s_Fallin_ElapsedTimer == 0.0) << 0xe);
	uVar2 = (uint)surfMap & 0xffff0000 | uVar3;
										// if (floatVal <= 0.0f)
	if (uVar3 != 0) {
		uVar3 = 0;
		do {
			rng = math::Maths_Rand();
			blockPos.x = (uint)(int)rng % (uint)(surfMap->smallDimensions).width;
			rng = math::Maths_Rand();
			blockPos.y = (uint)(int)rng % (uint)(surfMap->smallDimensions).height;
			BVar1 = Fallin_Block_FUN_0040f0c0(&blockPos,TRUE);
			if (BVar1 != 0) {
				front::Info_FUN_00419ab0(INFO_LANDSLIDE,NULL,NULL,&blockPos);
				break;
			}
			uVar3 += 1;
		} while (uVar3 < 100);
		rng = math::Maths_Rand();
										// div by 50 (0x32)
		uVar2 = (int)rng / 0x32;
		globs::s_Fallin_ElapsedTimer = (float)((int)rng % 0x32) - -750.0;
	}
	return uVar2;
}



BOOL __cdecl lego::game::Fallin_Block_FUN_0040f0c0(Point2I *blockPos,BOOL param_2)
{
	bool bVar1;
	BOOL BVar2;
	uint unkIntensity;
	int *piVar3;
	uint i;
	int local_30;
	Point2I blockAnglePos;
	Point2I DIRECTIONS [4];
	
	i = 0;
	bVar1 = true;
	unkIntensity = 0;
	local_30 = 0;
	GetSurfaceMap();
	DIRECTIONS[0].x = 0;
	DIRECTIONS[0].y = -1;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[2].y = 1;
	DIRECTIONS[3].x = -1;
	DIRECTIONS[3].y = 0;
	BVar2 = Fallin_Block_UpdateFallinsUnk1(blockPos);
	if (BVar2 != 0) {
		piVar3 = &DIRECTIONS[0].y;
		do {
			blockAnglePos.x = piVar3[-1] + blockPos->x;
			blockAnglePos.y = *piVar3 + blockPos->y;
			BVar2 = Level_GetBlockFlags1_10Not8(blockAnglePos.x,blockAnglePos.y);
			if (BVar2 != 0) {
				BVar2 = Level_Block_IsImmovable(&blockAnglePos);
				if (BVar2 == 0) {
					BVar2 = Level_Block_IsReinforced(blockAnglePos.x,blockAnglePos.y);
					if (BVar2 != 0) goto LAB_0040f164;
				}
				else {
LAB_0040f164:
					bVar1 = false;
				}
				unkIntensity |= 1 << ((byte)i & 0x1f);
				BVar2 = Level_Block_IsFlags1_c0(blockAnglePos.x,blockAnglePos.y);
				if (BVar2 == 0) {
					local_30 += 1;
				}
			}
			i += 1;
			piVar3 = piVar3 + 2;
		} while (i < 4);
		if (((bVar1) && (unkIntensity != 0)) && (local_30 != 0)) {
			Fallin_Block_FUN_0040f260(blockPos,unkIntensity,param_2);
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Fallin_Block_UpdateFallinsUnk1(Point2I *blockPos)
{
	TerrainType TVar1;
	BOOL BVar2;
	uint uVar3;
	LevelData *level;
	
	level = globs::gameGlobs.level;
	BVar2 = Level_BlockIsFlags1_8(blockPos->x,blockPos->y);
	if ((((BVar2 != 0) && (uVar3 = Level_GetBlockFlags1_8000000(blockPos), uVar3 == 0)) &&
			(TVar1 = level->blocks[(level->dimensions).width * blockPos->y + blockPos->x].terrain,
			TVar1 != TERRAIN_LAVA)) && ((TVar1 != TERRAIN_LAKE && (TVar1 != TERRAIN_WATER_unused)))) {
		if ((level->SafeCaverns != BOOL3_FALSE) && (BVar2 = Level_Block_IsExposed(blockPos), BVar2 != 0)
			 ) {
			return 0;
		}
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::Fallin_Block_FUN_0040f260(Point2I *blockPos,int unkIntensity,BOOL param_3)
{
	int iVar1;
	Point2I *pPVar2;
	BOOL BVar3;
	Point2I *pPVar4;
	float10 fVar5;
	float dirX;
	float dirY;
	float local_30;
	Vector3F local_2c;
	Point2F DIRECTIONS_F [4];
	Point2I *blockPos_00;
	
	blockPos_00 = blockPos;
	DIRECTIONS_F[0].x = 0.0;
	DIRECTIONS_F[0].y = 1.0;
	DIRECTIONS_F[1].x = 1.0;
	DIRECTIONS_F[1].y = 0.0;
	DIRECTIONS_F[2].x = 0.0;
	DIRECTIONS_F[2].y = -1.0;
	DIRECTIONS_F[3].x = -1.0;
	DIRECTIONS_F[3].y = 0.0;
	iVar1 = Level_BlockProc_FUN_00432bc0(blockPos);
	while (iVar1 == 0) {
		iVar1 = Level_BlockProc_FUN_00432bc0(blockPos_00);
	}
	ai::AITask_DoClearTypeAction(blockPos_00,MESSAGE_CLEARFALLIN_COMPLETE);
	pPVar2 = blockPos;
	pPVar4 = blockPos;
	switch(unkIntensity) {
	case 1:
	case 0xe:
		pPVar2 = NULL;
		pPVar4 = NULL;
		break;
	case 2:
	case 10:
	case 0xd:
		pPVar2 = (Point2I *)0x1;
		pPVar4 = NULL;
		break;
	case 3:
		pPVar2 = (Point2I *)0x1;
		pPVar4 = (Point2I *)0x1;
		break;
	case 4:
	case 5:
	case 0xb:
		pPVar2 = (Point2I *)0x2;
		pPVar4 = NULL;
		break;
	case 6:
		pPVar2 = (Point2I *)0x2;
		pPVar4 = (Point2I *)0x1;
		break;
	case 7:
	case 8:
		pPVar2 = (Point2I *)0x3;
		pPVar4 = NULL;
		break;
	case 9:
		pPVar2 = NULL;
		pPVar4 = (Point2I *)0x1;
		break;
	case 0xc:
		pPVar2 = (Point2I *)0x3;
		pPVar4 = (Point2I *)0x1;
	}
	Map3D_BlockToWorldPos
						((globs::gameGlobs.level)->surfaceMap,blockPos_00->x,blockPos_00->y,&local_30,
						 (float *)&blockPos);
	dirY = DIRECTIONS_F[(int)pPVar2].y;
	dirX = DIRECTIONS_F[(int)pPVar2].x;
	fVar5 = Map3D_GetWorldZ((globs::gameGlobs.level)->surfaceMap,local_30,(float)blockPos);
	BVar3 = lego::effect::Effect_Spawn_RockFall
										((int)pPVar4,blockPos_00->x,blockPos_00->y,local_30,blockPos,(float)fVar5,dirX,
										 dirY);
	if (BVar3 != 0) {
		local_2c.y = (float)blockPos;
		local_2c.x = local_30;
		fVar5 = Map3D_GetWorldZ((globs::gameGlobs.level)->surfaceMap,local_30,(float)blockPos);
		local_2c.z = (float)fVar5;
		iVar1 = ((globs::gameGlobs.level)->dimensions).width * blockPos_00->y + blockPos_00->x;
		(globs::gameGlobs.level)->blocks[iVar1].flags1 =
				 (globs::gameGlobs.level)->blocks[iVar1].flags1 | BLOCK1_UNK_800;
		iVar1 = ((globs::gameGlobs.level)->dimensions).width * blockPos_00->y + blockPos_00->x;
		(globs::gameGlobs.level)->blocks[iVar1].flags1 =
				 (globs::gameGlobs.level)->blocks[iVar1].flags1 | BLOCK1_UNK_1000;
		Level_Block_SetFlags1_8000000(blockPos_00,TRUE);
		res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(NULL,SFX_FALLIN,FALSE,FALSE,&local_2c);
	}
	if ((param_3 != 0) &&
		 (iVar1 = ((globs::gameGlobs.level)->dimensions).width * blockPos_00->y + blockPos_00->x,
		 (globs::gameGlobs.level)->blocks[iVar1].numLandSlides =
					(globs::gameGlobs.level)->blocks[iVar1].numLandSlides + 1,
		 globs::fallinGlobs_NumberOfLandSlidesTillCaveIn <=
		 (globs::gameGlobs.level)->blocks
		 [((globs::gameGlobs.level)->dimensions).width * blockPos_00->y + blockPos_00->x].numLandSlides)
		 ) {
		Fallin_LandSlideDoCaveIn(blockPos_00,unkIntensity);
		front::Info_FUN_00419ab0(INFO_LANDSLIDE,NULL,NULL,blockPos_00);
	}
	Level_UpdateBlockSurfaceUnk(globs::gameGlobs.level,blockPos_00->x,blockPos_00->y,0);
	return;
}



void __cdecl lego::game::Fallin_SetNumberOfLandSlidesTillCaveIn(int numLandSlidesTillCaveIn)
{
	globs::fallinGlobs_NumberOfLandSlidesTillCaveIn = numLandSlidesTillCaveIn;
	return;
}



void __cdecl lego::game::Fallin_LandSlideDoCaveIn(Point2I *blockPos,int unkIntensity)
{
	BOOL BVar1;
	int i;
	int *piVar2;
	Point2I pAngle;
	Point2I ANGLES [8];
	
	ANGLES[0].x = 0;
	ANGLES[0].y = 1;
	ANGLES[1].x = 1;
	ANGLES[1].y = 1;
	ANGLES[2].x = 1;
	ANGLES[2].y = 0;
	ANGLES[3].x = 1;
	ANGLES[3].y = -1;
	ANGLES[4].x = 0;
	ANGLES[4].y = -1;
	ANGLES[5].x = -1;
	ANGLES[5].y = -1;
	ANGLES[6].x = -1;
	ANGLES[6].y = 0;
	ANGLES[7].x = -1;
	ANGLES[7].y = 1;
	piVar2 = &ANGLES[0].y;
	i = 8;
	do {
		pAngle.x = piVar2[-1] + blockPos->x;
		pAngle.y = blockPos->y + *piVar2;
		BVar1 = Map3D_IsInsideDimensions((globs::gameGlobs.level)->surfaceMap,pAngle.x,pAngle.y);
		if (BVar1 != 0) {
			BVar1 = Fallin_Block_FUN_0040f0c0(&pAngle,0);
			if (BVar1 == 0) {
				BVar1 = Fallin_Block_UpdateFallinsUnk1(&pAngle);
				if (BVar1 != 0) {
					Fallin_Block_FUN_0040f260(&pAngle,unkIntensity,0);
				}
			}
		}
		piVar2 = piVar2 + 2;
		i += -1;
	} while (i != 0);
	return;
}



FlockSubdata * __cdecl
lego::game::Flocks_LiveObject_Flocks_CreateSubdata
					(Vector3F *vector_1,Vector3F *vector_2,float turn,float speed,float tightness,
					float goalUpdate,Container *resData)
{
	FlockSubdata *pFVar1;
	
	pFVar1 = (FlockSubdata *)std::malloc(0xa0);
	if (pFVar1 == NULL) {
		return NULL;
	}
	pFVar1->float_30 = 0.0;
	pFVar1->rotationZ_2c = 0.0;
	pFVar1->rotationX_28 = 0.0;
	pFVar1->rotationY_24 = 0.0;
	(pFVar1->vector_18).y = 0.0;
	(pFVar1->vector_18).x = 0.0;
	(pFVar1->vector_18).z = 1.0;
	if (vector_2 == NULL) {
		(pFVar1->vector_0).x = 0.0;
		(pFVar1->vector_0).y = 0.0;
		(pFVar1->vector_0).z = 0.0;
	}
	else {
		(pFVar1->vector_0).x = vector_2->x;
		(pFVar1->vector_0).y = vector_2->y;
		(pFVar1->vector_0).z = vector_2->z;
	}
	if (vector_1 == NULL) {
		(pFVar1->vector_c).x = 0.0;
		(pFVar1->vector_c).y = 0.0;
		(pFVar1->vector_c).z = 0.0;
	}
	else {
		(pFVar1->vector_c).x = vector_1->x;
		(pFVar1->vector_c).y = vector_1->y;
		(pFVar1->vector_c).z = vector_1->z;
	}
	pFVar1->float_34 = 0.0;
	pFVar1->Turn2 = turn;
	pFVar1->Turn1 = turn;
	pFVar1->Speed2 = speed;
	pFVar1->Speed1 = speed;
	pFVar1->Tightness2 = tightness;
	pFVar1->Tightness1 = tightness;
	pFVar1->GoalUpdate2 = goalUpdate;
	pFVar1->GoalUpdate1 = goalUpdate;
	pFVar1->resData_98 = resData;
	return pFVar1;
}



// Shared function used by multiple modules.

void __cdecl lego::util::freeNonNull(void *ptr)
{
	if (ptr != NULL) {
		std::free(ptr);
	}
	return;
}



FlockData * __cdecl
lego::game::Flocks_LiveObject_Flocks_CreateData
					(Vector3F *vector_1,Vector3F *vector_2,float turn,float speed,float tightness,
					Container *resData)
{
	FlockData *pFVar1;
	FlockSubdata *pFVar2;
	
	pFVar1 = (FlockData *)std::malloc(0x28);
	if (pFVar1 == NULL) {
		return NULL;
	}
	pFVar2 = Flocks_LiveObject_Flocks_CreateSubdata
										 (vector_1,vector_2,turn,speed,tightness,0.0,resData);
	pFVar1->flocksSubdata1 = pFVar2;
	if (vector_1 == NULL) {
		pFVar1->hasVector1 = 0;
	}
	else {
		pFVar1->hasVector1 = 1;
	}
	if (vector_2 != NULL) {
		pFVar1->hasVector2 = 1;
		pFVar1->flocksSubdata2 = NULL;
		pFVar1->numSubdata = 0;
		return pFVar1;
	}
	pFVar1->hasVector2 = 0;
	pFVar1->flocksSubdata2 = NULL;
	pFVar1->numSubdata = 0;
	return pFVar1;
}



void __cdecl lego::game::Flocks_FreeData(FlockData *flocksData)
{
	FlockSubdata *ptr;
	
	ptr = Flocks_Free_SubdataRecurse(flocksData);
	while (ptr != NULL) {
		util::freeNonNull(ptr);
		ptr = Flocks_Free_SubdataRecurse(flocksData);
	}
	util::freeNonNull(flocksData->flocksSubdata1);
	std::free(flocksData);
	return;
}



void __cdecl
lego::game::Flocks_Subdata_MathChangeRotationX(FlockSubdata *flockSubdata,Vector3F *vector)
{
	float fVar1;
	
	if ((ushort)((ushort)(vector->y < 1.0) << 8 | (ushort)(vector->y == 1.0) << 0xe) == 0) {
		fVar1 = flockSubdata->Turn1 + flockSubdata->rotationX_28;
		flockSubdata->rotationX_28 = fVar1;
		if ((ushort)((ushort)(fVar1 < 0.8) << 8 | (ushort)(fVar1 == 0.8) << 0xe) == 0) {
			flockSubdata->rotationX_28 = 0.8;
			return;
		}
	}
	else {
		if (-1.0 <= vector->y) {
			flockSubdata->rotationX_28 = flockSubdata->rotationX_28 * 0.95;
			return;
		}
		fVar1 = flockSubdata->rotationX_28 - flockSubdata->Turn1;
		flockSubdata->rotationX_28 = fVar1;
		if (fVar1 < -0.8) {
			flockSubdata->rotationX_28 = -0.8;
			return;
		}
	}
	return;
}



void __cdecl
lego::game::Flocks_Subdata_MathChangeRotationsYZ(FlockSubdata *subdata,Vector3F *ref_vector)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	float fVar9;
	float fVar10;
	
	ref_vector->y = 0.0;
	(subdata->vector_18).y = 0.0;
	fVar1 = (subdata->vector_18).x;
	fVar7 = (subdata->vector_18).z;
	fVar1 = 1.0 / SQRT(fVar1 * fVar1 + fVar7 * fVar7 + 0.0);
	(subdata->vector_18).x = fVar1 * (subdata->vector_18).x;
	(subdata->vector_18).y = fVar1 * (subdata->vector_18).y;
	(subdata->vector_18).z = fVar1 * (subdata->vector_18).z;
	fVar8 = 1.0 / SQRT(ref_vector->x * ref_vector->x +
										 ref_vector->z * ref_vector->z + ref_vector->y * ref_vector->y);
	fVar10 = fVar8 * ref_vector->x;
	fVar9 = fVar8 * ref_vector->y;
	fVar8 = fVar8 * ref_vector->z;
	ref_vector->x = fVar10;
	ref_vector->y = fVar9;
	ref_vector->z = fVar8;
	fVar1 = (subdata->vector_18).z;
	fVar7 = (subdata->vector_18).y;
	fVar2 = (subdata->vector_18).x;
	fVar3 = (subdata->vector_18).x;
	fVar4 = (subdata->vector_18).x;
	fVar5 = (subdata->vector_18).z;
	fVar6 = (subdata->vector_18).y;
	ref_vector->x = fVar9 * (subdata->vector_18).z - fVar8 * (subdata->vector_18).y;
	ref_vector->y = fVar3 * fVar8 - fVar10 * fVar5;
	ref_vector->z = fVar10 * fVar6 - fVar4 * fVar9;
	fVar1 = (1.0 - (fVar2 * fVar10 + fVar1 * fVar8 + fVar7 * fVar9)) * subdata->Turn1 * 10.0 * 0.5;
	if ((ushort)((ushort)(ref_vector->y < 0.01) << 8 | (ushort)(ref_vector->y == 0.01) << 0xe) == 0) {
		fVar1 = subdata->float_30 * 9.0 + fVar1;
	}
	else {
		if (0.01 <= ref_vector->y) goto LAB_0040fa04;
		fVar1 = subdata->float_30 * 9.0 - fVar1;
	}
	subdata->float_30 = fVar1 * 0.1;
LAB_0040fa04:
	subdata->rotationY_24 = subdata->rotationY_24 + subdata->float_30;
	subdata->rotationZ_2c = -(subdata->float_30 * 9.0);
	return;
}



void __cdecl lego::game::Flocks_Subdata_Matrix_MultRotXYZ(FlockSubdata *subdata)
{
	Matrix4F matRotY;
	Matrix4F matRotZ;
	Matrix4F matRotX;
	Matrix4F matMultiply;
	
	math::Matrix_RotX(&matRotX,subdata->rotationX_28);
	math::Matrix_RotY(&matRotY,subdata->rotationY_24);
	math::Matrix_RotZ(&matRotZ,subdata->rotationZ_2c);
	math::Matrix_Mult(&matMultiply,&matRotY,&matRotX);
	math::Matrix_Mult(&subdata->matrix,&matMultiply,&matRotZ);
	return;
}



void __cdecl
lego::game::Flocks_Callback_SubdataMoveAndTurn
					(FlockData *unused_flocksData,FlockSubdata *subdata,float *pElapsed)
{
	Vector3F *trans;
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	Vector3F vector_b;
	Vector3F vector_a;
	Matrix4F matrix_b;
	Matrix4F matrix_a;
	
	vector_b.x = (subdata->vector_0).x - (subdata->vector_c).x;
	vector_b.y = (subdata->vector_0).y - (subdata->vector_c).y;
	trans = &subdata->vector_c;
	fVar2 = *pElapsed;
	vector_b.z = (subdata->vector_0).z - (subdata->vector_c).z;
	if (SQRT(vector_b.z * vector_b.z + vector_b.y * vector_b.y + vector_b.x * vector_b.x) < 1e-05) {
		math::Maths_Vector3DRandom(&vector_b);
	}
	Flocks_Subdata_MathChangeRotationX(subdata,&vector_b);
	Flocks_Subdata_MathChangeRotationsYZ(subdata,&vector_b);
	Flocks_Subdata_Matrix_MultRotXYZ(subdata);
	fVar1 = subdata->Speed1;
	fVar3 = (subdata->matrix).values[2][1];
	fVar4 = (subdata->matrix).values[2][2];
	(subdata->vector_18).x = (subdata->matrix).values[2][0];
	fVar1 = fVar1 * fVar2;
	(subdata->vector_18).y = fVar3;
	(subdata->vector_18).z = fVar4;
	fVar2 = (subdata->vector_18).y;
	fVar3 = (subdata->vector_18).z;
	trans->x = (subdata->vector_18).x * fVar1 + trans->x;
	(subdata->vector_c).y = (subdata->vector_c).y + fVar2 * fVar1;
	(subdata->vector_c).z = (subdata->vector_c).z + fVar3 * fVar1;
	math::Matrix_Translate(&matrix_a,trans);
	math::Matrix_Copy(&matrix_b,&subdata->matrix);
	math::Matrix_Mult(&subdata->matrix,&matrix_a,&matrix_b);
	return;
}



// out_vector = random_vector() * { x, y, z }

void __cdecl lego::math::MathX_Vector3DRandomMultiply(Vector3F *out_vector,float x,float y,float z)
{
	if (out_vector != NULL) {
		Maths_Vector3DRandom(out_vector);
		out_vector->x = x * out_vector->x;
		out_vector->y = y * out_vector->y;
		out_vector->z = z * out_vector->z;
	}
	return;
}



void __cdecl
lego::game::Flocks_Callback_SubdataMoveTightness
					(FlockData *flocksData,FlockSubdata *subData,float *pElapsed)
{
	float fVar1;
	FlockSubdata *pFVar2;
	float10 extraout_ST0;
	float10 fVar3;
	longlong lVar4;
	longlong lVar5;
	Vector3F direction;
	float tightness;
	
	fVar1 = subData->float_34;
	lVar4 = __ftol((float10)subData->float_34 / (float10)subData->GoalUpdate1);
	fVar3 = extraout_ST0;
	if (extraout_ST0 == (float10)0.0) {
		fVar3 = (float10)0.001;
	}
	fVar1 = (float)((float10)1.0 / fVar3 + (float10)fVar1);
	lVar5 = __ftol((float10)fVar1 / (float10)subData->GoalUpdate1);
	if ((int)lVar5 != (int)lVar4 && -1 < (int)lVar5 - (int)lVar4) {
		tightness = subData->Tightness1;
		math::MathX_Vector3DRandomMultiply(&direction,tightness,tightness,tightness);
		pFVar2 = flocksData->flocksSubdata1;
		(subData->vector_0).x = (pFVar2->vector_c).x + direction.x;
		(subData->vector_0).y = (pFVar2->vector_c).y + direction.y;
		(subData->vector_0).z = (pFVar2->vector_c).z + direction.z;
	}
	subData->float_34 = fVar1;
	return;
}



void __cdecl lego::game::Flocks_SetVector2(FlockData *flocksData,Vector3F *vector2)
{
	FlockSubdata *pFVar1;
	
	pFVar1 = flocksData->flocksSubdata1;
	(pFVar1->vector_0).x = vector2->x;
	(pFVar1->vector_0).y = vector2->y;
	(pFVar1->vector_0).z = vector2->z;
	flocksData->hasVector2 = TRUE;
	return;
}



void __cdecl lego::game::Flocks_Subdata_MoveAndTurn(FlockSubdata *subdata,float elapsed)
{
	Flocks_Callback_SubdataMoveAndTurn(NULL,subdata,&elapsed);
	return;
}



void __cdecl lego::game::Flocks_Subdata_UpdateMove(FlockData *flocksData,float elapsed)
{
	Flocks_Subdata_MoveAndTurn(flocksData->flocksSubdata1,elapsed);
	Flocks_CallbackForAllSubdata(flocksData,Flocks_Callback_SubdataMoveAndTurn,&elapsed);
	Flocks_CallbackForAllSubdata(flocksData,Flocks_Callback_SubdataMoveTightness,&elapsed);
	return;
}



void __cdecl
lego::game::Flocks_LiveObject_Flocks_AddSubdata(FlockData *flockData,FlockSubdata *subdata)
{
	if ((flockData != NULL) && (subdata != NULL)) {
		subdata->subdataNext_9c = flockData->flocksSubdata2;
		flockData->flocksSubdata2 = subdata;
		flockData->numSubdata = flockData->numSubdata + 1;
	}
	return;
}



FlockSubdata * __cdecl lego::game::Flocks_Free_SubdataRecurse(FlockData *flocksData)
{
	FlockSubdata *pFVar1;
	FlockSubdata *pFVar2;
	
	if ((flocksData != NULL) && (flocksData->numSubdata != 0)) {
		pFVar1 = flocksData->flocksSubdata2;
		pFVar2 = pFVar1->subdataNext_9c;
		flocksData->numSubdata = flocksData->numSubdata - 1;
		flocksData->flocksSubdata2 = pFVar2;
		return pFVar1;
	}
	return NULL;
}



void __cdecl
lego::game::Flocks_CallbackForAllSubdata
					(FlockData *flockData,FlocksCallback *callback,void *context)
{
	FlockSubdata *subdata;
	
	for (subdata = flockData->flocksSubdata2; subdata != NULL; subdata = subdata->subdataNext_9c) {
		(*callback)(flockData,subdata,context);
	}
	return;
}



// Maths_RandRange(0.0f, 1.0f)

float10 __cdecl lego::math::MathX_RandRangeOne(void)
{
	float10 fVar1;
	
	fVar1 = Maths_RandRange(0.0,1.0);
	return fVar1;
}



void __cdecl
lego::game::Flocks_Callback_FUN_0040fe00(FlockData *flocksData,FlockSubdata *subdata,float *param_3)
{
	float fVar1;
	float fVar2;
	float10 fVar3;
	
	fVar2 = *param_3;
	fVar3 = math::MathX_RandRangeOne();
	fVar2 = 1.0 / fVar2;
	fVar1 = (float)((fVar3 + fVar3) - (float10)1.0);
	subdata->Turn1 = fVar2 * fVar1 * subdata->Turn2 + subdata->Turn2;
	subdata->Tightness1 = fVar2 * fVar1 * subdata->Tightness2 + subdata->Tightness2;
	subdata->GoalUpdate1 = fVar2 * fVar1 * subdata->GoalUpdate2 + subdata->GoalUpdate2;
	return;
}



void __cdecl lego::game::Flocks_FUN_0040fe80(FlockData *flocksData,float param_2)
{
	Flocks_CallbackForAllSubdata(flocksData,Flocks_Callback_FUN_0040fe00,&param_2);
	return;
}



void __cdecl
lego::game::Flocks_SetParameters1(FlockData *flocksData,float turn,float speed,float tightness)
{
	flocksData->flocksSubdata1->Turn1 = turn;
	flocksData->flocksSubdata1->Speed1 = speed;
	flocksData->flocksSubdata1->Tightness1 = tightness;
	return;
}



void __cdecl
lego::game::Flocks_Callback_SetSubdataParametersFromGlobals
					(FlockData *flocksData,FlockSubdata *subdata)
{
	subdata->Turn2 = globs::flocksGlobs.Turn;
	subdata->Turn1 = globs::flocksGlobs.Turn;
	subdata->Speed2 = globs::flocksGlobs.Speed;
	subdata->Speed1 = globs::flocksGlobs.Speed;
	subdata->Tightness2 = globs::flocksGlobs.Tightness;
	subdata->Tightness1 = globs::flocksGlobs.Tightness;
	subdata->GoalUpdate2 = globs::flocksGlobs.GoalUpdate;
	subdata->GoalUpdate1 = globs::flocksGlobs.GoalUpdate;
	return;
}



void __cdecl
lego::game::Flocks_SetGlobal_AndAllSubdataParameters
					(FlockData *flockData,float turn,float speed,float tightness,float goalUpdate)
{
	globs::flocksGlobs.Speed = speed;
	globs::flocksGlobs.Turn = turn;
	globs::flocksGlobs.Tightness = tightness;
	globs::flocksGlobs.GoalUpdate = goalUpdate;
	Flocks_CallbackForAllSubdata(flockData,Flocks_Callback_SetSubdataParametersFromGlobals,NULL);
	return;
}



void __cdecl lego::game::Flocks_SetVector1(FlockData *flocksData,Vector3F *vector1)
{
	FlockSubdata *pFVar1;
	
	if ((flocksData != NULL) && (vector1 != NULL)) {
		flocksData->hasVector1 = TRUE;
		pFVar1 = flocksData->flocksSubdata1;
		(pFVar1->vector_c).x = vector1->x;
		(pFVar1->vector_c).y = vector1->y;
		(pFVar1->vector_c).z = vector1->z;
	}
	return;
}



void __cdecl
lego::game::Flocks_Callback_SetSubdataVectorC
					(FlockData *flocksData,FlockSubdata *subdata,Vector3F *vector)
{
	(subdata->vector_c).x = vector->x;
	(subdata->vector_c).y = vector->y;
	(subdata->vector_c).z = vector->z;
	return;
}



void __cdecl lego::game::Flocks_SetAllSubdataVectorC(FlockData *flocksData,Vector3F *vector)
{
	Flocks_CallbackForAllSubdata(flocksData,Flocks_Callback_SetSubdataVectorC,vector);
	return;
}



void __cdecl
lego::game::Flocks_Callback_SetSubdataVector0
					(FlockData *flocksData,FlockSubdata *subdata,Vector3F *vector)
{
	(subdata->vector_0).x = vector->x;
	(subdata->vector_0).y = vector->y;
	(subdata->vector_0).z = vector->z;
	return;
}



void __cdecl lego::game::Flocks_SetAllSubdataVector0(FlockData *flocksData,Vector3F *vector)
{
	Flocks_CallbackForAllSubdata(flocksData,Flocks_Callback_SetSubdataVector0,vector);
	return;
}



void __cdecl
lego::game::Flocks_Callback_FUN_00410000
					(FlockData *flocksData,FlockSubdata *subdata,float *pElapsed)
{
	Vector3F *pVVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	float fVar9;
	float fVar10;
	float fVar11;
	float fVar12;
	
	fVar2 = *pElapsed;
	pVVar1 = &subdata->vector_c;
	fVar3 = (subdata->vector_0).x;
	fVar4 = pVVar1->x;
	fVar5 = (subdata->vector_0).y;
	fVar6 = (subdata->vector_c).y;
	fVar7 = (subdata->vector_c).z;
	fVar8 = (subdata->vector_0).z;
	Flocks_Callback_SubdataMoveAndTurn(flocksData,subdata,pElapsed);
	fVar11 = fVar3 - fVar4;
	fVar9 = fVar5 - fVar6;
	fVar12 = fVar8 - fVar7;
	fVar2 = subdata->Speed1 * fVar2;
	fVar10 = SQRT(fVar12 * fVar12 + fVar9 * fVar9 + fVar11 * fVar11);
	if (fVar2 <= fVar10) {
		fVar10 = 1.0 / fVar10;
		pVVar1->x = fVar10 * fVar11 * fVar2 + fVar4;
		(subdata->vector_c).y = fVar10 * fVar9 * fVar2 + fVar6;
		(subdata->vector_c).z = fVar10 * fVar12 * fVar2 + fVar7;
	}
	else {
		pVVar1->x = (subdata->vector_0).x;
		(subdata->vector_c).y = (subdata->vector_0).y;
		(subdata->vector_c).z = (subdata->vector_0).z;
	}
	(subdata->vector_0).x = fVar3;
	fVar2 = (subdata->vector_c).z;
	(subdata->matrix).values[3][0] = pVVar1->x;
	(subdata->matrix).values[3][2] = fVar2;
	(subdata->vector_0).y = fVar5;
	(subdata->vector_0).z = fVar8;
	(subdata->matrix).values[3][1] = (subdata->vector_c).y;
	return;
}



void __cdecl
lego::game::Flocks_Callback_CompareVecs_0_c
					(FlockData *flocksData,FlockSubdata *subdata,BOOL *pSuccess)
{
	if ((((subdata->vector_c).x == (subdata->vector_0).x) &&
			((subdata->vector_c).y == (subdata->vector_0).y)) &&
		 ((subdata->vector_c).z == (subdata->vector_0).z)) {
		res::Container_Hide(subdata->resData_98,TRUE);
		return;
	}
	*pSuccess = 0;
	return;
}



BOOL __cdecl lego::game::Flocks_CompareAllVecs_0_c(FlockData *flocksData)
{
	BOOL result;
	
	result = 1;
	Flocks_CallbackForAllSubdata(flocksData,Flocks_Callback_CompareVecs_0_c,&result);
	return result;
}



char * __cdecl lego::util::replaceTextSpaces(char *str)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	undefined4 *puVar4;
	char *pcVar5;
	undefined4 *puVar6;
	
	uVar2 = 0xffffffff;
	pcVar5 = str;
	do {
		if (uVar2 == 0) break;
		uVar2 -= 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	if (0xff < ~uVar2 - 1) {
		return str;
	}
	uVar2 = 0xffffffff;
	do {
		pcVar5 = str;
		if (uVar2 == 0) break;
		uVar2 -= 1;
		pcVar5 = str + 1;
		cVar1 = *str;
		str = pcVar5;
	} while (cVar1 != '\0');
	uVar2 = ~uVar2;
	puVar4 = (undefined4 *)(pcVar5 + -uVar2);
	puVar6 = (undefined4 *)CHAR_ARRAY_004dc748;
	for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
		*puVar6 = *puVar4;
		puVar4 = puVar4 + 1;
		puVar6 = puVar6 + 1;
	}
	uVar3 = 0;
	for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
		*(undefined *)puVar6 = *(undefined *)puVar4;
		puVar4 = (undefined4 *)((int)puVar4 + 1);
		puVar6 = (undefined4 *)((int)puVar6 + 1);
	}
	do {
		if (CHAR_ARRAY_004dc748[uVar3] == '_') {
			CHAR_ARRAY_004dc748[uVar3] = ' ';
		}
		uVar3 += 1;
	} while (uVar3 < 0x100);
	return CHAR_ARRAY_004dc748;
}



void __cdecl lego::front::Front_UnkPrintf_FUN_00410250(ImageFont *font,int x,int y,char *format,...)
{
	ImageFont **ppIVar1;
	uint i;
	char (*msg) [1024];
	
	if (format == NULL) {
		i = 0;
		if (COUNT_004dc8d0 != 0) {
			ppIVar1 = FONT_ARRAY_004d8b08;
			msg = CHAR_ARRAY_ARRAY_004d8b48;
			do {
				lego::image::Font_PrintF
									(*ppIVar1,POINT_X_ARRAY_004d88c8[i],POINT_Y_ARRAY_004dc850[i],(char *)msg);
				i += 1;
				msg = msg[1];
				ppIVar1 = ppIVar1 + 1;
			} while (i < COUNT_004dc8d0);
		}
		COUNT_004dc8d0 = 0;
		return;
	}
	if (COUNT_004dc8d0 < 0xf) {
		std::vsprintf((char *)CHAR_ARRAY_ARRAY_004d8b48[COUNT_004dc8d0],format,&stack0x00000014);
		POINT_X_ARRAY_004d88c8[COUNT_004dc8d0] = x;
		POINT_Y_ARRAY_004dc850[COUNT_004dc8d0] = y;
		FONT_ARRAY_004d8b08[COUNT_004dc8d0] = font;
		COUNT_004dc8d0 += 1;
	}
	return;
}



void __cdecl lego::front::MainMenuFull_TriggerShowCredits(void)
{
	Credits_Play(globs::gameGlobs.CreditsTextFile,globs::gameGlobs.bmpRSFont,
							 globs::gameGlobs.CreditsBackAVI);
	return;
}



void __cdecl lego::front::Front_PlayRockWipe_AndUnk(void)
{
	uint uVar1;
	
	if (globals::g_MenuWipeResource != NULL) {
		FLOAT_005584f4 = 0.0;
		FLAGS_005584f0 = FLAGS_005584f0 & 0xffffff00 | FLAGS_005584f0 & 0xff | 1 | 2;
		uVar1 = main::Main_GetTime();
		FLOAT_005584f8 = (float)(ulonglong)uVar1;
		snd::SFX_Sample_AddToQueue(SFX_ROCKWIPE,0);
	}
	return;
}



void __cdecl lego::unk::Lego_UnsetFlag3_005584f0(void)
{
	FLAGS_005584f0 = FLAGS_005584f0 & 0xfffffffc;
	return;
}



ImageCacheItem * __cdecl lego::image::ImageCache_FindByName(char *filename)
{
	int iVar1;
	ImageCacheItem *cache;
	
	cache = globals::g_ImageCache_NEXT;
	if (globals::g_ImageCache_NEXT == NULL) {
		return NULL;
	}
	do {
		iVar1 = std::_stricmp(filename,cache->filename);
		if (iVar1 == 0) {
			return cache;
		}
		cache = cache->next;
	} while (cache != NULL);
	return NULL;
}



ImageCacheItem * __cdecl lego::image::ImageCache_Get(char *filename)
{
	char cVar1;
	ImageCacheItem *cache;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	
	if ((filename == NULL) || (*filename == '\0')) {
		cache = NULL;
	}
	else {
		cache = ImageCache_FindByName(filename);
		if (cache == NULL) {
			cache = (ImageCacheItem *)std::malloc(0x10);
										// cache->filename = ::_strdup(filename);
			uVar3 = 0xffffffff;
			pcVar6 = filename;
			do {
				if (uVar3 == 0) break;
				uVar3 -= 1;
				cVar1 = *pcVar6;
				pcVar6 = pcVar6 + 1;
			} while (cVar1 != '\0');
			puVar2 = (undefined4 *)std::malloc(~uVar3);
			uVar3 = 0xffffffff;
			cache->filename = (char *)puVar2;
			do {
				pcVar6 = filename;
				if (uVar3 == 0) break;
				uVar3 -= 1;
				pcVar6 = filename + 1;
				cVar1 = *filename;
				filename = pcVar6;
			} while (cVar1 != '\0');
			uVar3 = ~uVar3;
			puVar5 = (undefined4 *)(pcVar6 + -uVar3);
			for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
				*puVar2 = *puVar5;
				puVar5 = puVar5 + 1;
				puVar2 = puVar2 + 1;
			}
			for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
				*(undefined *)puVar2 = *(undefined *)puVar5;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
				puVar2 = (undefined4 *)((int)puVar2 + 1);
			}
			cache->image = NULL;
			cache->next = globals::g_ImageCache_NEXT;
			cache->font = NULL;
			globals::g_ImageCache_NEXT = cache;
			return cache;
		}
	}
	return cache;
}



ImageBMP * __cdecl lego::image::ImageCache_LoadImage(char *filename)
{
	ImageCacheItem *cache;
	ImageBMP *image;
	
	if ((filename != NULL) && (*filename != '\0')) {
		cache = ImageCache_Get(filename);
		if (cache->image == NULL) {
			image = Image_LoadBMPScaled(filename,0,0);
			cache->image = image;
		}
		return cache->image;
	}
	return NULL;
}



ImageFont * __cdecl lego::image::ImageCache_LoadFont(char *filename)
{
	ImageCacheItem *cache;
	ImageFont *font;
	
	if ((filename != NULL) && (*filename != '\0')) {
		cache = ImageCache_Get(filename);
		if (cache->font == NULL) {
			font = Font_Load(filename);
			cache->font = font;
		}
		return cache->font;
	}
	return NULL;
}



char * __cdecl std::_strdup2(char *str)
{
	char cVar1;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	if (str == NULL) {
		return (char *)NULL;
	}
	uVar3 = 0xffffffff;
	pcVar6 = str;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar6;
		pcVar6 = pcVar6 + 1;
	} while (cVar1 != '\0');
	puVar2 = (undefined4 *)malloc(~uVar3);
	if (puVar2 == NULL) {
		return NULL;
	}
	uVar3 = 0xffffffff;
	do {
		pcVar6 = str;
		if (uVar3 == 0) break;
		uVar3 -= 1;
		pcVar6 = str + 1;
		cVar1 = *str;
		str = pcVar6;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	puVar5 = (undefined4 *)(pcVar6 + -uVar3);
	puVar7 = puVar2;
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
		*puVar7 = *puVar5;
		puVar5 = puVar5 + 1;
		puVar7 = puVar7 + 1;
	}
	for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)puVar7 = *(undefined *)puVar5;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
		puVar7 = (undefined4 *)((int)puVar7 + 1);
	}
	return (char *)puVar2;
}



MenuItemMissions * __cdecl
lego::front::Menu_CreateMissionsDisplay
					(void *value,char *string1,char *string2,int param_4,int param_5,int param_6,int param_7,
					int param_8,int param_9,int param_10,int param_11,int param_12,void *callback,
					undefined4 param_14)
{
	MenuItemMissions *pMVar1;
	char *pcVar2;
	int iVar3;
	MenuItemMissions *pMVar4;
	
	pMVar1 = (MenuItemMissions *)std::malloc(0x5c);
	pMVar4 = pMVar1;
	for (iVar3 = 0x17; iVar3 != 0; iVar3 += -1) {
		pMVar4->levelsList = NULL;
		pMVar4 = (MenuItemMissions *)pMVar4->widths;
	}
	pcVar2 = std::_strdup2(string1);
	pMVar1->string1 = pcVar2;
	pcVar2 = std::_strdup2(string2);
	pMVar1->string2 = pcVar2;
	(pMVar1->rect1).x = param_4;
	pMVar1->value = (int *)value;
	(pMVar1->rect1).y = param_5;
	(pMVar1->rect1).height = param_7;
	(pMVar1->rect1).width = param_6;
	(pMVar1->rect2).x = param_8;
	(pMVar1->rect2).width = param_10;
	(pMVar1->rect2).y = param_9;
	(pMVar1->rect2).height = param_11;
	pMVar1->callback = (undefined *)callback;
	pMVar1->field_50 = param_12;
	pMVar1->field_4c = 0;
	pMVar1->field_58 = param_14;
	return pMVar1;
}



void __cdecl lego::front::Menu_FreeSubMenuItem_Count(int *param_1)
{
	int *piVar1;
	uint uVar2;
	int *buffer;
	int iVar3;
	int iVar4;
	int iVar5;
	
	buffer = param_1;
	iVar4 = 0;
	if (param_1 != NULL) {
		if ((void *)param_1[8] != NULL) {
			std::free((void *)param_1[8]);
		}
		if ((void *)param_1[9] != NULL) {
			std::free((void *)param_1[9]);
		}
		if (*param_1 != 0) {
			piVar1 = param_1 + 7;
			param_1 = NULL;
			if (0 < *piVar1) {
				do {
					uVar2 = *(uint *)(*buffer + iVar4);
					if ((uVar2 & 1) == 0) {
						if ((uVar2 & 2) != 0) {
							iVar5 = iVar4 + 8;
							iVar3 = 3;
							do {
								lego::image::Image_Remove(*(ImageBMP **)(*buffer + iVar5));
								iVar5 += 4;
								iVar3 += -1;
							} while (iVar3 != 0);
						}
					}
					else {
						std::free(*(void **)(*buffer + iVar4 + 4));
					}
					param_1 = (int *)((int)param_1 + 1);
					iVar4 += 0x20;
				} while ((int)param_1 < buffer[7]);
			}
			std::free((void *)*buffer);
		}
		std::free(buffer);
	}
	return;
}



void __cdecl
lego::front::Missions_AddLevel
					(MenuItemMissions *missions,char *menuBMPName,BOOL unkMode,ImageFont *hiFont,int frontEndX
					,int frontEndY,BOOL frontEndOpen)
{
	int *piVar1;
	MenuItemMissions *pMVar2;
	MenuItemLevelIdentifier *pMVar3;
	void *pvVar4;
	int iVar5;
	char *pcVar6;
	ImageBMP *pIVar7;
	uint uVar8;
	int **ppiVar9;
	int **ppiVar10;
	int iVar11;
	int *apiStack24 [6];
	
	pMVar2 = missions;
	if (missions->levelsList == NULL) {
		pMVar3 = (MenuItemLevelIdentifier *)std::malloc((missions->levelsCount + 1) * 0x20);
		iVar11 = 0;
		do {
			pvVar4 = std::malloc(missions->levelsCount * 4 + 4);
			iVar5 = missions->levelsCount;
			*(void **)((int)apiStack24 + iVar11) = pvVar4;
			pvVar4 = std::malloc(iVar5 * 4 + 4);
			*(void **)((int)apiStack24 + iVar11 + 0xc) = pvVar4;
			iVar11 += 4;
		} while (iVar11 < 0xc);
	}
	else {
		pMVar3 = (MenuItemLevelIdentifier *)
						 std::realloc(missions->levelsList,(missions->levelsCount + 1) * 0x20);
		ppiVar10 = missions->heights;
		iVar11 = 0;
		do {
			pvVar4 = std::realloc(ppiVar10[-3],missions->levelsCount * 4 + 4);
			iVar5 = missions->levelsCount;
			piVar1 = *ppiVar10;
			*(void **)((int)apiStack24 + iVar11) = pvVar4;
			pvVar4 = std::realloc(piVar1,iVar5 * 4 + 4);
			*(void **)((int)apiStack24 + iVar11 + 0xc) = pvVar4;
			iVar11 += 4;
			ppiVar10 = ppiVar10 + 1;
		} while (iVar11 < 0xc);
	}
	if (pMVar3 != NULL) {
		missions->levelsList = pMVar3;
		pMVar3[missions->levelsCount].MenuBMPName = NULL;
		ppiVar10 = missions->heights;
		missions->levelsList[missions->levelsCount].flags = -(uint)(unkMode != 0) & 4;
		iVar11 = 0;
		ppiVar9 = ppiVar10;
		do {
			iVar5 = iVar11 + 4;
			ppiVar9[-3] = *(int **)((int)apiStack24 + iVar11);
			*ppiVar9 = *(int **)((int)apiStack24 + iVar11 + 0xc);
			ppiVar9 = ppiVar9 + 1;
			iVar11 = iVar5;
		} while (iVar5 < 0xc);
		if ((menuBMPName != NULL) && (pcVar6 = util::Util_StrIStr(menuBMPName,".bmp"), pcVar6 != NULL))
		{
			util::Util_Tokenise(menuBMPName,(char **)(apiStack24 + 3),",");
			iVar11 = 0;
			missions->levelsList[missions->levelsCount].flags =
					 missions->levelsList[missions->levelsCount].flags | 2;
			missions = (MenuItemMissions *)(apiStack24 + 3);
			do {
				pIVar7 = lego::image::ImageCache_LoadImage((char *)missions->levelsList);
				(&pMVar2->levelsList[pMVar2->levelsCount].HiImage)[iVar11] = pIVar7;
				pIVar7 = (&pMVar2->levelsList[pMVar2->levelsCount].HiImage)[iVar11];
				if (pIVar7 != NULL) {
					lego::image::Image_SetPenZeroTrans(pIVar7);
				}
				iVar11 += 1;
				ppiVar10[-3][pMVar2->levelsCount] = pIVar7->width;
				piVar1 = *ppiVar10;
				ppiVar10 = ppiVar10 + 1;
				piVar1[pMVar2->levelsCount] = pIVar7->height;
				missions = (MenuItemMissions *)missions->widths;
			} while (iVar11 < 3);
			pMVar2->levelsList[pMVar2->levelsCount].FrontEndX = frontEndX;
			pMVar2->levelsList[pMVar2->levelsCount].FrontEndY = frontEndY;
			pMVar2->levelsList[pMVar2->levelsCount].FrontEndOpen = frontEndOpen;
			pMVar2->levelsCount = pMVar2->levelsCount + 1;
			return;
		}
		missions->levelsList[missions->levelsCount].flags =
				 missions->levelsList[missions->levelsCount].flags | 1;
		pcVar6 = std::_strdup2(menuBMPName);
		missions->levelsList[missions->levelsCount].MenuBMPName = pcVar6;
		missions->levelsList[missions->levelsCount].FrontEndX = frontEndX;
		missions->levelsList[missions->levelsCount].FrontEndY = frontEndY;
		missions->levelsList[missions->levelsCount].FrontEndOpen = frontEndOpen;
		uVar8 = lego::image::Font_GetStringWidth(hiFont,menuBMPName);
		missions->widths[2][missions->levelsCount] = uVar8;
		missions->widths[1][missions->levelsCount] = missions->widths[2][missions->levelsCount];
		missions->widths[0][missions->levelsCount] = missions->widths[1][missions->levelsCount];
		uVar8 = lego::image::Font_GetHeight(hiFont);
		missions->heights[2][missions->levelsCount] = uVar8;
		missions->heights[1][missions->levelsCount] = missions->heights[2][missions->levelsCount];
		(*ppiVar10)[missions->levelsCount] = missions->heights[1][missions->levelsCount];
		missions->levelsCount = missions->levelsCount + 1;
	}
	return;
}



MenuItemCycle * __cdecl
lego::front::Menu_CreateCycle(uint count,void *value,int x2,int y2,void *callback)
{
	MenuItemCycle *cycleData;
	char **nameList;
	uint uVar1;
	int iVar2;
	
	cycleData = (MenuItemCycle *)std::malloc(0x1c);
	if (cycleData == NULL) {
		return NULL;
	}
	nameList = (char **)std::malloc(count * 4);
	cycleData->nameList = nameList;
	if (nameList == NULL) {
		Menu_FreeCycle(cycleData);
		return NULL;
	}
	for (uVar1 = count & 0x3fffffff; uVar1 != 0; uVar1 -= 1) {
		*nameList = NULL;
		nameList = nameList + 1;
	}
	for (iVar2 = 0; iVar2 != 0; iVar2 += -1) {
		*(undefined *)nameList = 0;
		nameList = (char **)((int)nameList + 1);
	}
	cycleData->value = (int *)value;
	cycleData->callback = (MenuItemCycleCallback)callback;
	cycleData->cycleCount = count;
	cycleData->nameCount = 0;
	cycleData->x2 = x2;
	cycleData->y2 = y2;
	return cycleData;
}



void __cdecl lego::front::Menu_AddCycleName(MenuItemCycle *cycleData,char *name)
{
	char *pcVar1;
	
	if (((cycleData != NULL) && (cycleData->nameList != NULL)) &&
		 (cycleData->nameCount < (int)cycleData->cycleCount)) {
		pcVar1 = std::_strdup2(name);
		cycleData->nameList[cycleData->nameCount] = pcVar1;
		if (cycleData->nameList[cycleData->nameCount] != NULL) {
			cycleData->nameCount = cycleData->nameCount + 1;
		}
	}
	return;
}



void __cdecl lego::front::Menu_FreeCycle(MenuItemCycle *cycleData)
{
	int iVar1;
	
	if (cycleData != NULL) {
		if (cycleData->nameList != NULL) {
			iVar1 = 0;
			if (0 < cycleData->nameCount) {
				do {
					if (cycleData->nameList[iVar1] != NULL) {
						std::free(cycleData->nameList[iVar1]);
					}
					iVar1 += 1;
				} while (iVar1 < cycleData->nameCount);
			}
			std::free(cycleData->nameList);
		}
		std::free(cycleData);
	}
	return;
}



int __cdecl lego::input::msx(void)
{
	return globs::INPUT.msx;
}



int __cdecl lego::input::msy(void)
{
	return globs::INPUT.msy;
}



BOOL __cdecl lego::input::mslb(void)
{
	return globs::INPUT.mslb;
}



MenuItemTrigger * __cdecl lego::front::Menu_CreateTrigger(void *value,BOOL end,void *callback)
{
	MenuItemTrigger *pMVar1;
	
	pMVar1 = (MenuItemTrigger *)std::malloc(0xc);
	if (pMVar1 == NULL) {
		return NULL;
	}
	pMVar1->value = (int *)value;
	pMVar1->end = end;
	pMVar1->callback = (MenuItemTriggerCallback)callback;
	return pMVar1;
}



MenuItemRealSlider * __cdecl
lego::front::Menu_CreateRealSlider
					(void *value,float lowLimit,float highLimit,float step,int x2,int y2,void *callback)
{
	MenuItemRealSlider *pMVar1;
	
	if ((ushort)((ushort)(highLimit < lowLimit) << 8 | (ushort)(highLimit == lowLimit) << 0xe) != 0) {
		return NULL;
	}
	pMVar1 = (MenuItemRealSlider *)std::malloc(0x1c);
	if (pMVar1 == NULL) {
		return NULL;
	}
	pMVar1->value = (float *)value;
	pMVar1->LowLimit = lowLimit;
	pMVar1->HighLimit = highLimit;
	pMVar1->Step = step;
	pMVar1->x2 = x2;
	pMVar1->y2 = y2;
	pMVar1->callback = (MenuItemRealSliderCallback)callback;
	return pMVar1;
}



MenuItemSlider * __cdecl
lego::front::Menu_CreateSlider
					(void *value,int lowLimit,int highLimit,int x2,int y2,void *callback,ImageBMP *offBarImage
					,ImageBMP *onBarImage,ImageBMP *leftCapImage,ImageBMP *rightCapImage,ImageBMP *loPlusImage
					,ImageBMP *loMinusImage,ImageBMP *hiPlusImage,ImageBMP *hiMinusImage)
{
	MenuItemSlider *pMVar1;
	
	if (highLimit <= lowLimit) {
		return NULL;
	}
	pMVar1 = (MenuItemSlider *)std::malloc(0x38);
	if (pMVar1 == NULL) {
		return NULL;
	}
	pMVar1->value = (int *)value;
	pMVar1->x2 = x2;
	pMVar1->y2 = y2;
	pMVar1->callback = (MenuItemSliderCallback)callback;
	pMVar1->OffBarImage = offBarImage;
	pMVar1->OnBarImage = onBarImage;
	pMVar1->LeftCapImage = leftCapImage;
	pMVar1->RightCapImage = rightCapImage;
	pMVar1->LoPlusImage = loPlusImage;
	pMVar1->LoMinusImage = loMinusImage;
	pMVar1->LowLimit = lowLimit;
	pMVar1->HighLimit = highLimit;
	pMVar1->HiPlusImage = hiPlusImage;
	pMVar1->HiMinusImage = hiMinusImage;
	return pMVar1;
}



void __cdecl lego::front::Menu_FreeMenuItem(MenuItem *menuItem)
{
	if (menuItem != NULL) {
		if (menuItem->banner != NULL) {
			std::free(menuItem->banner);
		}
		if (true) {
			switch(menuItem->itemType) {
			case MENUITEM_CYCLE:
				Menu_FreeCycle((MenuItemCycle *)menuItem->itemData);
				std::free(menuItem);
				return;
			case MENUITEM_TRIGGER:
				util::freeNonNull((void *)menuItem->itemData);
				std::free(menuItem);
				return;
			case MENUITEM_TEXTINPUT:
				util::freeNonNull((void *)menuItem->itemData);
				std::free(menuItem);
				return;
			case MENUITEM_SLIDER:
				util::freeNonNull((void *)menuItem->itemData);
				std::free(menuItem);
				return;
			case MENUITEM_REALSLIDER:
				util::freeNonNull((void *)menuItem->itemData);
				std::free(menuItem);
				return;
			case MENUITEM_MISSIONS:
				Menu_FreeSubMenuItem_Count((int *)menuItem->itemData);
			}
		}
		std::free(menuItem);
	}
	return;
}



MenuItem * __cdecl
lego::front::Menu_CreateBannerItem
					(char *banner,ImageFont *loFont,ImageFont *hiFont,int x1,int y1,MenuItemType itemType,
					BOOL centered,void *itemData,BOOL isNext6)
{
	char cVar1;
	MenuItem *pMVar2;
	char *pcVar3;
	int iVar4;
	uint uVar5;
	MenuItem *pMVar6;
	
	if (banner == NULL) {
		return NULL;
	}
	pMVar2 = (MenuItem *)std::malloc(0x3c);
	if (pMVar2 == NULL) {
		return NULL;
	}
	pMVar6 = pMVar2;
	for (iVar4 = 0xf; iVar4 != 0; iVar4 += -1) {
		pMVar6->banner = NULL;
		pMVar6 = (MenuItem *)&pMVar6->length;
	}
	uVar5 = 0xffffffff;
	pcVar3 = banner;
	do {
		if (uVar5 == 0) break;
		uVar5 -= 1;
		cVar1 = *pcVar3;
		pcVar3 = pcVar3 + 1;
	} while (cVar1 != '\0');
	pMVar2->length = ~uVar5 - 1;
	pcVar3 = std::_strdup2(banner);
	pMVar2->itemType = itemType;
	pMVar2->banner = pcVar3;
	pMVar2->x1 = x1;
	pMVar2->itemData = itemData;
	pMVar2->NotInTuto = isNext6;
	pMVar2->LoFont = loFont;
	pMVar2->HiFont = hiFont;
	pMVar2->y1 = y1;
	if (((centered != 0) && (loFont != NULL)) && (hiFont != NULL)) {
		uVar5 = lego::image::Font_GetStringWidth(loFont,banner);
		pMVar2->LoCenterOff = -(uVar5 >> 1);
		uVar5 = lego::image::Font_GetStringWidth(hiFont,banner);
		pMVar2->HiCenterOff = -(uVar5 >> 1);
		return pMVar2;
	}
	pMVar2->LoCenterOff = 0;
	pMVar2->HiCenterOff = 0;
	return pMVar2;
}



MenuItem * __cdecl
lego::front::Menu_CreateImageItem
					(char *banner,ImageFont *loFont,ImageFont *hiFont,char *loImageName,char *hiImageName,
					int x1,int y1,MenuItemType itemType,BOOL centered,char *toolTipName,void *itemData)
{
	char cVar1;
	MenuItem *pMVar2;
	char *pcVar3;
	ImageBMP *pIVar4;
	BOOL BVar5;
	int iVar6;
	uint uVar7;
	MenuItem *pMVar8;
	
	if (banner != NULL) {
		pMVar2 = (MenuItem *)std::malloc(0x3c);
		if (pMVar2 != NULL) {
			pMVar8 = pMVar2;
			for (iVar6 = 0xf; iVar6 != 0; iVar6 += -1) {
				pMVar8->banner = NULL;
				pMVar8 = (MenuItem *)&pMVar8->length;
			}
			uVar7 = 0xffffffff;
			pcVar3 = banner;
			do {
				if (uVar7 == 0) break;
				uVar7 -= 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar3 + 1;
			} while (cVar1 != '\0');
			pMVar2->length = ~uVar7 - 1;
			pcVar3 = std::_strdup2(banner);
			pMVar2->banner = pcVar3;
			pMVar2->HiFont = hiFont;
			pMVar2->LoFont = loFont;
			pIVar4 = lego::image::Image_LoadBMPScaled(loImageName,0,0);
			pMVar2->LoImage = pIVar4;
			if (pIVar4 != NULL) {
				pIVar4 = lego::image::Image_LoadBMPScaled(hiImageName,0,0);
				pMVar2->HiImage = pIVar4;
				if (pIVar4 != NULL) {
					pMVar2->isImageItem = 1;
				}
				pMVar2->itemData = itemData;
				pMVar2->itemType = itemType;
				pMVar2->x1 = x1;
				pMVar2->y1 = y1;
				BVar5 = ToolTip_GetType(toolTipName,&pMVar2->toolTipType);
				if (BVar5 == 0) {
					pMVar2->toolTipType = TOOLTIP_NULL;
				}
				if (((centered != 0) && (pMVar2->LoImage != NULL)) && (pMVar2->HiImage != NULL)) {
					pMVar2->LoCenterOff = -(pMVar2->LoImage->width >> 1);
					pMVar2->HiCenterOff = -(pMVar2->HiImage->width >> 1);
					return pMVar2;
				}
				pMVar2->LoCenterOff = 0;
				pMVar2->HiCenterOff = 0;
				return pMVar2;
			}
		}
	}
	return NULL;
}



void __cdecl lego::front::Menu_FreeSubMenu(SubMenu *submenu)
{
	MenuItem *menuItem;
	int iVar1;
	
	if (submenu != NULL) {
		if (submenu->ptr_0 != NULL) {
			std::free(submenu->ptr_0);
		}
		if (submenu->ptr_4 != NULL) {
			std::free(submenu->ptr_4);
		}
		if (submenu->Items != NULL) {
			std::free(submenu->Items);
		}
		iVar1 = 0;
		if (0 < submenu->ItemCount) {
			do {
				menuItem = (MenuItem *)(&submenu->Items->banner)[iVar1];
				if (menuItem != NULL) {
					Menu_FreeMenuItem(menuItem);
				}
				iVar1 += 1;
			} while (iVar1 < submenu->ItemCount);
		}
		if (submenu->MenuImage != NULL) {
			lego::image::Image_Remove(submenu->MenuImage);
		}
		std::free(submenu);
	}
	return;
}



BOOL __cdecl lego::front::Menu_LoadMenuImage(SubMenu *param_1,char *param_2,BOOL isLightImage)
{
	char cVar1;
	ImageBMP *pIVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	undefined4 *puVar8;
	float10 fVar9;
	char *local_410;
	char *local_40c;
	char *local_408;
	char *local_404;
	undefined4 local_400 [256];
	
	local_410 = NULL;
	local_40c = NULL;
	local_408 = NULL;
	local_404 = NULL;
	if (param_2 == NULL) {
		return 0;
	}
	uVar4 = 0xffffffff;
	do {
		pcVar7 = param_2;
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar7 = param_2 + 1;
		cVar1 = *param_2;
		param_2 = pcVar7;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar6 = (undefined4 *)(pcVar7 + -uVar4);
	puVar8 = local_400;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar8 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar8 = puVar8 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar8 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar8 = (undefined4 *)((int)puVar8 + 1);
	}
	uVar4 = util::Util_Tokenise((char *)local_400,&local_410,":");
	if (2 < uVar4) {
		param_1->uint_34 = param_1->uint_34 | 1;
		fVar9 = std::atof(local_40c);
		*(float *)&param_1->field_0x38 = (float)fVar9;
		fVar9 = std::atof(local_408);
		*(float *)&param_1->field_0x3c = (float)fVar9;
	}
	if (isLightImage != 0) {
		pIVar2 = lego::image::ImageCache_LoadImage(local_410);
		param_1->MenuImage = pIVar2;
		if ((pIVar2 != NULL) && (uVar4 == 4)) {
			iVar3 = std::atoi(local_404);
			if (iVar3 == 1) {
				lego::image::Image_SetPenZeroTrans(param_1->MenuImage);
			}
		}
		return (uint)(param_1->MenuImage != NULL);
	}
	pIVar2 = lego::image::ImageCache_LoadImage(local_410);
	param_1->MenuImageDark = pIVar2;
	if ((pIVar2 != NULL) && (uVar4 == 4)) {
		iVar3 = std::atoi(local_404);
		if (iVar3 == 1) {
			lego::image::Image_SetupTrans(param_1->MenuImageDark,0.0,0.0,0.0,0.0,0.0,0.0);
		}
	}
	return (uint)(param_1->MenuImageDark != NULL);
}



SubMenu * __cdecl
lego::front::Menu_CreateSubMenu
					(char *title,char *fullName,ImageFont *menuFont,int positionX,int positionY,
					BOOL autoCenter,BOOL displayTitle,int param_8,BOOL canScroll,char *anchored_str)
{
	char cVar1;
	SubMenu *submenu_00;
	char *pcVar2;
	MenuItem *pMVar3;
	int iVar4;
	uint uVar5;
	SubMenu *submenu;
	char *local_190;
	char *local_18c;
	
	submenu_00 = (SubMenu *)std::malloc(0xa0);
	if (submenu_00 == NULL) {
		return NULL;
	}
	submenu = submenu_00;
	for (iVar4 = 0x28; iVar4 != 0; iVar4 += -1) {
		submenu->ptr_0 = NULL;
		submenu = (SubMenu *)&submenu->ptr_4;
	}
	pcVar2 = std::_strdup2(title);
	submenu_00->ptr_0 = pcVar2;
	pcVar2 = std::_strdup2(fullName);
	submenu_00->ptr_4 = pcVar2;
	if (submenu_00->ptr_0 == NULL) {
		return NULL;
	}
	if (pcVar2 == NULL) {
		return NULL;
	}
	uVar5 = 0xffffffff;
	do {
		if (uVar5 == 0) break;
		uVar5 -= 1;
		cVar1 = *title;
		title = title + 1;
	} while (cVar1 != '\0');
	submenu_00->length_8 = ~uVar5 - 1;
	pMVar3 = (MenuItem *)std::malloc(0x3c);
	submenu_00->Items = pMVar3;
	if (pMVar3 == NULL) {
		Menu_FreeSubMenu(submenu_00);
		return NULL;
	}
	submenu_00->MenuFont = menuFont;
	(submenu_00->Position).y = positionY;
	submenu_00->AutoCenter = autoCenter;
	submenu_00->DisplayTitle = displayTitle;
	(submenu_00->Position).x = positionX;
	submenu_00->int_20 = 0xf;
	submenu_00->ItemCount = 0;
	submenu_00->field_24 = 0;
	submenu_00->field_28 = 0;
	submenu_00->flags_58 = param_8;
	submenu_00->uint_34 = -(uint)(canScroll != 0) & 2;
	if (anchored_str != NULL) {
		submenu_00->isAnchored = 1;
		util::Util_Tokenise(anchored_str,&local_190,":");
		iVar4 = std::atoi(local_190);
		(submenu_00->AnchoredPosition).x = iVar4;
		iVar4 = std::atoi(local_18c);
		(submenu_00->AnchoredPosition).y = iVar4;
	}
	return submenu_00;
}



BOOL __cdecl lego::front::Menu_AddSubMenuItem(SubMenu *submenu,MenuItem *menuItem)
{
	int iVar1;
	MenuItem *pMVar2;
	
	if ((menuItem == NULL) || (submenu == NULL)) {
		return 0;
	}
	iVar1 = submenu->int_20;
	if (submenu->ItemCount == iVar1) {
		if (submenu->Items == NULL) {
			pMVar2 = (MenuItem *)std::malloc(iVar1 * 4 + 0x3c);
		}
		else {
			pMVar2 = (MenuItem *)std::realloc(submenu->Items,iVar1 * 4 + 0x3c);
		}
		if (pMVar2 == NULL) {
			return 0;
		}
		submenu->Items = pMVar2;
		submenu->int_20 = submenu->int_20 + 0xf;
	}
	(&submenu->Items->banner)[submenu->ItemCount] = (char *)menuItem;
	submenu->ItemCount = submenu->ItemCount + 1;
	return 1;
}



BOOL __cdecl
lego::math::MathX_IsPointInsideRect(int ptX,int ptY,int rcX,int rcY,int rcWidth,int rcHeight)
{
	if ((rcX <= ptX) && (ptX <= rcWidth + rcX)) {
		if ((rcY <= ptY) && (ptY <= rcHeight + rcY)) {
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl
lego::math::MathX_IsPointInsideRect_OptCenterX
					(int ptX,int ptY,int rcX,int rcY,int rcWidth,int rcHeight,BOOL shouldCenterX)
{
	int iVar1;
	BOOL BVar2;
	
	if (shouldCenterX == 0) {
		iVar1 = 0;
	}
	else {
		iVar1 = -(rcWidth / 2);
	}
	BVar2 = MathX_IsPointInsideRect(ptX,ptY,iVar1 + rcX,rcY,rcWidth,rcHeight);
	return BVar2;
}



int __cdecl
lego::front::Front_SubmenuItem_CollisionCheck_FUN_00411290
					(SubMenu *submenu,MenuItem *item,int *itemData)
{
	MenuItem *pMVar1;
	MenuItem *pMVar2;
	BOOL BVar3;
	uint rcWidth;
	byte *pbVar4;
	int iVar5;
	uint rcHeight;
	int iVar6;
	
	pMVar1 = item;
	rcHeight = 0;
	if (item->HiFont == NULL) {
		item = NULL;
	}
	else {
		pMVar2 = (MenuItem *)lego::image::Font_GetStringWidth(item->HiFont,(char *)itemData[8]);
		rcHeight = lego::image::Font_GetHeight(item->HiFont);
		item = pMVar2;
	}
	BVar3 = math::MathX_IsPointInsideRect_OptCenterX
										(globs::INPUT.msx,globs::INPUT.msy,itemData[0xf] + (submenu->Position).x,
										 itemData[0x10] + (submenu->Position).y,(int)item,rcHeight,0);
	if (BVar3 != 0) {
		return -2;
	}
	if (pMVar1->HiFont == NULL) {
		rcWidth = 0;
	}
	else {
		rcWidth = lego::image::Font_GetStringWidth(pMVar1->HiFont,(char *)itemData[9]);
	}
	BVar3 = math::MathX_IsPointInsideRect_OptCenterX
										(globs::INPUT.msx,globs::INPUT.msy,itemData[0x11] + (submenu->Position).x,
										 itemData[0x12] + (submenu->Position).y,rcWidth,rcHeight,0);
	if (BVar3 != 0) {
		return -3;
	}
	iVar6 = 0;
	if (0 < itemData[0xe]) {
		while (iVar5 = itemData[0x13] + iVar6, iVar5 < itemData[7]) {
			pbVar4 = (byte *)(*itemData + iVar5 * 0x20);
			if ((*pbVar4 & 4) != 0) {
				BVar3 = math::MathX_IsPointInsideRect_OptCenterX
													(globs::INPUT.msx,globs::INPUT.msy,
													 pMVar1->x1 + itemData[0xb] + *(int *)(pbVar4 + 0x14) +
													 (int)Point2F_005584dc.x + (submenu->Position).x,
													 itemData[0xd] * iVar6 + pMVar1->y1 + itemData[0xc] +
													 *(int *)(pbVar4 + 0x18) + (int)Point2F_005584dc.y + (submenu->Position).y
													 ,*(int *)(itemData[1] + iVar5 * 4),*(int *)(itemData[4] + iVar5 * 4),
													 submenu->AutoCenter);
				if (BVar3 != 0) {
					return iVar6 + itemData[0x13];
				}
			}
			iVar6 += 1;
			if (itemData[0xe] <= iVar6) {
				return -1;
			}
		}
	}
	return -1;
}



BOOL __cdecl lego::front::Front_SubmenuItem_FUN_00411420(SubMenu *submenu,int itemIndex)
{
	MenuItem *item;
	int iVar1;
	
	if ((itemIndex < submenu->ItemCount) &&
		 (item = (MenuItem *)(&submenu->Items->banner)[itemIndex], item->itemType == MENUITEM_MISSIONS))
	{
		iVar1 = Front_SubmenuItem_CollisionCheck_FUN_00411290(submenu,item,(int *)item->itemData);
		return (uint)(iVar1 != -1);
	}
	return 0;
}



BOOL __cdecl
lego::front::Front_Submenu_FUN_00411460
					(SubMenu *submenu,int itemIndex,int *out_rcX,int *out_rcY,int *out_rcWidth,
					int *out_rcHeight)
{
	char **ppcVar1;
	ImageFont *pIVar2;
	uint uVar3;
	char *pcVar4;
	uint uVar5;
	char *pcVar6;
	char *pcVar7;
	char *pcVar8;
	char *pcVar9;
	int iVar10;
	int iVar11;
	
	if (submenu->ItemCount <= itemIndex) {
		return 0;
	}
	ppcVar1 = (char **)(&submenu->Items->banner)[itemIndex];
	if (ppcVar1[5] == (char *)0x3) {
		pcVar9 = ppcVar1[6] + (int)(ppcVar1[9] + (submenu->Position).x);
		pcVar6 = ppcVar1[4];
		pcVar4 = ppcVar1[7] + (submenu->Position).y;
		if (submenu->field_24 == itemIndex) {
			pIVar2 = (ImageFont *)ppcVar1[2];
		}
		else {
			pIVar2 = (ImageFont *)ppcVar1[3];
		}
		uVar3 = lego::image::Font_GetStringWidth(pIVar2,*ppcVar1);
		pcVar7 = (&submenu->Items->banner)[itemIndex];
		if (submenu->field_24 == itemIndex) {
			pIVar2 = *(ImageFont **)(pcVar7 + 8);
		}
		else {
			pIVar2 = *(ImageFont **)(pcVar7 + 0xc);
		}
		uVar5 = lego::image::Font_GetHeight(pIVar2);
		pcVar7 = ppcVar1[6] + (submenu->Position).x + *(int *)(pcVar6 + 0xc);
		pcVar8 = ppcVar1[7] + (submenu->Position).y + *(int *)(pcVar6 + 0x10);
		if (*(int *)(pcVar6 + 0x24) == 0) {
			iVar10 = 0;
		}
		else {
			iVar10 = *(int *)(*(int *)(pcVar6 + 0x24) + 4);
		}
		if (*(int *)(pcVar6 + 0x28) == 0) {
			iVar11 = 0;
		}
		else {
			iVar11 = *(int *)(*(int *)(pcVar6 + 0x28) + 4);
		}
		pcVar6 = pcVar9;
		if ((int)pcVar7 <= (int)pcVar9) {
			pcVar6 = pcVar7;
		}
		*out_rcX = (int)pcVar6;
		pcVar6 = pcVar4;
		if ((int)pcVar8 <= (int)pcVar4) {
			pcVar6 = pcVar8;
		}
		*out_rcY = (int)pcVar6;
		pcVar6 = pcVar7 + iVar11 + 0x68 + iVar10;
		if ((int)(pcVar7 + iVar11 + 0x68 + iVar10) < (int)(pcVar9 + uVar3)) {
			pcVar6 = pcVar9 + uVar3;
		}
		*out_rcWidth = (int)pcVar6;
		pcVar6 = pcVar4 + uVar5;
		if ((int)(pcVar4 + uVar5) <= (int)(pcVar8 + 0x14)) {
			pcVar6 = pcVar8 + 0x14;
		}
		*out_rcHeight = (int)pcVar6;
		*out_rcWidth = *out_rcWidth - *out_rcX;
		*out_rcHeight = *out_rcHeight - *out_rcY;
		return TRUE;
	}
	if (ppcVar1[5] == (char *)0x6) {
		return 0;
	}
	*out_rcX = (int)(ppcVar1[6] + (int)(ppcVar1[9] + (submenu->Position).x));
	*out_rcY = *(int *)((&submenu->Items->banner)[itemIndex] + 0x1c) + (submenu->Position).y;
	ppcVar1 = (char **)(&submenu->Items->banner)[itemIndex];
	if (ppcVar1[10] != NULL) {
		if (submenu->field_24 == itemIndex) {
			pcVar6 = ppcVar1[0xc];
		}
		else {
			pcVar6 = ppcVar1[0xb];
		}
		*out_rcWidth = *(int *)(pcVar6 + 4);
		pcVar6 = (&submenu->Items->banner)[itemIndex];
		if (submenu->field_24 == itemIndex) {
			*out_rcHeight = *(int *)(*(int *)(pcVar6 + 0x30) + 8);
			return TRUE;
		}
		*out_rcHeight = *(int *)(*(int *)(pcVar6 + 0x2c) + 8);
		return TRUE;
	}
	if (submenu->field_24 == itemIndex) {
		pIVar2 = (ImageFont *)ppcVar1[2];
	}
	else {
		pIVar2 = (ImageFont *)ppcVar1[3];
	}
	uVar3 = lego::image::Font_GetStringWidth(pIVar2,*ppcVar1);
	*out_rcWidth = uVar3;
	pcVar6 = (&submenu->Items->banner)[itemIndex];
	if (submenu->field_24 == itemIndex) {
		uVar3 = lego::image::Font_GetHeight(*(ImageFont **)(pcVar6 + 8));
		*out_rcHeight = uVar3;
		return TRUE;
	}
	uVar3 = lego::image::Font_GetHeight(*(ImageFont **)(pcVar6 + 0xc));
	*out_rcHeight = uVar3;
	return TRUE;
}



BOOL __cdecl lego::front::Front_Submenu_FUN_004116c0(SubMenu *submenu,int *out_itemResult)
{
	BOOL BVar1;
	BOOL BVar2;
	int itemIndex;
	int rcHeight;
	int rcWidth;
	int rcY;
	int rcX;
	
	itemIndex = 0;
	rcX = 0;
	rcY = 0;
	rcWidth = 0;
	rcHeight = 0;
	BVar2 = 0;
	while( true ) {
		BVar1 = Front_Submenu_FUN_00411460(submenu,itemIndex,&rcX,&rcY,&rcWidth,&rcHeight);
		if (BVar1 == 0) {
			BVar2 = Front_SubmenuItem_FUN_00411420(submenu,itemIndex);
			if (BVar2 == 0) {
				return 0;
			}
		}
		if (BVar2 != 0) break;
		BVar1 = math::MathX_IsPointInsideRect
											(globs::INPUT.msx,globs::INPUT.msy,rcX,rcY,rcWidth,rcHeight);
		if (BVar1 != 0) break;
		itemIndex += 1;
	}
	if (out_itemResult != NULL) {
		*out_itemResult = itemIndex;
	}
	return TRUE;
}



BOOL __cdecl lego::front::Front_GetMousePressedState(void)
{
	BOOL BVar1;
	
	if ((globs::INPUT.mslb != 0) || (BVar1 = TRUE, BOOL_004dc8d4 != TRUE)) {
		BVar1 = 0;
	}
	BOOL_004dc8d4 = globs::INPUT.mslb;
	return BVar1;
}



BOOL __cdecl
lego::front::Front_Submenu_Slider_FUN_004117a0(SubMenu *param_1,int param_2,int **param_3)
{
	int *piVar1;
	BOOL BVar2;
	int iVar3;
	int rcX;
	float10 fVar4;
	longlong lVar5;
	
	rcX = (int)param_3[3] + *(int *)(param_2 + 0x18) + (param_1->Position).x;
	iVar3 = (param_1->Position).y + *(int *)(param_2 + 0x1c) + (int)param_3[4];
	BVar2 = math::MathX_IsPointInsideRect(globs::INPUT.msx,globs::INPUT.msy,rcX,iVar3,100,0x14);
	if (BVar2 != 0) {
		fVar4 = ((float10)globs::INPUT.msx - (float10)rcX) * (float10)0.01;
		if ((ushort)((ushort)(fVar4 < (float10)1.0) << 8 | (ushort)(fVar4 == (float10)1.0) << 0xe) == 0)
		{
			fVar4 = (float10)1.0;
		}
		if (fVar4 < (float10)0.0) {
			fVar4 = (float10)0.0;
		}
		lVar5 = __ftol((float10)(int)((int)param_3[2] - (int)param_3[1]) * fVar4);
		**param_3 = (int)lVar5;
		return 1;
	}
	piVar1 = param_3[0xb];
	if ((piVar1 != NULL) && (param_3[10] != NULL)) {
		BVar2 = math::MathX_IsPointInsideRect
											(globs::INPUT.msx,globs::INPUT.msy,(rcX - piVar1[1]) + -4,iVar3,piVar1[1],
											 piVar1[2]);
		if (BVar2 == 0) {
			BVar2 = math::MathX_IsPointInsideRect
												(globs::INPUT.msx,globs::INPUT.msy,param_3[9][1] + 0x68 + rcX,iVar3,
												 param_3[10][1],param_3[10][2]);
			if (BVar2 == 0) {
				return 0;
			}
			iVar3 = **param_3;
			if (iVar3 < (int)param_3[2]) {
				**param_3 = iVar3 + 1;
			}
		}
		else {
			iVar3 = **param_3;
			if ((int)param_3[1] < iVar3) {
				**param_3 = iVar3 + -1;
				return 1;
			}
		}
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::front::Front_SubmenuItemCheckHasTutorialFlags(MenuItem *item)
{
	TutorialFlags TVar1;
	
	if ((item != NULL) && (item->NotInTuto != 0)) {
		TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
		if (TVar1 != TUTORIAL_NONE) {
			return TRUE;
		}
	}
	return 0;
}



SubMenu * __cdecl lego::front::Front_Submenu_FUN_00411930(undefined4 param_1,SubMenu *submenu)
{
	undefined *puVar1;
	float *pfVar2;
	int **ppiVar3;
	int **ppiVar4;
	float **ppfVar5;
	MenuItemType MVar6;
	undefined4 *puVar7;
	int *piVar8;
	bool bVar9;
	bool bVar10;
	BOOL BVar11;
	int iVar12;
	int iVar13;
	MenuItem *item;
	int iVar14;
	int local_4;
	
	local_4 = -1;
	iVar14 = submenu->field_24;
	bVar10 = false;
	if (iVar14 < 0) {
		item = NULL;
	}
	else {
		item = (MenuItem *)(&submenu->Items->banner)[iVar14];
	}
	if (((byte)FLAGS_005584f0 & 2) != 0) {
		return submenu;
	}
	bVar9 = true;
	if ((item == NULL) && (-1 < iVar14)) {
		submenu->field_28 = 1;
	}
	BVar11 = Front_Submenu_FUN_004116c0(submenu,&local_4);
	if (BVar11 != 0) {
		submenu->field_24 = local_4;
		item = (MenuItem *)(&submenu->Items->banner)[local_4];
	}
	BVar11 = Front_SubmenuItemCheckHasTutorialFlags(item);
	if (BVar11 != 0) {
		return submenu;
	}
	BVar11 = Front_GetMousePressedState();
	if ((BVar11 == 0) || (BVar11 = Front_Submenu_FUN_004116c0(submenu,&local_4), BVar11 == 0)) {
		bVar9 = false;
	}
	if ((item == NULL) && ((int)submenu->field_24 < 0)) {
		return submenu;
	}
										// IsKeyPressed(KEY_CURSORRIGHT) (205)
	if (((globs::INPUT.Key_Map[205] != false) &&
			(globs::INPUT.prevKey_Map[205] != globs::INPUT.Key_Map[205])) || (bVar9)) {
		snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_OKAY,FALSE);
		if (true) {
			switch(item->itemType) {
			case MENUITEM_CYCLE:
				iVar14 = item->itemData;
				**(int **)(iVar14 + 0xc) = (**(int **)(iVar14 + 0xc) + 1) % *(int *)(iVar14 + 8);
				bVar10 = bVar9;
				if (*(code **)(iVar14 + 0x18) != NULL) {
					(**(code **)(iVar14 + 0x18))(**(undefined4 **)(iVar14 + 0xc));
				}
				break;
			case MENUITEM_TEXTINPUT:
				iVar14 = item->itemData;
				iVar13 = *(int *)(iVar14 + 8) + 1;
				iVar12 = *(int *)(iVar14 + 4) + -1;
				*(int *)(iVar14 + 8) = iVar13;
				bVar10 = bVar9;
				if (iVar12 < iVar13) {
					*(int *)(iVar14 + 8) = iVar12;
				}
				break;
			case MENUITEM_SLIDER:
				ppiVar4 = (int **)item->itemData;
				if (bVar9) {
					Front_Submenu_Slider_FUN_004117a0(submenu,(int)item,ppiVar4);
					if (ppiVar4[5] != NULL) {
						(*(code *)ppiVar4[5])(**ppiVar4);
					}
				}
				else {
					**ppiVar4 = **ppiVar4 + 1;
					ppiVar3 = (int **)*ppiVar4;
					piVar8 = ppiVar4[2];
					if (*ppiVar3 != piVar8 && (int)piVar8 <= (int)*ppiVar3) {
						*ppiVar3 = piVar8;
					}
					bVar10 = false;
					if (ppiVar4[5] != NULL) {
						(*(code *)ppiVar4[5])(**ppiVar4);
					}
				}
				break;
			case MENUITEM_REALSLIDER:
				ppfVar5 = (float **)item->itemData;
				**ppfVar5 = (float)ppfVar5[3] + **ppfVar5;
				pfVar2 = (float *)**ppfVar5;
				if ((ushort)((ushort)((float)pfVar2 < (float)ppfVar5[2]) << 8 |
										(ushort)((float)pfVar2 == (float)ppfVar5[2]) << 0xe) == 0) {
					**ppfVar5 = (float)ppfVar5[2];
				}
				bVar10 = bVar9;
				if (ppfVar5[6] != NULL) {
					(*(code *)ppfVar5[6])(**ppfVar5);
				}
				break;
			case MENUITEM_MISSIONS:
				piVar8 = (int *)item->itemData;
				iVar14 = Front_SubmenuItem_CollisionCheck_FUN_00411290(submenu,item,piVar8);
				if (bVar9) {
					if (iVar14 == -3) {
						if (piVar8[0x13] < 1) break;
						iVar14 = piVar8[0x13] + -1;
					}
					else {
						if (iVar14 != -2) {
							if (iVar14 != -1) {
								if (piVar8[0x16] != 0) {
									*(int *)piVar8[10] = iVar14;
									if ((code *)piVar8[0x15] != NULL) {
										(*(code *)piVar8[0x15])(param_1,iVar14);
									}
									if ((submenu == globals::menu::g_MainMenuFull->menus[3]) ||
										 (submenu == *globals::menu::g_SaveMenu->menus)) {
										INT_004a2f4c = iVar14;
										globals::g_SaveMenu_OutNumber = iVar14;
									}
									return (SubMenu *)piVar8[0x16];
								}
								*(int *)piVar8[10] = iVar14;
								if ((code *)piVar8[0x15] != NULL) {
									(*(code *)piVar8[0x15])(param_1,iVar14);
								}
								submenu->field_28 = 1;
								if ((submenu == globals::menu::g_MainMenuFull->menus[3]) ||
									 (submenu == *globals::menu::g_SaveMenu->menus)) {
									INT_004a2f4c = iVar14;
									globals::g_SaveMenu_OutNumber = iVar14;
								}
							}
							break;
						}
						if (piVar8[7] - piVar8[0xe] <= piVar8[0x13]) break;
						iVar14 = piVar8[0x13] + 1;
					}
					piVar8[0x13] = iVar14;
				}
			}
		}
	}
										// IsKeyPressed(KEY_CURSORLEFT) (203)
	if (((globs::INPUT.Key_Map[203] != false) &&
			(globs::INPUT.prevKey_Map[203] != globs::INPUT.Key_Map[203])) && (true)) {
		switch(item->itemType) {
		case MENUITEM_CYCLE:
			iVar14 = item->itemData;
			**(int **)(iVar14 + 0xc) = **(int **)(iVar14 + 0xc) + -1;
			if (**(int **)(iVar14 + 0xc) < 0) {
				**(int **)(iVar14 + 0xc) = *(int *)(iVar14 + 8) + -1;
			}
			break;
		case MENUITEM_TEXTINPUT:
			iVar14 = item->itemData;
			iVar12 = *(int *)(iVar14 + 8) + -1;
			*(int *)(iVar14 + 8) = iVar12;
			if (iVar12 < 0) {
				*(undefined4 *)(iVar14 + 8) = 0;
			}
			break;
		case MENUITEM_SLIDER:
			ppiVar4 = (int **)item->itemData;
			**ppiVar4 = **ppiVar4 + -1;
			if ((int)**ppiVar4 < (int)ppiVar4[1]) {
				**ppiVar4 = (int)ppiVar4[1];
			}
			if (ppiVar4[5] != NULL) {
				(*(code *)ppiVar4[5])(**ppiVar4);
			}
			break;
		case MENUITEM_REALSLIDER:
			ppfVar5 = (float **)item->itemData;
			**ppfVar5 = **ppfVar5 - (float)ppfVar5[3];
			if ((float)**ppfVar5 < (float)ppfVar5[1]) {
				**ppfVar5 = (float)ppfVar5[1];
			}
			if (ppfVar5[6] != NULL) {
				(*(code *)ppfVar5[6])(**ppfVar5);
			}
		}
	}
	if ((bVar9) && (!bVar10)) {
		MVar6 = item->itemType;
		if (MVar6 == MENUITEM_CYCLE) {
			piVar8 = *(int **)(item->itemData + 0xc);
			*piVar8 = (*piVar8 + 1) % *(int *)(item->itemData + 8);
		}
		else {
			if (MVar6 == MENUITEM_TRIGGER) {
				puVar7 = (undefined4 *)item->itemData;
				if ((code *)puVar7[2] != NULL) {
					(*(code *)puVar7[2])();
				}
				if (puVar7[1] != 0) {
					submenu->field_28 = 1;
					*(undefined4 *)*puVar7 = 1;
				}
			}
			else {
				if (MVar6 == MENUITEM_NEXT) {
					return (SubMenu *)item->itemData;
				}
			}
		}
	}
	if (item->itemType == MENUITEM_TEXTINPUT) {
		piVar8 = (int *)item->itemData;
		iVar14 = 0;
		do {
			if ((globs::INPUT.Key_Map[iVar14] != false) &&
				 (globs::INPUT.prevKey_Map[iVar14] != globs::INPUT.Key_Map[iVar14])) {
				if ((iVar14 == 0xe) && (iVar12 = piVar8[2], 0 < iVar12)) {
					if (iVar12 < piVar8[1]) {
						do {
							puVar1 = (undefined *)(*piVar8 + iVar12);
							iVar12 += 1;
							puVar1[-1] = *puVar1;
						} while (iVar12 < piVar8[1]);
					}
					piVar8[2] = piVar8[2] + -1;
					piVar8[1] = piVar8[1] + -1;
				}
				if (((piVar8[1] != piVar8[3]) && (piVar8[2] < piVar8[3] + -1)) &&
					 (globals::g_DIKey_CharCodes_TABLE[iVar14] != 0)) {
					iVar12 = piVar8[1] + -1;
					if (piVar8[2] <= iVar12) {
						do {
							puVar1 = (undefined *)(*piVar8 + iVar12);
							iVar12 += -1;
							puVar1[1] = *puVar1;
						} while (piVar8[2] <= iVar12);
					}
					*(undefined *)(*piVar8 + piVar8[2]) =
							 *(undefined *)(globals::g_DIKey_CharCodes_TABLE + iVar14);
					if ((globs::INPUT.Key_Map[42] != false) || (globs::INPUT.Key_Map[54] != false)) {
						*(char *)(*piVar8 + piVar8[2]) = *(char *)(*piVar8 + piVar8[2]) + -0x20;
					}
					piVar8[2] = piVar8[2] + 1;
					piVar8[1] = piVar8[1] + 1;
				}
			}
			iVar14 += 1;
		} while (iVar14 < 0x100);
	}
	return submenu;
}



int __cdecl lego::input::Input_GetKeyCharacter(int diKey)
{
	return globals::g_DIKey_CharCodes_TABLE[diKey];
}



void __cdecl FUN_00411e40(int param_1,uint param_2,uint param_3,int param_4,uint param_5)
{
	float fVar1;
	float fVar2;
	float fVar3;
	ulonglong uVar4;
	int iVar5;
	BOOL BVar6;
	longlong lVar7;
	ImageBMP *image;
	int iVar8;
	int iVar9;
	Point2F local_20;
	uint local_18;
	undefined4 uStack20;
	Rect2F local_10;
	
	local_18 = param_3;
	uStack20 = 0;
	local_10.x = 0.0;
	local_10.y = 0.0;
	local_10.height = 20.0;
	fVar1 = (float)(ulonglong)((uint)(param_4 * 100) / param_5);
	fVar2 = (float)(ulonglong)param_2;
	uVar4 = (ulonglong)param_3;
	fVar3 = (float)uVar4;
	local_20.x = fVar2;
	local_20.y = fVar3;
	local_10.width = fVar1;
	lego::image::Image_DisplayScaled(*(ImageBMP **)(param_1 + 0x1c),&local_10,&local_20,NULL);
	local_10.width = 100.0 - fVar1;
	local_20.x = fVar2 + fVar1;
	local_10.y = 0.0;
	local_10.height = 20.0;
	local_20.y = fVar3;
	local_10.x = fVar1;
	lego::image::Image_DisplayScaled(*(ImageBMP **)(param_1 + 0x18),&local_10,&local_20,NULL);
	if (*(ImageBMP **)(param_1 + 0x20) != NULL) {
		local_20.x = fVar2;
		local_20.y = fVar3;
		lego::image::Image_DisplayScaled(*(ImageBMP **)(param_1 + 0x20),NULL,&local_20,NULL);
	}
	if (*(ImageBMP **)(param_1 + 0x24) != NULL) {
		local_20.x = fVar2 - -100.0;
		local_20.y = fVar3;
		lego::image::Image_DisplayScaled(*(ImageBMP **)(param_1 + 0x24),NULL,&local_20,NULL);
	}
	iVar8 = *(int *)(param_1 + 0x2c);
	if ((iVar8 != 0) && (*(int *)(param_1 + 0x34) != 0)) {
		local_20.x = fVar2 - (float)(*(int *)(iVar8 + 4) + 4);
		iVar9 = *(int *)(iVar8 + 8);
		iVar8 = *(int *)(iVar8 + 4);
		local_20.y = fVar3;
		lVar7 = __ftol((float10)uVar4);
		iVar5 = (int)lVar7;
		lVar7 = __ftol((float10)local_20.x);
		BVar6 = lego::math::MathX_IsPointInsideRect
											(lego::globs::INPUT.msx,lego::globs::INPUT.msy,(int)lVar7,iVar5,iVar8,iVar9);
		if (BVar6 == 0) {
			image = *(ImageBMP **)(param_1 + 0x2c);
		}
		else {
			image = *(ImageBMP **)(param_1 + 0x34);
		}
		lego::image::Image_DisplayScaled(image,NULL,&local_20,NULL);
	}
	iVar8 = *(int *)(param_1 + 0x28);
	if ((iVar8 != 0) && (*(int *)(param_1 + 0x30) != 0)) {
		local_20.x = ((float)*(int *)(*(int *)(param_1 + 0x24) + 4) + fVar2) - -104.0;
		iVar9 = *(int *)(iVar8 + 8);
		iVar8 = *(int *)(iVar8 + 4);
		local_20.y = fVar3;
		lVar7 = __ftol((float10)uVar4);
		iVar5 = (int)lVar7;
		lVar7 = __ftol((float10)local_20.x);
		BVar6 = lego::math::MathX_IsPointInsideRect
											(lego::globs::INPUT.msx,lego::globs::INPUT.msy,(int)lVar7,iVar5,iVar8,iVar9);
		if (BVar6 != 0) {
			lego::image::Image_DisplayScaled(*(ImageBMP **)(param_1 + 0x30),NULL,&local_20,NULL);
			return;
		}
		lego::image::Image_DisplayScaled(*(ImageBMP **)(param_1 + 0x28),NULL,&local_20,NULL);
	}
	return;
}



int __cdecl lego::unk::Lego_CountLinkedStruct1C_At40(int param_1)
{
	int iVar1;
	int iVar2;
	
	iVar2 = 0;
	for (iVar1 = *(int *)(param_1 + 0x40); iVar1 != 0; iVar1 = *(int *)(iVar1 + 0x18)) {
		iVar2 += 1;
	}
	return iVar2;
}



BOOL __cdecl lego::util::randomBool_1_In_400(void)
{
	int iVar1;
	
	iVar1 = std::rand();
	return (uint)(iVar1 % 400 == 0);
}



void __cdecl FUN_004120e0(int param_1)
{
	char **ppcVar1;
	uint uVar2;
	uint uVar3;
	BOOL BVar4;
	int iVar5;
	ulonglong uVar6;
	ulonglong uVar7;
	Rect2F local_10;
	
	if (PTRImageFlic_0055806c == NULL) {
		ppcVar1 = *(char ***)(param_1 + 0x40);
		if (ppcVar1 != NULL) {
			if (*(int *)(param_1 + 0x9c) == 1) {
				BVar4 = lego::util::randomBool_1_In_400();
				if (BVar4 == 0) {
					uVar2 = 0;
				}
				else {
					uVar2 = lego::unk::Lego_CountLinkedStruct1C_At40(param_1);
				}
				if (uVar2 != 0) {
					uVar3 = std::rand();
					for (uVar3 %= uVar2; uVar3 != 0; uVar3 -= 1) {
						ppcVar1 = (char **)ppcVar1[6];
					}
					BVar4 = lego::image::Flic_Setup(*ppcVar1,&PTRImageFlic_0055806c,FLICDISK);
					if (BVar4 != 0) {
						lego::snd::SFX_Sample_AddToQueue((SFXType)ppcVar1[5],0);
						DAT_00558068 = ppcVar1[3];
						DAT_00558064 = ppcVar1[4];
						TIMEUINT_00558070 = lego::main::Main_GetTime();
						TIMEUINT_00558074 = TIMEUINT_00558070;
						return;
					}
				}
			}
			else {
				if (-1 < INDEX_004a2f50) {
					for (iVar5 = 4 - INDEX_004a2f50; iVar5 != 0; iVar5 += -1) {
						ppcVar1 = (char **)ppcVar1[6];
					}
					BVar4 = lego::image::Flic_Setup(*ppcVar1,&PTRImageFlic_0055806c,FLICDISK);
					if (BVar4 != 0) {
						lego::snd::SFX_Sample_AddToQueue((SFXType)ppcVar1[5],0);
						DAT_00558068 = ppcVar1[3];
						DAT_00558064 = ppcVar1[4];
						TIMEUINT_00558070 = lego::main::Main_GetTime();
						TIMEUINT_00558074 = TIMEUINT_00558070;
					}
					INT_004a2f4c = -1;
					INDEX_004a2f50 = -1;
					BOOL_004dc8c0 = 1;
					return;
				}
				if (-1 < INT_004a2f4c) {
					INDEX_004a2f50 = INT_004a2f4c;
					BOOL_004dc8c8 = 0;
				}
			}
		}
	}
	else {
		uVar2 = lego::res::AnimClone_IsLws((AnimClone *)PTRImageFlic_0055806c);
		uVar3 = lego::image::Flic_GetHeight(PTRImageFlic_0055806c);
		local_10.x = (float)(int)DAT_00558068;
		local_10.y = (float)(int)DAT_00558064;
		local_10.width = (float)(ulonglong)uVar2;
		local_10.height = (float)(ulonglong)uVar3;
		uVar3 = lego::main::Main_GetTime();
		uVar2 = TIMEUINT_00558070;
		uVar6 = __ftol((float10)(ulonglong)(TIMEUINT_00558074 - TIMEUINT_00558070) * (float10)0.025);
		uVar7 = __ftol((float10)(ulonglong)(uVar3 - uVar2) * (float10)0.025);
		if ((BOOL_004dc8c0 != 0) &&
			 (uVar7 &= 0xffffffff,
			 (int)(uint)(PTRImageFlic_0055806c->fsHeader).frames <= PTRImageFlic_0055806c->currentframe))
		{
			uVar7 = uVar6 & 0xffffffff;
			INDEX_004a2f50 = -2;
		}
		TIMEUINT_00558074 = uVar3;
		BVar4 = lego::image::Flic_Animate
											(PTRImageFlic_0055806c,&local_10,(uint)((int)uVar7 != (int)uVar6),0);
		if (BVar4 == 0) {
			lego::image::Flic_Close(PTRImageFlic_0055806c);
			std::free(PTRImageFlic_0055806c);
			PTRImageFlic_0055806c = NULL;
			TIMEUINT_00558070 = 0;
			TIMEUINT_00558074 = 0;
			lego::snd::Sound3D_Stream_Stop(0);
		}
		if ((BOOL_004dc8c0 != 0) && (lego::globs::INPUT.mslb != 0)) {
			INDEX_004a2f50 = -2;
			BOOL_004dc8c0 = 0;
			return;
		}
	}
	return;
}



void __cdecl
FUN_00412380(int param_1,int param_2,undefined4 *param_3,int *param_4,int param_5,int param_6)
{
	ImageBMP *image;
	byte *pbVar1;
	int iVar2;
	Point2F local_8;
	
	pbVar1 = (byte *)(param_5 * 0x20 + *param_4);
	if ((*pbVar1 & 1) != 0) {
		lego::image::Font_PrintF((ImageFont *)param_3,param_1,param_2,*(char **)(pbVar1 + 4));
		return;
	}
	local_8.y = (float)param_2;
	local_8.x = (float)param_1;
	image = *(ImageBMP **)(*param_4 + 8 + (param_6 + param_5 * 8) * 4);
	if ((((image != NULL) && (param_1 < 0x280)) &&
			(iVar2 = -image->width,
			param_1 != iVar2 && SBORROW4(param_1,iVar2) == (int)(param_1 + image->width) < 0)) &&
		 ((iVar2 = -image->height,
			param_2 != iVar2 && SBORROW4(param_2,iVar2) == (int)(param_2 + image->height) < 0 &&
			(param_2 < 0x1e0)))) {
		lego::image::Image_DisplayScaled(image,NULL,&local_8,NULL);
	}
	return;
}



void __cdecl FUN_00412420(int param_1,int param_2,undefined4 param_3,int param_4)
{
	ImageBMP *image;
	char *pcVar1;
	int iVar2;
	char local_34 [8];
	Size2F local_2c;
	Point2F local_24;
	int local_1c;
	undefined4 uStack24;
	char *local_14;
	char *local_10;
	
	if (((SubMenu *)param_1 == lego::globals::menu::g_MainMenuFull->menus[3]) ||
		 ((SubMenu *)param_1 == *lego::globals::menu::g_SaveMenu->menus)) {
		image = lego::globals::g_SaveSlotImages_TABLE[param_2];
		if (image != NULL) {
			std::sprintf(local_34,"pos%d",param_2 + 1);
			pcVar1 = lego::cfg::CFG_JoinPath
												 (lego::globs::gameGlobs.CfgRootName,"Menu::SaveImage",local_34,0);
			pcVar1 = lego::cfg::CFG_CopyString(lego::globs::gameGlobs.LegoCfgRoot,pcVar1);
			lego::util::Util_Tokenise(pcVar1,&local_14,"|");
			iVar2 = std::atoi(local_14);
			local_24.x = (float)iVar2;
			iVar2 = std::atoi(local_10);
			local_24.y = (float)iVar2;
			pcVar1 = lego::cfg::CFG_JoinPath
												 (lego::globs::gameGlobs.CfgRootName,"Menu::SaveImage","Width",0);
			pcVar1 = lego::cfg::CFG_ReadString(lego::globs::gameGlobs.LegoCfgRoot,pcVar1);
			if (pcVar1 == NULL) {
				pcVar1 = ____EMPTYSTR__;
			}
			else {
				pcVar1 = lego::cfg::CFG_JoinPath
													 (lego::globs::gameGlobs.CfgRootName,"Menu::SaveImage","Width",0);
				pcVar1 = lego::cfg::CFG_ReadString(lego::globs::gameGlobs.LegoCfgRoot,pcVar1);
			}
			iVar2 = std::atoi(pcVar1);
			local_2c.width = (float)iVar2;
			pcVar1 = lego::cfg::CFG_JoinPath
												 (lego::globs::gameGlobs.CfgRootName,"Menu::SaveImage","Height",0);
			pcVar1 = lego::cfg::CFG_ReadString(lego::globs::gameGlobs.LegoCfgRoot,pcVar1);
			if (pcVar1 == NULL) {
				pcVar1 = ____EMPTYSTR__;
			}
			else {
				pcVar1 = lego::cfg::CFG_JoinPath
													 (lego::globs::gameGlobs.CfgRootName,"Menu::SaveImage","Height",0);
				pcVar1 = lego::cfg::CFG_ReadString(lego::globs::gameGlobs.LegoCfgRoot,pcVar1);
			}
			iVar2 = std::atoi(pcVar1);
			local_2c.height = (float)iVar2;
			if (param_4 != 0) {
				local_1c = lego::globals::g_Menu_SaveImage_BigSize.height;
				uStack24 = 0;
				local_24.x = local_24.x -
										 ((float)(ulonglong)(uint)lego::globals::g_Menu_SaveImage_BigSize.width -
										 local_2c.width) * 0.25;
				local_24.y = local_24.y -
										 ((float)(ulonglong)(uint)lego::globals::g_Menu_SaveImage_BigSize.height -
										 local_2c.height) * 0.25;
				local_2c.width =
						 local_2c.width -
						 ((float)(ulonglong)(uint)lego::globals::g_Menu_SaveImage_BigSize.width - local_2c.width
						 ) * -0.5;
				local_2c.height =
						 local_2c.height -
						 ((float)(ulonglong)(uint)lego::globals::g_Menu_SaveImage_BigSize.height -
						 local_2c.height) * -0.5;
			}
			lego::image::Image_DisplayScaled(image,NULL,&local_24,&local_2c);
		}
	}
	return;
}



// WARNING: Type propagation algorithm not settling

void __cdecl lego::front::Front_FUN_00412680(SubMenu **pSubmenu,int *param_2,int *param_3)
{
	int *piVar1;
	SubMenu *pSVar2;
	int iVar3;
	char *pcVar4;
	int iVar5;
	int iVar6;
	longlong lVar7;
	
	pSVar2 = *pSubmenu;
	if ((pSVar2 != globals::menu::g_MainMenuFull->menus[3]) &&
		 (pSVar2 != *globals::menu::g_SaveMenu->menus)) goto LAB_0041287c;
	if ((pSVar2 == *globals::menu::g_SaveMenu->menus) && (-1 < INT_004a2f4c)) {
		if (globals::g_SaveSlotPtrs_TABLE[INT_004a2f4c] == NULL) {
			BOOL_00558508 = 0;
			(*pSubmenu)->field_28 = 1;
		}
		else {
			BOOL_004dc8bc = 1;
		}
	}
	TextWindow_Clear(globals::g_MenuSaveTextWindow->textWindow);
	TextWindow_PrintF(globals::g_MenuSaveTextWindow->textWindow,"\n");
	if (INDEX_004a2f50 == -2) {
		if (BOOL_004dc8c8 != 0) {
			*param_2 = BOOL_004dc8c8;
		}
		BOOL_004dc8c8 = 0;
		INDEX_004a2f48 = -1;
		INDEX_004a2f54 = -1;
LAB_00412766:
		*param_3 = 0;
		INT_004a2f4c = -1;
		pcVar4 = globals::g_MenuSaveTextWindow->LoadText;
		if (*pSubmenu != globals::menu::g_MainMenuFull->menus[3]) {
			pcVar4 = globals::g_MenuSaveTextWindow->SaveText;
		}
		TextWindow_PrintF(globals::g_MenuSaveTextWindow->textWindow,pcVar4);
	}
	else {
		if (INDEX_004a2f50 == -1) goto LAB_00412766;
		BOOL_004dc8c8 = *param_2;
		*param_2 = *param_3;
		INDEX_004a2f54 = INDEX_004a2f50;
	}
	if (INDEX_004a2f54 < 0) {
		if (-1 < INDEX_004a2f48) {
			param_2 = (int *)(float)ZEXT48(globals::g_SaveSlotPtrs_TABLE[INDEX_004a2f48]);
			if ((ushort)((ushort)((float)param_2 < 100.0) << 8 | (ushort)((float)param_2 == 100.0) << 0xe)
					== 0) {
				param_2 = (int *)&DAT_42c80000;
			}
			TextWindow_PrintF(globals::g_MenuSaveTextWindow->textWindow,"\n");
			lVar7 = __ftol((float10)(float)param_2);
			TextWindow_PrintF(globals::g_MenuSaveTextWindow->textWindow,
												globals::g_MenuSaveTextWindow->SlotText,(int)lVar7);
		}
	}
	else {
		TextWindow_Clear(globals::g_MenuSaveTextWindow->textWindow);
		if (*pSubmenu == globals::menu::g_MainMenuFull->menus[3]) {
			TextWindow_PrintF(globals::g_MenuSaveTextWindow->textWindow,
												globals::g_MenuSaveTextWindow->LoadSelText,INDEX_004a2f54 + 1,0);
		}
	}
	if (globals::g_MenuSaveTextWindow->textWindow != NULL) {
		TextWindow_Update(globals::g_MenuSaveTextWindow->textWindow,0,1.0,NULL);
	}
LAB_0041287c:
	pSVar2 = *pSubmenu;
	if (((pSVar2 == globals::menu::g_MainMenuFull->menus[3]) && (true)) &&
		 (iVar6 = 0, 0 < pSVar2->ItemCount)) {
		do {
			pcVar4 = (&pSVar2->Items->banner)[iVar6];
			if (*(int *)(pcVar4 + 0x14) == 6) {
				piVar1 = *(int **)(pcVar4 + 0x10);
				iVar3 = 0;
				if (0 < piVar1[7]) {
					iVar5 = 0;
					do {
						iVar3 += 1;
						std::sprintf(*(char **)(*piVar1 + 4 + iVar5),"%s %d",globals::menu::g_Menu_LoadGame_text
												 ,iVar3);
						iVar5 += 0x20;
					} while (iVar3 < piVar1[7]);
				}
			}
			pSVar2 = *pSubmenu;
			iVar6 += 1;
		} while (iVar6 < pSVar2->ItemCount);
	}
	return;
}



void __cdecl lego::front::Struct728_FUN_00412900(SubMenu **pSubmenu)
{
	MenuTextWindow *pMVar1;
	Size2F size;
	Point2F point;
	
	pMVar1 = globals::g_MenuSaveLevelWindow;
	if ((*pSubmenu == globals::menu::g_MainMenuFull->menus[1]) ||
		 (*pSubmenu == globals::menu::g_MainMenuFull->menus[2])) {
		if (globals::g_MenuSaveLevelWindow->PanelImage != NULL) {
			point.x = (globals::g_MenuSaveLevelWindow->PanelArea).x;
			point.y = (globals::g_MenuSaveLevelWindow->PanelArea).y;
			size.width = (globals::g_MenuSaveLevelWindow->PanelArea).width;
			size.height = (globals::g_MenuSaveLevelWindow->PanelArea).height;
			lego::image::Image_DisplayScaled(globals::g_MenuSaveLevelWindow->PanelImage,NULL,&point,&size)
			;
		}
		if (pMVar1->textWindow != NULL) {
			TextWindow_Update(pMVar1->textWindow,0,1.0,NULL);
			TextWindow_Clear(pMVar1->textWindow);
			TextWindow_PrintF(pMVar1->textWindow,"\n");
			if ((*pSubmenu == globals::menu::g_MainMenuFull->menus[1]) && (pMVar1->LevelText != NULL)) {
				TextWindow_PrintF(pMVar1->textWindow,pMVar1->LevelText);
				TextWindow_PrintF(pMVar1->textWindow,"\n");
			}
			if ((*pSubmenu == globals::menu::g_MainMenuFull->menus[2]) && (pMVar1->TutorialText != NULL))
			{
				TextWindow_PrintF(pMVar1->textWindow,pMVar1->TutorialText);
				TextWindow_PrintF(pMVar1->textWindow,"\n");
			}
			BOOL_004dc8c4 = TRUE;
		}
	}
	return;
}



void __cdecl FUN_00412a20(int param_1,BOOL param_2)
{
	ImageBMP *pIVar1;
	Point2F local_18;
	Rect2F local_10;
	
	if (param_2 == 0) {
		pIVar1 = *(ImageBMP **)(param_1 + 0x14);
		if (pIVar1 != NULL) {
			if ((*(byte *)(param_1 + 0x34) & 1) != 0) {
				lego::image::Image_DisplayScaled(pIVar1,NULL,(Point2F *)(param_1 + 0x38),NULL);
				return;
			}
			local_10.x = -(float)(int)Point2F_005584dc.x;
			local_10.y = -(float)(int)Point2F_005584dc.y;
			local_10.width = 640.0;
			local_10.height = 480.0;
			local_18.x = 0.0;
			local_18.y = 0.0;
			lego::image::Image_DisplayScaled(pIVar1,&local_10,&local_18,NULL);
		}
	}
	else {
		pIVar1 = *(ImageBMP **)(param_1 + 0x10);
		if (pIVar1 != NULL) {
			if ((*(byte *)(param_1 + 0x34) & 1) != 0) {
				lego::image::Image_DisplayScaled(pIVar1,NULL,(Point2F *)(param_1 + 0x38),NULL);
				return;
			}
			local_10.x = -(float)(int)Point2F_005584dc.x;
			local_10.y = -(float)(int)Point2F_005584dc.y;
			local_10.width = 640.0;
			local_10.height = 480.0;
			local_18.x = 0.0;
			local_18.y = 0.0;
			lego::image::Image_DisplayScaled(pIVar1,&local_10,&local_18,NULL);
			return;
		}
	}
	return;
}



SubMenu * __cdecl
lego::front::SaveMenu_FUN_00412b30(undefined4 param_1,SubMenu *submenu,BOOL *out_bool)
{
	ImageFont **ppIVar1;
	int iVar2;
	char **ppcVar3;
	char *pcVar4;
	char **ppcVar5;
	MenuItem *item;
	int **ppiVar6;
	float **ppfVar7;
	int *piVar8;
	ulonglong uVar9;
	float fVar10;
	Viewport *view;
	Container *pCVar11;
	char *pcVar12;
	uint uVar13;
	BOOL BVar14;
	char *pcVar15;
	int iVar16;
	ImageFont *pIVar17;
	SubMenu *pSVar18;
	uint *puVar19;
	int iVar20;
	int iVar21;
	int iVar22;
	char *pcVar23;
	int local_864;
	Point2F local_850;
	char local_845;
	SubMenu *local_844;
	Container *local_840;
	Viewport *local_83c;
	undefined4 uStack2104;
	Point2F local_834;
	SubMenu *local_82c;
	PointerType local_828;
	Vector3F local_824;
	Vector3F local_818;
	Vector3F local_80c;
	char buff [2048];
	
	save::Save_GetCurrentSaveNumber_StructB8();
	local_828 = Pointer_GetCurrentType();
	view = globs::gameGlobs.viewMain;
	local_83c = globs::gameGlobs.viewMain;
	local_840 = lego::view::Viewport_GetCamera(globs::gameGlobs.viewMain);
	INT_004a2f4c = -1;
	submenu->field_24 = 0xffffffff;
	if (out_bool != NULL) {
		*out_bool = 0;
	}
	Pointer_SetType_IfUnkFloatLessThan0(POINTER_STANDARD);
	local_844 = submenu;
	local_82c = submenu;
	if ((BOOL_004dc8bc == 0) && (BOOL_004dc8c8 == 0)) {
		local_844 = Front_Submenu_FUN_00411930(param_1,submenu);
	}
	if (((submenu == *globals::menu::g_SaveMenu->menus) && (-1 < INT_004a2f4c)) && (INT_004a2f58 < 0))
	{
		submenu->field_28 = 0;
		local_844->field_28 = 0;
	}
	if (-1 < INDEX_004a2f50) {
		local_844 = local_82c;
	}
	iVar22 = (submenu->Position).x;
	iVar2 = (submenu->Position).y;
	if ((globals::g_MenuWipeResource != NULL) && (((byte)FLAGS_005584f0 & 1) != 0)) {
		lego::view::Viewport_Clear(view,TRUE);
		res::Container_SetParent(globals::g_MenuWipeResource,globs::gameGlobs.resRoot);
		pCVar11 = lego::view::Viewport_GetCamera(view);
		local_840 = pCVar11;
		res::Container_GetPosition(pCVar11,NULL,&local_80c);
		res::Container_GetOrientation(pCVar11,NULL,&local_818,&local_824);
		res::Container_SetPosition(pCVar11,NULL,0.0,0.0,5.0);
		res::Container_SetOrientation(pCVar11,NULL,0.0,0.0,1.0,0.0,1.0,0.0);
		res::Container_SetAnimationTime(globals::g_MenuWipeResource,FLOAT_005584f4);
	}
	FUN_00412a20((int)submenu,TRUE);
	if (submenu != *globals::menu::g_SaveMenu->menus) {
		FUN_004120e0((int)submenu);
	}
	Front_FUN_00412680(&submenu,(int *)&local_844,(int *)&local_82c);
	if (submenu->DisplayTitle != 0) {
		pcVar12 = util::replaceTextSpaces((char *)submenu->ptr_4);
		uVar13 = lego::image::Font_GetStringWidth(submenu->MenuFont,pcVar12);
		iVar21 = (submenu->AnchoredPosition).y;
		iVar20 = (int)globs::mainGlobs.appWidth / 2;
		pcVar12 = util::replaceTextSpaces((char *)submenu->ptr_4);
		lego::image::Font_PrintF(submenu->MenuFont,iVar20 - (uVar13 >> 1),iVar21 + iVar2,pcVar12);
	}
	INDEX_004a2f48 = -1;
	local_834.x = 0.0;
	if (0 < submenu->ItemCount) {
		do {
			fVar10 = local_834.x;
			if (((float)submenu->field_24 != local_834.x) || (BOOL_004dc8bc != 0)) {
LAB_004131e8:
				ppcVar3 = (char **)(&submenu->Items->banner)[(int)fVar10];
				pcVar12 = ppcVar3[6];
				pcVar23 = ppcVar3[7];
				pcVar4 = ppcVar3[8];
				ppIVar1 = (ImageFont **)(ppcVar3 + 3);
				if (ppcVar3[3] != NULL) {
					pcVar15 = util::replaceTextSpaces(*ppcVar3);
					lego::image::Font_PrintF
										(*(ImageFont **)((&submenu->Items->banner)[(int)fVar10] + 0xc),
										 (int)pcVar4 + (int)pcVar12 + iVar22,(int)(pcVar23 + iVar2),"%s",pcVar15);
				}
				pcVar15 = (&submenu->Items->banner)[(int)fVar10];
				if (true) {
					switch(*(undefined4 *)(pcVar15 + 0x14)) {
					case 0:
						piVar8 = *(int **)(pcVar15 + 0x10);
						if (*ppIVar1 != NULL) {
							pcVar15 = util::replaceTextSpaces(*(char **)(*piVar8 + *(int *)piVar8[3] * 4));
							pcVar23 = pcVar23 + iVar2 + piVar8[5];
							pIVar17 = *ppIVar1;
							pcVar12 = pcVar12 + (int)(pcVar4 + piVar8[4] + iVar22);
							goto LAB_004134b2;
						}
						break;
					case 2:
						ppcVar3 = *(char ***)(pcVar15 + 0x10);
						if (*ppIVar1 != NULL) {
							pcVar15 = util::replaceTextSpaces(*ppcVar3);
							lego::image::Font_PrintF
												(*ppIVar1,(int)(pcVar12 + (int)(ppcVar3[4] + (int)pcVar4 + iVar22)),
												 (int)ppcVar3[5] + (int)pcVar23 + iVar2,"%s",pcVar15);
						}
						break;
					case 3:
						ppiVar6 = *(int ***)(pcVar15 + 0x10);
						FUN_00411e40((int)ppiVar6,(int)ppiVar6[3] + (int)pcVar12 + iVar22,
												 (int)ppiVar6[4] + (int)pcVar23 + iVar2,**ppiVar6 - (int)ppiVar6[1],
												 (uint)((int)ppiVar6[2] - (int)ppiVar6[1]));
						break;
					case 4:
						ppfVar7 = *(float ***)(pcVar15 + 0x10);
						if (*ppIVar1 != NULL) {
							lego::image::Font_PrintF
												(*ppIVar1,(int)(pcVar12 + iVar22 + (int)ppfVar7[4] + (int)pcVar4),
												 (int)ppfVar7[5] + (int)pcVar23 + iVar2,"%.2f",(double)**ppfVar7);
						}
						break;
					case 6:
						piVar8 = *(int **)(pcVar15 + 0x10);
						iVar21 = 0;
						if (0 < piVar8[0xe]) {
							do {
								local_850.x = (float)(iVar21 + piVar8[0x13]);
								if (piVar8[7] <= (int)local_850.x) break;
								iVar20 = -(*(int *)(piVar8[1] + (int)local_850.x * 4) / 2);
								puVar19 = (uint *)((int)local_850.x * 0x20 + *piVar8);
								uVar13 = ~*puVar19 >> 1 & 2;
								if (submenu->AutoCenter == 0) {
									iVar20 = 0;
								}
								if (uVar13 == 0) {
									uVar13 = 1;
								}
								FUN_00412380((int)(pcVar12 +
																	(int)Point2F_005584dc.x +
																	iVar22 + piVar8[0xb] + puVar19[5] + iVar20),
														 (int)(pcVar23 +
																	(int)Point2F_005584dc.y +
																	iVar2 + piVar8[0xd] * iVar21 + piVar8[0xc] + puVar19[6]),
														 (undefined4 *)*ppIVar1,piVar8,(int)local_850.x,uVar13);
								FUN_00412420((int)submenu,iVar21 + piVar8[0x13],piVar8,0);
								iVar21 += 1;
							} while (iVar21 < piVar8[0xe]);
						}
						if ((piVar8[0x13] < piVar8[7] - piVar8[0xe]) && (*ppIVar1 != NULL)) {
							lego::image::Font_PrintF
												(*ppIVar1,piVar8[0xf] + iVar22,piVar8[0x10] + iVar2,(char *)piVar8[8]);
						}
						if ((0 < piVar8[0x13]) && (pIVar17 = *ppIVar1, pIVar17 != NULL)) {
							pcVar15 = (char *)piVar8[9];
							pcVar23 = (char *)piVar8[0x12];
							pcVar12 = (char *)piVar8[0x11];
							goto LAB_004134b1;
						}
					}
				}
				goto switchD_00413263_caseD_1;
			}
			BVar14 = Front_SubmenuItemCheckHasTutorialFlags
												 ((MenuItem *)(&submenu->Items->banner)[(int)local_834.x]);
			if (BVar14 != 0) goto LAB_004131e8;
			ppcVar3 = (char **)(&submenu->Items->banner)[(int)fVar10];
			pcVar23 = ppcVar3[7];
			pcVar12 = ppcVar3[6];
			pcVar4 = ppcVar3[9];
			local_850.x = (float)pcVar12;
			if (ppcVar3[2] != NULL) {
				pcVar15 = util::replaceTextSpaces(*ppcVar3);
				lego::image::Font_PrintF
									((ImageFont *)ppcVar3[2],(int)pcVar4 + (int)pcVar12 + iVar22,
									 (int)(pcVar23 + iVar2),"%s",pcVar15);
			}
			pcVar15 = (&submenu->Items->banner)[submenu->field_24];
			if (false) goto switchD_00413263_caseD_1;
			switch(*(undefined4 *)(pcVar15 + 0x14)) {
			case 0:
				piVar8 = *(int **)(pcVar15 + 0x10);
				if (ppcVar3[2] == NULL) break;
				pcVar15 = util::replaceTextSpaces(*(char **)(*piVar8 + *(int *)piVar8[3] * 4));
				pcVar23 = pcVar23 + piVar8[5];
				pIVar17 = (ImageFont *)ppcVar3[2];
				pcVar12 = (char *)((int)local_850.x + (int)(pcVar4 + piVar8[4]));
LAB_004134b1:
				pcVar23 = pcVar23 + iVar2;
				pcVar12 = pcVar12 + iVar22;
				goto LAB_004134b2;
			case 2:
				ppcVar5 = *(char ***)(pcVar15 + 0x10);
				local_845 = (*ppcVar5)[(int)ppcVar5[2]];
				COUNT_004dc8dc += 1;
				if ((COUNT_004dc8dc != 0) &&
					 (uVar13 = COUNT_004dc8dc / 2 >> 0x1f,
					 ((COUNT_004dc8dc / 2 ^ uVar13) - uVar13 & 1 ^ uVar13) != uVar13)) {
					(*ppcVar5)[(int)ppcVar5[2]] = '_';
				}
				if (ppcVar3[2] != NULL) {
					pcVar12 = util::replaceTextSpaces(*ppcVar5);
					lego::image::Font_PrintF
										((ImageFont *)ppcVar3[2],
										 (int)((int)local_850.x + (int)(ppcVar5[4] + (int)pcVar4 + iVar22)),
										 (int)ppcVar5[5] + (int)pcVar23 + iVar2,"%s",pcVar12);
				}
				if ((COUNT_004dc8dc != 0) &&
					 (uVar13 = COUNT_004dc8dc / 2 >> 0x1f,
					 ((COUNT_004dc8dc / 2 ^ uVar13) - uVar13 & 1 ^ uVar13) != uVar13)) {
					(*ppcVar5)[(int)ppcVar5[2]] = local_845;
				}
				break;
			case 3:
				ppiVar6 = *(int ***)(pcVar15 + 0x10);
				FUN_00411e40((int)ppiVar6,(int)ppiVar6[3] + (int)pcVar12 + iVar22,
										 (int)ppiVar6[4] + (int)pcVar23 + iVar2,**ppiVar6 - (int)ppiVar6[1],
										 (uint)((int)ppiVar6[2] - (int)ppiVar6[1]));
				break;
			case 4:
				ppfVar7 = *(float ***)(pcVar15 + 0x10);
				if ((ImageFont *)ppcVar3[2] != NULL) {
					lego::image::Font_PrintF
										((ImageFont *)ppcVar3[2],(int)(pcVar12 + iVar22 + (int)ppfVar7[4] + (int)pcVar4)
										 ,(int)ppfVar7[5] + (int)pcVar23 + iVar2,"%.2f",(double)**ppfVar7);
				}
				break;
			case 6:
				item = (MenuItem *)(&submenu->Items->banner)[(int)fVar10];
				piVar8 = (int *)item->itemData;
				iVar21 = Front_SubmenuItem_CollisionCheck_FUN_00411290(submenu,item,piVar8);
				local_864 = 0;
				INDEX_004a2f48 = iVar21;
				if (0 < piVar8[0xe]) {
					do {
						iVar20 = piVar8[0x13] + local_864;
						if (piVar8[7] <= iVar20) break;
						puVar19 = (uint *)(iVar20 * 0x20 + *piVar8);
						iVar16 = -(*(int *)(piVar8[1] + iVar20 * 4) / 2);
						uVar13 = ~*puVar19 >> 1 & 2;
						if (submenu->AutoCenter == 0) {
							iVar16 = 0;
						}
						if (iVar21 == iVar20) {
							FUN_00412380((int)((int)local_850.x +
																(int)Point2F_005584dc.x + iVar22 + piVar8[0xb] + puVar19[5] + iVar16
																),(int)(pcVar23 +
																			 (int)Point2F_005584dc.y +
																			 iVar2 + piVar8[0xd] * local_864 + piVar8[0xc] + puVar19[6]),
													 (undefined4 *)ppcVar3[2],piVar8,iVar20,uVar13);
							if ((code *)piVar8[0x15] != NULL) {
								(*(code *)piVar8[0x15])();
							}
							iVar20 = 1;
						}
						else {
							if (uVar13 == 0) {
								uVar13 = 1;
							}
							FUN_00412380((int)((int)local_850.x +
																(int)Point2F_005584dc.x + iVar22 + piVar8[0xb] + puVar19[5] + iVar16
																),(int)(pcVar23 +
																			 (int)Point2F_005584dc.y +
																			 iVar2 + piVar8[0xd] * local_864 + piVar8[0xc] + puVar19[6]),
													 (undefined4 *)ppcVar3[3],piVar8,iVar20,uVar13);
							iVar20 = 0;
						}
						FUN_00412420((int)submenu,local_864 + piVar8[0x13],piVar8,iVar20);
						local_864 += 1;
					} while (local_864 < piVar8[0xe]);
				}
				if ((iVar21 == -2) && (piVar8[0x13] < piVar8[7] - piVar8[0xe])) {
					pIVar17 = (ImageFont *)ppcVar3[2];
joined_r0x00413184:
					if (pIVar17 != NULL) {
						lego::image::Font_PrintF
											(pIVar17,piVar8[0xf] + iVar22,piVar8[0x10] + iVar2,(char *)piVar8[8]);
					}
				}
				else {
					if (piVar8[0x13] < piVar8[7] - piVar8[0xe]) {
						pIVar17 = (ImageFont *)ppcVar3[3];
						goto joined_r0x00413184;
					}
				}
				if (iVar21 != -3) {
					if (0 < piVar8[0x13]) {
						pIVar17 = (ImageFont *)ppcVar3[3];
						goto LAB_004131c3;
					}
					break;
				}
				if (piVar8[0x13] < 1) break;
				pIVar17 = (ImageFont *)ppcVar3[2];
LAB_004131c3:
				if (pIVar17 == NULL) break;
				pcVar15 = (char *)piVar8[9];
				pcVar23 = (char *)(piVar8[0x12] + iVar2);
				pcVar12 = (char *)(piVar8[0x11] + iVar22);
LAB_004134b2:
				lego::image::Font_PrintF(pIVar17,(int)pcVar12,(int)pcVar23,pcVar15);
			}
switchD_00413263_caseD_1:
			local_834.x = (float)((int)local_834.x + 1);
		} while ((int)local_834.x < submenu->ItemCount);
	}
	Struct728_FUN_00412900(&submenu);
	iVar22 = 0;
	pSVar18 = submenu;
	if (0 < submenu->ItemCount) {
		do {
			pcVar12 = (&pSVar18->Items->banner)[iVar22];
			if (*(int *)(pcVar12 + 0x28) != 0) {
				if (pSVar18->field_24 == iVar22) {
					if (*(ImageBMP **)(pcVar12 + 0x30) != NULL) {
						local_834.x = (float)(*(int *)(pcVar12 + 0x18) + (pSVar18->Position).x);
						local_834.y = (float)(*(int *)(pcVar12 + 0x1c) + (pSVar18->Position).y);
						lego::image::Image_DisplayScaled(*(ImageBMP **)(pcVar12 + 0x30),NULL,&local_834,NULL);
					}
					ToolTip_AddFlag4(*(ToolTipType *)(pcVar12 + 0x34));
					pSVar18 = submenu;
				}
				else {
					if (*(ImageBMP **)(pcVar12 + 0x2c) != NULL) {
						local_850.x = (float)(*(int *)(pcVar12 + 0x18) + (pSVar18->Position).x);
						local_850.y = (float)(*(int *)(pcVar12 + 0x1c) + (pSVar18->Position).y);
						lego::image::Image_DisplayScaled(*(ImageBMP **)(pcVar12 + 0x2c),NULL,&local_850,NULL);
						pSVar18 = submenu;
					}
				}
			}
			iVar22 += 1;
		} while (iVar22 < pSVar18->ItemCount);
	}
	if (((((globs::mainGlobs.flags & CMD_SHOWVERSION) != CMD_NONE) && (FONT_00558078 != NULL)) &&
			(globals::g_Main_Version != NULL)) && (globs::mainGlobs.programmerLevel == PROGRAMMER_OFF)) {
		lego::image::Font_PrintF(FONT_00558078,0x221,0x1c2,globals::g_Main_Version);
	}
	Front_UnkPrintf_FUN_00410250(NULL,0,0,NULL);
	if ((submenu == *globals::menu::g_SaveMenu->menus) && (BOOL_004dc8bc != 0)) {
		std::sprintf(buff,globals::menu::g_Overwrite_Text);
		INT_004a2f58 = SaveMenu_ConfirmMessage_FUN_004354f0
														 (globals::menu::g_Overwrite_Title,buff,globals::menu::g_Overwrite_Ok,
															globals::menu::g_Overwrite_Cancel);
		if (INT_004a2f58 == 0) {
			BOOL_00558508 = 1;
			submenu->field_28 = 1;
			BOOL_004dc8bc = 0;
			globals::g_SaveMenu_OutNumber = -1;
		}
		else {
			if (INT_004a2f58 == 1) {
				BOOL_00558508 = 0;
				submenu->field_28 = 1;
				BOOL_004dc8bc = 0;
			}
		}
	}
	if ((globals::g_MenuWipeResource != NULL) && (((byte)FLAGS_005584f0 & 1) != 0)) {
		res::Container_Hide(PTR_005584fc,0);
		lego::view::Viewport_Render(local_83c,globs::gameGlobs.resRoot,0.0);
		res::Container_Hide(PTR_005584fc,1);
		pCVar11 = local_840;
		res::Container_SetPosition(local_840,NULL,local_80c.x,local_80c.y,local_80c.z);
		res::Container_SetOrientation
							(pCVar11,NULL,local_818.x,local_818.y,local_818.z,local_824.x,local_824.y,local_824.z)
		;
		res::Container_SetParent(globals::g_MenuWipeResource,NULL);
		local_83c = (Viewport *)res::Container_GetAnimationFrames(globals::g_MenuWipeResource);
		uStack2104 = 0;
		local_840 = (Container *)(float)ZEXT48(local_83c);
		local_83c = (Viewport *)main::Main_GetTime();
		uStack2104 = 0;
		uVar9 = ZEXT48(local_83c);
		fVar10 = ((float)uVar9 - FLOAT_005584f8) * 0.001 * 25.0;
		local_850.x = fVar10 + fVar10;
		if ((ushort)((ushort)(local_850.x < 3.0) << 8 | (ushort)(local_850.x == 3.0) << 0xe) == 0) {
			local_850.x = 3.0;
		}
		fVar10 = (float)local_840 * 0.5;
		if (((ushort)((ushort)(FLOAT_005584f4 < fVar10) << 8 | (ushort)(FLOAT_005584f4 == fVar10) << 0xe
								 ) != 0) && (fVar10 <= local_850.x + FLOAT_005584f4)) {
			if (out_bool != NULL) {
				*out_bool = 1;
			}
			INDEX_004a2f50 = -1;
			INT_004a2f4c = -1;
			BOOL_004dc8c8 = 0;
			BOOL_004dc8c0 = 0;
			if (PTRImageFlic_0055806c != NULL) {
				TIMEUINT_00558070 = 0;
				TIMEUINT_00558074 = 0;
			}
		}
		if ((ushort)((ushort)(FLOAT_005584f4 < (float)local_840) << 8 |
								(ushort)(FLOAT_005584f4 == (float)local_840) << 0xe) == 0) {
			unk::Lego_UnsetFlag3_005584f0();
		}
		FLOAT_005584f4 = local_850.x + FLOAT_005584f4;
		FLOAT_005584f8 = (float)uVar9;
	}
	Pointer_DrawPointer(globs::INPUT.msx,globs::INPUT.msy);
	Pointer_SetType_IfUnkFloatLessThan0(local_828);
	return local_844;
}



void __cdecl lego::front::Menu_Submenu_FUN_004138a0(SubMenu *submenu)
{
	uint uVar1;
	float fVar2;
	float10 fVar3;
	longlong lVar4;
	
	if ((submenu->MenuImage == NULL) || ((*(byte *)&submenu->uint_34 & 2) == 0)) {
		Point2F_005584dc.x = 0.0;
		Point2F_005584dc.y = 0.0;
	}
	else {
		fVar2 = (float)globs::INPUT.msy;
		if (((ushort)((ushort)(fVar2 < 280.0) << 8 | (ushort)(fVar2 == 280.0) << 0xe) == 0) ||
			 (fVar2 < 200.0)) {
			uVar1 = submenu->MenuImage->height;
			if ((fVar2 < 480.0) && ((globs::INPUT.mslb == 0 && (globs::INPUT.msrb == 0)))) {
				fVar3 = (float10)globs::INPUT.msy * (float10)0.2083333 - (float10)50.0;
				fVar3 = fVar3 * fVar3 * (float10)0.02;
				if (fVar2 < 240.0) {
					fVar3 = -fVar3;
				}
				lVar4 = __ftol(fVar3 * (float10)-0.25);
				Point2F_005584dc.y = (float)((int)Point2F_005584dc.y + (int)lVar4);
			}
			if (0 < (int)Point2F_005584dc.y) {
				Point2F_005584dc.y = 0.0;
			}
			if (SBORROW4((int)Point2F_005584dc.y + -0x1e0,-uVar1) !=
					(int)((int)Point2F_005584dc.y + -0x1e0 + uVar1) < 0) {
				Point2F_005584dc.y = (float)(0x1e0 - uVar1);
				return;
			}
		}
	}
	return;
}



void __cdecl lego::front::Front_LoadSaveSlotImages(void)
{
	char *pcVar1;
	ImageBMP *pIVar2;
	int iVar3;
	float *pfVar4;
	uint saveIndex;
	ImageBMP **ppIVar5;
	void **ppvVar6;
	int iVar7;
	undefined4 *puVar8;
	SaveData local_b8;
	
	iVar7 = 0;
	ppIVar5 = globals::g_SaveSlotImages_TABLE;
	do {
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu::SaveImage","Path",0,iVar7);
		pcVar1 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar1);
		std::sprintf((char *)&local_b8,"%s\\%d.dat",pcVar1);
		pIVar2 = lego::image::Image_LoadBMPScaled((char *)&local_b8,0,0);
		*ppIVar5 = pIVar2;
		ppIVar5 = ppIVar5 + 1;
		iVar7 += 1;
	} while (ppIVar5 < &DAT_004dc8a4);
	saveIndex = 0;
	ppvVar6 = globals::g_SaveSlotPtrs_TABLE;
	do {
		local_b8.field_0x0 = 0;
		puVar8 = &local_b8.field_0x4;
		for (iVar7 = 0x2d; iVar7 != 0; iVar7 += -1) {
			*puVar8 = 0;
			puVar8 = puVar8 + 1;
		}
		save::Save_ReadSaveFile(saveIndex,&local_b8,1);
		*ppvVar6 = NULL;
		if (8 < local_b8.count_18) {
			pfVar4 = (float *)((int)local_b8.table3190_34 + 0x1bc38);
			iVar7 = local_b8.count_18 - 8;
			do {
				if (*pfVar4 == 0.0) {
					iVar3 = 0;
				}
				else {
					iVar3 = 4;
				}
				*ppvVar6 = (void *)((int)*ppvVar6 + iVar3);
				pfVar4 = pfVar4 + 0xc64;
				iVar7 += -1;
			} while (iVar7 != 0);
		}
		std::free(local_b8.table3190_34);
		ppvVar6 = ppvVar6 + 1;
		saveIndex += 1;
	} while (ppvVar6 < &BOOL_004dc8bc);
	return;
}



void __cdecl lego::front::Front_FreeSaveSlotImages(void)
{
	ImageBMP **ppIVar1;
	
	ppIVar1 = globals::g_SaveSlotImages_TABLE;
	do {
		if (*ppIVar1 != NULL) {
			lego::image::Image_Remove(*ppIVar1);
		}
		ppIVar1 = ppIVar1 + 1;
	} while (ppIVar1 < &DAT_004dc8a4);
	return;
}



// WARNING: Type propagation algorithm not settling

void __cdecl lego::front::Front_ScreenSubmenuLoop(SubMenu *submenu)
{
	int iVar1;
	bool bVar2;
	DWORD DVar3;
	DWORD DVar4;
	RewardFrontEnd *pRVar5;
	char *pcVar6;
	BOOL local_98;
	SubMenu *local_94;
	float local_90;
	char buff [128];
	
	bVar2 = false;
	local_98 = 0;
	local_90 = 1.0;
	Front_LoadSaveSlotImages();
	BOOL_004dc8c8 = 0;
	INDEX_004a2f50 = -1;
	INT_004a2f4c = -1;
	INDEX_004a2f54 = -1;
	INT_004a2f58 = -1;
	globals::g_SaveMenu_OutNumber = -1;
	BOOL_004dc8c0 = 0;
	BOOL_004dc8bc = 0;
	BOOL_004dc8c4 = 0;
	globals::g_SaveMenu_IsLoadMode = 1;
	BOOL_00558508 = 1;
	PTRImageFlic_0055806c = NULL;
	DVar3 = timeGetTime();
	iVar1 = submenu->field_28;
	while (iVar1 == 0) {
		if (bVar2) {
			SaveMenu_FUN_00412b30(local_90,submenu,&local_98);
		}
		else {
			local_94 = SaveMenu_FUN_00412b30(local_90,submenu,NULL);
		}
										// if ((submenu == globals::menu::g_MainMenuFull->menus[0]) ...
		if ((submenu == *globals::menu::g_MainMenuFull->menus) && (local_94 != submenu)) {
			globals::g_MenuMenuFull_MissionsTutorial = -1;
			Front_TutorialsCallback_FUN_00414fe0(local_90,-1);
		}
		Menu_Submenu_FUN_004138a0(submenu);
		ToolTip_Update(globs::INPUT.msx,globs::INPUT.msy,local_90);
		snd::SFX_Update(local_90);
		main::Main_LoopUpdate(0);
		DVar4 = timeGetTime();
		local_90 = (float)(ulonglong)(DVar4 - DVar3) * 0.025;
		if ((!bVar2) && (local_94 != submenu)) {
			Front_PlayRockWipe_AndUnk();
			bVar2 = true;
			if (globals::g_MenuWipeResource == NULL) {
				local_98 = 1;
			}
		}
		if ((bVar2) && (local_98 != 0)) {
			if ((submenu->MenuImage != local_94->MenuImage) && (PTRImageFlic_0055806c != NULL)) {
				lego::image::Flic_Close(PTRImageFlic_0055806c);
				std::free(PTRImageFlic_0055806c);
				snd::Sound3D_Stream_Stop(0);
				PTRImageFlic_0055806c = NULL;
				TIMEUINT_00558070 = 0;
				TIMEUINT_00558074 = 0;
			}
			Point2F_005584dc.y = 0.0;
			Point2F_005584dc.x = 0.0;
			bVar2 = false;
			local_98 = 0;
			submenu = local_94;
		}
		DVar3 = DVar4;
		iVar1 = submenu->field_28;
	}
	Front_FreeSaveSlotImages();
	if ((((local_94 == *globals::menu::g_SaveMenu->menus) && (-1 < globals::g_SaveMenu_OutNumber)) &&
			(pRVar5 = reward::GetCurrentRewardFrontEnd(), pRVar5 != NULL)) &&
		 (pRVar5 = reward::GetCurrentRewardFrontEnd(), *(int *)&pRVar5->field_0x4 != 0)) {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu::SaveImage","Path",0);
										// MORE MEMORY LEAKS!!!! GAHHHHHH
		pcVar6 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar6);
		std::sprintf(buff,"%s\\%d.dat",pcVar6,globals::g_SaveMenu_OutNumber);
		lego::image::Image_SaveBMP((ImageBMP *)&pRVar5->field_0x8,buff);
	}
	if (PTRImageFlic_0055806c != NULL) {
		lego::image::Flic_Close(PTRImageFlic_0055806c);
		std::free(PTRImageFlic_0055806c);
		snd::Sound3D_Stream_Stop(0);
		PTRImageFlic_0055806c = NULL;
		TIMEUINT_00558070 = 0;
		TIMEUINT_00558074 = 0;
	}
	unk::Lego_UnsetFlag3_005584f0();
	return;
}



void __cdecl lego::front::Front_RunScreenMenu(MenuCollection *menuCol,int submenuIndex)
{
	int iVar1;
	int iVar2;
	
	iVar1 = 0;
	if (0 < (int)menuCol->count) {
		do {
			iVar2 = iVar1 + 1;
			menuCol->menus[iVar1]->field_28 = 0;
			iVar1 = iVar2;
		} while (iVar2 < (int)menuCol->count);
	}
	Front_ScreenSubmenuLoop(menuCol->menus[submenuIndex]);
	return;
}



MenuItemType __cdecl lego::front::Menu_ParseMenuControlType(char *controlName)
{
	int iVar1;
	
	iVar1 = std::_stricmp(controlName,"cycle");
	if (iVar1 == 0) {
		return MENUITEM_CYCLE;
	}
	iVar1 = std::_stricmp(controlName,"trigger");
	if (iVar1 == 0) {
		return MENUITEM_TRIGGER;
	}
	iVar1 = std::_stricmp(controlName,"textinput");
	if (iVar1 == 0) {
		return MENUITEM_TEXTINPUT;
	}
	iVar1 = std::_stricmp(controlName,"slider");
	if (iVar1 == 0) {
		return MENUITEM_SLIDER;
	}
	iVar1 = std::_stricmp(controlName,"realslider");
	if (iVar1 == 0) {
		return MENUITEM_REALSLIDER;
	}
	iVar1 = std::_stricmp(controlName,"next");
	return (-(uint)(iVar1 != 0) & 0xfffffffa) + MENUITEM_NEXT;
}



char * __cdecl lego::util::stringReplaceChar(char *text,char origChar,char newChar)
{
	char *pcVar1;
	char *pcVar2;
	char c;
	
	c = *text;
	pcVar2 = text;
	while (c != '\0') {
		if (c == origChar) {
			*pcVar2 = newChar;
		}
		pcVar1 = pcVar2 + 1;
		pcVar2 = pcVar2 + 1;
		c = *pcVar1;
	}
	return text;
}



int __cdecl lego::front::Menu_GetOverlayType(char **param_1)
{
	char *pcVar1;
	char cVar2;
	int iVar3;
	char *_Str2;
	
	_Str2 = *param_1;
	cVar2 = *_Str2;
	while (cVar2 != '.') {
		pcVar1 = _Str2 + 1;
		_Str2 = _Str2 + 1;
		cVar2 = *pcVar1;
	}
	iVar3 = std::_stricmp(".avi",_Str2);
	if (iVar3 != 0) {
		iVar3 = std::_stricmp(".bmp",_Str2);
		if (iVar3 != 0) {
			iVar3 = std::_stricmp(".lws",_Str2);
			return (-(uint)(iVar3 != 0) & 0xfffffffd) + 3;
		}
		return 2;
	}
	return 1;
}



// ref_overlay functions as an input argument for the last overlay, and output argument for the new
// overlay (which is linked to the previous via linked list)

MenuOverlay * __cdecl
lego::front::Menu_CreateOverlay
					(char *filename,MenuOverlay **ref_overlay,int positionX,int positionY,SFXType sfxType)
{
	MenuOverlay *pMVar1;
	char *pcVar2;
	int iVar3;
	MenuOverlay *pMVar4;
	
	pMVar1 = (MenuOverlay *)std::malloc(0x20);
	pMVar4 = pMVar1;
	for (iVar3 = 8; iVar3 != 0; iVar3 += -1) {
		pMVar4->filename = NULL;
		pMVar4 = (MenuOverlay *)&pMVar4->overlayType;
	}
	iVar3 = std::_strnicmp(filename,"Null",4);
	if (iVar3 != 0) {
		if (filename != NULL) {
			pcVar2 = std::_strdup2(filename);
			pMVar1->filename = pcVar2;
		}
		iVar3 = Menu_GetOverlayType((char **)pMVar1);
		pMVar1->overlayType = iVar3;
		pMVar1->field_1c = 0;
		pMVar4 = *ref_overlay;
		(pMVar1->position).x = positionX;
		pMVar1->previous = pMVar4;
		pMVar1->sfxType = sfxType;
		(pMVar1->position).y = positionY;
		*ref_overlay = pMVar1;
	}
	return pMVar1;
}



void __cdecl
lego::front::Menu_LoadSliderImages(int numParts,char **stringParts,ImageBMP **outImages)
{
	ImageBMP *image;
	int iVar1;
	char **ppcVar2;
	
	if (numParts == 0x10) {
		ppcVar2 = stringParts + 8;
		iVar1 = 8;
		do {
			image = lego::image::ImageCache_LoadImage(*ppcVar2);
			*outImages = image;
			if (image != NULL) {
				lego::image::Image_SetPenZeroTrans(image);
			}
			ppcVar2 = ppcVar2 + 1;
			outImages = outImages + 1;
			iVar1 += -1;
		} while (iVar1 != 0);
		return;
	}
	for (iVar1 = 8; iVar1 != 0; iVar1 += -1) {
		*outImages = NULL;
		outImages = outImages + 1;
	}
	return;
}



MenuCollection * __cdecl lego::front::Menu_CreateCollection(uint count)
{
	MenuCollection *menuCollection;
	SubMenu **ppSVar1;
	uint uVar2;
	int iVar3;
	
	menuCollection = (MenuCollection *)std::malloc(8);
	menuCollection->menus = NULL;
	menuCollection->count = 0;
	ppSVar1 = (SubMenu **)std::malloc(count * 4);
	uVar2 = count & 0x3fffffff;
	menuCollection->menus = ppSVar1;
	for (; uVar2 != 0; uVar2 -= 1) {
		*ppSVar1 = NULL;
		ppSVar1 = ppSVar1 + 1;
	}
	for (iVar3 = 0; iVar3 != 0; iVar3 += -1) {
		*(undefined *)ppSVar1 = 0;
		ppSVar1 = (SubMenu **)((int)ppSVar1 + 1);
	}
	menuCollection->count = count;
	return menuCollection;
}



MenuCollection * __cdecl
lego::front::Menu_ParseMenu(undefined param_1,char *menuName,void *dst,void *callback,...)
{
	MenuItemType MVar1;
	char *pcVar2;
	uint uVar3;
	MenuCollection *menuCol;
	char *pcVar4;
	char *pcVar5;
	int iVar6;
	int iVar7;
	BOOL3 BVar8;
	uint uVar9;
	char *pcVar10;
	SubMenu *pSVar11;
	int menuIndex;
	int iVar12;
	ImageFont *loFont;
	ImageFont *hiFont;
	SFXType SVar13;
	MenuItemType MVar14;
	MenuItemCycle *cycleData;
	int highLimit;
	int lowLimit;
	int iVar15;
	MenuItem *submenu;
	MenuItemCallbackPair *pMVar16;
	MenuItemCallbackPair *argPtrNext;
	MenuItemCallbackPair *argptr;
	float10 fVar17;
	ImageBMP *offBarImage;
	ImageBMP *onBarImage;
	ImageFont *pIVar18;
	ImageBMP *leftCapImage;
	ImageFont *pIVar19;
	ImageBMP *rightCapImage;
	float highLimit_00;
	ImageBMP *loPlusImage;
	float step;
	ImageBMP *loMinusImage;
	MenuItemType MVar20;
	ImageBMP *hiPlusImage;
	MenuItemCycle *itemData;
	ImageBMP *hiMinusImage;
	MenuItemSlider *itemData_00;
	char **local_dd0;
	char *str;
	int local_dc8;
	SFXType local_dc4;
	char *local_dc0;
	int menuCount;
	int menuNumber;
	int itemNumber;
	ImageBMP *sliderImages [8];
	char *stringParts [100];
	char submenuPathBuff [1024];
	char overItemBuff [1024];
	char menuPathBuff [1024];
	void *argCallback;
	void *argValue;
	BOOL isLight;
	
	pMVar16 = (MenuItemCallbackPair *)&dst;
	std::sprintf(menuPathBuff,"Menu::%s",menuName);
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,menuPathBuff,"MenuCount",0);
	pcVar2 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,menuPathBuff,"MenuCount",0);
		pcVar2 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	}
	uVar3 = std::atoi(pcVar2);
	menuCount = uVar3;
	menuCol = Menu_CreateCollection(uVar3);
	menuIndex = 0;
	if (0 < (int)uVar3) {
		do {
			iVar12 = menuIndex + 1;
			local_dc8 = 0;
			std::sprintf(submenuPathBuff,"%s::Menu%i",menuPathBuff,iVar12);
			pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,"Title",0);
			pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
			pcVar4 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,"FullName",0);
			pcVar4 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar4);
			pcVar5 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,"Position",0);
			pcVar5 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar5);
			util::Util_Tokenise(pcVar5,stringParts,":");
			iVar6 = std::atoi(stringParts[0]);
			iVar7 = std::atoi(stringParts[1]);
			if (pcVar5 != NULL) {
				std::free(pcVar5);
			}
			pcVar5 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,"MenuFont",0);
			pcVar5 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar5);
			loFont = lego::image::ImageCache_LoadFont(pcVar5);
			pcVar5 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,"AutoCenter",0);
			BVar8 = cfg::CFG_ReadBool(globs::gameGlobs.LegoCfgRoot,pcVar5);
			uVar3 = (uint)(BVar8 == BOOL3_TRUE);
			pcVar5 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,"DisplayTitle",0);
			BVar8 = cfg::CFG_ReadBool(globs::gameGlobs.LegoCfgRoot,pcVar5);
			local_dc4 = (SFXType)(BVar8 != BOOL3_FALSE);
			pcVar5 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,"Anchored",0);
			local_dc0 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar5);
			if (((uVar3 != 0) && (pcVar2 != NULL)) && (*pcVar2 != '\0')) {
				uVar9 = lego::image::Font_GetStringWidth(loFont,pcVar2);
				local_dc8 = -((int)uVar9 / 2);
			}
			pcVar5 = local_dc0;
			pcVar10 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,"CanScroll",0);
			BVar8 = cfg::CFG_ReadBool(globs::gameGlobs.LegoCfgRoot,pcVar10);
			uVar9 = (uint)(BVar8 == BOOL3_TRUE);
			SVar13 = local_dc4;
			pcVar4 = util::stringReplaceChar(pcVar4,'_',' ');
			pcVar10 = util::stringReplaceChar(pcVar2,'_',' ');
			pSVar11 = Menu_CreateSubMenu(pcVar10,pcVar4,loFont,iVar6,iVar7,uVar3,SVar13,local_dc8,uVar9,
																	 pcVar5);
			isLight = 1;
			menuCol->menus[menuIndex] = pSVar11;
			pcVar4 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,"MenuImage",0);
			pcVar4 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar4);
			Menu_LoadMenuImage(menuCol->menus[menuIndex],pcVar4,isLight);
			isLight = 0;
			pcVar4 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,"MenuImageDark",0);
			pcVar4 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar4);
			Menu_LoadMenuImage(menuCol->menus[menuIndex],pcVar4,isLight);
			std::sprintf(menuCol->menus[menuIndex]->CfgName,"%s",submenuPathBuff);
			pcVar4 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,menuCol->menus[menuIndex]->CfgName,
																 "PlayRandom",0);
			BVar8 = cfg::CFG_ReadBool(globs::gameGlobs.LegoCfgRoot,pcVar4);
			menuCol->menus[menuIndex]->PlayRandom = BVar8;
			std::free(pcVar2);
			menuIndex = iVar12;
			uVar3 = menuCount;
		} while (iVar12 < menuCount);
	}
	menuIndex = 0;
	if ((int)uVar3 < 1) {
		return menuCol;
	}
LAB_00414425:
	iVar12 = menuIndex + 1;
	MVar1 = menuCol->menus[menuIndex]->AutoCenter;
	std::sprintf(submenuPathBuff,"%s::Menu%i",menuPathBuff,iVar12);
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,"LoFont",0);
	pcVar2 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	loFont = lego::image::ImageCache_LoadFont(pcVar2);
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,"HiFont",0);
	pcVar2 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	hiFont = lego::image::ImageCache_LoadFont(pcVar2);
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,"ItemCount",0);
	pcVar2 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,"ItemCount",0);
		pcVar2 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	}
	local_dc0 = (char *)std::atoi(pcVar2);
	local_dd0 = (char **)0x1;
	do {
		std::sprintf(overItemBuff,"Overlay%i",local_dd0);
		pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,overItemBuff,0);
		str = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
		if (str == NULL) {
			if ((globs::mainGlobs.flags & CMD_REDUCEFLICS) != CMD_NONE) break;
			std::sprintf(overItemBuff,"!Overlay%i",local_dd0);
			pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,overItemBuff,0);
			str = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
			if (str == NULL) break;
		}
		util::Util_Tokenise(str,stringParts,":");
		SVar13 = snd::SFX_GetType(stringParts[1],&local_dc4);
		if (SVar13 == SFX_NULL) {
			local_dc4 = SVar13;
		}
		SVar13 = local_dc4;
		iVar6 = std::atoi(stringParts[3]);
		iVar7 = std::atoi(stringParts[2]);
		Menu_CreateOverlay(stringParts[0],&menuCol->menus[menuIndex]->Overlays,iVar7,iVar6,SVar13);
		if (str != NULL) {
			std::free(str);
		}
		local_dd0 = (char **)((int)local_dd0 + 1);
	} while( true );
	iVar6 = 0;
	argptr = pMVar16;
	if (0 < (int)local_dc0) {
		do {
			iVar6 += 1;
			std::sprintf(overItemBuff,"Item%i",iVar6);
			if (str != NULL) {
				std::free(str);
			}
			pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,submenuPathBuff,overItemBuff,0);
			str = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
			iVar7 = util::Util_Tokenise(str,stringParts,":");
			MVar14 = Menu_ParseMenuControlType(stringParts[0]);
			pMVar16 = argptr;
			if (false) goto switchD_00414714_caseD_2;
			MVar20 = MVar1;
			switch(MVar14) {
			case MENUITEM_CYCLE:
				argValue = argptr->value;
				pMVar16 = argptr + 1;
				argCallback = argptr->callback;
				iVar7 = std::atoi(stringParts[4]);
				iVar15 = std::atoi(stringParts[3]);
				uVar3 = std::atoi(stringParts[6]);
				cycleData = Menu_CreateCycle(uVar3,argValue,iVar15,iVar7,argCallback);
				isLight = 0;
				MVar20 = MENUITEM_CYCLE;
				MVar14 = MVar1;
				itemData = cycleData;
				iVar7 = std::atoi(stringParts[2]);
				iVar15 = std::atoi(stringParts[1]);
				pIVar18 = loFont;
				pIVar19 = hiFont;
				pcVar2 = util::stringReplaceChar(stringParts[5],'_',' ');
				submenu = Menu_CreateBannerItem
														(pcVar2,pIVar18,pIVar19,iVar15,iVar7,MVar20,MVar14,itemData,isLight);
				Menu_AddSubMenuItem(menuCol->menus[menuIndex],submenu);
				local_dc8 = 0;
				iVar7 = std::atoi(stringParts[6]);
				if (0 < iVar7) {
					local_dd0 = stringParts + 7;
					do {
						pcVar2 = util::stringReplaceChar(*local_dd0,'_',' ');
						Menu_AddCycleName(cycleData,pcVar2);
						local_dc8 += 1;
						local_dd0 = local_dd0 + 1;
						iVar7 = std::atoi(stringParts[6]);
					} while (local_dc8 < iVar7);
				}
				break;
			case MENUITEM_TRIGGER:
				if (iVar7 == 8) {
					argValue = argptr->value;
					pMVar16 = argptr + 1;
					argCallback = argptr->callback;
					iVar7 = std::atoi(stringParts[7]);
					pSVar11 = (SubMenu *)Menu_CreateTrigger(argValue,(uint)(iVar7 == 1),argCallback);
					MVar14 = MENUITEM_TRIGGER;
LAB_00414992:
					pcVar2 = stringParts[6];
					iVar7 = std::atoi(stringParts[2]);
					iVar15 = std::atoi(stringParts[1]);
					submenu = Menu_CreateImageItem
															(____EMPTYSTR__,loFont,hiFont,stringParts[3],stringParts[4],iVar15,
															 iVar7,MVar14,MVar20,pcVar2,pSVar11);
					pSVar11 = menuCol->menus[menuIndex];
					argptr = pMVar16;
					goto LAB_00414b5a;
				}
				if (iVar7 != 5) break;
				argValue = argptr->value;
				argPtrNext = argptr + 1;
				isLight = 0;
				argCallback = argptr->callback;
				iVar7 = std::atoi(stringParts[4]);
				itemData_00 = (MenuItemSlider *)Menu_CreateTrigger(argValue,(uint)(iVar7 == 1),argCallback);
				MVar14 = MENUITEM_TRIGGER;
LAB_00414a6e:
				iVar7 = std::atoi(stringParts[2]);
				iVar15 = std::atoi(stringParts[1]);
				pcVar2 = stringParts[3];
				argptr = argPtrNext;
				goto LAB_00414b41;
			case MENUITEM_SLIDER:
				argValue = argptr->value;
				Menu_LoadSliderImages(iVar7,stringParts,sliderImages);
				isLight = 0;
				argCallback = argptr->callback;
				offBarImage = sliderImages[0];
				onBarImage = sliderImages[1];
				leftCapImage = sliderImages[2];
				rightCapImage = sliderImages[3];
				loPlusImage = sliderImages[4];
				loMinusImage = sliderImages[5];
				hiPlusImage = sliderImages[6];
				hiMinusImage = sliderImages[7];
				iVar7 = std::atoi(stringParts[4]);
				iVar15 = std::atoi(stringParts[3]);
				highLimit = std::atoi(stringParts[7]);
				lowLimit = std::atoi(stringParts[6]);
				itemData_00 = Menu_CreateSlider(argValue,lowLimit,highLimit,iVar15,iVar7,argCallback,
																				offBarImage,onBarImage,leftCapImage,rightCapImage,
																				loPlusImage,loMinusImage,hiPlusImage,hiMinusImage);
				MVar14 = MENUITEM_SLIDER;
				goto LAB_00414b10;
			case MENUITEM_REALSLIDER:
				argValue = argptr->value;
				isLight = 0;
				argCallback = argptr->callback;
				iVar7 = std::atoi(stringParts[4]);
				iVar15 = std::atoi(stringParts[3]);
				fVar17 = std::atof(stringParts[8]);
				step = (float)fVar17;
				fVar17 = std::atof(stringParts[7]);
				highLimit_00 = (float)fVar17;
				fVar17 = std::atof(stringParts[6]);
				itemData_00 = (MenuItemSlider *)
											Menu_CreateRealSlider
																(argValue,(float)fVar17,highLimit_00,step,iVar15,iVar7,argCallback);
				MVar14 = MENUITEM_REALSLIDER;
LAB_00414b10:
				argptr = argptr + 1;
				iVar7 = std::atoi(stringParts[2]);
				iVar15 = std::atoi(stringParts[1]);
				pcVar2 = stringParts[5];
LAB_00414b41:
				pIVar18 = loFont;
				pIVar19 = hiFont;
				pcVar2 = util::stringReplaceChar(pcVar2,'_',' ');
				submenu = Menu_CreateBannerItem
														(pcVar2,pIVar18,pIVar19,iVar15,iVar7,MVar14,MVar20,itemData_00,isLight);
				pSVar11 = menuCol->menus[menuIndex];
LAB_00414b5a:
				Menu_AddSubMenuItem(pSVar11,submenu);
				pMVar16 = argptr;
				break;
			case MENUITEM_NEXT:
				if (iVar7 == 8) {
					iVar7 = std::atoi(stringParts[7] + 4);
					pSVar11 = menuCol->menus[iVar7 + -1];
					MVar14 = MENUITEM_NEXT;
					goto LAB_00414992;
				}
				if (iVar7 == 6) {
					iVar7 = std::atoi(stringParts[4] + 4);
					isLight = 1;
				}
				else {
					if (*stringParts[4] == '\0') {
						isLight = 0;
						itemData_00 = NULL;
						argPtrNext = argptr;
						MVar14 = MVar1;
						MVar20 = MENUITEM_NEXT;
						goto LAB_00414a6e;
					}
					iVar7 = std::atoi(stringParts[4] + 4);
					isLight = 0;
				}
				pSVar11 = menuCol->menus[iVar7 + -1];
				MVar20 = MENUITEM_NEXT;
				MVar14 = MVar1;
				iVar7 = std::atoi(stringParts[2]);
				iVar15 = std::atoi(stringParts[1]);
				pIVar18 = loFont;
				pIVar19 = hiFont;
				pcVar2 = util::stringReplaceChar(stringParts[3],'_',' ');
				submenu = Menu_CreateBannerItem
														(pcVar2,pIVar18,pIVar19,iVar15,iVar7,MVar20,MVar14,pSVar11,isLight);
				pSVar11 = menuCol->menus[menuIndex];
				goto LAB_00414b5a;
			}
switchD_00414714_caseD_2:
			argptr = pMVar16;
		} while (iVar6 < (int)local_dc0);
	}
	if (str != NULL) {
		std::free(str);
	}
	menuIndex = iVar12;
	if (menuCount <= iVar12) {
		return menuCol;
	}
	goto LAB_00414425;
}



int __cdecl lego::front::Menu_GetSubMenuIDByName(MenuCollection *menuCol,char *name)
{
	int iVar1;
	int iVar2;
	
	iVar2 = 0;
	if ((int)menuCol->count < 1) {
		return -1;
	}
	while ((menuCol->menus[iVar2] == NULL ||
				 (iVar1 = std::_stricmp((char *)menuCol->menus[iVar2]->ptr_0,name), iVar1 != 0))) {
		iVar2 += 1;
		if ((int)menuCol->count <= iVar2) {
			return -1;
		}
	}
	return iVar2;
}



BOOL __cdecl lego::main::Config_IsIntrosEnabled(void)
{
	char *keyPath;
	BOOL3 BVar1;
	
	keyPath = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","DontPlayAvis",0);
	BVar1 = cfg::CFG_ReadBool(globs::gameGlobs.LegoCfgRoot,keyPath);
	if ((BVar1 != BOOL3_TRUE) && (globs::mainGlobs.programmerLevel < PROGRAMMER_MODE_3)) {
		return 1;
	}
	return 0;
}



void __cdecl lego::front::PausedMenu_SliderBrightness(int slider_0_10)
{
	float r;
	float r_00;
	
	r = (float)slider_0_10 * 0.1;
	r_00 = r * 0.8 - -0.2;
	res::Container_SetColourAlpha(globs::gameGlobs.resTopSpotlight,r,r,r,1.0);
	res::Container_SetColourAlpha(globs::gameGlobs.resFPLight,r_00,r_00,r_00,1.0);
	res::Container_Light_SetSpotPenumbra(globs::gameGlobs.resTopSpotlight,r * 1.5 - -0.5);
	res::Container_Light_SetSpotUmbra(globs::gameGlobs.resTopSpotlight,r * 0.8 - -0.2);
	return;
}



void __cdecl lego::front::PausedMenu_SliderSoundVolume(int slider_0_10)
{
	snd::Sound3D_SetGlobalVolumePrescaled(slider_0_10);
	return;
}



void __cdecl lego::front::PausedMenu_SliderMusicVolume(int slider_0_10)
{
	main::Main_SetCDVolume((float)slider_0_10 * 0.1111111,(float)slider_0_10 * 0.1111111);
	return;
}



int __cdecl lego::front::PausedMenu_CalcSliderCDVolume(void)
{
	BOOL BVar1;
	int iVar2;
	longlong lVar3;
	float rightVol;
	float leftVol;
	
	iVar2 = 0;
	BVar1 = game::Main_GetCDVolume(&leftVol,&rightVol);
	if (BVar1 != 0) {
		lVar3 = __ftol(((float10)rightVol + (float10)leftVol) * (float10)0.5 * (float10)9.0);
		iVar2 = (int)lVar3;
	}
	return iVar2;
}



void __cdecl lego::front::PausedMenu_CycleWallDetail(int cycle_High_Low)
{
	if (cycle_High_Low == 0) {
		globs::gameGlobs.flags1 |= GAME1_WALLPROMESHES;
	}
	else {
		if (cycle_High_Low == 1) {
			globs::gameGlobs.flags1 = globs::gameGlobs.flags1 & ~GAME1_WALLPROMESHES;
			return;
		}
	}
	return;
}



void __cdecl lego::front::PausedMenu_CycleAutoGameSpeed(int cycle_On_Off)
{
	Info_SetAutoGameSpeed((uint)(cycle_On_Off == 0));
	return;
}



void __cdecl lego::front::PausedMenu_CycleMusic(int cycle_On_Off)
{
	snd::Music_PlayNext((uint)(cycle_On_Off == 0));
	return;
}



void __cdecl lego::front::PausedMenu_CycleSound(int cycle_On_Off)
{
	snd::SFX_SetSoundEnabled((uint)(cycle_On_Off == 0));
	return;
}



void __cdecl lego::front::PausedMenu_CycleHelpWindow(int cycle_Off_On)
{
	if (cycle_Off_On == 0) {
		HelpWindow_FUN_00419130(0,1);
	}
	else {
		if (cycle_Off_On == 1) {
			HelpWindow_FUN_00419130(0,0);
			return;
		}
	}
	return;
}



void __cdecl lego::front::PausedMenu_TriggerReplayObjective(void)
{
	game::Objective_Level_SetCompleteStatus(LEVELSTATUS_NONE);
	return;
}



void __cdecl lego::front::PausedMenu_SliderGameSpeed(int slider_0_5)
{
	if (true) {
		switch(slider_0_5) {
		case 0:
			globs::gameGlobs.gameSpeed = 0.3333333;
			return;
		case 1:
			globs::gameGlobs.gameSpeed = 0.6666667;
			return;
		case 3:
			globs::gameGlobs.gameSpeed = 1.333333;
			return;
		case 4:
			globs::gameGlobs.gameSpeed = 1.666667;
			return;
		case 5:
			globs::gameGlobs.gameSpeed = 2.0;
			return;
		}
	}
	globs::gameGlobs.gameSpeed = 1.0;
	return;
}



void __cdecl lego::front::FrontEnd_UpdateSliderGameSpeed(void)
{
	if (globs::gameGlobs.gameSpeed < 0.6666666) {
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 0;
		return;
	}
	if (globs::gameGlobs.gameSpeed < 1.0) {
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 1;
		return;
	}
	if (globs::gameGlobs.gameSpeed < 1.333333) {
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 2;
		return;
	}
	if (globs::gameGlobs.gameSpeed < 1.666667) {
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 3;
		return;
	}
	globals::g_PausedMenu_SliderGameSpeed_0_5 = 4;
	if (2.0 <= globs::gameGlobs.gameSpeed) {
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 5;
	}
	return;
}



int __cdecl lego::front::PausedMenu_CalcSliderGameSpeed(void)
{
	int iVar1;
	
	if (globs::gameGlobs.gameSpeed < 0.6666666) {
		return 0;
	}
	if (globs::gameGlobs.gameSpeed < 1.0) {
		return 1;
	}
	if (globs::gameGlobs.gameSpeed < 1.333333) {
		return 2;
	}
	if (globs::gameGlobs.gameSpeed < 1.666667) {
		return 3;
	}
	iVar1 = 4;
	if (2.0 <= globs::gameGlobs.gameSpeed) {
		iVar1 = 5;
	}
	return iVar1;
}



void __cdecl lego::front::Front_TutorialsCallback_FUN_00414fe0(float elapsedAbs,int param_2)
{
	SaveData *pSVar1;
	void *pvVar2;
	LevelCollection *levelCol;
	MenuItemTrigger *pMVar3;
	undefined4 uVar4;
	
	save::Save_SetSaveNumber(param_2);
	pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
	if (pSVar1 == NULL) {
		uVar4 = 1;
		pMVar3 = *(MenuItemTrigger **)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
		levelCol = &globals::g_MissionLevels;
		pvVar2 = NULL;
	}
	else {
		uVar4 = 0;
		pMVar3 = *(MenuItemTrigger **)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
		levelCol = &globals::g_MissionLevels;
		pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
		pvVar2 = pSVar1->table3190_34;
	}
	LevelIdentifier_FUN_00417310(globals::g_StartMissionLevel,(int)pvVar2,levelCol,pMVar3,uVar4);
	LevelIdentifier_FUN_00417310
						(globals::g_StartTutorialLevel,0,&globals::g_TutorialLevels,
						 *(MenuItemTrigger **)(globals::menu::g_MainMenuFull->menus[2]->Items->length + 0x10),0)
	;
	return;
}



void __cdecl lego::front::Front_UpdatePausedMenuSliders(void)
{
	int saveIndex;
	SaveData *pSVar1;
	
	saveIndex = save::Save_GetSaveNumber();
	pSVar1 = save::Save_GetStructB8At(saveIndex);
	if (pSVar1 != NULL) {
		PausedMenu_SliderSoundVolume(pSVar1->SliderSoundVolume);
		PausedMenu_SliderBrightness(pSVar1->SliderBrightness);
		PausedMenu_SliderMusicVolume(pSVar1->field_0x4);
	}
	return;
}



void __cdecl lego::front::SaveMenu_TriggerBack(void)
{
	SaveData *pSVar1;
	LevelCollection *levelCol;
	MenuItemTrigger *pMVar2;
	undefined4 uVar3;
	
	globals::g_SaveMenu_IsLoadMode = 0;
	BOOL_00558508 = 0;
	INT_004a2f4c = -1;
	pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
	if (pSVar1 != NULL) {
		uVar3 = 0;
		pMVar2 = *(MenuItemTrigger **)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
		levelCol = &globals::g_MissionLevels;
		pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
		LevelIdentifier_FUN_00417310
							(globals::g_StartMissionLevel,(int)pSVar1->table3190_34,levelCol,pMVar2,uVar3);
		return;
	}
	LevelIdentifier_FUN_00417310
						(globals::g_StartMissionLevel,0,&globals::g_MissionLevels,
						 *(MenuItemTrigger **)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10),1)
	;
	return;
}



void __cdecl lego::debug::Debug_ProgrammerMode11_LoadLevel(void)
{
	char *levelName;
	int i;
	MenuCollection *menuCol;
	char buff [128];
	
	std::sprintf(buff,"%s",(globs::gameGlobs.level)->levelName);
	game::Game_SetPaused(FALSE,FALSE);
	game::Level_Free();
	levelName = std::_strdup(buff);
	main::Main_loadLevelCFG(levelName);
	i = 0;
	menuCol = globals::menu::g_PausedMenu;
	if (0 < (int)globals::menu::g_PausedMenu->count) {
		do {
			if (menuCol->menus[i] != NULL) {
				menuCol->menus[i]->field_28 = 1;
				menuCol = globals::menu::g_PausedMenu;
			}
			i += 1;
		} while (i < (int)menuCol->count);
	}
	globals::g_PausedMenu_TriggerRestart = 0;
	globs::gameGlobs.flags1 |= GAME1_PAUSED;
	save::ObjectRecall_Save_CreateNewObjectRecall();
	return;
}



void __cdecl
lego::front::Front_StructB8_GetGameCompleteWithPoints(SaveData *param_1,char *out_buffer)
{
	uint *puVar1;
	SaveData *pSVar2;
	SaveData *pSVar3;
	int iVar4;
	int iVar5;
	uint index;
	longlong lVar6;
	
	pSVar2 = param_1;
	if (param_1 != NULL) {
		puVar1 = &param_1->count_18;
		iVar5 = 0;
		index = 0;
		param_1 = NULL;
		pSVar3 = NULL;
		if (*puVar1 != 0) {
			iVar4 = 0;
			do {
				lVar6 = Front_StructB8_FUN_00417360(index,pSVar2);
				iVar5 += (int)lVar6;
				if ((*(byte *)((int)pSVar2->table3190_34 + iVar4) & 1) != 0) {
					param_1 = (SaveData *)((int)&param_1->field_0x0 + 1);
				}
				index += 1;
				iVar4 += 0x3190;
				pSVar3 = param_1;
			} while (index < pSVar2->count_18);
		}
		if (pSVar3 != NULL) {
			lVar6 = __ftol(((float10)ZEXT48(pSVar3) / (float10)pSVar2->count_18) * (float10)100.0);
			std::sprintf(out_buffer,"Game %i%% complete with %i points scored",(int)lVar6,iVar5);
		}
	}
	return;
}



void __cdecl lego::front::FrontEnd_UpdateGameSpeedSliderLevel(void)
{
	globals::g_PausedMenu_SliderGameSpeed_0_5 = PausedMenu_CalcSliderGameSpeed();
	return;
}



// WARNING: Type propagation algorithm not settling

BOOL __cdecl FUN_004152a0(float elapsed,int param_2)
{
	SubMenu *pSVar1;
	int iVar2;
	BOOL BVar3;
	MenuCollection *pMVar4;
	uint uVar5;
	
	uVar5 = 1;
	lego::front::FrontEnd_UpdateGameSpeedSliderLevel();
	pMVar4 = lego::globals::menu::g_PausedMenu;
	if ((param_2 != 0) && (pMVar4 = lego::globals::menu::g_OptionsMenu, param_2 != 1)) {
		return TRUE;
	}
	if (((((DAT_004dc8e0 != NULL) && (lego::globals::g_PausedMenu_TriggerRestart == 0)) &&
			 (lego::globals::g_PausedMenu_TriggerQuit == 0)) &&
			((lego::globals::g_PausedMenu_TriggerReplayObjective == 0 &&
			 (PTRMenuCollection_004dc8e4 == pMVar4)))) &&
		 (BVar3 = lego::game::Objective_Level_IsObjectiveFinished(), BVar3 == 0)) {
LAB_0041535f:
		BVar3 = lego::game::Objective_Level_IsObjectiveFinished();
		if (BVar3 == 0) {
			DAT_004dc8e0 = lego::front::SaveMenu_FUN_00412b30(elapsed,DAT_004dc8e0,NULL);
		}
		if (param_2 != 0) {
			if (param_2 == 1) {
				iVar2 = (*pMVar4->menus)->field_28;
				(*pMVar4->menus)->field_28 = 0;
				uVar5 = (uint)(iVar2 == 1);
			}
			return uVar5;
		}
		uVar5 = 1;
		pSVar1 = *pMVar4->menus;
		if ((pSVar1->field_28 != 1) && (pMVar4->menus[2]->field_28 != 1)) {
			uVar5 = 0;
		}
		pSVar1->field_28 = 0;
		pMVar4->menus[2]->field_28 = 0;
		return uVar5;
	}
	lego::globals::g_PausedMenu_TriggerQuit = 0;
	DAT_004dc8e0 = (SubMenu *)((SubMenu *)pMVar4->menus)->ptr_0;
	PTRMenuCollection_004dc8e4 = pMVar4;
	if (lego::globals::g_PausedMenu_TriggerReplayObjective == 0) {
		if (lego::globals::g_PausedMenu_TriggerRestart != 1) goto LAB_0041535f;
	}
	else {
		if (*pMVar4->menus != NULL) {
			(*pMVar4->menus)->field_28 = 1;
		}
		if (pMVar4->menus[2] != NULL) {
			pMVar4->menus[2]->field_28 = 1;
		}
		if (param_2 == 0) {
			lego::globals::g_PausedMenu_TriggerReplayObjective = 0;
			return 0;
		}
	}
	return 0;
}



// levelKey is either "StartLevel" or "TutorialStartLevel"

BOOL __cdecl
lego::front::LevelCollection_Load(CFGProperty *root,LevelCollection *levelCol,char *levelKey)
{
	uint length;
	char **ppcVar1;
	LevelIdentifier **ppLVar2;
	BOOL *pBVar3;
	char *fullName;
	uint uVar4;
	int i;
	uint count;
	char *nextName;
	
	nextName = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main",levelKey,0);
	nextName = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,nextName);
	if (nextName == NULL) {
		return 0;
	}
	count = 1;
										// MEMORY LEAKS!! MEMORY LEAKS EVERYWHERE!!!
	nextName = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,nextName,"NextLevel",0);
	for (nextName = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,nextName); nextName != NULL;
			nextName = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,nextName)) {
		count += 1;
		nextName = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,nextName,"NextLevel",0);
	}
	length = count * 4;
	levelCol->count = count;
	ppcVar1 = (char **)std::malloc(length);
	levelCol->LevelNames = ppcVar1;
	ppcVar1 = (char **)std::malloc(length);
	levelCol->FullNames = ppcVar1;
	ppLVar2 = (LevelIdentifier **)std::malloc(length);
	levelCol->LevelList = ppLVar2;
	for (uVar4 = count & 0x3fffffff; uVar4 != 0; uVar4 -= 1) {
		*ppLVar2 = NULL;
		ppLVar2 = ppLVar2 + 1;
	}
	for (i = 0; i != 0; i += -1) {
		*(undefined *)ppLVar2 = 0;
		ppLVar2 = (LevelIdentifier **)((int)ppLVar2 + 1);
	}
	pBVar3 = (BOOL *)std::malloc(length);
	levelCol->IsLinked = pBVar3;
	for (count &= 0x3fffffff; count != 0; count -= 1) {
		*pBVar3 = 0;
		pBVar3 = pBVar3 + 1;
	}
	for (i = 0; i != 0; i += -1) {
		*(undefined *)pBVar3 = 0;
		pBVar3 = (BOOL *)((int)pBVar3 + 1);
	}
	if (levelCol->LevelNames != NULL) {
		if (levelCol->FullNames != NULL) {
			nextName = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main",levelKey,0);
			nextName = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,nextName);
			*levelCol->LevelNames = nextName;
			nextName = *levelCol->LevelNames;
			fullName = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,nextName,"FullName",0);
			fullName = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,fullName);
			*levelCol->FullNames = fullName;
			if (*levelCol->FullNames == NULL) {
				fullName = std::_strdup2(*levelCol->LevelNames);
				*levelCol->FullNames = fullName;
			}
			else {
				util::stringReplaceChar(*levelCol->FullNames,'_',' ');
			}
			i = 1;
			if (1 < levelCol->count) {
				do {
					nextName = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,nextName,"NextLevel",0);
					nextName = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,nextName);
					levelCol->LevelNames[i] = nextName;
					nextName = levelCol->LevelNames[i];
					fullName = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,nextName,"FullName",0);
					fullName = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,fullName);
					levelCol->FullNames[i] = fullName;
					if (levelCol->FullNames[i] == NULL) {
						fullName = std::_strdup2(levelCol->LevelNames[i]);
						levelCol->FullNames[i] = fullName;
					}
					else {
						util::stringReplaceChar(levelCol->FullNames[i],'_',' ');
					}
					i += 1;
				} while (i < levelCol->count);
			}
			return TRUE;
		}
		return 0;
	}
	return 0;
}



void __cdecl lego::video::VideoPlayer_Play(VideoPlayer_t *videoPlayer,BOOL isSkippable)
{
	BOOL BVar1;
	uint uVar2;
	ulonglong uVar3;
	float local_1c;
	RECT rect;
	
										// HARDCODED SCREEN RESOLUTION!!
	rect.left = 0;
	rect.top = 0;
	rect.right = 640;
	rect.bottom = 480;
	local_1c = 0.0;
	BVar1 = VideoPlayer_Update(videoPlayer,1.0,&rect);
	if (BVar1 != 0) {
		while( true ) {
			main::Main_LoopUpdate(0);
			local_1c = local_1c - -1.0;
			uVar3 = VideoPlayer_GetLength(videoPlayer);
			if ((float)(uVar3 & 0xffffffff) < local_1c) break;
			if (isSkippable != 0) {
				uVar2 = input::Input_AnyKeyPressed();
				if (uVar2 != 0) {
					return;
				}
				if (globs::INPUT.msrb != 0) {
					return;
				}
				if (globs::INPUT.mslb != 0) {
					return;
				}
			}
			BVar1 = VideoPlayer_Update(videoPlayer,1.0,&rect);
			if (BVar1 == 0) {
				return;
			}
		}
	}
	return;
}



void __cdecl lego::main::Boot_PlayIntroImage(char *imageKeyName,BOOL isSkippable,char *timeKeyName)
{
	char *pcVar1;
	DWORD DVar2;
	ImageBMP *image;
	DWORD DVar3;
	uint uVar4;
	float10 fVar5;
	longlong lVar6;
	
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main",timeKeyName,0);
	pcVar1 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar1);
	if (pcVar1 == NULL) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main",timeKeyName,0);
		pcVar1 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar1);
	}
	fVar5 = std::atof(pcVar1);
	timeKeyName = (char *)(float)fVar5;
	if ((float)timeKeyName == 0.0) {
		timeKeyName = (char *)0x40400000;
	}
	DVar2 = timeGetTime();
	lVar6 = __ftol((float10)(float)timeKeyName * (float10)-1000.0);
	if (imageKeyName != NULL) {
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main",imageKeyName,0);
		pcVar1 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar1);
		if ((pcVar1 != NULL) && (image = lego::image::Image_LoadBMPScaled(pcVar1,0,0), image != NULL)) {
			while( true ) {
				lego::image::Image_DisplayScaled(image,NULL,NULL,NULL);
				Main_LoopUpdate(0);
				Sleep(100);
				DVar3 = timeGetTime();
				if (DVar2 - (int)lVar6 <= DVar3) break;
				if ((isSkippable != 0) &&
					 (((uVar4 = input::Input_AnyKeyPressed(), uVar4 != 0 || (globs::INPUT.msrb != 0)) ||
						(globs::INPUT.mslb != 0)))) break;
			}
			lego::image::Image_Remove(image);
		}
	}
	return;
}



void __cdecl lego::main::Boot_PlayIntroAVI(char *aviKeyName,BOOL isSkippable)
{
	char *pcVar1;
	BOOL BVar2;
	VideoPlayer_t *videoPlayer;
	
	if (aviKeyName != NULL) {
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main",aviKeyName,0);
		pcVar1 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar1);
		if (pcVar1 != NULL) {
			BVar2 = lego::file::File_Exists(pcVar1);
			if (BVar2 != 0) {
				videoPlayer = video::VideoPlayer_Load(pcVar1);
				video::VideoPlayer_Play(videoPlayer,isSkippable);
				video::VideoPlayer_Free(videoPlayer);
				std::free(pcVar1);
			}
		}
	}
	return;
}



void __cdecl lego::game::Level_DoVideo__004158c0(char *levelName,int param_2)
{
	char *pcVar1;
	BOOL BVar2;
	VideoPlayer_t *videoPlayer;
	
	if (levelName != NULL) {
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"Video",0);
		pcVar1 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar1);
		if (pcVar1 != NULL) {
			BVar2 = lego::file::File_Exists(pcVar1);
			if (BVar2 != 0) {
				videoPlayer = video::VideoPlayer_Load(pcVar1);
				video::VideoPlayer_Play(videoPlayer,param_2);
				video::VideoPlayer_Free(videoPlayer);
			}
			std::free(pcVar1);
		}
	}
	return;
}



// WARNING: Type propagation algorithm not settling

void __cdecl lego::front::Menu_LoadAllMissions(MenuCollection *mainMenuCol)
{
	int iVar1;
	int iVar2;
	int iVar3;
	MenuItemMissions *missions;
	MenuItem *pMVar4;
	MenuItemMissions *missions_00;
	char *pcVar7;
	int iVar8;
	SaveData *pSVar9;
	undefined4 uVar10;
	int iVar11;
	code *pcVar12;
	char buff [100];
	MenuItem *pcVar6;
	MenuItem *pcVar5;
	
	globals::g_StartMissionLevel =
			 LevelCollection_LoadLinks(&globals::g_MissionLevels,*globals::g_MissionLevels.LevelNames);
	globals::g_StartTutorialLevel =
			 LevelCollection_LoadLinks(&globals::g_TutorialLevels,*globals::g_TutorialLevels.LevelNames);
	LevelCollections_ClearAllLinks();
	iVar1 = Menu_GetSubMenuIDByName(globals::menu::g_MainMenuFull,"Levels");
	iVar2 = Menu_GetSubMenuIDByName(globals::menu::g_MainMenuFull,"Tutorials");
	iVar3 = Menu_GetSubMenuIDByName(globals::menu::g_MainMenuFull,"Load Level Save");
	missions = Menu_CreateMissionsDisplay
											 (&globals::g_MenuMenuFull_MissionsTutorial,____EMPTYSTR__,____EMPTYSTR__,-200
												,-100,60,5,-20,200,-20,-40,0,Front_TutorialsCallback_FUN_00414fe0,
												globals::menu::g_MainMenuFull->menus[iVar1]);
	pcVar5 = (MenuItem *)globals::menu::g_MainMenuFull->menus[iVar3]->Items->banner;
	pMVar4 = Menu_CreateBannerItem
										 (____EMPTYSTR__,pcVar5->LoFont,pcVar5->HiFont,0,0,MENUITEM_MISSIONS,TRUE,
											missions,FALSE);
	Menu_AddSubMenuItem(globals::menu::g_MainMenuFull->menus[iVar3],pMVar4);
	missions_00 = Menu_CreateMissionsDisplay
													(&globals::g_MenuMenuFull_MissionsTutorial,____EMPTYSTR__,____EMPTYSTR__,
													 -200,-100,60,5,-20,200,-20,-40,0,Front_TutorialsCallback_FUN_00414fe0,0);
	pcVar6 = (MenuItem *)globals::menu::g_MainMenuFull->menus[iVar3]->Items->banner;
	pMVar4 = Menu_CreateBannerItem
										 (____EMPTYSTR__,pcVar6->LoFont,pcVar6->HiFont,0,0,MENUITEM_MISSIONS,TRUE,
											missions_00,FALSE);
	Menu_AddSubMenuItem(*globals::menu::g_SaveMenu->menus,pMVar4);
	iVar8 = 0;
	pSVar9 = globals::g_Struct_b8_TABLE__00558080;
	do {
		iVar8 += 1;
		iVar11 = iVar8;
		pcVar7 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu","Save_Game",0);
		pcVar7 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar7);
		std::sprintf(buff,"%s %i",pcVar7,iVar11);
		util::stringReplaceChar(buff,'_',' ');
		Front_StructB8_GetGameCompleteWithPoints(pSVar9,buff);
		Missions_AddLevel(missions,buff,TRUE,
											*(ImageFont **)
											 (globals::menu::g_MainMenuFull->menus[iVar3]->Items->banner + 8),0,0,0);
		Missions_AddLevel(missions_00,buff,TRUE,
											*(ImageFont **)
											 (globals::menu::g_MainMenuFull->menus[iVar3]->Items->banner + 8),0,0,0);
		pSVar9 = pSVar9 + 1;
	} while ((int)pSVar9 < 0x558418);
	save::Front_StructB8_HasClearSaves_FUN_00417d20();
	pcVar12 = unk::lego_uses_testercall_FUN_00417390;
	uVar10 = 0;
	pSVar9 = save::Save_GetCurrentSaveNumber_StructB8();
	MainMenuFull_AddMissionsDisplay
						(4,globals::g_StartMissionLevel,(int *)&globals::g_MissionLevels,
						 globals::menu::g_MainMenuFull->menus[iVar1],pSVar9,uVar10,pcVar12);
	pcVar12 = Missions_MenuItemCallback;
	uVar10 = 0;
	pSVar9 = save::Save_GetCurrentSaveNumber_StructB8();
	MainMenuFull_AddMissionsDisplay
						(5,globals::g_StartTutorialLevel,(int *)&globals::g_TutorialLevels,
						 globals::menu::g_MainMenuFull->menus[iVar2],pSVar9,uVar10,pcVar12);
	return;
}



void __cdecl lego::save::Save_ClearSaveNumber(void)
{
	globals::g_SaveNumber = -1;
	return;
}



void __cdecl
lego::front::MenuTextWindow_Load(CFGProperty *root,char *rootPath,MenuTextWindow *menuWnd)
{
	char cVar1;
	char *pcVar2;
	int iVar3;
	TextWindow *pTVar4;
	ImageBMP *pIVar5;
	uint uVar6;
	uint uVar7;
	undefined4 *puVar8;
	char *pcVar9;
	undefined4 *puVar10;
	Rect2F local_24;
	char *local_14;
	char *local_10;
	char *local_c;
	char *local_8;
	char *local_4;
	
	local_24.y = 0.0;
	local_24.width = 0.0;
	local_24.x = 0.0;
	local_24.height = 0.0;
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,rootPath,"Load",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 -= 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = (undefined4 *)menuWnd->LoadText;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,rootPath,"Save",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 -= 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = (undefined4 *)menuWnd->SaveText;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,rootPath,"Slot",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 -= 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = (undefined4 *)menuWnd->SlotText;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,rootPath,"SaveSel",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 -= 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = (undefined4 *)menuWnd->SaveSelText;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,rootPath,"LoadSel",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 -= 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = (undefined4 *)menuWnd->LoadSelText;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,rootPath,"Level",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 -= 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = (undefined4 *)menuWnd->LevelText;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,rootPath,"Tutorial",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar6 = 0xffffffff;
		do {
			pcVar9 = pcVar2;
			if (uVar6 == 0) break;
			uVar6 -= 1;
			pcVar9 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar9;
		} while (cVar1 != '\0');
		uVar6 = ~uVar6;
		puVar8 = (undefined4 *)(pcVar9 + -uVar6);
		puVar10 = (undefined4 *)menuWnd->TutorialText;
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,rootPath,"Window",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		iVar3 = util::Util_Tokenise(pcVar2,&local_14,"|");
		if (iVar3 == 4) {
			iVar3 = std::atoi(local_14);
			local_24.x = (float)iVar3;
			(menuWnd->WindowArea).x = local_24.x;
			iVar3 = std::atoi(local_10);
			local_24.y = (float)iVar3;
			(menuWnd->WindowArea).y = local_24.y;
			iVar3 = std::atoi(local_c);
			local_24.width = (float)iVar3;
			(menuWnd->WindowArea).width = local_24.width;
			iVar3 = std::atoi(local_8);
			local_24.height = (float)iVar3;
			(menuWnd->WindowArea).height = local_24.height;
			pTVar4 = TextWindow_Create(globs::gameGlobs.bmpFONT5_HI,&local_24,0x200);
			menuWnd->textWindow = pTVar4;
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,rootPath,"Panel",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		iVar3 = util::Util_Tokenise(pcVar2,&local_14,"|");
		if ((iVar3 == 5) && (local_14 != NULL)) {
			pIVar5 = lego::image::Image_LoadBMPScaled(local_14,0,0);
			menuWnd->PanelImage = pIVar5;
			if (pIVar5 != NULL) {
				iVar3 = std::atoi(local_10);
				(menuWnd->PanelArea).x = (float)iVar3;
				iVar3 = std::atoi(local_c);
				(menuWnd->PanelArea).y = (float)iVar3;
				iVar3 = std::atoi(local_8);
				(menuWnd->PanelArea).width = (float)iVar3;
				iVar3 = std::atoi(local_4);
				pIVar5 = menuWnd->PanelImage;
				(menuWnd->PanelArea).height = (float)iVar3;
				lego::image::Image_SetupTrans(pIVar5,0.0,0.0,0.0,0.0,0.0,0.0);
			}
		}
	}
	return;
}



BOOL __cdecl FUN_00416080(int levelNumber)
{
	BOOL BVar1;
	SFXType local_84;
	char local_80 [128];
	
	std::sprintf(local_80,"Stream_LevelName_Level%d",levelNumber);
	BVar1 = lego::snd::SFX_GetType(local_80,&local_84);
	if (BVar1 != 0) {
		BVar1 = lego::snd::SFX_Sample_Random_SetAndPlayGlobalSample(local_84,NULL);
	}
	return BVar1;
}



BOOL __cdecl FUN_004160d0(int levelNumber)
{
	BOOL BVar1;
	SFXType local_84;
	char local_80 [128];
	
	std::sprintf(local_80,"Stream_LevelName_TLevel%d",levelNumber);
	BVar1 = lego::snd::SFX_GetType(local_80,&local_84);
	if (BVar1 != 0) {
		BVar1 = lego::snd::SFX_Sample_Random_SetAndPlayGlobalSample(local_84,NULL);
	}
	return BVar1;
}



void __cdecl lego::front::Menu_LoadMenus(CFGProperty *root)
{
	char cVar1;
	char *pcVar2;
	int iVar3;
	char *pcVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	MenuTextWindow *pMVar8;
	char *pcVar9;
	undefined4 *puVar10;
	undefined uVar11;
	
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu","MenuWipe",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu","!MenuWipe",0);
		pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
		if (pcVar2 == NULL) goto LAB_004161da;
		if ((globs::mainGlobs.flags & CMD_REDUCEANIMATION) == CMD_NONE) {
			iVar3 = std::_strnicmp(pcVar2,"Null",4);
			goto joined_r0x004161b8;
		}
	}
	else {
		iVar3 = std::_strnicmp(pcVar2,"Null",4);
joined_r0x004161b8:
		if (iVar3 != 0) {
			globals::g_MenuWipeResource = res::Container_Load(NULL,pcVar2,"LWS",1);
		}
	}
	std::free(pcVar2);
LAB_004161da:
	globals::g_MenuSaveTextWindow = (MenuTextWindow *)std::malloc(0x728);
	pMVar8 = globals::g_MenuSaveTextWindow;
	for (iVar3 = 0x1ca; iVar3 != 0; iVar3 += -1) {
		pMVar8->textWindow = NULL;
		pMVar8 = (MenuTextWindow *)&pMVar8->PanelImage;
	}
	MenuTextWindow_Load(root,"Menu::SaveText",globals::g_MenuSaveTextWindow);
	globals::g_MenuSaveLevelWindow = (MenuTextWindow *)std::malloc(0x728);
	pMVar8 = globals::g_MenuSaveLevelWindow;
	for (iVar3 = 0x1ca; iVar3 != 0; iVar3 += -1) {
		pMVar8->textWindow = NULL;
		pMVar8 = (MenuTextWindow *)&pMVar8->PanelImage;
	}
	MenuTextWindow_Load(root,"Menu::LevelText",globals::g_MenuSaveLevelWindow);
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu","Save_Game",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		pcVar4 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar9 = pcVar4;
			if (uVar5 == 0) break;
			uVar5 -= 1;
			pcVar9 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar9;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar9 + -uVar5);
		puVar10 = (undefined4 *)globals::menu::g_Menu_SaveGame_text;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
			*puVar10 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu","Load_Game",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		pcVar4 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar9 = pcVar4;
			if (uVar5 == 0) break;
			uVar5 -= 1;
			pcVar9 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar9;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar9 + -uVar5);
		puVar10 = (undefined4 *)globals::menu::g_Menu_LoadGame_text;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
			*puVar10 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu::Overwrite","Title",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		pcVar4 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar9 = pcVar4;
			if (uVar5 == 0) break;
			uVar5 -= 1;
			pcVar9 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar9;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar9 + -uVar5);
		puVar10 = (undefined4 *)globals::menu::g_Overwrite_Title;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
			*puVar10 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu::Overwrite","Text",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		pcVar4 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar9 = pcVar4;
			if (uVar5 == 0) break;
			uVar5 -= 1;
			pcVar9 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar9;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar9 + -uVar5);
		puVar10 = (undefined4 *)globals::menu::g_Overwrite_Text;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
			*puVar10 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu::Overwrite","Ok",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar4 = pcVar2;
			if (uVar5 == 0) break;
			uVar5 -= 1;
			pcVar4 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar4;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar4 + -uVar5);
		puVar10 = (undefined4 *)globals::menu::g_Overwrite_Ok;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
			*puVar10 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu::Overwrite","Cancel",0);
	pcVar2 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = util::replaceTextSpaces(pcVar2);
		uVar5 = 0xffffffff;
		do {
			pcVar4 = pcVar2;
			if (uVar5 == 0) break;
			uVar5 -= 1;
			pcVar4 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar4;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		puVar7 = (undefined4 *)(pcVar4 + -uVar5);
		puVar10 = (undefined4 *)globals::menu::g_Overwrite_Cancel;
		for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
			*puVar10 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar10 = puVar10 + 1;
		}
		for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	FONT_00558078 = globs::gameGlobs.bmpMbriefFONT2;
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","Version",0);
	globals::g_Main_Version = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu","DefaultLevelBMPS",0);
	globals::g_Menu_DefaultLevelBMPS = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar2);
	PTR_005584fc = res::Container_MakeLight
													 (globs::gameGlobs.resRoot,D3DRMLIGHT_DIRECTIONAL,0.8,0.8,0.8);
	res::Container_Hide(PTR_005584fc,1);
	uVar11 = SUB41(root,0);
	globals::menu::g_MainMenuFull =
			 Menu_ParseMenu(uVar11,"MainMenuFull",&globals::g_MainMenuFull_TriggerCredits,
											MainMenuFull_TriggerShowCredits,&globals::g_MainMenuFull_TriggerYesQuit,0,
											0xffffffff);
	globals::menu::g_SaveMenu =
			 Menu_ParseMenu(uVar11,"SaveMenu",&globals::g_SaveMenu_TriggerBack,SaveMenu_TriggerBack,
											0xffffffff);
	LevelCollection_Load(globs::gameGlobs.LegoCfgRoot,&globals::g_MissionLevels,"StartLevel");
	LevelCollection_Load(globs::gameGlobs.LegoCfgRoot,&globals::g_TutorialLevels,"TutorialStartLevel")
	;
	Menu_LoadAllMissions(globals::menu::g_MainMenuFull);
	globals::menu::g_PausedMenu =
			 Menu_ParseMenu(uVar11,"PausedMenu",&globals::g_PausedMenu_TriggerContinue,NULL,
											&globals::g_PausedMenu_SliderGameSpeed_0_5,PausedMenu_SliderGameSpeed,
											&globals::g_PausedMenu_SliderSoundVolume_0_10,PausedMenu_SliderSoundVolume,
											&globals::g_PausedMenu_SliderMusicVolume_0_10,PausedMenu_SliderMusicVolume,
											&globals::g_PausedMenu_SliderBrightness_0_10,PausedMenu_SliderBrightness,
											&globals::g_PausedMenu_CycleHelpWindow_Off_On,PausedMenu_CycleHelpWindow,
											&globals::g_PausedMenu_TriggerReplayObjective,
											PausedMenu_TriggerReplayObjective,&globals::g_PausedMenu_TriggerQuit,0,
											&globals::g_PausedMenu_TriggerRestart,0,
											&globals::g_PausedMenu_CycleWallDetail_High_Low,PausedMenu_CycleWallDetail,
											&globals::g_PausedMenu_CycleMusic_On_Off,PausedMenu_CycleMusic,
											&globals::g_PausedMenu_CycleSound_On_Off,PausedMenu_CycleSound,
											&globals::g_PausedMenu_CycleAutoGameSpeed_On_Off,PausedMenu_CycleAutoGameSpeed
											,0xffffffff);
	globals::menu::g_OptionsMenu =
			 Menu_ParseMenu(uVar11,"OptionsMenu",&globals::g_PausedMenu_SliderGameSpeed_0_5,
											PausedMenu_SliderGameSpeed,&globals::g_PausedMenu_SliderSoundVolume_0_10,
											PausedMenu_SliderSoundVolume,&globals::g_PausedMenu_SliderMusicVolume_0_10,
											PausedMenu_SliderMusicVolume,&globals::g_PausedMenu_SliderBrightness_0_10,
											PausedMenu_SliderBrightness,&globals::g_PausedMenu_CycleHelpWindow_Off_On,
											PausedMenu_CycleHelpWindow,&globals::g_PausedMenu_TriggerReplayObjective,
											PausedMenu_TriggerReplayObjective,&globals::g_PausedMenu_TriggerContinue,0,
											0xffffffff);
	globals::g_PausedMenu_SliderSoundVolume_0_10 = 8;
	globals::g_PausedMenu_TriggerContinue = 0;
	globals::g_PausedMenu_SliderBrightness_0_10 = 5;
	globals::g_PausedMenu_CycleHelpWindow_Off_On = 1;
	globals::g_PausedMenu_TriggerReplayObjective = 0;
	globals::g_PausedMenu_SliderGameSpeed_0_5 = PausedMenu_CalcSliderGameSpeed();
	globals::g_PausedMenu_SliderMusicVolume_0_10 = PausedMenu_CalcSliderCDVolume();
	BOOL_00558500 = 0;
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu","MaxLevelScreens",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu","MaxLevelScreens",0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	}
	globals::g_Menu_MaxLevelScreens = std::atoi(pcVar2);
	if (globals::g_Menu_MaxLevelScreens == 0) {
		globals::g_Menu_MaxLevelScreens = 1;
	}
	DAT_00558824 = 0;
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu","SaveImage","BigWidth",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu","SaveImage","BigWidth",0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	}
	globals::g_Menu_SaveImage_BigSize.width = std::atoi(pcVar2);
	if (globals::g_Menu_SaveImage_BigSize.width == 0) {
		globals::g_Menu_SaveImage_BigSize.width = 0x50;
	}
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu","SaveImage","BigHeight",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu","SaveImage","BigHeight",0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	}
	globals::g_Menu_SaveImage_BigSize.height = std::atoi(pcVar2);
	if (globals::g_Menu_SaveImage_BigSize.height == 0) {
		globals::g_Menu_SaveImage_BigSize.height = 0x3c;
	}
	Front_SetBool_0055881c(1);
	return;
}



void __cdecl lego::front::PausedMenu_UpdateUnkStruct_FromSliderValues(void)
{
	SaveData *pSVar1;
	
	pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
	if (pSVar1 != NULL) {
		pSVar1->SliderGameSpeed = globals::g_PausedMenu_SliderGameSpeed_0_5;
		pSVar1->SliderSoundVolume = globals::g_PausedMenu_SliderSoundVolume_0_10;
		pSVar1->SliderBrightness = globals::g_PausedMenu_SliderBrightness_0_10;
	}
	return;
}



void __cdecl lego::front::Front_FUN_00416870(BOOL param_1,BOOL param_2)
{
	SaveData *pSVar1;
	
	if (param_2 != 0) {
		globals::g_MainMenuFull_TriggerYesQuit = 0;
		globals::g_Menu_LabelUnkValue_1 = -1;
		globals::g_MenuMenuFull_MissionsNormal = -1;
		globals::g_PausedMenu_TriggerContinue = 0;
	}
	if (param_1 != 0) {
		if (globals::g_MenuMenuFull_MissionsTutorial != -1) {
			pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
			if (pSVar1 != NULL) {
				pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
				globals::g_PausedMenu_SliderGameSpeed_0_5 = pSVar1->SliderGameSpeed;
				globals::g_PausedMenu_SliderSoundVolume_0_10 = pSVar1->SliderSoundVolume;
				globals::g_PausedMenu_SliderBrightness_0_10 = pSVar1->SliderBrightness;
				return;
			}
		}
										// 100%(?)
		globals::g_PausedMenu_SliderGameSpeed_0_5 = 1;
		globals::g_PausedMenu_SliderSoundVolume_0_10 = 8;
		globals::g_PausedMenu_SliderBrightness_0_10 = 5;
	}
	return;
}



void __cdecl lego::front::Menu_FUN_004168f0(int menuId)
{
	SaveData *pSVar1;
	void *pvVar2;
	LevelCollection *pLVar3;
	MenuItemTrigger *pMVar4;
	undefined4 uVar5;
	
	switch(menuId) {
	case 0:
		globals::g_MenuMenuFull_MissionsTutorial = -1;
		Front_FUN_00416870(TRUE,TRUE);
		pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
		if (pSVar1 == NULL) {
			if (BOOL_0055881c != 0) {
				LevelIdentifier_FUN_00417310
									(globals::g_StartMissionLevel,0,&globals::g_MissionLevels,
									 *(MenuItemTrigger **)
										(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10),1);
			}
		}
		else {
LAB_00416af1:
			uVar5 = 0;
			pMVar4 = *(MenuItemTrigger **)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
			pLVar3 = &globals::g_MissionLevels;
			pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
			LevelIdentifier_FUN_00417310
								(globals::g_StartMissionLevel,(int)pSVar1->table3190_34,pLVar3,pMVar4,uVar5);
		}
		break;
	case 1:
		Front_FUN_00416870(TRUE,TRUE);
		pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
		if (pSVar1 == NULL) {
			if (BOOL_0055881c == 0) goto LAB_004169dd;
			uVar5 = 1;
			pMVar4 = *(MenuItemTrigger **)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
			pLVar3 = &globals::g_MissionLevels;
			pvVar2 = NULL;
		}
		else {
			uVar5 = 0;
			pMVar4 = *(MenuItemTrigger **)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
			pLVar3 = &globals::g_MissionLevels;
			pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
			pvVar2 = pSVar1->table3190_34;
		}
		LevelIdentifier_FUN_00417310(globals::g_StartMissionLevel,(int)pvVar2,pLVar3,pMVar4,uVar5);
LAB_004169dd:
		LevelIdentifier_FUN_00417310
							(globals::g_StartTutorialLevel,0,&globals::g_TutorialLevels,
							 *(MenuItemTrigger **)(globals::menu::g_MainMenuFull->menus[2]->Items->length + 0x10),
							 0);
		Front_SetBool_0055881c(1);
		return;
	case 2:
		Front_FUN_00416870(1,1);
		pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
		if (pSVar1 == NULL) {
			if (BOOL_0055881c == 0) goto LAB_00416a8d;
			uVar5 = 1;
			pMVar4 = *(MenuItemTrigger **)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
			pLVar3 = &globals::g_MissionLevels;
			pvVar2 = NULL;
		}
		else {
			uVar5 = 0;
			pMVar4 = *(MenuItemTrigger **)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
			pLVar3 = &globals::g_MissionLevels;
			pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
			pvVar2 = pSVar1->table3190_34;
		}
		LevelIdentifier_FUN_00417310(globals::g_StartMissionLevel,(int)pvVar2,pLVar3,pMVar4,uVar5);
LAB_00416a8d:
		LevelIdentifier_FUN_00417310
							(globals::g_StartTutorialLevel,0,&globals::g_TutorialLevels,
							 *(MenuItemTrigger **)(globals::menu::g_MainMenuFull->menus[2]->Items->length + 0x10),
							 0);
		Front_SetBool_0055881c(1);
		return;
	case 3:
		Front_FUN_00416870(0,1);
		Front_SetBool_0055881c(1);
		return;
	case 4:
		Front_FUN_00416870(0,1);
		pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
		if (pSVar1 != NULL) goto LAB_00416af1;
		if (BOOL_0055881c != 0) {
			LevelIdentifier_FUN_00417310
								(globals::g_StartMissionLevel,0,&globals::g_MissionLevels,
								 *(MenuItemTrigger **)
									(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10),1);
			BOOL_00558500 = TRUE;
		}
		break;
	default:
		goto switchD_004168fd_caseD_5;
	}
	LevelIdentifier_FUN_00417310
						(globals::g_StartTutorialLevel,0,&globals::g_TutorialLevels,
						 *(MenuItemTrigger **)(globals::menu::g_MainMenuFull->menus[2]->Items->length + 0x10),0)
	;
switchD_004168fd_caseD_5:
	Front_SetBool_0055881c(1);
	return;
}



BOOL __cdecl lego::front::Front_RunScreenMenuType(ScreenMenuType screenMenuType)
{
	MenuCollection *menuCol;
	int submenuIndex;
	
	menuCol = globals::menu::g_MainMenuFull;
	Menu_FUN_004168f0(screenMenuType);
	snd::SFX_Sample_AddToQueue(SFX_AMBIENTMUSICLOOP,TRUE);
	if (true) {
		switch(screenMenuType) {
		case MENU_SCREEN_TITLE:
										// MainMenuFull::Menu1 "Main"
			submenuIndex = 0;
			break;
		case MENU_SCREEN_MISSIONS:
										// MainMenuFull::Menu2 "Missions"
			submenuIndex = 1;
			break;
		case MENU_SCREEN_TRAINING:
										// MainMenuFull::Menu3 "Training_Missions"
			submenuIndex = 2;
			break;
		default:
			goto switchD_00416bd6_caseD_3;
		case MENU_SCREEN_SAVE:
										// SaveMenu::Menu1 "Load_A_Saved_Game"  (save a game)
			submenuIndex = 0;
			menuCol = globals::menu::g_SaveMenu;
		}
		Front_RunScreenMenu(menuCol,submenuIndex);
	}
switchD_00416bd6_caseD_3:
	snd::Sound3D_Stream_Stop(TRUE);
	snd::Sound3D_Stream_Stop(FALSE);
	return 0;
}



BOOL __cdecl lego::main::Config_IsFrontEndEnabled(void)
{
	char *keyPath;
	BOOL3 BVar1;
	
	keyPath = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","FrontEnd",0);
	BVar1 = cfg::CFG_ReadBool(globs::gameGlobs.LegoCfgRoot,keyPath);
	if ((BVar1 == BOOL3_TRUE) && (globs::mainGlobs.programmerLevel < PROGRAMMER_MODE_3)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::unk::Lego_GetIntNotM1__00558020(void)
{
	return (uint)(globals::g_Menu_LabelUnkValue_1 != -1);
}



BOOL __cdecl lego::front::Front_GetUnkTutoOrMissions(void)
{
	return (uint)(globals::g_MenuMenuFull_MissionsNormal != -1);
}



char * __cdecl lego::front::Front_GetSelectedLevel(void)
{
	BOOL BVar1;
	int iVar2;
	
	BVar1 = unk::Lego_GetIntNotM1__00558020();
	if (BVar1 == 0) {
		BVar1 = Front_GetUnkTutoOrMissions();
		if (BVar1 == 0) {
			return NULL;
		}
		iVar2 = LevelIdentifier_FUN_00417200
											(globals::g_StartTutorialLevel,globals::g_MenuMenuFull_MissionsNormal);
		if (iVar2 != -1) {
			return globals::g_TutorialLevels.LevelNames[iVar2];
		}
	}
	else {
		iVar2 = LevelIdentifier_FUN_00417200
											(globals::g_StartMissionLevel,globals::g_Menu_LabelUnkValue_1);
		if (iVar2 != -1) {
			return globals::g_MissionLevels.LevelNames[iVar2];
		}
	}
	return NULL;
}



int __cdecl lego::front::Front_IsTriggerAppQuit(void)
{
	return globals::g_MainMenuFull_TriggerYesQuit;
}



BOOL __cdecl lego::front::Front_IsTriggerMissionQuit(void)
{
	return (uint)(globals::g_PausedMenu_TriggerQuit != 0);
}



BOOL __cdecl lego::front::Front_IsTriggerMissionRestart(void)
{
	return (uint)(globals::g_PausedMenu_TriggerRestart != 0);
}



LevelCollection * __cdecl lego::front::LevelCollections_GetTutorialOrMissions(void)
{
	BOOL BVar1;
	LevelCollection *pLVar2;
	
	BVar1 = Front_GetUnkTutoOrMissions();
	pLVar2 = &globals::g_TutorialLevels;
	if (BVar1 == 0) {
		pLVar2 = &globals::g_MissionLevels;
	}
	return pLVar2;
}



int __cdecl lego::front::LevelCollection_IndexOf(LevelCollection *levelCol,char *levelName)
{
	int cmp;
	int i;
	
	i = 0;
	if (levelCol->count < 1) {
		return -1;
	}
	do {
		cmp = std::_stricmp(levelName,levelCol->LevelNames[i]);
		if (cmp == 0) {
			return i;
		}
		i += 1;
	} while (i < levelCol->count);
	return -1;
}



void __cdecl lego::front::LevelCollections_ClearAllLinks(void)
{
	int iVar1;
	
	iVar1 = 0;
	if (0 < globals::g_MissionLevels.count) {
		do {
			if (globals::g_MissionLevels.LevelList[iVar1] != NULL) {
				globals::g_MissionLevels.LevelList[iVar1]->field_10 = 0;
				globals::g_MissionLevels.IsLinked[iVar1] = 0;
			}
			iVar1 += 1;
		} while (iVar1 < globals::g_MissionLevels.count);
	}
	iVar1 = 0;
	if (0 < globals::g_TutorialLevels.count) {
		do {
			if (globals::g_TutorialLevels.LevelList[iVar1] != NULL) {
				globals::g_TutorialLevels.LevelList[iVar1]->field_10 = 0;
				globals::g_TutorialLevels.IsLinked[iVar1] = 0;
			}
			iVar1 += 1;
		} while (iVar1 < globals::g_TutorialLevels.count);
	}
	return;
}



void __cdecl
lego::front::LevelCollection_SetLinked(LevelCollection *levelCol,char *levelName,BOOL isLinked)
{
	byte *ptrNext;
	int cmp;
	int i;
	byte *ptrName;
	byte **ppbVar1;
	bool clt;
	byte cnext;
	
	i = 0;
	if (levelCol->count < 1) {
		return;
	}
	ppbVar1 = (byte **)levelCol->LevelNames;
	do {
		ptrNext = *ppbVar1;
		ptrName = (byte *)levelName;
		do {
			cnext = *ptrNext;
			clt = cnext < *ptrName;
			if (cnext != *ptrName) {
LAB_00416e3d:
				cmp = (1 - (uint)clt) - (uint)(clt != 0);
				goto LAB_00416e42;
			}
			if (cnext == 0) break;
			cnext = ptrNext[1];
			clt = cnext < ptrName[1];
			if (cnext != ptrName[1]) goto LAB_00416e3d;
			ptrNext = ptrNext + 2;
			ptrName = ptrName + 2;
		} while (cnext != 0);
		cmp = 0;
LAB_00416e42:
		if (cmp == 0) {
			levelCol->IsLinked[i] = isLinked;
			return;
		}
		i += 1;
		ppbVar1 = ppbVar1 + 1;
		if (levelCol->count <= i) {
			return;
		}
	} while( true );
}



BOOL __cdecl lego::front::LevelCollection_IsLinked(LevelCollection *levelCol,char *levelName)
{
	byte *ptrNext;
	int cmp;
	int i;
	byte *ptrName;
	byte **ppbVar1;
	bool clt;
	byte cnext;
	
	i = 0;
	if (levelCol->count < 1) {
		return 0;
	}
	ppbVar1 = (byte **)levelCol->LevelNames;
	do {
		ptrNext = *ppbVar1;
		ptrName = (byte *)levelName;
		do {
			cnext = *ptrNext;
			clt = cnext < *ptrName;
			if (cnext != *ptrName) {
LAB_00416ead:
				cmp = (1 - (uint)clt) - (uint)(clt != 0);
				goto LAB_00416eb2;
			}
			if (cnext == 0) break;
			cnext = ptrNext[1];
			clt = cnext < ptrName[1];
			if (cnext != ptrName[1]) goto LAB_00416ead;
			ptrNext = ptrNext + 2;
			ptrName = ptrName + 2;
		} while (cnext != 0);
		cmp = 0;
LAB_00416eb2:
		if (cmp == 0) {
			return levelCol->IsLinked[i];
		}
		i += 1;
		ppbVar1 = ppbVar1 + 1;
		if (levelCol->count <= i) {
			return 0;
		}
	} while( true );
}



void __cdecl
lego::front::LevelCollection_SetIdentifier
					(LevelCollection *levelCol,char *levelName,LevelIdentifier *identifier)
{
	byte *ptrNext;
	int cmp;
	int i;
	byte *ptrName;
	byte **ppbVar1;
	bool clt;
	byte cnext;
	
	i = 0;
	if (levelCol->count < 1) {
		return;
	}
	ppbVar1 = (byte **)levelCol->LevelNames;
	do {
		ptrNext = *ppbVar1;
		ptrName = (byte *)levelName;
		do {
			cnext = *ptrNext;
			clt = cnext < *ptrName;
			if (cnext != *ptrName) {
LAB_00416f1d:
				cmp = (1 - (uint)clt) - (uint)(clt != 0);
				goto LAB_00416f22;
			}
			if (cnext == 0) break;
			cnext = ptrNext[1];
			clt = cnext < ptrName[1];
			if (cnext != ptrName[1]) goto LAB_00416f1d;
			ptrNext = ptrNext + 2;
			ptrName = ptrName + 2;
		} while (cnext != 0);
		cmp = 0;
LAB_00416f22:
		if (cmp == 0) {
			levelCol->LevelList[i] = identifier;
			return;
		}
		i += 1;
		ppbVar1 = ppbVar1 + 1;
		if (levelCol->count <= i) {
			return;
		}
	} while( true );
}



LevelIdentifier * __cdecl
lego::front::LevelCollection_GetIdentifier(LevelCollection *levelCol,char *levelName)
{
	byte *ptrNext;
	int cmp;
	int i;
	byte *ptrName;
	byte **ppbVar1;
	bool clt;
	byte cnext;
	
	i = 0;
	if (levelCol->count < 1) {
		return NULL;
	}
	ppbVar1 = (byte **)levelCol->LevelNames;
	do {
										// iVar3 = std::strcmp(levelCol->NextLevels[i],levelName);
		ptrNext = *ppbVar1;
		ptrName = (byte *)levelName;
		do {
			cnext = *ptrNext;
			clt = cnext < *ptrName;
			if (cnext != *ptrName) {
LAB_00416f8d:
				cmp = (1 - (uint)clt) - (uint)(clt != 0);
				goto LAB_00416f92;
			}
			if (cnext == 0) break;
			cnext = ptrNext[1];
			clt = cnext < ptrName[1];
			if (cnext != ptrName[1]) goto LAB_00416f8d;
			ptrNext = ptrNext + 2;
			ptrName = ptrName + 2;
		} while (cnext != 0);
		cmp = 0;
LAB_00416f92:
		if (cmp == 0) {
			return levelCol->LevelList[i];
		}
		i += 1;
		ppbVar1 = ppbVar1 + 1;
		if (levelCol->count <= i) {
			return NULL;
		}
	} while( true );
}



LevelIdentifier * __cdecl
lego::front::LevelCollection_LoadLinks(LevelCollection *levelCol,char *levelName)
{
	BOOL isLinked;
	LevelIdentifier *identifier;
	int colIndex;
	char *linkNames;
	uint numParts;
	LevelIdentifier **levelLinks;
	LevelIdentifier *linkIdentifier;
	uint i;
	char *stringParts [15];
	
	if (levelName != NULL) {
		isLinked = LevelCollection_IsLinked(levelCol,levelName);
		if (isLinked != 0) {
			linkIdentifier = LevelCollection_GetIdentifier(levelCol,levelName);
			return linkIdentifier;
		}
		identifier = (LevelIdentifier *)std::malloc(0x14);
		LevelCollection_SetLinked(levelCol,levelName,TRUE);
		LevelCollection_SetIdentifier(levelCol,levelName,identifier);
		if (identifier != NULL) {
			colIndex = LevelCollection_IndexOf(levelCol,levelName);
			if (colIndex != -1) {
				linkNames = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"LevelLinks",0);
				linkNames = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,linkNames);
				identifier->index = colIndex;
				i = 0;
				if (linkNames == NULL) {
					identifier->LevelLinks = NULL;
				}
				else {
					numParts = util::Util_Tokenise(linkNames,stringParts,",");
					if (numParts == 0) goto LAB_004170bd;
					levelLinks = (LevelIdentifier **)std::malloc(numParts * 4);
					identifier->LevelLinks = levelLinks;
					if (numParts != 0) {
						do {
							linkIdentifier = LevelCollection_LoadLinks(levelCol,stringParts[i]);
							identifier->LevelLinks[i] = linkIdentifier;
							i += 1;
						} while (i < numParts);
						identifier->NumLinks = i;
						return identifier;
					}
				}
				identifier->NumLinks = 0;
				return identifier;
			}
LAB_004170bd:
			std::free(identifier);
			return NULL;
		}
	}
	return NULL;
}



BOOL __cdecl
lego::front::LevelIdentifier_RecurseCallbacks
					(LevelIdentifier *identifier,LevelIdentifierCallback callback,void *data)
{
	BOOL BVar1;
	uint uVar2;
	
	if ((identifier != NULL) && (identifier->field_10 == 0)) {
		identifier->field_10 = 1;
		BVar1 = (*callback)(identifier,data);
		if (BVar1 != 0) {
			return TRUE;
		}
		if ((identifier->LevelLinks != NULL) && (uVar2 = 0, identifier->NumLinks != 0)) {
			do {
				BVar1 = LevelIdentifier_RecurseCallbacks(identifier->LevelLinks[uVar2],callback,data);
				if (BVar1 != 0) {
					return TRUE;
				}
				uVar2 += 1;
			} while (uVar2 < identifier->NumLinks);
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl lego::front::LevelIdentifier_Callback_IncCount(LevelIdentifier *identifier,int *pCount)
{
	*pCount = *pCount + 1;
	return 0;
}



BOOL __cdecl
lego::front::LevelIdentifier_SearchCallback_FUN_00417180
					(LevelIdentifier *identifier,SearchLevelIdentifier_10 *search)
{
	int iVar1;
	
	iVar1 = search->currentIndex;
	if (search->searchIndex == iVar1) {
		search->resultIndex = iVar1;
		search->result = identifier;
		return TRUE;
	}
	search->currentIndex = iVar1 + 1;
	return 0;
}



LevelIdentifier * __cdecl
lego::front::LevelIdentifier_FindByUnkCallbacks_FUN_004171b0
					(LevelIdentifier *identifier,int searchIndex)
{
	BOOL BVar1;
	SearchLevelIdentifier_10 search;
	
	search.result = NULL;
	search.currentIndex = 0;
	search.resultIndex = 0;
	search.searchIndex = searchIndex;
	BVar1 = LevelIdentifier_RecurseCallbacks
										(identifier,LevelIdentifier_SearchCallback_FUN_00417180,&search);
	if (BVar1 != 0) {
		LevelCollections_ClearAllLinks();
		return search.result;
	}
	LevelCollections_ClearAllLinks();
	return NULL;
}



int __cdecl lego::front::LevelIdentifier_FUN_00417200(LevelIdentifier *identifier,int param_2)
{
	LevelIdentifier *pLVar1;
	
	pLVar1 = LevelIdentifier_FindByUnkCallbacks_FUN_004171b0(identifier,param_2);
	if (pLVar1 != NULL) {
		return pLVar1->index;
	}
	return -1;
}



void __cdecl
lego::front::LevelIdentifier_FUN_00417220
					(LevelIdentifier *identifier,int *ref_struct14_2,BOOL param_3)
{
	uint *puVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	
	uVar4 = 0;
	if ((identifier != NULL) && (identifier->field_10 == 0)) {
		if ((PROGRAMMER_MODE_1 < globs::mainGlobs.programmerLevel) ||
			 ((globs::mainGlobs.flags & CMD_TESTLEVELS) != CMD_NONE)) {
			ref_struct14_2[4] = 0;
		}
		identifier->field_10 = 1;
		if (((*ref_struct14_2 == 0) || (PROGRAMMER_MODE_1 < globs::mainGlobs.programmerLevel)) ||
			 ((globs::mainGlobs.flags & CMD_TESTLEVELS) != CMD_NONE)) {
			uVar3 = (uint)(ref_struct14_2[4] == 0);
		}
		else {
			uVar3 = *(uint *)(identifier->index * 0x3190 + *ref_struct14_2) & 1;
		}
		if (((uVar3 == 0) && (param_3 == 0)) &&
			 (puVar1 = (uint *)(*(int *)ref_struct14_2[2] + ref_struct14_2[3] * 0x20),
			 *(int *)(*(int *)ref_struct14_2[2] + 0x1c + ref_struct14_2[3] * 0x20) == 0)) {
			uVar2 = *puVar1 & 0xfffffffb;
		}
		else {
			puVar1 = (uint *)(*(int *)ref_struct14_2[2] + ref_struct14_2[3] * 0x20);
			uVar2 = *(uint *)(*(int *)ref_struct14_2[2] + ref_struct14_2[3] * 0x20) | 4;
		}
		*puVar1 = uVar2;
		ref_struct14_2[3] = ref_struct14_2[3] + 1;
		if (identifier->NumLinks != 0) {
			do {
				LevelIdentifier_FUN_00417220(identifier->LevelLinks[uVar4],ref_struct14_2,uVar3);
				uVar4 += 1;
			} while (uVar4 < identifier->NumLinks);
		}
	}
	return;
}



void __cdecl
lego::front::LevelIdentifier_FUN_00417310
					(LevelIdentifier *identifier,int param_2,LevelCollection *levelCol,
					MenuItemTrigger *param_4,undefined4 param_5)
{
	LevelIdentifier local_14;
	
	local_14.LevelLinks = (LevelIdentifier **)levelCol;
	local_14.NumLinks = (uint)param_4;
	local_14.index = param_2;
	local_14.field_c = 0;
	local_14.field_10 = param_5;
	LevelIdentifier_FUN_00417220(identifier,(int *)&local_14,1);
	LevelCollections_ClearAllLinks();
	return;
}



longlong __cdecl lego::front::Front_StructB8_FUN_00417360(int index,SaveData *param_2)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)*(float *)(index * 0x3190 + 0x2fb8 + (int)param_2->table3190_34));
	return lVar1;
}



void __cdecl lego::unk::lego_uses_testercall_FUN_00417390(float param_1,int param_2,float param_3)
{
	ImageFont *font;
	MenuTextWindow *pMVar1;
	LevelIdentifier *pLVar2;
	SaveData *pSVar3;
	uint uVar4;
	char *pcVar5;
	int iVar6;
	undefined4 *puVar7;
	longlong lVar8;
	char local_16c;
	undefined4 local_16b;
	char local_12c [300];
	
	pMVar1 = globals::g_MenuSaveLevelWindow;
	font = globals::menu::g_MainMenuFull->menus[1]->MenuFont;
	pLVar2 = front::LevelIdentifier_FindByUnkCallbacks_FUN_004171b0
										 (globals::g_StartMissionLevel,param_2);
	pcVar5 = globals::g_MissionLevels.FullNames[pLVar2->index];
	local_16c = '\0';
	puVar7 = &local_16b;
	for (iVar6 = 0xf; iVar6 != 0; iVar6 += -1) {
		*puVar7 = 0;
		puVar7 = puVar7 + 1;
	}
	*(undefined2 *)puVar7 = 0;
	*(undefined *)((int)puVar7 + 2) = 0;
	pSVar3 = save::Save_GetCurrentSaveNumber_StructB8();
	DAT_00558838 = DAT_00558834;
	DAT_00558834 = pLVar2->index + 1;
	if ((globs::mainGlobs.flags & CMD_TESTERCALL) != CMD_NONE) {
		std::sprintf(&local_16c," (Level %d)",pLVar2->index + 1);
	}
	if ((pcVar5 == NULL) || (*pcVar5 == '\0')) {
		pcVar5 = globals::g_MissionLevels.LevelNames[pLVar2->index];
	}
	if (pMVar1->textWindow == NULL) {
		uVar4 = lego::image::Font_GetStringWidth(font,pcVar5);
		front::Front_UnkPrintf_FUN_00410250
							(font,(int)globs::mainGlobs.appWidth / 2 - (int)uVar4 / 2,390,pcVar5);
	}
	else {
		if ((BOOL_004dc8c4 != 0) &&
			 (front::TextWindow_PrintF(pMVar1->textWindow,pcVar5),
			 (globs::mainGlobs.flags & CMD_TESTERCALL) != CMD_NONE)) {
			front::TextWindow_PrintF(pMVar1->textWindow,&local_16c);
		}
	}
	if (pSVar3 != NULL) {
		uVar4 = *(uint *)((int)pSVar3->table3190_34 + pLVar2->index * 0x3190);
		if (((uVar4 & 1) != 0) && ((uVar4 & 2) == 0)) {
			lVar8 = front::Front_StructB8_FUN_00417360(pLVar2->index,pSVar3);
			pcVar5 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu","Level_Completed",0,(int)lVar8)
			;
			pcVar5 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar5);
			std::sprintf(local_12c," %s (%i)",pcVar5);
			util::stringReplaceChar(local_12c,'_',' ');
			goto LAB_0041757a;
		}
	}
	pcVar5 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Menu","Level_Incomplete",0);
	pcVar5 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar5);
	std::sprintf(local_12c," %s",pcVar5);
	util::stringReplaceChar(local_12c,'_',' ');
LAB_0041757a:
	if ((pMVar1->textWindow != NULL) && (BOOL_004dc8c4 != 0)) {
		front::TextWindow_PrintF(pMVar1->textWindow,local_12c);
		if (DAT_00558834 != DAT_00558838) {
			BOOL_0055883c = 1;
			FLOAT_00558840 = 0.0;
		}
		if ((BOOL_0055883c != 0) &&
			 (FLOAT_00558840 = param_1 + FLOAT_00558840,
			 (ushort)((ushort)(FLOAT_00558840 * 25.0 < 500.0) << 8 |
							 (ushort)(FLOAT_00558840 * 25.0 == 500.0) << 0xe) == 0)) {
			if (DAT_00558834 < 9) {
				iVar6 = FUN_004160d0(DAT_00558834);
			}
			else {
				iVar6 = FUN_00416080(DAT_00558834 + -8);
			}
			if (iVar6 != 0) {
				BOOL_0055883c = 0;
			}
		}
	}
	BOOL_004dc8c4 = 0;
	return;
}



void __cdecl lego::front::Missions_MenuItemCallback(float param_1,int param_2)
{
	MenuTextWindow *pMVar1;
	LevelIdentifier *pLVar2;
	BOOL BVar3;
	char *format;
	
	pMVar1 = globals::g_MenuSaveLevelWindow;
	pLVar2 = LevelIdentifier_FindByUnkCallbacks_FUN_004171b0(globals::g_StartTutorialLevel,param_2);
	format = globals::g_TutorialLevels.FullNames[pLVar2->index];
	DAT_00558838 = DAT_00558834;
	DAT_00558834 = pLVar2->index + 1;
	if ((format == NULL) || (*format == '\0')) {
		format = globals::g_TutorialLevels.LevelNames[pLVar2->index];
	}
	if ((pMVar1->textWindow != NULL) && (BOOL_004dc8c4 != 0)) {
		TextWindow_PrintF(pMVar1->textWindow,format);
		if (DAT_00558834 != DAT_00558838) {
			BOOL_0055883c = 1;
			FLOAT_00558840 = 0.0;
		}
		if ((BOOL_0055883c != 0) &&
			 (FLOAT_00558840 = param_1 + FLOAT_00558840,
			 (ushort)((ushort)(FLOAT_00558840 * 25.0 < 500.0) << 8 |
							 (ushort)(FLOAT_00558840 * 25.0 == 500.0) << 0xe) == 0)) {
			BVar3 = FUN_004160d0(DAT_00558834);
			if (BVar3 != 0) {
				BOOL_0055883c = 0;
			}
		}
	}
	BOOL_004dc8c4 = 0;
	return;
}



BOOL __cdecl lego::front::Missions_AddLevelCallback(LevelIdentifier *identifier,int *search)
{
	char cVar1;
	undefined4 uVar2;
	char *pcVar3;
	int frontEndX;
	int frontEndY;
	BOOL3 frontEndOpen;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	undefined4 *puVar8;
	char buff [1024];
	
	uVar2 = *(undefined4 *)(*(int *)(*search + 4) + identifier->index * 4);
	pcVar3 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,uVar2,"FrontEndX",0);
	pcVar3 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar3);
	if (pcVar3 == NULL) {
		pcVar3 = ____EMPTYSTR__;
	}
	else {
		pcVar3 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,uVar2,"FrontEndX",0);
		pcVar3 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar3);
	}
	frontEndX = std::atoi(pcVar3);
	pcVar3 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,uVar2,"FrontEndY",0);
	pcVar3 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar3);
	if (pcVar3 == NULL) {
		pcVar3 = ____EMPTYSTR__;
	}
	else {
		pcVar3 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,uVar2,"FrontEndY",0);
		pcVar3 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar3);
	}
	frontEndY = std::atoi(pcVar3);
	pcVar3 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,uVar2,"FrontEndOpen",0);
	frontEndOpen = cfg::CFG_ReadBool(globs::gameGlobs.LegoCfgRoot,pcVar3);
	if (frontEndOpen == BOOL3_ERROR) {
		frontEndOpen = BOOL3_FALSE;
	}
	pcVar3 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,uVar2,"MenuBMP",0);
	pcVar3 = cfg::CFG_CopyString(globs::gameGlobs.LegoCfgRoot,pcVar3);
	if (pcVar3 != NULL) {
		Missions_AddLevel((MenuItemMissions *)search[2],pcVar3,FALSE,NULL,frontEndX,frontEndY,
											frontEndOpen);
		std::free(pcVar3);
		return 0;
	}
	uVar4 = 0xffffffff;
	pcVar3 = globals::g_Menu_DefaultLevelBMPS;
	do {
		pcVar7 = pcVar3;
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar7 = pcVar3 + 1;
		cVar1 = *pcVar3;
		pcVar3 = pcVar7;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar6 = (undefined4 *)(pcVar7 + -uVar4);
	puVar8 = (undefined4 *)buff;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar8 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar8 = puVar8 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar8 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar8 = (undefined4 *)((int)puVar8 + 1);
	}
	Missions_AddLevel((MenuItemMissions *)search[2],buff,FALSE,NULL,frontEndX,frontEndY,frontEndOpen);
	return 0;
}



void __cdecl
lego::front::MainMenuFull_AddMissionsDisplay
					(int valueOffset,LevelIdentifier *startIdentifier,int *pLevelCount,SubMenu *in_submenu,
					undefined4 param_5,undefined4 param_6,void *callback)
{
	MenuItemMissions *itemData;
	MenuItem *menuItem;
	int *local_10;
	SubMenu *local_c;
	MenuItemMissions *local_8;
	undefined4 local_4;
	
	local_10 = pLevelCount;
	local_c = in_submenu;
	local_8 = NULL;
	local_4 = param_5;
	pLevelCount = NULL;
	LevelIdentifier_RecurseCallbacks(startIdentifier,LevelIdentifier_Callback_IncCount,&pLevelCount);
	LevelCollections_ClearAllLinks();
	itemData = Menu_CreateMissionsDisplay
											 (&globals::g_MainMenuFull_TriggerCredits + valueOffset,____EMPTYSTR__,
												____EMPTYSTR__,0,0,0,(int)pLevelCount,0,0,0,0,0,callback,param_6);
	menuItem = Menu_CreateBannerItem("Levels!!!",NULL,NULL,0,0,MENUITEM_MISSIONS,TRUE,itemData,FALSE);
	Menu_AddSubMenuItem(in_submenu,menuItem);
	local_8 = itemData;
	LevelIdentifier_RecurseCallbacks(startIdentifier,Missions_AddLevelCallback,&local_10);
	LevelCollections_ClearAllLinks();
	return;
}



BOOL __cdecl lego::save::Save_ReadSaveFile(uint saveIndex,SaveData *out_saveData,BOOL param_3)
{
	uint saveNumber;
	File *f;
	void *out_buffer;
	int iVar1;
	undefined4 local_68;
	char buff [100];
	
	saveNumber = saveIndex;
	if (saveIndex < 6) {
		std::sprintf(buff,"%s\\%i.sav","Saves",saveIndex);
		f = lego::file::File_Open(buff,"rb");
		if (f != NULL) {
			saveIndex = 0;
			local_68 = 0;
										// Read the data directly into the structure.
										//  This means we can learn from the file format! :D
			lego::file::File_Read(out_saveData,0xb0,1,f);
			front::LevelIdentifier_RecurseCallbacks
								(globals::g_StartMissionLevel,front::LevelIdentifier_Callback_IncCount,&saveIndex);
			front::LevelCollections_ClearAllLinks();
			front::LevelIdentifier_RecurseCallbacks
								(globals::g_StartTutorialLevel,front::LevelIdentifier_Callback_IncCount,&local_68);
			front::LevelCollections_ClearAllLinks();
			if ((out_saveData->count_18 != saveIndex) && (param_3 == 0)) {
				Save_SPrintfFileUnkWrite__00417b00(saveNumber,NULL);
				for (iVar1 = 0x2e; iVar1 != 0; iVar1 += -1) {
					out_saveData->field_0x0 = 0;
					out_saveData = (SaveData *)&out_saveData->field_0x4;
				}
				return 0;
			}
			out_buffer = std::malloc(out_saveData->count_18 * 0x3190);
			out_saveData->table3190_34 = out_buffer;
			lego::file::File_Read(out_buffer,0x3190,out_saveData->count_18,f);
			lego::file::File_Close(f);
			return TRUE;
		}
		if (param_3 == 0) {
			Save_SPrintfFileUnkWrite__00417b00(saveNumber,NULL);
		}
	}
	return 0;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

BOOL __cdecl lego::save::Save_SPrintfFileUnkWrite__00417b00(uint saveNumber,SaveData *saveData)
{
	File *pFVar1;
	int iVar2;
	uint uVar3;
	undefined4 *puVar4;
	uint uStack12976;
	undefined4 uStack12972;
	undefined4 auStack12968 [5];
	uint auStack12948 [40];
	char acStack12788 [100];
	undefined4 uStack12688;
	undefined4 auStack12684 [3170];
	undefined4 uStack4;
	
	uStack4 = 0x417b0a;
	if (saveNumber < 6) {
		std::sprintf(acStack12788,"%s\\%i.sav","Saves",saveNumber);
		uVar3 = 0;
		if (saveData == NULL) {
			lego::file::File_MakeDir("Saves");
			pFVar1 = lego::file::File_Open(acStack12788,"wb");
			if (pFVar1 != NULL) {
				uStack12972 = 0;
				puVar4 = auStack12968;
				for (iVar2 = 0x2d; iVar2 != 0; iVar2 += -1) {
					*puVar4 = 0;
					puVar4 = puVar4 + 1;
				}
				uStack12688 = 0;
				auStack12968[1] = 7;
				puVar4 = auStack12684;
				for (iVar2 = 0xc63; iVar2 != 0; iVar2 += -1) {
					*puVar4 = 0;
					puVar4 = puVar4 + 1;
				}
				auStack12968[0] = 5;
				auStack12968[3] = 5;
				auStack12968[2] = 1;
				auStack12948[0] = 0;
				front::LevelIdentifier_RecurseCallbacks
									(globals::g_StartMissionLevel,front::LevelIdentifier_Callback_IncCount,
									 auStack12948);
				front::LevelCollections_ClearAllLinks();
				lego::file::File_Write(&uStack12972,0xb4,1,pFVar1);
				if (auStack12948[0] != 0) {
					do {
						lego::file::File_Write(&uStack12688,0x3190,1,pFVar1);
						uVar3 += 1;
					} while (uVar3 < auStack12948[0]);
				}
				lego::file::File_Close(pFVar1);
				return 1;
			}
		}
		else {
			uStack12976 = 0;
			front::LevelIdentifier_RecurseCallbacks
								(globals::g_StartMissionLevel,front::LevelIdentifier_Callback_IncCount,&uStack12976)
			;
			front::LevelCollections_ClearAllLinks();
			if (uStack12976 != saveData->count_18) {
				Save_SPrintfFileUnkWrite__00417b00(saveNumber,NULL);
				return 1;
			}
			pFVar1 = lego::file::File_Open(acStack12788,"wb");
			if (pFVar1 != NULL) {
				lego::file::File_Write(saveData,0xb0,1,pFVar1);
				if (saveData->count_18 != 0) {
					lego::file::File_Write(saveData->table3190_34,0x3190,saveData->count_18,pFVar1);
				}
				lego::file::File_Close(pFVar1);
				std::sprintf(acStack12788,"%s\\%i.osf","Saves",saveNumber);
				ObjectRecall_Save_SaveObjectRecallFile(acStack12788);
				return TRUE;
			}
		}
	}
	return 0;
}



void __cdecl lego::save::Front_StructB8_HasClearSaves_FUN_00417d20(void)
{
	BOOL BVar1;
	SaveData *out_saveData;
	uint saveIndex;
	
	saveIndex = 0;
	out_saveData = globals::g_Struct_b8_TABLE__00558080;
	do {
		if ((globs::mainGlobs.flags & CMD_CLEANSAVES) == CMD_NONE) {
			BVar1 = Save_ReadSaveFile(saveIndex,out_saveData,0);
			if (BVar1 == 0) goto LAB_00417d53;
		}
		else {
			Save_SPrintfFileUnkWrite__00417b00(saveIndex,NULL);
LAB_00417d53:
			Save_ReadSaveFile(saveIndex,out_saveData,0);
		}
		out_saveData = out_saveData + 1;
		saveIndex += 1;
		if ((SaveData *)((int)&globals::g_Struct_b8_TABLE__00558080[5].field_0xb4 + 3U) < out_saveData)
		{
			return;
		}
	} while( true );
}



SaveData * __cdecl lego::save::Save_GetStructB8At(int saveIndex)
{
	if ((saveIndex < 6) && (-1 < saveIndex)) {
		return globals::g_Struct_b8_TABLE__00558080 + saveIndex;
	}
	return NULL;
}



SaveData * __cdecl lego::save::Save_GetCurrentSaveNumber_StructB8(void)
{
	SaveData *pSVar1;
	
	if (globals::g_SaveNumber != -1) {
		pSVar1 = Save_GetStructB8At(globals::g_SaveNumber);
		return pSVar1;
	}
	return NULL;
}



int __cdecl lego::save::Save_GetSaveNumber(void)
{
	return globals::g_SaveNumber;
}



void __cdecl lego::save::Save_SetSaveNumber(int saveIndex)
{
	globals::g_SaveNumber = saveIndex;
	return;
}



void __cdecl lego::front::Front_FUN_00417de0(uint param_1)
{
	SaveData *pSVar1;
	BOOL BVar2;
	uint *puVar3;
	
	pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
	if (pSVar1 != NULL) {
		BVar2 = Front_GetUnkTutoOrMissions();
		if (BVar2 == 0) {
			if (7 < param_1) {
				if (pSVar1->count_18 <= param_1 && param_1 != pSVar1->count_18) {
					return;
				}
				*(uint *)(param_1 * 0x3190 + (int)pSVar1->table3190_34) =
						 *(uint *)(param_1 * 0x3190 + (int)pSVar1->table3190_34) | 1;
				return;
			}
		}
		else {
			if (7 < param_1) {
				return;
			}
		}
		puVar3 = (uint *)((int)pSVar1->table3190_34 + param_1 * 0x3190);
		*puVar3 = *puVar3 | 1;
		puVar3 = (uint *)(param_1 * 0x3190 + (int)pSVar1->table3190_34);
		*puVar3 = *puVar3 | 2;
	}
	return;
}



void __cdecl lego::save::SaveStruct18_FUN_00417e50(SaveStruct_18 *param_1)
{
	SaveData *pSVar1;
	int iVar2;
	SaveStruct_18 *pSVar3;
	
	pSVar1 = Save_GetCurrentSaveNumber_StructB8();
	if (pSVar1 != NULL) {
		pSVar3 = &pSVar1->saveStruct18_1c;
		for (iVar2 = 6; iVar2 != 0; iVar2 += -1) {
			*(undefined4 *)pSVar3 = *(undefined4 *)param_1;
			param_1 = (SaveStruct_18 *)&param_1->field_0x4;
			pSVar3 = (SaveStruct_18 *)&pSVar3->field_0x4;
		}
	}
	return;
}



BOOL __cdecl lego::front::Front_FUN_00417e70(int param_1,undefined4 *param_2)
{
	SaveData *pSVar1;
	int iVar2;
	undefined4 *puVar3;
	
	pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
	if ((pSVar1 != NULL) && (param_1 < (int)pSVar1->count_18)) {
		puVar3 = (undefined4 *)(param_1 * 0x3190 + 4 + (int)pSVar1->table3190_34);
		for (iVar2 = 0xc63; iVar2 != 0; iVar2 += -1) {
			*puVar3 = *param_2;
			param_2 = param_2 + 1;
			puVar3 = puVar3 + 1;
		}
		return TRUE;
	}
	return 0;
}



int __cdecl lego::front::LevelIndex_FUN_00417ec0(int levelIndex)
{
	SaveData *pSVar1;
	
	pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
	if ((pSVar1 != NULL) && (levelIndex < (int)pSVar1->count_18)) {
		return levelIndex * 0x3190 + 4 + (int)pSVar1->table3190_34;
	}
	return 0;
}



BOOL __cdecl lego::front::Front_FUN_00417ef0(void)
{
	SaveData *saveData;
	BOOL BVar1;
	
	saveData = save::Save_GetCurrentSaveNumber_StructB8();
	BVar1 = save::Save_SPrintfFileUnkWrite__00417b00(globals::g_SaveNumber,saveData);
	return BVar1;
}



BOOL __cdecl lego::front::Front_GetBool_00558500(void)
{
	return BOOL_00558500;
}



void __cdecl lego::front::Front_SetBool_00558500(BOOL state)
{
	BOOL_00558500 = state;
	return;
}



void __cdecl lego::front::Front_FUN_00417f30(void)
{
	int saveNumber;
	SaveData *saveData;
	
	saveData = NULL;
	saveNumber = save::Save_GetSaveNumber();
	save::Save_SPrintfFileUnkWrite__00417b00(saveNumber,saveData);
	LevelIdentifier_FUN_00417310
						(globals::g_StartMissionLevel,0,&globals::g_MissionLevels,
						 *(MenuItemTrigger **)(globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10),1)
	;
	return;
}



void __cdecl lego::save::Save_CopyData(SaveData *out_saveData)
{
	SaveData *pSVar1;
	void *pvVar2;
	int iVar3;
	uint uVar4;
	undefined4 *puVar5;
	SaveData *pSVar6;
	undefined4 *puVar7;
	
	pSVar1 = Save_GetCurrentSaveNumber_StructB8();
	if (pSVar1 != NULL) {
		pSVar1 = Save_GetCurrentSaveNumber_StructB8();
		pSVar6 = out_saveData;
		for (iVar3 = 0x2e; iVar3 != 0; iVar3 += -1) {
			pSVar6->field_0x0 = pSVar1->field_0x0;
			pSVar1 = (SaveData *)&pSVar1->field_0x4;
			pSVar6 = (SaveData *)&pSVar6->field_0x4;
		}
		pvVar2 = std::malloc(out_saveData->count_18 * 0x3190);
		out_saveData->table3190_34 = pvVar2;
		if (pvVar2 != NULL) {
			uVar4 = out_saveData->count_18;
			pSVar1 = Save_GetCurrentSaveNumber_StructB8();
			puVar5 = (undefined4 *)pSVar1->table3190_34;
			puVar7 = (undefined4 *)out_saveData->table3190_34;
			for (uVar4 = uVar4 * 0x3190 >> 2; uVar4 != 0; uVar4 -= 1) {
				*puVar7 = *puVar5;
				puVar5 = puVar5 + 1;
				puVar7 = puVar7 + 1;
			}
			for (iVar3 = 0; iVar3 != 0; iVar3 += -1) {
				*(undefined *)puVar7 = *(undefined *)puVar5;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
				puVar7 = (undefined4 *)((int)puVar7 + 1);
			}
		}
	}
	return;
}



void __cdecl lego::front::Save_OverwriteData(SaveData *saveData)
{
	SaveData *pSVar1;
	SaveData *pSVar2;
	int iVar3;
	
	pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
	if (pSVar1 != NULL) {
		pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
		if (pSVar1->table3190_34 != NULL) {
			pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
			std::free(pSVar1->table3190_34);
		}
		pSVar2 = save::Save_GetCurrentSaveNumber_StructB8();
		pSVar1 = saveData;
		for (iVar3 = 0x2e; iVar3 != 0; iVar3 += -1) {
			pSVar2->field_0x0 = pSVar1->field_0x0;
			pSVar1 = (SaveData *)&pSVar1->field_0x4;
			pSVar2 = (SaveData *)&pSVar2->field_0x4;
		}
		pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
		pSVar1->table3190_34 = saveData->table3190_34;
	}
	return;
}



void __cdecl lego::front::Front_SetBool_0055881c(BOOL state)
{
	BOOL_0055881c = state;
	return;
}



BOOL __cdecl lego::front::Front_FUN_00418050(void)
{
	SaveData *pSVar1;
	uint uVar2;
	uint uVar3;
	int iVar4;
	longlong lVar5;
	
	pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
	if (pSVar1 != NULL) {
		uVar2 = 0;
		uVar3 = 8;
		pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
		if (8 < pSVar1->count_18) {
			iVar4 = 0x18c80;
			do {
				pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
				lVar5 = __ftol((float10)*(float *)((int)pSVar1->table3190_34 + iVar4 + 0x2fb8));
				uVar2 += (int)lVar5;
				uVar3 += 1;
				iVar4 += 0x3190;
				pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
			} while (uVar3 < pSVar1->count_18);
		}
		pSVar1 = save::Save_GetCurrentSaveNumber_StructB8();
		if (99 < uVar2 / (pSVar1->count_18 - 8)) {
			return TRUE;
		}
	}
	return 0;
}



void __cdecl lego::front::HelpWindow_SetFont(ImageFont *font)
{
	globals::g_DefaultFont = font;
	return;
}



void __cdecl lego::front::HelpWindow_UnsetFlag1_004dd650(void)
{
	FLAGS_004dd650 = FLAGS_004dd650 & 0xfffffffe;
	return;
}



void __cdecl lego::front::HelpWindow_Load(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	int iVar4;
	Rect2F local_50;
	char *local_40;
	char *local_3c;
	char *local_38;
	char *local_34;
	
	HelpWindow_LoadInfoLevels(root,rootPath);
	pcVar3 = cfg::CFG_JoinPath(rootPath,"HelpWindow","BackGroundImage",0);
	pcVar3 = cfg::CFG_CopyString(root,pcVar3);
	if (pcVar3 != NULL) {
		util::Util_Tokenise(pcVar3,&local_40,",");
		globals::g_HelpWindow_BackgroundImage_bitmap = lego::image::Image_LoadBMPScaled(local_40,0,0);
		if (globals::g_HelpWindow_BackgroundImage_bitmap != NULL) {
			lego::image::Image_SetupTrans
								(globals::g_HelpWindow_BackgroundImage_bitmap,0.0,0.0,0.0,0.0,0.0,0.0);
		}
		iVar4 = std::atoi(local_3c);
		globals::g_HelpWindow_BackgroundImage_x = (float)iVar4;
		iVar4 = std::atoi(local_38);
		globals::g_HelpWindow_BackgroundImage_y = (float)iVar4;
		std::free(pcVar3);
	}
	HelpWindow_LoadButtons(root,rootPath);
	pcVar3 = cfg::CFG_JoinPath(rootPath,"HelpWindow","TextWindowArea",0);
	pcVar3 = cfg::CFG_CopyString(root,pcVar3);
	if (pcVar3 != NULL) {
		util::Util_Tokenise(pcVar3,&local_40,",");
		iVar4 = std::atoi(local_40);
		local_50.x = (float)iVar4;
		iVar4 = std::atoi(local_3c);
		local_50.y = (float)iVar4;
		iVar4 = std::atoi(local_38);
		local_50.width = (float)iVar4;
		iVar4 = std::atoi(local_34);
		local_50.height = (float)iVar4;
		globals::g_HelpWindow_TextWindowArea_unkDrawRegion =
				 TextWindow_Create(globals::g_DefaultFont,&local_50,0x400);
		globals::g_HelpWindow_TextWindowArea_y2 = local_50.y + local_50.height;
		globals::g_HelpWindow_TextWindowArea_x = local_50.x;
		globals::g_HelpWindow_TextWindowArea_y = local_50.y;
		std::free(pcVar3);
	}
	pcVar3 = cfg::CFG_JoinPath(rootPath,"HelpWindow","CanBuildMessage",0);
	globals::g_HelpWindow_CanBuildMessage = cfg::CFG_CopyString(root,pcVar3);
	if (globals::g_HelpWindow_CanBuildMessage != NULL) {
		cVar2 = *globals::g_HelpWindow_CanBuildMessage;
		pcVar3 = globals::g_HelpWindow_CanBuildMessage;
		while (cVar2 != '\0') {
			if (cVar2 == '_') {
				*pcVar3 = ' ';
			}
			pcVar1 = pcVar3 + 1;
			pcVar3 = pcVar3 + 1;
			cVar2 = *pcVar1;
		}
	}
	pcVar3 = cfg::CFG_JoinPath(rootPath,"HelpWindow","CanTransportMessage",0);
	globals::g_HelpWindow_CanTransportMessage = cfg::CFG_CopyString(root,pcVar3);
	if (globals::g_HelpWindow_CanTransportMessage != NULL) {
		cVar2 = *globals::g_HelpWindow_CanTransportMessage;
		pcVar3 = globals::g_HelpWindow_CanTransportMessage;
		while (cVar2 != '\0') {
			if (cVar2 == '_') {
				*pcVar3 = ' ';
			}
			pcVar1 = pcVar3 + 1;
			pcVar3 = pcVar3 + 1;
			cVar2 = *pcVar1;
		}
	}
	pcVar3 = cfg::CFG_JoinPath(rootPath,"HelpWindow","CanBuildAndTransportMessage",0);
	globals::g_HelpWindow_CanBuildAndTransportMessage = cfg::CFG_CopyString(root,pcVar3);
	if (globals::g_HelpWindow_CanBuildAndTransportMessage != NULL) {
		cVar2 = *globals::g_HelpWindow_CanBuildAndTransportMessage;
		pcVar3 = globals::g_HelpWindow_CanBuildAndTransportMessage;
		while (cVar2 != '\0') {
			if (cVar2 == '_') {
				*pcVar3 = ' ';
			}
			pcVar1 = pcVar3 + 1;
			pcVar3 = pcVar3 + 1;
			cVar2 = *pcVar1;
		}
	}
	FLAGS_004dd650 = FLAGS_004dd650 & 0xffffff00 | FLAGS_004dd650 & 0xff | 4 | 2;
	HelpWindow_FUN_00419130(0,0);
	return;
}



void __cdecl lego::front::HelpWindow_LoadInfoLevels(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	uint uVar5;
	HelpWindowInfoLevels *pHVar6;
	char local_400 [1024];
	
	uVar4 = 0;
	if (globs::gameGlobs.VehicleTypes_COUNT != 0) {
		pHVar6 = globals::g_HelpWindowInfo_VehicleTypes_Levels_TABLE;
		do {
			uVar5 = 0;
			do {
				std::sprintf(local_400,"HelpWindow::HelpWindowInfo::%sL%i",
										 globs::gameGlobs.VehicleTypes_TABLE[uVar4],uVar5);
				pcVar3 = cfg::CFG_JoinPath(rootPath,local_400,0);
				pcVar3 = cfg::CFG_CopyString(root,pcVar3);
				pHVar6->levels[0] = pcVar3;
				if (pcVar3 != NULL) {
					cVar2 = *pcVar3;
					while (cVar2 != '\0') {
						if (cVar2 == '_') {
							*pcVar3 = ' ';
						}
						pcVar1 = pcVar3 + 1;
						pcVar3 = pcVar3 + 1;
						cVar2 = *pcVar1;
					}
				}
				uVar5 += 1;
				pHVar6 = (HelpWindowInfoLevels *)(pHVar6->levels + 1);
			} while (uVar5 < 0x10);
			uVar4 += 1;
		} while (uVar4 < globs::gameGlobs.VehicleTypes_COUNT);
	}
	uVar4 = 0;
	if (globs::gameGlobs.MiniFigureTypes_COUNT != 0) {
		pHVar6 = globals::g_HelpWindowInfo_MiniFigureTypes_Levels_TABLE;
		do {
			uVar5 = 0;
			do {
				std::sprintf(local_400,"HelpWindow::HelpWindowInfo::%sL%i",
										 globs::gameGlobs.MiniFigureTypes_TABLE[uVar4],uVar5);
				pcVar3 = cfg::CFG_JoinPath(rootPath,local_400,0);
				pcVar3 = cfg::CFG_CopyString(root,pcVar3);
				pHVar6->levels[0] = pcVar3;
				if (pcVar3 != NULL) {
					cVar2 = *pcVar3;
					while (cVar2 != '\0') {
						if (cVar2 == '_') {
							*pcVar3 = ' ';
						}
						pcVar1 = pcVar3 + 1;
						pcVar3 = pcVar3 + 1;
						cVar2 = *pcVar1;
					}
				}
				uVar5 += 1;
				pHVar6 = (HelpWindowInfoLevels *)(pHVar6->levels + 1);
			} while (uVar5 < 0x10);
			uVar4 += 1;
		} while (uVar4 < globs::gameGlobs.MiniFigureTypes_COUNT);
	}
	uVar4 = 0;
	if (globs::gameGlobs.BuildingTypes_COUNT != 0) {
		pHVar6 = globals::g_HelpWindowInfo_BuildingTypes_Levels_TABLE;
		do {
			uVar5 = 0;
			do {
				std::sprintf(local_400,"HelpWindow::HelpWindowInfo::%sL%i",
										 globs::gameGlobs.BuildingTypes_TABLE[uVar4],uVar5);
				pcVar3 = cfg::CFG_JoinPath(rootPath,local_400,0);
				pcVar3 = cfg::CFG_CopyString(root,pcVar3);
				pHVar6->levels[0] = pcVar3;
				if (pcVar3 != NULL) {
					cVar2 = *pcVar3;
					while (cVar2 != '\0') {
						if (cVar2 == '_') {
							*pcVar3 = ' ';
						}
						pcVar1 = pcVar3 + 1;
						pcVar3 = pcVar3 + 1;
						cVar2 = *pcVar1;
					}
				}
				uVar5 += 1;
				pHVar6 = (HelpWindowInfoLevels *)(pHVar6->levels + 1);
			} while (uVar5 < 0x10);
			uVar4 += 1;
		} while (uVar4 < globs::gameGlobs.BuildingTypes_COUNT);
	}
	return;
}



void __cdecl lego::front::HelpWindow_LoadButtons(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	int iVar2;
	char *local_40;
	char *local_3c;
	char *local_38;
	char *local_34;
	char *local_30;
	char *local_2c;
	char *local_28;
	
	pcVar1 = cfg::CFG_JoinPath(rootPath,"HelpWindow","ContinueButton",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		util::Util_Tokenise(pcVar1,&local_40,",");
		iVar2 = std::atoi(local_40);
		globals::g_HelpWindow_ContinueButton_x = (float)iVar2 + globals::g_HelpWindow_BackgroundImage_x;
		iVar2 = std::atoi(local_3c);
		globals::g_HelpWindow_ContinueButton_y = (float)iVar2 + globals::g_HelpWindow_BackgroundImage_y;
		iVar2 = std::atoi(local_38);
		globals::g_HelpWindow_ContinueButton_width = (float)iVar2;
		iVar2 = std::atoi(local_34);
		globals::g_HelpWindow_ContinueButton_height = (float)iVar2;
		globals::g_HelpWindow_ContinueButton_bmp = lego::image::Image_LoadBMPScaled(local_30,0,0);
		globals::g_HelpWindow_ContinueButton_bmp_push = lego::image::Image_LoadBMPScaled(local_2c,0,0);
		globals::g_HelpWindow_ContinueButton_text = util::Util_RemoveUnderscores(local_28);
		ToolTip_SetText(TOOLTIP_INFOMENUCONTINUE,globals::g_HelpWindow_ContinueButton_text);
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"HelpWindow","CancelFutureButton",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		util::Util_Tokenise(pcVar1,&local_40,",");
		iVar2 = std::atoi(local_40);
		globals::g_HelpWindow_CancelFutureButton_x =
				 (float)iVar2 + globals::g_HelpWindow_BackgroundImage_x;
		iVar2 = std::atoi(local_3c);
		globals::g_HelpWindow_CancelFutureButton_y =
				 (float)iVar2 + globals::g_HelpWindow_BackgroundImage_y;
		iVar2 = std::atoi(local_38);
		globals::g_HelpWindow_CancelFutureButton_width = (float)iVar2;
		iVar2 = std::atoi(local_34);
		globals::g_HelpWindow_CancelFutureButton_height = (float)iVar2;
		globals::g_HelpWindow_CancelFutureButton_bmp = lego::image::Image_LoadBMPScaled(local_30,0,0);
		globals::g_HelpWindow_CancelFutureButton_bmp_push =
				 lego::image::Image_LoadBMPScaled(local_2c,0,0);
		globals::g_HelpWindow_CancelFutureButton_text = util::Util_RemoveUnderscores(local_28);
		ToolTip_SetText(TOOLTIP_INFOMENUDISABLEFUTURE,globals::g_HelpWindow_CancelFutureButton_text);
	}
	return;
}



void __cdecl lego::front::HelpWindow_Game_SetPlaceFlagsState_004dd650(BOOL param_1)
{
	if ((FLAGS_004dd650 & 4) != 0) {
		if (param_1 != 0) {
			FLAGS_004dd650 = FLAGS_004dd650 & 0xffffff00 | FLAGS_004dd650 & 0xfe | 2;
			return;
		}
		FLAGS_004dd650 &= 0xfffffffc;
	}
	return;
}



void __cdecl
lego::front::HelpWindow_Game_UpdateObjectDependencies
					(ObjectType objType,int objIndex,int objLevel,BOOL noHelpWindow)
{
	uint uVar1;
	
	game::Dependencies_Init_MiscObjectDependencies();
	uVar1 = game::Dependencies_GetObjectLevelFlag_100(objType,objIndex,objLevel);
	if (uVar1 == 0) {
		game::Dependencies_SetObjectLevelFlag_100(objType,objIndex,objLevel);
		if (noHelpWindow == 0) {
			globals::g_HelpWindow_ObjectType = objType;
			globals::g_HelpWindow_ObjectIndex = objIndex;
			globals::g_HelpWindow_ObjectLevel = objLevel;
			if (objType == OBJECT_VEHICLE) {
				globals::g_HelpWindow_ObjectName =
						 globals::g_HelpWindowInfo_VehicleTypes_Levels_TABLE[objIndex].levels[objLevel];
			}
			else {
				if (objType == OBJECT_MINIFIGURE) {
					globals::g_HelpWindow_ObjectName =
							 globals::g_HelpWindowInfo_MiniFigureTypes_Levels_TABLE[objIndex].levels[objLevel];
				}
				else {
					if (objType == OBJECT_BUILDING) {
						globals::g_HelpWindow_ObjectName =
								 globals::g_HelpWindowInfo_BuildingTypes_Levels_TABLE[objIndex].levels[objLevel];
					}
				}
			}
			TextWindow_Clear(globals::g_HelpWindow_TextWindowArea_unkDrawRegion);
			FLAGS_004dd650 |= 8;
			HelpWindow_Object_Dependencies_FUN_00418850(objType,objIndex,objLevel);
			FLAGS_004dd650 |= 1;
			FLOAT_004dd640 = 0.0;
			FLOAT_004dd644 = 0.0;
		}
	}
	return;
}



void __cdecl
lego::front::HelpWindow_Object_Dependencies_FUN_00418850
					(ObjectType objType,int objIndex,int objLevel)
{
	int iVar1;
	int iVar2;
	BOOL BVar3;
	int *piVar4;
	uint uVar5;
	ObjectType local_204 [32];
	int local_184 [32];
	int local_104 [64];
	uint local_4;
	
	uVar5 = 0;
	UINT_004dd63c = 0;
	game::Dependencies_Object_FUN_0040af30(objType,objIndex,objLevel,(int)local_204);
	if (local_4 != 0) {
		piVar4 = local_184;
		do {
			BVar3 = game::Dependencies_Object_IsLevelFlag4(piVar4[-0x20],*piVar4,piVar4[0x20]);
			if (BVar3 != 0) {
				iVar1 = *piVar4;
				(&DAT_004dd4d4)[UINT_004dd63c] = piVar4[-0x20];
				iVar2 = piVar4[0x20];
				(&DAT_004dd54c)[UINT_004dd63c] = iVar1;
				(&DAT_004dd5c4)[UINT_004dd63c] = iVar2;
				UINT_004dd63c += 1;
			}
			uVar5 += 1;
			piVar4 = piVar4 + 1;
		} while (uVar5 < local_4);
	}
	return;
}



void __cdecl lego::front::HelpWindow_FUN_00418900(void)
{
	if (((FLAGS_004dd650 & 2) != 0) && ((FLAGS_004dd650 & 1) != 0)) {
		game::Game_SetPaused(0,0);
		game::Game_SetMenuNextPosition(NULL);
		FLAGS_004dd650 &= 0xfffffffe;
	}
	return;
}



void __cdecl lego::front::HelpWindow_FUN_00418930(void)
{
	uint uVar1;
	TutorialFlags TVar2;
	ImageBMP *image;
	char *pcVar3;
	int *piVar4;
	int iVar5;
	ObjectType *pOVar6;
	int iVar7;
	float10 fVar8;
	longlong lVar9;
	char *format;
	undefined8 uVar10;
	float local_14;
	Point2F local_10;
	Point2F local_8;
	
	uVar1 = HelpWindow_FUN_00419120();
	if (uVar1 == 0) {
		HelpWindow_FUN_00418900();
	}
	uVar1 = HelpWindow_FUN_00419120();
	if (uVar1 == 0) {
		return;
	}
	if ((FLAGS_004dd650 & 2) == 0) {
		return;
	}
	if ((FLAGS_004dd650 & 1) == 0) {
		return;
	}
	TVar2 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if ((TVar2 & 0x800) != TUTORIAL_NONE) {
		return;
	}
	game::Game_SetPaused(0,1);
	if ((globals::g_HelpWindow_ObjectName == NULL) && (UINT_004dd63c == 0)) {
		HelpWindow_FUN_00418900();
		return;
	}
	if (globals::g_HelpWindow_BackgroundImage_bitmap != NULL) {
		lego::image::Image_DisplayScaled
							(globals::g_HelpWindow_BackgroundImage_bitmap,NULL,
							 (Point2F *)&globals::g_HelpWindow_BackgroundImage_x,NULL);
	}
	if ((FLAGS_004dd650 & 8) != 0) {
		if (globals::g_HelpWindow_ObjectName != NULL) {
			TextWindow_PrintF(globals::g_HelpWindow_TextWindowArea_unkDrawRegion,"%s");
		}
		FLAGS_004dd650 &= 0xfffffff7;
	}
	if (globals::g_HelpWindow_ObjectName == NULL) {
		lVar9 = __ftol((float10)globals::g_HelpWindow_TextWindowArea_y);
		local_14 = (float)lVar9;
	}
	else {
		TextWindow_Update(globals::g_HelpWindow_TextWindowArea_unkDrawRegion,0,0.0,(int *)&local_14);
	}
	if (UINT_004dd63c == 0) goto LAB_00418cb8;
	local_8.x = local_14;
	local_8.y = 0.0;
	iVar7 = 0;
	iVar5 = 0;
	local_10.y = (float)(ulonglong)(uint)local_14 - -10.0;
	local_10.x = globals::g_HelpWindow_TextWindowArea_x;
	if (UINT_004dd63c != 0) {
		piVar4 = &DAT_004dd4d4;
		uVar1 = UINT_004dd63c;
		do {
			if (*piVar4 == 1) {
				iVar5 += 1;
			}
			else {
				if (*piVar4 == 4) {
					iVar7 += 1;
				}
			}
			piVar4 = piVar4 + 1;
			uVar1 -= 1;
		} while (uVar1 != 0);
	}
	if (iVar5 == 0) {
		if (globals::g_HelpWindow_CanBuildMessage != NULL) {
			uVar10 = CONCAT44(globals::g_HelpWindow_CanBuildMessage,0x4a2d60);
			lVar9 = __ftol((float10)local_10.y);
			iVar5 = (int)lVar9;
			lVar9 = __ftol((float10)local_10.x);
			iVar7 = (int)lVar9;
			goto override_prt_418b00_2c9bc250;
		}
	}
	else {
		if (iVar7 == 0) {
			if (globals::g_HelpWindow_CanTransportMessage != NULL) {
				uVar10 = CONCAT44(globals::g_HelpWindow_CanTransportMessage,0x4a2d60);
				lVar9 = __ftol((float10)local_10.y);
				iVar5 = (int)lVar9;
				lVar9 = __ftol((float10)local_10.x);
				iVar7 = (int)lVar9;
override_prt_418b00_2c9bc250:
				lego::image::Font_PrintF
									(globals::g_DefaultFont,iVar7,iVar5,(char *)uVar10,
									 (char *)((ulonglong)uVar10 >> 0x20));
			}
		}
		else {
			if (globals::g_HelpWindow_CanBuildAndTransportMessage != NULL) {
				uVar10 = CONCAT44(globals::g_HelpWindow_CanBuildAndTransportMessage,0x4a2d60);
				lVar9 = __ftol((float10)local_10.y);
				iVar5 = (int)lVar9;
				lVar9 = __ftol((float10)local_10.x);
				iVar7 = (int)lVar9;
				goto override_prt_418b00_2c9bc250;
			}
		}
	}
	uVar1 = lego::image::Font_GetHeight(globals::g_DefaultFont);
	local_8.x = (float)(uVar1 + 10);
	local_8.y = 0.0;
	local_10.y = (float)(ulonglong)(uint)local_8.x + local_10.y;
	fVar8 = __floor((double)FLOAT_004dd640);
	local_10.y = (float)((float10)local_10.y - ((float10)FLOAT_004dd640 - fVar8) * (float10)45.0);
	fVar8 = __floor((double)FLOAT_004dd640);
	lVar9 = __ftol(fVar8);
	uVar1 = (uint)lVar9;
	if (uVar1 < UINT_004dd63c) {
		pOVar6 = &DAT_004dd4d4 + uVar1;
		do {
			local_10.x = globals::g_HelpWindow_TextWindowArea_x;
			image = Interface_GetObjectBuildImage(*pOVar6,pOVar6[0x1e],1);
			if (image != NULL) {
				if (globals::g_HelpWindow_TextWindowArea_y2 <= (float)image->height + local_10.y) {
					if (FLOAT_004dd644 == 0.0) {
						local_8.y = 0.0;
						local_8.x = (float)((UINT_004dd63c - uVar1) - 1);
						FLOAT_004dd644 = (float)(ulonglong)(uint)local_8.x;
					}
					if (FLOAT_004dd640 < FLOAT_004dd644) {
						local_8.x = 345.0;
						local_8.y = 350.0;
						game::Game_SetMenuNextPosition(&local_8);
					}
					break;
				}
				lego::image::Image_DisplayScaled(image,NULL,&local_10,NULL);
			}
			local_10.x = local_10.x - -50.0;
			local_10.y = local_10.y - -10.0;
			pcVar3 = game::Object_GetTheName(*pOVar6,pOVar6[0x1e]);
			format = "%s";
			lVar9 = __ftol((float10)local_10.y);
			iVar5 = (int)lVar9;
			lVar9 = __ftol((float10)local_10.x);
			lego::image::Font_PrintF(globals::g_DefaultFont,(int)lVar9,iVar5,format,pcVar3);
			local_10.y = local_10.y - -35.0;
			uVar1 += 1;
			pOVar6 = pOVar6 + 1;
			if (UINT_004dd63c <= uVar1) {
				HelpWindow_FUN_00419030();
				return;
			}
		} while( true );
	}
LAB_00418cb8:
	HelpWindow_FUN_00419030();
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOL __cdecl
lego::front::HelpWindow_FUN_00418cd0
					(uint mouseX,uint mouseY,BOOL leftButton,BOOL leftLast,BOOL leftReleased,float elapsed)
{
	float fVar1;
	float fVar2;
	float fVar3;
	BOOL BVar4;
	float *pfVar5;
	int iVar6;
	
	if (((FLAGS_004dd650 & 2) != 0) && ((FLAGS_004dd650 & 1) != 0)) {
		FLAGS_004dd650 &= 0xffffffcf;
		fVar1 = (float)(ulonglong)mouseX;
		if ((345.0 <= fVar1) &&
			 ((((fVar2 = (float)(globs::gameGlobs.NextButton)->width - -345.0,
					(ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) != 0 &&
					(fVar2 = (float)(ulonglong)mouseY, 350.0 <= fVar2)) &&
				 (fVar3 = (float)(globs::gameGlobs.NextButton)->height - -350.0,
				 (ushort)((ushort)(fVar2 < fVar3) << 8 | (ushort)(fVar2 == fVar3) << 0xe) != 0)) &&
				(ToolTip_AddFlag4(TOOLTIP_MORE), leftReleased != 0)))) {
			HelpWindow_FUN_00418f60(3,5.0);
			snd::Audio_FUN_00428730(0);
		}
		iVar6 = 0;
		pfVar5 = &globals::g_HelpWindow_ContinueButton_x;
		do {
			if (((*pfVar5 <= fVar1) &&
					(fVar2 = *pfVar5 + pfVar5[2],
					(ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) != 0)) &&
				 ((fVar2 = (float)(ulonglong)mouseY, pfVar5[1] <= fVar2 &&
					(fVar3 = pfVar5[1] + pfVar5[3],
					(ushort)((ushort)(fVar2 < fVar3) << 8 | (ushort)(fVar2 == fVar3) << 0xe) != 0)))) {
				FLAGS_004dd650 |= 0x10;
				_DAT_004dd648 = iVar6;
				BVar4 = HelpWindow_FUN_00418ef0(iVar6,leftButton,leftLast);
				if ((BVar4 != 0) && (leftReleased != 0)) {
					HelpWindow_FUN_00418f60(iVar6,elapsed);
					snd::Audio_FUN_00428730(0);
				}
				if ((leftButton == 0) && (leftReleased == 0)) {
					HelpWindow_ToolTip_FUN_00418eb0(iVar6);
				}
				return TRUE;
			}
			pfVar5 = pfVar5 + 7;
			iVar6 += 1;
		} while (pfVar5 < &DAT_004dc93c);
		HelpWindow_FUN_00418ef0(4,leftButton,leftLast);
	}
	return 0;
}



void __cdecl lego::front::HelpWindow_ToolTip_FUN_00418eb0(int param_1)
{
	if (true) {
		switch(param_1) {
		case 0:
			ToolTip_AddFlag4(TOOLTIP_INFOMENUCONTINUE);
			return;
		case 1:
			ToolTip_AddFlag4(TOOLTIP_INFOMENUDISABLEFUTURE);
		}
	}
	return;
}



BOOL __cdecl lego::front::HelpWindow_FUN_00418ef0(int param_1,int param_2,int param_3)
{
	int iVar1;
	
	iVar1 = DAT_004dd64c;
	if (param_2 == 0) {
		DAT_004dd64c = 4;
	}
	else {
		if (DAT_004dd64c == 4) {
			if (param_3 == 0) {
				DAT_004dd64c = param_1;
				FLAGS_004dd650 = FLAGS_004dd650 | 0x20;
				return (uint)(param_1 == 4);
			}
		}
		else {
			if (DAT_004dd64c == param_1) {
				FLAGS_004dd650 = FLAGS_004dd650 | 0x20;
				return (uint)(DAT_004dd64c == param_1);
			}
		}
	}
	return (uint)(iVar1 == param_1);
}



void __cdecl lego::front::HelpWindow_FUN_00418f60(undefined4 param_1,float elapsed)
{
	switch(param_1) {
	case 0:
		HelpWindow_FUN_00418900();
		return;
	case 1:
		HelpWindow_FUN_00419130(1,0);
		HelpWindow_FUN_00418900();
		return;
	case 2:
		if (((ushort)((ushort)(FLOAT_004dd640 < 0.0) << 8 | (ushort)(FLOAT_004dd640 == 0.0) << 0xe) == 0
				) && (FLOAT_004dd640 = FLOAT_004dd640 - elapsed * 0.2, FLOAT_004dd640 < 0.0)) {
			FLOAT_004dd640 = 0.0;
			return;
		}
		break;
	case 3:
		if ((FLOAT_004dd640 < FLOAT_004dd644) &&
			 (FLOAT_004dd640 = FLOAT_004dd640 - elapsed * -0.2, FLOAT_004dd644 <= FLOAT_004dd640)) {
			FLOAT_004dd640 = FLOAT_004dd644;
			game::Game_SetMenuNextPosition(NULL);
		}
	}
	return;
}



void __cdecl lego::front::HelpWindow_FUN_00419030(void)
{
	ImageBMP *image;
	float *pfVar1;
	int iVar2;
	Point2F local_8;
	
	iVar2 = 0;
	pfVar1 = &globals::g_HelpWindow_ContinueButton_y;
	do {
		local_8.x = pfVar1[-1];
		local_8.y = *pfVar1;
		image = (ImageBMP *)HelpWindow_FUN_00419080(iVar2);
		if (image != NULL) {
			lego::image::Image_DisplayScaled(image,NULL,&local_8,NULL);
		}
		pfVar1 = pfVar1 + 7;
		iVar2 += 1;
	} while (pfVar1 < &DAT_004dc940);
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ImageBMP * __cdecl lego::front::HelpWindow_FUN_00419080(int param_1)
{
	if ((param_1 == 1) && (((byte)FLAGS_004dd650 & 4) == 0)) {
		return globals::g_HelpWindow_CancelFutureButton_bmp_push;
	}
	if ((((byte)FLAGS_004dd650 & 0x10) != 0) && (_DAT_004dd648 == param_1)) {
		if (((byte)FLAGS_004dd650 & 0x20) != 0) {
			return (&globals::g_HelpWindow_ContinueButton_bmp_push)[param_1 * 7];
		}
		return (&globals::g_HelpWindow_ContinueButton_bmp)[param_1 * 7];
	}
	return NULL;
}



BOOL __cdecl lego::front::HelpWindow_FUN_004190d0(void)
{
	uint uVar1;
	uint uVar2;
	TutorialFlags TVar3;
	uint uVar4;
	
	uVar1 = HelpWindow_FUN_00419120();
	uVar2 = FLAGS_004dd650 & 1;
	uVar4 = FLAGS_004dd650 & 2;
	TVar3 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if ((((uVar1 != 0) && (uVar4 != 0)) && (uVar2 != 0)) && (TVar3 == TUTORIAL_NONE)) {
		return TRUE;
	}
	return 0;
}



uint __cdecl lego::front::HelpWindow_FUN_00419120(void)
{
	return FLAGS_004dd650 & 0x40;
}



void __cdecl lego::front::HelpWindow_FUN_00419130(BOOL param_1,BOOL param_2)
{
	if (param_1 != 0) {
		param_2 = FLAGS_004dd650 & 0x40;
	}
	if (param_2 == 0) {
		FLAGS_004dd650 = FLAGS_004dd650 | 0x40;
		return;
	}
	FLAGS_004dd650 = FLAGS_004dd650 & 0xffffffbf;
	return;
}



void __cdecl lego::front::Info_InitInfo(ImageFont *font)
{
	globals::g_Infos_TABLE[0] = "Info_CrystalFound";
	globals::g_Infos_TABLE[1] = "Info_OreSeamFound";
	globals::g_Infos_TABLE[2] = "Info_RockMonster";
	globals::g_Infos_TABLE[3] = "Info_LavaRockMonster";
	globals::g_Infos_TABLE[4] = "Info_IceRockMonster";
	globals::g_Infos_TABLE[5] = "Info_UnderAttack";
	globals::g_Infos_TABLE[6] = "Info_Landslide";
	globals::g_Infos_TABLE[7] = "Info_CaveIn";
	globals::g_Infos_TABLE[8] = "Info_Constructed";
	globals::g_Infos_TABLE[9] = "Info_CavernLocated";
	globals::g_Infos_TABLE[10] = "Info_LegoManDeath";
	globals::g_Infos_TABLE[11] = "Info_VehicleDeath";
	globals::g_Infos_TABLE[12] = "Info_BuildingDeath";
	globals::g_Infos_TABLE[13] = "Info_DynamitePlaced";
	globals::g_Infos_TABLE[14] = "Info_NoPower";
	globals::g_Infos_TABLE[15] = "Info_PowerDrain";
	globals::g_Infos_TABLE[16] = "Info_AirDepleting";
	globals::g_Infos_TABLE[17] = "Info_AirLow";
	globals::g_Infos_TABLE[18] = "Info_AirOut";
	globals::g_Infos_TABLE[19] = "Info_AirRestored";
	globals::g_Infos_TABLE[20] = "Info_TrainDriver";
	globals::g_Infos_TABLE[21] = "Info_TrainDynamite";
	globals::g_Infos_TABLE[22] = "Info_TrainRepair";
	globals::g_Infos_TABLE[23] = "Info_TrainPilot";
	globals::g_Infos_TABLE[24] = "Info_TrainSailor";
	globals::g_Infos_TABLE[25] = "Info_TrainScanner";
	globals::g_Infos_TABLE[26] = "Info_OreCollected";
	globals::g_Infos_TABLE[27] = "Info_WallDug";
	globals::g_Infos_TABLE[28] = "Info_WallReinforced";
	globals::g_Infos_TABLE[29] = "Info_CrystalPower";
	globals::g_Infos_TABLE[30] = "Info_LavaErode";
	globals::g_Infos_TABLE[31] = "Info_SlugEmerge";
	globals::g_Infos_TABLE[32] = "Info_PathCompleted";
	globals::g_Infos_TABLE[33] = "Info_FoundMinifigure";
	globals::g_Infos_TABLE[34] = "Info_CanUpgradeMinifigure";
	globals::g_Infos_TABLE[35] = "Info_CanTrainMinifigure";
	globals::g_Infos_TABLE[36] = "Info_CrystalSeamFound";
	globals::g_Infos_TABLE[37] = "Info_GenericSeamFound";
	globals::g_Infos_TABLE[38] = "Info_GenericDeath";
	globals::g_Infos_TABLE[39] = "Info_GenericMonster";
	globals::g_Info_Font = font;
	globals::g_InfoMessageFlags = globals::g_InfoMessageFlags | (INFOMSG_UNK_8|INFOMSG_AUTOGAMESPEED);
	return;
}



BOOL __cdecl lego::front::Info_GetInfoType(char *infoName,InfoType *out_infoType)
{
	int cmp;
	char **pInfoName;
	InfoType i;
	
	i = INFO_CRYSTALFOUND;
	pInfoName = globals::g_Infos_TABLE;
	do {
		cmp = std::_stricmp(*pInfoName,infoName);
		if (cmp == 0) {
			*out_infoType = i;
			return TRUE;
		}
		pInfoName = (char **)((int)pInfoName + 4);
		i += INFO_ORESEAMFOUND;
	} while (pInfoName < globals::g_InfoDatas_TABLE);
	return 0;
}



undefined4 __cdecl lego::front::Info_GetField4(InfoType infoType)
{
	return globals::g_InfoDatas_TABLE[infoType].field_4;
}



void __cdecl lego::front::Info_LoadMessageTabs_InfoOverFlow(char *filename)
{
	globals::g_MessageTabs_InfoOverFlow_bmp = lego::image::Image_LoadBMPScaled(filename,0,0);
	lego::image::Image_SetPenZeroTrans(globals::g_MessageTabs_InfoOverFlow_bmp);
	return;
}



void __cdecl lego::front::Info_SetAutoGameSpeed(BOOL state)
{
	if (state != 0) {
		globals::g_InfoMessageFlags = globals::g_InfoMessageFlags | INFOMSG_AUTOGAMESPEED;
		return;
	}
	globals::g_InfoMessageFlags = globals::g_InfoMessageFlags & ~INFOMSG_AUTOGAMESPEED;
	return;
}



void __cdecl lego::front::Info_SetFlag_10000(InfoType infoType,BOOL setFlag10000)
{
	if (setFlag10000 != 0) {
		globals::g_InfoDatas_TABLE[infoType].flags =
				 globals::g_InfoDatas_TABLE[infoType].flags | 0x10000;
		return;
	}
	globals::g_InfoDatas_TABLE[infoType].flags =
			 globals::g_InfoDatas_TABLE[infoType].flags & 0xfffeffff;
	return;
}



void __cdecl lego::front::Info_SetText(InfoType infoType,char *text)
{
	if (globals::g_InfoDatas_TABLE[infoType].text != NULL) {
		std::free(globals::g_InfoDatas_TABLE[infoType].text);
	}
	Info_SetText_internal(text,globals::g_InfoDatas_TABLE + infoType);
	return;
}



void __cdecl lego::front::Info_SetFlag_20000(InfoType infoType,BOOL setFlag20000)
{
	if (setFlag20000 != 0) {
		globals::g_InfoDatas_TABLE[infoType].flags =
				 globals::g_InfoDatas_TABLE[infoType].flags | 0x20000;
		return;
	}
	globals::g_InfoDatas_TABLE[infoType].flags =
			 globals::g_InfoDatas_TABLE[infoType].flags & 0xfffdffff;
	return;
}



void __cdecl lego::front::Info_SetText_internal(char *text,InfoMessageData *infoData)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	BOOL BVar4;
	uint uVar5;
	int iVar6;
	int iVar7;
	char *pcVar8;
	char *pcVar9;
	uint local_30;
	InfoType local_2c;
	char acStack40 [8];
	char local_20 [32];
	
	pcVar9 = text;
	uVar5 = 0xffffffff;
	local_30 = 0;
	pcVar3 = text;
	do {
		if (uVar5 == 0) break;
		uVar5 -= 1;
		cVar2 = *pcVar3;
		pcVar3 = pcVar3 + 1;
	} while (cVar2 != '\0');
	pcVar3 = (char *)std::malloc(~uVar5 + 0xb);
	infoData->text = pcVar3;
	cVar2 = *pcVar9;
	while (cVar2 != '\0') {
		cVar2 = *pcVar9;
		if (cVar2 == '_') {
			*pcVar3 = ' ';
		}
		else {
			if (cVar2 == '$') {
				pcVar8 = pcVar9 + 1;
				iVar6 = 0;
				iVar7 = 0;
				cVar2 = pcVar9[1];
				pcVar9 = pcVar8;
				while (cVar2 != '$') {
					local_20[iVar6] = cVar2;
					pcVar1 = pcVar8 + 1;
					iVar6 += 1;
					pcVar8 = pcVar8 + 1;
					pcVar9 = pcVar9 + 1;
					cVar2 = *pcVar1;
				}
				local_20[iVar6] = '\0';
				BVar4 = Pointer_GetType(local_20,(PointerType *)&text);
				if (BVar4 == 0) {
					BVar4 = Info_GetInfoType(local_20,&local_2c);
					if (BVar4 != 0) {
						iVar7 = Info_GetField4(local_2c);
					}
				}
				else {
					iVar7 = Pointers_GetImage((PointerType)text);
				}
				if (iVar7 != 0) {
					*pcVar3 = '%';
					pcVar3 = pcVar3 + 1;
					acStack40[local_30] = (char)iVar7;
					local_30 += 1;
					*pcVar3 = 'b';
				}
			}
			else {
				if ((cVar2 == '\\') && (pcVar9[1] == 'n')) {
					*pcVar3 = '\n';
					pcVar9 = pcVar9 + 1;
				}
				else {
					*pcVar3 = cVar2;
				}
			}
		}
		pcVar8 = pcVar9 + 1;
		pcVar3 = pcVar3 + 1;
		pcVar9 = pcVar9 + 1;
		cVar2 = *pcVar8;
	}
	*pcVar3 = '\0';
	pcVar3 = pcVar3 + 1;
	uVar5 = 0;
	*pcVar3 = (char)local_30;
	do {
		pcVar3 = pcVar3 + 1;
		if (uVar5 < local_30) {
			*pcVar3 = acStack40[uVar5];
		}
		else {
			*pcVar3 = '\0';
		}
		uVar5 += 1;
	} while (uVar5 < 5);
	return;
}



void __cdecl lego::front::Info_FUN_00419580(int param_1,char *filename)
{
	ImageBMP *image;
	
	image = lego::image::Image_LoadBMPScaled(filename,0,0);
	globals::g_InfoDatas_TABLE[param_1].field_4 = image;
	lego::image::Image_SetPenZeroTrans(image);
	return;
}



void __cdecl lego::front::Info_SetSFXType(InfoType infoType,SFXType sfxType)
{
	globals::g_InfoDatas_TABLE[infoType].sfxType = sfxType;
	return;
}



BOOL __cdecl
lego::front::Info_DoCallbacks_FUN_004195d0(int instanceIndex,undefined *callback,void *data)
{
	int iVar1;
	InfoType IVar2;
	
	IVar2 = globals::g_InfoInstances_TABLE[instanceIndex].infoType;
	if (IVar2 == INFO_CRYSTALFOUND) {
		return 0;
	}
	do {
		iVar1 = (*(code *)callback)(IVar2,data);
		if (iVar1 != 0) {
			return 1;
		}
		IVar2 = *(InfoType *)(IVar2 + INFO_AIRDEPLETING);
	} while (IVar2 != INFO_CRYSTALFOUND);
	return 0;
}



void __cdecl lego::front::Info_FUN_00419620(int param_1,int param_2)
{
	InfoType IVar1;
	int iVar2;
	int iVar3;
	
	IVar1 = globals::g_InfoInstances_TABLE[param_1].infoType;
	if (IVar1 == INFO_CRYSTALFOUND) {
		globals::g_InfoInstances_TABLE[param_1].infoType = param_2;
		*(undefined4 *)(param_2 + 0x10) = 0;
		*(int *)&globals::g_InfoInstances_TABLE[param_1].field_0x4 =
				 *(int *)&globals::g_InfoInstances_TABLE[param_1].field_0x4 + 1;
		return;
	}
	iVar3 = 1;
	iVar2 = *(int *)(IVar1 + INFO_AIRDEPLETING);
	while (iVar2 != 0) {
		iVar3 += 1;
		if (iVar3 == 9) {
			Info_FUN_004196e0(param_1,0);
		}
		IVar1 = *(InfoType *)(IVar1 + INFO_AIRDEPLETING);
		iVar2 = *(int *)(IVar1 + INFO_AIRDEPLETING);
	}
	*(int *)(IVar1 + INFO_AIRDEPLETING) = param_2;
	*(undefined4 *)(param_2 + 0x10) = 0;
	*(int *)&globals::g_InfoInstances_TABLE[param_1].field_0x4 =
			 *(int *)&globals::g_InfoInstances_TABLE[param_1].field_0x4 + 1;
	return;
}



int __cdecl lego::front::Info_FUN_004196b0(int param_1,int param_2)
{
	InfoType IVar1;
	
	IVar1 = globals::g_InfoInstances_TABLE[param_1].infoType;
	if ((param_2 < 0) || (*(int *)&globals::g_InfoInstances_TABLE[param_1].field_0x4 <= param_2)) {
		IVar1 = INFO_CRYSTALFOUND;
	}
	else {
		if (0 < param_2) {
			do {
				IVar1 = *(InfoType *)(IVar1 + INFO_AIRDEPLETING);
				param_2 += -1;
			} while (param_2 != 0);
			return IVar1;
		}
	}
	return IVar1;
}



int __cdecl lego::front::Info_FUN_004196e0(int param_1,int param_2)
{
	int iVar1;
	int iVar2;
	
	iVar1 = Info_FUN_004196b0(param_1,param_2);
	if (iVar1 == 0) {
		return 0;
	}
	iVar2 = Info_FUN_004196b0(param_1,param_2 + -1);
	if (param_2 == 0) {
		globals::g_InfoInstances_TABLE[param_1].infoType = *(InfoType *)(iVar1 + 0x10);
	}
	else {
		*(undefined4 *)(iVar2 + 0x10) = *(undefined4 *)(iVar1 + 0x10);
	}
	*(int *)&globals::g_InfoInstances_TABLE[param_1].field_0x4 =
			 *(int *)&globals::g_InfoInstances_TABLE[param_1].field_0x4 + -1;
	return iVar1;
}



BOOL __cdecl lego::front::Info_LiveObject_Release_internal_FUN_00419740(int param_1,int *param_2)
{
	if (*(int *)(param_1 + 8) == *param_2) {
		return 1;
	}
	param_2[1] = param_2[1] + 1;
	return 0;
}



void __cdecl lego::game::lego::front::Info_LiveObject_Release(LiveObject *liveObj)
{
	int iVar1;
	uint instanceIndex;
	uint uVar2;
	int *piVar3;
	LiveObject *local_8;
	int local_4;
	
	local_8 = liveObj;
	instanceIndex = 0;
	if (globals::g_InfoInstances_COUNT != 0) {
		piVar3 = (int *)&globals::g_InfoInstances_TABLE[0].field_0x4;
		do {
			local_4 = 0;
			iVar1 = lego::front::Info_DoCallbacks_FUN_004195d0
												(instanceIndex,lego::front::Info_LiveObject_Release_internal_FUN_00419740,
												 &local_8);
			while (iVar1 != 0) {
				lego::front::Info_FUN_004196e0(instanceIndex,local_4);
				local_4 = 0;
				iVar1 = lego::front::Info_DoCallbacks_FUN_004195d0
													(instanceIndex,lego::front::Info_LiveObject_Release_internal_FUN_00419740,
													 &local_8);
			}
			uVar2 = instanceIndex;
			if (*piVar3 == 0) {
				uVar2 = instanceIndex - 1;
				piVar3 = piVar3 + -5;
				lego::front::Info_FUN_00419db0(instanceIndex);
			}
			instanceIndex = uVar2 + 1;
			piVar3 = piVar3 + 5;
		} while (instanceIndex < (uint)globals::g_InfoInstances_COUNT);
	}
	return;
}



BOOL __cdecl lego::front::Info_FUN_004197f0(int *param_1,int **param_2)
{
	if ((*param_1 == **param_2) && (param_1[1] == (*param_2)[1])) {
		return TRUE;
	}
	param_2[1] = (int *)((int)param_2[1] + 1);
	return 0;
}



void __cdecl lego::front::Info_DoAll_FUN_00419820(undefined4 param_1)
{
	int iVar1;
	int *piVar2;
	uint instanceIndex;
	uint uVar3;
	int *piVar4;
	undefined4 local_8;
	int local_4;
	
	local_8 = param_1;
	instanceIndex = 0;
	if (globals::g_InfoInstances_COUNT != 0) {
		piVar2 = (int *)&globals::g_InfoInstances_TABLE[0].field_0x4;
		piVar4 = (int *)&globals::g_InfoInstances_TABLE[0].field_0x8;
		do {
			uVar3 = instanceIndex;
			if ((*piVar4 == 6) || (*piVar4 == 7)) {
				local_4 = 0;
				iVar1 = Info_DoCallbacks_FUN_004195d0(instanceIndex,Info_FUN_004197f0,&local_8);
				while (iVar1 != 0) {
					Info_FUN_004196e0(instanceIndex,local_4);
					local_4 = 0;
					iVar1 = Info_DoCallbacks_FUN_004195d0(instanceIndex,Info_FUN_004197f0,&local_8);
				}
				if (*piVar2 == 0) {
					uVar3 = instanceIndex - 1;
					piVar4 = piVar4 + -5;
					piVar2 = piVar2 + -5;
					Info_FUN_00419db0(instanceIndex);
				}
			}
			instanceIndex = uVar3 + 1;
			piVar4 = piVar4 + 5;
			piVar2 = piVar2 + 5;
		} while (instanceIndex < (uint)globals::g_InfoInstances_COUNT);
	}
	return;
}



BOOL __cdecl lego::front::Info_Callback_FUN_004198d0(int *param_1,int *param_2)
{
	int iVar1;
	int *piVar2;
	
	iVar1 = *param_2;
	if ((((iVar1 != 0) || (param_2[1] != 0)) && ((iVar1 == 0 || (param_1[2] != iVar1)))) &&
		 (((piVar2 = (int *)param_2[1], piVar2 == NULL || (*param_1 != *piVar2)) ||
			(param_1[1] != piVar2[1])))) {
		return 0;
	}
	return 1;
}



BOOL __cdecl lego::front::Info_FUN_00419920(InfoType infoType,undefined4 param_2,undefined4 param_3)
{
	BOOL BVar1;
	uint instanceIndex;
	InfoType *pIVar2;
	undefined4 local_8;
	undefined4 local_4;
	
	if ((((infoType != INFO_LEGOMANDEATH) && (infoType != INFO_BUILDINGDEATH)) &&
			(infoType != INFO_VEHICLEDEATH)) && (infoType != INFO_GENERICDEATH)) {
		local_4 = param_3;
		instanceIndex = 0;
		local_8 = param_2;
		if (globals::g_InfoInstances_COUNT != 0) {
			pIVar2 = (InfoType *)&globals::g_InfoInstances_TABLE[0].field_0x8;
			do {
				if (infoType == *pIVar2) {
					BVar1 = Info_DoCallbacks_FUN_004195d0(instanceIndex,Info_Callback_FUN_004198d0,&local_8);
					if (BVar1 != 0) {
						return TRUE;
					}
				}
				instanceIndex += 1;
				pIVar2 = pIVar2 + 5;
			} while (instanceIndex < (uint)globals::g_InfoInstances_COUNT);
			return 0;
		}
	}
	return 0;
}



undefined4 __cdecl
lego::front::Info_CreateInstance(undefined4 *param_1,undefined4 param_2,char *param_3)
{
	undefined4 *puVar1;
	
	puVar1 = (undefined4 *)std::malloc(0x14);
	if (puVar1 == NULL) {
		return NULL;
	}
	if (param_1 == NULL) {
		puVar1[1] = 0xffffffff;
		*puVar1 = 0xffffffff;
	}
	else {
		*puVar1 = *param_1;
		puVar1[1] = param_1[1];
	}
	puVar1[2] = param_2;
	if (param_3 != NULL) {
		Info_SetText_internal(param_3,(InfoMessageData *)(puVar1 + 3));
		return puVar1;
	}
	puVar1[3] = 0;
	return puVar1;
}



void __cdecl lego::front::Info_SetFlag4(BOOL state)
{
	if (state != 0) {
		globals::g_InfoMessageFlags = globals::g_InfoMessageFlags | INFOMSG_UNK_4;
		return;
	}
	globals::g_InfoMessageFlags = globals::g_InfoMessageFlags & ~INFOMSG_UNK_4;
	return;
}



BOOL __cdecl lego::front::Info_HasText(InfoType infoType)
{
	return (uint)(globals::g_InfoDatas_TABLE[infoType].text != NULL);
}



int __cdecl lego::front::Info_FUN_00419a50(int param_1)
{
	int iVar1;
	int *piVar2;
	
	iVar1 = 0;
	if (0 < globals::g_InfoInstances_COUNT) {
		piVar2 = (int *)&globals::g_InfoInstances_TABLE[0].field_0x8;
		do {
			if (*piVar2 == param_1) {
				return iVar1;
			}
			iVar1 += 1;
			piVar2 = piVar2 + 5;
		} while (iVar1 < globals::g_InfoInstances_COUNT);
	}
	return -1;
}



float10 __cdecl lego::front::Info_FUN_00419a80(void)
{
	int iVar1;
	int *piVar2;
	int iVar3;
	float10 fVar4;
	
	fVar4 = (float10)333.0;
	if (globals::g_InfoInstances_COUNT != 0) {
		piVar2 = (int *)&globals::g_InfoInstances_TABLE[0].field_0x8;
		iVar3 = globals::g_InfoInstances_COUNT;
		do {
			iVar1 = *piVar2;
			piVar2 = piVar2 + 5;
			iVar3 += -1;
			fVar4 = fVar4 - (float10)*(int *)(globals::g_InfoDatas_TABLE[iVar1].field_4 + 8);
		} while (iVar3 != 0);
	}
	return fVar4;
}



void __cdecl
lego::front::Info_FUN_00419ab0(InfoType infoType,char *param_2,LiveObject *param_3,Point2I *param_4)
{
	InfoMessageInstance *pIVar1;
	int iVar2;
	TutorialFlags TVar3;
	BOOL BVar4;
	int iVar5;
	int iVar6;
	ProgrammerMode PVar7;
	float10 fVar8;
	
	if (((byte)globals::g_InfoMessageFlags & INFOMSG_UNK_4) != 0) {
		TVar3 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
		if ((TVar3 & TUTORIAL_UNK_100) == TUTORIAL_NONE) {
			if (((((byte)globals::g_InfoMessageFlags & INFOMSG_UNK_8) != 0) &&
					((globals::g_InfoDatas_TABLE[infoType].flags & 0x20000) != 0)) &&
				 ((ushort)((ushort)(globals::g_InfoDatas_TABLE[infoType].float_c < 0.0) << 8 |
									(ushort)(globals::g_InfoDatas_TABLE[infoType].float_c == 0.0) << 0xe) != 0)) {
				globals::g_InfoDatas_TABLE[infoType].float_c = 25.0;
				if (((infoType == INFO_LEGOMANDEATH) || (infoType == INFO_VEHICLEDEATH)) ||
					 (infoType == INFO_BUILDINGDEATH)) {
					globals::g_InfoDatas_TABLE[10].float_c = 25.0;
					globals::g_InfoDatas_TABLE[11].float_c = 25.0;
					globals::g_InfoDatas_TABLE[12].float_c = 25.0;
					globals::g_InfoDatas_TABLE[38].float_c = 25.0;
				}
				snd::SFX_Sample_Random_SetAndPlayGlobalSample
									(globals::g_InfoDatas_TABLE[infoType].sfxType,NULL);
			}
			BVar4 = Info_FUN_00419920(infoType,param_3,param_4);
			if (BVar4 == 0) {
				BVar4 = Info_HasText(infoType);
				if (BVar4 != 0) {
					iVar6 = globals::g_InfoDatas_TABLE[infoType].field_4;
					if (((((byte)globals::g_InfoMessageFlags & INFOMSG_UNK_8) != 0) &&
							((globals::g_InfoDatas_TABLE[infoType].flags & 0x20000) == 0)) &&
						 ((ushort)((ushort)(globals::g_InfoDatas_TABLE[infoType].float_c < 0.0) << 8 |
											(ushort)(globals::g_InfoDatas_TABLE[infoType].float_c == 0.0) << 0xe) != 0)) {
						globals::g_InfoDatas_TABLE[infoType].float_c = 25.0;
						if ((((infoType == INFO_LEGOMANDEATH) || (infoType == INFO_VEHICLEDEATH)) ||
								(infoType == INFO_BUILDINGDEATH)) || (infoType == INFO_GENERICDEATH)) {
							globals::g_InfoDatas_TABLE[10].float_c = 25.0;
							globals::g_InfoDatas_TABLE[11].float_c = 25.0;
							globals::g_InfoDatas_TABLE[12].float_c = 25.0;
							globals::g_InfoDatas_TABLE[38].float_c = 25.0;
						}
						snd::SFX_Sample_Random_SetAndPlayGlobalSample
											(globals::g_InfoDatas_TABLE[infoType].sfxType,NULL);
					}
					if (globals::g_InfoInstances_COUNT != 0x28) {
						iVar5 = Info_FUN_00419a50(infoType);
						iVar2 = globals::g_InfoInstances_COUNT;
						if (iVar5 == -1) {
							pIVar1 = globals::g_InfoInstances_TABLE + globals::g_InfoInstances_COUNT;
							globals::g_InfoInstances_COUNT = globals::g_InfoInstances_COUNT + 1;
							pIVar1->float_c = -(float)*(int *)(iVar6 + 4);
							fVar8 = Info_FUN_00419a80();
							*(float *)&globals::g_InfoInstances_TABLE[iVar2].field_0x10 = (float)fVar8;
							iVar5 = iVar2;
						}
						*(InfoType *)&globals::g_InfoInstances_TABLE[iVar5].field_0x8 = infoType;
						iVar6 = Info_CreateInstance((undefined4 *)param_4,param_3,param_2);
						Info_FUN_00419620(iVar5,iVar6);
						PVar7 = main::Main_ProgrammerMode();
						if (((PVar7 < 5) && (((byte)globals::g_InfoMessageFlags & INFOMSG_AUTOGAMESPEED) != 0))
							 && ((globals::g_InfoDatas_TABLE[infoType].flags & 0x10000) != 0)) {
							fVar8 = game::Game_GetGameSpeed();
							if ((ushort)((ushort)(fVar8 < (float10)1.0) << 8 |
													(ushort)(fVar8 == (float10)1.0) << 0xe) == 0) {
								game::Game_SetGameSpeed(1.0);
							}
						}
					}
				}
			}
		}
	}
	return;
}



void __cdecl lego::front::Info_FUN_00419cd0(void)
{
	if ((globals::g_InfoInstances_COUNT != 0) && (globals::g_InfoInstances_TABLE[0]._4_4_ != 0)) {
		if ((*(LiveObject **)(globals::g_InfoInstances_TABLE[0].infoType + INFO_CONSTRUCTED) != NULL) ||
			 ((0 < *(int *)globals::g_InfoInstances_TABLE[0].infoType &&
				(0 < *(int *)(globals::g_InfoInstances_TABLE[0].infoType + INFO_ICEROCKMONSTER))))) {
			game::LiveObject_FUN_0042dd70
								(*(LiveObject **)(globals::g_InfoInstances_TABLE[0].infoType + INFO_CONSTRUCTED),
								 (uint *)globals::g_InfoInstances_TABLE[0].infoType,0);
		}
	}
	return;
}



void __cdecl lego::front::Info_UpdateInstance_FUN_00419d10(uint param_1)
{
	InfoMessageInstance *pIVar1;
	int iVar2;
	InfoMessageInstance *pIVar3;
	InfoType *pIVar4;
	InfoMessageInstance *pIVar5;
	InfoType local_14 [5];
	
	if (param_1 < (uint)globals::g_InfoInstances_COUNT) {
		if (param_1 != 0) {
			pIVar3 = globals::g_InfoInstances_TABLE + param_1;
			pIVar4 = local_14;
			for (iVar2 = 5; pIVar1 = globals::g_InfoInstances_TABLE + param_1, iVar2 != 0; iVar2 += -1) {
				*pIVar4 = pIVar3->infoType;
				pIVar3 = (InfoMessageInstance *)&pIVar3->field_0x4;
				pIVar4 = pIVar4 + 1;
			}
			do {
				param_1 -= 1;
				pIVar3 = pIVar1 + -1;
				pIVar5 = pIVar1;
				for (iVar2 = 5; iVar2 != 0; iVar2 += -1) {
					pIVar5->infoType = pIVar3->infoType;
					pIVar3 = (InfoMessageInstance *)&pIVar3->field_0x4;
					pIVar5 = (InfoMessageInstance *)&pIVar5->field_0x4;
				}
				pIVar1 = pIVar1 + -1;
			} while (param_1 != 0);
			pIVar4 = local_14;
			pIVar3 = globals::g_InfoInstances_TABLE;
			for (iVar2 = 5; iVar2 != 0; iVar2 += -1) {
				pIVar3->infoType = *pIVar4;
				pIVar4 = pIVar4 + 1;
				pIVar3 = (InfoMessageInstance *)&pIVar3->field_0x4;
			}
		}
		globals::g_InfoMessageFlags |= INFOMSG_UNK_1|INFOMSG_UNK_2;
	}
	return;
}



void __cdecl lego::front::Info_FUN_00419d90(void)
{
	if (globals::g_InfoInstances_COUNT != 0) {
		Info_FUN_00419db0(0);
	}
	return;
}



void __cdecl lego::front::Info_FUN_00419db0(uint param_1)
{
	int iVar1;
	InfoMessageInstance *pIVar2;
	uint uVar3;
	InfoMessageInstance *pIVar4;
	InfoMessageInstance *pIVar5;
	
	if (param_1 < (uint)globals::g_InfoInstances_COUNT) {
		iVar1 = Info_FUN_004196e0(param_1,0);
		if ((iVar1 != 0) && (*(void **)(iVar1 + 0xc) != NULL)) {
			std::free(*(void **)(iVar1 + 0xc));
		}
		if (*(int *)&globals::g_InfoInstances_TABLE[param_1].field_0x4 == 0) {
			if (param_1 < (uint)globals::g_InfoInstances_COUNT) {
				pIVar2 = globals::g_InfoInstances_TABLE + param_1;
				uVar3 = param_1;
				do {
					uVar3 += 1;
					pIVar4 = pIVar2 + 1;
					pIVar5 = pIVar2;
					for (iVar1 = 5; iVar1 != 0; iVar1 += -1) {
						pIVar5->infoType = pIVar4->infoType;
						pIVar4 = (InfoMessageInstance *)&pIVar4->field_0x4;
						pIVar5 = (InfoMessageInstance *)&pIVar5->field_0x4;
					}
					pIVar2 = pIVar2 + 1;
				} while (uVar3 < (uint)globals::g_InfoInstances_COUNT);
			}
			globals::g_InfoInstances_COUNT += -1;
		}
		if (param_1 == 0) {
			globals::g_InfoMessageFlags &= ~INFOMSG_UNK_1;
		}
	}
	return;
}



void __cdecl lego::front::Info_FUN_00419e40(void)
{
	if (globals::g_InfoInstances_COUNT != 0) {
		do {
			Info_FUN_00419db0(0);
		} while (globals::g_InfoInstances_COUNT != 0);
	}
	return;
}



void __cdecl lego::front::Info_FUN_00419e60(float param_1)
{
	ImageBMP *image;
	int y;
	int x;
	ImageFont *font;
	uint uVar1;
	float *pfVar2;
	longlong lVar3;
	char *msg;
	float fVar4;
	Point2F local_8;
	
	local_8.y = 333.0;
	uVar1 = 0;
	if (globals::g_InfoInstances_COUNT == 0) {
		return;
	}
	pfVar2 = (float *)&globals::g_InfoInstances_TABLE[0].field_0x10;
	while( true ) {
		image = (ImageBMP *)globals::g_InfoDatas_TABLE[(int)pfVar2[-2]].field_4;
		if ((ushort)((ushort)(local_8.y < *pfVar2) << 8 | (ushort)(local_8.y == *pfVar2) << 0xe) == 0) {
			*pfVar2 = *pfVar2 - param_1 * -8.0;
		}
		if (local_8.y < *pfVar2) {
			*pfVar2 = local_8.y;
		}
		if (pfVar2[-1] < 0.0) {
			pfVar2[-1] = pfVar2[-1] - param_1 * -3.0;
		}
		if ((ushort)((ushort)(pfVar2[-1] < 0.0) << 8 | (ushort)(pfVar2[-1] == 0.0) << 0xe) == 0) {
			pfVar2[-1] = 0.0;
		}
		local_8.y = *pfVar2;
		local_8.x = pfVar2[-1];
		lego::image::Image_DisplayScaled(image,NULL,&local_8,NULL);
		if (local_8.y < 0.0) break;
		fVar4 = pfVar2[-3];
		msg = "%i";
		lVar3 = __ftol((float10)local_8.y);
		y = (int)lVar3 + 10;
		lVar3 = __ftol((float10)local_8.x);
		x = (int)lVar3 + 2;
		font = (ImageFont *)Info_GetFont_004ddd58();
		lego::image::Font_PrintF(font,x,y,msg,fVar4);
		uVar1 += 1;
		pfVar2 = pfVar2 + 5;
		local_8.y = local_8.y - (float)image->height;
		if ((uint)globals::g_InfoInstances_COUNT <= uVar1) {
			return;
		}
	}
	local_8.y = 0.0;
	lego::image::Image_DisplayScaled(globals::g_MessageTabs_InfoOverFlow_bmp,NULL,&local_8,NULL);
	return;
}



void __cdecl lego::front::Info_FUN_00419fb0(float param_1)
{
	char cVar1;
	uint uVar2;
	char *msg;
	char *pcVar3;
	
	if (((globals::g_InfoMessageFlags & INFOMSG_UNK_1) == INFOMSG_NONE) ||
		 (globals::g_InfoInstances_COUNT == 0)) {
		if (((byte)globals::g_PanelDatas_TABLE[7].flags & 4) == 0) {
			Panel_FUN_0045adc0(PANEL_INFORMATION);
		}
	}
	else {
		if (((byte)globals::g_PanelDatas_TABLE[7].flags & 2) == 0) {
			Panel_FUN_0045adc0(PANEL_INFORMATION);
		}
		if ((globals::g_InfoMessageFlags & INFOMSG_UNK_2) != INFOMSG_NONE) {
			Panel_TextWindow_Clear(PTR_005017d8);
			msg = *(char **)(globals::g_InfoInstances_TABLE[0].infoType + INFO_BUILDINGDEATH);
			if (msg == NULL) {
				msg = globals::g_InfoDatas_TABLE[globals::g_InfoInstances_TABLE[0]._8_4_].text;
			}
			uVar2 = 0xffffffff;
			pcVar3 = msg;
			do {
				if (uVar2 == 0) break;
				uVar2 -= 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar3 + 1;
			} while (cVar1 != '\0');
			uVar2 = ~uVar2;
			if (msg[uVar2] == '\0') {
				Panel_TextWindow_PrintF(PTR_005017d8,msg);
			}
			else {
				Panel_TextWindow_PrintF
									(PTR_005017d8,msg,(uint)(byte)msg[uVar2 + 1],(uint)(byte)msg[uVar2 + 2],
									 (uint)(byte)msg[uVar2 + 3],(uint)(byte)msg[uVar2 + 4],(uint)(byte)msg[uVar2 + 5])
				;
			}
			Panel_TextWindow_Update(PTR_005017d8,INT_004ddd44,param_1);
			Info_FUN_0041a180();
			globals::g_InfoMessageFlags &= ~INFOMSG_UNK_2;
		}
	}
	Panel_TextWindow_Update(PTR_005017d8,INT_004ddd44,param_1);
	return;
}



BOOL __cdecl lego::front::Info_Update_FUN_0041a0d0(int mouseX,int mouseY,BOOL leftReleased)
{
	int iVar1;
	uint uVar2;
	float *pfVar3;
	longlong lVar4;
	
	uVar2 = 0;
	if (globals::g_InfoInstances_COUNT == 0) {
		return 0;
	}
	pfVar3 = (float *)&globals::g_InfoInstances_TABLE[0].field_0x10;
	do {
		iVar1 = *(int *)(globals::g_InfoDatas_TABLE[(int)pfVar3[-2]].field_4 + 8);
		if ((-1 < mouseX) &&
			 (mouseX <= *(int *)(globals::g_InfoDatas_TABLE[(int)pfVar3[-2]].field_4 + 4))) {
			lVar4 = __ftol((float10)*pfVar3);
			if (((int)lVar4 <= mouseY) && (mouseY <= iVar1 + (int)lVar4)) {
				if (leftReleased != 0) {
					if (((globals::g_InfoMessageFlags & INFOMSG_UNK_1) != INFOMSG_NONE) && (uVar2 == 0)) {
						Panel_FUN_0045adc0(PANEL_INFORMATION);
						globals::g_InfoMessageFlags = globals::g_InfoMessageFlags & ~INFOMSG_UNK_1;
						return TRUE;
					}
					Info_UpdateInstance_FUN_00419d10(uVar2);
				}
				return TRUE;
			}
		}
		uVar2 += 1;
		pfVar3 = pfVar3 + 5;
		if ((uint)globals::g_InfoInstances_COUNT <= uVar2) {
			return 0;
		}
	} while( true );
}



void __cdecl lego::front::Info_FUN_0041a180(void)
{
	int iVar1;
	uint local_8;
	uint local_4;
	
	Panel_TextWindow_GetInfo(PTR_005017d8,&local_8,&local_4);
	iVar1 = local_8 - local_4;
	if (iVar1 < 0) {
		iVar1 = 0;
	}
	FUN_00464190(0,iVar1,0);
	Info_FUN_0041a1c0();
	return;
}



void __cdecl lego::front::Info_FUN_0041a1c0(void)
{
	int local_8;
	int local_4;
	
	draw::Draw_UnkFuncOfInterestTable__00464160(0,&local_8,&local_4);
	INT_004ddd44 = local_8 - local_4;
	return;
}



void __cdecl lego::front::Info_FUN_0041a1f0(float elapsed)
{
	float *pfVar1;
	
	pfVar1 = &globals::g_InfoDatas_TABLE[0].float_c;
	do {
		if ((ushort)((ushort)(*pfVar1 < 0.0) << 8 | (ushort)(*pfVar1 == 0.0) << 0xe) == 0) {
			*pfVar1 = *pfVar1 - elapsed;
		}
		pfVar1 = pfVar1 + 5;
	} while (pfVar1 < &globals::g_InfoInstances_TABLE[0].float_c);
	return;
}



ImageFont * __cdecl lego::front::Info_GetFont_004ddd58(void)
{
	return PTRImageFont_004ddd58;
}



void __cdecl lego::front::Interface_Initialise(uint x_565,uint y_18,ImageFont *font)
{
	ToolTip_SetFlag10(TOOLTIP_INTERFACEMENU,TRUE);
	Point2F_004decd0.x = (float)(ulonglong)x_565;
	globals::g_InterfaceMenuItemNames_TABLE[0] = "Interface_MenuItem_BackToDefault";
	Point2F_004decd0.y = (float)(ulonglong)y_18;
	PTRImageFont_004ddd58 = font;
	globals::g_InterfaceMenuItemNames_TABLE[1] = "Interface_MenuItem_TeleportMan";
	globals::g_InterfaceMenuItemNames_TABLE[2] = "Interface_MenuItem_BuildBuilding";
	globals::g_InterfaceMenuItemNames_TABLE[3] = "Interface_MenuItem_BuildSmallVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[4] = "Interface_MenuItem_BuildLargeVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[5] = "Interface_MenuItem_LayPath";
	globals::g_InterfaceMenuItemNames_TABLE[7] = "Interface_MenuItem_RepairLava";
	globals::g_InterfaceMenuItemNames_TABLE[8] = "Interface_MenuItem_GeologistTest";
	globals::g_InterfaceMenuItemNames_TABLE[9] = "Interface_MenuItem_ClearRubble";
	globals::g_InterfaceMenuItemNames_TABLE[10] = "Interface_MenuItem_Dam";
	globals::g_InterfaceMenuItemNames_TABLE[17] = "Interface_MenuItem_SelectMan";
	globals::g_InterfaceMenuItemNames_TABLE[32] = "Interface_MenuItem_DeleteMan";
	globals::g_InterfaceMenuItemNames_TABLE[41] = "Interface_MenuItem_DeleteVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[40] = "Interface_MenuItem_DeleteBuilding";
	globals::g_InterfaceMenuItemNames_TABLE[43] = "Interface_MenuItem_Attack";
	globals::g_InterfaceMenuItemNames_TABLE[18] = "Interface_MenuItem_SelectVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[22] = "Interface_MenuItem_UnLoadVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[23] = "Interface_MenuItem_UnLoadMinifigure";
	globals::g_InterfaceMenuItemNames_TABLE[20] = "Interface_MenuItem_VehiclePickUp";
	globals::g_InterfaceMenuItemNames_TABLE[21] = "Interface_MenuItem_MinifigurePickUp";
	globals::g_InterfaceMenuItemNames_TABLE[25] = "Interface_MenuItem_GetOut";
	globals::g_InterfaceMenuItemNames_TABLE[24] = "Interface_MenuItem_GetIn";
	globals::g_InterfaceMenuItemNames_TABLE[26] = "Interface_MenuItem_GotoDock";
	globals::g_InterfaceMenuItemNames_TABLE[11] = "Interface_MenuItem_Dig";
	globals::g_InterfaceMenuItemNames_TABLE[12] = "Interface_MenuItem_Reinforce";
	globals::g_InterfaceMenuItemNames_TABLE[13] = "Interface_MenuItem_Dynamite";
	globals::g_InterfaceMenuItemNames_TABLE[64] = "Interface_MenuItem_UpgradeMan";
	globals::g_InterfaceMenuItemNames_TABLE[31] = "Interface_MenuItem_GoFeed";
	globals::g_InterfaceMenuItemNames_TABLE[45] = "Interface_MenuItem_GotoFirstPerson";
	globals::g_InterfaceMenuItemNames_TABLE[46] = "Interface_MenuItem_GotoSecondPerson";
	globals::g_InterfaceMenuItemNames_TABLE[57] = "Interface_MenuItem_TrainSkill";
	globals::g_InterfaceMenuItemNames_TABLE[34] = "Interface_MenuItem_PowerOn";
	globals::g_InterfaceMenuItemNames_TABLE[35] = "Interface_MenuItem_PowerOff";
	globals::g_InterfaceMenuItemNames_TABLE[65] = "Interface_MenuItem_UpgradeBuilding";
	globals::g_InterfaceMenuItemNames_TABLE[36] = "Interface_MenuItem_Repair";
	globals::g_InterfaceMenuItemNames_TABLE[19] = "Interface_MenuItem_SelectBuilding";
	globals::g_InterfaceMenuItemNames_TABLE[44] = "Interface_MenuItem_GotoTopView";
	globals::g_InterfaceMenuItemNames_TABLE[48] = "Interface_MenuItem_GetTool";
	globals::g_InterfaceMenuItemNames_TABLE[49] = "Interface_MenuItem_GetDrill";
	globals::g_InterfaceMenuItemNames_TABLE[50] = "Interface_MenuItem_GetSpade";
	globals::g_InterfaceMenuItemNames_TABLE[51] = "Interface_MenuItem_GetHammer";
	globals::g_InterfaceMenuItemNames_TABLE[52] = "Interface_MenuItem_GetSpanner";
	globals::g_InterfaceMenuItemNames_TABLE[58] = "Interface_MenuItem_TrainDriver";
	globals::g_InterfaceMenuItemNames_TABLE[59] = "Interface_MenuItem_TrainEngineer";
	globals::g_InterfaceMenuItemNames_TABLE[60] = "Interface_MenuItem_TrainGeologist";
	globals::g_InterfaceMenuItemNames_TABLE[61] = "Interface_MenuItem_TrainPilot";
	globals::g_InterfaceMenuItemNames_TABLE[62] = "Interface_MenuItem_TrainSailor";
	globals::g_InterfaceMenuItemNames_TABLE[63] = "Interface_MenuItem_TrainDynamite";
	globals::g_InterfaceMenuItemNames_TABLE[73] = "Interface_MenuItem_Build";
	globals::g_InterfaceMenuItemNames_TABLE[14] = "Interface_MenuItem_PlaceFence";
	globals::g_InterfaceMenuItemNames_TABLE[37] = "Interface_MenuItem_MakeTeleporterPrimary";
	globals::g_InterfaceMenuItemNames_TABLE[15] = "Interface_MenuItem_DeselectDig";
	globals::g_InterfaceMenuItemNames_TABLE[72] = "Interface_MenuItem_ClearSelection";
	globals::g_InterfaceMenuItemNames_TABLE[71] = "Interface_MenuItem_Encyclopedia";
	globals::g_InterfaceMenuItemNames_TABLE[38] = "Interface_MenuItem_EjectCrystal";
	globals::g_InterfaceMenuItemNames_TABLE[39] = "Interface_MenuItem_EjectOre";
	globals::g_InterfaceMenuItemNames_TABLE[47] = "Interface_MenuItem_TrackObject";
	globals::g_InterfaceMenuItemNames_TABLE[27] = "Interface_MenuItem_LegoManGoto";
	globals::g_InterfaceMenuItemNames_TABLE[30] = "Interface_MenuItem_LegoManDig";
	globals::g_InterfaceMenuItemNames_TABLE[28] = "Interface_MenuItem_VehicleGoto";
	globals::g_InterfaceMenuItemNames_TABLE[29] = "Interface_MenuItem_VehicleDig";
	globals::g_InterfaceMenuItemNames_TABLE[6] = "Interface_MenuItem_RemovePath";
	globals::g_InterfaceMenuItemNames_TABLE[66] = "Interface_MenuItem_UpgradeVehicle";
	globals::g_InterfaceMenuItemNames_TABLE[67] = "Interface_MenuItem_UpgradeEngine";
	globals::g_InterfaceMenuItemNames_TABLE[68] = "Interface_MenuItem_UpgardeDrill";
	globals::g_InterfaceMenuItemNames_TABLE[69] = "Interface_MenuItem_UpgardeScan";
	globals::g_InterfaceMenuItemNames_TABLE[70] = "Interface_MenuItem_UpgardeCarry";
	globals::g_InterfaceMenuItemNames_TABLE[42] = "Interface_MenuItem_DeleteElectricFence";
	globals::g_InterfaceMenuItemNames_TABLE[53] = "Interface_MenuItem_GetLaser";
	globals::g_InterfaceMenuItemNames_TABLE[54] = "Interface_MenuItem_GetPusherGun";
	globals::g_InterfaceMenuItemNames_TABLE[55] = "Interface_MenuItem_GetFreezerGun";
	globals::g_InterfaceMenuItemNames_TABLE[56] = "Interface_MenuItem_GetBirdScarer";
	globals::g_InterfaceMenuItemNames_TABLE[33] = "Interface_MenuItem_DropBirdScarer";
	globals::g_InterfaceMenuItemNames_TABLE[16] = "Interface_MenuItem_CancelConstruction";
	Interface_AddAllMenuItems();
	Interface_SetUnkPositions1(x_565,y_18,globs::mainGlobs.appWidth + 10,y_18,750.0);
	Interface_ResetUnkValues();
	return;
}



void __cdecl lego::front::Interface_AddAllMenuItems(void)
{
	Interface_AddMenuItem
						(INTERFACE_MENU_MAIN,4,INTERFACE_MENUITEM_TEKEPORTMAN,INTERFACE_MENUITEM_BUILDBUILDING,
						 INTERFACE_MENUITEM_BUILDSMALLVEHICLE,INTERFACE_MENUITEM_BUILDLARGEVEHICLE);
	Interface_AddMenuItem
						(INTERFACE_MENU_GROUND,3,INTERFACE_MENUITEM_LAYPATH,INTERFACE_MENUITEM_REMOVEPATH,
						 INTERFACE_MENUITEM_PLACEFENCE);
	Interface_AddMenuItem(INTERFACE_MENU_ERODE,1,INTERFACE_MENUITEM_REPAIRLAVA);
	Interface_AddMenuItem(INTERFACE_MENU_PLACEFENCE,1,INTERFACE_MENUITEM_PLACEFENCE);
	Interface_AddMenuItem(INTERFACE_MENU_CONSTRUCTION,1,INTERFACE_MENUITEM_CANCELCONSTRUCTION);
	Interface_AddMenuItem
						(INTERFACE_MENU_RUBBLE,2,INTERFACE_MENUITEM_CLEARRUBBLE,INTERFACE_MENUITEM_PLACEFENCE);
	Interface_AddMenuItem
						(INTERFACE_MENU_WALL,4,INTERFACE_MENUITEM_DIG,INTERFACE_MENUITEM_REINFORCE,
						 INTERFACE_MENUITEM_DYNAMITE,INTERFACE_MENUITEM_DESELECTDIG);
	Interface_AddMenuItem
						(INTERFACE_MENU_TRACKER,2,INTERFACE_MENUITEM_ATTACK,INTERFACE_MENUITEM_TRACKOBJECT);
	Interface_AddMenuItem
						(INTERFACE_MENU_VEHICLE,7,INTERFACE_MENUITEM_UNLOADVEHICLE,
						 INTERFACE_MENUITEM_VEHICLEPICKUP,INTERFACE_MENUITEM_UPGRADEVEHICLE,
						 INTERFACE_MENUITEM_GETOUT,INTERFACE_MENUITEM_GOTOFIRSTPERSON,
						 INTERFACE_MENUITEM_GOTOSECONDPERSON,INTERFACE_MENUITEM_DELETEVEHICLE);
	Interface_AddMenuItem
						(INTERFACE_MENU_WATERVEHICLE,6,INTERFACE_MENUITEM_UNLOADVEHICLE,
						 INTERFACE_MENUITEM_VEHICLEPICKUP,INTERFACE_MENUITEM_GETOUT,
						 INTERFACE_MENUITEM_GOTOFIRSTPERSON,INTERFACE_MENUITEM_GOTOSECONDPERSON,
						 INTERFACE_MENUITEM_GOTODOCK);
	Interface_AddMenuItem
						(INTERFACE_MENU_UNMANNEDVEHICLE,2,INTERFACE_MENUITEM_GETIN,
						 INTERFACE_MENUITEM_DELETEVEHICLE);
	Interface_AddMenuItem
						(INTERFACE_MENU_LEGOMAN,10,INTERFACE_MENUITEM_GOFEED,INTERFACE_MENUITEM_UNLOADMINIFIGURE
						 ,INTERFACE_MENUITEM_MINIFIGUREPICKUP,INTERFACE_MENUITEM_GETTOOL,
						 INTERFACE_MENUITEM_DROPBIRDSCARER,INTERFACE_MENUITEM_UPGRADEMAN,
						 INTERFACE_MENUITEM_TRAINSKILL,INTERFACE_MENUITEM_GOTOFIRSTPERSON,
						 INTERFACE_MENUITEM_GOTOSECONDPERSON,INTERFACE_MENUITEM_DELETEMAN);
	Interface_AddMenuItem
						(INTERFACE_MENU_BUILDING,4,INTERFACE_MENUITEM_REPAIR,INTERFACE_MENUITEM_POWERON,
						 INTERFACE_MENUITEM_UPGRADEBUILDING,INTERFACE_MENUITEM_DELETEBUILDING);
	Interface_AddMenuItem(INTERFACE_MENU_ELECTRICFENCE,1,INTERFACE_MENUITEM_DELETEELECTRICFENCE);
	Interface_AddMenuItem
						(INTERFACE_MENU_FIRSTPERSON,3,INTERFACE_MENUITEM_GOTOTOPVIEW,
						 INTERFACE_MENUITEM_GOTOSECONDPERSON,INTERFACE_MENUITEM_GOTOFIRSTPERSON);
	Interface_AddMenuItem
						(INTERFACE_MENU_GETTOOL,8,INTERFACE_MENUITEM_GETDRILL,INTERFACE_MENUITEM_GETSPADE,
						 INTERFACE_MENUITEM_GETHAMMER,INTERFACE_MENUITEM_GETSPANNER,INTERFACE_MENUITEM_GETLASER,
						 INTERFACE_MENUITEM_GETPUSHERGUN,INTERFACE_MENUITEM_GETFREEZERGUN,
						 INTERFACE_MENUITEM_GETBIRDSCARER);
	Interface_AddMenuItem
						(INTERFACE_MENU_TRAINSKILL,6,INTERFACE_MENUITEM_TRAINDRIVER,
						 INTERFACE_MENUITEM_TRAINENGINEER,INTERFACE_MENUITEM_TRAINGEOLOGIST,
						 INTERFACE_MENUITEM_TRAINPILOT,INTERFACE_MENUITEM_TRAINSAILOR,
						 INTERFACE_MENUITEM_TRAINDYNAMITE);
	Interface_AddMenuItem
						(INTERFACE_MENU_UPGRADEVEHICLE,4,INTERFACE_MENUITEM_UPGRADEENGINE,
						 INTERFACE_MENUITEM_UPGRADEDRILL,INTERFACE_MENUITEM_UPGRADESCAN,
						 INTERFACE_MENUITEM_UPGRADECARRY);
	return;
}



void __cdecl
lego::front::Interface_AddMenuItem(InterfaceMenuType interfaceMenuType,int numParams,...)
{
	MenuIcon MVar1;
	MenuIcon *pMVar2;
	MenuIcon *pMVar3;
	uint uVar4;
	int iVar5;
	MenuIcon *pMVar6;
	MenuIcon local_78 [30];
	
	globals::g_InterfaceMenuItemDefines_TABLE[interfaceMenuType].numIcons = numParams;
	pMVar2 = (MenuIcon *)std::malloc(numParams * 4);
	globals::g_InterfaceMenuItemDefines_TABLE[interfaceMenuType].iconList = pMVar2;
	pMVar3 = (MenuIcon *)&stack0x0000000c;
	if (numParams != 0) {
		pMVar6 = local_78;
		do {
			MVar1 = *pMVar3;
			pMVar3 = pMVar3 + 1;
			*pMVar6 = MVar1;
			pMVar6 = pMVar6 + 1;
			numParams += -1;
		} while (numParams != 0);
	}
	pMVar3 = local_78;
	for (uVar4 = globals::g_InterfaceMenuItemDefines_TABLE[interfaceMenuType].numIcons & 0x3fffffff;
			uVar4 != 0; uVar4 -= 1) {
		*pMVar2 = *pMVar3;
		pMVar3 = pMVar3 + 1;
		pMVar2 = pMVar2 + 1;
	}
	for (iVar5 = 0; iVar5 != 0; iVar5 += -1) {
		*(undefined *)pMVar2 = *(undefined *)pMVar3;
		pMVar3 = (MenuIcon *)((int)pMVar3 + 1);
		pMVar2 = (MenuIcon *)((int)pMVar2 + 1);
	}
	return;
}



void __cdecl lego::front::Interface_FreeInterfaceIcons(void)
{
	InterfaceMenuItem *pIVar1;
	
	pIVar1 = globals::g_InterfaceMenuItemDefines_TABLE;
	do {
		if (pIVar1->iconList != NULL) {
			std::free(pIVar1->iconList);
		}
		pIVar1 = pIVar1 + 1;
	} while (pIVar1 < &Point2IBlockPos_004decc4);
	std::free(globals::g_InterfaceBuildImages_Vehicles_normal_TABLE);
	std::free(globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE);
	std::free(globals::g_InterfaceBuildImages_Vehicles_disabled_TABLE);
	std::free(globals::g_SubmenuIcons_VehicleTypesClicked_TABLE);
	std::free(globals::g_InterfaceBuildKeys_Vehicles_TABLE);
	std::free(globals::g_SubmenuIcons_VehicleTypes2_TABLE);
	std::free(globals::g_InterfaceBuildImages_Buildings_normal_TABLE);
	std::free(globals::g_InterfaceBuildImages_Buildings_pressed_TABLE);
	std::free(globals::g_InterfaceBuildImages_Buildings_disabled_TABLE);
	std::free(globals::g_SubmenuIcons_BuildingTypesClicked_TABLE);
	std::free(globals::g_InterfaceBuildKeys_Buildings_TABLE);
	std::free(globals::g_SubmenuIcons_BuildingTypes2_TABLE);
	return;
}



void __cdecl lego::front::Interface_LevelFree_FUN_0041a850(void)
{
	int iVar1;
	uint uVar2;
	uint uVar3;
	uint *puVar4;
	undefined4 *puVar5;
	undefined4 *puVar6;
	
	FLAGS_004df1f8 = 0;
	puVar4 = globals::g_Interface_Icons_Clicked;
	for (iVar1 = 0x4a; iVar1 != 0; iVar1 += -1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	puVar4 = UINT_ARRAY_004de60c;
	for (iVar1 = 0x4a; uVar2 = globs::gameGlobs.VehicleTypes_COUNT,
			puVar6 = (undefined4 *)globals::g_SubmenuIcons_VehicleTypesClicked_TABLE, iVar1 != 0;
			iVar1 += -1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	for (; uVar3 = globs::gameGlobs.VehicleTypes_COUNT,
			puVar5 = (undefined4 *)globals::g_SubmenuIcons_VehicleTypes2_TABLE, uVar2 != 0;
			uVar2 = uVar2 - 1) {
		*puVar6 = 0;
		puVar6 = puVar6 + 1;
	}
	for (; uVar2 = globs::gameGlobs.BuildingTypes_COUNT,
			puVar6 = (undefined4 *)globals::g_SubmenuIcons_BuildingTypesClicked_TABLE, uVar3 != 0;
			uVar3 = uVar3 - 1) {
		*puVar5 = 0;
		puVar5 = puVar5 + 1;
	}
	for (; uVar3 = globs::gameGlobs.BuildingTypes_COUNT,
			puVar5 = (undefined4 *)globals::g_SubmenuIcons_BuildingTypes2_TABLE, uVar2 != 0;
			uVar2 = uVar2 - 1) {
		*puVar6 = 0;
		puVar6 = puVar6 + 1;
	}
	for (; uVar3 != 0; uVar3 = uVar3 - 1) {
		*puVar5 = 0;
		puVar5 = puVar5 + 1;
	}
	puVar6 = &DAT_004ded34;
	for (iVar1 = 300; iVar1 != 0; iVar1 += -1) {
		*puVar6 = 0;
		puVar6 = puVar6 + 1;
	}
	Interface_ResetUnkValues();
	return;
}



void __cdecl lego::front::Interface_ResetUnkValues(void)
{
	InterfaceMenuType_004deccc = INTERFACE_MENU_MAIN;
	Point2F_004decd0.x = Point2F_004dece8.x;
	FLAGS_004df1f8 = FLAGS_004df1f8 | 0x84;
	return;
}



BOOL __cdecl lego::front::Interface_GetMenuItemType(char *menuItemName,int *out_menuItemType)
{
	int iVar1;
	char **ppcVar2;
	int iVar3;
	
	iVar3 = 0;
	ppcVar2 = globals::g_InterfaceMenuItemNames_TABLE;
	do {
		iVar1 = std::_stricmp((char *)*ppcVar2,menuItemName);
		if (iVar1 == 0) {
			*out_menuItemType = iVar3;
			return 1;
		}
		ppcVar2 = (char **)((ImageBMP **)ppcVar2 + 1);
		iVar3 += 1;
	} while (ppcVar2 < PTRImageBMP_ARRAY_004ddff8);
	return 0;
}



void __cdecl lego::main::lego::front::Interface_InitSubmenuIconTables(void)
{
	uint uVar1;
	uint uVar2;
	undefined4 *puVar3;
	
	globals::g_SubmenuIcons_VehicleTypesClicked_TABLE =
			 std::malloc(globs::gameGlobs.VehicleTypes_COUNT * 4);
	puVar3 = (undefined4 *)globals::g_SubmenuIcons_VehicleTypesClicked_TABLE;
	for (uVar1 = globs::gameGlobs.VehicleTypes_COUNT; uVar1 != 0; uVar1 -= 1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	globals::g_InterfaceBuildKeys_Vehicles_TABLE =
			 (byte *)std::malloc(globs::gameGlobs.VehicleTypes_COUNT);
	uVar1 = globs::gameGlobs.VehicleTypes_COUNT;
	puVar3 = (undefined4 *)globals::g_InterfaceBuildKeys_Vehicles_TABLE;
	for (uVar2 = globs::gameGlobs.VehicleTypes_COUNT >> 2; uVar2 != 0; uVar2 -= 1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	for (uVar1 &= 3; uVar1 != 0; uVar1 -= 1) {
		*(undefined *)puVar3 = 0;
		puVar3 = (undefined4 *)((int)puVar3 + 1);
	}
	globals::g_SubmenuIcons_VehicleTypes2_TABLE = std::malloc(globs::gameGlobs.VehicleTypes_COUNT * 4)
	;
	puVar3 = (undefined4 *)globals::g_SubmenuIcons_VehicleTypes2_TABLE;
	for (uVar1 = globs::gameGlobs.VehicleTypes_COUNT; uVar1 != 0; uVar1 -= 1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	globals::g_SubmenuIcons_BuildingTypesClicked_TABLE =
			 std::malloc(globs::gameGlobs.BuildingTypes_COUNT * 4);
	puVar3 = (undefined4 *)globals::g_SubmenuIcons_BuildingTypesClicked_TABLE;
	for (uVar1 = globs::gameGlobs.BuildingTypes_COUNT; uVar1 != 0; uVar1 -= 1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	globals::g_InterfaceBuildKeys_Buildings_TABLE =
			 (byte *)std::malloc(globs::gameGlobs.BuildingTypes_COUNT);
	uVar1 = globs::gameGlobs.BuildingTypes_COUNT;
	puVar3 = (undefined4 *)globals::g_InterfaceBuildKeys_Buildings_TABLE;
	for (uVar2 = globs::gameGlobs.BuildingTypes_COUNT >> 2; uVar2 != 0; uVar2 -= 1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	for (uVar1 &= 3; uVar1 != 0; uVar1 -= 1) {
		*(undefined *)puVar3 = 0;
		puVar3 = (undefined4 *)((int)puVar3 + 1);
	}
	globals::g_SubmenuIcons_BuildingTypes2_TABLE =
			 std::malloc(globs::gameGlobs.BuildingTypes_COUNT * 4);
	puVar3 = (undefined4 *)globals::g_SubmenuIcons_BuildingTypes2_TABLE;
	for (uVar1 = globs::gameGlobs.BuildingTypes_COUNT; uVar1 != 0; uVar1 -= 1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	return;
}



void __cdecl lego::front::Interface_LoadInterfaceBuildImages(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	ImageBMP *pIVar2;
	BOOL BVar3;
	uint uVar4;
	KeysByte local_51;
	char *local_50;
	char *local_4c;
	char *local_48;
	char *local_44;
	
	globals::g_InterfaceBuildImages_Vehicles_normal_TABLE =
			 (ImageBMP **)std::malloc(globs::gameGlobs.VehicleTypes_COUNT * 4);
	globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE =
			 (ImageBMP **)std::malloc(globs::gameGlobs.VehicleTypes_COUNT * 4);
	globals::g_InterfaceBuildImages_Vehicles_disabled_TABLE =
			 (ImageBMP **)std::malloc(globs::gameGlobs.VehicleTypes_COUNT * 4);
	uVar4 = 0;
	if (globs::gameGlobs.VehicleTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"InterfaceBuildImages",
																 globs::gameGlobs.VehicleTypes_TABLE[uVar4],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 == NULL) {
				globals::g_InterfaceBuildImages_Vehicles_normal_TABLE[uVar4] = NULL;
				globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE[uVar4] = NULL;
				globals::g_InterfaceBuildImages_Vehicles_disabled_TABLE[uVar4] = NULL;
			}
			else {
				util::Util_Tokenise(pcVar1,&local_50,":");
				pIVar2 = lego::image::Image_LoadBMPScaled(local_50,0,0);
				globals::g_InterfaceBuildImages_Vehicles_normal_TABLE[uVar4] = pIVar2;
				pIVar2 = lego::image::Image_LoadBMPScaled(local_4c,0,0);
				globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE[uVar4] = pIVar2;
				pIVar2 = lego::image::Image_LoadBMPScaled(local_48,0,0);
				globals::g_InterfaceBuildImages_Vehicles_disabled_TABLE[uVar4] = pIVar2;
				BVar3 = input::Key_Find(local_44,&local_51);
				if (BVar3 != 0) {
					globals::g_InterfaceBuildKeys_Vehicles_TABLE[uVar4] = local_51;
				}
			}
			uVar4 += 1;
		} while (uVar4 < globs::gameGlobs.VehicleTypes_COUNT);
	}
	globals::g_InterfaceBuildImages_Buildings_normal_TABLE =
			 (ImageBMP **)std::malloc(globs::gameGlobs.BuildingTypes_COUNT * 4);
	globals::g_InterfaceBuildImages_Buildings_pressed_TABLE =
			 (ImageBMP **)std::malloc(globs::gameGlobs.BuildingTypes_COUNT * 4);
	globals::g_InterfaceBuildImages_Buildings_disabled_TABLE =
			 (ImageBMP **)std::malloc(globs::gameGlobs.BuildingTypes_COUNT * 4);
	uVar4 = 0;
	if (globs::gameGlobs.BuildingTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"InterfaceBuildImages",
																 globs::gameGlobs.BuildingTypes_TABLE[uVar4],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 == NULL) {
				globals::g_InterfaceBuildImages_Buildings_normal_TABLE[uVar4] = NULL;
				globals::g_InterfaceBuildImages_Buildings_pressed_TABLE[uVar4] = NULL;
				globals::g_InterfaceBuildImages_Buildings_disabled_TABLE[uVar4] = NULL;
			}
			else {
				util::Util_Tokenise(pcVar1,&local_50,":");
				pIVar2 = lego::image::Image_LoadBMPScaled(local_50,0,0);
				globals::g_InterfaceBuildImages_Buildings_normal_TABLE[uVar4] = pIVar2;
				pIVar2 = lego::image::Image_LoadBMPScaled(local_4c,0,0);
				globals::g_InterfaceBuildImages_Buildings_pressed_TABLE[uVar4] = pIVar2;
				pIVar2 = lego::image::Image_LoadBMPScaled(local_48,0,0);
				globals::g_InterfaceBuildImages_Buildings_disabled_TABLE[uVar4] = pIVar2;
				BVar3 = input::Key_Find(local_44,&local_51);
				if (BVar3 != 0) {
					globals::g_InterfaceBuildKeys_Buildings_TABLE[uVar4] = local_51;
				}
			}
			uVar4 += 1;
		} while (uVar4 < globs::gameGlobs.BuildingTypes_COUNT);
	}
	return;
}



void __cdecl lego::front::Interface_LoadInterfaceImages(CFGProperty *root,char *keyBasePath)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *prop;
	BOOL BVar3;
	int iVar4;
	BOOL3 BVar5;
	ImageBMP *pIVar6;
	int iVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	undefined4 *puVar11;
	char *pcVar12;
	undefined4 *puVar13;
	KeysByte local_47d;
	int local_47c;
	char *local_478;
	char *local_474;
	char *local_450;
	char *local_44c;
	char *local_448;
	char *local_444;
	char *local_440;
	char *local_43c;
	char *local_438;
	undefined4 local_400 [256];
	
	pcVar2 = cfg::CFG_JoinPath(keyBasePath,"InterfaceImages",0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (prop == NULL) {
			Interface_LoadInterfaceBuildImages(root,keyBasePath);
			Interface_LoadInterfaceBackButton(root,keyBasePath);
			return;
		}
		BVar3 = Interface_GetMenuItemType(prop->key,&local_47c);
		if (BVar3 != 0) {
			uVar8 = 0xffffffff;
			uVar10 = 0;
			pcVar2 = prop->value;
			do {
				pcVar12 = pcVar2;
				if (uVar8 == 0) break;
				uVar8 -= 1;
				pcVar12 = pcVar2 + 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar12;
			} while (cVar1 != '\0');
			uVar8 = ~uVar8;
			puVar11 = (undefined4 *)(pcVar12 + -uVar8);
			puVar13 = local_400;
			for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 -= 1) {
				*puVar13 = *puVar11;
				puVar11 = puVar11 + 1;
				puVar13 = puVar13 + 1;
			}
			for (uVar8 &= 3; uVar8 != 0; uVar8 -= 1) {
				*(undefined *)puVar13 = *(undefined *)puVar11;
				puVar11 = (undefined4 *)((int)puVar11 + 1);
				puVar13 = (undefined4 *)((int)puVar13 + 1);
			}
			iVar4 = util::Util_Tokenise((char *)local_400,&local_450,":");
			if ((iVar4 == 7) && (BVar5 = util::Util_GetBoolFromString(local_438), BVar5 != BOOL3_ERROR)) {
				BVar5 = util::Util_GetBoolFromString(local_438);
				uVar10 = (uint)(BVar5 == BOOL3_TRUE);
			}
			BOOL_ARRAY_004deadc[local_47c] = uVar10;
			pIVar6 = lego::image::Image_LoadBMPScaled(local_450,0,0);
			PTRImageBMP_ARRAY_004ddff8[local_47c] = pIVar6;
			pIVar6 = lego::image::Image_LoadBMPScaled(local_44c,0,0);
			PTRImageBMP_ARRAY_004de120[local_47c] = pIVar6;
			pIVar6 = lego::image::Image_LoadBMPScaled(local_448,0,0);
			PTRImageBMP_ARRAY_004de248[local_47c] = pIVar6;
			iVar7 = util::Util_Tokenise(local_444,&local_478,"|");
			iVar4 = local_47c;
			pcVar2 = std::_strdup(local_478);
			PTRString_ARRAY_004de370[iVar4] = pcVar2;
			if (iVar7 == 2) {
				snd::SFX_GetType(local_474,SFXType_ARRAY_004de498 + iVar4);
			}
			iVar7 = util::Util_Tokenise(local_440,&local_478,"|");
			iVar4 = local_47c * 4;
			pcVar2 = std::_strdup(local_478);
			*(char **)(&DAT_004de74c + iVar4) = pcVar2;
			if (iVar7 == 2) {
				snd::SFX_GetType(local_474,(SFXType *)(&DAT_004de874 + iVar4));
			}
			BVar3 = input::Key_Find(local_43c,&local_47d);
			if (BVar3 != 0) {
				globals::g_InterfaceIcon_Keys_TABLE[local_47c] = local_47d;
			}
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



void __cdecl lego::front::Interface_LoadInterfaceSurroundImages(CFGProperty *root,char *keyBasePath)
{
	int value;
	char *pcVar1;
	int iVar2;
	ImageBMP *pIVar3;
	ImageBMP **ppIVar4;
	ImageBMP **ppIVar5;
	char local_64 [20];
	char *stringParts [20];
	
	value = 0;
	ppIVar4 = globals::g_InterfaceSurroundImages;
	ppIVar5 = (ImageBMP **)&Point2F_ARRAY_004ddd88[0].y;
	do {
		value += 1;
		std::itoa(value,local_64,10);
		pcVar1 = cfg::CFG_JoinPath(keyBasePath,"InterfaceSurroundImages",local_64,0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		if (pcVar1 == NULL) {
			*ppIVar4 = NULL;
		}
		else {
			util::Util_Tokenise(pcVar1,stringParts,":");
			iVar2 = std::_stricmp(stringParts[0],"NULL");
			if (iVar2 != 0) {
				pIVar3 = lego::image::Image_LoadBMPScaled(stringParts[0],0,0);
				*ppIVar4 = pIVar3;
				if (pIVar3 != NULL) {
					lego::image::Image_SetupTrans(pIVar3,0.0,0.0,0.0,0.0,0.0,0.0);
				}
				iVar2 = std::atoi(stringParts[1]);
				ppIVar5[-1] = (ImageBMP *)(float)iVar2;
				iVar2 = std::atoi(stringParts[2]);
				*ppIVar5 = (ImageBMP *)(float)iVar2;
				iVar2 = std::atoi(stringParts[3]);
				ppIVar5[0x38] = (ImageBMP *)(float)iVar2;
				iVar2 = std::atoi(stringParts[4]);
				ppIVar5[0x39] = (ImageBMP *)(float)iVar2;
			}
			iVar2 = std::_stricmp(stringParts[5],"NULL");
			if (iVar2 != 0) {
				pIVar3 = lego::image::Image_LoadBMPScaled(stringParts[5],0,0);
				ppIVar4[0x21] = pIVar3;
				if (pIVar3 != NULL) {
					lego::image::Image_SetupTrans(pIVar3,0.0,0.0,0.0,0.0,0.0,0.0);
				}
				iVar2 = std::atoi(stringParts[6]);
				ppIVar5[0x20] = (ImageBMP *)(float)iVar2;
				iVar2 = std::atoi(stringParts[7]);
				ppIVar5[0x21] = (ImageBMP *)(float)iVar2;
			}
		}
		ppIVar5 = ppIVar5 + 2;
		ppIVar4 = ppIVar4 + 1;
	} while (ppIVar5 < globals::g_InterfaceSurroundImagesBack + 1);
	return;
}



void __cdecl lego::front::Interface_LoadInterfaceBackButton(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	char *local_50;
	char *local_4c;
	char *local_48;
	char *local_44;
	char *local_40;
	
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"InterfaceBackButton",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		util::Util_Tokenise(pcVar1,&local_50,":");
		globals::g_InterfaceBackButton_size.width = std::atoi(local_50);
		globals::g_InterfaceBackButton_size.height = std::atoi(local_4c);
		globals::g_InterfaceBackButton_bmp = lego::image::Image_LoadBMPScaled(local_48,0,0);
		globals::g_InterfaceBackButton_bmp_pressed = lego::image::Image_LoadBMPScaled(local_44,0,0);
		globals::g_InterfaceBackButton_text = util::Util_RemoveUnderscores(local_40);
		ToolTip_SetText(TOOLTIP_INTERFACEMENUBACKBUTTON,globals::g_InterfaceBackButton_text);
	}
	return;
}



void __cdecl lego::front::Interface_LoadInterfaceDependencies_PlusMinus(char *plus,char *minus)
{
	globals::g_InterfaceDependencies_Plus_bmp = lego::image::Image_LoadBMPScaled(plus,0,0);
	if (globals::g_InterfaceDependencies_Plus_bmp != NULL) {
		lego::image::Image_SetupTrans(globals::g_InterfaceDependencies_Plus_bmp,0.0,0.0,0.0,0.0,0.0,0.0)
		;
	}
	globals::g_InterfaceDependencies_Minus_bmp = lego::image::Image_LoadBMPScaled(minus,0,0);
	if (globals::g_InterfaceDependencies_Minus_bmp != NULL) {
		lego::image::Image_SetupTrans
							(globals::g_InterfaceDependencies_Minus_bmp,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	return;
}



void __cdecl
lego::front::Interface_OpenMenu_FUN_0041b200(InterfaceMenuType interfaceMenuType,Point2I *blockPos)
{
	game::Game_ClearSomeFlags3_FUN_00435950();
	Interface_SelectBlock(interfaceMenuType,blockPos);
	Interface_UnkSlideOffScreen_FUN_0041e980_internal(interfaceMenuType,blockPos);
	return;
}



void __cdecl
lego::front::Interface_SelectBlock(InterfaceMenuType interfaceMenuType,Point2I *blockPos)
{
	SurfaceMap *pSVar1;
	WallHighlightType WVar2;
	int iVar3;
	int iVar4;
	
	if ((((InterfaceMenuType_004decfc == INTERFACE_MENU_GROUND) ||
			 (InterfaceMenuType_004decfc == INTERFACE_MENU_ERODE)) ||
			(InterfaceMenuType_004decfc == INTERFACE_MENU_WALL)) ||
		 (((InterfaceMenuType_004decfc == INTERFACE_MENU_RUBBLE ||
			 (InterfaceMenuType_004decfc == INTERFACE_MENU_PLACEFENCE)) ||
			(InterfaceMenuType_004decfc == INTERFACE_MENU_CONSTRUCTION)))) {
		iVar3 = Point2IBlockPos_004decf4.x;
		iVar4 = Point2IBlockPos_004decf4.y;
		pSVar1 = game::GetSurfaceMap();
		WVar2 = game::Map3D_Block_GetHighlightType(pSVar1,iVar3,iVar4);
		if (WVar2 == WALLHIGHLIGHT_NONE) {
			WallHighlightType_004df1f0 = WALLHIGHLIGHT_NONE;
		}
		else {
			iVar3 = Point2IBlockPos_004decf4.x;
			iVar4 = Point2IBlockPos_004decf4.y;
			WVar2 = WallHighlightType_004df1f0;
			pSVar1 = game::GetSurfaceMap();
			game::Map3D_Block_SetHighlightType(pSVar1,iVar3,iVar4,WVar2);
		}
	}
	if (((interfaceMenuType == INTERFACE_MENU_GROUND) || (interfaceMenuType == INTERFACE_MENU_ERODE))
		 || ((interfaceMenuType == INTERFACE_MENU_WALL ||
				 (((interfaceMenuType == INTERFACE_MENU_RUBBLE ||
					 (interfaceMenuType == INTERFACE_MENU_PLACEFENCE)) ||
					(interfaceMenuType == INTERFACE_MENU_CONSTRUCTION)))))) {
		WVar2 = WALLHIGHLIGHT_SELECTED;
		iVar3 = blockPos->y;
		iVar4 = blockPos->x;
		pSVar1 = game::GetSurfaceMap();
		WVar2 = game::Map3D_Block_SetHighlightType(pSVar1,iVar4,iVar3,WVar2);
		if (WVar2 != WALLHIGHLIGHT_SELECTED) {
			WallHighlightType_004df1f0 = WVar2;
		}
	}
	return;
}



int __cdecl lego::front::Interface_FUN_0041b2f0(InterfaceMenuType interfaceMenuType)
{
	ObjectStatsFlags2 OVar1;
	ObjectStatsFlags3 OVar2;
	uint uVar3;
	uint uVar4;
	
	if (interfaceMenuType == INTERFACE_MENU_BUILDBUILDING) {
		return globs::gameGlobs.BuildingTypes_COUNT;
	}
	if (interfaceMenuType == INTERFACE_MENU_BUILDSMALLVEHICLE) {
		uVar4 = 0;
		uVar3 = 0;
		if (globs::gameGlobs.VehicleTypes_COUNT != 0) {
			do {
				OVar1 = game::Object_GetStatsFlags2(OBJECT_VEHICLE,uVar3);
				if ((OVar1 & STATS2_USESMALLTELEPORTER) == STATS2_NONE) {
					OVar1 = game::Object_GetStatsFlags2(OBJECT_VEHICLE,uVar3);
					if ((OVar1 & STATS2_USEWATERTELEPORTER) != STATS2_NONE) goto LAB_0041b335;
				}
				else {
LAB_0041b335:
					OVar2 = game::Object_GetStatsFlags3(OBJECT_VEHICLE,uVar3);
					if ((OVar2 & STATS3_CLASSASLARGE) == STATS3_NONE) {
						uVar4 += 1;
					}
				}
				uVar3 += 1;
				if (globs::gameGlobs.VehicleTypes_COUNT <= uVar3) {
					return uVar4;
				}
			} while( true );
		}
	}
	else {
		if (interfaceMenuType != INTERFACE_MENU_BUILDLARGEVEHICLE) {
			return globals::g_InterfaceMenuItemDefines_TABLE[interfaceMenuType].numIcons;
		}
		uVar4 = 0;
		uVar3 = 0;
		if (globs::gameGlobs.VehicleTypes_COUNT != 0) {
			do {
				OVar1 = game::Object_GetStatsFlags2(OBJECT_VEHICLE,uVar3);
				if ((OVar1 & STATS2_USEBIGTELEPORTER) == STATS2_NONE) {
					OVar2 = game::Object_GetStatsFlags3(OBJECT_VEHICLE,uVar3);
					if ((OVar2 & STATS3_CLASSASLARGE) != STATS3_NONE) goto LAB_0041b385;
				}
				else {
LAB_0041b385:
					uVar4 += 1;
				}
				uVar3 += 1;
			} while (uVar3 < globs::gameGlobs.VehicleTypes_COUNT);
		}
	}
	return uVar4;
}



BOOL __cdecl lego::front::Interface_NotMainOrFirstPersonMenu(InterfaceMenuType interfaceMenuType)
{
	if ((interfaceMenuType != INTERFACE_MENU_MAIN) &&
		 (interfaceMenuType != INTERFACE_MENU_FIRSTPERSON)) {
		return TRUE;
	}
	return 0;
}



void __cdecl lego::front::Interface_FUN_0041b3c0(void)
{
	int iVar1;
	BOOL BVar2;
	ImageBMP *pIVar3;
	uint uVar4;
	Point2F local_8;
	
	if ((FLAGS_004df1f8 & 4) == 0) {
		return;
	}
	iVar1 = Interface_FUN_0041b2f0(InterfaceMenuType_004deccc);
	BVar2 = Interface_NotMainOrFirstPersonMenu(InterfaceMenuType_004deccc);
	if (BVar2 == 0) {
		if ((ImageBMP *)(&Point2F_ARRAY_004ddd88[10].y)[iVar1] != NULL) {
			local_8.x = (float)globals::g_InterfaceSurroundImagesBack[iVar1 * 2 + 9] + Point2F_004decd0.x;
			local_8.y = (float)globals::g_InterfaceSurroundImagesBack[iVar1 * 2 + 10] + Point2F_004decd0.y
			;
			lego::image::Image_DisplayScaled
								((ImageBMP *)(&Point2F_ARRAY_004ddd88[10].y)[iVar1],NULL,&local_8,NULL);
		}
		goto LAB_0041b52f;
	}
	if ((&PTRImageFont_004ddd58)[iVar1] != NULL) {
		local_8.x = (float)globals::g_InterfaceSurroundImages[iVar1 * 2 + 9] + Point2F_004decd0.x;
		local_8.y = (float)globals::g_InterfaceSurroundImages[iVar1 * 2 + 10] + Point2F_004decd0.y;
		lego::image::Image_DisplayScaled((ImageBMP *)(&PTRImageFont_004ddd58)[iVar1],NULL,&local_8,NULL)
		;
	}
	uVar4 = UINT_ARRAY_004de60c[0] & 4;
	BVar2 = Interface_FUN_0041c990(INTERFACE_MENUITEM_BACKTODEFAULT);
	pIVar3 = globals::g_InterfaceBackButton_bmp;
	if (BVar2 == 0) {
		if ((FLAGS_004df1f8 & 0x4000) == 0) {
			if (uVar4 != 0) goto LAB_0041b47e;
LAB_0041b48e:
			pIVar3 = NULL;
		}
		else {
			if (uVar4 != 0) {
LAB_0041b47e:
				if (BOOL_004ded1c == 0) goto LAB_0041b48e;
			}
		}
	}
	else {
		pIVar3 = globals::g_InterfaceBackButton_bmp_pressed;
		if ((uVar4 != 0) && (BOOL_004ded1c != 0)) {
			pIVar3 = globals::g_InterfaceBackButton_bmp;
		}
	}
	if (pIVar3 != NULL) {
		local_8.x = (float)(&globals::g_InterfaceBackButton_bmp)[iVar1 * 2] + Point2F_004decd0.x;
		local_8.y = (float)(&globals::g_InterfaceBackButton_bmp_pressed)[iVar1 * 2] + Point2F_004decd0.y
		;
		lego::image::Image_DisplayScaled(pIVar3,NULL,&local_8,NULL);
	}
	Interface_FUN_0041c420(INTERFACE_MENUITEM_BACKTODEFAULT,OBJECT_NONE,0,NULL);
	Interface_FUN_0041c920(INTERFACE_MENUITEM_BACKTODEFAULT,0);
	Interface_FUN_0041c6e0(INTERFACE_MENUITEM_BACKTODEFAULT);
LAB_0041b52f:
	local_8.x = Point2F_004decd0.x;
	local_8.y = Point2F_004decd0.y;
	Interface_FUN_0041b5b0(InterfaceMenuType_004deccc,Interface_FUN_0041b730,&local_8);
	if ((FLAGS_004df1f8 & 0x1200) != 0) {
		Interface_Front_DrawLineListUnk_FUN_0041cc60(&Rect2F_004ded0c);
	}
	if ((FLAGS_004df1f8 & 0x3000) != 0) {
		Interface_FUN_0041ebd0(Rect2F_004ded0c.x,Rect2F_004ded0c.y);
		return;
	}
	Interface_SetFloatTo25_004df1ec_AndUnsetFlags800_004df1f8();
	return;
}



BOOL __cdecl
lego::front::Interface_FUN_0041b5b0(InterfaceMenuType menuIcon,undefined *callback,void *context)
{
	int iVar1;
	ObjectStatsFlags2 OVar2;
	ObjectStatsFlags3 OVar3;
	MenuIcon MVar4;
	uint uVar5;
	
	uVar5 = 0;
	if (menuIcon == INTERFACE_MENU_BUILDBUILDING) {
		if (globs::gameGlobs.BuildingTypes_COUNT != 0) {
			do {
				iVar1 = (*(code *)callback)(0x49,4,uVar5,context);
				if (iVar1 != 0) {
					return 1;
				}
				uVar5 += 1;
			} while (uVar5 < globs::gameGlobs.BuildingTypes_COUNT);
			return 0;
		}
	}
	else {
		if (menuIcon == INTERFACE_MENU_BUILDSMALLVEHICLE) {
			uVar5 = 0;
			if (globs::gameGlobs.VehicleTypes_COUNT != 0) {
				while (((OVar2 = game::Object_GetStatsFlags2(OBJECT_VEHICLE,uVar5),
								(OVar2 & STATS2_USESMALLTELEPORTER) == STATS2_NONE &&
								(OVar2 = game::Object_GetStatsFlags2(OBJECT_VEHICLE,uVar5),
								(OVar2 & STATS2_USEWATERTELEPORTER) == STATS2_NONE)) ||
							 ((OVar3 = game::Object_GetStatsFlags3(OBJECT_VEHICLE,uVar5),
								(OVar3 & STATS3_CLASSASLARGE) != STATS3_NONE ||
								(iVar1 = (*(code *)callback)(0x49,1,uVar5,context), iVar1 == 0))))) {
					uVar5 += 1;
					if (globs::gameGlobs.VehicleTypes_COUNT <= uVar5) {
						return 0;
					}
				}
				return 1;
			}
		}
		else {
			if (menuIcon == INTERFACE_MENU_BUILDLARGEVEHICLE) {
				uVar5 = 0;
				if (globs::gameGlobs.VehicleTypes_COUNT != 0) {
					while (((OVar2 = game::Object_GetStatsFlags2(OBJECT_VEHICLE,uVar5),
									(OVar2 & STATS2_USEBIGTELEPORTER) == STATS2_NONE &&
									(OVar3 = game::Object_GetStatsFlags3(OBJECT_VEHICLE,uVar5),
									(OVar3 & STATS3_CLASSASLARGE) == STATS3_NONE)) ||
								 (iVar1 = (*(code *)callback)(0x49,1,uVar5,context), iVar1 == 0))) {
						uVar5 += 1;
						if (globs::gameGlobs.VehicleTypes_COUNT <= uVar5) {
							return 0;
						}
					}
					return TRUE;
				}
			}
			else {
				if (globals::g_InterfaceMenuItemDefines_TABLE[menuIcon].numIcons != 0) {
					while( true ) {
						MVar4 = globals::g_InterfaceMenuItemDefines_TABLE[menuIcon].iconList[uVar5];
						if ((MVar4 == INTERFACE_MENUITEM_POWERON) || (MVar4 == INTERFACE_MENUITEM_POWEROFF)) {
							MVar4 = Interface_GetPrimaryUnit_PowerIcon
																(globals::g_InterfaceMenuItemDefines_TABLE[menuIcon].iconList +
																 uVar5);
						}
						iVar1 = (*(code *)callback)(MVar4,0,0,context);
						if (iVar1 != 0) break;
						uVar5 += 1;
						if (globals::g_InterfaceMenuItemDefines_TABLE[menuIcon].numIcons <= uVar5) {
							return 0;
						}
					}
					return 1;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::front::Interface_FUN_0041b730(MenuIcon menuIcon,uint param_2,int param_3,float *param_4)
{
	MenuIcon MVar1;
	ImageBMP *image;
	uint uVar2;
	
	MVar1 = menuIcon;
	if (menuIcon == INTERFACE_MENUITEM_BUILD) {
		Interface_FUN_0041c730(param_2,param_3);
		image = Interface_GetBuildImageByObjectType(param_2,param_3);
		if (param_2 == 1) {
			uVar2 = *(uint *)((int)globals::g_SubmenuIcons_VehicleTypes2_TABLE + param_3 * 4) & 4;
		}
		else {
			uVar2 = param_2;
			if (param_2 == 4) {
				uVar2 = *(uint *)((int)globals::g_SubmenuIcons_BuildingTypes2_TABLE + param_3 * 4) & 4;
			}
		}
		Interface_FUN_0041c950(param_2,param_3,0);
	}
	else {
		Interface_FUN_0041c6e0(menuIcon);
		image = Interface_FUN_0041c9e0(menuIcon);
		uVar2 = UINT_ARRAY_004de60c[menuIcon] & 4;
		Interface_FUN_0041c920(menuIcon,0);
	}
	Interface_FUN_0041c420(menuIcon,param_2,param_3,param_4);
	if (image == NULL) {
		menuIcon = INTERFACE_MENUITEM_DELETEBUILDING;
	}
	else {
		menuIcon = image->height;
		if ((uVar2 == 0) || (BOOL_004ded1c != 0)) {
			lego::image::Image_DisplayScaled(image,NULL,(Point2F *)param_4,NULL);
		}
	}
	if (MVar1 == INTERFACE_MENUITEM_TEKEPORTMAN) {
		param_3 = 0;
		param_2 = 2;
	}
	else {
		if (MVar1 != INTERFACE_MENUITEM_BUILD) goto LAB_0041b82e;
	}
	Interface_FUN_0041eb60(param_2,param_3,(Point2F *)param_4);
LAB_0041b82e:
	param_4[1] = (float)(ulonglong)menuIcon + param_4[1];
	return 0;
}



void __cdecl lego::front::Interface_FUN_0041b860(float elapsedAbs)
{
	TIMER_004ded20 = TIMER_004ded20 - elapsedAbs;
	if (TIMER_004ded20 < 0.0) {
		BOOL_004ded1c = ZEXT14(BOOL_004ded1c == 0);
		TIMER_004ded20 = 15.0;
	}
	Interface_FUN_0041e9f0(elapsedAbs);
	if ((ushort)((ushort)(FLOAT_004df1ec < 0.0) << 8 | (ushort)(FLOAT_004df1ec == 0.0) << 0xe) == 0) {
		FLOAT_004df1ec = FLOAT_004df1ec - elapsedAbs;
		return;
	}
	FLAGS_004df1f8 = FLAGS_004df1f8 | 0x800;
	return;
}



BOOL __cdecl lego::front::Interface_GetBool_004ded1c(void)
{
	return BOOL_004ded1c;
}



// Result is same as final value of *ref_param_1 (param_1 may not be changed)

MenuIcon __cdecl lego::front::Interface_GetPrimaryUnit_PowerIcon(MenuIcon *ref_menuIcon)
{
	LiveObject *primaryUnit;
	
	primaryUnit = game::Message_GetPrimarySelectedUnit();
	if (((FLAGS_004df1f8 & 0x80) == 0) && ((FLAGS_004df1f8 & 0x100) != 0)) {
		return *ref_menuIcon;
	}
	if ((primaryUnit->flags3 & LIVEOBJ3_POWEROFF) != LIVEOBJ3_NONE) {
		*ref_menuIcon = INTERFACE_MENUITEM_POWERON;
		return INTERFACE_MENUITEM_POWERON;
	}
	*ref_menuIcon = INTERFACE_MENUITEM_POWEROFF;
	return INTERFACE_MENUITEM_POWEROFF;
}



void __cdecl lego::front::Interface_FUN_0041b940(float elapsedAbs)
{
	SFXType SVar1;
	
	SVar1 = SFXType_004df1f4;
	if (SFXType_004df1f4 != SFXType_004df1fc) {
		TIMER_004a3b58 = 25.0;
		SFXType_004df1f4 = SFX_NULL;
		SFXType_004df1fc = SVar1;
		BOOLSFXPlaying_004df200 = 0;
		return;
	}
	TIMER_004a3b58 = TIMER_004a3b58 - elapsedAbs;
	if (((ushort)((ushort)(TIMER_004a3b58 < 0.0) << 8 | (ushort)(TIMER_004a3b58 == 0.0) << 0xe) != 0)
		 && (BOOLSFXPlaying_004df200 == 0)) {
		BOOLSFXPlaying_004df200 = snd::SFX_Sample_Random_SetAndPlayGlobalSample(SFXType_004df1f4,NULL);
	}
	SFXType_004df1f4 = SFX_NULL;
	return;
}



void __cdecl lego::front::Interface_SetDat_004df1f4(SFXType param_1)
{
	SFXType_004df1f4 = param_1;
	return;
}



BOOL __cdecl
lego::front::Interface_DoSomethingWithRenameReplace
					(uint param_1,uint param_2,int param_3,int param_4,int param_5)
{
	ImageBMP *pIVar1;
	char cVar2;
	BOOL BVar3;
	char *pcVar4;
	LiveObject *pLVar5;
	uint uVar6;
	undefined4 *puVar7;
	int iVar8;
	uint uVar9;
	uint uVar10;
	char *pcVar11;
	char **ppcVar12;
	ImageFont *image;
	undefined4 *puVar13;
	int iVar14;
	char *pcVar15;
	undefined4 *puVar16;
	longlong lVar17;
	SFXType SVar18;
	MenuIcon local_a78;
	int local_a74;
	uint local_a70;
	ObjectType local_a6c;
	int local_a68;
	ObjectType local_a64;
	int local_a60;
	int local_a5c;
	uint local_a58;
	uint local_a54;
	char *local_a50 [20];
	char local_a00 [512];
	undefined4 local_800;
	undefined4 local_600 [128];
	char local_400 [1024];
	
	pcVar11 = NULL;
	local_a70 = 0;
	local_a60 = 0;
	if (((FLAGS_004df1f8 & 4) == 0) || ((FLAGS_004df1f8 & 0x80) == 0)) {
		FLAGS_004df1f8 = FLAGS_004df1f8 & 0xffff89ff;
		return 0;
	}
	FLAGS_004df1f8 = FLAGS_004df1f8 & 0xffff89ff;
	BVar3 = Interface_FUN_0041edb0
										(param_1,param_2,Rect2F_004ded0c.x,Rect2F_004ded0c.y,&local_a64,&local_a68,
										 &local_a5c);
	if (BVar3 != 0) {
		FLAGS_004df1f8 |= 0x1000;
		if (((param_3 == 0) && (param_5 == 0)) && (local_a64 != 0x14)) {
			pcVar11 = globs::gameGlobs.UpgradeNames_TABLE[local_a5c];
			if (pcVar11 == NULL) {
				pcVar11 = game::Object_GetName(local_a64,local_a68);
				std::sprintf((char *)&local_800,"%s",pcVar11);
			}
			else {
				pcVar4 = game::Object_GetName(local_a64,local_a68);
				std::sprintf((char *)&local_800,"%s (%s)",pcVar4,pcVar11);
			}
			ToolTip_SetText(TOOLTIP_INTERFACEMENU,(char *)&local_800);
			ToolTip_AddFlag4(TOOLTIP_INTERFACEMENU);
			ToolTip_ResetTimer(TOOLTIP_INTERFACEMENU);
			if ((globs::gameGlobs.flags2 & GAME2_DISABLETOOLTIPSOUND) == GAME2_NONE) {
				Interface_SetDat_004df1f4(globs::liveGlobs.ObjTtSFX_TABLE[local_a64][local_a68]);
			}
		}
		Interface_FUN_0041c610(INTERFACE_MENUITEM_BACKTODEFAULT,0,0,param_3,param_4);
		return TRUE;
	}
	BVar3 = Interface_FUN_0041c0f0(param_1,param_2,&local_a78,&local_a6c,&local_a74);
	if (BVar3 == 0) {
		iVar14 = Interface_FUN_0041b2f0(InterfaceMenuType_004deccc);
		BVar3 = Interface_NotMainOrFirstPersonMenu(InterfaceMenuType_004deccc);
		if (BVar3 == 0) {
			image = (ImageFont *)(&Point2F_ARRAY_004ddd88[10].y)[iVar14];
			lVar17 = __ftol((float10)(float)globals::g_InterfaceSurroundImagesBack[iVar14 * 2 + 9] +
											(float10)Point2F_004decd0.x);
			iVar8 = (int)lVar17;
			pIVar1 = globals::g_InterfaceSurroundImagesBack[iVar14 * 2 + 10];
		}
		else {
			image = (&PTRImageFont_004ddd58)[iVar14];
			lVar17 = __ftol((float10)(float)globals::g_InterfaceSurroundImages[iVar14 * 2 + 9] +
											(float10)Point2F_004decd0.x);
			iVar8 = (int)lVar17;
			pIVar1 = globals::g_InterfaceSurroundImages[iVar14 * 2 + 10];
		}
		lVar17 = __ftol((float10)(float)pIVar1 + (float10)Point2F_004decd0.y);
		if (image == NULL) {
			return local_a70;
		}
		BVar3 = lego::image::Image_GetPixel
											((ImageBMP *)image,param_1 - iVar8,param_2 - (int)lVar17,&local_a58);
		if (BVar3 == 0) {
			return local_a70;
		}
		if (local_a58 == 0) {
			return local_a70;
		}
		if (param_5 != 0) {
			snd::Audio_FUN_00428730(1);
		}
		return TRUE;
	}
	if (local_a78 == INTERFACE_MENUITEM_BACKTODEFAULT) {
		FLAGS_004df1f8 |= 0x4000;
		ToolTip_AddFlag4(TOOLTIP_INTERFACEMENUBACKBUTTON);
		goto LAB_0041bf5c;
	}
	if (local_a78 == INTERFACE_MENUITEM_BUILD) {
		FLAGS_004df1f8 =
				 FLAGS_004df1f8 & 0xffff0000 |
				 (uint)(ushort)(CONCAT11((char)((FLAGS_004df1f8 | 0x200) >> 8),(char)FLAGS_004df1f8) | 0x400
											 ) | 0x2000;
		pcVar11 = game::Object_GetName(local_a6c,local_a74);
		std::sprintf(local_a00,"%s",pcVar11);
		if ((globs::gameGlobs.flags2 & GAME2_DISABLETOOLTIPSOUND) == GAME2_NONE) {
			Interface_SetDat_004df1f4(globs::liveGlobs.ObjTtSFX_TABLE[local_a6c][local_a74]);
			pcVar4 = local_a00;
		}
		else {
LAB_0041bec2:
			pcVar4 = local_a00;
		}
	}
	else {
		if ((local_a78 == INTERFACE_MENUITEM_LAYPATH) ||
			 (uVar6 = FLAGS_004df1f8 | 0x200, local_a78 == INTERFACE_MENUITEM_PLACEFENCE)) {
			uVar6 = FLAGS_004df1f8 | 0x2200;
		}
		FLAGS_004df1f8 = uVar6;
		BVar3 = Interface_FUN_0041c820(local_a78,0);
		if (BVar3 == 0) {
			pcVar4 = PTRString_ARRAY_004de370[local_a78];
			if ((pcVar4 != NULL) &&
				 (pcVar11 = pcVar4, (globs::gameGlobs.flags2 & GAME2_DISABLETOOLTIPSOUND) == GAME2_NONE)) {
				SVar18 = SFXType_ARRAY_004de498[local_a78];
LAB_0041bd3e:
				Interface_SetDat_004df1f4(SVar18);
				pcVar11 = pcVar4;
			}
		}
		else {
			if (*(int *)(&DAT_004de74c + local_a78 * 4) != 0) {
				pLVar5 = game::Message_GetPrimarySelectedUnit();
				if (((((pLVar5 == NULL) || (local_a78 != INTERFACE_MENUITEM_UPGRADEBUILDING)) ||
						 (uVar6 = game::Object_GetLevels(pLVar5->objType,pLVar5->objIndex),
						 uVar6 <= pLVar5->objLevel + 1)) ||
						((uVar6 = game::Level_GetOreCount(0),
						 (uint)globs::gameGlobs.BuildingUpgradeCostOre <= uVar6 ||
						 (uVar6 = game::Level_GetOreCount(1),
						 (uint)globs::gameGlobs.BuildingUpgradeCostStuds <= uVar6)))) ||
					 (globs::liveGlobs.ToolTipIcon_Ore == NULL)) {
					pcVar11 = *(char **)(&DAT_004de74c + local_a78 * 4);
				}
				else {
					if (globs::gameGlobs.OreRequiredText != NULL) {
						std::sprintf(local_400,"%s",globs::gameGlobs.OreRequiredText);
						pcVar11 = local_400;
					}
					local_a60 = game::Level_GetOreCount(0);
					local_a60 = globs::gameGlobs.BuildingUpgradeCostOre - local_a60;
				}
				if ((globs::gameGlobs.flags2 & GAME2_DISABLETOOLTIPSOUND) == GAME2_NONE) {
					SVar18 = *(SFXType *)(&DAT_004de874 + local_a78 * 4);
					pcVar4 = pcVar11;
					goto LAB_0041bd3e;
				}
			}
		}
		pcVar4 = NULL;
		if (((pcVar11 != NULL) && (pcVar4 = pcVar11, BOOL_ARRAY_004deadc[local_a78] != 0)) &&
			 ((uVar6 = game::Message_GetNumSelectedUnits(), uVar6 == 1 &&
				(((pLVar5 = game::Message_GetPrimarySelectedUnit(), pLVar5 != NULL &&
					(pLVar5 = game::Message_GetPrimarySelectedUnit(), pLVar5->customName != NULL)) &&
				 (pLVar5 = game::Message_GetPrimarySelectedUnit(), *pLVar5->customName != '\0')))))) {
			uVar6 = 0xffffffff;
			pcVar4 = globs::gameGlobs.RenameReplace;
			do {
				pcVar15 = pcVar4;
				if (uVar6 == 0) break;
				uVar6 -= 1;
				pcVar15 = pcVar4 + 1;
				cVar2 = *pcVar4;
				pcVar4 = pcVar15;
			} while (cVar2 != '\0');
			uVar6 = ~uVar6;
			puVar13 = (undefined4 *)(pcVar15 + -uVar6);
			puVar16 = &local_800;
			for (uVar9 = uVar6 >> 2; uVar9 != 0; uVar9 -= 1) {
				*puVar16 = *puVar13;
				puVar13 = puVar13 + 1;
				puVar16 = puVar16 + 1;
			}
			for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
				*(undefined *)puVar16 = *(undefined *)puVar13;
				puVar13 = (undefined4 *)((int)puVar13 + 1);
				puVar16 = (undefined4 *)((int)puVar16 + 1);
			}
			uVar6 = 0xffffffff;
			do {
				pcVar4 = pcVar11;
				if (uVar6 == 0) break;
				uVar6 -= 1;
				pcVar4 = pcVar11 + 1;
				cVar2 = *pcVar11;
				pcVar11 = pcVar4;
			} while (cVar2 != '\0');
			uVar6 = ~uVar6;
			puVar13 = (undefined4 *)(pcVar4 + -uVar6);
			puVar16 = local_600;
			for (uVar9 = uVar6 >> 2; uVar9 != 0; uVar9 -= 1) {
				*puVar16 = *puVar13;
				puVar13 = puVar13 + 1;
				puVar16 = puVar16 + 1;
			}
			puVar7 = &local_800;
			for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
				*(undefined *)puVar16 = *(undefined *)puVar13;
				puVar13 = (undefined4 *)((int)puVar13 + 1);
				puVar16 = (undefined4 *)((int)puVar16 + 1);
			}
			while ((char)local_800 != '\0') {
				if (*(char *)puVar7 == ' ') {
					*(char *)puVar7 = '_';
				}
				pcVar11 = (char *)((int)puVar7 + 1);
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				local_800._0_1_ = *pcVar11;
			}
			local_a54 = util::Util_Tokenise((char *)local_600,local_a50,(char *)&local_800);
			uVar6 = 0;
			local_a00[0] = '\0';
			if (local_a54 != 0) {
				local_a70 = local_a54 - 1;
				ppcVar12 = local_a50;
				do {
					uVar9 = 0xffffffff;
					pcVar11 = *ppcVar12;
					do {
						pcVar4 = pcVar11;
						if (uVar9 == 0) break;
						uVar9 -= 1;
						pcVar4 = pcVar11 + 1;
						cVar2 = *pcVar11;
						pcVar11 = pcVar4;
					} while (cVar2 != '\0');
					uVar9 = ~uVar9;
					iVar14 = -1;
					pcVar11 = local_a00;
					do {
						pcVar15 = pcVar11;
						if (iVar14 == 0) break;
						iVar14 += -1;
						pcVar15 = pcVar11 + 1;
						cVar2 = *pcVar11;
						pcVar11 = pcVar15;
					} while (cVar2 != '\0');
					puVar13 = (undefined4 *)(pcVar4 + -uVar9);
					puVar16 = (undefined4 *)(pcVar15 + -1);
					for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 -= 1) {
						*puVar16 = *puVar13;
						puVar13 = puVar13 + 1;
						puVar16 = puVar16 + 1;
					}
					for (uVar9 &= 3; uVar9 != 0; uVar9 -= 1) {
						*(undefined *)puVar16 = *(undefined *)puVar13;
						puVar13 = (undefined4 *)((int)puVar13 + 1);
						puVar16 = (undefined4 *)((int)puVar16 + 1);
					}
					if (uVar6 < local_a70) {
						pLVar5 = game::Message_GetPrimarySelectedUnit();
						uVar9 = 0xffffffff;
						pcVar11 = pLVar5->customName;
						do {
							pcVar4 = pcVar11;
							if (uVar9 == 0) break;
							uVar9 -= 1;
							pcVar4 = pcVar11 + 1;
							cVar2 = *pcVar11;
							pcVar11 = pcVar4;
						} while (cVar2 != '\0');
						uVar9 = ~uVar9;
						iVar14 = -1;
						pcVar11 = local_a00;
						do {
							pcVar15 = pcVar11;
							if (iVar14 == 0) break;
							iVar14 += -1;
							pcVar15 = pcVar11 + 1;
							cVar2 = *pcVar11;
							pcVar11 = pcVar15;
						} while (cVar2 != '\0');
						puVar13 = (undefined4 *)(pcVar4 + -uVar9);
						puVar16 = (undefined4 *)(pcVar15 + -1);
						for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 -= 1) {
							*puVar16 = *puVar13;
							puVar13 = puVar13 + 1;
							puVar16 = puVar16 + 1;
						}
						for (uVar9 &= 3; uVar9 != 0; uVar9 -= 1) {
							*(undefined *)puVar16 = *(undefined *)puVar13;
							puVar13 = (undefined4 *)((int)puVar13 + 1);
							puVar16 = (undefined4 *)((int)puVar16 + 1);
						}
					}
					uVar6 += 1;
					ppcVar12 = ppcVar12 + 1;
				} while (uVar6 < local_a54);
			}
			goto LAB_0041bec2;
		}
	}
	if ((param_3 == 0) && (param_5 == 0)) {
		if (pcVar4 == NULL) {
			std::sprintf(local_a00,"Missing config for\n\'%s\'",
									 globals::g_InterfaceMenuItemNames_TABLE[local_a78]);
			ToolTip_SetText(TOOLTIP_INTERFACEMENU,local_a00);
		}
		else {
			ToolTip_SetText(TOOLTIP_INTERFACEMENU,pcVar4);
			for (iVar14 = local_a60; iVar14 != 0; iVar14 += -1) {
				ToolTip_AddIcon(TOOLTIP_INTERFACEMENU,globs::liveGlobs.ToolTipIcon_Ore);
			}
		}
		ToolTip_AddFlag4(TOOLTIP_INTERFACEMENU);
		ToolTip_ResetTimer(TOOLTIP_INTERFACEMENU);
	}
	else {
		Interface_SetDat_004df1f4(0);
	}
LAB_0041bf5c:
	BVar3 = Interface_FUN_0041c610(local_a78,local_a6c,local_a74,param_3,param_4);
	if ((BVar3 != 0) && (param_5 != 0)) {
		if (local_a78 == INTERFACE_MENUITEM_BUILD) {
			if ((InterfaceMenuType_004deccc == INTERFACE_MENU_BUILDSMALLVEHICLE) ||
				 (InterfaceMenuType_004deccc == INTERFACE_MENU_BUILDLARGEVEHICLE)) {
				*(int *)((int)globals::g_SubmenuIcons_VehicleTypesClicked_TABLE + local_a74 * 4) =
						 *(int *)((int)globals::g_SubmenuIcons_VehicleTypesClicked_TABLE + local_a74 * 4) + 1;
			}
			else {
				if (InterfaceMenuType_004deccc == INTERFACE_MENU_BUILDBUILDING) {
					*(int *)((int)globals::g_SubmenuIcons_BuildingTypesClicked_TABLE + local_a74 * 4) =
							 *(int *)((int)globals::g_SubmenuIcons_BuildingTypesClicked_TABLE + local_a74 * 4) + 1
					;
				}
			}
		}
		else {
			globals::g_Interface_Icons_Clicked[local_a78] =
					 globals::g_Interface_Icons_Clicked[local_a78] + 1;
		}
		BVar3 = Interface_DoAction_FUN_0041dbd0(local_a78);
		snd::Audio_FUN_00428730((uint)(BVar3 == 0));
	}
	return 1;
}



BOOL __cdecl
lego::front::Interface_FUN_0041c0f0
					(uint param_1,uint param_2,undefined4 *param_3,undefined4 *param_4,undefined4 *param_5)
{
	float fVar1;
	float fVar2;
	int iVar3;
	BOOL BVar4;
	uint local_1c;
	uint local_18;
	float local_14;
	float local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	iVar3 = Interface_FUN_0041b2f0(InterfaceMenuType_004deccc);
	BVar4 = Interface_NotMainOrFirstPersonMenu(InterfaceMenuType_004deccc);
	if (BVar4 != 0) {
		fVar1 = (float)(ulonglong)param_1;
		if (((((float)(&globals::g_InterfaceBackButton_bmp)[iVar3 * 2] + Point2F_004decd0.x <= fVar1) &&
				 (fVar2 = (float)(ulonglong)(uint)globals::g_InterfaceBackButton_size.width +
									(float)(&globals::g_InterfaceBackButton_bmp)[iVar3 * 2] + Point2F_004decd0.x,
				 (ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) != 0)) &&
				(fVar1 = (float)(ulonglong)param_2,
				(float)(&globals::g_InterfaceBackButton_bmp_pressed)[iVar3 * 2] + Point2F_004decd0.y <=
				fVar1)) &&
			 (fVar2 = (float)(ulonglong)(uint)globals::g_InterfaceBackButton_size.height +
								(float)(&globals::g_InterfaceBackButton_bmp_pressed)[iVar3 * 2] + Point2F_004decd0.y
			 , (ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) != 0)) {
			*param_3 = 0;
			return TRUE;
		}
	}
	local_14 = Point2F_004decd0.x;
	local_1c = param_1;
	local_18 = param_2;
	local_10 = Point2F_004decd0.y;
	BVar4 = Interface_FUN_0041b5b0(InterfaceMenuType_004deccc,Interface_FUN_0041c240,&local_1c);
	if (BVar4 == 0) {
		return 0;
	}
	*param_3 = local_c;
	*param_4 = local_8;
	*param_5 = local_4;
	return TRUE;
}



BOOL __cdecl
lego::front::Interface_FUN_0041c240
					(MenuIcon in_menuIcon,ObjectType objType,int objIndex,uint *param_4)
{
	Point2F *point;
	float fVar1;
	float fVar2;
	MenuIcon menuIcon;
	ImageBMP *pIVar3;
	uint uVar4;
	
	menuIcon = in_menuIcon;
	if (in_menuIcon == INTERFACE_MENUITEM_BUILD) {
		pIVar3 = Interface_GetBuildImageByObjectType(objType,objIndex);
	}
	else {
		pIVar3 = Interface_FUN_0041c9e0(in_menuIcon);
	}
	if (pIVar3 == NULL) {
		uVar4 = 0x28;
		in_menuIcon = INTERFACE_MENUITEM_DELETEBUILDING;
	}
	else {
		in_menuIcon = pIVar3->width;
		uVar4 = pIVar3->height;
	}
	point = (Point2F *)(param_4 + 2);
	fVar1 = (float)(ulonglong)*param_4;
	if ((((point->x <= fVar1) &&
			 (fVar2 = (float)(ulonglong)in_menuIcon + point->x,
			 (ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) != 0)) &&
			(fVar1 = (float)(ulonglong)param_4[1], (float)param_4[3] <= fVar1)) &&
		 ((ushort)((ushort)(fVar1 < (float)(ulonglong)uVar4 + (float)param_4[3]) << 8 |
							(ushort)(fVar1 == (float)(ulonglong)uVar4 + (float)param_4[3]) << 0xe) != 0)) {
		param_4[4] = menuIcon;
		Interface_SetDat_004decd8_004decdc(menuIcon,objType,objIndex);
		if (menuIcon == INTERFACE_MENUITEM_BUILD) {
			param_4[5] = objType;
			param_4[6] = objIndex;
		}
		Interface_FUN_0041cc10(point,in_menuIcon + ~INTERFACE_MENUITEM_BACKTODEFAULT,uVar4 - 1);
		return TRUE;
	}
	param_4[3] = (uint)((float)(ulonglong)uVar4 + (float)param_4[3]);
	return 0;
}



void __cdecl lego::front::Interface_DoF2InterfaceKeyAction(void)
{
	if (((((byte)FLAGS_004df1f8 & 4) != 0) && (((byte)FLAGS_004df1f8 & 0x80) != 0)) &&
		 (globs::INPUT.Key_Map[60] != false)) {
		Interface_FUN_0041b5b0(InterfaceMenuType_004deccc,Interface_DoMenuIconKey_Action,NULL);
	}
	return;
}



BOOL __cdecl
lego::front::Interface_DoMenuIconKey_Action(MenuIcon menuIcon,ObjectType objType,int objIndex)
{
	MenuIcon menuIcon_00;
	
	menuIcon_00 = menuIcon;
	if (menuIcon == INTERFACE_MENUITEM_BUILD) {
		if (objType == OBJECT_VEHICLE) {
			menuIcon = (MenuIcon)globals::g_InterfaceBuildKeys_Vehicles_TABLE[objIndex];
		}
		else {
			if (objType == OBJECT_BUILDING) {
				menuIcon = (MenuIcon)globals::g_InterfaceBuildKeys_Buildings_TABLE[objIndex];
			}
		}
	}
	else {
		menuIcon = (MenuIcon)globals::g_InterfaceIcon_Keys_TABLE[menuIcon];
	}
	if ((globs::INPUT.Key_Map[menuIcon & 0xff] != false) &&
		 (globs::INPUT.prevKey_Map[menuIcon & 0xff] != globs::INPUT.Key_Map[menuIcon & 0xff])) {
		Interface_SetDat_004decd8_004decdc(menuIcon_00,objType,objIndex);
		Interface_DoAction_FUN_0041dbd0(menuIcon_00);
	}
	return 0;
}



void __cdecl
lego::front::Interface_FUN_0041c420
					(MenuIcon menuIcon,ObjectType objType,int objIndex,float *param_4)
{
	bool bVar1;
	bool bVar2;
	BOOL BVar3;
	int iVar4;
	float local_18;
	float fStack20;
	float local_10;
	float local_c;
	uint local_8;
	undefined4 uStack4;
	
	bVar2 = false;
	if (((FLAGS_004df1f8 & 0x20) != 0) && (BVar3 = Advisor_GetFlag1(), BVar3 == 0)) {
		bVar1 = false;
		if (MenuIcon_004ded28 == INTERFACE_MENUITEM_BUILD) {
			if ((ObjectType_004ded2c == objType) && (INT_004ded30 == objIndex)) {
				objType = (ObjectType)Interface_GetBuildImageByObjectType(objType,objIndex);
				bVar1 = true;
			}
		}
		else {
			if (menuIcon == MenuIcon_004ded28) {
				if (menuIcon == INTERFACE_MENUITEM_BACKTODEFAULT) {
					bVar2 = true;
					bVar1 = true;
				}
				else {
					objType = (ObjectType)Interface_FUN_0041c9e0(menuIcon);
					bVar1 = true;
				}
			}
		}
		if (bVar1) {
			if (bVar2) {
				iVar4 = Interface_FUN_0041b2f0(InterfaceMenuType_004deccc);
				if ((FLAGS_004df1f8 & 0x80) == 0) {
					local_18 = (float)(&globals::g_InterfaceBackButton_bmp)[iVar4 * 2] + Point2F_004dece8.x;
				}
				else {
					local_18 = (float)(&globals::g_InterfaceBackButton_bmp)[iVar4 * 2] + Point2F_004decd0.x;
				}
				local_18 = local_18 -
									 (float)(ulonglong)(uint)globals::g_InterfaceBackButton_size.width * -0.5;
				fStack20 = ((float)(&globals::g_InterfaceBackButton_bmp_pressed)[iVar4 * 2] +
									 Point2F_004decd0.y) -
									 (float)(ulonglong)(uint)globals::g_InterfaceBackButton_size.height * -0.5;
			}
			else {
				if ((ImageBMP *)objType == NULL) {
					local_8 = 0x28;
				}
				else {
					local_8 = *(uint *)(objType + 8);
				}
				local_18 = *param_4;
				if ((FLAGS_004df1f8 & 0x80) == 0) {
					local_18 = Point2F_004dece8.x;
				}
				uStack4 = 0;
				fStack20 = (float)(ulonglong)local_8 * 0.5 + param_4[1];
			}
			Advisor_GetPoint2(AdvisorType_004ded24,&local_10,&local_c);
			Advisor_SetParameters
								(AdvisorType_004ded24,PANEL__COUNT,local_10 + local_18,local_c + fStack20);
			Advisor_SetCurrentAdvisor(AdvisorType_004ded24,FLAGS_004df1f8 & 0x40);
			FLAGS_004df1f8 &= 0xffffffdf;
		}
	}
	return;
}



BOOL __cdecl
lego::front::Interface_FUN_0041c610
					(MenuIcon menuIcon,int param_2,int param_3,int param_4,int param_5)
{
	MenuIcon MVar1;
	
	MVar1 = INTMenuIcon_004ded00;
	if (param_4 == 0) {
		INTMenuIcon_004ded00 = INTERFACE_MENUITEM__COUNT;
	}
	else {
		if ((FLAGS_004df1f8 & 0x1000) == 0) {
			if (INTMenuIcon_004ded00 == INTERFACE_MENUITEM__COUNT) {
				if (param_5 != 0) goto LAB_0041c6aa;
				INTMenuIcon_004ded00 = menuIcon;
				DAT_004ded04 = param_2;
				DAT_004ded08 = param_3;
				if (menuIcon == INTERFACE_MENUITEM_BUILD) {
					Interface_FUN_0041c950(param_2,param_3,TRUE);
					goto LAB_0041c6aa;
				}
			}
			else {
				if (INTMenuIcon_004ded00 != menuIcon) goto LAB_0041c6aa;
				if (menuIcon == INTERFACE_MENUITEM_BUILD) {
					if ((DAT_004ded04 == param_2) && (DAT_004ded08 == param_3)) {
						Interface_FUN_0041c950(param_2,param_3,TRUE);
					}
					goto LAB_0041c6aa;
				}
			}
			Interface_FUN_0041c920(menuIcon,TRUE);
		}
	}
LAB_0041c6aa:
	if (MVar1 == menuIcon) {
		if (menuIcon != INTERFACE_MENUITEM_BUILD) {
			return TRUE;
		}
		if ((DAT_004ded04 == param_2) && (DAT_004ded08 == param_3)) {
			return TRUE;
		}
	}
	return 0;
}



void __cdecl lego::front::Interface_FUN_0041c6e0(MenuIcon menuIcon)
{
	BOOL BVar1;
	uint uVar2;
	
	uVar2 = UINT_ARRAY_004de60c[menuIcon];
	if (((uVar2 & 2) == 0) && (((byte)FLAGS_004df1f8 & 0x80) != 0)) {
		BVar1 = Interface_HandleIcon_FUN_0041cf70(menuIcon);
		uVar2 = UINT_ARRAY_004de60c[menuIcon];
		if (BVar1 != 0) {
			UINT_ARRAY_004de60c[menuIcon] = uVar2 & 0xfffffffe;
			return;
		}
	}
	UINT_ARRAY_004de60c[menuIcon] = uVar2 | 1;
	return;
}



void __cdecl lego::front::Interface_FUN_0041c730(ObjectType objType,int objIndex)
{
	uint *puVar1;
	BOOL BVar2;
	int iVar3;
	int iVar4;
	uint uVar5;
	void *pvVar6;
	
	if (objType == OBJECT_VEHICLE) {
		uVar5 = *(uint *)((int)globals::g_SubmenuIcons_VehicleTypes2_TABLE + objIndex * 4);
		pvVar6 = globals::g_SubmenuIcons_VehicleTypes2_TABLE;
		if (((uVar5 & 2) == 0) && (((byte)FLAGS_004df1f8 & 0x80) != 0)) {
			BVar2 = Interface_Object_FindTeleporter_FUN_0041f030(OBJECT_VEHICLE,objIndex);
			if ((BVar2 != 0) &&
				 (BVar2 = game::Dependencies_Object_FUN_0040add0(OBJECT_VEHICLE,objIndex,0), BVar2 != 0)) {
				iVar3 = game::Object_GetCostCrystal(OBJECT_VEHICLE,objIndex,0);
				iVar4 = game::Level_GetCrystalCount(1);
				if (iVar3 <= iVar4) {
					puVar1 = (uint *)((int)globals::g_SubmenuIcons_VehicleTypes2_TABLE + objIndex * 4);
					*puVar1 = *puVar1 & 0xfffffffe;
					return;
				}
			}
			puVar1 = (uint *)((int)globals::g_SubmenuIcons_VehicleTypes2_TABLE + objIndex * 4);
			*puVar1 = *puVar1 | 1;
			return;
		}
	}
	else {
		if (objType != OBJECT_BUILDING) {
			return;
		}
		uVar5 = *(uint *)((int)globals::g_SubmenuIcons_BuildingTypes2_TABLE + objIndex * 4);
		pvVar6 = globals::g_SubmenuIcons_BuildingTypes2_TABLE;
		if (((uVar5 & 2) == 0) && (((byte)FLAGS_004df1f8 & 0x80) != 0)) {
			BVar2 = Interface_Object_FindTeleporter_FUN_0041f030(OBJECT_BUILDING,objIndex);
			if ((BVar2 != 0) &&
				 (BVar2 = game::Dependencies_Object_FUN_0040add0(OBJECT_BUILDING,objIndex,0), BVar2 != 0)) {
				puVar1 = (uint *)((int)globals::g_SubmenuIcons_BuildingTypes2_TABLE + objIndex * 4);
				*puVar1 = *puVar1 & 0xfffffffe;
				return;
			}
			puVar1 = (uint *)((int)globals::g_SubmenuIcons_BuildingTypes2_TABLE + objIndex * 4);
			*puVar1 = *puVar1 | 1;
			return;
		}
	}
	*(uint *)((int)pvVar6 + objIndex * 4) = uVar5 | 1;
	return;
}



BOOL __cdecl lego::front::Interface_FUN_0041c820(MenuIcon menuIcon,BOOL param_2)
{
	TutorialFlags TVar1;
	
	if (menuIcon == INTERFACE_MENUITEM_BUILD) {
		return 0;
	}
	if ((globs::gameGlobs.flags1 & GAME1_LASERTRACKER) != GAME1_NONE) {
		return 1;
	}
	if (param_2 != 0) {
		TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
		if ((TVar1 & 1) != TUTORIAL_NONE) {
			return ~UINT_ARRAY_004de60c[menuIcon] >> 2 & 1;
		}
	}
	return UINT_ARRAY_004de60c[menuIcon] & 1;
}



BOOL __cdecl lego::front::Interface_FUN_0041c880(ObjectType objType,int objIndex,BOOL param_3)
{
	TutorialFlags TVar1;
	
	if ((globs::gameGlobs.flags1 & GAME1_LASERTRACKER) != GAME1_NONE) {
		return TRUE;
	}
	if (param_3 != 0) {
		TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
		if ((TVar1 & 1) != TUTORIAL_NONE) {
			if (objType == OBJECT_VEHICLE) {
				return ~*(uint *)((int)globals::g_SubmenuIcons_VehicleTypes2_TABLE + objIndex * 4) >> 2 & 1;
			}
			if (objType == OBJECT_BUILDING) {
				return ~*(uint *)((int)globals::g_SubmenuIcons_BuildingTypes2_TABLE + objIndex * 4) >> 2 & 1
				;
			}
		}
	}
	if (objType == OBJECT_VEHICLE) {
		return *(uint *)((int)globals::g_SubmenuIcons_VehicleTypes2_TABLE + objIndex * 4) & 1;
	}
	if (objType == OBJECT_BUILDING) {
		return *(uint *)((int)globals::g_SubmenuIcons_BuildingTypes2_TABLE + objIndex * 4) & 1;
	}
	return 0;
}



void __cdecl lego::front::Interface_FUN_0041c920(MenuIcon menuIcon,BOOL setFlag8)
{
	if (setFlag8 != 0) {
		UINT_ARRAY_004de60c[menuIcon] = UINT_ARRAY_004de60c[menuIcon] | 8;
		return;
	}
	UINT_ARRAY_004de60c[menuIcon] = UINT_ARRAY_004de60c[menuIcon] & 0xfffffff7;
	return;
}



void __cdecl lego::front::Interface_FUN_0041c950(ObjectType objType,int objIndex,BOOL param_3)
{
	uint uVar1;
	void *pvVar2;
	
	pvVar2 = globals::g_SubmenuIcons_VehicleTypes2_TABLE;
	if ((objType == OBJECT_VEHICLE) ||
		 (pvVar2 = globals::g_SubmenuIcons_BuildingTypes2_TABLE, objType == OBJECT_BUILDING)) {
		uVar1 = *(uint *)((int)pvVar2 + objIndex * 4);
		if (param_3 != 0) {
			*(uint *)((int)pvVar2 + objIndex * 4) = uVar1 | 8;
			return;
		}
		*(uint *)((int)pvVar2 + objIndex * 4) = uVar1 & 0xfffffff7;
	}
	return;
}



BOOL __cdecl lego::front::Interface_FUN_0041c990(MenuIcon menuIcon)
{
	return UINT_ARRAY_004de60c[menuIcon] & 8;
}



BOOL __cdecl lego::front::Interface_FUN_0041c9a0(ObjectType objType,int objIndex)
{
	if (objType == OBJECT_VEHICLE) {
		return *(uint *)((int)globals::g_SubmenuIcons_VehicleTypes2_TABLE + objIndex * 4) & 8;
	}
	if (objType == OBJECT_BUILDING) {
		return *(uint *)((int)globals::g_SubmenuIcons_BuildingTypes2_TABLE + objIndex * 4) & 8;
	}
	return 0;
}



ImageBMP * __cdecl lego::front::Interface_FUN_0041c9e0(MenuIcon menuIcon)
{
	BOOL BVar1;
	
	BVar1 = Interface_FUN_0041c820(menuIcon,FALSE);
	if (BVar1 != 0) {
		return PTRImageBMP_ARRAY_004de120[menuIcon];
	}
	BVar1 = Interface_FUN_0041c990(menuIcon);
	if (BVar1 != 0) {
		return PTRImageBMP_ARRAY_004de248[menuIcon];
	}
	return PTRImageBMP_ARRAY_004ddff8[menuIcon];
}



ImageBMP * __cdecl lego::front::Interface_GetBuildImageByObjectType(ObjectType objType,int objIndex)
{
	BOOL BVar1;
	
	BVar1 = Interface_FUN_0041c880(objType,objIndex,0);
	if (BVar1 == 0) {
		BVar1 = Interface_FUN_0041c9a0(objType,objIndex);
		if (BVar1 == 0) {
			if (objType == OBJECT_VEHICLE) {
				return globals::g_InterfaceBuildImages_Vehicles_normal_TABLE[objIndex];
			}
			if (objType == OBJECT_BUILDING) {
				return globals::g_InterfaceBuildImages_Buildings_normal_TABLE[objIndex];
			}
		}
		else {
			if (objType == OBJECT_VEHICLE) {
				return globals::g_InterfaceBuildImages_Vehicles_disabled_TABLE[objIndex];
			}
			if (objType == OBJECT_BUILDING) {
				return globals::g_InterfaceBuildImages_Buildings_disabled_TABLE[objIndex];
			}
		}
	}
	else {
		if (objType == OBJECT_VEHICLE) {
			return globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE[objIndex];
		}
		if (objType == OBJECT_BUILDING) {
			return globals::g_InterfaceBuildImages_Buildings_pressed_TABLE[objIndex];
		}
	}
	return NULL;
}



ImageBMP * __cdecl
lego::front::Interface_GetObjectBuildImage(ObjectType objType,int objIndex,BOOL param_3)
{
	if (param_3 == 0) {
		if (true) {
			switch(objType) {
			case OBJECT_VEHICLE:
				return globals::g_InterfaceBuildImages_Vehicles_pressed_TABLE[objIndex];
			case OBJECT_MINIFIGURE:
				return PTRImageBMP_ARRAY_004de120[1];
			case OBJECT_BUILDING:
				return globals::g_InterfaceBuildImages_Buildings_pressed_TABLE[objIndex];
			case OBJECT_ELECTRICFENCE:
				return PTRImageBMP_ARRAY_004de120[14];
			case OBJECT_PATH:
				return PTRImageBMP_ARRAY_004de120[5];
			}
		}
	}
	else {
		if (true) {
			switch(objType) {
			case OBJECT_VEHICLE:
				return globals::g_InterfaceBuildImages_Vehicles_normal_TABLE[objIndex];
			case OBJECT_MINIFIGURE:
				return PTRImageBMP_ARRAY_004ddff8[1];
			case OBJECT_BUILDING:
				return globals::g_InterfaceBuildImages_Buildings_normal_TABLE[objIndex];
			case OBJECT_ELECTRICFENCE:
				return PTRImageBMP_ARRAY_004ddff8[14];
			case OBJECT_PATH:
				return PTRImageBMP_ARRAY_004ddff8[5];
			}
		}
	}
	return NULL;
}



void __cdecl
lego::front::Interface_SetDat_004decd8_004decdc(MenuIcon menuIcon,ObjectType objType,int objIndex)
{
	if (menuIcon == INTERFACE_MENUITEM_BUILD) {
		ObjectType_004decd8 = objType;
		INTObjectIndex_004decdc = objIndex;
		return;
	}
	if (menuIcon == INTERFACE_MENUITEM_LAYPATH) {
		ObjectType_004decd8 = OBJECT_PATH;
		INTObjectIndex_004decdc = 0;
		return;
	}
	if (menuIcon == INTERFACE_MENUITEM_PLACEFENCE) {
		ObjectType_004decd8 = OBJECT_ELECTRICFENCE;
		INTObjectIndex_004decdc = 0;
	}
	return;
}



void __cdecl lego::front::Interface_FUN_0041cc10(Point2F *point,uint unkWidth,uint unkHeight)
{
	Rect2F_004ded0c.x = point->x;
	Rect2F_004ded0c.y = point->y;
	Rect2F_004ded0c.width = (float)(ulonglong)unkWidth;
	Rect2F_004ded0c.height = (float)(ulonglong)unkHeight;
	return;
}



void __cdecl lego::front::Interface_Front_DrawLineListUnk_FUN_0041cc60(Rect2F *rect)
{
	Point2F local_28;
	Point2F local_20 [4];
	
	if ((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) {
		local_28.x = rect->x - 1.0;
		local_28.y = rect->y - 1.0;
		local_20[1].y = (rect->height + rect->y) - -1.0;
		local_20[0].x = (rect->x + rect->width) - -1.0;
		local_20[0].y = local_28.y;
		local_20[1].x = local_20[0].x;
		local_20[2].x = local_28.x;
		local_20[2].y = local_20[1].y;
		local_20[3].x = local_28.x;
		local_20[3].y = local_28.y;
		draw::Draw_LineListEx(&local_28,local_20,4,0.0,1.0,0.0,DRAWEFFECT_NONE);
		local_28.x = rect->x - 2.0;
		local_28.y = rect->y - 2.0;
		local_20[0].x = (rect->x + rect->width) - -2.0;
		local_20[1].y = (rect->height + rect->y) - -2.0;
		local_20[0].y = local_28.y;
		local_20[1].x = local_20[0].x;
		local_20[2].x = local_28.x;
		local_20[2].y = local_20[1].y;
		local_20[3].x = local_28.x;
		local_20[3].y = local_28.y;
		draw::Draw_LineListEx(&local_28,local_20,4,0.0,1.0,0.0,DRAWEFFECT_NONE);
	}
	return;
}



void __cdecl lego::front::Interface_ChangeMenu_IfVehicleMounted_IsLiveObject(LiveObject *liveObj)
{
	uint uVar1;
	LiveObject **ppLVar2;
	ObjectStatsFlags1 OVar3;
	uint uVar4;
	
	if (InterfaceMenuType_004deccc == INTERFACE_MENU_UNMANNEDVEHICLE) {
		uVar1 = game::Message_GetNumSelectedUnits();
		ppLVar2 = game::Message_GetSelectedUnits();
		for (uVar4 = uVar1; uVar4 != 0; uVar4 -= 1) {
			if (liveObj == *ppLVar2) {
				if (uVar1 == 1) {
					OVar3 = game::LiveObject_GetStatsFlags1(liveObj);
					if (((OVar3 & STATS1_CROSSLAND) == STATS1_NONE) &&
						 ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_40) == 0)) {
						Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_WATERVEHICLE,NULL);
					}
					else {
						Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_VEHICLE,NULL);
					}
				}
				else {
					Interface_BackToMain();
				}
			}
			ppLVar2 = ppLVar2 + 1;
		}
	}
	return;
}



void __cdecl
lego::front::Interface_ChangeMenu_IfPrimarySelectedVehicle_IsLiveObject(LiveObject *liveObj)
{
	uint count;
	LiveObject **ppUnit;
	uint i;
	
	if (((InterfaceMenuType_004deccc == INTERFACE_MENU_VEHICLE) ||
			(InterfaceMenuType_004deccc == INTERFACE_MENU_UPGRADEVEHICLE)) ||
		 (InterfaceMenuType_004deccc == INTERFACE_MENU_WATERVEHICLE)) {
		count = game::Message_GetNumSelectedUnits();
		ppUnit = game::Message_GetSelectedUnits();
		for (i = count; i != 0; i -= 1) {
			if (liveObj->drivenObject == *ppUnit) {
				if (count == 1) {
					Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_UNMANNEDVEHICLE,NULL);
				}
				else {
					Interface_BackToMain();
				}
			}
			ppUnit = ppUnit + 1;
		}
	}
	return;
}



void __cdecl lego::front::Interface_BackToMain_IfSelectedWall_IsBlockPos(Point2I *blockPos)
{
	if (((InterfaceMenuType_004deccc == INTERFACE_MENU_WALL) &&
			(Point2IBlockPos_004decc4.x == blockPos->x)) && (Point2IBlockPos_004decc4.y == blockPos->y)) {
		Interface_BackToMain();
		return;
	}
	return;
}



void __cdecl
lego::front::Interface_BackToMain_IfSelectedGroundOrConstruction_IsBlockPos(Point2I *blockPos)
{
	if ((((InterfaceMenuType_004deccc == INTERFACE_MENU_GROUND) ||
			 (InterfaceMenuType_004deccc == INTERFACE_MENU_CONSTRUCTION)) &&
			(Point2IBlockPos_004decc4.x == blockPos->x)) && (Point2IBlockPos_004decc4.y == blockPos->y)) {
		Interface_BackToMain();
		return;
	}
	return;
}



void __cdecl lego::front::Interface_IfSelectedRubble_IsBlockPos(Point2I *blockPos)
{
	if (((InterfaceMenuType_004deccc == INTERFACE_MENU_RUBBLE) &&
			(Point2IBlockPos_004decc4.x == blockPos->x)) && (Point2IBlockPos_004decc4.y == blockPos->y)) {
		Interface_BackToMain();
		return;
	}
	return;
}



void __cdecl
lego::front::Interface_BackToMain_IfLiveObject_IsSelected_OrFlags3_200000(LiveObject *liveObj)
{
	BOOL BVar1;
	
	if (globs::gameGlobs.viewMode != VIEW_FIRSTPERSON) {
		BVar1 = game::Message_LiveObject_Check_IsSelected_OrFlags3_200000(liveObj,NULL);
		if (BVar1 != 0) {
			Interface_BackToMain();
			return;
		}
	}
	return;
}



BOOL __cdecl lego::front::Interface_HandleIcon_FUN_0041cf70(MenuIcon menuIcon)
{
	TerrainType TVar1;
	LiveFlags5 LVar2;
	MenuIcon MVar3;
	LiveObject *liveObj;
	ObjectStatsFlags3 OVar4;
	ObjectStatsFlags1 OVar5;
	uint uVar6;
	BOOL BVar7;
	ObjectStatsFlags2 OVar8;
	float10 fVar9;
	ObjectType objType;
	code *callback;
	ToolType toolType;
	undefined4 uVar10;
	int iVar11;
	ObjectType local_8;
	int local_4;
	
	liveObj = game::Message_GetPrimarySelectedUnit();
	MVar3 = menuIcon;
	if (false) goto switchD_0041cf8b_caseD_2;
	switch(menuIcon) {
	case INTERFACE_MENUITEM_BACKTODEFAULT:
		if (InterfaceMenuType_004decfc == INTERFACE_MENU_FIRSTPERSON) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_TEKEPORTMAN:
		game::Object_GetObjectByName("Barracks",&local_8,(int *)&menuIcon,NULL);
		BVar7 = Interface_Object_FindTeleporter_FUN_0041f030(OBJECT_MINIFIGURE,0);
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = game::Dependencies_Object_FUN_0040add0(OBJECT_MINIFIGURE,0,0);
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = game::Object_DoOxygenCheck_FUN_0043c4c0(OBJECT_MINIFIGURE,0,local_8,menuIcon);
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_LAYPATH:
		BVar7 = game::Construction_Block_FUN_00408fd0(&Point2IBlockPos_004decc4);
		if (BVar7 != 0) {
			return 0;
		}
		BVar7 = game::Level_Block_IsPowerPath(&Point2IBlockPos_004decc4);
		if (BVar7 != 0) {
			return 0;
		}
		objType = OBJECT_PATH;
		goto LAB_0041d8d5;
	case INTERFACE_MENUITEM_REMOVEPATH:
		BVar7 = game::Level_Block_IsPowerPath(&Point2IBlockPos_004decc4);
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_REPAIRLAVA:
		BVar7 = game::Construction_Block_FUN_00408fd0(&Point2IBlockPos_004decc4);
		if (BVar7 != 0) {
			return 0;
		}
		if ((globs::gameGlobs.level)->blocks
				[((globs::gameGlobs.level)->dimensions).width * Point2IBlockPos_004decc4.y +
				 Point2IBlockPos_004decc4.x].terrain == TERRAIN_LAVA) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_CLEARRUBBLE:
		BVar7 = game::Message_IsAnyUnitsSelected();
		if (BVar7 == 0) break;
		toolType = TOOL_SPADE;
		goto LAB_0041d17f;
	case INTERFACE_MENUITEM_DIG:
		BVar7 = Interface_Block_FUN_0041f670(&Point2IBlockPos_004decc4);
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = game::Message_IsAnyUnitsSelected();
		if (BVar7 == 0) {
			BVar7 = Interface_FUN_0041f2f0(&Point2IBlockPos_004decc4);
			if (BVar7 == 0) {
				return 0;
			}
		}
		else {
			BVar7 = ai::AITask_Game_SelectedUnits_UnkEquippedTool_FUN_00403110(TOOL_DRILL);
			if ((BVar7 == 0) && (BVar7 = Interface_FUN_0041f1e0(), BVar7 == 0)) {
				return 0;
			}
			BVar7 = game::Level_FindSelectedUnit_BlockCheck_FUN_00431960
												(Point2IBlockPos_004decc4.x,Point2IBlockPos_004decc4.y,0);
			if (BVar7 == 0) {
				return 0;
			}
		}
		break;
	case INTERFACE_MENUITEM_REINFORCE:
		BVar7 = Interface_Block_FUN_0041f670(&Point2IBlockPos_004decc4);
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = game::Level_Block_IsReinforced(Point2IBlockPos_004decc4.x,Point2IBlockPos_004decc4.y);
		if (BVar7 != 0) {
			return 0;
		}
		BVar7 = game::Level_Block_IsFlags1_c0(Point2IBlockPos_004decc4.x,Point2IBlockPos_004decc4.y);
		if (BVar7 != 0) {
			return 0;
		}
		BVar7 = game::LiveObject_CheckLevel_FUN_00432950
											(NULL,Point2IBlockPos_004decc4.x,Point2IBlockPos_004decc4.y);
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = game::Message_IsAnyUnitsSelected();
		if (BVar7 == 0) {
			BVar7 = Interface_FUN_0041f330(&Point2IBlockPos_004decc4);
			if (BVar7 == 0) {
				return 0;
			}
		}
		else {
			BVar7 = ai::AITask_Game_SelectedUnits_UnkEquippedTool_FUN_00403110(TOOL_HAMMER);
			if ((BVar7 == 0) && (BVar7 = Interface_FUN_0041f1e0(), BVar7 == 0)) {
				return 0;
			}
			BVar7 = game::Level_FindSelectedLiveObject_Block_FUN_004319e0
												(Point2IBlockPos_004decc4.x,Point2IBlockPos_004decc4.y);
			if (BVar7 == 0) {
				return 0;
			}
		}
		break;
	case INTERFACE_MENUITEM_DYNAMITE:
		BVar7 = Interface_Block_FUN_0041f670(&Point2IBlockPos_004decc4);
		if (BVar7 == 0) {
			return 0;
		}
		TVar1 = (globs::gameGlobs.level)->blocks
						[((globs::gameGlobs.level)->dimensions).width * Point2IBlockPos_004decc4.y +
						 Point2IBlockPos_004decc4.x].terrain;
		if (TVar1 == TERRAIN_IMMOVABLE) {
			return 0;
		}
		if (TVar1 == TERRAIN_RECHARGESEAM) {
			return 0;
		}
		BVar7 = game::Level_GetBlockFlags1_10Not8(Point2IBlockPos_004decc4.x,Point2IBlockPos_004decc4.y)
		;
		if (BVar7 == 0) {
			return 0;
		}
		uVar6 = game::Level_GetBlockFlags1_8000000(&Point2IBlockPos_004decc4);
		if (uVar6 != 0) {
			return 0;
		}
		BVar7 = Interface_FUN_0041f1e0();
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = Interface_FUN_0041f270(8);
		if (BVar7 != 0) break;
		BVar7 = Interface_FUN_0041f220(2,0);
		if (BVar7 == 0) {
			return 0;
		}
		uVar10 = 0x20;
		goto LAB_0041d599;
	case INTERFACE_MENUITEM_PLACEFENCE:
		uVar6 = FUN_00432450(Point2IBlockPos_004decc4.x,Point2IBlockPos_004decc4.y);
		if (uVar6 != 0) {
			return 0;
		}
		BVar7 = game::ElectricFence_Block_FUN_0040d170
											(Point2IBlockPos_004decc4.x,Point2IBlockPos_004decc4.y);
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = 0;
		objType = OBJECT_ELECTRICFENCE;
LAB_0041d8d5:
		BVar7 = game::Dependencies_Object_FUN_0040add0(objType,BVar7,BVar7);
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_CANCELCONSTRUCTION:
		if (((globs::gameGlobs.level)->blocks
				 [((globs::gameGlobs.level)->dimensions).width * Point2IBlockPos_004decc4.y +
					Point2IBlockPos_004decc4.x].flags1 & (BLOCK1_UNK_100000|BLOCK1_UNK_40000000)) ==
				BLOCK1_NONE) {
			return 0;
		}
		uVar6 = FUN_00432f60((int *)&Point2IBlockPos_004decc4);
		if (uVar6 != 0) {
			return 0;
		}
		BVar7 = game::Level_Block_IsPowerPath(&Point2IBlockPos_004decc4);
		if (BVar7 != 0) {
			return 0;
		}
		BVar7 = game::Level_BlockIsFlags1_400_AndOptIsFlags2_4
											(Point2IBlockPos_004decc4.x,Point2IBlockPos_004decc4.y,1);
		if (BVar7 != 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_VEHICLEPICKUP:
	case INTERFACE_MENUITEM_MINIFIGUREPICKUP:
		iVar11 = 0;
		callback = Interface_FUN_0041f400;
		goto LAB_0041d969;
	case INTERFACE_MENUITEM_UNLOADVEHICLE:
	case INTERFACE_MENUITEM_UNLOADMINIFIGURE:
		if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
			 (liveObj->carriedObjects[0]->objType == OBJECT_BARRIER)) {
			return 0;
		}
		OVar4 = game::LiveObject_GetStatsFlags3(liveObj);
		if (((OVar4 & STATS3_CARRYVEHICLES) != STATS3_NONE) &&
			 (iVar11 = FUN_00440080((int *)liveObj), iVar11 == 0)) {
			return 0;
		}
		iVar11 = 0;
		callback = Interface_LiveObject_FUN_0041f3a0;
		goto LAB_0041d969;
	case INTERFACE_MENUITEM_GETIN:
		iVar11 = 2;
		uVar10 = 8;
		OVar4 = game::LiveObject_GetStatsFlags3(liveObj);
		if ((OVar4 & STATS3_NEEDSPILOT) == STATS3_NONE) {
			OVar5 = game::LiveObject_GetStatsFlags1(liveObj);
			if ((OVar5 & STATS1_CROSSLAND) != STATS1_NONE) {
				OVar5 = game::LiveObject_GetStatsFlags1(liveObj);
				if ((OVar5 & STATS1_CROSSWATER) == STATS1_NONE) {
					iVar11 = 4;
					uVar10 = 0x10;
				}
				else {
					iVar11 = 1;
					uVar10 = 4;
				}
			}
		}
		else {
			iVar11 = 1;
			uVar10 = 4;
		}
		OVar4 = game::LiveObject_GetStatsFlags3(liveObj);
		if (((OVar4 & STATS3_GETINATLAND) == STATS3_NONE) || ((*(byte *)&liveObj->flags4 & 0x40) != 0))
		{
			if ((iVar11 == 2) && ((*(byte *)&liveObj->flags4 & 0x40) == 0)) {
				return 0;
			}
		}
		else {
			BVar7 = game::LiveObject_CheckUnkGetInAtLand_FUN_0043a100(liveObj,NULL);
			if (BVar7 == 0) {
				return 0;
			}
		}
		if ((*(byte *)&liveObj->flags2 & 0x10) != 0) {
			return 0;
		}
		BVar7 = Interface_FUN_0041f270(iVar11);
		if (BVar7 != 0) break;
		BVar7 = Interface_FUN_0041f220(2,0);
		if (BVar7 == 0) {
			return 0;
		}
		goto LAB_0041d599;
	case INTERFACE_MENUITEM_GETOUT:
		if ((*(byte *)&liveObj->flags1 & 1) != 0) {
			return 0;
		}
		OVar5 = game::LiveObject_GetStatsFlags1(liveObj);
		if ((OVar5 & STATS1_CANBEDRIVEN) == STATS1_NONE) {
			return 0;
		}
		OVar5 = game::LiveObject_GetStatsFlags1(liveObj);
		if ((((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) &&
				(iVar11 = FUN_0043a0d0(liveObj,NULL), iVar11 == 0)) &&
			 ((*(byte *)&liveObj->flags4 & 0x40) == 0)) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_GOTODOCK:
		if ((*(byte *)&liveObj->flags1 & 1) != 0) {
			return 0;
		}
		OVar5 = game::LiveObject_GetStatsFlags1(liveObj);
		if ((OVar5 & STATS1_CANBEDRIVEN) == STATS1_NONE) {
			return 0;
		}
		if ((*(byte *)&liveObj->flags4 & 0x40) != 0) {
			return 0;
		}
		iVar11 = game::LiveObject_FUN_00438ca0(liveObj,1);
		if (iVar11 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_VEHICLEDIG:
		if ((*(byte *)&liveObj->flags3 & 2) == 0) {
			return 0;
		}
		if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_LEGOMANDIG:
		toolType = TOOL_DRILL;
LAB_0041d17f:
		BVar7 = ai::AITask_Game_SelectedUnits_UnkEquippedTool_FUN_00403110(toolType);
		if ((BVar7 == 0) && (BVar7 = Interface_FUN_0041f1e0(), BVar7 == 0)) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_GOFEED:
		iVar11 = 0;
		callback = Interface_LiveObject_IsEnergyLessThan100;
		goto LAB_0041d969;
	case INTERFACE_MENUITEM_DROPBIRDSCARER:
		iVar11 = 6;
		callback = Interface_LiveObject_HasToolEquipped_2;
LAB_0041d969:
		BVar7 = Interface_DoSelectedUnits_Callback(callback,iVar11);
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_POWERON:
	case INTERFACE_MENUITEM_POWEROFF:
		OVar8 = game::LiveObject_GetStatsFlags2(liveObj);
		if ((OVar8 & STATS2_SELFPOWERED) != STATS2_NONE) {
			return 0;
		}
		if ((liveObj->flags3 & LIVEOBJ3_HASPOWER) == LIVEOBJ3_NONE) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_REPAIR:
		BVar7 = Interface_DoSelectedUnits_Callback(Interface_LiveObject_IsHealthLessThan100,0);
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = Interface_FUN_0041f270(0x10);
		if (BVar7 != 0) break;
		BVar7 = Interface_FUN_0041f220(2,0);
		if (BVar7 == 0) {
			return 0;
		}
		uVar10 = 0x40;
LAB_0041d599:
		BVar7 = Interface_FUN_0041f1a0(uVar10);
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_MAKETELEPORTERPRIMARY:
		BVar7 = game::LiveObject_IsSmallTeleporter(liveObj);
		if (((BVar7 == 0) && (BVar7 = game::LiveObject_IsBigTeleporter(liveObj), BVar7 == 0)) &&
			 (BVar7 = game::LiveObject_IsWaterTeleporter(liveObj), BVar7 == 0)) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_EJECTCRYSTAL:
		BVar7 = game::LiveObject_CanSpawnCarryableObject(liveObj,OBJECT_POWERCRYSTAL,0);
		if (BVar7 == 0) {
			return 0;
		}
	case INTERFACE_MENUITEM_EJECTORE:
		BVar7 = game::LiveObject_CanSpawnCarryableObject(liveObj,OBJECT_ORE,0);
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_DELETEVEHICLE:
		game::LiveObject_GetBlockPos(liveObj,(int *)&local_8,&local_4);
		if ((liveObj->drivenObject != NULL) &&
			 (iVar11 = game::LiveObject_FUN_00431cd0
													 (liveObj->drivenObject,local_8,local_4,local_8,local_4,1), iVar11 == 0))
		{
			return 0;
		}
		OVar4 = game::LiveObject_GetStatsFlags3(liveObj);
		if (((((OVar4 & STATS3_CARRYVEHICLES) != STATS3_NONE) &&
				 ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
				(liveObj->carriedObjects[0] != NULL)) &&
			 (iVar11 = game::LiveObject_FUN_00431cd0
													 (liveObj->carriedObjects[0],local_8,local_4,local_8,local_4,1),
			 iVar11 == 0)) {
			return 0;
		}
		OVar5 = game::LiveObject_GetStatsFlags1(liveObj);
		if (((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) && ((*(byte *)&liveObj->flags4 & 0x40) == 0)) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_GOTOFIRSTPERSON:
		if ((liveObj == globs::gameGlobs.objectFP) && ((globs::gameGlobs.cameraFP)->field_14 == 0)) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_GOTOSECONDPERSON:
		if ((liveObj == globs::gameGlobs.objectFP) && ((globs::gameGlobs.cameraFP)->field_14 == 1)) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_GETTOOL:
		goto switchD_0041cf8b_caseD_30;
	case INTERFACE_MENUITEM_GETDRILL:
		iVar11 = TOOL_DRILL;
		goto LAB_0041d741;
	case INTERFACE_MENUITEM_GETSPADE:
		iVar11 = TOOL_SPADE;
		goto LAB_0041d741;
	case INTERFACE_MENUITEM_GETHAMMER:
		iVar11 = TOOL_HAMMER;
		goto LAB_0041d741;
	case INTERFACE_MENUITEM_GETSPANNER:
		iVar11 = TOOL_SPANNER;
		goto LAB_0041d741;
	case INTERFACE_MENUITEM_GETLASER:
		iVar11 = TOOL_LASER;
		goto LAB_0041d741;
	case INTERFACE_MENUITEM_GETPUSHERGUN:
		iVar11 = TOOL_PUSHERGUN;
		goto LAB_0041d741;
	case INTERFACE_MENUITEM_GETFREEZERGUN:
		iVar11 = TOOL_FREEZERGUN;
		goto LAB_0041d741;
	case INTERFACE_MENUITEM_GETBIRDSCARER:
		iVar11 = TOOL_BIRDSCARER;
LAB_0041d741:
		BVar7 = Interface_DoSelectedUnits_Callback(Interface_LiveObject_DoesNotHaveToolEquipped,iVar11);
		if (BVar7 == 0) {
			return 0;
		}
switchD_0041cf8b_caseD_30:
		BVar7 = Interface_FUN_0041f1e0();
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_TRAINSKILL:
		BVar7 = Interface_FUN_0041f1a0(0xfc);
		if (BVar7 == 0) {
			return 0;
		}
		LVar2 = liveObj->flags5_3f0;
		if (((((LVar2 & LIVEOBJ5_ABILITY_PILOT) != LIVEOBJ5_NONE) &&
				 ((LVar2 & LIVEOBJ5_ABILITY_SAILOR) != LIVEOBJ5_NONE)) &&
				(((LVar2 & LIVEOBJ5_ABILITY_DRIVER) != LIVEOBJ5_NONE &&
				 (((LVar2 & LIVEOBJ5_ABILITY_DYNAMITE) != LIVEOBJ5_NONE &&
					((LVar2 & LIVEOBJ5_ABILITY_REPAIR) != LIVEOBJ5_NONE)))))) &&
			 ((LVar2 & LIVEOBJ5_ABILITY_SCANNER) != LIVEOBJ5_NONE)) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_TRAINDRIVER:
		BVar7 = Interface_FUN_0041f650(4);
		if (BVar7 != 0) {
			return 0;
		}
		uVar10 = 0x10;
		goto LAB_0041d829;
	case INTERFACE_MENUITEM_TRAINENGINEER:
		BVar7 = Interface_FUN_0041f650(0x10);
		if (BVar7 != 0) {
			return 0;
		}
		uVar10 = 0x40;
		goto LAB_0041d829;
	case INTERFACE_MENUITEM_TRAINGEOLOGIST:
		BVar7 = Interface_FUN_0041f650(0x20);
		if (BVar7 != 0) {
			return 0;
		}
		uVar10 = 0x80;
		goto LAB_0041d829;
	case INTERFACE_MENUITEM_TRAINPILOT:
		BVar7 = Interface_FUN_0041f650(1);
		if (BVar7 != 0) {
			return 0;
		}
		uVar10 = 4;
LAB_0041d829:
		iVar11 = Interface_FUN_0041f1a0(uVar10);
joined_r0x0041d86f:
		if (iVar11 == 0) {
			return 0;
		}
		fVar9 = game::Level_GetTrainTime();
		if ((ushort)((ushort)(fVar9 < (float10)liveObj->elapsedTime1) << 8 |
								(ushort)(fVar9 == (float10)liveObj->elapsedTime1) << 0xe) == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_TRAINSAILOR:
		BVar7 = Interface_FUN_0041f650(2);
		if (BVar7 != 0) {
			return 0;
		}
		uVar10 = 8;
		goto LAB_0041d865;
	case INTERFACE_MENUITEM_TRAINDYNAMITE:
		BVar7 = Interface_FUN_0041f650(8);
		if (BVar7 != 0) {
			return 0;
		}
		uVar10 = 0x20;
LAB_0041d865:
		iVar11 = Interface_FUN_0041f1a0(uVar10);
		goto joined_r0x0041d86f;
	case INTERFACE_MENUITEM_UPGRADEMAN:
		uVar6 = game::Object_GetLevels(liveObj->objType,liveObj->objIndex);
		if (uVar6 <= liveObj->objLevel + 1) {
			return 0;
		}
		if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
			return 0;
		}
		goto switchD_0041cf8b_caseD_30;
	case INTERFACE_MENUITEM_UPGRADEBUILDING:
		BVar7 = game::LiveObject_GetBuildingUpgradeCost(liveObj,NULL);
		if (BVar7 == 0) {
			return 0;
		}
		break;
	case INTERFACE_MENUITEM_UPGRADEVEHICLE:
		BVar7 = Interface_FUN_0041f160();
		if (BVar7 == 0) {
			return 0;
		}
		BVar7 = FUN_00438b70(liveObj,1);
		if (((BVar7 != 0) || (BVar7 = FUN_00438b70(liveObj,0), BVar7 != 0)) ||
			 (BVar7 = FUN_00438b70(liveObj,2), BVar7 != 0)) break;
		goto LAB_0041da08;
	case INTERFACE_MENUITEM_UPGRADEENGINE:
		BVar7 = Interface_FUN_0041f160();
		if (BVar7 == 0) {
			return 0;
		}
		iVar11 = 1;
		goto LAB_0041da0a;
	case INTERFACE_MENUITEM_UPGRADEDRILL:
		BVar7 = Interface_FUN_0041f160();
		if (BVar7 == 0) {
			return 0;
		}
		iVar11 = 0;
		goto LAB_0041da0a;
	case INTERFACE_MENUITEM_UPGRADESCAN:
		BVar7 = Interface_FUN_0041f160();
		if (BVar7 == 0) {
			return 0;
		}
		iVar11 = 2;
		goto LAB_0041da0a;
	case INTERFACE_MENUITEM_UPGRADECARRY:
		BVar7 = Interface_FUN_0041f160();
		if (BVar7 == 0) {
			return 0;
		}
LAB_0041da08:
		iVar11 = 3;
LAB_0041da0a:
		BVar7 = FUN_00438b70(liveObj,iVar11);
		if (BVar7 == 0) {
			return 0;
		}
	}
switchD_0041cf8b_caseD_2:
	if (((byte)globs::gameGlobs.flags3 & 6) == 0) {
		if (((byte)globs::gameGlobs.flags3 & 0x18) == 0) {
			if ((((byte)globs::gameGlobs.flags3 & 0x60) != 0) &&
				 (MVar3 != INTERFACE_MENUITEM_BACKTODEFAULT)) {
				if ((int)MVar3 < 0x1d) {
					return 0;
				}
				if (0x1e < (int)MVar3) {
					return 0;
				}
			}
		}
		else {
			if (MVar3 != INTERFACE_MENUITEM_BACKTODEFAULT) {
				if ((int)MVar3 < 0x14) {
					return 0;
				}
				if (0x15 < (int)MVar3) {
					return 0;
				}
			}
		}
	}
	else {
		if ((MVar3 != INTERFACE_MENUITEM_BACKTODEFAULT) && (((int)MVar3 < 0x1b || (0x1c < (int)MVar3))))
		{
			return 0;
		}
	}
	return TRUE;
}



BOOL __cdecl lego::front::Interface_DoAction_FUN_0041dbd0(MenuIcon menuIcon)
{
	ObjectType OVar1;
	LiveObject *pLVar2;
	BOOL BVar3;
	SurfaceMap *pSVar4;
	ObjectStatsFlags1 OVar5;
	LevelData *pLVar6;
	int iVar7;
	ObjectStatsFlags3 OVar8;
	GameFlags3 GVar9;
	int iVar10;
	WallHighlightType highlightType;
	undefined4 uVar11;
	
	pLVar2 = game::Message_GetPrimarySelectedUnit();
	BVar3 = Interface_FUN_0041c820(menuIcon,TRUE);
	if (BVar3 != 0) {
		return 0;
	}
	if (false) goto switchD_0041dbfa_caseD_8;
	switch(menuIcon) {
	case INTERFACE_MENUITEM_BACKTODEFAULT:
		if (0xf < (int)InterfaceMenuType_004deccc) {
			if ((int)InterfaceMenuType_004deccc < 0x12) {
				Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_LEGOMAN,NULL);
				return TRUE;
			}
			if (InterfaceMenuType_004deccc == INTERFACE_MENU_UPGRADEVEHICLE) {
				OVar5 = game::LiveObject_GetStatsFlags1(pLVar2);
				if (((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) &&
					 ((*(byte *)&pLVar2->flags4 & LIVEOBJ4_UNK_40) == 0)) {
					Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_WATERVEHICLE,NULL);
					return TRUE;
				}
				Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_VEHICLE,NULL);
				return TRUE;
			}
		}
		break;
	case INTERFACE_MENUITEM_TEKEPORTMAN:
		game::Game_TryPlaceObject(OBJECT_MINIFIGURE,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_BUILDBUILDING:
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_BUILDBUILDING,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_BUILDSMALLVEHICLE:
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_BUILDSMALLVEHICLE,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_BUILDLARGEVEHICLE:
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_BUILDLARGEVEHICLE,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_LAYPATH:
	case INTERFACE_MENUITEM_REPAIRLAVA:
		game::Construction_Block_FUN_00409230(&Point2IBlockPos_004decc4);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_REMOVEPATH:
		ai::AITask_DoClearTypeAction(&Point2IBlockPos_004decc4,MESSAGE_CLEARREMOVEPATH_COMPLETE);
		pLVar6 = game::GetLevel();
		iVar7 = (pLVar6->dimensions).width * Point2IBlockPos_004decc4.y + Point2IBlockPos_004decc4.x;
		pLVar6 = game::GetLevel();
		pLVar6->blocks[iVar7].flags1 = pLVar6->blocks[iVar7].flags1 & ~BLOCK1_POWERPATH;
		game::Level_UpdateBlockSurfaceUnk
							(globs::gameGlobs.level,Point2IBlockPos_004decc4.x,Point2IBlockPos_004decc4.y,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_CLEARRUBBLE:
		ai::AITask_FUN_00401f40(AITASK_CLEAR,NULL,&Point2IBlockPos_004decc4);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_DIG:
		ai::AITask_DoDig_AtBlockPos(&Point2IBlockPos_004decc4,0,1);
		goto LAB_0041de87;
	case INTERFACE_MENUITEM_REINFORCE:
		ai::AITask_DoReinforce_AtBlockPos(&Point2IBlockPos_004decc4);
		goto LAB_0041de87;
	case INTERFACE_MENUITEM_DYNAMITE:
		ai::AITask_DoDynamite_AtBlockPos(&Point2IBlockPos_004decc4,0);
LAB_0041de87:
		iVar7 = Point2IBlockPos_004decc4.x;
		iVar10 = Point2IBlockPos_004decc4.y;
		pSVar4 = game::GetSurfaceMap();
		WallHighlightType_004df1f0 = game::Map3D_Block_GetHighlightType(pSVar4,iVar7,iVar10);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_PLACEFENCE:
		ai::AITask_DoElecFence(&Point2IBlockPos_004decc4);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_DESELECTDIG:
		ai::AITask_Block_FUN_00402a10(&Point2IBlockPos_004decc4,0);
		WallHighlightType_004df1f0 = WALLHIGHLIGHT_NONE;
		highlightType = WALLHIGHLIGHT_SELECTED;
		iVar7 = Point2IBlockPos_004decc4.x;
		iVar10 = Point2IBlockPos_004decc4.y;
		pSVar4 = game::GetSurfaceMap();
		game::Map3D_Block_SetHighlightType(pSVar4,iVar7,iVar10,highlightType);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_CANCELCONSTRUCTION:
		if (((globs::gameGlobs.level)->blocks
				 [((globs::gameGlobs.level)->dimensions).width * Point2IBlockPos_004decc4.y +
					Point2IBlockPos_004decc4.x].flags1 & BLOCK1_UNK_40000000) == BLOCK1_NONE) {
			game::Construction_Cancel(&Point2IBlockPos_004decc4);
			Interface_BackToMain();
			return TRUE;
		}
		game::Construction_Cancel2(&Point2IBlockPos_004decc4);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_SELECTMAN:
		game::Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
		game::Message_AddMessageAction(MESSAGE_SELECT,pLVar2,0,NULL);
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_LEGOMAN,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_SELECTVEHICLE:
		game::Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
		game::Message_AddMessageAction(MESSAGE_SELECT,pLVar2,0,NULL);
		OVar5 = game::LiveObject_GetStatsFlags1(pLVar2);
		if (((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) && ((*(byte *)&pLVar2->flags4 & 0x40) == 0)) {
			Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_WATERVEHICLE,NULL);
			return TRUE;
		}
LAB_0041df4c:
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_VEHICLE,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_SELECTBUILDING:
		game::Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
		game::Message_AddMessageAction(MESSAGE_SELECT,pLVar2,0,NULL);
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_BUILDING,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_VEHICLEPICKUP:
		OVar8 = game::LiveObject_GetStatsFlags3(pLVar2);
		if ((OVar8 & STATS3_CARRYVEHICLES) != STATS3_NONE) {
			ai::AITask_DoFindLoad(pLVar2);
			return TRUE;
		}
		GVar9 = GAME3_LOADVEHICLE;
		if ((globs::gameGlobs.flags3 & GAME3_LOADVEHICLE) != GAME3_NONE) {
			game::Game_ClearSomeFlags3_FUN_00435950();
			return TRUE;
		}
		goto LAB_0041e4b7;
	case INTERFACE_MENUITEM_MINIFIGUREPICKUP:
		GVar9 = GAME3_PICKUPOBJECT;
		if ((globs::gameGlobs.flags3 & GAME3_PICKUPOBJECT) != GAME3_NONE) {
			game::Game_ClearSomeFlags3_FUN_00435950();
			return TRUE;
		}
		goto LAB_0041e4b7;
	case INTERFACE_MENUITEM_UNLOADVEHICLE:
	case INTERFACE_MENUITEM_UNLOADMINIFIGURE:
		Interface_DoSelectedUnits_Callback(Interface_LiveObject_Callback_FUN_0041f5f0,0);
		return TRUE;
	case INTERFACE_MENUITEM_GETIN:
		game::Message_PTL_ClearSelection();
		ai::AITask_DoFindDriver_Target(pLVar2);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETOUT:
		FUN_00440470(pLVar2,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GOTODOCK:
		FUN_00440470(pLVar2,1);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_LEGOMANGOTO:
		GVar9 = GAME3_UNK_2;
		if ((globs::gameGlobs.flags3 & GAME3_UNK_2) != GAME3_NONE) {
			game::Game_ClearSomeFlags3_FUN_00435950();
			return TRUE;
		}
		goto LAB_0041e4b7;
	case INTERFACE_MENUITEM_VEHICLEGOTO:
		GVar9 = GAME3_UNK_4;
		if ((globs::gameGlobs.flags3 & GAME3_UNK_4) != GAME3_NONE) {
			game::Game_ClearSomeFlags3_FUN_00435950();
			return TRUE;
		}
		goto LAB_0041e4b7;
	case INTERFACE_MENUITEM_VEHICLEDIG:
		GVar9 = GAME3_UNK_40;
		goto LAB_0041e4a1;
	case INTERFACE_MENUITEM_LEGOMANDIG:
		GVar9 = GAME3_UNK_20;
LAB_0041e4a1:
		if (((byte)globs::gameGlobs.flags3 & (byte)GVar9) != 0) {
			game::Game_ClearSomeFlags3_FUN_00435950();
			return TRUE;
		}
LAB_0041e4b7:
		game::Game_ClearSomeFlags3_FUN_00435950();
		globs::gameGlobs.flags3 = globs::gameGlobs.flags3 | GVar9;
		return TRUE;
	case INTERFACE_MENUITEM_GOFEED:
		Interface_DoSelectedUnits_Callback(Interface_LiveObject_GoEatIfEnergyIsLessThan100,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_DELETEMAN:
	case INTERFACE_MENUITEM_DELETEBUILDING:
	case INTERFACE_MENUITEM_DELETEVEHICLE:
	case INTERFACE_MENUITEM_DELETEELECTRICFENCE:
		Interface_DoSelectedUnits_Callback(Interface_LiveObject_Callback_FUN_0041f520,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_DROPBIRDSCARER:
		Interface_DoSelectedUnits_Callback(Interface_LiveObject_FUN_0041f770,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_POWERON:
		BVar3 = 1;
		goto LAB_0041e51b;
	case INTERFACE_MENUITEM_POWEROFF:
		BVar3 = 0;
LAB_0041e51b:
		game::LiveObject_SetFlag3_80000000(pLVar2,BVar3);
		break;
	case INTERFACE_MENUITEM_REPAIR:
		Interface_DoSelectedUnits_Callback(Interface_LiveObject_GoRepairIfHealthLessThan100,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_MAKETELEPORTERPRIMARY:
		BVar3 = game::LiveObject_IsSmallTeleporter(pLVar2);
		if (BVar3 != 0) {
			globs::gameGlobs.placeDestSmallTeleporter = pLVar2;
			Interface_BackToMain();
			return TRUE;
		}
		BVar3 = game::LiveObject_IsBigTeleporter(pLVar2);
		if (BVar3 != 0) {
			globs::gameGlobs.placeDestBigTeleporter = pLVar2;
			Interface_BackToMain();
			return TRUE;
		}
		BVar3 = game::LiveObject_IsWaterTeleporter(pLVar2);
		if (BVar3 != 0) {
			globs::gameGlobs.placeDestWaterTeleporter = pLVar2;
			Interface_BackToMain();
			return TRUE;
		}
		break;
	case INTERFACE_MENUITEM_EJECTCRYSTAL:
		FUN_0043a910(pLVar2,OBJECT_POWERCRYSTAL,0,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_EJECTORE:
		FUN_0043a910(pLVar2,OBJECT_ORE,ORE_NORMAL,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GOTOTOPVIEW:
		game::Message_AddMessageAction(MESSAGE_TOPVIEW,0,0,NULL);
		OVar1 = pLVar2->objType;
		if (OVar1 == OBJECT_VEHICLE) {
			OVar5 = game::LiveObject_GetStatsFlags1(pLVar2);
			if (((OVar5 & STATS1_CROSSLAND) == STATS1_NONE) &&
				 ((*(byte *)&pLVar2->flags4 & LIVEOBJ4_UNK_40) == 0)) {
				Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_WATERVEHICLE,NULL);
				return TRUE;
			}
			goto LAB_0041df4c;
		}
		if (OVar1 == OBJECT_MINIFIGURE) {
			Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_LEGOMAN,NULL);
			return TRUE;
		}
		if (OVar1 == OBJECT_BUILDING) {
			Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_BUILDING,NULL);
			return TRUE;
		}
		break;
	case INTERFACE_MENUITEM_GOTOFIRSTPERSON:
		uVar11 = 0;
		goto LAB_0041deb2;
	case INTERFACE_MENUITEM_GOTOSECONDPERSON:
		uVar11 = 1;
LAB_0041deb2:
		game::Message_AddMessageAction(MESSAGE_FIRSTPERSON,0,uVar11,NULL);
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_FIRSTPERSON,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_TRACKOBJECT:
		game::Game_TrackObjectInRadar(pLVar2);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETTOOL:
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_GETTOOL,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_GETDRILL:
		Interface_DoSelectedUnits_Callback(Interface_LiveObject_GoGetToolIfNotEquipped,TOOL_DRILL);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETSPADE:
		Interface_DoSelectedUnits_Callback(Interface_LiveObject_GoGetToolIfNotEquipped,TOOL_SPADE);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETHAMMER:
		Interface_DoSelectedUnits_Callback(Interface_LiveObject_GoGetToolIfNotEquipped,TOOL_HAMMER);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETSPANNER:
		Interface_DoSelectedUnits_Callback(Interface_LiveObject_GoGetToolIfNotEquipped,TOOL_SPANNER);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETLASER:
		Interface_DoSelectedUnits_Callback(Interface_LiveObject_GoGetToolIfNotEquipped,TOOL_LASER);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETPUSHERGUN:
		Interface_DoSelectedUnits_Callback(Interface_LiveObject_GoGetToolIfNotEquipped,TOOL_PUSHERGUN);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETFREEZERGUN:
		Interface_DoSelectedUnits_Callback(Interface_LiveObject_GoGetToolIfNotEquipped,TOOL_FREEZERGUN);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_GETBIRDSCARER:
		Interface_DoSelectedUnits_Callback(Interface_LiveObject_GoGetToolIfNotEquipped,TOOL_BIRDSCARER);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_TRAINSKILL:
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_TRAINSKILL,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_TRAINDRIVER:
	case INTERFACE_MENUITEM_TRAINENGINEER:
	case INTERFACE_MENUITEM_TRAINGEOLOGIST:
	case INTERFACE_MENUITEM_TRAINPILOT:
	case INTERFACE_MENUITEM_TRAINSAILOR:
	case INTERFACE_MENUITEM_TRAINDYNAMITE:
		switch(menuIcon) {
		case INTERFACE_MENUITEM_TRAINDRIVER:
			menuIcon = TRAINED_DRIVER;
			break;
		case INTERFACE_MENUITEM_TRAINENGINEER:
			menuIcon = TRAINED_REPAIR;
			break;
		case INTERFACE_MENUITEM_TRAINGEOLOGIST:
			menuIcon = TRAINED_SCANNER;
			break;
		case INTERFACE_MENUITEM_TRAINPILOT:
			menuIcon = TRAINED_PILOT;
			break;
		case INTERFACE_MENUITEM_TRAINSAILOR:
			menuIcon = TRAINED_SAILOR;
			break;
		case INTERFACE_MENUITEM_TRAINDYNAMITE:
			menuIcon = TRAINED_DYNAMITE;
		}
		pLVar2 = (LiveObject *)FUN_00439110(pLVar2,NULL,menuIcon);
		if (pLVar2 == NULL) {
			return 0;
		}
		ai::AITask_DoTrain_Target(pLVar2,menuIcon,TRUE);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_UPGRADEMAN:
		ai::AITask_DoUpgrade(pLVar2,0);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_UPGRADEBUILDING:
		game::LiveObject_FUN_00438ab0(pLVar2);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_UPGRADEVEHICLE:
		Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_UPGRADEVEHICLE,NULL);
		return TRUE;
	case INTERFACE_MENUITEM_UPGRADEENGINE:
		uVar11 = 1;
		goto LAB_0041e4f4;
	case INTERFACE_MENUITEM_UPGRADEDRILL:
		uVar11 = 0;
		goto LAB_0041e4f4;
	case INTERFACE_MENUITEM_UPGRADESCAN:
		uVar11 = 2;
		goto LAB_0041e4f4;
	case INTERFACE_MENUITEM_UPGRADECARRY:
		uVar11 = 3;
LAB_0041e4f4:
		ai::AITask_DoUpgrade(pLVar2,uVar11);
		pLVar2->elapsedTime2 = 0.0;
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_ENCYCLOPEDIA:
		if ((globs::gameGlobs.flags3 & GAME3_UNK_1) == GAME3_NONE) {
			game::Game_ClearSomeFlags3_FUN_00435950();
			globs::gameGlobs.flags3 |= GAME3_UNK_1;
			Encyclopedia_UnsetFlag1_004c8ea8();
			Interface_BackToMain();
			return TRUE;
		}
		game::Game_ClearSomeFlags3_FUN_00435950();
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_CLEARSELECTION:
		game::Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
		Interface_BackToMain();
		return TRUE;
	case INTERFACE_MENUITEM_BUILD:
		BVar3 = Interface_FUN_0041c880(ObjectType_004decd8,INTObjectIndex_004decdc,1);
		if (BVar3 != 0) {
			return 0;
		}
		game::Game_TryPlaceObject(ObjectType_004decd8,INTObjectIndex_004decdc);
		if (ObjectType_004decd8 == OBJECT_BUILDING) {
			return TRUE;
		}
	}
switchD_0041dbfa_caseD_8:
	Interface_BackToMain();
	return TRUE;
}



void __cdecl lego::front::Interface_BackToMain(void)
{
	game::Message_AddMessageAction(MESSAGE_CLEARSELECT,0,FALSE,NULL);
	Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_MAIN,NULL);
	return;
}



void __cdecl lego::front::Interface_SetIconFlash(MenuIcon menuIcon,BOOL flash)
{
	if (flash != 0) {
		UINT_ARRAY_004de60c[menuIcon] = UINT_ARRAY_004de60c[menuIcon] | 4;
		return;
	}
	UINT_ARRAY_004de60c[menuIcon] = UINT_ARRAY_004de60c[menuIcon] & 0xfffffffb;
	return;
}



void __cdecl lego::front::Interface_SetSubmenuIconFlash(ObjectType objType,int objIndex,BOOL state)
{
	uint uVar1;
	void *pvVar2;
	
	pvVar2 = globals::g_SubmenuIcons_VehicleTypes2_TABLE;
	if ((objType == OBJECT_VEHICLE) ||
		 (pvVar2 = globals::g_SubmenuIcons_BuildingTypes2_TABLE, objType == OBJECT_BUILDING)) {
		uVar1 = *(uint *)((int)pvVar2 + objIndex * 4);
		if (state != 0) {
			*(uint *)((int)pvVar2 + objIndex * 4) = uVar1 | 4;
			return;
		}
		*(uint *)((int)pvVar2 + objIndex * 4) = uVar1 & 0xfffffffb;
	}
	return;
}



LiveObject * __cdecl lego::front::Interface_GetPrimarySelectedUnit(void)
{
	return (LiveObject *)
				 (-(uint)(globs::messageGlobs.selectedUnitCount != 0) &
				 (uint)globs::messageGlobs.selectedUnitList[0]);
}



BOOL __cdecl lego::front::Interface_SetIconClicked(MenuIcon menuIcon,uint clicked)
{
	uint uVar1;
	
	uVar1 = globals::g_Interface_Icons_Clicked[menuIcon];
	globals::g_Interface_Icons_Clicked[menuIcon] = clicked;
	return uVar1;
}



BOOL __cdecl lego::front::Interface_GetIconClicked(MenuIcon menuIcon)
{
	return globals::g_Interface_Icons_Clicked[menuIcon];
}



BOOL __cdecl
lego::front::Interface_SetSubmenuIconClicked(ObjectType objType,int objIndex,BOOL clicked)
{
	BOOL BVar1;
	
	BVar1 = 0;
	if (objType == OBJECT_VEHICLE) {
		BVar1 = *(BOOL *)((int)globals::g_SubmenuIcons_VehicleTypesClicked_TABLE + objIndex * 4);
		*(BOOL *)((int)globals::g_SubmenuIcons_VehicleTypesClicked_TABLE + objIndex * 4) = clicked;
		return BVar1;
	}
	if (objType == OBJECT_BUILDING) {
		BVar1 = *(BOOL *)((int)globals::g_SubmenuIcons_BuildingTypesClicked_TABLE + objIndex * 4);
		*(BOOL *)((int)globals::g_SubmenuIcons_BuildingTypesClicked_TABLE + objIndex * 4) = clicked;
	}
	return BVar1;
}



BOOL __cdecl lego::front::Interface_GetSubmenuIconClicked(ObjectType objType,int objIndex)
{
	if (objType == OBJECT_VEHICLE) {
		return *(BOOL *)((int)globals::g_SubmenuIcons_VehicleTypesClicked_TABLE + objIndex * 4);
	}
	if (objType == OBJECT_BUILDING) {
		return *(BOOL *)((int)globals::g_SubmenuIcons_BuildingTypesClicked_TABLE + objIndex * 4);
	}
	return 0;
}



BOOL __cdecl lego::front::Interface_DoAdvisorIcon_FUN_0041e7c0(MenuIcon menuIcon,BOOL setFlag60)
{
	uint uVar1;
	
	uVar1 = FLAGS_004df1f8 | 0x20;
	if (setFlag60 != 0) {
		uVar1 = FLAGS_004df1f8 | 0x60;
	}
	FLAGS_004df1f8 = uVar1;
	AdvisorType_004ded24 = Interface_GetAdvisorType_FromIcon(menuIcon);
	MenuIcon_004ded28 = menuIcon;
	return TRUE;
}



AdvisorType __cdecl lego::front::Interface_GetAdvisorType_FromIcon(MenuIcon menuIcon)
{
	if (true) {
		switch(menuIcon) {
		case INTERFACE_MENUITEM_BACKTODEFAULT:
			return ADVISOR_ICONPOINT_BACKBUTTON;
		case INTERFACE_MENUITEM_TEKEPORTMAN:
		case INTERFACE_MENUITEM_BUILDBUILDING:
		case INTERFACE_MENUITEM_LAYPATH:
		case INTERFACE_MENUITEM_REMOVEPATH:
		case INTERFACE_MENUITEM_CLEARRUBBLE:
		case INTERFACE_MENUITEM_DIG:
		case INTERFACE_MENUITEM_REINFORCE:
		case INTERFACE_MENUITEM_PLACEFENCE:
		case INTERFACE_MENUITEM_VEHICLEPICKUP:
		case INTERFACE_MENUITEM_UNLOADVEHICLE:
		case INTERFACE_MENUITEM_UNLOADMINIFIGURE:
		case INTERFACE_MENUITEM_GETIN:
		case INTERFACE_MENUITEM_GOFEED:
		case INTERFACE_MENUITEM_POWERON:
		case INTERFACE_MENUITEM_REPAIR:
		case INTERFACE_MENUITEM_DELETEVEHICLE:
		case INTERFACE_MENUITEM_DELETEELECTRICFENCE:
		case INTERFACE_MENUITEM_ATTACK:
		case INTERFACE_MENUITEM_GOTOTOPVIEW:
		case INTERFACE_MENUITEM_GOTOSECONDPERSON:
		case INTERFACE_MENUITEM_TRACKOBJECT:
		case INTERFACE_MENUITEM_GETDRILL:
		case INTERFACE_MENUITEM_GETSPADE:
		case INTERFACE_MENUITEM_TRAINDRIVER:
		case INTERFACE_MENUITEM_TRAINENGINEER:
		case INTERFACE_MENUITEM_UPGRADEENGINE:
		case INTERFACE_MENUITEM_UPGRADEDRILL:
			return ADVISOR_ICONPOINT_TOPBUTTONS;
		}
	}
	return ADVISOR_ICONPOINT_NORMAL;
}



BOOL __cdecl lego::front::Interface_FUN_0041e8c0(ObjectType objType,int objIndex)
{
	TutorialFlags TVar1;
	
	TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if ((TVar1 & TUTORIAL_UNK_4) != TUTORIAL_NONE) {
		return (&DAT_004ded34)[objIndex + objType * 0xf];
	}
	return TRUE;
}



void __cdecl
lego::front::Interface_SetUnkPositions1
					(uint x1_565,uint y1_18,uint x2_appWidthPlus10,uint y2_18,float param_5)
{
	Point2F_004dece0.x = (float)(ulonglong)x2_appWidthPlus10;
	Point2F_004dece0.y = (float)(ulonglong)y2_18;
	Point2F_004dece8.x = (float)(ulonglong)x1_565;
	Point2F_004dece8.y = (float)(ulonglong)y1_18;
	FLOAT_004decf0 = param_5 * 0.04;
	return;
}



void __cdecl
lego::front::Interface_UnkSlideOffScreen_FUN_0041e980_internal
					(InterfaceMenuType interfaceMenuType,Point2I *position)
{
	if (((FLAGS_004df1f8 & 0x80) == 0) || (InterfaceMenuType_004deccc != interfaceMenuType)) {
		FLAGS_004df1f8 = FLAGS_004df1f8 & 0xffffff7f | 0x100;
		snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_INTERFACESLIDEOFFSCREEN,FALSE);
	}
	else {
		InterfaceMenuType_004deccc = interfaceMenuType;
		if (position == NULL) {
			InterfaceMenuType_004decfc = interfaceMenuType;
			return;
		}
		Point2IBlockPos_004decc4.x = position->x;
		Point2IBlockPos_004decc4.y = position->y;
	}
	if (position != NULL) {
		Point2IBlockPos_004decf4.x = position->x;
		Point2IBlockPos_004decf4.y = position->y;
	}
	InterfaceMenuType_004decfc = interfaceMenuType;
	return;
}



void __cdecl lego::front::Interface_FUN_0041e9f0(float elapsedAbs)
{
	if ((FLAGS_004df1f8 & 0x80) == 0) {
		if ((FLAGS_004df1f8 & 0x100) == 0) {
			if ((FLAGS_004df1f8 & 4) != 0) {
				Point2F_004decd0.x = Point2F_004decd0.x - elapsedAbs * FLOAT_004decf0;
				if ((ushort)((ushort)(Point2F_004decd0.x < Point2F_004dece8.x) << 8 |
										(ushort)(Point2F_004decd0.x == Point2F_004dece8.x) << 0xe) != 0) {
					FLAGS_004df1f8 |= 0x80;
					Point2F_004decd0.x = Point2F_004dece8.x;
				}
			}
		}
		else {
			Point2F_004decd0.x = elapsedAbs * FLOAT_004decf0 + Point2F_004decd0.x;
			if ((InterfaceMenuType_004deccc == 0x16) &&
				 (((byte)globals::g_PanelDatas_TABLE[8].flags & 2) != 0)) {
				Panel_FUN_0045adc0(PANEL_PRIORITYLIST);
				Panel_FUN_0045aeb0(PANEL_TOPPANEL,1,0);
				Point2F_004decd0.x = Point2F_004dece0.x;
			}
			if (Point2F_004dece0.x <= Point2F_004decd0.x) {
				FLAGS_004df1f8 &= 0xfffffeff;
				Point2F_004decd0.x = Point2F_004dece0.x;
				snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_INTERFACESLIDEONSCREEN,0);
				if (InterfaceMenuType_004decfc == 0x16) {
					FLAGS_004df1f8 = FLAGS_004df1f8 & 0xfffffffb | 0x80;
					Panel_FUN_0045adc0(PANEL_PRIORITYLIST);
					unk::Lego_UnsetFlag6_00501860();
					FLAGS_00501860 |= 2;
				}
				else {
					if (InterfaceMenuType_004decfc == 0x17) {
						FLAGS_004df1f8 = FLAGS_004df1f8 & 0xfffffffb | 0x80;
						Panel_FUN_0045adc0(PANEL_ENCYCLOPEDIA);
						globs::gameGlobs.flags3 |= GAME3_UNK_1;
						Encyclopedia_UnsetFlag1_004c8ea8();
					}
					else {
						FLAGS_004df1f8 |= 4;
					}
				}
				Point2IBlockPos_004decc4.x = Point2IBlockPos_004decf4.x;
				Point2IBlockPos_004decc4.y = Point2IBlockPos_004decf4.y;
				InterfaceMenuType_004deccc = InterfaceMenuType_004decfc;
				return;
			}
		}
	}
	return;
}



void __cdecl lego::front::Interface_FUN_0041eb60(int param_1,int param_2,Point2F *param_3)
{
	ObjectType *pOVar1;
	int y;
	uint uVar2;
	int iVar3;
	longlong lVar4;
	char *msg;
	
	iVar3 = 0;
	if (globs::gameGlobs.objTeleportQueue_COUNT != 0) {
		pOVar1 = globs::gameGlobs.objTeleportQueueTypes_TABLE;
		uVar2 = globs::gameGlobs.objTeleportQueue_COUNT;
		do {
			if ((*pOVar1 == param_1) && (pOVar1[0x14] == param_2)) {
				iVar3 += 1;
			}
			pOVar1 = pOVar1 + 1;
			uVar2 -= 1;
		} while (uVar2 != 0);
	}
	if (iVar3 != 0) {
		msg = "%i";
		lVar4 = __ftol((float10)param_3->y);
		y = (int)lVar4 + 3;
		lVar4 = __ftol((float10)param_3->x);
		lego::image::Font_PrintF(PTRImageFont_004ddd58,(int)lVar4 + 3,y,msg,iVar3);
	}
	return;
}



void __cdecl lego::front::Interface_FUN_0041ebd0(float param_1,float param_2)
{
	BOOL BVar1;
	ImageBMP *image;
	int iVar2;
	uint uVar3;
	longlong lVar4;
	char *msg;
	char *pcVar5;
	int local_10;
	uint local_c;
	Point2F local_8;
	
	if ((UINT_004a3b5c != ObjectType_004decd8) || (DAT_004ddd50 != INTObjectIndex_004decdc)) {
		Interface_SetFloatTo25_004df1ec_AndUnsetFlags800_004df1f8();
		UINT_004a3b5c = ObjectType_004decd8;
		DAT_004ddd50 = INTObjectIndex_004decdc;
	}
	if (((FLAGS_004df1f8 & 0x800) != 0) &&
		 (game::Dependencies_Object_Getter_FUN_0040aec0
								(ObjectType_004decd8,INTObjectIndex_004decdc,0,&local_10,&local_c), local_c != 0)) {
		local_8.x = param_1 - 15.0;
		uVar3 = 0;
		local_8.y = param_2;
		if (local_c != 0) {
			do {
				if (uVar3 == 0) {
					if (globals::g_InterfaceDependencies_Minus_bmp == NULL) {
LAB_0041ecb4:
						local_8.x = local_8.x - 20.0;
					}
					else {
						local_8.x = local_8.x - (float)globals::g_InterfaceDependencies_Minus_bmp->width;
						lego::image::Image_DisplayScaled
											(globals::g_InterfaceDependencies_Minus_bmp,NULL,&local_8,NULL);
					}
				}
				else {
					if (globals::g_InterfaceDependencies_Plus_bmp == NULL) goto LAB_0041ecb4;
					local_8.x = local_8.x - (float)globals::g_InterfaceDependencies_Plus_bmp->width;
					lego::image::Image_DisplayScaled
										(globals::g_InterfaceDependencies_Plus_bmp,NULL,&local_8,NULL);
				}
				iVar2 = uVar3 * 0x10;
				BVar1 = game::Search_LiveObjects_SkipIgnoreMes
													(game::Dependencies_LiveObject_CallbackCheck_FUN_0040ae70,
													 (undefined4 *)(local_10 + iVar2));
				image = Interface_GetObjectBuildImage
													(*(ObjectType *)(local_10 + iVar2),*(int *)(local_10 + 4 + iVar2),
													 (uint)(BVar1 != 0));
				if (image == NULL) {
					local_8.x = local_8.x - 40.0;
				}
				else {
					local_8.x = local_8.x - (float)image->width;
					lego::image::Image_DisplayScaled(image,NULL,&local_8,NULL);
					if ((*(int *)(local_10 + 0xc + iVar2) != 0) &&
						 (iVar2 = *(int *)(local_10 + 8 + iVar2), iVar2 != 0)) {
						pcVar5 = globs::gameGlobs.UpgradeNames_TABLE[iVar2];
						msg = "%s";
						lVar4 = __ftol((float10)local_8.y);
						iVar2 = (int)lVar4 + 3;
						lVar4 = __ftol((float10)local_8.x);
						lego::image::Font_PrintF(PTRImageFont_004ddd58,(int)lVar4 + 3,iVar2,msg,pcVar5);
					}
				}
				uVar3 += 1;
			} while (uVar3 < local_c);
		}
	}
	return;
}



void __cdecl lego::front::Interface_SetFloatTo25_004df1ec_AndUnsetFlags800_004df1f8(void)
{
	FLOAT_004df1ec = 25.0;
	FLAGS_004df1f8 = FLAGS_004df1f8 & 0xfffff7ff;
	return;
}



BOOL __cdecl
lego::front::Interface_FUN_0041edb0
					(uint param_1,uint param_2,float param_3,float param_4,undefined4 *param_5,
					undefined4 *param_6,undefined4 *param_7)
{
	int iVar1;
	float fVar2;
	float fVar3;
	ImageBMP *pIVar4;
	uint uVar5;
	uint uVar6;
	uint local_40;
	int local_3c;
	float local_38;
	undefined4 uStack52;
	uint local_30;
	undefined4 uStack44;
	uint local_28;
	undefined4 uStack36;
	uint local_20;
	undefined4 uStack28;
	uint local_18;
	undefined4 uStack20;
	uint local_10;
	undefined4 uStack12;
	uint local_8;
	undefined4 uStack4;
	
	if (((FLAGS_004df1f8 & 0x800) != 0) &&
		 (game::Dependencies_Object_Getter_FUN_0040aec0
								(ObjectType_004decd8,INTObjectIndex_004decdc,0,&local_3c,&local_40), local_40 != 0))
	{
		local_38 = param_3 - 15.0;
		fVar3 = (float)(ulonglong)param_1;
		if ((local_38 <= fVar3) &&
			 ((((ushort)((ushort)(fVar3 < local_38 - -15.0) << 8 |
									(ushort)(fVar3 == local_38 - -15.0) << 0xe) != 0 &&
				 (fVar2 = (float)(ulonglong)param_2, param_4 <= fVar2)) &&
				((ushort)((ushort)(fVar2 < param_4 - -40.0) << 8 | (ushort)(fVar2 == param_4 - -40.0) << 0xe
								 ) != 0)))) {
			*param_5 = 0x14;
			return 1;
		}
		uStack52 = 0;
		uVar6 = 0;
		if (local_40 != 0) {
			do {
				pIVar4 = globals::g_InterfaceDependencies_Minus_bmp;
				if (uVar6 != 0) {
					pIVar4 = globals::g_InterfaceDependencies_Plus_bmp;
				}
				if (pIVar4 == NULL) {
					local_30 = 0x14;
					uVar5 = 0x28;
				}
				else {
					local_30 = pIVar4->width;
					uVar5 = pIVar4->height;
				}
				uStack44 = 0;
				local_38 = local_38 - (float)(ulonglong)local_30;
				if ((local_38 <= fVar3) &&
					 (fVar2 = local_38 + (float)(ulonglong)local_30,
					 (ushort)((ushort)(fVar3 < fVar2) << 8 | (ushort)(fVar3 == fVar2) << 0xe) != 0)) {
					local_28 = param_2;
					uStack36 = 0;
					fVar2 = (float)(ulonglong)param_2;
					if ((param_4 <= fVar2) &&
						 (uStack28 = 0, local_20 = uVar5,
						 (ushort)((ushort)(fVar2 < (float)(ulonglong)uVar5 + param_4) << 8 |
										 (ushort)(fVar2 == (float)(ulonglong)uVar5 + param_4) << 0xe) != 0)) {
						*param_5 = 0x14;
						return 1;
					}
				}
				pIVar4 = Interface_GetObjectBuildImage
													 (*(ObjectType *)(uVar6 * 0x10 + local_3c),
														*(int *)(uVar6 * 0x10 + 4 + local_3c),0);
				if (pIVar4 == NULL) {
					local_18 = 0x28;
					uVar5 = 0x28;
				}
				else {
					local_18 = pIVar4->width;
					uVar5 = pIVar4->height;
				}
				uStack20 = 0;
				local_38 = local_38 - (float)(ulonglong)local_18;
				if ((local_38 <= fVar3) &&
					 (fVar2 = local_38 + (float)(ulonglong)local_18,
					 (ushort)((ushort)(fVar3 < fVar2) << 8 | (ushort)(fVar3 == fVar2) << 0xe) != 0)) {
					local_10 = param_2;
					uStack12 = 0;
					fVar2 = (float)(ulonglong)param_2;
					if ((param_4 <= fVar2) &&
						 (uStack4 = 0, local_8 = uVar5,
						 (ushort)((ushort)(fVar2 < (float)(ulonglong)uVar5 + param_4) << 8 |
										 (ushort)(fVar2 == (float)(ulonglong)uVar5 + param_4) << 0xe) != 0)) {
						iVar1 = uVar6 * 0x10 + local_3c;
						*param_5 = *(undefined4 *)(uVar6 * 0x10 + local_3c);
						*param_6 = *(undefined4 *)(iVar1 + 4);
						*param_7 = *(undefined4 *)(iVar1 + 8);
						return 1;
					}
				}
				uVar6 += 1;
				if (local_40 <= uVar6) {
					return 0;
				}
			} while( true );
		}
	}
	return 0;
}



BOOL __cdecl
lego::front::Interface_Object_FindTeleporter_FUN_0041f030(ObjectType objType,int objIndex)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_14 = 0;
	local_10 = 0;
	local_18 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	OVar1 = game::Object_GetStatsFlags2(objType,objIndex);
	if ((OVar1 & STATS2_USESMALLTELEPORTER) == STATS2_NONE) {
		if ((OVar1 & STATS2_USEBIGTELEPORTER) == STATS2_NONE) {
			if ((OVar1 & STATS2_USEWATERTELEPORTER) == STATS2_NONE) {
				if ((OVar1 & STATS2_USELEGOMANTELEPORTER) == STATS2_NONE) {
					return 1;
				}
				local_10 = 0x80000000;
			}
			else {
				local_10 = 0x40;
			}
		}
		else {
			local_10 = 0x20;
		}
	}
	else {
		local_10 = 0x10;
	}
	BVar2 = game::Search_LiveObjects_SkipIgnoreMes
										(Interface_LiveObject_CallbackCheck_FUN_0041f0c0,&local_18);
	return BVar2;
}



BOOL __cdecl
lego::front::Interface_LiveObject_CallbackCheck_FUN_0041f0c0(LiveObject *liveObj,ObjectType *search)
{
	BOOL BVar1;
	ObjectStatsFlags1 OVar2;
	ObjectStatsFlags2 OVar3;
	
	if ((liveObj->objType == OBJECT_BUILDING) &&
		 (BVar1 = game::LiveObject_CheckCondition_FUN_00438870(liveObj,FALSE), BVar1 == 0)) {
		return 0;
	}
	if ((search[5] & 1) != 0) {
		if (liveObj->objType != *search) {
			return 0;
		}
		if (liveObj->objIndex != search[1]) {
			return 0;
		}
	}
	if (((search[5] & 2) != 0) && ((search[4] & liveObj->flags5_3f0) == LIVEOBJ5_NONE)) {
		return 0;
	}
	if ((search[2] != OBJECT_NONE) &&
		 (OVar2 = game::LiveObject_GetStatsFlags1(liveObj), (search[2] & OVar2) == STATS1_NONE)) {
		return 0;
	}
	if ((search[3] != OBJECT_NONE) &&
		 (OVar3 = game::LiveObject_GetStatsFlags2(liveObj), (search[3] & OVar3) == STATS2_NONE)) {
		return 0;
	}
	return TRUE;
}



BOOL __cdecl lego::front::Interface_FUN_0041f160(void)
{
	BOOL BVar1;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_14 = 0;
	local_10 = 0;
	local_18 = 0;
	local_8 = 0;
	local_c = 2;
	local_4 = 0;
	BVar1 = game::Search_LiveObjects_SkipIgnoreMes
										(Interface_LiveObject_CallbackCheck_FUN_0041f0c0,&local_18);
	return BVar1;
}



BOOL __cdecl lego::front::Interface_FUN_0041f1a0(undefined4 param_1)
{
	BOOL BVar1;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_14 = 0;
	local_10 = 0;
	local_8 = 0;
	local_18 = 0;
	local_4 = 0;
	local_c = param_1;
	BVar1 = game::Search_LiveObjects_SkipIgnoreMes
										(Interface_LiveObject_CallbackCheck_FUN_0041f0c0,&local_18);
	return BVar1;
}



BOOL __cdecl lego::front::Interface_FUN_0041f1e0(void)
{
	BOOL BVar1;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_14 = 0;
	local_c = 0;
	local_18 = 0;
	local_8 = 0;
	local_10 = 0x100000;
	local_4 = 0;
	BVar1 = game::Search_LiveObjects_SkipIgnoreMes
										(Interface_LiveObject_CallbackCheck_FUN_0041f0c0,&local_18);
	return BVar1;
}



BOOL __cdecl lego::front::Interface_FUN_0041f220(undefined4 param_1,undefined4 param_2)
{
	BOOL BVar1;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 1;
	local_18 = param_1;
	local_14 = param_2;
	BVar1 = game::Search_LiveObjects_SkipIgnoreMes
										(Interface_LiveObject_CallbackCheck_FUN_0041f0c0,&local_18);
	return BVar1;
}



BOOL __cdecl lego::front::Interface_FUN_0041f270(undefined4 param_1)
{
	BOOL BVar1;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_14 = 0;
	local_10 = 0;
	local_c = 0;
	local_4 = 2;
	local_18 = 0;
	local_8 = param_1;
	BVar1 = game::Search_LiveObjects_SkipIgnoreMes
										(Interface_LiveObject_CallbackCheck_FUN_0041f0c0,&local_18);
	return BVar1;
}



BOOL __cdecl
lego::front::Interface_LiveObject_Callback_FUN_0041f2c0(LiveObject *liveObj,Point2I *param_2)
{
	BOOL BVar1;
	
	BVar1 = game::LiveObject_Check_FUN_004326a0(liveObj,param_2->x,param_2->y,FALSE,FALSE);
	return (uint)(BVar1 != 0);
}



BOOL __cdecl lego::front::Interface_FUN_0041f2f0(undefined4 *param_1)
{
	BOOL BVar1;
	
	BVar1 = game::Search_LiveObjects_SkipIgnoreMes(Interface_LiveObject_Callback_FUN_0041f2c0,param_1)
	;
	return BVar1;
}



BOOL __cdecl
lego::front::Interface_LiveObject_CallbackCheckLevel_FUN_0041f310
					(LiveObject *liveObj,Point2I *position)
{
	BOOL BVar1;
	
	BVar1 = game::LiveObject_CheckLevel_FUN_00432950(liveObj,position->x,position->y);
	return (uint)(BVar1 != 0);
}



BOOL __cdecl lego::front::Interface_FUN_0041f330(undefined4 *param_1)
{
	BOOL BVar1;
	
	BVar1 = game::Search_LiveObjects_SkipIgnoreMes
										(Interface_LiveObject_CallbackCheckLevel_FUN_0041f310,param_1);
	return BVar1;
}



BOOL __cdecl lego::front::Interface_DoSelectedUnits_Callback(undefined *callback,int lpContext)
{
	uint uVar1;
	LiveObject **ppLVar2;
	int iVar3;
	uint uVar4;
	
	uVar1 = game::Message_GetNumSelectedUnits();
	ppLVar2 = game::Message_GetSelectedUnits();
	uVar4 = 0;
	if (uVar1 == 0) {
		return 0;
	}
	do {
		iVar3 = (*(code *)callback)(*ppLVar2,lpContext);
		if (iVar3 != 0) {
			return 1;
		}
		uVar4 += 1;
		ppLVar2 = ppLVar2 + 1;
	} while (uVar4 < uVar1);
	return 0;
}



BOOL __cdecl lego::front::Interface_LiveObject_FUN_0041f3a0(LiveObject *liveObj)
{
	if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
		 ((liveObj->flags1 & LIVEOBJ1_UNK_2000) == LIVEOBJ1_NONE)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::front::Interface_LiveObject_IsEnergyLessThan100(LiveObject *liveObj)
{
	if (liveObj->energy < 100.0) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::front::Interface_LiveObject_IsHealthLessThan100(LiveObject *liveObj)
{
	if (liveObj->health < 100.0) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::front::Interface_FUN_0041f400(LiveObject *liveObj)
{
	ObjectStatsFlags3 OVar1;
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	int *out_bx;
	int *out_by;
	int local_14;
	int local_10;
	Vector3F local_c;
	
	OVar1 = game::LiveObject_GetStatsFlags3(liveObj);
	if ((OVar1 & STATS3_CARRYVEHICLES) == STATS3_NONE) {
		if (liveObj->objType == OBJECT_MINIFIGURE) {
			if ((((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) &&
					((liveObj->flags3 & LIVEOBJ3_UNK_20) != LIVEOBJ3_NONE)) &&
				 ((liveObj->flags3 & LIVEOBJ3_UNK_40) != LIVEOBJ3_NONE)) {
				return 1;
			}
		}
		else {
			if (((liveObj->flags3 & LIVEOBJ3_UNK_20) != LIVEOBJ3_NONE) &&
				 ((liveObj->flags3 & LIVEOBJ3_UNK_40) != LIVEOBJ3_NONE)) {
				uVar5 = liveObj->field_328;
				uVar4 = game::LiveObject_GetMaxCarry(liveObj);
				if (uVar4 <= uVar5) {
					uVar5 = game::LiveObject_GetMaxCarry(liveObj);
				}
				if (liveObj->numCarriedObjects < uVar5) {
					return 1;
				}
			}
		}
	}
	else {
		if ((((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) &&
				((liveObj->flags4 & LIVEOBJ4_UNK_10000) == LIVEOBJ4_NONE)) &&
			 (cont = game::LiveObject_GetDepositNull(liveObj), cont != NULL)) {
			res::Container_GetPosition(cont,NULL,&local_c);
			out_by = &local_10;
			out_bx = &local_14;
			surfMap = game::GetSurfaceMap();
			BVar2 = game::Map3D_WorldToBlockPos_NoZ(surfMap,local_c.x,local_c.y,out_bx,out_by);
			if ((BVar2 != 0) &&
				 (iVar3 = game::LiveObject_FUN_00431cd0(NULL,local_14,local_10,local_14,local_10,1),
				 iVar3 != 0)) {
				return 1;
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::front::Interface_LiveObject_Callback_FUN_0041f520(LiveObject *liveObj)
{
	liveObj->health = -1.0;
	liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_8;
	return 0;
}



BOOL __cdecl lego::front::Interface_LiveObject_GoEatIfEnergyIsLessThan100(LiveObject *liveObj)
{
	if (liveObj->energy < 100.0) {
		game::LiveObject_GoEat_unk(liveObj);
	}
	return 0;
}



BOOL __cdecl lego::front::Interface_LiveObject_GoRepairIfHealthLessThan100(LiveObject *liveObj)
{
	if (liveObj->health < 100.0) {
		ai::AITask_DoRepair_Target(liveObj,0);
	}
	return 0;
}



BOOL __cdecl
lego::front::Interface_LiveObject_DoesNotHaveToolEquipped(LiveObject *liveObj,ToolType toolType)
{
	BOOL BVar1;
	
	BVar1 = game::LiveObject_HasToolEquipped(liveObj,toolType);
	return (uint)(BVar1 == 0);
}



BOOL __cdecl
lego::front::Interface_LiveObject_GoGetToolIfNotEquipped(LiveObject *liveObj,ToolType toolType)
{
	BOOL BVar1;
	
	BVar1 = game::LiveObject_HasToolEquipped(liveObj,toolType);
	if (BVar1 == 0) {
		ai::AITask_DoGetTool(toolType);
	}
	return 0;
}



BOOL __cdecl lego::front::Interface_LiveObject_Callback_FUN_0041f5f0(LiveObject *liveObj)
{
	ObjectStatsFlags3 OVar1;
	
	OVar1 = game::LiveObject_GetStatsFlags3(liveObj);
	if ((OVar1 & STATS3_CARRYVEHICLES) == STATS3_NONE) {
		if (((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) ||
			 (liveObj->carriedObjects[0]->objType != OBJECT_BARRIER)) {
			game::LiveObject_FUN_0043a130(liveObj,0);
		}
	}
	else {
		if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
			 (liveObj->carriedObjects[0] != NULL)) {
			game::LiveObject_FUN_0043fee0(liveObj->carriedObjects[0]);
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl lego::front::Interface_FUN_0041f650(uint param_1)
{
	LiveObject *pLVar1;
	
	pLVar1 = game::Message_GetPrimarySelectedUnit();
	return (uint)((pLVar1->flags5_3f0 & param_1) != LIVEOBJ5_NONE);
}



BOOL __cdecl lego::front::Interface_Block_FUN_0041f670(Point2I *blockPos)
{
	BOOL BVar1;
	uint uVar2;
	int iVar3;
	int *piVar4;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_20[4] = 0xffffffff;
	local_4 = 0xffffffff;
	uVar2 = 0;
	local_20[0] = 1;
	local_20[1] = 0;
	local_20[2] = 0;
	local_20[3] = 1;
	local_c = 0;
	local_8 = 0;
	BVar1 = game::Level_Block_IsFlags1_c0(blockPos->x,blockPos->y);
	if (BVar1 == 0) {
		piVar4 = local_20;
		do {
			BVar1 = game::Level_BlockIsFlags1_400_AndOptIsFlags2_4
												(blockPos->x + *piVar4,piVar4[1] + blockPos->y,1);
			if (BVar1 != 0) {
				return 0;
			}
			uVar2 += 1;
			piVar4 = piVar4 + 2;
		} while (uVar2 < 4);
		return 1;
	}
	uVar2 = 0;
	piVar4 = local_20;
	iVar3 = 4;
	do {
		BVar1 = game::Level_BlockIsFlags1_400_AndOptIsFlags2_4
											(blockPos->x + *piVar4,piVar4[1] + blockPos->y,1);
		if (BVar1 != 0) {
			uVar2 += 1;
		}
		piVar4 = piVar4 + 2;
		iVar3 += -1;
	} while (iVar3 != 0);
	if (1 < uVar2) {
		return 0;
	}
	return 1;
}



BOOL __cdecl
lego::front::Interface_LiveObject_HasToolEquipped_2(LiveObject *liveObj,ToolType toolType)
{
	BOOL BVar1;
	
	BVar1 = game::LiveObject_HasToolEquipped(liveObj,toolType);
	return (uint)(BVar1 != 0);
}



BOOL __cdecl lego::front::Interface_LiveObject_FUN_0041f770(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = game::LiveObject_HasToolEquipped(liveObj,TOOL_BIRDSCARER);
	if (BVar1 != 0) {
		game::LiveObject_00448c60(liveObj);
	}
	return 0;
}



void __cdecl lego::game::Level_IncrementCrystals(void)
{
	if (globs::gameGlobs.level != NULL) {
		(globs::gameGlobs.level)->numCrystals = (globs::gameGlobs.level)->numCrystals + 1;
	}
	return;
}



void __cdecl lego::game::Level_SubtractCrystals(int crystalCount)
{
	if (globs::gameGlobs.level != NULL) {
		(globs::gameGlobs.level)->numCrystals = (globs::gameGlobs.level)->numCrystals - crystalCount;
	}
	return;
}



void __cdecl lego::game::Level_AddDrainedCrystals(int drainedCrystalCount)
{
	if (globs::gameGlobs.level != NULL) {
		(globs::gameGlobs.level)->numDrainedCrystals =
				 (globs::gameGlobs.level)->numDrainedCrystals + drainedCrystalCount;
	}
	return;
}



int __cdecl lego::game::Level_GetCrystalCount(BOOL includeDrained)
{
	int in_EAX;
	
	if ((globs::gameGlobs.level != NULL) &&
		 (in_EAX = (globs::gameGlobs.level)->numCrystals, includeDrained == 0)) {
		in_EAX -= (globs::gameGlobs.level)->numDrainedCrystals;
	}
	return in_EAX;
}



int __cdecl lego::game::Level_GetOreCount(BOOL isProcessed)
{
	LevelData *pLVar1;
	
	pLVar1 = globs::gameGlobs.level;
	if (globs::gameGlobs.level != NULL) {
		if (isProcessed != 0) {
			return (int)(LevelData *)(globs::gameGlobs.level)->numProcessedOre;
		}
		pLVar1 = (LevelData *)(globs::gameGlobs.level)->numOre;
	}
	return (int)pLVar1;
}



void __cdecl lego::game::Level_AddToField9c(int value)
{
	if (globs::gameGlobs.level != NULL) {
		(globs::gameGlobs.level)->field_9c = (globs::gameGlobs.level)->field_9c + value;
	}
	return;
}



void __cdecl lego::game::Game_SetFlag1_20000_unkCamera(BOOL state)
{
	if (state != 0) {
		globs::gameGlobs.flags1 = globs::gameGlobs.flags1 | GAME1_UNK_20000;
		return;
	}
	globs::gameGlobs.flags1 = globs::gameGlobs.flags1 & ~GAME1_UNK_20000;
	return;
}



BOOL __cdecl lego::game::Game_IsNoclipOn(void)
{
	return globs::gameGlobs.flags1 & GAME1_DEBUG_NOCLIP_FPS;
}



void __cdecl lego::game::Level_IncField94(void)
{
	if (globs::gameGlobs.level != NULL) {
		(globs::gameGlobs.level)->field_94 = (globs::gameGlobs.level)->field_94 + 1;
	}
	return;
}



void __cdecl lego::game::Level_IncFieldA8(void)
{
	if (globs::gameGlobs.level != NULL) {
		(globs::gameGlobs.level)->field_a8 = (globs::gameGlobs.level)->field_a8 + 1;
	}
	return;
}



void __cdecl lego::game::Level_IncOre(OreType isProcessed)
{
	if (globs::gameGlobs.level != NULL) {
		if (isProcessed == ORE_NORMAL) {
			(globs::gameGlobs.level)->numOre = (globs::gameGlobs.level)->numOre + 1;
		}
		else {
			(globs::gameGlobs.level)->numProcessedOre = (globs::gameGlobs.level)->numProcessedOre + 1;
		}
	}
	if (isProcessed != ORE_NORMAL) {
		FUN_0045c840(1,5);
		return;
	}
	FUN_0045c840(1,1);
	return;
}



void __cdecl lego::game::Level_SubtractOre(BOOL isProcessed,int oreCount)
{
	if (globs::gameGlobs.level != NULL) {
		if (isProcessed == 0) {
			(globs::gameGlobs.level)->numOre = (globs::gameGlobs.level)->numOre - oreCount;
		}
		else {
			(globs::gameGlobs.level)->numProcessedOre =
					 (globs::gameGlobs.level)->numProcessedOre - oreCount;
		}
	}
	if (isProcessed != 0) {
		FUN_0045c840(0,5);
		return;
	}
	FUN_0045c840(0,oreCount);
	return;
}



BOOL __cdecl lego::main::LRR_Go(char *programName)
{
	BOOL BVar1;
	int iVar2;
	Lego_Globs *pLVar3;
	Main_State mainState;
	
										// std::memset(&legoGlobs, 0, sizeof(legoGlobs)); // 0xef8
	pLVar3 = &globs::gameGlobs;
	for (iVar2 = 0x3be; iVar2 != 0; iVar2 += -1) {
		pLVar3->LegoCfgRoot = NULL;
		pLVar3 = (Lego_Globs *)&pLVar3->CfgRootName;
	}
	globs::gameGlobs.CfgRootName = programName;
	Main_SetTitle(programName);
	mainState.Initialise = LRR_Initialise;
	mainState.MainLoop = LRR_MainLoop;
	mainState.Shutdown = LRR_Shutdown;
	if (globs::mainGlobs.programmerLevel != PROGRAMMER_MODE_10) {
		mainState.Shutdown = LRR_Exit;
	}
	BVar1 = Main_SetState(&mainState);
	return BVar1;
}



void __cdecl lego::game::LRR_SetLoadFlag_Unk(void)
{
	GetLevel();
	if ((globs::gameGlobs.flags1 & GAME1_UNK_8000000) == GAME1_NONE) {
		UINT_00556118 = nerps::NERPs_Game_GetPilotPreviousLevel("Pilot",0);
		globs::gameGlobs.flags1 |= GAME1_UNK_8000000;
		Game_DisableCryOreDrop(TRUE);
		LiveManager_SetFlag20(TRUE);
		unk::Teleporter_Start(TELEPORT_SERVIVE_VEHICLE,1,1);
		unk::Teleporter_Start(TELEPORT_SERVIVE_MINIFIGURE,1,1);
		unk::Teleporter_Start(TELEPORT_SERVIVE_BUILDING,1,1);
		unk::Teleporter_Start(TELEPORT_SERVIVE_ELECTRICFENCE,1,1);
		Game_SetPaused(FALSE,FALSE);
		front::Interface_BackToMain();
		if (((byte)globals::g_PanelDatas_TABLE[0].flags & 2) != 0) {
			front::Panel_FUN_0045adc0(PANEL_RADAR);
			front::Panel_FUN_0045adc0(PANEL_RADARFILL);
		}
	}
	return;
}



float10 __cdecl lego::game::Game_GetGameSpeed(void)
{
	return (float10)globs::gameGlobs.gameSpeed;
}


/*
Unable to decompile 'LRR_Initialise'
Cause: Exception while decompiling 0041fa80: process: timeout

*/


BOOL __cdecl lego::main::LRR_Initialise(void)
{
	CFGProperty *prop;
	char *pcVar1;
	BOOL BVar2;
	uint uVar3;
	uint uVar4;
	char *pcVar5;
	ProgrammerMode PVar6;
	char *pcVar7;
	byte *input;
	BOOL3 BVar8;
	int iVar9;
	CFGProperty *prop_00;
	float10 fVar10;
	float10 fVar11;
	float10 fVar12;
	float10 fVar13;
	int iVar14;
	float *out_r;
	float red;
	ColourRGBF *pCVar15;
	float *pfVar16;
	float green;
	float *pfVar17;
	float blue;
	char *MinEnergyForEat_str;
	char *HighPolyRange_str;
	char *MedPolyRange_str;
	char *ReinforceHits_str;
	char *DrainTime_str;
	char *MiniFigureRunAway_str;
	char *HPBlocks_str;
	char *CDTracks_str;
	char *CDStartTrack_str;
	char *BirdScarerRadius_str;
	char *DynamiteWakeRadius_str;
	char *DynamiteMaxDamage_str;
	char *DynamiteDamageRadius_str;
	char *tvclipdist_str;
	char *maxdist_str;
	char *mindist_str;
	char *MouseScrollBorder_str;
	char *MaxReturnedCrystals_str;
	char *RollOffFor3DSounds_str;
	char *MaxDistFor3DSounds_str;
	char *MinDistFor3DSoundsOnTopView_str;
	char *MouseScrollIndent_str;
	char *CameraAcceleration_str;
	char *CameraDropOff_str;
	char *CameraSpeed_str;
	char *LoaderProfile_filename;
	char *TextPauseTime_str;
	char *TextureUsage_str;
	char *BuildingUpgradeCostStuds_str;
	char *BuildingUpgradeCostOre_str;
	char *startLevelName;
	Point2F Dialog_center;
	char *Window_stringParts [4];
	int Window_numParts;
	Rect2F Window_rect;
	CFGProperty *Pointers_cfgProp;
	float CameraDropOff;
	float CameraSpeed;
	float MaxDistFor3DSounds;
	float RollOffFor3DSounds;
	int MouseScrollIndent;
	float CameraAcceleration;
	float MinDistFor3DSoundsOnTopView;
	char *Button_lpstr;
	char *Button_stringParts [10];
	char Button_buffer [128];
	char *Button_filename;
	char *SharedSizes_str;
	char *LoadScreen;
	char *ProgressBar;
	char *ProgressWindow;
	char *LoadingText;
	char *ShutdownScreen;
	Direction ProgressBar_direction;
	Rect2F ProgressWindow_rect;
	char *ProgressWindow_stringParts [10];
	char *StartMessage;
	char *Version;
	Rect2F MsgPanel_rect1;
	Rect2F MsgPanel_rect2;
	float local_5c;
	Rect2F fontRender84_rect;
	Rect2F fontRender80_rect;
	uint TextureUsage;
	uint videoMemFree;
	uint videoMemTotal;
	char *RenameReplace_ptr;
	float ToolTipRGB_g;
	float ToolTipRGB_r;
	float ToolTipRGB_b;
	float maxdist;
	float mindist;
	CFGProperty *legoCfgRoot;
	uint surfaceIdx_unused;
	float maxtilt;
	float mintilt;
	
	globs::gameGlobs.DragBoxRGB.red = 0.2;
	globs::gameGlobs.DragBoxRGB.green = 0.7;
	globs::gameGlobs.DragBoxRGB.blue = 1.0;
	globs::gameGlobs.SurfaceTypes_TABLE[0] = "Lego_SurfaceType_Tunnel";
	globs::gameGlobs.SurfaceTypes_TABLE[1] = "Lego_SurfaceType_Immovable";
	globs::gameGlobs.SurfaceTypes_TABLE[2] = "Lego_SurfaceType_Hard";
	globs::gameGlobs.SurfaceTypes_TABLE[3] = "Lego_SurfaceType_Medium";
	globs::gameGlobs.SurfaceTypes_TABLE[4] = "Lego_SurfaceType_Loose";
	globs::gameGlobs.SurfaceTypes_TABLE[5] = "Lego_SurfaceType_Soil";
	globs::gameGlobs.SurfaceTypes_TABLE[6] = "Lego_SurfaceType_Lava";
	globs::gameGlobs.SurfaceTypes_TABLE[7] = "Lego_SurfaceType_Water";
	globs::gameGlobs.SurfaceTypes_TABLE[8] = "Lego_SurfaceType_OreSeam";
	globs::gameGlobs.SurfaceTypes_TABLE[9] = "Lego_SurfaceType_Lake";
	globs::gameGlobs.SurfaceTypes_TABLE[10] = "Lego_SurfaceType_CrystalSeam";
	globs::gameGlobs.SurfaceTypes_TABLE[11] = "Lego_SurfaceType_RechargeSeam";
	globs::gameGlobs.SurfaceTypes_TABLE[12] = "Lego_SurfaceType_Rubble";
	globs::gameGlobs.SurfaceTypes_TABLE[13] = "Lego_SurfaceType_Reinforcement";
	globs::gameGlobs.SurfaceTypes_TABLE[14] = "Lego_SurfaceType_Path";
	globs::gameGlobs.SurfaceTypes_TABLE[15] = "Lego_SurfaceType_SlugHole";
	globs::gameGlobs.SurfaceTypes_TABLE[16] = "Lego_SurfaceType_Undiscovered";
	globs::gameGlobs.SurfaceTypes_TABLE[17] = "Lego_SurfaceType_Cavern";
	for (surfaceIdx_unused = 0; surfaceIdx_unused < 0x12; surfaceIdx_unused += 1) {
	}
	game::Game_SetGameSpeed(1.0);
	lego::input::Keys_Initialise();
	lego::view::Viewport_Initialise();
	pool::ReservedPool<LiveObject>__Init();
	lego::image::Image_Initialise();
										/* No argument actually passed, just problem with variadic functions not
											 allowing zero args */
	util::logf_removed();
	game::LevelStruct3C_InitUnkVectorTables();
	front::Panel_InitPanelButtons();
	ai::AITask_Initialise();
	game::Message_Initialise();
	effect::Smoke_Initialise();
	lego::front::Pointer_Initialise();
	front::Bubble_Initialise();
	globs::gameGlobs.bmpFONT5_HI = lego::image::Font_Load("Interface\\Fonts\\FONT5_HI.bmp");
	globs::gameGlobs.bmpToolTipFont = lego::image::Font_Load("Interface\\Fonts\\ToolTipFont.bmp");
	globs::gameGlobs.bmpDeskTopFont = lego::image::Font_Load("Interface\\Fonts\\DeskTopFont.bmp");
	globs::gameGlobs.bmpfont5_HI = lego::image::Font_Load("Interface\\Fonts\\font5_HI.bmp");
	globs::gameGlobs.bmpMbriefFONT = lego::image::Font_Load("Interface\\Fonts\\MBriefFONT.bmp");
	globs::gameGlobs.bmpMbriefFONT2 = lego::image::Font_Load("Interface\\Fonts\\MBriefFONT2.bmp");
	globs::gameGlobs.bmpRSFont = lego::image::Font_Load("Interface\\Fonts\\RSFont.bmp");
	front::Info_InitInfo(globs::gameGlobs.bmpFONT5_HI);
	front::Interface_Initialise(565,18,globs::gameGlobs.bmpToolTipFont);
	globs::gameGlobs.resRoot = res::Container_Initialise(globs::gameGlobs.CfgRootName);
	if (globs::gameGlobs.resRoot == NULL) {
		return 0;
	}
	res::Container_SetTriggerFrameCallback(game::Game_Container_TriggerFrameCallback,NULL);
	prop = cfg::CFG_Open("Lego.cfg");
	globs::gameGlobs.LegoCfgRoot = prop;
	if (prop == NULL) goto LAB_0042274b;
	pfVar17 = &ToolTipRGB_b;
	pfVar16 = &ToolTipRGB_g;
	out_r = &ToolTipRGB_r;
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","ToolTipRGB",0);
	BVar2 = cfg::CFG_ReadRGBF(prop,pcVar1,out_r,pfVar16,pfVar17);
	if (BVar2 == 0) {
		ToolTipRGB_b = 0.3254902;
		ToolTipRGB_g = 0.3254902;
		ToolTipRGB_r = 0.3254902;
	}
	iVar14 = 32;
	red = ToolTipRGB_r;
	green = ToolTipRGB_g;
	blue = ToolTipRGB_b;
	uVar3 = appHeight();
	uVar4 = appWidth();
	front::ToolTip_Initialise
						(globs::gameGlobs.bmpToolTipFont,2,1,1.0,uVar4,uVar3,iVar14,red,green,blue);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","CreditsTextFile",0);
	globs::gameGlobs.CreditsTextFile = cfg::CFG_CopyString(prop,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","CreditsBackAVI",0);
	globs::gameGlobs.CreditsBackAVI = cfg::CFG_CopyString(prop,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","BuildingUpgradeCostOre",0);
	pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
	if (pcVar1 == NULL) {
		BuildingUpgradeCostOre_str = ""/*EMPTYSTR*/;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","BuildingUpgradeCostOre",0);
		BuildingUpgradeCostOre_str = cfg::CFG_ReadString(prop,pcVar1);
	}
	globs::gameGlobs.BuildingUpgradeCostOre = std::atoi(BuildingUpgradeCostOre_str);
	if (globs::gameGlobs.BuildingUpgradeCostOre == 0) {
		globs::gameGlobs.BuildingUpgradeCostOre = 5;
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","BuildingUpgradeCostStuds",0);
	pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
	if (pcVar1 == NULL) {
		BuildingUpgradeCostStuds_str = ""/*EMPTYSTR*/;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","BuildingUpgradeCostStuds",0);
		BuildingUpgradeCostStuds_str = cfg::CFG_ReadString(prop,pcVar1);
	}
	globs::gameGlobs.BuildingUpgradeCostStuds = std::atoi(BuildingUpgradeCostStuds_str);
	if (globs::gameGlobs.BuildingUpgradeCostStuds == 0) {
		globs::gameGlobs.BuildingUpgradeCostStuds = 1;
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","RenameReplace",0);
	globs::gameGlobs.RenameReplace = cfg::CFG_CopyString(prop,pcVar1);
	RenameReplace_ptr = globs::gameGlobs.RenameReplace;
	if (globs::gameGlobs.RenameReplace != NULL) {
		for (; *RenameReplace_ptr != '\0'; RenameReplace_ptr = RenameReplace_ptr + 1) {
			if (*RenameReplace_ptr == '_') {
				*RenameReplace_ptr = ' ';
			}
		}
	}
	BVar2 = ddraw::DirectDraw_GetAvailTextureMem(&videoMemTotal,&videoMemFree);
	if (BVar2 != 0) {
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","TextureUsage",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			TextureUsage_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","TextureUsage",0);
			TextureUsage_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		TextureUsage = std::atoi(TextureUsage_str);
		if ((TextureUsage != 0) &&
			 (ddraw::DirectDraw_AdjustTextureUsage(&TextureUsage), TextureUsage <= videoMemFree)) {
			Main_DisableTextureManagement();
		}
	}
	fontRender80_rect.x = 55.0;
	fontRender80_rect.y = 435.0;
	fontRender80_rect.width = 325.0;
	fontRender80_rect.height = 42.0;
	globs::gameGlobs.textWnd_80 =
			 front::TextWindow_Create(globs::gameGlobs.bmpfont5_HI,&fontRender80_rect,0x400);
	fontRender84_rect.x = 55.0;
	fontRender84_rect.y = 435.0;
	fontRender84_rect.width = 260.0;
	fontRender84_rect.height = 42.0;
	globs::gameGlobs.textWnd_84 =
			 front::TextWindow_Create(globs::gameGlobs.bmpfont5_HI,&fontRender84_rect,0x400);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","TextPauseTime",0);
	pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
	if (pcVar1 == NULL) {
		TextPauseTime_str = ""/*EMPTYSTR*/;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","TextPauseTime",0);
		TextPauseTime_str = cfg::CFG_ReadString(prop,pcVar1);
	}
	fVar10 = std::atof(TextPauseTime_str);
	front::Text_Load(globs::gameGlobs.textWnd_80,globs::gameGlobs.textWnd_84,316,425,
									 (float)(fVar10 * (float10)25.0));
	MsgPanel_rect1.x = 55.0;
	MsgPanel_rect1.y = 435.0;
	MsgPanel_rect1.width = 325.0;
	MsgPanel_rect1.height = 42.0;
	MsgPanel_rect2.x = 55.0;
	MsgPanel_rect2.y = 363.0;
	MsgPanel_rect2.width = 325.0;
	MsgPanel_rect2.height = 140.0;
	front::Text_MsgPanel_Initialise
						("Interface\\MessagePanel\\MsgPanel.bmp",0x2a,409,338,&MsgPanel_rect1,&MsgPanel_rect2,
						 20.0);
	if ((globs::mainGlobs.flags & CMD_SHOWVERSION) != CMD_NONE) {
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","StartMessage",0);
		pcVar1 = cfg::CFG_CopyString(prop,pcVar1);
		pcVar5 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","Version",0);
		pcVar5 = cfg::CFG_ReadString(prop,pcVar5);
		if (pcVar1 != NULL) {
			pcVar1 = util::stringReplaceChar(pcVar1,'_',' ');
			if (pcVar5 == NULL) {
				front::TextWindow_PrintF(globs::gameGlobs.textWnd_80,"\n%s",pcVar1);
			}
			else {
				front::TextWindow_PrintF(globs::gameGlobs.textWnd_80,"\n%s (%s)",pcVar1,pcVar5);
			}
			util::free2(pcVar1);
		}
	}
	BVar2 = Config_IsFrontEndEnabled();
	if ((BVar2 != 0) && (BVar2 = Config_IsIntrosEnabled(), BVar2 != 0)) {
		PVar6 = Main_ProgrammerMode();
		Boot_PlayIntroAVI("LegoAvi",(uint)(PVar6 != PROGRAMMER_OFF));
		Boot_PlayIntroImage("DDILogo",TRUE,"DDILogoTime");
		Boot_PlayIntroAVI("DDIAvi",TRUE);
		Boot_PlayIntroAVI("RRAvi",TRUE);
		pcVar1 = "LMILogoTime";
		PVar6 = Main_ProgrammerMode();
		Boot_PlayIntroImage("LMILogo",(uint)(PVar6 != PROGRAMMER_OFF),pcVar1);
	}
	snd::SFX_InitHashNames();
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","ProgressBar",0);
	ProgressBar = cfg::CFG_ReadString(prop,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","LoadScreen",0);
	pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
	pcVar5 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","ShutdownScreen",0);
	pcVar5 = cfg::CFG_ReadString(prop,pcVar5);
	pcVar7 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","ProgressWindow",0);
	input = (byte *)cfg::CFG_CopyString(prop,pcVar7);
	pcVar7 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","LoadingText",0);
	pcVar7 = cfg::CFG_ReadString(prop,pcVar7);
	if (input == NULL) {
		ProgressBar = NULL;
	}
	else {
		iVar14 = std::toupper((uint)*input);
		*input = (byte)iVar14;
		if (false) {
LAB_004203f0:
			ProgressBar_direction = DIRECTION__COUNT;
		}
		else {
			switch(*input) {
			case 0x44:
				ProgressBar_direction = DIRECTION_DOWN;
				break;
			default:
				goto LAB_004203f0;
			case 0x4c:
				ProgressBar_direction = DIRECTION_LEFT;
				break;
			case 0x52:
				ProgressBar_direction = DIRECTION_RIGHT;
				break;
			case 0x55:
				ProgressBar_direction = DIRECTION_UP;
			}
		}
		iVar14 = util::Util_Tokenise((char *)input,ProgressWindow_stringParts,",");
		if (((iVar14 == 4) && (input[1] == 0x3a)) && (ProgressBar_direction != DIRECTION__COUNT)) {
			iVar14 = std::atoi(ProgressWindow_stringParts[0] + 2);
			ProgressWindow_rect.x = (float)iVar14;
			iVar14 = std::atoi(ProgressWindow_stringParts[1]);
			ProgressWindow_rect.y = (float)iVar14;
			iVar14 = std::atoi(ProgressWindow_stringParts[2]);
			ProgressWindow_rect.width = (float)iVar14;
			iVar14 = std::atoi(ProgressWindow_stringParts[3]);
			ProgressWindow_rect.height = (float)iVar14;
		}
	}
	util::free2(input);
	BVar2 = snd::Sound_IsInitialised();
	if (BVar2 == 0) {
		LoaderProfile_filename = "LoaderProfileNoSound.txt";
	}
	else {
		LoaderProfile_filename = "LoaderProfile.txt";
	}
	front::Loader_Initialise
						(pcVar1,pcVar5,globs::gameGlobs.bmpFONT5_HI,LoaderProfile_filename,ProgressBar_direction
						 ,ProgressBar,&ProgressWindow_rect,pcVar7);
	front::Loader_display_loading_bar("Game Data");
	globs::gameGlobs.cameraMain =
			 lego::view::Camera_Create(globs::gameGlobs.resRoot,CAMERATYPE_TOPDOWN);
	if (((globs::gameGlobs.cameraMain == NULL) ||
			(globs::gameGlobs.cameraFP =
						lego::view::Camera_Create(globs::gameGlobs.resRoot,CAMERATYPE_FIRSTPERSON),
			globs::gameGlobs.cameraFP == NULL)) ||
		 ((globs::gameGlobs.cameraRadar =
						lego::view::Camera_Create(globs::gameGlobs.resRoot,CAMERATYPE_RADAR),
			globs::gameGlobs.cameraRadar == NULL ||
			((globs::gameGlobs.viewMain =
						 lego::view::Viewport_Create(0.0,0.0,1.0,1.0,(globs::gameGlobs.cameraMain)->resData1),
			 globs::gameGlobs.viewMain == NULL ||
			 (globs::gameGlobs.viewRadar =
						 lego::view::Viewport_CreatePixel
											 (0x10,0xd,0x97,0x97,(globs::gameGlobs.cameraRadar)->resData1),
			 globs::gameGlobs.viewRadar == NULL)))))) goto LAB_0042274b;
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","StreamNERPSSpeach",0);
	BVar8 = cfg::CFG_ReadBool(prop,pcVar1);
	if (BVar8 == BOOL3_TRUE) {
		globs::gameGlobs.flags1 |= GAME1_STREAMNERPSSPEACH;
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","ShowDebugToolTips",0);
	BVar8 = cfg::CFG_ReadBool(prop,pcVar1);
	if ((BVar8 == BOOL3_TRUE) || (PVar6 = Main_ProgrammerMode(), PVar6 != PROGRAMMER_OFF)) {
		globs::gameGlobs.flags2 |= GAME2_SHOWDEBUGTOOLTIPS;
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","AllowDebugKeys",0);
	BVar8 = cfg::CFG_ReadBool(prop,pcVar1);
	if ((BVar8 == BOOL3_TRUE) || (PVar6 = Main_ProgrammerMode(), PVar6 != PROGRAMMER_OFF)) {
		globs::gameGlobs.flags2 |= GAME2_ALLOWDEBUGKEYS;
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","AllowEditMode",0);
	BVar8 = cfg::CFG_ReadBool(prop,pcVar1);
	if ((BVar8 == BOOL3_TRUE) || (PVar6 = Main_ProgrammerMode(), PVar6 != PROGRAMMER_OFF)) {
		globs::gameGlobs.flags2 |= GAME2_ALLOWEDITMODE;
	}
	pfVar16 = &globs::gameGlobs.PowerCrystalRGB.blue;
	pfVar17 = &globs::gameGlobs.PowerCrystalRGB.green;
	pCVar15 = &globs::gameGlobs.PowerCrystalRGB;
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","PowerCrystalRGB",0);
	cfg::CFG_ReadRGBF(prop,pcVar1,(float *)pCVar15,pfVar17,pfVar16);
	pfVar16 = &globs::gameGlobs.UnpoweredCrystalRGB.blue;
	pfVar17 = &globs::gameGlobs.UnpoweredCrystalRGB.green;
	pCVar15 = &globs::gameGlobs.UnpoweredCrystalRGB;
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","UnpoweredCrystalRGB",0);
	cfg::CFG_ReadRGBF(prop,pcVar1,(float *)pCVar15,pfVar17,pfVar16);
	snd::Sample_LoadAllProperties
						(prop,(uint)((globs::mainGlobs.flags & CMD_REDUCESAMPLES) == CMD_NONE));
	Main_LoadSurfaceTypeDescriptions_sound(prop,globs::gameGlobs.CfgRootName);
	front::PriorityList_LoadImagePositions(prop,globs::gameGlobs.CfgRootName);
	Main_LoadPriorityImages(prop,globs::gameGlobs.CfgRootName);
	Main_Load_ToolTipInfo(prop,globs::gameGlobs.CfgRootName);
	Main_LoadToolNames(prop,globs::gameGlobs.CfgRootName);
	Main_LoadPanelRotationControl(prop,globs::gameGlobs.CfgRootName);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","SharedObjects",0);
	pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
	res::Lws_Initialise(pcVar1,snd::SFX_GetType,snd::SFX_Sample_Random_Play_OrInitSoundUnk,
											snd::SFX_IsSoundOn);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","SharedTextures",0);
	pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
	if (pcVar1 != NULL) {
		res::Container_SetSharedTextureDirectory(pcVar1);
	}
	res::Mesh_Initialise(pcVar1);
	iVar14 = appHeight();
	iVar9 = appWidth();
	std::sprintf(Button_buffer,"NextButton%ix%i",iVar9,iVar14);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main",Button_buffer,0);
	pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
	if ((pcVar1 != NULL) &&
		 (globs::gameGlobs.NextButton = lego::image::Image_LoadBMPScaled(pcVar1,0,0),
		 globs::gameGlobs.NextButton != NULL)) {
		lego::image::Image_SetupTrans(globs::gameGlobs.NextButton,0.0,0.0,0.0,0.0,0.0,0.0);
		iVar14 = appHeight();
		iVar9 = appWidth();
		std::sprintf(Button_buffer,"NextButtonPos%ix%i",iVar9,iVar14);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main",Button_buffer,0);
		pcVar1 = cfg::CFG_CopyString(prop,pcVar1);
		if (pcVar1 != NULL) {
			iVar14 = util::Util_Tokenise(pcVar1,Button_stringParts,",");
			if (iVar14 == 2) {
				fVar10 = std::atof(Button_stringParts[0]);
				globs::gameGlobs.NextButtonPos.x = (float)fVar10;
				fVar10 = std::atof(Button_stringParts[1]);
				globs::gameGlobs.NextButtonPos.y = (float)fVar10;
			}
			util::free2(pcVar1);
		}
	}
	iVar14 = appHeight();
	iVar9 = appWidth();
	std::sprintf(Button_buffer,"BackButton%ix%i",iVar9,iVar14);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main",Button_buffer,0);
	pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
	if ((pcVar1 != NULL) &&
		 (globs::gameGlobs.BackButton = lego::image::Image_LoadBMPScaled(pcVar1,0,0),
		 globs::gameGlobs.BackButton != NULL)) {
		lego::image::Image_SetupTrans(globs::gameGlobs.BackButton,0.0,0.0,0.0,0.0,0.0,0.0);
		iVar14 = appHeight();
		iVar9 = appWidth();
		std::sprintf(Button_buffer,"BackButtonPos%ix%i",iVar9,iVar14);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main",Button_buffer,0);
		pcVar1 = cfg::CFG_CopyString(prop,pcVar1);
		if (pcVar1 != NULL) {
			iVar14 = util::Util_Tokenise(pcVar1,Button_stringParts,",");
			if (iVar14 == 2) {
				fVar10 = std::atof(Button_stringParts[0]);
				globs::gameGlobs.BackButtonPos.x = (float)fVar10;
				fVar10 = std::atof(Button_stringParts[1]);
				globs::gameGlobs.BackButtonPos.y = (float)fVar10;
			}
			util::free2(pcVar1);
		}
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","BackArrow",0);
	pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
	if ((pcVar1 != NULL) &&
		 (globs::gameGlobs.BackArrow = lego::image::Image_LoadBMPScaled(pcVar1,0,0),
		 globs::gameGlobs.BackArrow != NULL)) {
		lego::image::Image_SetupTrans(globs::gameGlobs.BackArrow,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	unk::NERPs_SetHasNextButton((uint)(globs::gameGlobs.NextButton != NULL));
	BVar2 = Main_LoadLighting();
	if (((((BVar2 != 0) && (BVar2 = Main_Load_GraphicsSettings(), BVar2 != 0)) &&
			 (BVar2 = Boot_Load_UpgradeTypes(), BVar2 != 0)) &&
			((BVar2 = Boot_Load_VehicleTypes(), BVar2 != 0 &&
			 (BVar2 = Boot_Load_MiniFigureTypes(), BVar2 != 0)))) &&
		 ((BVar2 = Boot_Load_RockMonsterTypes(), BVar2 != 0 &&
			(BVar2 = Boot_Load_BuildingTypes(), BVar2 != 0)))) {
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","CameraSpeed",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			CameraSpeed_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","CameraSpeed",0);
			CameraSpeed_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar10 = std::atof(CameraSpeed_str);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","CameraDropOff",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			CameraDropOff_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","CameraDropOff",0);
			CameraDropOff_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar11 = std::atof(CameraDropOff_str);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","CameraAcceleration",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			CameraAcceleration_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","CameraAcceleration",0);
			CameraAcceleration_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar12 = std::atof(CameraAcceleration_str);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MouseScrollIndent",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			MouseScrollIndent_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MouseScrollIndent",0);
			MouseScrollIndent_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		iVar14 = std::atoi(MouseScrollIndent_str);
		lego::view::Camera_SetCameraMovements((float)fVar10,(float)fVar11,(float)fVar12,iVar14);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MinDistFor3DSoundsOnTopView",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			MinDistFor3DSoundsOnTopView_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MinDistFor3DSoundsOnTopView",0
																);
			MinDistFor3DSoundsOnTopView_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar10 = std::atof(MinDistFor3DSoundsOnTopView_str);
		globs::gameGlobs.MinDistFor3DSoundsOnTopView = (float)fVar10;
		if (fVar10 == (float10)0.0) {
			globs::gameGlobs.MinDistFor3DSoundsOnTopView = 150.0;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MaxDistFor3DSounds",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			MaxDistFor3DSounds_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MaxDistFor3DSounds",0);
			MaxDistFor3DSounds_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar10 = std::atof(MaxDistFor3DSounds_str);
		if (fVar10 != (float10)0.0) {
			snd::Sound3D_SetMaxDist((float)fVar10);
		}
		snd::Sound3D_SetRollOffFactor(1.0);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","RollOffFor3DSounds",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			RollOffFor3DSounds_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","RollOffFor3DSounds",0);
			RollOffFor3DSounds_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar10 = std::atof(RollOffFor3DSounds_str);
		if (fVar10 != (float10)0.0) {
			snd::Sound3D_SetRollOffFactor((float)fVar10);
		}
		globs::gameGlobs.RES_2f4_TABLEUNK =
				 (Container **)res::Res_FUN_004641c0(globs::gameGlobs.resRoot,5.0);
		res::ResLp_Hide(globs::gameGlobs.RES_2f4_TABLEUNK,1);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MaxReturnedCrystals",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			MaxReturnedCrystals_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MaxReturnedCrystals",0);
			MaxReturnedCrystals_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		globs::gameGlobs.MaxReturnedCrystals = std::atoi(MaxReturnedCrystals_str);
		if (globs::gameGlobs.MaxReturnedCrystals == 0) {
			globs::gameGlobs.MaxReturnedCrystals = 10;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MouseScrollBorder",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			MouseScrollBorder_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MouseScrollBorder",0);
			MouseScrollBorder_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		globs::gameGlobs.MouseScrollBorder = std::atoi(MouseScrollBorder_str);
		if (globs::gameGlobs.MouseScrollBorder == 0) {
			globs::gameGlobs.MouseScrollBorder = 5;
		}
		Main_Load_ObjectNames(prop);
		Main_Load_ObjectTheNames(prop);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","HelpWindowOn",0);
		BVar8 = cfg::CFG_ReadBool(prop,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			front::HelpWindow_SetFont(globs::gameGlobs.bmpMbriefFONT2);
			front::HelpWindow_Load(prop,globs::gameGlobs.CfgRootName);
		}
		front::ObjInfo_LoadObjInfo(prop,globs::gameGlobs.CfgRootName);
		light::LightEffects_Load(prop,globs::gameGlobs.CfgRootName);
		stats::Stats_Initialise(prop,globs::gameGlobs.CfgRootName);
		game::Dependencies_Load(prop,globs::gameGlobs.CfgRootName);
		front::Bubble_LoadBubbles(prop);
		front::Encyclopedia_Initialise(prop,globs::gameGlobs.CfgRootName);
		Main_LoadObjTtSFXs(prop,globs::gameGlobs.CfgRootName);
		tools::Weapon_LoadWeaponTypes(prop,globs::gameGlobs.CfgRootName);
		globs::gameGlobs.viewMode = VIEW_TOPDOWN;
		snd::Sound3D_MakeListener((globs::gameGlobs.cameraMain)->resTableunk_34->masterFrame);
		snd::Sound3D_SetMinDistForAtten(globs::gameGlobs.MinDistFor3DSoundsOnTopView);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","mindist",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			mindist_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","mindist",0);
			mindist_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar10 = std::atof(mindist_str);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","maxdist",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			maxdist_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","maxdist",0);
			maxdist_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar11 = std::atof(maxdist_str);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","mintilt",0);
		fVar12 = cfg::CFG_ReadRadians(prop,pcVar1);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","maxtilt",0);
		fVar13 = cfg::CFG_ReadRadians(prop,pcVar1);
		lego::view::Camera_SetDistRange(globs::gameGlobs.cameraMain,(float)fVar10,(float)fVar11);
		lego::view::Camera_SetTiltRange(globs::gameGlobs.cameraMain,(float)fVar12,(float)fVar13);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","tvclipdist",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			tvclipdist_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","tvclipdist",0);
			tvclipdist_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar10 = std::atof(tvclipdist_str);
		globs::gameGlobs.TVClipDist = (float)fVar10;
		lego::view::Viewport_SetBackClip(globs::gameGlobs.viewMain,globs::gameGlobs.TVClipDist);
		lego::view::Viewport_SetBackClip(globs::gameGlobs.viewRadar,globs::gameGlobs.TVClipDist);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","DynamiteDamageRadius",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			DynamiteDamageRadius_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","DynamiteDamageRadius",0);
			DynamiteDamageRadius_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar10 = std::atof(DynamiteDamageRadius_str);
		globs::gameGlobs.DynamiteDamageRadius = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","DynamiteMaxDamage",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			DynamiteMaxDamage_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","DynamiteMaxDamage",0);
			DynamiteMaxDamage_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar10 = std::atof(DynamiteMaxDamage_str);
		globs::gameGlobs.DynamiteMaxDamage = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","DynamiteWakeRadius",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			DynamiteWakeRadius_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","DynamiteWakeRadius",0);
			DynamiteWakeRadius_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar10 = std::atof(DynamiteWakeRadius_str);
		globs::gameGlobs.DynamiteWakeRadius = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","BirdScarerRadius",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			BirdScarerRadius_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","BirdScarerRadius",0);
			BirdScarerRadius_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar10 = std::atof(BirdScarerRadius_str);
		globs::gameGlobs.BirdScarerRadius = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MusicOn",0);
		BVar8 = cfg::CFG_ReadBool(prop,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			globs::gameGlobs.flags2 |= GAME2_MUSICON;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","CDStartTrack",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			CDStartTrack_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","CDStartTrack",0);
			CDStartTrack_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		globs::gameGlobs.CDStartTrack = std::atoi(CDStartTrack_str);
		if (globs::gameGlobs.CDStartTrack == 0) {
			globs::gameGlobs.CDStartTrack = 2;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","CDTracks",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			CDTracks_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","CDTracks",0);
			CDTracks_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		globs::gameGlobs.CDTracks = std::atoi(CDTracks_str);
		if (globs::gameGlobs.CDTracks == 0) {
			globs::gameGlobs.flags2 &= ~GAME2_MUSICON;
			globs::gameGlobs.CDTracks = 1;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","SoundOn",0);
		BVar8 = cfg::CFG_ReadBool(prop,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			globs::gameGlobs.flags1 |= GAME1_SOUNDON;
		}
		globs::gameGlobs.flags1 |= GAME1_WALLPROMESHES|GAME1_CLEAR|GAME1_PANELS|GAME1_DYNAMICPM;
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","Clear",0);
		BVar8 = cfg::CFG_ReadBool(prop,pcVar1);
		if (BVar8 == BOOL3_FALSE) {
			globs::gameGlobs.flags1 &= ~GAME1_CLEAR;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","Panels",0);
		BVar8 = cfg::CFG_ReadBool(prop,pcVar1);
		if (BVar8 == BOOL3_FALSE) {
			globs::gameGlobs.flags1 &= ~GAME1_PANELS;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","WallProMeshes",0);
		BVar8 = cfg::CFG_ReadBool(prop,pcVar1);
		if (BVar8 == BOOL3_FALSE) {
			globs::gameGlobs.flags1 &= ~GAME1_WALLPROMESHES;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","DynamicPM",0);
		BVar8 = cfg::CFG_ReadBool(prop,pcVar1);
		if (BVar8 == BOOL3_FALSE) {
			globs::gameGlobs.flags1 &= ~GAME1_DYNAMICPM;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","HPBlocks",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			HPBlocks_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","HPBlocks",0);
			HPBlocks_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		globs::gameGlobs.HPBlocks = std::atoi(HPBlocks_str);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","OnlyBuildOnPaths",0);
		BVar8 = cfg::CFG_ReadBool(prop,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			globs::gameGlobs.flags1 |= GAME1_ONLYBUILDONPATHS;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","AlwaysRockFall",0);
		BVar8 = cfg::CFG_ReadBool(prop,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			globs::gameGlobs.flags1 |= GAME1_ALWAYSROCKFALL;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MiniFigureRunAway",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			MiniFigureRunAway_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MiniFigureRunAway",0);
			MiniFigureRunAway_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar10 = std::atof(MiniFigureRunAway_str);
		globs::gameGlobs.MiniFigureRunAway = (float)fVar10;
		if (fVar10 == (float10)0.0) {
			globs::gameGlobs.MiniFigureRunAway = 10.0;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","DrainTime",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			DrainTime_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","DrainTime",0);
			DrainTime_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar10 = std::atof(DrainTime_str);
		globs::gameGlobs.DrainTime = (float)fVar10;
		if (fVar10 == (float10)0.0) {
			globs::gameGlobs.DrainTime = 10.0;
		}
		globs::gameGlobs.DrainTime = globs::gameGlobs.DrainTime * 25.0;
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","ReinforceHits",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			ReinforceHits_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","ReinforceHits",0);
			ReinforceHits_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		globs::gameGlobs.ReinforceHits = std::atoi(ReinforceHits_str);
		if (globs::gameGlobs.ReinforceHits == 0) {
			globs::gameGlobs.ReinforceHits = 4;
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MedPolyRange",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			MedPolyRange_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MedPolyRange",0);
			MedPolyRange_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar10 = std::atof(MedPolyRange_str);
		globs::gameGlobs.MedPolyRange = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","HighPolyRange",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			HighPolyRange_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","HighPolyRange",0);
			HighPolyRange_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar10 = std::atof(HighPolyRange_str);
		globs::gameGlobs.HighPolyRange = (float)fVar10;
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MinEnergyForEat",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			MinEnergyForEat_str = ""/*EMPTYSTR*/;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MinEnergyForEat",0);
			MinEnergyForEat_str = cfg::CFG_ReadString(prop,pcVar1);
		}
		fVar10 = std::atof(MinEnergyForEat_str);
		globs::gameGlobs.MinEnergyForEat = (float)fVar10;
		Main_LoadMiscObjects(prop);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Pointers",0);
		prop_00 = cfg::CFG_GetChildren(prop,pcVar1);
		front::Pointer_LoadPointers(prop_00);
		front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_STANDARD);
		if ((globs::gameGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
			game::Message_Debug_RegisterSelectedUnitHotkey(KEY_ONE,MESSAGE_FIRSTPERSON,NULL,FALSE,NULL);
			game::Message_Debug_RegisterSelectedUnitHotkey(KEY_TWO,MESSAGE_FIRSTPERSON,NULL,TRUE,NULL);
			game::Message_Debug_RegisterSelectedUnitHotkey(KEY_FOUR,MESSAGE_TRACKOBJECT,NULL,FALSE,NULL);
			game::Message_Debug_RegisterSelectedUnitHotkey(KEY_THREE,MESSAGE_TOPVIEW,NULL,FALSE,NULL);
		}
		effect::Smoke_LoadTextures("MiscAnims\\Smoke","Smoke",3);
		effect::DamageFont_LoadFrames("Interface\\FONTS\\HealthFont","a000_");
		Dialog_center.x = 0.0;
		Dialog_center.y = 0.0;
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Dialog","Image",0);
		pcVar1 = cfg::CFG_CopyString(prop,pcVar1);
		if ((pcVar1 != NULL) &&
			 (globs::gameGlobs.DialogImage = lego::image::Image_LoadBMPScaled(pcVar1,0,0),
			 globs::gameGlobs.DialogImage != NULL)) {
			lego::image::Image_SetupTrans(globs::gameGlobs.DialogImage,0.0,0.0,0.0,0.0,0.0,0.0);
			iVar14 = appWidth();
			Dialog_center.x = (float)(iVar14 / 2) - (float)((globs::gameGlobs.DialogImage)->width >> 1);
			iVar14 = appHeight();
			Dialog_center.y = (float)(iVar14 / 2) - (float)((globs::gameGlobs.DialogImage)->height >> 1);
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Dialog","TitleWindow",0);
		pcVar1 = cfg::CFG_CopyString(prop,pcVar1);
		if ((pcVar1 != NULL) &&
			 (iVar14 = util::Util_Tokenise(pcVar1,Window_stringParts,"|"), iVar14 == 4)) {
			iVar14 = std::atoi(Window_stringParts[0]);
			Window_rect.x = (float)iVar14 + Dialog_center.x;
			iVar14 = std::atoi(Window_stringParts[1]);
			Window_rect.y = (float)iVar14 + Dialog_center.y;
			iVar14 = std::atoi(Window_stringParts[2]);
			Window_rect.width = (float)iVar14;
			iVar14 = std::atoi(Window_stringParts[3]);
			Window_rect.height = (float)iVar14;
			globs::gameGlobs.DialogTextWndTitle =
					 front::TextWindow_Create(globs::gameGlobs.bmpMbriefFONT2,&Window_rect,0x400);
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Dialog","TextWindow",0);
		pcVar1 = cfg::CFG_CopyString(prop,pcVar1);
		if ((pcVar1 != NULL) &&
			 (iVar14 = util::Util_Tokenise(pcVar1,Window_stringParts,"|"), iVar14 == 4)) {
			iVar14 = std::atoi(Window_stringParts[0]);
			Window_rect.x = (float)iVar14 + Dialog_center.x;
			iVar14 = std::atoi(Window_stringParts[1]);
			Window_rect.y = (float)iVar14 + Dialog_center.y;
			iVar14 = std::atoi(Window_stringParts[2]);
			Window_rect.width = (float)iVar14;
			iVar14 = std::atoi(Window_stringParts[3]);
			Window_rect.height = (float)iVar14;
			globs::gameGlobs.DialogTextWndMessage =
					 front::TextWindow_Create(globs::gameGlobs.bmpMbriefFONT,&Window_rect,0x400);
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Dialog","OkWindow",0);
		pcVar1 = cfg::CFG_CopyString(prop,pcVar1);
		if ((pcVar1 != NULL) &&
			 (iVar14 = util::Util_Tokenise(pcVar1,Window_stringParts,"|"), iVar14 == 4)) {
			iVar14 = std::atoi(Window_stringParts[0]);
			Window_rect.x = (float)iVar14 + Dialog_center.x;
			iVar14 = std::atoi(Window_stringParts[1]);
			Window_rect.y = (float)iVar14 + Dialog_center.y;
			iVar14 = std::atoi(Window_stringParts[2]);
			Window_rect.width = (float)iVar14;
			iVar14 = std::atoi(Window_stringParts[3]);
			Window_rect.height = (float)iVar14;
			globs::gameGlobs.DialogTextWndOK =
					 front::TextWindow_Create(globs::gameGlobs.bmpMbriefFONT,&Window_rect,0x400);
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Dialog","CancelWindow",0);
		pcVar1 = cfg::CFG_CopyString(prop,pcVar1);
		if ((pcVar1 != NULL) &&
			 (iVar14 = util::Util_Tokenise(pcVar1,Window_stringParts,"|"), iVar14 == 4)) {
			iVar14 = std::atoi(Window_stringParts[0]);
			Window_rect.x = (float)iVar14 + Dialog_center.x;
			iVar14 = std::atoi(Window_stringParts[1]);
			Window_rect.y = (float)iVar14 + Dialog_center.y;
			iVar14 = std::atoi(Window_stringParts[2]);
			Window_rect.width = (float)iVar14;
			iVar14 = std::atoi(Window_stringParts[3]);
			Window_rect.height = (float)iVar14;
			globs::gameGlobs.DialogTextWndCancel =
					 front::TextWindow_Create(globs::gameGlobs.bmpMbriefFONT,&Window_rect,0x400);
		}
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Dialog","ContrastOverlay",0);
		pcVar1 = cfg::CFG_CopyString(prop,pcVar1);
		if ((pcVar1 != NULL) &&
			 (globs::gameGlobs.DialogContrastOverlay = lego::image::Image_LoadBMPScaled(pcVar1,0,0),
			 globs::gameGlobs.DialogContrastOverlay != NULL)) {
			lego::image::Image_SetupTrans(globs::gameGlobs.DialogContrastOverlay,0.0,0.0,0.0,0.0,0.0,0.0);
		}
		globs::gameGlobs.flags1 |= GAME1_RADARON|GAME1_RADAR_TRACKOBJECTVIEW;
		util::logf_removed((char *)globs::gameGlobs.resRoot,"animtex\\dirt");
		globs::gameGlobs.tvTiltOrZoom_334 = 15.0;
		globs::gameGlobs.float_324 = 16.0;
		globs::gameGlobs.float_328 = 13.0;
		globs::gameGlobs.float_32c = 151.0;
		globs::gameGlobs.float_330 = 151.0;
		effect::Effect_Load_RockFallStyles(prop,globs::gameGlobs.CfgRootName,globs::gameGlobs.resRoot);
		Main_LoadToolTips(prop);
		game::LiveManager_LoadToolTipIcons(prop);
		Main_LoadUpgradeNames(prop);
		front::Info_LoadInfoMessages(prop);
		front::Info_LoadMessageTabs_InfoOverFlow("Interface\\MessageTabs\\infoOverFlow.bmp");
		Main_LoadTextMessages(prop);
		uVar3 = appHeight();
		uVar4 = appWidth();
		front::Panel_LoadPanels(prop,uVar4,uVar3);
		Main_LoadRightPanelCrystals
							("Interface\\RightPanel\\SmallCrystal.bmp","Interface\\RightPanel\\UsedCrystal.bmp",
							 "Interface\\RightPanel\\NoSmallCrystal.bmp");
		front::AirMeter_Load
							("Interface\\AirMeter\\msgpanel_air_juice.bmp",85,6,236,
							 "Interface\\AirMeter\\msgpanel_noair.bmp",21,0);
		Main_LoadRightPanel_CryOreSidebar
							("Interface\\RightPanel\\crystalsidebar_ore.bmp",0x267,0x1b2,0x1a7);
		uVar3 = appHeight();
		iVar14 = appWidth();
		front::Panel_LoadButtons(prop,iVar14,uVar3);
		Main_LoadTutorialIcon(prop);
		lego::front::Interface_InitSubmenuIconTables();
		front::Interface_LoadInterfaceImages(prop,globs::gameGlobs.CfgRootName);
		front::Interface_LoadInterfaceSurroundImages(prop,globs::gameGlobs.CfgRootName);
		front::Interface_LoadInterfaceDependencies_PlusMinus
							("Interface\\Dependencies\\+.bmp","Interface\\Dependencies\\=.bmp");
		front::Reward_LoadBaseGraphics(prop,globs::gameGlobs.CfgRootName);
		reward::Reward_LoadBaseFrontEnd();
		front::Panel_LoadInterfaceButtons_ScrollInfo();
		front::Panel_FUN_0045ad80(PANEL_RADAR,2,TRUE);
		front::Panel_FUN_0045ad80(PANEL_RADAR,3,TRUE);
		save::Save_ClearSaveNumber();
		BVar2 = Config_IsFrontEndEnabled();
		if (BVar2 != 0) {
			front::Menu_LoadMenus(globs::gameGlobs.LegoCfgRoot);
		}
		front::Advisor_Init(globs::gameGlobs.CfgRootName,globs::gameGlobs.cameraMain,
												globs::gameGlobs.viewMain);
		front::Advisor_InitViewport(200.0);
		front::Advisor_LoadAdvisorAnims(prop,globs::gameGlobs.CfgRootName);
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","DisplayAdvisor",0);
		BVar8 = cfg::CFG_ReadBool(prop,pcVar1);
		if (BVar8 == BOOL3_TRUE) {
			iVar14 = appHeight();
			iVar9 = appWidth();
			front::Advisor_LoadAdvisorPositions(prop,globs::gameGlobs.CfgRootName,iVar9,iVar14);
		}
		if ((globs::gameGlobs.flags1 & GAME1_SOUNDON) != GAME1_NONE) {
			snd::SFX_SetSoundEnabled(TRUE);
		}
		PVar6 = Main_ProgrammerMode();
		if (PVar6 < PROGRAMMER_MODE_3) {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","FrontEnd",0);
			BVar8 = cfg::CFG_ReadBool(prop,pcVar1);
			if (BVar8 != BOOL3_TRUE) goto LAB_004226cc;
			front::Loader_display_loading_bar(NULL);
			front::Front_RunScreenMenuType(MENU_SCREEN_TITLE);
			iVar14 = front::Front_IsTriggerAppQuit();
			if (iVar14 != 0) {
				return 0;
			}
			startLevelName = front::Front_GetSelectedLevel();
		}
		else {
LAB_004226cc:
			startLevelName = Main_GetStartLevel();
			if (startLevelName == NULL) {
				pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","startlevel",0);
				startLevelName = cfg::CFG_ReadString(prop,pcVar1);
			}
		}
		front::Front_FUN_00416870(TRUE,FALSE);
		BVar2 = Main_loadLevelCFG(startLevelName);
		if (BVar2 != 0) {
			snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_AMBIENTLOOP,TRUE);
			return TRUE;
		}
	}
	cfg::CFG_Close(prop);
LAB_0042274b:
	res::Container_Shutdown();
	return 0;
}



void __cdecl lego::main::Main_LoadMiscObjects(CFGProperty *root)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","Boulder",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_Boulder = res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"LWO",TRUE);
	if (globs::gameGlobs.RES_Boulder == NULL) {
		globs::gameGlobs.RES_Boulder = res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"MESH",TRUE);
	}
	res::Container_Hide(globs::gameGlobs.RES_Boulder,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","BoulderExplodeIce",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_BoulderExplodeIce =
			 res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::gameGlobs.RES_BoulderExplodeIce,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","BoulderExplode",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_BoulderExplode =
			 res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::gameGlobs.RES_BoulderExplode,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","SmashPath",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_SmashPath = res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::gameGlobs.RES_SmashPath,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","Explosion",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	effect::Effect_Load_Explosion(globs::gameGlobs.resRoot,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","Crystal",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_Crystal = res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"LWO",TRUE);
	if (globs::gameGlobs.RES_Crystal == NULL) {
		globs::gameGlobs.RES_Crystal = res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"MESH",TRUE);
	}
	res::Container_Hide(globs::gameGlobs.RES_Crystal,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","Dynamite",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_Dynamite = res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"ACT",TRUE);
	res::Container_Hide(globs::gameGlobs.RES_Dynamite,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","OohScary",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_OohScary = res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"ACT",TRUE);
	res::Container_Hide(globs::gameGlobs.RES_OohScary,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","Barrier",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_Barrier = res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"ACT",TRUE);
	res::Container_Hide(globs::gameGlobs.RES_Barrier,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","Ore",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_Ores_TABLE[0] =
			 res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"LWO",TRUE);
	if (globs::gameGlobs.RES_Ores_TABLE[0] == NULL) {
		globs::gameGlobs.RES_Ores_TABLE[0] =
				 res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"MESH",TRUE);
	}
	res::Container_Hide(globs::gameGlobs.RES_Ores_TABLE[0],TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","ProcessedOre",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_Ores_TABLE[1] =
			 res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"LWO",TRUE);
	if (globs::gameGlobs.RES_Ores_TABLE[1] == NULL) {
		globs::gameGlobs.RES_Ores_TABLE[1] =
				 res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"MESH",TRUE);
	}
	res::Container_Hide(globs::gameGlobs.RES_Ores_TABLE[1],TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","ElectricFence",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_ElectricFence =
			 res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"LWO",TRUE);
	res::Container_Hide(globs::gameGlobs.RES_ElectricFence,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","ElectricFenceStud",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_ElectricFenceStud =
			 res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::gameGlobs.RES_ElectricFenceStud,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","ShortElectricFenceBeam",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	effect::Effect_LoadMiscObjectResource_ElectricFenceBeam(globs::gameGlobs.resRoot,pcVar1,FALSE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","LongElectricFenceBeam",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	effect::Effect_LoadMiscObjectResource_ElectricFenceBeam(globs::gameGlobs.resRoot,pcVar1,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","SpiderWeb",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_SpiderWeb = res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"ACT",TRUE);
	res::Container_Hide(globs::gameGlobs.RES_SpiderWeb,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","RechargeSparkle",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_RechargeSparkle =
			 res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::gameGlobs.RES_RechargeSparkle,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","MiniTeleportUp",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_MiniTeleportUp =
			 res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"LWS",FALSE);
	res::Container_Hide(globs::gameGlobs.RES_MiniTeleportUp,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","IceCube",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_IceCube = res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"ACT",TRUE);
	res::Container_Hide(globs::gameGlobs.RES_IceCube,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","Pusher",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_Pusher = res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::gameGlobs.RES_Pusher,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","Freezer",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_Freezer = res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::gameGlobs.RES_Freezer,TRUE);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiscObjects","LaserShot",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globs::gameGlobs.RES_LaserShot = res::Container_Load(globs::gameGlobs.resRoot,pcVar1,"LWS",TRUE);
	res::Container_Hide(globs::gameGlobs.RES_LaserShot,TRUE);
	effect::Effect_LoadMiscObjectEffects(root,globs::gameGlobs.CfgRootName,globs::gameGlobs.resRoot);
	return;
}



Container * __cdecl lego::game::Game_GetCamera24_IfBool308_ElseCamera2C(void)
{
	Container *pCVar1;
	
	if (globs::gameGlobs.viewMode == VIEW_TOPDOWN) {
		return (globs::gameGlobs.cameraMain)->resData1;
	}
	pCVar1 = (Container *)globs::gameGlobs.viewMode;
	if (globs::gameGlobs.viewMode == VIEW_FIRSTPERSON) {
		pCVar1 = (globs::gameGlobs.cameraFP)->resData1;
	}
	return pCVar1;
}



float10 __cdecl lego::game::Game_GetFloatFPS_e40(void)
{
	return (float10)globs::gameGlobs.elapsedAbs;
}



void __cdecl lego::game::Game_RenameInputUnk(float elapsed)
{
	uint uVar1;
	uint uVar2;
	LiveObject *pLVar3;
	char *pcVar4;
	uint uVar5;
	char *pcVar6;
	char *pcVar7;
	int iVar8;
	longlong lVar9;
	
	globals::g_RenameInputTimer = globals::g_RenameInputTimer - elapsed;
	if ((ushort)((ushort)(globals::g_RenameInputTimer < 0.0) << 8 |
							(ushort)(globals::g_RenameInputTimer == 0.0) << 0xe) != 0) {
		globals::g_RenameInputTimer = globals::g_RenameInputTimer - -12.5;
		globals::g_UseQuotes_Unk = ZEXT14(globals::g_UseQuotes_Unk == 0);
	}
	if (globs::gameGlobs.renameInput != NULL) {
		lVar9 = __ftol((float10)globs::gameGlobs.renamePosition.x);
		iVar8 = (int)lVar9;
		uVar1 = lego::image::Font_GetHeight(globs::gameGlobs.bmpToolTipFont);
		lVar9 = __ftol((float10)globs::gameGlobs.renamePosition.y);
		uVar2 = lego::image::Font_GetCharWidth(globs::gameGlobs.bmpToolTipFont,'\"');
		pcVar4 = globs::gameGlobs.renameInput;
		if ((*globs::gameGlobs.renameInput == '\0') &&
			 (pLVar3 = Message_GetPrimarySelectedUnit(), pcVar4 = globs::gameGlobs.renameInput,
			 pLVar3 != NULL)) {
			pLVar3 = Message_GetPrimarySelectedUnit();
			pcVar4 = LiveObject_GetName(pLVar3);
		}
		uVar5 = lego::image::Font_GetStringWidth(globs::gameGlobs.bmpToolTipFont,"\"%s\"",pcVar4);
		if (globs::mainGlobs.appWidth - 40 < iVar8 + uVar5) {
			iVar8 -= uVar5;
		}
		pcVar7 = "\"";
		if (globals::g_UseQuotes_Unk == 0) {
			pcVar7 = ____EMPTYSTR__;
		}
		pcVar6 = "\"";
		if (globals::g_UseQuotes_Unk == 0) {
			pcVar6 = ____EMPTYSTR__;
		}
		lego::image::Font_PrintF
							(globs::gameGlobs.bmpToolTipFont,
							 (~-(uint)(globals::g_UseQuotes_Unk != 0) & uVar2) + iVar8,(int)lVar9 - (uVar1 >> 1),
							 "%s%s%s",pcVar6,pcVar4,pcVar7);
	}
	return;
}



void __cdecl lego::input::Input_UpdateTyping(void)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	int iVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	if (globs::gameGlobs.renameInput != NULL) {
		uVar2 = 0xffffffff;
		pcVar6 = globs::gameGlobs.renameInput;
		do {
			if (uVar2 == 0) break;
			uVar2 -= 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
		uVar3 = ~uVar2 - 1;
										// 1 = DIK_ESCAPE, 14 = DIK_BACK (backspace), 28 = DIK_RETURN (enter)
		if ((globs::INPUT.Key_Map[14] == false) ||
			 ((bool)globals::g_KeyboardState_Typing_TABLE[14] == globs::INPUT.Key_Map[14])) {
			if (((globs::INPUT.Key_Map[28] == false) && (globals::g_KeyboardState_Typing_TABLE[28] != 0))
				 || ((globs::INPUT.Key_Map[1] == false && (globals::g_KeyboardState_Typing_TABLE[1] != 0))))
			{
				globs::gameGlobs.renameInput = NULL;
				game::Game_SetPaused(0,0);
			}
			else {
				uVar2 = 0;
				do {
					if ((((uVar3 < 0xb) && (globs::INPUT.Key_Map[uVar2] != false)) &&
							((bool)globals::g_KeyboardState_Typing_TABLE[uVar2] != globs::INPUT.Key_Map[uVar2]))
						 && (iVar4 = Input_GetKeyCharacter(uVar2), iVar4 != 0)) {
						iVar4 = std::toupper(iVar4);
						globs::gameGlobs.renameInput[uVar3] = (char)iVar4;
						uVar3 += 1;
						globs::gameGlobs.renameInput[uVar3] = '\0';
					}
					uVar2 += 1;
				} while (uVar2 < 0x100);
			}
		}
		else {
			if (uVar3 != 0) {
				globs::gameGlobs.renameInput[~uVar2 - 2] = '\0';
			}
		}
		puVar5 = (undefined4 *)globs::INPUT.Key_Map;
		puVar7 = (undefined4 *)globals::g_KeyboardState_Typing_TABLE;
		for (iVar4 = 0x40; iVar4 != 0; iVar4 += -1) {
			*puVar7 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar7 = puVar7 + 1;
		}
		puVar5 = (undefined4 *)globs::INPUT.Key_Map;
		for (iVar4 = 0x40; iVar4 != 0; iVar4 += -1) {
			*puVar5 = 0;
			puVar5 = puVar5 + 1;
		}
	}
	return;
}



BOOL __cdecl lego::main::LRR_MainLoop(float elapsed)
{
	float fVar1;
	LiveObject *pLVar2;
	BOOL BVar3;
	LevelData *level;
	char *pcVar4;
	uint uVar5;
	LiveObject **ppLVar6;
	ObjectUpgradesData *pOVar7;
	float fVar8;
	float elapsedGame_00;
	uint uVar9;
	int iVar10;
	int iVar11;
	float10 fVar12;
	longlong lVar13;
	TextType textType;
	float fVar15;
	ulonglong uVar14;
	float local_34;
	SFXType local_30;
	float elapsedGame;
	Vector4F local_28;
	int local_18;
	BOOL local_14;
	BOOL local_10;
	Vector3F local_c;
	
	fVar1 = elapsed;
	local_30 = SFX_NULL;
	if ((globs::mainGlobs.programmerLevel == PROGRAMMER_MODE_10) &&
		 (BVar3 = FUN_00435870(), BVar3 == 0)) {
		return 0;
	}
	if ((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) != GAME1_NONE) {
		elapsed = 0.0;
	}
	input::Input_UpdateTyping();
	globs::gameGlobs.elapsedAbs = elapsed;
	if ((globs::gameGlobs.viewMode == VIEW_FIRSTPERSON) &&
		 (globs::mainGlobs.programmerLevel < PROGRAMMER_MODE_2)) {
										// In first person view, game speed is locked at 100%
		elapsedGame = elapsed;
	}
	else {
		fVar12 = game::Game_GetGameSpeed();
		elapsedGame = (float)(fVar12 * (float10)elapsed);
	}
	elapsedGame_00 = elapsedGame;
	unk::Teleporter_Update(elapsedGame);
	game::Game_UnkTeleporterInit_FUN_00435980();
	fVar15 = elapsed;
	level = game::GetLevel();
	game::Level_FUN_0042c370(level,fVar15);
	game::Game_UpdateFallins(elapsedGame_00);
	unk::Lego_unkSlug__004260f0(elapsedGame_00);
	if ((globs::gameGlobs.flags2 & GAME2_CALLTOARMS) == GAME2_NONE) {
		if (((globs::gameGlobs.cameraFP != NULL) && ((globs::gameGlobs.cameraFP)->resData1 != NULL)) &&
			 (globs::gameGlobs.resFPRotLightDefault != NULL)) {
			res::Container_Hide(globs::gameGlobs.resFPRotLightDefault,1);
		}
	}
	else {
		if (((globs::gameGlobs.cameraFP != NULL) && ((globs::gameGlobs.cameraFP)->resData1 != NULL)) &&
			 ((globs::gameGlobs.resFPRotLightDefault != NULL &&
				((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE)))) {
			res::Container_Hide(globs::gameGlobs.resFPRotLightDefault,0);
			res::Container_AddRotation
								(globs::gameGlobs.resFPRotLightDefault,D3DRMCOMBINE_AFTER,0.0,1.0,0.0,elapsed * 0.1)
			;
		}
	}
	if (((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) &&
		 (((globs::gameGlobs.flags1 & GAME1_UNK_200000) != GAME1_NONE || (globs::gameGlobs.bool_98 != 0)
			))) {
		if (globs::gameGlobs.bool_98 != 0) {
			local_28.x = (1.0 / elapsed) * 5.0;
			res::Container_GetPosition((globs::gameGlobs.cameraMain)->resData3,NULL,&local_c);
			globs::gameGlobs.pointf_88.x =
					 (local_28.x * local_c.x + globs::gameGlobs.pointf_90.x) / (local_28.x - -1.0);
			globs::gameGlobs.pointf_88.y =
					 (local_28.x * local_c.y + globs::gameGlobs.pointf_90.y) / (local_28.x - -1.0);
			local_28.x = globs::gameGlobs.pointf_88.x - local_c.x;
			local_28.y = globs::gameGlobs.pointf_88.y - local_c.y;
			if (SQRT(local_28.y * local_28.y + local_28.x * local_28.x) < 2.0) {
				globs::gameGlobs.bool_98 = 0;
			}
		}
		lego::view::Camera_SetFramePosition_IfTopdown
							(globs::gameGlobs.cameraMain,globs::gameGlobs.pointf_88.x,globs::gameGlobs.pointf_88.y
							);
		globs::gameGlobs.flags1 &= ~GAME1_UNK_200000;
	}
	if ((globs::gameGlobs.flags1 & GAME1_LEVELSTART) != GAME1_NONE) {
		elapsedGame = 1.0;
		globs::gameGlobs.flags1 &= ~GAME1_LEVELSTART;
		elapsedGame_00 = 1.0;
	}
	BVar3 = game::Game_DoHotkeyChecks(elapsedGame_00,elapsed,&local_10,&local_14,&local_18);
	if (BVar3 == 0) {
		return 0;
	}
	if ((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) {
		FUN_00425cc0();
	}
	ai::AITask_Update(elapsedGame_00);
	game::Level_FUN_00424530(globs::gameGlobs.level,elapsedGame_00);
	effect::DamageFont_UpdateAll(elapsed);
	game::LiveManager_UpdateAll(elapsedGame_00);
	res::Struct2B0_Table_FUN_0046f810(elapsedGame_00);
	game::Erode_Update(elapsedGame_00);
	game::Level_LevelStruct1C_FUN_004312e0(globs::gameGlobs.level,elapsedGame_00);
	game::Message_PTL_Update();
	lego::view::Camera_Update
						(globs::gameGlobs.cameraMain,globs::gameGlobs.level,elapsed,elapsedGame_00);
	lego::view::Camera_Update
						(globs::gameGlobs.cameraRadar,globs::gameGlobs.level,elapsed,elapsedGame_00);
	lego::view::Camera_Update(globs::gameGlobs.cameraFP,globs::gameGlobs.level,elapsed,elapsedGame_00)
	;
	game::Construction_Update(elapsedGame_00);
	front::Interface_FUN_0041b940(fVar1);
	FUN_004290d0(elapsed,FALSE);
	FUN_00449ec0();
	game::ElectricFence_Update(elapsedGame_00);
	game::Game_unkGameLoop_FUN_00426450(fVar1,elapsed,local_10,local_14,local_18);
	game::Map3D_Update((globs::gameGlobs.level)->surfaceMap,elapsedGame_00);
	game::LevelStruct428_FUN_0046e650(globs::gameGlobs.level,elapsedGame_00);
	snd::Sound3D_UpdateListener();
	effect::Smoke_Update(elapsedGame_00);
	game::SpiderWeb_Update(elapsedGame_00);
	light::LightEffects_Update(elapsedGame_00);
	front::Info_FUN_0041a1f0(fVar1);
	if (globs::gameGlobs.IsFallinsEnabled != 0) {
		game::Fallin_Update(elapsedGame_00);
	}
	if ((((globs::gameGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) &&
			(globs::INPUT.Key_Map[64] != false)) &&
		 (globs::INPUT.prevKey_Map[64] != globs::INPUT.Key_Map[64])) {
		globs::gameGlobs.IsFallinsEnabled = ZEXT14(globs::gameGlobs.IsFallinsEnabled == 0);
		pcVar4 = "On";
		if (globs::gameGlobs.IsFallinsEnabled == 0) {
			pcVar4 = "Off";
		}
		front::TextWindow_PrintF(globs::gameGlobs.textWnd_80,"\nFallin Mode %s",pcVar4);
	}
	res::Container_Hide(globs::gameGlobs.resAmbientLight,FALSE);
	if (globs::gameGlobs.viewMode == VIEW_TOPDOWN) {
		if ((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) {
			res::Container_Hide(globs::gameGlobs.resRootSpotlight,FALSE);
		}
		res::Container_Hide(globs::gameGlobs.resTopSpotlight,FALSE);
		lego::view::Viewport_Clear(globs::gameGlobs.viewMain,TRUE);
		lego::view::Viewport_Render(globs::gameGlobs.viewMain,globs::gameGlobs.resRoot,elapsed);
		res::Container_Hide(globs::gameGlobs.resTopSpotlight,TRUE);
		res::Container_Hide(globs::gameGlobs.resRootSpotlight,TRUE);
	}
	else {
		if (globs::gameGlobs.viewMode == VIEW_FIRSTPERSON) {
			game::WorldMesh_Hide(0);
			FUN_004634f0();
			game::LiveObject_FP_SetRanges
								(globs::gameGlobs.objectFP,(globs::gameGlobs.cameraFP)->resData1,
								 globs::gameGlobs.MedPolyRange,globs::gameGlobs.HighPolyRange,1);
			BVar3 = 1;
			iVar10 = lego::view::Camera_GetField14(globs::gameGlobs.cameraFP);
			game::LiveObject_FUN_0043bae0(globs::gameGlobs.objectFP,iVar10,BVar3);
			game::Game_UpdateSceneFog(TRUE,elapsedGame_00);
			if (((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) &&
				 (res::Container_Hide(globs::gameGlobs.resFPLight,0), globs::gameGlobs.resFPRotLight != NULL
				 )) {
				res::Container_AddRotation
									(globs::gameGlobs.resFPRotLight,D3DRMCOMBINE_AFTER,0.0,1.0,0.0,elapsed * 0.01);
				res::Container_Hide(globs::gameGlobs.resFPRotLight,FALSE);
			}
			lego::view::Viewport_Clear(globs::gameGlobs.viewMain,TRUE);
			lego::view::Viewport_Render(globs::gameGlobs.viewMain,globs::gameGlobs.resRoot,elapsed);
			res::Container_Hide(globs::gameGlobs.resFPLight,TRUE);
			if (globs::gameGlobs.resFPRotLight != NULL) {
				res::Container_Hide(globs::gameGlobs.resFPRotLight,TRUE);
			}
			game::Game_UpdateSceneFog(0,elapsedGame_00);
			BVar3 = 0;
			iVar10 = lego::view::Camera_GetField14(globs::gameGlobs.cameraFP);
			game::LiveObject_FUN_0043bae0(globs::gameGlobs.objectFP,iVar10,BVar3);
			game::LiveObject_FP_SetRanges(globs::gameGlobs.objectFP,NULL,0,0,0);
			game::WorldMesh_FUN_00463800();
			game::WorldMesh_Hide(TRUE);
			game::Level_RemoveAll_ProMeshes();
		}
	}
	res::Container_Hide(globs::gameGlobs.resAmbientLight,1);
	BVar3 = front::Panel_FUN_0045ae20(PANEL_RADAR);
	if (BVar3 == 0) {
		globs::gameGlobs.flags1 &= ~GAME1_RADARON;
	}
	else {
		globs::gameGlobs.flags1 |= GAME1_RADARON;
	}
	if (globs::gameGlobs.viewMode == VIEW_TOPDOWN) {
		game::Game_DrawSelectedUnitBoxes(globs::gameGlobs.viewMain);
		game::Game_DrawRedBoxes_AroundUnitsWithFlags4_1(globs::gameGlobs.viewMain);
		front::Encyclopedia_FUN_0040e800((int)globs::gameGlobs.viewMain);
	}
	game::Level_DrawDragSelectionBox(globs::gameGlobs.level);
	if ((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) {
		front::Bubble_Unk_DrawObjectUIs_FUN_004074d0(elapsed);
	}
	if ((((globs::gameGlobs.flags1 & GAME1_RADARON) != GAME1_NONE) &&
			((globs::gameGlobs.flags1 & GAME1_RADAR_TRACKOBJECTVIEW) != GAME1_NONE)) &&
		 (lego::view::Viewport_Clear(globs::gameGlobs.viewRadar,TRUE),
		 (globs::gameGlobs.flags1 & GAME1_UNK_20000) == GAME1_NONE)) {
		FUN_004290d0(elapsedGame_00,1);
		FUN_00449ec0();
		res::Container_Hide(globs::gameGlobs.resTrackSpotlight,FALSE);
		if (((globs::gameGlobs.cameraFP != NULL) && ((globs::gameGlobs.cameraFP)->resData1 != NULL)) &&
			 (globs::gameGlobs.resFPRotLightDefault != NULL)) {
			res::Container_Hide(globs::gameGlobs.resFPRotLightDefault,TRUE);
		}
		lego::view::Viewport_Render(globs::gameGlobs.viewRadar,globs::gameGlobs.resRoot,elapsed);
		res::Container_Hide(globs::gameGlobs.resTrackSpotlight,TRUE);
		game::Map3D_DoForCoordsAndClear_Mesh_FUN_00474df0((globs::gameGlobs.level)->surfaceMap);
	}
	Main_Finalise3D();
	effect::Smoke_HideAll(TRUE);
	snd::SFX_Update(fVar1);
	if ((globs::gameGlobs.viewMode == VIEW_TOPDOWN) &&
		 ((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE)) {
		game::Level_FUN_00435230
							(globs::gameGlobs.level,globs::gameGlobs.viewMain,elapsedGame_00,elapsed);
		nerps::NERPs_DrawTutorialIcon
							(globs::gameGlobs.level,globs::gameGlobs.viewMain,elapsedGame_00,elapsed);
	}
	game::Map3D_DoForCoordsAndClear_Mesh_FUN_00474df0((globs::gameGlobs.level)->surfaceMap);
	if (((globs::gameGlobs.flags1 & GAME1_RADARON) == GAME1_NONE) ||
		 ((globs::gameGlobs.flags1 & GAME1_RADAR_MAPVIEW) == GAME1_NONE)) {
		iVar10 = 0;
	}
	else {
		iVar10 = 1;
	}
	if (iVar10 != 0) {
		FUN_00426180();
	}
	FUN_0043c570(elapsedGame_00,iVar10);
	if ((globs::gameGlobs.flags1 & GAME1_PANELS) != GAME1_NONE) {
		if ((globs::gameGlobs.flags1 & GAME1_RADARON) == GAME1_NONE) {
			front::Panel_FUN_0045a9f0(PANEL_RADARFILL,elapsed);
		}
		front::Panel_FUN_0045a9f0(PANEL_RADAR,elapsed);
		if ((((globs::gameGlobs.flags1 & GAME1_RADARON) != GAME1_NONE) &&
				((globs::gameGlobs.flags1 & GAME1_RADAR_TRACKOBJECTVIEW) != GAME1_NONE)) &&
			 ((globs::gameGlobs.flags1 & GAME1_UNK_20000) == GAME1_NONE)) {
			front::Panel_FUN_0045a9f0(PANEL_RADAROVERLAY,elapsed);
		}
		front::Panel_FUN_0045a9f0(PANEL_MESSAGESIDE,elapsed);
		front::Panel_FUN_0045a9f0(PANEL_CAMERACONTROL,elapsed);
		front::Panel_FUN_0045a9f0(PANEL_TOPPANEL,elapsed);
		front::Panel_FUN_0045a9f0(PANEL_PRIORITYLIST,elapsed);
		front::PriorityList_Update();
		front::Panel_FUN_0045a9f0(PANEL_ENCYCLOPEDIA,elapsed);
		front::Encyclopedia_FUN_0040e720(elapsed);
		if ((globs::gameGlobs.flags2 & GAME2_INMENU) == GAME2_NONE) {
			front::Interface_FUN_0041b3c0();
		}
		front::Interface_FUN_0041b860(elapsed);
		front::Panel_FUN_0045a9f0(PANEL_CRYSTALSIDEBAR,elapsed);
		fVar8 = elapsed;
		fVar15 = elapsed;
		if (globs::gameGlobs.level != NULL) {
			fVar8 = (float)(globs::gameGlobs.level)->numCrystals;
			fVar15 = (float)((globs::gameGlobs.level)->numCrystals -
											(globs::gameGlobs.level)->numDrainedCrystals);
		}
		FUN_0045c390((uint)fVar8,(uint)fVar15,elapsedGame_00);
		front::Panel_CryOreSidebar_Draw();
		front::Panel_FUN_0045a720(5,globs::gameGlobs.bmpToolTipFont,0x10,0x1d5,1,"%i");
		front::Panel_FUN_0045a9f0(PANEL_INFORMATION,elapsed);
		FUN_00463fe0(0);
		front::Info_FUN_00419fb0(elapsed);
		front::Panel_FUN_0045a9f0(PANEL_INFODOCK,elapsed);
		front::Info_FUN_00419e60(elapsed);
	}
	front::HelpWindow_FUN_00418930();
	BVar3 = game::Objective_Level_IsObjectiveFinished();
	fVar15 = elapsed;
	if (BVar3 != 0) {
		fVar15 = fVar1;
	}
	front::Advisor_Update(fVar15);
	snd::Sound_Update(globs::gameGlobs.flags1 & GAME1_MUSICON);
	if ((globs::gameGlobs.flags1 & GAME1_DEBUG_NONERPS) == GAME1_NONE) {
		nerps::NERPs_Exec__004535e0(elapsed);
	}
	game::Objective_FUN_00458ea0
						(globs::gameGlobs.textWnd_80,globs::gameGlobs.level,elapsedGame_00,fVar1);
	if (globs::mainGlobs.programmerLevel < PROGRAMMER_MODE_2) {
		if (((globs::gameGlobs.level)->MaxStolen != 0.0) &&
			 ((uint)(globs::gameGlobs.level)->MaxStolen <= (uint)(globs::gameGlobs.level)->field_9c)) {
			game::Objective_Level_SetCompleteStatus(LEVELSTATUS_FAILED_CRYSTALS);
		}
		iVar10 = game::LiveObject_GetOrSubLevelsTable(OBJECT_PATH,0,0,1);
		if (iVar10 == 0) {
			uVar9 = 0;
			iVar11 = 0;
			iVar10 = game::Object_GetLevels(OBJECT_MINIFIGURE,0);
			if (iVar10 != 0) {
				do {
					iVar10 = game::LiveObject_GetOrSubLevelsTable(OBJECT_MINIFIGURE,0,uVar9,1);
					iVar11 += iVar10;
					uVar9 += 1;
					uVar5 = game::Object_GetLevels(OBJECT_MINIFIGURE,0);
				} while (uVar9 < uVar5);
			}
			if ((iVar11 == 0) && (level = game::GetLevel(), level->status == LEVELSTATUS_NONE)) {
				game::Objective_Level_SetCompleteStatus(LEVELSTATUS_FAILED);
			}
		}
	}
	front::Text_Update(elapsed);
	if (((globs::gameGlobs.flags2 & GAME2_MENU_HASNEXT) != GAME2_NONE) &&
		 (globs::gameGlobs.NextButton != NULL)) {
		lego::image::Image_DisplayScaled
							(globs::gameGlobs.NextButton,NULL,&globs::gameGlobs.menuNextPoint,NULL);
	}
	if (((globs::gameGlobs.flags2 & GAME2_MENU_HASPREVIOUS) != GAME2_NONE) &&
		 (globs::gameGlobs.BackArrow != NULL)) {
		lego::image::Image_DisplayScaled
							(globs::gameGlobs.BackArrow,NULL,&globs::gameGlobs.menuPrevPoint,NULL);
	}
	if ((((globs::gameGlobs.flags2 & GAME2_UNK_40) != GAME2_NONE) &&
			(globs::gameGlobs.NextButton != NULL)) &&
		 (((globs::gameGlobs.flags2 & GAME2_CAMERAMOVING) == GAME2_NONE ||
			(BVar3 = front::Interface_GetBool_004ded1c(), BVar3 != 0)))) {
		lego::image::Image_DisplayScaled
							(globs::gameGlobs.NextButton,NULL,&globs::gameGlobs.NextButtonPos,NULL);
	}
	if (((globs::gameGlobs.flags2 & GAME2_UNK_80) != GAME2_NONE) &&
		 (globs::gameGlobs.BackButton != NULL)) {
		lego::image::Image_DisplayScaled
							(globs::gameGlobs.BackButton,NULL,&globs::gameGlobs.BackButtonPos,NULL);
	}
	if ((((globs::gameGlobs.flags2 & GAME2_INOPTIONSMENU) != GAME2_NONE) &&
			(BVar3 = Config_IsFrontEndEnabled(), BVar3 != 0)) &&
		 (BVar3 = FUN_004152a0(elapsed,1), BVar3 != 0)) {
		globs::gameGlobs.flags2 &= ~GAME2_INOPTIONSMENU;
		BVar3 = game::Objective_Level_IsObjectiveFinished();
		if (BVar3 == 0) {
			game::Game_SetPaused(0,0);
		}
		else {
			globs::gameGlobs.flags1 |= GAME1_PAUSED;
		}
	}
	game::Game_RenameInputUnk(fVar1);
	if ((globs::gameGlobs.flags1 & GAME1_PAUSED) == GAME1_NONE) {
		front::Pointer_SubUnkFloat_IfGreaterThan0(fVar1);
		if (globs::gameGlobs.renameInput == NULL) goto LAB_00423e04;
	}
	else {
		BVar3 = Config_IsFrontEndEnabled();
		if ((BVar3 == 0) || (BVar3 = FUN_004152a0(elapsed,0), BVar3 == 0)) {
			front::Pointer_SubUnkFloat_IfGreaterThan0(fVar1);
LAB_00423e04:
			front::Pointer_DrawPointer(globs::INPUT.msx,globs::INPUT.msy);
		}
		else {
			globs::gameGlobs.flags1 ^= GAME1_PAUSED;
			BVar3 = front::Front_IsTriggerMissionQuit();
			if (BVar3 == 0) {
				BVar3 = game::Objective_Level_IsObjectiveFinished();
				if (BVar3 == 0) {
					game::Game_SetPaused(0,0);
				}
			}
			else {
				game::LRR_SetLoadFlag_Unk();
				level = game::GetLevel();
				level->status = LEVELSTATUS_FAILED_CRYSTALS;
				unk::lego::reward::Reward_UnkLevelImportantPilot_FUN_004604e0();
				if ((globs::gameGlobs.flags1 & GAME1_MUSICON) != GAME1_NONE) {
					globs::gameGlobs.flags2 |= GAME2_MUSICON;
					snd::Music_PlayNext(FALSE);
				}
			}
		}
	}
	BVar3 = front::Front_IsTriggerMissionRestart();
	if ((BVar3 == 1) || (globs::mainGlobs.programmerLevel == PROGRAMMER_MODE_11)) {
		debug::Debug_ProgrammerMode11_LoadLevel();
	}
	if ((globs::gameGlobs.flags1 & GAME1_UNK_20000000) != GAME1_NONE) {
		pcVar4 = "Vertex";
		if ((globs::gameGlobs.flags1 & GAME1_UNK_40000) == GAME1_NONE) {
			pcVar4 = "Block";
		}
		lego::image::Font_PrintF(globs::gameGlobs.bmpDeskTopFont,10,10,"%s mode",pcVar4);
	}
	if (((globs::gameGlobs.flags1 & GAME1_UNK_40000) != GAME1_NONE) && (globs::gameGlobs.bool_c8 != 0)
		 ) {
		game::Map3D_FUN_00450320
							((globs::gameGlobs.level)->surfaceMap,globs::gameGlobs.pointi_c0.x,
							 globs::gameGlobs.pointi_c0.y,&local_c);
		lego::view::Viewport_Transform(globs::gameGlobs.viewMain,&local_28,&local_c);
		local_28.x = local_28.x / local_28.w;
		local_28.y = local_28.y / local_28.w;
		front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_DRILL);
		lVar13 = __ftol((float10)local_28.y);
		uVar9 = (uint)lVar13;
		lVar13 = __ftol((float10)local_28.x);
		front::Pointer_DrawPointer((uint)lVar13,uVar9);
		globs::gameGlobs.flags1 &= ~GAME1_UNK_80000000;
	}
	front::ToolTip_Update(globs::INPUT.msx,globs::INPUT.msy,fVar1);
	if ((globs::gameGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
										// IsKeyPressed(KEY_FIVE) (6)
										//  "Set selected unit model to first upgrade code."
										// IsKeyPressed(KEY_SIX)   (7)
										//  "Set selected unit model to second upgrade code."
										// IsKeyPressed(KEY_SEVEN) (8)
										//  "Set selected unit model to third upgrade code."
										// IsKeyPressed(KEY_EIGHT) (9)
										//  "Set selected unit model to fourth upgrade code."
		if (((((globs::INPUT.Key_Map[6] != false) &&
					(globs::INPUT.prevKey_Map[6] != globs::INPUT.Key_Map[6])) ||
				 ((globs::INPUT.Key_Map[7] != false &&
					(globs::INPUT.prevKey_Map[7] != globs::INPUT.Key_Map[7])))) ||
				((globs::INPUT.Key_Map[8] != false &&
				 (globs::INPUT.prevKey_Map[8] != globs::INPUT.Key_Map[8])))) ||
			 ((globs::INPUT.Key_Map[9] != false &&
				(globs::INPUT.prevKey_Map[9] != globs::INPUT.Key_Map[9])))) {
			globals::g_UpgradeChangeTimer = 1.0;
		}
		if ((ushort)((ushort)(globals::g_UpgradeChangeTimer < 0.0) << 8 |
								(ushort)(globals::g_UpgradeChangeTimer == 0.0) << 0xe) == 0) {
			ppLVar6 = game::Message_GetSelectedUnits((uint *)&local_28);
			if (local_28.x != 0.0) {
				pLVar2 = *ppLVar6;
				if (pLVar2->objType == OBJECT_BUILDING) {
					pOVar7 = &pLVar2->building->upgrades;
				}
				else {
					if (pLVar2->objType == OBJECT_VEHICLE) {
						pOVar7 = &pLVar2->vehicle->upgrades;
					}
					else {
						pOVar7 = NULL;
					}
				}
				if (pOVar7 != NULL) {
					uVar9 = pOVar7->currentLevel;
					uVar14 = CONCAT44(uVar9,uVar9 >> 1) & 0x100000001;
					lego::image::Font_PrintF
										(globs::gameGlobs.bmpFONT5_HI,0,0,"Upgrade - (%i%i%i%i)",uVar9 >> 3 & 1,
										 uVar9 >> 2 & 1,(uint)uVar14,(uint)(uVar14 >> 0x20));
				}
			}
			globals::g_UpgradeChangeTimer = globals::g_UpgradeChangeTimer - 0.1;
		}
	}
	if (globals::g_DripSFXTimer < 0.0) {
		snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_DRIP,0);
		fVar12 = math::Maths_RandRange(75.0,125.0);
		globals::g_DripSFXTimer = (float)fVar12;
	}
	if (globals::g_AmbientSFXTimer < 0.0) {
		snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_AMBIENT,0);
		fVar12 = math::Maths_RandRange(250.0,750.0);
		globals::g_AmbientSFXTimer = (float)fVar12;
	}
	globals::g_DripSFXTimer = globals::g_DripSFXTimer - elapsed;
	globals::g_AmbientSFXTimer = globals::g_AmbientSFXTimer - elapsed;
	if ((globs::gameGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
										// IsKeyUp(KEYPAD_9) (73)
		if (globs::INPUT.Key_Map[73] == false) {
			local_34 = -1.0;
										// IsKeyUp(KEYPAD_8) (72)
			if (globs::INPUT.Key_Map[72] == false) {
				local_34 = 0.0;
			}
		}
		else {
			local_34 = 1.0;
		}
		if (local_34 != 0.0) {
			globals::g_SpeedChangeTimer = 25.0;
			fVar12 = game::Game_GetGameSpeed();
			game::Game_SetGameSpeed
								((float)((float10)local_34 * (float10)elapsed * (float10)0.01 + fVar12));
			fVar12 = game::Game_GetGameSpeed();
			if ((ushort)((ushort)(fVar12 < (float10)3.0) << 8 | (ushort)(fVar12 == (float10)3.0) << 0xe)
					== 0) {
				game::Game_SetGameSpeed(3.0);
			}
			fVar12 = game::Game_GetGameSpeed();
			if (fVar12 < (float10)0.0) {
				game::Game_SetGameSpeed(0.0);
			}
		}
		if ((ushort)((ushort)(globals::g_SpeedChangeTimer < 0.0) << 8 |
								(ushort)(globals::g_SpeedChangeTimer == 0.0) << 0xe) == 0) {
			fVar12 = game::Game_GetGameSpeed();
			lego::image::Font_PrintF
								(globs::gameGlobs.bmpFONT5_HI,10,0x50,"Game Speed %0.0f%%",
								 (double)(fVar12 * (float10)100.0));
		}
		globals::g_SpeedChangeTimer = globals::g_SpeedChangeTimer - elapsed;
	}
	if ((globs::gameGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) == GAME2_NONE) goto LAB_0042427c;
	if (globals::g_DebugRollOffFactor_Value == -1.0) {
		fVar12 = snd::Sound3D_SetRollOffFactor(-1.0);
		globals::g_DebugRollOffFactor_Value = (float)fVar12;
	}
	if (globs::INPUT.Key_Map[10] == false) {
		if (globs::INPUT.Key_Map[11] != false) {
			globals::g_DebugRollOffFactor_Value = globals::g_DebugRollOffFactor_Value - -0.05;
			goto LAB_0042421e;
		}
	}
	else {
		globals::g_DebugRollOffFactor_Value = globals::g_DebugRollOffFactor_Value - 0.05;
LAB_0042421e:
		fVar12 = snd::Sound3D_SetRollOffFactor(globals::g_DebugRollOffFactor_Value);
		globals::g_DebugRollOffFactor_Value = (float)fVar12;
		globals::g_RollOffChangeTimer = 25.0;
	}
	if ((ushort)((ushort)(globals::g_RollOffChangeTimer < 0.0) << 8 |
							(ushort)(globals::g_RollOffChangeTimer == 0.0) << 0xe) == 0) {
		lego::image::Font_PrintF
							(globs::gameGlobs.bmpFONT5_HI,10,0x50,"3D sound fall off: %f",
							 (double)globals::g_DebugRollOffFactor_Value);
	}
	globals::g_RollOffChangeTimer = globals::g_RollOffChangeTimer - elapsed;
LAB_0042427c:
	if ((globs::gameGlobs.flags1 & GAME1_DEBUG_NONERPS) == GAME1_NONE) {
		nerps::NERPs_FUN_00453e70(elapsed);
	}
	else {
		lego::image::Font_PrintF(globs::gameGlobs.bmpFONT5_HI,0,0,"NoNERPS");
	}
	if ((ushort)((ushort)((globs::gameGlobs.level)->oxygenLevel < 0.0) << 8 |
							(ushort)((globs::gameGlobs.level)->oxygenLevel == 0.0) << 0xe) == 0) {
		fVar1 = (globs::gameGlobs.level)->oxygenLevel;
		if ((globs::gameGlobs.level)->float_204 - 5.0 <= (globs::gameGlobs.level)->oxygenLevel) {
			if ((ushort)((ushort)(fVar1 < (globs::gameGlobs.level)->float_204) << 8 |
									(ushort)(fVar1 == (globs::gameGlobs.level)->float_204) << 0xe) == 0) {
				if ((undefined *)(globs::gameGlobs.level)->oxygenLevel == &DAT_42c80000) {
					front::Info_FUN_00419ab0(INFO_AIRRESTORED,NULL,NULL,NULL);
				}
				(globs::gameGlobs.level)->float_204 = (globs::gameGlobs.level)->oxygenLevel;
			}
		}
		else {
			if ((ushort)((ushort)(fVar1 < 10.0) << 8 | (ushort)(fVar1 == 10.0) << 0xe) == 0) {
				front::Info_FUN_00419ab0(INFO_AIRDEPLETING,NULL,NULL,NULL);
				textType = TEXT_AIRSUPPLYRUNNINGOUT;
			}
			else {
				front::Info_FUN_00419ab0(INFO_AIRLOW,NULL,NULL,NULL);
				textType = TEXT_AIRSUPPLYLOW;
			}
			front::Text_DisplayMessage(textType,1,0);
			(globs::gameGlobs.level)->float_204 = (globs::gameGlobs.level)->oxygenLevel;
		}
	}
	else {
		front::Info_FUN_00419ab0(INFO_AIROUT,NULL,NULL,NULL);
	}
	if ((ushort)((ushort)((globs::gameGlobs.level)->oxygenLevel < 10.0) << 8 |
							(ushort)((globs::gameGlobs.level)->oxygenLevel == 10.0) << 0xe) == 0) {
		if ((globals::g_AirMeter_BeatUnkBool != 0) &&
			 (BVar3 = snd::SFX_GetType("SND_AirBeat",&local_30), BVar3 != 0)) {
			iVar10 = snd::SFX_Sample_Random_GetSoundHandle(local_30);
			snd::SFX_Sample_Sound3D_StopSound(iVar10);
		}
		BVar3 = 0;
	}
	else {
		if ((globals::g_AirMeter_BeatUnkBool == 0) &&
			 (BVar3 = snd::SFX_GetType("SND_AirBeat",&local_30), BVar3 != 0)) {
			snd::SFX_Sample_Random_Play_OrAddToQueue(local_30,1);
		}
		BVar3 = snd::SFX_GetType("SND_AirBeat",&local_30);
		if (BVar3 != 0) {
			iVar10 = snd::Sound3D_MinVolume();
			lVar13 = __ftol((float10)(globs::gameGlobs.level)->oxygenLevel * (float10)0.1 *
											(float10)iVar10 * (float10)0.1);
			iVar10 = snd::SFX_Sample_Random_GetBufferVolume(local_30);
			if ((int)lVar13 != iVar10) {
				snd::SFX_Sample_Random_SetBufferVolume(local_30,(int)lVar13);
			}
		}
		BVar3 = 1;
	}
	front::AirMeter_SetAirBeat_UnkBool(BVar3);
	globs::gameGlobs.timerGame_e3c = globs::gameGlobs.timerGame_e3c - elapsedGame;
	return TRUE;
}



void __cdecl lego::game::LiveObject_ConsumeOxygen(LiveObject *liveObj,float elapsed)
{
	LevelData *pLVar1;
	float10 fVar2;
	
	pLVar1 = globs::gameGlobs.level;
	fVar2 = LiveObject_GetOxygenCoef(liveObj);
	if ((liveObj->objType != OBJECT_BUILDING) ||
		 ((liveObj->flags3 & LIVEOBJ3_HASPOWER) != LIVEOBJ3_NONE)) {
		fVar2 = (float10)elapsed * (float10)0.04 * (float10)pLVar1->OxygenRate * fVar2 +
						(float10)pLVar1->oxygenLevel;
		pLVar1->oxygenLevel = (float)fVar2;
		if ((ushort)((ushort)(fVar2 < (float10)100.0) << 8 | (ushort)(fVar2 == (float10)100.0) << 0xe)
				== 0) {
			pLVar1->oxygenLevel = (float)&DAT_42c80000;
		}
		if (((ushort)((ushort)(pLVar1->oxygenLevel < 0.0) << 8 |
								 (ushort)(pLVar1->oxygenLevel == 0.0) << 0xe) != 0) &&
			 (pLVar1->oxygenLevel = 0.0, (globs::gameGlobs.flags1 & GAME1_UNK_8000000) == GAME1_NONE)) {
			Objective_Level_SetCompleteStatus(LEVELSTATUS_FAILED);
			return;
		}
	}
	return;
}



void __cdecl lego::game::Level_FUN_00424530(LevelData *level,float elapsedGame)
{
	LevelBlockFlags1 *pLVar1;
	uint uVar2;
	int iVar3;
	uint uVar4;
	int local_14;
	int local_10;
	int local_c;
	Point2I local_8;
	
	uVar2 = lego::effect::Effect_MiscObjectUpdateUnk_FUN_0040c2d0(elapsedGame,&local_c,&local_10);
	uVar4 = 0;
	if (uVar2 != 0) {
		do {
			lego::effect::Effect_GetXY_RockFall
								(*(int *)(local_c + uVar4 * 4),*(int *)(local_10 + uVar4 * 4),&local_14,
								 (int *)&elapsedGame);
			local_8.x = local_14;
			local_8.y = (int)elapsedGame;
			iVar3 = ((globs::gameGlobs.level)->dimensions).width * (int)elapsedGame + local_14;
			(globs::gameGlobs.level)->blocks[iVar3].flags1 =
					 (globs::gameGlobs.level)->blocks[iVar3].flags1 & ~BLOCK1_UNK_800;
			if (((globs::gameGlobs.level)->blocks
					 [((globs::gameGlobs.level)->dimensions).width * (int)elapsedGame + local_14].flags1 &
					BLOCK1_UNK_1000) == BLOCK1_NONE) {
				Message_AddMessageAction(MESSAGE_ROCKFALL_COMPLETE,0,0,&local_8);
			}
			iVar3 = ((globs::gameGlobs.level)->dimensions).width * (int)elapsedGame + local_14;
			(globs::gameGlobs.level)->blocks[iVar3].flags1 =
					 (globs::gameGlobs.level)->blocks[iVar3].flags1 & ~BLOCK1_UNK_1000;
			pLVar1 = &(globs::gameGlobs.level)->blocks
								[((globs::gameGlobs.level)->dimensions).width * local_8.y + local_8.x].flags1;
			uVar4 += 1;
			*pLVar1 = *pLVar1 & ~BLOCK1_UNK_8000000;
		} while (uVar4 < uVar2);
	}
	return;
}



void __cdecl lego::game::Game_UpdateSceneFog(BOOL isFogEnabled,float elapsed)
{
	uint uVar1;
	uint uVar2;
	float10 fVar3;
	float10 fVar4;
	ColourRGBF local_c;
	
	if ((globs::gameGlobs.flags1 & GAME1_FOGCOLOURRGB) != GAME1_NONE) {
		res::Container_EnableFog(isFogEnabled);
		if ((isFogEnabled != 0) && ((globs::gameGlobs.flags1 & GAME1_HIGHFOGCOLOURRGB) != GAME1_NONE)) {
			fVar3 = ((float10)6.283185 / (float10)globs::gameGlobs.FogRate) * (float10)elapsed +
							(float10)FLOAT_004df53c;
			FLOAT_004df53c = (float)fVar3;
			fVar3 = (float10)fsin(fVar3);
			uVar1 = 0;
			do {
				uVar2 = uVar1 + 4;
				fVar4 = ((float10)*(float *)((int)globs::gameGlobs.objTeleportQueueTypes_TABLE +
																		(uVar1 - 0x5c)) -
								(float10)*(float *)((int)globs::gameGlobs.recordObjs + uVar1 + 0x54)) * (float10)0.5
				;
				*(float *)((int)&local_c.red + uVar1) =
						 (float)(fVar4 + (float10)*(float *)((int)globs::gameGlobs.recordObjs + uVar1 + 0x54) +
										fVar4 * fVar3);
				uVar1 = uVar2;
			} while (uVar2 < 0xc);
			res::Container_SetFogColour(local_c.red,local_c.green,local_c.blue);
		}
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_Callback_DrawRedBox_IfFlags4_1(LiveObject *liveObj,Viewport *viewMain)
{
	if ((liveObj->flags4 & LIVEOBJ4_UNK_1) != LIVEOBJ4_NONE) {
		LiveObject_DrawSelectedBox(liveObj,viewMain,1.0,0.0,0.0);
	}
	return 0;
}



BOOL __cdecl lego::game::Game_DrawRedBoxes_AroundUnitsWithFlags4_1(Viewport *viewMain)
{
	BOOL BVar1;
	
	BVar1 = Search_LiveObjects_SkipIgnoreMes
										(LiveObject_Callback_DrawRedBox_IfFlags4_1,(undefined4 *)viewMain);
	return BVar1;
}



void __cdecl lego::game::Game_DrawSelectedUnitBoxes(Viewport *viewMain)
{
	uint uVar1;
	LiveObject **ppLVar2;
	uint index;
	
	uVar1 = Message_GetNumSelectedUnits();
	ppLVar2 = Message_GetSelectedUnits();
	for (index = 0; index < uVar1; index += 1) {
		if (index == 0) {
										// Primary selected unit has a green box
			LiveObject_DrawSelectedBox(*ppLVar2,viewMain,0.0,1.0,0.0);
		}
		else {
										// All remaining selected units have a yellow box
			LiveObject_DrawSelectedBox(ppLVar2[index],viewMain,1.0,1.0,0.0);
		}
	}
	return;
}



void __cdecl
lego::game::LiveObject_DrawSelectedBox
					(LiveObject *liveObj,Viewport *param_2,float r,float g,float b)
{
	float fVar1;
	BOOL BVar2;
	SurfaceMap *surfMap;
	int iVar3;
	uint uVar4;
	float10 fVar5;
	longlong lVar6;
	char *msg;
	Point2F linePts1 [8];
	Vector3F local_a8;
	Vector3F local_9c;
	Point2F linePts2 [8];
	Vector3F local_4c;
	Point2F local_40 [2];
	Vector4F local_30;
	Vector3F local_20;
	Vector3F local_14;
	float local_8;
	
	local_4c.x = 0.0;
	local_4c.y = 1.0;
	local_4c.z = 0.0;
	BVar2 = LiveObject_IsHidden(liveObj);
	if (BVar2 == 0) {
		if ((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) != GAME1_NONE) {
			r = r * 0.3;
			g = g * 0.3;
			b = b * 0.3;
		}
		LiveObject_GetPosition(liveObj,(float *)&local_a8,&local_a8.y);
		surfMap = GetSurfaceMap();
		fVar5 = Map3D_GetWorldZ(surfMap,local_a8.x,local_a8.y);
		local_a8.z = (float)fVar5;
		fVar5 = LiveObject_GetCollHeight(liveObj);
		local_a8.z = (float)((float10)local_a8.z - fVar5 / (float10)2.0);
		lego::view::Viewport_WorldToScreen(param_2,(Point2F *)&local_30,&local_a8);
		if ((0.0 <= local_30.x) && (0.0 <= local_30.y)) {
			iVar3 = main::appWidth();
			if (local_30.x <= (float)iVar3) {
				iVar3 = main::appHeight();
				if (local_30.y <= (float)iVar3) {
					local_30.z = 0.0;
					local_30.w = 1.0;
					lego::view::Viewport_InverseTransform(param_2,&local_9c,&local_30);
					math::Maths_Vector3DSubtract(&local_14,&local_a8,&local_9c);
					math::Maths_Vector3DNormalize(&local_14);
					math::Maths_Vector3DCrossProduct(&local_20,&local_14,&local_4c);
					math::Maths_Vector3DNormalize(&local_20);
					fVar5 = LiveObject_GetPickSphere(liveObj);
					math::Maths_Vector3DScale(&local_20,&local_20,(float)fVar5);
					math::Maths_Vector3DAdd(&local_a8,&local_a8,&local_20);
					lego::view::Viewport_WorldToScreen(param_2,local_40,&local_a8);
					fVar5 = math::Maths_Vector2DDistance((Point2F *)&local_30,local_40);
					fVar1 = (float)(fVar5 / (float10)2.5);
					local_8 = (float)((fVar5 / (float10)2.5) / (float10)5.0 + (float10)3.0);
					linePts1[0].x = local_30.x - fVar1;
					linePts1[0].y = (local_30.y - fVar1) + local_8;
					linePts2[0].x = local_30.x - fVar1;
					linePts2[0].y = local_30.y - fVar1;
					linePts1[1].x = (local_30.x - fVar1) + 1.0;
					linePts1[1].y = local_30.y - fVar1;
					linePts2[1].x = (local_30.x - fVar1) + local_8;
					linePts2[1].y = local_30.y - fVar1;
					linePts1[2].x = (local_30.x + fVar1) - local_8;
					linePts1[2].y = local_30.y - fVar1;
					linePts2[2].x = local_30.x + fVar1;
					linePts2[2].y = local_30.y - fVar1;
					linePts1[3].x = local_30.x + fVar1;
					linePts1[3].y = (local_30.y - fVar1) + 1.0;
					linePts2[3].x = local_30.x + fVar1;
					linePts2[3].y = (local_30.y - fVar1) + local_8;
					linePts1[4].x = local_30.x + fVar1;
					linePts1[4].y = (local_30.y + fVar1) - local_8;
					linePts2[4].x = local_30.x + fVar1;
					linePts2[4].y = local_30.y + fVar1;
					linePts1[5].x = (local_30.x + fVar1) - 1.0;
					linePts1[5].y = local_30.y + fVar1;
					linePts2[5].x = (local_30.x + fVar1) - local_8;
					linePts2[5].y = local_30.y + fVar1;
					linePts1[6].x = (local_30.x - fVar1) + local_8;
					linePts1[6].y = local_30.y + fVar1;
					linePts2[6].x = local_30.x - fVar1;
					linePts2[6].y = local_30.y + fVar1;
					linePts1[7].x = local_30.x - fVar1;
					linePts1[7].y = (local_30.y + fVar1) - 1.0;
					linePts2[7].x = local_30.x - fVar1;
					linePts2[7].y = (local_30.y + fVar1) - local_8;
					draw::Draw_LineListEx(linePts1,linePts2,8,r,g,b,DRAWEFFECT_NONE);
					if ((((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) &&
							(liveObj->customName != NULL)) && (*liveObj->customName != '\0')) {
						msg = liveObj->customName;
						lVar6 = __ftol((float10)local_30.y - (float10)fVar1);
						uVar4 = lego::image::Font_GetHeight(globs::gameGlobs.bmpToolTipFont);
						iVar3 = (int)lVar6 - uVar4;
						lVar6 = __ftol((float10)local_30.x - (float10)fVar1);
						lego::image::Font_PrintF(globs::gameGlobs.bmpToolTipFont,(int)lVar6,iVar3,msg);
					}
				}
			}
		}
	}
	return;
}



void __cdecl lego::main::LRR_Exit(void)
{
	Game_Exit();
	return;
}



// This is only called as a ProgrammerMode_10 setting,
//  where proper cleanup is performed.

void __cdecl lego::main::LRR_Shutdown(void)
{
	BOOL BVar1;
	char *filename;
	uint uVar2;
	char *unaff_EDI;
	int iVar3;
	
	front::Loader_display_shutdown();
	reward::Reward_CleanupBase();
	snd::Music_PlayNext(0);
	snd::SFX_SetSoundEnabled(0);
	game::Level_Free();
	front::Interface_FreeInterfaceIcons();
	cfg::CFG_Close(globs::gameGlobs.LegoCfgRoot);
	lego::view::Viewport_Remove(globs::gameGlobs.viewMain);
	res::Container_Remove(globs::gameGlobs.resRoot);
	lego::view::Camera_Free(globs::gameGlobs.cameraMain);
	lego::view::Camera_Free(globs::gameGlobs.cameraRadar);
	lego::view::Camera_Free(globs::gameGlobs.cameraFP);
	uVar2 = 0;
	if (globs::gameGlobs.VehicleTypes_COUNT != 0) {
		iVar3 = 0;
		do {
			res::Vehicle_Destroy
								((VehicleData *)
								 ((int)(globs::gameGlobs.VehicleData_TABLE)->WheelMeshes + iVar3 + -0x10));
			std::free(globs::gameGlobs.VehicleTypes_TABLE[uVar2]);
			uVar2 += 1;
			iVar3 += 0x1ec;
		} while (uVar2 < globs::gameGlobs.VehicleTypes_COUNT);
	}
	std::free(globs::gameGlobs.VehicleTypes_TABLE);
	std::free(globs::gameGlobs.ObjectNames_VehicleTypes_TABLE);
	std::free(globs::gameGlobs.VehicleData_TABLE);
	uVar2 = 0;
	if (globs::gameGlobs.MiniFigureTypes_COUNT != 0) {
		iVar3 = 0;
		do {
			res::Creature_Destroy
								((CreatureData *)
								 ((int)(globs::gameGlobs.MiniFigureData_TABLE)->cameraFramesTable_54 + iVar3 + -0x54
								 ));
			std::free(globs::gameGlobs.MiniFigureTypes_TABLE[uVar2]);
			uVar2 += 1;
			iVar3 += 0x74;
		} while (uVar2 < globs::gameGlobs.MiniFigureTypes_COUNT);
	}
	std::free(globs::gameGlobs.MiniFigureTypes_TABLE);
	std::free(globs::gameGlobs.ObjectNames_MiniFigureTypes_TABLE);
	std::free(globs::gameGlobs.MiniFigureData_TABLE);
	uVar2 = 0;
	if (globs::gameGlobs.RockMonsterTypes_COUNT != 0) {
		iVar3 = 0;
		do {
			res::Creature_Destroy
								((CreatureData *)
								 ((int)(globs::gameGlobs.RockMonsterData_TABLE)->cameraFramesTable_54 +
								 iVar3 + -0x54));
			std::free(globs::gameGlobs.RockMonsterTypes_TABLE[uVar2]);
			uVar2 += 1;
			iVar3 += 0x74;
		} while (uVar2 < globs::gameGlobs.RockMonsterTypes_COUNT);
	}
	std::free(globs::gameGlobs.RockMonsterTypes_TABLE);
	std::free(globs::gameGlobs.ObjectNames_RockMonsterTypes_TABLE);
	std::free(globs::gameGlobs.RockMonsterData_TABLE);
	uVar2 = 0;
	if (globs::gameGlobs.UpgradeTypes_COUNT != 0) {
		iVar3 = 0;
		do {
			res::Upgrade_Destroy
								((UpgradeData *)((int)&(globs::gameGlobs.UpgradeData_TABLE)->objectIndex + iVar3));
			std::free(globs::gameGlobs.UpgradeTypes_TABLE[uVar2]);
			uVar2 += 1;
			iVar3 += 0x10;
		} while (uVar2 < globs::gameGlobs.UpgradeTypes_COUNT);
	}
	std::free(globs::gameGlobs.UpgradeTypes_TABLE);
	std::free(globs::gameGlobs.ObjectNames_UpgradeTypes_TABLE);
	std::free(globs::gameGlobs.UpgradeData_TABLE);
	uVar2 = 0;
	if (globs::gameGlobs.BuildingTypes_COUNT != 0) {
		iVar3 = 0;
		do {
			res::Building_Destroy
								((BuildingData *)
								 ((int)(globs::gameGlobs.BuildingData_TABLE)->carryFramesTable_28 + iVar3 + -0x28));
			std::free(globs::gameGlobs.BuildingTypes_TABLE[uVar2]);
			uVar2 += 1;
			iVar3 += 0x14c;
		} while (uVar2 < globs::gameGlobs.BuildingTypes_COUNT);
	}
	std::free(globs::gameGlobs.BuildingTypes_TABLE);
	std::free(globs::gameGlobs.ObjectNames_BuildingTypes_TABLE);
	std::free(globs::gameGlobs.BuildingData_TABLE);
	std::free(globs::gameGlobs.ObjectNames_PowerCrystal);
	std::free(globs::gameGlobs.ObjectNames_Ore);
	std::free(globs::gameGlobs.ObjectNames_ProcessedOre);
	std::free(globs::gameGlobs.ObjectNames_Dynamite);
	std::free(globs::gameGlobs.ObjectNames_Barrier);
	std::free(globs::gameGlobs.ObjectNames_ElectricFence);
	std::free(globs::gameGlobs.ObjectNames_SpiderWeb);
	std::free(globs::gameGlobs.ObjectNames_OohScary);
	std::free(globs::gameGlobs.ObjectNames_Path);
	front::TextWindow_Remove(globs::gameGlobs.textWnd_80);
	lego::image::Font_Remove(globs::gameGlobs.bmpFONT5_HI);
	lego::image::Font_Remove(globs::gameGlobs.bmpToolTipFont);
	effect::Effect_RemoveAll_RockFall();
	ai::AITask_Shutdown();
	pool::ReservedPool_LiveObject___Cleanup();
	res::Container_Shutdown();
	lego::view::Viewport_Shutdown();
	if (globs::mainGlobs.programmerLevel == PROGRAMMER_MODE_10) {
		BVar1 = snd::Sound_IsInitialised();
		filename = "LoaderProfile.txt";
		if (BVar1 == 0) {
			filename = "LoaderProfileNoSound.txt";
		}
	}
	else {
		filename = NULL;
	}
	front::Loader_Shutdown(filename);
	util::logf_removed(unaff_EDI);
	lego::image::Image_Shutdown();
	res::Lws_Shutdown();
	snd::Sound3D_ShutDown();
	ddraw::DirectDraw_Clear(NULL,0);
	return;
}



void __cdecl lego::main::Game_Exit(void)
{
	snd::Music_PlayNext(0);
	std::exit(0);
	return;
}



BOOL __cdecl
lego::game::Game_DoHotkeyChecks
					(float elapsedGame,float param_2,BOOL *out_t,BOOL *put_r,BOOL *out_shift)
{
	LiveObject *pLVar1;
	Container *cont;
	BOOL BVar2;
	TutorialFlags TVar3;
	char *pcVar4;
	int iVar5;
	BOOL3 BVar6;
	int iVar7;
	bool bVar8;
	float10 fVar9;
	ActivityType actType;
	undefined4 unkbool2d8;
	Point2F local_14;
	Vector3F local_c;
	
										// IsKeyReleased(KEY_RETURN) (28)
										//  "Submit unit rename input."
	if ((((((globs::gameGlobs.flags2 & GAME2_ALLOWRENAME) != GAME2_NONE) &&
				(globs::INPUT.Key_Map[28] == false)) && (globs::INPUT.prevKey_Map[28] != false)) &&
			(((globs::gameGlobs.viewMode == VIEW_TOPDOWN &&
				((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE)) &&
			 ((pLVar1 = Message_GetPrimarySelectedUnit(), pLVar1 != NULL &&
				(pLVar1->objType == OBJECT_MINIFIGURE)))))) &&
		 ((pLVar1->flags5_3f0 != LIVEOBJ5_NONE || (pLVar1->objLevel != 0)))) {
		cont = LiveObject_GetContainer(pLVar1);
		res::Container_GetPosition(cont,NULL,&local_c);
		fVar9 = LiveObject_GetCollHeight(pLVar1);
		local_c.z = (float)((float10)local_c.z - fVar9 * (float10)0.5);
		lego::view::Viewport_WorldToScreen(globs::gameGlobs.viewMain,&local_14,&local_c);
		if ((40.0 <= local_14.x) &&
			 (((40.0 <= local_14.y &&
				 ((ushort)((ushort)(local_14.x < (float)globs::mainGlobs.appWidth - 40.0) << 8 |
									(ushort)(local_14.x == (float)globs::mainGlobs.appWidth - 40.0) << 0xe) != 0)) &&
				((ushort)((ushort)(local_14.y < (float)globs::mainGlobs.appHeight - 80.0) << 8 |
								 (ushort)(local_14.y == (float)globs::mainGlobs.appHeight - 80.0) << 0xe) != 0)))) {
			Game_SetPaused(FALSE,TRUE);
			if (pLVar1->customName == NULL) {
				LiveObject_SetCustomName(pLVar1,"Object");
				*pLVar1->customName = '\0';
			}
			globs::gameGlobs.renameInput = pLVar1->customName;
			globs::gameGlobs.renamePosition.x = local_14.x;
			globs::gameGlobs.renamePosition.y = local_14.y;
		}
	}
										// IsKeyDown(KEY_ESCAPE) (1)
	if (globs::INPUT.Key_Map[1] != false) {
		if ((((globs::gameGlobs.flags2 & GAME2_INOPTIONSMENU) == GAME2_NONE) &&
				(BVar2 = front::HelpWindow_FUN_004190d0(), BVar2 == 0)) &&
			 ((BVar2 = Objective_Level_IsObjectiveFinished(), BVar2 == 0 &&
				((globs::gameGlobs.flags1 & GAME1_UNK_8000000) == GAME1_NONE)))) {
			if ((globs::gameGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
										// IsKeyUp(KEY_SPACE) (57)
				if (globs::INPUT.Key_Map[57] == false) {
										// IsKeyDown(KEY_RETURN) (28)
					if (globs::INPUT.Key_Map[28] != false) {
						return 0;
					}
				}
				else {
					snd::Sound3D_ShutDown();
					main::Game_Exit();
				}
			}
			Game_SetPaused(FALSE,TRUE);
			globs::gameGlobs.flags1 |= GAME1_PAUSED;
		}
		else {
										// IsKeyDown(KEY_ESCAPE) (1)
			if (((globs::INPUT.Key_Map[1] != false) &&
					((globs::gameGlobs.flags2 & GAME2_INOPTIONSMENU) == GAME2_NONE)) &&
				 ((BVar2 = front::HelpWindow_FUN_004190d0(), BVar2 == 0 &&
					((BVar2 = Objective_Level_IsObjectiveFinished(), BVar2 == 0 &&
					 ((globs::gameGlobs.flags1 & GAME1_UNK_8000000) == GAME1_NONE)))))) {
				snd::Sound3D_ShutDown();
				main::Game_Exit();
			}
		}
	}
	if ((globs::gameGlobs.flags2 & GAME2_UNK_2) != GAME2_NONE) {
		BVar2 = main::Config_IsFrontEndEnabled();
										// IsKeyDown(KEY_SPACE) (57)
		if ((BVar2 == 0) || (globs::INPUT.Key_Map[57] != false)) {
			snd::Sound3D_ShutDown();
			main::Game_Exit();
		}
		else {
										// IsKeyDown(KEY_RETURN) (28)
			if (globs::INPUT.Key_Map[28] != false) {
				return 0;
			}
			BVar2 = FUN_00435870();
			if (BVar2 == 0) {
				return 0;
			}
		}
	}
	*out_t = 0;
	*put_r = 0;
	*out_shift = 0;
	if ((globs::gameGlobs.flags1 & (GAME1_CAMERADISABLED|GAME1_UNK_8000000)) == GAME1_NONE) {
		front::Interface_DoF2InterfaceKeyAction();
										// IsKeyPressed(KEY_SPACE) (57)
										//  "Toggle unit info bubbles/HUDs visibility."
		if ((globs::INPUT.Key_Map[57] != false) &&
			 (globs::INPUT.prevKey_Map[57] != globs::INPUT.Key_Map[57])) {
			front::Bubble_ToggleObjectUIsAlwaysVisible();
		}
										// IsKeyDown(KEY_LEFTSHIFT) (42) || IsKeyDown(KEY_RIGHTSHIFT) (54)
		if ((globs::INPUT.Key_Map[42] != false) || (globs::INPUT.Key_Map[54] != false)) {
			*out_shift = 1;
		}
		if ((globs::gameGlobs.viewMode == VIEW_TOPDOWN) &&
			 (TVar3 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL),
			 (TVar3 & TUTORIAL_UNK_1000) == TUTORIAL_NONE)) {
										// IsKeyDown(KEY_CURSORDOWN) (208)
										//  "Topdown view: Pitch lower (around center)."
			if (globs::INPUT.Key_Map[208] != false) {
				lego::view::Camera_AddTilt(globs::gameGlobs.cameraMain,param_2 * 0.02);
			}
										// IsKeyDown(KEY_CURSORUP) (200)
										//  "Topdown view: Pitch raise (around center)."
			if (globs::INPUT.Key_Map[200] != false) {
				lego::view::Camera_AddTilt(globs::gameGlobs.cameraMain,param_2 * -0.02);
			}
										// IsKeyDown(KEY_CURSORLEFT) (203)
										//  "Topdown view: Rotate clockwise (around center)."
			if (globs::INPUT.Key_Map[203] != false) {
				lego::view::Camera_AddYaw(globs::gameGlobs.cameraMain,param_2 * 0.02);
			}
										// IsKeyDown(KEY_CURSORRIGHT) (205)
										//  "Topdown view: Rotate counter-clockwise (around center)."
			if (globs::INPUT.Key_Map[205] != false) {
				lego::view::Camera_AddYaw(globs::gameGlobs.cameraMain,param_2 * -0.02);
			}
										// IsKeyDown(KEY_MINUS) (12)
										//  "Topdown view: Zoom out."
			if (globs::INPUT.Key_Map[12] != false) {
				lego::view::Camera_AddDist(globs::gameGlobs.cameraMain,param_2 * 3.0);
			}
										// IsKeyDown(KEY_EQUALS) (13)  "+""Topdown view: Zoom in."
			if (globs::INPUT.Key_Map[13] != false) {
				lego::view::Camera_AddDist(globs::gameGlobs.cameraMain,param_2 * -3.0);
			}
		}
		if ((globs::gameGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
										// IsKeyDown(KEYPAD_7) (71)
										//  "Set game speed to 300%."
			if (globs::INPUT.Key_Map[71] != false) {
				Game_SetGameSpeed(3.0);
			}
										// IsKeyDown(KEY_T) (20)
			if (globs::INPUT.Key_Map[20] != false) {
				*out_t = 1;
			}
										// IsKeyDown(KEY_R) (19)
			if (globs::INPUT.Key_Map[19] != false) {
				*put_r = 1;
			}
										// IsKeyPressed(KEY_L) (38)
			if (((globs::INPUT.Key_Map[38] != false) &&
					(globs::INPUT.prevKey_Map[38] != globs::INPUT.Key_Map[38])) &&
				 (BVar2 = FUN_00435870(), BVar2 == 0)) {
				return 0;
			}
										// IsKeyDown(KEY_LEFTCTRL) (29) && IsKeyPressed(KEY_F) (33)
										//  "Toggle framerate monitor."
			if (((globs::INPUT.Key_Map[29] != false) && (globs::INPUT.Key_Map[33] != false)) &&
				 (globs::INPUT.prevKey_Map[33] != globs::INPUT.Key_Map[33])) {
				if ((globs::gameGlobs.flags1 & GAME1_FRAMERATEMONITOR) == GAME1_NONE) {
					globs::gameGlobs.flags1 |= GAME1_FRAMERATEMONITOR;
				}
				else {
					globs::gameGlobs.flags1 &= ~GAME1_FRAMERATEMONITOR;
				}
				pcVar4 = "ON";
				if ((globs::gameGlobs.flags1 & GAME1_FRAMERATEMONITOR) == GAME1_NONE) {
					pcVar4 = "OFF";
				}
				front::TextWindow_PrintF(globs::gameGlobs.textWnd_80,"\nFrame Rate Monitor: %s",pcVar4);
			}
										// IsKeyPressed(KEY_TAB) (15)
										//  "Toggle between Radar Map/Track Object View."
			if ((((globs::gameGlobs.flags1 & GAME1_RADARON) != GAME1_NONE) &&
					(globs::INPUT.Key_Map[15] != false)) &&
				 (globs::INPUT.prevKey_Map[15] != globs::INPUT.Key_Map[15])) {
				bVar8 = (globs::gameGlobs.flags1 & GAME1_RADAR_TRACKOBJECTVIEW) == GAME1_NONE;
				if (bVar8) {
					globs::gameGlobs.flags1 =
							 globs::gameGlobs.flags1 &
							 (GAME1_HIGHFOGCOLOURRGB|GAME1_UNK_20000|GAME1_UNK_40000|GAME1_DYNAMICPM|
								GAME1_CAMERADISABLED|GAME1_UNK_200000|GAME1_ONLYBUILDONPATHS|GAME1_ALWAYSROCKFALL|
								GAME1_DEBUG_NONERPS|GAME1_PAUSED|GAME1_STREAMNERPSSPEACH|GAME1_UNK_8000000|
								GAME1_LASERTRACKER|GAME1_UNK_20000000|GAME1_DEBUG_NOCLIP_FPS|GAME1_UNK_80000000) |
							 (ushort)((ushort)globs::gameGlobs.flags1 | 0x2000) & ~GAME1_RADAR_MAPVIEW;
					front::Panel_FUN_0045ad80(PANEL_RADAR,2,TRUE);
				}
				else {
					globs::gameGlobs.flags1 =
							 globs::gameGlobs.flags1 & ~GAME1_RADAR_TRACKOBJECTVIEW | GAME1_RADAR_MAPVIEW;
					front::Panel_FUN_0045ad80(PANEL_RADAR,2,FALSE);
				}
				front::Panel_FUN_0045ad80(PANEL_RADAR,3,(uint)bVar8);
			}
										// IsKeyDown(KEY_LEFTCTRL) (29)
			if (globs::INPUT.Key_Map[29] != false) {
										// IsKeyPressed(KEY_G) (34)
										//  "Toggle memory monitor."
				if ((globs::INPUT.Key_Map[34] != false) &&
					 (globs::INPUT.prevKey_Map[34] != globs::INPUT.Key_Map[34])) {
					if ((globs::gameGlobs.flags1 & GAME1_MEMORYMONITOR) == GAME1_NONE) {
						globs::gameGlobs.flags1 |= GAME1_MEMORYMONITOR;
					}
					else {
						globs::gameGlobs.flags1 &= ~GAME1_MEMORYMONITOR;
					}
					pcVar4 = "ON";
					if ((globs::gameGlobs.flags1 & GAME1_MEMORYMONITOR) == GAME1_NONE) {
						pcVar4 = "OFF";
					}
					front::TextWindow_PrintF(globs::gameGlobs.textWnd_80,"\nMemory Monitor: %s",pcVar4);
				}
										// IsKeyDown(KEY_LEFTCTRL) (29) && IsKeyPressed(KEY_RETURN) (28)
										//  "Toggle Noclip in first/second person view."
				if (((globs::INPUT.Key_Map[29] != false) && (globs::INPUT.Key_Map[28] != false)) &&
					 (globs::INPUT.prevKey_Map[28] != globs::INPUT.Key_Map[28])) {
					if ((globs::gameGlobs.flags1 & GAME1_DEBUG_NOCLIP_FPS) == GAME1_NONE) {
						globs::gameGlobs.flags1 |= GAME1_DEBUG_NOCLIP_FPS;
					}
					else {
						globs::gameGlobs.flags1 &= ~GAME1_DEBUG_NOCLIP_FPS;
					}
				}
			}
		}
		if ((globs::gameGlobs.viewMode == VIEW_FIRSTPERSON) &&
			 ((*(byte *)&(globs::gameGlobs.objectFP)->flags2 & LIVEOBJ2_UNK_1) == 0)) {
										// First person view controls
										// IsKeyDown(KEY_CURSORUP) (200)
										//  "First person view: Move forward."
			if (globs::INPUT.Key_Map[200] != false) {
				LiveObject_FPMove(globs::gameGlobs.objectFP,1,0,0.0);
			}
										// IsKeyDown(KEY_CURSORDOWN) (208)
										//  "First person view: Move back."
			if (globs::INPUT.Key_Map[208] != false) {
				LiveObject_FPMove(globs::gameGlobs.objectFP,-1,0,0.0);
			}
										// IsKeyDown(KEY_CURSORLEFT) (203)
										//  "First person view: Turn left."
			if (globs::INPUT.Key_Map[203] != false) {
				LiveObject_FPMove(globs::gameGlobs.objectFP,0,0,-0.05);
			}
										// IsKeyDown(KEY_CURSORRIGHT) (205)
										//  "First person view: Turn right."
			if (globs::INPUT.Key_Map[205] != false) {
				LiveObject_FPMove(globs::gameGlobs.objectFP,0,0,0.05);
			}
										// IsKeyDown(KEY_Z) (44)
										//  "First person view: Strafe left."
			if (globs::INPUT.Key_Map[44] != false) {
				LiveObject_FPMove(globs::gameGlobs.objectFP,0,-1,0.0);
			}
										// IsKeyDown(KEY_X) (45)
										//  "First person view: Strafe right."
			if (globs::INPUT.Key_Map[45] != false) {
				LiveObject_FPMove(globs::gameGlobs.objectFP,0,1,0.0);
			}
		}
		if ((globs::gameGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
										// IsKeyPressed(KEY_S) (31)
										//  "Toggle sound On/Off."
			if ((globs::INPUT.Key_Map[31] != false) &&
				 (globs::INPUT.prevKey_Map[31] != globs::INPUT.Key_Map[31])) {
				if ((globs::gameGlobs.flags1 & GAME1_SOUNDON) == GAME1_NONE) {
					snd::SFX_SetSoundEnabled(TRUE);
					snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_AMBIENTLOOP,1);
				}
				else {
					snd::SFX_SetSoundEnabled(0);
				}
				pcVar4 = "ON";
				if ((globs::gameGlobs.flags1 & GAME1_SOUNDON) == GAME1_NONE) {
					pcVar4 = "OFF";
				}
				front::TextWindow_PrintF(globs::gameGlobs.textWnd_80,"\nSound Effects: %s",pcVar4);
			}
										// IsKeyPressed(KEY_M) (55)
										//  "Toggle music On/Off."
			if ((globs::INPUT.Key_Map[50] != false) &&
				 (globs::INPUT.prevKey_Map[50] != globs::INPUT.Key_Map[50])) {
				snd::Music_PlayNext((uint)((globs::gameGlobs.flags1 & GAME1_MUSICON) == GAME1_NONE));
				pcVar4 = "ON";
				if ((globs::gameGlobs.flags1 & GAME1_MUSICON) == GAME1_NONE) {
					pcVar4 = "OFF";
				}
				front::TextWindow_PrintF(globs::gameGlobs.textWnd_80,"\nMusic: %s",pcVar4);
			}
		}
										// IsKeyPressed(KEYPAD_0) (82)
		if ((((globs::gameGlobs.flags2 & GAME2_ALLOWEDITMODE) != GAME2_NONE) &&
				(globs::INPUT.Key_Map[82] != false)) &&
			 (globs::INPUT.prevKey_Map[82] != globs::INPUT.Key_Map[82])) {
			lego::view::Camera_Debug_EnableEditMode(globs::gameGlobs.cameraMain,FALSE);
			res::ResLp_Hide(globs::gameGlobs.RES_2f4_TABLEUNK,TRUE);
		}
										// IsKeyPressed(KEY_Z) (44)
										//  "Make primary selected unit eat."
		if ((((globs::gameGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) &&
				(globs::INPUT.Key_Map[44] != false)) &&
			 (globs::INPUT.prevKey_Map[44] != globs::INPUT.Key_Map[44])) {
			lego::view::Camera_SetFloata0_a4_Zeroa8(globs::gameGlobs.cameraMain,5.0,25.0);
			pLVar1 = Message_GetPrimarySelectedUnit();
			if (pLVar1 != NULL) {
				pLVar1 = Message_GetPrimarySelectedUnit();
				unkbool2d8 = 0;
				actType = ACTIVITY_EAT;
				pLVar1->flags1 = pLVar1->flags1 | LIVEOBJ1_EATING;
				pLVar1 = Message_GetPrimarySelectedUnit();
				LiveObject_SetActivityUnk(pLVar1,actType,unkbool2d8);
				pLVar1 = Message_GetPrimarySelectedUnit();
				LiveObject_Container_ActivityUpdate_Check(pLVar1);
				pLVar1 = Message_GetPrimarySelectedUnit();
				ai::AITask_DoAnimationWait(pLVar1);
			}
		}
	}
	iVar7 = 0;
	param_2 = 0.0;
	if ((globals::g_Front_mslb_Last_4 != 0) && (globs::INPUT.mslb == 0)) {
		iVar7 = 1;
	}
										// IsKeyUp(KEY_SPACE) && !IsKeyReleased(KEY_SPACE) (57)
	if ((globs::INPUT.Key_Map[57] == false) ||
		 (globs::INPUT.prevKey_Map[57] == globs::INPUT.Key_Map[57])) {
		iVar5 = 0;
	}
	else {
		iVar5 = 1;
	}
	iVar7 = Objective_FUN_00458c80(iVar5,iVar7,(uint *)&param_2);
	if ((((iVar7 == 0) && (BVar2 = front::HelpWindow_FUN_004190d0(), BVar2 == 0)) &&
			(BVar2 = Objective_Level_IsObjectiveFinished(), BVar2 == 0)) &&
		 (((globs::gameGlobs.flags1 & GAME1_UNK_8000000) == GAME1_NONE &&
			((globs::gameGlobs.flags2 & GAME2_INOPTIONSMENU) == GAME2_NONE)))) {
										// IsKeyPressed(KEY_P) (25)
										//  "Pause/unpause the game."
		if ((globs::INPUT.Key_Map[25] != false) &&
			 (globs::INPUT.prevKey_Map[25] != globs::INPUT.Key_Map[25])) {
			Game_SetPaused(TRUE,FALSE);
			globs::gameGlobs.flags1 ^= GAME1_PAUSED;
		}
		if (globs::mainGlobs.active == 0) {
			pcVar4 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","LoseFocusAndPause",0);
			BVar6 = cfg::CFG_ReadBool(globs::gameGlobs.LegoCfgRoot,pcVar4);
			if (((BVar6 == BOOL3_TRUE) && ((globs::gameGlobs.flags1 & GAME1_UNK_8000000) == GAME1_NONE))
				 && (Game_SetPaused(0,1), (globs::gameGlobs.flags1 & GAME1_PAUSED) == GAME1_NONE)) {
				globs::gameGlobs.flags1 |= GAME1_PAUSED;
			}
		}
	}
	globals::g_Front_mslb_Last_4 = globs::INPUT.mslb;
	if (param_2 != 0.0) {
		return 0;
	}
	if ((globs::gameGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
										// IsKeyUp(KEY_LEFTSHIFT) (42)
		if (globs::INPUT.Key_Map[42] == false) {
										// IsKeyDown(KEY_FIVE) (6)
			if (globs::INPUT.Key_Map[6] != false) {
				globals::g_CursorLightLevel_Base = globals::g_CursorLightLevel_Base - 0.02;
				res::Container_Light_SetSpotPenumbra
									(globs::gameGlobs.resRootSpotlight,globals::g_CursorLightLevel_Base);
			}
										// IsKeyDown(KEY_SIX) (7)
			if (globs::INPUT.Key_Map[7] != false) {
				globals::g_CursorLightLevel_Current = globals::g_CursorLightLevel_Current - 0.02;
				goto LAB_004259b9;
			}
		}
		else {
										// IsKeyDown(KEY_FIVE) (6)
			if (globs::INPUT.Key_Map[6] != false) {
				globals::g_CursorLightLevel_Base = globals::g_CursorLightLevel_Base - -0.02;
				res::Container_Light_SetSpotPenumbra
									(globs::gameGlobs.resRootSpotlight,globals::g_CursorLightLevel_Base);
			}
										// IsKeyDown(KEY_SIX) (7)
			if (globs::INPUT.Key_Map[7] != false) {
				globals::g_CursorLightLevel_Current = globals::g_CursorLightLevel_Current - -0.02;
LAB_004259b9:
				res::Container_Light_SetSpotUmbra
									(globs::gameGlobs.resRootSpotlight,globals::g_CursorLightLevel_Current);
			}
		}
		if ((globs::gameGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) goto LAB_004259d8;
	}
	if ((globs::mainGlobs.flags & CMD_DEBUGCOMPLETE) == CMD_NONE) {
		return 1;
	}
LAB_004259d8:
										// IsKeyDown(KEY_LEFTCTRL) (29)
	if (globs::INPUT.Key_Map[29] != false) {
										// IsKeyPressed(KEY_D) (32)
										//  "Instantly fails the current level."
		if ((globs::INPUT.Key_Map[32] != false) &&
			 (globs::INPUT.prevKey_Map[32] != globs::INPUT.Key_Map[32])) {
			nerps::funcs::NERPFunc__SetLevelFail(NULL);
		}
										// IsKeyPressed(KEY_S) (31)
										//  "Instantly completes the current level."
		if ((globs::INPUT.Key_Map[31] != false) &&
			 (globs::INPUT.prevKey_Map[31] != globs::INPUT.Key_Map[31])) {
			nerps::funcs::NERPFunc__SetLevelCompleted(NULL);
		}
	}
										// IsKeyDown(KEY_RIGHTCTRL) (157)  && IsKeyPressed(KEY_S) (31)
										//  "Instantly fails the current level with reason, too many crystals stolen."
	if (((globs::INPUT.Key_Map[157] != false) && (globs::INPUT.Key_Map[31] != false)) &&
		 (globs::INPUT.prevKey_Map[31] != globs::INPUT.Key_Map[31])) {
		Objective_Level_SetCompleteStatus(LEVELSTATUS_FAILED_CRYSTALS);
	}
										// IsKeyDown(KEY_O) (24)
										//  "Decreases oxygen level."
	if (globs::INPUT.Key_Map[24] != false) {
		(globs::gameGlobs.level)->oxygenLevel = (globs::gameGlobs.level)->oxygenLevel - 1.0;
	}
	return TRUE;
}



BOOL __cdecl lego::game::LiveManager_Update3DSounds(BOOL stopAll)
{
	BOOL BVar1;
	
	BVar1 = Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackUpdate3DSounds,&stopAll);
	return BVar1;
}



BOOL __cdecl lego::game::LiveObject_CallbackUpdate3DSounds(LiveObject *liveObj,BOOL *pStopAll)
{
	Container *cont;
	SFXType SVar1;
	BOOL loop;
	BOOL sound3D;
	Vector3F *opt_position;
	
	cont = LiveObject_GetContainer(liveObj);
	if (cont != NULL) {
		if ((liveObj->flags4 & LIVEOBJ4_UNK_20000) == LIVEOBJ4_NONE) {
			if (*pStopAll != 0) {
				snd::SFX_Sample_Sound3D_StopSound(liveObj->soundHandle_350);
			}
			if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_UNK_8) != 0) {
				opt_position = NULL;
				sound3D = TRUE;
				loop = TRUE;
				SVar1 = LiveObject_GetDrillSoundType(liveObj,FALSE);
				res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(cont,SVar1,loop,sound3D,opt_position);
				liveObj->soundHandle_350 = SVar1;
				liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_100000;
			}
		}
		if (*pStopAll != 0) {
			snd::SFX_Sample_Sound3D_StopSound(liveObj->soundHandle_354);
		}
		SVar1 = LiveObject_GetEngineSound(liveObj);
		if (SVar1 != SFX_NULL) {
			res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(cont,SVar1,TRUE,TRUE,NULL);
			liveObj->soundHandle_354 = SVar1;
			liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_80000;
		}
	}
	return 0;
}



void __cdecl lego::game::Game_SetPaused(BOOL checkCamDisableFlag,BOOL paused)
{
	if ((globs::gameGlobs.flags2 & GAME2_UNK_2) == GAME2_NONE) {
		if (checkCamDisableFlag != 0) {
										// param_2 = (gameGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE;
			paused = ~globs::gameGlobs.flags1 >> 20 & 1;
		}
		if (paused != 0) {
			if ((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) {
				snd::Sound3D_StopAllSounds();
			}
			globs::gameGlobs.flags1 = globs::gameGlobs.flags1 | GAME1_CAMERADISABLED;
			globs::gameGlobs.flags2 = globs::gameGlobs.flags2 | GAME2_INMENU;
			return;
		}
		LiveManager_Update3DSounds(FALSE);
		snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_AMBIENTLOOP,TRUE);
		globs::gameGlobs.flags1 &= ~GAME1_CAMERADISABLED;
		globs::gameGlobs.flags2 &= ~GAME2_INMENU;
	}
	return;
}



// When set to TRUE, game speed can only be lowered, not raised.

void __cdecl lego::game::Game_LockGameSpeed(BOOL locked)
{
	globals::g_Front_GameSpeedLocked = locked;
	return;
}



// Set new game speed and update front end speed slider.
//  If GameSpeedLocked global is true, game speed can only be lowered, not raised.

void __cdecl lego::game::Game_SetGameSpeed(float newGameSpeed)
{
	if ((globs::gameGlobs.gameSpeed <= newGameSpeed) || (globals::g_Front_GameSpeedLocked == 0)) {
		front::FrontEnd_UpdateSliderGameSpeed();
		globs::gameGlobs.gameSpeed = newGameSpeed;
		if (newGameSpeed < 0.0) {
			globs::gameGlobs.gameSpeed = 0.0;
		}
										// Debug mode allows game speeds up to 300%
										// 
										// if (gameGlobs.gameSpeed > 3.0f)
										//   gameGlobs.gameSpeed = 3.0f;
		if ((ushort)((ushort)(globs::gameGlobs.gameSpeed < 3.0) << 8 |
								(ushort)(globs::gameGlobs.gameSpeed == 3.0) << 0xe) == 0) {
			globs::gameGlobs.gameSpeed = 3.0;
		}
	}
	return;
}



void __cdecl lego::game::Game_TrackObjectInRadar(LiveObject *liveObj)
{
	float10 fVar1;
	float fVar2;
	float fVar3;
	
	fVar3 = 0.01;
	fVar2 = 0.7;
	fVar1 = LiveObject_GetTrackDist(liveObj);
	lego::view::Camera_FollowObject(globs::gameGlobs.cameraRadar,liveObj,2.0,(float)fVar1,fVar2,fVar3)
	;
	return;
}



BOOL __cdecl lego::game::Game_IsFirstPersonView(void)
{
	return (uint)(globs::gameGlobs.viewMode == VIEW_FIRSTPERSON);
}



void __cdecl FUN_00425cc0(void)
{
	TutorialFlags TVar1;
	BOOL BVar2;
	float fVar3;
	int iVar4;
	char *pcVar5;
	SFXType sfxType;
	LevelBlockFlags1 LVar6;
	float10 fVar7;
	float fVar8;
	ToolTipType toolTipType;
	LiveObject *local_30;
	Point2F local_2c;
	int local_24;
	int local_20;
	Point2I local_1c;
	Point2F local_10;
	float local_8;
	float local_4;
	LevelData *level;
	
	level = lego::globs::gameGlobs.level;
	if ((lego::globs::gameGlobs.flags1 & GAME1_RADARON) == GAME1_NONE) {
		return;
	}
	if ((lego::globs::gameGlobs.flags1 & GAME1_RADAR_MAPVIEW) == GAME1_NONE) {
		return;
	}
	if ((lego::globs::gameGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) != GAME1_NONE) {
		return;
	}
	local_1c.x = (int)((float)lego::globs::INPUT.msx - (float)lego::globals::g_Front_msx_Last_1);
	local_10.x = (float)lego::globals::g_Front_msy_Last_1;
	local_10.y = 0.0;
	local_1c.y = (int)((float)lego::globs::INPUT.msy - (float)lego::globals::g_Front_msy_Last_1);
	lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_STANDARD);
	TVar1 = lego::nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if ((TVar1 & TUTORIAL_UNK_1000) == TUTORIAL_NONE) {
		lego::globals::g_Front_mslb_Last_1 =
				 (BOOL)(SQRT((float)local_1c.y * (float)local_1c.y + (float)local_1c.x * (float)local_1c.x)
							 + (float)lego::globals::g_Front_mslb_Last_1);
	}
	if ((((lego::globals::g_Front_mslb_Last_3 != 0) && (lego::globs::INPUT.mslb != 0)) &&
			(4.0 <= (float)lego::globals::g_Front_mslb_Last_1)) &&
		 (BVar2 = lego::game::LevelStruct3C_FUN_0045e990
												(level->struct3c_84,lego::globs::INPUT.msx,lego::globs::INPUT.msy,&local_10,
												 (int *)&local_2c,(int *)&local_2c.y), BVar2 != 0)) {
		lego::view::Camera_GetFramePosition_IfTopdown(lego::globs::gameGlobs.cameraMain,&local_1c);
		fVar3 = (float)lego::view::Camera_GetMouseScrollIndent();
		if (((uint)local_2c.x < (uint)fVar3) ||
			 (iVar4 = lego::view::Camera_GetMouseScrollIndent(),
			 (uint)((level->surfaceMap->smallDimensions).width - iVar4) <= (uint)local_2c.x)) {
			local_10.x = (float)local_1c.x;
		}
		fVar3 = (float)lego::view::Camera_GetMouseScrollIndent();
		if (((uint)local_2c.y < (uint)fVar3) ||
			 (iVar4 = lego::view::Camera_GetMouseScrollIndent(),
			 (uint)((level->surfaceMap->smallDimensions).height - iVar4) <= (uint)local_2c.y)) {
			local_10.y = (float)local_1c.y;
		}
		if (lego::globs::gameGlobs.viewMode == VIEW_TOPDOWN) {
			lego::view::Camera_SetFramePosition_IfTopdown
								(lego::globs::gameGlobs.cameraMain,local_10.x,local_10.y);
		}
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_RADARPAN);
		lego::globs::gameGlobs.flags1 |= GAME1_UNK_200;
	}
	BVar2 = lego::game::LevelStruct3C_FUN_0045e920
										(level->struct3c_84,lego::globs::INPUT.msx,lego::globs::INPUT.msy);
	if (((BVar2 != 0) && (lego::globs::INPUT.mslb != 0)) && (lego::globals::g_Front_mslb_Last_2 == 0))
	{
		lego::globals::g_Front_mslb_Last_3 = 1;
	}
	if (4.0 <= (float)lego::globals::g_Front_mslb_Last_1) goto LAB_004260b6;
	BVar2 = lego::game::LevelStruct3C_FUN_0045eae0
										(level->struct3c_84,lego::globs::INPUT.msx,lego::globs::INPUT.msy,&local_30,
										 &local_8);
	if (BVar2 == 0) {
		if (lego::globs::INPUT.mslb != 0) goto LAB_004260b6;
		if (lego::globals::g_Front_mslb_Last_2 != 0) {
			BVar2 = lego::game::LevelStruct3C_FUN_0045e990
												(level->struct3c_84,lego::globs::INPUT.msx,lego::globs::INPUT.msy,
												 &lego::globs::gameGlobs.tvFaceDirection_338,&local_20,&local_24);
			if (BVar2 != 0) {
				lego::globs::gameGlobs.flags1 |= GAME1_UNK_4000;
			}
			goto LAB_004260b6;
		}
		if ((false) ||
			 (BVar2 = lego::game::LevelStruct3C_FUN_0045e990
													(level->struct3c_84,lego::globs::INPUT.msx,lego::globs::INPUT.msy,NULL,
													 (int *)&local_2c,(int *)&local_2c.y), BVar2 == 0)) goto LAB_004260b6;
		if ((Point2F_004df554.x == local_2c.x) && (Point2F_004df554.y == local_2c.y)) {
			iVar4 = ((lego::globs::gameGlobs.level)->dimensions).width;
			if (((uint)local_2c.x < iVar4 - 1U) &&
				 ((uint)local_2c.y < ((lego::globs::gameGlobs.level)->dimensions).height - 1U)) {
				LVar6 = (lego::globs::gameGlobs.level)->blocks[(int)local_2c.y * iVar4 + (int)local_2c.x].
								flags1 & BLOCK1_UNK_4;
			}
			else {
				LVar6 = BLOCK1_NONE;
			}
			if (LVar6 != BLOCK1_NONE) {
				local_1c.x = (int)local_2c.x;
				local_1c.y = (int)local_2c.y;
				FUN_00428260(&local_1c,FALSE,TRUE,TRUE);
			}
			goto LAB_004260b6;
		}
		Point2F_004df554.x = local_2c.x;
		Point2F_004df554.y = local_2c.y;
		toolTipType = TOOLTIP_NULL;
	}
	else {
		if (lego::globs::INPUT.mslb != 0) goto LAB_004260b6;
		if (lego::globals::g_Front_mslb_Last_2 != 0) {
			if (lego::globs::gameGlobs.viewMode == VIEW_TOPDOWN) {
				lego::view::Camera_SetFramePosition_IfTopdown
									(lego::globs::gameGlobs.cameraMain,local_8,local_4);
			}
			fVar8 = 0.01;
			fVar3 = 0.7;
			fVar7 = lego::game::LiveObject_GetTrackDist(local_30);
			lego::view::Camera_FollowObject
								(lego::globs::gameGlobs.cameraRadar,local_30,2.0,(float)fVar7,fVar3,fVar8);
			lego::globs::gameGlobs.flags1 &= ~GAME1_UNK_4000;
			goto LAB_004260b6;
		}
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_TRACKOBJECT);
		pcVar5 = lego::game::LiveObject_GetName(local_30);
		lego::front::ToolTip_SetText(TOOLTIP_UNITSELECTED,"%s",pcVar5);
		sfxType = lego::game::LiveObject_GetObjTtSFX(local_30);
		lego::front::ToolTip_SetSFX(TOOLTIP_UNITSELECTED,sfxType);
		toolTipType = TOOLTIP_UNITSELECTED;
	}
	lego::front::ToolTip_AddFlag4(toolTipType);
LAB_004260b6:
	if (lego::globs::INPUT.mslb == 0) {
		lego::globals::g_Front_mslb_Last_1 = lego::globs::INPUT.mslb;
		lego::globals::g_Front_mslb_Last_3 = lego::globs::INPUT.mslb;
	}
	lego::globals::g_Front_msy_Last_1 = lego::globs::INPUT.msy;
	lego::globals::g_Front_msx_Last_1 = lego::globs::INPUT.msx;
	lego::globals::g_Front_mslb_Last_2 = lego::globs::INPUT.mslb;
	return;
}



void __cdecl lego::unk::Lego_unkSlug__004260f0(float elapsedGame)
{
	int iVar1;
	
	if (((globs::gameGlobs.level)->Slug != 0x14) &&
		 (globs::gameGlobs.InitialSlugTime = globs::gameGlobs.InitialSlugTime - elapsedGame,
		 globs::gameGlobs.InitialSlugTime < 0.0)) {
		iVar1 = FUN_00438c20(NULL,0);
		if (iVar1 != 0) {
			FUN_0043b010(NULL,(globs::gameGlobs.level)->Slug);
		}
		globs::gameGlobs.InitialSlugTime = (globs::gameGlobs.level)->SlugTime;
	}
	return;
}



void __cdecl lego::game::Game_GetVector_45c(Vector3F *out_vector)
{
	out_vector->x = globs::gameGlobs.vector_45c.x;
	out_vector->y = globs::gameGlobs.vector_45c.y;
	out_vector->z = globs::gameGlobs.vector_45c.z;
	return;
}



void __cdecl FUN_00426180(void)
{
	Point2F local_8;
	
	if ((lego::globs::gameGlobs.cameraRadar)->trackObj == NULL) {
		lego::globs::gameGlobs.flags1 |= GAME1_UNK_4000;
	}
	if ((lego::globs::gameGlobs.flags1 & GAME1_UNK_4000) == GAME1_NONE) {
		lego::game::LiveObject_GetPosition
							((lego::globs::gameGlobs.cameraRadar)->trackObj,(float *)&local_8,&local_8.y);
	}
	else {
		local_8.x = lego::globs::gameGlobs.tvFaceDirection_338.x;
		local_8.y = lego::globs::gameGlobs.tvFaceDirection_338.y;
	}
	lego::game::LevelStruct3C_SetFloat14
						((lego::globs::gameGlobs.level)->struct3c_84,lego::globs::gameGlobs.tvTiltOrZoom_334);
	lego::game::LevelStruct3C_FUN_0045de80((lego::globs::gameGlobs.level)->struct3c_84,&local_8);
	return;
}



void __cdecl lego::game::Game_SetMenuNextPosition(Point2F *position)
{
	if (position != NULL) {
		globs::gameGlobs.flags2 = globs::gameGlobs.flags2 | GAME2_MENU_HASNEXT;
		globs::gameGlobs.menuNextPoint.x = position->x;
		globs::gameGlobs.menuNextPoint.y = position->y;
		return;
	}
	globs::gameGlobs.flags2 = globs::gameGlobs.flags2 & ~GAME2_MENU_HASNEXT;
	return;
}



void __cdecl lego::game::Game_SetMenuPreviousPosition(Point2F *position)
{
	if (position != NULL) {
		globs::gameGlobs.flags2 = globs::gameGlobs.flags2 | GAME2_MENU_HASPREVIOUS;
		globs::gameGlobs.menuPrevPoint.x = position->x;
		globs::gameGlobs.menuPrevPoint.y = position->y;
		return;
	}
	globs::gameGlobs.flags2 = globs::gameGlobs.flags2 & ~GAME2_MENU_HASPREVIOUS;
	return;
}



void __cdecl lego::game::Game_SetFlags2_40_And_2_unkCamera(BOOL onFlag40,BOOL onFlag2)
{
	GameFlags2 GVar1;
	
	if (onFlag40 == 0) {
		GVar1 = globs::gameGlobs.flags2 & ~GAME2_UNK_40;
	}
	else {
		GVar1 = globs::gameGlobs.flags2 | GAME2_UNK_40;
	}
	if (onFlag2 != 0) {
		globs::gameGlobs.flags2 = GVar1 | GAME2_CAMERAMOVING;
		return;
	}
	globs::gameGlobs.flags2 = GVar1 & ~GAME2_CAMERAMOVING;
	return;
}



void __cdecl lego::game::Game_SetFlags2_80(BOOL state)
{
	if (state != 0) {
		globs::gameGlobs.flags2 = globs::gameGlobs.flags2 | GAME2_UNK_80;
		return;
	}
	globs::gameGlobs.flags2 = globs::gameGlobs.flags2 & ~GAME2_UNK_80;
	return;
}



void __cdecl FUN_004262f0(void)
{
	int local_4;
	
	local_4 = 1;
	FLAGS_00504610 = 0;
	lego::nerps::funcs::NERPFunc__SetMessagePermit(&local_4);
	FLOAT_00504618 = 0.0;
	lego::front::TextWindow_Clear(lego::globs::gameGlobs.textWnd_80);
	lego::game::Game_SetFlags2_40_And_2_unkCamera(0,0);
	lego::game::Game_SetFlags2_80(0);
	return;
}



void __cdecl lego::game::Game_UpdateTopdownCamera(float elapsedAbs)
{
	TutorialFlags TVar1;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	if (globs::gameGlobs.viewMode == VIEW_TOPDOWN) {
		TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
		if ((TVar1 & TUTORIAL_UNK_1000) == TUTORIAL_NONE) {
			if (((((int)globs::gameGlobs.MouseScrollBorder <= globs::INPUT.msx) &&
					 ((int)globs::gameGlobs.MouseScrollBorder <= globs::INPUT.msy)) &&
					(globs::INPUT.msx <= (int)(globs::mainGlobs.appWidth - globs::gameGlobs.MouseScrollBorder)
					)) && (globs::INPUT.msy <=
								 (int)(globs::mainGlobs.appHeight - globs::gameGlobs.MouseScrollBorder))) {
				lego::view::Camera_ZeroField9c_UnkSpeedAccel(globs::gameGlobs.cameraMain);
				return;
			}
			lego::view::Camera_GetSurfacePosition_IfTopdown
								(globs::gameGlobs.cameraMain,(globs::gameGlobs.level)->surfaceMap,&local_18);
			Game_MainView_MouseTransform(globs::INPUT.msx,globs::INPUT.msy,(float *)&local_24,&local_24.y)
			;
			local_c.x = local_24.x - local_18.x;
			local_c.y = local_24.y - local_18.y;
			local_18.z = 0.0;
			local_24.z = 0.0;
			local_c.z = 0.0;
			lego::view::Camera_FUN_00436da9(globs::gameGlobs.cameraMain,&local_c,elapsedAbs);
		}
	}
	return;
}



void __cdecl
lego::game::Game_unkGameLoop_FUN_00426450
					(float elapsedGame,float elapsedAbs,undefined4 param_3,undefined4 param_4,int param_5)
{
	char cVar1;
	ObjectType OVar2;
	LevelData *pLVar3;
	PointerType PVar4;
	LiveObject *pLVar5;
	ObjectStatsFlags3 OVar6;
	ObjectStatsFlags1 OVar7;
	LiveObject *pLVar8;
	LevelBlockFlags1 LVar9;
	TutorialFlags TVar10;
	float fVar11;
	LiveFlags5 LVar12;
	BOOL BVar13;
	bool bVar14;
	uint uVar15;
	float fVar16;
	uint uVar17;
	float fVar18;
	InterfaceMenuType interfaceMenuType;
	PointerType pointerType;
	int iVar19;
	Point2F *opt_blockPos;
	float fVar20;
	BOOL leftReleased;
	LiveObject *local_3c;
	float local_38;
	uint local_34;
	BOOL rightReleased;
	int local_2c;
	int local_28;
	Point2F local_24;
	Point2F local_1c;
	Point2F local_14;
	Vector3F local_c;
	
	pLVar3 = globs::gameGlobs.level;
	globs::gameGlobs.flags2 &= ~GAME2_MOUSE_INSIDEGAMEVIEW;
	BVar13 = 0;
	local_3c = NULL;
	local_28 = 0;
	local_2c = 0;
	leftReleased = 0;
	rightReleased = 0;
	res::ResLp_Hide(globs::gameGlobs.RES_2f4_TABLEUNK,TRUE);
	if ((globs::INPUT.mslb == 0) && (globs::INPUT.msrb == 0)) {
		ELAPSED_004df56c = ELAPSED_004df56c + elapsedGame;
	}
	else {
		ELAPSED_004df56c = 0.0;
	}
	if (globals::g_Front_mslb_Last != 0) {
		if (globs::INPUT.mslb == 0) {
			if ((globs::gameGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) {
				BVar13 = 1;
				leftReleased = 1;
			}
		}
		else {
			globals::g_Front_mslb_Last_6 = TRUE;
		}
	}
	if (globs::INPUT.mslb == 0) {
		globals::g_Front_mslb_Last_6 = 0;
	}
	if ((globals::g_Front_msrb_Last != 0) && (globs::INPUT.msrb == 0)) {
		rightReleased = 1;
	}
	if (globals::g_Front_mslb_Last_6 == 0) {
		Point2F_004df418.y = 0.0;
		Point2F_004df418.x = 0.0;
	}
	else {
		Point2F_004df418.x =
				 (float)((globs::INPUT.diffx ^ globs::INPUT.diffx >> 0x1f) - (globs::INPUT.diffx >> 0x1f)) +
				 Point2F_004df418.x;
		local_24.x = (float)((globs::INPUT.diffy ^ globs::INPUT.diffy >> 0x1f) -
												(globs::INPUT.diffy >> 0x1f));
		Point2F_004df418.y = (float)(int)local_24.x + Point2F_004df418.y;
	}
	front::HelpWindow_FUN_00418cd0
						(globs::INPUT.msx,globs::INPUT.msy,globs::INPUT.mslb,globals::g_Front_mslb_Last,BVar13,
						 elapsedGame);
	if ((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) != GAME1_NONE) {
		front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_STANDARD);
		globals::g_Front_mslb_Last = globs::INPUT.mslb;
		globals::g_Front_msrb_Last = globs::INPUT.msrb;
		BOOL_004df570 = 1;
		globs::gameGlobs.flags1 = globs::gameGlobs.flags1 & ~(GAME1_DRAGGINGBOX_UNK|GAME1_UNK_200);
		return;
	}
	if (BOOL_004df570 != 0) {
		globals::g_Front_mslb_Last = 0;
		globals::g_Front_msrb_Last = 0;
		globals::g_Front_mslb_Last_6 = 0;
		leftReleased = 0;
		rightReleased = 0;
		BOOL_004df570 = 0;
	}
	BVar13 = Map3D_GetIntersections
										 ((globs::gameGlobs.level)->surfaceMap,globs::gameGlobs.viewMain,
											globs::INPUT.msx,globs::INPUT.msy,&local_34,(uint *)&local_38,&local_c);
	bVar14 = BVar13 == 0;
	if (!bVar14) {
		elapsedGame = (float)(pLVar3->blocks + (pLVar3->dimensions).width * (int)local_38 + local_34);
		res::Container_SetPosition
							(globs::gameGlobs.resRootLight,NULL,local_c.x,local_c.y,local_c.z - 250.0);
	}
	light::LightEffects_SetDimmerMode((uint)bVar14);
	if ((globs::gameGlobs.flags1 & GAME1_UNK_8000000) != GAME1_NONE) {
		Game_UpdateTopdownCamera(elapsedAbs);
		front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_STANDARD);
		globs::gameGlobs.flags1 = globs::gameGlobs.flags1 & ~(GAME1_DRAGGINGBOX_UNK|GAME1_UNK_200);
		return;
	}
	PVar4 = front::Pointer_GetCurrentType();
	if (((globs::gameGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) &&
		 (BVar13 = Message_IsAnyUnitsSelected(), BVar13 != 0)) {
		pointerType = POINTER_SELECTED;
	}
	else {
		pointerType = POINTER_STANDARD;
	}
	front::Pointer_SetType_IfUnkFloatLessThan0(pointerType);
	if (((globs::gameGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) &&
		 (BVar13 = FUN_0045b070(elapsedAbs,globs::INPUT.msx,globs::INPUT.msy,globs::INPUT.mslb,
														globals::g_Front_mslb_Last,(int)&local_2c), BVar13 != 0)) {
		Game_UpdateTopdownCamera(elapsedAbs);
		globs::gameGlobs.flags1 |= GAME1_UNK_200;
		goto LAB_00427c9c;
	}
	Game_UpdateTopdownCamera(elapsedAbs);
	if ((globs::gameGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) {
		BVar13 = front::PriorityList_UnkUpdate_FUN_0045d3d0
											 (globs::INPUT.msx,globs::INPUT.msy,globs::INPUT.mslb,
												globals::g_Front_mslb_Last,leftReleased);
		if (BVar13 != 0) {
			globs::gameGlobs.flags1 |= GAME1_UNK_200;
			goto LAB_00427c9c;
		}
		if ((((globs::gameGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) &&
				((globs::gameGlobs.flags2 & GAME2_INMENU) == GAME2_NONE)) &&
			 (BVar13 = front::Interface_DoSomethingWithRenameReplace
													 (globs::INPUT.msx,globs::INPUT.msy,globs::INPUT.mslb,
														globals::g_Front_mslb_Last,leftReleased), BVar13 != 0)) {
			globs::gameGlobs.flags1 |= GAME1_UNK_200;
			goto LAB_00427c9c;
		}
		if (((globs::gameGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) != GAME1_NONE) ||
			 (BVar13 = front::Info_Update_FUN_0041a0d0(globs::INPUT.msx,globs::INPUT.msy,leftReleased),
			 BVar13 == 0)) goto LAB_0042682b;
		globs::gameGlobs.flags1 |= GAME1_UNK_200;
		if (leftReleased == 0) goto LAB_00427c9c;
		iVar19 = 0;
LAB_00427c94:
		snd::Audio_FUN_00428730(iVar19);
		goto LAB_00427c9c;
	}
LAB_0042682b:
	if (globs::gameGlobs.viewMode == VIEW_FIRSTPERSON) {
		globs::gameGlobs.flags1 |= GAME1_UNK_200;
		goto LAB_00427c9c;
	}
	if ((((globs::gameGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) &&
			((globs::gameGlobs.flags1 & GAME1_RADARON) != GAME1_NONE)) &&
		 (BVar13 = LevelStruct3C_FUN_0045e920(pLVar3->struct3c_84,globs::INPUT.msx,globs::INPUT.msy),
		 BVar13 != 0)) {
		if (leftReleased != 0) {
			snd::Audio_FUN_00428730(0);
		}
		if ((globs::gameGlobs.flags1 & GAME1_RADAR_TRACKOBJECTVIEW) == GAME1_NONE) {
			front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
		}
		goto LAB_00427c9c;
	}
	if (local_2c != 0) {
		bVar14 = false;
		if ((globs::gameGlobs.NextButton != NULL) &&
			 ((globs::gameGlobs.flags2 & GAME2_UNK_40) != GAME2_NONE)) {
			fVar16 = (float)globs::INPUT.msx;
			fVar11 = (float)(globs::gameGlobs.NextButton)->height;
			if ((((ushort)((ushort)(fVar16 < globs::gameGlobs.NextButtonPos.x) << 8 |
										(ushort)(fVar16 == globs::gameGlobs.NextButtonPos.x) << 0xe) == 0) &&
					(((fVar18 = (float)globs::INPUT.msy,
						(ushort)((ushort)(fVar18 < globs::gameGlobs.NextButtonPos.y) << 8 |
										(ushort)(fVar18 == globs::gameGlobs.NextButtonPos.y) << 0xe) == 0 &&
						(local_24.y = 0.0, local_24.x = (float)(globs::gameGlobs.NextButton)->width,
						fVar16 < (float)(ulonglong)(globs::gameGlobs.NextButton)->width +
										 globs::gameGlobs.NextButtonPos.x)) &&
					 (local_24.y = 0.0, local_24.x = fVar11,
					 fVar18 < (float)(ulonglong)(uint)fVar11 + globs::gameGlobs.NextButtonPos.y)))) &&
				 (front::ToolTip_AddFlag4(TOOLTIP_NEXTMESSAGE), leftReleased != 0)) {
				nerps::NERPs_FUN_00453be0();
				bVar14 = true;
			}
		}
		if ((globs::gameGlobs.BackButton != NULL) &&
			 ((globs::gameGlobs.flags2 & GAME2_UNK_80) != GAME2_NONE)) {
			fVar16 = (float)globs::INPUT.msx;
			fVar11 = (float)(globs::gameGlobs.BackButton)->height;
			if ((((ushort)((ushort)(fVar16 < globs::gameGlobs.BackButtonPos.x) << 8 |
										(ushort)(fVar16 == globs::gameGlobs.BackButtonPos.x) << 0xe) == 0) &&
					((fVar18 = (float)globs::INPUT.msy,
					 (ushort)((ushort)(fVar18 < globs::gameGlobs.BackButtonPos.y) << 8 |
									 (ushort)(fVar18 == globs::gameGlobs.BackButtonPos.y) << 0xe) == 0 &&
					 (local_24.y = 0.0, local_24.x = (float)(globs::gameGlobs.BackButton)->width,
					 fVar16 < (float)(ulonglong)(globs::gameGlobs.BackButton)->width +
										globs::gameGlobs.BackButtonPos.x)))) &&
				 (local_24.y = 0.0, local_24.x = fVar11,
				 fVar18 < (float)(ulonglong)(uint)fVar11 + globs::gameGlobs.BackButtonPos.y)) {
				front::ToolTip_AddFlag4(TOOLTIP_PREVIOUSMESSAGE);
				if (leftReleased == 0) goto LAB_00427c9c;
				unk::NERPs_PlayUnkSampleIndex_IfDat_004a773c();
				bVar14 = true;
			}
		}
		if ((leftReleased == 0) || (bVar14)) goto LAB_00427c9c;
		iVar19 = 1;
		goto LAB_00427c94;
	}
	if (bVar14) goto LAB_00427c9c;
	globs::gameGlobs.vector_45c.y = local_c.y;
	globs::gameGlobs.vector_45c.x = local_c.x;
	globs::gameGlobs.vector_45c.z = local_c.z;
	globs::gameGlobs.flags2 |= GAME2_MOUSE_INSIDEGAMEVIEW;
	globs::gameGlobs.s_mouseBlockPos_ef8.x = local_34;
	globs::gameGlobs.s_mouseBlockPos_ef8.y = (int)local_38;
	if (((globs::gameGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) ||
		 ((globs::gameGlobs.flags3 & (GAME3_UNK_1|GAME3_PLACEBUILDING)) != GAME3_NONE)) {
		if ((globs::gameGlobs.flags3 & GAME3_PLACEBUILDING) == GAME3_NONE) {
			iVar19 = LiveManager_DoPickSphereCallbacks_MouseXY
												 (globs::INPUT.msx,globs::INPUT.msy,&local_3c);
			if (iVar19 == 0) {
				if ((globs::gameGlobs.flags1 & GAME1_LASERTRACKER) != GAME1_NONE) {
					iVar19 = ((globs::gameGlobs.level)->dimensions).width;
					if (((local_34 < iVar19 - 1U) &&
							((uint)local_38 < ((globs::gameGlobs.level)->dimensions).height - 1U)) &&
						 ((LVar9 = (globs::gameGlobs.level)->blocks[(int)local_38 * iVar19 + local_34].flags1,
							(LVar9 & BLOCK1_UNK_10) != BLOCK1_NONE && ((LVar9 & BLOCK1_UNK_8) == BLOCK1_NONE)))) {
						bVar14 = true;
					}
					else {
						bVar14 = false;
					}
					if (bVar14) {
						FUN_004350d0((uint)*(byte *)((int)elapsedGame + 2));
					}
					goto LAB_0042797a;
				}
				if (leftReleased != 0) {
					*(int *)((int)elapsedGame + 0x28) = *(int *)((int)elapsedGame + 0x28) + 1;
				}
				if (((globs::gameGlobs.flags3 & GAME3_PICKUPOBJECT) != GAME3_NONE) ||
					 ((globs::gameGlobs.flags3 & GAME3_LOADVEHICLE) != GAME3_NONE)) {
					if ((globs::gameGlobs.flags3 & GAME3_PICKUPOBJECT) == GAME3_NONE) {
						PVar4 = POINTER_VEHICLECANTPICKUP;
					}
					else {
						PVar4 = POINTER_LEGOMANCANTPICKUP;
					}
					goto LAB_00427972;
				}
				if (((globs::gameGlobs.flags3 & GAME3_UNK_20) == GAME3_NONE) &&
					 ((globs::gameGlobs.flags3 & GAME3_UNK_40) == GAME3_NONE)) {
					if (((globs::gameGlobs.flags3 & GAME3_UNK_2) == GAME3_NONE) &&
						 ((globs::gameGlobs.flags3 & GAME3_UNK_4) == GAME3_NONE)) {
						if ((globs::gameGlobs.flags3 & GAME3_UNK_1) == GAME3_NONE) {
							iVar19 = ((globs::gameGlobs.level)->dimensions).width;
							if ((local_34 < iVar19 - 1U) &&
								 ((uint)local_38 < ((globs::gameGlobs.level)->dimensions).height - 1U)) {
								LVar9 = (globs::gameGlobs.level)->blocks[(int)local_38 * iVar19 + local_34].flags1 &
												BLOCK1_UNK_4;
							}
							else {
								LVar9 = BLOCK1_NONE;
							}
							if (LVar9 != BLOCK1_NONE) {
								iVar19 = ((globs::gameGlobs.level)->dimensions).width;
								if ((((local_34 < iVar19 - 1U) &&
										 ((uint)local_38 < ((globs::gameGlobs.level)->dimensions).height - 1U)) &&
										(LVar9 = (globs::gameGlobs.level)->blocks[(int)local_38 * iVar19 + local_34].
														 flags1, (LVar9 & BLOCK1_UNK_10) != BLOCK1_NONE)) &&
									 ((LVar9 & BLOCK1_UNK_8) == BLOCK1_NONE)) {
									bVar14 = true;
								}
								else {
									bVar14 = false;
								}
								if ((bVar14) &&
									 (((globs::gameGlobs.level)->blocks
										 [((globs::gameGlobs.level)->dimensions).width *
											globs::gameGlobs.s_mouseBlockPos_ef8.y +
											globs::gameGlobs.s_mouseBlockPos_ef8.x].terrain == TERRAIN_IMMOVABLE ||
										((globs::gameGlobs.level)->blocks
										 [((globs::gameGlobs.level)->dimensions).width *
											globs::gameGlobs.s_mouseBlockPos_ef8.y +
											globs::gameGlobs.s_mouseBlockPos_ef8.x].terrain == TERRAIN_RECHARGESEAM)))) {
									if ((*(byte *)((int)elapsedGame + 8) & 8) == 0) {
										FUN_004350d0((uint)*(byte *)((int)elapsedGame + 2));
									}
									if (globals::g_Front_mslb_Last_6 == 0) {
										FUN_00428260(&globs::gameGlobs.s_mouseBlockPos_ef8,TRUE,TRUE,FALSE);
									}
									if (leftReleased != 0) {
										snd::Audio_FUN_00428730(2);
									}
								}
								else {
									fVar11 = 0.0;
									elapsedAbs = 0.0;
									if ((*(byte *)((int)elapsedGame + 8) & 8) == 0) {
										FUN_004350d0((uint)*(byte *)((int)elapsedGame + 2));
									}
									if (globals::g_Front_mslb_Last_6 == 0) {
										FUN_00428260(&globs::gameGlobs.s_mouseBlockPos_ef8,TRUE,TRUE,FALSE);
									}
									BVar13 = Message_IsAnyUnitsSelected();
									if (BVar13 != 0) {
										if ((globs::gameGlobs.flags1 & GAME1_UNK_40000) == GAME1_NONE) {
											if (((*(byte *)((int)elapsedGame + 8) & 8) == 0) &&
												 (BVar13 = Level_FindSelectedUnit_BlockCheck_FUN_00431960
																						 (local_34,(uint)local_38,0), BVar13 != 0)) {
												pLVar8 = Message_GetPrimarySelectedUnit();
												if (pLVar8->objType == OBJECT_MINIFIGURE) {
													PVar4 = POINTER_LEGOMANCANTDIG;
												}
												else {
													PVar4 = POINTER_VEHICLECANTDIG;
												}
												front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
												front::Text_DisplayMessage(TEXT_NODRILL,0,0);
												cVar1 = *(char *)((int)elapsedGame + 2);
												if ((((cVar1 != '\x01') && (cVar1 != '\t')) && (cVar1 != '\v')) &&
													 ((*(byte *)((int)elapsedGame + 8) & 0x40) == 0)) {
													fVar11 = 1.401298e-45;
													elapsedAbs = 1.401298e-45;
													pLVar8 = Message_GetPrimarySelectedUnit();
													if (pLVar8->objType == OBJECT_MINIFIGURE) {
														PVar4 = POINTER_LEGOMANDIG;
													}
													else {
														PVar4 = POINTER_VEHICLEDIG;
													}
													front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
													front::Text_DisplayMessage(TEXT_DRILL,0,0);
													if ((leftReleased != 0) &&
														 (BVar13 = Level_BlockPointerCheck
																								 (&globs::gameGlobs.s_mouseBlockPos_ef8),
														 BVar13 == 0)) {
														ai::AITask_DoDig_AtBlockPos(&globs::gameGlobs.s_mouseBlockPos_ef8,0,1);
														ai::AITask_FUN_00401f40
																			(AITASK_DIG,NULL,&globs::gameGlobs.s_mouseBlockPos_ef8);
														goto LAB_004271d4;
													}
												}
											}
										}
										else {
											if ((*(char *)elapsedGame == '\x01') ||
												 (BVar13 = Level_FindSelectedUnit_BlockCheck_FUN_00431960
																						 (local_34,(uint)local_38,1), BVar13 == 0)) {
												globs::gameGlobs.bool_c8 = 0;
											}
											else {
												globs::gameGlobs.pointi_c0.y = (int)local_38;
												fVar11 = 1.401298e-45;
												globs::gameGlobs.pointi_c0.x = local_34;
												elapsedAbs = 1.401298e-45;
												globs::gameGlobs.bool_c8 = 1;
												if ((leftReleased != 0) &&
													 (BVar13 = Level_BlockPointerCheck(&globs::gameGlobs.s_mouseBlockPos_ef8),
													 BVar13 == 0)) {
													ai::AITask_DoDig_AtBlockPos(&globs::gameGlobs.s_mouseBlockPos_ef8,1,1);
LAB_004271d4:
													elapsedAbs = 1.401298e-45;
													fVar11 = 1.401298e-45;
													snd::Audio_FUN_00428730(0);
													front::Interface_BackToMain();
												}
											}
										}
										if ((fVar11 == 0.0) && ((*(uint *)((int)elapsedGame + 8) & 8) != 0)) {
											if ((((globs::gameGlobs.level)->blocks
														[((globs::gameGlobs.level)->dimensions).width * (int)local_38 + local_34
														].flags1 & BLOCK1_UNK_400) == BLOCK1_NONE) &&
												 ((*(byte *)&(globs::gameGlobs.level)->blocks
																		 [((globs::gameGlobs.level)->dimensions).width * (int)local_38 +
																			local_34].flags2 & 4) == 0)) {
												bVar14 = false;
											}
											else {
												bVar14 = true;
											}
											if ((!bVar14) && ((*(byte *)((int)elapsedGame + 0xc) & 0x20) == 0)) {
												if ((*(uint *)((int)elapsedGame + 8) & 0x200000) == 0) {
													pLVar8 = Message_GetPrimarySelectedUnit();
													OVar7 = LiveObject_GetStatsFlags1(pLVar8);
													if ((OVar7 & STATS1_CANCLEARRUBBLE) != STATS1_NONE) {
														BVar13 = 0;
														uVar15 = local_34;
														fVar16 = local_38;
														uVar17 = local_34;
														fVar18 = local_38;
														pLVar8 = Message_GetPrimarySelectedUnit();
														iVar19 = LiveObject_FUN_00431cd0
																							 (pLVar8,uVar15,(int)fVar16,uVar17,(int)fVar18,BVar13)
														;
														if (iVar19 != 0) {
															fVar11 = 1.401298e-45;
															elapsedAbs = 1.401298e-45;
															pLVar8 = Message_GetPrimarySelectedUnit();
															if (pLVar8->objType == OBJECT_MINIFIGURE) {
																PVar4 = POINTER_LEGOMANCLEAR;
															}
															else {
																PVar4 = POINTER_VEHICLECLEAR;
															}
															front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
															if ((leftReleased != 0) &&
																 (BVar13 = Level_BlockPointerCheck
																										 (&globs::gameGlobs.s_mouseBlockPos_ef8),
																 BVar13 == 0)) {
																Message_AddMessageAction
																					(MESSAGE_USERGOTO,0,0,
																					 &globs::gameGlobs.s_mouseBlockPos_ef8);
																ai::AITask_FUN_00401f40
																					(AITASK_CLEAR,NULL,&globs::gameGlobs.s_mouseBlockPos_ef8);
																snd::Audio_FUN_00428730(0);
																front::Interface_BackToMain();
															}
														}
													}
												}
												if (fVar11 != 0.0) goto LAB_0042797a;
												uVar15 = local_34;
												fVar16 = local_38;
												uVar17 = local_34;
												fVar18 = local_38;
												fVar20 = fVar11;
												pLVar8 = Message_GetPrimarySelectedUnit();
												iVar19 = LiveObject_FUN_00431cd0
																					 (pLVar8,uVar15,(int)fVar16,uVar17,(int)fVar18,
																						(BOOL)fVar20);
												if (iVar19 != 0) {
													fVar11 = 1.401298e-45;
													elapsedAbs = 1.401298e-45;
													pLVar8 = Message_GetPrimarySelectedUnit();
													if (pLVar8->objType == OBJECT_MINIFIGURE) {
														PVar4 = POINTER_LEGOMANGO;
													}
													else {
														PVar4 = POINTER_VEHICLEGO;
													}
													front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
													front::Text_DisplayMessage(TEXT_WALK,0,0);
													if ((leftReleased != 0) &&
														 (BVar13 = Level_BlockPointerCheck
																								 (&globs::gameGlobs.s_mouseBlockPos_ef8),
														 BVar13 == 0)) {
														Message_AddMessageAction
																			(MESSAGE_USERGOTO,0,0,&globs::gameGlobs.s_mouseBlockPos_ef8);
														snd::Audio_FUN_00428730(0);
														front::Interface_BackToMain();
													}
												}
											}
										}
									}
									if (fVar11 == 0.0) {
										if ((((globs::gameGlobs.level)->blocks
													[((globs::gameGlobs.level)->dimensions).width * (int)local_38 + local_34].
													flags1 & BLOCK1_UNK_400) == BLOCK1_NONE) &&
											 ((*(byte *)&(globs::gameGlobs.level)->blocks
																	 [((globs::gameGlobs.level)->dimensions).width * (int)local_38 +
																		local_34].flags2 & 4) == 0)) {
											bVar14 = false;
										}
										else {
											bVar14 = true;
										}
										if ((((!bVar14) && (cVar1 = *(char *)((int)elapsedGame + 2), cVar1 != '\x06'))
												&& (cVar1 != '\t')) && ((*(byte *)((int)elapsedGame + 0xc) & 0x20) == 0)) {
											if ((*(uint *)((int)elapsedGame + 8) & 8) != 0) {
												if (((globs::gameGlobs.level)->blocks
														 [((globs::gameGlobs.level)->dimensions).width *
															globs::gameGlobs.s_mouseBlockPos_ef8.y +
															globs::gameGlobs.s_mouseBlockPos_ef8.x].flags1 & BLOCK1_UNK_80000000)
														!= BLOCK1_NONE) {
													fVar11 = 1.401298e-45;
													elapsedAbs = 1.401298e-45;
													if ((leftReleased != 0) &&
														 (BVar13 = Level_BlockPointerCheck
																								 (&globs::gameGlobs.s_mouseBlockPos_ef8),
														 BVar13 == 0)) {
														Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
														snd::Audio_FUN_00428730(5);
														front::Interface_OpenMenu_FUN_0041b200
																			(INTERFACE_MENU_ERODE,&globs::gameGlobs.s_mouseBlockPos_ef8);
													}
												}
												if (((fVar11 == 0.0) && ((*(uint *)((int)elapsedGame + 8) & 0x8000) != 0))
													 && (elapsedAbs = 1.401298e-45, leftReleased != 0)) {
													snd::Audio_FUN_00428730(1);
												}
												if ((((*(uint *)((int)elapsedGame + 8) & 0x100000) != 0) ||
														(((globs::gameGlobs.level)->blocks
															[((globs::gameGlobs.level)->dimensions).width *
															 globs::gameGlobs.s_mouseBlockPos_ef8.y +
															 globs::gameGlobs.s_mouseBlockPos_ef8.x].flags1 & BLOCK1_UNK_40000000)
														 != BLOCK1_NONE)) &&
													 (((globs::gameGlobs.level)->blocks
														 [((globs::gameGlobs.level)->dimensions).width *
															globs::gameGlobs.s_mouseBlockPos_ef8.y +
															globs::gameGlobs.s_mouseBlockPos_ef8.x].flags1 & BLOCK1_UNK_8000) ==
														BLOCK1_NONE)) {
													if (((globs::gameGlobs.s_mouseBlockPos_ef8.x < 0) ||
															(globs::gameGlobs.s_mouseBlockPos_ef8.y < 0)) ||
														 ((iVar19 = ((globs::gameGlobs.level)->dimensions).width,
															iVar19 <= globs::gameGlobs.s_mouseBlockPos_ef8.x ||
															(((globs::gameGlobs.level)->dimensions).height <=
															 globs::gameGlobs.s_mouseBlockPos_ef8.y)))) {
														LVar9 = BLOCK1_NONE;
													}
													else {
														LVar9 = (globs::gameGlobs.level)->blocks
																		[globs::gameGlobs.s_mouseBlockPos_ef8.y * iVar19 +
																		 globs::gameGlobs.s_mouseBlockPos_ef8.x].flags1 &
																		BLOCK1_POWERPATH;
													}
													if (((LVar9 == BLOCK1_NONE) &&
															(elapsedAbs = 1.401298e-45, leftReleased != 0)) &&
														 (BVar13 = Level_BlockPointerCheck
																								 (&globs::gameGlobs.s_mouseBlockPos_ef8),
														 BVar13 == 0)) {
														snd::Audio_FUN_00428730(5);
														front::Interface_OpenMenu_FUN_0041b200
																			(INTERFACE_MENU_CONSTRUCTION,
																			 &globs::gameGlobs.s_mouseBlockPos_ef8);
													}
												}
												if (elapsedAbs != 0.0) goto LAB_0042797a;
												if (((globs::gameGlobs.level)->blocks
														 [((globs::gameGlobs.level)->dimensions).width *
															globs::gameGlobs.s_mouseBlockPos_ef8.y +
															globs::gameGlobs.s_mouseBlockPos_ef8.x].flags1 & BLOCK1_UNK_40000000)
														== BLOCK1_NONE) {
													if (((globs::gameGlobs.s_mouseBlockPos_ef8.x < 0) ||
															(globs::gameGlobs.s_mouseBlockPos_ef8.y < 0)) ||
														 ((iVar19 = ((globs::gameGlobs.level)->dimensions).width,
															iVar19 <= globs::gameGlobs.s_mouseBlockPos_ef8.x ||
															(((globs::gameGlobs.level)->dimensions).height <=
															 globs::gameGlobs.s_mouseBlockPos_ef8.y)))) {
														LVar9 = BLOCK1_NONE;
													}
													else {
														LVar9 = (globs::gameGlobs.level)->blocks
																		[globs::gameGlobs.s_mouseBlockPos_ef8.y * iVar19 +
																		 globs::gameGlobs.s_mouseBlockPos_ef8.x].flags1 &
																		BLOCK1_POWERPATH;
													}
													fVar11 = elapsedAbs;
													if (LVar9 != BLOCK1_NONE) goto LAB_004275d9;
												}
												else {
LAB_004275d9:
													fVar11 = 1.401298e-45;
													if ((leftReleased != 0) &&
														 (BVar13 = Level_BlockPointerCheck
																								 (&globs::gameGlobs.s_mouseBlockPos_ef8),
														 BVar13 == 0)) {
														Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
														snd::Audio_FUN_00428730(5);
														front::Interface_OpenMenu_FUN_0041b200
																			(INTERFACE_MENU_GROUND,&globs::gameGlobs.s_mouseBlockPos_ef8);
													}
												}
												if (fVar11 == 0.0) {
													if ((((*(uint *)((int)elapsedGame + 8) & 0x200000) != 0) &&
															(fVar11 = 1.401298e-45, leftReleased != 0)) &&
														 (BVar13 = Level_BlockPointerCheck
																								 (&globs::gameGlobs.s_mouseBlockPos_ef8),
														 BVar13 == 0)) {
														Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
														snd::Audio_FUN_00428730(5);
														front::Interface_OpenMenu_FUN_0041b200
																			(INTERFACE_MENU_GROUND,&globs::gameGlobs.s_mouseBlockPos_ef8);
													}
													if (fVar11 == 0.0) {
														if ((((*(uint *)((int)elapsedGame + 8) & 0x200000) != 0) ||
																(fVar11 = 1.401298e-45, leftReleased == 0)) ||
															 (BVar13 = Level_BlockPointerCheck
																									 (&globs::gameGlobs.s_mouseBlockPos_ef8),
															 BVar13 != 0)) goto LAB_00427713;
														Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
														snd::Audio_FUN_00428730(5);
														interfaceMenuType = INTERFACE_MENU_RUBBLE;
														goto LAB_0042770b;
													}
												}
												goto LAB_0042797a;
											}
											if (((cVar1 == '\x01') || ((*(uint *)((int)elapsedGame + 8) & 0x40) != 0)) ||
												 ((fVar11 = 1.401298e-45, leftReleased == 0 ||
													(BVar13 = Level_BlockPointerCheck(&globs::gameGlobs.s_mouseBlockPos_ef8),
													BVar13 != 0)))) goto LAB_00427713;
											Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
											snd::Audio_FUN_00428730(4);
											interfaceMenuType = INTERFACE_MENU_WALL;
LAB_0042770b:
											fVar11 = 1.401298e-45;
											front::Interface_OpenMenu_FUN_0041b200
																(interfaceMenuType,&globs::gameGlobs.s_mouseBlockPos_ef8);
										}
LAB_00427713:
										if (fVar11 == 0.0) goto LAB_0042771b;
									}
								}
								goto LAB_0042797a;
							}
						}
						else {
							globs::gameGlobs.flags1 |= GAME1_UNK_200;
							front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_CANTHELP);
							front::Text_DisplayMessage(TEXT_ENCYCLOPEDIA,0,0);
						}
LAB_0042771b:
						if (leftReleased != 0) {
LAB_00427727:
							snd::Audio_FUN_00428730(1);
						}
					}
					else {
						if ((globs::gameGlobs.flags3 & GAME3_UNK_2) == GAME3_NONE) {
							PVar4 = POINTER_VEHICLECANTGO;
						}
						else {
							PVar4 = POINTER_LEGOMANCANTGO;
						}
						front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
						if (((*(byte *)((int)elapsedGame + 8) & 8) != 0) &&
							 (BVar13 = Message_IsAnyUnitsSelected(), BVar13 != 0)) {
							BVar13 = 0;
							uVar15 = local_34;
							fVar11 = local_38;
							uVar17 = local_34;
							fVar16 = local_38;
							pLVar8 = Message_GetPrimarySelectedUnit();
							iVar19 = LiveObject_FUN_00431cd0(pLVar8,uVar15,(int)fVar11,uVar17,(int)fVar16,BVar13);
							if (iVar19 != 0) {
								if ((globs::gameGlobs.flags3 & GAME3_UNK_2) == GAME3_NONE) {
									PVar4 = POINTER_VEHICLEGO;
								}
								else {
									PVar4 = POINTER_LEGOMANGO;
								}
								front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
								front::Text_DisplayMessage(TEXT_WALK,0,0);
								if ((leftReleased != 0) &&
									 (BVar13 = Level_BlockPointerCheck(&globs::gameGlobs.s_mouseBlockPos_ef8),
									 BVar13 == 0)) {
									Message_AddMessageAction
														(MESSAGE_USERGOTO,0,0,&globs::gameGlobs.s_mouseBlockPos_ef8);
									snd::Audio_FUN_00428730(0);
									front::Interface_BackToMain();
								}
							}
						}
					}
				}
				else {
					if ((globs::gameGlobs.flags3 & GAME3_UNK_20) == GAME3_NONE) {
						PVar4 = POINTER_VEHICLECANTDIG;
					}
					else {
						PVar4 = POINTER_LEGOMANCANTDIG;
					}
					front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
					front::Text_DisplayMessage(TEXT_NODRILL,0,0);
					if ((globs::gameGlobs.flags1 & GAME1_UNK_40000) == GAME1_NONE) {
						if ((((((*(uint *)((int)elapsedGame + 8) & 8) == 0) &&
									(cVar1 = *(char *)((int)elapsedGame + 2), cVar1 != '\x01')) && (cVar1 != '\t')) &&
								((cVar1 != '\v' && ((*(uint *)((int)elapsedGame + 8) & 0x40) == 0)))) &&
							 ((BVar13 = Message_IsAnyUnitsSelected(), BVar13 == 0 ||
								(BVar13 = Level_FindSelectedUnit_BlockCheck_FUN_00431960(local_34,(uint)local_38,0),
								BVar13 != 0)))) {
							if ((globs::gameGlobs.flags3 & GAME3_UNK_20) == GAME3_NONE) {
								PVar4 = POINTER_VEHICLEDIG;
							}
							else {
								PVar4 = POINTER_LEGOMANDIG;
							}
							front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
							front::Text_DisplayMessage(TEXT_DRILL,0,0);
							if ((leftReleased != 0) &&
								 (BVar13 = Level_BlockPointerCheck(&globs::gameGlobs.s_mouseBlockPos_ef8),
								 BVar13 == 0)) {
								ai::AITask_DoDig_AtBlockPos(&globs::gameGlobs.s_mouseBlockPos_ef8,0,1);
								goto LAB_00427954;
							}
						}
					}
					else {
						if ((*(char *)elapsedGame == '\x01') ||
							 ((BVar13 = Message_IsAnyUnitsSelected(), BVar13 != 0 &&
								(BVar13 = Level_FindSelectedUnit_BlockCheck_FUN_00431960(local_34,(uint)local_38,1),
								BVar13 == 0)))) {
							globs::gameGlobs.bool_c8 = 0;
						}
						else {
							globs::gameGlobs.pointi_c0.y = (int)local_38;
							globs::gameGlobs.pointi_c0.x = local_34;
							globs::gameGlobs.bool_c8 = 1;
							if ((leftReleased != 0) &&
								 (BVar13 = Level_BlockPointerCheck(&globs::gameGlobs.s_mouseBlockPos_ef8),
								 BVar13 == 0)) {
								ai::AITask_DoDig_AtBlockPos(&globs::gameGlobs.s_mouseBlockPos_ef8,1,1);
								snd::Audio_FUN_00428730(0);
								front::Interface_BackToMain();
							}
						}
					}
				}
			}
			else {
				if ((local_3c->objType == OBJECT_MINIFIGURE) && (local_3c->drivenObject != NULL)) {
					local_3c = local_3c->drivenObject;
				}
				if (local_3c->carryingThisObject != NULL) {
					local_3c = local_3c->carryingThisObject;
				}
				if (((local_3c->objType == OBJECT_VEHICLE) &&
						(BVar13 = Message_IsAnyUnitsSelected(), BVar13 != 0)) &&
					 (pLVar5 = Message_GetPrimarySelectedUnit(), pLVar8 = local_3c,
					 pLVar5->objType == OBJECT_MINIFIGURE)) {
					pLVar5 = Message_GetPrimarySelectedUnit();
					LVar12 = LIVEOBJ5_ABILITY_SAILOR;
					OVar6 = LiveObject_GetStatsFlags3(pLVar8);
					if ((OVar6 & STATS3_NEEDSPILOT) == STATS3_NONE) {
						OVar7 = LiveObject_GetStatsFlags1(pLVar8);
						if ((OVar7 & STATS1_CROSSLAND) != STATS1_NONE) {
							OVar7 = LiveObject_GetStatsFlags1(pLVar8);
							LVar12 = (-(uint)((OVar7 & STATS1_CROSSWATER) != STATS1_NONE) & 0xfffffffd) +
											 LIVEOBJ5_ABILITY_DRIVER;
						}
					}
					else {
						LVar12 = LIVEOBJ5_ABILITY_PILOT;
					}
					if ((pLVar5->flags5_3f0 & LVar12) != LIVEOBJ5_NONE) {
						if (leftReleased == 0) {
							PVar4 = POINTER_GETIN;
							goto LAB_00427972;
						}
						ai::AITask_DoFindDriver_Target(pLVar8);
						snd::Audio_FUN_00428730(0);
						front::Interface_BackToMain();
					}
				}
				else {
					if (((globs::gameGlobs.flags3 & GAME3_UNK_20) == GAME3_NONE) &&
						 ((globs::gameGlobs.flags3 & GAME3_UNK_40) == GAME3_NONE)) {
						if (((globs::gameGlobs.flags3 & GAME3_PICKUPOBJECT) == GAME3_NONE) &&
							 ((globs::gameGlobs.flags3 & GAME3_LOADVEHICLE) == GAME3_NONE)) {
							if (((globs::gameGlobs.flags3 & GAME3_UNK_2) != GAME3_NONE) ||
								 ((globs::gameGlobs.flags3 & GAME3_UNK_4) != GAME3_NONE)) {
								if ((globs::gameGlobs.flags3 & GAME3_UNK_2) == GAME3_NONE) {
									PVar4 = POINTER_VEHICLECANTGO;
								}
								else {
									PVar4 = POINTER_LEGOMANCANTGO;
								}
								goto LAB_00427972;
							}
							if ((globs::gameGlobs.flags3 & GAME3_UNK_1) == GAME3_NONE) {
								BVar13 = LiveObject_CheckCondition_FUN_00438870(local_3c,1);
								if (BVar13 != 0) {
									front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SELECTED);
									if (globals::g_Front_mslb_Last_6 == 0) {
										LiveObject_ShowToolTip(local_3c);
									}
									if (leftReleased == 0) {
										pLVar8 = Message_GetPrimarySelectedUnit();
										if ((pLVar8 != NULL) &&
											 ((local_3c->objType == OBJECT_POWERCRYSTAL ||
												(local_3c->objType == OBJECT_ORE)))) {
											LiveObject_GetBlockPos(local_3c,(int *)&local_24,(int *)&local_24.y);
											iVar19 = LiveObject_FUN_00431cd0
																				 (pLVar8,(int)local_24.x,(int)local_24.y,(int)local_24.x,
																					(int)local_24.y,0);
											if (iVar19 != 0) {
												if (local_3c->objType == OBJECT_ORE) {
													PVar4 = POINTER_PICKUPORE;
												}
												else {
													if (pLVar8->objType == OBJECT_MINIFIGURE) {
														PVar4 = POINTER_LEGOMANPICKUP;
													}
													else {
														if (pLVar8->objType != OBJECT_VEHICLE) goto LAB_0042797a;
														PVar4 = POINTER_VEHICLEPICKUP;
													}
												}
LAB_00427972:
												front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
											}
										}
									}
									else {
										TVar10 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
										if (((TVar10 & TUTORIAL_UNK_8) != TUTORIAL_NONE) ||
											 ((TVar10 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL),
												TVar10 != TUTORIAL_NONE && (local_3c->field_3f8 == 0)))) goto LAB_00427727;
										BVar13 = front::Interface_FUN_0041e8c0(local_3c->objType,local_3c->objIndex);
										if (((BVar13 != 0) &&
												(((local_3c->flags2 & LIVEOBJ2_UNK_2) == LIVEOBJ2_NONE &&
												 ((OVar2 = local_3c->objType, OVar2 != OBJECT_VEHICLE ||
													((local_3c->flags1 & LIVEOBJ1_CLEARING) == LIVEOBJ1_NONE)))))) &&
											 (((globs::gameGlobs.flags1 & GAME1_LASERTRACKER) == GAME1_NONE ||
												((*(byte *)&local_3c->flags4 & 1) != 0)))) {
											if ((((OVar2 == OBJECT_VEHICLE) || (OVar2 == OBJECT_BUILDING)) ||
													(OVar2 == OBJECT_MINIFIGURE)) ||
												 ((OVar2 == OBJECT_ELECTRICFENCE &&
													((local_3c->flags2 & LIVEOBJ2_UNK_2000000) != LIVEOBJ2_NONE)))) {
												snd::Audio_FUN_00428730(0);
												if (((param_5 == 0) &&
														(Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL), true)) ||
													 (BVar13 = Message_LiveObject_Check_IsSelected_OrFlags3_200000
																							 (local_3c,NULL), BVar13 == 0)) {
													Message_AddMessageAction(MESSAGE_SELECT,local_3c,0,NULL);
													Message_AddMessageAction(MESSAGE_REDUCESELECTION,0,0,NULL);
												}
											}
											else {
												if ((OVar2 == OBJECT_POWERCRYSTAL) || (OVar2 == OBJECT_ORE)) {
													pLVar8 = Message_GetPrimarySelectedUnit();
													if (pLVar8 != NULL) {
														LiveObject_GetBlockPos(local_3c,(int *)&local_24,(int *)&local_24.y);
														iVar19 = LiveObject_FUN_00431cd0
																							 (pLVar8,(int)local_24.x,(int)local_24.y,
																								(int)local_24.x,(int)local_24.y,0);
														if (iVar19 != 0) {
															opt_blockPos = &local_24;
															goto LAB_00426def;
														}
													}
												}
												else {
													snd::Audio_FUN_00428730(1);
												}
											}
										}
									}
								}
							}
							else {
								globs::gameGlobs.flags1 |= GAME1_UNK_200;
								front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_HELP);
								front::Text_DisplayMessage(TEXT_ENCYCLOPEDIA,0,0);
								if (leftReleased != 0) {
									snd::Audio_FUN_00428730(0);
									front::Encyclopedia_FUN_0040e630((undefined4 *)local_3c);
								}
							}
						}
						else {
							if ((globs::gameGlobs.flags3 & GAME3_PICKUPOBJECT) == GAME3_NONE) {
								PVar4 = POINTER_VEHICLECANTPICKUP;
							}
							else {
								PVar4 = POINTER_LEGOMANCANTPICKUP;
							}
							front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
							OVar2 = local_3c->objType;
							if ((((OVar2 == OBJECT_ORE) || (OVar2 == OBJECT_POWERCRYSTAL)) ||
									((OVar2 == OBJECT_ELECTRICFENCE &&
									 ((local_3c->flags2 & LIVEOBJ2_UNK_2000000) == LIVEOBJ2_NONE)))) ||
								 ((OVar2 == OBJECT_DYNAMITE &&
									((local_3c->flags3 & LIVEOBJ3_UNK_10000) == LIVEOBJ3_NONE)))) {
								BVar13 = 0;
								uVar15 = local_34;
								fVar11 = local_38;
								uVar17 = local_34;
								fVar16 = local_38;
								pLVar8 = Message_GetPrimarySelectedUnit();
								iVar19 = LiveObject_FUN_00431cd0
																	 (pLVar8,uVar15,(int)fVar11,uVar17,(int)fVar16,BVar13);
								if (iVar19 != 0) {
									if (local_3c->objType == OBJECT_ORE) {
										PVar4 = POINTER_PICKUPORE;
									}
									else {
										if ((globs::gameGlobs.flags3 & GAME3_PICKUPOBJECT) == GAME3_NONE) {
											PVar4 = POINTER_VEHICLEPICKUP;
										}
										else {
											PVar4 = POINTER_LEGOMANPICKUP;
										}
									}
									front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
									if (leftReleased != 0) {
										opt_blockPos = (Point2F *)&globs::gameGlobs.s_mouseBlockPos_ef8;
LAB_00426def:
										Message_AddMessageAction(MESSAGE_USERGOTO,0,0,(Point2I *)opt_blockPos);
										ai::AITask_LiveObject_FUN_004025f0(local_3c);
										ai::AITask_FUN_00401f40(AITASK_COLLECT,local_3c,NULL);
LAB_00427954:
										snd::Audio_FUN_00428730(0);
										front::Interface_BackToMain();
									}
								}
							}
						}
					}
					else {
						if ((globs::gameGlobs.flags3 & GAME3_UNK_20) == GAME3_NONE) {
							PVar4 = POINTER_VEHICLECANTDIG;
						}
						else {
							PVar4 = POINTER_LEGOMANCANTDIG;
						}
						front::Pointer_SetType_IfUnkFloatLessThan0(PVar4);
						front::Text_DisplayMessage(TEXT_NODRILL,FALSE,FALSE);
					}
				}
			}
		}
		else {
			local_1c.x = local_c.x;
			local_1c.y = local_c.y;
			local_28 = 1;
			BVar13 = Game_UnkBuildingPlaceDirection
												 (globs::gameGlobs.placeObjType,globs::gameGlobs.placeObjIndex,leftReleased,
													FALSE,&local_1c,local_34,(uint)local_38,TRUE,
													globs::gameGlobs.RES_2f4_TABLEUNK);
			if (BVar13 == 0) {
				globs::gameGlobs.flags3 &= ~GAME3_PLACEBUILDING;
			}
			if (leftReleased != 0) {
				*(int *)((int)elapsedGame + 0x28) = *(int *)((int)elapsedGame + 0x28) + 1;
			}
		}
	}
LAB_0042797a:
	if ((((globs::gameGlobs.flags3 & GAME3_PLACEBUILDING) == GAME3_NONE) &&
			((globs::gameGlobs.flags1 & GAME1_LASERTRACKER) == GAME1_NONE)) &&
		 (TVar10 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL),
		 (TVar10 & TUTORIAL_UNK_200) == TUTORIAL_NONE)) {
		if (globs::INPUT.mslb == 0) {
			if ((globs::gameGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) {
				globs::gameGlobs.vectorDragStartUnk_a4.x = local_c.x;
				globs::gameGlobs.vectorDragStartUnk_a4.y = local_c.y;
				globs::gameGlobs.vectorDragStartUnk_a4.z = local_c.z;
			}
			else {
				local_24.x = (float)globs::INPUT.msx;
				local_24.y = (float)globs::INPUT.msy;
				TVar10 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
				if ((TVar10 & TUTORIAL_UNK_8) == TUTORIAL_NONE) {
					if (param_5 == 0) {
						Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
					}
					lego::view::Viewport_WorldToScreen
										(globs::gameGlobs.viewMain,&local_14,&globs::gameGlobs.vectorDragStartUnk_a4);
					lego::view::Viewport_DoSelection(globs::gameGlobs.viewMain,&local_14,&local_24);
					snd::Audio_FUN_00428730(0);
				}
			}
			globs::gameGlobs.float_b0 = (float)(ulonglong)local_34;
			local_24.x = local_38;
			local_24.y = 0.0;
			globs::gameGlobs.float_b4 = (float)(ulonglong)(uint)local_38;
		}
		if (((globals::g_Front_mslb_Last_6 != 0) &&
				((globs::gameGlobs.flags2 & GAME2_NOMULTISELECT) == GAME2_NONE)) &&
			 ((globs::gameGlobs.flags1 & GAME1_UNK_200) == GAME1_NONE)) {
			if (((globs::gameGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) == GAME1_NONE) &&
				 (fVar11 = SQRT(Point2F_004df418.y * Point2F_004df418.y +
												Point2F_004df418.x * Point2F_004df418.x),
				 (ushort)((ushort)(fVar11 < 10.0) << 8 | (ushort)(fVar11 == 10.0) << 0xe) == 0)) {
				globs::gameGlobs.flags1 |= GAME1_DRAGGINGBOX_UNK;
			}
			globs::gameGlobs.float_b8 = (float)(ulonglong)local_34;
			local_24.x = local_38;
			local_24.y = 0.0;
			globs::gameGlobs.float_bc = (float)(ulonglong)(uint)local_38;
		}
	}
	if ((globs::gameGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != GAME2_NONE) {
		Game_HandleDebugKeys(local_34,(int)local_38,local_3c);
	}
LAB_00427c9c:
	if (((local_28 == 0) && ((globs::gameGlobs.flags3 & GAME3_PLACEBUILDING) != GAME3_NONE)) &&
		 (BVar13 = Game_UnkBuildingPlaceDirection
												 (globs::gameGlobs.placeObjType,globs::gameGlobs.placeObjIndex,leftReleased,
													rightReleased,NULL,local_34,(uint)local_38,0,
													globs::gameGlobs.RES_2f4_TABLEUNK), BVar13 == 0)) {
		globs::gameGlobs.flags3 &= ~GAME3_PLACEBUILDING;
	}
	if (globals::g_Front_mslb_Last_6 == 0) {
		globs::gameGlobs.flags1 &= ~(GAME1_DRAGGINGBOX_UNK|GAME1_UNK_200);
	}
	globals::g_Front_mslb_Last = globs::INPUT.mslb;
	globals::g_Front_msrb_Last = globs::INPUT.msrb;
	return;
}



void __cdecl lego::main::Main_Load_ToolTipInfo(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ToolTipInfo","HealthText",0);
	globs::gameGlobs.HealthText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ToolTipInfo","EnergyText",0);
	globs::gameGlobs.EnergyText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ToolTipInfo","CrystalsText",0);
	globs::gameGlobs.CrystalsText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ToolTipInfo","OreText",0);
	globs::gameGlobs.OreText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ToolTipInfo","StudsText",0);
	globs::gameGlobs.StudsText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ToolTipInfo","ToolsText",0);
	globs::gameGlobs.ToolsText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ToolTipInfo","CarryObjectText",0);
	globs::gameGlobs.CarryObjectText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ToolTipInfo","DrivenByText",0);
	globs::gameGlobs.DrivenByText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ToolTipInfo","OreRequiredText",0);
	globs::gameGlobs.OreRequiredText = cfg::CFG_CopyString(root,pcVar1);
	return;
}



void __cdecl lego::main::Main_LoadUpgradeNames(CFGProperty *root)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *prop;
	int iVar3;
	uint uVar4;
	
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"UpgradeNames",0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (prop == NULL) {
			return;
		}
		uVar4 = 0xffffffff;
		pcVar2 = "Level";
		do {
			if (uVar4 == 0) break;
			uVar4 -= 1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar2 + 1;
		} while (cVar1 != '\0');
		iVar3 = std::_strnicmp("Level",prop->key,~uVar4 - 1);
		if (iVar3 == 0) {
			uVar4 = 0xffffffff;
			pcVar2 = "Level";
			do {
				if (uVar4 == 0) break;
				uVar4 -= 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar2 + 1;
			} while (cVar1 != '\0');
			uVar4 = std::atoi(prop->key + (~uVar4 - 1));
			if (uVar4 < 0x10) {
				pcVar2 = std::_strdup(prop->value);
				globs::gameGlobs.UpgradeNames_TABLE[uVar4] = pcVar2;
			}
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



void __cdecl lego::game::LiveObject_ShowToolTip(LiveObject *liveObj)
{
	char cVar1;
	ObjectType OVar2;
	ImageBMP *image;
	char *pcVar3;
	BOOL BVar4;
	undefined4 uVar5;
	SFXType sfxType;
	int iVar6;
	uint uVar7;
	uint uVar8;
	undefined4 *puVar9;
	ImageBMP **ppIVar10;
	byte bVar11;
	char *pcVar12;
	char *pcVar13;
	undefined4 *puVar14;
	ToolType *pTVar15;
	longlong lVar16;
	char local_180 [128];
	char local_100 [256];
	
	pcVar3 = LiveObject_GetName(liveObj);
	if (pcVar3 != NULL) {
		pcVar3 = LiveObject_GetName(liveObj);
		iVar6 = -1;
		do {
			if (iVar6 == 0) break;
			iVar6 += -1;
			cVar1 = *pcVar3;
			pcVar3 = pcVar3 + 1;
		} while (cVar1 != '\0');
		if (iVar6 != -2) {
			if (PTRLiveObject_004df574 != liveObj) {
				PTRLiveObject_004df574 = liveObj;
				return;
			}
			if ((liveObj->customName != NULL) && (*liveObj->customName == '\0')) {
				LiveObject_SetCustomName(liveObj,NULL);
			}
			pcVar3 = liveObj->customName;
			if (pcVar3 == NULL) {
				pcVar3 = LiveObject_GetName(liveObj);
			}
			uVar7 = 0xffffffff;
			do {
				pcVar12 = pcVar3;
				if (uVar7 == 0) break;
				uVar7 -= 1;
				pcVar12 = pcVar3 + 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar12;
			} while (cVar1 != '\0');
			uVar7 = ~uVar7;
			puVar9 = (undefined4 *)(pcVar12 + -uVar7);
			puVar14 = (undefined4 *)local_100;
			for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
				*puVar14 = *puVar9;
				puVar9 = puVar9 + 1;
				puVar14 = puVar14 + 1;
			}
			OVar2 = liveObj->objType;
			for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
				*(undefined *)puVar14 = *(undefined *)puVar9;
				puVar9 = (undefined4 *)((int)puVar9 + 1);
				puVar14 = (undefined4 *)((int)puVar14 + 1);
			}
			if ((OVar2 == OBJECT_BUILDING) &&
				 (globs::gameGlobs.UpgradeNames_TABLE[liveObj->objLevel] != NULL)) {
				std::sprintf(local_180," (%s)",globs::gameGlobs.UpgradeNames_TABLE[liveObj->objLevel]);
				uVar7 = 0xffffffff;
				pcVar3 = local_180;
				do {
					pcVar12 = pcVar3;
					if (uVar7 == 0) break;
					uVar7 -= 1;
					pcVar12 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar12;
				} while (cVar1 != '\0');
				uVar7 = ~uVar7;
				iVar6 = -1;
				pcVar3 = local_100;
				do {
					pcVar13 = pcVar3;
					if (iVar6 == 0) break;
					iVar6 += -1;
					pcVar13 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar13;
				} while (cVar1 != '\0');
				puVar9 = (undefined4 *)(pcVar12 + -uVar7);
				puVar14 = (undefined4 *)(pcVar13 + -1);
				for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
					*puVar14 = *puVar9;
					puVar9 = puVar9 + 1;
					puVar14 = puVar14 + 1;
				}
				for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
					*(undefined *)puVar14 = *(undefined *)puVar9;
					puVar9 = (undefined4 *)((int)puVar9 + 1);
					puVar14 = (undefined4 *)((int)puVar14 + 1);
				}
			}
			if (((((liveObj->flags3 & LIVEOBJ3_UNK_40000) != LIVEOBJ3_NONE) &&
					 (BVar4 = front::DamageFont_LiveObject_CheckCanShowDamage_Unk(liveObj), BVar4 != 0)) &&
					(liveObj->objType != OBJECT_MINIFIGURE)) && (liveObj->objType != OBJECT_ROCKMONSTER)) {
				if (0.0 <= liveObj->health) {
					lVar16 = __ftol((float10)liveObj->health);
					uVar5 = (undefined4)lVar16;
				}
				else {
					uVar5 = 0;
				}
				std::sprintf(local_180,"\n%s: %i",globs::gameGlobs.EnergyText,uVar5);
				uVar7 = 0xffffffff;
				pcVar3 = local_180;
				do {
					pcVar12 = pcVar3;
					if (uVar7 == 0) break;
					uVar7 -= 1;
					pcVar12 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar12;
				} while (cVar1 != '\0');
				uVar7 = ~uVar7;
				iVar6 = -1;
				pcVar3 = local_100;
				do {
					pcVar13 = pcVar3;
					if (iVar6 == 0) break;
					iVar6 += -1;
					pcVar13 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar13;
				} while (cVar1 != '\0');
				puVar9 = (undefined4 *)(pcVar12 + -uVar7);
				puVar14 = (undefined4 *)(pcVar13 + -1);
				for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
					*puVar14 = *puVar9;
					puVar9 = puVar9 + 1;
					puVar14 = puVar14 + 1;
				}
				for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
					*(undefined *)puVar14 = *(undefined *)puVar9;
					puVar9 = (undefined4 *)((int)puVar9 + 1);
					puVar14 = (undefined4 *)((int)puVar14 + 1);
				}
			}
			if (((liveObj->objType == OBJECT_VEHICLE) && (liveObj->drivenObject != NULL)) &&
				 ((pcVar3 = liveObj->drivenObject->customName, pcVar3 != NULL &&
					((*pcVar3 != '\0' && (globs::gameGlobs.DrivenByText != NULL)))))) {
				std::sprintf(local_180,"\n%s: %s",globs::gameGlobs.DrivenByText,pcVar3);
				uVar7 = 0xffffffff;
				pcVar3 = local_180;
				do {
					pcVar12 = pcVar3;
					if (uVar7 == 0) break;
					uVar7 -= 1;
					pcVar12 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar12;
				} while (cVar1 != '\0');
				uVar7 = ~uVar7;
				iVar6 = -1;
				pcVar3 = local_100;
				do {
					pcVar13 = pcVar3;
					if (iVar6 == 0) break;
					iVar6 += -1;
					pcVar13 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar13;
				} while (cVar1 != '\0');
				puVar9 = (undefined4 *)(pcVar12 + -uVar7);
				puVar14 = (undefined4 *)(pcVar13 + -1);
				for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
					*puVar14 = *puVar9;
					puVar9 = puVar9 + 1;
					puVar14 = puVar14 + 1;
				}
				for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
					*(undefined *)puVar14 = *(undefined *)puVar9;
					puVar9 = (undefined4 *)((int)puVar9 + 1);
					puVar14 = (undefined4 *)((int)puVar14 + 1);
				}
			}
			front::ToolTip_SetText(TOOLTIP_UNITSELECTED,local_100);
			sfxType = LiveObject_GetObjTtSFX(liveObj);
			front::ToolTip_SetSFX(TOOLTIP_UNITSELECTED,sfxType);
			if (liveObj->objType == OBJECT_MINIFIGURE) {
				uVar7 = 0;
				if (liveObj->numCarriedTools != 0) {
					pTVar15 = liveObj->carriedTools;
					do {
						if (globs::liveGlobs.ToolTipIcons_Tools_TABLE[*pTVar15] != NULL) {
							front::ToolTip_AddIcon
												(TOOLTIP_UNITSELECTED,globs::liveGlobs.ToolTipIcons_Tools_TABLE[*pTVar15]);
						}
						uVar7 += 1;
						pTVar15 = pTVar15 + 1;
					} while (uVar7 < liveObj->numCarriedTools);
				}
				uVar8 = LiveObject_GetNumOfToolsCanCarry(liveObj);
				if (uVar7 < uVar8) {
					do {
						if (globs::liveGlobs.ToolTipIcon_Blank != NULL) {
							front::ToolTip_AddIcon(TOOLTIP_UNITSELECTED,globs::liveGlobs.ToolTipIcon_Blank);
						}
						uVar7 += 1;
						uVar8 = LiveObject_GetNumOfToolsCanCarry(liveObj);
					} while (uVar7 < uVar8);
				}
				if (liveObj->flags5_3f0 != LIVEOBJ5_NONE) {
					front::ToolTip_AddIcon(TOOLTIP_UNITSELECTED,NULL);
					bVar11 = 0;
					ppIVar10 = globs::liveGlobs.ToolTipIcons_Abilities;
					do {
						image = globs::liveGlobs.ToolTipIcon_Blank;
						if ((liveObj->flags5_3f0 & 1 << (bVar11 & 0x1f)) != LIVEOBJ5_NONE) {
							image = *ppIVar10;
						}
						if (image != NULL) {
							front::ToolTip_AddIcon(TOOLTIP_UNITSELECTED,image);
						}
						ppIVar10 = ppIVar10 + 1;
						bVar11 += 1;
					} while (ppIVar10 < globs::liveGlobs.ToolTipIcons_Tools_TABLE);
				}
			}
			front::ToolTip_AddFlag4(TOOLTIP_UNITSELECTED);
		}
	}
	return;
}



void __cdecl FUN_00428260(Point2I *mouseBlockPos,BOOL param_2,BOOL param_3,BOOL param_4)
{
	LevelBlock *pLVar1;
	char cVar2;
	LevelBlockFlags1 LVar3;
	BlockStruct_d4 *pBVar4;
	bool bVar5;
	char *pcVar6;
	int iVar7;
	int iVar8;
	int iVar9;
	int iVar10;
	int iVar11;
	int iVar12;
	char *pcVar13;
	LevelBlockFlags1 LVar14;
	uint uVar15;
	uint uVar16;
	uint uVar17;
	undefined4 *puVar18;
	char *pcVar19;
	undefined4 *puVar20;
	SurfaceType SVar21;
	char buff2 [128];
	char buff1 [128];
	
	iVar9 = mouseBlockPos->y;
	iVar10 = mouseBlockPos->x;
	pLVar1 = (lego::globs::gameGlobs.level)->blocks +
					 ((lego::globs::gameGlobs.level)->dimensions).width * iVar9 + iVar10;
	if ((Point2I_004df208.x != iVar10) || (Point2I_004df208.y != iVar9)) {
		Point2I_004df208.x = mouseBlockPos->x;
		Point2I_004df208.y = mouseBlockPos->y;
		return;
	}
	LVar3 = pLVar1->flags1;
	pcVar6 = (char *)(LVar3 & BLOCK1_UNK_100000);
	if ((((pcVar6 != NULL) &&
			 (((lego::globs::gameGlobs.level)->blocks
				 [((lego::globs::gameGlobs.level)->dimensions).width * iVar9 + iVar10].flags1 &
				BLOCK1_UNK_400) == BLOCK1_NONE)) &&
			((*(byte *)&(lego::globs::gameGlobs.level)->blocks
									[((lego::globs::gameGlobs.level)->dimensions).width * iVar9 + iVar10].flags2 & 4)
			 == 0)) && ((LVar3 & BLOCK1_UNK_8000) == BLOCK1_NONE)) {
		pBVar4 = (BlockStruct_d4 *)pLVar1->ptr_10;
		uVar17 = pBVar4->flags;
		pcVar6 = lego::game::Object_GetName(OBJECT_BUILDING,pBVar4->field_0);
		uVar15 = 0xffffffff;
		do {
			pcVar13 = pcVar6;
			if (uVar15 == 0) break;
			uVar15 -= 1;
			pcVar13 = pcVar6 + 1;
			cVar2 = *pcVar6;
			pcVar6 = pcVar13;
		} while (cVar2 != '\0');
		uVar15 = ~uVar15;
		puVar18 = (undefined4 *)(pcVar13 + -uVar15);
		puVar20 = (undefined4 *)buff1;
		for (uVar16 = uVar15 >> 2; uVar16 != 0; uVar16 -= 1) {
			*puVar20 = *puVar18;
			puVar18 = puVar18 + 1;
			puVar20 = puVar20 + 1;
		}
		for (uVar15 &= 3; uVar15 != 0; uVar15 -= 1) {
			*(undefined *)puVar20 = *(undefined *)puVar18;
			puVar18 = (undefined4 *)((int)puVar18 + 1);
			puVar20 = (undefined4 *)((int)puVar20 + 1);
		}
		if (param_2 != 0) {
			iVar7 = lego::game::Construction_FUN_00408d40(pBVar4,OBJECT_POWERCRYSTAL,0);
			iVar8 = lego::game::Object_GetCostCrystal(OBJECT_BUILDING,pBVar4->field_0,0);
			iVar9 = lego::game::Construction_FUN_00408d40(pBVar4,OBJECT_ORE,ORE_NORMAL);
			iVar10 = lego::game::Object_GetCostOre(OBJECT_BUILDING,pBVar4->field_0,0);
			iVar11 = lego::game::Construction_FUN_00408d40(pBVar4,OBJECT_ORE,ORE_PROCESSED);
			iVar12 = lego::game::Object_GetCostRefinedOre(OBJECT_BUILDING,pBVar4->field_0,0);
			if (iVar8 != 0) {
				std::sprintf(buff2,"\n%s: %i/%i",lego::globs::gameGlobs.CrystalsText,iVar7,iVar8);
				uVar15 = 0xffffffff;
				pcVar6 = buff2;
				do {
					pcVar13 = pcVar6;
					if (uVar15 == 0) break;
					uVar15 -= 1;
					pcVar13 = pcVar6 + 1;
					cVar2 = *pcVar6;
					pcVar6 = pcVar13;
				} while (cVar2 != '\0');
				uVar15 = ~uVar15;
				iVar7 = -1;
				pcVar6 = buff1;
				do {
					pcVar19 = pcVar6;
					if (iVar7 == 0) break;
					iVar7 += -1;
					pcVar19 = pcVar6 + 1;
					cVar2 = *pcVar6;
					pcVar6 = pcVar19;
				} while (cVar2 != '\0');
				puVar18 = (undefined4 *)(pcVar13 + -uVar15);
				puVar20 = (undefined4 *)(pcVar19 + -1);
				for (uVar16 = uVar15 >> 2; uVar16 != 0; uVar16 -= 1) {
					*puVar20 = *puVar18;
					puVar18 = puVar18 + 1;
					puVar20 = puVar20 + 1;
				}
				for (uVar15 &= 3; uVar15 != 0; uVar15 -= 1) {
					*(undefined *)puVar20 = *(undefined *)puVar18;
					puVar18 = (undefined4 *)((int)puVar18 + 1);
					puVar20 = (undefined4 *)((int)puVar20 + 1);
				}
			}
			pcVar6 = lego::globs::gameGlobs.OreText;
			if ((uVar17 & 8) != 0) {
				iVar9 = iVar11;
				iVar10 = iVar12;
				pcVar6 = lego::globs::gameGlobs.StudsText;
			}
			if (iVar10 != 0) {
				std::sprintf(buff2,"\n%s: %i/%i",pcVar6,iVar9,iVar10);
				uVar17 = 0xffffffff;
				pcVar6 = buff2;
				do {
					pcVar13 = pcVar6;
					if (uVar17 == 0) break;
					uVar17 -= 1;
					pcVar13 = pcVar6 + 1;
					cVar2 = *pcVar6;
					pcVar6 = pcVar13;
				} while (cVar2 != '\0');
				uVar17 = ~uVar17;
				iVar9 = -1;
				pcVar6 = buff1;
				do {
					pcVar19 = pcVar6;
					if (iVar9 == 0) break;
					iVar9 += -1;
					pcVar19 = pcVar6 + 1;
					cVar2 = *pcVar6;
					pcVar6 = pcVar19;
				} while (cVar2 != '\0');
				puVar18 = (undefined4 *)(pcVar13 + -uVar17);
				puVar20 = (undefined4 *)(pcVar19 + -1);
				for (uVar15 = uVar17 >> 2; uVar15 != 0; uVar15 -= 1) {
					*puVar20 = *puVar18;
					puVar18 = puVar18 + 1;
					puVar20 = puVar20 + 1;
				}
				for (uVar17 &= 3; uVar17 != 0; uVar17 -= 1) {
					*(undefined *)puVar20 = *(undefined *)puVar18;
					puVar18 = (undefined4 *)((int)puVar18 + 1);
					puVar20 = (undefined4 *)((int)puVar20 + 1);
				}
			}
		}
		lego::front::ToolTip_SetText(TOOLTIP_CONSTRUCTION,buff1);
		lego::front::ToolTip_SetSFX(TOOLTIP_CONSTRUCTION,SFX_NULL);
		lego::front::ToolTip_AddFlag4(TOOLTIP_CONSTRUCTION);
		return;
	}
	bVar5 = false;
	if ((LVar3 & BLOCK1_UNK_8) == BLOCK1_NONE) {
		if (((LVar3 & BLOCK1_UNK_10) == BLOCK1_NONE) && ((LVar3 & BLOCK1_HIDDEN) != BLOCK1_NONE)) {
			pcVar6 = lego::game::Game_GetSurfaceTypeDescription(SURFACE_UNDISCOVERED);
			SVar21 = SURFACE_UNDISCOVERED;
		}
		else {
			if ((LVar3 & BLOCK1_REINFORCED) == BLOCK1_NONE) {
				SVar21 = (SurfaceType)pLVar1->terrain;
				goto LAB_00428649;
			}
			pcVar6 = lego::game::Game_GetSurfaceTypeDescription(SURFACE_REINFORCEMENT);
			SVar21 = SURFACE_REINFORCEMENT;
		}
	}
	else {
		if ((LVar3 & BLOCK1_UNK_80000000) == BLOCK1_NONE) {
			if ((LVar3 & BLOCK1_UNK_200000) == BLOCK1_NONE) {
				pcVar6 = lego::game::Game_GetSurfaceTypeDescription(SURFACE_RUBBLE);
				pcVar13 = (char *)lego::game::Game_GetSurfaceTypeSFX(SURFACE_RUBBLE);
				bVar5 = true;
			}
			else {
				if ((*(byte *)&pLVar1->flags2 & 0x20) == 0) {
					if (((iVar10 < 0) || (iVar9 < 0)) ||
						 ((iVar7 = ((lego::globs::gameGlobs.level)->dimensions).width, iVar7 <= iVar10 ||
							(((lego::globs::gameGlobs.level)->dimensions).height <= iVar9)))) {
						LVar14 = BLOCK1_NONE;
					}
					else {
						LVar14 = (lego::globs::gameGlobs.level)->blocks[iVar7 * iVar9 + iVar10].flags1 &
										 BLOCK1_POWERPATH;
					}
					if ((LVar14 == BLOCK1_NONE) && ((LVar3 & BLOCK1_UNK_8000) == BLOCK1_NONE)) {
						pcVar13 = pcVar6;
						if (((((lego::globs::gameGlobs.level)->blocks
									 [((lego::globs::gameGlobs.level)->dimensions).width * iVar9 + iVar10].flags1 &
									BLOCK1_UNK_400) == BLOCK1_NONE) &&
								((*(byte *)&(lego::globs::gameGlobs.level)->blocks
														[((lego::globs::gameGlobs.level)->dimensions).width * iVar9 + iVar10].
														flags2 & 4) == 0)) && (pcVar6 == NULL)) {
							if (param_4 == 0) goto LAB_004285a8;
							pcVar6 = lego::game::Game_GetSurfaceTypeDescription(SURFACE_CAVERN);
							pcVar13 = (char *)lego::game::Game_GetSurfaceTypeSFX(SURFACE_CAVERN);
							bVar5 = true;
						}
					}
					else {
						pcVar6 = lego::game::Game_GetSurfaceTypeDescription(SURFACE_PATH);
						pcVar13 = (char *)lego::game::Game_GetSurfaceTypeSFX(SURFACE_PATH);
						bVar5 = true;
					}
				}
				else {
					pcVar6 = lego::game::Game_GetSurfaceTypeDescription(SURFACE_SLUGHOLE);
					pcVar13 = (char *)lego::game::Game_GetSurfaceTypeSFX(SURFACE_SLUGHOLE);
					bVar5 = true;
				}
			}
		}
		else {
LAB_004285a8:
			pcVar6 = lego::game::Game_GetSurfaceTypeDescription(SURFACE_TUNNEL);
			pcVar13 = (char *)lego::game::Game_GetSurfaceTypeSFX(SURFACE_TUNNEL);
			bVar5 = true;
		}
		if (pLVar1->terrain == TERRAIN_LAKE) {
			SVar21 = SURFACE_LAKE;
LAB_00428649:
			pcVar6 = lego::game::Game_GetSurfaceTypeDescription(SVar21);
			SVar21 = (SurfaceType)pLVar1->terrain;
		}
		else {
			if (pLVar1->terrain != TERRAIN_LAVA) goto LAB_00428668;
			pcVar6 = lego::game::Game_GetSurfaceTypeDescription(SURFACE_LAVA);
			SVar21 = (SurfaceType)pLVar1->terrain;
		}
	}
	pcVar13 = (char *)lego::game::Game_GetSurfaceTypeSFX(SVar21);
	bVar5 = true;
LAB_00428668:
	if (bVar5) {
		lego::front::ToolTip_SetText(TOOLTIP_MAPBLOCK,"%s",pcVar6);
		if (param_3 == 0) {
			pcVar13 = NULL;
		}
		lego::front::ToolTip_SetSFX(TOOLTIP_MAPBLOCK,(SFXType)pcVar13);
		lego::front::ToolTip_AddFlag4(TOOLTIP_MAPBLOCK);
	}
	return;
}



BOOL __cdecl lego::game::Level_BlockPointerCheck(Point2I *blockPos)
{
	int iVar1;
	int iVar2;
	int iVar3;
	TutorialFlags TVar4;
	LevelData *level;
	
	TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if (TVar4 != TUTORIAL_NONE) {
		TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
		if ((TVar4 & TUTORIAL_UNK_8) == TUTORIAL_NONE) {
			TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
			if ((TVar4 & TUTORIAL_UNK_4) == TUTORIAL_NONE) {
				return 1;
			}
		}
	}
	TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if ((TVar4 & TUTORIAL_UNK_2) != TUTORIAL_NONE) {
		level = GetLevel();
		iVar1 = (level->dimensions).width;
		iVar2 = blockPos->y;
		iVar3 = blockPos->x;
		level = GetLevel();
		if (level->blocks[iVar1 * iVar2 + iVar3].blockpointer == 0) {
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::snd::Audio_FUN_00428730(int param_1)
{
	BOOL setFlag8;
	SFXType sfxType;
	
	setFlag8 = SFX_GetFlag8();
	SFX_SetFlag8To_AndOptPlayQueuedInstances(0,0);
	switch(param_1) {
	case 0:
		front::Pointer_SetTypeAndUnkFloat(POINTER_OKAY,12.5);
		sfxType = SFX_OKAY;
		break;
	case 1:
		front::Pointer_SetTypeAndUnkFloat(POINTER_NOTOKAY,12.5);
		sfxType = SFX_NOTOKAY;
		break;
	case 2:
		front::Pointer_SetTypeAndUnkFloat(POINTER_NOTOKAY,12.5);
		sfxType = SFX_IMMOVABLEROCK;
		break;
	case 3:
		front::Pointer_SetTypeAndUnkFloat(POINTER_OKAY,12.5);
		sfxType = SFX_TOPPRIORITY;
		break;
	case 4:
		front::Pointer_SetTypeAndUnkFloat(POINTER_OKAY,12.5);
		sfxType = SFX_WALL;
		break;
	case 5:
		front::Pointer_SetTypeAndUnkFloat(POINTER_OKAY,12.5);
		sfxType = SFX_FLOOR;
		break;
	default:
		goto switchD_00428751_caseD_6;
	}
	SFX_Sample_Random_Play_OrAddToQueue(sfxType,FALSE);
switchD_00428751_caseD_6:
	SFX_SetFlag8To_AndOptPlayQueuedInstances(setFlag8,FALSE);
	return;
}



void __cdecl lego::game::Game_HandleDebugKeys(int bx,int by,LiveObject *liveObj)
{
	LevelData *pLVar1;
	BOOL BVar2;
	LiveObject *pLVar3;
	BOOL BVar4;
	BOOL BVar5;
	BOOL BVar6;
	LiveObject *liveObj_00;
	Container_Texture *contTexture;
	LiveObject **ppLVar7;
	ObjectUpgradesData *pOVar8;
	uint uVar9;
	float in_stack_00000010;
	float dirz;
	int iVar10;
	uint local_18;
	LiveObject **local_14;
	Point2F local_10;
	Point2I mouseBlockPos;
	
	mouseBlockPos.x = bx;
	mouseBlockPos.y = by;
										// IsKeyPressed(KEY_A) (30)
										// "Creates a landslide at mousepoint."
	if (((globs::INPUT.Key_Map[30] != false) &&
			(globs::INPUT.prevKey_Map[30] != globs::INPUT.Key_Map[30])) &&
		 (Fallin_Block_FUN_0040f260(&mouseBlockPos,1,TRUE), liveObj != NULL)) {
		ai::AI_LiveObject_DoSlip(liveObj);
	}
										// IsKeyPressed(KEY_END) (207)
										// "Toggles power Off/On for currently selected building"
	if (((globs::INPUT.Key_Map[207] != false) &&
			(globs::INPUT.prevKey_Map[207] != globs::INPUT.Key_Map[207])) &&
		 (BVar2 = Message_IsAnyUnitsSelected(), BVar2 != 0)) {
		pLVar3 = Message_GetPrimarySelectedUnit();
		debug::LiveObject_Debug_ToggleObjectPower(pLVar3);
	}
										// IsKeyPressed(KEY_E) (18)
	if ((globs::INPUT.Key_Map[18] != false) &&
		 (globs::INPUT.prevKey_Map[18] != globs::INPUT.Key_Map[18])) {
		Game_TryGeneratedRockMonsterLiveObject
							((int **)(globs::gameGlobs.RockMonsterData_TABLE +
											 (globs::gameGlobs.level)->EmergeCreature),OBJECT_ROCKMONSTER,
							 (globs::gameGlobs.level)->EmergeCreature,bx,by);
	}
										// IsKeyDown(KEY_W) (17)
	if (globs::INPUT.Key_Map[17] != false) {
		Level_FUN_004303a0(globs::gameGlobs.level,0,bx,by);
	}
										// IsKeyPressed(KEY_C) (46)
	if (globs::INPUT.Key_Map[46] != false) {
		if ((globs::INPUT.prevKey_Map[46] != globs::INPUT.Key_Map[46]) &&
			 (BVar2 = Message_IsAnyUnitsSelected(), BVar2 != 0)) {
			pLVar3 = Message_GetPrimarySelectedUnit();
			FUN_00448a80((int *)pLVar3);
		}
										// IsKeyPressed(KEY_C) (46)
		if (((globs::INPUT.Key_Map[46] != false) &&
				(globs::INPUT.prevKey_Map[46] != globs::INPUT.Key_Map[46])) &&
			 (BVar2 = Message_IsAnyUnitsSelected(), BVar2 != 0)) {
			pLVar3 = Message_GetPrimarySelectedUnit();
			FUN_00448a80((int *)pLVar3);
		}
	}
										// IsKeyPressed(KEY_F12) (88)
										// "Disables all NERPs functions."
	if ((globs::INPUT.Key_Map[88] != false) &&
		 (globs::INPUT.prevKey_Map[88] != globs::INPUT.Key_Map[88])) {
		if ((globs::gameGlobs.flags1 & GAME1_DEBUG_NONERPS) == GAME1_NONE) {
			local_14 = NULL;
			globs::gameGlobs.flags1 |= GAME1_DEBUG_NONERPS;
			nerps::funcs::NERPFunc__SetTutorialFlags((int *)&local_14);
		}
		else {
			globs::gameGlobs.flags1 &= ~GAME1_DEBUG_NONERPS;
		}
	}
										// IsKeyPressed(KEY_F11) (87)
										// "Disables all building and vehicle prerequisites."
	if ((globs::INPUT.Key_Map[87] != false) &&
		 (globs::INPUT.prevKey_Map[87] != globs::INPUT.Key_Map[87])) {
		debug::Dependencies_Debug_SetBuildingPrerequisits(FALSE);
	}
										// IsKeyPressed(KEY_F10) (68)
										// "Inverts the direction of lighting."
	if ((globs::INPUT.Key_Map[68] != false) &&
		 (globs::INPUT.prevKey_Map[68] != globs::INPUT.Key_Map[68])) {
		globals::g_GameLighting_Invert_DebugF10 = ZEXT14(globals::g_GameLighting_Invert_DebugF10 == 0);
		if (globals::g_GameLighting_Invert_DebugF10 == 0) {
			res::Container_SetPosition
								(globs::gameGlobs.resTopSpotlight,(globs::gameGlobs.cameraMain)->resData3,200.0,
								 140.0,-130.0);
			dirz = 0.75;
		}
		else {
			res::Container_SetPosition
								(globs::gameGlobs.resTopSpotlight,(globs::gameGlobs.cameraMain)->resData3,250.0,
								 190.0,20.0);
			dirz = 0.0;
		}
		res::Container_SetOrientation
							(globs::gameGlobs.resTopSpotlight,(globs::gameGlobs.cameraMain)->resData3,-1.0,-0.8,
							 dirz,0.0,1.0,0.0);
		light::LightEffects_InvalidatePosition();
	}
										// IsKeyPressed(KEY_F9) (67)
	if ((globs::INPUT.Key_Map[67] != false) &&
		 (globs::INPUT.prevKey_Map[67] != globs::INPUT.Key_Map[67])) {
		globals::g_GameLighting_Unk_DebugF9 = ZEXT14(globals::g_GameLighting_Unk_DebugF9 == 0);
		light::LightEffects_SetDisabled(globals::g_GameLighting_Unk_DebugF9);
	}
	BVar2 = Message_IsAnyUnitsSelected();
										// IsKeyPressed(KEY_FIVE) (6) || IsKeyPressed(KEY_SIX) (7) ||
										// IsKeyPressed(KEY_SEVEN) (8) || IsKeyPressed(KEY_EIGHT) (9)
										// "Change selected unit visual upgrade parts"
	if ((BVar2 != 0) &&
		 ((((((globs::INPUT.Key_Map[6] != false &&
					(globs::INPUT.prevKey_Map[6] != globs::INPUT.Key_Map[6])) ||
				 ((globs::INPUT.Key_Map[7] != false &&
					(globs::INPUT.prevKey_Map[7] != globs::INPUT.Key_Map[7])))) ||
				((globs::INPUT.Key_Map[8] != false &&
				 (globs::INPUT.prevKey_Map[8] != globs::INPUT.Key_Map[8])))) ||
			 ((globs::INPUT.Key_Map[9] != false &&
				(globs::INPUT.prevKey_Map[9] != globs::INPUT.Key_Map[9])))) &&
			(local_14 = Message_GetSelectedUnits((uint *)&local_10), local_10.x != 0.0)))) {
		pLVar3 = *local_14;
		if (pLVar3->objType == OBJECT_BUILDING) {
			BVar2 = FALSE;
			iVar10 = 0;
			pOVar8 = &pLVar3->building->upgrades;
			pLVar3 = Message_GetPrimarySelectedUnit();
			BVar4 = res::Object_Debug_ChangeUpgradeModel(pLVar3->building,iVar10,BVar2);
			BVar2 = FALSE;
			iVar10 = 1;
			pLVar3 = Message_GetPrimarySelectedUnit();
			BVar5 = res::Object_Debug_ChangeUpgradeModel(pLVar3->building,iVar10,BVar2);
			BVar2 = FALSE;
			iVar10 = 2;
			pLVar3 = Message_GetPrimarySelectedUnit();
			BVar6 = res::Object_Debug_ChangeUpgradeModel(pLVar3->building,iVar10,BVar2);
			BVar2 = FALSE;
			iVar10 = 3;
			pLVar3 = Message_GetPrimarySelectedUnit();
			BVar2 = res::Object_Debug_ChangeUpgradeModel(pLVar3->building,iVar10,BVar2);
		}
		else {
			if (pLVar3->objType == OBJECT_VEHICLE) {
				BVar2 = 0;
				iVar10 = 0;
				pOVar8 = &pLVar3->vehicle->upgrades;
				pLVar3 = Message_GetPrimarySelectedUnit();
				BVar4 = res::Vehicle_FUN_0046d200(pLVar3->vehicle,iVar10,BVar2);
				BVar2 = 0;
				iVar10 = 1;
				pLVar3 = Message_GetPrimarySelectedUnit();
				BVar5 = res::Vehicle_FUN_0046d200(pLVar3->vehicle,iVar10,BVar2);
				BVar2 = 0;
				iVar10 = 2;
				pLVar3 = Message_GetPrimarySelectedUnit();
				BVar6 = res::Vehicle_FUN_0046d200(pLVar3->vehicle,iVar10,BVar2);
				BVar2 = 0;
				iVar10 = 3;
				pLVar3 = Message_GetPrimarySelectedUnit();
				BVar2 = res::Vehicle_FUN_0046d200(pLVar3->vehicle,iVar10,BVar2);
			}
			else {
				pOVar8 = NULL;
				BVar2 = bx;
				BVar5 = bx;
				BVar6 = bx;
				BVar4 = bx;
			}
		}
		if (pOVar8 != NULL) {
			local_18 = pOVar8->currentLevel;
			uVar9 = local_18;
										// IsKeyPressed(KEY_FIVE) (6)
										// "Change selected unit visual upgrade parts (level bit 3)"
			if (((globs::INPUT.Key_Map[6] != false) &&
					(globs::INPUT.prevKey_Map[6] != globs::INPUT.Key_Map[6])) && (BVar4 != 0)) {
				uVar9 = local_18 ^ 8;
			}
										// IsKeyPressed(KEY_SIX) (7)
										// "Change selected unit visual upgrade parts (level bit 2)"
			if (((globs::INPUT.Key_Map[7] != false) &&
					(globs::INPUT.prevKey_Map[7] != globs::INPUT.Key_Map[7])) && (BVar5 != 0)) {
				uVar9 ^= 4;
			}
										// IsKeyPressed(KEY_SEVEN) (8)
										// "Change selected unit visual upgrade parts (level bit 1)"
			if (((globs::INPUT.Key_Map[8] != false) &&
					(globs::INPUT.prevKey_Map[8] != globs::INPUT.Key_Map[8])) && (BVar6 != 0)) {
				uVar9 ^= 2;
			}
										// IsKeyPressed(KEY_EIGHT) (9)
										// "Change selected unit visual upgrade parts (level bit 0)"
			if (((globs::INPUT.Key_Map[9] != false) &&
					(globs::INPUT.prevKey_Map[9] != globs::INPUT.Key_Map[9])) && (BVar2 != 0)) {
				uVar9 ^= 1;
			}
			if (uVar9 != local_18) {
				if ((*local_14)->objType == OBJECT_BUILDING) {
					pLVar3 = Message_GetPrimarySelectedUnit();
					res::Building_ChangeUpgradeParts(pLVar3->building,uVar9);
				}
				else {
					if ((*local_14)->objType == OBJECT_VEHICLE) {
						pLVar3 = Message_GetPrimarySelectedUnit();
						res::Vehicle_ChangeUpgradeParts(pLVar3->vehicle,uVar9);
					}
				}
			}
		}
	}
										// IsKeyPressed(KEY_BACKSPACE) (14)
	if ((globs::INPUT.Key_Map[14] != false) &&
		 (globs::INPUT.prevKey_Map[14] != globs::INPUT.Key_Map[14])) {
		ai::AITask_DoGather_Count(5);
	}
										// IsKeyPressed(KEYPAD_DELETE) (83)
										// "Destroys any walls at mousepoint, except border rock"
	if ((globs::INPUT.Key_Map[83] != false) &&
		 (globs::INPUT.prevKey_Map[83] != globs::INPUT.Key_Map[83])) {
		Level_DestroyWall(globs::gameGlobs.level,bx,by,0);
	}
										// IsKeyDown(KEYPAD_3) (81)
										// "Destroys connections between any walls at mousepoint, except border rock."
	if (globs::INPUT.Key_Map[81] != false) {
		Level_DestroyWallConnection(globs::gameGlobs.level,bx,by);
	}
										// IsKeyPressed(KEY_W) (17)
	if ((((globs::INPUT.Key_Map[17] != false) &&
			 (globs::INPUT.prevKey_Map[17] != globs::INPUT.Key_Map[17])) &&
			(BVar2 = Message_IsAnyUnitsSelected(), BVar2 != 0)) &&
		 (pLVar3 = Message_GetPrimarySelectedUnit(), pLVar1 = globs::gameGlobs.level,
		 pLVar3->objType == OBJECT_ROCKMONSTER)) {
		LiveObject_FUN_0044a890(pLVar3,(int *)&local_18,(int *)&local_14,1,0,0);
		liveObj_00 = LiveObject__Create((int **)globs::gameGlobs.RES_Boulder,OBJECT_BOULDER,0);
		LiveObject_HideAll(liveObj_00,TRUE);
		LiveObject_RoutingNoCarry_FUN_00447470(pLVar3,local_18,(uint)local_14,liveObj_00);
		contTexture = res::DynamicPM_SurfaceTextureGrid_GetTexture
														(pLVar1->surfTextGrid,
														 pLVar1->blocks[(pLVar1->dimensions).width * (int)local_14 + local_18].
														 texture);
		LiveObject_InitBoulderMesh_FUN_00440eb0(liveObj_00,contTexture);
	}
										// IsKeyPressed(KEY_N) (49)
	if (((globs::INPUT.Key_Map[49] != false) &&
			(globs::INPUT.prevKey_Map[49] != globs::INPUT.Key_Map[49])) &&
		 (BVar2 = Message_IsAnyUnitsSelected(), BVar2 != 0)) {
		BVar2 = 0;
		pLVar3 = Message_GetPrimarySelectedUnit();
		LiveObject_UnkDoRouting_FUN_00441c00(pLVar3,BVar2);
	}
										// IsKeyUp(KEY_LEFTSHIFT) (42) && IsKeyPressed(KEY_A) (30)
										// "Tells a Rock Raider to get a Sonic Blaster from Tool Store and place at
										// mousepoint."
	if (((globs::INPUT.Key_Map[42] != false) && (globs::INPUT.Key_Map[30] != false)) &&
		 (globs::INPUT.prevKey_Map[30] != globs::INPUT.Key_Map[30])) {
		ai::AITask_DoBirdScarer_AtPosition(&mouseBlockPos);
	}
										// IsKeyPressed(KEY_B) (48)
										// "Pushes any Rock Raider or Monster at mousepoint east-northeast."
	if ((globs::INPUT.Key_Map[48] != false) &&
		 (globs::INPUT.prevKey_Map[48] != globs::INPUT.Key_Map[48])) {
		local_10.x = 2.0;
		local_10.y = 1.0;
		if (liveObj != NULL) {
			LiveObject_Unk_AndSetVector3B4(liveObj,&local_10,40.0);
		}
	}
										// IsKeyPressed(KEY_H) (35)
										// "Creates a spider web at mousepoint."
	if ((globs::INPUT.Key_Map[35] != false) &&
		 (globs::INPUT.prevKey_Map[35] != globs::INPUT.Key_Map[35])) {
		SpiderWeb_SpawnAt(bx,by);
	}
										// IsKeyPressed(KEY_F) (33)
	if ((((globs::INPUT.Key_Map[33] != false) &&
			 (globs::INPUT.prevKey_Map[33] != globs::INPUT.Key_Map[33])) &&
			(BVar2 = Message_IsAnyUnitsSelected(), BVar2 != 0)) &&
		 (uVar9 = Message_GetNumSelectedUnits(), uVar9 != 0)) {
		ppLVar7 = Message_GetSelectedUnits();
		for (; uVar9 != 0; uVar9 -= 1) {
			LiveObject_AddDamage2(*ppLVar7,40.0,1,in_stack_00000010);
			ppLVar7 = ppLVar7 + 1;
		}
	}
										// IsKeyPressed(KEY_H) (35)
	if (((globs::INPUT.Key_Map[35] != false) &&
			(globs::INPUT.prevKey_Map[35] != globs::INPUT.Key_Map[35])) &&
		 ((BVar2 = Message_IsAnyUnitsSelected(), BVar2 != 0 &&
			(pLVar3 = Message_GetPrimarySelectedUnit(), pLVar3->objType == OBJECT_BUILDING)))) {
		ElectricFence_FUN_0040d420((undefined4 *)pLVar3,0,0);
	}
										// IsKeyPressed(KEY_J) (36)
	if ((globs::INPUT.Key_Map[36] != false) &&
		 (globs::INPUT.prevKey_Map[36] != globs::INPUT.Key_Map[36])) {
		BVar2 = ElectricFence_BlockCheck_FUN_0040e390(bx,by);
		if (BVar2 == 0) {
			ElectricFence_Block_FUN_0040d0a0(bx,by);
		}
		else {
			ElectricFence_DestroyAttachedElecFence(bx,by);
		}
	}
										// IsKeyPressed(KEY_Y) (21)
										// "Triggers the CrystalFound InfoMessage."
	if ((globs::INPUT.Key_Map[21] != false) &&
		 (globs::INPUT.prevKey_Map[21] != globs::INPUT.Key_Map[21])) {
		local_10.x = 1.401298e-45;
		local_10.y = 1.401298e-45;
		front::Info_FUN_00419ab0(INFO_CRYSTALFOUND,NULL,NULL,(Point2I *)&local_10);
	}
										// IsKeyUp(KEY_LEFTSHIFT) (42)
	if (globs::INPUT.Key_Map[42] == false) {
										// IsKeyPressed(KEY_U) (22)
										// "Ends Advisor_Anim_Point_N."
		if ((globs::INPUT.Key_Map[22] != false) &&
			 (globs::INPUT.prevKey_Map[22] != globs::INPUT.Key_Map[22])) {
			front::Advisor_ClearFlag2();
		}
	}
	else {
										// IsKeyPressed(KEY_U) (22)
										// "Begins Advisor_Anim_Point_N."
		if ((globs::INPUT.Key_Map[22] != false) &&
			 (globs::INPUT.prevKey_Map[22] != globs::INPUT.Key_Map[22])) {
			front::Panel_SetCurrentAdvisorFromButton(PANEL_RADAR,0,1);
		}
	}
										// IsKeyPressed(KEY_K) (37)
	if (((globs::INPUT.Key_Map[37] != false) &&
			(globs::INPUT.prevKey_Map[37] != globs::INPUT.Key_Map[37])) &&
		 (BVar2 = Message_IsAnyUnitsSelected(), BVar2 != 0)) {
		pLVar3 = Message_GetPrimarySelectedUnit();
		if (pLVar3->objType == OBJECT_VEHICLE) {
			PTRLiveObject_004df584 = Message_GetPrimarySelectedUnit();
			return;
		}
		pLVar3 = Message_GetPrimarySelectedUnit();
		if ((pLVar3->objType == OBJECT_MINIFIGURE) && (PTRLiveObject_004df584 != NULL)) {
			pLVar3 = PTRLiveObject_004df584;
			liveObj_00 = Message_GetPrimarySelectedUnit();
			LiveObject_TryFindDriver_FUN_00440690(liveObj_00,pLVar3);
		}
	}
	return;
}



void __cdecl lego::game::SurfaceMap_LevelXYCallback_FUN_00429040(int x,int y)
{
	if (((globs::gameGlobs.level)->blocks[((globs::gameGlobs.level)->dimensions).width * y + x].flags1
			& BLOCK1_UNK_4000) != BLOCK1_NONE) {
		lego::effect::Smoke_Hide
							((globs::gameGlobs.level)->blocks
							 [((globs::gameGlobs.level)->dimensions).width * y + x].smokeptr_1c,0);
	}
	return;
}



Container_Texture * __cdecl FUN_00429090(Point2I *textCoord)
{
	Container_Texture *pCVar1;
	
	pCVar1 = lego::res::DynamicPM_SurfaceTextureGrid_GetTexture
										 ((lego::globs::gameGlobs.level)->surfTextGrid,
											(lego::globs::gameGlobs.level)->blocks
											[((lego::globs::gameGlobs.level)->dimensions).width * textCoord->y +
											 textCoord->x].texture);
	return pCVar1;
}



void __cdecl FUN_004290d0(float elapsedAny,BOOL param_2)
{
	SurfaceMap *surfMap;
	float fVar1;
	float10 fVar2;
	longlong lVar3;
	Vector3F local_18;
	Vector3F local_c;
	
	if (param_2 == 0) {
		if (lego::globs::gameGlobs.viewMode == VIEW_TOPDOWN) {
			lego::res::Container_GetPosition((lego::globs::gameGlobs.cameraMain)->resData2,NULL,&local_18)
			;
			lego::game::Map3D_WorldToBlockPos_NoZ
								((lego::globs::gameGlobs.level)->surfaceMap,local_18.x,local_18.y,&param_2,
								 (int *)&elapsedAny);
			lego::res::Container_GetOrientation
								((lego::globs::gameGlobs.cameraMain)->resData1,NULL,&local_c,NULL);
			surfMap = lego::game::GetSurfaceMap();
			fVar2 = lego::game::Map3D_GetBlockSize(surfMap);
			fVar2 = fVar2 * (float10)3.0;
			local_c.x = (float)(fVar2 * (float10)local_c.x);
			local_c.y = (float)(fVar2 * (float10)local_c.y);
			local_c.z = (float)(fVar2 * (float10)local_c.z);
			local_18.x = local_c.x + local_18.x;
			local_18.y = local_c.y + local_18.y;
			local_18.z = local_c.z + local_18.z;
			lego::game::Map3D_WorldToBlockPos_NoZ
								((lego::globs::gameGlobs.level)->surfaceMap,local_18.x,local_18.y,&param_2,
								 (int *)&elapsedAny);
			lego::game::Map3D_AddCoordsInRadius_AndDoCallbacks
								((lego::globs::gameGlobs.level)->surfaceMap,param_2,(int)elapsedAny,8,
								 lego::game::SurfaceMap_LevelXYCallback_FUN_00429040);
			return;
		}
		if (lego::globs::gameGlobs.viewMode == VIEW_FIRSTPERSON) {
			param_2 = (BOOL)((lego::globs::gameGlobs.level)->surfaceMap->BlockSize *
											lego::globs::gameGlobs.FPClipBlocks);
			fVar1 = (float)lego::globs::gameGlobs.HPBlocks;
			if (((lego::globs::gameGlobs.flags1 & GAME1_DYNAMICPM) != GAME1_NONE) && (elapsedAny != 0.0))
			{
				local_18.x = (float)lego::globs::gameGlobs.HPBlocks;
				local_18.y = 0.0;
				lVar3 = __ftol((float10)(ulonglong)(uint)lego::globs::gameGlobs.HPBlocks /
											 (float10)elapsedAny);
				fVar1 = (float)lVar3;
			}
			FUN_00433db0((lego::globs::gameGlobs.cameraFP)->resData1,lego::globs::gameGlobs.viewMain,
									 (float)param_2,fVar1);
			return;
		}
	}
	else {
		if (((lego::globs::gameGlobs.flags1 & GAME1_RADARON) != GAME1_NONE) &&
			 ((lego::globs::gameGlobs.flags1 & GAME1_RADAR_TRACKOBJECTVIEW) != GAME1_NONE)) {
			lego::res::Container_GetPosition((lego::globs::gameGlobs.cameraRadar)->resData2,NULL,&local_c)
			;
			lego::game::Map3D_WorldToBlockPos_NoZ
								((lego::globs::gameGlobs.level)->surfaceMap,local_c.x,local_c.y,&param_2,
								 (int *)&elapsedAny);
			lego::game::Map3D_AddCoordsInRadius_AndDoCallbacks
								((lego::globs::gameGlobs.level)->surfaceMap,param_2,(int)elapsedAny,2,NULL);
		}
	}
	return;
}



void __cdecl lego::game::Level_DrawDragSelectionBox(LevelData *level)
{
	Point2F local_38;
	Point2F mousePos;
	Point2F lineList [5];
	
	if ((globs::gameGlobs.flags1 & GAME1_DRAGGINGBOX_UNK) != GAME1_NONE) {
		mousePos.y = (float)globs::INPUT.msy;
		mousePos.x = (float)globs::INPUT.msx;
		lego::view::Viewport_WorldToScreen
							(globs::gameGlobs.viewMain,&local_38,&globs::gameGlobs.vectorDragStartUnk_a4);
		lineList[0].x = local_38.x;
		lineList[0].y = local_38.y;
		lineList[1].x = mousePos.x;
		lineList[1].y = local_38.y;
		lineList[2].x = mousePos.x;
		lineList[2].y = mousePos.y;
		lineList[3].x = local_38.x;
		lineList[3].y = mousePos.y;
		lineList[4].x = local_38.x;
		lineList[4].y = local_38.y;
		draw::Draw_LineListEx
							(lineList,lineList + 1,4,globs::gameGlobs.DragBoxRGB.red,
							 globs::gameGlobs.DragBoxRGB.green,globs::gameGlobs.DragBoxRGB.blue,
							 DRAWEFFECT_HALFTRANS);
	}
	return;
}



void __cdecl
lego::game::Game_MainView_MouseTransform(uint mouseX,uint mouseY,float *out_x,float *out_y)
{
	BOOL BVar1;
	Vector3F local_4c;
	Vector3F local_40;
	Vector3F local_34;
	Vector3F local_28;
	Vector3F local_1c;
	Vector4F local_10;
	
	local_28.x = 0.0;
	local_4c.x = (float)mouseY;
	local_4c.y = 0.0;
	local_28.y = 0.0;
	local_28.z = 0.0;
	local_34.x = 0.0;
	local_34.y = 0.0;
	local_34.z = -1.0;
	local_10.z = 0.0;
	local_10.w = 1.0;
	local_10.x = (float)(ulonglong)mouseX;
	local_10.y = (float)(ulonglong)mouseY;
	lego::view::Viewport_InverseTransform(globs::gameGlobs.viewMain,&local_40,&local_10);
	local_10.z = 1.0;
	local_10.w = 1.0;
	local_10.x = (float)(ulonglong)mouseX;
	local_10.y = (float)(ulonglong)mouseY;
	lego::view::Viewport_InverseTransform(globs::gameGlobs.viewMain,&local_4c,&local_10);
	local_4c.x = local_4c.x - local_40.x;
	local_4c.y = local_4c.y - local_40.y;
	local_4c.z = local_4c.z - local_40.z;
	BVar1 = math::Maths_RayPlaneIntersection(&local_1c,&local_40,&local_4c,&local_28,&local_34);
	if (BVar1 != 0) {
		*out_x = local_1c.x;
		*out_y = local_1c.y;
	}
	return;
}



Container * __cdecl lego::game::Game_GetCurrentViewLight(void)
{
	Container *light;
	
	light = globs::gameGlobs.resFPLight;
	if (globs::gameGlobs.viewMode != VIEW_FIRSTPERSON) {
		light = globs::gameGlobs.resRootSpotlight;
	}
	return light;
}



BOOL __cdecl lego::game::LiveObject_Check_FUN_004294f0(LiveObject *liveObj)
{
	if (((globs::gameGlobs.viewMode != VIEW_FIRSTPERSON) || (liveObj != globs::gameGlobs.objectFP)) &&
		 ((liveObj->drivenObject == NULL || (liveObj->drivenObject != globs::gameGlobs.objectFP)))) {
		return 0;
	}
	return 1;
}



void __cdecl lego::game::Game_SetViewMode(ViewMode viewMode,LiveObject *liveObj,int camField14)
{
	ViewMode VVar1;
	
	VVar1 = viewMode;
	if (viewMode == VIEW_FIRSTPERSON) {
		viewMode = 1063675494;
		if (camField14 != 0) {
			viewMode = 1058642330;
		}
		lego::view::Camera_SetObject4_Field14(globs::gameGlobs.cameraFP,liveObj,camField14);
		debug::LevelStruct428_Debug_Log_LevelStruct428Floats(TRUE);
		Map3D_Coords_SetEmissive((globs::gameGlobs.level)->surfaceMap,TRUE);
		globs::gameGlobs.objectFP = liveObj;
		if (liveObj->objType == OBJECT_MINIFIGURE) {
			LiveObject_FUN_0043a130(liveObj,FALSE);
		}
		lego::view::Viewport_SetCamera(globs::gameGlobs.viewMain,(globs::gameGlobs.cameraFP)->resData1);
		snd::Sound3D_MakeListener((globs::gameGlobs.cameraFP)->resData1->masterFrame);
		snd::Sound3D_SetMinDistForAtten(50.0);
		lego::view::Viewport_SmoothSetField(globs::gameGlobs.viewMain,(float)viewMode);
		lego::view::Viewport_SetBackClip
							(globs::gameGlobs.viewMain,
							 (globs::gameGlobs.level)->BlockSize * globs::gameGlobs.FPClipBlocks);
		globs::gameGlobs.viewMode = VVar1;
		return;
	}
	if (viewMode == VIEW_TOPDOWN) {
		if (globs::gameGlobs.objectFP != NULL) {
			LiveObject_FUN_0042dd70(globs::gameGlobs.objectFP,NULL,FALSE);
		}
		(globs::gameGlobs.cameraFP)->trackObj = NULL;
		globs::gameGlobs.objectFP = NULL;
		debug::LevelStruct428_Debug_Log_LevelStruct428Floats(FALSE);
		Map3D_Coords_SetEmissive((globs::gameGlobs.level)->surfaceMap,FALSE);
		lego::view::Viewport_SetCamera
							(globs::gameGlobs.viewMain,(globs::gameGlobs.cameraMain)->resData1);
		snd::Sound3D_MakeListener((globs::gameGlobs.cameraMain)->resTableunk_34->masterFrame);
		snd::Sound3D_SetMinDistForAtten(globs::gameGlobs.MinDistFor3DSoundsOnTopView);
		lego::view::Viewport_SetField(globs::gameGlobs.viewMain,0.5);
		lego::view::Viewport_SetBackClip(globs::gameGlobs.viewMain,globs::gameGlobs.TVClipDist);
	}
	globs::gameGlobs.viewMode = viewMode;
	return;
}



void __cdecl lego::snd::Music_CDAudio_PlayNextCallback(void)
{
	Sound_StopCD();
	Music_PlayNext(1);
	return;
}



void __cdecl lego::snd::Music_PlayNext(BOOL isMusicOn)
{
	short sVar1;
	
	if (isMusicOn != 0) {
		sVar1 = math::Maths_Rand();
		globs::gameGlobs.flags1 |= GAME1_MUSICON;
		Sound_PlayCDTrack(((uint)(int)sVar1 % globs::gameGlobs.CDTracks - 1) +
											globs::gameGlobs.CDStartTrack,SOUND_ONCE,Music_CDAudio_PlayNextCallback);
		return;
	}
	globs::gameGlobs.flags1 &= ~GAME1_MUSICON;
	Sound_StopCD();
	Sound_Update(0);
	return;
}



void __cdecl lego::snd::SFX_SetSoundEnabled(BOOL isSoundOn)
{
	if (isSoundOn != 0) {
		globs::gameGlobs.flags1 |= GAME1_SOUNDON;
		SFX_StopAll_AndSetSoundState_IsOn(isSoundOn);
		return;
	}
	globs::gameGlobs.flags1 &= ~GAME1_SOUNDON;
	SFX_StopAll_AndSetSoundState_IsOn(0);
	return;
}



int __cdecl lego::game::Level_GetEmergeCreature(void)
{
	return (globs::gameGlobs.level)->EmergeCreature;
}



float10 __cdecl lego::game::Level_GetObjectUpgradeTime(ObjectType objType)
{
	return (float10)(globs::gameGlobs.level)->UpgradeTimes[objType];
}



float10 __cdecl lego::game::Level_GetTrainTime(void)
{
	return (float10)(globs::gameGlobs.level)->TrainTime;
}



// WARNING: Could not reconcile some variable overlaps

BOOL __cdecl lego::main::Main_loadLevelCFG(char *levelName)
{
	float fVar1;
	CFGProperty *root;
	char cVar2;
	SaveData *pSVar3;
	SaveStruct_18 *saveStruct18;
	BOOL BVar4;
	int iVar5;
	LevelData *level;
	char *pcVar6;
	uint uVar7;
	BOOL3 BVar8;
	float fVar9;
	LiveObject *pLVar10;
	LiveObject **ppLVar11;
	LevelData *pLVar12;
	float *pfVar13;
	uint uVar14;
	float10 fVar15;
	ColourRGBF *pCVar16;
	float *pfVar17;
	float local_1c0;
	float local_1bc;
	float local_1b8;
	char *nameEmergeCreature;
	ObjectType local_1b0;
	char *local_1ac;
	char *local_1a8;
	char *local_1a4;
	char *local_1a0;
	char *local_19c;
	char *local_198;
	char *local_194;
	char *local_190;
	char *local_18c;
	char *local_188;
	char *local_184;
	Point2F filenameObjectList;
	char *local_178;
	char *filenameIntroAVI;
	char *filenameNERPMessage;
	char *filenameNERP;
	char *filenamePTL;
	uint local_164;
	char *local_160;
	char *local_15c;
	undefined4 local_138;
	int local_134;
	int local_130;
	LiveObject *local_12c [10];
	char local_104 [260];
	
	root = globs::gameGlobs.LegoCfgRoot;
	game::Level_DoVideo__004158c0(levelName,1);
	unk::Teleporter_RemoveAll();
	front::Front_UpdatePausedMenuSliders();
	front::HelpWindow_Game_SetPlaceFlagsState_004dd650(FALSE);
	game::Game_DisableCryOreDrop(FALSE);
	game::LiveManager_SetFlag20(FALSE);
	pSVar3 = save::Save_GetCurrentSaveNumber_StructB8();
	if (pSVar3 == NULL) {
		saveStruct18 = NULL;
	}
	else {
		saveStruct18 = &pSVar3->saveStruct18_1c;
	}
	save::Save_OverwriteStruct18(saveStruct18);
	BVar4 = save::ObjectRecall_Save_GetBool_00500e64();
	if ((BVar4 == 0) && (iVar5 = save::Save_GetSaveNumber(), iVar5 != -1)) {
		std::sprintf(local_104,"%s\\%i.osf","Saves",iVar5);
		save::ObjectRecall_Save_LoadRROSFile(local_104);
	}
	level = (LevelData *)std::malloc(0x284);
	if (level == NULL) goto LAB_0042b198;
	pLVar12 = level;
	for (iVar5 = 0xa1; iVar5 != 0; iVar5 += -1) {
		pLVar12->levelName = NULL;
		pLVar12 = (LevelData *)&pLVar12->surfaceMap;
	}
	globs::gameGlobs.flags1 |= GAME1_LEVELSTART;
	globs::gameGlobs.level = level;
	front::Loader_display_loading_bar(levelName);
	game::Level_LoadPriorities(root,globs::gameGlobs.CfgRootName,levelName);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"Seed",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"Seed",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	uVar7 = std::atoi(pcVar6);
	if (uVar7 != 0) {
		std::srand(uVar7);
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"BoulderAnimation",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if ((pcVar6 == NULL) || (iVar5 = std::_stricmp(pcVar6,"Rock"), iVar5 == 0)) {
LAB_00429989:
		level->BoulderAnimation = TEXTURES_ROCK;
	}
	else {
		iVar5 = std::_stricmp(pcVar6,"Lava");
		if (iVar5 == 0) {
			level->BoulderAnimation = TEXTURES_LAVA;
		}
		else {
			iVar5 = std::_stricmp(pcVar6,"Ice");
			if (iVar5 != 0) goto LAB_00429989;
			level->BoulderAnimation = TEXTURES_ICE;
		}
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"FallinMultiplier",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"FallinMultiplier",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	globs::gameGlobs.FallinMultiplier = std::atoi(pcVar6);
	if (globs::gameGlobs.FallinMultiplier == 0) {
		globs::gameGlobs.FallinMultiplier = 1;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"blocksize",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"blocksize",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->BlockSize = (float)fVar15;
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"digdepth",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"digdepth",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->DigDepth = (float)fVar15;
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"useroof",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	level->UseRoof = BVar8;
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"roofheight",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"roofheight",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->RoofHeight = (float)fVar15;
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"roughlevel",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"roughlevel",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->RoughLevel = (float)fVar15;
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"surfacemap",0);
	local_1a0 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"predugmap",0);
	local_1a8 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"terrainmap",0);
	local_194 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"blockPointersMap",0);
	local_198 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"CryOreMap",0);
	local_1ac = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"ErodeMap",0);
	local_18c = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"EmergeMap",0);
	local_184 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"AIMap",0);
	local_188 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"PathMap",0);
	local_1a4 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"FallinMap",0);
	local_190 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"textureset",0);
	local_178 = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"EmergeTimeOut",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"EmergeTimeOut",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->EmergeTimeOut = (float)fVar15;
	if (fVar15 == (float10)0.0) {
		level->EmergeTimeOut = 1500.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"olistfile",0);
	filenameObjectList.x = (float)cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"elistfile",0);
	cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"selboxheight",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"selboxheight",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->SelBoxHeight = (float)fVar15;
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"PTLFile",0);
	filenamePTL = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"NERPFile",0);
	filenameNERP = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"NERPMessageFile",0);
	filenameNERPMessage = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"EmergeCreature",0);
	nameEmergeCreature = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"SafeCaverns",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	level->SafeCaverns = BVar8;
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"IntroAVI",0);
	filenameIntroAVI = cfg::CFG_ReadString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"StartFP",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	level->StartFP = (uint)(BVar8 == BOOL3_TRUE);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"NoDrain",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	level->NoDrain = (uint)(BVar8 == BOOL3_TRUE);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"OxygenRate",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"OxygenRate",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->OxygenRate = (float)(fVar15 * (float10)0.001);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"UpgradeTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"UpgradeTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	fVar9 = (float)(fVar15 * (float10)25.0);
	pfVar13 = level->UpgradeTimes;
	for (iVar5 = 0x14; iVar5 != 0; iVar5 += -1) {
		*pfVar13 = fVar9;
		pfVar13 = pfVar13 + 1;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"MinifigureUpgradeTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"MinifigureUpgradeTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	fVar1 = (float)fVar15;
	level->UpgradeTimes[2] = fVar1;
	if (fVar1 == 0.0) {
		level->UpgradeTimes[2] = fVar9;
	}
	else {
		level->UpgradeTimes[2] = fVar1 * 25.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"VehicleUpgradeTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"VehicleUpgradeTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	fVar1 = (float)fVar15;
	level->UpgradeTimes[1] = fVar1;
	if (fVar1 == 0.0) {
		level->UpgradeTimes[1] = fVar9;
	}
	else {
		level->UpgradeTimes[1] = fVar1 * 25.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"BuildingUpgradeTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"BuildingUpgradeTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	fVar1 = (float)fVar15;
	level->UpgradeTimes[4] = fVar1;
	if (fVar1 == 0.0) {
		level->UpgradeTimes[4] = fVar9;
	}
	else {
		level->UpgradeTimes[4] = fVar1 * 25.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"TrainTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"TrainTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->TrainTime = (float)(fVar15 * (float10)25.0);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"NoMultiSelect",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	if (BVar8 == BOOL3_TRUE) {
		globs::gameGlobs.flags2 |= GAME2_NOMULTISELECT;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"NoAutoEat",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	if (BVar8 == BOOL3_TRUE) {
		globs::gameGlobs.flags2 |= GAME2_NOAUTOEAT;
	}
	else {
		globs::gameGlobs.flags2 &= ~GAME2_NOAUTOEAT;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"EndGameAVI1",0);
	globs::gameGlobs.EndGameAVI1 = cfg::CFG_CopyString(root,pcVar6);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"EndGameAVI2",0);
	globs::gameGlobs.EndGameAVI2 = cfg::CFG_CopyString(root,pcVar6);
	if (globs::gameGlobs.RenameReplace != NULL) {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"AllowRename",0);
		BVar8 = cfg::CFG_ReadBool(root,pcVar6);
		if (BVar8 == BOOL3_TRUE) {
			globs::gameGlobs.flags2 |= GAME2_ALLOWRENAME;
		}
		else {
			globs::gameGlobs.flags2 &= ~GAME2_ALLOWRENAME;
		}
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"RecallOLObjects",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	if (BVar8 == BOOL3_TRUE) {
		globs::gameGlobs.flags2 |= GAME2_RECALLOLOBJECTS;
	}
	else {
		globs::gameGlobs.flags2 &= ~GAME2_RECALLOLOBJECTS;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"GenerateSpiders",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	if (BVar8 == BOOL3_TRUE) {
		globs::gameGlobs.flags2 |= GAME2_GENERATESPIDERS;
	}
	else {
		globs::gameGlobs.flags2 &= ~GAME2_GENERATESPIDERS;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"DisableToolTipSound",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	if (BVar8 == BOOL3_TRUE) {
		globs::gameGlobs.flags2 |= GAME2_DISABLETOOLTIPSOUND;
	}
	else {
		globs::gameGlobs.flags2 &= ~GAME2_DISABLETOOLTIPSOUND;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"DisableEndTeleport",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	game::Objective_Game_SetEndTeleportEnabled((uint)(BVar8 != BOOL3_TRUE));
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"DragBoxRGB",0);
	pcVar6 = cfg::CFG_CopyString(root,pcVar6);
	local_19c = pcVar6;
	if (pcVar6 != NULL) {
		iVar5 = util::Util_Tokenise(pcVar6,(char **)local_12c,":");
		if (iVar5 == 3) {
			uVar7 = 0;
			do {
				local_1b0 = std::atoi(*(char **)((int)local_12c + uVar7));
				uVar14 = uVar7 + 4;
				*(float *)((int)globs::gameGlobs.UpgradeNames_TABLE + (uVar7 - 0x2c)) =
						 (float)local_1b0 * 0.003921569;
				pcVar6 = local_19c;
				uVar7 = uVar14;
			} while (uVar14 < 0xc);
		}
		std::free(pcVar6);
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"BuildingTolerance",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"BuildingTolerance",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->BuildingTolerance = (float)fVar15;
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"BuildingMaxVariation",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"BuildingMaxVariation",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	level->BuildingMaxVariation = (float)fVar15;
	if (level->BuildingTolerance == 0.0) {
		level->BuildingTolerance = 4.0;
	}
	if ((float10)0.0 == fVar15) {
		level->BuildingMaxVariation = 6.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"MaxStolen",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"MaxStolen",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar9 = (float)std::atoi(pcVar6);
	level->MaxStolen = fVar9;
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"Slug",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		level->Slug = 0x14;
	}
	else {
		BVar4 = game::Object_GetObjectByName(pcVar6,&local_1b0,&level->Slug,NULL);
		if (BVar4 != 0) {
			pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"SlugTime",0);
			pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			if (pcVar6 == NULL) {
				pcVar6 = ____EMPTYSTR__;
			}
			else {
				pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"SlugTime",0);
				pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			}
			fVar15 = std::atof(pcVar6);
			level->SlugTime = (float)fVar15;
			if ((float)fVar15 == 0.0) {
				level->SlugTime = 60.0;
			}
			level->SlugTime = level->SlugTime * 25.0;
			pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"InitialSlugTime",0);
			pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			if (pcVar6 == NULL) {
				pcVar6 = ____EMPTYSTR__;
			}
			else {
				pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"InitialSlugTime",0);
				pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			}
			fVar15 = std::atof(pcVar6);
			if ((float10)0.0 == fVar15) {
				fVar15 = (float10)60.0;
			}
			globs::gameGlobs.InitialSlugTime = (float)(fVar15 * (float10)25.0);
		}
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"RockFallStyle",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	effect::Effect_GetRockFallStyle(pcVar6,&local_164);
	effect::Effect_SetRockFallStyleIndex(local_164);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"noFallins",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	globs::gameGlobs.IsFallinsEnabled = ZEXT14(BVar8 != BOOL3_TRUE);
	game::Level_LoadRewardQuotaCrystals(root,globs::gameGlobs.CfgRootName,levelName);
	game::Object_GetObjectByName
						(nameEmergeCreature,(ObjectType *)&nameEmergeCreature,&level->EmergeCreature,NULL);
	pfVar17 = &globs::gameGlobs.FogColourRGB.blue;
	pfVar13 = &globs::gameGlobs.FogColourRGB.green;
	pCVar16 = &globs::gameGlobs.FogColourRGB;
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"FogColourRGB",0);
	BVar4 = cfg::CFG_ReadRGBF(globs::gameGlobs.LegoCfgRoot,pcVar6,(float *)pCVar16,pfVar13,pfVar17);
	if (BVar4 == 0) {
		globs::gameGlobs.flags1 &= ~GAME1_FOGCOLOURRGB;
	}
	else {
		pfVar17 = &globs::gameGlobs.HighFogColourRGB.blue;
		pfVar13 = &globs::gameGlobs.HighFogColourRGB.green;
		pCVar16 = &globs::gameGlobs.HighFogColourRGB;
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"HighFogColourRGB",0);
		BVar4 = cfg::CFG_ReadRGBF(globs::gameGlobs.LegoCfgRoot,pcVar6,(float *)pCVar16,pfVar13,pfVar17);
		if (BVar4 == 0) {
			globs::gameGlobs.flags1 &= ~GAME1_HIGHFOGCOLOURRGB;
		}
		else {
			globs::gameGlobs.flags1 |= GAME1_HIGHFOGCOLOURRGB;
			globs::gameGlobs.float_364 = 1.0;
			pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"FogRate",0);
			pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			if (pcVar6 == NULL) {
				pcVar6 = ____EMPTYSTR__;
			}
			else {
				pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"FogRate",0);
				pcVar6 = cfg::CFG_ReadString(root,pcVar6);
			}
			fVar15 = std::atof(pcVar6);
			if ((float10)0.0 == fVar15) {
				globs::gameGlobs.FogRate = 1500.0;
			}
			else {
				globs::gameGlobs.FogRate = (float)fVar15 * 25.0;
			}
		}
		res::Container_SetFogColour
							(globs::gameGlobs.FogColourRGB.red,globs::gameGlobs.FogColourRGB.green,
							 globs::gameGlobs.FogColourRGB.blue);
		res::Container_SetFogMode(D3DRMFOGMETHOD_TABLE);
		res::Container_SetFogParams
							(0.0,(globs::gameGlobs.level)->BlockSize * globs::gameGlobs.FPClipBlocks,0.0032);
		globs::gameGlobs.flags1 |= GAME1_FOGCOLOURRGB;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"nextlevel",0);
	pcVar6 = cfg::CFG_CopyString(root,pcVar6);
	level->NextLevel = pcVar6;
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"FullName",0);
	nameEmergeCreature = cfg::CFG_CopyString(root,pcVar6);
	level->FullName = nameEmergeCreature;
	if (nameEmergeCreature == NULL) {
		level->FullName = NULL;
	}
	else {
		iVar5 = -1;
		uVar7 = 0;
		pcVar6 = nameEmergeCreature;
		do {
			if (iVar5 == 0) break;
			iVar5 += -1;
			cVar2 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar2 != '\0');
		if (iVar5 != -2) {
			do {
				cVar2 = nameEmergeCreature[uVar7];
				if (cVar2 == '_') {
					cVar2 = ' ';
				}
				nameEmergeCreature[uVar7] = cVar2;
				nameEmergeCreature = level->FullName;
				uVar14 = 0xffffffff;
				uVar7 += 1;
				pcVar6 = nameEmergeCreature;
				do {
					if (uVar14 == 0) break;
					uVar14 -= 1;
					cVar2 = *pcVar6;
					pcVar6 = pcVar6 + 1;
				} while (cVar2 != '\0');
			} while (uVar7 < ~uVar14 - 1);
		}
	}
	game::Objective_Level_LoadObjectiveInfo
						(root,globs::gameGlobs.CfgRootName,levelName,level,globs::mainGlobs.appWidth,
						 globs::mainGlobs.appHeight);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"ErodeTriggerTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"ErodeTriggerTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	local_1bc = (float)fVar15;
	if ((float10)0.0 == fVar15) {
		local_1bc = 10.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"ErodeErodeTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"ErodeErodeTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	local_1b8 = (float)fVar15;
	if ((float10)0.0 == fVar15) {
		local_1b8 = 5.0;
	}
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"ErodeLockTime",0);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"ErodeLockTime",0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	fVar15 = std::atof(pcVar6);
	local_1c0 = (float)fVar15;
	if ((float10)0.0 == fVar15) {
		local_1c0 = 60.0;
	}
	game::Erode_Initialise(local_1bc,local_1b8,local_1c0);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"NumberOfLandSlidesTillCaveIn",0
														);
	pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	if (pcVar6 == NULL) {
		pcVar6 = ____EMPTYSTR__;
	}
	else {
		pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"NumberOfLandSlidesTillCaveIn"
															 ,0);
		pcVar6 = cfg::CFG_ReadString(root,pcVar6);
	}
	iVar5 = std::atoi(pcVar6);
	if (iVar5 == 0) {
		iVar5 = 3;
	}
	game::Fallin_SetNumberOfLandSlidesTillCaveIn(iVar5);
	pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"DisableStartTeleport",0);
	BVar8 = cfg::CFG_ReadBool(root,pcVar6);
	level->levelName = levelName;
	level->IsStartTeleportEnabled = (uint)(BVar8 != BOOL3_TRUE);
	level->float_204 = (float)&DAT_42c80000;
	level->oxygenLevel = (float)&DAT_42c80000;
	level->numCrystals = 0;
	level->numOre = 0;
	level->field_90 = 0;
	level->field_a4 = 0;
	level->field_94 = 0;
	level->field_a8 = 0;
	level->status = LEVELSTATUS_NONE;
	globs::gameGlobs.placeDestSmallTeleporter = NULL;
	globs::gameGlobs.placeDestBigTeleporter = NULL;
	nerps::NERPs_Level_LoadNERPsFile(filenameNERP);
	nerps::NERPs_Level_LoadNERPMessageFile(filenameNERPMessage);
	BVar4 = Main_loadPTLCFG__0045daa0(filenamePTL,globs::gameGlobs.CfgRootName);
	if (BVar4 != 0) {
		local_1bc = 0.0;
		local_1c0._0_1_ = '\0';
		local_1b8 = 0.0;
		local_19c = NULL;
		local_1b0 = OBJECT_NONE;
		if ((local_1a0 != NULL) && (iVar5 = util::Util_Tokenise(local_1a0,&local_160,":"), iVar5 == 2))
		{
			std::atoi(local_15c);
		}
		if ((local_1a8 != NULL) && (iVar5 = util::Util_Tokenise(local_1a8,&local_160,":"), iVar5 == 2))
		{
			local_1b0 = std::atoi(local_15c);
		}
		if ((local_194 != NULL) && (iVar5 = util::Util_Tokenise(local_194,&local_160,":"), iVar5 == 2))
		{
			local_19c = (char *)std::atoi(local_15c);
		}
		if ((local_198 != NULL) && (iVar5 = util::Util_Tokenise(local_198,&local_160,":"), iVar5 == 2))
		{
			local_1b8 = (float)std::atoi(local_15c);
		}
		if ((local_1ac != NULL) && (iVar5 = util::Util_Tokenise(local_1ac,&local_160,":"), iVar5 == 2))
		{
			iVar5 = std::atoi(local_15c);
			local_1c0._0_1_ = (char)iVar5;
		}
		if ((local_1a4 != NULL) && (iVar5 = util::Util_Tokenise(local_1a4,&local_160,":"), iVar5 == 2))
		{
			local_1bc = (float)std::atoi(local_15c);
		}
		if ((local_190 != NULL) && (iVar5 = util::Util_Tokenise(local_190,&local_160,":"), iVar5 == 2))
		{
			std::atoi(local_15c);
		}
		pcVar6 = local_184;
		if ((local_184 != NULL) && (iVar5 = util::Util_Tokenise(local_184,&local_160,":"), iVar5 == 2))
		{
			local_1bc = (float)std::atoi(local_15c);
		}
		BVar4 = game::Level_LoadMapFiles
											(level,local_1a0,local_1a8,local_1b0,local_194,(int)local_19c,local_198,
											 local_1b8,local_1ac,local_1c0._0_1_,local_18c,local_1a4,(int)local_1bc,
											 local_178,pcVar6,local_188,local_190);
		if (BVar4 != 0) {
			std::free(local_1a0);
			std::free(local_1a8);
			std::free(local_194);
			std::free(local_198);
			std::free(local_1ac);
			std::free(local_18c);
			std::free(pcVar6);
			std::free(local_188);
			std::free(local_190);
			if (local_1a4 != NULL) {
				std::free(local_1a4);
			}
			game::ElectricFence_ResetAll(level);
			game::SpiderWeb_ResetAll(level);
			game::Objective_Level_SetCompleteStatus(LEVELSTATUS_NONE);
			game::Objective_FUN_00458ea0(globs::gameGlobs.textWnd_80,globs::gameGlobs.level,1.0,1.0);
			BVar4 = game::Game_LoadOLObjectList(level,(char *)filenameObjectList.x);
			if (BVar4 != 0) {
				pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"InitialCrystals",0);
				pcVar6 = cfg::CFG_ReadString(root,pcVar6);
				if (pcVar6 == NULL) {
					pcVar6 = ____EMPTYSTR__;
				}
				else {
					pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"InitialCrystals",0);
					pcVar6 = cfg::CFG_ReadString(root,pcVar6);
				}
				local_134 = std::atoi(pcVar6);
				pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"InitialOre",0);
				pcVar6 = cfg::CFG_ReadString(root,pcVar6);
				if (pcVar6 == NULL) {
					pcVar6 = ____EMPTYSTR__;
				}
				else {
					pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"InitialOre",0);
					pcVar6 = cfg::CFG_ReadString(root,pcVar6);
				}
				local_130 = std::atoi(pcVar6);
				game::Search_LiveObjects_SkipIgnoreMes(FUN_0042b220,&local_138);
				front::Loader_display_loading_bar(NULL);
				filenameObjectList.x = 350.0;
				filenameObjectList.y = 70.0;
				video::VideoPlayer_OpenAndPlay(filenameIntroAVI,&filenameObjectList);
				pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"NoGather",0);
				BVar8 = cfg::CFG_ReadBool(root,pcVar6);
				ai::AITask_Game_SetNoGather((uint)(BVar8 == BOOL3_TRUE));
				front::Info_SetFlag4(1);
				if ((level->StartFP == 0) || (globs::liveGlobs.minifigureObj_9cb8 == NULL)) {
					game::Game_SetViewMode(VIEW_TOPDOWN,NULL,0);
				}
				else {
					game::Game_SetViewMode(VIEW_FIRSTPERSON,globs::liveGlobs.minifigureObj_9cb8,1);
					game::Message_AddMessageAction(MESSAGE_SELECT,globs::liveGlobs.minifigureObj_9cb8,0,NULL);
					front::Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_FIRSTPERSON,NULL);
				}
				nerps::NERPs_InitBlockPointersTable(level);
				pcVar6 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,levelName,"Precreate",0);
				BVar8 = cfg::CFG_ReadBool(root,pcVar6);
				if (BVar8 == BOOL3_TRUE) {
					ppLVar11 = local_12c;
					iVar5 = 10;
					do {
						pLVar10 = game::LiveObject__Create
																((int **)globs::gameGlobs.MiniFigureData_TABLE,OBJECT_MINIFIGURE,0);
						*ppLVar11 = pLVar10;
						ppLVar11 = ppLVar11 + 1;
						iVar5 += -1;
					} while (iVar5 != 0);
					ppLVar11 = local_12c;
					iVar5 = 10;
					do {
						pool::ReservedPool_LiveObject___Release(*ppLVar11);
						ppLVar11 = ppLVar11 + 1;
						iVar5 += -1;
					} while (iVar5 != 0);
				}
				return TRUE;
			}
		}
	}
	std::free(level);
LAB_0042b198:
	std::free(local_1a0);
	std::free(local_1a8);
	std::free(local_194);
	std::free(local_198);
	std::free(local_1ac);
	std::free(local_18c);
	std::free(local_184);
	front::Loader_display_loading_bar(NULL);
	globs::gameGlobs.level = NULL;
	return 0;
}



undefined4 __cdecl FUN_0042b220(int param_1,int param_2)
{
	ObjectStatsFlags1 OVar1;
	
	OVar1 = lego::game::LiveObject_GetStatsFlags1((LiveObject *)param_1);
	if ((OVar1 & STATS1_STOREOBJECTS) != STATS1_NONE) {
		FUN_0043abb0(param_1,*(int *)(param_2 + 4));
		FUN_0043abd0(param_1,*(int *)(param_2 + 8));
	}
	return 0;
}



BOOL __cdecl lego::game::WorldMesh_LoadPromeshGrid(LevelData *level,char *meshBaseName)
{
	ProMeshData **ppPVar1;
	ProMeshData *pPVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	int local_20c;
	char meshName_a [256];
	char meshName_b [256];
	uint width;
	uint height;
	
	height = (level->surfTextSize).height;
	width = (level->surfTextSize).width;
	ppPVar1 = (ProMeshData **)std::malloc(height * width * 4);
	level->promeshGrid = ppPVar1;
	if (ppPVar1 == NULL) {
		return 0;
	}
	if ((globs::mainGlobs.flags & CMD_REDUCEPROMESHES) == CMD_NONE) {
		uVar5 = 0;
		if (height != 0) {
			local_20c = 0;
			do {
				uVar4 = 0;
				iVar3 = local_20c;
				if (width != 0) {
					do {
						std::sprintf(meshName_a,"%s%0.1x%0.1xa",meshBaseName,uVar4,uVar5);
						std::sprintf(meshName_b,"%s%0.1x%0.1xb",meshBaseName,uVar4,uVar5);
						pPVar2 = res::DynamicPM_LoadPromesh_AB
															 (globs::gameGlobs.resRoot,meshName_a,meshName_b,level->BlockSize,
																level->surfTextGrid);
						uVar4 += 1;
						*(ProMeshData **)((int)level->promeshGrid + iVar3) = pPVar2;
						iVar3 = iVar3 + 4;
					} while (uVar4 < width);
				}
				uVar5 += 1;
				local_20c += width * 4;
			} while (uVar5 < height);
			return TRUE;
		}
	}
	else {
		for (uVar5 = height * width & 0x3fffffff; uVar5 != 0; uVar5 -= 1) {
			*ppPVar1 = NULL;
			ppPVar1 = ppPVar1 + 1;
		}
		for (iVar3 = 0; iVar3 != 0; iVar3 += -1) {
			*(undefined *)ppPVar1 = 0;
			ppPVar1 = (ProMeshData **)((int)ppPVar1 + 1);
		}
	}
	return TRUE;
}



void __cdecl lego::game::Level_Free_ProMeshGrid(LevelData *level)
{
	LevelData *pLVar1;
	int iVar2;
	int iVar3;
	int iVar4;
	LevelData *level_00;
	int width;
	
	level_00 = level;
	pLVar1 = (LevelData *)(level->surfTextSize).height;
	width = (level->surfTextSize).width;
	if (pLVar1 != NULL) {
		iVar3 = 0;
		iVar2 = width;
		level = pLVar1;
		iVar4 = iVar3;
		do {
			for (; iVar2 != 0; iVar2 = iVar2 + -1) {
				res::DynamicPM_Free(*(ProMeshData **)((int)level_00->promeshGrid + iVar3));
				iVar3 += 4;
			}
			iVar3 = iVar4 + width * 4;
			level = (LevelData *)((int)&level[-1].IsStartTeleportEnabled + 3);
			iVar2 = width;
			iVar4 = iVar3;
		} while (level != NULL);
	}
	std::free(level_00->promeshGrid);
	level_00->promeshGrid = NULL;
	return;
}



LevelStruct_3c * __cdecl FUN_0042b430(void)
{
	return (lego::globs::gameGlobs.level)->struct3c_84;
}



BOOL __cdecl
lego::game::Level_LoadMapFiles
					(LevelData *level,char *surfaceMap,char *predugMap,int predugParam,char *terrainMap,
					int terrainParam,char *blockPointersMap,int blockPointersParam,char *cryOreMap,
					char cryOreParam,char *erodeMap,char *pathMap,int pathParam,char *textureSet,
					char *emergeMap,char *aiMap,char *fallinMap)
{
	short sVar1;
	SurfaceMap *pSVar2;
	LevelStruct_3c *pLVar3;
	BOOL BVar4;
	uint uVar5;
	int iVar6;
	uint uVar7;
	uint uVar8;
	
	pSVar2 = Map3D_LoadSurfaceMap
										 (globs::gameGlobs.resRoot,surfaceMap,level->BlockSize,level->RoughLevel);
	level->surfaceMap = pSVar2;
	if (pSVar2 != NULL) {
		pLVar3 = LevelStruct3C_Create
											 (pSVar2,(Rect2F *)&globs::gameGlobs.float_324,
												globs::gameGlobs.tvTiltOrZoom_334);
		level->struct3c_84 = pLVar3;
		Map3D_SetPerspectiveCorrectionAll(level->surfaceMap,TRUE);
										// It seems this entire chain of calls is redundant, as they all cause the exact
										// same effect.
		Map3D_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		Map3D_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		Map3D_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		Map3D_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		Map3D_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		Map3D_SetArray40B4_IndexToTrue(level->surfaceMap,0x70);
		pSVar2 = level->surfaceMap;
		(level->dimensions).width = (pSVar2->dimensions).width;
		(level->dimensions).height = (pSVar2->dimensions).height;
		ElectricFence_ResetAll(level);
		SpiderWeb_ResetAll(level);
		if (level->UseRoof != BOOL3_FALSE) {
			WorldMesh_Create(globs::gameGlobs.resRoot,(level->dimensions).width,(level->dimensions).height
											);
			WorldMesh_Hide(TRUE);
		}
		pSVar2 = (SurfaceMap *)WorldMesh_LoadTextureType(level,textureSet);
		if (pSVar2 != NULL) {
			pSVar2 = (SurfaceMap *)
							 std::malloc((level->dimensions).height * (level->dimensions).width * 0x48);
			level->blocks = (LevelBlock *)pSVar2;
			if (pSVar2 != NULL) {
				uVar7 = 0;
				for (uVar5 = (uint)((level->dimensions).height * (level->dimensions).width * 0x48) >> 2;
						uVar5 != 0; uVar5 -= 1) {
					(pSVar2->smallDimensions).width = 0;
					pSVar2 = (SurfaceMap *)&(pSVar2->smallDimensions).height;
				}
				for (iVar6 = 0; iVar6 != 0; iVar6 += -1) {
					*(undefined *)&(pSVar2->smallDimensions).width = 0;
					pSVar2 = (SurfaceMap *)((int)&(pSVar2->smallDimensions).width + 1);
				}
				if ((level->dimensions).height != 0) {
					do {
						uVar5 = (level->dimensions).width;
						uVar8 = 0;
						if (uVar5 != 0) {
							do {
								level->blocks[uVar7 * uVar5 + uVar8].predug = PREDUG_WALL;
								level->blocks[uVar7 * (level->dimensions).width + uVar8].texture = TEXTURE_GROUND;
								level->blocks[uVar7 * (level->dimensions).width + uVar8].terrain = TERRAIN_TUNNEL;
								level->blocks[uVar7 * (level->dimensions).width + uVar8].flags1 = BLOCK1_NONE;
								level->blocks[uVar7 * (level->dimensions).width + uVar8].field_3 = 0;
								level->blocks[uVar7 * (level->dimensions).width + uVar8].struct1c_18 = NULL;
								level->blocks[uVar7 * (level->dimensions).width + uVar8].float_14 = 0.0;
								sVar1 = math::Maths_Rand();
								iVar6 = uVar7 * (level->dimensions).width + uVar8;
								uVar8 += 1;
								level->blocks[iVar6].randomness = sVar1;
								uVar5 = (level->dimensions).width;
							} while (uVar8 < uVar5);
						}
						uVar7 += 1;
					} while (uVar7 < (uint)(level->dimensions).height);
				}
				pSVar2 = (SurfaceMap *)Level_LoadPredugMap(level,predugMap,predugParam);
				if (pSVar2 != NULL) {
					pSVar2 = (SurfaceMap *)Level_LoadTerrainMap(level,terrainMap,terrainParam);
					if (pSVar2 != NULL) {
						Level_LoadCryOreMap(level,cryOreMap,cryOreParam);
						Level_LoadErodeMap(level,erodeMap);
						Level_LoadPathMap(level,pathMap,pathParam);
						Level_LoadEmergeMap(level,emergeMap);
						Level_LoadAIMap(level,aiMap);
						Level_LoadFallinMap(level,fallinMap);
						BVar4 = Level_LoadBlockPointersMap(level,blockPointersMap,blockPointersParam);
						if (BVar4 != 0) {
							level->hasBlockPointers = 1;
						}
						uVar5 = 0;
						if ((level->dimensions).height != 0) {
							do {
								uVar7 = 0;
								if ((level->dimensions).width != 0) {
									do {
										Level_UpdateBlockSurfaceUnk(level,uVar7,uVar5,1);
										uVar7 += 1;
									} while (uVar7 < (uint)(level->dimensions).width);
								}
								uVar5 += 1;
							} while (uVar5 < (uint)(level->dimensions).height);
						}
						Map3D_UpdateAll_BlockTexturesAndVertices(level->surfaceMap);
						LevelStruct428_Load_FUN_0046de50(globs::gameGlobs.resRoot,level);
						pSVar2 = (SurfaceMap *)0x1;
					}
				}
			}
		}
	}
	return (BOOL)pSVar2;
}



void __cdecl lego::game::SurfaceMap_InitTextureCoords(SurfaceMap *surfMap)
{
	SurfaceTexture SVar1;
	uint uVar2;
	uint uVar3;
	SurfaceTexture local_68 [8];
	SurfaceTexture local_60 [8];
	SurfaceTexture local_58 [8];
	SurfaceTexture local_50 [8];
	SurfaceTexture local_48 [8];
	SurfaceTexture local_40 [8];
	SurfaceTexture local_38 [8];
	SurfaceTexture local_30 [16];
	SurfaceTexture local_20 [32];
	
	local_38[0] = TEXTURE_TUNNEL;
	local_38[1] = TEXTURE_TUNNEL;
	local_38[2] = TEXTURE_TUNNEL;
	local_38[3] = TEXTURE_TUNNEL;
	local_38[4] = TEXTURE_TUNNEL;
	local_38[5] = TEXTURE_TUNNEL;
	local_30[4] = TEXTURE_WALL_F_SOIL;
	local_30[5] = TEXTURE_WALL_F_ORESEAM;
	local_30[6] = TEXTURE_WALL_F_CRYSTALSEAM;
	local_30[7] = TEXTURE_WALL_F_RECHARGESEAM;
	local_30[12] = TEXTURE_WALL_F_SOIL;
	local_30[13] = TEXTURE_WALL_F_ORESEAM;
	local_30[14] = TEXTURE_WALL_F_CRYSTALSEAM;
	local_30[15] = TEXTURE_WALL_F_RECHARGESEAM;
	local_20[0] = TEXTURE_GROUND;
	local_20[1] = TEXTURE_GROUND;
	local_20[2] = TEXTURE_GROUND;
	local_20[3] = TEXTURE_GROUND;
	local_20[4] = TEXTURE_LAVA;
	local_20[5] = TEXTURE_LAVA_NOTHOT;
	local_20[6] = TEXTURE_WATER;
	local_20[7] = TEXTURE_GROUND;
	local_20[8] = TEXTURE_PLATE;
	local_20[9] = TEXTURE_PLATE_POWERED;
	local_20[10] = TEXTURE_RUBBLE_FULL;
	local_20[11] = TEXTURE_RUBBLE_HIGH;
	local_20[12] = TEXTURE_RUBBLE_MEDIUM;
	local_20[13] = TEXTURE_RUBBLE_LOW;
	local_20[14] = TEXTURE_ERODE_LOW;
	local_20[15] = TEXTURE_ERODE_MEDIUM;
	local_20[16] = TEXTURE_ERODE_HIGH;
	local_20[17] = TEXTURE_ERODE_FULL;
	local_20[18] = TEXTURE_07;
	local_20[19] = TEXTURE_PATH_BUILD;
	local_20[20] = TEXTURE_PATH_4;
	local_20[21] = TEXTURE_PATH_2;
	local_20[22] = TEXTURE_PATH_C;
	local_20[23] = TEXTURE_PATH_3;
	local_20[24] = TEXTURE_PATH_1;
	local_20[25] = TEXTURE_PATH_4_POWERED;
	local_20[26] = TEXTURE_PATH_2_POWERED;
	local_20[27] = TEXTURE_PATH_C_POWERED;
	local_20[28] = TEXTURE_PATH_3_POWERED;
	local_20[29] = TEXTURE_PATH_1_POWERED;
	local_20[30] = TEXTURE_SLUGHOLE;
	local_30[0] = TEXTURE_WALL_F_IMMOVABLE;
	local_30[1] = TEXTURE_WALL_F_HARD;
	local_30[2] = TEXTURE_WALL_F_MEDIUM;
	local_30[3] = TEXTURE_WALL_F_LOOSE;
	local_30[8] = TEXTURE_WALL_F_IMMOVABLE;
	local_30[9] = TEXTURE_WALL_F_HARD;
	local_30[10] = TEXTURE_WALL_F_MEDIUM;
	local_30[11] = TEXTURE_WALL_F_LOOSE;
	local_68[0] = TEXTURE_WALL_R_IMMOVABLE;
	local_68[1] = TEXTURE_WALL_R_HARD;
	local_68[2] = TEXTURE_WALL_R_MEDIUM;
	local_68[3] = TEXTURE_WALL_R_LOOSE;
	local_68[4] = TEXTURE_WALL_R_SOIL;
	local_60[0] = TEXTURE_WALL_C_IMMOVABLE;
	local_60[1] = TEXTURE_WALL_C_HARD;
	local_60[2] = TEXTURE_WALL_C_MEDIUM;
	local_60[3] = TEXTURE_WALL_C_LOOSE;
	local_60[4] = TEXTURE_WALL_C_SOIL;
	local_58[0] = TEXTURE_WALL_C_IMMOVABLE;
	local_58[1] = TEXTURE_WALL_C_HARD;
	local_58[2] = TEXTURE_WALL_C_MEDIUM;
	local_58[3] = TEXTURE_WALL_C_LOOSE;
	local_58[4] = TEXTURE_WALL_C_SOIL;
	local_50[4] = TEXTURE_WALL_O_SOIL;
	local_48[4] = TEXTURE_WALL_O_SOIL;
	local_50[0] = TEXTURE_WALL_O_IMMOVABLE;
	local_50[1] = TEXTURE_WALL_O_HARD;
	local_50[2] = TEXTURE_WALL_O_MEDIUM;
	local_50[3] = TEXTURE_WALL_O_LOOSE;
	local_48[0] = TEXTURE_WALL_O_IMMOVABLE;
	local_48[1] = TEXTURE_WALL_O_HARD;
	local_48[2] = TEXTURE_WALL_O_MEDIUM;
	local_48[3] = TEXTURE_WALL_O_LOOSE;
	local_40[0] = TEXTURE_WALL_GAP;
	local_40[1] = TEXTURE_WALL_GAP;
	local_40[2] = TEXTURE_WALL_GAP;
	local_40[3] = TEXTURE_WALL_GAP;
	local_40[4] = TEXTURE_WALL_GAP;
	uVar2 = 0;
	do {
		SVar1 = local_20[uVar2];
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_30[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 0x10);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_68[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_60[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_58[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_50[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_48[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_40[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar2 += 1;
	} while (uVar2 < 0x1f);
	uVar2 = 0;
	do {
		SVar1 = local_38[uVar2];
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_30[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 0x10);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_68[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_60[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_58[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_50[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_48[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar3 = 0;
		do {
			Map3D_AddTextureCoordMapping(surfMap,SVar1,local_40[uVar3]);
			uVar3 += 1;
		} while (uVar3 < 5);
		uVar2 += 1;
	} while (uVar2 < 6);
	return;
}



BOOL __cdecl lego::game::WorldMesh_LoadTextureType(LevelData *level,char *keyTexturePath)
{
	SurfaceMap *surfMap;
	CFGProperty *prop;
	char *pcVar1;
	int iVar2;
	int iVar3;
	char *pcVar4;
	SurfaceTextureGrid *field2c;
	BOOL BVar5;
	BOOL result;
	
	prop = globs::gameGlobs.LegoCfgRoot;
	result = 0;
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,keyTexturePath,"surftextwidth",0);
	pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
	if (pcVar1 == NULL) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,keyTexturePath,"surftextwidth",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
	}
	iVar2 = std::atoi(pcVar1);
	if (iVar2 != 0) {
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,keyTexturePath,"surftextheight",0);
		pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		if (pcVar1 == NULL) {
			pcVar1 = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,keyTexturePath,"surftextheight",0);
			pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
		}
		iVar3 = std::atoi(pcVar1);
		if (iVar3 != 0) {
			surfMap = level->surfaceMap;
			(level->surfTextSize).width = iVar2;
			(level->surfTextSize).height = iVar3;
			SurfaceMap_InitTextureCoords(surfMap);
			Map3D_UpdateAll_BlockTexturesAndVertices(level->surfaceMap);
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,keyTexturePath,"meshbasename",0);
			pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
			if (pcVar1 != NULL) {
				pcVar4 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,keyTexturePath,"texturebasename",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 != NULL) {
					field2c = res::DynamicPM_LoadTextureBaseName
															(pcVar4,(level->surfTextSize).width,(level->surfTextSize).height);
					level->surfTextGrid = field2c;
					if (field2c != NULL) {
						Map3D_SetField_2c(level->surfaceMap,field2c);
						BVar5 = WorldMesh_LoadPromeshGrid(level,pcVar1);
						if (BVar5 != 0) {
							pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,keyTexturePath,"rooftexture",0
																				);
							pcVar1 = cfg::CFG_ReadString(prop,pcVar1);
							if (pcVar1 != NULL) {
								BVar5 = WorldMesh_LoadTextures(pcVar1);
								if (BVar5 != 0) {
									result = TRUE;
								}
							}
						}
					}
				}
			}
		}
	}
	return result;
}



BOOL __cdecl lego::game::Level_LoadPredugMap(LevelData *level,char *filename,int modifier)
{
	int *piVar1;
	LevelBlockFlags1 *pLVar2;
	int iVar3;
	uint uVar4;
	char *pcVar5;
	int *piVar6;
	int iVar7;
	uint by;
	int iVar8;
	char *bx;
	int local_58;
	uint local_54;
	Point2I local_50;
	int local_48 [5];
	undefined4 local_34;
	undefined4 local_30;
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if ((filename != NULL) &&
		 (uVar4 = lego::file::File_LoadBinaryHandle(filename,NULL), uVar4 != 0xffffffff)) {
		local_54 = uVar4;
		MapShared_GetDimensions(uVar4,(int *)&filename,&local_58);
		if ((filename == (char *)(level->dimensions).width) && (local_58 == (level->dimensions).height))
		{
			by = 1;
			pcVar5 = filename;
			iVar8 = local_58;
			if (local_58 != 1 && local_58 != 2) {
				do {
					bx = (char *)0x1;
					if (pcVar5 != (char *)0x1 && pcVar5 != (char *)0x2) {
						do {
							uVar4 = MapShared_GetBlock(local_54,(int)bx,by);
							iVar8 = uVar4 - modifier;
							if ((iVar8 == 1) || (iVar8 == 3)) {
								Level_DestroyWall(level,(int)bx,by,1);
								local_48[0] = -1;
								local_48[1] = 0xffffffff;
								local_48[3] = 0xffffffff;
								local_34 = 0xffffffff;
								local_18 = 0xffffffff;
								local_10 = 0xffffffff;
								local_8 = 0;
								local_48[2] = 0;
								local_48[4] = 1;
								local_30 = 1;
								local_2c = 0;
								local_28 = 1;
								local_24 = 1;
								local_20 = 0;
								local_1c = 1;
								local_14 = 1;
								local_c = 0;
								local_4 = 0;
								piVar6 = local_48;
								iVar7 = 9;
								do {
									piVar1 = piVar6 + 1;
									iVar3 = *piVar6;
									piVar6 = piVar6 + 2;
									pLVar2 = &level->blocks
														[(int)(bx + iVar3 + (*piVar1 + by) * (level->dimensions).width)].flags1;
									iVar7 += -1;
									*pLVar2 = *pLVar2 | BLOCK1_EXPOSED;
								} while (iVar7 != 0);
							}
							else {
								if ((iVar8 == 2) || (iVar8 == 4)) {
									level->blocks[(int)(bx + by * (level->dimensions).width)].flags1 =
											 level->blocks[(int)(bx + by * (level->dimensions).width)].flags1 |
											 BLOCK1_HIDDEN;
								}
							}
							if (iVar8 == 3) {
								level->blocks[(int)(bx + by * (level->dimensions).width)].flags2 =
										 level->blocks[(int)(bx + by * (level->dimensions).width)].flags2 |
										 BLOCK2_SLUGHOLE_EXPOSED;
								local_50.x = (int)bx;
								local_50.y = by;
								Level_RegisterSlimySlugHole(&local_50);
							}
							if (iVar8 == 4) {
								level->blocks[(int)(bx + by * (level->dimensions).width)].flags2 =
										 level->blocks[(int)(bx + by * (level->dimensions).width)].flags2 |
										 BLOCK2_SLUGHOLE_HIDDEN;
							}
							bx = bx + 1;
							pcVar5 = filename;
							iVar8 = local_58;
						} while (bx < filename + -1);
					}
					by += 1;
					uVar4 = local_54;
				} while (by < iVar8 - 1U);
			}
			lego::file::Mem_FreeHandle(uVar4);
			return 1;
		}
		lego::file::Mem_FreeHandle(uVar4);
	}
	return 0;
}



BOOL __cdecl lego::game::Level_LoadErodeMap(LevelData *level,char *filename)
{
	bool bVar1;
	short sVar2;
	uint uVar3;
	char *pcVar4;
	uint uVar5;
	char *bx;
	uint by;
	uint local_10;
	uint local_c;
	Point2I blockPos;
	
	if ((filename != NULL) &&
		 (uVar3 = lego::file::File_LoadBinaryHandle(filename,NULL), uVar3 != 0xffffffff)) {
		local_c = uVar3;
		MapShared_GetDimensions(uVar3,(int *)&filename,(int *)&local_10);
		if ((filename == (char *)(level->dimensions).width) && (local_10 == (level->dimensions).height))
		{
			by = 0;
			pcVar4 = filename;
			uVar5 = local_10;
			if (local_10 != 0) {
				do {
					bx = NULL;
					if (pcVar4 != NULL) {
						do {
							blockPos.x = (int)bx;
							blockPos.y = by;
							uVar3 = MapShared_GetBlock(local_c,(int)bx,by);
							bVar1 = false;
							if ((uVar3 == 0) || ((uVar3 & 1) != 0)) {
								uVar3 += 1;
							}
							else {
								bVar1 = true;
							}
							level->blocks[(int)(bx + by * (level->dimensions).width)].erodeSpeed =
									 (ErodeType)(uVar3 >> 1);
							if (bVar1) {
								sVar2 = math::Maths_Rand();
								uVar3 = (int)sVar2 >> 0x1f;
								Erode_AddActiveBlock(&blockPos,(((int)sVar2 ^ uVar3) - uVar3 & 3 ^ uVar3) - uVar3);
							}
							bx = bx + 1;
							pcVar4 = filename;
							uVar5 = local_10;
						} while (bx < filename);
					}
					by += 1;
					uVar3 = local_c;
				} while (by < uVar5);
			}
			lego::file::Mem_FreeHandle(uVar3);
			return 1;
		}
		lego::file::Mem_FreeHandle(uVar3);
	}
	return 0;
}



BOOL __cdecl lego::game::Level_LoadAIMap(LevelData *level,char *filename)
{
	uint sharedIndex;
	uint uVar1;
	char *pcVar2;
	char *bx;
	uint by;
	uint local_4;
	
	if ((filename != NULL) &&
		 (sharedIndex = lego::file::File_LoadBinaryHandle(filename,NULL), sharedIndex != 0xffffffff)) {
		MapShared_GetDimensions(sharedIndex,(int *)&filename,(int *)&local_4);
		if ((filename == (char *)(level->dimensions).width) && (local_4 == (level->dimensions).height))
		{
			by = 0;
			pcVar2 = filename;
			uVar1 = local_4;
			if (local_4 != 0) {
				do {
					bx = NULL;
					if (pcVar2 != NULL) {
						do {
							uVar1 = MapShared_GetBlock(sharedIndex,(int)bx,by);
							pcVar2 = bx + by * (level->dimensions).width;
							bx = bx + 1;
							level->blocks[(int)pcVar2].aiNode = (byte)uVar1;
							pcVar2 = filename;
							uVar1 = local_4;
						} while (bx < filename);
					}
					by += 1;
				} while (by < uVar1);
			}
			lego::file::Mem_FreeHandle(sharedIndex);
			return 1;
		}
		lego::file::Mem_FreeHandle(sharedIndex);
	}
	return 0;
}



BOOL __cdecl lego::game::Level_LoadEmergeMap(LevelData *level,char *filename)
{
	LevelBlockFlags2 *pLVar1;
	uint uVar2;
	uint uVar3;
	void *pvVar4;
	int iVar5;
	char *pcVar6;
	uint uVar7;
	uint uVar8;
	undefined4 *puVar9;
	uint local_c;
	char *local_8;
	uint local_4;
	
	if (filename != NULL) {
		uVar2 = lego::file::File_LoadBinaryHandle(filename,NULL);
		local_4 = uVar2;
		if (((uVar2 != 0xffffffff) &&
				(MapShared_GetDimensions(uVar2,(int *)&local_c,(int *)&local_8),
				local_c == (level->dimensions).width)) && (local_8 == (char *)(level->dimensions).height)) {
			filename = NULL;
			uVar3 = local_c;
			pcVar6 = local_8;
			if (local_8 != NULL) {
				do {
					uVar2 = 0;
					if (uVar3 != 0) {
						do {
							uVar3 = MapShared_GetBlock(local_4,uVar2,(int)filename);
							if (uVar3 != 0) {
								uVar7 = (uVar3 - 1) % 6;
								uVar8 = (uVar3 - 1) / 6;
								uVar3 = uVar8 + 1;
								if (level->count_c < uVar3) {
									if (level->ptrtable_8 == NULL) {
										pvVar4 = std::malloc(uVar3 * 0x4c);
									}
									else {
										pvVar4 = std::realloc(level->ptrtable_8,uVar3 * 0x4c);
									}
									level->ptrtable_8 = pvVar4;
									puVar9 = (undefined4 *)((int)level->ptrtable_8 + level->count_c * 0x4c);
									for (uVar3 = ((uVar8 - level->count_c) + 1) * 0x13 & 0x3fffffff; uVar3 != 0;
											uVar3 -= 1) {
										*puVar9 = 0;
										puVar9 = puVar9 + 1;
									}
									for (iVar5 = 0; iVar5 != 0; iVar5 += -1) {
										*(undefined *)puVar9 = 0;
										puVar9 = (undefined4 *)((int)puVar9 + 1);
									}
									level->count_c = uVar8 + 1;
								}
								if (uVar7 == 0) {
									iVar5 = (int)filename * (level->dimensions).width + uVar2;
									level->blocks[iVar5].flags2 = level->blocks[iVar5].flags2 | BLOCK2_EMERGE_TRIGGER;
									*(uint *)(uVar8 * 0x4c + 4 + (int)level->ptrtable_8) = uVar2;
									*(char **)(uVar8 * 0x4c + 8 + (int)level->ptrtable_8) = filename;
								}
								else {
									pLVar1 = &level->blocks[(int)filename * (level->dimensions).width + uVar2].flags2;
									*pLVar1 = *pLVar1 | BLOCK2_EMERGE_POINT;
									iVar5 = uVar8 * 0x4c;
									*(uint *)(iVar5 + uVar7 * 0xc + 4 + (int)level->ptrtable_8) = uVar2;
									*(char **)(uVar7 * 0xc + iVar5 + 8 + (int)level->ptrtable_8) = filename;
									*(undefined4 *)(iVar5 + (uVar7 + 1) * 0xc + (int)level->ptrtable_8) = 1;
								}
							}
							uVar2 += 1;
							uVar3 = local_c;
							pcVar6 = local_8;
						} while (uVar2 < local_c);
					}
					filename = filename + 1;
					uVar2 = local_4;
				} while (filename < pcVar6);
			}
			lego::file::Mem_FreeHandle(uVar2);
			return 1;
		}
		lego::file::Mem_FreeHandle(uVar2);
	}
	return 0;
}



BOOL __cdecl
lego::game::Level_UnkEmerge_FUN_0042c260
					(LevelData *level,Point2I *in_position,undefined4 *out_unkPosition)
{
	int iVar1;
	LiveObject *pLVar2;
	int iVar3;
	int iVar4;
	uint uVar5;
	uint local_4;
	
	iVar4 = 0;
	local_4 = 0;
	if (level->count_c == 0) {
		return 0;
	}
	do {
		iVar1 = (int)level->ptrtable_8 + iVar4;
		if (((in_position->x == *(int *)(iVar1 + 4)) && (in_position->y == *(int *)(iVar1 + 8))) &&
			 ((ushort)((ushort)(*(float *)(iVar1 + 0xc) < 0.0) << 8 |
								(ushort)(*(float *)(iVar1 + 0xc) == 0.0) << 0xe) != 0)) {
			iVar1 = 0;
			uVar5 = 0;
			do {
				if (*(int *)(iVar4 + uVar5 + 0x18 + (int)level->ptrtable_8) != 0) {
					iVar3 = iVar4 + uVar5 + (int)level->ptrtable_8;
					pLVar2 = Game_TryGeneratedRockMonsterLiveObject
														 ((int **)(globs::gameGlobs.RockMonsterData_TABLE +
																			level->EmergeCreature),OBJECT_ROCKMONSTER,
															level->EmergeCreature,*(uint *)(iVar3 + 0x10),*(uint *)(iVar3 + 0x14))
					;
					if (pLVar2 != NULL) {
						iVar4 = local_4 * 0x4c;
						*(float *)(iVar4 + 0xc + (int)level->ptrtable_8) = level->EmergeTimeOut;
						if (out_unkPosition != NULL) {
							*out_unkPosition =
									 *(undefined4 *)(iVar1 * 0xc + iVar4 + 0x10 + (int)level->ptrtable_8);
							out_unkPosition[1] =
									 *(undefined4 *)(iVar1 * 0xc + iVar4 + 0x14 + (int)level->ptrtable_8);
						}
						return 1;
					}
				}
				uVar5 += 0xc;
				iVar1 += 1;
			} while (uVar5 < 0x3c);
		}
		local_4 += 1;
		iVar4 += 0x4c;
	} while (local_4 < level->count_c);
	return 0;
}



void __cdecl lego::game::Level_FUN_0042c370(LevelData *level,float elapsedAbs)
{
	float *pfVar1;
	float fVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 0;
	if (level->count_c != 0) {
		iVar3 = 0;
		do {
			fVar2 = *(float *)((int)level->ptrtable_8 + iVar3 + 0xc);
			pfVar1 = (float *)((int)level->ptrtable_8 + iVar3 + 0xc);
			if ((ushort)((ushort)(fVar2 < 0.0) << 8 | (ushort)(fVar2 == 0.0) << 0xe) == 0) {
				*pfVar1 = *pfVar1 - elapsedAbs;
			}
			uVar4 += 1;
			iVar3 += 0x4c;
		} while (uVar4 < level->count_c);
	}
	return;
}



BOOL __cdecl lego::game::Level_LoadTerrainMap(LevelData *level,char *filename,int modifier)
{
	TerrainType TVar1;
	uint sharedIndex;
	uint uVar2;
	int iVar3;
	char *pcVar4;
	uint by;
	char *bx;
	uint local_c;
	Point2I local_8;
	
	sharedIndex = lego::file::File_LoadBinaryHandle(filename,NULL);
	if (sharedIndex != 0xffffffff) {
		MapShared_GetDimensions(sharedIndex,(int *)&filename,(int *)&local_c);
		if ((filename == (char *)(level->dimensions).width) && (local_c == (level->dimensions).height))
		{
			by = 0;
			pcVar4 = filename;
			uVar2 = local_c;
			if (local_c != 0) {
				do {
					bx = NULL;
					if (pcVar4 != NULL) {
						do {
							uVar2 = MapShared_GetBlock(sharedIndex,(int)bx,by);
							iVar3 = uVar2 - modifier;
										// Soil SurfaceType was removed, change to Dirt
							if (iVar3 == 5) {
								iVar3 = 4;
							}
							level->blocks[(int)(bx + by * (level->dimensions).width)].terrain = (TerrainType)iVar3
							;
							TVar1 = level->blocks[(int)(bx + by * (level->dimensions).width)].terrain;
							if (TVar1 == TERRAIN_LAVA) {
								level->blocks[(int)(bx + by * (level->dimensions).width)].field_7 = 4;
							}
							else {
								if (TVar1 == TERRAIN_RECHARGESEAM) {
									local_8.x = (int)bx;
									local_8.y = by;
									Level_RegisterRechargeSeam(&local_8);
									res::Level_LevelStruct1C_Create_Res_Unk_RechargeSparkle(level,&local_8,1);
								}
							}
							bx = bx + 1;
							pcVar4 = filename;
							uVar2 = local_c;
						} while (bx < filename);
					}
					by += 1;
				} while (by < uVar2);
			}
			lego::file::Mem_FreeHandle(sharedIndex);
			return 1;
		}
		lego::file::Mem_FreeHandle(sharedIndex);
	}
	return 0;
}



BOOL __cdecl
lego::game::Level_GetBlockCryOre
					(Point2I *position,int *out_crystal,int *out_ore,int *out_crystalAlt,int *out_oreAlt)
{
	int iVar1;
	uint uVar2;
	uint uVar3;
	int CRYORE_COUNTS [5];
	
	uVar3 = (uint)(globs::gameGlobs.level)->blocks
								[position->y * ((globs::gameGlobs.level)->dimensions).width + position->x].cryOre;
	CRYORE_COUNTS[0] = 1;
	uVar2 = uVar3 - 1;
	*out_oreAlt = 0;
	*out_crystalAlt = 0;
	*out_ore = 0;
	CRYORE_COUNTS[1] = 3;
	CRYORE_COUNTS[2] = 5;
	CRYORE_COUNTS[3] = 10;
	CRYORE_COUNTS[4] = 0x19;
	*out_crystal = 0;
	if (uVar3 != 0) {
		iVar1 = *(int *)((int)CRYORE_COUNTS + (uVar2 & 0xfffffffc));
		switch(uVar2 & 3) {
		case 0:
			*out_crystal = iVar1;
			return 1;
		case 1:
			*out_crystalAlt = iVar1;
			return 1;
		case 2:
			*out_ore = iVar1;
			return 1;
		case 3:
			*out_oreAlt = iVar1;
		}
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::game::Level_LoadCryOreMap(LevelData *level,char *filename,char modifier)
{
	uint sharedIndex;
	uint uVar1;
	char *pcVar2;
	char *bx;
	uint by;
	uint local_4;
	
	sharedIndex = lego::file::File_LoadBinaryHandle(filename,NULL);
	if (sharedIndex != 0xffffffff) {
		MapShared_GetDimensions(sharedIndex,(int *)&filename,(int *)&local_4);
		if ((filename == (char *)(level->dimensions).width) && (local_4 == (level->dimensions).height))
		{
			by = 0;
			pcVar2 = filename;
			uVar1 = local_4;
			if (local_4 != 0) {
				do {
					bx = NULL;
					if (pcVar2 != NULL) {
						do {
							uVar1 = MapShared_GetBlock(sharedIndex,(int)bx,by);
							pcVar2 = bx + by * (level->dimensions).width;
							bx = bx + 1;
							level->blocks[(int)pcVar2].cryOre = (char)uVar1 - modifier;
							pcVar2 = filename;
							uVar1 = local_4;
						} while (bx < filename);
					}
					by += 1;
				} while (by < uVar1);
			}
			lego::file::Mem_FreeHandle(sharedIndex);
			return 1;
		}
		lego::file::Mem_FreeHandle(sharedIndex);
	}
	return 0;
}



BOOL __cdecl lego::game::Level_LoadPathMap(LevelData *level,char *filename,int modifier)
{
	LevelBlockFlags1 *pLVar1;
	LevelBlockFlags1 LVar2;
	uint uVar3;
	BOOL BVar4;
	char *pcVar5;
	uint uVar6;
	uint by;
	int iVar7;
	char *bx;
	uint local_10;
	uint local_c;
	Point2I local_8;
	
	if ((filename != NULL) &&
		 (uVar3 = lego::file::File_LoadBinaryHandle(filename,NULL), uVar3 != 0xffffffff)) {
		local_c = uVar3;
		MapShared_GetDimensions(uVar3,(int *)&filename,(int *)&local_10);
		if ((filename == (char *)(level->dimensions).width) && (local_10 == (level->dimensions).height))
		{
			by = 0;
			pcVar5 = filename;
			uVar6 = local_10;
			if (local_10 != 0) {
				do {
					bx = NULL;
					if (pcVar5 != NULL) {
						do {
							local_8.x = (int)bx;
							local_8.y = by;
							uVar3 = MapShared_GetBlock(local_c,(int)bx,by);
							pLVar1 = &level->blocks[(int)(bx + by * (level->dimensions).width)].flags1;
							LVar2 = *pLVar1;
							if ((LVar2 & BLOCK1_UNK_8) != BLOCK1_NONE) {
								if (uVar3 - modifier == 2) {
									*pLVar1 = LVar2 | BLOCK1_POWERPATH;
								}
								else {
									if ((((uVar3 - modifier == 1) &&
											 (((globs::gameGlobs.level)->blocks
												 [(int)(local_8.x + ((globs::gameGlobs.level)->dimensions).width * local_8.y
															 )].flags1 & BLOCK1_UNK_400) == BLOCK1_NONE)) &&
											((*(byte *)&(globs::gameGlobs.level)->blocks
																	[(int)(local_8.x +
																				((globs::gameGlobs.level)->dimensions).width * local_8.y)].
																	flags2 & 4) == 0)) &&
										 ((((globs::gameGlobs.level)->blocks
												[(int)(local_8.x + ((globs::gameGlobs.level)->dimensions).width * local_8.y)
												].flags1 & BLOCK1_UNK_8000) == BLOCK1_NONE &&
											(BVar4 = Construction_Block_FUN_00408fd0(&local_8), BVar4 == 0)))) {
										(globs::gameGlobs.level)->blocks
										[(int)(char *)(local_8.x +
																	((globs::gameGlobs.level)->dimensions).width * local_8.y)].flags1
												 = (globs::gameGlobs.level)->blocks
													 [(int)(char *)(local_8.x +
																				 ((globs::gameGlobs.level)->dimensions).width * local_8.y)].
													 flags1 & ~BLOCK1_UNK_200000;
										(globs::gameGlobs.level)->blocks
										[(int)(char *)(local_8.x +
																	((globs::gameGlobs.level)->dimensions).width * local_8.y)].flags1
												 = (globs::gameGlobs.level)->blocks
													 [(int)(char *)(local_8.x +
																				 ((globs::gameGlobs.level)->dimensions).width * local_8.y)].
													 flags1 & ~BLOCK1_POWERPATH;
										(globs::gameGlobs.level)->blocks
										[(int)(char *)(local_8.x +
																	((globs::gameGlobs.level)->dimensions).width * local_8.y)].flags1
												 = (globs::gameGlobs.level)->blocks
													 [(int)(char *)(local_8.x +
																				 ((globs::gameGlobs.level)->dimensions).width * local_8.y)].
													 flags1 & ~BLOCK1_UNK_40000000;
										LiveManager_InitFlagsToggle_AndClearNumDrained();
										ai::AITask_DoCallbacks_IfAttackPath_FUN_00402970(&local_8);
										util::logf_removed((char *)&local_8);
										iVar7 = 4;
										do {
											ai::AITask_DoClear_AtPosition(&local_8,MESSAGE_CLEARINITIAL_COMPLETE);
											iVar7 += -1;
										} while (iVar7 != 0);
										(globs::gameGlobs.level)->blocks
										[(int)(char *)(local_8.x +
																	((globs::gameGlobs.level)->dimensions).width * local_8.y)].flags1
												 = (globs::gameGlobs.level)->blocks
													 [(int)(char *)(local_8.x +
																				 ((globs::gameGlobs.level)->dimensions).width * local_8.y)].
													 flags1 | BLOCK1_RUBBLE_FULL;
									}
								}
							}
							bx = bx + 1;
							pcVar5 = filename;
							uVar6 = local_10;
						} while (bx < filename);
					}
					by += 1;
					uVar3 = local_c;
				} while (by < uVar6);
			}
			lego::file::Mem_FreeHandle(uVar3);
			return 1;
		}
		lego::file::Mem_FreeHandle(uVar3);
	}
	return 0;
}



BOOL __cdecl lego::game::Level_LoadFallinMap(LevelData *level,char *filename)
{
	uint uVar1;
	char *pcVar2;
	uint uVar3;
	uint by;
	char *bx;
	uint local_10;
	uint sharedIndex;
	uint local_8;
	undefined4 uStack4;
	
	globs::gameGlobs.hasFallins = 0;
	if ((filename != NULL) &&
		 (uVar1 = lego::file::File_LoadBinaryHandle(filename,NULL), uVar1 != 0xffffffff)) {
		sharedIndex = uVar1;
		MapShared_GetDimensions(uVar1,(int *)&filename,(int *)&local_10);
		if ((filename == (char *)(level->dimensions).width) && (local_10 == (level->dimensions).height))
		{
			by = 0;
			pcVar2 = filename;
			uVar3 = local_10;
			if (local_10 != 0) {
				do {
					bx = NULL;
					if (pcVar2 != NULL) {
						do {
							uVar1 = MapShared_GetBlock(sharedIndex,(int)bx,by);
							level->blocks[(int)(bx + by * (level->dimensions).width)].fallinIntensity = 0;
							if (uVar1 != 0) {
								level->blocks[(int)(bx + by * (level->dimensions).width)].fallinIntensity = uVar1;
										// * 25 (0x19)
								local_8 = (uint)(int)level->blocks[(int)(bx + by * (level->dimensions).width)].
																		 randomness % (uVar1 * globs::gameGlobs.FallinMultiplier * 0x19)
								;
								uStack4 = 0;
								level->blocks[(int)(bx + by * (level->dimensions).width)].fallinTimer =
										 (float)(ulonglong)local_8;
								level->blocks[(int)(bx + by * (level->dimensions).width)].fallinUpper = 0;
								if (4 < uVar1) {
									level->blocks[(int)(bx + by * (level->dimensions).width)].fallinIntensity =
											 uVar1 - 4;
									level->blocks[(int)(bx + by * (level->dimensions).width)].fallinUpper = TRUE;
								}
							}
							bx = bx + 1;
							pcVar2 = filename;
							uVar3 = local_10;
						} while (bx < filename);
					}
					by += 1;
					uVar1 = sharedIndex;
				} while (by < uVar3);
			}
			globs::gameGlobs.hasFallins = TRUE;
			lego::file::Mem_FreeHandle(uVar1);
			return TRUE;
		}
		lego::file::Mem_FreeHandle(uVar1);
	}
	return 0;
}



void __cdecl lego::game::Game_UpdateFallins(float elapsedGame)
{
	uint uVar1;
	uint uVar2;
	LevelData *level;
	int iVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	Point2I position;
	LevelBlock *block;
	
	level = GetLevel();
	if ((((globs::gameGlobs.hasFallins != 0) && (uVar1 = (level->dimensions).width, uVar1 != 0)) &&
			(uVar2 = (level->dimensions).height, uVar2 != 0)) && (uVar5 = 0, uVar2 != 0)) {
		do {
			uVar6 = 0;
			if (uVar1 != 0) {
				do {
					block = level->blocks + uVar5 * (level->dimensions).width + uVar6;
					if (block->fallinIntensity != 0) {
						block->fallinTimer = elapsedGame + block->fallinTimer;
						iVar3 = uVar5 * (level->dimensions).width + uVar6;
						block = level->blocks + iVar3;
						if ((float)(ulonglong)
											 (level->blocks[iVar3].fallinIntensity * globs::gameGlobs.FallinMultiplier *
											 0x19) < block->fallinTimer) {
							block->fallinTimer = 0.0;
							position.x = uVar6;
							position.y = uVar5;
							BVar4 = Fallin_Block_FUN_0040f0c0
																(&position,
																 level->blocks[uVar5 * (level->dimensions).width + uVar6].
																 fallinUpper);
							if (BVar4 != 0) {
								front::Info_FUN_00419ab0(INFO_LANDSLIDE,NULL,NULL,&position);
							}
						}
					}
					uVar6 += 1;
				} while (uVar6 < uVar1);
			}
			uVar5 += 1;
		} while (uVar5 < uVar2);
	}
	return;
}



BOOL __cdecl lego::game::Level_LoadBlockPointersMap(LevelData *level,char *filename,int modifier)
{
	uint sharedIndex;
	uint uVar1;
	char *pcVar2;
	char *bx;
	uint by;
	uint local_4;
	
	if ((filename != NULL) &&
		 (sharedIndex = lego::file::File_LoadBinaryHandle(filename,NULL), sharedIndex != 0xffffffff)) {
		MapShared_GetDimensions(sharedIndex,(int *)&filename,(int *)&local_4);
		if ((filename == (char *)(level->dimensions).width) && (local_4 == (level->dimensions).height))
		{
			by = 0;
			pcVar2 = filename;
			uVar1 = local_4;
			if (local_4 != 0) {
				do {
					bx = NULL;
					if (pcVar2 != NULL) {
						do {
							uVar1 = MapShared_GetBlock(sharedIndex,(int)bx,by);
							pcVar2 = bx + by * (level->dimensions).width;
							bx = bx + 1;
							level->blocks[(int)pcVar2].blockpointer = (char)uVar1 - (char)modifier;
							pcVar2 = filename;
							uVar1 = local_4;
						} while (bx < filename);
					}
					by += 1;
				} while (by < uVar1);
			}
			lego::file::Mem_FreeHandle(sharedIndex);
			return 1;
		}
		lego::file::Mem_FreeHandle(sharedIndex);
	}
	return 0;
}



UpgradeData * __cdecl lego::game::Game_GetUpgradeData(char *upgradeName)
{
	int iVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (globs::gameGlobs.UpgradeTypes_COUNT == 0) {
		return NULL;
	}
	do {
		iVar1 = std::_stricmp(upgradeName,globs::gameGlobs.UpgradeTypes_TABLE[uVar2]);
		if (iVar1 == 0) {
			return globs::gameGlobs.UpgradeData_TABLE + uVar2;
		}
		uVar2 += 1;
	} while (uVar2 < globs::gameGlobs.UpgradeTypes_COUNT);
	return NULL;
}



BOOL __cdecl lego::main::Boot_Load_VehicleTypes(void)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	undefined4 *puVar8;
	undefined4 *puVar9;
	int local_4;
	
	iVar7 = 0;
	globs::gameGlobs.VehicleTypes_COUNT = 0;
	local_4 = 0;
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"VehicleTypes",0);
	for (pCVar3 = cfg::CFG_GetChildren(globs::gameGlobs.LegoCfgRoot,pcVar2); pCVar3 != NULL;
			pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		globs::gameGlobs.VehicleTypes_COUNT += 1;
	}
	if ((globs::gameGlobs.VehicleTypes_COUNT != 0) &&
		 (globs::gameGlobs.VehicleData_TABLE =
					 (VehicleData *)std::malloc(globs::gameGlobs.VehicleTypes_COUNT * 0x1ec),
		 globs::gameGlobs.VehicleData_TABLE != NULL)) {
		globs::gameGlobs.VehicleTypes_TABLE =
				 (char **)std::malloc(globs::gameGlobs.VehicleTypes_COUNT * 4);
		if (globs::gameGlobs.VehicleTypes_TABLE != NULL) {
			pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"VehicleTypes",0);
			pCVar3 = cfg::CFG_GetChildren(globs::gameGlobs.LegoCfgRoot,pcVar2);
			while ((pCVar3 != NULL &&
						 (BVar4 = res::Vehicle_LoadActivityFile
																((VehicleData *)
																 ((int)(globs::gameGlobs.VehicleData_TABLE)->WheelMeshes +
																 iVar7 + -0x10),local_4,globs::gameGlobs.resRoot,pCVar3->value,
																 globs::gameGlobs.CfgRootName), BVar4 != 0))) {
				res::Vehicle_HideAll
									((VehicleData *)
									 ((int)(globs::gameGlobs.VehicleData_TABLE)->WheelMeshes + iVar7 + -0x10),TRUE);
				uVar5 = 0xffffffff;
				pcVar2 = pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *pcVar2;
					pcVar2 = pcVar2 + 1;
				} while (cVar1 != '\0');
				pcVar2 = (char *)std::malloc(~uVar5);
				iVar7 += 0x1ec;
				globs::gameGlobs.VehicleTypes_TABLE[local_4] = pcVar2;
				uVar5 = 0xffffffff;
				puVar8 = (undefined4 *)pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *(char *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				} while (cVar1 != '\0');
				puVar8 = (undefined4 *)pCVar3->key;
				puVar9 = (undefined4 *)globs::gameGlobs.VehicleTypes_TABLE[local_4];
				for (uVar6 = ~uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
					*puVar9 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar9 = puVar9 + 1;
				}
				local_4 += 1;
				for (uVar5 = ~uVar5 & 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar9 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				pCVar3 = cfg::CFG_NextFlat(pCVar3);
			}
			if (pCVar3 == NULL) {
				return TRUE;
			}
			std::free(globs::gameGlobs.VehicleTypes_TABLE);
		}
		std::free(globs::gameGlobs.VehicleData_TABLE);
	}
	return 0;
}



BOOL __cdecl lego::main::Boot_Load_MiniFigureTypes(void)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	undefined4 *puVar8;
	undefined4 *puVar9;
	int local_4;
	
	iVar7 = 0;
	globs::gameGlobs.MiniFigureTypes_COUNT = 0;
	local_4 = 0;
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiniFigureTypes",0);
	for (pCVar3 = cfg::CFG_GetChildren(globs::gameGlobs.LegoCfgRoot,pcVar2); pCVar3 != NULL;
			pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		globs::gameGlobs.MiniFigureTypes_COUNT += 1;
	}
	if ((globs::gameGlobs.MiniFigureTypes_COUNT != 0) &&
		 (globs::gameGlobs.MiniFigureData_TABLE =
					 (CreatureData *)std::malloc(globs::gameGlobs.MiniFigureTypes_COUNT * 0x74),
		 globs::gameGlobs.MiniFigureData_TABLE != NULL)) {
		globs::gameGlobs.MiniFigureTypes_TABLE =
				 (char **)std::malloc(globs::gameGlobs.MiniFigureTypes_COUNT * 4);
		if (globs::gameGlobs.MiniFigureTypes_TABLE != NULL) {
			pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"MiniFigureTypes",0);
			pCVar3 = cfg::CFG_GetChildren(globs::gameGlobs.LegoCfgRoot,pcVar2);
			while ((pCVar3 != NULL &&
						 (BVar4 = res::Creature_LoadActivityFile
																((CreatureData *)
																 ((int)(globs::gameGlobs.MiniFigureData_TABLE)->cameraFramesTable_54
																 + iVar7 + -0x54),local_4,globs::gameGlobs.resRoot,pCVar3->value,
																 globs::gameGlobs.CfgRootName), BVar4 != 0))) {
				res::Object_HideAll((BasicObjectData *)
														((int)(globs::gameGlobs.MiniFigureData_TABLE)->cameraFramesTable_54 +
														iVar7 + -0x54),TRUE);
				uVar5 = 0xffffffff;
				pcVar2 = pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *pcVar2;
					pcVar2 = pcVar2 + 1;
				} while (cVar1 != '\0');
				pcVar2 = (char *)std::malloc(~uVar5);
				iVar7 += 0x74;
				globs::gameGlobs.MiniFigureTypes_TABLE[local_4] = pcVar2;
				uVar5 = 0xffffffff;
				puVar8 = (undefined4 *)pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *(char *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				} while (cVar1 != '\0');
				puVar8 = (undefined4 *)pCVar3->key;
				puVar9 = (undefined4 *)globs::gameGlobs.MiniFigureTypes_TABLE[local_4];
				for (uVar6 = ~uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
					*puVar9 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar9 = puVar9 + 1;
				}
				local_4 += 1;
				for (uVar5 = ~uVar5 & 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar9 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				pCVar3 = cfg::CFG_NextFlat(pCVar3);
			}
			if (pCVar3 == NULL) {
				return TRUE;
			}
			std::free(globs::gameGlobs.MiniFigureTypes_TABLE);
		}
		std::free(globs::gameGlobs.MiniFigureData_TABLE);
	}
	return 0;
}



BOOL __cdecl lego::main::Boot_Load_RockMonsterTypes(void)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	undefined4 *puVar8;
	undefined4 *puVar9;
	int local_4;
	
	iVar7 = 0;
	globs::gameGlobs.RockMonsterTypes_COUNT = 0;
	local_4 = 0;
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"RockMonsterTypes",0);
	for (pCVar3 = cfg::CFG_GetChildren(globs::gameGlobs.LegoCfgRoot,pcVar2); pCVar3 != NULL;
			pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		globs::gameGlobs.RockMonsterTypes_COUNT += 1;
	}
	if ((globs::gameGlobs.RockMonsterTypes_COUNT != 0) &&
		 (globs::gameGlobs.RockMonsterData_TABLE =
					 (CreatureData *)std::malloc(globs::gameGlobs.RockMonsterTypes_COUNT * 0x74),
		 globs::gameGlobs.RockMonsterData_TABLE != NULL)) {
		globs::gameGlobs.RockMonsterTypes_TABLE =
				 (char **)std::malloc(globs::gameGlobs.RockMonsterTypes_COUNT * 4);
		if (globs::gameGlobs.RockMonsterTypes_TABLE != NULL) {
			pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"RockMonsterTypes",0);
			pCVar3 = cfg::CFG_GetChildren(globs::gameGlobs.LegoCfgRoot,pcVar2);
			while ((pCVar3 != NULL &&
						 (BVar4 = res::Creature_LoadActivityFile
																((CreatureData *)
																 ((int)(globs::gameGlobs.RockMonsterData_TABLE)->
																			 cameraFramesTable_54 + iVar7 + -0x54),local_4,
																 globs::gameGlobs.resRoot,pCVar3->value,globs::gameGlobs.CfgRootName
																), BVar4 != 0))) {
				res::Object_HideAll((BasicObjectData *)
														((int)(globs::gameGlobs.RockMonsterData_TABLE)->cameraFramesTable_54 +
														iVar7 + -0x54),TRUE);
				uVar5 = 0xffffffff;
				pcVar2 = pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *pcVar2;
					pcVar2 = pcVar2 + 1;
				} while (cVar1 != '\0');
				pcVar2 = (char *)std::malloc(~uVar5);
				iVar7 += 0x74;
				globs::gameGlobs.RockMonsterTypes_TABLE[local_4] = pcVar2;
				uVar5 = 0xffffffff;
				puVar8 = (undefined4 *)pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *(char *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				} while (cVar1 != '\0');
				puVar8 = (undefined4 *)pCVar3->key;
				puVar9 = (undefined4 *)globs::gameGlobs.RockMonsterTypes_TABLE[local_4];
				for (uVar6 = ~uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
					*puVar9 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar9 = puVar9 + 1;
				}
				local_4 += 1;
				for (uVar5 = ~uVar5 & 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar9 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				pCVar3 = cfg::CFG_NextFlat(pCVar3);
			}
			if (pCVar3 == NULL) {
				return TRUE;
			}
			std::free(globs::gameGlobs.RockMonsterTypes_TABLE);
		}
		std::free(globs::gameGlobs.RockMonsterData_TABLE);
	}
	return 0;
}



BOOL __cdecl lego::main::Boot_Load_BuildingTypes(void)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	undefined4 *puVar8;
	undefined4 *puVar9;
	int local_4;
	
	iVar7 = 0;
	globs::gameGlobs.BuildingTypes_COUNT = 0;
	local_4 = 0;
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"BuildingTypes",0);
	for (pCVar3 = cfg::CFG_GetChildren(globs::gameGlobs.LegoCfgRoot,pcVar2); pCVar3 != NULL;
			pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		globs::gameGlobs.BuildingTypes_COUNT += 1;
	}
	if ((globs::gameGlobs.BuildingTypes_COUNT != 0) &&
		 (globs::gameGlobs.BuildingData_TABLE =
					 (BuildingData *)std::malloc(globs::gameGlobs.BuildingTypes_COUNT * 0x14c),
		 globs::gameGlobs.BuildingData_TABLE != NULL)) {
		globs::gameGlobs.BuildingTypes_TABLE =
				 (char **)std::malloc(globs::gameGlobs.BuildingTypes_COUNT * 4);
		if (globs::gameGlobs.BuildingTypes_TABLE != NULL) {
			pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"BuildingTypes",0);
			pCVar3 = cfg::CFG_GetChildren(globs::gameGlobs.LegoCfgRoot,pcVar2);
			while ((pCVar3 != NULL &&
						 (BVar4 = res::Building_LoadActivityFile
																((BuildingData *)
																 ((int)(globs::gameGlobs.BuildingData_TABLE)->carryFramesTable_28 +
																 iVar7 + -0x28),local_4,globs::gameGlobs.resRoot,pCVar3->value,
																 globs::gameGlobs.CfgRootName), BVar4 != 0))) {
				res::Building_HideAll
									((BuildingData *)
									 ((int)(globs::gameGlobs.BuildingData_TABLE)->carryFramesTable_28 + iVar7 + -0x28)
									 ,TRUE);
				uVar5 = 0xffffffff;
				pcVar2 = pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *pcVar2;
					pcVar2 = pcVar2 + 1;
				} while (cVar1 != '\0');
				pcVar2 = (char *)std::malloc(~uVar5);
				iVar7 += 0x14c;
				globs::gameGlobs.BuildingTypes_TABLE[local_4] = pcVar2;
				uVar5 = 0xffffffff;
				puVar8 = (undefined4 *)pCVar3->key;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *(char *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				} while (cVar1 != '\0');
				puVar8 = (undefined4 *)pCVar3->key;
				puVar9 = (undefined4 *)globs::gameGlobs.BuildingTypes_TABLE[local_4];
				for (uVar6 = ~uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
					*puVar9 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar9 = puVar9 + 1;
				}
				local_4 += 1;
				for (uVar5 = ~uVar5 & 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar9 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				pCVar3 = cfg::CFG_NextFlat(pCVar3);
			}
			if (pCVar3 == NULL) {
				return TRUE;
			}
			std::free(globs::gameGlobs.BuildingTypes_TABLE);
		}
		std::free(globs::gameGlobs.BuildingData_TABLE);
	}
	return 0;
}



BOOL __cdecl lego::main::Boot_Load_UpgradeTypes(void)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	undefined4 *puVar7;
	undefined4 *puVar8;
	int local_4;
	
	iVar6 = 0;
	globs::gameGlobs.UpgradeTypes_COUNT = 0;
	local_4 = 0;
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"UpgradeTypes",0);
	for (pCVar3 = cfg::CFG_GetChildren(globs::gameGlobs.LegoCfgRoot,pcVar2); pCVar3 != NULL;
			pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		globs::gameGlobs.UpgradeTypes_COUNT += 1;
	}
	if ((globs::gameGlobs.UpgradeTypes_COUNT != 0) &&
		 (globs::gameGlobs.UpgradeData_TABLE =
					 (UpgradeData *)std::malloc(globs::gameGlobs.UpgradeTypes_COUNT << 4),
		 globs::gameGlobs.UpgradeData_TABLE != NULL)) {
		globs::gameGlobs.UpgradeTypes_TABLE =
				 (char **)std::malloc(globs::gameGlobs.UpgradeTypes_COUNT * 4);
		if (globs::gameGlobs.UpgradeTypes_TABLE != NULL) {
			pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"UpgradeTypes",0);
			for (pCVar3 = cfg::CFG_GetChildren(globs::gameGlobs.LegoCfgRoot,pcVar2); pCVar3 != NULL;
					pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
				res::Upgrade_InitUnk_FUN_0046c2f0
									((UpgradeData *)((int)&(globs::gameGlobs.UpgradeData_TABLE)->objectIndex + iVar6),
									 local_4,globs::gameGlobs.resRoot,pCVar3->value);
				res::Object_HideAll((BasicObjectData *)
														((int)&(globs::gameGlobs.UpgradeData_TABLE)->objectIndex + iVar6),TRUE);
				uVar4 = 0xffffffff;
				pcVar2 = pCVar3->key;
				do {
					if (uVar4 == 0) break;
					uVar4 -= 1;
					cVar1 = *pcVar2;
					pcVar2 = pcVar2 + 1;
				} while (cVar1 != '\0');
				pcVar2 = (char *)std::malloc(~uVar4);
				iVar6 += 0x10;
				globs::gameGlobs.UpgradeTypes_TABLE[local_4] = pcVar2;
				uVar4 = 0xffffffff;
				puVar7 = (undefined4 *)pCVar3->key;
				do {
					if (uVar4 == 0) break;
					uVar4 -= 1;
					cVar1 = *(char *)puVar7;
					puVar7 = (undefined4 *)((int)puVar7 + 1);
				} while (cVar1 != '\0');
				puVar7 = (undefined4 *)pCVar3->key;
				puVar8 = (undefined4 *)globs::gameGlobs.UpgradeTypes_TABLE[local_4];
				for (uVar5 = ~uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
					*puVar8 = *puVar7;
					puVar7 = puVar7 + 1;
					puVar8 = puVar8 + 1;
				}
				local_4 += 1;
				for (uVar4 = ~uVar4 & 3; uVar4 != 0; uVar4 -= 1) {
					*(undefined *)puVar8 = *(undefined *)puVar7;
					puVar7 = (undefined4 *)((int)puVar7 + 1);
					puVar8 = (undefined4 *)((int)puVar8 + 1);
				}
			}
			if (true) {
				return TRUE;
			}
			std::free(globs::gameGlobs.UpgradeTypes_TABLE);
		}
		std::free(globs::gameGlobs.UpgradeData_TABLE);
	}
	return 0;
}



void __cdecl lego::main::Main_Load_ObjectNames(CFGProperty *root)
{
	char *pcVar1;
	uint uVar2;
	uint uVar3;
	
	globs::gameGlobs.ObjectNames_VehicleTypes_TABLE =
			 (char **)std::malloc(globs::gameGlobs.VehicleTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::gameGlobs.VehicleTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectNames",
																 globs::gameGlobs.VehicleTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::gameGlobs.ObjectNames_VehicleTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::gameGlobs.VehicleTypes_COUNT);
	}
	globs::gameGlobs.ObjectNames_MiniFigureTypes_TABLE =
			 (char **)std::malloc(globs::gameGlobs.MiniFigureTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::gameGlobs.MiniFigureTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectNames",
																 globs::gameGlobs.MiniFigureTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::gameGlobs.ObjectNames_MiniFigureTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::gameGlobs.MiniFigureTypes_COUNT);
	}
	globs::gameGlobs.ObjectNames_RockMonsterTypes_TABLE =
			 (char **)std::malloc(globs::gameGlobs.RockMonsterTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::gameGlobs.RockMonsterTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectNames",
																 globs::gameGlobs.RockMonsterTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::gameGlobs.ObjectNames_RockMonsterTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::gameGlobs.RockMonsterTypes_COUNT);
	}
	globs::gameGlobs.ObjectNames_BuildingTypes_TABLE =
			 (char **)std::malloc(globs::gameGlobs.BuildingTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::gameGlobs.BuildingTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectNames",
																 globs::gameGlobs.BuildingTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::gameGlobs.ObjectNames_BuildingTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::gameGlobs.BuildingTypes_COUNT);
	}
	globs::gameGlobs.ObjectNames_UpgradeTypes_TABLE =
			 (char **)std::malloc(globs::gameGlobs.UpgradeTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::gameGlobs.UpgradeTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectNames",
																 globs::gameGlobs.UpgradeTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != NULL) {
				pcVar1 = util::Util_RemoveUnderscores(pcVar1);
				globs::gameGlobs.ObjectNames_UpgradeTypes_TABLE[uVar2] = pcVar1;
			}
			uVar3 = uVar2 + 1;
			globs::gameGlobs.ObjectNames_UpgradeTypes_TABLE[uVar2] = NULL;
			uVar2 = uVar3;
		} while (uVar3 < globs::gameGlobs.UpgradeTypes_COUNT);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectNames","PowerCrystal",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectNames_PowerCrystal = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectNames","Ore",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectNames_Ore = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectNames","ProcessedOre",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectNames_ProcessedOre = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectNames","Dynamite",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectNames_Dynamite = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectNames","Barrier",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectNames_Barrier = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectNames","ElectricFence",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectNames_ElectricFence = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectNames","SpiderWeb",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectNames_SpiderWeb = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectNames","OohScary",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectNames_OohScary = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectNames","Path",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectNames_Path = util::Util_RemoveUnderscores(pcVar1);
	}
	return;
}



void __cdecl lego::main::Main_Load_ObjectTheNames(CFGProperty *root)
{
	char *pcVar1;
	uint uVar2;
	uint uVar3;
	
	globs::gameGlobs.ObjectTheNames_VehicleTypes_TABLE =
			 (char **)std::malloc(globs::gameGlobs.VehicleTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::gameGlobs.VehicleTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectTheNames",
																 globs::gameGlobs.VehicleTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::gameGlobs.ObjectTheNames_VehicleTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::gameGlobs.VehicleTypes_COUNT);
	}
	globs::gameGlobs.ObjectTheNames_MiniFigureTypes_TABLE =
			 (char **)std::malloc(globs::gameGlobs.MiniFigureTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::gameGlobs.MiniFigureTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectTheNames",
																 globs::gameGlobs.MiniFigureTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::gameGlobs.ObjectTheNames_MiniFigureTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::gameGlobs.MiniFigureTypes_COUNT);
	}
	globs::gameGlobs.ObjectTheNames_RockMonsterTypes_TABLE =
			 (char **)std::malloc(globs::gameGlobs.RockMonsterTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::gameGlobs.RockMonsterTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectTheNames",
																 globs::gameGlobs.RockMonsterTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::gameGlobs.ObjectTheNames_RockMonsterTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::gameGlobs.RockMonsterTypes_COUNT);
	}
	globs::gameGlobs.ObjectTheNames_BuildingTypes_TABLE =
			 (char **)std::malloc(globs::gameGlobs.BuildingTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::gameGlobs.BuildingTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectTheNames",
																 globs::gameGlobs.BuildingTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			pcVar1 = util::Util_RemoveUnderscores(pcVar1);
			globs::gameGlobs.ObjectTheNames_BuildingTypes_TABLE[uVar2] = pcVar1;
			uVar2 += 1;
		} while (uVar2 < globs::gameGlobs.BuildingTypes_COUNT);
	}
	globs::gameGlobs.ObjectTheNames_UpgradeTypes_TABLE =
			 (char **)std::malloc(globs::gameGlobs.UpgradeTypes_COUNT * 4);
	uVar2 = 0;
	if (globs::gameGlobs.UpgradeTypes_COUNT != 0) {
		do {
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectTheNames",
																 globs::gameGlobs.UpgradeTypes_TABLE[uVar2],0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 != NULL) {
				pcVar1 = util::Util_RemoveUnderscores(pcVar1);
				globs::gameGlobs.ObjectTheNames_UpgradeTypes_TABLE[uVar2] = pcVar1;
			}
			uVar3 = uVar2 + 1;
			globs::gameGlobs.ObjectTheNames_UpgradeTypes_TABLE[uVar2] = NULL;
			uVar2 = uVar3;
		} while (uVar3 < globs::gameGlobs.UpgradeTypes_COUNT);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectTheNames","PowerCrystal",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectTheNames_PowerCrystal = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectTheNames","Ore",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectTheNames_Ore = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectTheNames","ProcessedOre",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectTheNames_ProcessedOre = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectTheNames","Dynamite",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectTheNames_Dynamite = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectTheNames","Barrier",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectTheNames_Barrier = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectTheNames","ElectricFence",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectTheNames_ElectricFence = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectTheNames","SpiderWeb",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectTheNames_SpiderWeb = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectTheNames","OohScary",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectTheNames_OohScary = util::Util_RemoveUnderscores(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ObjectTheNames","Path",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.ObjectTheNames_Path = util::Util_RemoveUnderscores(pcVar1);
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_0042dd70(LiveObject *liveObj,uint *param_2,BOOL param_3)
{
	Point2F *pPVar1;
	LevelData *pLVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	SurfaceMap *pSVar6;
	Point2F *pPVar7;
	uint local_8;
	uint local_4;
	
	pLVar2 = globs::gameGlobs.level;
	globs::gameGlobs.bool_98 = param_3;
	if (liveObj == NULL) {
		if (param_3 == 0) {
			pSVar6 = (globs::gameGlobs.level)->surfaceMap;
			pPVar1 = &globs::gameGlobs.pointf_88;
			pPVar7 = &globs::gameGlobs.pointf_88;
			uVar4 = param_2[1];
			uVar5 = *param_2;
		}
		else {
			pPVar1 = &globs::gameGlobs.pointf_90;
			pPVar7 = &globs::gameGlobs.pointf_90;
			uVar4 = param_2[1];
			uVar5 = *param_2;
			pSVar6 = (globs::gameGlobs.level)->surfaceMap;
		}
		Map3D_BlockToWorldPos(pSVar6,uVar5,uVar4,(float *)pPVar7,&pPVar1->y);
		local_8 = *param_2;
		local_4 = param_2[1];
	}
	else {
		if (param_3 == 0) {
			pPVar1 = &globs::gameGlobs.pointf_88;
			pPVar7 = &globs::gameGlobs.pointf_88;
		}
		else {
			pPVar1 = &globs::gameGlobs.pointf_90;
			pPVar7 = &globs::gameGlobs.pointf_90;
		}
		LiveObject_GetPosition(liveObj,(float *)pPVar7,&pPVar1->y);
		LiveObject_GetBlockPos(liveObj,(int *)&local_8,(int *)&local_4);
	}
	uVar5 = local_4;
	uVar4 = local_8;
	iVar3 = lego::view::Camera_GetMouseScrollIndent();
	if ((int)local_8 < iVar3) {
		uVar4 = lego::view::Camera_GetMouseScrollIndent();
	}
	iVar3 = lego::view::Camera_GetMouseScrollIndent();
	if ((pLVar2->surfaceMap->smallDimensions).width - iVar3 <= (int)local_8) {
		iVar3 = lego::view::Camera_GetMouseScrollIndent();
		uVar4 = ((pLVar2->surfaceMap->smallDimensions).width - iVar3) - 1;
	}
	iVar3 = lego::view::Camera_GetMouseScrollIndent();
	if ((int)local_4 < iVar3) {
		uVar5 = lego::view::Camera_GetMouseScrollIndent();
	}
	iVar3 = lego::view::Camera_GetMouseScrollIndent();
	if ((pLVar2->surfaceMap->smallDimensions).height - iVar3 <= (int)local_4) {
		iVar3 = lego::view::Camera_GetMouseScrollIndent();
		uVar5 = ((pLVar2->surfaceMap->smallDimensions).height - iVar3) - 1;
	}
	if ((local_8 != uVar4) || (local_4 != uVar5)) {
		if (param_3 == 0) {
			pPVar1 = &globs::gameGlobs.pointf_88;
			pPVar7 = &globs::gameGlobs.pointf_88;
			pSVar6 = (globs::gameGlobs.level)->surfaceMap;
		}
		else {
			pPVar1 = &globs::gameGlobs.pointf_90;
			pPVar7 = &globs::gameGlobs.pointf_90;
			pSVar6 = (globs::gameGlobs.level)->surfaceMap;
		}
		Map3D_BlockToWorldPos(pSVar6,uVar4,uVar5,(float *)pPVar7,&pPVar1->y);
	}
	globs::gameGlobs.flags1 = globs::gameGlobs.flags1 | GAME1_UNK_200000;
	return;
}



void __cdecl lego::game::Game_RemoveRecordObject(LiveObject *liveObj)
{
	LiveObject **ppLVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (globs::gameGlobs.recordObjsCount != 0) {
		ppLVar1 = globs::gameGlobs.recordObjs;
		do {
			if (liveObj == *ppLVar1) {
				*ppLVar1 = NULL;
			}
			uVar2 += 1;
			ppLVar1 = ppLVar1 + 1;
		} while (uVar2 < globs::gameGlobs.recordObjsCount);
	}
	return;
}



BOOL __cdecl lego::game::Game_GetRecordObject(uint recordObjPtr,LiveObject **out_liveObj)
{
	LiveObject *liveObj;
	
	if ((recordObjPtr < globs::gameGlobs.recordObjsCount) &&
		 (liveObj = globs::gameGlobs.recordObjs[recordObjPtr], *out_liveObj = liveObj, liveObj != NULL))
	{
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::game::Game_LoadOLObjectList(LevelData *level,char *filename)
{
	LiveObject *liveObj;
	float yaw;
	bool bVar1;
	CFGProperty *prop;
	char *pcVar2;
	CFGProperty *prop_00;
	CFGProperty *pCVar3;
	uint by;
	BOOL BVar4;
	LevelBlockFlags1 LVar5;
	Point2I *pPVar6;
	ObjectStatsFlags3 OVar7;
	ObjectStatsFlags1 OVar8;
	int iVar9;
	char **ppcVar10;
	LiveObject *pLVar11;
	Direction rotation;
	uint uVar12;
	LiveObject **ppLVar13;
	bool bVar14;
	float10 fVar15;
	float10 fVar16;
	float10 fVar17;
	ulonglong uVar18;
	ulonglong uVar19;
	longlong lVar20;
	float fVar21;
	float fVar22;
	TrainedFlags trainFlags;
	uint local_9c8;
	ObjectType local_9c4;
	float local_9c0;
	float local_9bc;
	float objYpos;
	float objHeading;
	uint local_9b0;
	float objXpos;
	uint local_9a8;
	float objHealth;
	LiveObject **local_9a0;
	char *objDrivenByName;
	Container *local_990;
	char *objTypeName;
	uint local_988;
	Point2I local_984;
	char *objDrivingName;
	Point2F local_978;
	uint local_970;
	undefined4 uStack2412;
	uint local_968;
	undefined4 uStack2404;
	LiveObject *local_960 [200];
	char *local_640 [200];
	char *apcStack800 [200];
	
	bVar14 = false;
	bVar1 = true;
	local_9c8 = 0;
	prop = cfg::CFG_Open(filename);
	if (prop != NULL) {
		ppLVar13 = globs::gameGlobs.recordObjs;
		for (iVar9 = 10; iVar9 != 0; iVar9 += -1) {
			*ppLVar13 = NULL;
			ppLVar13 = ppLVar13 + 1;
		}
		globs::gameGlobs.recordObjsCount = 0;
		pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,0);
		prop_00 = cfg::CFG_GetChildren(prop,pcVar2);
		if (prop_00 != NULL) {
			local_9a0 = local_960;
			do {
				pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,prop_00->key,"type",0);
				objTypeName = cfg::CFG_CopyString(prop,pcVar2);
				if (objTypeName == NULL) break;
				pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,prop_00->key,"xpos",0);
				pCVar3 = cfg::CFG_GetProperty(prop,pcVar2);
				if (pCVar3 == NULL) break;
				pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,prop_00->key,"ypos",0);
				pCVar3 = cfg::CFG_GetProperty(prop,pcVar2);
				if (pCVar3 == NULL) break;
				pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,prop_00->key,"heading",0);
				pCVar3 = cfg::CFG_GetProperty(prop,pcVar2);
				if (pCVar3 == NULL) break;
				pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,prop_00->key,"xpos",0);
				pcVar2 = cfg::CFG_ReadString(prop,pcVar2);
				if (pcVar2 == NULL) {
					pcVar2 = ____EMPTYSTR__;
				}
				else {
					pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,prop_00->key,"xpos",0);
					pcVar2 = cfg::CFG_ReadString(prop,pcVar2);
				}
				fVar15 = std::atof(pcVar2);
				pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,prop_00->key,"ypos",0);
				pcVar2 = cfg::CFG_ReadString(prop,pcVar2);
				if (pcVar2 == NULL) {
					pcVar2 = ____EMPTYSTR__;
				}
				else {
					pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,prop_00->key,"ypos",0);
					pcVar2 = cfg::CFG_ReadString(prop,pcVar2);
				}
				fVar16 = std::atof(pcVar2);
				objYpos = (float)fVar16;
				pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,prop_00->key,"heading",0);
				pcVar2 = cfg::CFG_ReadString(prop,pcVar2);
				if (pcVar2 == NULL) {
					pcVar2 = ____EMPTYSTR__;
				}
				else {
					pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,prop_00->key,"heading",0);
					pcVar2 = cfg::CFG_ReadString(prop,pcVar2);
				}
				fVar16 = std::atof(pcVar2);
				pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,prop_00->key,"health",0);
				pcVar2 = cfg::CFG_ReadString(prop,pcVar2);
				if (pcVar2 == NULL) {
					pcVar2 = ____EMPTYSTR__;
				}
				else {
					pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,prop_00->key,"health",0);
					pcVar2 = cfg::CFG_ReadString(prop,pcVar2);
				}
				fVar17 = std::atof(pcVar2);
				objHealth = (float)fVar17;
				if ((float10)0.0 == fVar17) {
					objHealth = (float)&DAT_42c80000;
				}
				pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,prop_00->key,"driving",0);
				objDrivingName = cfg::CFG_CopyString(prop,pcVar2);
				apcStack800[local_9c8] = objDrivingName;
				pcVar2 = std::_strdup(prop_00->key);
				local_640[local_9c8] = pcVar2;
				objYpos = objYpos - 1.0;
				uVar18 = __ftol((float10)((float)fVar15 - 1.0));
				uVar12 = (uint)uVar18;
				uVar19 = __ftol((float10)objYpos);
				by = (uint)uVar19;
				Map3D_BlockToWorldPos(level->surfaceMap,uVar12,by,&local_9c0,&local_9bc);
				uStack2404 = 0;
				uStack2412 = 0;
				objYpos = (objYpos - ((float)(uVar19 & 0xffffffff) - -0.5)) * level->BlockSize;
				local_9c0 = local_9c0 +
										(((float)fVar15 - 1.0) - ((float)(uVar18 & 0xffffffff) - -0.5)) *
										level->BlockSize;
				local_9bc = local_9bc - objYpos;
				yaw = (float)fVar16 * 0.005555556 * 3.141593;
				local_970 = by;
				local_968 = uVar12;
				BVar4 = Object_GetObjectByName(objTypeName,&local_9c4,(int *)&local_9a8,&local_990);
				if (BVar4 == 0) break;
				pLVar11 = NULL;
				if (local_9c4 == OBJECT_TVCAMERA) {
					lego::view::Camera_SetFramePosition_IfTopdown
										(globs::gameGlobs.cameraMain,local_9c0,local_9bc);
					lego::view::Camera_SetYaw(globs::gameGlobs.cameraMain,yaw);
					lego::view::Camera_SetTilt(globs::gameGlobs.cameraMain,0.8);
					globs::gameGlobs.tvFaceDirection_338.x = local_9c0;
					globs::gameGlobs.tvFaceDirection_338.y = local_9bc;
					globs::gameGlobs.tvTiltOrZoom_334 = 15.0;
				}
				else {
					iVar9 = ((globs::gameGlobs.level)->dimensions).width;
					if ((uVar12 < iVar9 - 1U) && (by < ((globs::gameGlobs.level)->dimensions).height - 1U)) {
						LVar5 = (globs::gameGlobs.level)->blocks[by * iVar9 + uVar12].flags1 & BLOCK1_UNK_8;
					}
					else {
						LVar5 = BLOCK1_NONE;
					}
					if (LVar5 == BLOCK1_NONE) {
						local_978.x = local_9c0;
						local_978.y = local_9bc;
						LiveManager_HiddenStruct2C_FUN_00437ee0
											(local_990,local_9c4,local_9a8,&local_978,yaw,objHealth,pcVar2,objDrivingName)
						;
					}
					else {
						if (local_9c4 == OBJECT_BUILDING) {
							local_984.x = uVar12;
							local_984.y = by;
							pPVar6 = res::Building_GetShapePoints
																 (globs::gameGlobs.BuildingData_TABLE + local_9a8,&local_988);
							lVar20 = __ftol((float10)yaw * (float10)0.1591549 * (float10)8.0);
							rotation = ((uint)lVar20 & 1) + (uint)lVar20 >> 1;
							pPVar6 = Game_TransformShapePoints(&local_984,pPVar6,local_988,rotation);
							pLVar11 = Construction_Block_FUN_004099c0
																	(local_9a8,&local_984,rotation,(uint *)pPVar6,local_988,
																	 level->IsStartTeleportEnabled);
							if (pLVar11 != NULL) {
								LiveObject_FUN_00438720(pLVar11);
							}
						}
						else {
							pLVar11 = LiveObject__Create((int **)local_990,local_9c4,local_9a8);
						}
					}
				}
				*local_9a0 = pLVar11;
				if (pLVar11 != NULL) {
					if (bVar1) {
						fVar22 = 0.01;
						fVar21 = 0.7;
						fVar15 = LiveObject_GetTrackDist(pLVar11);
						lego::view::Camera_FollowObject
											(globs::gameGlobs.cameraRadar,pLVar11,2.0,(float)fVar15,fVar21,fVar22);
					}
					bVar1 = false;
					if (local_9c4 != OBJECT_BUILDING) {
						LiveObject_UnkUpdatePositioning(pLVar11,local_9c0,local_9bc,yaw,1);
					}
					if ((((local_9c4 == OBJECT_POWERCRYSTAL) || (local_9c4 == OBJECT_ORE)) ||
							(local_9c4 == OBJECT_DYNAMITE)) || (local_9c4 == OBJECT_BARRIER)) {
						ai::AITask_DoCollect(pLVar11,0.0);
					}
					if ((globs::liveGlobs.minifigureObj_9cb8 == NULL) &&
						 (pLVar11->objType == OBJECT_MINIFIGURE)) {
						globs::liveGlobs.minifigureObj_9cb8 = pLVar11;
					}
					if (globs::gameGlobs.recordObjsCount < 10) {
						globs::gameGlobs.recordObjs[globs::gameGlobs.recordObjsCount] = pLVar11;
						globs::gameGlobs.recordObjsCount += 1;
					}
					pLVar11->flags4 = pLVar11->flags4 | 0x200;
					pLVar11->health = objHealth;
					front::HelpWindow_Game_UpdateObjectDependencies(pLVar11->objType,pLVar11->objIndex,0,TRUE)
					;
					if ((globs::gameGlobs.flags2 & GAME2_RECALLOLOBJECTS) != GAME2_NONE) {
						ObjectRecall_LiveObject_RecallMiniFigure(pLVar11);
					}
					LiveObject_Vehicle_FUN_0043aca0(pLVar11);
					if (local_9c4 == OBJECT_SPIDERWEB) {
						pLVar11->flags3 = pLVar11->flags3 | LIVEOBJ3_UNK_10000;
						res::Container_SetActivity(pLVar11->other,"FlapInWind");
						res::Container_SetAnimationTime(pLVar11->other,0.0);
						SpiderWeb_Add(uVar12,by,pLVar11);
					}
					else {
						if (local_9c4 == OBJECT_ELECTRICFENCE) {
							ElectricFence_AssignBlockObject(pLVar11);
						}
					}
				}
				std::free(objTypeName);
				local_9c8 += 1;
				local_9a0 = local_9a0 + 1;
				prop_00 = cfg::CFG_NextFlat(prop_00);
			} while (prop_00 != NULL);
			bVar14 = prop_00 == NULL;
		}
		cfg::CFG_Close(prop);
	}
	if (!bVar14) {
		return 0;
	}
	local_9b0 = 0;
	if (local_9c8 != 0) {
		do {
			pLVar11 = local_960[local_9b0];
			if ((pLVar11 != NULL) && (pcVar2 = apcStack800[local_9b0], pcVar2 != NULL)) {
				uVar12 = 0;
				ppcVar10 = local_640;
				do {
					iVar9 = std::_stricmp(pcVar2,*ppcVar10);
					if (iVar9 == 0) {
						liveObj = local_960[uVar12];
						if (liveObj != NULL) {
							pLVar11->object_2fc = liveObj;
							pLVar11->flags2 = pLVar11->flags2 | LIVEOBJ2_UNK_4;
							OVar7 = LiveObject_GetStatsFlags3(liveObj);
							if ((OVar7 & STATS3_NEEDSPILOT) == STATS3_NONE) {
								OVar8 = LiveObject_GetStatsFlags1(liveObj);
								if ((OVar8 & STATS1_CROSSWATER) == STATS1_NONE) {
									trainFlags = TRAINED_DRIVER;
								}
								else {
									OVar8 = LiveObject_GetStatsFlags1(liveObj);
									if ((OVar8 & STATS1_CROSSLAND) == STATS1_NONE) {
										trainFlags = TRAINED_SAILOR;
									}
									else {
										trainFlags = TRAINED_PILOT;
									}
								}
							}
							else {
								trainFlags = TRAINED_PILOT;
							}
							LiveObject_TrainMiniFigure_instantunk(pLVar11,trainFlags);
							LiveObject_ClearFlags4_40_AndSameForObject2FC(pLVar11,liveObj);
						}
						break;
					}
					uVar12 += 1;
					ppcVar10 = ppcVar10 + 1;
				} while (uVar12 < local_9c8);
			}
			local_9b0 += 1;
		} while (local_9b0 < local_9c8);
	}
	uVar12 = 0;
	if (local_9c8 != 0) {
		do {
			if (local_640[uVar12] != NULL) {
				std::free(local_640[uVar12]);
			}
			if (apcStack800[uVar12] != NULL) {
				std::free(apcStack800[uVar12]);
			}
			uVar12 += 1;
		} while (uVar12 < local_9c8);
	}
	return 1;
}



BOOL __cdecl
lego::game::Object_GetObjectByName
					(char *objName,ObjectType *out_objType,int *out_objIndex,Container **opt_resData)
{
	int iVar1;
	uint index;
	
	index = 0;
	*out_objIndex = 0;
	if (globs::gameGlobs.RockMonsterTypes_COUNT != 0) {
		do {
			iVar1 = std::_stricmp(globs::gameGlobs.RockMonsterTypes_TABLE[index],objName);
			if (iVar1 == 0) {
				*out_objType = OBJECT_ROCKMONSTER;
				*out_objIndex = index;
				if (opt_resData == NULL) {
					return 1;
				}
				*opt_resData = (Container *)(globs::gameGlobs.RockMonsterData_TABLE + index);
				return 1;
			}
			index += 1;
		} while (index < globs::gameGlobs.RockMonsterTypes_COUNT);
	}
	iVar1 = std::_stricmp("tvcamera",objName);
	if (iVar1 == 0) {
		*out_objType = OBJECT_TVCAMERA;
		if (opt_resData != NULL) {
			*opt_resData = NULL;
			return 1;
		}
	}
	else {
		iVar1 = std::_stricmp("PowerCrystal",objName);
		if (iVar1 == 0) {
			*out_objType = OBJECT_POWERCRYSTAL;
			if (opt_resData != NULL) {
				*opt_resData = globs::gameGlobs.RES_Crystal;
				return 1;
			}
		}
		else {
			iVar1 = std::_stricmp("Ore",objName);
			if (iVar1 == 0) {
				*out_objType = OBJECT_ORE;
				*out_objIndex = 0;
				if (opt_resData != NULL) {
					*opt_resData = globs::gameGlobs.RES_Ores_TABLE[0];
					return 1;
				}
			}
			else {
				iVar1 = std::_stricmp("ProcessedOre",objName);
				if (iVar1 == 0) {
					*out_objType = OBJECT_ORE;
					*out_objIndex = 1;
					if (opt_resData != NULL) {
						*opt_resData = globs::gameGlobs.RES_Ores_TABLE[1];
						return 1;
					}
				}
				else {
					iVar1 = std::_stricmp("Boulder",objName);
					if (iVar1 == 0) {
						*out_objType = OBJECT_BOULDER;
						if (opt_resData != NULL) {
							*opt_resData = globs::gameGlobs.RES_Boulder;
							return 1;
						}
					}
					else {
						iVar1 = std::_stricmp("Pusher",objName);
						if (iVar1 == 0) {
							*out_objType = OBJECT_PUSHER;
							if (opt_resData != NULL) {
								*opt_resData = globs::gameGlobs.RES_Pusher;
								return 1;
							}
						}
						else {
							iVar1 = std::_stricmp("LaserShot",objName);
							if (iVar1 == 0) {
								*out_objType = OBJECT_LASERSHOT;
								if (opt_resData != NULL) {
									*opt_resData = globs::gameGlobs.RES_LaserShot;
									return 1;
								}
							}
							else {
								iVar1 = std::_stricmp("Freezer",objName);
								if (iVar1 == 0) {
									*out_objType = OBJECT_FREEZER;
									if (opt_resData != NULL) {
										*opt_resData = globs::gameGlobs.RES_Freezer;
										return 1;
									}
								}
								else {
									iVar1 = std::_stricmp("Dynamite",objName);
									if (iVar1 == 0) {
										*out_objType = OBJECT_DYNAMITE;
										if (opt_resData != NULL) {
											*opt_resData = globs::gameGlobs.RES_Dynamite;
											return 1;
										}
									}
									else {
										iVar1 = std::_stricmp("ElectricFence",objName);
										if (iVar1 == 0) {
											*out_objType = OBJECT_ELECTRICFENCE;
											if (opt_resData != NULL) {
												*opt_resData = globs::gameGlobs.RES_ElectricFence;
												return 1;
											}
										}
										else {
											iVar1 = std::_stricmp("SpiderWeb",objName);
											if (iVar1 == 0) {
												*out_objType = OBJECT_SPIDERWEB;
												if (opt_resData != NULL) {
													*opt_resData = globs::gameGlobs.RES_SpiderWeb;
													return 1;
												}
											}
											else {
												iVar1 = std::_stricmp("Barrier",objName);
												if (iVar1 == 0) {
													*out_objType = OBJECT_BARRIER;
													if (opt_resData != NULL) {
														*opt_resData = globs::gameGlobs.RES_Barrier;
														return 1;
													}
												}
												else {
													iVar1 = std::_stricmp("OohScary",objName);
													if (iVar1 == 0) {
														*out_objType = OBJECT_OOHSCARY;
														if (opt_resData != NULL) {
															*opt_resData = globs::gameGlobs.RES_OohScary;
															return 1;
														}
													}
													else {
														iVar1 = std::_stricmp("Path",objName);
														if (iVar1 == 0) {
															*out_objType = OBJECT_PATH;
															if (opt_resData != NULL) {
																*opt_resData = NULL;
																return 1;
															}
														}
														else {
															index = 0;
															if (globs::gameGlobs.VehicleTypes_COUNT != 0) {
																do {
																	iVar1 = std::_stricmp(globs::gameGlobs.VehicleTypes_TABLE[index],
																												objName);
																	if (iVar1 == 0) {
																		*out_objType = OBJECT_VEHICLE;
																		*out_objIndex = index;
																		if (opt_resData == NULL) {
																			return 1;
																		}
																		*opt_resData = (Container *)
																									 (globs::gameGlobs.VehicleData_TABLE + index);
																		return 1;
																	}
																	index += 1;
																} while (index < globs::gameGlobs.VehicleTypes_COUNT);
															}
															index = 0;
															if (globs::gameGlobs.MiniFigureTypes_COUNT != 0) {
																do {
																	iVar1 = std::_stricmp(globs::gameGlobs.MiniFigureTypes_TABLE
																												[index],objName);
																	if (iVar1 == 0) {
																		*out_objType = OBJECT_MINIFIGURE;
																		*out_objIndex = index;
																		if (opt_resData == NULL) {
																			return 1;
																		}
																		*opt_resData = (Container *)
																									 (globs::gameGlobs.MiniFigureData_TABLE + index);
																		return 1;
																	}
																	index += 1;
																} while (index < globs::gameGlobs.MiniFigureTypes_COUNT);
															}
															index = 0;
															if (globs::gameGlobs.BuildingTypes_COUNT == 0) {
																return 0;
															}
															while (iVar1 = std::_stricmp(globs::gameGlobs.BuildingTypes_TABLE
																													 [index],objName), iVar1 != 0) {
																index += 1;
																if (globs::gameGlobs.BuildingTypes_COUNT <= index) {
																	return 0;
																}
															}
															*out_objType = OBJECT_BUILDING;
															*out_objIndex = index;
															if (opt_resData != NULL) {
																*opt_resData = (Container *)
																							 (globs::gameGlobs.BuildingData_TABLE + index);
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return 1;
}



BOOL __cdecl
lego::game::Object_GetTypeResource(ObjectType objType,int objIndex,Container **out_resData)
{
	if (objType == OBJECT_TVCAMERA) {
		*out_resData = NULL;
		return 1;
	}
	if (objType == OBJECT_POWERCRYSTAL) {
		*out_resData = globs::gameGlobs.RES_Crystal;
		return 1;
	}
	if (objType == OBJECT_ORE) {
		*out_resData = globs::gameGlobs.RES_Ores_TABLE[objIndex];
		return 1;
	}
	if (objType == OBJECT_DYNAMITE) {
		*out_resData = globs::gameGlobs.RES_Dynamite;
		return 1;
	}
	if (objType == OBJECT_BARRIER) {
		*out_resData = globs::gameGlobs.RES_Barrier;
		return 1;
	}
	if (objType == OBJECT_ELECTRICFENCE) {
		*out_resData = globs::gameGlobs.RES_ElectricFence;
		return 1;
	}
	if (objType == OBJECT_SPIDERWEB) {
		*out_resData = globs::gameGlobs.RES_SpiderWeb;
		return 1;
	}
	if (objType == OBJECT_OOHSCARY) {
		*out_resData = globs::gameGlobs.RES_OohScary;
		return 1;
	}
	if (objType == OBJECT_PATH) {
		*out_resData = NULL;
		return 1;
	}
	if (objType == OBJECT_BOULDER) {
		*out_resData = globs::gameGlobs.RES_Boulder;
		return 1;
	}
	if (objType == OBJECT_VEHICLE) {
		*out_resData = (Container *)(globs::gameGlobs.VehicleData_TABLE + objIndex);
		return 1;
	}
	if (objType == OBJECT_MINIFIGURE) {
		*out_resData = (Container *)(globs::gameGlobs.MiniFigureData_TABLE + objIndex);
		return 1;
	}
	if (objType == OBJECT_ROCKMONSTER) {
		*out_resData = (Container *)(globs::gameGlobs.RockMonsterData_TABLE + objIndex);
		return 1;
	}
	if (objType == OBJECT_BUILDING) {
		*out_resData = (Container *)(globs::gameGlobs.BuildingData_TABLE + objIndex);
		return 1;
	}
	if (objType == OBJECT_PUSHER) {
		*out_resData = globs::gameGlobs.RES_Pusher;
		return 1;
	}
	if (objType == OBJECT_LASERSHOT) {
		*out_resData = globs::gameGlobs.RES_LaserShot;
		return 1;
	}
	if (objType == OBJECT_FREEZER) {
		*out_resData = globs::gameGlobs.RES_Freezer;
		return 1;
	}
	return 0;
}



int __cdecl lego::game::Object_GetTypeCount(ObjectType objType)
{
	uint uVar1;
	
	uVar1 = objType + OBJECT_TVCAMERA;
	switch(objType) {
	case OBJECT_VEHICLE:
		return globs::gameGlobs.VehicleTypes_COUNT;
	case OBJECT_MINIFIGURE:
		return globs::gameGlobs.MiniFigureTypes_COUNT;
	case OBJECT_ROCKMONSTER:
		return globs::gameGlobs.RockMonsterTypes_COUNT;
	case OBJECT_BUILDING:
		return globs::gameGlobs.BuildingTypes_COUNT;
	case OBJECT_BOULDER:
	case OBJECT_POWERCRYSTAL:
	case OBJECT_DYNAMITE:
	case OBJECT_BARRIER:
	case OBJECT_ELECTRICFENCE:
	case OBJECT_SPIDERWEB:
	case OBJECT_OOHSCARY:
	case OBJECT_ELECTRICFENCESTUD:
	case OBJECT_PATH:
	case OBJECT_PUSHER:
	case OBJECT_FREEZER:
	case OBJECT_ICECUBE:
	case OBJECT_LASERSHOT:
		uVar1 = 1;
		break;
	case OBJECT_ORE:
		return 2;
	case OBJECT_UPGRADEPART:
		return globs::gameGlobs.UpgradeTypes_COUNT;
	}
	return uVar1;
}



void __cdecl lego::video::VideoPlayer_OpenAndPlay(char *filename,Point2F *opt_point)
{
	Point2F *pPVar1;
	VideoPlayer_t *videoPlayer;
	int iVar2;
	BOOL doFillSurface;
	RECT *lpRect;
	longlong lVar3;
	RECT rect;
	
	if (filename == NULL) {
		return;
	}
	videoPlayer = VideoPlayer_Load(filename);
	pPVar1 = opt_point;
	if (videoPlayer == NULL) {
		return;
	}
	if (opt_point == NULL) {
		doFillSurface = 1;
		if (true) goto LAB_0042ef98;
	}
	else {
		VideoPlayer_GetSize(videoPlayer,(uint *)&filename,(uint *)&opt_point);
		lVar3 = __ftol((float10)pPVar1->x);
		rect.left = (LONG)lVar3;
		lVar3 = __ftol((float10)pPVar1->y);
		rect.top = (LONG)lVar3;
		lVar3 = __ftol((float10)ZEXT48(filename) + (float10)pPVar1->x);
		rect.right = (LONG)lVar3;
		lVar3 = __ftol((float10)ZEXT48(opt_point) + (float10)pPVar1->y);
		rect.bottom = (LONG)lVar3;
		doFillSurface = 0;
	}
	ddraw::DirectDraw_ReturnFrontBuffer();
LAB_0042ef98:
	lpRect = (RECT *)(~-(uint)(doFillSurface != 0) & (uint)&rect);
	iVar2 = VideoPlayer_Update(videoPlayer,1.0,lpRect);
	while (iVar2 != 0) {
		main::Main_LoopUpdate(doFillSurface);
		iVar2 = VideoPlayer_Update(videoPlayer,1.0,lpRect);
	}
	VideoPlayer_Free(videoPlayer);
	return;
}



// Returns string containing name of nextLevel.

char * __cdecl lego::game::Level_Free(void)
{
	char *nextLevel;
	LevelData *level;
	
	level = globs::gameGlobs.level;
	nextLevel = NULL;
	if (globs::gameGlobs.level != NULL) {
		std::free((globs::gameGlobs.level)->ptrtable_8);
		if (globs::gameGlobs.EndGameAVI1 != NULL) {
			std::free(globs::gameGlobs.EndGameAVI1);
		}
		if (globs::gameGlobs.EndGameAVI2 != NULL) {
			std::free(globs::gameGlobs.EndGameAVI2);
		}
		std::free(level->FullName);
		globs::gameGlobs.flags1 &= ~(GAME1_UNK_200000|GAME1_UNK_8000000);
		globs::liveGlobs.flags &= 0xffffffbf;
		globs::gameGlobs.flags2 &= ~(GAME2_UNK_2|GAME2_NOMULTISELECT);
		globs::gameGlobs.bool_98 = 0;
		globs::gameGlobs.objTeleportQueue_COUNT = 0;
		globs::liveGlobs.minifigureObj_9cb8 = NULL;
		globs::liveGlobs.count_c434 = 0;
		globs::liveGlobs.countBuildingsOnly_c438 = 0;
		Game_SetCallToArmsOn(0);
		globs::gameGlobs.flags1 &= ~GAME1_LASERTRACKER;
		globs::gameGlobs.flags2 &= ~(GAME2_ATTACKDEFER|GAME2_UNK_40|GAME2_UNK_80|GAME2_MENU_HASNEXT);
		globs::gameGlobs.pointsCount2_dcc[0] = 0;
		globs::gameGlobs.pointsCount2_dcc[1] = 0;
		lego::view::Camera_SetFloata0_a4_Zeroa8(globs::gameGlobs.cameraMain,0.0,0.0);
		lego::view::Camera_SetDist(globs::gameGlobs.cameraMain,200.0);
		lego::effect::Smoke_RemoveAll();
		Game_ClearSomeFlags3_FUN_00435950();
		nextLevel = level->NextLevel;
		front::Text_FUN_0046ad50();
		front::HelpWindow_UnsetFlag1_004dd650();
		Dependencies_Object_FUN_0040aa60();
		nerps::NERPs_BlockPointers_FUN_00456f20();
		ai::AITask_FUN_00402040(0);
		LiveManager_FUN_00437560();
		Construction_RemoveAll();
		lego::effect::Effect_FUN_0040bcf0();
		ai::AITask_FUN_00402040(TRUE);
		front::Info_SetFlag4(0);
		WorldMesh_UnkFreeGridPtr_FUN_00463190();
		lego::view::Camera_FollowObject(globs::gameGlobs.cameraRadar,NULL,0.0,0.0,0.0,0.0);
		lego::view::Camera_SetObject4_Field14(globs::gameGlobs.cameraFP,NULL,0);
		Message_CleanupSelectedUnitsCount();
		nerps::NERPs_Cleanup();
		LevelStruct3C_Free_Unwind(level->struct3c_84);
		Map3D_Free(level->surfaceMap);
		Level_Free_ProMeshGrid(level);
		res::DynamicPM_Free_SurfaceTextureGrid(level->surfTextGrid);
		Level_FreeAll_LevelStruct1Cs_FUN_00431460(level);
		lego::effect::Effect_RemoveAll_BoulderExplode();
		std::free(level->blocks);
		std::free(level);
		front::Info_FUN_00419e40();
		front::Interface_LevelFree_FUN_0041a850();
		Game_SetGameSpeed(1.0);
		front::Panel_FUN_0045a530();
		front::Advisor_Cleanup();
		snd::Sound3D_StopAllSounds();
		lego::effect::DamageFont_Cleanup();
	}
	globs::gameGlobs.level = NULL;
	return nextLevel;
}



void __cdecl FUN_0042f210(LevelData *level,int *param_2,int *param_3,int param_4)
{
	LevelBlockFlags1 *pLVar1;
	int iVar2;
	
	iVar2 = (level->dimensions).width;
	if (param_4 != 0) {
		pLVar1 = &level->blocks[(int)(iVar2 * (int)param_3 + (int)param_2)].flags1;
		*pLVar1 = *pLVar1 | BLOCK1_UNK_200;
		lego::game::Level_UpdateBlockSurfaceUnk(level,(int)param_2,(int)param_3,0);
		return;
	}
	pLVar1 = &level->blocks[(int)(iVar2 * (int)param_3 + (int)param_2)].flags1;
	*pLVar1 = *pLVar1 & ~BLOCK1_UNK_200;
	lego::game::Level_UpdateBlockSurfaceUnk(level,(int)param_2,(int)param_3,0);
	return;
}



uint __cdecl FUN_0042f280(int param_1,int param_2,undefined *param_3,int param_4)
{
	int iVar1;
	LevelBlockFlags1 LVar2;
	undefined3 uVar3;
	uint uVar5;
	int iVar6;
	int *piVar7;
	int iVar8;
	uint local_24;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	undefined3 uVar4;
	
	local_20[2] = 1;
	local_c = 1;
	local_20[1] = 0xffffffff;
	local_20[3] = 0;
	local_20[4] = 0;
	local_8 = 0xffffffff;
	local_4 = 0;
	local_24 = 0;
	uVar5 = 0;
	piVar7 = local_20 + 1;
	do {
		iVar6 = piVar7[-1] + param_1;
		iVar8 = param_2 + *piVar7;
		if ((((iVar6 < 0) || (iVar8 < 0)) ||
				(iVar1 = ((lego::globs::gameGlobs.level)->dimensions).width, iVar1 <= iVar6)) ||
			 (((lego::globs::gameGlobs.level)->dimensions).height <= iVar8)) {
			LVar2 = BLOCK1_NONE;
		}
		else {
			LVar2 = (lego::globs::gameGlobs.level)->blocks[iVar8 * iVar1 + iVar6].flags1 &
							BLOCK1_POWERPATH;
		}
		if ((LVar2 != BLOCK1_NONE) ||
			 (((lego::globs::gameGlobs.level)->blocks
				 [((lego::globs::gameGlobs.level)->dimensions).width * iVar8 + iVar6].flags1 &
				BLOCK1_UNK_400) != BLOCK1_NONE)) {
			local_24 |= 1 << ((byte)uVar5 & 0x1f);
		}
		uVar5 += 1;
		piVar7 = piVar7 + 2;
	} while (uVar5 < 4);
	uVar3 = (undefined3)(local_24 >> 8);
	uVar4 = (undefined3)((uint)param_3 >> 8);
	if (param_4 == 0) {
		switch(local_24) {
		case 0:
			*param_3 = 0;
			return CONCAT31(uVar3,0x65);
		case 1:
			*param_3 = 2;
			return CONCAT31(uVar4,0x65);
		case 2:
			*param_3 = 3;
			return CONCAT31(uVar3,0x65);
		case 3:
			*param_3 = 3;
			return CONCAT31(uVar3,99);
		case 4:
			*param_3 = 0;
			return CONCAT31(uVar3,0x65);
		case 5:
			*param_3 = 0;
			return CONCAT31(uVar3,0x62);
		case 6:
			*param_3 = 0;
			return CONCAT31(uVar3,99);
		case 7:
			*param_3 = 0;
			return CONCAT31(uVar3,100);
		case 8:
			*param_3 = 1;
			return CONCAT31(uVar4,0x65);
		case 9:
			*param_3 = 2;
			return CONCAT31(uVar4,99);
		case 10:
			*param_3 = 1;
			return CONCAT31(uVar4,0x62);
		case 0xb:
			*param_3 = 3;
			return CONCAT31(uVar3,100);
		case 0xc:
			*param_3 = 1;
			return CONCAT31(uVar3,99);
		case 0xd:
			*param_3 = 2;
			return CONCAT31(uVar3,100);
		case 0xe:
			*param_3 = 1;
			return CONCAT31(uVar4,100);
		case 0xf:
			*param_3 = 0;
			return CONCAT31(uVar3,0x60);
		}
	}
	else {
		switch(local_24) {
		case 0:
			*param_3 = 0;
			return CONCAT31(uVar4,0x75);
		case 1:
			*param_3 = 2;
			return CONCAT31(uVar3,0x75);
		case 2:
			*param_3 = 3;
			return CONCAT31(uVar4,0x75);
		case 3:
			*param_3 = 3;
			return CONCAT31(uVar4,0x73);
		case 4:
			*param_3 = 0;
			return CONCAT31(uVar3,0x75);
		case 5:
			*param_3 = 0;
			return CONCAT31(uVar3,0x72);
		case 6:
			*param_3 = 0;
			return CONCAT31(uVar4,0x73);
		case 7:
			*param_3 = 0;
			return CONCAT31(uVar3,0x74);
		case 8:
			*param_3 = 1;
			return CONCAT31(uVar3,0x75);
		case 9:
			*param_3 = 2;
			return CONCAT31(uVar3,0x73);
		case 10:
			*param_3 = 1;
			return CONCAT31(uVar3,0x72);
		case 0xb:
			*param_3 = 3;
			return CONCAT31(uVar3,0x74);
		case 0xc:
			*param_3 = 1;
			return CONCAT31(uVar3,0x73);
		case 0xd:
			*param_3 = 2;
			return CONCAT31(uVar4,0x74);
		case 0xe:
			*param_3 = 1;
			return CONCAT31(uVar3,0x74);
		case 0xf:
			*param_3 = 0;
			return CONCAT31(uVar4,0x71);
		}
	}
	return local_24 & 0xffffff00 | (uint)param_3 & 0xff;
}



// WARNING: Switch with 1 destination removed at 0x0042fd79 : 5 cases all go to same destination
// WARNING: Switch with 1 destination removed at 0x0042fdd8 : 5 cases all go to same destination

void __cdecl lego::game::Level_UpdateBlockSurfaceUnk(LevelData *level,int bx,int by,BOOL reserved)
{
	LevelBlock *pLVar1;
	SurfaceMap *surfMap;
	int iVar2;
	LevelBlockFlags1 LVar3;
	LevelBlockFlags2 LVar4;
	LevelBlockFlags1 LVar5;
	BOOL BVar6;
	SurfaceMapStruct_2a8 *pSVar7;
	FeatureFlags FVar8;
	Point2I *pDir;
	uint *puVar9;
	uint extraout_ECX;
	uint uVar10;
	uint extraout_EDX;
	uint uVar11;
	float local_60;
	int local_5c;
	float local_58;
	float local_54;
	Point2I *local_50;
	SurfaceMap *local_4c;
	Vector3F local_48;
	int local_3c;
	Point2I local_38;
	Point2I DIRECTIONS [4];
	LevelBlock *block;
	
	iVar2 = (level->dimensions).width;
	if (iVar2 - 1U <= (uint)bx) {
		return;
	}
	if ((level->dimensions).height - 1U <= (uint)by) {
		return;
	}
	local_4c = level->surfaceMap;
	iVar2 = by * iVar2 + bx;
	local_5c = 0;
	DIRECTIONS[0].x = 0;
	LVar3 = level->blocks[iVar2].flags1 & BLOCK1_POWERPATH;
	DIRECTIONS[0].y = 0;
	block = level->blocks + iVar2;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 1;
	DIRECTIONS[2].y = 1;
	DIRECTIONS[3].x = 0;
	DIRECTIONS[3].y = 1;
	local_3c = 1;
	if ((LVar3 == BLOCK1_NONE) || ((block->flags2 & BLOCK2_UNK_400) != BLOCK2_NONE)) {
		if ((LVar3 == BLOCK1_NONE) && ((block->flags2 & BLOCK2_UNK_400) != BLOCK2_NONE)) {
			unk::Lego_PathLiveLevelsIncrementConditional(0);
			LVar4 = block->flags2 & ~BLOCK2_UNK_400;
			goto LAB_0042f6d5;
		}
	}
	else {
		unk::Lego_PathLiveLevelsIncrementConditional(1);
		LVar4 = block->flags2 | BLOCK2_UNK_400;
LAB_0042f6d5:
		block->flags2 = LVar4;
	}
	iVar2 = (level->dimensions).width;
	pLVar1 = level->blocks;
	local_50 = &local_38;
	uVar10 = 0;
										// Get surrounding blocks for orientation?
	pDir = DIRECTIONS;
	do {
		if (pLVar1[(pDir->y + by) * iVar2 + bx + pDir->x].predug == PREDUG_EXPOSED) {
			local_48.x = (float)((uint)local_48.x & 0xffffff00 | uVar10 & 0xff);
			local_5c += 1;
		}
		else {
			*(char *)&local_50->x = (char)uVar10;
			local_50 = (Point2I *)((int)&local_50->x + 1);
		}
		uVar10 += 1;
		pDir = pDir + 1;
	} while (uVar10 < 4);
	LVar3 = block->flags1;
	LVar5 = LVar3 & ~(BLOCK1_UNK_8|BLOCK1_UNK_10|BLOCK1_UNK_40|BLOCK1_UNK_80|BLOCK1_UNK_2000);
	block->flags1 = LVar5;
	if (local_5c == 4) {
		local_38.x = bx;
		local_38.y = by;
		block->flags1 =
				 LVar3 & ~(BLOCK1_UNK_8|BLOCK1_UNK_10|BLOCK1_REINFORCED|BLOCK1_UNK_40|BLOCK1_UNK_80|
									BLOCK1_UNK_2000) | (BLOCK1_UNK_4|BLOCK1_UNK_8);
		block->field_3 = 0;
		if ((LVar3 & BLOCK1_UNK_8) == BLOCK1_NONE) {
			local_48.x = (float)bx;
			local_48.y = (float)by;
			ai::AITask_Block_FUN_00402a10(&local_38,0);
			Level_Block_LevelStruct1C_DoActivityDestroy(level,(Point2I *)&local_48,TRUE);
			if ((globs::gameGlobs.flags1 & GAME1_ALWAYSROCKFALL) != GAME1_NONE) {
				Message_AddMessageAction
									(MESSAGE_DIG_COMPLETE,0,
									 (uint)(globs::gameGlobs.level)->blocks
												 [((globs::gameGlobs.level)->dimensions).width * by + bx].field_3,
									 (Point2I *)&local_48);
			}
		}
		if ((block->flags1 & BLOCK1_UNK_400000) == BLOCK1_NONE) {
			if ((((((globs::gameGlobs.level)->blocks
							[((globs::gameGlobs.level)->dimensions).width * local_38.y + local_38.x].flags1 &
						 BLOCK1_UNK_400) == BLOCK1_NONE) &&
					 ((*(byte *)&(globs::gameGlobs.level)->blocks
											 [((globs::gameGlobs.level)->dimensions).width * local_38.y + local_38.x].
											 flags2 & 4) == 0)) &&
					((*(byte *)((int)&(globs::gameGlobs.level)->blocks
														[((globs::gameGlobs.level)->dimensions).width * local_38.y + local_38.x]
														.flags1 + 1) & 0x80) == 0)) &&
				 (BVar6 = Construction_Block_FUN_00408fd0(&local_38), BVar6 == 0)) {
				iVar2 = ((globs::gameGlobs.level)->dimensions).width * local_38.y + local_38.x;
				(globs::gameGlobs.level)->blocks[iVar2].flags1 =
						 (globs::gameGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_200000;
				iVar2 = ((globs::gameGlobs.level)->dimensions).width * local_38.y + local_38.x;
				(globs::gameGlobs.level)->blocks[iVar2].flags1 =
						 (globs::gameGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_POWERPATH;
				iVar2 = ((globs::gameGlobs.level)->dimensions).width * local_38.y + local_38.x;
				(globs::gameGlobs.level)->blocks[iVar2].flags1 =
						 (globs::gameGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_40000000;
				LiveManager_InitFlagsToggle_AndClearNumDrained();
				ai::AITask_DoCallbacks_IfAttackPath_FUN_00402970(&local_38);
				util::logf_removed((char *)&local_38);
				iVar2 = 4;
				do {
					ai::AITask_DoClear_AtPosition(&local_38,MESSAGE_CLEAR_COMPLETE);
					iVar2 += -1;
				} while (iVar2 != 0);
				iVar2 = ((globs::gameGlobs.level)->dimensions).width * local_38.y + local_38.x;
				(globs::gameGlobs.level)->blocks[iVar2].flags1 =
						 (globs::gameGlobs.level)->blocks[iVar2].flags1 | BLOCK1_RUBBLE_FULL;
			}
			iVar2 = ((globs::gameGlobs.level)->dimensions).width * local_38.y + local_38.x;
			(globs::gameGlobs.level)->blocks[iVar2].flags1 =
					 (globs::gameGlobs.level)->blocks[iVar2].flags1 | BLOCK1_UNK_400000;
			front::Interface_BackToMain_IfSelectedWall_IsBlockPos(&local_38);
		}
		BVar6 = ElectricFence_Block_FUN_0040e110(level,bx,by);
		ElectricFence_Block_ElecFenceStud_FUN_0040e280(level,bx,by,(uint)(BVar6 != 0));
		if ((block->terrain == TERRAIN_LAVA) ||
			 (LVar3 = block->flags1, (LVar3 & BLOCK1_UNK_80000000) != BLOCK1_NONE)) {
			Erode_Block_FUN_0040ed80(&local_38,TRUE);
			if ((block->flags1 & BLOCK1_UNK_200) == BLOCK1_NONE) {
				if (block->field_7 == 4) {
					block->texture = TEXTURE_LAVA;
					Map3D_Block_FUN_00450c20(level->surfaceMap,bx,by,TRUE);
					if ((block->flags1 & BLOCK1_UNK_4000) == BLOCK1_NONE) {
						if ((int)block->randomness % 3 == 0) {
							local_48.x = 0.1;
							local_48.y = 0.1;
							local_48.z = -1.0;
							pSVar7 = lego::effect::Smoke_CreateSmokeArea
																 (0,bx,by,&local_48,0.6,0.4,0.0,1.0,0.3,0,(int)block->randomness,
																	0x26);
							block->smokeptr_1c = pSVar7;
							block->flags1 = block->flags1 | BLOCK1_UNK_4000;
						}
					}
					else {
						lego::effect::Smoke_Hide(block->smokeptr_1c,FALSE);
					}
				}
				else {
					Map3D_Block_FUN_00450c20(level->surfaceMap,bx,by,FALSE);
					switch(block->field_7) {
					case 0:
						block->texture = TEXTURE_ERODE_LOW;
						break;
					case 1:
						block->texture = TEXTURE_ERODE_MEDIUM;
						break;
					case 2:
						block->texture = TEXTURE_ERODE_HIGH;
						break;
					case 3:
						block->texture = TEXTURE_ERODE_FULL;
					}
				}
			}
			else {
				Map3D_Block_FUN_00450c20(level->surfaceMap,bx,by,FALSE);
				block->texture = TEXTURE_LAVA_NOTHOT;
				if ((block->flags1 & BLOCK1_UNK_4000) != BLOCK1_NONE) {
					lego::effect::Smoke_Hide(block->smokeptr_1c,TRUE);
				}
			}
		}
		else {
			if (block->terrain == TERRAIN_LAKE) {
				block->texture = TEXTURE_WATER;
				Map3D_Block_FUN_00450c20(level->surfaceMap,bx,by,TRUE);
			}
			else {
				if ((LVar3 & BLOCK1_UNK_100000) == BLOCK1_NONE) {
					if ((LVar3 & BLOCK1_POWERPATH) == BLOCK1_NONE) {
						if ((*(byte *)&block->flags2 & BLOCK2_SLUGHOLE_EXPOSED) == 0) {
							if ((LVar3 & BLOCK1_UNK_200000) == BLOCK1_NONE) {
								switch(LVar3 & BLOCK1_RUBBLE_FULL) {
								case BLOCK1_NONE:
									block->texture = TEXTURE_RUBBLE_LOW;
									break;
								case BLOCK1_RUBBLE_LOW:
									block->texture = TEXTURE_RUBBLE_MEDIUM;
									break;
								case BLOCK1_RUBBLE_MEDIUM:
									block->texture = TEXTURE_RUBBLE_HIGH;
									break;
								case BLOCK1_RUBBLE_FULL:
									block->texture = TEXTURE_RUBBLE_FULL;
								}
							}
							else {
								if ((LVar3 & BLOCK1_UNK_40000000) == BLOCK1_NONE) {
									block->texture = TEXTURE_GROUND;
								}
								else {
									block->texture = TEXTURE_PATH_BUILD;
								}
							}
						}
						else {
							block->texture = TEXTURE_SLUGHOLE;
						}
					}
					else {
						uVar10 = FUN_0042f280(bx,by,&block->field_3,block->flags2 & BLOCK2_UNK_100);
						block->texture = (SurfaceTexture)uVar10;
					}
				}
				else {
					if ((block->flags2 & BLOCK2_UNK_100) == BLOCK2_NONE) {
						block->texture = TEXTURE_PLATE;
					}
					else {
						block->texture = TEXTURE_PLATE_POWERED;
					}
				}
			}
		}
		goto switchD_0042fb8d_caseD_4;
	}
	if (local_5c != 2) {
		if ((local_5c != 1) && (local_5c != 3)) {
			if (((LVar3 & BLOCK1_UNK_4) == BLOCK1_NONE) || (block->terrain - 1 < 5)) {
				block->texture = TEXTURE_TUNNEL;
			}
			block->field_3 = 0;
			goto switchD_0042fb8d_caseD_4;
		}
		block->flags1 =
				 LVar3 & ~(BLOCK1_UNK_8|BLOCK1_UNK_10|BLOCK1_REINFORCED|BLOCK1_UNK_40|BLOCK1_UNK_80|
									BLOCK1_UNK_2000) | (BLOCK1_UNK_4|BLOCK1_UNK_10);
		if (local_5c == 1) {
			if (true) {
				if (true) {
					switch(block->terrain) {
					case TERRAIN_IMMOVABLE:
					case TERRAIN_WATER_unused:
						goto switchD_0042fe25_caseD_1;
					case TERRAIN_HARD:
						goto switchD_0042fe25_caseD_2;
					case TERRAIN_MEDIUM:
						goto switchD_0042fe25_caseD_3;
					case TERRAIN_LOOSE:
						goto switchD_0042fe25_caseD_4;
					case TERRAIN_SOIL:
						goto switchD_0042fe25_caseD_5;
					}
				}
			}
			else {
				if (true) {
					switch(block->terrain) {
					case TERRAIN_IMMOVABLE:
					case TERRAIN_WATER_unused:
switchD_0042fe25_caseD_1:
						block->texture = TEXTURE_WALL_C_IMMOVABLE;
						break;
					case TERRAIN_HARD:
switchD_0042fe25_caseD_2:
						block->texture = TEXTURE_WALL_C_HARD;
						break;
					case TERRAIN_MEDIUM:
switchD_0042fe25_caseD_3:
						block->texture = TEXTURE_WALL_C_MEDIUM;
						break;
					case TERRAIN_LOOSE:
switchD_0042fe25_caseD_4:
						block->texture = TEXTURE_WALL_C_LOOSE;
						break;
					case TERRAIN_SOIL:
switchD_0042fe25_caseD_5:
						block->texture = TEXTURE_WALL_C_SOIL;
					}
				}
			}
			block->flags1 =
					 LVar3 & ~(BLOCK1_UNK_8|BLOCK1_UNK_10|BLOCK1_REINFORCED|BLOCK1_UNK_40|BLOCK1_UNK_80|
										BLOCK1_UNK_2000) | (BLOCK1_UNK_4|BLOCK1_UNK_10|BLOCK1_UNK_40);
			local_38.y = by;
			block->field_3 = SUB41(local_48.x,0) + 2U & 3;
			local_38.x = bx;
			Level_Block_LevelStruct1C_DoActivityDestroy(level,&local_38,TRUE);
		}
		else {
			if (local_5c == 3) {
				if (true) {
					if (true) {
						switch(block->terrain) {
						case TERRAIN_IMMOVABLE:
						case TERRAIN_WATER_unused:
							goto switchD_0042febf_caseD_1;
						case TERRAIN_HARD:
							goto switchD_0042febf_caseD_2;
						case TERRAIN_MEDIUM:
							goto switchD_0042febf_caseD_3;
						case TERRAIN_LOOSE:
							goto switchD_0042febf_caseD_4;
						case TERRAIN_SOIL:
							goto switchD_0042febf_caseD_5;
						}
					}
				}
				else {
										// Duplicate code. Unreachable, but contains effects of above switch
					if (true) {
						switch(block->terrain) {
						case TERRAIN_IMMOVABLE:
						case TERRAIN_WATER_unused:
switchD_0042febf_caseD_1:
							block->texture = TEXTURE_WALL_O_IMMOVABLE;
							break;
						case TERRAIN_HARD:
switchD_0042febf_caseD_2:
							block->texture = TEXTURE_WALL_O_HARD;
							break;
						case TERRAIN_MEDIUM:
switchD_0042febf_caseD_3:
							block->texture = TEXTURE_WALL_O_MEDIUM;
							break;
						case TERRAIN_LOOSE:
switchD_0042febf_caseD_4:
							block->texture = TEXTURE_WALL_O_LOOSE;
							break;
						case TERRAIN_SOIL:
switchD_0042febf_caseD_5:
							block->texture = TEXTURE_WALL_O_SOIL;
						}
					}
				}
				local_48.x = (float)bx;
				local_48.y = (float)by;
				Level_Block_LevelStruct1C_DoActivityDestroy(level,(Point2I *)&local_48,TRUE);
				ai::AITask_Block_FUN_00402a60((Point2I *)&local_48);
				block->field_3 = (byte)local_38.x;
				block->flags1 = block->flags1 | BLOCK1_UNK_80;
			}
		}
		surfMap = local_4c;
		Map3D_BlockVertexToWorldPos(local_4c,bx,by,&local_60,&local_60,&local_58);
		Map3D_BlockVertexToWorldPos(surfMap,bx + 1U,by + 1U,&local_60,&local_60,&local_54);
		local_48.x = local_58 - local_54;
		Map3D_BlockVertexToWorldPos(surfMap,bx + 1U,by,&local_60,&local_60,&local_58);
		Map3D_BlockVertexToWorldPos(surfMap,bx,by + 1U,&local_60,&local_60,&local_54);
		Map3D_FUN_0044f0b0(surfMap,bx,by,
											 (uint)((ushort)((ushort)(ABS(local_48.x) < ABS(local_58 - local_54)) << 8 |
																			(ushort)(ABS(local_48.x) == ABS(local_58 - local_54)) << 0xe)
														 == 0));
		local_38.x = bx;
		local_38.y = by;
		Level_Block_LevelStruct1C_DoActivityDestroy(level,&local_38,TRUE);
		goto switchD_0042fb8d_caseD_4;
	}
	DIRECTIONS[0].y = 1;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[0].x = 0;
	DIRECTIONS[3].x = 0;
	DIRECTIONS[2].y = 3;
	DIRECTIONS[3].y = 3;
	uVar10 = 0;
	DIRECTIONS[1].y = 2;
	DIRECTIONS[2].x = 2;
	block->flags1 = LVar5 | (BLOCK1_UNK_4|BLOCK1_UNK_10);
	puVar9 = (uint *)&DIRECTIONS[0].y;
	do {
		if ((puVar9[-1] == (local_38.x & 0xffU)) && (*puVar9 == ((uint)local_38.x >> 8 & 0xff))) {
			bx._0_1_ = (byte)uVar10;
			goto LAB_0042fc43;
		}
		uVar10 += 1;
		puVar9 = puVar9 + 2;
	} while (uVar10 < 6);
LAB_0042fc43:
	if (3 < (byte)bx) {
		if (block->terrain - 1 < 5) {
			block->texture = TEXTURE_WALL_GAP;
		}
		block->flags1 =
				 LVar3 & ~(BLOCK1_RUBBLE_FULL|BLOCK1_UNK_4|BLOCK1_UNK_8|BLOCK1_UNK_10|BLOCK1_REINFORCED|
									 BLOCK1_UNK_40|BLOCK1_UNK_80|BLOCK1_UNK_100|BLOCK1_UNK_200|BLOCK1_UNK_400|
									 BLOCK1_UNK_800|BLOCK1_UNK_1000|BLOCK1_UNK_2000|BLOCK1_UNK_4000|BLOCK1_UNK_8000) |
				 (uint)CONCAT11((char)(LVar5 >> 8),(char)(LVar5 | (BLOCK1_UNK_4|BLOCK1_UNK_10))) |
				 BLOCK1_UNK_2000;
		block->field_3 = (byte)bx - 4;
		Map3D_FUN_0044f0b0(local_4c,bx,by,(byte)((byte)bx - 4) & 1);
		goto switchD_0042fb8d_caseD_4;
	}
	if ((LVar3 & BLOCK1_REINFORCED) == BLOCK1_NONE) {
		if ((int)block->randomness % 10 == 0) {
			if (true) {
				switch(block->terrain) {
				case TERRAIN_IMMOVABLE:
				case TERRAIN_WATER_unused:
					goto switchD_0042fce8_caseD_1;
				case TERRAIN_HARD:
					goto switchD_0042fce8_caseD_2;
				case TERRAIN_MEDIUM:
					goto switchD_0042fce8_caseD_3;
				case TERRAIN_LOOSE:
					goto switchD_0042fce8_caseD_4;
				case TERRAIN_SOIL:
					goto switchD_0042fce8_caseD_5;
				case TERRAIN_ORESEAM:
					goto switchD_0042fce8_caseD_8;
				case TERRAIN_CRYSTALSEAM:
					goto switchD_0042fce8_caseD_a;
				case TERRAIN_RECHARGESEAM:
					goto switchD_0042fce8_caseD_b;
				}
			}
		}
		else {
			if (true) {
				switch(block->terrain) {
				case TERRAIN_IMMOVABLE:
				case TERRAIN_WATER_unused:
switchD_0042fce8_caseD_1:
					block->texture = TEXTURE_WALL_F_IMMOVABLE;
					block->field_3 = (byte)bx;
					goto switchD_0042fb8d_caseD_4;
				case TERRAIN_HARD:
switchD_0042fce8_caseD_2:
					block->texture = TEXTURE_WALL_F_HARD;
					block->field_3 = (byte)bx;
					goto switchD_0042fb8d_caseD_4;
				case TERRAIN_MEDIUM:
switchD_0042fce8_caseD_3:
					block->texture = TEXTURE_WALL_F_MEDIUM;
					block->field_3 = (byte)bx;
					goto switchD_0042fb8d_caseD_4;
				case TERRAIN_LOOSE:
switchD_0042fce8_caseD_4:
					block->texture = TEXTURE_WALL_F_LOOSE;
					block->field_3 = (byte)bx;
					goto switchD_0042fb8d_caseD_4;
				case TERRAIN_SOIL:
switchD_0042fce8_caseD_5:
					block->texture = TEXTURE_WALL_F_SOIL;
					block->field_3 = (byte)bx;
					goto switchD_0042fb8d_caseD_4;
				case TERRAIN_ORESEAM:
switchD_0042fce8_caseD_8:
					block->texture = TEXTURE_WALL_F_ORESEAM;
					block->field_3 = (byte)bx;
					goto switchD_0042fb8d_caseD_4;
				case TERRAIN_CRYSTALSEAM:
switchD_0042fce8_caseD_a:
					block->texture = TEXTURE_WALL_F_CRYSTALSEAM;
					block->field_3 = (byte)bx;
					goto switchD_0042fb8d_caseD_4;
				case TERRAIN_RECHARGESEAM:
switchD_0042fce8_caseD_b:
					block->texture = TEXTURE_WALL_F_RECHARGESEAM;
				}
			}
		}
	}
	else {
		if (true) {
			switch(block->terrain) {
			case TERRAIN_IMMOVABLE:
			case TERRAIN_WATER_unused:
				block->texture = TEXTURE_WALL_R_IMMOVABLE;
				block->field_3 = (byte)bx;
				break;
			case TERRAIN_HARD:
				block->texture = TEXTURE_WALL_R_HARD;
				block->field_3 = (byte)bx;
				break;
			case TERRAIN_MEDIUM:
				block->texture = TEXTURE_WALL_R_MEDIUM;
				block->field_3 = (byte)bx;
				break;
			case TERRAIN_LOOSE:
				block->texture = TEXTURE_WALL_R_LOOSE;
				block->field_3 = (byte)bx;
				break;
			case TERRAIN_SOIL:
				block->texture = TEXTURE_WALL_R_SOIL;
				block->field_3 = (byte)bx;
				break;
			default:
				goto switchD_0042fce8_caseD_6;
			}
			goto switchD_0042fb8d_caseD_4;
		}
	}
switchD_0042fce8_caseD_6:
	block->field_3 = (byte)bx;
switchD_0042fb8d_caseD_4:
	LVar3 = block->flags1;
	if ((((LVar3 & BLOCK1_UNK_4) != BLOCK1_NONE) && ((LVar3 & BLOCK1_UNK_800000) != BLOCK1_NONE)) &&
		 ((block->terrain == TERRAIN_IMMOVABLE ||
			((block->terrain == TERRAIN_WATER_unused || ((LVar3 & BLOCK1_UNK_8) != BLOCK1_NONE)))))) {
		block->flags1 = LVar3 & ~BLOCK1_UNK_800000;
		Map3D_Block_ClearHighlight(level->surfaceMap,bx,by);
	}
	FVar8 = main::Main_GetCLFlags();
	iVar2 = local_3c;
	if ((FVar8 & FEATURE_BLOCKFADEIN) == FEATURE_NONE) {
		iVar2 = 0;
	}
	uVar10 = extraout_ECX & 0xffffff00 | (uint)block->field_3;
	uVar11 = extraout_EDX & 0xffffff00 | (uint)block->texture;
	if (iVar2 == 0) {
		Map3D_UpdateBlockVisual(level->surfaceMap,bx,by,uVar11,uVar10);
	}
	else {
		Map3D_FadeInBlock(level->surfaceMap,bx,by,uVar11,uVar10);
	}
	if (level->UseRoof != BOOL3_FALSE) {
		Level_Block_LowerDigVertices(level,bx,by);
	}
	return;
}



void __cdecl lego::game::Level_Block_Proc_FUN_004301e0(Point2I *blockPos)
{
	LevelBlockFlags1 *pLVar1;
	int iVar2;
	
	pLVar1 = &(globs::gameGlobs.level)->blocks
						[((globs::gameGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags1;
	*pLVar1 = *pLVar1 & ~BLOCK1_POWERPATH;
	iVar2 = ((globs::gameGlobs.level)->dimensions).width * blockPos->y + blockPos->x;
	(globs::gameGlobs.level)->blocks[iVar2].flags1 =
			 (globs::gameGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_40000000;
	LiveManager_InitFlagsToggle_AndClearNumDrained();
	ai::AITask_DoCallbacks_IfAttackPath_FUN_00402970(blockPos);
	util::logf_removed((char *)blockPos);
	return;
}



void __cdecl lego::ai::AITask_DoClearTypeAction(Point2I *position,MessageType completeAction)
{
	BOOL BVar1;
	int iVar2;
	
	if (((((globs::gameGlobs.level)->blocks
				 [((globs::gameGlobs.level)->dimensions).width * position->y + position->x].flags1 &
				BLOCK1_UNK_400) == BLOCK1_NONE) &&
			((*(byte *)&(globs::gameGlobs.level)->blocks
									[((globs::gameGlobs.level)->dimensions).width * position->y + position->x].flags2
			 & 4) == 0)) &&
		 (((globs::gameGlobs.level)->blocks
			 [((globs::gameGlobs.level)->dimensions).width * position->y + position->x].flags1 &
			BLOCK1_UNK_8000) == BLOCK1_NONE)) {
		BVar1 = game::Construction_Block_FUN_00408fd0(position);
		if (BVar1 == 0) {
			iVar2 = ((globs::gameGlobs.level)->dimensions).width * position->y + position->x;
			(globs::gameGlobs.level)->blocks[iVar2].flags1 =
					 (globs::gameGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_200000;
			iVar2 = ((globs::gameGlobs.level)->dimensions).width * position->y + position->x;
			(globs::gameGlobs.level)->blocks[iVar2].flags1 =
					 (globs::gameGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_POWERPATH;
			iVar2 = ((globs::gameGlobs.level)->dimensions).width * position->y + position->x;
			(globs::gameGlobs.level)->blocks[iVar2].flags1 =
					 (globs::gameGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_40000000;
			game::LiveManager_InitFlagsToggle_AndClearNumDrained();
			AITask_DoCallbacks_IfAttackPath_FUN_00402970(position);
			util::logf_removed((char *)position);
			iVar2 = 4;
			do {
				AITask_DoClear_AtPosition(position,completeAction);
				iVar2 += -1;
			} while (iVar2 != 0);
			iVar2 = ((globs::gameGlobs.level)->dimensions).width * position->y + position->x;
			(globs::gameGlobs.level)->blocks[iVar2].flags1 =
					 (globs::gameGlobs.level)->blocks[iVar2].flags1 | BLOCK1_RUBBLE_FULL;
		}
	}
	return;
}



void __cdecl lego::game::Level_FUN_004303a0(LevelData *level,BOOL unused,uint bx,uint by)
{
	undefined4 *puVar1;
	int iVar2;
	
	if ((bx != 0) && (by != 0)) {
		iVar2 = (level->dimensions).width;
		if ((bx < iVar2 - 2U) &&
			 ((by < (level->dimensions).height - 2U &&
				((*(byte *)&level->blocks[by * iVar2 + bx].flags1 & 8) != 0)))) {
			puVar1 = LevelStruct428_FUN_0046eb60(bx,by,NULL);
			if (puVar1 != NULL) {
				iVar2 = by * (level->dimensions).width + bx;
				level->blocks[iVar2].flags1 = level->blocks[iVar2].flags1 & ~BLOCK1_UNK_8;
				iVar2 = by * (level->dimensions).width + bx;
				level->blocks[iVar2].flags1 = level->blocks[iVar2].flags1 | BLOCK1_UNK_10;
				Level_UpdateBlockSurfaceUnk(level,bx,by,0);
				LevelStruct428_FUN_0046e5f0(bx,by);
			}
		}
	}
	return;
}



BOOL __cdecl lego::game::Level_DestroyWall(LevelData *level,int in_x,int in_y,BOOL isHiddenCavern)
{
	int *piVar1;
	LevelBlock *pLVar2;
	LevelBlockFlags1 *pLVar3;
	LevelBlockFlags2 *pLVar4;
	short *psVar5;
	TerrainType TVar6;
	PredugType PVar7;
	SurfaceMap *surfMap;
	LevelBlockFlags1 LVar8;
	LevelBlockFlags2 LVar9;
	int bx;
	int *piVar10;
	int iVar11;
	TutorialFlags TVar12;
	BOOL BVar13;
	uint uVar14;
	int iVar15;
	uint *puVar16;
	uint uVar17;
	InfoType infoType;
	Point2I local_50;
	Point2I local_48;
	int local_40 [5];
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	bx = in_x;
	surfMap = level->surfaceMap;
	local_40[0] = 0;
	local_40[1] = 0;
	local_40[2] = 1;
	local_40[3] = 0;
	local_40[4] = 1;
	local_2c = 1;
	local_28 = 0;
	local_24 = 1;
	if ((((in_x == 0) || (in_y == 0)) ||
			(iVar11 = (level->dimensions).width, iVar11 - 2U <= (uint)in_x)) ||
		 (((level->dimensions).height - 2U <= (uint)in_y ||
			(pLVar2 = level->blocks + in_y * iVar11 + in_x, (*(byte *)&pLVar2->flags1 & 8) != 0)))) {
		return 0;
	}
	if ((pLVar2->terrain == TERRAIN_ORESEAM) || (pLVar2->terrain == TERRAIN_CRYSTALSEAM)) {
		local_48.x = in_x;
		local_48.y = in_y;
		pLVar2->float_14 = 0.0;
		piVar10 = local_40;
		in_x = 4;
		do {
			uVar14 = piVar10[1] + in_y;
			iVar11 = *piVar10;
			iVar15 = uVar14 * (level->dimensions).width + bx + iVar11;
			if (level->blocks[iVar15].predug == PREDUG_WALL) {
				local_50.x = bx;
				local_50.y = in_y;
				level->blocks[iVar15].predug = PREDUG_EXPOSED|PREDUG_HIDDEN_SLUGHOLE;
				TVar6 = level->blocks[in_y * (level->dimensions).width + bx].terrain;
				if ((TVar6 == TERRAIN_ORESEAM) || (TVar6 == TERRAIN_CRYSTALSEAM)) {
					front::Info_FUN_00419ab0(INFO_GENERICSEAMFOUND,NULL,NULL,&local_50);
				}
				TVar6 = level->blocks[in_y * (level->dimensions).width + bx].terrain;
				if (TVar6 == TERRAIN_ORESEAM) {
					infoType = INFO_ORESEAMFOUND;
				}
				else {
					if (TVar6 != TERRAIN_CRYSTALSEAM) goto LAB_00430c0d;
					infoType = INFO_CRYSTALSEAMFOUND;
				}
				front::Info_FUN_00419ab0(infoType,NULL,NULL,&local_50);
			}
LAB_00430c0d:
			PVar7 = level->blocks[uVar14 * (level->dimensions).width + bx + iVar11].predug;
			if (PVar7 != PREDUG_EXPOSED) {
				level->blocks[uVar14 * (level->dimensions).width + bx + iVar11].predug =
						 PVar7 + ~PREDUG_WALL;
				Map3D_Unk_ChangeWallDepth(surfMap,iVar11 + bx,uVar14,level->DigDepth * 0.25);
			}
			piVar10 = piVar10 + 2;
			in_x += -1;
		} while (in_x != 0);
		FUN_00430d20((int *)&local_48);
		psVar5 = (short *)&level->blocks[in_y * (level->dimensions).width + bx].field_0x22;
		*psVar5 = *psVar5 + 1;
		iVar11 = 4;
		if (*(short *)&level->blocks[in_y * (level->dimensions).width + bx].field_0x22 != 4) {
			Level_Block_LowerDigVertices(globs::gameGlobs.level,bx,in_y);
			Construction_FlattenGround(&local_48);
			return 0;
		}
		level->blocks[in_y * (level->dimensions).width + bx].terrain = TERRAIN_SOIL;
		piVar10 = local_40;
		do {
			piVar1 = piVar10 + 1;
			iVar15 = *piVar10;
			piVar10 = piVar10 + 2;
			iVar11 += -1;
			level->blocks[(*piVar1 + in_y) * (level->dimensions).width + bx + iVar15].predug =
					 PREDUG_EXPOSED;
		} while (iVar11 != 0);
		Level_DestroyWall(level,bx,in_y,isHiddenCavern);
	}
	else {
		if (pLVar2->predug == PREDUG_WALL) {
			Map3D_Unk_ChangeWallDepth(surfMap,in_x,in_y,level->DigDepth);
			level->blocks[in_y * (level->dimensions).width + in_x].predug = PREDUG_EXPOSED;
		}
		if (level->blocks[in_y * (level->dimensions).width + 1 + in_x].predug == PREDUG_WALL) {
			Map3D_Unk_ChangeWallDepth(surfMap,in_x + 1,in_y,level->DigDepth);
			level->blocks[in_y * (level->dimensions).width + 1 + in_x].predug = PREDUG_EXPOSED;
		}
		uVar14 = in_y + 1;
		if (level->blocks[uVar14 * (level->dimensions).width + 1 + in_x].predug == PREDUG_WALL) {
			Map3D_Unk_ChangeWallDepth(surfMap,in_x + 1,uVar14,level->DigDepth);
			level->blocks[uVar14 * (level->dimensions).width + 1 + in_x].predug = PREDUG_EXPOSED;
		}
		if (level->blocks[uVar14 * (level->dimensions).width + in_x].predug == PREDUG_WALL) {
			Map3D_Unk_ChangeWallDepth(surfMap,in_x,uVar14,level->DigDepth);
			level->blocks[uVar14 * (level->dimensions).width + in_x].predug = PREDUG_EXPOSED;
		}
		local_40[0] = -1;
		local_40[1] = 0xffffffff;
		local_40[3] = 0xffffffff;
		local_2c = 0xffffffff;
		local_28 = 0xffffffff;
		local_18 = 0xffffffff;
		piVar10 = local_40;
		local_40[2] = 0;
		local_40[4] = 1;
		local_24 = 0;
		local_20 = 1;
		local_1c = 0;
		local_14 = 1;
		local_10 = 0;
		local_c = 1;
		local_8 = 1;
		local_4 = 1;
		in_x = 8;
		do {
			iVar11 = piVar10[1];
			iVar15 = *piVar10;
			pLVar3 = &level->blocks[(iVar11 + in_y) * (level->dimensions).width + bx + iVar15].flags1;
			LVar8 = *pLVar3;
			if ((LVar8 & BLOCK1_UNK_8) == BLOCK1_NONE) {
				*pLVar3 = LVar8 | BLOCK1_UNK_10;
				iVar15 = (iVar11 + in_y) * (level->dimensions).width + bx + iVar15;
				level->blocks[iVar15].flags1 = level->blocks[iVar15].flags1 & 0xfffbffff;
			}
			piVar10 = piVar10 + 2;
			in_x += -1;
		} while (in_x != 0);
		local_48.x = bx;
		local_48.y = in_y;
		pLVar3 = &level->blocks[in_y * (level->dimensions).width + bx].flags1;
		*pLVar3 = *pLVar3 | BLOCK1_UNK_8;
		Level_Block_LevelStruct1C_DoActivityDestroy(level,&local_48,TRUE);
		iVar11 = in_y * (level->dimensions).width + bx;
		level->blocks[iVar11].flags1 = level->blocks[iVar11].flags1 & ~BLOCK1_REINFORCED;
		iVar11 = in_y * (level->dimensions).width + bx;
		level->blocks[iVar11].flags1 = level->blocks[iVar11].flags1 | BLOCK1_UNK_400000;
		LVar8 = level->blocks[in_y * (level->dimensions).width + bx].flags1;
		if ((((LVar8 & BLOCK1_EXPOSED) == BLOCK1_NONE) || ((LVar8 & BLOCK1_HIDDEN) != BLOCK1_NONE)) &&
			 ((LVar8 & BLOCK1_UNK_800000) != BLOCK1_NONE)) {
			unk::Lego_DecFloat_00555adc();
		}
		if (isHiddenCavern == 0) {
			uVar14 = in_y - 1;
			local_48.x = bx;
			local_48.y = in_y;
			if (uVar14 <= in_y + 1U) {
				do {
					puVar16 = (uint *)(bx - 1);
					if (puVar16 <= (uint *)(bx + 1U)) {
						do {
							if ((*(byte *)((int)&level->blocks
																	 [(int)(uVar14 * (level->dimensions).width + (int)puVar16)].flags1
														+ 2) & 2) != 0) {
								FUN_004314b0(puVar16,uVar14);
								TVar12 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
								if (TVar12 == TUTORIAL_NONE) {
									front::Info_FUN_00419ab0(INFO_CAVERNLOCATED,NULL,NULL,&local_48);
									front::Text_DisplayMessage(TEXT_CAVERNDISCOVERED,1,0);
									unk::Lego_DecFloat_00555efc();
								}
							}
							puVar16 = (uint *)((int)puVar16 + 1);
						} while (puVar16 <= (uint *)(bx + 1U));
					}
					uVar14 += 1;
				} while (uVar14 <= in_y + 1U);
			}
			iVar11 = ((globs::gameGlobs.level)->dimensions).width * in_y + bx;
			(globs::gameGlobs.level)->blocks[iVar11].flags1 =
					 (globs::gameGlobs.level)->blocks[iVar11].flags1 | BLOCK1_UNK_800;
			Message_AddMessageAction
								(MESSAGE_DIG_COMPLETE,0,
								 (uint)(globs::gameGlobs.level)->blocks
											 [((globs::gameGlobs.level)->dimensions).width * in_y + bx].field_3,&local_48)
			;
			LevelStruct428_FUN_0046e4e0(level,bx,in_y);
			local_50.x = bx;
			local_50.y = in_y;
			if (((((globs::gameGlobs.level)->blocks
						 [((globs::gameGlobs.level)->dimensions).width * in_y + bx].flags1 & BLOCK1_UNK_400) ==
						BLOCK1_NONE) &&
					((*(byte *)&(globs::gameGlobs.level)->blocks
											[((globs::gameGlobs.level)->dimensions).width * in_y + bx].flags2 & 4) == 0))
				 && ((((globs::gameGlobs.level)->blocks
							 [((globs::gameGlobs.level)->dimensions).width * in_y + bx].flags1 & BLOCK1_UNK_8000)
							== BLOCK1_NONE && (BVar13 = Construction_Block_FUN_00408fd0(&local_50), BVar13 == 0)))
				 ) {
				iVar11 = ((globs::gameGlobs.level)->dimensions).width * local_50.y + local_50.x;
				(globs::gameGlobs.level)->blocks[iVar11].flags1 =
						 (globs::gameGlobs.level)->blocks[iVar11].flags1 & ~BLOCK1_UNK_200000;
				iVar11 = ((globs::gameGlobs.level)->dimensions).width * local_50.y + local_50.x;
				(globs::gameGlobs.level)->blocks[iVar11].flags1 =
						 (globs::gameGlobs.level)->blocks[iVar11].flags1 & ~BLOCK1_POWERPATH;
				iVar11 = ((globs::gameGlobs.level)->dimensions).width * local_50.y + local_50.x;
				(globs::gameGlobs.level)->blocks[iVar11].flags1 =
						 (globs::gameGlobs.level)->blocks[iVar11].flags1 & ~BLOCK1_UNK_40000000;
				LiveManager_InitFlagsToggle_AndClearNumDrained();
				ai::AITask_DoCallbacks_IfAttackPath_FUN_00402970(&local_50);
				util::logf_removed((char *)&local_50);
				iVar11 = 4;
				do {
					ai::AITask_DoClear_AtPosition(&local_50,MESSAGE_CLEAR_COMPLETE);
					iVar11 += -1;
				} while (iVar11 != 0);
				iVar11 = ((globs::gameGlobs.level)->dimensions).width * local_50.y + local_50.x;
				(globs::gameGlobs.level)->blocks[iVar11].flags1 =
						 (globs::gameGlobs.level)->blocks[iVar11].flags1 | BLOCK1_RUBBLE_FULL;
			}
			front::Interface_BackToMain_IfSelectedWall_IsBlockPos(&local_50);
		}
		else {
			pLVar3 = &level->blocks[in_y * (level->dimensions).width + bx].flags1;
			*pLVar3 = *pLVar3 | BLOCK1_UNK_200000;
		}
		local_48.x = bx;
		local_48.y = in_y;
		ai::AITask_Block_FUN_00402a10(&local_48,0);
		uVar14 = in_y - 1;
		if (uVar14 < in_y + 2U) {
			do {
				uVar17 = bx - 1;
				if (uVar17 < bx + 2U) {
					do {
						Level_UpdateBlockSurfaceUnk(level,uVar17,uVar14,isHiddenCavern);
						uVar17 += 1;
					} while (uVar17 < bx + 2U);
				}
				uVar14 += 1;
			} while (uVar14 < in_y + 2U);
		}
		iVar11 = in_y * (level->dimensions).width + bx;
		level->blocks[iVar11].flags1 = level->blocks[iVar11].flags1 & ~BLOCK1_UNK_800000;
		uVar14 = in_y - 1;
		if (uVar14 <= in_y + 2U) {
			do {
				uVar17 = bx - 1;
				if (uVar17 <= bx + 2U) {
					do {
						Map3D_SetFlags2_AndStruct28_SetFlag19_4(surfMap,uVar17,uVar14);
						uVar17 += 1;
					} while (uVar17 <= bx + 2U);
				}
				uVar14 += 1;
			} while (uVar14 <= in_y + 2U);
		}
		if ((isHiddenCavern == 0) && ((globs::gameGlobs.flags2 & GAME2_GENERATESPIDERS) != GAME2_NONE))
		{
			uVar14 = SEXT24(level->blocks[in_y * (level->dimensions).width + bx].randomness);
			uVar17 = (int)uVar14 >> 0x1f;
			if (((uVar14 ^ uVar17) - uVar17 & 3 ^ uVar17) == uVar17) {
				Level_GenerateSmallSpiders(bx,in_y,(int)uVar14 % 0x549);
			}
		}
		local_50.x = bx;
		local_50.y = in_y;
		LiveManager_HiddenStruct2C_FUN_00437c00(&local_50);
		pLVar4 = &level->blocks[in_y * (level->dimensions).width + bx].flags2;
		LVar9 = *pLVar4;
		if ((LVar9 & BLOCK2_SLUGHOLE_HIDDEN) != BLOCK2_NONE) {
			*pLVar4 = LVar9 & ~BLOCK2_SLUGHOLE_HIDDEN;
			iVar11 = in_y * (level->dimensions).width + bx;
			level->blocks[iVar11].flags2 = level->blocks[iVar11].flags2 | BLOCK2_SLUGHOLE_EXPOSED;
			Level_RegisterSlimySlugHole(&local_50);
			Level_UpdateBlockSurfaceUnk(level,bx,in_y,0);
		}
		if (isHiddenCavern == 0) {
			front::Info_FUN_00419ab0(INFO_WALLDUG,NULL,NULL,&local_50);
			return 1;
		}
	}
	return 1;
}



void __cdecl FUN_00430d20(int *param_1)
{
	TerrainType TVar1;
	int iVar2;
	int iVar3;
	int iVar4;
	int *piVar5;
	uint uVar6;
	Point2I local_28;
	int local_20 [8];
	
	uVar6 = 0;
	local_20[1] = 0xffffffff;
	local_20[6] = 0xffffffff;
	local_20[2] = 1;
	local_20[5] = 1;
	iVar2 = param_1[1];
	iVar3 = *param_1;
	local_20[0] = 0;
	local_20[3] = 0;
	local_20[4] = 0;
	local_20[7] = 0;
	piVar5 = local_20;
	do {
		iVar4 = (piVar5[1] + iVar2) * ((lego::globs::gameGlobs.level)->dimensions).width + iVar3 +
						*piVar5;
		if ((((*(byte *)&(lego::globs::gameGlobs.level)->blocks[iVar4].flags1 & 8) != 0) &&
				(TVar1 = (lego::globs::gameGlobs.level)->blocks[iVar4].terrain, TVar1 != TERRAIN_LAKE)) &&
			 (TVar1 != TERRAIN_LAVA)) break;
		uVar6 += 1;
		piVar5 = piVar5 + 2;
	} while (uVar6 < 4);
	if (uVar6 != 4) {
		local_28.y = local_20[uVar6 * 2 + 1] + iVar2;
		local_28.x = local_20[uVar6 * 2] + iVar3;
		TVar1 = (lego::globs::gameGlobs.level)->blocks
						[iVar2 * ((lego::globs::gameGlobs.level)->dimensions).width + iVar3].terrain;
		if (TVar1 == TERRAIN_ORESEAM) {
			lego::game::Level_GenerateOre(&local_28,0,NULL,1);
			return;
		}
		if (TVar1 == TERRAIN_CRYSTALSEAM) {
			lego::game::Level_GenerateCrystal(&local_28,0,NULL,1);
		}
	}
	return;
}



BOOL __cdecl lego::game::Level_DestroyWallConnection(LevelData *level,uint x,uint y)
{
	int *piVar1;
	Size2I *pSVar2;
	LevelBlock **ppLVar3;
	LevelBlockFlags1 *pLVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	int *piVar8;
	int iVar9;
	uint uVar10;
	Point2I local_28;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar6 = x;
	local_28.x = (int)level->surfaceMap;
	local_20[0] = -1;
	local_20[1] = 0xffffffff;
	local_20[2] = 0;
	local_20[3] = 0xffffffff;
	local_20[4] = 0;
	local_c = 0;
	local_8 = 0xffffffff;
	local_4 = 0;
	if ((((x != 0) && (y != 0)) && (iVar9 = (level->dimensions).width, x < iVar9 - 2U)) &&
		 (y < (level->dimensions).height - 2U)) {
		if (level->blocks[y * iVar9 + x].predug == PREDUG_WALL) {
			Map3D_Unk_ChangeWallDepth((SurfaceMap *)local_28.x,x,y,level->DigDepth);
			iVar9 = 4;
			level->blocks[y * (level->dimensions).width + x].predug = PREDUG_EXPOSED;
			piVar8 = local_20 + 1;
			do {
				piVar1 = piVar8 + -1;
				iVar5 = *piVar8;
				piVar8 = piVar8 + 2;
				pLVar4 = &level->blocks[(y + iVar5) * (level->dimensions).width + *piVar1 + x].flags1;
				iVar9 += -1;
				*pLVar4 = *pLVar4 | 0x40000;
			} while (iVar9 != 0);
			for (uVar7 = y - 1; uVar7 <= y; uVar7 += 1) {
				for (uVar10 = x - 1; uVar10 <= x; uVar10 += 1) {
					Level_UpdateBlockSurfaceUnk(level,uVar10,uVar7,0);
				}
			}
			uVar7 = y - 1;
			if (uVar7 <= y + 1) {
				do {
					uVar10 = x - 1;
					if (uVar10 <= x + 1) {
						do {
							Map3D_SetFlags2_AndStruct28_SetFlag19_4((SurfaceMap *)local_28.x,uVar10,uVar7);
							uVar10 += 1;
						} while (uVar10 <= x + 1);
					}
					uVar7 += 1;
				} while (uVar7 <= y + 1);
			}
			pSVar2 = &level->dimensions;
			ppLVar3 = &level->blocks;
			uVar7 = 0;
			local_20[2] = 1;
			local_c = 1;
			local_28.x = x;
			local_28.y = y;
			level = NULL;
			local_20[0] = 0;
			local_20[1] = 0xffffffff;
			local_20[3] = 0;
			local_20[4] = 0;
			local_8 = 0xffffffff;
			local_4 = 0;
			piVar8 = local_20;
			do {
				if ((*ppLVar3)[(piVar8[1] + y) * pSVar2->width + uVar6 + *piVar8].predug == PREDUG_EXPOSED)
				{
					level = (LevelData *)((int)&level->levelName + 1);
					x = uVar7;
				}
				uVar7 += 1;
				piVar8 = piVar8 + 2;
			} while (uVar7 < 4);
			if (level == (LevelData *)0x1) {
				Message_AddMessageAction(MESSAGE_DIG_COMPLETE,0,x - 2 & 3 | 0x10000,&local_28);
			}
			ai::AITask_Block_FUN_00402a10(&local_28,1);
		}
		return 1;
	}
	return 0;
}



void __cdecl lego::game::Block_RemoveReinforcement(Point2I *blockPos)
{
	LevelData *level;
	int iVar1;
	
	level = globs::gameGlobs.level;
	Level_Block_LevelStruct1C_DoActivityDestroy(globs::gameGlobs.level,blockPos,FALSE);
	iVar1 = (level->dimensions).width * blockPos->y + blockPos->x;
	level->blocks[iVar1].flags1 = level->blocks[iVar1].flags1 & ~BLOCK1_REINFORCED;
	Level_UpdateBlockSurfaceUnk(level,blockPos->x,blockPos->y,0);
	return;
}



void __cdecl lego::game::Level_Block_Reinforce(int bx,int by)
{
	LevelData *level;
	Point2I blockPos;
	LevelBlockFlags1 flags1;
	LevelBlockFlags1 *pFlags1;
	
	level = globs::gameGlobs.level;
	pFlags1 = &(globs::gameGlobs.level)->blocks
						 [((globs::gameGlobs.level)->dimensions).width * by + bx].flags1;
	flags1 = *pFlags1;
	if (((flags1 & BLOCK1_UNK_10) != BLOCK1_NONE) &&
		 ((flags1 & (BLOCK1_REINFORCED|BLOCK1_UNK_40|BLOCK1_UNK_80)) == BLOCK1_NONE)) {
		*pFlags1 = flags1 | BLOCK1_REINFORCED;
		Level_UpdateBlockSurfaceUnk(level,bx,by,0);
		blockPos.x = bx;
		blockPos.y = by;
		res::Level_LevelStruct1C_Create_Res_Unk_RechargeSparkle(level,&blockPos,0);
		ai::AITask_Block_FUN_00402a60(&blockPos);
		front::Info_FUN_00419ab0(INFO_WALLREINFORCED,NULL,NULL,&blockPos);
	}
	return;
}



void __cdecl
lego::res::Level_LevelStruct1C_Create_Res_Unk_RechargeSparkle
					(LevelData *level,Point2I *blockPos,BOOL bool18)
{
	int iVar1;
	LevelStruct_1c *pLVar2;
	Container *pCVar3;
	uint uVar4;
	LevelStruct_1c *pLVar5;
	float10 fVar6;
	float local_3c;
	float local_38;
	float local_34;
	float local_30 [4];
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	pCVar3 = globs::gameGlobs.RES_RechargeSparkle;
	iVar1 = blockPos->y * (level->dimensions).width + blockPos->x;
	local_30[0] = 0.0;
	local_30[1] = 1.0;
	local_30[2] = 0.0;
	uVar4 = (uint)level->blocks[iVar1].field_3;
	local_30[3] = 1.0;
	local_20 = 0;
	local_1c = 0;
	local_18 = 0;
	local_14 = 0xbf800000;
	local_10 = 0;
	local_c = 0xbf800000;
	local_8 = 0;
	local_4 = 0;
	if (bool18 != 0) {
		pLVar2 = level->blocks[iVar1].struct1c_18;
		if (pLVar2 == NULL) {
			pLVar2 = (LevelStruct_1c *)std::malloc(0x1c);
			pLVar5 = pLVar2;
			for (iVar1 = 7; iVar1 != 0; iVar1 += -1) {
				pLVar5->resData = NULL;
				pLVar5 = (LevelStruct_1c *)&pLVar5->blockPos;
			}
			pLVar2->bool_18 = bool18;
			pCVar3 = Container_Clone(pCVar3);
			pLVar2->resData = pCVar3;
			if (pLVar2->bool_18 == 0) {
				Container_SetActivity(pCVar3,"Activity_Build");
			}
			Container_SetAnimationTime(pLVar2->resData,0.0);
			(pLVar2->blockPos).x = blockPos->x;
										// (pLVar2->blockPos).y = blockPos->y;  WTF Ghidra
			*(int *)&pLVar2->blockPos = blockPos->y;
			pLVar2->next = NULL;
			pLVar5 = level->terrain1c_88;
			pLVar2->previous = pLVar5;
			if (pLVar5 != NULL) {
				pLVar5->next = pLVar2;
			}
			level->terrain1c_88 = pLVar2;
			level->blocks[blockPos->y * (level->dimensions).width + blockPos->x].struct1c_18 = pLVar2;
		}
		game::Map3D_BlockToWorldPos(level->surfaceMap,blockPos->x,blockPos->y,&local_3c,&local_38);
		fVar6 = game::Map3D_GetWorldZ(level->surfaceMap,local_3c,local_38);
		local_34 = (float)fVar6;
		Container_SetPosition(pLVar2->resData,NULL,local_3c,local_38,local_34);
		Container_SetOrientation
							(pLVar2->resData,NULL,local_30[uVar4 * 3],local_30[uVar4 * 3 + 1],
							 local_30[uVar4 * 3 + 2],0.0,0.0,-1.0);
	}
	return;
}



void __cdecl lego::game::Level_LevelStruct1C_FUN_004312e0(LevelData *level,float elapsedGame)
{
	byte bVar1;
	LevelStruct_1c *pLVar2;
	LevelStruct_1c *pLVar3;
	float10 fVar4;
	
	pLVar2 = level->terrain1c_88;
	while (pLVar3 = pLVar2, pLVar3 != NULL) {
		pLVar2 = pLVar3->previous;
		fVar4 = res::Container_MoveAnimation(pLVar3->resData,elapsedGame);
		if (pLVar3->bool_18 == 0) {
			bVar1 = *(byte *)&pLVar3->flags;
			if (((bVar1 & 1) == 0) && ((float)fVar4 != 0.0)) {
				*(byte *)&pLVar3->flags = bVar1 | 1;
				res::Container_SetActivity(pLVar3->resData,"Activity_Stand");
			}
			else {
				if ((bVar1 & 2) == 0) {
					if (((bVar1 & 4) != 0) && ((float)fVar4 != 0.0)) {
						*(byte *)&pLVar3->flags = bVar1 | 2;
					}
				}
				else {
					Level_Remove_LevelStruct1C_AndFree(pLVar3);
				}
			}
		}
	}
	return;
}



void __cdecl
lego::game::Level_Block_LevelStruct1C_DoActivityDestroy
					(LevelData *level,Point2I *blockPos,BOOL requireNotBool18)
{
	LevelStruct_1c *pLVar1;
	
	pLVar1 = level->blocks[(level->dimensions).width * blockPos->y + blockPos->x].struct1c_18;
	if (pLVar1 != NULL) {
		if ((requireNotBool18 == 0) && (pLVar1->bool_18 == 0)) {
			res::Container_SetActivity(pLVar1->resData,"Activity_Destroy");
			res::Container_SetAnimationTime(pLVar1->resData,0.0);
			*(byte *)&pLVar1->flags = *(byte *)&pLVar1->flags | 4;
			return;
		}
		*(byte *)&pLVar1->flags = *(byte *)&pLVar1->flags | 2;
	}
	return;
}



void __cdecl lego::game::Level_Remove_LevelStruct1C_AndFree(LevelStruct_1c *param_1)
{
	LevelData *level;
	
	level = globs::gameGlobs.level;
	res::Container_Remove(param_1->resData);
	level->blocks[(param_1->blockPos).y * (level->dimensions).width + (param_1->blockPos).x].
	struct1c_18 = NULL;
	if (param_1->next == NULL) {
		level->terrain1c_88 = param_1->previous;
	}
	else {
		param_1->next->previous = param_1->previous;
	}
	if (param_1->previous != NULL) {
		param_1->previous->next = param_1->next;
	}
	std::free(param_1);
	return;
}



void __cdecl lego::game::Level_FreeAll_LevelStruct1Cs_FUN_00431460(LevelData *level)
{
	LevelStruct_1c *pLVar1;
	LevelStruct_1c *pLVar2;
	
	pLVar2 = level->terrain1c_88;
	while (pLVar2 != NULL) {
		pLVar1 = pLVar2->previous;
		Level_Remove_LevelStruct1C_AndFree(pLVar2);
		pLVar2 = pLVar1;
	}
	return;
}



LevelData * __cdecl lego::game::GetLevel(void)
{
	return globs::gameGlobs.level;
}



SurfaceMap * __cdecl lego::game::GetSurfaceMap(void)
{
	LevelData *pLVar1;
	
	pLVar1 = GetLevel();
	return pLVar1->surfaceMap;
}



void __cdecl FUN_004314b0(uint *param_1,uint param_2)
{
	int iVar1;
	float fVar2;
	float fVar3;
	uint uVar4;
	int in_x;
	LevelData *level;
	float *pfVar5;
	int iVar6;
	int iVar7;
	uint uVar8;
	uint uVar9;
	int iVar10;
	float *pfVar11;
	longlong lVar12;
	uint local_2c;
	uint local_10 [2];
	float *local_8 [2];
	
	level = lego::globs::gameGlobs.level;
	iVar10 = ((lego::globs::gameGlobs.level)->dimensions).height +
					 ((lego::globs::gameGlobs.level)->dimensions).width;
	local_10[0] = 0;
	local_10[1] = 0;
	uVar9 = 0;
	pfVar5 = (float *)std::malloc(iVar10 * 0x20);
	local_8[0] = pfVar5;
	if (pfVar5 != NULL) {
		local_8[1] = pfVar5 + iVar10 * 4;
		*pfVar5 = (float)ZEXT48(param_1);
		param_1 = local_10;
		local_10[0] = 1;
		iVar10 = 0;
		pfVar5[1] = (float)(ulonglong)param_2;
		do {
			local_2c = 0;
			if (*param_1 != 0) {
				pfVar11 = *(float **)((int)local_8 + iVar10);
				do {
					fVar2 = pfVar11[1];
					fVar3 = *pfVar11;
					lVar12 = __ftol((float10)fVar2);
					iVar10 = (int)lVar12 + -1;
					iVar6 = (int)lVar12 + 1;
					if (iVar10 <= iVar6) {
						lVar12 = __ftol((float10)fVar3);
						iVar1 = (int)lVar12 + -1;
						in_x = iVar1;
						do {
							for (; in_x <= (int)lVar12 + 1; in_x = in_x + 1) {
								if ((level->blocks[iVar10 * (level->dimensions).width + in_x].flags1 & BLOCK1_HIDDEN
										) != BLOCK1_NONE) {
									lego::game::Level_DestroyWall(level,in_x,iVar10,1);
									iVar7 = iVar10 * (level->dimensions).width + in_x;
									level->blocks[iVar7].flags1 = level->blocks[iVar7].flags1 & ~BLOCK1_HIDDEN;
									if ((fVar3 != (float)in_x) || ((float)iVar10 != fVar2)) {
										uVar8 = (uint)(uVar9 == 0);
										uVar4 = local_10[uVar8];
										pfVar5 = local_8[uVar8];
										pfVar5[uVar4 * 2] = (float)in_x;
										local_10[uVar8] = uVar4 + 1;
										pfVar5[uVar4 * 2 + 1] = (float)iVar10;
									}
								}
							}
							iVar10 += 1;
							in_x = iVar1;
						} while (iVar10 <= iVar6);
					}
					local_2c += 1;
					pfVar11 = pfVar11 + 2;
					pfVar5 = local_8[0];
				} while (local_2c < *param_1);
			}
			uVar9 = (uint)(uVar9 == 0);
			*param_1 = 0;
			iVar10 = uVar9 * 4;
			param_1 = local_10 + uVar9;
		} while (local_10[uVar9] != 0);
		std::free(pfVar5);
	}
	return;
}



void __cdecl lego::game::Game_PTL_RockFall(uint bx,uint by,int param_3,BOOL param_4)
{
	LevelBlockFlags1 *pLVar1;
	LevelBlock *pLVar2;
	int iVar3;
	BOOL BVar4;
	float *pfVar5;
	bool bVar6;
	float10 fVar7;
	float10 extraout_ST0;
	longlong lVar8;
	longlong lVar9;
	float dirX;
	float fVar10;
	float local_40;
	undefined4 uStack60;
	uint local_38;
	float local_34;
	undefined4 uStack48;
	Vector3F local_2c;
	float local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uStack60 = 0;
	fVar7 = (float10)(ulonglong)by;
	uStack48 = 0;
	local_38 = 0;
	local_34 = (float)(ulonglong)bx;
	pLVar2 = (globs::gameGlobs.level)->blocks;
	iVar3 = ((globs::gameGlobs.level)->dimensions).width;
	local_20[0] = 1.0;
	local_20[1] = 0.0;
	local_20[2] = 0.0;
	local_20[3] = 1.0;
	local_20[4] = -1.0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0xbf800000;
	pfVar5 = local_20;
										// local_40 = 4;
	local_40 = 5.605194e-45;
	do {
		*pfVar5 = local_34 + *pfVar5;
		fVar10 = pfVar5[1];
		pfVar5[1] = (float)(fVar7 + (float10)fVar10);
		lVar8 = __ftol(fVar7 + (float10)fVar10);
		lVar9 = __ftol((float10)*pfVar5);
		if ((*(byte *)&pLVar2[iVar3 * (int)lVar8 + (int)lVar9].flags1 & 8) != 0) {
			local_38 += 1;
		}
		pfVar5 = pfVar5 + 2;
		local_40 = (float)((int)local_40 + -1);
		fVar7 = extraout_ST0;
	} while (local_40 != 0.0);
	if ((float)param_4 == 0.0) {
		Map3D_BlockToWorldPos((globs::gameGlobs.level)->surfaceMap,bx,by,&local_40,(float *)&param_4);
	}
	else {
		Map3D_BlockVertexToWorldPos
							((globs::gameGlobs.level)->surfaceMap,bx,by,&local_40,(float *)&param_4,&local_34);
	}
	local_2c.y = (float)param_4;
	local_2c.x = local_40;
	fVar7 = Map3D_GetWorldZ((globs::gameGlobs.level)->surfaceMap,local_40,(float)param_4);
	local_2c.z = (float)fVar7;
	res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(NULL,SFX_ROCKBREAK,0,0,&local_2c);
	bVar6 = 1 < local_38;
	local_20[0] = 0.0;
	local_20[1] = 1.0;
	local_20[2] = 1.0;
	local_20[3] = 0.0;
	local_20[4] = 0.0;
	local_c = 0xbf800000;
	local_8 = 0xbf800000;
	local_4 = 0;
	fVar10 = local_20[param_3 * 2 + 1];
	dirX = local_20[param_3 * 2];
	fVar7 = Map3D_GetWorldZ((globs::gameGlobs.level)->surfaceMap,local_40,(float)param_4);
	BVar4 = lego::effect::Effect_Spawn_RockFall
										((uint)bVar6,bx,by,local_40,param_4,(float)fVar7,dirX,fVar10);
	if (BVar4 != 0) {
		pLVar1 = &(globs::gameGlobs.level)->blocks
							[((globs::gameGlobs.level)->dimensions).width * by + bx].flags1;
		*pLVar1 = *pLVar1 | BLOCK1_UNK_800;
	}
	return;
}



SurfaceType __cdecl lego::game::Level_GetBlockTerrain(int bx,int by)
{
	return (uint)(globs::gameGlobs.level)->blocks
							 [((globs::gameGlobs.level)->dimensions).width * by + bx].terrain;
}



uint __cdecl lego::game::MapShared_GetBlock(uint memHandle,int bx,int by)
{
	MapFileInfo *mapFile;
	int local_4;
	uint sharedIndex_00;
	
	sharedIndex_00 = memHandle;
	mapFile = (MapFileInfo *)lego::file::Mem_AddressHandle(memHandle);
	MapShared_GetDimensions(sharedIndex_00,(int *)&memHandle,&local_4);
	return (uint)mapFile->blocks[memHandle * by + bx];
}



BOOL __cdecl
lego::game::Level_FindSelectedUnit_BlockCheck_FUN_00431960(uint bx,uint by,BOOL param_3)
{
	LiveObject **pLiveObj;
	BOOL BVar1;
	uint local_8;
	uint numSelected;
	
	pLiveObj = Message_GetSelectedUnits(&numSelected);
	if ((pLiveObj != NULL) && (local_8 = 0, numSelected != 0)) {
		do {
			BVar1 = LiveObject_Check_FUN_004326a0(*pLiveObj,bx,by,param_3,TRUE);
			if (BVar1 != 0) {
				return TRUE;
			}
			local_8 += 1;
			pLiveObj = pLiveObj + 1;
		} while (local_8 < numSelected);
		return 0;
	}
	return 0;
}



BOOL __cdecl lego::game::Level_FindSelectedLiveObject_Block_FUN_004319e0(uint bx,uint by)
{
	LiveObject **ppLVar1;
	BOOL BVar2;
	uint uVar3;
	uint local_4;
	
	ppLVar1 = Message_GetSelectedUnits(&local_4);
	if ((ppLVar1 != NULL) && (uVar3 = 0, local_4 != 0)) {
		do {
			BVar2 = LiveObject_CheckLevel_FUN_00432950(*ppLVar1,bx,by);
			if (BVar2 != 0) {
				return TRUE;
			}
			uVar3 += 1;
			ppLVar1 = ppLVar1 + 1;
		} while (uVar3 < local_4);
		return 0;
	}
	return 0;
}



BOOL __cdecl lego::game::Level_FUN_00431a50(int bx,int by,int param_3,int param_4)
{
	LevelBlock *pLVar1;
	LevelBlockFlags1 LVar2;
	int iVar3;
	BOOL BVar4;
	int *piVar5;
	uint uVar6;
	Point2I local_28;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_28.y = by;
	iVar3 = ((globs::gameGlobs.level)->dimensions).width * by + bx;
	local_28.x = bx;
	pLVar1 = (globs::gameGlobs.level)->blocks + iVar3;
	if ((*(byte *)&(globs::gameGlobs.level)->blocks[iVar3].flags2 & BLOCK2_SLUGHOLE_EXPOSED) == 0) {
		BVar4 = Construction_Block_FUN_00408fd0(&local_28);
		if ((BVar4 == 0) && (LVar2 = pLVar1->flags1, (LVar2 & BLOCK1_POWERPATH) == BLOCK1_NONE)) {
			uVar6 = 0;
			if (((param_3 == 0) || ((param_4 == 0 || (pLVar1->terrain == TERRAIN_LAKE)))) &&
				 (((param_3 == 0 || ((LVar2 & BLOCK1_UNK_8000) == BLOCK1_NONE)) &&
					((((param_4 != 0 || (pLVar1->terrain != TERRAIN_LAKE)) &&
						(pLVar1->terrain != TERRAIN_LAVA)) &&
					 ((((LVar2 & BLOCK1_UNK_8) != BLOCK1_NONE && ((LVar2 & BLOCK1_UNK_200000) != BLOCK1_NONE))
						&& ((LVar2 & (BLOCK1_UNK_400|BLOCK1_UNK_8000|BLOCK1_UNK_100000)) == BLOCK1_NONE))))))))
			{
				BVar4 = ElectricFence_BlockCheck_FUN_0040e390(bx,by);
				if (BVar4 == 0) {
					local_20[1] = 0xffffffff;
					local_8 = 0xffffffff;
					local_20[0] = 0;
					local_20[2] = 1;
					local_20[3] = 0;
					local_20[4] = 0;
					local_c = 1;
					local_4 = 0;
					piVar5 = local_20;
					while ((globs::gameGlobs.level)->blocks
								 [(piVar5[1] + by) * ((globs::gameGlobs.level)->dimensions).width + bx + *piVar5].
								 terrain != TERRAIN_RECHARGESEAM) {
						uVar6 += 1;
						piVar5 = piVar5 + 2;
						if (3 < uVar6) {
							return TRUE;
						}
					}
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_FUN_00431ba0
					(LiveObject *liveObj,Point2I *param_2,Point2I *out_point,BOOL param_4)
{
	LevelBlockFlags1 LVar1;
	bool bVar2;
	uint uVar3;
	int iVar4;
	uint uVar5;
	int iVar6;
	LevelData *pLVar7;
	uint uVar8;
	uint local_24;
	int local_20 [4];
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_20[1] = 0xffffffff;
	local_8 = 0xffffffff;
										// static variable used only in this function
	Direction_004df588 += DIRECTION_RIGHT;
	local_20[0] = 0;
	local_20[2] = 1;
	local_20[3] = 0;
	local_10 = 0;
	local_c = 1;
	local_4 = 0;
	local_24 = 0;
	pLVar7 = globs::gameGlobs.level;
	do {
		uVar8 = Direction_004df588 + local_24 & 3;
		if (param_4 == 0) {
LAB_00431c58:
			iVar4 = local_20[uVar8 * 2 + 1] + param_2->y;
			iVar6 = local_20[uVar8 * 2] + param_2->x;
			iVar4 = LiveObject_FUN_00431cd0(liveObj,iVar6,iVar4,iVar6,iVar4,0);
			pLVar7 = globs::gameGlobs.level;
			if (iVar4 != 0) {
				iVar4 = local_20[uVar8 * 2 + 1];
				out_point->x = local_20[uVar8 * 2] + param_2->x;
				out_point->y = iVar4 + param_2->y;
				return TRUE;
			}
		}
		else {
			uVar5 = local_20[uVar8 * 2] + param_2->x;
			iVar4 = (pLVar7->dimensions).width;
			uVar3 = local_20[uVar8 * 2 + 1] + param_2->y;
			if ((((uVar5 < iVar4 - 1U) && (uVar3 < (pLVar7->dimensions).height - 1U)) &&
					(LVar1 = pLVar7->blocks[uVar3 * iVar4 + uVar5].flags1,
					(LVar1 & BLOCK1_UNK_10) != BLOCK1_NONE)) && ((LVar1 & BLOCK1_UNK_8) == BLOCK1_NONE)) {
				bVar2 = true;
			}
			else {
				bVar2 = false;
			}
			if (!bVar2) goto LAB_00431c58;
		}
		local_24 += 1;
		if (3 < local_24) {
			return 0;
		}
	} while( true );
}



int __cdecl
lego::game::LiveObject_FUN_00431cd0
					(LiveObject *in_liveObj,int param_2,int param_3,int param_4,int param_5,BOOL param_6)
{
	int iVar1;
	LevelBlockFlags1 LVar2;
	LevelBlock *pLVar3;
	LevelData *pLVar4;
	LiveObject *liveObj;
	int iVar5;
	ObjectStatsFlags1 OVar6;
	int *piVar7;
	BOOL BVar8;
	int iVar9;
	ObjectStatsFlags1 OVar10;
	LevelBlockFlags1 LVar11;
	ObjectStatsFlags2 local_40;
	ObjectStatsFlags1 local_3c;
	ObjectStatsFlags3 local_38;
	ObjectStatsFlags1 local_34;
	int local_30;
	int local_2c;
	LevelBlock *local_28;
	LevelBlock *local_24;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	iVar5 = param_3;
	liveObj = in_liveObj;
	pLVar4 = globs::gameGlobs.level;
	iVar1 = ((globs::gameGlobs.level)->dimensions).width;
	OVar10 = STATS1_NONE;
	local_3c = STATS1_SINGLEWIDTHDIG;
	local_40 = STATS2_NONE;
	local_38 = STATS3_NONE;
	local_28 = (globs::gameGlobs.level)->blocks + param_3 * iVar1 + param_2;
	local_20[0] = 0;
	local_20[3] = 0;
	local_24 = (globs::gameGlobs.level)->blocks + param_5 * iVar1 + param_4;
	param_3 = 1;
	local_20[1] = 0xffffffff;
	local_20[2] = 1;
	local_20[4] = 0;
	local_c = 1;
	local_8 = 0xffffffff;
	local_4 = 0;
	if (((in_liveObj != NULL) &&
			(OVar6 = LiveObject_GetStatsFlags1(in_liveObj), (OVar6 & STATS1_CANBEDRIVEN) != STATS1_NONE))
		 && (in_liveObj->drivenObject == NULL)) {
		return 0;
	}
	in_liveObj = NULL;
	piVar7 = local_20 + 1;
	do {
		if ((piVar7[-1] + param_4 == param_2) && (param_5 + *piVar7 == iVar5)) break;
		piVar7 = piVar7 + 2;
		in_liveObj = (LiveObject *)((int)&in_liveObj->objType + 1);
	} while (in_liveObj < (LiveObject *)&DAT_00000004);
	if (liveObj == NULL) {
		local_34 = STATS1_NONE;
	}
	else {
		if (liveObj->objType == OBJECT_ELECTRICFENCE) {
			return 0;
		}
		local_38 = LiveObject_GetStatsFlags3(liveObj);
		local_38 &= STATS3_ENTERTOOLSTORE;
		local_34 = LiveObject_GetStatsFlags1(liveObj);
		local_34 &= STATS1_SINGLEWIDTHDIG;
		OVar10 = LiveObject_GetStatsFlags1(liveObj);
		OVar10 &= STATS1_CROSSWATER;
		local_3c = LiveObject_GetStatsFlags1(liveObj);
		local_3c &= STATS1_CROSSLAND;
		local_40 = LiveObject_GetStatsFlags2(liveObj);
		local_40 &= STATS2_CROSSLAVA;
		if (((param_6 == 0) && (BVar8 = LiveObject_GetBlockPos(liveObj,&local_30,&local_2c), BVar8 != 0)
				) && ((param_2 == local_30 && (iVar5 == local_2c)))) {
			return 1;
		}
	}
	if (local_28->terrain == TERRAIN_LAKE) {
		if (OVar10 == STATS1_NONE) {
			return 0;
		}
		if (true) goto LAB_00431ea3;
	}
	if (local_3c == STATS1_NONE) {
		return 0;
	}
LAB_00431ea3:
	if (((local_28->terrain == TERRAIN_LAVA) && (local_40 == STATS2_NONE)) &&
		 ((local_28->flags1 & BLOCK1_UNK_200) == BLOCK1_NONE)) {
		return 0;
	}
	LVar2 = local_28->flags1;
	if ((LVar2 & BLOCK1_UNK_400) != BLOCK1_NONE) {
		return 0;
	}
	if ((param_6 != 0) && ((LVar2 & BLOCK1_UNK_40) != BLOCK1_NONE)) {
		return 0;
	}
	if ((local_38 == STATS3_NONE) && ((*(byte *)&local_28->flags2 & 4) != 0)) {
		return 0;
	}
	if (local_34 == STATS1_NONE) {
		if ((LVar2 & BLOCK1_UNK_8) == BLOCK1_NONE) {
			return 0;
		}
	}
	else {
		if ((LVar2 & BLOCK1_UNK_10) != BLOCK1_NONE) {
			param_3 = 3;
		}
		if (local_28->predug == PREDUG_WALL) {
			return 0;
		}
		iVar1 = (pLVar4->dimensions).width;
		pLVar3 = pLVar4->blocks;
		iVar9 = iVar5 * iVar1 + param_2;
		LVar11 = pLVar3[iVar9].flags1 & BLOCK1_UNK_10;
		if (LVar11 != BLOCK1_NONE) {
			if ((pLVar3 + iVar9)[-1].terrain == TERRAIN_LAVA) {
				return 0;
			}
			if (pLVar3[(iVar5 + -1) * iVar1 + param_2].terrain == TERRAIN_LAVA) {
				return 0;
			}
		}
		if (LVar11 != BLOCK1_NONE) {
			if ((pLVar3 + iVar9)[-1].terrain == TERRAIN_WATER_unused) {
				return 0;
			}
			if (pLVar3[(iVar5 + -1) * iVar1 + param_2].terrain == TERRAIN_WATER_unused) {
				return 0;
			}
		}
		if (in_liveObj == NULL) {
			if ((LVar2 & BLOCK1_UNK_2000) != BLOCK1_NONE) {
				param_3 = 2;
			}
			if ((local_24->flags1 & BLOCK1_UNK_2000) != BLOCK1_NONE) {
				param_3 = 2;
			}
		}
	}
	if ((param_4 != param_2) && (param_5 != iVar5)) {
		iVar1 = (pLVar4->dimensions).width;
		if (((*(byte *)&pLVar4->blocks[param_5 * iVar1 + param_2].flags1 & 8) != 0) &&
			 ((*(byte *)&pLVar4->blocks[iVar5 * iVar1 + param_4].flags1 & 8) != 0)) {
			return 2;
		}
	}
	return param_3;
}



void __cdecl lego::game::Level_Block_FUN_00432030(Point2I *blockPos)
{
	LevelData *level;
	LevelBlockFlags2 *flags2;
	
	level = globs::gameGlobs.level;
	flags2 = &(globs::gameGlobs.level)->blocks
						[((globs::gameGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags2;
	*flags2 = *flags2 | BLOCK2_UNK_100;
	globs::gameGlobs.points2x100_78c[globs::gameGlobs.pointsCount2_dcc[0]].x = blockPos->x;
	globs::gameGlobs.points2x100_78c[globs::gameGlobs.pointsCount2_dcc[0]].y = blockPos->y;
	globs::gameGlobs.pointsCount2_dcc[0] += 1;
	Level_UpdateBlockSurfaceUnk(level,blockPos->x,blockPos->y,0);
	return;
}



BOOL __cdecl lego::game::Level_BlockHasFlag2_100(Point2I *blockPos)
{
	return (globs::gameGlobs.level)->blocks
				 [blockPos->y * ((globs::gameGlobs.level)->dimensions).width + blockPos->x].flags2 &
				 BLOCK2_UNK_100;
}



void __cdecl lego::game::Game_UpdateLevelBlocks_PointsAAC(void)
{
	int by;
	int bx;
	LevelData *level;
	uint uVar1;
	Point2I (*paPVar2) [100];
	
	level = globs::gameGlobs.level;
	uVar1 = 0;
	if (globs::gameGlobs.pointsCount2_dcc[1] != 0) {
		paPVar2 = globs::gameGlobs.points2x100_78c[1];
		do {
			by = (*paPVar2)[0].y;
			bx = (*paPVar2)[0].x;
			if ((*(byte *)((int)&level->blocks[(level->dimensions).width * by + bx].flags2 + 1) & 1) == 0)
			{
				Level_UpdateBlockSurfaceUnk(level,bx,by,0);
			}
			uVar1 += 1;
			paPVar2 = (Point2I (*) [100])(*paPVar2 + 1);
		} while (uVar1 < globs::gameGlobs.pointsCount2_dcc[1]);
	}
	globs::gameGlobs.pointsCount2_dcc[1] = 0;
	return;
}



void __cdecl lego::game::Game_LevelClearBlockFlag2_100_Points28C(void)
{
	LevelBlockFlags2 *pLVar1;
	Point2I *pPVar2;
	Point2I *pPVar3;
	Point2I (*paPVar4) [100];
	uint uVar5;
	LevelData *level;
	
	level = globs::gameGlobs.level;
	uVar5 = 0;
	globs::gameGlobs.pointsCount2_dcc[1] = globs::gameGlobs.pointsCount2_dcc[0];
	if (globs::gameGlobs.pointsCount2_dcc[0] != 0) {
		paPVar4 = globs::gameGlobs.points2x100_78c;
		do {
			paPVar4[1][0].x = (*paPVar4)[0].x;
			paPVar4[1][0].y = (*paPVar4)[0].y;
			pPVar2 = *paPVar4;
			pPVar3 = *paPVar4;
			paPVar4 = (Point2I (*) [100])(*paPVar4 + 1);
			pLVar1 = &level->blocks[pPVar2->y * (level->dimensions).width + pPVar3->x].flags2;
			uVar5 += 1;
			*pLVar1 = *pLVar1 & ~BLOCK2_UNK_100;
			globs::gameGlobs.pointsCount2_dcc[1] = globs::gameGlobs.pointsCount2_dcc[0];
		} while (uVar5 < globs::gameGlobs.pointsCount2_dcc[0]);
	}
	globs::gameGlobs.pointsCount2_dcc[0] = 0;
	return;
}



void __cdecl lego::game::Level_AddBlockToGameTable_AndSetFlag2_2(Point2I *blockPos)
{
	LevelBlockFlags2 *pLVar1;
	
	pLVar1 = &(globs::gameGlobs.level)->blocks
						[((globs::gameGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags2;
	*pLVar1 = *pLVar1 | BLOCK2_UNK_2;
	globs::gameGlobs.blockPts_468[globs::gameGlobs.blockPtsCount_788].x = blockPos->x;
	globs::gameGlobs.blockPts_468[globs::gameGlobs.blockPtsCount_788].y = blockPos->y;
	globs::gameGlobs.blockPtsCount_788 = globs::gameGlobs.blockPtsCount_788 + 1;
	return;
}



BOOL __cdecl lego::game::Level_IsBlockFlag2_2(Point2I *blockPos)
{
	return (globs::gameGlobs.level)->blocks
				 [((globs::gameGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags2 &
				 BLOCK2_UNK_2;
}



void __cdecl lego::game::Game_UnkProcessBlockPtsTable_UnsetsFlag2_2(void)
{
	int *piVar1;
	LevelBlockFlags2 *pLVar2;
	int *piVar3;
	LevelData *pLVar4;
	Point2I *pPVar5;
	uint uVar6;
	
	pLVar4 = globs::gameGlobs.level;
	uVar6 = 0;
	if (globs::gameGlobs.blockPtsCount_788 != 0) {
		pPVar5 = globs::gameGlobs.blockPts_468;
		do {
			piVar1 = &pPVar5->y;
			piVar3 = &pPVar5->x;
			pPVar5 = pPVar5 + 1;
			pLVar2 = &pLVar4->blocks[*piVar1 * (pLVar4->dimensions).width + *piVar3].flags2;
			uVar6 += 1;
			*pLVar2 = *pLVar2 & ~BLOCK2_UNK_2;
		} while (uVar6 < globs::gameGlobs.blockPtsCount_788);
	}
	globs::gameGlobs.blockPtsCount_788 = 0;
	return;
}



void __cdecl
lego::game::Level_Block_UnsetFlags1_108400PwrPath_AndUnsetFlags2_4_UpdateSurface(Point2I *blockPos)
{
	LevelData *level;
	LevelBlockFlags2 *pFlags2;
	LevelBlockFlags1 *pFlags1;
	
	level = globs::gameGlobs.level;
	pFlags1 = &(globs::gameGlobs.level)->blocks
						 [((globs::gameGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags1;
	*pFlags1 = *pFlags1 & ~(BLOCK1_UNK_400|BLOCK1_UNK_8000|BLOCK1_UNK_100000|BLOCK1_POWERPATH);
	pFlags2 = &level->blocks[(level->dimensions).width * blockPos->y + blockPos->x].flags2;
	*pFlags2 = *pFlags2 & ~BLOCK2_UNK_4;
	Level_UpdateBlockSurfaceUnk(level,blockPos->x,blockPos->y,0);
	return;
}



void __cdecl lego::game::Level_Block_UnsetFlags2_1(Point2I *blockPos)
{
	LevelBlockFlags2 *pFlags2;
	
	pFlags2 = &(globs::gameGlobs.level)->blocks
						 [blockPos->y * ((globs::gameGlobs.level)->dimensions).width + blockPos->x].flags2;
	*pFlags2 = *pFlags2 & ~BLOCK2_UNK_1;
	return;
}



void __cdecl FUN_00432320(int **param_1)
{
	LevelBlockFlags1 *pLVar1;
	LevelBlockFlags2 *pLVar2;
	LevelData *level;
	
	level = lego::globs::gameGlobs.level;
	pLVar1 = &(lego::globs::gameGlobs.level)->blocks
						[(int)(((lego::globs::gameGlobs.level)->dimensions).width * (int)param_1[1] +
									(int)*param_1)].flags1;
	*pLVar1 = *pLVar1 | (BLOCK1_UNK_8000|BLOCK1_UNK_100000);
	pLVar2 = &level->blocks[(int)((level->dimensions).width * (int)param_1[1] + (int)*param_1)].flags2
	;
	*pLVar2 = *pLVar2 | BLOCK2_UNK_4;
	lego::game::Level_UpdateBlockSurfaceUnk(level,(int)*param_1,(int)param_1[1],0);
	return;
}



void __cdecl FUN_00432380(int *param_1,int *param_2)
{
	LevelBlockFlags1 *pLVar1;
	LevelData *level;
	
	level = lego::globs::gameGlobs.level;
	pLVar1 = &(lego::globs::gameGlobs.level)->blocks
						[(int)(((lego::globs::gameGlobs.level)->dimensions).width * (int)param_2 + (int)param_1)
						].flags1;
	*pLVar1 = *pLVar1 | (BLOCK1_UNK_400|BLOCK1_UNK_100000);
	lego::game::Level_UpdateBlockSurfaceUnk(level,(int)param_1,(int)param_2,0);
	return;
}



void __cdecl FUN_004323c0(int *param_1,int *param_2)
{
	LevelBlockFlags1 *pLVar1;
	LevelData *level;
	
	level = lego::globs::gameGlobs.level;
	pLVar1 = &(lego::globs::gameGlobs.level)->blocks
						[(int)(((lego::globs::gameGlobs.level)->dimensions).width * (int)param_2 + (int)param_1)
						].flags1;
	*pLVar1 = *pLVar1 | (BLOCK1_UNK_8000|BLOCK1_UNK_100000|BLOCK1_POWERPATH);
	lego::game::Level_UpdateBlockSurfaceUnk(level,(int)param_1,(int)param_2,0);
	return;
}



void __cdecl lego::game::Level_SetBlockFlag8(int x,int y,BOOL state)
{
	LevelBlockFlags2 *pLVar1;
	int iVar2;
	
	iVar2 = ((globs::gameGlobs.level)->dimensions).width;
	if (state != 0) {
		pLVar1 = &(globs::gameGlobs.level)->blocks[iVar2 * y + x].flags2;
		*pLVar1 = *pLVar1 | 8;
		return;
	}
	iVar2 = iVar2 * y + x;
	(globs::gameGlobs.level)->blocks[iVar2].flags2 =
			 (globs::gameGlobs.level)->blocks[iVar2].flags2 & 0xfffffff7;
	return;
}



uint __cdecl FUN_00432450(int param_1,int param_2)
{
	return (lego::globs::gameGlobs.level)->blocks
				 [((lego::globs::gameGlobs.level)->dimensions).width * param_2 + param_1].flags2 & 8;
}



undefined4 __cdecl lego::util::return_1(undefined4 param_1)
{
	return 1;
}



void __cdecl lego::game::Level_Block_Proc_FUN_00432490(Point2I *position,BOOL param_2)
{
	int iVar1;
	LevelData *level;
	LevelBlockFlags1 *pLVar2;
	LevelBlockFlags1 LVar3;
	
	level = globs::gameGlobs.level;
	iVar1 = ((globs::gameGlobs.level)->dimensions).width;
	if (param_2 == 0) {
		pLVar2 = &(globs::gameGlobs.level)->blocks[iVar1 * position->y + position->x].flags1;
		LVar3 = *pLVar2 & ~BLOCK1_UNK_40000000;
	}
	else {
		pLVar2 = &(globs::gameGlobs.level)->blocks[iVar1 * position->y + position->x].flags1;
		LVar3 = *pLVar2 | BLOCK1_UNK_40000000;
	}
	*pLVar2 = LVar3;
	Level_UpdateBlockSurfaceUnk(level,position->x,position->y,0);
	return;
}



void __cdecl FUN_00432500(int *param_1)
{
	LevelBlockFlags2 *pLVar1;
	
	pLVar1 = &(lego::globs::gameGlobs.level)->blocks
						[param_1[1] * ((lego::globs::gameGlobs.level)->dimensions).width + *param_1].flags2;
	*pLVar1 = *pLVar1 | BLOCK2_UNK_1;
	return;
}



BOOL __cdecl lego::game::Level_Block_FUN_00432530(Point2I *blockPos)
{
	LevelData *level;
	int idx;
	int dir;
	Point2I *pDir;
	Point2I DIRECTIONS_I5 [5];
	LevelBlock *block;
	LevelBlockFlags1 flags1;
	
	level = globs::gameGlobs.level;
	idx = ((globs::gameGlobs.level)->dimensions).width * blockPos->y + blockPos->x;
	block = (globs::gameGlobs.level)->blocks + idx;
	flags1 = (globs::gameGlobs.level)->blocks[idx].flags1;
	if (((flags1 & BLOCK1_UNK_200000) != BLOCK1_NONE) && (block->terrain != TERRAIN_LAVA)) {
		DIRECTIONS_I5[0].x = 0;
		DIRECTIONS_I5[0].y = 0;
		DIRECTIONS_I5[1].x = 0;
		DIRECTIONS_I5[1].y = -1;
		DIRECTIONS_I5[2].x = 1;
		DIRECTIONS_I5[2].y = 0;
		DIRECTIONS_I5[3].x = 0;
		DIRECTIONS_I5[3].y = 1;
		DIRECTIONS_I5[4].x = -1;
		DIRECTIONS_I5[4].y = 0;
		if ((flags1 & BLOCK1_UNK_80000000) == BLOCK1_NONE) {
			block->flags1 = flags1 | BLOCK1_POWERPATH;
		}
		else {
			Erode_Block_FUN_0040ed80(blockPos,0);
			level->blocks[(level->dimensions).width * blockPos->y + blockPos->x].field_7 = 0;
		}
		idx = (level->dimensions).width * blockPos->y + blockPos->x;
		pDir = DIRECTIONS_I5;
		dir = 5;
		level->blocks[idx].flags1 = level->blocks[idx].flags1 & ~BLOCK1_UNK_40000000;
		do {
			Level_UpdateBlockSurfaceUnk(level,blockPos->x + pDir->x,pDir->y + blockPos->y,0);
			pDir = pDir + 1;
			dir += -1;
		} while (dir != 0);
		LiveManager_InitFlagsToggle_AndClearNumDrained();
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::Level_BlockSetter_FUN_00432640(Point2I *blockPos,BOOL condition)
{
	LevelBlockFlags1 *pLVar1;
	int iVar2;
	
	iVar2 = ((globs::gameGlobs.level)->dimensions).width;
	if (condition != 0) {
		pLVar1 = &(globs::gameGlobs.level)->blocks[iVar2 * blockPos->y + blockPos->x].flags1;
		*pLVar1 = *pLVar1 | BLOCK1_UNK_80000;
		return;
	}
	iVar2 = iVar2 * blockPos->y + blockPos->x;
	(globs::gameGlobs.level)->blocks[iVar2].flags1 =
			 (globs::gameGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_80000;
	return;
}



BOOL __cdecl
lego::game::LiveObject_Check_FUN_004326a0
					(LiveObject *liveObj,uint bx,uint by,BOOL param_4,BOOL param_5)
{
	LevelBlock *pLVar1;
	TerrainType TVar2;
	int iVar3;
	LevelData *pLVar4;
	ObjectStatsFlags1 OVar5;
	int *piVar6;
	uint uVar7;
	float10 fVar8;
	int local_40 [5];
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	pLVar4 = globs::gameGlobs.level;
	pLVar1 = (globs::gameGlobs.level)->blocks + by * ((globs::gameGlobs.level)->dimensions).width + bx
	;
	OVar5 = LiveObject_GetStatsFlags1(liveObj);
	if (((OVar5 & STATS1_CANBEDRIVEN) == STATS1_NONE) || (liveObj->drivenObject != NULL)) {
		if ((param_4 != 0) &&
			 (OVar5 = LiveObject_GetStatsFlags1(liveObj), (OVar5 & STATS1_SINGLEWIDTHDIG) == STATS1_NONE))
		{
			return 0;
		}
		if (((((param_5 == 0) || ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE)) &&
				 ((*(byte *)&liveObj->flags3 & 2) != 0)) &&
				((fVar8 = LiveObject_GetDrillTimeType(liveObj,(uint)pLVar1->terrain), fVar8 != (float10)0.0
				 && (iVar3 = (pLVar4->dimensions).width, bx < iVar3 - 2U)))) &&
			 (by < (pLVar4->dimensions).height - 2U)) {
			uVar7 = 0;
			if (param_4 == 0) {
				if ((((pLVar1->flags1 & BLOCK1_UNK_10) != BLOCK1_NONE) &&
						((pLVar1->flags1 & BLOCK1_UNK_40) == BLOCK1_NONE)) &&
					 ((TVar2 = pLVar1->terrain, TVar2 != TERRAIN_IMMOVABLE &&
						((TVar2 != TERRAIN_WATER_unused && (TVar2 != TERRAIN_RECHARGESEAM)))))) {
					return 1;
				}
			}
			else {
				if (pLVar1->predug == PREDUG_WALL) {
					local_40[2] = 1;
					local_2c = 1;
					local_20[0] = -1;
					local_20[1] = 0xffffffff;
					local_20[2] = 0;
					local_20[3] = 0xffffffff;
					local_20[4] = 0;
					local_c = 0;
					local_8 = 0xffffffff;
					local_4 = 0;
					local_40[0] = 0;
					local_40[1] = 0xffffffff;
					local_40[3] = 0;
					local_40[4] = 0;
					local_28 = 0xffffffff;
					local_24 = 0;
					piVar6 = local_40;
					do {
						if (pLVar4->blocks[(piVar6[1] + by) * iVar3 + bx + *piVar6].predug != PREDUG_WALL)
						break;
						uVar7 += 1;
						piVar6 = piVar6 + 2;
					} while (uVar7 < 4);
					if (uVar7 < 4) {
						uVar7 = 0;
						piVar6 = local_20;
						do {
							TVar2 = pLVar4->blocks[(piVar6[1] + by) * iVar3 + bx + *piVar6].terrain;
							if ((TVar2 != TERRAIN_IMMOVABLE) && (TVar2 != TERRAIN_WATER_unused)) break;
							uVar7 += 1;
							piVar6 = piVar6 + 2;
						} while (uVar7 < 4);
						if (uVar7 < 4) {
							return TRUE;
						}
					}
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_00432880(LiveObject *liveObj,uint bx,uint by)
{
	int idx;
	LevelBlockFlags1 flags1;
	int width;
	TerrainType terrain;
	
	if (((((liveObj->flags3 & LIVEOBJ3_UNK_8000) != LIVEOBJ3_NONE) && (bx != 0)) && (by != 0)) &&
		 ((width = ((globs::gameGlobs.level)->dimensions).width, bx < width - 2U &&
			(by < ((globs::gameGlobs.level)->dimensions).height - 2U)))) {
		idx = by * width + bx;
		flags1 = (globs::gameGlobs.level)->blocks[idx].flags1;
		if (((((flags1 & BLOCK1_UNK_10) != BLOCK1_NONE) &&
				 (((flags1 & BLOCK1_UNK_40) == BLOCK1_NONE &&
					(terrain = (globs::gameGlobs.level)->blocks[idx].terrain, terrain != TERRAIN_IMMOVABLE))))
				&& (terrain != TERRAIN_RECHARGESEAM)) && (terrain != TERRAIN_WATER_unused)) {
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Level_BlockCheck_FUN_00432900(LiveObject *liveObj,uint bx,uint by)
{
	BOOL BVar1;
	LevelData *level;
	
	level = globs::gameGlobs.level;
	BVar1 = Map3D_IsInsideDimensions((globs::gameGlobs.level)->surfaceMap,bx,by);
										// GHIDRA WARNING: DO NOT TRY TO EQUATE THIS FLAG 0x8!!
										//   It causes Ghidra to fail decompilation... -_-
	if ((BVar1 != 0) &&
		 ((*(byte *)&level->blocks[(level->dimensions).width * by + bx].flags1 & 8) != 0)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_CheckLevel_FUN_00432950(LiveObject *liveObj,uint bx,uint by)
{
	TerrainType TVar1;
	LevelBlockFlags1 LVar2;
	int width;
	
	if (((((liveObj == NULL) || ((*(byte *)&liveObj->flags3 & LIVEOBJ3_UNK_4) != 0)) && (bx != 0)) &&
			((by != 0 && (width = ((globs::gameGlobs.level)->dimensions).width, bx < width - 2U)))) &&
		 (by < ((globs::gameGlobs.level)->dimensions).height - 2U)) {
		LVar2 = (globs::gameGlobs.level)->blocks[by * width + bx].flags1;
		if ((((LVar2 & BLOCK1_UNK_10) != BLOCK1_NONE) && ((LVar2 & BLOCK1_REINFORCED) == BLOCK1_NONE))
			 && ((TVar1 = (globs::gameGlobs.level)->blocks[by * width + bx].terrain,
					 TVar1 != TERRAIN_RECHARGESEAM &&
					 ((TVar1 != TERRAIN_ORESEAM && (TVar1 != TERRAIN_CRYSTALSEAM)))))) {
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::Level_BlockIsFlags1_400_AndOptIsFlags2_4(int bx,int by,BOOL alsoCheckFlags2_4)
{
	int width;
	
	width = ((globs::gameGlobs.level)->dimensions).width;
	if (alsoCheckFlags2_4 == 0) {
		return (globs::gameGlobs.level)->blocks[width * by + bx].flags1 & BLOCK1_UNK_400;
	}
	if ((((globs::gameGlobs.level)->blocks[width * by + bx].flags1 & BLOCK1_UNK_400) == BLOCK1_NONE)
		 && ((*(byte *)&(globs::gameGlobs.level)->blocks[width * by + bx].flags2 & BLOCK2_UNK_4) == 0))
	{
										// return FALSE;
		return BLOCK1_NONE;
	}
										// return TRUE;
	return BLOCK1_RUBBLE_LOW;
}



BOOL __cdecl lego::game::Level_BlockIsFlags1_800(uint bx,uint by)
{
	int width;
	
	width = ((globs::gameGlobs.level)->dimensions).width;
	if ((bx < width - 1U) && (by < ((globs::gameGlobs.level)->dimensions).height - 1U)) {
		return (globs::gameGlobs.level)->blocks[by * width + bx].flags1 & BLOCK1_UNK_800;
	}
	return BLOCK1_NONE;
}



BOOL __cdecl lego::game::Level_BlockIsFlags1_8(uint bx,uint by)
{
	int width;
	
	width = ((globs::gameGlobs.level)->dimensions).width;
	if ((bx < width - 1U) && (by < ((globs::gameGlobs.level)->dimensions).height - 1U)) {
		return (globs::gameGlobs.level)->blocks[by * width + bx].flags1 & BLOCK1_UNK_8;
	}
	return BLOCK1_NONE;
}



undefined4 __cdecl FUN_00432ac0(int param_1,int param_2)
{
	TerrainType TVar1;
	
	TVar1 = (lego::globs::gameGlobs.level)->blocks
					[((lego::globs::gameGlobs.level)->dimensions).width * param_2 + param_1].terrain;
	if (((TVar1 != TERRAIN_ORESEAM) && (TVar1 != TERRAIN_CRYSTALSEAM)) &&
		 (TVar1 != TERRAIN_RECHARGESEAM)) {
		return 0;
	}
	return 1;
}



BOOL __cdecl lego::game::Level_GetBlockFlags1_10Not8(uint bx,uint by)
{
	int width;
	LevelBlockFlags1 flags1;
	
	width = ((globs::gameGlobs.level)->dimensions).width;
	if ((((bx < width - 1U) && (by < ((globs::gameGlobs.level)->dimensions).height - 1U)) &&
			(flags1 = (globs::gameGlobs.level)->blocks[by * width + bx].flags1,
			(flags1 & BLOCK1_UNK_10) != BLOCK1_NONE)) && ((flags1 & BLOCK1_UNK_8) == BLOCK1_NONE)) {
		return TRUE;
	}
	return 0;
}



uint __cdecl FUN_00432b50(int param_1,int param_2)
{
	return (lego::globs::gameGlobs.level)->blocks
				 [((lego::globs::gameGlobs.level)->dimensions).width * param_2 + param_1].flags1 & 0x40000;
}



int __cdecl lego::game::Level_GetBlockRubbleLevel_OrFlag200000(Point2I *position)
{
	LevelBlockFlags1 LVar1;
	
	LVar1 = (globs::gameGlobs.level)->blocks
					[((globs::gameGlobs.level)->dimensions).width * position->y + position->x].flags1;
	if ((LVar1 & BLOCK1_UNK_200000) != BLOCK1_NONE) {
		return 0;
	}
	return (LVar1 & BLOCK1_RUBBLE_FULL) + BLOCK1_RUBBLE_LOW;
}



BOOL __cdecl lego::game::Level_BlockProc_FUN_00432bc0(Point2I *blockPos)
{
	LevelBlock *pLVar1;
	LevelBlockFlags1 LVar2;
	LevelData *level;
	int iVar3;
	LevelBlockFlags1 LVar4;
	uint uVar5;
	float10 fVar6;
	Vector3F local_18;
	Vector3F local_c;
	
	level = globs::gameGlobs.level;
	uVar5 = 1;
	iVar3 = ((globs::gameGlobs.level)->dimensions).width * blockPos->y + blockPos->x;
	pLVar1 = (globs::gameGlobs.level)->blocks + iVar3;
	LVar2 = (globs::gameGlobs.level)->blocks[iVar3].flags1;
	LVar4 = LVar2 & BLOCK1_RUBBLE_FULL;
	if ((LVar2 & BLOCK1_UNK_200000) == BLOCK1_NONE) {
		if (LVar4 != BLOCK1_NONE) {
			pLVar1->flags1 = (LVar4 + ~BLOCK1_NONE ^ LVar2) & BLOCK1_RUBBLE_FULL ^ LVar2;
		}
		else {
			pLVar1->flags1 = LVar2 | BLOCK1_UNK_200000;
			front::Info_DoAll_FUN_00419820(blockPos);
			front::Interface_IfSelectedRubble_IsBlockPos(blockPos);
			ai::AITask_DoCallbacks_Block_FUN_00402a90(blockPos,FALSE);
			Map3D_BlockToWorldPos
								(level->surfaceMap,blockPos->x,blockPos->y,(float *)&local_18,&local_18.y);
			fVar6 = Map3D_GetWorldZ(level->surfaceMap,local_18.x,local_18.y);
			local_18.z = (float)fVar6;
			math::Maths_Vector3DRandom(&local_c);
			local_c.z = 0.0;
			lego::effect::Effect_Spawn_Particle(MISCOBJECT_PATHDUST,&local_18,&local_c);
		}
		uVar5 = (uint)(LVar4 == BLOCK1_NONE);
		Level_UpdateBlockSurfaceUnk(level,blockPos->x,blockPos->y,0);
	}
	return uVar5;
}



BOOL __cdecl lego::game::Level_Block_IsReinforced(uint bx,uint by)
{
	int width;
	
	width = ((globs::gameGlobs.level)->dimensions).width;
	if ((bx < width - 1U) && (by < ((globs::gameGlobs.level)->dimensions).height - 1U)) {
		return (globs::gameGlobs.level)->blocks[by * width + bx].flags1 & BLOCK1_REINFORCED;
	}
	return BLOCK1_NONE;
}



uint __cdecl lego::game::Level_GetBlockFlags1_8000000(Point2I *position)
{
	return (globs::gameGlobs.level)->blocks
				 [position->y * ((globs::gameGlobs.level)->dimensions).width + position->x].flags1 &
				 BLOCK1_UNK_8000000;
}



void __cdecl lego::game::Level_Block_SetFlags1_8000000(Point2I *blockPos,BOOL state)
{
	LevelBlockFlags1 *pLVar1;
	int iVar2;
	
	iVar2 = ((globs::gameGlobs.level)->dimensions).width;
	if (state != 0) {
		pLVar1 = &(globs::gameGlobs.level)->blocks[iVar2 * blockPos->y + blockPos->x].flags1;
		*pLVar1 = *pLVar1 | BLOCK1_UNK_8000000;
		return;
	}
	iVar2 = iVar2 * blockPos->y + blockPos->x;
	(globs::gameGlobs.level)->blocks[iVar2].flags1 =
			 (globs::gameGlobs.level)->blocks[iVar2].flags1 & ~BLOCK1_UNK_8000000;
	return;
}



BOOL __cdecl lego::game::Level_Block_IsFlags1_c0(int bx,int by)
{
										// (BLOCK1_UNK_40|BLOCK1_UNK_80)
	if ((*(byte *)&(globs::gameGlobs.level)->blocks
								 [((globs::gameGlobs.level)->dimensions).width * by + bx].flags1 & 0xc0) == 0) {
		return 0;
	}
	return TRUE;
}



BOOL __cdecl lego::game::Level_Block_IsExposed(Point2I *blockPos)
{
	return (globs::gameGlobs.level)->blocks
				 [((globs::gameGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags1 &
				 BLOCK1_EXPOSED;
}



BOOL __cdecl lego::game::Level_Block_IsImmovable(Point2I *blockPos)
{
	return (uint)((globs::gameGlobs.level)->blocks
								[((globs::gameGlobs.level)->dimensions).width * blockPos->y + blockPos->x].terrain
							 == TERRAIN_IMMOVABLE);
}



BOOL __cdecl lego::game::Level_Block_IsLava(Point2I *blockPos)
{
	return (uint)((globs::gameGlobs.level)->blocks
								[blockPos->y * ((globs::gameGlobs.level)->dimensions).width + blockPos->x].terrain
							 == TERRAIN_LAVA);
}



BOOL __cdecl lego::game::Level_BlockIsNotFlags1_18(uint bx,uint by)
{
	int width;
	
	width = ((globs::gameGlobs.level)->dimensions).width;
	if ((bx < width - 1U) && (by < ((globs::gameGlobs.level)->dimensions).height - 1U)) {
		return (uint)(((globs::gameGlobs.level)->blocks[by * width + bx].flags1 &
									(BLOCK1_UNK_8|BLOCK1_UNK_10)) == BLOCK1_NONE);
	}
	return TRUE;
}



BOOL __cdecl FUN_00432ec0(uint x,uint y)
{
	int iVar1;
	
	iVar1 = ((lego::globs::gameGlobs.level)->dimensions).width;
	if ((x < iVar1 - 1U) && (y < ((lego::globs::gameGlobs.level)->dimensions).height - 1U)) {
		return (lego::globs::gameGlobs.level)->blocks[y * iVar1 + x].flags1 & BLOCK1_UNK_4;
	}
	return BLOCK1_NONE;
}



uint __cdecl FUN_00432f00(int param_1,int param_2)
{
	return (lego::globs::gameGlobs.level)->blocks
				 [((lego::globs::gameGlobs.level)->dimensions).width * param_2 + param_1].flags1 &
				 BLOCK1_UNK_2000;
}



uint __cdecl FUN_00432f30(int param_1,int param_2)
{
	return (lego::globs::gameGlobs.level)->blocks
				 [((lego::globs::gameGlobs.level)->dimensions).width * param_2 + param_1].flags1 &
				 BLOCK1_UNK_80;
}



uint __cdecl FUN_00432f60(int *param_1)
{
	return (lego::globs::gameGlobs.level)->blocks
				 [((lego::globs::gameGlobs.level)->dimensions).width * param_1[1] + *param_1].flags1 &
				 BLOCK1_UNK_8000;
}



BOOL __cdecl lego::game::Level_IsBlockFlag2_1(Point2I *blockPos)
{
	return (globs::gameGlobs.level)->blocks
				 [((globs::gameGlobs.level)->dimensions).width * blockPos->y + blockPos->x].flags2 &
				 BLOCK2_UNK_1;
}



BOOL __cdecl lego::game::Level_Block_IsPowerPath(Point2I *blockPos)
{
	int width;
	int x;
	int y;
	
	x = blockPos->x;
	if ((((-1 < x) && (y = blockPos->y, -1 < y)) &&
			(width = ((globs::gameGlobs.level)->dimensions).width, x < width)) &&
		 (y < ((globs::gameGlobs.level)->dimensions).height)) {
		return (globs::gameGlobs.level)->blocks[width * y + x].flags1 & BLOCK1_POWERPATH;
	}
	return BLOCK1_NONE;
}



BOOL __cdecl lego::game::Level_BlockIsFlags1_180000(Point2I *blockPos)
{
	if (((globs::gameGlobs.level)->blocks
			 [blockPos->y * ((globs::gameGlobs.level)->dimensions).width + blockPos->x].flags1 &
			(BLOCK1_UNK_80000|BLOCK1_UNK_100000)) == BLOCK1_NONE) {
		return 0;
	}
	return TRUE;
}



void __cdecl lego::game::Level_BlockSetFlags1_10000000(Point2I *blockPos,BOOL state)
{
	int idx;
	LevelBlockFlags1 *pFlags1;
	
	if (state != 0) {
		pFlags1 = &(globs::gameGlobs.level)->blocks
							 [blockPos->y * ((globs::gameGlobs.level)->dimensions).width + blockPos->x].flags1;
		*pFlags1 = *pFlags1 | 0x10000000;
		return;
	}
	idx = blockPos->y * ((globs::gameGlobs.level)->dimensions).width + blockPos->x;
	(globs::gameGlobs.level)->blocks[idx].flags1 =
			 (globs::gameGlobs.level)->blocks[idx].flags1 & 0xefffffff;
	return;
}



BOOL __cdecl
lego::game::LiveObject_UnkGetDamage
					(LiveObject *liveObj,int x,int y,float elapsed,float *optout_value)
{
	ObjectType OVar1;
	LevelData *pLVar2;
	ObjectStatsFlags1 OVar3;
	ObjectStatsFlags2 OVar4;
	uint weaponType;
	float10 fVar5;
	
	pLVar2 = globs::gameGlobs.level;
	OVar1 = liveObj->objType;
	if ((((((OVar1 != OBJECT_POWERCRYSTAL) && (OVar1 != OBJECT_ORE)) && (OVar1 != OBJECT_BOULDER)) &&
			 ((OVar1 != OBJECT_DYNAMITE && (OVar1 != OBJECT_ELECTRICFENCE)))) &&
			(((OVar1 != OBJECT_OOHSCARY && ((OVar1 != OBJECT_ELECTRICFENCESTUD && (OVar1 != OBJECT_PATH)))
				) && (OVar1 != OBJECT_PUSHER)))) &&
		 (((OVar1 != OBJECT_FREEZER && (OVar1 != OBJECT_ICECUBE)) && (OVar1 != OBJECT_LASERSHOT)))) {
		if ((liveObj->drivenObject != NULL) &&
			 (OVar3 = LiveObject_GetStatsFlags1(liveObj), (OVar3 & STATS1_CANBEDRIVEN) == STATS1_NONE)) {
			return 0;
		}
		if (((pLVar2->blocks[y * (pLVar2->dimensions).width + x].terrain == TERRAIN_LAVA) &&
				((pLVar2->blocks[y * (pLVar2->dimensions).width + x].flags1 & BLOCK1_UNK_200) == BLOCK1_NONE
				)) && (OVar4 = LiveObject_GetStatsFlags2(liveObj), (OVar4 & STATS2_CROSSLAVA) == STATS2_NONE
							)) {
			if (optout_value == NULL) {
				return 1;
			}
			*optout_value = elapsed;
			return 1;
		}
		if ((pLVar2->blocks[y * (pLVar2->dimensions).width + x].flags1 & BLOCK1_UNK_1000) != BLOCK1_NONE
			 ) {
			if (optout_value != NULL) {
				weaponType = tools::Weapon_GetWeaponTypeByName("RockFallIn");
				fVar5 = Weapon_GetDamageForLiveObject(weaponType,liveObj);
				*optout_value = (float)(fVar5 * (float10)elapsed);
			}
			return 1;
		}
	}
	return 0;
}



uint __cdecl FUN_004331f0(int param_1,int param_2)
{
	return (uint)(lego::globs::gameGlobs.level)->blocks
							 [((lego::globs::gameGlobs.level)->dimensions).width * param_2 + param_1].field_3;
}



void __cdecl FUN_00433220(uint param_1,uint param_2)
{
	int iVar1;
	
	iVar1 = ((lego::globs::gameGlobs.level)->dimensions).width;
	if ((param_1 < iVar1 - 1U) && (param_2 < ((lego::globs::gameGlobs.level)->dimensions).height - 1U)
		 ) {
		iVar1 = param_2 * iVar1 + param_1;
		(lego::globs::gameGlobs.level)->blocks[iVar1].flags1 =
				 (lego::globs::gameGlobs.level)->blocks[iVar1].flags1 | BLOCK1_UNK_4;
	}
	return;
}



undefined4 __cdecl FUN_00433260(uint param_1,uint param_2,uint *param_3)
{
	int iVar1;
	
	iVar1 = ((lego::globs::gameGlobs.level)->dimensions).width;
	if ((param_1 < iVar1 - 1U) && (param_2 < ((lego::globs::gameGlobs.level)->dimensions).height - 1U)
		 ) {
		*param_3 = (uint)(lego::globs::gameGlobs.level)->blocks[param_2 * iVar1 + param_1].terrain;
		return 1;
	}
	return 0;
}



void __cdecl lego::game::Level_Block_LowerDigVertices(LevelData *level,uint bx,uint by)
{
	float fVar1;
	int idx;
	Vector3F vertPoses [4];
	int width;
	LevelBlockFlags1 block;
	LevelBlock *blocksGrid;
	
	if ((bx < (level->dimensions).width - 1U) && (by < (level->dimensions).height - 1U)) {
		Map3D_GetBlockVertexPositions(level->surfaceMap,bx,by,vertPoses);
		width = (level->dimensions).width;
		blocksGrid = level->blocks;
		idx = by * width + bx;
		block = blocksGrid[idx].flags1;
		if ((block & BLOCK1_UNK_8) == BLOCK1_NONE) {
			if ((block & BLOCK1_UNK_10) == BLOCK1_NONE) {
				return;
			}
			if (blocksGrid[idx].predug == PREDUG_EXPOSED) {
				vertPoses[0].z = vertPoses[0].z - (level->DigDepth + level->RoofHeight);
			}
			if (blocksGrid[idx + 1].predug == PREDUG_EXPOSED) {
				vertPoses[1].z = vertPoses[1].z - (level->DigDepth + level->RoofHeight);
			}
			idx = (by + 1) * width + bx;
			if (blocksGrid[idx + 1].predug == PREDUG_EXPOSED) {
				vertPoses[2].z = vertPoses[2].z - (level->DigDepth + level->RoofHeight);
			}
			if (blocksGrid[idx].predug == PREDUG_EXPOSED) {
				vertPoses[3].z = vertPoses[3].z - (level->DigDepth + level->RoofHeight);
			}
		}
		else {
			fVar1 = level->DigDepth + level->RoofHeight;
			vertPoses[0].z = vertPoses[0].z - fVar1;
			vertPoses[1].z = vertPoses[1].z - fVar1;
			vertPoses[2].z = vertPoses[2].z - fVar1;
			vertPoses[3].z = vertPoses[3].z - fVar1;
		}
		Level_Block_SetVertexPositions(bx,by,vertPoses,vertPoses + 1,vertPoses + 2,vertPoses + 3);
	}
	return;
}



void __cdecl lego::game::MapShared_GetDimensions(uint sharedIndex,int *out_width,int *out_height)
{
	MapFileInfo *mapFile;
	
	mapFile = (MapFileInfo *)lego::file::Mem_AddressHandle(sharedIndex);
	*out_width = (mapFile->dimensions).width;
	*out_height = (mapFile->dimensions).height;
	return;
}



BOOL __cdecl lego::main::Main_Load_GraphicsSettings(void)
{
	char *pcVar1;
	int iVar2;
	BOOL3 BVar3;
	BOOL3 BVar4;
	BOOL3 BVar5;
	BOOL3 BVar6;
	BOOL3 BVar7;
	BOOL3 BVar8;
	GraphicsQuality renderQuality;
	float10 fVar9;
	
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","fpclipblocks",0);
	pcVar1 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar1);
	if (pcVar1 == NULL) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","fpclipblocks",0);
		pcVar1 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar1);
	}
	fVar9 = std::atof(pcVar1);
	globs::gameGlobs.FPClipBlocks = (float)fVar9;
	if ((float10)0.0 != fVar9) {
		pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","quality",0);
		pcVar1 = cfg::CFG_ReadString(globs::gameGlobs.LegoCfgRoot,pcVar1);
		if (pcVar1 != NULL) {
			iVar2 = std::_stricmp("gouraud",pcVar1);
			if (iVar2 == 0) {
				renderQuality = QUALITY_GOURAUD;
			}
			else {
				iVar2 = std::_stricmp("flat",pcVar1);
				if (iVar2 == 0) {
					renderQuality = QUALITY_FLAT;
				}
				else {
					iVar2 = std::_stricmp("wireframe",pcVar1);
					if (iVar2 != 0) {
						return 0;
					}
					renderQuality = QUALITY_WIREFRAME;
				}
			}
			globs::gameGlobs.Quality = renderQuality;
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","dither",0);
			BVar3 = cfg::CFG_ReadBool(globs::gameGlobs.LegoCfgRoot,pcVar1);
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","filter",0);
			BVar4 = cfg::CFG_ReadBool(globs::gameGlobs.LegoCfgRoot,pcVar1);
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","blend",0);
			BVar5 = cfg::CFG_ReadBool(globs::gameGlobs.LegoCfgRoot,pcVar1);
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","sort",0);
			BVar6 = cfg::CFG_ReadBool(globs::gameGlobs.LegoCfgRoot,pcVar1);
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","mipmap",0);
			BVar7 = cfg::CFG_ReadBool(globs::gameGlobs.LegoCfgRoot,pcVar1);
			pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","linearmipmap",0);
			BVar8 = cfg::CFG_ReadBool(globs::gameGlobs.LegoCfgRoot,pcVar1);
			Main_Setup3D(renderQuality,(uint)(BVar3 == BOOL3_TRUE),(uint)(BVar4 == BOOL3_TRUE),
									 (uint)(BVar7 == BOOL3_TRUE),(uint)(BVar8 == BOOL3_TRUE),
									 (uint)(BVar5 == BOOL3_TRUE),(uint)(BVar6 == BOOL3_TRUE));
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::main::Main_LoadLighting(void)
{
	char *pcVar1;
	BOOL BVar2;
	Container *opt_parent;
	float *pfVar3;
	float *pfVar4;
	float *pfVar5;
	float local_c;
	float local_8;
	float local_4;
	
	pfVar4 = &local_c;
	pfVar5 = &local_8;
	pfVar3 = &local_4;
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","topspotrgb",0);
	BVar2 = cfg::CFG_ReadRGBF(globs::gameGlobs.LegoCfgRoot,pcVar1,pfVar3,pfVar5,pfVar4);
	if (BVar2 == 0) {
		return 0;
	}
	globs::gameGlobs.resTopSpotlight =
			 res::Container_MakeLight
								 ((globs::gameGlobs.cameraMain)->resData3,D3DRMLIGHT_SPOT,local_4,local_8,local_c);
	if (globs::gameGlobs.resTopSpotlight == NULL) {
		return 0;
	}
	res::Container_Light_SetSpotPenumbra(globs::gameGlobs.resTopSpotlight,0.85);
	res::Container_Light_SetSpotUmbra(globs::gameGlobs.resTopSpotlight,0.4);
	res::Container_SetPosition
						(globs::gameGlobs.resTopSpotlight,(globs::gameGlobs.cameraMain)->resData3,200.0,140.0,
						 -130.0);
	res::Container_SetOrientation
						(globs::gameGlobs.resTopSpotlight,(globs::gameGlobs.cameraMain)->resData3,-1.0,-0.8,0.75
						 ,0.0,1.0,0.0);
	pfVar4 = &local_c;
	pfVar5 = &local_8;
	pfVar3 = &local_4;
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","trackspotrgb",0);
	BVar2 = cfg::CFG_ReadRGBF(globs::gameGlobs.LegoCfgRoot,pcVar1,pfVar3,pfVar5,pfVar4);
	if (BVar2 == 0) {
		return 0;
	}
	globs::gameGlobs.resTrackSpotlight =
			 res::Container_MakeLight
								 ((globs::gameGlobs.cameraRadar)->resData2,D3DRMLIGHT_SPOT,local_4,local_8,local_c);
	if (globs::gameGlobs.resTrackSpotlight == NULL) {
		return 0;
	}
	res::Container_SetPosition(globs::gameGlobs.resTrackSpotlight,NULL,0.0,0.0,-150.0);
	res::Container_SetOrientation(globs::gameGlobs.resTrackSpotlight,NULL,0.0,0.0,1.0,0.0,1.0,0.0);
	pfVar4 = &local_c;
	pfVar5 = &local_8;
	pfVar3 = &local_4;
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","ambientrgb",0);
	BVar2 = cfg::CFG_ReadRGBF(globs::gameGlobs.LegoCfgRoot,pcVar1,pfVar3,pfVar5,pfVar4);
	if (BVar2 == 0) {
		return 0;
	}
	globs::gameGlobs.resAmbientLight =
			 res::Container_MakeLight(globs::gameGlobs.resRoot,D3DRMLIGHT_AMBIENT,local_4,local_8,local_c)
	;
	pfVar5 = &local_c;
	if (globs::gameGlobs.resAmbientLight == NULL) {
		return 0;
	}
	pfVar3 = &local_8;
	pfVar4 = &local_4;
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","fplightrgb",0);
	BVar2 = cfg::CFG_ReadRGBF(globs::gameGlobs.LegoCfgRoot,pcVar1,pfVar4,pfVar3,pfVar5);
	if (BVar2 == 0) {
		return 0;
	}
	globs::gameGlobs.resFPLight =
			 res::Container_MakeLight
								 ((globs::gameGlobs.cameraFP)->resData1,D3DRMLIGHT_POINT,local_4,local_8,local_c);
	pfVar5 = &local_c;
	if (globs::gameGlobs.resFPLight == NULL) {
		return 0;
	}
	pfVar3 = &local_8;
	pfVar4 = &local_4;
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","fprotlightrgb",0);
	BVar2 = cfg::CFG_ReadRGBF(globs::gameGlobs.LegoCfgRoot,pcVar1,pfVar4,pfVar3,pfVar5);
	if (BVar2 == 0) {
		globs::gameGlobs.resFPRotLight = NULL;
	}
	else {
		globs::gameGlobs.resFPRotLight =
				 res::Container_MakeLight
									 ((globs::gameGlobs.cameraFP)->resData1,D3DRMLIGHT_DIRECTIONAL,local_4,local_8,
										local_c);
	}
	globs::gameGlobs.resFPRotLightDefault =
			 res::Container_MakeLight
								 ((globs::gameGlobs.cameraFP)->resData1,D3DRMLIGHT_DIRECTIONAL,1.0,0.0,0.0);
	if (globs::gameGlobs.resFPRotLightDefault == NULL) {
		return 0;
	}
	opt_parent = res::GetRoot();
	globs::gameGlobs.resRootLight = res::Container_Create(opt_parent);
	globs::gameGlobs.resRootSpotlight =
			 res::Container_MakeLight(globs::gameGlobs.resRootLight,D3DRMLIGHT_SPOT,1.0,1.0,1.0);
	if (globs::gameGlobs.resRootSpotlight == NULL) {
		return 0;
	}
	light::LightEffects_Initialise
						(globs::gameGlobs.resRootSpotlight,globs::gameGlobs.resRootLight,0.8,0.8,0.8);
	res::Container_SetOrientation(globs::gameGlobs.resRootSpotlight,NULL,0.0,0.0,1.0,0.0,1.0,0.0);
	res::Container_Light_SetSpotPenumbra(globs::gameGlobs.resRootSpotlight,0.85);
	res::Container_Light_SetSpotUmbra(globs::gameGlobs.resRootSpotlight,0.0);
	res::Container_Hide(globs::gameGlobs.resFPLight,1);
	if (globs::gameGlobs.resFPRotLight != NULL) {
		res::Container_Hide(globs::gameGlobs.resFPRotLight,1);
	}
	res::Container_Hide(globs::gameGlobs.resTopSpotlight,1);
	res::Container_Hide(globs::gameGlobs.resTrackSpotlight,1);
	res::Container_Hide(globs::gameGlobs.resAmbientLight,1);
	res::Container_Hide(globs::gameGlobs.resRootSpotlight,1);
	res::Container_Hide(globs::gameGlobs.resFPRotLightDefault,1);
	res::Container_Light_SetSpotRange(globs::gameGlobs.resTopSpotlight,2000.0);
	res::Container_Light_SetSpotRange(globs::gameGlobs.resTrackSpotlight,2000.0);
	res::Container_Light_SetSpotRange(globs::gameGlobs.resRootSpotlight,2000.0);
	return 1;
}



BOOL __cdecl lego::game::Level_ToBlockCoordinatesNoZ(float in_x,float in_y,int *out_x,int *out_y)
{
	BOOL BVar1;
	
	BVar1 = Map3D_WorldToBlockPos_NoZ((globs::gameGlobs.level)->surfaceMap,in_x,in_y,out_x,out_y);
	return BVar1;
}



BOOL __cdecl lego::game::LiveObject_FUN_00433b40(LiveObject *liveObj,float param_2,int param_3)
{
	int iVar1;
	LevelBlockFlags1 LVar2;
	float fVar3;
	bool bVar4;
	short sVar5;
	ObjectStatsFlags1 OVar6;
	BOOL BVar7;
	int *piVar8;
	uint uVar9;
	ulonglong uVar10;
	float local_2c;
	int local_28;
	int local_24;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar9 = 0;
	local_20[0] = -1;
	local_20[1] = 0;
	local_20[2] = 1;
	local_20[3] = 0;
	local_20[4] = 0;
	local_c = 0xffffffff;
	local_8 = 0;
	local_4 = 1;
	OVar6 = LiveObject_GetStatsFlags1(liveObj);
	if (((((OVar6 & STATS1_RANDOMENTERWALL) != STATS1_NONE) && ((*(byte *)&liveObj->flags1 & 1) == 0))
			&& (BVar7 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj), BVar7 == 0)) &&
		 (param_2 != 0.0)) {
		local_2c = param_2;
		if ((ushort)((ushort)(param_2 < 300.0) << 8 | (ushort)(param_2 == 300.0) << 0xe) == 0) {
			local_2c = 300.0;
		}
		sVar5 = math::Maths_Rand();
		uVar10 = __ftol((float10)300.0 / (float10)local_2c);
		if ((int)((ulonglong)(uint)(int)sVar5 % (uVar10 & 0xffffffff)) == 0) {
			LiveObject_GetBlockPos(liveObj,&local_24,&local_28);
			piVar8 = local_20;
			iVar1 = ((globs::gameGlobs.level)->dimensions).width;
			do {
				if ((((uint)(local_24 + *piVar8) < iVar1 - 1U) &&
						((uint)(piVar8[1] + local_28) < ((globs::gameGlobs.level)->dimensions).height - 1U)) &&
					 ((LVar2 = (globs::gameGlobs.level)->blocks
										 [(piVar8[1] + local_28) * iVar1 + local_24 + *piVar8].flags1,
						(LVar2 & BLOCK1_UNK_10) != BLOCK1_NONE && ((LVar2 & BLOCK1_UNK_8) == BLOCK1_NONE)))) {
					bVar4 = true;
				}
				else {
					bVar4 = false;
				}
				if (bVar4) {
					liveObj->health = -1.0;
					LiveObject_TryDepart_FUN_004499c0(liveObj);
					return 1;
				}
				uVar9 += 1;
				piVar8 = piVar8 + 2;
			} while (uVar9 < 4);
		}
	}
	if (((param_3 != 0) ||
			(OVar6 = LiveObject_GetStatsFlags1(liveObj), (OVar6 & STATS1_RANDOMMOVE) != STATS1_NONE)) &&
		 (((*(byte *)&liveObj->flags1 & 1) == 0 &&
			((BVar7 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj), BVar7 == 0 &&
			 (fVar3 = liveObj->stats->RandomMoveTime, param_2 != 0.0)))))) {
		local_2c = param_2;
		if ((ushort)((ushort)(param_2 < fVar3) << 8 | (ushort)(param_2 == fVar3) << 0xe) == 0) {
			local_2c = fVar3;
		}
		if (param_3 == 0) {
			sVar5 = math::Maths_Rand();
			uVar10 = __ftol((float10)fVar3 / (float10)local_2c);
			if ((int)((ulonglong)(uint)(int)sVar5 % (uVar10 & 0xffffffff)) != 0) {
				return 0;
			}
		}
		LiveObject_FUN_00444520(liveObj);
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::game::Level_Block_FUN_00433d60(int bx,int by)
{
	SurfaceMap *surfMap;
	BOOL BVar1;
	
	if (((globs::gameGlobs.level)->blocks[((globs::gameGlobs.level)->dimensions).width * by + bx].
			 flags1 & BLOCK1_UNK_100) == BLOCK1_NONE) {
		surfMap = GetSurfaceMap();
		BVar1 = Map3D_IsBlockMeshHidden(surfMap,bx,by);
		if (BVar1 != 0) {
			return TRUE;
		}
	}
	return 0;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

void __cdecl FUN_00433db0(Container *resData,Viewport *view,float param_3,float param_4)
{
	LevelBlockFlags1 *pLVar1;
	bool bVar2;
	LevelData *level;
	float fVar3;
	BOOL BVar4;
	uint uVar5;
	uint *puVar6;
	float *pfVar7;
	SurfaceMap *surfMap;
	uint uVar8;
	int iVar9;
	float10 fVar10;
	longlong lVar11;
	float fStack7376;
	uint uStack7372;
	SurfaceMap *pSStack7368;
	uint uStack7364;
	float fStack7360;
	float fStack7356;
	float fStack7352;
	undefined4 uStack7348;
	float fStack7344;
	int iStack7340;
	float fStack7336;
	float fStack7332;
	float fStack7328;
	float fStack7324;
	float fStack7320;
	float fStack7316;
	float fStack7312;
	float fStack7308;
	int iStack7304;
	Vector3F VStack7300;
	int iStack7288;
	uint uStack7284;
	undefined4 uStack7280;
	float fStack7276;
	undefined4 uStack7272;
	Point2F PStack7268;
	Vector3F VStack7260;
	Vector3F aVStack7248 [4];
	uint auStack7200 [600];
	float local_12c0 [1199];
	undefined4 uStack4;
	
	level = lego::globs::gameGlobs.level;
	uStack4 = 0x433dba;
	surfMap = (lego::globs::gameGlobs.level)->surfaceMap;
	fStack7332 = 0.0;
	pSStack7368 = surfMap;
	fVar10 = lego::game::Map3D_GetBlockSize(surfMap);
	fStack7356 = (float)fVar10;
	lVar11 = __ftol((float10)param_3 / (float10)fStack7356);
	iVar9 = (int)lVar11;
	iStack7340 = 0;
	lego::res::Container_GetPosition(resData,NULL,&VStack7300);
	lego::game::Map3D_WorldToBlockPos_NoZ(surfMap,VStack7300.x,VStack7300.y,&iStack7304,&iStack7288);
	lego::res::Container_GetOrientation(resData,NULL,&VStack7260,NULL);
	fVar10 = lego::view::Viewport_GetField(lego::globs::gameGlobs.viewMain);
	fVar10 = (float10)fcos(fVar10 * (float10)1.4);
	fStack7344 = (float)fVar10;
	lego::view::Viewport_GetSize(lego::globs::gameGlobs.viewMain,(uint *)&fStack7376,&uStack7372);
	PStack7268.x = (float)(ulonglong)(uint)fStack7376;
	uStack7348 = 0;
	PStack7268.y = (float)(ulonglong)uStack7372;
	fStack7352 = (float)(iStack7304 - iVar9);
	uVar5 = iStack7288 - iVar9;
	fStack7360 = (float)(iStack7304 + iVar9);
	uStack7364 = iVar9 + iStack7288;
	if ((int)fStack7352 < 0) {
		fStack7352 = 0.0;
	}
	if ((int)uVar5 < 0) {
		uVar5 = 0;
	}
	if ((int)fStack7360 < 0) {
		fStack7360 = 0.0;
	}
	if ((int)uStack7364 < 0) {
		uStack7364 = 0;
	}
	iVar9 = (level->dimensions).width;
	if (iVar9 <= (int)fStack7360) {
		fStack7360 = (float)(iVar9 + -1);
	}
	iVar9 = (level->dimensions).height;
	if (iVar9 <= (int)uStack7364) {
		uStack7364 = iVar9 - 1;
	}
	fVar3 = fStack7352;
	uVar8 = uStack7364;
	uStack7372 = uVar5;
	if (uVar5 < uStack7364) {
		do {
			fStack7376 = fVar3;
			fVar3 = fStack7376;
			if ((uint)fStack7376 < (uint)fStack7360) {
				puVar6 = auStack7200 + iStack7340 * 2 + 1;
				pfVar7 = local_12c0 + (int)fStack7332 * 4 + 1;
				uStack7372 = uVar5;
				do {
					surfMap = pSStack7368;
					if ((*(byte *)&level->blocks[uVar5 * (level->dimensions).width + (int)fStack7376].flags1 &
							0x18) != 0) {
						lego::game::Map3D_BlockToWorldPos
											(pSStack7368,(uint)fStack7376,uVar5,&fStack7316,&fStack7312);
						fVar10 = lego::game::Map3D_GetWorldZ(surfMap,fStack7316,fStack7312);
						fStack7308 = (float)fVar10;
						fStack7328 = (float)((float10)fStack7316 - (float10)VStack7300.x);
						fStack7324 = (float)((float10)fStack7312 - (float10)VStack7300.y);
						fStack7320 = (float)(fVar10 - (float10)VStack7300.z);
						fVar10 = SQRT((fVar10 - (float10)VStack7300.z) * (float10)fStack7320 +
													((float10)fStack7312 - (float10)VStack7300.y) * (float10)fStack7324 +
													((float10)fStack7316 - (float10)VStack7300.x) * (float10)fStack7328);
						fStack7336 = (float)fVar10;
						uVar5 = uStack7372;
						if (fVar10 < (float10)param_3) {
							fVar3 = 1.0 / fStack7336;
							fVar3 = fVar3 * fStack7320 * VStack7260.z +
											fVar3 * fStack7324 * VStack7260.y + fVar3 * fStack7328 * VStack7260.x;
							bVar2 = fStack7336 < (fVar3 - -2.0) * fStack7356;
							if (bVar2) {
								fVar3 = fStack7344 - -1.0;
							}
							if ((ushort)((ushort)(fVar3 < fStack7344) << 8 | (ushort)(fVar3 == fStack7344) << 0xe)
									== 0) {
								lego::game::Map3D_GetBlockVertexPositions
													(pSStack7368,(uint)fStack7376,uStack7372,aVStack7248);
								fStack7276 = fStack7376;
								uStack7272 = 0;
								uStack7284 = uStack7372;
								uStack7280 = 0;
								pfVar7[-1] = (float)(ulonglong)(uint)fStack7376;
								*pfVar7 = (float)(ulonglong)uStack7372;
								pfVar7[1] = fStack7336;
								fVar10 = lego::res::DynamicPM_FUN_0040b3a0
																	 ((int)aVStack7248,view,&PStack7268,(uint)bVar2);
								pfVar7[2] = (float)fVar10;
								uVar5 = uStack7372;
								if ((ushort)((ushort)(fVar10 < (float10)0.0) << 8 |
														(ushort)(fVar10 == (float10)0.0) << 0xe) == 0) {
									fStack7332 = (float)((int)fStack7332 + 1);
									pfVar7 = pfVar7 + 4;
								}
								else {
									puVar6[-1] = (uint)fStack7376;
									iStack7340 += 1;
									*puVar6 = uStack7372;
									puVar6 = puVar6 + 2;
								}
							}
						}
					}
					fStack7376 = (float)((int)fStack7376 + 1);
					fVar3 = fStack7352;
					surfMap = pSStack7368;
					uVar8 = uStack7364;
				} while ((uint)fStack7376 < (uint)fStack7360);
			}
			uVar5 += 1;
			uStack7372 = uVar5;
		} while (uVar5 < uVar8);
	}
	fVar3 = fStack7332;
	std::qsort(local_12c0,(uint)fStack7332,0x10,lego::unk::Lego_CompareQsortUnk_FUN_00434380);
	pSStack7368 = NULL;
	if (fVar3 != 0.0) {
		pfVar7 = local_12c0 + 2;
		fStack7356 = fVar3;
		do {
			lVar11 = __ftol((float10)pfVar7[-2]);
			fVar3 = (float)lVar11;
			fStack7376 = fVar3;
			lVar11 = __ftol((float10)pfVar7[-1]);
			uStack7372 = (uint)lVar11;
			if (((uint)param_4 <= pSStack7368) || (param_3 * 0.6666667 <= *pfVar7)) {
				pLVar1 = &level->blocks[uStack7372 * (level->dimensions).width + (int)fVar3].flags1;
				*pLVar1 = *pLVar1 & ~BLOCK1_UNK_100;
				lego::game::Map3D_AddBlockCoord(surfMap,(int)fStack7376,uStack7372);
				lego::game::WorldMesh_FUN_004637b0((int)fStack7376,uStack7372);
				if ((level->blocks[uStack7372 * (level->dimensions).width + (int)fStack7376].flags1 &
						BLOCK1_UNK_4000) != BLOCK1_NONE) {
					lego::effect::Smoke_Hide
										(level->blocks[uStack7372 * (level->dimensions).width + (int)fStack7376].
										 smokeptr_1c,FALSE);
				}
			}
			else {
				fStack7344 = 1.0 - *pfVar7 / (param_3 * 0.6666667);
				fStack7352 = fStack7344 * 0.7 - -0.3;
				if ((((byte)lego::globs::gameGlobs.flags1 & GAME1_WALLPROMESHES) == 0) ||
					 (BVar4 = lego::game::Level_Block_ProMesh_FUN_004343b0
															(level,(uint)fVar3,uStack7372,fStack7344,(uint)fStack7352),
					 fVar3 = fStack7376, BVar4 == 0)) {
					lego::game::Map3D_AddBlockCoord(surfMap,(int)fVar3,uStack7372);
					lego::game::WorldMesh_FUN_004637b0((int)fStack7376,uStack7372);
					if ((level->blocks[uStack7372 * (level->dimensions).width + (int)fStack7376].flags1 &
							BLOCK1_UNK_4000) != BLOCK1_NONE) {
						lego::effect::Smoke_Hide
											(level->blocks[uStack7372 * (level->dimensions).width + (int)fStack7376].
											 smokeptr_1c,FALSE);
					}
					iVar9 = uStack7372 * (level->dimensions).width + (int)fStack7376;
					level->blocks[iVar9].flags1 = level->blocks[iVar9].flags1 & ~BLOCK1_UNK_100;
				}
				else {
					pLVar1 = &level->blocks[uStack7372 * (level->dimensions).width + (int)fStack7376].flags1;
					*pLVar1 = *pLVar1 | BLOCK1_UNK_100;
					lego::game::WorldMesh_FUN_004637b0((int)fStack7376,uStack7372);
					pSStack7368 = (SurfaceMap *)((int)pSStack7368 + 1);
				}
			}
			pfVar7 = pfVar7 + 4;
			fStack7356 = (float)((int)fStack7356 + -1);
		} while (fStack7356 != 0.0);
	}
	if (iStack7340 != 0) {
		puVar6 = auStack7200;
		iVar9 = iStack7340;
		do {
			lego::game::WorldMesh_FUN_004637b0(*puVar6,puVar6[1]);
			puVar6 = puVar6 + 2;
			iVar9 += -1;
		} while (iVar9 != 0);
	}
	return;
}



int __cdecl lego::unk::Lego_CompareQsortUnk_FUN_00434380(int param_1,int param_2)
{
	if (*(float *)(param_1 + 0xc) < *(float *)(param_2 + 0xc)) {
		return 1;
	}
	if ((ushort)((ushort)(*(float *)(param_1 + 0xc) < *(float *)(param_2 + 0xc)) << 8 |
							(ushort)(*(float *)(param_1 + 0xc) == *(float *)(param_2 + 0xc)) << 0xe) == 0) {
		return -1;
	}
	return 0;
}



BOOL __cdecl
lego::game::Level_Block_ProMesh_FUN_004343b0
					(LevelData *level,uint bx,uint by,undefined4 param_4,uint param_5)
{
	SurfaceTexture SVar1;
	ProMeshData *promesh;
	int iVar2;
	Vector3F vertPoses [4];
	
	if (((*(byte *)&level->blocks[by * (level->dimensions).width + bx].flags1 & 0x18) != 0) &&
		 (SVar1 = level->blocks[by * (level->dimensions).width + bx].texture,
		 promesh = level->promeshGrid[(level->surfTextSize).width * (SVar1 & 0xf) + (uint)(SVar1 >> 4)],
		 promesh != NULL)) {
		Map3D_GetBlockVertexPositions(level->surfaceMap,bx,by,vertPoses);
		iVar2 = by * (level->dimensions).width + bx;
		res::DynamicPM_FUN_0040b7b0
							(promesh,vertPoses,level->blocks[iVar2].texture,level->blocks[iVar2].field_3,param_4,
							 param_5);
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::Level_RemoveAll_ProMeshes(void)
{
	uint i;
	LevelData *level;
	
	level = globs::gameGlobs.level;
	i = 0;
	if (((globs::gameGlobs.level)->surfTextSize).height *
			((globs::gameGlobs.level)->surfTextSize).width != 0) {
		do {
			if (level->promeshGrid[i] != NULL) {
				res::DynamicPM_Remove_FUN_0040b740(level->promeshGrid[i]);
			}
			i += 1;
		} while (i < (uint)((level->surfTextSize).height * (level->surfTextSize).width));
	}
	return;
}



BOOL __cdecl lego::game::Level_Block_GetUnkField14Test(int bx,int by,float param_3,float param_4)
{
	float fVar1;
	LevelData *pLVar2;
	int iVar3;
	
	pLVar2 = globs::gameGlobs.level;
	if ((param_3 != 0.0) &&
		 (iVar3 = by * ((globs::gameGlobs.level)->dimensions).width + bx,
		 (globs::gameGlobs.level)->blocks[iVar3].float_14 =
					param_4 / param_3 + (globs::gameGlobs.level)->blocks[iVar3].float_14,
		 fVar1 = pLVar2->blocks[by * (pLVar2->dimensions).width + bx].float_14,
		 (ushort)((ushort)(fVar1 < 1.0) << 8 | (ushort)(fVar1 == 1.0) << 0xe) == 0)) {
		return TRUE;
	}
	return 0;
}



void __cdecl lego::front::Panel_LoadPanels(CFGProperty *root,uint screenWidth,uint screenHeight)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *prop;
	BOOL BVar3;
	int yIn;
	int xIn;
	int yOut;
	int xOut;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	undefined4 *puVar8;
	PanelType panelType;
	char *stringParts [10];
	char buff [256];
	
	std::sprintf(buff,"Panels%ix%i",screenWidth,screenHeight);
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,buff,0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (prop == NULL) {
			return;
		}
		BVar3 = Panel_GetPanelType(prop->key,&panelType);
		if (BVar3 != 0) {
			uVar4 = 0xffffffff;
			pcVar2 = prop->value;
			do {
				pcVar7 = pcVar2;
				if (uVar4 == 0) break;
				uVar4 -= 1;
				pcVar7 = pcVar2 + 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar7;
			} while (cVar1 != '\0');
			uVar4 = ~uVar4;
			puVar6 = (undefined4 *)(pcVar7 + -uVar4);
			puVar8 = (undefined4 *)buff;
			for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
				*puVar8 = *puVar6;
				puVar6 = puVar6 + 1;
				puVar8 = puVar8 + 1;
			}
			for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
				*(undefined *)puVar8 = *(undefined *)puVar6;
				puVar6 = (undefined4 *)((int)puVar6 + 1);
				puVar8 = (undefined4 *)((int)puVar8 + 1);
			}
			util::Util_Tokenise(buff,stringParts,",");
			Panel_LoadImage(stringParts[0],panelType,4);
			yIn = std::atoi(stringParts[4]);
			xIn = std::atoi(stringParts[3]);
			yOut = std::atoi(stringParts[2]);
			xOut = std::atoi(stringParts[1]);
			Panel_SetArea(panelType,xOut,yOut,xIn,yIn);
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

void __cdecl lego::front::Panel_LoadButtons(CFGProperty *root,int screenWidth,uint screenHeight)
{
	char *pcVar1;
	CFGProperty *prop;
	BOOL BVar2;
	int iVar3;
	int iVar4;
	char **ppcVar5;
	uint uVar6;
	int *piVar7;
	char **ppcVar8;
	CFGProperty *pCStack11756;
	int iStack11752;
	int iStack11748;
	uint uStack11744;
	ToolTipType TStack11740;
	int aiStack11736 [12];
	char *pcStack11688;
	char *apcStack11684 [4];
	char *pcStack11668;
	char *pcStack11664;
	char *pcStack11660;
	char *pcStack11656;
	char acStack11648 [128];
	ToolTipType aTStack11520 [288];
	uint auStack10368 [288];
	char *apcStack9216 [288];
	undefined auStack8064 [1152];
	undefined auStack6912 [1152];
	char *apcStack5760 [288];
	float afStack4608 [1151];
	undefined4 uStack4;
	
	uStack4 = 0x43464a;
	piVar7 = aiStack11736;
	aiStack11736[0] = 0;
	for (iVar4 = 0xb; piVar7 = piVar7 + 1, iVar4 != 0; iVar4 += -1) {
		*piVar7 = 0;
	}
	iStack11748 = 0;
	std::sprintf(acStack11648,"Buttons%ix%i",screenWidth,screenHeight);
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,acStack11648,0);
	prop = cfg::CFG_GetChildren(root,pcVar1);
	if (prop != NULL) {
		ppcVar5 = apcStack5760;
		do {
			BVar2 = Panel_GetPanelType(prop->key,(PanelType *)&pCStack11756);
			if (BVar2 != 0) {
				pcVar1 = std::_strdup(prop->value);
				*ppcVar5 = pcVar1;
				util::Util_Tokenise(pcVar1,&pcStack11688,",");
				BVar2 = Panel_GetButtonType((PanelType)pCStack11756,pcStack11688,&uStack11744);
				if (BVar2 != 0) {
					uVar6 = 0;
					ppcVar8 = apcStack11684;
					auStack10368[aiStack11736[(int)pCStack11756] + (int)pCStack11756 * 0x18] = uStack11744;
					do {
						iVar3 = std::_stricmp("NULL",*ppcVar8);
						iVar4 = aiStack11736[(int)pCStack11756] + ((int)&pCStack11756->fileData + uVar6) * 0x18;
						if (iVar3 == 0) {
							apcStack9216[iVar4] = NULL;
						}
						else {
							apcStack9216[iVar4] = *ppcVar8;
						}
						uVar6 += 0xc;
						ppcVar8 = ppcVar8 + 1;
					} while (uVar6 < 0x24);
					iStack11752 = std::atoi(apcStack11684[3]);
					afStack4608[(aiStack11736[(int)pCStack11756] + (int)pCStack11756 * 0x18) * 4] =
							 (float)iStack11752;
					iStack11752 = std::atoi(pcStack11668);
					afStack4608[(aiStack11736[(int)pCStack11756] + (int)pCStack11756 * 0x18) * 4 + 1] =
							 (float)iStack11752;
					iStack11752 = std::atoi(pcStack11664);
					afStack4608[(aiStack11736[(int)pCStack11756] + (int)pCStack11756 * 0x18) * 4 + 2] =
							 (float)iStack11752;
					iStack11752 = std::atoi(pcStack11660);
					afStack4608[(aiStack11736[(int)pCStack11756] + (int)pCStack11756 * 0x18) * 4 + 3] =
							 (float)iStack11752;
					BVar2 = ToolTip_GetType(pcStack11656,&TStack11740);
					iVar3 = aiStack11736[(int)pCStack11756];
					iVar4 = iVar3 + (int)pCStack11756 * 0x18;
					if (BVar2 == 0) {
						aTStack11520[iVar4] = TOOLTIP_NULL;
					}
					else {
						aTStack11520[iVar4] = TStack11740;
					}
					aiStack11736[(int)pCStack11756] = iVar3 + 1;
					iStack11748 += 1;
					ppcVar5 = ppcVar5 + 1;
				}
			}
			prop = cfg::CFG_NextFlat(prop);
		} while (prop != NULL);
		do {
			pCStack11756 = prop;
			Panel_FUN_0045aef0((PanelType)prop,aiStack11736[(int)prop],
												 (int)(auStack10368 + (int)prop * 0x18),
												 (int)(afStack4608 + (int)prop * 0x60),
												 (int *)(apcStack9216 + (int)prop * 0x18),
												 (int)(auStack8064 + (int)prop * 0x60),(int)(auStack6912 + (int)prop * 0x60)
												 ,(int)(aTStack11520 + (int)prop * 0x18));
			prop = (CFGProperty *)((int)&pCStack11756->fileData + 1);
		} while (prop < (CFGProperty *)&DAT_0000000c);
		if (iStack11748 != 0) {
			ppcVar5 = apcStack5760;
			iVar4 = iStack11748;
			pCStack11756 = prop;
			do {
				std::free(*ppcVar5);
				ppcVar5 = ppcVar5 + 1;
				iVar4 += -1;
			} while (iVar4 != 0);
		}
	}
	return;
}



void __cdecl lego::main::Main_LoadTutorialIcon(CFGProperty *root)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","TutorialIcon",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		globs::gameGlobs.TutorialIcon = lego::image::Image_LoadBMPScaled(pcVar1,0,0);
		if (globs::gameGlobs.TutorialIcon != NULL) {
			lego::image::Image_SetPenZeroTrans(globs::gameGlobs.TutorialIcon);
		}
	}
	return;
}



void __cdecl lego::snd::Sample_LoadAllProperties(CFGProperty *root,BOOL noReduceSamples)
{
	char *pcVar1;
	CFGProperty *prop;
	BOOL BVar2;
	SFXType sfxType;
	bool reduced;
	
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Samples",0);
	prop = cfg::CFG_GetChildren(root,pcVar1);
	if (prop != NULL) {
		SFX_SetSamplePopulateMode(TRUE);
		do {
			pcVar1 = prop->key;
			reduced = false;
			if ((*pcVar1 == '!') && (pcVar1 = pcVar1 + 1, noReduceSamples == 0)) {
				reduced = true;
			}
			if (!reduced) {
										// Audio_SetSamplePopulateMode(TRUE); was called, meaning this function will
										// register new SFX if they don't already exist
				BVar2 = SFX_GetType(pcVar1,&sfxType);
				if (BVar2 != 0) {
					SFX_Sample_LoadProperty(prop->value,sfxType);
				}
			}
			prop = cfg::CFG_NextFlat(prop);
		} while (prop != NULL);
		SFX_SetSamplePopulateMode(0);
	}
	return;
}



void __cdecl lego::main::Main_LoadTextMessages(CFGProperty *root)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *pCVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	undefined4 *puVar9;
	TextType local_22c;
	char *stringParts [10];
	char buffer [512];
	
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"TextMessages",0);
	for (pCVar3 = cfg::CFG_GetChildren(root,pcVar2); pCVar3 != NULL;
			pCVar3 = cfg::CFG_NextFlat(pCVar3)) {
		BVar4 = front::Text_GetTextType(pCVar3->key,&local_22c);
		if (BVar4 != 0) {
			front::Text_SetMessage(local_22c,pCVar3->value);
		}
	}
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"TextMessagesWithImages",0);
	pCVar3 = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (pCVar3 == NULL) {
			return;
		}
		BVar4 = front::Text_GetTextType(pCVar3->key,&local_22c);
		if (BVar4 != 0) {
			uVar5 = 0xffffffff;
			pcVar2 = pCVar3->value;
			do {
				pcVar8 = pcVar2;
				if (uVar5 == 0) break;
				uVar5 -= 1;
				pcVar8 = pcVar2 + 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar8;
			} while (cVar1 != '\0');
			uVar5 = ~uVar5;
			puVar7 = (undefined4 *)(pcVar8 + -uVar5);
			puVar9 = (undefined4 *)buffer;
			for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
				*puVar9 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar9 = puVar9 + 1;
			}
			for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
				*(undefined *)puVar9 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar9 = (undefined4 *)((int)puVar9 + 1);
			}
			util::Util_Tokenise(buffer,stringParts,":");
			front::Text_SetMessageWithImage(local_22c,stringParts[0],stringParts[1],stringParts[2]);
		}
		pCVar3 = cfg::CFG_NextFlat(pCVar3);
	} while( true );
}



void __cdecl lego::front::Info_LoadInfoMessages(CFGProperty *root)
{
	char cVar1;
	char *pcVar2;
	CFGProperty *prop;
	BOOL BVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	undefined4 *puVar9;
	InfoType infoType;
	SFXType sfxType;
	char *stringParts [10];
	char buffer [1024];
	
	pcVar2 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"InfoMessages",0);
	prop = cfg::CFG_GetChildren(root,pcVar2);
	do {
		if (prop == NULL) {
			return;
		}
		BVar3 = Info_GetInfoType(prop->key,&infoType);
		if (BVar3 != 0) {
			uVar5 = 0xffffffff;
			pcVar2 = prop->value;
			do {
				pcVar8 = pcVar2;
				if (uVar5 == 0) break;
				uVar5 -= 1;
				pcVar8 = pcVar2 + 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar8;
			} while (cVar1 != '\0');
			uVar5 = ~uVar5;
			puVar7 = (undefined4 *)(pcVar8 + -uVar5);
			puVar9 = (undefined4 *)buffer;
			for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
				*puVar9 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar9 = puVar9 + 1;
			}
			for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
				*(undefined *)puVar9 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar9 = (undefined4 *)((int)puVar9 + 1);
			}
			uVar5 = util::Util_Tokenise(buffer,stringParts,":");
			Info_SetText(infoType,stringParts[0]);
			Info_FUN_00419580(infoType,stringParts[1]);
			BVar3 = snd::SFX_GetType(stringParts[2],&sfxType);
			if (BVar3 != 0) {
				Info_SetSFXType(infoType,sfxType);
			}
			if (uVar5 < 4) {
				Info_SetFlag_10000(infoType,1);
				BVar3 = 0;
			}
			else {
				iVar4 = std::_stricmp(stringParts[3],"SLOW");
				Info_SetFlag_10000(infoType,(uint)(iVar4 == 0));
				iVar4 = std::_stricmp(stringParts[3],"ALWAYSPLAYSFX");
				if (iVar4 == 0) {
					BVar3 = 1;
				}
				else {
					if ((uVar5 < 5) || (iVar4 = std::_stricmp(stringParts[4],"ALWAYSPLAYSFX"), iVar4 != 0)) {
						BVar3 = 0;
					}
					else {
						BVar3 = 1;
					}
				}
			}
			Info_SetFlag_20000(infoType,BVar3);
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



void __cdecl lego::main::Main_LoadToolTips(CFGProperty *root)
{
	char *pcVar1;
	CFGProperty *pCVar2;
	BOOL BVar3;
	ToolTipType toolTipType;
	SFXType sfxType;
	
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ToolTips",0);
	for (pCVar2 = cfg::CFG_GetChildren(root,pcVar1); pCVar2 != NULL;
			pCVar2 = cfg::CFG_NextFlat(pCVar2)) {
		BVar3 = front::ToolTip_GetType(pCVar2->key,&toolTipType);
		if (BVar3 != 0) {
			front::ToolTip_SetText(toolTipType,pCVar2->value);
		}
	}
	pcVar1 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ToolTipsSFXs",0);
	for (pCVar2 = cfg::CFG_GetChildren(root,pcVar1); pCVar2 != NULL;
			pCVar2 = cfg::CFG_NextFlat(pCVar2)) {
		BVar3 = front::ToolTip_GetType(pCVar2->key,&toolTipType);
		if ((BVar3 != 0) && (BVar3 = snd::SFX_GetType(pCVar2->value,&sfxType), BVar3 != 0)) {
			front::ToolTip_SetSFX(toolTipType,sfxType);
		}
	}
	return;
}



BOOL __cdecl lego::game::Game_TryPlaceObject(ObjectType objType,int objIndex)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	Vector3F local_c;
	
	globs::gameGlobs.flags3 &= ~GAME3_PLACEBUILDING;
	front::HelpWindow_Game_SetPlaceFlagsState_004dd650(1);
	if ((objType == OBJECT_BUILDING) || (objType == OBJECT_ELECTRICFENCE)) {
		globs::gameGlobs.flags3 |= GAME3_PLACEBUILDING;
		globs::gameGlobs.placeObjType = objType;
		globs::gameGlobs.placeObjIndex = objIndex;
		res::Container_GetOrientation((globs::gameGlobs.cameraMain)->resData1,NULL,&local_c,NULL);
		if (ABS(local_c.x) <= ABS(local_c.y)) {
			if ((ushort)((ushort)(local_c.y < 0.0) << 8 | (ushort)(local_c.y == 0.0) << 0xe) == 0) {
				globs::gameGlobs.placeObjDirection = DIRECTION_DOWN;
				return 1;
			}
			globs::gameGlobs.placeObjDirection = DIRECTION_UP;
			return 1;
		}
		if ((ushort)((ushort)(local_c.x < 0.0) << 8 | (ushort)(local_c.x == 0.0) << 0xe) == 0) {
			globs::gameGlobs.placeObjDirection = DIRECTION_LEFT;
			return 1;
		}
		globs::gameGlobs.placeObjDirection = DIRECTION_RIGHT;
		return 1;
	}
	OVar1 = Object_GetStatsFlags2(objType,objIndex);
	if ((OVar1 & STATS2_USESMALLTELEPORTER) != STATS2_NONE) {
		BVar2 = LiveObject_QueueTeleport(globs::gameGlobs.placeDestSmallTeleporter,objType,objIndex);
		return BVar2;
	}
	OVar1 = Object_GetStatsFlags2(objType,objIndex);
	if ((OVar1 & STATS2_USEBIGTELEPORTER) != STATS2_NONE) {
		BVar2 = LiveObject_QueueTeleport(globs::gameGlobs.placeDestBigTeleporter,objType,objIndex);
		return BVar2;
	}
	OVar1 = Object_GetStatsFlags2(objType,objIndex);
	if ((OVar1 & STATS2_USEWATERTELEPORTER) != STATS2_NONE) {
		BVar2 = LiveObject_QueueTeleport(globs::gameGlobs.placeDestWaterTeleporter,objType,objIndex);
		return BVar2;
	}
	OVar1 = Object_GetStatsFlags2(objType,objIndex);
	if ((OVar1 & STATS2_USELEGOMANTELEPORTER) != STATS2_NONE) {
		BVar2 = LiveObject_QueueTeleport(NULL,objType,objIndex);
		return BVar2;
	}
	return 0;
}



void __cdecl FUN_00434f40(int *param_1,int param_2)
{
	uint uVar1;
	LevelData *pLVar2;
	uint uVar3;
	int iVar4;
	int iVar5;
	int iVar6;
	
	pLVar2 = lego::globs::gameGlobs.level;
	iVar4 = -param_2;
	iVar6 = iVar4;
	if (-param_2 == param_2 || SBORROW4(iVar4,param_2) != param_2 * -2 < 0) {
		do {
			for (iVar5 = iVar4; iVar5 <= param_2; iVar5 += 1) {
				if ((((iVar5 * iVar5 + iVar6 * iVar6 <= param_2 * param_2) &&
						 (uVar1 = iVar5 + *param_1, -1 < (int)uVar1)) &&
						((int)uVar1 < (pLVar2->dimensions).width)) &&
					 ((uVar3 = param_1[1] + iVar6, -1 < (int)uVar3 &&
						((int)uVar3 < (pLVar2->dimensions).height)))) {
					FUN_00433220(uVar1,uVar3);
				}
			}
			iVar6 += 1;
		} while (iVar6 <= param_2);
	}
	return;
}



void __cdecl lego::main::Main_LoadSurfaceTypeDescriptions_sound(CFGProperty *root,char *keyBasePath)
{
	char cVar1;
	char *pcVar2;
	BOOL BVar3;
	uint uVar4;
	uint uVar5;
	void **ppvVar6;
	undefined4 *puVar7;
	char *pcVar8;
	char *pcVar9;
	undefined4 *puVar10;
	SFXType local_430;
	undefined4 *local_42c;
	char *local_428;
	char *local_424;
	undefined4 local_400 [256];
	
	ppvVar6 = globs::gameGlobs.SurfaceTypeDescriptions_sound_TABLE;
	do {
		pcVar2 = cfg::CFG_JoinPath(keyBasePath,"SurfaceTypeDescriptions",ppvVar6[-0x24],0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
		if (pcVar2 != NULL) {
			uVar4 = 0xffffffff;
			local_42c = local_400;
			pcVar8 = pcVar2;
			do {
				pcVar9 = pcVar8;
				if (uVar4 == 0) break;
				uVar4 -= 1;
				pcVar9 = pcVar8 + 1;
				cVar1 = *pcVar8;
				pcVar8 = pcVar9;
			} while (cVar1 != '\0');
			uVar4 = ~uVar4;
			puVar7 = (undefined4 *)(pcVar9 + -uVar4);
			puVar10 = local_42c;
			for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
				*puVar10 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar10 = puVar10 + 1;
			}
			for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
				*(undefined *)puVar10 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar10 = (undefined4 *)((int)puVar10 + 1);
			}
			util::Util_Tokenise(pcVar2,&local_428,",");
			pcVar2 = util::Util_RemoveUnderscores(local_428);
			ppvVar6[-0x12] = pcVar2;
			BVar3 = snd::SFX_GetType(local_424,&local_430);
			*ppvVar6 = (void *)(-(uint)(BVar3 != 0) & local_430);
		}
		ppvVar6 = ppvVar6 + 1;
		if ((void **)((int)globs::gameGlobs.SurfaceTypeDescriptions_sound_TABLE + 0x47) < ppvVar6) {
			return;
		}
	} while( true );
}



char * __cdecl lego::game::Game_GetSurfaceTypeDescription(SurfaceType surfaceType)
{
	char *pcVar1;
	
	pcVar1 = globs::gameGlobs.SurfaceTypeDescriptions_name_TABLE[surfaceType];
	if (pcVar1 == NULL) {
		pcVar1 = "Need config for surface type.";
	}
	return pcVar1;
}



void * __cdecl lego::game::Game_GetSurfaceTypeSFX(SurfaceType surfaceType)
{
	return globs::gameGlobs.SurfaceTypeDescriptions_sound_TABLE[surfaceType];
}



void __cdecl FUN_004350d0(int param_1)
{
	if (param_1 == 1) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_IMMOVABLE);
		return;
	}
	if (param_1 == 2) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_HARD);
		return;
	}
	if (param_1 == 3) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_MEDIUM);
		return;
	}
	if (param_1 == 4) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_LOOSE);
		return;
	}
	if (param_1 == 5) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_SOIL);
		return;
	}
	if (param_1 == 8) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_ORESEAM);
		return;
	}
	if (param_1 == 10) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_CRYSTALSEAM);
		return;
	}
	if (param_1 == 0xb) {
		lego::front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_SURFACETYPE_RECHARGESEAM);
	}
	return;
}



void __cdecl FUN_00435160(Point2I *param_1,int param_2,int param_3)
{
	uint uVar1;
	short sVar2;
	short sVar3;
	uint uVar4;
	BOOL BVar5;
	int iVar6;
	int *piVar7;
	uint local_19c;
	Point2I local_198;
	int local_190 [100];
	
	piVar7 = local_190;
	for (iVar6 = 100; iVar6 != 0; iVar6 += -1) {
		*piVar7 = 0;
		piVar7 = piVar7 + 1;
	}
	uVar1 = param_2 * 2;
	local_19c = 0;
	while( true ) {
		if (param_3 == 0) {
			uVar4 = uVar1 * uVar1 >> 2;
		}
		else {
			uVar4 = uVar1 * uVar1;
		}
		if (uVar4 <= local_19c) break;
		sVar2 = lego::math::Maths_Rand();
		sVar3 = lego::math::Maths_Rand();
		local_198.x = ((uint)(int)sVar2 % uVar1 + param_1->x) - param_2;
		local_198.y = (param_1->y + (uint)(int)sVar3 % uVar1) - param_2;
		iVar6 = (uint)(int)sVar3 % uVar1 + ((uint)(int)sVar2 % uVar1) * 10;
		if (local_190[iVar6] == 0) {
			BVar5 = lego::game::Fallin_Block_FUN_0040f0c0(&local_198,1);
			if ((BVar5 != 0) && (param_3 != 0)) {
				return;
			}
			local_190[iVar6] = 1;
		}
		local_19c += 1;
	}
	return;
}



void __cdecl
lego::game::Level_FUN_00435230
					(LevelData *level,Viewport *viewMain,float elapsedGame,float elapsedAbs)
{
	LevelBlock *pLVar1;
	TutorialFlags TVar2;
	SurfaceMap *pSVar3;
	BOOL BVar4;
	WallHighlightType WVar5;
	uint by;
	uint bx;
	float10 fVar6;
	float10 fVar7;
	Point2F local_14;
	Vector3F local_c;
	
	fVar6 = (float10)fsin((float10)TIMER_004df58c);
	TIMER_004df58c = TIMER_004df58c - elapsedAbs * 25.0 * -0.01333333;
	TVar2 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if (TVar2 != TUTORIAL_NONE) {
		by = 0;
		pSVar3 = level->surfaceMap;
		if ((pSVar3->smallDimensions).height != 0) {
			do {
				bx = 0;
				if ((pSVar3->smallDimensions).width != 0) {
					do {
						BVar4 = Level_Block_FUN_00433d60(bx,by);
						if (BVar4 == 0) {
							pLVar1 = level->blocks + by * (level->dimensions).width + bx;
							if (pLVar1->blockpointer == 0) {
								if (pLVar1->field_44 == 1) {
									pLVar1->field_44 = 0;
									TVar2 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
									if ((((TVar2 & TUTORIAL_UNK_2) == TUTORIAL_NONE) &&
											(level->blocks[by * (level->dimensions).width + bx].clickCount != 0)) &&
										 (InterfaceMenuType_004deccc == INTERFACE_MENU_MAIN)) {
										Map3D_Block_SetHighlightType
															((globs::gameGlobs.level)->surfaceMap,bx,by,WALLHIGHLIGHT_SELECTED);
									}
									else {
										pSVar3 = (globs::gameGlobs.level)->surfaceMap;
LAB_0043544b:
										Map3D_Block_ClearHighlight(pSVar3,bx,by);
									}
								}
								else {
									if ((pLVar1->field_44 == 0) &&
										 (WVar5 = Map3D_Block_GetHighlightType
																				((globs::gameGlobs.level)->surfaceMap,bx,by),
										 WVar5 == WALLHIGHLIGHT_TUTORIAL)) {
										pSVar3 = (globs::gameGlobs.level)->surfaceMap;
										goto LAB_0043544b;
									}
								}
							}
							else {
								Map3D_BlockToWorldPos(level->surfaceMap,bx,by,(float *)&local_c,&local_c.y);
								fVar7 = Map3D_GetWorldZ(level->surfaceMap,local_c.x,local_c.y);
								local_c.z = (float)fVar7;
								lego::view::Viewport_WorldToScreen(viewMain,&local_14,&local_c);
								local_14.x = local_14.x - (float)((int)(globs::gameGlobs.TutorialIcon)->width / 2);
								local_14.y = local_14.y -
														 ((float)fVar6 * 20.0 +
														 (float)((globs::gameGlobs.TutorialIcon)->height << 1));
								lego::image::Image_DisplayScaled(globs::gameGlobs.TutorialIcon,NULL,&local_14,NULL);
								if (BOOL_004ded1c == 0) {
									Map3D_Block_ClearHighlight((globs::gameGlobs.level)->surfaceMap,bx,by);
									level->blocks[by * (level->dimensions).width + bx].field_44 = 1;
								}
								else {
									Map3D_Block_SetHighlightType
														((globs::gameGlobs.level)->surfaceMap,bx,by,WALLHIGHLIGHT_TUTORIAL);
									level->blocks[by * (level->dimensions).width + bx].field_44 = 1;
								}
							}
						}
						bx += 1;
					} while (bx < (uint)(level->surfaceMap->smallDimensions).width);
				}
				pSVar3 = level->surfaceMap;
				by += 1;
			} while (by < (uint)(pSVar3->smallDimensions).height);
		}
	}
	return;
}



BOOL __cdecl lego::front::Front_LeftButtonInputUnk_FUN_00435480(void)
{
	if ((globs::INPUT.mslb == 0) && (globals::g_Front_mslb_Last_0 != 0)) {
		globals::g_Front_mslb_Last_0 = globs::INPUT.mslb;
		return TRUE;
	}
	globals::g_Front_mslb_Last_0 = globs::INPUT.mslb;
	return 0;
}



BOOL __cdecl lego::front::Front_DrawDialogContrastOverlay(void)
{
	Point2F point;
	
	point.x = 0.0;
	point.y = 0.0;
	if (globs::gameGlobs.DialogContrastOverlay == NULL) {
		return 0;
	}
	lego::image::Image_DisplayScaled(globs::gameGlobs.DialogContrastOverlay,NULL,&point,NULL);
	return TRUE;
}



int __cdecl
lego::front::SaveMenu_ConfirmMessage_FUN_004354f0
					(char *titleText,char *message,char *okText,char *cancelText)
{
	float fVar1;
	float fVar2;
	uint uVar3;
	uint uVar4;
	BOOL BVar5;
	int iVar6;
	Point2F local_18;
	float local_c;
	undefined4 local_8;
	float local_4;
	
	iVar6 = -1;
	if (((globs::gameGlobs.DialogImage != NULL) && (globs::gameGlobs.DialogTextWndTitle != NULL)) &&
		 (globs::gameGlobs.DialogTextWndMessage != NULL)) {
		Front_DrawDialogContrastOverlay();
		local_18.x = (float)((int)globs::mainGlobs.appWidth / 2) -
								 (float)((globs::gameGlobs.DialogImage)->width >> 1);
		local_18.y = (float)((int)globs::mainGlobs.appHeight / 2) -
								 (float)((globs::gameGlobs.DialogImage)->height >> 1);
		lego::image::Image_DisplayScaled(globs::gameGlobs.DialogImage,NULL,&local_18,NULL);
		TextWindow_Clear(globs::gameGlobs.DialogTextWndTitle);
		TextWindow_Clear(globs::gameGlobs.DialogTextWndMessage);
		TextWindow_Clear(globs::gameGlobs.DialogTextWndOK);
		TextWindow_Clear(globs::gameGlobs.DialogTextWndCancel);
		if (okText != NULL) {
			local_c = 0.0;
			local_8 = 0;
			local_4 = 0.0;
			uVar3 = lego::image::Font_GetStringWidth(globs::gameGlobs.bmpMbriefFONT,okText);
			uVar4 = lego::image::Font_GetHeight(globs::gameGlobs.bmpMbriefFONT);
			fVar1 = (((globs::gameGlobs.DialogTextWndOK)->windowSize).x -
							((globs::gameGlobs.DialogTextWndOK)->windowSize).width * -0.5) - (float)(uVar3 >> 1);
			local_c = ((globs::gameGlobs.DialogTextWndOK)->windowSize).y;
			local_4 = (float)(ulonglong)uVar4;
			fVar2 = (float)globs::INPUT.msx;
			if ((((ushort)((ushort)(fVar2 < fVar1) << 8 | (ushort)(fVar2 == fVar1) << 0xe) != 0) ||
					(fVar1 + (float)(ulonglong)uVar3 <= fVar2)) ||
				 ((fVar1 = (float)globs::INPUT.msy,
					(ushort)((ushort)(fVar1 < local_c) << 8 | (ushort)(fVar1 == local_c) << 0xe) != 0 ||
					(local_c + local_4 <= fVar1)))) {
				(globs::gameGlobs.DialogTextWndOK)->font = globs::gameGlobs.bmpMbriefFONT;
				TextWindow_PrintF(globs::gameGlobs.DialogTextWndOK,okText);
			}
			else {
				(globs::gameGlobs.DialogTextWndOK)->font = globs::gameGlobs.bmpMbriefFONT2;
				TextWindow_PrintF(globs::gameGlobs.DialogTextWndOK,okText);
				BVar5 = Front_LeftButtonInputUnk_FUN_00435480();
				if (BVar5 != 0) {
					iVar6 = 1;
				}
			}
		}
		if (cancelText != NULL) {
			local_c = 0.0;
			local_8 = 0;
			local_4 = 0.0;
			uVar3 = lego::image::Font_GetStringWidth(globs::gameGlobs.bmpMbriefFONT,cancelText);
			uVar4 = lego::image::Font_GetHeight(globs::gameGlobs.bmpMbriefFONT);
			fVar1 = (((globs::gameGlobs.DialogTextWndCancel)->windowSize).x -
							((globs::gameGlobs.DialogTextWndCancel)->windowSize).width * -0.5) -
							(float)(uVar3 >> 1);
			local_c = ((globs::gameGlobs.DialogTextWndCancel)->windowSize).y;
			local_4 = (float)(ulonglong)uVar4;
			fVar2 = (float)globs::INPUT.msx;
			if ((((ushort)((ushort)(fVar2 < fVar1) << 8 | (ushort)(fVar2 == fVar1) << 0xe) != 0) ||
					(fVar1 + (float)(ulonglong)uVar3 <= fVar2)) ||
				 ((fVar1 = (float)globs::INPUT.msy,
					(ushort)((ushort)(fVar1 < local_c) << 8 | (ushort)(fVar1 == local_c) << 0xe) != 0 ||
					(local_c + local_4 <= fVar1)))) {
				(globs::gameGlobs.DialogTextWndCancel)->font = globs::gameGlobs.bmpMbriefFONT;
				TextWindow_PrintF(globs::gameGlobs.DialogTextWndCancel,cancelText);
			}
			else {
				(globs::gameGlobs.DialogTextWndCancel)->font = globs::gameGlobs.bmpMbriefFONT2;
				TextWindow_PrintF(globs::gameGlobs.DialogTextWndCancel,cancelText);
				BVar5 = Front_LeftButtonInputUnk_FUN_00435480();
				if (BVar5 != 0) {
					iVar6 = 0;
				}
			}
		}
		TextWindow_PrintF(globs::gameGlobs.DialogTextWndTitle,titleText);
		TextWindow_PrintF(globs::gameGlobs.DialogTextWndMessage,message);
		TextWindow_Update(globs::gameGlobs.DialogTextWndTitle,0,1.0,NULL);
		TextWindow_Update(globs::gameGlobs.DialogTextWndMessage,0,1.0,NULL);
		TextWindow_Update(globs::gameGlobs.DialogTextWndOK,0,1.0,NULL);
		TextWindow_Update(globs::gameGlobs.DialogTextWndCancel,0,1.0,NULL);
		return iVar6;
	}
	return -1;
}



BOOL __cdecl FUN_00435870(void)
{
	BOOL BVar1;
	BOOL BVar2;
	BOOL BVar3;
	char *levelName;
	int iVar4;
	
	lego::game::GetLevel();
	BVar1 = lego::unk::Lego_GetIntNotM1__00558020();
	BVar2 = lego::front::Front_GetUnkTutoOrMissions();
	lego::snd::Sound3D_StopAllSounds();
	BVar3 = lego::main::Config_IsFrontEndEnabled();
	if (BVar3 != 0) {
		lego::reward::Reward_LoadLevelFrontEnd();
		lego::reward::Reward_FUN_00460620();
		lego::reward::Reward_waitFrontEndRewards_FUN_004616d0();
		lego::reward::RewardFrontEnd_Free();
	}
	lego::game::Game_SetViewMode(VIEW_TOPDOWN,NULL,0);
	lego::front::TextWindow_Clear(lego::globs::gameGlobs.textWnd_80);
	levelName = lego::game::Level_Free();
	BVar3 = lego::main::Config_IsFrontEndEnabled();
	if (BVar3 != 0) {
		if (BVar1 == 0) {
			if (BVar2 == 0) goto LAB_00435915;
			lego::front::Front_RunScreenMenuType(MENU_SCREEN_TRAINING);
			iVar4 = lego::front::Front_IsTriggerAppQuit();
			if (iVar4 != 0) {
				return 0;
			}
		}
		else {
			lego::front::Front_RunScreenMenuType(MENU_SCREEN_MISSIONS);
			iVar4 = lego::front::Front_IsTriggerAppQuit();
			if (iVar4 != 0) {
				return 0;
			}
		}
		levelName = lego::front::Front_GetSelectedLevel();
	}
LAB_00435915:
	lego::front::Front_FUN_00416870(1,0);
	if (levelName == NULL) {
		return 0;
	}
	BVar1 = lego::main::Main_loadLevelCFG(levelName);
	if (BVar1 == 0) {
		return 0;
	}
	std::free(levelName);
	return TRUE;
}



void __cdecl lego::game::Game_ClearSomeFlags3_FUN_00435950(void)
{
	globs::gameGlobs.flags3 &=
			 ~(GAME3_UNK_1|GAME3_UNK_2|GAME3_UNK_4|GAME3_PICKUPOBJECT|GAME3_LOADVEHICLE|GAME3_UNK_20|
				 GAME3_UNK_40|GAME3_PLACEBUILDING);
	res::ResLp_Hide(globs::gameGlobs.RES_2f4_TABLEUNK,TRUE);
	return;
}



void __cdecl lego::game::Game_UnkTeleporterInit_FUN_00435980(void)
{
	BOOL BVar1;
	
	if ((globs::gameGlobs.flags1 & GAME1_UNK_8000000) != GAME1_NONE) {
		BVar1 = unk::Teleporter_FUN_0046a780
											(TELEPORT_SERVIVE_VEHICLE|TELEPORT_SERVIVE_MINIFIGURE|
											 TELEPORT_SERVIVE_BUILDING|TELEPORT_SERVIVE_ELECTRICFENCE);
		if (BVar1 != 0) {
			globs::gameGlobs.flags2 |= GAME2_UNK_2;
		}
	}
	return;
}



void __cdecl lego::game::Game_SetAttackDefer(BOOL defer)
{
	if (defer != 0) {
		globs::gameGlobs.flags2 = globs::gameGlobs.flags2 | GAME2_ATTACKDEFER;
		return;
	}
	globs::gameGlobs.flags2 = globs::gameGlobs.flags2 & ~GAME2_ATTACKDEFER;
	return;
}



void __cdecl lego::game::Game_SetCallToArmsOn(BOOL callToArms)
{
	if (callToArms != 0) {
		globs::gameGlobs.flags2 |= GAME2_CALLTOARMS;
		if ((ushort)((ushort)(globs::gameGlobs.timerGame_e3c < 0.0) << 8 |
								(ushort)(globs::gameGlobs.timerGame_e3c == 0.0) << 0xe) != 0) {
			snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_SIREN,0);
			globs::gameGlobs.timerGame_e3c = 250.0;
		}
		front::Panel_FUN_0045aeb0(PANEL_TOPPANEL,2,1);
		return;
	}
	globs::gameGlobs.flags2 &= ~GAME2_CALLTOARMS;
	globs::gameGlobs.timerGame_e3c = 0.0;
	front::Panel_FUN_0045aeb0(PANEL_TOPPANEL,2,0);
	return;
}



CameraData * __cdecl lego::view::Camera_Create(Container *resRoot,CameraType camType)
{
	CameraData *cam;
	Container *pCVar1;
	
	cam = (CameraData *)std::malloc(0xbc);
	if (cam != NULL) {
		cam->camType = camType;
		cam->trackObj = NULL;
		cam->trackDist = 0.0;
		cam->trackFloat_8 = 0.0;
		*(undefined *)&cam->flags = CAMERA_NONE;
		cam->yaw = 0.0;
		cam->tilt = 0.0;
		cam->dist = 200.0;
		cam->field_14 = 0;
		(cam->vector_18).x = 0.0;
		(cam->vector_18).y = 0.0;
		(cam->vector_18).z = 0.0;
		cam->speedAccel_9c = 0.0;
		(cam->vector_a0).z = 0.0;
		(cam->vector_a0).y = 0.0;
		(cam->vector_a0).x = 0.0;
		(cam->vector_ac).z = 0.0;
		(cam->vector_ac).y = 0.0;
		(cam->vector_ac).x = 0.0;
		pCVar1 = res::Container_Create(NULL);
		cam->resData1 = pCVar1;
		if (cam->resData1 != NULL) {
			res::Container_SetPosition(cam->resData1,NULL,0.0,0.0,-cam->dist);
			res::Container_SetOrientation(cam->resData1,NULL,0.0,0.0,1.0,0.0,1.0,0.0);
			if (camType == CAMERATYPE_FIRSTPERSON) {
				res::Container_SetParent(cam->resData1,resRoot);
				return cam;
			}
			pCVar1 = res::Container_Create(resRoot);
			cam->resData2 = pCVar1;
			if (cam->resData2 != NULL) {
				pCVar1 = res::Container_Create(resRoot);
				cam->resData3 = pCVar1;
				if (cam->resData3 != NULL) {
					pCVar1 = res::Container_Create(cam->resData2);
					cam->resData4 = pCVar1;
					if (cam->resData4 != NULL) {
						if (camType == CAMERATYPE_TOPDOWN) {
							pCVar1 = res::Container_Create(cam->resData4);
							cam->resTableunk_34 = pCVar1;
							if (cam->resTableunk_34 != NULL) {
								res::Container_SetPosition(cam->resTableunk_34,NULL,0.0,0.0,-80.0);
							}
						}
						res::Container_SetParent(cam->resData1,cam->resData4);
						return cam;
					}
					res::Container_Remove(cam->resData3);
				}
				res::Container_Remove(cam->resData2);
			}
			res::Container_Remove(cam->resData1);
		}
		std::free(cam);
	}
	return NULL;
}



void __cdecl lego::view::Camera_Debug_EnableEditMode(CameraData *cam,BOOL enableUnsetFlag)
{
	if (enableUnsetFlag == 0) {
										// ~CAMERA_EDITMODE_UNK (~0x8)
		*(byte *)&cam->flags = *(byte *)&cam->flags & 0xf7;
	}
	else {
		*(byte *)&cam->flags = *(byte *)&cam->flags | CAMERA_EDITMODE_UNK;
	}
	return;
}



void __cdecl lego::view::Camera_Free(CameraData *cam)
{
	res::Container_Remove(cam->resData1);
	if (cam->camType != CAMERATYPE_FIRSTPERSON) {
		res::Container_Remove(cam->resData2);
		res::Container_Remove(cam->resData4);
	}
	std::free(cam);
	return;
}



void __cdecl
lego::view::Camera_SetCameraMovements
					(float cameraSpeed,float cameraDropOff,float cameraAcceleration,int mouseScrollIndent)
{
	globs::cameraGlobs.CameraSpeed = cameraSpeed;
	globs::cameraGlobs.CameraDropOff = cameraDropOff;
	globs::cameraGlobs.CameraAcceleration = cameraAcceleration;
	globs::cameraGlobs.MouseScrollIndent = mouseScrollIndent;
	return;
}



void __cdecl lego::view::Camera_CopyPositionOrientation(CameraData *dstCamera,CameraData *srcCamera)
{
	Vector3F vectorPos;
	Vector3F vectorD;
	Vector3F vectorU;
	
	if (dstCamera->camType == CAMERATYPE_FIRSTPERSON) {
		res::Container_GetPosition(srcCamera->resData1,NULL,&vectorPos);
		res::Container_GetOrientation(srcCamera->resData1,NULL,&vectorD,&vectorU);
		res::Container_SetPosition(dstCamera->resData1,NULL,vectorPos.x,vectorPos.y,vectorPos.z);
		res::Container_SetOrientation
							(dstCamera->resData1,NULL,vectorD.x,vectorD.y,vectorD.z,vectorU.x,vectorU.y,vectorU.z)
		;
	}
	return;
}



// Set liveObj to NULL to disable.

void __cdecl
lego::view::Camera_FollowObject
					(CameraData *cam,LiveObject *liveObj,float param_3,float trackDist,float param_5,
					float param_6)
{
	cam->trackObj = liveObj;
	cam->trackFloat_8 = param_3;
	cam->trackDist = trackDist;
	Camera_SetTilt(cam,param_5);
	cam->trackFloat_10 = param_6;
	return;
}



void __cdecl
lego::view::Camera_SetObject4_Field14(CameraData *cam,LiveObject *liveObj,undefined4 param_3)
{
	cam->trackObj = liveObj;
	cam->field_14 = param_3;
	return;
}



undefined4 __cdecl lego::view::Camera_GetField14(CameraData *cam)
{
	return cam->field_14;
}



void __cdecl lego::view::Camera_ZeroField9c_UnkSpeedAccel(CameraData *cam)
{
	cam->speedAccel_9c = 0.0;
	return;
}



int __cdecl lego::view::Camera_GetMouseScrollIndent(void)
{
	return globs::cameraGlobs.MouseScrollIndent;
}



void __cdecl lego::view::Camera_SetFloata0_a4_Zeroa8(CameraData *cam,float param_2,float param_3)
{
	(cam->vector_a0).x = param_2;
	(cam->vector_a0).y = param_3;
	(cam->vector_a0).z = 0.0;
	return;
}



void __cdecl lego::view::Camera_Update(CameraData *cam,LevelData *level,float param_3,float param_4)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	BOOL BVar5;
	SurfaceMap *surfMap;
	float10 fVar6;
	Vector3F local_e0;
	float local_d4;
	float local_d0;
	float local_cc;
	float local_c8;
	float local_c4;
	float local_c0;
	float local_bc;
	Vector3F local_b8;
	Vector3F local_ac;
	Vector3F local_a0;
	float local_94;
	float local_90;
	float local_8c;
	float local_88;
	Vector3F local_84;
	Container *local_78;
	float local_74;
	float local_70;
	float local_6c;
	Vector3F local_68;
	float local_5c;
	Vector3F local_58;
	Vector3F local_4c;
	float local_40;
	float local_3c;
	float local_38;
	float local_34;
	Vector3F local_30;
	Vector3F local_24;
	Vector3F local_18;
	uint local_c;
	uint local_8;
	
	res::Container_AddTranslation
						(cam->resData1,D3DRMCOMBINE_BEFORE,-(cam->vector_ac).x,-(cam->vector_ac).y,
						 -(cam->vector_ac).z);
	fVar1 = globs::cameraGlobs.CameraDropOff;
	if (cam->camType == CAMERATYPE_TOPDOWN) {
		(cam->vector_18).x = (cam->vector_18).x * globs::cameraGlobs.CameraDropOff;
		(cam->vector_18).y = (cam->vector_18).y * fVar1;
		(cam->vector_18).z = (cam->vector_18).z * fVar1;
		res::Container_AddTranslation
							(cam->resData2,D3DRMCOMBINE_AFTER,(cam->vector_18).x,(cam->vector_18).y,
							 (cam->vector_18).z);
		res::Container_GetPosition(cam->resData2,NULL,&local_30);
		res::Container_GetOrientation(cam->resData2,NULL,&local_24,&local_18);
		BVar5 = game::Map3D_WorldToBlockPos_NoZ
											(level->surfaceMap,local_30.x,local_30.y,(int *)&local_8,(int *)&local_c);
		if (BVar5 == 0) {
			res::Container_AddTranslation
								(cam->resData2,D3DRMCOMBINE_AFTER,-(cam->vector_18).x,-(cam->vector_18).y,
								 -(cam->vector_18).z);
		}
		else {
			if ((local_8 < (uint)globs::cameraGlobs.MouseScrollIndent) ||
				 ((uint)((level->surfaceMap->smallDimensions).width - globs::cameraGlobs.MouseScrollIndent)
					<= local_8)) {
				res::Container_AddTranslation(cam->resData2,D3DRMCOMBINE_AFTER,-(cam->vector_18).x,0.0,0.0);
			}
			if ((local_c < (uint)globs::cameraGlobs.MouseScrollIndent) ||
				 ((uint)((level->surfaceMap->smallDimensions).height - globs::cameraGlobs.MouseScrollIndent)
					<= local_c)) {
				res::Container_AddTranslation(cam->resData2,D3DRMCOMBINE_AFTER,0.0,-(cam->vector_18).y,0.0);
			}
			fVar6 = game::Map3D_GetWorldZ(level->surfaceMap,local_30.x,local_30.y);
			res::Container_SetPosition(cam->resData3,NULL,local_30.x,local_30.y,(float)fVar6);
			res::Container_SetOrientation(cam->resData3,NULL,local_18.x,local_18.y,0.0,0.0,0.0,-1.0);
			surfMap = game::GetSurfaceMap();
			fVar6 = game::Map3D_UnkCameraXYFunc_RetZunk(surfMap,local_30.x,local_30.y);
			local_34 = (float)-fVar6;
			local_38 = cam->dist + local_34;
			res::Container_SetPosition(cam->resData1,cam->resData4,0.0,0.0,-local_38);
		}
		goto LAB_004368f0;
	}
	if (cam->camType != CAMERATYPE_FIRSTPERSON) {
		if (cam->camType == CAMERATYPE_RADAR) {
			if (cam->trackObj == NULL) {
				game::Game_SetFlag1_20000_unkCamera(1);
			}
			else {
				local_78 = game::LiveObject_GetContainer(cam->trackObj);
				if (local_78 != NULL) {
					local_88 = cam->trackFloat_8 * param_4;
					game::Game_SetFlag1_20000_unkCamera(0);
					res::Container_GetPosition(cam->resData1,NULL,&local_a0);
					res::Container_GetPosition(local_78,NULL,&local_84);
					local_84.z = local_84.z - cam->trackDist / 10.0;
					fVar1 = cam->dist;
					cam->dist = cam->trackDist;
					res::Container_SetPosition(cam->resData1,cam->resData4,0.0,0.0,-cam->dist);
					res::Container_GetPosition(cam->resData2,NULL,&local_b8);
					res::Container_SetPosition(cam->resData2,NULL,local_84.x,local_84.y,local_84.z);
					res::Container_GetPosition(cam->resData1,NULL,&local_e0);
					local_c8 = local_e0.x - local_a0.x;
					local_c4 = local_e0.y - local_a0.y;
					local_c0 = local_e0.z - local_a0.z;
					fVar6 = std::sqrt((double)(local_c0 * local_c0 + local_c4 * local_c4 + local_c8 * local_c8
																		));
					local_8c = (float)fVar6;
					if (((ushort)((ushort)(fVar6 < (float10)local_88) << 8 |
											 (ushort)(fVar6 == (float10)local_88) << 0xe) == 0) && (local_8c < 120.0)) {
						local_90 = local_8c / local_88;
						res::Container_GetOrientation(local_78,NULL,&local_ac,NULL);
						local_d4 = local_ac.x * local_90;
						local_d0 = local_ac.y * local_90;
						local_cc = local_ac.z * local_90;
						local_84.x = local_84.x + local_d4;
						local_84.y = local_84.y + local_d0;
						local_84.z = local_84.z + local_cc;
						local_c8 = local_84.x - local_b8.x;
						local_c4 = local_84.y - local_b8.y;
						local_c0 = local_84.z - local_b8.z;
						fVar6 = std::sqrt((double)(local_c0 * local_c0 +
																			local_c4 * local_c4 + local_c8 * local_c8));
						local_94 = (float)fVar6;
						fVar6 = std::round((double)(cam->trackDist - fVar1));
						local_bc = (float)fVar6;
						fVar2 = local_94 + local_bc;
						fVar6 = std::sqrt((double)(local_c0 * local_c0 +
																			local_c4 * local_c4 + local_c8 * local_c8));
						fVar3 = 1.0 / (float)fVar6;
						fVar4 = (local_94 / fVar2) * local_88;
						local_c8 = local_c8 * fVar3 * fVar4;
						local_c4 = local_c4 * fVar3 * fVar4;
						local_c0 = local_c0 * fVar3 * fVar4;
						local_b8.x = local_b8.x + local_c8;
						local_b8.y = local_b8.y + local_c4;
						local_b8.z = local_b8.z + local_c0;
						res::Container_SetPosition(cam->resData2,NULL,local_b8.x,local_b8.y,local_b8.z);
						if ((ushort)((ushort)(fVar1 < cam->trackDist) << 8 |
												(ushort)(fVar1 == cam->trackDist) << 0xe) == 0) {
							cam->dist = fVar1 - (local_bc / fVar2) * local_88;
						}
						else {
							if (fVar1 != cam->trackDist) {
								cam->dist = (local_bc / fVar2) * local_88 + fVar1;
							}
						}
						res::Container_SetPosition(cam->resData1,cam->resData4,0.0,0.0,-cam->dist);
					}
					Camera_AddYaw(cam,cam->trackFloat_10 * param_3);
				}
			}
		}
		goto LAB_004368f0;
	}
	if ((cam->trackObj == NULL) || (param_3 == 0.0)) goto LAB_004368f0;
	res::Container_GetPosition(cam->resData1,NULL,&local_58);
	res::Container_GetOrientation(cam->resData1,NULL,&local_4c,&local_68);
	game::LiveObject_UnkCameraFunc(cam->trackObj,cam->field_14,&local_74,&local_68);
	if ((*(byte *)&cam->flags & 0x10) == 0) {
LAB_0043621d:
		local_58.x = local_74;
		local_58.y = local_70;
		local_58.z = local_6c;
		local_4c.x = local_68.x;
		local_4c.y = local_68.y;
		local_4c.z = local_68.z;
	}
	else {
		fVar6 = std::sqrt((double)((local_6c - local_58.z) * (local_6c - local_58.z) +
															(local_70 - local_58.y) * (local_70 - local_58.y) +
															(local_74 - local_58.x) * (local_74 - local_58.x)));
		local_40 = (float)fVar6;
		if (((ushort)((ushort)(fVar6 < (float10)100.0) << 8 | (ushort)(fVar6 == (float10)100.0) << 0xe)
				 == 0) ||
			 (local_5c = local_68.x * local_4c.x + local_68.y * local_4c.y + local_68.z * local_4c.z,
			 local_5c < 0.0)) goto LAB_0043621d;
	}
	local_3c = (1.0 / param_3) * 4.0;
	fVar6 = std::sqrt((double)(local_4c.z * local_4c.z +
														local_4c.y * local_4c.y + local_4c.x * local_4c.x));
	fVar1 = 1.0 / (float)fVar6;
	local_4c.x = local_4c.x * fVar1;
	local_4c.y = local_4c.y * fVar1;
	local_4c.z = local_4c.z * fVar1;
	fVar6 = std::sqrt((double)(local_68.z * local_68.z +
														local_68.y * local_68.y + local_68.x * local_68.x));
	fVar1 = 1.0 / (float)fVar6;
	local_4c.x = local_4c.x * local_3c;
	local_4c.y = local_4c.y * local_3c;
	local_4c.z = local_4c.z * local_3c;
	local_68.x = local_68.x * fVar1 + local_4c.x;
	local_68.y = local_68.y * fVar1 + local_4c.y;
	local_68.z = local_68.z * fVar1 + local_4c.z;
	local_58.x = local_58.x * local_3c;
	local_58.y = local_58.y * local_3c;
	local_58.z = local_58.z * local_3c;
	fVar1 = 1.0 / (local_3c + 1.0);
	local_74 = (local_74 + local_58.x) * fVar1;
	local_70 = (local_70 + local_58.y) * fVar1;
	local_6c = (local_6c + local_58.z) * fVar1;
	if ((ushort)((ushort)(local_40 < 0.01) << 8 | (ushort)(local_40 == 0.01) << 0xe) == 0) {
		res::Container_SetPosition(cam->resData1,NULL,local_74,local_70,local_6c);
	}
	if (local_5c < 0.99999) {
		res::Container_SetOrientation(cam->resData1,NULL,local_68.x,local_68.y,local_68.z,0.0,0.0,-1.0);
	}
	*(byte *)&cam->flags = *(byte *)&cam->flags | 0x10;
LAB_004368f0:
	if ((cam->vector_a0).y <= (cam->vector_a0).z) {
		(cam->vector_ac).z = 0.0;
		(cam->vector_ac).y = 0.0;
		(cam->vector_ac).x = 0.0;
	}
	else {
		fVar1 = (cam->vector_a0).y;
		fVar2 = (cam->vector_a0).z;
		fVar3 = (cam->vector_a0).y;
		fVar4 = (cam->vector_a0).x;
		fVar6 = math::Maths_RandRange(0.0,1.0);
		math::Maths_Vector3DRandom(&cam->vector_ac);
		fVar1 = ((fVar1 - fVar2) / fVar3) * fVar4 * (float)fVar6;
		(cam->vector_ac).x = (cam->vector_ac).x * fVar1;
		(cam->vector_ac).y = (cam->vector_ac).y * fVar1;
		(cam->vector_ac).z = (cam->vector_ac).z * fVar1;
		(cam->vector_a0).z = (cam->vector_a0).z + param_4;
		res::Container_AddTranslation
							(cam->resData1,D3DRMCOMBINE_BEFORE,-(cam->vector_ac).x,-(cam->vector_ac).y,
							 -(cam->vector_ac).z);
	}
	return;
}



void __cdecl lego::view::Camera_SetTiltRange(CameraData *cam,float minTilt,float maxTilt)
{
	*(byte *)&cam->flags = *(byte *)&cam->flags | 1;
	(cam->TiltRange).min = minTilt;
	(cam->TiltRange).max = maxTilt;
	return;
}



void __cdecl lego::view::Camera_SetTilt(CameraData *cam,float tilt)
{
	float fVar1;
	
	if ((((*(byte *)&cam->flags & CAMERA_TILTRANGE) == 0) ||
			((*(byte *)&cam->flags & CAMERA_EDITMODE_UNK) != 0)) ||
		 (((cam->TiltRange).min <= tilt &&
			(fVar1 = (cam->TiltRange).max,
			(ushort)((ushort)(tilt < fVar1) << 8 | (ushort)(tilt == fVar1) << 0xe) != 0)))) {
		cam->tilt = tilt;
		res::Container_SetOrientation(cam->resData4,cam->resData2,0.0,0.0,1.0,0.0,1.0,0.0);
		res::Container_AddRotation(cam->resData4,D3DRMCOMBINE_BEFORE,1.0,0.0,0.0,-tilt);
	}
	return;
}



void __cdecl lego::view::Camera_AddTilt(CameraData *cam,float tiltAmount)
{
	Camera_SetTilt(cam,tiltAmount + cam->tilt);
	return;
}



void __cdecl lego::view::Camera_SetYawRange(CameraData *cam,float minYaw,float maxYaw)
{
	*(byte *)&cam->flags = *(byte *)&cam->flags | CAMERA_YAWRANGE;
	(cam->YawRange).min = minYaw;
	(cam->YawRange).max = maxYaw;
	return;
}



void __cdecl lego::view::Camera_SetYaw(CameraData *cam,float yaw)
{
	float fVar1;
	
	if ((((*(byte *)&cam->flags & CAMERA_YAWRANGE) == 0) ||
			((*(byte *)&cam->flags & CAMERA_EDITMODE_UNK) != 0)) ||
		 (((cam->YawRange).min <= yaw &&
			(fVar1 = (cam->YawRange).max,
			(ushort)((ushort)(yaw < fVar1) << 8 | (ushort)(yaw == fVar1) << 0xe) != 0)))) {
		cam->yaw = yaw;
		res::Container_SetOrientation(cam->resData2,NULL,0.0,0.0,1.0,0.0,1.0,0.0);
		res::Container_AddRotation(cam->resData2,D3DRMCOMBINE_BEFORE,0.0,0.0,1.0,-yaw);
	}
	return;
}



void __cdecl lego::view::Camera_AddYaw(CameraData *cam,float yawAmount)
{
	Camera_SetYaw(cam,yawAmount + cam->yaw);
	return;
}



void __cdecl lego::view::Camera_SetDistRange(CameraData *cam,float minDist,float maxDist)
{
	*(byte *)&cam->flags = *(byte *)&cam->flags | CAMERA_DISTRANGE;
	(cam->DistRange).min = minDist;
	(cam->DistRange).max = maxDist;
	return;
}



void __cdecl lego::view::Camera_SetDist(CameraData *cam,float dist)
{
	float fVar1;
	
	if ((((*(byte *)&cam->flags & CAMERA_DISTRANGE) == 0) ||
			((*(byte *)&cam->flags & CAMERA_EDITMODE_UNK) != 0)) ||
		 (((cam->DistRange).min <= dist &&
			(fVar1 = (cam->DistRange).max,
			(ushort)((ushort)(dist < fVar1) << 8 | (ushort)(dist == fVar1) << 0xe) != 0)))) {
		cam->dist = dist;
	}
	return;
}



void __cdecl lego::view::Camera_AddDist(CameraData *cam,float distAmount)
{
	Camera_SetDist(cam,distAmount + cam->dist);
	return;
}



void __cdecl lego::view::Camera_AddTranslation2F(CameraData *cam,float translateX,float translateY)
{
	res::Container_AddTranslation(cam->resData2,D3DRMCOMBINE_BEFORE,translateX,translateY,0.0);
	return;
}



void __cdecl lego::view::Camera_GetFramePosition_IfTopdown(CameraData *cam,Vector3F *out_position)
{
	if (cam->camType == CAMERATYPE_TOPDOWN) {
		res::Container_GetPosition(cam->resData2,NULL,out_position);
	}
	return;
}



void __cdecl lego::view::Camera_SetFramePosition_IfTopdown(CameraData *cam,float x,float y)
{
	if (cam->camType == CAMERATYPE_TOPDOWN) {
		res::Container_SetPosition(cam->resData2,NULL,x,y,0.0);
	}
	return;
}



BOOL __cdecl
lego::view::Camera_GetSurfacePosition_IfTopdown
					(CameraData *cam,SurfaceMap *surfMap,Vector3F *out_surfPosition)
{
	float10 fVar1;
	
	if (cam->camType == CAMERATYPE_TOPDOWN) {
		res::Container_GetPosition(cam->resData2,NULL,out_surfPosition);
		fVar1 = game::Map3D_GetWorldZ(surfMap,out_surfPosition->x,out_surfPosition->y);
		out_surfPosition->z = (float)fVar1;
	}
	return TRUE;
}



float10 __cdecl lego::view::Camera_GetYaw(CameraData *cam)
{
	return (float10)cam->yaw;
}



void __cdecl lego::view::Camera_FUN_00436da9(CameraData *cam,Vector3F *ref_vector,float elapsed)
{
	float fVar1;
	float10 fVar2;
	
	fVar2 = std::sqrt((double)(ref_vector->z * ref_vector->z +
														ref_vector->y * ref_vector->y + ref_vector->x * ref_vector->x));
	fVar1 = 1.0 / (float)fVar2;
	ref_vector->x = ref_vector->x * fVar1;
	ref_vector->y = ref_vector->y * fVar1;
	ref_vector->z = ref_vector->z * fVar1;
	cam->speedAccel_9c = elapsed * globs::cameraGlobs.CameraAcceleration + cam->speedAccel_9c;
	if ((ushort)((ushort)(cam->speedAccel_9c < globs::cameraGlobs.CameraSpeed) << 8 |
							(ushort)(cam->speedAccel_9c == globs::cameraGlobs.CameraSpeed) << 0xe) == 0) {
		cam->speedAccel_9c = globs::cameraGlobs.CameraSpeed;
	}
	fVar1 = cam->speedAccel_9c * elapsed;
	ref_vector->x = ref_vector->x * fVar1;
	ref_vector->y = ref_vector->y * fVar1;
	ref_vector->z = ref_vector->z * fVar1;
	(cam->vector_18).x = (cam->vector_18).x + ref_vector->x;
	(cam->vector_18).y = (cam->vector_18).y + ref_vector->y;
	(cam->vector_18).z = (cam->vector_18).z + ref_vector->z;
	return;
}



void __cdecl lego::pool::ReservedPool_LiveObject___Init(void)
{
	int iVar1;
	LiveObject_Globs *pLVar2;
	
	pLVar2 = &globs::liveGlobs;
	for (iVar1 = 0x318f; iVar1 != 0; iVar1 += -1) {
		pLVar2->listSet[0] = NULL;
		pLVar2 = (LiveObject_Globs *)(pLVar2->listSet + 1);
	}
	globs::liveGlobs.Activities_TABLE[0] = "Activity_Stand";
	globs::liveGlobs.Activities_TABLE[1] = "Activity_Route";
	globs::liveGlobs.Activities_TABLE[2] = "Activity_RouteRubble";
	globs::liveGlobs.Activities_TABLE[3] = "Activity_RunPanic";
	globs::liveGlobs.Activities_TABLE[4] = "Activity_Drill";
	globs::liveGlobs.Activities_TABLE[5] = "Activity_Teleport";
	globs::liveGlobs.Activities_TABLE[6] = "Activity_Walk";
	globs::liveGlobs.Activities_TABLE[7] = "Activity_Reinforce";
	globs::liveGlobs.Activities_TABLE[8] = "Activity_Reverse";
	globs::liveGlobs.Activities_TABLE[9] = "Activity_TurnLeft";
	globs::liveGlobs.Activities_TABLE[10] = "Activity_TurnRight";
	globs::liveGlobs.Activities_TABLE[11] = "Activity_CantDo";
	globs::liveGlobs.Activities_TABLE[12] = "Activity_Emerge";
	globs::liveGlobs.Activities_TABLE[13] = "Activity_Enter";
	globs::liveGlobs.Activities_TABLE[14] = "Activity_EnterRein";
	globs::liveGlobs.Activities_TABLE[15] = "Activity_Collect";
	globs::liveGlobs.Activities_TABLE[16] = "Activity_Gather";
	globs::liveGlobs.Activities_TABLE[17] = "Activity_Carry";
	globs::liveGlobs.Activities_TABLE[18] = "Activity_CarryRubble";
	globs::liveGlobs.Activities_TABLE[19] = "Activity_Throw";
	globs::liveGlobs.Activities_TABLE[20] = "Activity_CarryTurnLeft";
	globs::liveGlobs.Activities_TABLE[21] = "Activity_CarryTurnRight";
	globs::liveGlobs.Activities_TABLE[22] = "Activity_CarryStand";
	globs::liveGlobs.Activities_TABLE[23] = "Activity_HitLeft";
	globs::liveGlobs.Activities_TABLE[24] = "Activity_HitRight";
	globs::liveGlobs.Activities_TABLE[25] = "Activity_HitFront";
	globs::liveGlobs.Activities_TABLE[26] = "Activity_HitBack";
	globs::liveGlobs.Activities_TABLE[27] = "Activity_HitHard";
	globs::liveGlobs.Activities_TABLE[28] = "Activity_Dynamite";
	globs::liveGlobs.Activities_TABLE[29] = "Activity_Deposit";
	globs::liveGlobs.Activities_TABLE[30] = "Activity_Clear";
	globs::liveGlobs.Activities_TABLE[31] = "Activity_Place";
	globs::liveGlobs.Activities_TABLE[32] = "Activity_Repair";
	globs::liveGlobs.Activities_TABLE[33] = "Activity_Slip";
	globs::liveGlobs.Activities_TABLE[34] = "Activity_Rest";
	globs::liveGlobs.Activities_TABLE[35] = "Activity_Eat";
	globs::liveGlobs.Activities_TABLE[36] = "Activity_Stamp";
	globs::liveGlobs.Activities_TABLE[37] = "Activity_ThrowMan";
	globs::liveGlobs.Activities_TABLE[38] = "Activity_ThrownByRockMonster";
	globs::liveGlobs.Activities_TABLE[39] = "Activity_GetUp";
	globs::liveGlobs.Activities_TABLE[40] = "Activity_BuildPath";
	globs::liveGlobs.Activities_TABLE[41] = "Activity_Upgrade";
	globs::liveGlobs.Activities_TABLE[42] = "Activity_Explode";
	globs::liveGlobs.Activities_TABLE[43] = "Activity_Unpowered";
	globs::liveGlobs.Activities_TABLE[44] = "Activity_FireLaser";
	globs::liveGlobs.Activities_TABLE[45] = "Activity_Freezed";
	globs::liveGlobs.Activities_TABLE[46] = "Activity_FreezeStart";
	globs::liveGlobs.Activities_TABLE[47] = "Activity_FreezeMelt";
	globs::liveGlobs.Activities_TABLE[48] = "Activity_Recharge";
	globs::liveGlobs.Activities_TABLE[49] = "Activity_WakeUp";
	globs::liveGlobs.Activities_TABLE[50] = "Activity_Train";
	globs::liveGlobs.Activities_TABLE[51] = "Activity_FloatOn";
	globs::liveGlobs.Activities_TABLE[52] = "Activity_FloatOff";
	globs::liveGlobs.Activities_TABLE[53] = "Activity_Opening";
	globs::liveGlobs.Activities_TABLE[54] = "Activity_Closing";
	globs::liveGlobs.Activities_TABLE[55] = "Activity_Open";
	globs::liveGlobs.Activities_TABLE[56] = "Activity_Waiting1";
	globs::liveGlobs.Activities_TABLE[57] = "Activity_Waiting2";
	globs::liveGlobs.Activities_TABLE[58] = "Activity_Waiting3";
	globs::liveGlobs.Activities_TABLE[59] = "Activity_Waiting4";
	globs::liveGlobs.Activities_TABLE[60] = "Activity_Waiting5";
	globs::liveGlobs.Activities_TABLE[61] = "Activity_Waiting6";
	globs::liveGlobs.Activities_TABLE[62] = "Activity_Waiting7";
	globs::liveGlobs.Activities_TABLE[63] = "Activity_Waiting8";
	globs::liveGlobs.Activities_TABLE[64] = "Activity_Waiting9";
	globs::liveGlobs.Activities_TABLE[65] = "Activity_Waiting10";
	globs::liveGlobs.Activities_TABLE[66] = "Activity_Waiting11";
	globs::liveGlobs.Activities_TABLE[67] = "Activity_Waiting12";
	globs::liveGlobs.Activities_TABLE[68] = "Activity_Waiting13";
	globs::liveGlobs.Activities_TABLE[69] = "Activity_Waiting14";
	globs::liveGlobs.Activities_TABLE[70] = "Activity_Waiting15";
	globs::liveGlobs.Activities_TABLE[71] = "Activity_Waiting16";
	globs::liveGlobs.Activities_TABLE[72] = "Activity_Waiting17";
	globs::liveGlobs.Activities_TABLE[73] = "Activity_Waiting18";
	globs::liveGlobs.Activities_TABLE[74] = "Activity_Waiting19";
	globs::liveGlobs.Activities_TABLE[75] = "Activity_Waiting20";
	globs::liveGlobs.Activities_TABLE[76] = "Activity_Waiting21";
	globs::liveGlobs.Activities_TABLE[77] = "Activity_Crumble";
	globs::liveGlobs.Activities_TABLE[78] = "Activity_TeleportIn";
	globs::liveGlobs.AbilityTypes_TABLE[0] = "LegoObject_AbilityType_Pilot";
	globs::liveGlobs.AbilityTypes_TABLE[1] = "LegoObject_AbilityType_Sailor";
	globs::liveGlobs.AbilityTypes_TABLE[2] = "LegoObject_AbilityType_Driver";
	globs::liveGlobs.AbilityTypes_TABLE[3] = "LegoObject_AbilityType_Dynamite";
	globs::liveGlobs.AbilityTypes_TABLE[4] = "LegoObject_AbilityType_Repair";
	globs::liveGlobs.AbilityTypes_TABLE[5] = "LegoObject_AbilityType_Scanner";
	pLVar2 = &globs::liveGlobs;
	for (iVar1 = 0x20; iVar1 != 0; iVar1 += -1) {
		pLVar2->listSet[0] = NULL;
		pLVar2 = (LiveObject_Globs *)(pLVar2->listSet + 1);
	}
	globs::liveGlobs.freeList = NULL;
	globs::liveGlobs.listCount = 0;
	globs::liveGlobs.flags = LIVEMANAGER_ISUSED;
	globs::liveGlobs.ToolNullIndexes_TABLE[0] = 0;
	globs::liveGlobs.ToolNullIndexes_TABLE[1] = 0;
	globs::liveGlobs.ToolNullIndexes_TABLE[2] = 1;
	globs::liveGlobs.ToolNullIndexes_TABLE[3] = 1;
	globs::liveGlobs.ToolNullIndexes_TABLE[4] = 4;
	globs::liveGlobs.ToolNullIndexes_TABLE[5] = 4;
	globs::liveGlobs.ToolNullIndexes_TABLE[6] = 4;
	globs::liveGlobs.ToolNullIndexes_TABLE[7] = 4;
	globs::liveGlobs.ToolNullIndexes_TABLE[8] = 3;
	globs::liveGlobs.ToolNullIndexes_TABLE[9] = 2;
	globs::liveGlobs.ToolNullIndexes_TABLE[10] = 4;
	globs::gameGlobs.ToolTypes_TABLE[0] = "LegoObject_ToolType_Drill";
	globs::gameGlobs.ToolTypes_TABLE[1] = "LegoObject_ToolType_Spade";
	globs::gameGlobs.ToolTypes_TABLE[2] = "LegoObject_ToolType_Hammer";
	globs::gameGlobs.ToolTypes_TABLE[3] = "LegoObject_ToolType_Spanner";
	globs::gameGlobs.ToolTypes_TABLE[4] = "LegoObject_ToolType_Laser";
	globs::gameGlobs.ToolTypes_TABLE[5] = "LegoObject_ToolType_PusherGun";
	globs::gameGlobs.ToolTypes_TABLE[6] = "LegoObject_ToolType_BirdScarer";
	globs::gameGlobs.ToolTypes_TABLE[7] = "LegoObject_ToolType_FreezerGun";
	return;
}



void __cdecl lego::pool::ReservedPool_LiveObject___Cleanup(void)
{
	LiveObject_Globs *pLVar1;
	
	game::LiveManager_Cleanup_FUN_0043b5e0();
	pLVar1 = &globs::liveGlobs;
	do {
		if (pLVar1->listSet[0] != NULL) {
			std::free(pLVar1->listSet[0]);
		}
		pLVar1 = (LiveObject_Globs *)(pLVar1->listSet + 1);
	} while (pLVar1 < (LiveObject_Globs *)&globs::liveGlobs.freeList);
	globs::liveGlobs.freeList = NULL;
	globs::liveGlobs.flags = LIVEMANAGER_NONE;
	if (globs::liveGlobs.UnkSurfaceGrid_1_TABLE != NULL) {
		std::free(globs::liveGlobs.UnkSurfaceGrid_1_TABLE);
	}
	globs::liveGlobs.flags = globs::liveGlobs.flags & ~LIVEMANAGER_ISUSED;
	return;
}



void __cdecl lego::save::Save_CopyStruct18(SaveStruct_18 *out_saveStruct18)
{
	int iVar1;
	SaveStruct_18 *pSVar2;
	
	pSVar2 = &globs::liveGlobs.savestruct18_c01c;
	for (iVar1 = 6; iVar1 != 0; iVar1 += -1) {
		*(undefined4 *)out_saveStruct18 = *(undefined4 *)pSVar2;
		pSVar2 = (SaveStruct_18 *)&pSVar2->field_0x4;
		out_saveStruct18 = (SaveStruct_18 *)&out_saveStruct18->field_0x4;
	}
	return;
}



// NULL will simply memzero the entire structure at the address

void __cdecl lego::save::Save_OverwriteStruct18(SaveStruct_18 *saveStruct18)
{
	int iVar1;
	SaveStruct_18 *pSVar2;
	
	iVar1 = 6;
	if (saveStruct18 != NULL) {
		pSVar2 = &globs::liveGlobs.savestruct18_c01c;
		for (; iVar1 != 0; iVar1 += -1) {
			*(undefined4 *)pSVar2 = *(undefined4 *)saveStruct18;
			saveStruct18 = (SaveStruct_18 *)&saveStruct18->field_0x4;
			pSVar2 = (SaveStruct_18 *)&pSVar2->field_0x4;
		}
		return;
	}
	pSVar2 = &globs::liveGlobs.savestruct18_c01c;
	for (; iVar1 != 0; iVar1 += -1) {
		*(undefined4 *)pSVar2 = 0;
		pSVar2 = (SaveStruct_18 *)&pSVar2->field_0x4;
	}
	return;
}



int __cdecl lego::game::LiveManager_FUN_004373c0(ObjectType objType,BOOL param_2)
{
	ObjectStatsFlags1 OVar1;
	int iVar2;
	int iVar3;
	uint objIndex;
	uint objLevel;
	
	iVar3 = 0;
	objIndex = 0;
	do {
		objLevel = 0;
		do {
			if (param_2 == 0) {
LAB_004373e4:
				iVar2 = LiveObject_GetOrSubLevelsTable(objType,objIndex,objLevel,TRUE);
				iVar3 += iVar2;
			}
			else {
				OVar1 = Object_GetStatsFlags1(objType,objIndex);
				if ((OVar1 & STATS1_STOREOBJECTS) == STATS1_NONE) goto LAB_004373e4;
			}
			objLevel += 1;
		} while (objLevel < 0x10);
		objIndex += 1;
		if (0xe < objIndex) {
			return iVar3;
		}
	} while( true );
}



void __cdecl lego::game::LiveManager_LoadToolTipIcons(CFGProperty *root)
{
	char *keyPath;
	CFGProperty *prop;
	int iVar1;
	ImageBMP *pIVar2;
	int iVar3;
	char **ppcVar4;
	ImageBMP **ppIVar5;
	
	keyPath = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"ToolTipIcons",0);
	prop = cfg::CFG_GetChildren(root,keyPath);
	do {
		if (prop == NULL) {
			if (globs::liveGlobs.ToolTipIcon_Ore != NULL) {
				lego::image::Image_SetupTrans(globs::liveGlobs.ToolTipIcon_Ore,0.0,0.0,0.0,0.0,0.0,0.0);
			}
			return;
		}
		iVar3 = 0;
		ppcVar4 = globs::gameGlobs.ToolTypes_TABLE;
		do {
			if ((*ppcVar4 != NULL) && (iVar1 = std::_stricmp(prop->key,*ppcVar4), iVar1 == 0)) {
				pIVar2 = lego::image::Image_LoadBMPScaled(prop->value,0,0);
				globs::liveGlobs.ToolTipIcons_Tools_TABLE[iVar3] = pIVar2;
				break;
			}
			ppcVar4 = ppcVar4 + 1;
			iVar3 += 1;
		} while (ppcVar4 < globs::gameGlobs.ToolNames_TABLE);
		if (iVar3 == 0xb) {
			iVar3 = 0;
			ppIVar5 = (ImageBMP **)globs::liveGlobs.AbilityTypes_TABLE;
			do {
				if ((*ppIVar5 != NULL) && (iVar1 = std::_stricmp(prop->key,(char *)*ppIVar5), iVar1 == 0)) {
					pIVar2 = lego::image::Image_LoadBMPScaled(prop->value,0,0);
					globs::liveGlobs.ToolTipIcons_Abilities[iVar3] = pIVar2;
					break;
				}
				ppIVar5 = ppIVar5 + 1;
				iVar3 += 1;
			} while (ppIVar5 < globs::liveGlobs.ToolTipIcons_Abilities);
		}
		if (iVar3 == 6) {
			iVar3 = std::_stricmp(prop->key,"Blank");
			if (iVar3 == 0) {
				globs::liveGlobs.ToolTipIcon_Blank = lego::image::Image_LoadBMPScaled(prop->value,0,0);
			}
			else {
				iVar3 = std::_stricmp(prop->key,"Ore");
				if (iVar3 == 0) {
					globs::liveGlobs.ToolTipIcon_Ore = lego::image::Image_LoadBMPScaled(prop->value,0,0);
				}
			}
		}
		prop = cfg::CFG_NextFlat(prop);
	} while( true );
}



void __cdecl lego::game::LiveManager_FUN_00437560(void)
{
	int iVar1;
	Point2I *pPVar2;
	LiveObject **ppLVar3;
	
	LiveManager_Cleanup_FUN_0043b5e0();
	LiveManager_FUN_00437700();
	LiveManager_HiddenStruct2C_FUN_00437ba0();
	pPVar2 = globs::liveGlobs.SlugHoles_TABLE;
	for (iVar1 = 0x28; iVar1 != 0; iVar1 += -1) {
		pPVar2->x = 0;
		pPVar2 = (Point2I *)&pPVar2->y;
	}
	pPVar2 = globs::liveGlobs.RechargeSeams_TABLE;
	for (iVar1 = 0x14; iVar1 != 0; iVar1 += -1) {
		pPVar2->x = 0;
		pPVar2 = (Point2I *)&pPVar2->y;
	}
	globs::liveGlobs.SlugHoles_COUNT = 0;
	globs::liveGlobs.RechargeSeams_COUNT = 0;
	globs::liveGlobs.float_c018 = 0.0;
	ppLVar3 = globs::liveGlobs.liveObjArray100_c43c;
	for (iVar1 = 100; iVar1 != 0; iVar1 += -1) {
		*ppLVar3 = NULL;
		ppLVar3 = ppLVar3 + 1;
	}
	globs::liveGlobs.uintCount_c5cc = 0;
	LiveManage_SetNumBuildingsTeleported(0);
	return;
}



void __cdecl
lego::game::LiveObject_Weapon_FUN_004375c0(LiveObject *in_liveObj,int weaponType,float param_3)
{
	LiveObject *pLVar1;
	float10 fVar2;
	Point2I local_8;
	
	if (weaponType == -1) {
		fVar2 = (float10)param_3;
	}
	else {
		fVar2 = tools::Weapon_GetDischargeRate(weaponType);
		fVar2 = fVar2 * (float10)param_3;
	}
	globs::liveGlobs.float_c018 = (float)(fVar2 + (float10)globs::liveGlobs.float_c018);
	LiveObject_GetBlockPos(in_liveObj,(int *)&local_8,&local_8.y);
	while (((1.0 <= globs::liveGlobs.float_c018 &&
					(pLVar1 = FUN_00438d20(&local_8,OBJECT_POWERCRYSTAL,0,0), pLVar1 != NULL)) &&
				 (pLVar1 = (LiveObject *)FUN_0043a910(pLVar1,OBJECT_POWERCRYSTAL,0,0), pLVar1 != NULL))) {
		pLVar1->flags3 = pLVar1->flags3 | LIVEOBJ3_POWEROFF;
		LiveObject_SetCrystalPoweredColor(pLVar1,0);
		globs::liveGlobs.float_c018 = globs::liveGlobs.float_c018 - 1.0;
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_00437690(LiveObject *liveObj,BOOL condition)
{
	BOOL BVar1;
	
	if ((condition == 0) && ((liveObj->flags4 & LIVEOBJ4_UNK_2000) != LIVEOBJ4_NONE)) {
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_2000 | LIVEOBJ4_UNK_4000;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_CLOSING,0);
		BVar1 = LiveObject_Container_ActivityUpdate_Check(liveObj);
		return BVar1;
	}
	if ((condition != 0) && ((liveObj->flags4 & LIVEOBJ4_UNK_2000) == LIVEOBJ4_NONE)) {
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_1000;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_OPENING,0);
	}
	BVar1 = LiveObject_Container_ActivityUpdate_Check(liveObj);
	return BVar1;
}



void __cdecl lego::game::LiveManager_FUN_00437700(void)
{
	int iVar1;
	uint (*paauVar2) [15] [16];
	
	paauVar2 = globs::liveGlobs.ObjectLevels_Previous_TABLE;
	for (iVar1 = 0x12c0; iVar1 != 0; iVar1 += -1) {
		(*paauVar2)[0] = 0;
		paauVar2 = (uint (*) [15] [16])(*paauVar2 + 1);
	}
	paauVar2 = globs::liveGlobs.ObjectLevels_Current_TABLE;
	for (iVar1 = 0x12c0; iVar1 != 0; iVar1 += -1) {
		(*paauVar2)[0] = 0;
		paauVar2 = (uint (*) [15] [16])(*paauVar2 + 1);
	}
	return;
}



int __cdecl
lego::game::LiveObject_GetOrSubLevelsTable
					(ObjectType objType,int objIndex,int objLevel,BOOL doSubtract)
{
	uint uVar1;
	
	uVar1 = globs::liveGlobs.ObjectLevels_Current_TABLE[objType][objIndex][objLevel];
	if (doSubtract != 0) {
		uVar1 -= globs::liveGlobs.ObjectLevels_Previous_TABLE[objType][objIndex][objLevel];
	}
	return uVar1;
}



uint __cdecl lego::game::LiveObject_GetPreviousLevel(ObjectType objType,int objIndex,int objLevel)
{
	return globs::liveGlobs.ObjectLevels_Previous_TABLE[objType][objIndex][objLevel];
}



void __cdecl lego::unk::Lego_PathLiveLevelsIncrementConditional(BOOL param_1)
{
	if (param_1 != 0) {
		globs::liveGlobs.ObjectLevels_Current_TABLE[15][0][0] += 1;
		return;
	}
	globs::liveGlobs.ObjectLevels_Previous_TABLE[15][0][0] += 1;
	return;
}



void __cdecl lego::game::LiveObject_FUN_004377b0(LiveObject *liveObj)
{
	if (liveObj->objType != OBJECT_BOULDER) {
		Search_LiveObjects_SkipIgnoreMes(LiveObject_FUN_004377d0,(undefined4 *)liveObj);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_004377d0(LiveObject *liveObj1,LiveObject *liveObj2)
{
	if (liveObj1->object_2fc == liveObj2) {
		LiveObject_UnkDoRouting_FUN_00441c00(liveObj1,0);
		liveObj1->object_2fc = NULL;
	}
	return 0;
}



BOOL __cdecl lego::pool::ReservedPool_LiveObject___Release(LiveObject *liveObj)
{
	LiveFlags4 *pLVar1;
	LiveObject *pLVar2;
	ObjectType OVar3;
	ObjectStatsFlags1 OVar4;
	VehicleData *buffer;
	
	globs::liveGlobs.ObjectLevels_Previous_TABLE[liveObj->objType][liveObj->objIndex]
	[liveObj->objLevel] =
			 globs::liveGlobs.ObjectLevels_Previous_TABLE[liveObj->objType][liveObj->objIndex]
			 [liveObj->objLevel] + 1;
	if ((liveObj->flags4 & LIVEOBJ4_UNK_100000) != LIVEOBJ4_NONE) {
		snd::SFX_Sample_Sound3D_StopSound(liveObj->soundHandle_350);
	}
	if ((liveObj->flags4 & LIVEOBJ4_UNK_80000) != LIVEOBJ4_NONE) {
		snd::SFX_Sample_Sound3D_StopSound(liveObj->soundHandle_354);
	}
	game::Search_LiveObjects_SkipIgnoreMes(game::LiveObject_SetField_3c4,(undefined4 *)liveObj);
	if (liveObj->objType == OBJECT_ROCKMONSTER) {
		ai::AITask_LiveObject_DoCallbacks_FUN_004029d0(liveObj);
	}
	if (liveObj->resData_2e4 != NULL) {
		res::Container_Remove(liveObj->resData_2e4);
	}
	if (liveObj->carryingThisObject != NULL) {
		game::LiveObject_FUN_0043a130(liveObj->carryingThisObject,0);
	}
	if ((liveObj->flags4 & LIVEOBJ4_UNK_40) != LIVEOBJ4_NONE) {
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_40;
		if (liveObj->object_2fc != NULL) {
			pLVar1 = &liveObj->object_2fc->flags4;
			*pLVar1 = *pLVar1 & ~LIVEOBJ4_UNK_40;
		}
	}
	game::LiveObject_FUN_0043abf0(liveObj);
	if ((*(byte *)&liveObj->flags4 & 1) != 0) {
		globs::gameGlobs.flags1 &= ~GAME1_LASERTRACKER;
	}
	if ((*(byte *)&liveObj->flags4 & 0x80) != 0) {
		pLVar2 = liveObj->object_2fc;
		if (pLVar2 != NULL) {
			pLVar2->flags4 = pLVar2->flags4 & ~LIVEOBJ4_UNK_80;
		}
		liveObj->object_2fc = NULL;
	}
	game::LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
	game::LiveObject_FUN_00447bc0(liveObj);
	game::LiveObject_FUN_0043a130(liveObj,0);
	ai::AITask_LiveObject_FUN_00403980(liveObj);
	game::LiveObject_FUN_0043f820(liveObj);
	front::Encyclopedia_LiveObject_ClearPtr_004c8ea4_IfEqual(liveObj);
	OVar4 = game::LiveObject_GetStatsFlags1(liveObj);
	if (((OVar4 & STATS1_PROCESSCRYSTAL) != STATS1_NONE) ||
		 (OVar4 = game::LiveObject_GetStatsFlags1(liveObj), (OVar4 & STATS1_PROCESSORE) != STATS1_NONE))
	{
		ai::AITask_LiveObject_FUN_00403940(liveObj);
	}
	game::Message_LiveObject_FUN_00452770(liveObj);
	game::lego::front::Info_LiveObject_Release(liveObj);
	front::Bubble_LiveObject_FUN_004072d0(liveObj);
	game::LiveObject_FUN_004377b0(liveObj);
	game::Game_RemoveRecordObject(liveObj);
	OVar3 = liveObj->objType;
	if (OVar3 == OBJECT_VEHICLE) {
		res::Vehicle_Destroy(liveObj->vehicle);
		buffer = liveObj->vehicle;
	}
	else {
		if (OVar3 == OBJECT_MINIFIGURE) {
			res::Creature_Destroy(liveObj->miniFigure);
			buffer = (VehicleData *)liveObj->miniFigure;
		}
		else {
			if (OVar3 == OBJECT_ROCKMONSTER) {
				OVar4 = game::LiveObject_GetStatsFlags1(liveObj);
				if ((OVar4 & STATS1_FLOCKS) != STATS1_NONE) {
					game::LiveObject_FlocksDestroy(liveObj);
				}
				res::Creature_Destroy(liveObj->rockMonster);
				buffer = (VehicleData *)liveObj->rockMonster;
			}
			else {
				if (OVar3 == OBJECT_BUILDING) {
					res::Building_Destroy(liveObj->building);
					buffer = (VehicleData *)liveObj->building;
				}
				else {
					if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
						res::Container_Remove(liveObj->other);
						goto LAB_00437a4d;
					}
					if (OVar3 != OBJECT_UPGRADEPART) goto LAB_00437a4d;
					res::Upgrade_Destroy(liveObj->upgrade);
					buffer = (VehicleData *)liveObj->upgrade;
				}
			}
		}
	}
	std::free(buffer);
LAB_00437a4d:
	liveObj->pool_m_next = globs::liveGlobs.freeList;
	globs::liveGlobs.freeList = liveObj;
	return 0;
}



BOOL __cdecl
lego::game::Search_LiveObjects_SkipIgnoreMes
					(SearchLiveObjectCallback *predicateFunc,undefined4 *search)
{
	BOOL BVar1;
	
	BVar1 = Search_LiveObjects(predicateFunc,search,TRUE);
	return BVar1;
}



BOOL __cdecl
lego::game::Search_LiveObjects
					(SearchLiveObjectCallback *callback,void *search,BOOL skipIgnoreMeObjs)
{
	LiveObject *liveObj;
	BOOL BVar1;
	int iVar2;
	LiveObject_Globs *pLVar3;
	uint uVar4;
	uint uVar5;
	uint tblIndex;
	
	tblIndex = 0;
	if (globs::liveGlobs.listCount == 0) {
		return 0;
	}
	pLVar3 = &globs::liveGlobs;
	do {
		if (pLVar3->listSet[0] != NULL) {
			uVar5 = 0;
			uVar4 = 1 << ((byte)tblIndex & 0x1f);
			if (uVar4 != 0) {
				iVar2 = 0;
				do {
					liveObj = (LiveObject *)((int)pLVar3->listSet[0]->routing_points_4 + iVar2 + -0x34);
					if ((((liveObj != NULL) && (liveObj->pool_m_next == liveObj)) &&
							((skipIgnoreMeObjs == 0 ||
							 ((liveObj->flags3 & LIVEOBJ3_IGNOREME_UNK) == LIVEOBJ3_NONE)))) &&
						 (BVar1 = (*callback)(liveObj,search), BVar1 != 0)) {
						return TRUE;
					}
					uVar5 += 1;
					iVar2 += 0x40c;
				} while (uVar5 < uVar4);
			}
		}
		tblIndex += 1;
		pLVar3 = (LiveObject_Globs *)(pLVar3->listSet + 1);
		if (globs::liveGlobs.listCount <= tblIndex) {
			return 0;
		}
	} while( true );
}



void __cdecl lego::game::LiveObject_SetCustomName(LiveObject *liveObj,char *customName)
{
	char *pcVar1;
	
	if ((customName != NULL) && (*customName != '\0')) {
										// There is no regard for memory bounds here,
										// allocates 11 bytes, assigns bytes[11]...
										// why......
		if (liveObj->customName == NULL) {
			pcVar1 = (char *)std::malloc(0xb);
			liveObj->customName = pcVar1;
		}
		std::_strncpy(liveObj->customName,customName,0xb);
		liveObj->customName[0xb] = '\0';
		return;
	}
	if (liveObj->customName != NULL) {
		std::free(liveObj->customName);
	}
	liveObj->customName = NULL;
	return;
}



void __cdecl lego::game::LiveManager_HiddenStruct2C_FUN_00437ba0(void)
{
	int iVar1;
	void **ppvVar2;
	uint uVar3;
	HiddenStruct_2c *pHVar4;
	
	uVar3 = 0;
	if (globs::liveGlobs.HiddenStruct2C_COUNT != 0) {
		ppvVar2 = (void **)&globs::liveGlobs.HiddenStruct2C_TABLE[0].field_0x24;
		do {
			if (ppvVar2[1] != NULL) {
				std::free(ppvVar2[1]);
			}
			if (*ppvVar2 != NULL) {
				std::free(*ppvVar2);
			}
			uVar3 += 1;
			ppvVar2 = ppvVar2 + 0xb;
		} while (uVar3 < globs::liveGlobs.HiddenStruct2C_COUNT);
	}
	globs::liveGlobs.HiddenStruct2C_COUNT = 0;
	pHVar4 = globs::liveGlobs.HiddenStruct2C_TABLE;
	for (iVar1 = 200; iVar1 != 0; iVar1 += -1) {
		*(undefined4 *)pHVar4 = 0;
		pHVar4 = (HiddenStruct_2c *)&pHVar4->field_0x4;
	}
	nerps::NERPs_ClearHiddenObjectsFound();
	return;
}



void __cdecl lego::game::LiveManager_HiddenStruct2C_FUN_00437c00(Point2I *param_1)
{
	char *pcVar1;
	char *pcVar2;
	LiveObject *liveObj;
	Point2I *pPVar3;
	LiveObject *pLVar4;
	ObjectStatsFlags3 OVar5;
	ObjectStatsFlags1 OVar6;
	int iVar7;
	HiddenStruct_2c *translation;
	HiddenStruct_2c *pHVar8;
	uint uVar9;
	Direction rotation;
	undefined4 *puVar10;
	uint uVar11;
	longlong lVar12;
	TrainedFlags trainFlags;
	char **local_96c;
	uint local_968;
	uint local_964;
	LiveObject *apLStack2400 [200];
	char *local_640 [200];
	char *apcStack800 [200];
	
	uVar11 = 0;
	uVar9 = 0;
	local_968 = 0;
	if (globs::liveGlobs.HiddenStruct2C_COUNT != 0) {
		local_96c = local_640;
		translation = globs::liveGlobs.HiddenStruct2C_TABLE;
		do {
			pHVar8 = translation;
			if ((*(int *)&translation->field_0x0 == param_1->x) &&
				 (*(int *)&translation->field_0x4 == param_1->y)) {
				if (*(ObjectType *)&translation->field_0x18 == OBJECT_BUILDING) {
					pPVar3 = res::Building_GetShapePoints
														 (globs::gameGlobs.BuildingData_TABLE + *(int *)&translation->field_0x1c
															,&local_964);
					lVar12 = __ftol((float10)*(float *)&translation->field_0x10 * (float10)0.1591549 *
													(float10)8.0);
					rotation = ((uint)lVar12 & 1) + (uint)lVar12 >> 1;
					pPVar3 = Game_TransformShapePoints((Point2I *)translation,pPVar3,local_964,rotation);
					pLVar4 = Construction_Block_FUN_004099c0
														 (*(uint *)&translation->field_0x1c,(Point2I *)translation,rotation,
															(uint *)pPVar3,local_964,0);
					uVar11 = local_968;
				}
				else {
					pLVar4 = LiveObject__Create(*(int ***)&translation->field_0x14,
																			*(ObjectType *)&translation->field_0x18,
																			*(int *)&translation->field_0x1c);
				}
				if (pLVar4 != NULL) {
					if (*(int *)&translation->field_0x18 != 4) {
						LiveObject_UnkUpdatePositioning
											(pLVar4,*(float *)&translation->field_0x8,*(float *)&translation->field_0xc,
											 *(undefined4 *)&translation->field_0x10,1);
					}
					iVar7 = *(int *)&translation->field_0x18;
					if ((((iVar7 == 6) || (iVar7 == 7)) || (iVar7 == 8)) || (iVar7 == 9)) {
						ai::AITask_DoCollect(pLVar4,0.0);
					}
					pLVar4->health = *(float *)&translation->field_0x20;
					if (pLVar4->objType == OBJECT_MINIFIGURE) {
						nerps::NERPs_IncHiddenObjectsFound(OBJECT_MINIFIGURE);
						front::Info_FUN_00419ab0(INFO_FOUNDMINIFIGURE,NULL,pLVar4,NULL);
					}
					pLVar4->flags4 = pLVar4->flags4 | 0x200;
					LiveObject_FUN_00438720(pLVar4);
					if (pLVar4->objType == OBJECT_ELECTRICFENCE) {
						ElectricFence_AssignBlockObject(pLVar4);
					}
					pcVar1 = *(char **)&translation->field_0x24;
					pcVar2 = *(char **)&translation->field_0x28;
					apLStack2400[uVar11] = pLVar4;
					apcStack800[uVar11] = pcVar1;
					*local_96c = pcVar2;
					local_968 = uVar11 + 1;
					local_96c = local_96c + 1;
					*(undefined4 *)&translation->field_0x24 = 0;
				}
				uVar9 -= 1;
				pHVar8 = translation + -1;
				puVar10 = (undefined4 *)
									((int)globs::liveGlobs.RechargeSeams_TABLE +
									globs::liveGlobs.HiddenStruct2C_COUNT * 0x2c + 0x2c);
				globs::liveGlobs.HiddenStruct2C_COUNT = globs::liveGlobs.HiddenStruct2C_COUNT - 1;
				for (iVar7 = 0xb; uVar11 = local_968, iVar7 != 0; iVar7 += -1) {
					*(undefined4 *)&translation->field_0x0 = *puVar10;
					puVar10 = puVar10 + 1;
					translation = (HiddenStruct_2c *)&translation->field_0x4;
				}
			}
			uVar9 += 1;
			translation = pHVar8 + 1;
		} while (uVar9 < globs::liveGlobs.HiddenStruct2C_COUNT);
	}
	local_96c = NULL;
	if (uVar11 != 0) {
		do {
			pcVar1 = local_640[(int)local_96c];
			if (pcVar1 != NULL) {
				uVar9 = 0;
				do {
					if ((local_96c != (char **)uVar9) &&
						 (iVar7 = std::_stricmp(apcStack800[uVar9],pcVar1), iVar7 == 0)) {
						pLVar4 = apLStack2400[(int)local_96c];
						liveObj = apLStack2400[uVar9];
						pLVar4->object_2fc = liveObj;
						pLVar4->flags2 = pLVar4->flags2 | LIVEOBJ2_UNK_4;
						OVar5 = LiveObject_GetStatsFlags3(liveObj);
						if ((OVar5 & STATS3_NEEDSPILOT) == STATS3_NONE) {
							OVar6 = LiveObject_GetStatsFlags1(liveObj);
							if ((OVar6 & STATS1_CROSSWATER) == STATS1_NONE) {
								trainFlags = TRAINED_DRIVER;
							}
							else {
								OVar6 = LiveObject_GetStatsFlags1(liveObj);
								if ((OVar6 & STATS1_CROSSLAND) == STATS1_NONE) {
									trainFlags = TRAINED_SAILOR;
								}
								else {
									trainFlags = TRAINED_PILOT;
								}
							}
						}
						else {
							trainFlags = TRAINED_PILOT;
						}
						LiveObject_TrainMiniFigure_instantunk(pLVar4,trainFlags);
						LiveObject_ClearFlags4_40_AndSameForObject2FC(pLVar4,liveObj);
						uVar11 = local_968;
					}
					uVar9 += 1;
				} while (uVar9 < uVar11);
			}
			local_96c = (char **)((int)local_96c + 1);
		} while (local_96c < uVar11);
	}
	uVar9 = 0;
	if (uVar11 != 0) {
		do {
			if (local_640[uVar9] != NULL) {
				std::free(local_640[uVar9]);
			}
			if (apcStack800[uVar9] != NULL) {
				std::free(apcStack800[uVar9]);
			}
			uVar9 += 1;
		} while (uVar9 < uVar11);
	}
	return;
}



void __cdecl
lego::game::LiveManager_HiddenStruct2C_FUN_00437ee0
					(undefined4 param_1,undefined4 param_2,undefined4 param_3,Point2F *param_4,
					undefined4 param_5,undefined4 param_6,char *param_7,char *param_8)
{
	HiddenStruct_2c *pHVar1;
	uint uVar2;
	char *pcVar3;
	SurfaceMap *surfMap;
	float in_x;
	float fVar4;
	HiddenStruct_2c *out_bx;
	int *out_by;
	
	uVar2 = globs::liveGlobs.HiddenStruct2C_COUNT;
	out_bx = globs::liveGlobs.HiddenStruct2C_TABLE + globs::liveGlobs.HiddenStruct2C_COUNT;
	pHVar1 = globs::liveGlobs.HiddenStruct2C_TABLE + globs::liveGlobs.HiddenStruct2C_COUNT;
	globs::liveGlobs.HiddenStruct2C_COUNT = globs::liveGlobs.HiddenStruct2C_COUNT + 1;
	*(float *)&pHVar1->field_0x8 = param_4->x;
	fVar4 = param_4->y;
	*(undefined4 *)&globs::liveGlobs.HiddenStruct2C_TABLE[uVar2].field_0x14 = param_1;
	*(float *)&globs::liveGlobs.HiddenStruct2C_TABLE[uVar2].field_0xc = fVar4;
	*(undefined4 *)&globs::liveGlobs.HiddenStruct2C_TABLE[uVar2].field_0x20 = param_6;
	*(undefined4 *)&globs::liveGlobs.HiddenStruct2C_TABLE[uVar2].field_0x10 = param_5;
	*(undefined4 *)&globs::liveGlobs.HiddenStruct2C_TABLE[uVar2].field_0x18 = param_2;
	*(undefined4 *)&globs::liveGlobs.HiddenStruct2C_TABLE[uVar2].field_0x1c = param_3;
	if (param_7 != NULL) {
		pcVar3 = std::_strdup(param_7);
		*(char **)&globs::liveGlobs.HiddenStruct2C_TABLE[uVar2].field_0x24 = pcVar3;
	}
	if (param_8 != NULL) {
		pcVar3 = std::_strdup(param_8);
		*(char **)&globs::liveGlobs.HiddenStruct2C_TABLE[uVar2].field_0x28 = pcVar3;
	}
	fVar4 = param_4->y;
	in_x = param_4->x;
	out_by = (int *)&globs::liveGlobs.HiddenStruct2C_TABLE[uVar2].field_0x4;
	surfMap = GetSurfaceMap();
	Map3D_WorldToBlockPos_NoZ(surfMap,in_x,fVar4,(int *)out_bx,out_by);
	return;
}



BOOL __cdecl lego::game::LiveObject_CanShootObject(LiveObject *liveObj)
{
	ObjectStatsFlags2 OVar1;
	float10 fVar2;
	
	OVar1 = LiveObject_GetStatsFlags2(liveObj);
	if ((OVar1 & STATS2_CANBESHOTAT) != STATS2_NONE) {
		fVar2 = LiveObject_GetPainThreshold(liveObj);
		if (fVar2 < (float10)liveObj->health) {
			return 1;
		}
	}
	return 0;
}



LiveObject * __cdecl lego::game::LiveObject__Create(int **srcData,ObjectType objType,int objIndex)
{
	ObjectType OVar1;
	LiveObject *liveObj;
	BOOL BVar2;
	VehicleData *out_vehicle;
	uint uVar3;
	ObjectStatsFlags1 OVar4;
	CreatureData *pCVar5;
	BuildingData *out_building;
	UpgradeData *out_upgrade;
	Container *cont;
	LiveFlags3 LVar6;
	BOOL BVar7;
	ObjectStatsFlags2 OVar8;
	
	liveObj = pool::ReservedPool_LiveObject___Next();
	if (liveObj == NULL) {
		return NULL;
	}
	liveObj->objType = objType;
	liveObj->objIndex = objIndex;
	liveObj->flags3 = LIVEOBJ3_NONE;
	liveObj->health = (float)&DAT_42c80000;
	liveObj->energy = (float)&DAT_42c80000;
	res::Container_EnableSoundTriggers(0);
	BVar2 = snd::SFX_IsSoundOn();
	snd::SFX_SetSoundStates_IsOn_StopAll(0,0);
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		out_vehicle = (VehicleData *)std::malloc(0x1ec);
		liveObj->vehicle = out_vehicle;
		res::Vehicle_Duplicate((VehicleData *)srcData,out_vehicle);
		res::Vehicle_SetOwnerObject(liveObj->vehicle,liveObj);
		uVar3 = res::Vehicle_GetCarryNullFrames(liveObj->vehicle);
		liveObj->field_328 = uVar3;
		res::Vehicle_ChangeUpgradeParts(liveObj->vehicle,0);
		liveObj->flags5_3f0 = LIVEOBJ5_ABILITY_SCANNER;
		liveObj->flags3 =
				 liveObj->flags3 |
				 (LIVEOBJ3_UNK_10|LIVEOBJ3_UNK_80|LIVEOBJ3_CANSELECT|LIVEOBJ3_UNK_1000|LIVEOBJ3_UNK_40000|
				 LIVEOBJ3_UNK_400000);
		LiveObject_SetLevel(liveObj,0);
		if (srcData[0x2d] != NULL) {
			liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_2;
		}
		if (srcData[0x37] != NULL) {
			liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_20;
			OVar4 = LiveObject_GetStatsFlags1(liveObj);
			if ((OVar4 & STATS1_CROSSLAND) != STATS1_NONE) {
				liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_40;
			}
		}
		goto LAB_00438452;
	}
	if (OVar1 == OBJECT_MINIFIGURE) {
		pCVar5 = (CreatureData *)std::malloc(0x74);
		liveObj->miniFigure = pCVar5;
		res::Creature_Duplicate((CreatureData *)srcData,pCVar5);
		res::Object_SetOwnerObject((BasicObjectData *)liveObj->miniFigure,liveObj);
		uVar3 = nerps::funcs::NERPFunc__True((int *)liveObj->miniFigure);
		LVar6 = liveObj->flags3;
		liveObj->field_328 = uVar3;
		liveObj->flags3 =
				 LVar6 | (LIVEOBJ3_UNK_1|LIVEOBJ3_UNK_4|LIVEOBJ3_UNK_10|LIVEOBJ3_UNK_20|LIVEOBJ3_UNK_40|
									LIVEOBJ3_UNK_80|LIVEOBJ3_CANSELECT|LIVEOBJ3_UNK_40000|LIVEOBJ3_UNK_400000);
		if (srcData[0xb] != NULL) {
			liveObj->flags3 =
					 LVar6 | (LIVEOBJ3_UNK_1|LIVEOBJ3_UNK_2|LIVEOBJ3_UNK_4|LIVEOBJ3_UNK_10|LIVEOBJ3_UNK_20|
										LIVEOBJ3_UNK_40|LIVEOBJ3_UNK_80|LIVEOBJ3_CANSELECT|LIVEOBJ3_UNK_40000|
									 LIVEOBJ3_UNK_400000);
		}
		LiveObject_SetLevel(liveObj,0);
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_8000;
		MiniFigure_EquipTool(liveObj,TOOL_DRILL);
		goto LAB_00438452;
	}
	if (OVar1 == OBJECT_ROCKMONSTER) {
		pCVar5 = (CreatureData *)std::malloc(0x74);
		liveObj->rockMonster = pCVar5;
		res::Creature_Duplicate((CreatureData *)srcData,pCVar5);
		res::Object_SetOwnerObject((BasicObjectData *)liveObj->rockMonster,liveObj);
		uVar3 = nerps::funcs::NERPFunc__True((int *)liveObj->rockMonster);
		LVar6 = liveObj->flags3;
		liveObj->field_328 = uVar3;
		liveObj->flags3 =
				 LVar6 | (LIVEOBJ3_UNK_200|LIVEOBJ3_UNK_40000|LIVEOBJ3_UNK_400000|LIVEOBJ3_UNK_8000000);
		if (srcData[0xb] != NULL) {
			liveObj->flags3 =
					 LVar6 | (LIVEOBJ3_UNK_2|LIVEOBJ3_UNK_200|LIVEOBJ3_UNK_40000|LIVEOBJ3_UNK_400000|
									 LIVEOBJ3_UNK_8000000);
		}
		LiveObject_SetLevel(liveObj,0);
		OVar4 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar4 & STATS1_FLOCKS) == STATS1_NONE) {
			liveObj->flocksData_32c = NULL;
		}
		else {
			LiveObject_Flocks_Initialise(liveObj);
			OVar4 = LiveObject_GetStatsFlags1(liveObj);
			if ((OVar4 & STATS1_FLOCKS_DEBUG) == STATS1_NONE) {
				LiveObject_HideAll(liveObj,TRUE);
				liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_CANSELECT;
			}
		}
		BVar7 = LiveObject_CanShootObject(liveObj);
		if (BVar7 != 0) {
			ai::AITask_DoAttackRockMonster_Target(liveObj);
		}
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_POWEROFF;
		goto LAB_00438452;
	}
	if (OVar1 == OBJECT_BUILDING) {
		out_building = (BuildingData *)std::malloc(0x14c);
		liveObj->building = out_building;
		res::Building_Duplicate((BuildingData *)srcData,out_building);
		res::Object_SetOwnerObject((BasicObjectData *)liveObj->building,liveObj);
		uVar3 = res::Building_GetCarryNullFrames(liveObj->building);
		liveObj->field_328 = uVar3;
		liveObj->flags3 = liveObj->flags3 | (LIVEOBJ3_CANSELECT|LIVEOBJ3_UNK_40000);
		res::Building_ChangeUpgradeParts(liveObj->building,0);
		LiveObject_SetLevel(liveObj,0);
		OVar4 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar4 & STATS1_SMALLTELEPORTER) != STATS1_NONE) {
			globs::gameGlobs.placeDestSmallTeleporter = liveObj;
		}
		OVar4 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar4 & STATS1_BIGTELEPORTER) != STATS1_NONE) {
			globs::gameGlobs.placeDestBigTeleporter = liveObj;
		}
		OVar4 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar4 & STATS1_WATERTELEPORTER) != STATS1_NONE) {
			globs::gameGlobs.placeDestWaterTeleporter = liveObj;
		}
		LiveObject_GetStatsFlags1(liveObj);
		OVar4 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar4 & STATS1_SNAXULIKE) != STATS1_NONE) {
			ai::AITask_DoGotoEat(liveObj);
		}
		ai::AITask_DoRepair(liveObj);
		liveObj->flags5_3f0 = LIVEOBJ5_ABILITY_SCANNER;
		LiveManager_InitFlagsToggle_AndClearNumDrained();
		goto LAB_00438452;
	}
	if (OVar1 == OBJECT_UPGRADEPART) {
		out_upgrade = (UpgradeData *)std::malloc(0x10);
		liveObj->upgrade = out_upgrade;
		res::Upgrade_Duplicate((UpgradeData *)srcData,out_upgrade);
		liveObj->stats = &globals::const::c_ObjectStats_Upgrade;
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_IGNOREME_UNK;
		goto LAB_00438452;
	}
	cont = res::Container_Clone((Container *)srcData);
	liveObj->other = cont;
	res::Container_SetUserData(cont,liveObj);
	LVar6 = liveObj->flags3;
	OVar1 = liveObj->objType;
	liveObj->flags3 = LVar6 | LIVEOBJ3_SIMPLEOBJECT;
	if (OVar1 == OBJECT_ELECTRICFENCE) {
		liveObj->flags3 = LVar6 | (LIVEOBJ3_CANSELECT|LIVEOBJ3_SIMPLEOBJECT|LIVEOBJ3_UNK_40000);
	}
	if ((OVar1 == OBJECT_ORE) || (OVar1 == OBJECT_POWERCRYSTAL)) {
		LVar6 = liveObj->flags3 | (LIVEOBJ3_CANSELECT|LIVEOBJ3_UNK_100000);
LAB_004383f9:
		liveObj->flags3 = LVar6;
	}
	else {
		if ((OVar1 == OBJECT_DYNAMITE) || (OVar1 == OBJECT_OOHSCARY)) {
			LVar6 = liveObj->flags3 | LIVEOBJ3_UNK_40000;
			goto LAB_004383f9;
		}
	}
	LiveObject_SetCrystalPoweredColor(liveObj,TRUE);
	if (true) {
		switch(liveObj->objType) {
		case OBJECT_DYNAMITE:
			liveObj->stats = &globals::const::c_ObjectStats_Dynamite;
			break;
		case OBJECT_BARRIER:
			liveObj->stats = &globals::const::c_ObjectStats_Barrier;
			break;
		default:
			goto switchD_0043841c_caseD_a;
		case OBJECT_SPIDERWEB:
		case OBJECT_OOHSCARY:
		case OBJECT_ELECTRICFENCESTUD:
		case OBJECT_PUSHER:
		case OBJECT_FREEZER:
		case OBJECT_ICECUBE:
		case OBJECT_LASERSHOT:
			liveObj->stats = &globals::const::c_ObjectStats_Other;
		}
	}
	else {
switchD_0043841c_caseD_a:
		LiveObject_SetLevel(liveObj,0);
	}
LAB_00438452:
	liveObj->aitaskName2 = globs::liveGlobs.Activities_TABLE[0];
	liveObj->aitaskName1 = globs::liveGlobs.Activities_TABLE[9];
	BVar7 = LiveObject_Container_ActivityUpdate_Check(liveObj);
	if (BVar7 != 0) {
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_8;
	}
	liveObj->aitaskName1 = globs::liveGlobs.Activities_TABLE[16];
	BVar7 = LiveObject_Container_ActivityUpdate_Check(liveObj);
	if (BVar7 != 0) {
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_CANGATHER;
	}
	liveObj->aitaskName1 = globs::liveGlobs.Activities_TABLE[2];
	BVar7 = LiveObject_Container_ActivityUpdate_Check(liveObj);
	if (BVar7 != 0) {
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_CANROUTERUBBLE;
	}
	liveObj->aitaskName1 = globs::liveGlobs.Activities_TABLE[0];
	LiveObject_Container_ActivityUpdate_Check(liveObj);
	ai::AITask_LiveObject_Unk_UpdateAITask_AnimationWait(liveObj);
	res::Container_EnableSoundTriggers(TRUE);
	if (BVar2 != 0) {
		snd::SFX_SetSoundStates_IsOn_StopAll(TRUE,FALSE);
	}
	LiveObject_UpdatePowerConsumption(liveObj);
	globs::liveGlobs.ObjectLevels_Current_TABLE[liveObj->objType][liveObj->objIndex][0] =
			 globs::liveGlobs.ObjectLevels_Current_TABLE[liveObj->objType][liveObj->objIndex][0] + 1;
	OVar8 = LiveObject_GetStatsFlags2(liveObj);
	if ((OVar8 & STATS2_UNSELECTABLE) != STATS2_NONE) {
		liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_CANSELECT;
	}
	return liveObj;
}



LiveObject * __cdecl lego::pool::ReservedPool_LiveObject___Next(void)
{
	int iVar1;
	LiveObject *pLVar2;
	LiveObject *liveObj;
	
	if (globs::liveGlobs.freeList == NULL) {
		ReservedPool_LiveObject___Alloc();
	}
	liveObj = globs::liveGlobs.freeList;
	pLVar2 = globs::liveGlobs.freeList;
	globs::liveGlobs.freeList = (globs::liveGlobs.freeList)->pool_m_next;
	for (iVar1 = 0x103; iVar1 != 0; iVar1 += -1) {
		pLVar2->objType = OBJECT_NONE;
		pLVar2 = (LiveObject *)&pLVar2->objIndex;
	}
	liveObj->pool_m_next = liveObj;
	(liveObj->point_2f4).y = -1.0;
	(liveObj->point_2f4).x = -1.0;
	return liveObj;
}



void __cdecl lego::pool::ReservedPool_LiveObject___Alloc(void)
{
	LiveObject *pLVar1;
	LiveObject *pLVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::liveGlobs.listCount & 0x1f);
	pLVar2 = (LiveObject *)std::malloc(uVar4 * 0x40c);
	globs::liveGlobs.listSet[globs::liveGlobs.listCount] = pLVar2;
	pLVar2 = globs::liveGlobs.listSet[globs::liveGlobs.listCount];
	if (pLVar2 != NULL) {
		globs::liveGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pLVar1 = pLVar2;
			do {
				pLVar1->pool_m_next = pLVar1 + 1;
				iVar3 += -1;
				pLVar1 = pLVar1 + 1;
			} while (iVar3 != 0);
		}
		pLVar2[uVar4 - 1].pool_m_next = globs::liveGlobs.freeList;
		globs::liveGlobs.freeList = pLVar2;
	}
	return;
}



int __cdecl lego::game::LiveManage_GetNumBuildingsTeleported(int *stack)
{
	return globs::liveGlobs.BuildingsTeleported;
}



void __cdecl lego::game::LiveManage_SetNumBuildingsTeleported(uint numTeleported)
{
	globs::liveGlobs.BuildingsTeleported = numTeleported;
	return;
}



void __cdecl lego::game::LiveObject_SetCrystalPoweredColor(LiveObject *liveObj,BOOL isPowered)
{
	uint uVar1;
	D3DRMGroupIndex DVar2;
	float b;
	D3DRMGroupIndex groupID;
	float local_4;
	
	if (liveObj->objType == OBJECT_POWERCRYSTAL) {
		if (isPowered == 0) {
			isPowered = (BOOL)globs::gameGlobs.UnpoweredCrystalRGB.red;
			local_4 = globs::gameGlobs.UnpoweredCrystalRGB.green;
			b = globs::gameGlobs.UnpoweredCrystalRGB.blue;
		}
		else {
			isPowered = (BOOL)globs::gameGlobs.PowerCrystalRGB.red;
			local_4 = globs::gameGlobs.PowerCrystalRGB.green;
			b = globs::gameGlobs.PowerCrystalRGB.blue;
		}
		groupID = D3DRMGROUP_0;
		uVar1 = res::Container_Mesh_GetGroupCount(liveObj->other);
		if (uVar1 != 0) {
			do {
				res::Container_Mesh_SetColourAlpha(liveObj->other,groupID,(float)isPowered,local_4,b,1.0);
				res::Container_Mesh_SetEmissive(liveObj->other,groupID,(float)isPowered,local_4,b);
				groupID += 1;
				DVar2 = res::Container_Mesh_GetGroupCount(liveObj->other);
			} while (groupID < DVar2);
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_00438720(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	
	if (liveObj->objType == OBJECT_BUILDING) {
		LiveObject_Container_ActivityUpdate_Check(liveObj);
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_20;
		OVar1 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar1 & STATS1_STOREOBJECTS) == STATS1_NONE) {
			OVar1 = LiveObject_GetStatsFlags1(liveObj);
			if ((OVar1 & STATS1_PROCESSORE) == STATS1_NONE) {
				OVar1 = LiveObject_GetStatsFlags1(liveObj);
				if ((OVar1 & STATS1_PROCESSCRYSTAL) == STATS1_NONE) {
					liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_20;
				}
				else {
					ai::AITask_DoDeposit_ObjectType(liveObj,OBJECT_POWERCRYSTAL,0,0);
				}
			}
			else {
				ai::AITask_DoDeposit_ObjectType(liveObj,OBJECT_ORE,0,0);
			}
		}
		else {
			ai::AITask_LiveObject_FUN_004038d0(liveObj);
		}
		LiveManager_InitFlagsToggle_AndClearNumDrained();
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_200000;
	}
	else {
		if (liveObj->objType == OBJECT_VEHICLE) {
			res::Vehicle_FUN_0046d280(liveObj->vehicle,0);
		}
	}
	if ((liveObj->objType == OBJECT_MINIFIGURE) || (liveObj->objType == OBJECT_VEHICLE)) {
		LiveObject_FUN_0043f820(liveObj);
	}
	front::HelpWindow_Game_UpdateObjectDependencies
						(liveObj->objType,liveObj->objIndex,0,liveObj->flags4 & 0x200);
	if (liveObj->objType == OBJECT_BUILDING) {
		globs::liveGlobs.BuildingsTeleported += 1;
	}
	if ((liveObj->objType == OBJECT_MINIFIGURE) || (liveObj->objType == OBJECT_VEHICLE)) {
		ai::AITask_DoAttackObject(liveObj);
	}
	if ((liveObj->objType == OBJECT_VEHICLE) || (liveObj->objType == OBJECT_BUILDING)) {
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_40000;
	}
	return;
}



void __cdecl lego::game::LiveObject_SetFlag3_80000000(LiveObject *liveObj,BOOL state)
{
	LiveFlags3 LVar1;
	
	if (state == 0) {
		LVar1 = liveObj->flags3 | LIVEOBJ3_POWEROFF;
	}
	else {
		LVar1 = liveObj->flags3 & ~LIVEOBJ3_POWEROFF;
	}
	liveObj->flags3 = LVar1;
	LiveManager_InitFlagsToggle_AndClearNumDrained();
	return;
}



BOOL __cdecl lego::game::LiveObject_CheckCondition_FUN_00438870(LiveObject *liveObj,BOOL state)
{
	if ((((((liveObj->flags1 &
					(LIVEOBJ1_UNK_100|LIVEOBJ1_UNK_100000|LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) ==
					LIVEOBJ1_NONE) && ((liveObj->flags2 & LIVEOBJ2_UNK_100000) == LIVEOBJ2_NONE)) &&
			 (0.0 <= liveObj->health)) && ((liveObj->flags1 & LIVEOBJ1_UNK_20000) == LIVEOBJ1_NONE)) &&
		 ((state != 0 ||
			(((liveObj->flags3 & LIVEOBJ3_HASPOWER) != LIVEOBJ3_NONE &&
			 ((liveObj->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE)))))) {
		return TRUE;
	}
	return 0;
}



LiveObject * __cdecl
lego::game::Game_CreateLiveResourceObject
					(Container *resData,ObjectType objType,int objIndex,int objLevel,float x,float y,
					float theta)
{
	LiveObject *liveObj;
	
	liveObj = LiveObject__Create((int **)resData,objType,objIndex);
	if (liveObj != NULL) {
		LiveObject_UnkUpdatePositioning(liveObj,x,y,theta,1);
		if ((liveObj->objType == OBJECT_POWERCRYSTAL) || (liveObj->objType == OBJECT_ORE)) {
			LiveObject_SetLevel_thunk(liveObj,objLevel);
		}
		return liveObj;
	}
	return NULL;
}



LiveObject * __cdecl lego::game::Game_Unk_DoSearchCallbacks_Unique(Point2I *blockPos)
{
	LiveObject *local_c;
	int local_8;
	int local_4;
	
	local_c = NULL;
	local_8 = blockPos->x;
	local_4 = blockPos->y;
	Search_LiveObjects_SkipIgnoreMes(LiveManage_FUN_00438970,&local_c);
	return local_c;
}



BOOL __cdecl lego::game::LiveManage_FUN_00438970(LiveObject *liveObj,LiveObject **param_2)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	LiveObject *local_8;
	LiveObject *local_4;
	
	if (liveObj->objType == OBJECT_BUILDING) {
		OVar1 = LiveObject_GetStatsFlags2(liveObj);
		if ((OVar1 & STATS2_GENERATEPOWER) != STATS2_NONE) {
			BVar2 = LiveObject_CheckCondition_FUN_00438870(liveObj,0);
			if (BVar2 != 0) {
				LiveObject_GetBlockPos(liveObj,(int *)&local_8,(int *)&local_4);
				if ((local_8 == param_2[1]) && (local_4 == param_2[2])) {
					*param_2 = liveObj;
					return 1;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_AddThisDrainedCrystals(LiveObject *liveObj,int crystalCount)
{
	int iVar1;
	
	if ((globs::gameGlobs.level)->NoDrain != 0) {
		crystalCount = 0;
	}
	iVar1 = Level_GetCrystalCount(0);
	if (iVar1 < crystalCount) {
		front::Info_FUN_00419ab0(INFO_NOPOWER,NULL,liveObj,NULL);
		return 0;
	}
	Level_AddDrainedCrystals(crystalCount);
	return TRUE;
}



BOOL __cdecl lego::game::LiveObject_GetBuildingUpgradeCost(LiveObject *liveObj,uint *out_oreCost)
{
	uint uVar1;
	
	uVar1 = Object_GetLevels(liveObj->objType,liveObj->objIndex);
	if (uVar1 <= liveObj->objLevel + 1) {
		return 0;
	}
	uVar1 = Level_GetOreCount(0);
	if (uVar1 < (uint)globs::gameGlobs.BuildingUpgradeCostOre) {
		uVar1 = Level_GetOreCount(1);
		if (uVar1 < (uint)globs::gameGlobs.BuildingUpgradeCostStuds) {
			return 0;
		}
		if (out_oreCost != NULL) {
			*out_oreCost = globs::gameGlobs.BuildingUpgradeCostStuds;
		}
	}
	else {
		if (out_oreCost != NULL) {
			*out_oreCost = 0;
			return 1;
		}
	}
	return 1;
}



void __cdecl lego::game::LiveObject_FUN_00438ab0(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	BOOL BVar1;
	Container *cont;
	LiveObject *oreCount;
	Container *opt_ref;
	Vector3F *out_pos;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	if (in_liveObj->objType == OBJECT_BUILDING) {
		BVar1 = LiveObject_GetBuildingUpgradeCost(in_liveObj,(uint *)&in_liveObj);
		if (BVar1 != 0) {
			oreCount = in_liveObj;
			if (in_liveObj == NULL) {
				oreCount = (LiveObject *)globs::gameGlobs.BuildingUpgradeCostOre;
			}
			Level_SubtractOre((uint)(in_liveObj != NULL),(int)oreCount);
			liveObj->elapsedTime2 = 0.0;
			res::Building_ChangeUpgradeParts(liveObj->building,liveObj->objLevel + 1);
			LiveObject_SetLevel(liveObj,liveObj->objLevel + 1);
			out_pos = &local_c;
			opt_ref = NULL;
			cont = LiveObject_GetContainer(liveObj);
			res::Container_GetPosition(cont,opt_ref,out_pos);
			lego::effect::Effect_Spawn_Particle(MISCOBJECT_UPGRADEEFFECT,&local_c,NULL);
			front::HelpWindow_Game_UpdateObjectDependencies
								(liveObj->objType,liveObj->objIndex,liveObj->objLevel,0);
		}
	}
	return;
}



BOOL __cdecl FUN_00438b70(LiveObject *liveObj,int objLevel)
{
	BOOL BVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	
	if ((liveObj->objType != OBJECT_VEHICLE) ||
		 (BVar1 = lego::res::Vehicle_FUN_0046d200(liveObj->vehicle,objLevel,1), BVar1 == 0)) {
		return 0;
	}
	uVar2 = lego::game::Object_GetUpgradeCostOre(liveObj->objType,liveObj->objIndex,objLevel);
	uVar3 = lego::game::Object_GetUpgradeCostOre(liveObj->objType,liveObj->objIndex,objLevel);
	uVar4 = lego::game::Object_GetUpgradeCostOre(liveObj->objType,liveObj->objIndex,objLevel);
	uVar5 = lego::game::Level_GetOreCount(0);
	if ((uVar5 < uVar4) &&
		 (uVar4 = lego::game::Level_GetOreCount(1), uVar4 < (uint)(uVar2 % 5 != 0) + uVar3 / 5)) {
		return 0;
	}
	return 1;
}



undefined4 __cdecl FUN_00438c20(LiveObject *opt_liveObj,BOOL param_2)
{
	undefined4 local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = 0;
	local_20 = 0.0;
	local_1c = 0.0;
	local_18 = 0x461c4000;
	local_14 = 0x2000;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	if (param_2 != 0) {
		local_14 = 0x6000;
	}
	if (opt_liveObj != NULL) {
		lego::game::LiveObject_GetPosition(opt_liveObj,&local_20,&local_1c);
	}
	lego::game::Search_LiveObjects_SkipIgnoreMes
						(lego::game::LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



undefined4 __cdecl lego::game::LiveObject_FUN_00438ca0(LiveObject *liveObj,BOOL param_2)
{
	undefined4 local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	uint local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = 0;
	local_20 = 0.0;
	local_1c = 0.0;
	local_18 = 0x461c4000;
	local_14 = 0x1000;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	LiveObject_GetPosition(liveObj,&local_20,&local_1c);
	if (param_2 != 0) {
		local_14 |= 0x400;
	}
	Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



LiveObject * __cdecl FUN_00438d20(Point2I *blockPos,ObjectType objType,int objIndex,int objLevel)
{
	SurfaceMap *surfMap;
	uint bx;
	uint by;
	float *out_x;
	float *out_y;
	LiveObject *local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	ObjectType local_10;
	int local_c;
	int local_8;
	undefined4 local_4;
	
	local_c = objIndex;
	local_24 = NULL;
	local_20 = 0.0;
	local_1c = 0.0;
	local_4 = 0;
	out_y = &local_1c;
	out_x = &local_20;
	local_10 = objType;
	local_8 = objLevel;
	local_18 = 0x461c4000;
	local_14 = 1;
	by = blockPos->y;
	bx = blockPos->x;
	surfMap = lego::game::GetSurfaceMap();
	lego::game::Map3D_BlockToWorldPos(surfMap,bx,by,out_x,out_y);
	lego::game::Search_LiveObjects_SkipIgnoreMes
						(lego::game::LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



LiveObject * __cdecl
lego::game::LiveObject_FUN_00438da0
					(LiveObject *liveObj,Point2I *blockPos,ObjectType objType,int objLevel)
{
	SurfaceMap *surfMap;
	uint bx;
	uint by;
	float *out_x;
	float *out_y;
	LiveObject *local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	ObjectType local_10;
	undefined4 local_c;
	int local_8;
	undefined4 local_4;
	
	local_10 = objType;
	local_18 = 0x461c4000;
	local_24 = NULL;
	local_20 = 0.0;
	local_1c = 0.0;
	local_14 = 2;
	local_c = 0;
	local_8 = objLevel;
	local_4 = 0;
	if (liveObj == NULL) {
		out_y = &local_1c;
		out_x = &local_20;
		by = blockPos->y;
		bx = blockPos->x;
		surfMap = GetSurfaceMap();
		Map3D_BlockToWorldPos(surfMap,bx,by,out_x,out_y);
	}
	else {
		LiveObject_GetPosition(liveObj,&local_20,&local_1c);
	}
	Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



undefined4 __cdecl FUN_00438e40(LiveObject *liveObj,undefined4 param_2)
{
	undefined4 local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = 0;
	local_20 = 0.0;
	local_1c = 0.0;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	local_14 = param_2;
	local_18 = 0x461c4000;
	lego::game::LiveObject_GetPosition(liveObj,&local_20,&local_1c);
	lego::game::Search_LiveObjects_SkipIgnoreMes
						(lego::game::LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



undefined4 __cdecl FUN_00438eb0(LiveObject *liveObj)
{
	undefined4 local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = 0;
	local_20 = 0.0;
	local_1c = 0.0;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	local_18 = 0x461c4000;
	local_14 = 0x80;
	lego::game::LiveObject_GetPosition(liveObj,&local_20,&local_1c);
	lego::game::Search_LiveObjects_SkipIgnoreMes
						(lego::game::LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



undefined4 __cdecl FUN_00438f20(LiveObject *liveObj)
{
	undefined4 local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = 0;
	local_20 = 0.0;
	local_1c = 0.0;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	local_18 = 0x461c4000;
	local_14 = 4;
	lego::game::LiveObject_GetPosition(liveObj,&local_20,&local_1c);
	lego::game::Search_LiveObjects_SkipIgnoreMes
						(lego::game::LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



LiveObject * __cdecl lego::game::Game_FindBigTeleporter(Point2F *point)
{
	LiveObject *local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = NULL;
	local_18 = 0x461c4000;
	local_20 = point->x;
	local_1c = point->y;
	local_14 = 0x20;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



LiveObject * __cdecl lego::game::Game_FindSmallTeleporter(Point2F *point)
{
	LiveObject *local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = NULL;
	local_18 = 0x461c4000;
	local_20 = point->x;
	local_1c = point->y;
	local_14 = 0x10;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



LiveObject * __cdecl lego::game::Game_FindWaterTeleporter(Point2F *point)
{
	LiveObject *local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = NULL;
	local_18 = 0x461c4000;
	local_20 = point->x;
	local_1c = point->y;
	local_14 = 0x200;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



LiveObject * __cdecl lego::game::Level_GetBuildingAtPosition(Point2F *point)
{
	LiveObject *local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_24 = NULL;
	local_18 = 0x461c4000;
	local_20 = point->x;
	local_1c = point->y;
	local_14 = 8;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	local_4 = 0;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



undefined4 __cdecl FUN_00439110(LiveObject *liveObj,Point2F *param_2,TrainedFlags trainedType)
{
	undefined4 local_24;
	float local_20;
	float local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	TrainedFlags local_4;
	
	local_4 = trainedType;
	local_24 = 0;
	local_20 = 0.0;
	local_1c = 0.0;
	local_18 = 0x461c4000;
	local_14 = 0x100;
	local_10 = 0;
	local_c = 0;
	local_8 = 0;
	if (param_2 != NULL) {
		local_20 = param_2->x;
		local_1c = param_2->y;
	}
	if (liveObj != NULL) {
		lego::game::LiveObject_GetPosition(liveObj,&local_20,&local_1c);
	}
	lego::game::Search_LiveObjects_SkipIgnoreMes
						(lego::game::LiveObject_CallbackSearch_FUN_00439270,&local_24);
	return local_24;
}



BOOL __cdecl lego::game::LiveObject_HasTraining(LiveObject *liveObj,TrainedFlags training)
{
	ObjectStatsFlags2 OVar1;
	
	OVar1 = LiveObject_GetStatsFlags2(liveObj);
	if (((OVar1 & STATS2_TRAINPILOT) == STATS2_NONE) || (training != TRAINED_PILOT)) {
		OVar1 = LiveObject_GetStatsFlags2(liveObj);
		if (((OVar1 & STATS2_TRAINSAILOR) == STATS2_NONE) || (training != TRAINED_SAILOR)) {
			OVar1 = LiveObject_GetStatsFlags2(liveObj);
			if (((OVar1 & STATS2_TRAINDRIVER) == STATS2_NONE) || (training != TRAINED_DRIVER)) {
				OVar1 = LiveObject_GetStatsFlags2(liveObj);
				if (((OVar1 & STATS2_TRAINDYNAMITE) == STATS2_NONE) || (training != TRAINED_DYNAMITE)) {
					OVar1 = LiveObject_GetStatsFlags2(liveObj);
					if (((OVar1 & STATS2_TRAINREPAIR) == STATS2_NONE) || (training != TRAINED_REPAIR)) {
						OVar1 = LiveObject_GetStatsFlags2(liveObj);
						if (((OVar1 & STATS2_TRAINSCANNER) == STATS2_NONE) || (training != TRAINED_SCANNER)) {
							return 0;
						}
					}
				}
			}
		}
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_IsDocksBuilding_Unk(LiveObject *liveObj)
{
	BOOL BVar1;
	ObjectType local_8;
	int local_4;
	
	BVar1 = Object_GetObjectByName("Docks",&local_8,&local_4,NULL);
	if (((BVar1 != 0) && (liveObj->objType == local_8)) && (liveObj->objIndex == local_4)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_CallbackSearch_FUN_00439270(LiveObject *liveObj,int **search)
{
	int *piVar1;
	bool bVar2;
	BOOL BVar3;
	ObjectStatsFlags1 OVar4;
	ObjectStatsFlags2 OVar5;
	float local_8;
	float local_4;
	
	piVar1 = search[4];
	bVar2 = false;
	BVar3 = LiveObject_CheckCondition_FUN_00438870(liveObj,(uint)piVar1 & 0x400);
	if (BVar3 == 0) {
		return 0;
	}
	if ((((uint)piVar1 & 0x4000) != 0) && ((*(byte *)&liveObj->flags4 & 0x10) != 0)) {
		return 0;
	}
	if (((uint)piVar1 & 0xfffffbff) == 0) {
		if (liveObj->objType != OBJECT_BUILDING) goto LAB_00439459;
	}
	else {
		if (((((uint)piVar1 & 1) != 0) &&
				(OVar4 = LiveObject_GetStatsFlags1(liveObj), (OVar4 & STATS1_STOREOBJECTS) != STATS1_NONE))
			 && (BVar3 = LiveObject_CanSpawnCarryableObject(liveObj,(ObjectType)search[5],(int)search[6]),
					BVar3 != 0)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x1000) != 0) &&
			 (BVar3 = LiveObject_IsDocksBuilding_Unk(liveObj), BVar3 != 0)) {
			bVar2 = true;
		}
		if (((((uint)piVar1 & 0x2000) != 0) &&
				(OVar5 = LiveObject_GetStatsFlags2(liveObj), (OVar5 & STATS2_SELFPOWERED) == STATS2_NONE))
			 && ((OVar5 = LiveObject_GetStatsFlags2(liveObj),
					 (OVar5 & STATS2_GENERATEPOWER) == STATS2_NONE &&
					 (BVar3 = LiveObject_CheckCondition_FUN_00438870(liveObj,0), BVar3 != 0)))) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x100) != 0) &&
			 (BVar3 = LiveObject_HasTraining(liveObj,(TrainedFlags)search[8]), BVar3 != 0)) {
			bVar2 = true;
		}
		if (((((uint)piVar1 & 0x40) != 0) &&
				(OVar4 = LiveObject_GetStatsFlags1(liveObj), (OVar4 & STATS1_STOREOBJECTS) == STATS1_NONE))
			 && (liveObj->objType == OBJECT_BUILDING)) {
			bVar2 = true;
		}
		if (((((uint)piVar1 & 0x80) != 0) &&
				(OVar5 = LiveObject_GetStatsFlags2(liveObj), (OVar5 & STATS2_UPGRADEBUILDING) != STATS2_NONE
				)) && (liveObj->object_300 == NULL)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x800) != 0) &&
			 (OVar4 = LiveObject_GetStatsFlags1(liveObj), (OVar4 & STATS1_MANTELEPORTER) != STATS1_NONE))
		{
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x10) != 0) &&
			 (OVar4 = LiveObject_GetStatsFlags1(liveObj), (OVar4 & STATS1_SMALLTELEPORTER) != STATS1_NONE)
			 ) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x20) != 0) &&
			 (OVar4 = LiveObject_GetStatsFlags1(liveObj), (OVar4 & STATS1_BIGTELEPORTER) != STATS1_NONE))
		{
			bVar2 = true;
		}
		if ((((uint)piVar1 & 0x200) != 0) &&
			 (OVar4 = LiveObject_GetStatsFlags1(liveObj), (OVar4 & STATS1_WATERTELEPORTER) != STATS1_NONE)
			 ) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 2) != 0) &&
			 (((OVar4 = LiveObject_GetStatsFlags1(liveObj), (OVar4 & STATS1_PROCESSORE) != STATS1_NONE &&
				 (search[5] == (int *)&DAT_00000007)) ||
				((OVar4 = LiveObject_GetStatsFlags1(liveObj), (OVar4 & STATS1_PROCESSCRYSTAL) != STATS1_NONE
				 && (search[5] == (int *)0x6)))))) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 4) != 0) &&
			 (OVar4 = LiveObject_GetStatsFlags1(liveObj), (OVar4 & STATS1_SNAXULIKE) != STATS1_NONE)) {
			bVar2 = true;
		}
		if ((((uint)piVar1 & 8) == 0) ||
			 (OVar4 = LiveObject_GetStatsFlags1(liveObj), (OVar4 & STATS1_TOOLSTORE) == STATS1_NONE))
		goto LAB_00439459;
	}
	bVar2 = true;
LAB_00439459:
	if (bVar2) {
		LiveObject_GetPosition(liveObj,&local_8,&local_4);
		piVar1 = (int *)SQRT(((float)search[2] - local_4) * ((float)search[2] - local_4) +
												 ((float)search[1] - local_8) * ((float)search[1] - local_8));
		if ((float)piVar1 < (float)search[3]) {
			search[3] = piVar1;
			*search = (int *)liveObj;
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Game_CanStoredObjectTypeBeSpawned(ObjectType objType)
{
	BOOL BVar1;
	
	if (((objType != OBJECT_VEHICLE) && (objType != OBJECT_MINIFIGURE)) &&
		 (objType != OBJECT_BUILDING)) {
		BVar1 = Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_CanSpawnStoredObjects,&objType);
		if (BVar1 != 0) {
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_Callback_CanSpawnStoredObjects(LiveObject *liveObj1,LiveObject *spawnObj)
{
	ObjectStatsFlags1 OVar1;
	BOOL BVar2;
	
	OVar1 = LiveObject_GetStatsFlags1(liveObj1);
	if ((OVar1 & STATS1_STOREOBJECTS) != STATS1_NONE) {
		BVar2 = LiveObject_CanSpawnCarryableObject(liveObj1,spawnObj->objType,0);
		if (BVar2 != 0) {
			return TRUE;
		}
	}
	return 0;
}



void __cdecl lego::game::Game_PTL_GenerateFromCryOre(Point2I *position)
{
	Point2I *blockPos;
	BOOL BVar1;
	Point2I *pPVar2;
	uint uVar3;
	uint local_c;
	uint local_8;
	uint local_4;
	
	blockPos = position;
	BVar1 = Level_GetBlockCryOre
										(position,(int *)&position,(int *)&local_c,(int *)&local_8,(int *)&local_4);
	if (BVar1 != 0) {
		pPVar2 = NULL;
		if (position != NULL) {
			do {
				Level_GenerateCrystal(blockPos,0,NULL,1);
				pPVar2 = (Point2I *)((int)&pPVar2->x + 1);
			} while (pPVar2 < position);
		}
		uVar3 = 0;
		if (local_c != 0) {
			do {
				Level_GenerateCrystal(blockPos,1,NULL,1);
				uVar3 += 1;
			} while (uVar3 < local_c);
		}
		uVar3 = 0;
		if (local_8 != 0) {
			do {
				Level_GenerateOre(blockPos,0,NULL,1);
				uVar3 += 1;
			} while (uVar3 < local_8);
		}
		uVar3 = 0;
		if (local_4 != 0) {
			do {
				Level_GenerateOre(blockPos,1,NULL,1);
				uVar3 += 1;
			} while (uVar3 < local_4);
		}
	}
	return;
}



void __cdecl lego::game::Game_PTL_GenerateCrystalsAndOre(Point2I *blockPos,uint objLevel)
{
	Level_GenerateCrystal(blockPos,objLevel,NULL,TRUE);
	Level_GenerateOre(blockPos,objLevel,NULL,TRUE);
	return;
}



void __cdecl
lego::game::Level_GenerateCrystal
					(Point2I *blockPos,uint objLevel,Point2F *opt_point,BOOL showInfoMessage)
{
	SurfaceMap *surfMap;
	float fVar1;
	LiveObject *argument1Obj;
	LevelData *pLVar2;
	int iVar3;
	float x;
	float10 fVar4;
	float10 fVar5;
	uint x_00;
	uint y;
	Vector3F *out_vertices4;
	Vector3F local_30 [2];
	float local_18;
	float local_14;
	
	surfMap = GetSurfaceMap();
	fVar4 = Map3D_GetBlockSize(surfMap);
	surfMap = GetSurfaceMap();
	fVar5 = Map3D_GetBlockSize(surfMap);
	fVar1 = (float)((float10)(float)(fVar4 * (float10)0.5) - fVar5 * (float10)0.25);
	if (opt_point == NULL) {
		y = blockPos->y;
		x_00 = blockPos->x;
		out_vertices4 = local_30;
		surfMap = GetSurfaceMap();
		Map3D_GetBlockVertexPositions(surfMap,x_00,y,out_vertices4);
		fVar4 = math::Maths_RandRange(local_30[0].x + fVar1,local_18 - fVar1);
		x = (float)fVar4;
		fVar4 = math::Maths_RandRange(local_30[0].y - fVar1,local_14 + fVar1);
		fVar1 = (float)fVar4;
	}
	else {
		x = opt_point->x;
		fVar1 = opt_point->y;
	}
	argument1Obj = Game_CreateLiveResourceObject
													 (globs::gameGlobs.RES_Crystal,OBJECT_POWERCRYSTAL,0,objLevel,x,fVar1,0.0)
	;
	Message_AddMessageAction(MESSAGE_GENERATECRYSTAL_COMPLETE,argument1Obj,0,NULL);
	if (showInfoMessage != 0) {
		front::Info_FUN_00419ab0(INFO_CRYSTALFOUND,NULL,NULL,blockPos);
		front::Text_DisplayMessage(TEXT_CRYSTALFOUND,TRUE,FALSE);
		pLVar2 = GetLevel();
		iVar3 = (pLVar2->dimensions).width * blockPos->y + blockPos->x;
		pLVar2 = GetLevel();
		pLVar2->blocks[iVar3].generateCrystals = pLVar2->blocks[iVar3].generateCrystals + 1;
	}
	return;
}



void __cdecl
lego::game::Level_GenerateOre
					(Point2I *blockPos,uint objLevel,Point2F *opt_point,BOOL showInfoMessage)
{
	SurfaceMap *pSVar1;
	float fVar2;
	LiveObject *argument1Obj;
	LevelData *pLVar3;
	int iVar4;
	float x;
	float10 fVar5;
	float10 fVar6;
	uint x_00;
	uint y;
	Vector3F *out_vertices4;
	Vector3F local_30 [2];
	float local_18;
	float local_14;
	
	pSVar1 = GetSurfaceMap();
	fVar5 = Map3D_GetBlockSize(pSVar1);
	pSVar1 = GetSurfaceMap();
	fVar6 = Map3D_GetBlockSize(pSVar1);
	fVar2 = (float)((float10)(float)(fVar5 * (float10)0.5) - fVar6 * (float10)0.25);
	if (opt_point == NULL) {
		y = blockPos->y;
		x_00 = blockPos->x;
		out_vertices4 = local_30;
		pSVar1 = GetSurfaceMap();
		Map3D_GetBlockVertexPositions(pSVar1,x_00,y,out_vertices4);
		fVar5 = math::Maths_RandRange(local_30[0].x + fVar2,local_18 - fVar2);
		x = (float)fVar5;
		fVar5 = math::Maths_RandRange(local_30[0].y - fVar2,local_14 + fVar2);
		fVar2 = (float)fVar5;
	}
	else {
		x = opt_point->x;
		fVar2 = opt_point->y;
	}
	argument1Obj = Game_CreateLiveResourceObject
													 (globs::gameGlobs.RES_Ores_TABLE[0],OBJECT_ORE,0,objLevel,x,fVar2,0.0);
	Message_AddMessageAction(MESSAGE_GENERATEORE_COMPLETE,argument1Obj,0,NULL);
	front::Text_DisplayMessage(TEXT_OREFOUND,1,0);
	if (showInfoMessage != 0) {
		pLVar3 = GetLevel();
		iVar4 = (pLVar3->dimensions).width * blockPos->y + blockPos->x;
		pLVar3 = GetLevel();
		pLVar3->blocks[iVar4].generateOre = pLVar3->blocks[iVar4].generateOre + 1;
	}
	return;
}



char * __cdecl lego::game::LiveObject_GetName(LiveObject *liveObj)
{
	if (true) {
		switch(liveObj->objType) {
		case OBJECT_VEHICLE:
			return globs::gameGlobs.ObjectNames_VehicleTypes_TABLE[liveObj->vehicle->objIndex];
		case OBJECT_MINIFIGURE:
			return globs::gameGlobs.ObjectNames_MiniFigureTypes_TABLE[liveObj->miniFigure->objIndex];
		case OBJECT_ROCKMONSTER:
			return globs::gameGlobs.ObjectNames_RockMonsterTypes_TABLE[liveObj->rockMonster->objIndex];
		case OBJECT_BUILDING:
			return globs::gameGlobs.ObjectNames_BuildingTypes_TABLE[liveObj->building->objIndex];
		case OBJECT_POWERCRYSTAL:
			return globs::gameGlobs.ObjectNames_PowerCrystal;
		case OBJECT_ORE:
			return globs::gameGlobs.ToolTypes_TABLE[liveObj->objIndex + -0x1b];
		case OBJECT_DYNAMITE:
			return globs::gameGlobs.ObjectNames_Dynamite;
		case OBJECT_BARRIER:
			return globs::gameGlobs.ObjectNames_Barrier;
		case OBJECT_UPGRADEPART:
			return globs::gameGlobs.ObjectNames_UpgradeTypes_TABLE[liveObj->upgrade->objectIndex];
		case OBJECT_ELECTRICFENCE:
			return globs::gameGlobs.ObjectNames_ElectricFence;
		case OBJECT_SPIDERWEB:
			return globs::gameGlobs.ObjectNames_SpiderWeb;
		case OBJECT_OOHSCARY:
			return globs::gameGlobs.ObjectNames_OohScary;
		case OBJECT_PATH:
			return globs::gameGlobs.ObjectNames_Path;
		}
	}
	return NULL;
}



char * __cdecl lego::game::Object_GetTypeName(ObjectType objType,int objIndex)
{
	if (objType < OBJECT_BARRIER) {
		if (objType == OBJECT_DYNAMITE) {
			return "Dynamite";
		}
		if (true) {
			switch(objType) {
			case OBJECT_VEHICLE:
				return globs::gameGlobs.VehicleTypes_TABLE[objIndex];
			case OBJECT_MINIFIGURE:
				return globs::gameGlobs.MiniFigureTypes_TABLE[objIndex];
			case OBJECT_ROCKMONSTER:
				return globs::gameGlobs.RockMonsterTypes_TABLE[objIndex];
			case OBJECT_BUILDING:
				return globs::gameGlobs.BuildingTypes_TABLE[objIndex];
			case OBJECT_POWERCRYSTAL:
				return "PowerCrystal";
			case OBJECT_ORE:
				if (objIndex == 0) {
					return "Ore";
				}
				return "ProcessedOre";
			}
		}
	}
	else {
		if (objType < OBJECT_OOHSCARY) {
			if (objType == OBJECT_SPIDERWEB) {
				return "SpiderWeb";
			}
			if (objType == OBJECT_BARRIER) {
				return "Barrier";
			}
			if (objType == OBJECT_ELECTRICFENCE) {
				return "ElectricFence";
			}
		}
		else {
			if (objType == OBJECT_OOHSCARY) {
				return "OohScary";
			}
			if (objType == OBJECT_TVCAMERA) {
				return "tvcamera";
			}
		}
	}
	return NULL;
}



char * __cdecl lego::game::Object_GetTheName(ObjectType objType,int objIndex)
{
	if (true) {
		switch(objType) {
		case OBJECT_VEHICLE:
			return globs::gameGlobs.ObjectTheNames_VehicleTypes_TABLE[objIndex];
		case OBJECT_MINIFIGURE:
			return globs::gameGlobs.ObjectTheNames_MiniFigureTypes_TABLE[objIndex];
		case OBJECT_ROCKMONSTER:
			return globs::gameGlobs.ObjectTheNames_RockMonsterTypes_TABLE[objIndex];
		case OBJECT_BUILDING:
			return globs::gameGlobs.ObjectTheNames_BuildingTypes_TABLE[objIndex];
		case OBJECT_POWERCRYSTAL:
			return globs::gameGlobs.ObjectTheNames_PowerCrystal;
		case OBJECT_ORE:
			return globs::gameGlobs.ToolTypes_TABLE[objIndex + -0x12];
		case OBJECT_DYNAMITE:
			return globs::gameGlobs.ObjectTheNames_Dynamite;
		case OBJECT_BARRIER:
			return globs::gameGlobs.ObjectTheNames_Barrier;
		case OBJECT_UPGRADEPART:
			return globs::gameGlobs.ObjectTheNames_UpgradeTypes_TABLE[objIndex];
		case OBJECT_ELECTRICFENCE:
			return globs::gameGlobs.ObjectTheNames_ElectricFence;
		case OBJECT_SPIDERWEB:
			return globs::gameGlobs.ObjectTheNames_SpiderWeb;
		case OBJECT_OOHSCARY:
			return globs::gameGlobs.ObjectTheNames_OohScary;
		case OBJECT_PATH:
			return globs::gameGlobs.ObjectTheNames_Path;
		}
	}
	return NULL;
}



char * __cdecl lego::game::Object_GetName(ObjectType objType,int objIndex)
{
	if (true) {
		switch(objType) {
		case OBJECT_VEHICLE:
			return globs::gameGlobs.ObjectNames_VehicleTypes_TABLE[objIndex];
		case OBJECT_MINIFIGURE:
			return globs::gameGlobs.ObjectNames_MiniFigureTypes_TABLE[objIndex];
		case OBJECT_ROCKMONSTER:
			return globs::gameGlobs.ObjectNames_RockMonsterTypes_TABLE[objIndex];
		case OBJECT_BUILDING:
			return globs::gameGlobs.ObjectNames_BuildingTypes_TABLE[objIndex];
		case OBJECT_POWERCRYSTAL:
			return globs::gameGlobs.ObjectNames_PowerCrystal;
		case OBJECT_ORE:
			return globs::gameGlobs.ToolTypes_TABLE[objIndex + -0x1b];
		case OBJECT_DYNAMITE:
			return globs::gameGlobs.ObjectNames_Dynamite;
		case OBJECT_BARRIER:
			return globs::gameGlobs.ObjectNames_Barrier;
		case OBJECT_UPGRADEPART:
			return globs::gameGlobs.ObjectNames_UpgradeTypes_TABLE[objIndex];
		case OBJECT_ELECTRICFENCE:
			return globs::gameGlobs.ObjectNames_ElectricFence;
		case OBJECT_SPIDERWEB:
			return globs::gameGlobs.ObjectNames_SpiderWeb;
		case OBJECT_OOHSCARY:
			return globs::gameGlobs.ObjectNames_OohScary;
		case OBJECT_PATH:
			return globs::gameGlobs.ObjectNames_Path;
		}
	}
	return NULL;
}



void __cdecl
lego::game::LiveObject_GetTypeIndex(LiveObject *param_1,int *out_objType,int *out_objIndex)
{
	*out_objType = param_1->objType;
	*out_objIndex = param_1->objIndex;
	return;
}



void __cdecl lego::main::Main_LoadToolNames(CFGProperty *root,char *keyBasePath)
{
	char *keyPath;
	char **ppcVar1;
	char ***pppcVar2;
	
	pppcVar2 = (char ***)globs::gameGlobs.ToolNames_TABLE;
	do {
		keyPath = cfg::CFG_JoinPath(keyBasePath,"ToolNames",pppcVar2[-0xb],0);
		ppcVar1 = (char **)cfg::CFG_CopyString(root,keyPath);
		*pppcVar2 = ppcVar1;
		pppcVar2 = pppcVar2 + 1;
	} while (pppcVar2 < &globs::gameGlobs.ObjectNames_VehicleTypes_TABLE);
	return;
}



void __cdecl lego::game::LiveManager_InitFlagsToggle_AndClearNumDrained(void)
{
	if ((globs::liveGlobs.flags & 0x10) != LIVEMANAGER_NONE) {
		globs::liveGlobs.flags = globs::liveGlobs.flags | 8;
		return;
	}
	globs::liveGlobs.flags |= 4;
	if (globs::gameGlobs.level != NULL) {
		(globs::gameGlobs.level)->numDrainedCrystals = 0;
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_VehicleMaxCarryChecksTime_FUN_00439c80(LiveObject *liveObj)
{
	uint uVar1;
	uint uVar2;
	
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
		return 0;
	}
	if (liveObj->objType == OBJECT_VEHICLE) {
		uVar2 = liveObj->field_328;
		uVar1 = LiveObject_GetMaxCarry(liveObj);
		if (uVar1 <= uVar2) {
			uVar2 = LiveObject_GetMaxCarry(liveObj);
		}
		if ((liveObj->numCarriedObjects < uVar2) && (liveObj->elapsedTime1 < 75.0)) {
			return 0;
		}
	}
	return TRUE;
}



BOOL __cdecl
lego::game::LiveObject_TryCollect_FUN_00439ce0(LiveObject *liveObj1,LiveObject *targetObj)
{
	LiveObject *liveObj1_00;
	LiveObject *liveObj;
	BOOL BVar1;
	SurfaceMap *pSVar2;
	LiveObject **ppLVar3;
	LiveObject **ppLVar4;
	float *local_24;
	float *local_20;
	LiveObject *local_1c;
	LiveObject *local_18;
	uint local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	liveObj1_00 = liveObj1;
	BVar1 = LiveObject_VehicleMaxCarryChecksTime_FUN_00439c80(liveObj1);
	liveObj = targetObj;
	if ((BVar1 == 0) && (BVar1 = LiveObject_FUN_00439e90(liveObj1_00,targetObj,TRUE), BVar1 != 0)) {
		LiveObject_GetPosition(liveObj,&local_10,&local_c);
		ppLVar4 = &liveObj1;
		ppLVar3 = &targetObj;
		pSVar2 = GetSurfaceMap();
		Map3D_WorldToBlockPos_NoZ(pSVar2,local_10,local_c,(int *)ppLVar3,(int *)ppLVar4);
		LiveObject_GetPosition(liveObj1_00,&local_8,&local_4);
		ppLVar4 = &local_18;
		ppLVar3 = &local_1c;
		pSVar2 = GetSurfaceMap();
		Map3D_WorldToBlockPos_NoZ(pSVar2,local_8,local_4,(int *)ppLVar3,(int *)ppLVar4);
		if ((local_1c == targetObj) && (local_18 == liveObj1)) {
			LiveObject_FUN_004419c0(liveObj1_00,1,(float *)&targetObj,(float *)&liveObj1,&local_10);
		}
		else {
			BVar1 = LiveObject_FUN_004413b0
												(liveObj1_00,local_1c,local_18,targetObj,liveObj1,&local_24,&local_20,
												 &local_14,0,0);
			if (BVar1 == 0) {
				return 0;
			}
			LiveObject_FUN_004419c0(liveObj1_00,local_14,local_24,local_20,&local_10);
			std::free(local_24);
			std::free(local_20);
		}
		*(undefined *)((int)liveObj1_00->routeptr_24 + liveObj1_00->routingBlocksTotal * 0x14 + -3) = 3;
		liveObj1_00->object_2fc = liveObj;
		return TRUE;
	}
	return 0;
}



BOOL __cdecl FUN_00439e40(LiveObject *liveObj,undefined4 *param_2)
{
	ObjectStatsFlags3 OVar1;
	LiveObject *pLVar2;
	
	if (liveObj->objType == OBJECT_VEHICLE) {
		if (param_2[1] != 0) {
			return 0;
		}
		OVar1 = lego::game::LiveObject_GetStatsFlags3(liveObj);
		if ((OVar1 & STATS3_ENTERTOOLSTORE) == STATS3_NONE) {
			pLVar2 = lego::game::LiveObject_FUN_00438da0(liveObj,NULL,*param_2,param_2[0xcc]);
			return (uint)(pLVar2 != NULL);
		}
	}
	return 1;
}



BOOL __cdecl
lego::game::LiveObject_FUN_00439e90(LiveObject *liveObj1,LiveObject *liveObj2,BOOL param_3)
{
	BOOL BVar1;
	ObjectStatsFlags1 OVar2;
	
	if (liveObj1->objType == OBJECT_ROCKMONSTER) {
		if ((liveObj1->flags3 & LIVEOBJ3_UNK_8000000) == LIVEOBJ3_NONE) {
			return 0;
		}
	}
	else {
		if ((*(byte *)&liveObj1->flags3 & 0x20) == 0) {
			return 0;
		}
	}
	if ((*(byte *)&liveObj1->flags1 & 1) != 0) {
		return 0;
	}
	if (param_3 != 0) {
		BVar1 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj1);
		if (BVar1 != 0) {
			return 0;
		}
	}
	OVar2 = LiveObject_GetStatsFlags1(liveObj1);
	if (((OVar2 & STATS1_PROCESSCRYSTAL) != STATS1_NONE) && (liveObj2->objType != OBJECT_POWERCRYSTAL)
		 ) {
		return 0;
	}
	OVar2 = LiveObject_GetStatsFlags1(liveObj1);
	if (((OVar2 & STATS1_PROCESSORE) != STATS1_NONE) && (liveObj2->objType != OBJECT_ORE)) {
		return 0;
	}
	if ((liveObj1->numCarriedObjects != 0) &&
		 (liveObj1->carriedObjects[0]->objType != liveObj2->objType)) {
		return 0;
	}
	return TRUE;
}



void __cdecl lego::game::LiveObject_CompleteVehicleUpgrade(LiveObject *liveObj)
{
	uint uVar1;
	
	if (liveObj->objType == OBJECT_VEHICLE) {
		uVar1 = Vehicle_GetUpgradesCurrentLevel(liveObj->vehicle);
		uVar1 |= 1 << ((byte)liveObj->field_404 & 0x1f);
		res::Vehicle_ChangeUpgradeParts(liveObj->vehicle,uVar1);
		LiveObject_SetLevel(liveObj,uVar1);
		front::Text_DisplayMessage(TEXT_UNITUPGRADED,1,0);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_SetLevel_thunk(LiveObject *liveObj,int objLevel)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_SetLevel(liveObj,objLevel);
	return BVar1;
}



BOOL __cdecl lego::game::LiveObject_IsSmallTeleporter(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	return OVar1 & STATS1_SMALLTELEPORTER;
}



BOOL __cdecl lego::game::LiveObject_IsBigTeleporter(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	return OVar1 & STATS1_BIGTELEPORTER;
}



BOOL __cdecl lego::game::LiveObject_IsWaterTeleporter(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	return OVar1 & STATS1_WATERTELEPORTER;
}



BOOL __cdecl FUN_0043a010(LiveObject *liveObj,Point2I *out_position)
{
	uint bx;
	BOOL BVar1;
	int iVar2;
	uint by;
	uint uVar3;
	Point2I *pPVar4;
	Point2I local_28;
	Point2I DIRECTIONS [4];
	
	DIRECTIONS[0].y = -1;
	DIRECTIONS[3].x = -1;
	DIRECTIONS[1].x = 1;
	DIRECTIONS[2].y = 1;
	DIRECTIONS[0].x = 0;
	DIRECTIONS[1].y = 0;
	DIRECTIONS[2].x = 0;
	DIRECTIONS[3].y = 0;
	lego::game::LiveObject_GetBlockPos(liveObj,(int *)&local_28,&local_28.y);
	uVar3 = 0;
	pPVar4 = DIRECTIONS;
	do {
		pPVar4->x = pPVar4->x + local_28.x;
		by = pPVar4->y + local_28.y;
		pPVar4->y = by;
		bx = pPVar4->x;
		BVar1 = lego::game::Level_BlockIsFlags1_8(bx,by);
		if (BVar1 != 0) {
			iVar2 = lego::game::LiveObject_FUN_00431cd0(NULL,bx,pPVar4->y,bx,pPVar4->y,0);
			if (iVar2 != 0) {
				if (out_position != NULL) {
					iVar2 = DIRECTIONS[uVar3].y;
					out_position->x = DIRECTIONS[uVar3].x;
					out_position->y = iVar2;
				}
				return TRUE;
			}
		}
		uVar3 += 1;
		pPVar4 = pPVar4 + 1;
	} while (uVar3 < 4);
	return 0;
}



BOOL __cdecl FUN_0043a0d0(LiveObject *liveObj,uint *param_2)
{
	ObjectStatsFlags3 OVar1;
	BOOL BVar2;
	
	OVar1 = lego::game::LiveObject_GetStatsFlags3(liveObj);
	if ((OVar1 & STATS3_GETOUTATLAND) != STATS3_NONE) {
		BVar2 = FUN_0043a010(liveObj,(Point2I *)param_2);
		return BVar2;
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_CheckUnkGetInAtLand_FUN_0043a100(LiveObject *liveObj,Point2I *param_2)
{
	ObjectStatsFlags3 OVar1;
	BOOL BVar2;
	
	OVar1 = LiveObject_GetStatsFlags3(liveObj);
	if ((OVar1 & STATS3_GETINATLAND) != STATS3_NONE) {
		BVar2 = FUN_0043a010(liveObj,param_2);
		return BVar2;
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_0043a130(LiveObject *in_liveObj,BOOL param_2)
{
	char cVar1;
	LiveFlags1 LVar2;
	LiveObject *liveObj;
	LiveObject *liveObj_00;
	LiveObject *liveObj1;
	ObjectStatsFlags1 OVar3;
	BOOL BVar4;
	Container *cont;
	int iVar5;
	uint uVar6;
	LiveObject **ppLVar7;
	AITaskType taskType;
	Point2I local_20;
	float local_18;
	float local_14 [2];
	Vector3F local_c;
	
	liveObj1 = in_liveObj;
	LVar2 = in_liveObj->flags1;
	if (((LVar2 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
		 (((LVar2 & LIVEOBJ1_UNK_2000) == LIVEOBJ1_NONE || (param_2 != 0)))) {
		liveObj = in_liveObj->object_2fc;
		uVar6 = 0;
		in_liveObj = NULL;
		if (liveObj != NULL) {
			OVar3 = LiveObject_GetStatsFlags1(liveObj);
			in_liveObj = (LiveObject *)(OVar3 & STATS1_STOREOBJECTS);
		}
		if ((in_liveObj == NULL) && (param_2 != 0)) {
			ai::AITask_LiveObject_SetAITaskUnk(liveObj1,AITASK_DUMP,NULL,TRUE);
			ai::AITask_LiveObject_SetAITaskUnk(liveObj1,AITASK_DYNAMITE,NULL,TRUE);
			ai::AITask_LiveObject_SetAITaskUnk(liveObj1,AITASK_ELECFENCE,NULL,TRUE);
			ai::AITask_LiveObject_SetAITaskUnk(liveObj1,AITASK_BIRDSCARER,NULL,TRUE);
		}
		if (liveObj1->numCarriedObjects != 0) {
			ppLVar7 = liveObj1->carriedObjects;
			do {
				liveObj_00 = *ppLVar7;
				*ppLVar7 = NULL;
				liveObj_00->carryingThisObject = NULL;
				liveObj_00->object_300 = NULL;
				if ((in_liveObj == NULL) || (param_2 == 0)) {
					LiveObject_GetBlockPos(liveObj_00,(int *)&local_20,&local_20.y);
					BVar4 = Level_BlockIsFlags1_8(local_20.x,local_20.y);
					if (BVar4 == 0) {
LAB_0043a27e:
						cont = LiveObject_GetContainer(liveObj_00);
						LiveObject_GetPosition(liveObj1,&local_18,local_14);
						res::Container_GetPosition(cont,NULL,&local_c);
						res::Container_SetPosition(cont,NULL,local_18,local_14[0],local_c.z);
					}
					else {
						BVar4 = Level_Block_IsLava(&local_20);
						if (BVar4 != 0) goto LAB_0043a27e;
						BVar4 = Level_BlockIsFlags1_400_AndOptIsFlags2_4(local_20.x,local_20.y,0);
						if (BVar4 != 0) goto LAB_0043a27e;
					}
					if (param_2 == 0) {
						if ((LVar2 & LIVEOBJ1_UNK_200) == LIVEOBJ1_NONE) {
							ai::AITask_LiveObject_FUN_00403b30(liveObj1,AITASK_DEPOSITE,liveObj_00);
							ai::AITask_LiveObject_FUN_00403b30(liveObj1,AITASK_DUMP,liveObj_00);
							ai::AITask_LiveObject_FUN_00403b30(liveObj1,AITASK_DYNAMITE,liveObj_00);
							ai::AITask_LiveObject_FUN_00403b30(liveObj1,AITASK_ELECFENCE,liveObj_00);
							ai::AITask_LiveObject_FUN_00403b30(liveObj1,AITASK_REQUEST,liveObj_00);
							ai::AITask_LiveObject_FUN_00403b30(liveObj1,AITASK_GATHER,NULL);
							taskType = AITASK_BIRDSCARER;
						}
						else {
							taskType = AITASK_COLLECT;
						}
						ai::AITask_LiveObject_FUN_00403b30(liveObj1,taskType,liveObj_00);
					}
					else {
						ai::AITask_LiveObject_SetAITaskUnk
											(liveObj1,AITASK_REQUEST,liveObj_00,
											 (uint)(uVar6 == liveObj1->numCarriedObjects - 1));
						if ((liveObj_00->objType != OBJECT_ORE) && (liveObj_00->objType != OBJECT_POWERCRYSTAL))
						{
							liveObj_00->flags1 = liveObj_00->flags1 | LIVEOBJ1_PLACING;
						}
					}
					if (liveObj_00->objType == OBJECT_BOULDER) {
						LiveObject_DestroyBoulder_AndCreateExplode(liveObj_00);
					}
				}
				else {
					ai::AITask_LiveObject_SetAITaskUnk(liveObj1,AITASK_DEPOSITE,liveObj_00,TRUE);
					LiveObject_FUN_0043ab10(liveObj,liveObj_00);
					LiveManager_InitFlagsToggle_AndClearNumDrained();
				}
				uVar6 += 1;
				ppLVar7 = ppLVar7 + 1;
			} while (uVar6 < liveObj1->numCarriedObjects);
		}
		uVar6 = 0;
		liveObj1->numCarriedObjects = 0;
		liveObj1->flags1 = liveObj1->flags1 & ~LIVEOBJ1_CARRYING;
		if (liveObj1->routingBlocksTotal != 0) {
			iVar5 = 0;
			do {
				cVar1 = *(char *)(iVar5 + 0x11 + (int)liveObj1->routeptr_24);
				if ((cVar1 == '\a') || (cVar1 == '\x05')) {
					*(undefined *)(iVar5 + 0x11 + (int)liveObj1->routeptr_24) = 0;
				}
				uVar6 += 1;
				iVar5 += 0x14;
			} while (uVar6 < liveObj1->routingBlocksTotal);
		}
	}
	return;
}



int __cdecl
lego::game::LiveObject_TryRequestOrDump_FUN_0043a3e0
					(LiveObject *liveObj,Point2I *blockPos,Point2F *param_3,BOOL param_4,BOOL param_5)
{
	float fVar1;
	void *pvVar2;
	short sVar3;
	BOOL BVar4;
	uint uVar5;
	BOOL BVar6;
	float10 fVar7;
	float *local_1c;
	float *local_18;
	int local_14;
	int local_10;
	uint local_c;
	float local_8;
	float local_4;
	
	BVar6 = 0;
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		LiveObject_GetBlockPos(liveObj,&local_14,&local_10);
		if ((local_14 == blockPos->x) && (local_10 == blockPos->y)) {
			BVar6 = LiveObject_FUN_004419c0(liveObj,1,(float *)blockPos,(float *)&blockPos->y,NULL);
		}
		else {
			BVar4 = LiveObject_FUN_004413b0
												(liveObj,local_14,local_10,blockPos->x,blockPos->y,&local_1c,&local_18,
												 &local_c,0,0);
			if (BVar4 != 0) {
				BVar6 = LiveObject_FUN_004419c0(liveObj,local_c,local_1c,local_18,NULL);
				std::free(local_1c);
				std::free(local_18);
			}
		}
		if (BVar6 != 0) {
			if (liveObj->objType == OBJECT_VEHICLE) {
				fVar7 = math::Maths_RandRange(0.55,0.75);
				fVar1 = (float)fVar7;
				sVar3 = math::Maths_Rand();
				uVar5 = (int)sVar3 >> 0x1f;
				param_5 = 1;
				switch((((int)sVar3 ^ uVar5) - uVar5 & 3 ^ uVar5) - uVar5) {
				case 0:
					local_8 = 0.5;
					local_4 = fVar1;
					break;
				case 1:
					local_4 = 0.5;
					local_8 = fVar1;
					break;
				case 2:
					local_8 = 0.5;
					local_4 = 1.0 - fVar1;
					break;
				case 3:
					local_4 = 0.5;
					local_8 = 1.0 - fVar1;
				}
			}
			else {
				local_8 = param_3->x;
				local_4 = param_3->y;
			}
			if (param_4 == 0) {
				*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 8;
			}
			else {
				*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 9;
			}
			if (param_3 != NULL) {
				uVar5 = liveObj->routingBlocksTotal;
				pvVar2 = liveObj->routeptr_24;
				*(float *)((int)pvVar2 + uVar5 * 0x14 + -0xc) = local_8;
				*(float *)((int)pvVar2 + uVar5 * 0x14 + -8) = local_4;
			}
			if (param_5 != 0) {
				*(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) =
						 *(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) | 8;
			}
		}
	}
	return BVar6;
}



BOOL __cdecl
lego::game::LiveObject_TryDeposit_FUN_0043a5c0(LiveObject *liveObj1,LiveObject *targetObj)
{
	byte *pbVar1;
	LiveObject *liveObj;
	LiveObject *liveObj_00;
	ObjectStatsFlags1 OVar2;
	BOOL BVar3;
	SurfaceMap *pSVar4;
	Container *cont;
	float in_x;
	float in_y;
	LiveObject **ppLVar5;
	LiveObject **ppLVar6;
	LiveObject *local_3c;
	float *local_38;
	float *local_34;
	LiveObject *local_30;
	uint local_2c;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	Vector3F local_18;
	Vector3F local_c;
	
	liveObj = liveObj1;
	if ((liveObj1->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		OVar2 = LiveObject_GetStatsFlags1(liveObj1);
		if (((OVar2 & STATS1_PROCESSCRYSTAL) != STATS1_NONE) ||
			 (OVar2 = LiveObject_GetStatsFlags1(liveObj), liveObj_00 = targetObj,
			 (OVar2 & STATS1_PROCESSORE) != STATS1_NONE)) {
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_2000;
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_DESPOSIT,1);
			LiveObject_Container_ActivityUpdate_Check(liveObj);
			LiveObject_FUN_00447df0(liveObj,1.0);
			return TRUE;
		}
		BVar3 = LiveObject_FUN_00439e90(targetObj,liveObj->carriedObjects[0],0);
		if ((BVar3 != 0) ||
			 (OVar2 = LiveObject_GetStatsFlags1(liveObj_00), (OVar2 & STATS1_STOREOBJECTS) != STATS1_NONE)
			 ) {
			cont = NULL;
			OVar2 = LiveObject_GetStatsFlags1(liveObj_00);
			if ((OVar2 & STATS1_STOREOBJECTS) == STATS1_NONE) {
				if (liveObj_00->objType == OBJECT_BUILDING) {
					cont = res::Building_GetDepositNull(liveObj_00->building);
				}
			}
			else {
				cont = res::Building_GetToolNull
												 (liveObj_00->building,globs::liveGlobs.ToolNullIndexes_TABLE[10]);
			}
			if (cont == NULL) {
				LiveObject_GetPosition(liveObj_00,&local_28,&local_24);
			}
			else {
				res::Container_GetPosition(cont,NULL,&local_c);
				res::Container_GetOrientation(cont,NULL,&local_18,NULL);
				local_28 = local_c.x;
				local_24 = local_c.y;
				if (ABS(local_18.x) <= ABS(local_18.y)) {
					if ((ushort)((ushort)(local_18.y < 0.0) << 8 | (ushort)(local_18.y == 0.0) << 0xe) == 0) {
						liveObj1._0_1_ = 2;
					}
					else {
						liveObj1._0_1_ = 0;
					}
				}
				else {
					if ((ushort)((ushort)(local_18.x < 0.0) << 8 | (ushort)(local_18.x == 0.0) << 0xe) == 0) {
						liveObj1._0_1_ = 3;
					}
					else {
						liveObj1._0_1_ = 1;
					}
				}
			}
			ppLVar6 = &liveObj1;
			ppLVar5 = &targetObj;
			in_x = local_28;
			in_y = local_24;
			pSVar4 = GetSurfaceMap();
			Map3D_WorldToBlockPos_NoZ(pSVar4,in_x,in_y,(int *)ppLVar5,(int *)ppLVar6);
			LiveObject_GetPosition(liveObj,&local_20,&local_1c);
			ppLVar6 = &local_3c;
			ppLVar5 = &local_30;
			pSVar4 = GetSurfaceMap();
			Map3D_WorldToBlockPos_NoZ(pSVar4,local_20,local_1c,(int *)ppLVar5,(int *)ppLVar6);
			if ((local_30 == targetObj) && (local_3c == liveObj1)) {
				BVar3 = LiveObject_FUN_004419c0(liveObj,1,(float *)&targetObj,(float *)&liveObj1,&local_28);
			}
			else {
				BVar3 = LiveObject_FUN_004413b0
													(liveObj,local_30,local_3c,targetObj,liveObj1,&local_38,&local_34,
													 &local_2c,0,0);
				if (BVar3 == 0) {
					return 0;
				}
				BVar3 = LiveObject_FUN_004419c0(liveObj,local_2c,local_38,local_34,&local_28);
				std::free(local_38);
				std::free(local_34);
			}
			if (BVar3 != 0) {
				liveObj->object_2fc = liveObj_00;
				OVar2 = LiveObject_GetStatsFlags1(liveObj_00);
				if ((OVar2 & STATS1_STOREOBJECTS) != STATS1_NONE) {
					*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 9;
					liveObj->object_2fc = liveObj_00;
					return TRUE;
				}
				*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 7;
				*(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) =
						 *(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) | 4;
				pbVar1 = (byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4);
				*pbVar1 = *pbVar1 | (byte)liveObj1 & 3;
			}
			return TRUE;
		}
	}
	return 0;
}



Container * __cdecl lego::game::LiveObject_GetDepositNull(LiveObject *liveObj)
{
	ObjectType OVar1;
	Container *pCVar2;
	
	pCVar2 = NULL;
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_BUILDING) {
		pCVar2 = res::Building_GetDepositNull(liveObj->building);
	}
	else {
		if (OVar1 == OBJECT_ROCKMONSTER) {
			pCVar2 = res::Creature_GetDepositNull(liveObj->rockMonster);
		}
		else {
			if (OVar1 == OBJECT_MINIFIGURE) {
				pCVar2 = res::Creature_GetDepositNull(liveObj->miniFigure);
			}
			else {
				if (OVar1 == OBJECT_VEHICLE) {
					pCVar2 = res::Vehicle_GetDepositNull(liveObj->vehicle);
				}
			}
		}
	}
	if (pCVar2 == NULL) {
		pCVar2 = LiveObject_GetContainer(liveObj);
	}
	return pCVar2;
}



int __cdecl FUN_0043a910(LiveObject *liveObj,ObjectType objType,int objIndex,int objLevel)
{
	BOOL BVar1;
	int iVar2;
	Container *pCVar3;
	LiveObject *argument1Obj;
	MessageType messageType;
	Vector3F local_c;
	
	BVar1 = lego::game::LiveObject_CanSpawnCarryableObject(liveObj,objType,objIndex);
	if (BVar1 == 0) {
		return (int)NULL;
	}
	switch(objType) {
	case OBJECT_POWERCRYSTAL:
	case OBJECT_ORE:
		iVar2 = 10;
		break;
	case OBJECT_DYNAMITE:
		iVar2 = 9;
		break;
	case OBJECT_BARRIER:
		iVar2 = 8;
		break;
	default:
		iVar2 = 0;
	}
	pCVar3 = lego::res::Building_GetToolNull
										 (liveObj->building,lego::globs::liveGlobs.ToolNullIndexes_TABLE[iVar2]);
	lego::res::Container_GetPosition(pCVar3,NULL,&local_c);
	pCVar3 = lego::globs::gameGlobs.RES_Crystal;
	if (objType == OBJECT_POWERCRYSTAL) {
		lego::game::LiveManager_InitFlagsToggle_AndClearNumDrained();
		lego::game::Level_SubtractCrystals(1);
	}
	else {
		if (objType == OBJECT_ORE) {
			pCVar3 = lego::globs::gameGlobs.RES_Ores_TABLE[objIndex];
			lego::game::Level_SubtractOre(objIndex,1);
		}
		else {
			pCVar3 = lego::globs::gameGlobs.RES_Barrier;
			if ((((objType != OBJECT_BARRIER) &&
					 (pCVar3 = lego::globs::gameGlobs.RES_Dynamite, objType != OBJECT_DYNAMITE)) &&
					(pCVar3 = lego::globs::gameGlobs.RES_ElectricFence, objType != OBJECT_ELECTRICFENCE)) &&
				 (pCVar3 = lego::globs::gameGlobs.RES_OohScary, objType != OBJECT_OOHSCARY)) {
				return (int)NULL;
			}
		}
	}
	argument1Obj = lego::game::Game_CreateLiveResourceObject
													 (pCVar3,objType,objIndex,objLevel,local_c.x,local_c.y,0.0);
	if (objType == OBJECT_ORE) {
		messageType = MESSAGE_GENERATEORE_COMPLETE;
	}
	else {
		messageType = MESSAGE_GENERATECRYSTAL_COMPLETE;
	}
	lego::game::Message_AddMessageAction(messageType,argument1Obj,0,NULL);
	if (objType != OBJECT_BARRIER) {
		if (objType == OBJECT_DYNAMITE) {
			lego::res::Container_SetActivity(argument1Obj->other,"Normal");
		}
		return (int)argument1Obj;
	}
	lego::res::Container_SetActivity(argument1Obj->other,"Short");
	return (int)argument1Obj;
}



BOOL __cdecl
lego::game::LiveObject_CanSpawnCarryableObject(LiveObject *liveObj,ObjectType objType,int objIndex)
{
	ObjectStatsFlags1 OVar1;
	int iVar2;
	
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_STOREOBJECTS) != STATS1_NONE) {
		if (objType == OBJECT_POWERCRYSTAL) {
			iVar2 = Level_GetCrystalCount(1);
			if (iVar2 != 0) {
				return 1;
			}
		}
		if (objType == OBJECT_ORE) {
			iVar2 = Level_GetOreCount(objIndex);
			if (iVar2 != 0) {
				return 1;
			}
		}
		if (objType == OBJECT_BARRIER) {
			return 1;
		}
		if (objType == OBJECT_DYNAMITE) {
			return 1;
		}
		if (objType == OBJECT_ELECTRICFENCE) {
			return 1;
		}
		if (objType == OBJECT_OOHSCARY) {
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_0043ab10(LiveObject *liveObj,LiveObject *liveObj2)
{
	int *piVar1;
	int iVar2;
	
	if ((liveObj->objType == OBJECT_ROCKMONSTER) && (liveObj->tableptr_348 == NULL)) {
		piVar1 = (int *)std::malloc(0x18);
		liveObj->tableptr_348 = piVar1;
		for (iVar2 = 6; iVar2 != 0; iVar2 += -1) {
			*piVar1 = 0;
			piVar1 = piVar1 + 1;
		}
	}
	if (liveObj2->objType == OBJECT_POWERCRYSTAL) {
		if (liveObj->objType == OBJECT_ROCKMONSTER) {
			liveObj->tableptr_348[liveObj2->objLevel] = liveObj->tableptr_348[liveObj2->objLevel] + 1;
		}
		else {
			Level_IncrementCrystals();
		}
	}
	else {
		if ((liveObj2->objType == OBJECT_ORE) && (liveObj->objType != OBJECT_ROCKMONSTER)) {
			Level_IncOre(liveObj2->objIndex);
		}
	}
	liveObj2->carryingThisObject = NULL;
	pool::ReservedPool_LiveObject___Release(liveObj2);
	if (liveObj->objType != OBJECT_ROCKMONSTER) {
		ai::AITask_LiveObject_FUN_00403840(liveObj);
	}
	return;
}



void __cdecl FUN_0043abb0(undefined4 param_1,int param_2)
{
	if (param_2 != 0) {
		do {
			lego::game::Level_IncrementCrystals();
			param_2 += -1;
		} while (param_2 != 0);
	}
	lego::game::LiveManager_InitFlagsToggle_AndClearNumDrained();
	return;
}



void __cdecl FUN_0043abd0(undefined4 param_1,int param_2)
{
	if (param_2 != 0) {
		do {
			lego::game::Level_IncOre(ORE_NORMAL);
			param_2 += -1;
		} while (param_2 != 0);
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_0043abf0(LiveObject *liveObj)
{
	LiveObject **ppLVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (globs::liveGlobs.uintCount_c5cc != 0) {
		ppLVar1 = globs::liveGlobs.liveObjArray100_c43c;
		do {
			if (liveObj == *ppLVar1) {
				*ppLVar1 = NULL;
			}
			uVar2 += 1;
			ppLVar1 = ppLVar1 + 1;
		} while (uVar2 < globs::liveGlobs.uintCount_c5cc);
	}
	return;
}



void __cdecl lego::game::LiveObject_Vehicle_FUN_0043ac20(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	int local_8;
	int local_4;
	
	if (liveObj->objType == OBJECT_VEHICLE) {
		OVar1 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar1 & STATS1_CROSSLAND) == STATS1_NONE) {
			LiveObject_GetBlockPos(liveObj,&local_8,&local_4);
			if (((globs::gameGlobs.level)->blocks
					 [((globs::gameGlobs.level)->dimensions).width * local_4 + local_8].terrain ==
					 TERRAIN_LAKE) && (globs::liveGlobs.uintCount_c5cc < 100)) {
				globs::liveGlobs.liveObjArray100_c43c[globs::liveGlobs.uintCount_c5cc] = liveObj;
				globs::liveGlobs.uintCount_c5cc += 1;
			}
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_Vehicle_FUN_0043aca0(LiveObject *liveObj)
{
	LiveObject_Vehicle_FUN_0043ac20(liveObj);
	return;
}



void __cdecl lego::game::LiveObject_FUN_0043acb0(LiveObject *liveObj1,LiveObject *liveObj2)
{
	int local_10;
	int local_c;
	int local_8;
	int local_4;
	
	if (((((liveObj1->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) &&
			 ((*(byte *)&liveObj1->flags2 & 1) == 0)) &&
			((liveObj1->flags1 & (LIVEOBJ1_UNK_100|LIVEOBJ1_UNK_1000000)) == LIVEOBJ1_NONE)) &&
		 ((((ushort)((ushort)(liveObj1->health < 0.0) << 8 | (ushort)(liveObj1->health == 0.0) << 0xe)
				== 0 && ((liveObj2->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
			(liveObj2->carriedObjects[0]->objType == OBJECT_POWERCRYSTAL)))) {
		LiveObject_GetBlockPos(liveObj1,&local_10,&local_c);
		LiveObject_GetBlockPos(liveObj2,&local_8,&local_4);
		if (globs::liveGlobs.Activities_TABLE[36] != liveObj1->aitaskName1) {
			LiveObject_SetActivityUnk(liveObj1,ACTIVITY_STAMP,0);
			LiveObject_Container_ActivityUpdate_Check(liveObj1);
			liveObj1->flags2 = liveObj1->flags2 | LIVEOBJ2_UNK_200000;
		}
	}
	return;
}



void __cdecl FUN_0043ad70(uint *param_1)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	uint uVar3;
	SurfaceMap *pSVar4;
	float10 fVar5;
	float10 fVar6;
	float *out_x;
	float *out_y;
	Point2I local_18;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	if (*param_1 == 3) {
		OVar1 = lego::game::LiveObject_GetStatsFlags2((LiveObject *)param_1);
		if ((OVar1 & STATS2_ATTACKPATHS) != STATS2_NONE) {
			fVar5 = lego::game::LiveObject_GetPainThreshold((LiveObject *)param_1);
			if (((fVar5 < (float10)(float)param_1[0xd0]) &&
					(lego::globs::liveGlobs.Activities_TABLE[36] != (char *)param_1[0xba])) &&
				 ((param_1[0xf8] & 0x400) == 0)) {
				lego::game::LiveObject_GetBlockPos((LiveObject *)param_1,(int *)&local_18,&local_18.y);
				BVar2 = lego::game::Level_Block_IsPowerPath(&local_18);
				if (BVar2 != 0) {
					uVar3 = FUN_00432f60((int *)&local_18);
					if (uVar3 == 0) {
						lego::game::LiveObject_GetPosition((LiveObject *)param_1,&local_10,&local_c);
						out_y = &local_4;
						out_x = &local_8;
						pSVar4 = lego::game::GetSurfaceMap();
						lego::game::Map3D_BlockToWorldPos(pSVar4,local_18.x,local_18.y,out_x,out_y);
						pSVar4 = lego::game::GetSurfaceMap();
						fVar6 = lego::game::Map3D_GetBlockSize(pSVar4);
						fVar5 = (float10)SQRT((local_c - local_4) * (local_c - local_4) +
																	(local_10 - local_8) * (local_10 - local_8));
						if ((ushort)((ushort)(fVar6 * (float10)0.3333333 < fVar5) << 8 |
												(ushort)(fVar6 * (float10)0.3333333 == fVar5) << 0xe) == 0) {
							lego::game::LiveObject_SetActivityUnk((LiveObject *)param_1,ACTIVITY_STAMP,0);
							lego::game::LiveObject_Container_ActivityUpdate_Check((LiveObject *)param_1);
							param_1[0xf9] = param_1[0xf9] | 0x200000;
						}
					}
				}
			}
		}
	}
	return;
}



void __cdecl FUN_0043aeb0(LiveObject *liveObj)
{
	short sVar1;
	BOOL BVar2;
	Point2I local_8;
	
	lego::game::LiveObject_GetBlockPos(liveObj,(int *)&local_8,&local_8.y);
	sVar1 = lego::math::Maths_Rand();
	if ((int)sVar1 % 5 == 0) {
		FUN_00435160(&local_8,3,1);
	}
	BVar2 = lego::game::Level_Block_IsPowerPath(&local_8);
	if (BVar2 != 0) {
		lego::effect::Effect_Spawn_SmashPath(liveObj,NULL);
		lego::ai::AITask_DoClearTypeAction(&local_8,MESSAGE_CLEARREMOVEPATH_COMPLETE);
		lego::game::Level_UpdateBlockSurfaceUnk(lego::globs::gameGlobs.level,local_8.x,local_8.y,0);
	}
	lego::game::Search_LiveObjects_SkipIgnoreMes(FUN_0043af50,(undefined4 *)liveObj);
	return;
}



undefined4 __cdecl FUN_0043af50(int *param_1,undefined4 *param_2)
{
	float10 fVar1;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	if (((*param_1 == 2) && ((param_1[0xf8] & 0x400U) != 0)) && (*(int *)param_1[0xc2] == 6)) {
		lego::game::LiveObject_GetPosition((LiveObject *)param_2,&local_8,&local_4);
		lego::game::LiveObject_GetPosition((LiveObject *)param_1,&local_10,&local_c);
		fVar1 = lego::game::LiveObject_GetStampRadius((LiveObject *)param_2);
		if ((float10)SQRT((local_c - local_4) * (local_c - local_4) +
											(local_10 - local_8) * (local_10 - local_8)) < fVar1) {
			lego::game::LiveObject_FUN_0043a130((LiveObject *)param_1,0);
			lego::game::LiveObject_UnkDoRouting_FUN_00441c00((LiveObject *)param_1,0);
		}
	}
	return 0;
}



uint * __cdecl FUN_0043b010(undefined4 *param_1,uint param_2)
{
	short sVar1;
	SurfaceMap *surfMap;
	LiveObject *liveObj;
	float10 fVar2;
	float10 fVar3;
	uint bx;
	uint by;
	float *out_x;
	float *out_y;
	float local_18;
	float local_14;
	Point2I local_10;
	float local_8;
	float local_4;
	
	liveObj = NULL;
	if (lego::globs::liveGlobs.SlugHoles_COUNT != 0) {
		fVar2 = lego::math::Maths_RandRange(0.0,6.283185);
		fVar3 = (float10)fsin(fVar2);
		local_8 = (float)fVar3;
		fVar3 = (float10)fcos((float10)(float)fVar2);
		local_4 = (float)fVar3;
		if (param_1 == NULL) {
			sVar1 = lego::math::Maths_Rand();
			local_10.x = lego::globs::liveGlobs.SlugHoles_TABLE
									 [(uint)(int)sVar1 % lego::globs::liveGlobs.SlugHoles_COUNT].x;
			local_10.y = lego::globs::liveGlobs.SlugHoles_TABLE
									 [(uint)(int)sVar1 % lego::globs::liveGlobs.SlugHoles_COUNT].y;
		}
		else {
			lego::game::LiveObject_NearestSlugHole_FUN_0044a7b0((LiveObject *)param_1,&local_10);
		}
		out_y = &local_14;
		out_x = &local_18;
		bx = local_10.x;
		by = local_10.y;
		surfMap = lego::game::GetSurfaceMap();
		lego::game::Map3D_BlockToWorldPos(surfMap,bx,by,out_x,out_y);
		local_18 = local_8 * 12.75 + local_18;
		local_14 = local_4 * 12.75 + local_14;
		liveObj = lego::game::Game_CreateLiveResourceObject
												((Container *)(lego::globs::gameGlobs.RockMonsterData_TABLE + param_2),
												 OBJECT_ROCKMONSTER,param_2,0,local_18,local_14,(float)fVar2);
		if (liveObj != NULL) {
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_100;
			liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_POWEROFF;
			lego::game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_EMERGE,0);
			lego::game::LiveObject_Container_ActivityUpdate_Check(liveObj);
			lego::ai::AITask_DoAnimationWait(liveObj);
			lego::front::Info_FUN_00419ab0(INFO_SLUGEMERGE,NULL,liveObj,NULL);
		}
	}
	return (uint *)liveObj;
}



LiveObject * __cdecl lego::game::Game_PTL_GenerateRockMonster(void)
{
	short rngX;
	short rngY;
	int objIndex;
	SurfaceMap *pSVar1;
	LiveObject *pLVar2;
	uint local_c;
	int height;
	int width;
	
	objIndex = Level_GetEmergeCreature();
	pSVar1 = GetSurfaceMap();
	width = (pSVar1->smallDimensions).width;
	pSVar1 = GetSurfaceMap();
	height = (pSVar1->smallDimensions).height;
	local_c = 0;
	do {
		rngX = math::Maths_Rand();
		rngY = math::Maths_Rand();
		pLVar2 = Game_TryGeneratedRockMonsterLiveObject
											 ((int **)(globs::gameGlobs.RockMonsterData_TABLE + objIndex),
												OBJECT_ROCKMONSTER,objIndex,(int)rngX % width,(int)rngY % height);
		if (pLVar2 != NULL) {
			return pLVar2;
		}
		local_c += 1;
	} while (local_c < 1000);
	return NULL;
}



LiveObject * __cdecl
lego::game::Game_TryGeneratedRockMonsterLiveObject
					(int **objSrc,ObjectType objType,int objIndex,uint bx,uint by)
{
	BOOL BVar1;
	uint uVar2;
	int iVar3;
	SurfaceMap *surfMap;
	LiveObject *liveObj;
	Container *cont;
	uint uVar4;
	Point2I *blockPos;
	bool bVar5;
	ObjectType bx_00;
	uint uVar6;
	float *pfVar7;
	float *pfVar8;
	float local_44;
	float local_40;
	float local_3c;
	Point2I local_38;
	float local_30 [4];
	Point2I local_20;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar6 = by;
	bx_00 = bx;
	local_38.x = bx;
	local_38.y = by;
	if ((float)objType != 4.203895e-45) {
		return NULL;
	}
	BVar1 = Level_GetBlockFlags1_10Not8(bx,by);
	if (BVar1 == 0) {
		return NULL;
	}
	BVar1 = Level_Block_IsReinforced(bx_00,uVar6);
	if (BVar1 != 0) {
		return NULL;
	}
	BVar1 = Level_Block_IsFlags1_c0(bx_00,uVar6);
	if (BVar1 != 0) {
		return NULL;
	}
	BVar1 = Level_Block_IsImmovable(&local_38);
	if (BVar1 != 0) {
		return NULL;
	}
	uVar2 = Level_GetBlockFlags1_8000000(&local_38);
	if (uVar2 != 0) {
		return NULL;
	}
	uVar2 = 0;
	local_20.x = 0;
	local_20.y = -1;
	local_18 = 1;
	local_14 = 0;
	local_10 = 0;
	local_c = 1;
	local_8 = 0xffffffff;
	local_4 = 0;
	local_30[0] = 0.0;
	local_30[1] = 1.570796;
	local_30[2] = 3.141593;
	local_30[3] = 4.712389;
	blockPos = &local_20;
	do {
		blockPos->x = blockPos->x + bx_00;
		uVar4 = blockPos->y + uVar6;
		blockPos->y = uVar4;
		BVar1 = Level_BlockIsFlags1_8(blockPos->x,uVar4);
		if (((BVar1 != 0) && (BVar1 = Level_BlockIsFlags1_180000(blockPos), BVar1 == 0)) &&
			 (iVar3 = LiveObject_FUN_00431cd0(NULL,blockPos->x,blockPos->y,blockPos->x,blockPos->y,0),
			 iVar3 != 0)) break;
		uVar2 += 1;
		blockPos = blockPos + 1;
	} while (uVar2 < 4);
	if (3 < uVar2) {
		return NULL;
	}
	pfVar8 = &local_3c;
	pfVar7 = &local_40;
	surfMap = GetSurfaceMap();
	Map3D_BlockToWorldPos(surfMap,bx_00,uVar6,pfVar7,pfVar8);
	uVar6 = (&local_20)[uVar2].y;
	pfVar8 = (float *)&objType;
	pfVar7 = &local_44;
	uVar4 = (&local_20)[uVar2].x;
	surfMap = GetSurfaceMap();
	Map3D_BlockToWorldPos(surfMap,uVar4,uVar6,pfVar7,pfVar8);
	local_44 = (local_40 * 9.0 + local_44 * 10.0) * 0.05263158;
	objType = (ObjectType)((local_3c * 9.0 + (float)objType * 10.0) * 0.05263158);
	liveObj = Game_CreateLiveResourceObject
											((Container *)objSrc,OBJECT_ROCKMONSTER,objIndex,0,local_44,(float)objType,
											 local_30[uVar2]);
	liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_100;
	LiveObject_RockMonster_DoWakeUp(liveObj);
	LiveObject_SetActivityUnk(liveObj,ACTIVITY_EMERGE,0);
	LiveObject_Container_ActivityUpdate_Check(liveObj);
	ai::AITask_DoAnimationWait(liveObj);
	cont = LiveObject_GetContainer(liveObj);
	res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(cont,SFX_ROCKMONSTER2,FALSE,TRUE,NULL);
	Level_Block_SetFlags1_8000000(&local_38,TRUE);
	bVar5 = false;
	(liveObj->point_2f4).x = (float)local_38.x;
	(liveObj->point_2f4).y = (float)local_38.y;
	BVar1 = Object_GetObjectByName("RockMonster",&bx,(int *)&by,NULL);
	if (((BVar1 != 0) && (bx == liveObj->objType)) && (by == liveObj->objIndex)) {
		front::Info_FUN_00419ab0(INFO_ROCKMONSTER,NULL,liveObj,NULL);
		bVar5 = true;
	}
	if (!bVar5) {
		BVar1 = Object_GetObjectByName("Lavamonster",&bx,(int *)&by,NULL);
		if (((BVar1 != 0) && (bx == liveObj->objType)) && (by == liveObj->objIndex)) {
			front::Info_FUN_00419ab0(INFO_LAVAROCKMONSTER,NULL,liveObj,NULL);
			bVar5 = true;
		}
		if (!bVar5) {
			BVar1 = Object_GetObjectByName("Icemonster",&bx,(int *)&by,NULL);
			if (((BVar1 != 0) && (bx == liveObj->objType)) && (by == liveObj->objIndex)) {
				front::Info_FUN_00419ab0(INFO_ICEROCKMONSTER,NULL,liveObj,NULL);
				bVar5 = true;
			}
			if (!bVar5) goto LAB_0043b517;
		}
	}
	front::Info_FUN_00419ab0(INFO_GENERICMONSTER,NULL,liveObj,NULL);
LAB_0043b517:
	nerps::NERPs_IncRockMonstersGenerated();
	return liveObj;
}



void __cdecl lego::game::LiveManager_UpdateAll(float elapsedGame)
{
	LiveManagerFlags LVar1;
	LiveManagerFlags LVar2;
	
	if ((globs::liveGlobs.flags & 4) != LIVEMANAGER_NONE) {
		Game_LevelClearBlockFlag2_100_Points28C();
	}
	globs::liveGlobs.flags |= 0x10;
	Search_LiveObjects(Game_LiveObjectLargeCallback,&elapsedGame,FALSE);
	LVar2 = globs::liveGlobs.flags & 0xffffffef;
	LVar1 = globs::liveGlobs.flags & 4;
	globs::liveGlobs.flags = LVar2;
	if (LVar1 != LIVEMANAGER_NONE) {
		Game_UpdateLevelBlocks_PointsAAC();
	}
	if ((globs::liveGlobs.flags & 8) == LIVEMANAGER_NONE) {
		globs::liveGlobs.flags &= 0xfffffffb;
	}
	else {
		LiveManager_InitFlagsToggle_AndClearNumDrained();
		globs::liveGlobs.flags &= 0xfffffff7;
	}
	Flocks_Update_FUN_0044c1c0(&elapsedGame);
	globs::liveGlobs.LiveManager_TimerUnk = globs::liveGlobs.LiveManager_TimerUnk - elapsedGame;
	if ((ushort)((ushort)(globs::liveGlobs.LiveManager_TimerUnk < 0.0) << 8 |
							(ushort)(globs::liveGlobs.LiveManager_TimerUnk == 0.0) << 0xe) != 0) {
		globs::liveGlobs.LiveManager_TimerUnk = 125.0;
		LiveManager_Update3DSounds(TRUE);
	}
	return;
}



void __cdecl lego::game::LiveManager_Cleanup_FUN_0043b5e0(void)
{
	globs::liveGlobs.flags |= 2;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_Release,NULL);
	globs::liveGlobs.flags = globs::liveGlobs.flags & 0xfffffffd;
	return;
}



BOOL __cdecl lego::game::LiveObject_Callback_Release(LiveObject *liveObj,void *unused)
{
	BOOL BVar1;
	
	BVar1 = pool::ReservedPool_LiveObject___Release(liveObj);
	return BVar1;
}



void __cdecl
lego::game::LiveManager_DoPickSphereCallbacks_MouseXY
					(uint mouseX,uint mouseY,undefined4 *ref_param_3)
{
	undefined4 *local_c;
	float local_8;
	float local_4;
	
	local_c = ref_param_3;
	*ref_param_3 = 0;
	local_8 = (float)(ulonglong)mouseX;
	local_4 = (float)(ulonglong)mouseY;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_FUN_0043b670,&local_c);
	return;
}



BOOL __cdecl lego::game::LiveObject_Callback_FUN_0043b670(LiveObject *liveObj,int **param_2)
{
	BOOL BVar1;
	SurfaceMap *pSVar2;
	Container *cont;
	Point2I *pPVar3;
	uint uVar4;
	uint uVar5;
	Direction rotation;
	Vector3F *pVVar6;
	Viewport *view;
	float10 fVar7;
	uint bx;
	Vector3F *pVVar8;
	float x;
	Vector3F *camera;
	float *out_y;
	float y;
	uint local_d0;
	uint local_cc;
	Point2I *local_c8;
	Viewport *local_c4;
	Vector4F local_c0;
	Vector3F local_b0;
	Vector3F local_a4;
	Point2I local_98;
	Vector3F local_90;
	Vector3F local_84;
	Vector3F local_78 [10];
	
	view = globs::gameGlobs.viewMain;
	local_c0.x = (float)param_2[1];
	local_c0.y = (float)param_2[2];
	rotation = DIRECTION_RIGHT;
	local_c4 = globs::gameGlobs.viewMain;
	local_c0.z = 0.0;
	local_c0.w = 1.0;
	BVar1 = LiveObject_CheckCondition_FUN_00438870(liveObj,1);
	if (BVar1 != 0) {
		LiveObject_GetBlockPos(liveObj,(int *)&local_98,&local_98.y);
		LiveObject_GetPosition(liveObj,(float *)local_78,&local_78[0].y);
		pSVar2 = GetSurfaceMap();
		fVar7 = Map3D_GetWorldZ(pSVar2,local_78[0].x,local_78[0].y);
		local_78[0].z = (float)fVar7;
		fVar7 = LiveObject_GetCollHeight(liveObj);
		local_78[0].z = (float)((float10)local_78[0].z - fVar7 * (float10)0.5);
		if (liveObj->objType == OBJECT_BUILDING) {
			cont = LiveObject_GetContainer(liveObj);
			uVar5 = 0;
			res::Container_GetOrientation(cont,NULL,&local_b0,NULL);
			if (ABS(local_b0.x) <= ABS(local_b0.y)) {
				if ((ushort)((ushort)(local_b0.y < 0.0) << 8 | (ushort)(local_b0.y == 0.0) << 0xe) == 0) {
					rotation = DIRECTION_UP;
				}
				else {
					rotation = DIRECTION_DOWN;
				}
			}
			else {
				if ((ushort)((ushort)(local_b0.x < 0.0) << 8 | (ushort)(local_b0.x == 0.0) << 0xe) != 0) {
					rotation = DIRECTION_LEFT;
				}
			}
			pPVar3 = res::Building_GetShapePoints
												 (globs::gameGlobs.BuildingData_TABLE + liveObj->objIndex,&local_cc);
			pPVar3 = Game_TransformShapePoints(&local_98,pPVar3,local_cc,rotation);
			local_d0 = 0;
			if (local_cc != 0) {
				local_c8 = pPVar3 + 1;
				pVVar6 = local_78;
				uVar4 = local_cc;
				do {
					if (((uVar5 == uVar4 - 1) || (pPVar3->x != local_c8->x)) || (pPVar3->y != local_c8->y)) {
						uVar4 = pPVar3->y;
						bx = pPVar3->x;
						pVVar8 = pVVar6;
						out_y = &pVVar6->y;
						pSVar2 = GetSurfaceMap();
						Map3D_BlockToWorldPos(pSVar2,bx,uVar4,(float *)pVVar8,out_y);
						y = pVVar6->y;
						x = pVVar6->x;
						pSVar2 = GetSurfaceMap();
						fVar7 = Map3D_GetWorldZ(pSVar2,x,y);
						pVVar6->z = (float)fVar7;
						fVar7 = LiveObject_GetCollHeight(liveObj);
						local_d0 += 1;
						pVVar6->z = (float)((float10)pVVar6->z - fVar7 * (float10)0.5);
						uVar4 = local_cc;
						pVVar6 = pVVar6 + 1;
					}
					else {
						uVar5 += 1;
						local_c8 = local_c8 + 1;
						pPVar3 = pPVar3 + 1;
					}
					uVar5 += 1;
					local_c8 = local_c8 + 1;
					pPVar3 = pPVar3 + 1;
					view = local_c4;
				} while (uVar5 < uVar4);
			}
		}
		else {
			local_d0 = 1;
		}
		lego::view::Viewport_InverseTransform(view,&local_a4,&local_c0);
		local_c0.z = 1.0;
		lego::view::Viewport_InverseTransform(view,&local_84,&local_c0);
		local_90.x = local_84.x - local_a4.x;
		local_84.y = local_84.y - local_a4.y;
		local_84.z = local_84.z - local_a4.z;
		uVar5 = 0;
		local_90.z = 1.0 / SQRT(local_84.z * local_84.z +
														local_84.y * local_84.y + local_90.x * local_90.x);
		local_90.x = local_90.z * local_90.x;
		local_90.y = local_90.z * local_84.y;
		local_90.z = local_90.z * local_84.z;
		if (local_d0 != 0) {
			pVVar6 = local_78;
			do {
				pVVar8 = &local_90;
				camera = &local_a4;
				fVar7 = LiveObject_GetPickSphere(liveObj);
				BVar1 = math::Maths_RaySphereIntersection(pVVar6,(float)fVar7,camera,pVVar8);
				if (BVar1 != 0) {
					**param_2 = (int)liveObj;
					return TRUE;
				}
				uVar5 += 1;
				pVVar6 = pVVar6 + 1;
			} while (uVar5 < local_d0);
			return 0;
		}
	}
	return 0;
}



void __cdecl lego::view::Viewport_DoSelection(Viewport *view,Point2F *dragStart,Point2F *dragEnd)
{
	TutorialFlags TVar1;
	Viewport *local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if ((TVar1 & TUTORIAL_UNK_8) == TUTORIAL_NONE) {
		local_14 = view;
		if (dragEnd->x <= dragStart->x) {
			local_10 = dragEnd->x;
		}
		else {
			local_10 = dragStart->x;
		}
		if ((ushort)((ushort)(dragEnd->y < dragStart->y) << 8 |
								(ushort)(dragEnd->y == dragStart->y) << 0xe) == 0) {
			local_c = dragStart->y;
		}
		else {
			local_c = dragEnd->y;
		}
		if ((ushort)((ushort)(dragStart->x < dragEnd->x) << 8 |
								(ushort)(dragStart->x == dragEnd->x) << 0xe) == 0) {
			local_8 = dragStart->x;
		}
		else {
			local_8 = dragEnd->x;
		}
		if (dragStart->y <= dragEnd->y) {
			local_4 = dragEnd->y;
		}
		else {
			local_4 = dragStart->y;
		}
		game::Search_LiveObjects_SkipIgnoreMes(FUN_0043ba30,&local_14);
		game::Message_AddMessageAction(MESSAGE_REDUCESELECTION,0,0,NULL);
	}
	return;
}



undefined4 __cdecl FUN_0043ba30(LiveObject *liveObj,int *param_2)
{
	Container *cont;
	Vector3F local_1c;
	Vector4F local_10;
	
	cont = lego::game::LiveObject_GetContainer(liveObj);
	lego::res::Container_GetPosition(cont,NULL,&local_1c);
	lego::view::Viewport_Transform((Viewport *)*param_2,&local_10,&local_1c);
	local_10.x = local_10.x / local_10.w;
	local_10.y = local_10.y / local_10.w;
	if (((((float)param_2[1] <= local_10.x) && ((float)param_2[2] <= local_10.y)) &&
			((ushort)((ushort)(local_10.x < (float)param_2[3]) << 8 |
							 (ushort)(local_10.x == (float)param_2[3]) << 0xe) != 0)) &&
		 ((ushort)((ushort)(local_10.y < (float)param_2[4]) << 8 |
							(ushort)(local_10.y == (float)param_2[4]) << 0xe) != 0)) {
		lego::game::Message_AddMessageAction(MESSAGE_SELECT,liveObj,1,NULL);
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_FUN_0043bae0(LiveObject *liveObj,int camField14,BOOL in_polyIndexUnk)
{
	if ((liveObj->objType == OBJECT_MINIFIGURE) ||
		 ((liveObj = liveObj->drivenObject, liveObj != NULL && (liveObj->objType == OBJECT_MINIFIGURE)))
		 ) {
		res::Creature_SwapPolyFP(liveObj->miniFigure,in_polyIndexUnk,camField14);
	}
	return;
}



void __cdecl
lego::game::LiveObject_FP_SetRanges
					(LiveObject *liveObj,Container *resData,float medPolyRange,float highPolyRange,
					BOOL param_5)
{
	LiveObject *pLVar1;
	LiveObjectInfo liveInfo;
	
	liveInfo.point_8.x = medPolyRange;
	liveInfo.point_8.y = highPolyRange;
	liveInfo.liveObj = liveObj;
	liveInfo.vector_10.x = 0.0;
	liveInfo.intbool_4 = param_5;
	liveInfo.vector_10.y = 0.0;
	liveInfo.vector_10.z = 0.0;
	if (((liveObj->objType != OBJECT_MINIFIGURE) && (pLVar1 = liveObj->drivenObject, pLVar1 != NULL))
		 && (pLVar1->objType == OBJECT_MINIFIGURE)) {
		liveInfo.liveObj = pLVar1;
	}
	if (param_5 != 0) {
		res::Container_GetPosition(resData,NULL,&liveInfo.vector_10);
	}
	Search_LiveObjects_SkipIgnoreMes(LiveObject_FP_Callback_SwapPolyMeshParts,(undefined4 *)&liveInfo)
	;
	return;
}



BOOL __cdecl
lego::game::LiveObject_FP_Callback_SwapPolyMeshParts(LiveObject *liveObj,LiveObjectInfo *liveInfo)
{
	float fVar1;
	PolyMode PVar2;
	ObjectType OVar3;
	float fVar4;
	float fVar5;
	Container *cont;
	Vector3F vector;
	
	if (liveObj != liveInfo->liveObj) {
		PVar2 = liveObj->polyMode_34c;
		if (liveInfo->intbool_4 == 0) {
			if (PVar2 == POLY_MEDIUM) {
				OVar3 = liveObj->objType;
				if (OVar3 == OBJECT_MINIFIGURE) {
					res::Creature_SwapPolyMedium(liveObj->miniFigure,FALSE);
				}
				else {
					if (OVar3 == OBJECT_ROCKMONSTER) {
						res::Creature_SwapPolyMedium(liveObj->rockMonster,FALSE);
					}
					else {
						if (OVar3 == OBJECT_VEHICLE) {
							res::Vehicle_SwapPolyMedium(liveObj->vehicle,FALSE);
						}
					}
				}
			}
			else {
				if (PVar2 == POLY_HIGH) {
					OVar3 = liveObj->objType;
					if (OVar3 == OBJECT_MINIFIGURE) {
						res::Creature_SwapPolyHigh(liveObj->miniFigure,FALSE);
					}
					else {
						if (OVar3 == OBJECT_ROCKMONSTER) {
							res::Creature_SwapPolyHigh(liveObj->rockMonster,FALSE);
						}
						else {
							if (OVar3 == OBJECT_VEHICLE) {
								res::Vehicle_SwapPolyHigh(liveObj->vehicle,FALSE);
							}
						}
					}
				}
			}
			liveObj->polyMode_34c = POLY_LOW;
		}
		else {
			if (PVar2 == POLY_LOW) {
				cont = LiveObject_GetContainer(liveObj);
				res::Container_GetPosition(cont,NULL,&vector);
				fVar5 = (liveInfo->vector_10).x - vector.x;
				fVar1 = (liveInfo->vector_10).y - vector.y;
				fVar4 = (liveInfo->vector_10).z - vector.z;
				fVar4 = SQRT(fVar4 * fVar4 + fVar1 * fVar1 + fVar5 * fVar5);
				fVar1 = (liveInfo->point_8).y;
				if ((ushort)((ushort)(fVar4 < fVar1) << 8 | (ushort)(fVar4 == fVar1) << 0xe) != 0) {
					OVar3 = liveObj->objType;
					if (OVar3 == OBJECT_MINIFIGURE) {
						res::Creature_SwapPolyHigh(liveObj->miniFigure,TRUE);
						liveObj->polyMode_34c = POLY_HIGH;
						return 0;
					}
					if (OVar3 != OBJECT_ROCKMONSTER) {
						if (OVar3 == OBJECT_VEHICLE) {
							res::Vehicle_SwapPolyHigh(liveObj->vehicle,1);
						}
						liveObj->polyMode_34c = POLY_HIGH;
						return 0;
					}
					res::Creature_SwapPolyHigh(liveObj->rockMonster,TRUE);
					liveObj->polyMode_34c = POLY_HIGH;
					return 0;
				}
				fVar1 = (liveInfo->point_8).x;
				if ((ushort)((ushort)(fVar4 < fVar1) << 8 | (ushort)(fVar4 == fVar1) << 0xe) != 0) {
					OVar3 = liveObj->objType;
					if (OVar3 == OBJECT_MINIFIGURE) {
						res::Creature_SwapPolyMedium(liveObj->miniFigure,TRUE);
						liveObj->polyMode_34c = POLY_MEDIUM;
						return 0;
					}
					if (OVar3 != OBJECT_ROCKMONSTER) {
						if (OVar3 == OBJECT_VEHICLE) {
							res::Vehicle_SwapPolyMedium(liveObj->vehicle,1);
						}
						liveObj->polyMode_34c = POLY_MEDIUM;
						return 0;
					}
					res::Creature_SwapPolyMedium(liveObj->rockMonster,TRUE);
					liveObj->polyMode_34c = POLY_MEDIUM;
					return 0;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(LiveObject *liveObj)
{
	if ((liveObj->flags1 &
			(LIVEOBJ1_LIFTING|LIVEOBJ1_TURNING|LIVEOBJ1_UNK_8|LIVEOBJ1_UNK_10|LIVEOBJ1_REINFORCING|
			 LIVEOBJ1_TURNRIGHT|LIVEOBJ1_UNK_100|LIVEOBJ1_UNK_200|LIVEOBJ1_UNK_1000|LIVEOBJ1_UNK_2000|
			 LIVEOBJ1_CLEARING|LIVEOBJ1_PLACING|LIVEOBJ1_UNK_100000|LIVEOBJ1_UNK_200000|
			 LIVEOBJ1_UNK_400000|LIVEOBJ1_UNK_10000000)) != LIVEOBJ1_NONE) {
		return TRUE;
	}
	return (uint)((liveObj->flags2 &
								(LIVEOBJ2_UNK_1|LIVEOBJ2_UNK_2|LIVEOBJ2_UNK_200|LIVEOBJ2_UNK_400000|
								 LIVEOBJ2_UNK_800000|LIVEOBJ2_UNK_1000000)) != LIVEOBJ2_NONE);
}



void __cdecl lego::game::LiveObject_FUN_0043bde0(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	uint uVar2;
	uint uVar3;
	
	if (liveObj->objType == OBJECT_BUILDING) {
		OVar1 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar1 & STATS1_PROCESSORE) == STATS1_NONE) {
			uVar3 = liveObj->numCarriedObjects;
		}
		else {
			uVar3 = liveObj->field_328;
			uVar2 = LiveObject_GetMaxCarry(liveObj);
			if (uVar2 <= uVar3) {
				uVar3 = LiveObject_GetMaxCarry(liveObj);
			}
		}
		if (((liveObj->numCarriedObjects < uVar3) ||
				((liveObj->flags1 & LIVEOBJ1_UNK_2000) != LIVEOBJ1_NONE)) ||
			 ((liveObj->flags3 & LIVEOBJ3_UNK_1000000) != LIVEOBJ3_NONE)) {
			liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_1000000;
		}
		else {
			OVar1 = LiveObject_GetStatsFlags1(liveObj);
			if (((OVar1 & STATS1_PROCESSCRYSTAL) != STATS1_NONE) ||
				 (OVar1 = LiveObject_GetStatsFlags1(liveObj), (OVar1 & STATS1_PROCESSORE) != STATS1_NONE)) {
				LiveObject_TryDeposit_FUN_0043a5c0(liveObj,NULL);
				return;
			}
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_0043be80(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	
	if (liveObj->objType == OBJECT_ROCKMONSTER) {
		pLVar1 = liveObj->carriedObjects[0];
		if ((pLVar1 != NULL) && (pLVar1->objType == OBJECT_POWERCRYSTAL)) {
			liveObj->carriedObjects[0] = NULL;
			liveObj->numCarriedObjects = 0;
			pLVar1->carryingThisObject = NULL;
			liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CARRYING;
			pLVar1->health = -1.0;
		}
		if (liveObj->tableptr_348 != NULL) {
			Level_AddToField9c(*liveObj->tableptr_348);
		}
		liveObj->health = -1.0;
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
	}
	return;
}



void __cdecl lego::game::LiveObject_TeleportUp(LiveObject *liveObj)
{
	LiveFlags1 *pLVar1;
	LiveObject *pLVar2;
	LiveFlags3 LVar3;
	ObjectType OVar4;
	char *actname;
	ObjectStatsFlags1 OVar5;
	ObjectStatsFlags2 OVar6;
	Container *pCVar7;
	ObjectStatsFlags3 OVar8;
	int iVar9;
	float10 fVar10;
	InfoType infoType;
	float x;
	float y;
	float z;
	int local_10;
	int local_c;
	Point2I local_8;
	
	if (liveObj->objType != OBJECT_BUILDING) {
		if ((liveObj->flags2 & LIVEOBJ2_UNK_8000000) != LIVEOBJ2_NONE) {
			return;
		}
		if ((liveObj->flags1 & LIVEOBJ1_UNK_200000) != LIVEOBJ1_NONE) {
			return;
		}
	}
	if ((ushort)((ushort)(liveObj->health < 0.0) << 8 | (ushort)(liveObj->health == 0.0) << 0xe) == 0)
	{
		return;
	}
	OVar5 = LiveObject_GetStatsFlags1(liveObj);
	if ((((OVar5 & (STATS1_SMALLTELEPORTER|STATS1_BIGTELEPORTER|STATS1_WATERTELEPORTER|
								 STATS1_MANTELEPORTER)) != STATS1_NONE) &&
			(pLVar2 = liveObj->object_3cc, pLVar2 != NULL)) &&
		 ((pLVar2->flags1 & LIVEOBJ1_UNK_200000) != LIVEOBJ1_NONE)) {
		pLVar2->health = -1.0;
		pLVar1 = &liveObj->object_3cc->flags1;
		*pLVar1 = *pLVar1 & ~LIVEOBJ1_UNK_200000;
		LiveObject_FUN_00438720(liveObj);
		LiveObject_SetActivityUnk(liveObj->object_3cc,ACTIVITY_STAND,TRUE);
		LiveObject_Container_ActivityUpdate_Check(liveObj->object_3cc);
	}
	LVar3 = liveObj->flags3;
	if ((LVar3 & LIVEOBJ3_UNK_800000) != LIVEOBJ3_NONE) {
		if (liveObj->drivenObject != NULL) {
			front::Interface_ChangeMenu_IfPrimarySelectedVehicle_IsLiveObject(liveObj);
			liveObj->drivenObject->flags2 = liveObj->drivenObject->flags2 & ~LIVEOBJ2_DRIVING;
			liveObj->drivenObject->drivenObject = NULL;
			liveObj->drivenObject = NULL;
		}
		if ((liveObj->objType == OBJECT_MINIFIGURE) &&
			 ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_8) != 0)) {
			ObjectRecall_LiveObject_UnkRecallMiniFigureName(liveObj);
		}
		if (liveObj->objType == OBJECT_VEHICLE) {
			res::Vehicle_ChangeUpgradeParts(liveObj->vehicle,0);
		}
		LiveObject_FUN_0044b0a0(liveObj);
		if (liveObj->objType == OBJECT_BOULDER) {
			LiveObject_DestroyBoulder_AndCreateExplode(liveObj);
			return;
		}
		if (liveObj->objType == OBJECT_BUILDING) {
			LiveObject_BuildingDestroy(liveObj);
			return;
		}
		pool::ReservedPool_LiveObject___Release(liveObj);
		return;
	}
	OVar4 = liveObj->objType;
	if (OVar4 == OBJECT_ROCKMONSTER) {
		OVar6 = LiveObject_GetStatsFlags2(liveObj);
		if ((OVar6 & STATS2_SPLITONZEROHEALTH) == STATS2_NONE) {
			OVar6 = LiveObject_GetStatsFlags2(liveObj);
			if ((OVar6 & STATS2_USEHOLES) == STATS2_NONE) {
				return;
			}
			LiveObject_FUN_00441df0(liveObj,FALSE,TRUE);
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_20000;
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_ENTER,FALSE);
			LiveObject_Container_ActivityUpdate_Check(liveObj);
			return;
		}
		if ((liveObj->flags1 & LIVEOBJ1_UNK_100000) != LIVEOBJ1_NONE) {
			return;
		}
		LiveObject_UnkActivityCrumble_FUN_004424d0(liveObj);
		return;
	}
	if (((OVar4 != OBJECT_MINIFIGURE) && (OVar4 != OBJECT_VEHICLE)) && (OVar4 != OBJECT_ELECTRICFENCE)
		 ) {
		if (OVar4 != OBJECT_BUILDING) {
LAB_0043c168:
			if (OVar4 != OBJECT_POWERCRYSTAL) {
				return;
			}
			liveObj->flags3 = LVar3 | LIVEOBJ3_UNK_800000;
			return;
		}
		if (((*(byte *)&liveObj->teleporter_field_390 & 4) == 0) &&
			 ((*(byte *)&liveObj->flags4 & 8) == 0)) {
			if (false) goto LAB_0043c168;
			if ((liveObj->flags2 & LIVEOBJ2_UNK_100000) != LIVEOBJ2_NONE) {
				return;
			}
			liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_100000;
			LiveObject_FUN_00409c80(liveObj);
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_EXPLODE,0);
			LiveObject_Container_ActivityUpdate_Check(liveObj);
			ai::AITask_LiveObject_FUN_00403490(liveObj);
			goto LAB_0043c4a7;
		}
	}
	if ((LVar3 & LIVEOBJ3_UNK_40000) == LIVEOBJ3_NONE) {
		return;
	}
	if ((liveObj->flags1 & LIVEOBJ1_UNK_400000) != LIVEOBJ1_NONE) {
		return;
	}
	actname = liveObj->aitaskName1;
	pCVar7 = LiveObject_GetContainer(liveObj);
	if ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_8) != 0) {
		LiveObject_FUN_0044b0a0(liveObj);
	}
	if (liveObj->objType == OBJECT_BUILDING) {
		LiveObject_FUN_00409c80(liveObj);
	}
	if ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_80) != 0) {
		pLVar2 = liveObj->object_2fc;
		if (pLVar2 != NULL) {
			pLVar2->flags4 = pLVar2->flags4 & ~LIVEOBJ4_UNK_80;
		}
		liveObj->object_2fc = NULL;
	}
	if (liveObj->drivenObject != NULL) {
		LiveObject_GetBlockPos(liveObj,&local_10,&local_c);
		OVar8 = LiveObject_GetStatsFlags3(liveObj);
		if (((((OVar8 & STATS3_CARRYVEHICLES) != STATS3_NONE) &&
				 ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
				(liveObj->carriedObjects[0] != NULL)) &&
			 (iVar9 = LiveObject_FUN_00431cd0
													(liveObj->carriedObjects[0],local_10,local_c,local_10,local_c,1),
			 iVar9 == 0)) {
			liveObj->carriedObjects[0]->health = -1.0;
		}
		OVar5 = LiveObject_GetStatsFlags1(liveObj);
		if (((OVar5 & STATS1_CANBEDRIVEN) == STATS1_NONE) ||
			 (iVar9 = LiveObject_FUN_00431cd0(liveObj->drivenObject,local_10,local_c,local_10,local_c,1),
			 iVar9 != 0)) {
			front::Interface_ChangeMenu_IfPrimarySelectedVehicle_IsLiveObject(liveObj);
			liveObj->drivenObject->flags2 = liveObj->drivenObject->flags2 & ~LIVEOBJ2_DRIVING;
			if (liveObj->drivenObject->objType == OBJECT_MINIFIGURE) {
				res::Creature_SetActivity_AndRemoveCarryCameraFrames
									(liveObj->drivenObject->miniFigure,globs::liveGlobs.Activities_TABLE[0],0.0);
			}
			liveObj->drivenObject->drivenObject = NULL;
			liveObj->drivenObject = NULL;
		}
		else {
			liveObj->drivenObject->health = -1.0;
		}
	}
	if (liveObj->objType == OBJECT_ELECTRICFENCE) {
		ElectricFence_LiveObject_Destroy(liveObj);
	}
	LiveObject_GetBlockPos(liveObj,(int *)&local_8,&local_8.y);
	OVar4 = liveObj->objType;
	if (((OVar4 == OBJECT_MINIFIGURE) || (OVar4 == OBJECT_VEHICLE)) || (OVar4 == OBJECT_BUILDING)) {
		front::Info_FUN_00419ab0(INFO_GENERICDEATH,NULL,NULL,&local_8);
	}
	OVar4 = liveObj->objType;
	if (OVar4 == OBJECT_MINIFIGURE) {
		infoType = INFO_LEGOMANDEATH;
LAB_0043c382:
		front::Info_FUN_00419ab0(infoType,NULL,NULL,&local_8);
	}
	else {
		if (OVar4 == OBJECT_VEHICLE) {
			infoType = INFO_VEHICLEDEATH;
			goto LAB_0043c382;
		}
		if (OVar4 == OBJECT_BUILDING) {
			infoType = INFO_BUILDINGDEATH;
			goto LAB_0043c382;
		}
	}
	if ((*(byte *)&liveObj->flags2 & 2) == 0) {
		LiveObject_FUN_00441df0(liveObj,FALSE,TRUE);
		res::Container_SetActivity(pCVar7,actname);
		liveObj->aitaskName2 = liveObj->aitaskName1;
	}
	else {
		LiveObject_FUN_00441df0(liveObj,TRUE,TRUE);
	}
	liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_400000;
	pCVar7 = res::Container_Clone(globs::gameGlobs.RES_MiniTeleportUp);
	liveObj->resData_2e4 = pCVar7;
	res::Container_SetAnimationTime(pCVar7,0.0);
	res::Container_Hide(liveObj->resData_2e4,FALSE);
	z = 0.0;
	y = 0.0;
	x = 0.0;
	pCVar7 = LiveObject_GetContainer(liveObj);
	res::Container_SetPosition(liveObj->resData_2e4,pCVar7,x,y,z);
	res::Container_SetOrientation(liveObj->resData_2e4,NULL,0.0,1.0,0.0,0.0,0.0,-1.0);
	if (liveObj->objType == OBJECT_BUILDING) {
		fVar10 = LiveObject_GetCollRadius(liveObj);
		if ((ushort)((ushort)(fVar10 < (float10)0.0) << 8 | (ushort)(fVar10 == (float10)0.0) << 0xe) !=
				0) {
			fVar10 = (float10)4.0;
		}
		if ((ushort)((ushort)(fVar10 < (float10)0.0) << 8 | (ushort)(fVar10 == (float10)0.0) << 0xe) ==
				0) {
			res::Container_AddScale
								(liveObj->resData_2e4,D3DRMCOMBINE_BEFORE,(float)(fVar10 * (float10)0.25),1.0,
								 (float)(fVar10 * (float10)0.25));
		}
	}
LAB_0043c4a7:
	Message_PTL_Deselect_LiveObject(liveObj);
	Message_LiveObject_FUN_00452770(liveObj);
	return;
}



BOOL __cdecl
lego::game::Object_DoOxygenCheck_FUN_0043c4c0
					(ObjectType objType1,int objIndex1,ObjectType objType2,int objIndex2)
{
	int objIndex;
	float10 fVar1;
	float10 fVar2;
	
	objIndex = objIndex1;
	fVar1 = Object_GetOxygenCoef(objType1,objIndex1);
	if (fVar1 != (float10)0.0) {
		objIndex1 = 0;
		Search_LiveObjects_SkipIgnoreMes(LiveObject_OxygenCallback_FUN_0043c540,&objIndex1);
		fVar1 = Object_GetOxygenCoef(objType2,objIndex2);
		fVar2 = Object_GetOxygenCoef(objType1,objIndex);
		fVar1 = fVar2 + (float10)(float)fVar1 + (float10)(float)objIndex1;
		if ((ushort)((ushort)(fVar1 < (float10)0.0) << 8 | (ushort)(fVar1 == (float10)0.0) << 0xe) != 0)
		{
			return 0;
		}
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_OxygenCallback_FUN_0043c540(LiveObject *liveObj,float *param_2)
{
	BOOL BVar1;
	float10 fVar2;
	
	if ((liveObj->objType == OBJECT_BUILDING) &&
		 (BVar1 = LiveObject_CheckCondition_FUN_00438870(liveObj,0), BVar1 == 0)) {
		return 0;
	}
	fVar2 = LiveObject_GetOxygenCoef(liveObj);
	*param_2 = (float)(fVar2 + (float10)*param_2);
	return 0;
}



void __cdecl FUN_0043c570(float elapsedGame,BOOL isRadarMapView)
{
	lego::globs::liveGlobs.float_67c = elapsedGame + lego::globs::liveGlobs.float_67c;
	if ((ushort)((ushort)(lego::globs::liveGlobs.float_67c < 25.0) << 8 |
							(ushort)(lego::globs::liveGlobs.float_67c == 25.0) << 0xe) == 0) {
		lego::globs::liveGlobs.float_67c = 0.0;
	}
	lego::game::Search_LiveObjects_SkipIgnoreMes
						(lego::game::LiveObject_Callback_FUN_0043c5b0,&isRadarMapView);
	return;
}



BOOL __cdecl lego::game::LiveObject_Callback_FUN_0043c5b0(LiveObject *liveObj,BOOL *pIsRadarMapView)
{
	int iVar1;
	BOOL BVar2;
	SurfaceMap *surfMap;
	LevelStruct_3c *pLVar3;
	float10 fVar4;
	Point2F *pPVar5;
	float fVar6;
	float fVar7;
	int local_10;
	int local_c;
	Point2F local_8;
	
	fVar6 = globs::liveGlobs.float_67c * 0.04;
	if (((*(byte *)&liveObj->flags5_3f0 & 0x20) != 0) &&
		 (iVar1 = LiveObject_GetSurveyRadius(liveObj), iVar1 != 0)) {
		local_10 = iVar1;
		if ((liveObj->objType == OBJECT_BUILDING) &&
			 (BVar2 = LiveObject_CheckCondition_FUN_00438870(liveObj,0), BVar2 == 0)) {
			return 0;
		}
		if (globs::liveGlobs.float_67c == 0.0) {
			LiveObject_GetBlockPos(liveObj,&local_10,&local_c);
			FUN_00434f40(&local_10,iVar1);
			return 0;
		}
		if (*pIsRadarMapView != 0) {
			LiveObject_GetPosition(liveObj,(float *)&local_8,&local_8.y);
			fVar7 = 1.0 - fVar6;
			surfMap = GetSurfaceMap();
			fVar4 = Map3D_GetBlockSize(surfMap);
			pPVar5 = &local_8;
			fVar6 = (float)(fVar4 * (float10)fVar6 * (float10)local_10);
			pLVar3 = (LevelStruct_3c *)FUN_0042b430();
			LevelStruct3C_FUN_0045ddc0(pLVar3,pPVar5,fVar6,fVar7);
		}
	}
	return 0;
}



undefined4 __cdecl FUN_0043c6a0(int *param_1)
{
	int *piVar1;
	BOOL BVar2;
	
	if ((((param_1 != NULL) && (*param_1 == 2)) && (piVar1 = (int *)param_1[0xbc], piVar1 != NULL)) &&
		 (*piVar1 == 0x1a)) {
		BVar2 = lego::game::LiveObject_FUN_00472340((LiveObject *)param_1,(undefined4 *)piVar1[4]);
		if (BVar2 != 0) {
			BVar2 = lego::game::LiveObject_DoCallbacksSearch_FUN_00471b90
												((LiveObject *)param_1,*(LiveObject **)(param_1[0xbc] + 0x10));
			if (BVar2 == 0) {
				return 1;
			}
		}
	}
	return 0;
}



uint __cdecl lego::game::LiveObject_GetEquippedBeam(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_LASER);
	if (BVar1 != 0) {
		return 1;
	}
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_PUSHERGUN);
	if (BVar1 != 0) {
		return 2;
	}
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_FREEZERGUN);
	return -(uint)(BVar1 != 0) & 3;
}



undefined4 __cdecl FUN_0043c750(undefined4 param_1,int param_2,int param_3)
{
	BOOL BVar1;
	
	BVar1 = lego::game::LiveObject_CheckCondition_FUN_00438870((LiveObject *)param_2,1);
	if ((BVar1 != 0) && (param_3 != 0)) {
		return 1;
	}
	return 0;
}



void __cdecl FUN_0043c780(uint *param_1)
{
	uint uVar1;
	int iVar2;
	
	if (param_1[0xbf] != 0) {
		uVar1 = lego::game::LiveObject_GetEquippedBeam((LiveObject *)param_1);
		iVar2 = FUN_0043c750(param_1,param_1[0xbf],uVar1);
		if (iVar2 != 0) {
			lego::game::LiveObject_FUN_00442190((LiveObject *)param_1,(LiveObject *)param_1[0xbf],uVar1);
		}
	}
	param_1[0xf9] = param_1[0xf9] & 0xfbffffff;
	lego::ai::AITask_LiveObject_SetAITaskUnk((LiveObject *)param_1,AITASK_ATTACKROCKMONSTER,NULL,1);
	return;
}



void __cdecl FUN_0043c7f0(uint *param_1)
{
	if ((((param_1 != NULL) && (*param_1 == 2)) && ((int *)param_1[0xbc] != NULL)) &&
		 (*(int *)param_1[0xbc] == 0x1a)) {
		param_1[0xf9] = param_1[0xf9] | 0x4000000;
		FUN_0043c780(param_1);
	}
	return;
}



void __cdecl lego::game::LiveObject_UpdatePowerConsumption(LiveObject *liveObj)
{
	int iVar1;
	ObjectStatsFlags2 OVar2;
	BOOL BVar3;
	Point2I blockPos;
	
	if ((liveObj->objType == OBJECT_BUILDING) &&
		 ((liveObj->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE)) {
		iVar1 = LiveObject_GetCrystalDrain(liveObj);
		LiveObject_GetBlockPos(liveObj,(int *)&blockPos,&blockPos.y);
		OVar2 = LiveObject_GetStatsFlags2(liveObj);
		if ((OVar2 & STATS2_GENERATEPOWER) == STATS2_NONE) {
			OVar2 = LiveObject_GetStatsFlags2(liveObj);
			if ((OVar2 & STATS2_SELFPOWERED) == STATS2_NONE) {
				BVar3 = Construction_Level_Blocks_UnkPowerCrystalProc_FUN_00409380(&blockPos,iVar1);
				if (BVar3 == 0) {
					liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_HASPOWER;
					front::Bubble_LiveObject_FUN_00407340(liveObj);
					return;
				}
			}
		}
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_HASPOWER;
		OVar2 = LiveObject_GetStatsFlags2(liveObj);
		if ((OVar2 & STATS2_GENERATEPOWER) != STATS2_NONE) {
			BVar3 = LiveObject_CheckCondition_FUN_00438870(liveObj,FALSE);
			if (BVar3 != 0) {
				iVar1 = Level_GetCrystalCount(TRUE);
				if (iVar1 != 0) {
					Construction_Level_Block_FUN_004092e0(&blockPos);
				}
			}
		}
	}
	return;
}



BOOL __cdecl FUN_0043c910(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	int iVar2;
	uint uVar3;
	
	OVar1 = lego::game::LiveObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_CANSTEAL) != STATS1_NONE) {
		iVar2 = lego::game::LiveObject_GetCapacity(liveObj);
		if (((iVar2 != 0) && (liveObj->tableptr_348 != NULL)) &&
			 (uVar3 = lego::game::LiveObject_GetCapacity(liveObj), uVar3 <= (uint)*liveObj->tableptr_348))
		{
			return 0;
		}
		if ((liveObj->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE) {
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_0043c970(LiveObject *liveObj,float elapsed)
{
	float fVar1;
	float fVar2;
	ObjectType OVar3;
	float fVar4;
	float10 fVar5;
	float10 fVar6;
	
	fVar4 = elapsed + liveObj->elapsedTime2;
	fVar1 = liveObj->elapsedTime2;
	fVar2 = liveObj->elapsedTime1;
	liveObj->elapsedTime2 = fVar4;
	OVar3 = liveObj->objType;
	liveObj->elapsedTime1 = elapsed + liveObj->elapsedTime1;
	liveObj->activityElapsedTime = elapsed + liveObj->activityElapsedTime;
	if (OVar3 == OBJECT_MINIFIGURE) {
		fVar5 = Level_GetObjectUpgradeTime(OBJECT_MINIFIGURE);
		if (fVar5 != (float10)0.0) {
			fVar5 = Level_GetObjectUpgradeTime(liveObj->objType);
			if ((ushort)((ushort)(fVar5 < (float10)liveObj->elapsedTime2) << 8 |
									(ushort)(fVar5 == (float10)liveObj->elapsedTime2) << 0xe) != 0) {
				fVar6 = Level_GetObjectUpgradeTime(liveObj->objType);
				fVar5 = (float10)fVar1;
				if ((ushort)((ushort)(fVar6 < fVar5) << 8 | (ushort)(fVar6 == fVar5) << 0xe) == 0) {
					front::Info_FUN_00419ab0(INFO_CANUPGRADEMINIFIGURE,NULL,liveObj,NULL);
				}
			}
		}
		fVar5 = Level_GetTrainTime();
		if (fVar5 != (float10)0.0) {
			fVar5 = Level_GetTrainTime();
			if ((ushort)((ushort)(fVar5 < (float10)liveObj->elapsedTime1) << 8 |
									(ushort)(fVar5 == (float10)liveObj->elapsedTime1) << 0xe) != 0) {
				fVar5 = Level_GetTrainTime();
				if ((ushort)((ushort)(fVar5 < (float10)fVar2) << 8 |
										(ushort)(fVar5 == (float10)fVar2) << 0xe) == 0) {
					front::Info_FUN_00419ab0(INFO_CANTRAINMINIFIGURE,NULL,liveObj,NULL);
					return;
				}
			}
		}
	}
	else {
		if (((((OVar3 == OBJECT_POWERCRYSTAL) || (OVar3 == OBJECT_ORE)) || (OVar3 == OBJECT_BARRIER)) ||
				((OVar3 == OBJECT_ELECTRICFENCE &&
				 ((liveObj->flags2 & LIVEOBJ2_UNK_2000000) == LIVEOBJ2_NONE)))) &&
			 ((750.0 <= fVar4 && (fVar1 < 750.0)))) {
			liveObj->elapsedTime2 = 0.0;
			ai::AITask_LiveObject_FUN_004025f0(liveObj);
		}
	}
	return;
}


/*
Unable to decompile 'Game_LiveObjectLargeCallback'
Cause: Exception while decompiling 0043cad0: process: timeout

*/


BOOL __cdecl lego::game::Game_LiveObjectLargeCallback(LiveObject *in_liveObj,float *lpElapsed)
{
	LiveFlags3 *pLVar1;
	LiveFlags4 *pLVar2;
	float elapsed;
	void *pvVar3;
	LiveFlags2 LVar4;
	ObjectType OVar5;
	ushort uVar6;
	ushort uVar7;
	bool bVar8;
	LiveObject *liveObj;
	short sVar9;
	Container *pCVar10;
	SFXType SVar11;
	BOOL BVar12;
	LiveFlags4 LVar13;
	LevelData *pLVar14;
	ObjectStatsFlags1 OVar15;
	LiveFlags3 LVar16;
	Container *pCVar17;
	SurfaceType SVar18;
	int iVar19;
	SurfaceMap *pSVar20;
	ObjectStatsFlags2 OVar21;
	uint uVar22;
	BlockStruct_d4 *pBVar23;
	LiveFlags1 LVar24;
	uint uVar25;
	float10 fVar26;
	longlong lVar27;
	float fVar28;
	float fVar29;
	LiveObject *pLVar30;
	BOOL BVar31;
	float fVar32;
	ActivityType AVar33;
	Vector3F *pVVar34;
	undefined4 uVar35;
	float fVar36;
	float upz;
	float *out_by;
	float local_34;
	Vector3F local_30;
	float local_24;
	Vector3F local_20;
	int local_14;
	float local_10;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	elapsed = *lpElapsed;
	bVar8 = true;
	PTRLiveObject_00557090 = in_liveObj;
	LiveObject_FUN_0043c970(in_liveObj,elapsed);
	if ((liveObj->flags4 & LIVEOBJ4_UNK_200000) != LIVEOBJ4_NONE) {
		liveObj->aitaskName1 = NULL;
		LiveObject_Container_ActivityUpdate_Check(liveObj);
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_200000;
	}
	if ((liveObj->flags2 & LIVEOBJ2_UNK_8000000) != LIVEOBJ2_NONE) {
		if ((ushort)((ushort)(liveObj->float_368 < 0.0) << 8 |
								(ushort)(liveObj->float_368 == 0.0) << 0xe) != 0) {
			LiveObject_FUN_0044c3d0(liveObj);
		}
		liveObj->float_368 = liveObj->float_368 - elapsed;
		return 0;
	}
	if ((liveObj->flags4 & LIVEOBJ4_UNK_40000) != LIVEOBJ4_NONE) {
		pCVar10 = LiveObject_GetContainer(liveObj);
		if ((pCVar10 != NULL) && (SVar11 = LiveObject_GetEngineSound(liveObj), SVar11 != SFX_NULL)) {
			res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(pCVar10,SVar11,1,1,NULL);
			liveObj->soundHandle_354 = SVar11;
			liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_80000;
		}
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_40000;
	}
	if ((((byte)globs::gameGlobs.flags2 & GAME2_CALLTOARMS) == 0) ||
		 (BVar12 = LiveObject_MiniFigureHasBeamEquipped(liveObj), BVar12 == 0)) {
		front::Bubble_LiveObject_MiniFigure_FUN_00407440(liveObj,0);
		LVar13 = liveObj->flags4 & ~LIVEOBJ4_CALLTOARMS_20;
	}
	else {
										/* Update MiniFigure with Call-to-arms behavior? */
		front::Bubble_LiveObject_MiniFIgure_FUN_004073e0(liveObj);
		LVar13 = liveObj->flags4 | LIVEOBJ4_CALLTOARMS_20;
	}
	liveObj->flags4 = LVar13;
	if ((((liveObj->objType == OBJECT_VEHICLE) &&
			 ((liveObj->flags4 & LIVEOBJ4_UNK_40) != LIVEOBJ4_NONE)) && (liveObj->object_2fc == NULL)) &&
		 (liveObj->drivenObject == NULL)) {
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_40;
		LiveObject_Vehicle_FUN_0043ac20(liveObj);
	}
	if ((liveObj->objType == OBJECT_MINIFIGURE) || (liveObj->objType == OBJECT_VEHICLE)) {
		pLVar14 = GetLevel();
		LiveObject_GetBlockPos(liveObj,(int *)&local_20,(int *)&local_20.y);
		if ((*(byte *)&pLVar14->blocks[(pLVar14->dimensions).width * (int)local_20.y + (int)local_20.x].
									 flags2 & BLOCK2_EMERGE_TRIGGER) != 0) {
			Level_UnkEmerge_FUN_0042c260(pLVar14,(Point2I *)&local_20,NULL);
		}
	}
	LiveObject_FUN_0043bde0(liveObj);
	if (((liveObj->objType == OBJECT_MINIFIGURE) &&
			((*(byte *)&liveObj->flags2 & LIVEOBJ2_DRIVING) != 0)) &&
		 ((pLVar30 = liveObj->drivenObject, pLVar30 != NULL && (pLVar30->objType == OBJECT_VEHICLE)))) {
		fVar26 = res::Vehicle_GetAnimFloat10(pLVar30->vehicle);
		res::Creature_DoCallbacks(liveObj->miniFigure,(float)fVar26);
	}
	else {
		fVar26 = LiveObject_FUN_00447df0(liveObj,elapsed);
		local_10 = (float)fVar26;
	}
	OVar15 = LiveObject_GetStatsFlags1(liveObj);
	if ((OVar15 & (STATS1_SMALLTELEPORTER|STATS1_BIGTELEPORTER|STATS1_WATERTELEPORTER|
								STATS1_MANTELEPORTER)) != STATS1_NONE) {
		LiveObject_FUN_0043f450(liveObj);
	}
	if ((liveObj->objType != OBJECT_BUILDING) ||
		 (BVar12 = LiveObject_CheckCondition_FUN_00438870(liveObj,0), BVar12 != 0)) {
		LiveObject_ConsumeOxygen(liveObj,elapsed);
	}
	if (((byte)globs::liveGlobs.flags & 4) == 0) {
		liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_40000000;
	}
	else {
		LiveObject_UpdatePowerConsumption(liveObj);
	}
	LVar24 = liveObj->flags1;
	if ((LVar24 & LIVEOBJ1_UNK_400000) != LIVEOBJ1_NONE) {
		if (liveObj->resData_2e4 == NULL) {
			liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
			return 0;
		}
		pCVar10 = LiveObject_GetContainer(liveObj);
		res::Container_AddTranslation(pCVar10,D3DRMCOMBINE_AFTER,0.0,0.0,-elapsed);
		fVar26 = res::Container_MoveAnimation(liveObj->resData_2e4,elapsed);
		if ((ushort)((ushort)(fVar26 < (float10)0.0) << 8 | (ushort)(fVar26 == (float10)0.0) << 0xe) !=
				0) {
			return 0;
		}
		liveObj->health = -1.0;
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_400000;
		res::Container_Remove(liveObj->resData_2e4);
		return 0;
	}
	if ((LVar24 & LIVEOBJ1_UNK_8) == LIVEOBJ1_NONE) goto LAB_0043d12f;
	if ((LVar24 & LIVEOBJ1_UNK_10) != LIVEOBJ1_NONE) {
		pCVar10 = LiveObject_GetContainer(liveObj);
		pVVar34 = NULL;
		BVar31 = 1;
		BVar12 = 1;
		SVar11 = LiveObject_GetDrillSoundType(liveObj,0);
		res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(pCVar10,SVar11,BVar12,BVar31,pVVar34);
		liveObj->soundHandle_350 = SVar11;
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_100000;
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_10;
	}
	pvVar3 = liveObj->routeptr_24;
	if (pvVar3 == NULL) {
LAB_0043d0aa:
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_8;
		liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_2000000;
		pCVar10 = LiveObject_GetContainer(liveObj);
		iVar19 = liveObj->soundHandle_350;
LAB_0043d0dd:
		snd::SFX_Sample_Sound3D_StopSound(iVar19);
		pVVar34 = NULL;
		BVar31 = 1;
		BVar12 = 0;
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_100000;
		SVar11 = LiveObject_GetDrillSoundType(liveObj,1);
		res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(pCVar10,SVar11,BVar12,BVar31,pVVar34);
		util::logf_removed(NULL,0,0);
		LVar16 = liveObj->flags3 & ~LIVEOBJ3_UNK_4000;
LAB_0043d129:
		liveObj->flags3 = LVar16;
	}
	else {
		fVar36 = *(float *)((int)pvVar3 + liveObj->routingBlocksCurrent * 0x14);
		fVar28 = *(float *)((int)pvVar3 + liveObj->routingBlocksCurrent * 0x14 + 4);
		BVar12 = 1;
		LVar16 = liveObj->flags3 & LIVEOBJ3_UNK_2000000;
		lVar27 = __ftol((float10)(liveObj->point_2f4).y);
		uVar22 = (uint)lVar27;
		lVar27 = __ftol((float10)(liveObj->point_2f4).x);
		BVar12 = LiveObject_Check_FUN_004326a0(liveObj,(uint)lVar27,uVar22,LVar16,BVar12);
		if (BVar12 == 0) goto LAB_0043d0aa;
		BVar12 = LiveObject_GetDrillNullPosition(liveObj,(float *)&local_30,&local_34);
		if (BVar12 == 0) goto LAB_0043d12f;
		if (liveObj->objType == OBJECT_MINIFIGURE) {
			uVar35 = 0;
			pCVar10 = Game_GetCamera24_IfBool308_ElseCamera2C();
			pCVar17 = res::Creature_GetDrillNull(liveObj->miniFigure);
			util::logf_removed((char *)pCVar17,pCVar10,uVar35);
		}
		lVar27 = __ftol((float10)(liveObj->point_2f4).y);
		iVar19 = (int)lVar27;
		lVar27 = __ftol((float10)(liveObj->point_2f4).x);
		SVar18 = Level_GetBlockTerrain((int)lVar27,iVar19);
		fVar26 = LiveObject_GetDrillTimeType(liveObj,SVar18);
		in_liveObj = (LiveObject *)(float)fVar26;
		OVar15 = LiveObject_GetStatsFlags1(liveObj);
		if (((OVar15 & STATS1_SINGLEWIDTHDIG) != STATS1_NONE) &&
			 ((liveObj->flags3 & LIVEOBJ3_UNK_2000000) != LIVEOBJ3_NONE)) {
			in_liveObj = (LiveObject *)((float)in_liveObj * 0.5);
		}
		pLVar30 = in_liveObj;
		fVar29 = elapsed;
		lVar27 = __ftol((float10)(liveObj->point_2f4).y);
		iVar19 = (int)lVar27;
		lVar27 = __ftol((float10)(liveObj->point_2f4).x);
		BVar12 = Level_Block_GetUnkField14Test((int)lVar27,iVar19,(float)pLVar30,fVar29);
		if (BVar12 == 0) {
			BVar12 = Level_ToBlockCoordinatesNoZ(local_30.x,local_34,(int *)&local_24,(int *)&local_20);
			if (((BVar12 == 0) || (local_24 != fVar36)) || (local_20.x != fVar28)) goto LAB_0043d12f;
			LVar16 = liveObj->flags3 | LIVEOBJ3_UNK_4000;
			goto LAB_0043d129;
		}
		BVar12 = 1;
		LVar16 = liveObj->flags3 & LIVEOBJ3_UNK_2000000;
		lVar27 = __ftol((float10)(liveObj->point_2f4).y);
		uVar22 = (uint)lVar27;
		lVar27 = __ftol((float10)(liveObj->point_2f4).x);
		BVar12 = LiveObject_Check_FUN_004326a0(liveObj,(uint)lVar27,uVar22,LVar16,BVar12);
		if (BVar12 != 0) {
			lVar27 = __ftol((float10)(liveObj->point_2f4).x);
			fVar29 = (float)lVar27;
			local_c.x = fVar29;
			lVar27 = __ftol((float10)(liveObj->point_2f4).y);
			fVar32 = (float)lVar27;
			local_c.y = fVar32;
			if ((liveObj->flags3 & LIVEOBJ3_UNK_2000000) == LIVEOBJ3_NONE) {
				BVar12 = 0;
				pLVar14 = GetLevel();
				iVar19 = Level_DestroyWall(pLVar14,(int)fVar36,(int)fVar28,BVar12);
			}
			else {
				pLVar14 = GetLevel();
				iVar19 = Level_DestroyWallConnection(pLVar14,(uint)fVar29,(uint)fVar32);
			}
			if (iVar19 == 0) goto LAB_0043d12f;
			ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_DIG,NULL,1);
			liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_8;
			Level_Block_SetFlags1_8000000((Point2I *)&local_c,0);
			if (*(char *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) == '\x01')
			{
				*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 0;
			}
			pCVar10 = LiveObject_GetContainer(liveObj);
			iVar19 = liveObj->soundHandle_350;
			goto LAB_0043d0dd;
		}
	}
LAB_0043d12f:
	if ((liveObj->flags2 & LIVEOBJ2_UNK_4000) != LIVEOBJ2_NONE) {
		LiveObject_FUN_0044c470(liveObj,elapsed);
	}
	if ((((liveObj->flags2 & LIVEOBJ2_UNK_40000000) != LIVEOBJ2_NONE) &&
			((ushort)((ushort)(elapsed < 0.0) << 8 | (ushort)(elapsed == 0.0) << 0xe) == 0)) &&
		 (pCVar10 = LiveObject_GetContainer(liveObj), pCVar10 != NULL)) {
		res::Container_GetOrientation(pCVar10,NULL,&local_20,&local_c);
		local_c.x = local_c.x * 10.0;
		local_c.y = local_c.y * 10.0;
		local_c.z = local_c.z * 10.0;
		math::Maths_Vector3DRandom(&local_30);
		local_c.y = FLOAT_004a58b0 * 0.1 * (local_30.y + local_c.y);
		local_c.x = FLOAT_004a58b0 * 0.1 * (local_30.x + local_c.x);
		local_c.z = -1.0;
		res::Container_SetOrientation
							(pCVar10,NULL,local_20.x,local_20.y,local_20.z,local_c.x,local_c.y,-1.0);
		FLOAT_004a58b0 = FLOAT_004a58b0 - elapsed * 0.16;
		if (FLOAT_004a58b0 < 0.0) {
			FLOAT_004a58b0 = 1.0;
			liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_40000000;
		}
	}
	LVar24 = liveObj->flags1;
	if ((LVar24 & LIVEOBJ1_UNK_100000) != LIVEOBJ1_NONE) {
		LiveObject_DestroyRockMonster_FUN_0044c290(liveObj);
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_UNK_4000000) != LIVEOBJ1_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_4000000;
		}
		goto LAB_0043f040;
	}
	LVar13 = liveObj->flags4;
	if ((LVar13 & LIVEOBJ4_UNK_1000) != LIVEOBJ4_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags4 = LVar13 & ~LIVEOBJ4_UNK_1000 | LIVEOBJ4_UNK_2000;
		}
		goto LAB_0043f040;
	}
	if ((LVar13 & LIVEOBJ4_UNK_4000) != LIVEOBJ4_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags4 = LVar13 & ~LIVEOBJ4_UNK_4000;
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		}
		goto LAB_0043f040;
	}
	if ((LVar13 & LIVEOBJ4_UNK_2000) != LIVEOBJ4_NONE) {
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_OPEN,0);
		goto LAB_0043f040;
	}
	LVar4 = liveObj->flags2;
	if ((LVar4 & LIVEOBJ2_UNK_4000) != LIVEOBJ2_NONE) goto LAB_0043f040;
	if ((LVar24 & LIVEOBJ1_TURNING) != LIVEOBJ1_NONE) {
		uVar6 = (ushort)(liveObj->float_2d4 < 0.0) << 8;
		uVar7 = (ushort)(liveObj->float_2d4 == 0.0) << 0xe;
		if ((LVar24 & LIVEOBJ1_TURNRIGHT) != LIVEOBJ1_NONE) {
			if ((uVar6 | uVar7) == 0) {
				pCVar10 = LiveObject_GetContainer(liveObj);
				res::Container_AddRotation(pCVar10,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,1.570796);
				res::Container_SetAnimationTime(pCVar10,0.0);
				liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_TURNRIGHT;
			}
			goto LAB_0043f040;
		}
		if ((uVar6 | uVar7) != 0) goto LAB_0043f040;
		pCVar10 = LiveObject_GetContainer(liveObj);
		if ((globs::liveGlobs.Activities_TABLE[9] == liveObj->aitaskName1) ||
			 (globs::liveGlobs.Activities_TABLE[20] == liveObj->aitaskName1)) {
			fVar36 = -1.570796;
		}
		else {
			fVar36 = 1.570796;
		}
		res::Container_AddRotation(pCVar10,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,fVar36);
		LVar24 = liveObj->flags1;
		liveObj->flags1 = LVar24 & ~LIVEOBJ1_TURNING | LIVEOBJ1_MOVING;
		if (liveObj->routingBlocksTotal != 0) {
			if (((LVar24 & LIVEOBJ1_UNK_800000) != LIVEOBJ1_NONE) &&
				 (liveObj->objType == OBJECT_MINIFIGURE)) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_RUNPANIC,0);
				goto LAB_0043f040;
			}
LAB_0043e732:
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_ROUTE,0);
			goto LAB_0043f040;
		}
LAB_0043ecae:
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_20) != LIVEOBJ2_NONE) {
		LiveObject_TryDepart_FUN_004499c0(liveObj);
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_UNK_80000000) != LIVEOBJ1_NONE) {
LAB_0043eb11:
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_80000000;
		}
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_UNK_10000000) != LIVEOBJ1_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			pCVar10 = LiveObject_GetContainer(liveObj);
			liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_10000000;
			res::Container_SetOrientation
								(pCVar10,NULL,(float)liveObj->field_2c8,(float)liveObj->field_2cc,0.0,0.0,0.0,-1.0);
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_400000) != LIVEOBJ2_NONE) {
		if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
			Game_GetWeaponUnk(liveObj,1);
		}
		if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
			 (LVar4 = liveObj->flags2, liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_400000,
			 (LVar4 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE)) {
			Game_GetWeaponUnk(liveObj,1);
		}
		goto LAB_0043f040;
	}
	if ((LVar13 & LIVEOBJ4_UNK_8000) != LIVEOBJ4_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) != 0) goto LAB_0043f040;
		liveObj->flags4 = LVar13 & ~LIVEOBJ4_UNK_8000;
		if (liveObj->object_2fc != NULL) {
			pCVar10 = LiveObject_GetDepositNull(liveObj->object_2fc);
			if (pCVar10 != NULL) {
				res::Container_GetPosition(pCVar10,NULL,&local_c);
				res::Container_GetOrientation(pCVar10,NULL,&local_20,NULL);
				fVar36 = local_c.x;
				fVar28 = local_c.y;
				pSVar20 = GetSurfaceMap();
				fVar26 = Map3D_GetWorldZ(pSVar20,fVar36,fVar28);
				fVar36 = (float)fVar26;
				pCVar17 = NULL;
				fVar28 = local_c.x;
				fVar29 = local_c.y;
				pCVar10 = LiveObject_GetContainer(liveObj);
				res::Container_SetPosition(pCVar10,pCVar17,fVar28,fVar29,fVar36);
				upz = -1.0;
				fVar32 = 0.0;
				fVar29 = 0.0;
				pCVar17 = NULL;
				fVar36 = local_20.x;
				fVar28 = local_20.y;
				pCVar10 = LiveObject_GetContainer(liveObj);
				res::Container_SetOrientation(pCVar10,pCVar17,fVar36,fVar28,local_20.z,fVar29,fVar32,upz);
			}
			LiveObject_FUN_00437690(liveObj->object_2fc,0);
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
			goto LAB_0043f040;
		}
		goto LAB_0043ecae;
	}
	if ((LVar4 & LIVEOBJ2_UNK_80000000) != LIVEOBJ2_NONE) {
		if (liveObj->object_2fc == NULL) {
			liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_80000000;
		}
		else {
			pCVar10 = LiveObject_GetContainer(liveObj);
			pCVar17 = LiveObject_GetContainer(liveObj->object_2fc);
			pLVar30 = liveObj->object_2fc;
			res::Container_GetPosition(pCVar17,NULL,&local_c);
			res::Container_GetOrientation(pCVar17,NULL,&local_30,&local_20);
			res::Container_SetPosition(pCVar10,NULL,local_c.x,local_c.y,local_c.z);
			res::Container_SetOrientation
								(pCVar10,NULL,local_30.x,local_30.y,local_30.z,local_20.x,local_20.y,local_20.z);
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				pLVar30->carriedObjects[pLVar30->numCarriedObjects] = liveObj;
				pLVar30->carriedObjects[pLVar30->numCarriedObjects]->carryingThisObject = pLVar30;
				pLVar30->carriedObjects[(int)(LiveObject *)pLVar30->numCarriedObjects]->carriedObjects[6] =
						 (LiveObject *)pLVar30->numCarriedObjects;
				pLVar30->flags1 = pLVar30->flags1 | LIVEOBJ1_CARRYING;
				LiveObject_FUN_00437690(pLVar30,0);
				pLVar30->numCarriedObjects = pLVar30->numCarriedObjects + 1;
				liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_80000000;
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_FINDLOAD,NULL,1);
				pLVar30->flags4 = pLVar30->flags4 & ~LIVEOBJ4_UNK_10000;
			}
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_10000000) != LIVEOBJ2_NONE) {
		if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
			 (liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_10000000,
			 (LVar24 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) {
			pVVar34 = &local_c;
			pCVar17 = NULL;
			liveObj->carriedObjects[0]->flags3 = liveObj->carriedObjects[0]->flags3 & ~LIVEOBJ3_POWEROFF;
			pCVar10 = LiveObject_GetContainer(liveObj->carriedObjects[0]);
			res::Container_GetPosition(pCVar10,pCVar17,pVVar34);
			res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(NULL,SFX_CRYSTALRECHARGE,0,0,&local_c);
			LiveObject_SetCrystalPoweredColor(liveObj->carriedObjects[0],1);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_800000) != LIVEOBJ2_NONE) {
		if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
			Game_GetWeaponUnk(liveObj,2);
		}
		if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
			 (LVar4 = liveObj->flags2, liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_800000,
			 (LVar4 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE)) {
			Game_GetWeaponUnk(liveObj,2);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_1000000) != LIVEOBJ2_NONE) {
		if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
			Game_GetWeaponUnk(liveObj,3);
		}
		if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
			 (LVar4 = liveObj->flags2, liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_1000000,
			 (LVar4 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE)) {
			Game_GetWeaponUnk(liveObj,3);
		}
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_UNK_800) != LIVEOBJ1_NONE) {
		if ((liveObj->objType == OBJECT_ROCKMONSTER) &&
			 (BVar12 = res::Creature_GetThrowNull(liveObj->rockMonster), BVar12 != 0)) {
			FUN_00447a40(liveObj);
		}
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_800;
		}
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_UNK_4000) != LIVEOBJ1_NONE) {
		pLVar30 = liveObj->object_2fc;
		if ((((pLVar30 != NULL) && ((pLVar30->flags1 & LIVEOBJ1_UNK_2000) == LIVEOBJ1_NONE)) &&
				((pLVar30->flags3 & LIVEOBJ3_UNK_1000000) == LIVEOBJ3_NONE)) &&
			 (pLVar30->numCarriedObjects != pLVar30->field_328)) {
			liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_4000 | LIVEOBJ1_UNK_2000;
		}
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_UNK_2000) != LIVEOBJ1_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_2000;
			ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_DEPOSITE,liveObj,1);
			LiveObject_ProcCarriedObjects_FUN_0043f160(liveObj);
		}
		else {
			if (liveObj->object_2fc != NULL) {
				pLVar1 = &liveObj->object_2fc->flags3;
				*pLVar1 = *pLVar1 | LIVEOBJ3_UNK_1000000;
			}
		}
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_REST) != LIVEOBJ1_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags1 = LVar24 & ~LIVEOBJ1_REST;
			liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_4000;
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_200000) != LIVEOBJ2_NONE) {
		if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
			FUN_0043aeb0(liveObj);
		}
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_200000;
			ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_ATTACKPATH,NULL,1);
			if ((liveObj->flags2 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE) {
				FUN_0043aeb0(liveObj);
			}
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_40000) != LIVEOBJ2_NONE) {
		if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
			LiveObject_FUN_004477b0(liveObj);
		}
		if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
			 (LVar4 = liveObj->flags2, liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_40000,
			 (LVar4 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE)) {
			LiveObject_FUN_004477b0(liveObj);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_20000000) != LIVEOBJ2_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_20000000;
			liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_POWEROFF;
		}
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_UNK_1000000) != LIVEOBJ1_NONE) {
		OVar21 = LiveObject_GetStatsFlags2(liveObj);
		if ((((OVar21 & STATS2_DRAINPOWER) != STATS2_NONE) &&
				(pLVar30 = liveObj->object_2fc, pLVar30 != NULL)) &&
			 ((*(byte *)&pLVar30->flags4 & LIVEOBJ4_UNK_10) == 0)) {
			BVar12 = LiveObject_CheckCondition_FUN_00438870(pLVar30,0);
			if (BVar12 != 0) {
				front::Info_FUN_00419ab0(INFO_POWERDRAIN,NULL,liveObj->object_2fc,NULL);
				Game_SetCallToArmsOn(1);
			}
			pLVar2 = &liveObj->object_2fc->flags4;
			*pLVar2 = *pLVar2 | LIVEOBJ4_UNK_10;
			LiveManager_InitFlagsToggle_AndClearNumDrained();
		}
		if (((liveObj->flags2 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) &&
			 (iVar19 = LiveObject_FUN_00447880(liveObj), iVar19 != 0)) {
			liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_80000;
		}
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			if (((liveObj->flags2 & LIVEOBJ2_UNK_20000) == LIVEOBJ2_NONE) &&
				 (iVar19 = LiveObject_FUN_00447880(liveObj), iVar19 != 0)) {
				liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_80000;
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_REPAIR,NULL,1);
			}
			if ((liveObj->flags2 & LIVEOBJ2_UNK_80000) == LIVEOBJ2_NONE) {
				liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_1000000;
				if (liveObj->object_2fc != NULL) {
					pLVar2 = &liveObj->object_2fc->flags4;
					*pLVar2 = *pLVar2 & ~LIVEOBJ4_UNK_10;
					LiveManager_InitFlagsToggle_AndClearNumDrained();
					liveObj->object_2fc = NULL;
				}
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_REPAIR,NULL,1);
			}
			else {
				pCVar10 = LiveObject_GetContainer(liveObj);
				res::Container_SetAnimationTime(pCVar10,liveObj->float_2d4);
			}
		}
		goto LAB_0043f040;
	}
	if ((LVar24 & LIVEOBJ1_EATING) != LIVEOBJ1_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			iVar19 = FUN_004479f0((int)liveObj);
			if (iVar19 == 0) {
				pCVar10 = LiveObject_GetContainer(liveObj);
				res::Container_SetAnimationTime(pCVar10,liveObj->float_2d4);
			}
			else {
				liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_EATING;
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_EAT,NULL,1);
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_GOTOEAT,NULL,1);
			}
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UNK_40) != LIVEOBJ2_NONE) {
		liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_40;
		if (liveObj->aitask_2f0 != NULL) {
			MiniFigure_EquipTool(liveObj,liveObj->aitask_2f0->toolType);
			ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_GETTOOL,NULL,1);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_TRAINING) != LIVEOBJ2_NONE) {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
			liveObj->flags2 = LVar4 & ~LIVEOBJ2_TRAINING;
			ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_TRAIN,NULL,1);
		}
		goto LAB_0043f040;
	}
	if ((LVar4 & LIVEOBJ2_UPGRADING) == LIVEOBJ2_NONE) {
		if ((LVar24 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
			pCVar10 = LiveObject_GetContainer(liveObj);
			res::Container_ForceAnimationUpdate(pCVar10);
			if ((((liveObj->flags2 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) &&
					((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
				 (liveObj->carriedObjects[0] != NULL)) {
				pVVar34 = &local_c;
				pCVar17 = NULL;
				pCVar10 = LiveObject_GetContainer(liveObj->carriedObjects[0]);
				res::Container_GetPosition(pCVar10,pCVar17,pVVar34);
				OVar5 = liveObj->carriedObjects[0]->objType;
				if (OVar5 == OBJECT_ORE) {
					SVar11 = SFX_PLACEORE;
				}
				else {
					if (OVar5 == OBJECT_POWERCRYSTAL) {
						SVar11 = SFX_PLACECRYSTAL;
					}
					else {
						SVar11 = SFX_PLACE;
					}
				}
				res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(NULL,SVar11,0,0,&local_c);
			}
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_PLACING;
				LiveObject_FUN_0043a130(liveObj,1);
			}
			goto LAB_0043f040;
		}
		if ((LVar24 & LIVEOBJ1_UNK_1000) != LIVEOBJ1_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_1000;
			}
			goto LAB_0043f040;
		}
		if (liveObj->carryingThisObject != NULL) goto LAB_0043f040;
		if (((LVar24 & LIVEOBJ1_MOVING) != LIVEOBJ1_NONE) &&
			 (iVar19 = FUN_0043c6a0((int *)liveObj), iVar19 != 0)) {
			LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
			FUN_0043c7f0((uint *)liveObj);
			goto LAB_0043f040;
		}
		LVar24 = liveObj->flags1;
		if ((LVar24 & LIVEOBJ1_MOVING) != LIVEOBJ1_NONE) {
			LiveObject_LargeFlagsSwitch_FUN_00443b70(liveObj,elapsed);
			LiveObject_FUN_004443b0(liveObj,elapsed);
			FUN_0043ad70((uint *)liveObj);
			LVar4 = liveObj->flags2;
			if ((LVar4 & LIVEOBJ2_UNK_4000000) != LIVEOBJ2_NONE) {
				BVar12 = LiveObject_FUN_00472340(liveObj,(undefined4 *)liveObj->aitask_2f0->object_10);
				if ((BVar12 == 0) ||
					 (BVar12 = LiveObject_DoCallbacksSearch_FUN_00471b90
															 (liveObj,liveObj->aitask_2f0->object_10), BVar12 != 0)) {
					liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_4000000;
				}
				else {
					FUN_0043c780((uint *)liveObj);
				}
				goto LAB_0043f040;
			}
			LVar24 = liveObj->flags1;
			if ((LVar24 & LIVEOBJ1_UNK_8) != LIVEOBJ1_NONE) {
				lVar27 = __ftol((float10)(liveObj->point_2f4).x);
				local_c.x = (float)lVar27;
				lVar27 = __ftol((float10)(liveObj->point_2f4).y);
				local_c.y = (float)lVar27;
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_DRILL,0);
				Level_Block_SetFlags1_8000000((Point2I *)&local_c,1);
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_LIFTING) != LIVEOBJ1_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_REVERSE,0);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_TRAINING) != LIVEOBJ2_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_TRAIN,0);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_UNK_10000000) != LIVEOBJ2_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_RECHARGE,0);
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_CLEARING) != LIVEOBJ1_NONE) {
				LiveObject_SetActivityUnk
									(liveObj,ACTIVITY_CLEAR,(liveObj->objType != OBJECT_MINIFIGURE) - 1 & 2);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_UNK_80000000) != LIVEOBJ2_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_FLOATON,0);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_UNK_4) != LIVEOBJ2_NONE) {
				if (liveObj->object_2fc != NULL) {
					LiveObject_ClearFlags4_40_AndSameForObject2FC(liveObj,liveObj->object_2fc);
				}
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_REINFORCING) != LIVEOBJ1_NONE) {
				lVar27 = __ftol((float10)(liveObj->point_2f4).x);
				local_c.x = (float)lVar27;
				lVar27 = __ftol((float10)(liveObj->point_2f4).y);
				local_c.y = (float)lVar27;
				Level_Block_SetFlags1_8000000((Point2I *)&local_c,1);
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_REINFORCE,globs::gameGlobs.ReinforceHits);
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_PLACE,0);
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_UNK_20000) != LIVEOBJ1_NONE) {
				lVar27 = __ftol((float10)(liveObj->point_2f4).x);
				local_20.x = (float)lVar27;
				lVar27 = __ftol((float10)(liveObj->point_2f4).y);
				local_20.y = (float)lVar27;
				OVar21 = LiveObject_GetStatsFlags2(liveObj);
				if (((OVar21 & STATS2_USEHOLES) == STATS2_NONE) &&
					 (BVar12 = Level_GetBlockFlags1_10Not8((uint)local_20.x,(uint)local_20.y), BVar12 == 0)) {
					liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_20000;
					liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_20;
				}
				else {
					BVar12 = Level_Block_IsReinforced((uint)local_20.x,(uint)local_20.y);
					if (BVar12 == 0) {
						LiveObject_SetActivityUnk(liveObj,ACTIVITY_ENTER,0);
					}
					else {
						LiveObject_SetActivityUnk(liveObj,ACTIVITY_ENTERREIN,0);
						BVar12 = LiveObject_Container_ActivityUpdate_Check(liveObj);
						if (BVar12 == 0) {
							LiveObject_SetActivityUnk(liveObj,ACTIVITY_ENTER,0);
							LiveObject_Container_ActivityUpdate_Check(liveObj);
						}
						OVar21 = LiveObject_GetStatsFlags2(liveObj);
						if ((OVar21 & STATS2_REMOVEREINFORCEMENT) != STATS2_NONE) {
							Block_RemoveReinforcement((Point2I *)&local_20);
						}
					}
				}
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_UNK_1000000) != LIVEOBJ1_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_REPAIR,0);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_UNK_200000) != LIVEOBJ2_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAMP,0);
				goto LAB_0043f040;
			}
			if ((LVar4 & LIVEOBJ2_UPGRADING) != LIVEOBJ2_NONE) {
				if (liveObj->objType == OBJECT_MINIFIGURE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_TRAIN,100);
				}
				else {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_UPGRADE,0);
					LiveObject_SetActivityUnk(liveObj->object_2fc,ACTIVITY_UPGRADE,0);
					LiveObject_Container_ActivityUpdate_Check(liveObj->object_2fc);
					liveObj->object_2fc->flags2 = liveObj->object_2fc->flags2 | LIVEOBJ2_UPGRADING;
				}
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_EATING) != LIVEOBJ1_NONE) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_EAT,0);
				goto LAB_0043f040;
			}
			if ((LVar24 & LIVEOBJ1_UNK_200) == LIVEOBJ1_NONE) {
				if ((LVar24 & LIVEOBJ1_UNK_2000) != LIVEOBJ1_NONE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_DESPOSIT,0);
					pLVar30 = liveObj->object_2fc;
					if ((pLVar30 != NULL) &&
						 ((OVar15 = LiveObject_GetStatsFlags1(pLVar30),
							(OVar15 & STATS1_PROCESSCRYSTAL) != STATS1_NONE ||
							(OVar15 = LiveObject_GetStatsFlags1(pLVar30),
							(OVar15 & STATS1_PROCESSORE) != STATS1_NONE)))) {
						pLVar30 = liveObj->object_2fc;
						if (((pLVar30->flags1 & LIVEOBJ1_UNK_2000) == LIVEOBJ1_NONE) &&
							 (((pLVar30->flags3 & LIVEOBJ3_UNK_1000000) == LIVEOBJ3_NONE &&
								(pLVar30->numCarriedObjects != pLVar30->field_328)))) {
							pLVar30->flags3 = pLVar30->flags3 | LIVEOBJ3_UNK_1000000;
						}
						else {
							liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_2000 | LIVEOBJ1_UNK_4000;
						}
					}
					goto LAB_0043f040;
				}
				if ((LVar24 & LIVEOBJ1_UNK_800) != LIVEOBJ1_NONE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_THROW,0);
					goto LAB_0043f040;
				}
				if (((LVar24 & LIVEOBJ1_TURNING) != LIVEOBJ1_NONE) ||
					 ((LVar24 & LIVEOBJ1_REST) != LIVEOBJ1_NONE)) goto LAB_0043f040;
				if ((LVar24 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
					LiveObject_GetBlockPos(liveObj,(int *)&local_20,(int *)&local_20.y);
					uVar22 = Level_GetBlockRubbleLevel_OrFlag200000((Point2I *)&local_20);
					if (((uVar22 < 3) &&
							((globs::gameGlobs.level)->blocks
							 [((globs::gameGlobs.level)->dimensions).width * (int)local_20.y + (int)local_20.x].
							 terrain != TERRAIN_LAKE)) ||
						 ((liveObj->flags3 & LIVEOBJ3_CANROUTERUBBLE) == LIVEOBJ3_NONE)) {
						LiveObject_SetActivityUnk(liveObj,ACTIVITY_CARRY,0);
					}
					else {
						LiveObject_SetActivityUnk(liveObj,ACTIVITY_CARRYRUBBLE,0);
					}
					goto LAB_0043f040;
				}
				if ((LVar24 & LIVEOBJ1_UNK_80000000) != LIVEOBJ1_NONE) {
					LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_CANTDO,1);
					goto LAB_0043f040;
				}
				if ((LVar24 & LIVEOBJ1_MOVING) == LIVEOBJ1_NONE) goto LAB_0043f040;
				LiveObject_GetBlockPos(liveObj,(int *)&local_20,(int *)&local_20.y);
				if (((liveObj->flags1 & LIVEOBJ1_UNK_800000) != LIVEOBJ1_NONE) &&
					 (liveObj->objType == OBJECT_MINIFIGURE)) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_RUNPANIC,0);
					goto LAB_0043f040;
				}
				uVar22 = Level_GetBlockRubbleLevel_OrFlag200000((Point2I *)&local_20);
				if (((2 < uVar22) ||
						((globs::gameGlobs.level)->blocks
						 [((globs::gameGlobs.level)->dimensions).width * (int)local_20.y + (int)local_20.x].
						 terrain == TERRAIN_LAKE)) &&
					 ((liveObj->flags3 & LIVEOBJ3_CANROUTERUBBLE) != LIVEOBJ3_NONE)) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_ROUTERUBBLE,0);
					goto LAB_0043f040;
				}
				goto LAB_0043e732;
			}
			if ((liveObj->object_2fc == NULL) || (liveObj->object_2fc->carryingThisObject != NULL)) {
				liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_200;
				goto LAB_0043f040;
			}
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_COLLECT,0);
			if (liveObj->objType == OBJECT_ROCKMONSTER) {
				OVar5 = liveObj->object_2fc->objType;
				if (OVar5 == OBJECT_BOULDER) {
					AVar33 = ACTIVITY_GATHER;
				}
				else {
					if (OVar5 != OBJECT_POWERCRYSTAL) goto LAB_0043e4b7;
					AVar33 = ACTIVITY_EAT;
				}
				LiveObject_SetActivityUnk(liveObj,AVar33,0);
			}
LAB_0043e4b7:
			liveObj->carriedObjects[liveObj->numCarriedObjects] = liveObj->object_2fc;
			liveObj->object_2fc = NULL;
			liveObj->carriedObjects[liveObj->numCarriedObjects]->carryingThisObject = liveObj;
			liveObj->carriedObjects[(int)(LiveObject *)liveObj->numCarriedObjects]->carriedObjects[6] =
					 (LiveObject *)liveObj->numCarriedObjects;
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_CARRYING;
			ai::AITask_LiveObject_SetAITaskUnk
								(liveObj,AITASK_COLLECT,liveObj->carriedObjects[liveObj->numCarriedObjects],1);
			ai::AITask_DoAnimationWait(liveObj);
			liveObj->numCarriedObjects = liveObj->numCarriedObjects + 1;
			goto LAB_0043f040;
		}
		if ((LVar24 & LIVEOBJ1_UNK_200000) != LIVEOBJ1_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_200000;
				if (liveObj->objType == OBJECT_VEHICLE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_ROUTE,0);
					LiveObject_Container_ActivityUpdate_Check(liveObj);
				}
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
				LiveObject_FUN_00438720(liveObj);
			}
			FUN_00443240(liveObj,elapsed);
			pCVar10 = LiveObject_GetContainer(liveObj);
			if (pCVar10 != NULL) {
				res::Container_GetOrientation(pCVar10,NULL,&local_c,NULL);
				res::Container_SetOrientation(pCVar10,NULL,local_c.x,local_c.y,local_c.z,0.0,0.0,-1.0);
			}
			goto LAB_0043f040;
		}
		BVar12 = FUN_00449c40(liveObj,elapsed,&local_14);
		if (BVar12 != 0) {
			if (local_14 != 0) {
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_REINFORCE,NULL,1);
			}
			goto LAB_0043f040;
		}
		LVar24 = liveObj->flags1;
		if ((LVar24 & LIVEOBJ1_UNK_100) != LIVEOBJ1_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_100;
				BVar12 = LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj);
				if (BVar12 != 0) {
					lVar27 = __ftol((float10)(liveObj->point_2f4).x);
					local_c.x = (float)lVar27;
					lVar27 = __ftol((float10)(liveObj->point_2f4).y);
					local_c.y = (float)lVar27;
					Message_AddMessageAction(MESSAGE_GENERATEROCKMONSTER_COMPLETE,liveObj,0,NULL);
					Level_Block_SetFlags1_8000000((Point2I *)&local_c,0);
				}
			}
			goto LAB_0043f040;
		}
		LVar4 = liveObj->flags2;
		if ((LVar4 & LIVEOBJ2_UNK_100000) != LIVEOBJ2_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_100000;
				liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
			}
			goto LAB_0043f040;
		}
		if ((LVar4 & LIVEOBJ2_UNK_4) != LIVEOBJ2_NONE) {
			pLVar30 = liveObj->object_2fc;
			liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_4;
			ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_FINDDRIVER,NULL,1);
			liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_DRIVING;
			pLVar30->flags4 = pLVar30->flags4 & ~LIVEOBJ4_UNK_80;
			if (pLVar30->object_2fc != NULL) {
				pLVar2 = &pLVar30->object_2fc->flags4;
				*pLVar2 = *pLVar2 & ~LIVEOBJ4_UNK_80;
			}
			pLVar30->object_2fc = NULL;
			pLVar30->flags2 = pLVar30->flags2 & ~LIVEOBJ2_UNK_10;
			liveObj->drivenObject = pLVar30;
			pLVar30->drivenObject = liveObj;
			liveObj->object_2fc = NULL;
			front::Interface_ChangeMenu_IfVehicleMounted_IsLiveObject(liveObj->drivenObject);
			FUN_00443240(liveObj,elapsed);
			pLVar30->aitaskName2 = NULL;
			LiveObject_Container_ActivityUpdate_Check(pLVar30);
			goto LAB_0043f040;
		}
		if ((LVar4 & LIVEOBJ2_DRIVING) != LIVEOBJ2_NONE) goto LAB_0043f040;
		if ((LVar24 & LIVEOBJ1_UNK_20000) != LIVEOBJ1_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_20000;
				liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_20;
				LiveObject_FUN_0043be80(liveObj);
			}
			goto LAB_0043f040;
		}
		if ((LVar4 & LIVEOBJ2_UNK_200) != LIVEOBJ2_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				LiveObject_GetBlockPos(liveObj,(int *)&local_20,(int *)&local_20.y);
				pBVar23 = Construction_Block_FUN_00408ff0((Point2I *)&local_20,NULL);
				if ((pBVar23 != NULL) && ((*(byte *)&pBVar23->flags & 2) != 0)) {
					Level_Block_FUN_00432530((Point2I *)&local_20);
					Construction_Block_FUN_00409040((Point2I *)&local_20);
					front::Info_FUN_00419ab0(INFO_PATHCOMPLETED,NULL,NULL,(Point2I *)&local_20);
					ai::AITask_DoAttackPath((Point2I *)&local_20);
				}
				liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_200;
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_BUILDPATH,NULL,1);
			}
			goto LAB_0043f040;
		}
		if ((LVar24 & LIVEOBJ1_CLEARING) != LIVEOBJ1_NONE) {
			if (liveObj->objType == OBJECT_VEHICLE) {
				FUN_00443240(liveObj,elapsed);
			}
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CLEARING;
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_CLEAR,NULL,1);
				if (liveObj->objType == OBJECT_VEHICLE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
				}
			}
			goto LAB_0043f040;
		}
		if ((LVar24 & LIVEOBJ1_UNK_80000000) != LIVEOBJ1_NONE) goto LAB_0043eb11;
		if ((LVar4 & LIVEOBJ2_UNK_100) != LIVEOBJ2_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_100;
			}
			goto LAB_0043f040;
		}
		if ((LVar24 & LIVEOBJ1_UNK_10000) != LIVEOBJ1_NONE) {
			sVar9 = math::Maths_Rand();
			if ((int)sVar9 % 10 != 0) {
				LiveObject_FUN_00444520(liveObj);
			}
			liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_10000;
			goto LAB_0043f040;
		}
		if ((LVar4 & LIVEOBJ2_UNK_2) != LIVEOBJ2_NONE) {
			if (((*(byte *)&liveObj->object_3c0->flags2 & 1) == 0) ||
				 ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0)) {
				liveObj->flags2 = LVar4 & ~LIVEOBJ2_UNK_2;
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_GETUP,0);
				LiveObject_Container_ActivityUpdate_Check(liveObj);
				liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_100;
			}
			goto LAB_0043f040;
		}
		if ((LVar4 & LIVEOBJ2_UNK_1) != LIVEOBJ2_NONE) {
			if ((LVar4 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
				LiveObject_GetPosition(liveObj,(float *)&local_c,&local_c.y);
				BVar12 = 1;
				fVar26 = LiveObject_UnkRadians_FUN_00442740(liveObj);
				LiveObject_UnkUpdatePositioning
									(liveObj->object_3c0,local_c.x,local_c.y,(float)fVar26,BVar12);
			}
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) != 0) goto LAB_0043f040;
			pCVar10 = LiveObject_GetDepositNull(liveObj);
			res::Container_GetPosition(pCVar10,NULL,&local_c);
			LiveObject_UnkUpdatePositioning(liveObj,local_c.x,local_c.y,0,0);
			liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_1;
			LiveObject_AddDamage2(liveObj->object_3c0,10.0,1,elapsed);
			goto LAB_0043ecae;
		}
		BVar12 = LiveObject_FUN_00433b40(liveObj,elapsed,0);
		if (BVar12 != 0) goto LAB_0043f040;
		iVar19 = LiveObject_FUN_00442dd0(liveObj,elapsed,&local_10);
		if (iVar19 != 0) {
			if (iVar19 == 1) {
				if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_ROUTE,0);
				}
				else {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_CARRY,0);
				}
			}
			else {
				if (iVar19 == 4) {
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
				}
				else {
					if (iVar19 == 2) {
						LiveObject_SetActivityUnk(liveObj,ACTIVITY_WALK,0);
					}
					else {
						if ((iVar19 == 3) &&
							 (BVar12 = LiveObject_GetDrillNullPosition
																	 (liveObj,(float *)&local_20,(float *)&in_liveObj), BVar12 != 0))
						{
							out_by = &local_30.y;
							pVVar34 = &local_30;
							fVar36 = local_20.x;
							pLVar30 = in_liveObj;
							pSVar20 = GetSurfaceMap();
							BVar12 = Map3D_WorldToBlockPos_NoZ
																 (pSVar20,fVar36,(float)pLVar30,(int *)pVVar34,(int *)out_by);
							if ((BVar12 != 0) &&
								 (BVar12 = Level_GetBlockFlags1_10Not8((uint)local_30.x,(uint)local_30.y),
								 BVar12 != 0)) {
								SVar18 = Level_GetBlockTerrain((int)local_30.x,(int)local_30.y);
								fVar26 = LiveObject_GetDrillTimeType(liveObj,SVar18);
								local_24 = (float)fVar26;
								if ((liveObj->flags4 & LIVEOBJ4_UNK_20000) == LIVEOBJ4_NONE) {
									LiveObject_GetContainer(liveObj);
									BVar12 = 1;
									SVar11 = LiveObject_GetDrillSoundType(liveObj,0);
									iVar19 = snd::SFX_Sample_Random_Play_OrAddToQueue(SVar11,BVar12);
									liveObj->soundHandle_350 = iVar19;
									liveObj->flags4 = liveObj->flags4 | (LIVEOBJ4_UNK_20000|LIVEOBJ4_UNK_100000);
								}
								bVar8 = false;
								LiveObject_SetActivityUnk(liveObj,ACTIVITY_DRILL,0);
								BVar12 = Level_Block_GetUnkField14Test
																	 ((int)local_30.x,(int)local_30.y,local_24,elapsed);
								if ((BVar12 != 0) &&
									 (BVar12 = LiveObject_Check_FUN_004326a0
																			 (liveObj,(uint)local_30.x,(uint)local_30.y,0,1), BVar12 != 0)
									 ) {
									BVar12 = 0;
									pLVar14 = GetLevel();
									Level_DestroyWall(pLVar14,(int)local_30.x,(int)local_30.y,BVar12);
								}
							}
						}
					}
				}
			}
			if (liveObj->objType == OBJECT_MINIFIGURE) {
				if ((globs::liveGlobs.s_stepCounter_c63c & 3) == 0) {
					snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_STEP,0);
				}
				globs::liveGlobs.s_stepCounter_c63c += 1;
			}
			goto LAB_0043f040;
		}
		LVar24 = liveObj->flags1;
		if ((LVar24 & LIVEOBJ1_UNK_200) != LIVEOBJ1_NONE) {
			if (((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									 (ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) &&
				 (liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_200,
				 (LVar24 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) {
				if (liveObj->objType == OBJECT_ROCKMONSTER) {
					pLVar30 = liveObj->carriedObjects[0];
					if (pLVar30->objType == OBJECT_BOULDER) {
						uVar35 = FUN_00438e40(liveObj,0x400);
						Message_AddMessageAction(MESSAGE_GATHERROCK_COMPLETE,liveObj,uVar35,NULL);
					}
					else {
						liveObj->carriedObjects[0] = NULL;
						liveObj->numCarriedObjects = 0;
						pLVar30->carryingThisObject = NULL;
						pLVar30->object_300 = NULL;
						ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_COLLECT,pLVar30,1);
						LiveObject_FUN_0043ab10(liveObj,pLVar30);
						liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CARRYING;
					}
				}
				else {
					OVar5 = liveObj->carriedObjects[liveObj->numCarriedObjects - 1]->objType;
					if (OVar5 == OBJECT_POWERCRYSTAL) {
						Level_IncField94();
					}
					else {
						if (OVar5 == OBJECT_ORE) {
							Level_IncFieldA8();
							front::Info_FUN_00419ab0(INFO_ORECOLLECTED,NULL,liveObj,NULL);
						}
					}
				}
			}
			goto LAB_0043f040;
		}
		if ((LVar24 & LIVEOBJ1_UNK_8000) != LIVEOBJ1_NONE) {
			if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
									(ushort)(liveObj->float_2d4 == 0.0) << 0xe) == 0) {
				liveObj->flags1 = LVar24 & ~LIVEOBJ1_UNK_8000;
			}
			goto LAB_0043f040;
		}
		if ((LVar24 & LIVEOBJ1_TURNING) != LIVEOBJ1_NONE) goto LAB_0043f040;
		if ((LVar24 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
			OVar5 = liveObj->objType;
			if (OVar5 == OBJECT_BUILDING) {
				if ((liveObj->flags3 & LIVEOBJ3_HASPOWER) != LIVEOBJ3_NONE) {
					if ((liveObj->flags3 & LIVEOBJ3_POWEROFF) != LIVEOBJ3_NONE) {
						AVar33 = ACTIVITY_UNPOWERED;
						goto LAB_0043f029;
					}
					goto LAB_0043eff8;
				}
			}
			else {
LAB_0043eff8:
				if ((OVar5 != OBJECT_ROCKMONSTER) ||
					 ((liveObj->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE)) {
					if ((OVar5 == OBJECT_VEHICLE) && ((liveObj->flags4 & LIVEOBJ4_UNK_2000) != LIVEOBJ4_NONE))
					{
						AVar33 = ACTIVITY_OPEN;
					}
					else {
						AVar33 = ACTIVITY_STAND;
					}
					goto LAB_0043f029;
				}
			}
			AVar33 = ACTIVITY_UNPOWERED;
		}
		else {
			AVar33 = ACTIVITY_CARRYSTAND;
		}
LAB_0043f029:
		LiveObject_SetActivityUnk(liveObj,AVar33,0);
		FUN_00443240(liveObj,elapsed);
		goto LAB_0043f040;
	}
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		if (liveObj->object_2fc == NULL) {
			liveObj->flags2 = LVar4 & ~LIVEOBJ2_UPGRADING;
		}
		else {
			fVar26 = res::Creature_GetAnimFloat10(liveObj->miniFigure);
			local_20.x = (float)fVar26;
			fVar26 = LiveObject_GetUpgradeTime(liveObj);
			in_liveObj = (LiveObject *)(float)fVar26;
			fVar26 = LiveObject_GetFunctionCoef(liveObj->object_2fc);
			if (fVar26 * (float10)(float)in_liveObj <= (float10)local_20.x) {
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_UPGRADE,NULL,1);
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
				LiveObject_Container_ActivityUpdate_Check(liveObj);
				uVar25 = liveObj->objLevel + 1;
				uVar22 = Object_GetLevels(liveObj->objType,liveObj->objIndex);
				if (uVar25 < uVar22) {
					LiveObject_SetLevel(liveObj,uVar25);
					front::HelpWindow_Game_UpdateObjectDependencies
										(liveObj->objType,liveObj->objIndex,liveObj->objLevel,0);
				}
				liveObj->object_2fc = NULL;
				liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UPGRADING;
			}
		}
		goto LAB_0043f040;
	}
	if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 | (ushort)(liveObj->float_2d4 == 0.0) << 0xe)
			!= 0) goto LAB_0043f040;
	if ((liveObj->object_2fc == NULL) ||
		 (OVar21 = LiveObject_GetStatsFlags2(liveObj->object_2fc),
		 (OVar21 & STATS2_UPGRADEBUILDING) == STATS2_NONE)) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UPGRADING;
		goto LAB_0043f040;
	}
	if ((liveObj->object_2fc->flags2 & LIVEOBJ2_UPGRADING) != LIVEOBJ2_NONE) goto LAB_0043f040;
	ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_UPGRADE,NULL,1);
	uVar22 = Object_GetUpgradeCostOre(liveObj->objType,liveObj->objIndex,liveObj->field_404);
	uVar25 = Level_GetOreCount(0);
	if (uVar25 < uVar22) {
		uVar22 = Object_GetUpgradeCostStuds(liveObj->objType,liveObj->objIndex,liveObj->field_404);
		uVar25 = Level_GetOreCount(1);
		if (uVar22 <= uVar25) {
			LiveObject_CompleteVehicleUpgrade(liveObj);
			iVar19 = Object_GetUpgradeCostStuds(liveObj->objType,liveObj->objIndex,liveObj->field_404);
			BVar12 = 1;
			goto LAB_0043df73;
		}
	}
	else {
		LiveObject_CompleteVehicleUpgrade(liveObj);
		iVar19 = Object_GetUpgradeCostOre(liveObj->objType,liveObj->objIndex,liveObj->field_404);
		BVar12 = 0;
LAB_0043df73:
		Level_SubtractOre(BVar12,iVar19);
	}
	liveObj->object_2fc->object_300 = NULL;
	liveObj->object_2fc = NULL;
	liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UPGRADING;
LAB_0043f040:
	if ((bVar8) && ((liveObj->flags4 & LIVEOBJ4_UNK_20000) != LIVEOBJ4_NONE)) {
		LiveObject_GetContainer(liveObj);
		snd::SFX_Sample_Sound3D_StopSound(liveObj->soundHandle_350);
		BVar12 = 0;
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_100000;
		SVar11 = LiveObject_GetDrillSoundType(liveObj,1);
		snd::SFX_Sample_Random_Play_OrAddToQueue(SVar11,BVar12);
		liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_20000;
	}
	LiveObject_Container_ActivityUpdate_Check(liveObj);
	if ((liveObj->drivenObject != NULL) && (liveObj->objType != OBJECT_MINIFIGURE)) {
		FUN_004437d0(liveObj);
	}
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		LiveObject_UpdateCarrying(liveObj);
	}
	BVar12 = LiveObject_UnkTracker_FUN_00471fa0(liveObj);
	if (BVar12 != 0) {
		LiveObject_FUN_00472280(liveObj,elapsed);
	}
	LiveObject_FUN_004459a0(liveObj);
	LiveObject_Flocks_FUN_0044bef0(liveObj,*lpElapsed);
	LiveObject_UnkUpdateEnergyHealth(liveObj,elapsed);
	if ((liveObj->flags2 & LIVEOBJ2_UNK_10000) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_10000 | LIVEOBJ2_UNK_20000;
	}
	liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_2;
	LiveObject_TeleportUp(liveObj);
	return 0;
}



void __cdecl lego::game::LiveObject_ProcCarriedObjects_FUN_0043f160(LiveObject *in_liveObj)
{
	LiveObject *pLVar1;
	LiveObject *liveObj2;
	bool bVar2;
	LiveObject *liveObj;
	ObjectStatsFlags1 OVar3;
	uint uVar4;
	Container *cont;
	LiveObject *argument1Obj;
	int iVar5;
	int iVar6;
	LiveObject **ppLVar7;
	uint uVar8;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	pLVar1 = in_liveObj->object_2fc;
	OVar3 = LiveObject_GetStatsFlags1(in_liveObj);
	if (((OVar3 & STATS1_PROCESSCRYSTAL) == STATS1_NONE) &&
		 (OVar3 = LiveObject_GetStatsFlags1(in_liveObj), (OVar3 & STATS1_PROCESSORE) == STATS1_NONE)) {
		bVar2 = false;
	}
	else {
		bVar2 = true;
	}
	uVar8 = 0;
	if (in_liveObj->numCarriedObjects != 0) {
		in_liveObj = (LiveObject *)in_liveObj->carriedObjects;
		do {
			liveObj2 = (LiveObject *)in_liveObj->objType;
			liveObj2->object_2fc = NULL;
			if (bVar2) {
				liveObj2->carryingThisObject = NULL;
				liveObj2->object_300 = NULL;
				if (liveObj2->objType == OBJECT_ORE) {
					if ((uVar8 == 0) || (uVar4 = LiveObject_GetMaxCarry(liveObj), uVar4 <= uVar8)) {
						cont = res::Building_GetDepositNull(liveObj->building);
						if (uVar8 == 0) {
							res::Container_GetPosition(cont,NULL,&local_c);
							argument1Obj = Game_CreateLiveResourceObject
																			 (globs::gameGlobs.RES_Ores_TABLE[1],OBJECT_ORE,ORE_PROCESSED,
																				0,local_c.x,local_c.y,0.0);
							Message_AddMessageAction(MESSAGE_GENERATEORE_COMPLETE,argument1Obj,0,NULL);
							pool::ReservedPool_LiveObject___Release(liveObj2);
							goto LAB_0043f315;
						}
						Level_IncOre(ORE_NORMAL);
					}
					pool::ReservedPool_LiveObject___Release(liveObj2);
				}
				else {
					LiveObject_FUN_0043ab10(liveObj,liveObj2);
					if (liveObj->objType == OBJECT_BUILDING) {
						res::Building_FUN_00408210(liveObj->building,TRUE);
					}
					LiveManager_InitFlagsToggle_AndClearNumDrained();
				}
			}
			else {
				if (pLVar1->numCarriedObjects == pLVar1->field_328) {
					if (uVar8 < liveObj->numCarriedObjects) {
						iVar6 = uVar8 * 4;
						ppLVar7 = liveObj->carriedObjects + uVar8;
						uVar4 = uVar8;
						do {
							pLVar1 = *ppLVar7;
							iVar5 = iVar6 + uVar8 * -4;
							uVar4 += 1;
							iVar6 += 4;
							ppLVar7 = ppLVar7 + 1;
							*(LiveObject **)((int)liveObj + iVar5 + 0x308) = pLVar1;
						} while (uVar4 < liveObj->numCarriedObjects);
					}
					liveObj->numCarriedObjects = liveObj->numCarriedObjects - uVar8;
					return;
				}
				pLVar1->carriedObjects[pLVar1->numCarriedObjects] = liveObj2;
				liveObj2->carryingThisObject = pLVar1;
				liveObj2->carriedObjects[6] = (LiveObject *)pLVar1->numCarriedObjects;
				pLVar1->numCarriedObjects = pLVar1->numCarriedObjects + 1;
				pLVar1->flags1 = pLVar1->flags1 | LIVEOBJ1_CARRYING;
				Message_AddMessageAction(MESSAGE_CRYSTALTOREFINERY_COMPLETE,0,0,NULL);
				OVar3 = LiveObject_GetStatsFlags1(pLVar1);
				if ((OVar3 & STATS1_PROCESSCRYSTAL) != STATS1_NONE) {
					front::Info_FUN_00419ab0(INFO_CRYSTALPOWER,NULL,pLVar1,NULL);
				}
			}
LAB_0043f315:
			uVar8 += 1;
			in_liveObj->objType = OBJECT_NONE;
			in_liveObj = (LiveObject *)&in_liveObj->objIndex;
		} while (uVar8 < liveObj->numCarriedObjects);
	}
	liveObj->numCarriedObjects = 0;
	liveObj->object_2fc = NULL;
	liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CARRYING;
	return;
}



void __cdecl
lego::game::LiveObject_ClearFlags4_40_AndSameForObject2FC
					(LiveObject *unused_liveObj,LiveObject *liveObj)
{
	LiveFlags4 *pLVar1;
	
	liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_40;
	if (liveObj->object_2fc != NULL) {
		pLVar1 = &liveObj->object_2fc->flags4;
		*pLVar1 = *pLVar1 & ~LIVEOBJ4_UNK_40;
	}
	return;
}



void __cdecl lego::game::Game_Container_TriggerFrameCallback(Container *cont,void *data)
{
	LiveObject *liveObj;
	
	liveObj = (LiveObject *)res::Container_GetUserData(cont);
	if (liveObj != NULL) {
		liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_10000;
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_QueueTeleport(LiveObject *liveObj,ObjectType objType,int objIndex)
{
	if (globs::gameGlobs.objTeleportQueue_COUNT < 9) {
		globs::gameGlobs.objTeleportQueueTypes_TABLE[globs::gameGlobs.objTeleportQueue_COUNT] = objType;
		globs::gameGlobs.objTeleportQueueIndexes_TABLE[globs::gameGlobs.objTeleportQueue_COUNT] =
				 objIndex;
		globs::gameGlobs.objTeleportQueue_COUNT = globs::gameGlobs.objTeleportQueue_COUNT + 1;
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_0043f450(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	BOOL BVar1;
	ObjectStatsFlags2 OVar2;
	ObjectStatsFlags1 OVar3;
	int iVar4;
	int iVar5;
	LiveObject *pLVar6;
	Container *cont;
	SurfaceMap *pSVar7;
	int *piVar8;
	uint uVar9;
	ObjectType *pOVar10;
	float in_x;
	float in_y;
	uint *out_bx;
	Vector3F *out_x;
	uint *out_by;
	float *out_y;
	ObjectType local_2c;
	int local_28;
	Container *local_24;
	uint local_20;
	uint local_1c;
	Vector3F local_18;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	local_28 = 0;
	BVar1 = LiveObject_CheckCondition_FUN_00438870(in_liveObj,0);
	if ((((BVar1 != 0) && (globs::gameGlobs.objTeleportQueue_COUNT != 0)) &&
			((liveObj->object_3cc == NULL ||
			 ((liveObj->object_3cc->flags1 & LIVEOBJ1_UNK_200000) == LIVEOBJ1_NONE)))) &&
		 ((*(byte *)&liveObj->flags4 & 0xc0) == 0)) {
		uVar9 = 0;
		iVar4 = 0;
		if (globs::gameGlobs.objTeleportQueue_COUNT != 0) {
			pOVar10 = globs::gameGlobs.objTeleportQueueTypes_TABLE;
			do {
				OVar2 = Object_GetStatsFlags2(*pOVar10,pOVar10[0x14]);
				if (((((OVar2 & STATS2_USESMALLTELEPORTER) != STATS2_NONE) &&
						 (OVar3 = LiveObject_GetStatsFlags1(liveObj),
						 (OVar3 & STATS1_SMALLTELEPORTER) != STATS1_NONE)) ||
						(((OVar2 = Object_GetStatsFlags2(*pOVar10,pOVar10[0x14]),
							(OVar2 & STATS2_USEBIGTELEPORTER) != STATS2_NONE &&
							(OVar3 = LiveObject_GetStatsFlags1(liveObj),
							(OVar3 & STATS1_BIGTELEPORTER) != STATS1_NONE)) ||
						 ((OVar2 = Object_GetStatsFlags2(*pOVar10,pOVar10[0x14]),
							(OVar2 & STATS2_USEWATERTELEPORTER) != STATS2_NONE &&
							(OVar3 = LiveObject_GetStatsFlags1(liveObj),
							(OVar3 & STATS1_WATERTELEPORTER) != STATS1_NONE)))))) ||
					 ((OVar2 = Object_GetStatsFlags2(*pOVar10,pOVar10[0x14]),
						(OVar2 & STATS2_USELEGOMANTELEPORTER) != STATS2_NONE &&
						(OVar3 = LiveObject_GetStatsFlags1(liveObj),
						(OVar3 & STATS1_MANTELEPORTER) != STATS1_NONE)))) {
					iVar4 = Object_GetCostCrystal(*pOVar10,pOVar10[0x14],0);
					iVar5 = Level_GetCrystalCount(0);
					if (iVar4 <= iVar5) {
						Object_GetObjectByName("Barracks",&local_2c,(int *)&in_liveObj,NULL);
						BVar1 = Object_DoOxygenCheck_FUN_0043c4c0
															(*pOVar10,pOVar10[0x14],local_2c,(int)in_liveObj);
						if (BVar1 != 0) {
							iVar4 = 1;
							break;
						}
					}
				}
				uVar9 += 1;
				pOVar10 = pOVar10 + 1;
				iVar4 = local_28;
			} while (uVar9 < globs::gameGlobs.objTeleportQueue_COUNT);
		}
		if (iVar4 != 0) {
			Object_GetTypeResource
								(globs::gameGlobs.objTeleportQueueTypes_TABLE[uVar9],
								 globs::gameGlobs.objTeleportQueueIndexes_TABLE[uVar9],&local_24);
			pLVar6 = Game_CreateLiveResourceObject
												 (local_24,globs::gameGlobs.objTeleportQueueTypes_TABLE[uVar9],
													globs::gameGlobs.objTeleportQueueIndexes_TABLE[uVar9],0,0.0,0.0,0.0);
			liveObj->object_3cc = pLVar6;
			iVar4 = Object_GetCostCrystal
												(globs::gameGlobs.objTeleportQueueTypes_TABLE[uVar9],
												 globs::gameGlobs.objTeleportQueueIndexes_TABLE[uVar9],0);
			Level_SubtractCrystals(iVar4);
			LiveManager_InitFlagsToggle_AndClearNumDrained();
			OVar3 = LiveObject_GetStatsFlags1(liveObj);
			if ((OVar3 & STATS1_WATERTELEPORTER) == STATS1_NONE) {
				OVar3 = LiveObject_GetStatsFlags1(liveObj->object_3cc);
				if ((OVar3 & STATS1_CANBEDRIVEN) != STATS1_NONE) {
					liveObj->object_3cc->flags4 = liveObj->object_3cc->flags4 | LIVEOBJ4_UNK_80;
					liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_80;
					liveObj->object_3cc->object_2fc = liveObj;
				}
			}
			else {
				liveObj->object_3cc->flags4 = liveObj->object_3cc->flags4 | LIVEOBJ4_UNK_40;
				liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_40;
				liveObj->object_3cc->object_2fc = liveObj;
			}
			cont = res::Building_GetDepositNull(liveObj->building);
			res::Container_GetPosition(cont,NULL,&local_18);
			res::Container_GetOrientation(cont,NULL,&local_c,NULL);
			if ((globs::gameGlobs.objTeleportQueueTypes_TABLE[uVar9] == OBJECT_VEHICLE) &&
				 (OVar2 = Object_GetStatsFlags2
														(OBJECT_VEHICLE,globs::gameGlobs.objTeleportQueueIndexes_TABLE[uVar9]),
				 (OVar2 & STATS2_USESMALLTELEPORTER) != STATS2_NONE)) {
				out_by = &local_1c;
				out_bx = &local_20;
				in_x = local_18.x;
				in_y = local_18.y;
				pSVar7 = GetSurfaceMap();
				Map3D_WorldToBlockPos_NoZ(pSVar7,in_x,in_y,(int *)out_bx,(int *)out_by);
				out_y = &local_18.y;
				out_x = &local_18;
				pSVar7 = GetSurfaceMap();
				Map3D_BlockToWorldPos(pSVar7,local_20,local_1c,(float *)out_x,out_y);
			}
			LiveObject_UnkUpdatePositioning(liveObj->object_3cc,local_18.x,local_18.y,0,0);
			LiveObject_UnkUpdateOrientation(liveObj->object_3cc,0.0,&local_c);
			ObjectRecall_LiveObject_RecallMiniFigure(liveObj->object_3cc);
			liveObj->object_3cc->flags1 = liveObj->object_3cc->flags1 | LIVEOBJ1_UNK_200000;
			LiveObject_SetActivityUnk(liveObj->object_3cc,ACTIVITY_TELEPORTIN,1);
			LiveObject_Container_ActivityUpdate_Check(liveObj->object_3cc);
			if (liveObj->object_3cc->objType == OBJECT_VEHICLE) {
				res::Vehicle_FUN_0046d280(liveObj->object_3cc->vehicle,1);
			}
			globs::gameGlobs.objTeleportQueue_COUNT -= 1;
			if (uVar9 < globs::gameGlobs.objTeleportQueue_COUNT) {
				piVar8 = globs::gameGlobs.objTeleportQueueIndexes_TABLE + uVar9 + 1;
				do {
					uVar9 += 1;
					piVar8[-0x15] = piVar8[-0x14];
					piVar8[-1] = *piVar8;
					piVar8 = piVar8 + 1;
				} while (uVar9 < globs::gameGlobs.objTeleportQueue_COUNT);
			}
		}
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_0043f820(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = Search_LiveObjects_SkipIgnoreMes(FUN_0043f840,(undefined4 *)liveObj);
	return BVar1;
}



BOOL __cdecl FUN_0043f840(int param_1,LiveObject *param_2)
{
	if (*(LiveObject **)(param_1 + 0x3cc) == param_2) {
		*(undefined4 *)(param_1 + 0x3cc) = 0;
		return 1;
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_TrainMiniFigure_instantunk(LiveObject *liveObj,TrainedFlags trainFlags)
{
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		liveObj->flags5_3f0 = liveObj->flags5_3f0 | trainFlags;
		globs::liveGlobs.NERPs_TrainFlags |= trainFlags;
		if ((trainFlags & TRAINED_PILOT) != TRAINED_NONE) {
			front::Info_FUN_00419ab0(INFO_TRAINPILOT,NULL,liveObj,NULL);
			liveObj->elapsedTime1 = 0.0;
			return;
		}
		if ((trainFlags & TRAINED_SAILOR) != TRAINED_NONE) {
			front::Info_FUN_00419ab0(INFO_TRAINSAILOR,NULL,liveObj,NULL);
			liveObj->elapsedTime1 = 0.0;
			return;
		}
		if ((trainFlags & TRAINED_DRIVER) != TRAINED_NONE) {
			front::Info_FUN_00419ab0(INFO_TRAINDRIVER,NULL,liveObj,NULL);
			liveObj->elapsedTime1 = 0.0;
			return;
		}
		if ((trainFlags & TRAINED_DYNAMITE) != TRAINED_NONE) {
			front::Info_FUN_00419ab0(INFO_TRAINDYNAMITE,NULL,liveObj,NULL);
			liveObj->elapsedTime1 = 0.0;
			return;
		}
		if ((trainFlags & TRAINED_REPAIR) != TRAINED_NONE) {
			front::Info_FUN_00419ab0(INFO_TRAINREPAIR,NULL,liveObj,NULL);
			liveObj->elapsedTime1 = 0.0;
			return;
		}
		if ((trainFlags & TRAINED_SCANNER) != TRAINED_NONE) {
			front::Info_FUN_00419ab0(INFO_TRAINSCANNER,NULL,liveObj,NULL);
		}
		liveObj->elapsedTime1 = 0.0;
	}
	return;
}



void __cdecl
lego::game::LiveObject_AddDamage2(LiveObject *liveObj,float damage,BOOL param_3,float param_4)
{
	BOOL BVar1;
	ObjectStatsFlags2 OVar2;
	float10 fVar3;
	longlong lVar4;
	longlong lVar5;
	
	BVar1 = LiveObject_CheckCondition_FUN_00438870(liveObj,TRUE);
	if ((BVar1 != 0) && (liveObj->carryingThisObject == NULL)) {
		if ((liveObj->objType == OBJECT_BUILDING) &&
			 ((damage != 0.0 && ((undefined *)liveObj->health == &DAT_42c80000)))) {
			ai::AITask_DoRepair_Target(liveObj,FALSE);
		}
		BVar1 = LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj);
		if (BVar1 != 0) {
			fVar3 = LiveObject_GetHealthDecayRate(liveObj);
			lVar4 = __ftol(fVar3 * (float10)0.04 * (float10)param_4 * (float10)10010.0);
			lVar5 = __ftol((float10)damage * (float10)10000.0);
			if ((uint)lVar4 < (uint)lVar5) {
				nerps::NERPs_AddToFloat_00556330(damage);
			}
		}
		if (liveObj->objType == OBJECT_MINIFIGURE) {
			nerps::NERPs_AddToFloat_00556120(damage);
		}
		liveObj->health = liveObj->health - damage;
		if ((param_3 != 0) &&
			 ((ushort)((ushort)(damage < 0.0) << 8 | (ushort)(damage == 0.0) << 0xe) == 0)) {
			liveObj->flags2 = liveObj->flags2 | (LIVEOBJ2_UNK_1000|LIVEOBJ2_UNK_2000);
			liveObj->field_3d0 = damage + (float)liveObj->field_3d0;
			front::Bubble_LiveObject_FUN_00407470(liveObj);
		}
		OVar2 = LiveObject_GetStatsFlags2(liveObj);
		if (((OVar2 & STATS2_DAMAGECAUSESCALLTOARMS) != STATS2_NONE) &&
			 ((ushort)((ushort)(damage < 0.0) << 8 | (ushort)(damage == 0.0) << 0xe) == 0)) {
			Game_SetCallToArmsOn(TRUE);
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_UnkUpdateEnergyHealth(LiveObject *in_liveObj,float elapsed)
{
	LiveObject *liveObj;
	ObjectStatsFlags2 OVar1;
	LiveObject *liveObj_00;
	uint uVar2;
	int *piVar3;
	float10 fVar4;
	longlong lVar5;
	BOOL BVar6;
	float fVar7;
	float damage;
	void *local_40;
	undefined local_3c [4];
	int local_38;
	int local_34;
	int local_30;
	int local_2c;
	int local_28;
	int local_24;
	int local_20 [5];
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	liveObj = in_liveObj;
	damage = 0.0;
	if ((in_liveObj->objType != OBJECT_UPGRADEPART) && (in_liveObj->objType != OBJECT_BOULDER)) {
		if ((ushort)((ushort)(in_liveObj->health < 0.0) << 8 |
								(ushort)(in_liveObj->health == 0.0) << 0xe) == 0) {
			if ((in_liveObj->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE) {
				BVar6 = 0;
				fVar7 = elapsed;
				fVar4 = LiveObject_GetHealthDecayRate(in_liveObj);
				LiveObject_AddDamage2(liveObj,(float)(fVar4 * (float10)0.04 * (float10)elapsed),BVar6,fVar7)
				;
			}
		}
		else {
			in_liveObj->health = 0.0;
		}
		uVar2 = 0;
		if ((ushort)((ushort)(liveObj->energy < 0.0) << 8 | (ushort)(liveObj->energy == 0.0) << 0xe) ==
				0) {
			if ((liveObj->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE) {
				fVar4 = LiveObject_GetEnergyDecayRate(liveObj);
				liveObj->energy =
						 (float)((float10)liveObj->energy - fVar4 * (float10)0.04 * (float10)elapsed);
			}
		}
		else {
			liveObj->energy = 0.0;
		}
		LiveObject_GetBlockPos(liveObj,&local_38,&local_34);
		if (((liveObj->carryingThisObject == NULL) &&
				((globs::gameGlobs.level)->blocks
				 [((globs::gameGlobs.level)->dimensions).width * local_34 + local_38].terrain ==
				 TERRAIN_LAVA)) &&
			 ((liveObj->objType == OBJECT_ORE || (liveObj->objType == OBJECT_POWERCRYSTAL)))) {
			Level_AddToField9c(1);
			liveObj->health = -1.0;
			liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
		}
		BVar6 = LiveObject_UnkGetDamage(liveObj,local_38,local_34,elapsed,&damage);
		if (BVar6 != 0) {
			LiveObject_AddDamage2(liveObj,damage,1,elapsed);
		}
		OVar1 = LiveObject_GetStatsFlags2(liveObj);
		if ((((OVar1 & STATS2_CANBEHITBYFENCE) != STATS2_NONE) &&
				((liveObj->flags1 & (LIVEOBJ1_UNK_100|LIVEOBJ1_UNK_100000)) == LIVEOBJ1_NONE)) &&
			 ((liveObj->flags2 & LIVEOBJ2_UNK_8000000) == LIVEOBJ2_NONE)) {
			ElectricFence_LiveObject_FUN_0040dd70(liveObj);
		}
		if (((((globs::gameGlobs.flags2 & GAME2_NOAUTOEAT) == GAME2_NONE) &&
				 (liveObj->objType == OBJECT_MINIFIGURE)) &&
				(((liveObj->energy < liveObj->health * 0.01 * globs::gameGlobs.MinEnergyForEat &&
					(((ushort)((ushort)(liveObj->activityElapsedTime < 125.0) << 8 |
										(ushort)(liveObj->activityElapsedTime == 125.0) << 0xe) == 0 &&
					 (liveObj->activityElapsedTime = 0.0, liveObj->drivenObject == NULL)))) &&
				 (BVar6 = ai::AITask_LiveObject_IsCurrentTaskType(liveObj,AITASK_GOTOEAT), BVar6 == 0)))) &&
			 (liveObj_00 = (LiveObject *)FUN_00438f20(liveObj), liveObj_00 != NULL)) {
			local_20[1] = 0xffffffff;
			local_8 = 0xffffffff;
			local_20[0] = 0;
			local_20[2] = 1;
			local_20[3] = 0;
			local_20[4] = 0;
			local_c = 1;
			local_4 = 0;
			LiveObject_GetBlockPos(liveObj,&local_28,&local_24);
			LiveObject_GetBlockPos(liveObj_00,&local_30,&local_2c);
			piVar3 = local_20;
			do {
				BVar6 = LiveObject_FUN_004413b0
													(liveObj,local_28,local_24,local_30 + *piVar3,piVar3[1] + local_2c,
													 &in_liveObj,&local_40,local_3c,0,0);
				if (BVar6 != 0) {
					std::free(in_liveObj);
					std::free(local_40);
					ai::AITask_DoGotoEat_Target(liveObj,liveObj_00);
					break;
				}
				uVar2 += 1;
				piVar3 = piVar3 + 2;
			} while (uVar2 < 4);
		}
		if ((ushort)((ushort)(liveObj->energy < liveObj->health) << 8 |
								(ushort)(liveObj->energy == liveObj->health) << 0xe) == 0) {
			liveObj->energy = liveObj->health;
		}
		LiveObject_MiniFigurePlayHurtSND(liveObj,elapsed,damage);
		if (((liveObj->flags2 & LIVEOBJ2_UNK_2000) != LIVEOBJ2_NONE) &&
			 ((liveObj->flags2 & LIVEOBJ2_UNK_1000) == LIVEOBJ2_NONE)) {
			lVar5 = __ftol((float10)(float)liveObj->field_3d0);
			lego::effect::DamageFont_DisplayDamage_OverLiveObject(liveObj,(uint)lVar5);
			liveObj->field_3d0 = 0;
			liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_2000;
		}
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_1000;
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_MiniFigurePlayHurtSND(LiveObject *in_liveObj,float elapsed,float damage)
{
	float fVar1;
	float fVar2;
	LiveObject *liveObj;
	BOOL BVar3;
	Container *cont;
	float10 fVar4;
	LiveObject *sfxType;
	BOOL sound3D;
	Vector3F *opt_position;
	
	liveObj = in_liveObj;
	if ((in_liveObj->objType == OBJECT_MINIFIGURE) && (damage != 0.0)) {
		BVar3 = snd::SFX_GetType("SND_Hurt",(SFXType *)&in_liveObj);
		if (BVar3 != 0) {
			if (liveObj->floatSnd_3fc == 0.0) {
				opt_position = NULL;
				sound3D = TRUE;
				BVar3 = FALSE;
				sfxType = in_liveObj;
				cont = LiveObject_GetContainer(liveObj);
				res::SFX_Sample_Container_Random_Play_OrInitSoundUnk
									(cont,(SFXType)sfxType,BVar3,sound3D,opt_position);
				liveObj->floatSnd_3fc = elapsed + liveObj->floatSnd_3fc;
				fVar4 = snd::SFX_Sample_Random_GetSamplePlayTime((SFXType)in_liveObj);
				liveObj->floatSnd_400 = (float)fVar4;
			}
			else {
				fVar1 = liveObj->floatSnd_3fc - elapsed * -0.04;
				fVar2 = liveObj->floatSnd_400 + liveObj->floatSnd_400;
				liveObj->floatSnd_3fc = fVar1;
				if ((ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) == 0) {
					liveObj->floatSnd_3fc = 0.0;
					liveObj->floatSnd_400 = 0.0;
					return TRUE;
				}
			}
		}
	}
	return TRUE;
}



BOOL __cdecl lego::game::LiveObject_FUN_0043fee0(LiveObject *carriedObj)
{
	LiveObject *liveObj;
	Container *pCVar1;
	SurfaceMap *surfMap;
	BOOL BVar2;
	int iVar3;
	Container *cont;
	float in_x;
	float in_y;
	int *out_bx;
	int *out_by;
	int local_2c;
	int local_28;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	liveObj = carriedObj->carryingThisObject;
	if (liveObj != NULL) {
		pCVar1 = LiveObject_GetDepositNull(liveObj);
		if (pCVar1 != NULL) {
			res::Container_GetPosition(pCVar1,NULL,&local_24);
			out_by = &local_28;
			out_bx = &local_2c;
			in_x = local_24.x;
			in_y = local_24.y;
			surfMap = GetSurfaceMap();
			BVar2 = Map3D_WorldToBlockPos_NoZ(surfMap,in_x,in_y,out_bx,out_by);
			if (BVar2 != 0) {
				iVar3 = LiveObject_FUN_00431cd0(carriedObj,local_2c,local_28,local_2c,local_28,0);
				if (iVar3 != 0) {
					pCVar1 = LiveObject_GetContainer(carriedObj);
					if (pCVar1 != NULL) {
						cont = LiveObject_GetContainer(liveObj);
						if (cont != NULL) {
							carriedObj->carryingThisObject = NULL;
							liveObj->carriedObjects[0] = NULL;
							liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CARRYING;
							liveObj->numCarriedObjects = 0;
							res::Container_GetPosition(cont,NULL,&local_24);
							res::Container_GetOrientation(cont,NULL,&local_c,&local_18);
							res::Container_SetPosition(pCVar1,NULL,local_24.x,local_24.y,local_24.z);
							res::Container_SetOrientation
												(pCVar1,NULL,local_c.x,local_c.y,local_c.z,local_18.x,local_18.y,local_18.z)
							;
							LiveObject_FUN_00437690(liveObj,1);
							ai::AITask_DoAnimationWait(liveObj);
							LiveObject_SetActivityUnk(carriedObj,ACTIVITY_FLOATOFF,0);
							LiveObject_Container_ActivityUpdate_Check(carriedObj);
							ai::AITask_DoAnimationWait(carriedObj);
							carriedObj->object_2fc = liveObj;
							carriedObj->flags4 = carriedObj->flags4 | LIVEOBJ4_UNK_8000;
							return 1;
						}
					}
				}
			}
		}
	}
	return 0;
}



undefined4 __cdecl FUN_00440080(int *param_1)
{
	ObjectStatsFlags3 OVar1;
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar2;
	int iVar3;
	int *out_bx;
	int *out_by;
	int local_14;
	int local_10;
	Vector3F local_c;
	
	OVar1 = lego::game::LiveObject_GetStatsFlags3((LiveObject *)param_1);
	if (((((OVar1 & STATS3_CARRYVEHICLES) != STATS3_NONE) && ((param_1[0xf8] & 0x400U) != 0)) &&
			((int *)param_1[0xc2] != NULL)) && (*(int *)param_1[0xc2] == 1)) {
		cont = lego::game::LiveObject_GetDepositNull((LiveObject *)param_1);
		if (cont != NULL) {
			lego::res::Container_GetPosition(cont,NULL,&local_c);
			out_by = &local_10;
			out_bx = &local_14;
			surfMap = lego::game::GetSurfaceMap();
			BVar2 = lego::game::Map3D_WorldToBlockPos_NoZ(surfMap,local_c.x,local_c.y,out_bx,out_by);
			if (BVar2 != 0) {
				iVar3 = lego::game::LiveObject_FUN_00431cd0
													((LiveObject *)param_1[0xc2],local_14,local_10,local_14,local_10,1);
				if (iVar3 != 0) {
					return 1;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_TryFindLoad_FUN_00440130(LiveObject *in_liveObj,LiveObject *targetObj)
{
	LiveObject *liveObj;
	LiveObject *liveObj_00;
	ObjectStatsFlags3 OVar1;
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar2;
	BOOL BVar3;
	float *out_bx;
	float *out_by;
	uint local_20;
	float local_1c;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	BVar3 = 0;
	OVar1 = LiveObject_GetStatsFlags3(in_liveObj);
	liveObj_00 = targetObj;
	if ((OVar1 & STATS3_VEHICLECANBECARRIED) != STATS3_NONE) {
		OVar1 = LiveObject_GetStatsFlags3(targetObj);
		if (((OVar1 & STATS3_CARRYVEHICLES) != STATS3_NONE) && (liveObj->carryingThisObject == NULL)) {
			LiveObject_GetBlockPos(liveObj,(int *)&local_14,(int *)&local_10);
			cont = LiveObject_GetDepositNull(liveObj_00);
			if (cont != NULL) {
				res::Container_GetPosition(cont,NULL,&local_c);
				out_by = &local_18;
				out_bx = &local_1c;
				surfMap = GetSurfaceMap();
				BVar2 = Map3D_WorldToBlockPos_NoZ(surfMap,local_c.x,local_c.y,(int *)out_bx,(int *)out_by);
				if (BVar2 != 0) {
					if ((local_1c == local_14) && (local_18 == local_10)) {
						BVar3 = LiveObject_FUN_004419c0(liveObj,1,&local_1c,&local_18,(float *)&local_c);
					}
					else {
						BVar3 = LiveObject_FUN_004413b0
															(liveObj,local_14,local_10,local_1c,local_18,&in_liveObj,&targetObj,
															 &local_20,0,0);
						if (BVar3 == 0) {
							return 0;
						}
						BVar3 = LiveObject_FUN_004419c0
															(liveObj,local_20,(float *)in_liveObj,(float *)targetObj,
															 (float *)&local_c);
						std::free(in_liveObj);
						std::free(targetObj);
					}
					if (BVar3 != 0) {
						liveObj->object_2fc = liveObj_00;
						*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) =
								 0x15;
						LiveObject_FUN_00437690(liveObj_00,1);
						return TRUE;
					}
				}
			}
		}
	}
	return BVar3;
}



BOOL __cdecl lego::game::LiveObject_TryDock_FUN_004402b0(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	LiveObject *liveObj_00;
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar1;
	float *out_bx;
	float *out_by;
	float *local_24;
	uint local_20;
	float local_1c;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	LiveObject_GetBlockPos(in_liveObj,(int *)&local_14,(int *)&local_10);
	liveObj_00 = (LiveObject *)LiveObject_FUN_00438ca0(liveObj,TRUE);
	if ((liveObj_00 != NULL) && (cont = LiveObject_GetDepositNull(liveObj_00), cont != NULL)) {
		res::Container_GetPosition(cont,NULL,&local_c);
		out_by = &local_18;
		out_bx = &local_1c;
		surfMap = GetSurfaceMap();
		BVar1 = Map3D_WorldToBlockPos_NoZ(surfMap,local_c.x,local_c.y,(int *)out_bx,(int *)out_by);
		if (BVar1 != 0) {
			if ((local_1c == local_14) && (local_18 == local_10)) {
				BVar1 = LiveObject_FUN_004419c0(liveObj,1,&local_1c,&local_18,(float *)&local_c);
			}
			else {
				BVar1 = LiveObject_FUN_004413b0
													(liveObj,local_14,local_10,local_1c,local_18,&in_liveObj,&local_24,
													 &local_20,0,0);
				if (BVar1 == 0) {
					return 0;
				}
				BVar1 = LiveObject_FUN_004419c0
													(liveObj,local_20,(float *)in_liveObj,local_24,(float *)&local_c);
				std::free(in_liveObj);
				std::free(local_24);
			}
			if (BVar1 != 0) {
				liveObj->object_2fc = liveObj_00;
				*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 0x13;
				return TRUE;
			}
		}
	}
	return 0;
}



void __cdecl FUN_004403f0(int param_1,int *param_2)
{
	LiveObject *liveObj;
	uint uVar1;
	LiveObject **ppLVar2;
	int local_8;
	int local_4;
	
	uVar1 = 0;
	if (lego::globs::liveGlobs.uintCount_c5cc != 0) {
		ppLVar2 = lego::globs::liveGlobs.liveObjArray100_c43c;
		do {
			liveObj = *ppLVar2;
			if (((liveObj != NULL) &&
					(lego::game::LiveObject_GetBlockPos(liveObj,&local_8,&local_4), local_8 == *param_2)) &&
				 (local_4 == param_2[1])) {
				liveObj->object_2fc = (LiveObject *)param_1;
				FUN_00444360(liveObj);
				*ppLVar2 = NULL;
			}
			uVar1 += 1;
			ppLVar2 = ppLVar2 + 1;
		} while (uVar1 < lego::globs::liveGlobs.uintCount_c5cc);
	}
	return;
}



BOOL __cdecl FUN_00440470(LiveObject *in_liveObj,int param_2)
{
	LiveObject *liveObj;
	LiveObject *pLVar1;
	ObjectStatsFlags1 OVar2;
	Container *pCVar3;
	Container *cont;
	SurfaceMap *pSVar4;
	BOOL BVar5;
	int iVar6;
	float10 fVar7;
	float fVar8;
	float fVar9;
	int *out_bx;
	Vector3F *out_x;
	int *out_by;
	float *out_y;
	int local_28;
	int local_24;
	uint local_20;
	uint local_1c;
	Vector3F local_18;
	Vector3F local_c;
	
	liveObj = in_liveObj->drivenObject;
	OVar2 = lego::game::LiveObject_GetStatsFlags1(in_liveObj);
	if ((OVar2 & STATS1_CANBEDRIVEN) == STATS1_NONE) {
		return 0;
	}
	if (liveObj == NULL) {
		return 0;
	}
	if ((*(byte *)&liveObj->flags1 & 1) != 0) {
		return 0;
	}
	pCVar3 = lego::game::LiveObject_GetDepositNull(in_liveObj);
	cont = lego::game::LiveObject_GetContainer(liveObj);
	lego::res::Container_GetPosition(pCVar3,NULL,&local_18);
	out_by = &local_24;
	out_bx = &local_28;
	fVar8 = local_18.x;
	fVar9 = local_18.y;
	pSVar4 = lego::game::GetSurfaceMap();
	BVar5 = lego::game::Map3D_WorldToBlockPos_NoZ(pSVar4,fVar8,fVar9,out_bx,out_by);
	if (BVar5 == 0) {
		return 0;
	}
	OVar2 = lego::game::LiveObject_GetStatsFlags1(in_liveObj);
	if (((OVar2 & STATS1_CROSSLAND) != STATS1_NONE) &&
		 (iVar6 = lego::game::LiveObject_FUN_00431cd0(liveObj,local_28,local_24,local_28,local_24,1),
		 iVar6 != 0)) {
LAB_004405c7:
		in_liveObj->drivenObject = NULL;
		liveObj->drivenObject = NULL;
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_DRIVING;
		fVar8 = local_18.x;
		fVar9 = local_18.y;
		pSVar4 = lego::game::GetSurfaceMap();
		fVar7 = lego::game::Map3D_GetWorldZ(pSVar4,fVar8,fVar9);
		lego::res::Container_SetPosition(cont,NULL,local_18.x,local_18.y,(float)fVar7);
		lego::res::Container_SetOrientation(cont,NULL,local_c.x,local_c.y,0.0,0.0,0.0,-1.0);
		lego::game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		liveObj->aitaskName2 = NULL;
		lego::game::LiveObject_Container_ActivityUpdate_Check(liveObj);
		lego::game::Message_PTL_Deselect_LiveObject(in_liveObj);
		return 1;
	}
	if ((*(byte *)&in_liveObj->flags4 & 0x40) == 0) {
		if ((param_2 == 0) && (iVar6 = FUN_0043a0d0(in_liveObj,&local_20), iVar6 != 0)) {
			out_y = &local_18.y;
			out_x = &local_18;
			pSVar4 = lego::game::GetSurfaceMap();
			lego::game::Map3D_BlockToWorldPos(pSVar4,local_20,local_1c,(float *)out_x,out_y);
			goto LAB_004405c7;
		}
		OVar2 = lego::game::LiveObject_GetStatsFlags1(in_liveObj);
		if ((OVar2 & STATS1_CROSSLAND) == STATS1_NONE) {
			lego::ai::AITask_DoDock(in_liveObj);
		}
	}
	else {
		pLVar1 = in_liveObj->object_2fc;
		if (((pLVar1 != NULL) && (pLVar1->objType == OBJECT_BUILDING)) &&
			 (pCVar3 = lego::res::Building_GetEntranceNull(pLVar1->building), pCVar3 != NULL)) {
			lego::res::Container_GetPosition(pCVar3,NULL,&local_18);
			lego::res::Container_GetOrientation(pCVar3,NULL,&local_c,NULL);
			goto LAB_004405c7;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_TryFindDriver_FUN_00440690(LiveObject *in_liveObj,LiveObject *targetObj)
{
	byte *pbVar1;
	AITaskData *pAVar2;
	LiveObject *pLVar3;
	LiveObject *liveObj;
	LiveObject *liveObj_00;
	ObjectStatsFlags1 OVar4;
	SurfaceMap *pSVar5;
	BOOL BVar6;
	byte bVar7;
	Container *cont;
	float *pfVar8;
	float *pfVar9;
	uint local_44;
	uint local_40;
	uint local_3c;
	uint local_38;
	float local_34;
	float local_30;
	float local_2c;
	float local_28;
	Vector3F local_24;
	Vector3F local_18;
	float local_c;
	float local_8 [2];
	
	liveObj_00 = targetObj;
	liveObj = in_liveObj;
	cont = NULL;
	pAVar2 = in_liveObj->aitask_2f0;
	if (pAVar2 != NULL) {
		if (pAVar2->taskType != AITASK_FINDDRIVER) {
			return 0;
		}
		if (pAVar2->next != NULL) {
			return 0;
		}
	}
	if (in_liveObj->drivenObject != NULL) {
		return 0;
	}
	if (targetObj->drivenObject != NULL) {
		return 0;
	}
	if (in_liveObj->objType != OBJECT_MINIFIGURE) {
		return 0;
	}
	if (((((in_liveObj->flags5_3f0 & (LIVEOBJ5_ABILITY_PILOT|LIVEOBJ5_ABILITY_DRIVER)) ==
				 LIVEOBJ5_NONE) ||
			 (OVar4 = LiveObject_GetStatsFlags1(targetObj), (OVar4 & STATS1_CROSSLAND) == STATS1_NONE)) ||
			(OVar4 = LiveObject_GetStatsFlags1(liveObj_00), (OVar4 & STATS1_CANBEDRIVEN) == STATS1_NONE))
		 || ((*(byte *)&liveObj_00->flags4 & 0x40) != 0)) {
		if ((*(byte *)&liveObj->flags5_3f0 & 2) != 0) {
			OVar4 = LiveObject_GetStatsFlags1(liveObj_00);
			if ((((OVar4 & STATS1_CANBEDRIVEN) == STATS1_NONE) ||
					((*(byte *)&liveObj_00->flags4 & 0x40) == 0)) ||
				 ((pLVar3 = liveObj_00->object_2fc, pLVar3 == NULL || (pLVar3->objType != OBJECT_BUILDING)))
				 ) {
				if ((((*(byte *)&liveObj->flags5_3f0 & 2) != 0) &&
						(OVar4 = LiveObject_GetStatsFlags1(liveObj_00),
						(OVar4 & STATS1_CANBEDRIVEN) != STATS1_NONE)) &&
					 (BVar6 = LiveObject_CheckUnkGetInAtLand_FUN_0043a100(liveObj_00,NULL), BVar6 != 0)) {
					LiveObject_GetBlockPos(liveObj_00,(int *)&local_40,(int *)&local_44);
					BVar6 = LiveObject_FUN_00446c80(liveObj,local_40,local_44,0,&local_3c,1);
					if (BVar6 != 0) {
						*(undefined4 *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -8) =
								 0x3f000000;
						*(undefined4 *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -0xc) =
								 0x3f000000;
						switch(local_3c) {
						case 0:
							*(undefined4 *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -8) =
									 0x3dcccccd;
							break;
						case 1:
							*(undefined4 *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -0xc)
									 = 0x3dcccccd;
							break;
						case 2:
							*(undefined4 *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -8) =
									 0x3f666666;
							break;
						case 3:
							*(undefined4 *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -0xc)
									 = 0x3f666666;
						}
						*(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) =
								 *(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) | 8;
						*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) =
								 0xc;
						liveObj->object_2fc = liveObj_00;
						return 1;
					}
				}
			}
			else {
				cont = res::Building_GetEntranceNull(pLVar3->building);
			}
		}
	}
	else {
		cont = LiveObject_GetContainer(liveObj_00);
	}
	if (cont != NULL) {
		res::Container_GetPosition(cont,NULL,&local_18);
		res::Container_GetOrientation(cont,NULL,&local_24,NULL);
		if (ABS(local_24.x) <= ABS(local_24.y)) {
			if ((ushort)((ushort)(local_24.y < 0.0) << 8 | (ushort)(local_24.y == 0.0) << 0xe) == 0) {
				bVar7 = 0;
			}
			else {
				bVar7 = 2;
			}
		}
		else {
			if ((ushort)((ushort)(local_24.x < 0.0) << 8 | (ushort)(local_24.x == 0.0) << 0xe) == 0) {
				bVar7 = 1;
			}
			else {
				bVar7 = 3;
			}
		}
		pfVar9 = &local_30;
		pfVar8 = &local_34;
		pSVar5 = GetSurfaceMap();
		Map3D_WorldToBlockPos_NoZ(pSVar5,local_18.x,local_18.y,(int *)pfVar8,(int *)pfVar9);
		LiveObject_GetPosition(liveObj,&local_c,local_8);
		pfVar9 = &local_28;
		pfVar8 = &local_2c;
		pSVar5 = GetSurfaceMap();
		Map3D_WorldToBlockPos_NoZ(pSVar5,local_c,local_8[0],(int *)pfVar8,(int *)pfVar9);
		if ((local_2c == local_34) && (local_28 == local_30)) {
			BVar6 = LiveObject_FUN_004419c0(liveObj,1,&local_34,&local_30,(float *)&local_18);
		}
		else {
			BVar6 = LiveObject_FUN_004413b0
												(liveObj,local_2c,local_28,local_34,local_30,&in_liveObj,&targetObj,
												 &local_38,0,0);
			if (BVar6 == 0) {
				return 0;
			}
			BVar6 = LiveObject_FUN_004419c0
												(liveObj,local_38,(float *)in_liveObj,(float *)targetObj,(float *)&local_18)
			;
			std::free(in_liveObj);
			std::free(targetObj);
		}
		if (BVar6 != 0) {
			liveObj->object_2fc = liveObj_00;
			*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 0xc;
			*(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) =
					 *(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) | 4;
			pbVar1 = (byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4);
			*pbVar1 = *pbVar1 | bVar7;
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::Game_DoDynamiteExplosionCallbacks
					(LiveObject *liveObj,float damageRadius,float maxDamage,float wakeRadius)
{
	BOOL BVar1;
	SearchDynamiteRadius searchDynamite;
	
	searchDynamite.liveObj = liveObj;
	LiveObject_GetPosition(liveObj,(float *)&searchDynamite.position,&searchDynamite.position.y);
	searchDynamite.damageRadius = damageRadius;
	searchDynamite.maxDamage = maxDamage;
	searchDynamite.wakeRadius = wakeRadius;
	BVar1 = Search_LiveObjects_SkipIgnoreMes
										(LiveObject_Callback_DynamiteRadius,(undefined4 *)&searchDynamite);
	return BVar1;
}



// Affect live objects within the radius of an exploding dynamite object

BOOL __cdecl
lego::game::LiveObject_Callback_DynamiteRadius(LiveObject *liveObj,SearchDynamiteRadius *search)
{
	float fVar1;
	float fVar2;
	Point2F distance;
	
	if ((liveObj != search->liveObj) && ((liveObj->flags3 & LIVEOBJ3_UNK_40000) != LIVEOBJ3_NONE)) {
		LiveObject_GetPosition(liveObj,(float *)&distance,&distance.y);
		fVar2 = distance.y - (search->position).y;
		fVar1 = distance.x - (search->position).x;
		fVar1 = SQRT(fVar1 * fVar1 + fVar2 * fVar2);
		if (fVar1 < search->damageRadius) {
			LiveObject_AddDamage2
								(liveObj,(1.0 - fVar1 / search->damageRadius) * search->maxDamage,TRUE,1.0);
		}
		if ((liveObj->objType == OBJECT_ROCKMONSTER) && (fVar1 < search->wakeRadius)) {
			LiveObject_RockMonster_DoWakeUp(liveObj);
		}
	}
	return 0;
}



void __cdecl
lego::game::Game_DoBirdScarerRadiusCallbacks_FUN_00440b80
					(LiveObject *optor_liveObj,Point2F *optor_position,float radius)
{
	LiveObject *local_18;
	float local_14;
	float local_10;
	float local_c;
	
	local_18 = optor_liveObj;
	if (optor_position == NULL) {
		LiveObject_GetPosition(optor_liveObj,&local_14,&local_10);
	}
	else {
		local_14 = optor_position->x;
		local_10 = optor_position->y;
	}
	local_c = radius;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_CallbackProc_FUN_00440be0,&local_18);
	return;
}



BOOL __cdecl
lego::game::LiveObject_CallbackProc_FUN_00440be0(LiveObject *liveObj,LiveObject **search)
{
	float fVar1;
	ObjectStatsFlags2 OVar2;
	Point2F local_10;
	float local_8;
	float local_4;
	
	if (liveObj != *search) {
		OVar2 = LiveObject_GetStatsFlags2(liveObj);
		if ((OVar2 & STATS2_SCAREDBYBIGBANGS) != STATS2_NONE) {
			LiveObject_GetPosition(liveObj,&local_8,&local_4);
			local_10.x = local_8 - (float)search[1];
			local_10.y = local_4 - (float)search[2];
			fVar1 = SQRT(local_10.y * local_10.y + local_10.x * local_10.x);
			if (fVar1 < (float)search[3]) {
				if (liveObj->objType == OBJECT_ROCKMONSTER) {
					LiveObject_RockMonster_DoWakeUp(liveObj);
				}
				fVar1 = 1.0 / fVar1;
				local_10.x = fVar1 * local_10.x;
				local_10.y = fVar1 * local_10.y;
				LiveObject_FUN_00444720(liveObj,&local_10);
			}
		}
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_SetActivityUnk(LiveObject *liveObj,ActivityType actType,BOOL unkbool2d8)
{
	liveObj->aitaskName1 = globs::liveGlobs.Activities_TABLE[actType];
	liveObj->unkbool_2d8 = unkbool2d8;
	liveObj->float_2d4 = 0.0;
	return;
}



void __cdecl lego::game::LiveObject_UpdateCarrying(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	ObjectType OVar1;
	float fVar2;
	float fVar3;
	LiveObject *pLVar4;
	int iVar5;
	Container *cont;
	VehicleData *vehicle;
	LiveObject **local_14;
	uint local_10;
	Vector3F local_c;
	
	local_10 = 0;
	if (in_liveObj->numCarriedObjects != 0) {
		local_14 = in_liveObj->carriedObjects;
		pLVar4 = in_liveObj;
		do {
			liveObj = *local_14;
			if ((liveObj->flags3 & LIVEOBJ3_UNK_2000) == LIVEOBJ3_NONE) {
				OVar1 = in_liveObj->objType;
				if (OVar1 == OBJECT_ROCKMONSTER) {
					pLVar4 = (LiveObject *)res::Creature_GetCarryNull(in_liveObj->rockMonster);
				}
				else {
					if (OVar1 == OBJECT_MINIFIGURE) {
						pLVar4 = in_liveObj->drivenObject;
						if ((pLVar4 == NULL) || (pLVar4->objType != OBJECT_VEHICLE)) {
							pLVar4 = (LiveObject *)res::Creature_GetCarryNull(in_liveObj->miniFigure);
						}
						else {
							iVar5 = LiveObject_GetCarryStart(pLVar4);
							vehicle = in_liveObj->drivenObject->vehicle;
LAB_00440d93:
							pLVar4 = (LiveObject *)res::Vehicle_GetCarryNull(vehicle,iVar5);
						}
					}
					else {
						if (OVar1 == OBJECT_BUILDING) {
							pLVar4 = (LiveObject *)
											 res::Building_GetCarryNull
																 (in_liveObj->building,(int)liveObj->carriedObjects[6]);
						}
						else {
							if (OVar1 == OBJECT_VEHICLE) {
								iVar5 = LiveObject_GetCarryStart(in_liveObj);
								vehicle = in_liveObj->vehicle;
								iVar5 = (int)liveObj->carriedObjects[6]->routing_points_4 + iVar5 + -0x34;
								goto LAB_00440d93;
							}
						}
					}
				}
				if (pLVar4 != NULL) {
					cont = LiveObject_GetContainer(liveObj);
					res::Container_GetPosition(cont,NULL,&liveObj->vector_2a0);
					res::Container_SetPosition(cont,(Container *)pLVar4,0.0,0.0,0.0);
					res::Container_SetOrientation(cont,(Container *)pLVar4,0.0,0.0,1.0,0.0,1.0,0.0);
					res::Container_GetPosition(cont,NULL,&local_c);
					local_c.x = local_c.x - (liveObj->vector_2a0).x;
					local_c.y = local_c.y - (liveObj->vector_2a0).y;
					local_c.z = local_c.z - (liveObj->vector_2a0).z;
					fVar2 = SQRT(local_c.z * local_c.z + local_c.y * local_c.y + local_c.x * local_c.x);
					fVar3 = 1.0 / fVar2;
					liveObj->float_2b8 = fVar2;
					(liveObj->faceDirection).x = fVar3 * local_c.x;
					(liveObj->faceDirection).y = fVar3 * local_c.y;
					(liveObj->faceDirection).z = fVar3 * local_c.z;
				}
			}
			local_10 += 1;
			local_14 = local_14 + 1;
		} while (local_10 < in_liveObj->numCarriedObjects);
	}
	return;
}



void __cdecl
lego::game::LiveObject_InitBoulderMesh_FUN_00440eb0
					(LiveObject *liveObj,Container_Texture *contTexture)
{
	D3DRMGroupIndex DVar1;
	D3DRMGroupIndex groupID;
	
	if (liveObj->objType == OBJECT_BOULDER) {
		DVar1 = res::Container_Mesh_GetGroupCount(liveObj->other);
		groupID = D3DRMGROUP_0;
		if (DVar1 != D3DRMGROUP_0) {
			do {
				res::Container_Mesh_SetTexture(liveObj->other,groupID,contTexture);
				groupID += 1;
			} while (groupID < DVar1);
		}
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_FUN_00440ef0
					(LiveObject *liveObj,undefined4 param_2,undefined4 param_3,undefined4 param_4,
					undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_FUN_004413b0
										(liveObj,param_2,param_3,param_4,param_5,param_6,param_7,param_8,0,0);
	return BVar1;
}



BOOL __cdecl
lego::game::LiveObject_FUN_00440f30
					(LiveObject *liveObj,uint param_2,uint param_3,uint param_4,uint param_5,uint **param_6,
					uint **param_7,uint *param_8,undefined *param_9,undefined4 param_10)
{
	uint uVar1;
	uint uVar2;
	uint uVar3;
	SurfaceMap *pSVar4;
	int iVar5;
	int iVar6;
	uint uVar7;
	uint *puVar8;
	uint *puVar9;
	int iVar10;
	void *pvVar11;
	uint uVar12;
	uint uVar13;
	undefined4 *puVar14;
	uint uVar15;
	uint *local_ff0;
	uint local_fec;
	uint *local_fe8;
	uint local_fe4;
	uint local_fe0;
	uint local_fdc;
	uint local_fd0 [4];
	uint local_fc0 [9];
	uint local_f9c;
	
	local_fc0[0] = 0;
	local_fc0[1] = 0xffffffff;
	local_fc0[2] = 1;
	local_fc0[3] = 0;
	local_fc0[4] = 0;
	local_fc0[5] = 1;
	local_fc0[6] = 0xffffffff;
	local_fc0[7] = 0;
	local_fec = 0;
	pSVar4 = GetSurfaceMap();
	uVar1 = (pSVar4->smallDimensions).width;
	uVar2 = (pSVar4->smallDimensions).height;
	if (uVar1 <= param_2) {
		return 0;
	}
	if (uVar2 <= param_3) {
		return 0;
	}
	if (param_9 == NULL) {
		if (uVar1 <= param_4) {
			return 0;
		}
		if (uVar2 <= param_5) {
			return 0;
		}
		iVar5 = LiveObject_FUN_00431cd0(liveObj,param_4,param_5,param_4,param_5,0);
		if (iVar5 == 0) {
			return 0;
		}
	}
	if (globs::liveGlobs.UnkSurfaceGrid_2_TABLE != NULL) {
		if (globs::liveGlobs.UnkSurfaceGrid_COUNT == uVar2 * uVar1) goto LAB_00441021;
		if (globs::liveGlobs.UnkSurfaceGrid_2_TABLE != NULL) {
			std::free(globs::liveGlobs.UnkSurfaceGrid_2_TABLE);
		}
	}
	globs::liveGlobs.UnkSurfaceGrid_COUNT = uVar2 * uVar1;
	globs::liveGlobs.UnkSurfaceGrid_2_TABLE = std::malloc(globs::liveGlobs.UnkSurfaceGrid_COUNT * 4);
LAB_00441021:
	iVar5 = uVar2 * uVar1;
	puVar14 = (undefined4 *)globs::liveGlobs.UnkSurfaceGrid_2_TABLE;
	if (globs::liveGlobs.UnkSurfaceGrid_2_TABLE != NULL) {
		for (; iVar5 != 0; iVar5 += -1) {
			*puVar14 = 0;
			puVar14 = puVar14 + 1;
		}
		local_fe4 = 0;
		local_f9c = param_3;
		*(undefined4 *)((int)globs::liveGlobs.UnkSurfaceGrid_2_TABLE + (uVar1 * param_3 + param_2) * 4)
				 = 1;
		local_ff0 = local_fd0;
		local_fc0[8] = param_2;
		local_fd0[0] = 1;
		local_fd0[1] = 0;
		uVar12 = 1;
		do {
			local_fe0 = uVar12;
			uVar12 = local_fe0 + 1;
			local_fdc = 0;
			if (*local_ff0 != 0) {
				iVar5 = 0;
				local_fe8 = local_fc0 + local_fe4 * 500 + 9;
				while( true ) {
					do {
						uVar13 = local_fe8[-1];
						uVar15 = *local_fe8;
						if (iVar5 == 0) {
							uVar15 -= 1;
						}
						else {
							if (iVar5 == 1) {
								uVar13 += 1;
							}
							else {
								if (iVar5 == 2) {
									uVar15 += 1;
								}
								else {
									if (iVar5 == 3) {
										uVar13 -= 1;
									}
								}
							}
						}
						if ((uVar13 < uVar1) && (uVar15 < uVar2)) {
							iVar6 = LiveObject_FUN_00431cd0
																(liveObj,uVar13,uVar15,local_fc0[iVar5 * 2] + uVar13,
																 local_fc0[iVar5 * 2 + 1] + uVar15,0);
							iVar10 = uVar15 * uVar1 + uVar13;
							if ((*(int *)((int)globs::liveGlobs.UnkSurfaceGrid_2_TABLE + iVar10 * 4) == 0) &&
								 (iVar6 != 0)) {
								uVar7 = (uint)(local_fe4 == 0);
								uVar3 = local_fd0[uVar7];
								iVar6 = uVar3 + uVar7 * 100;
								local_fc0[iVar6 * 5 + 8] = uVar13;
								local_fc0[iVar6 * 5 + 9] = uVar15;
								local_fd0[uVar7] = uVar3 + 1;
								*(uint *)((int)globs::liveGlobs.UnkSurfaceGrid_2_TABLE + iVar10 * 4) = uVar12;
								if (param_9 == NULL) {
									if ((uVar13 == param_4) && (uVar15 == param_5)) {
										local_fec = 1;
									}
								}
								else {
									local_fd0[2] = uVar13;
									local_fd0[3] = uVar15;
									iVar6 = (*(code *)param_9)(liveObj,local_fd0 + 2,param_10);
									if (iVar6 != 0) {
										local_fec = 1;
										param_4 = uVar13;
										param_5 = uVar15;
									}
								}
							}
						}
						iVar5 += 1;
					} while (iVar5 < 4);
					local_fdc += 1;
					local_fe8 = local_fe8 + 5;
					if (*local_ff0 <= local_fdc) break;
					iVar5 = 0;
				}
			}
			iVar5 = 0;
			*local_ff0 = 0;
			local_fe4 = (uint)(local_fe4 == 0);
			local_ff0 = local_fd0 + local_fe4;
			if (local_fd0[local_fe4] == 0) {
				local_fec = -1;
			}
		} while (local_fec == 0);
		if (local_fec == -1) {
			return 0;
		}
		local_fd0[0] = uVar12;
		puVar8 = (uint *)std::malloc(uVar12 * 4);
		if ((puVar8 != NULL) && (puVar9 = (uint *)std::malloc(uVar12 * 4), puVar9 != NULL)) {
			local_fec = param_5;
			local_ff0 = puVar9 + local_fe0;
			puVar8[local_fe0] = param_4;
			*local_ff0 = param_5;
			*puVar8 = param_2;
			*puVar9 = param_3;
			if (local_fe0 != 1) {
				pvVar11 = globs::liveGlobs.UnkSurfaceGrid_2_TABLE;
				do {
					local_fdc = 0;
					uVar12 = param_5;
					do {
						uVar13 = param_4;
						if (iVar5 == 0) {
							param_5 = uVar12 - 1;
						}
						else {
							param_5 = uVar12;
							if (iVar5 == 1) {
								uVar13 = param_4 + 1;
							}
							else {
								if (iVar5 == 2) {
									param_5 = uVar12 + 1;
								}
								else {
									if (iVar5 == 3) {
										uVar13 = param_4 - 1;
									}
								}
							}
						}
						if (((uVar13 < uVar1) && (param_5 < uVar2)) &&
							 (uVar12 = local_fec,
							 *(uint *)((int)pvVar11 + (param_5 * uVar1 + uVar13) * 4) == local_fe0)) {
							*(uint *)((int)puVar8 + (-4 - (int)puVar9) + (int)local_ff0) = uVar13;
							local_ff0[-1] = param_5;
							pvVar11 = globs::liveGlobs.UnkSurfaceGrid_2_TABLE;
							param_4 = uVar13;
							local_fec = param_5;
							break;
						}
						param_5 = uVar12;
						iVar5 += 1;
						if (3 < iVar5) {
							iVar5 = 0;
						}
						local_fdc += 1;
						uVar12 = param_5;
					} while ((int)local_fdc < 4);
					local_fe0 -= 1;
					local_ff0 = local_ff0 + -1;
				} while (local_fe0 != 1);
			}
			*param_6 = puVar8;
			*param_7 = puVar9;
			*param_8 = local_fd0[0];
		}
	}
	return TRUE;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

BOOL __cdecl
lego::game::LiveObject_FUN_004413b0
					(LiveObject *liveObj,uint bx,uint by,uint param_4,uint param_5,uint **param_6,
					uint **param_7,float *param_8,code *callback,undefined4 param_10)
{
	float *pfVar1;
	float fVar2;
	float fVar3;
	int iVar4;
	float fVar5;
	bool bVar6;
	SurfaceMap *pSVar7;
	int iVar8;
	BOOL BVar9;
	uint uVar10;
	uint *puVar11;
	uint *buffer;
	uint uVar12;
	uint uVar13;
	uint uVar14;
	uint uVar15;
	undefined4 *puVar16;
	uint uVar17;
	int iStack4108;
	uint *puStack4104;
	uint uStack4096;
	float fStack4092;
	float fStack4088;
	uint *puStack4080;
	int iStack4076;
	uint uStack4068;
	uint auStack4060 [2];
	float fStack4052;
	Point2I PStack4048;
	Point2I PStack4040;
	int aiStack4032 [4];
	undefined4 uStack4016;
	undefined4 uStack4012;
	undefined4 uStack4008;
	undefined4 uStack4004;
	uint auStack4000 [999];
	undefined4 uStack4;
	
	uStack4 = 0x4413ba;
	aiStack4032[0] = 0;
	aiStack4032[1] = 0xffffffff;
	aiStack4032[2] = 1;
	aiStack4032[3] = 0;
	uStack4016 = 0;
	uStack4012 = 1;
	uStack4008 = 0xffffffff;
	uStack4004 = 0;
	iStack4076 = 0;
	bVar6 = false;
	pSVar7 = GetSurfaceMap();
	uVar12 = (pSVar7->smallDimensions).width;
	uVar13 = (pSVar7->smallDimensions).height;
	if (uVar12 <= bx) {
		return 0;
	}
	if (uVar13 <= by) {
		return 0;
	}
	if (callback == NULL) {
		if (uVar12 <= param_4) {
			return 0;
		}
		if (uVar13 <= param_5) {
			return 0;
		}
		iVar8 = LiveObject_FUN_00431cd0(liveObj,param_4,param_5,param_4,param_5,0);
		if (iVar8 == 0) {
			return 0;
		}
	}
	if (globs::liveGlobs.UnkSurfaceGrid_1_TABLE != NULL) {
		if (globs::liveGlobs.UnkSurfaceGrid_COUNT == uVar13 * uVar12) goto LAB_004414be;
		if (globs::liveGlobs.UnkSurfaceGrid_1_TABLE != NULL) {
			std::free(globs::liveGlobs.UnkSurfaceGrid_1_TABLE);
		}
	}
	globs::liveGlobs.UnkSurfaceGrid_COUNT = uVar13 * uVar12;
	globs::liveGlobs.UnkSurfaceGrid_1_TABLE = std::malloc(globs::liveGlobs.UnkSurfaceGrid_COUNT * 4);
LAB_004414be:
	iVar8 = uVar13 * uVar12;
	puVar16 = (undefined4 *)globs::liveGlobs.UnkSurfaceGrid_1_TABLE;
	if (globs::liveGlobs.UnkSurfaceGrid_1_TABLE != NULL) {
		for (; iVar8 != 0; iVar8 += -1) {
			*puVar16 = 0;
			puVar16 = puVar16 + 1;
		}
		fStack4092 = 1.401298e-45;
		auStack4060[0] = 1;
		puStack4104 = auStack4060;
		uStack4096 = 0;
		*(undefined4 *)((int)globs::liveGlobs.UnkSurfaceGrid_1_TABLE + (uVar12 * by + bx) * 4) =
				 0x3f800000;
		auStack4000[0] = bx;
		auStack4000[1] = by;
		auStack4060[1] = 0;
		do {
			fStack4092 = (float)((int)fStack4092 + 1);
			uStack4068 = 0;
			if (*puStack4104 != 0) {
				puVar11 = auStack4000 + uStack4096 * 500 + 1;
				do {
					fVar2 = *(float *)((int)globs::liveGlobs.UnkSurfaceGrid_1_TABLE +
														(uVar12 * *puVar11 + puVar11[-1]) * 4);
					iStack4108 = 0;
					do {
						uVar14 = puVar11[-1];
						uVar17 = *puVar11;
						if (iStack4108 == 0) {
							uVar17 -= 1;
						}
						else {
							if (iStack4108 == 1) {
								uVar14 += 1;
							}
							else {
								if (iStack4108 == 2) {
									uVar17 += 1;
								}
								else {
									if (iStack4108 == 3) {
										uVar14 -= 1;
									}
								}
							}
						}
						if ((uVar14 < uVar12) && (uVar17 < uVar13)) {
							fStack4088 = 1.0;
							iVar8 = aiStack4032[iStack4108 * 2];
							iVar4 = aiStack4032[iStack4108 * 2 + 1];
							PStack4040.x = iVar8 + uVar14;
							PStack4040.y = iVar4 + uVar17;
							BVar9 = Level_Block_IsPowerPath(&PStack4040);
							if (BVar9 != 0) {
								fStack4088 = 0.5;
							}
							iVar8 = LiveObject_FUN_00431cd0(liveObj,uVar14,uVar17,iVar8 + uVar14,iVar4 + uVar17,0)
							;
							if ((iVar8 != 0) &&
								 ((iVar8 = uVar17 * uVar12 + uVar14,
									pfVar1 = (float *)((int)globs::liveGlobs.UnkSurfaceGrid_1_TABLE + iVar8 * 4),
									*(float *)((int)globs::liveGlobs.UnkSurfaceGrid_1_TABLE + iVar8 * 4) == 0.0 ||
									(fVar5 = fStack4088 + fVar2, fVar3 = *pfVar1,
									(ushort)((ushort)(fVar3 < fVar5) << 8 | (ushort)(fVar3 == fVar5) << 0xe) == 0))))
							{
								uVar10 = (uint)(uStack4096 == 0);
								uVar15 = auStack4060[uVar10];
								iVar8 = uVar15 + uVar10 * 100;
								*pfVar1 = fStack4088 + fVar2;
								auStack4000[iVar8 * 5] = uVar14;
								auStack4000[iVar8 * 5 + 1] = uVar17;
								auStack4060[uVar10] = uVar15 + 1;
								if (callback == NULL) {
									if ((uVar14 == param_4) && (uVar17 == param_5)) {
										bVar6 = true;
										fStack4052 = fStack4092;
									}
								}
								else {
									PStack4048.x = uVar14;
									PStack4048.y = uVar17;
									iVar8 = (*callback)(liveObj,&PStack4048,param_10);
									if (iVar8 != 0) {
										iStack4076 = 1;
										param_4 = uVar14;
										param_5 = uVar17;
									}
								}
							}
						}
						iStack4108 += 1;
					} while (iStack4108 < 4);
					uStack4068 += 1;
					puVar11 = puVar11 + 5;
				} while (uStack4068 < *puStack4104);
			}
			*puStack4104 = 0;
			uStack4096 = (uint)(uStack4096 == 0);
			puStack4104 = auStack4060 + uStack4096;
			if (auStack4060[uStack4096] == 0) {
				iStack4076 = -1;
			}
		} while (iStack4076 == 0);
		if (bVar6) {
			iStack4076 = 1;
			fStack4092 = fStack4052;
		}
		if (iStack4076 == -1) {
			return 0;
		}
		puVar11 = (uint *)std::malloc((int)fStack4092 * 4);
		if ((puVar11 != NULL) && (buffer = (uint *)std::malloc((int)fStack4092 * 4), buffer != NULL)) {
			iVar8 = (int)fStack4092 + -1;
			puVar11[iVar8] = param_4;
			puStack4080 = buffer + iVar8;
			*puStack4080 = param_5;
			*puVar11 = bx;
			*buffer = by;
			if (iVar8 != 1) {
				uStack4068 = (int)fStack4092 + -2;
				uVar14 = param_4;
				uVar17 = param_5;
				do {
					puStack4104 = (uint *)0x461c4000;
					iStack4108 = 0;
					do {
						uVar15 = uVar14;
						if (iStack4108 == 0) {
							uVar10 = uVar17 - 1;
						}
						else {
							uVar10 = uVar17;
							if (iStack4108 == 1) {
								uVar15 = uVar14 + 1;
							}
							else {
								if (iStack4108 == 2) {
									uVar10 = uVar17 + 1;
								}
								else {
									if (iStack4108 == 3) {
										uVar15 = uVar14 - 1;
									}
								}
							}
						}
						PStack4048.x = uVar15;
						PStack4048.y = uVar10;
						if (((uVar15 < uVar12) && (uVar10 < uVar13)) &&
							 (((fStack4052 = *(float *)((int)globs::liveGlobs.UnkSurfaceGrid_1_TABLE +
																				 (uVar17 * uVar12 + uVar14) * 4) -
															 *(float *)((int)globs::liveGlobs.UnkSurfaceGrid_1_TABLE +
																				 (uVar10 * uVar12 + uVar15) * 4),
								 (ushort)((ushort)(fStack4052 < 0.0) << 8 | (ushort)(fStack4052 == 0.0) << 0xe) == 0
								 && (fStack4052 < (float)puStack4104)) ||
								((fStack4052 == (float)puStack4104 &&
								 (BVar9 = Level_Block_IsPowerPath(&PStack4048), BVar9 != 0)))))) {
							puStack4104 = (uint *)fStack4052;
							auStack4060[0] = uVar15;
							auStack4060[1] = uVar10;
						}
						iStack4108 += 1;
					} while (iStack4108 < 4);
					puStack4080 = puStack4080 + -1;
					*(uint *)((int)((int)puVar11 - (int)buffer) + (int)puStack4080) = auStack4060[0];
					*puStack4080 = auStack4060[1];
					uStack4068 += -1;
					uVar14 = auStack4060[0];
					uVar17 = auStack4060[1];
				} while (uStack4068 != 0);
			}
			*param_6 = puVar11;
			*param_7 = buffer;
			*param_8 = fStack4092;
			if (((*puVar11 != puVar11[1]) ||
					(uVar12 = (int)(*buffer - buffer[1]) >> 0x1f, (*buffer - buffer[1] ^ uVar12) - uVar12 != 1
					)) && ((*buffer != buffer[1] ||
								 (uVar12 = *puVar11 - puVar11[1], uVar13 = (int)uVar12 >> 0x1f,
								 (uVar12 ^ uVar13) - uVar13 != 1)))) {
				std::free(puVar11);
				std::free(buffer);
				BVar9 = LiveObject_FUN_00440f30
													(liveObj,bx,by,param_4,param_5,param_6,param_7,(uint *)param_8,callback,
													 param_10);
				return BVar9;
			}
		}
	}
	return TRUE;
}



BOOL __cdecl
lego::game::LiveObject_FUN_004419c0
					(LiveObject *liveObj,uint param_2,float *param_3,float *param_4,float *param_5)
{
	bool bVar1;
	BOOL BVar2;
	void *buffer;
	SurfaceMap *surfMap;
	ObjectStatsFlags1 OVar3;
	int iVar4;
	int iVar5;
	float *pfVar6;
	float *pfVar7;
	float *pfVar8;
	float10 fVar9;
	Point2F *pPVar10;
	Point2F *pPVar11;
	Point2F *pPVar12;
	uint local_1c;
	int local_14;
	Point2F local_8;
	
	BVar2 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj);
	if (BVar2 == 0) {
		local_14 = -1;
		bVar1 = false;
		local_8.x = 0.5;
		local_8.y = 0.5;
		if ((liveObj->flags4 & LIVEOBJ4_UNK_40) != LIVEOBJ4_NONE) {
			liveObj->object_2fc = NULL;
			liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_40;
		}
		buffer = std::malloc(param_2 * 0x14);
		if ((buffer != NULL) && (local_1c = 0, param_2 != 0)) {
			pfVar7 = (float *)((int)buffer + 8);
			pfVar6 = (float *)((int)param_4 - (int)param_3);
			do {
				pfVar8 = param_3 + 1;
				pfVar7[-2] = *param_3;
				pfVar7[-1] = *param_4;
				if ((param_5 == NULL) || (local_1c != param_2 - 1)) {
					if (((liveObj->flags3 & LIVEOBJ3_UNK_1000) == LIVEOBJ3_NONE) &&
						 (OVar3 = LiveObject_GetStatsFlags1(liveObj),
						 (OVar3 & STATS1_ROUTEAVOIDANCE) != STATS1_NONE)) {
						fVar9 = math::Maths_RandRange(0.3,0.7);
						*pfVar7 = (float)fVar9;
						fVar9 = math::Maths_RandRange(0.3,0.7);
						pfVar7[1] = (float)fVar9;
					}
					else {
						pfVar7[1] = 0.5;
						*pfVar7 = 0.5;
					}
				}
				else {
					pPVar12 = &local_8;
					pPVar11 = NULL;
					pPVar10 = (Point2F *)param_5;
					surfMap = GetSurfaceMap();
					Map3D_FUN_0044fb30(surfMap,pPVar10,pPVar11,pPVar12);
					*pfVar7 = local_8.x;
					pfVar7[1] = local_8.y;
				}
				*(undefined *)(pfVar7 + 2) = 0;
				*(undefined *)((int)pfVar7 + 9) = 0;
				iVar4 = local_14;
				if (local_1c < param_2 - 1) {
					iVar4 = unk::Map3D_CheckComparison_FUN_00450b60
														((int)*pfVar8,*(int *)((int)pfVar6 + (int)pfVar8),(int)*param_3,
														 (int)*param_4);
					if (iVar4 == -1) {
						bVar1 = true;
						break;
					}
					if (((local_1c != 0) && (local_14 != iVar4)) &&
						 (iVar5 = LiveObject_FUN_00431cd0
																(liveObj,(int)*pfVar8,*(int *)((int)pfVar6 + (int)pfVar8),
																 (int)param_3[-1],(int)param_4[-1],0), iVar5 == 2)) {
						*(byte *)(pfVar7 + 2) = *(byte *)(pfVar7 + 2) | 0x10;
					}
				}
				local_14 = iVar4;
				local_1c += 1;
				param_4 = param_4 + 1;
				pfVar7 = pfVar7 + 5;
				param_3 = pfVar8;
			} while (local_1c < param_2);
		}
		if (!bVar1) {
			LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
			liveObj->flags3 = liveObj->flags3 & 0xfffffbff;
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_MOVING;
			liveObj->routeptr_24 = buffer;
			liveObj->routingBlocksTotal = param_2;
			liveObj->routingBlocksCurrent = 0;
			(liveObj->vector_28c).y = 0.0;
			(liveObj->vector_28c).x = 0.0;
			return 1;
		}
		std::free(buffer);
	}
	return 0;
}



void __cdecl lego::game::LiveObject_UnkDoRouting_FUN_00441c00(LiveObject *in_liveObj,BOOL param_2)
{
	LiveFlags4 *pLVar1;
	float fVar2;
	LiveFlags1 LVar3;
	LiveFlags3 LVar4;
	LiveObject *pLVar5;
	uint uVar6;
	char *pcVar7;
	longlong lVar8;
	Point2I point;
	
	if (in_liveObj->routeptr_24 != NULL) {
		if (param_2 == 0) {
			uVar6 = in_liveObj->routingBlocksCurrent;
			if (uVar6 < in_liveObj->routingBlocksTotal) {
				pcVar7 = (char *)((int)in_liveObj->routeptr_24 + uVar6 * 0x14 + 0x11);
				do {
					if (*pcVar7 == '\x03') {
						pLVar5 = in_liveObj->object_2fc;
						if (pLVar5 != NULL) {
							if (pLVar5->objType == OBJECT_BOULDER) {
								LiveObject_DestroyBoulder_AndCreateExplode(pLVar5);
							}
							else {
								pLVar5->object_300 = NULL;
							}
LAB_00441ca7:
							in_liveObj->object_2fc = NULL;
						}
						break;
					}
					if (*pcVar7 == '\a') goto LAB_00441ca7;
					uVar6 += 1;
					pcVar7 = pcVar7 + 0x14;
				} while (uVar6 < in_liveObj->routingBlocksTotal);
			}
			if (in_liveObj->objType == OBJECT_ROCKMONSTER) {
				if (((in_liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
					 (in_liveObj->carriedObjects[0]->objType == OBJECT_BOULDER)) {
					LiveObject_FUN_0043a130(in_liveObj,0);
				}
				ai::AITask_LiveObject_FUN_00403b30(in_liveObj,AITASK_GATHER,NULL);
				ai::AITask_LiveObject_FUN_00403b30(in_liveObj,AITASK_REPAIR,NULL);
			}
			if ((*(byte *)&in_liveObj->flags1 & 8) != 0) {
				lVar8 = __ftol((float10)(in_liveObj->point_2f4).x);
				point.x = (int)lVar8;
				lVar8 = __ftol((float10)(in_liveObj->point_2f4).y);
				point.y = (int)lVar8;
				Level_Block_SetFlags1_8000000(&point,0);
			}
			ai::AITask_Game_UnkLiveObjectHandleDynamite(in_liveObj);
		}
		else {
			if (in_liveObj->objType == OBJECT_MINIFIGURE) {
				res::Creature_SetOrientation
									(in_liveObj->miniFigure,(in_liveObj->point_298).x,(in_liveObj->point_298).y);
				fVar2 = (in_liveObj->point_298).y;
				(in_liveObj->faceDirection).x = (in_liveObj->point_298).x;
				(in_liveObj->faceDirection).y = fVar2;
			}
		}
		std::free(in_liveObj->routeptr_24);
		in_liveObj->routeptr_24 = NULL;
		ai::AITask_LiveObject_FUN_00403a20(in_liveObj,param_2);
	}
	LVar3 = in_liveObj->flags1;
	LVar4 = in_liveObj->flags3;
	pLVar5 = in_liveObj->object_2fc;
	in_liveObj->routingBlocksTotal = 0;
	in_liveObj->routingBlocksCurrent = 0;
	(in_liveObj->vector_28c).y = 0.0;
	(in_liveObj->vector_28c).x = 0.0;
	(in_liveObj->vector_28c).z = 0.0;
	in_liveObj->flags1 = LVar3 & ~(LIVEOBJ1_MOVING|LIVEOBJ1_UNK_800000);
	in_liveObj->flags3 = LVar4 & 0xffffbbff;
	if (pLVar5 != NULL) {
		pLVar1 = &pLVar5->flags4;
		*pLVar1 = *pLVar1 & ~LIVEOBJ4_UNK_10;
	}
	if ((*(byte *)&in_liveObj->flags1 & 2) != 0) {
		(in_liveObj->faceDirection).x = (in_liveObj->faceDirection).x * -1.0;
		(in_liveObj->faceDirection).y = (in_liveObj->faceDirection).y * -1.0;
		(in_liveObj->faceDirection).z = (in_liveObj->faceDirection).z * -1.0;
		in_liveObj->flags1 = in_liveObj->flags1 & ~LIVEOBJ1_LIFTING;
	}
	LiveObject_SetActivityUnk(in_liveObj,ACTIVITY_STAND,0);
	return;
}



void __cdecl lego::game::LiveObject_FUN_00441df0(LiveObject *liveObj,BOOL param_2,BOOL param_3)
{
	LiveFlags2 *pLVar1;
	LiveFlags3 *pLVar2;
	LiveFlags2 LVar3;
	LiveFlags1 LVar4;
	ObjectStatsFlags2 OVar5;
	longlong lVar6;
	Point2I local_8;
	
	LiveObject_UnkDoRouting_FUN_00441c00(liveObj,FALSE);
	if (param_3 != 0) {
		LiveObject_FUN_0043a130(liveObj,FALSE);
	}
	if ((liveObj->flags2 & LIVEOBJ2_UNK_2) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_2;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_GETUP,0);
		LiveObject_Container_ActivityUpdate_Check(liveObj);
		liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_100;
		LVar3 = liveObj->object_3c0->flags2;
		if ((LVar3 & LIVEOBJ2_UNK_1) != LIVEOBJ2_NONE) {
			liveObj->object_3c0->flags2 = LVar3 & ~LIVEOBJ2_UNK_1;
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		}
	}
	if ((liveObj->flags2 & LIVEOBJ2_UNK_1) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_1;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,FALSE);
		LVar3 = liveObj->object_3c0->flags2;
		if ((LVar3 & LIVEOBJ2_UNK_2) != LIVEOBJ2_NONE) {
			liveObj->object_3c0->flags2 = LVar3 & ~LIVEOBJ2_UNK_2;
			LiveObject_SetActivityUnk(liveObj->object_3c0,ACTIVITY_GETUP,FALSE);
			LiveObject_Container_ActivityUpdate_Check(liveObj->object_3c0);
			pLVar1 = &liveObj->object_3c0->flags2;
			*pLVar1 = *pLVar1 | LIVEOBJ2_UNK_100;
		}
	}
	LVar4 = liveObj->flags1;
	liveObj->flags2 =
			 liveObj->flags2 &
			 ~(LIVEOBJ2_UNK_20|LIVEOBJ2_UNK_4000|LIVEOBJ2_UNK_400000|LIVEOBJ2_UNK_800000|
				LIVEOBJ2_UNK_1000000);
	liveObj->flags1 = LVar4 & ~(LIVEOBJ1_UNK_800|LIVEOBJ1_UNK_10000000|LIVEOBJ1_UNK_80000000);
	if ((LVar4 & LIVEOBJ1_UNK_2000) != LIVEOBJ1_NONE) {
		liveObj->flags1 =
				 LVar4 & ~(LIVEOBJ1_UNK_800|LIVEOBJ1_UNK_2000|LIVEOBJ1_UNK_10000000|LIVEOBJ1_UNK_80000000);
		ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_DEPOSITE,liveObj,TRUE);
		LiveObject_ProcCarriedObjects_FUN_0043f160(liveObj);
		if (liveObj->object_2fc != NULL) {
			pLVar2 = &liveObj->object_2fc->flags3;
			*pLVar2 = *pLVar2 & ~LIVEOBJ3_UNK_1000000;
		}
	}
	LVar4 = liveObj->flags1;
	liveObj->flags1 = LVar4 & ~(LIVEOBJ1_UNK_200|LIVEOBJ1_REST);
	liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_4000;
	if ((liveObj->flags2 & LIVEOBJ2_UNK_200000) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_200000;
	}
	LVar3 = liveObj->flags2;
	liveObj->flags2 = LVar3 & ~LIVEOBJ2_UNK_40000;
	if ((LVar4 & LIVEOBJ1_UNK_1000000) != LIVEOBJ1_NONE) {
		liveObj->flags2 = LVar3 & ~(LIVEOBJ2_UNK_40000|LIVEOBJ2_UNK_80000);
		ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_REPAIR,NULL,TRUE);
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_1000000;
	}
	if ((liveObj->flags1 & LIVEOBJ1_EATING) != LIVEOBJ1_NONE) {
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_EATING;
	}
	if ((liveObj->flags2 & LIVEOBJ2_UNK_40) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_40;
	}
	if ((liveObj->flags2 & LIVEOBJ2_TRAINING) != LIVEOBJ2_NONE) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_TRAINING;
	}
	if ((liveObj->flags2 & LIVEOBJ2_UPGRADING) != LIVEOBJ2_NONE) {
		if (liveObj->object_2fc != NULL) {
			OVar5 = LiveObject_GetStatsFlags2(liveObj->object_2fc);
			if ((OVar5 & STATS2_UPGRADEBUILDING) != STATS2_NONE) {
				if ((liveObj->object_2fc->flags2 & LIVEOBJ2_UPGRADING) != LIVEOBJ2_NONE) goto LAB_00442065;
				ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_UPGRADE,NULL,TRUE);
				liveObj->object_2fc->object_300 = NULL;
				liveObj->object_2fc = NULL;
			}
		}
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UPGRADING;
	}
LAB_00442065:
	if ((liveObj->flags1 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_PLACING;
		LiveObject_FUN_0043a130(liveObj,TRUE);
	}
	LVar4 = liveObj->flags1;
	liveObj->flags1 = LVar4 & ~LIVEOBJ1_UNK_1000;
	if ((LVar4 & LIVEOBJ1_REINFORCING) != LIVEOBJ1_NONE) {
		lVar6 = __ftol((float10)(liveObj->point_2f4).x);
		local_8.x = (int)lVar6;
		lVar6 = __ftol((float10)(liveObj->point_2f4).y);
		local_8.y = (int)lVar6;
		liveObj->flags1 = LVar4 & ~(LIVEOBJ1_REINFORCING|LIVEOBJ1_UNK_1000) | LIVEOBJ1_UNK_80000000;
		Level_Block_SetFlags1_8000000(&local_8,0);
	}
	LVar4 = liveObj->flags1;
	liveObj->flags1 = LVar4 & ~LIVEOBJ1_UNK_4000000;
	if ((liveObj->flags2 & LIVEOBJ2_UNK_4) != LIVEOBJ2_NONE) {
		liveObj->object_2fc = NULL;
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_4;
	}
	liveObj->flags1 =
			 LVar4 & ~(LIVEOBJ1_UNK_8000|LIVEOBJ1_UNK_10000|LIVEOBJ1_CLEARING|LIVEOBJ1_UNK_4000000|
								LIVEOBJ1_UNK_80000000);
	liveObj->flags2 =
			 liveObj->flags2 & ~(LIVEOBJ2_UNK_100|LIVEOBJ2_UNK_200|LIVEOBJ2_UNK_10000|LIVEOBJ2_UNK_20000);
	if (param_2 != 0) {
		ai::AITask_LiveObject_Unk_UpdateAITask_AnimationWait(liveObj);
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,TRUE);
		LiveObject_Container_ActivityUpdate_Check(liveObj);
	}
	return;
}



void __cdecl lego::game::LiveObject_DestroyBoulder_AndCreateExplode(LiveObject *liveObj)
{
	if ((((byte)globs::liveGlobs.flags & 2) == 0) && (liveObj->objType == OBJECT_BOULDER)) {
		Effect_Spawn_BoulderExplode_AtObject(liveObj);
		pool::ReservedPool_LiveObject___Release(liveObj);
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_FUN_00442190(LiveObject *liveObj,LiveObject *targetObj,int param_3)
{
	float fVar1;
	float fVar2;
	float fVar3;
	BOOL BVar4;
	Container *pCVar5;
	LiveFlags2 LVar6;
	float10 fVar7;
	Container *pCVar8;
	Vector3F *pVVar9;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	if ((((ushort)((ushort)((float)liveObj->field_360 < 0.0) << 8 |
								(ushort)((float)liveObj->field_360 == 0.0) << 0xe) == 0) ||
			(((byte)globs::gameGlobs.flags2 & 4) != 0)) || (targetObj->objType != OBJECT_ROCKMONSTER)) {
		return 0;
	}
	BVar4 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj);
	if (BVar4 != 0) {
		return 0;
	}
	LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
	pVVar9 = &local_18;
	pCVar8 = NULL;
	pCVar5 = LiveObject_GetContainer(targetObj);
	res::Container_GetPosition(pCVar5,pCVar8,pVVar9);
	pVVar9 = &local_c;
	pCVar8 = NULL;
	pCVar5 = LiveObject_GetContainer(liveObj);
	res::Container_GetPosition(pCVar5,pCVar8,pVVar9);
	fVar7 = LiveObject_GetCollHeight(liveObj);
	local_c.z = (float)((float10)local_c.z - fVar7 * (float10)0.5);
	fVar7 = LiveObject_GetCollHeight(targetObj);
	fVar7 = (float10)local_18.z - fVar7 * (float10)0.5;
	local_18.z = (float)fVar7;
	fVar7 = fVar7 - (float10)local_c.z;
	fVar1 = (float)((float10)local_18.x - (float10)local_c.x);
	fVar2 = (float)((float10)local_18.y - (float10)local_c.y);
	fVar3 = (float)fVar7;
	fVar7 = (float10)1.0 /
					SQRT(fVar7 * (float10)fVar3 +
							 ((float10)local_18.y - (float10)local_c.y) * (float10)fVar2 +
							 ((float10)local_18.x - (float10)local_c.x) * (float10)fVar1);
	local_24.x = (float)(fVar7 * (float10)fVar1);
	local_24.y = (float)(fVar7 * (float10)fVar2);
	local_24.z = (float)(fVar7 * (float10)fVar3);
	LiveObject_UnkUpdateOrientation(liveObj,0.0,&local_24);
	if (param_3 == 1) {
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_FIRELASER,1);
		LiveObject_Container_ActivityUpdate_Check(liveObj);
		LVar6 = liveObj->flags2 | LIVEOBJ2_UNK_400000;
	}
	else {
		if (param_3 == 2) {
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_FIRELASER,1);
			LiveObject_Container_ActivityUpdate_Check(liveObj);
			LVar6 = liveObj->flags2 | LIVEOBJ2_UNK_800000;
		}
		else {
			if (param_3 != 3) goto LAB_0044233f;
			LiveObject_SetActivityUnk(liveObj,ACTIVITY_FIRELASER,1);
			LiveObject_Container_ActivityUpdate_Check(liveObj);
			LVar6 = liveObj->flags2 | LIVEOBJ2_UNK_1000000;
		}
	}
	liveObj->flags2 = LVar6;
LAB_0044233f:
	liveObj->field_3a8 = local_18.x;
	liveObj->field_3ac = local_18.y;
	liveObj->field_39c = local_24.x;
	liveObj->field_3b0 = local_18.z;
	liveObj->field_3a0 = local_24.y;
	liveObj->field_3a4 = local_24.z;
	return TRUE;
}



void __cdecl lego::game::Game_GetWeaponUnk(LiveObject *liveObj,int weaponType)
{
	SurfaceMap *surfMap;
	float weaponType_00;
	float10 fVar1;
	Vector3F local_c;
	
	LiveObject_GetPosition(liveObj,(float *)&local_c,&local_c.y);
	surfMap = GetSurfaceMap();
	fVar1 = Map3D_GetWorldZ(surfMap,local_c.x,local_c.y);
	weaponType_00 = (float)fVar1;
	fVar1 = LiveObject_GetCollHeight(liveObj);
	local_c.z = (float)((float10)weaponType_00 - fVar1 * (float10)0.5);
	switch(weaponType) {
	case 1:
		weaponType_00 = (float)tools::Weapon_GetWeaponTypeByName("Lazer");
		unk::Struct2B0_FUN_0046fdb0
							(liveObj,&local_c,(Vector3F *)&liveObj->field_39c,(uint)weaponType_00,1);
		break;
	case 2:
		weaponType_00 = (float)tools::Weapon_GetWeaponTypeByName("Pusher");
		unk::Struct2B0_FUN_0046fdb0
							(liveObj,&local_c,(Vector3F *)&liveObj->field_39c,(uint)weaponType_00,2);
		break;
	case 3:
		weaponType_00 = (float)tools::Weapon_GetWeaponTypeByName("Freezer");
		unk::Struct2B0_FUN_0046fdb0
							(liveObj,&local_c,(Vector3F *)&liveObj->field_39c,(uint)weaponType_00,3);
		break;
	case 4:
		weaponType_00 = (float)tools::Weapon_GetWeaponTypeByName("Lazer");
		tools::Weapon_UpdateRoutingUnk_FUN_0046ff30
							(liveObj,&local_c,(Vector3F *)&liveObj->field_3a8,weaponType_00,WEAPONKNOWN_LAZER_4);
	}
	fVar1 = tools::Weapon_GetRechargeTime((int)weaponType_00);
	liveObj->field_360 = (float)fVar1;
	return;
}



void __cdecl lego::game::LiveObject_UnkActivityCrumble_FUN_004424d0(LiveObject *liveObj)
{
	BOOL BVar1;
	
	LiveObject_FUN_00441df0(liveObj,0,1);
	LiveObject_SetActivityUnk(liveObj,ACTIVITY_CRUMBLE,1);
	BVar1 = LiveObject_Container_ActivityUpdate_Check(liveObj);
	if (BVar1 != 0) {
		liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_100000;
	}
	liveObj->health = -1.0;
	return;
}



void __cdecl lego::game::LiveObject_GetPosition(LiveObject *liveObj,float *out_x,float *out_y)
{
	Container *cont;
	Vector3F vector;
	
	cont = LiveObject_GetContainer(liveObj);
	res::Container_GetPosition(cont,NULL,&vector);
	*out_x = vector.x;
	*out_y = vector.y;
	return;
}



void __cdecl lego::game::LiveObject_GetFaceDirection(LiveObject *liveObj,Point2F *out_direction)
{
	float fVar1;
	Container *cont;
	Vector3F local_c;
	
	cont = LiveObject_GetContainer(liveObj);
	res::Container_GetOrientation(cont,NULL,&local_c,NULL);
	fVar1 = 1.0 / SQRT(local_c.x * local_c.x + local_c.y * local_c.y);
	out_direction->x = fVar1 * local_c.x;
	out_direction->y = fVar1 * local_c.y;
	return;
}



void __cdecl
lego::game::LiveObject_UnkUpdateOrientation(LiveObject *liveObj,float theta,Vector3F *dvector)
{
	ObjectType OVar1;
	Vector3F local_18;
	Vector3F local_c;
	
	if (dvector == NULL) {
		local_18.z = 0.0;
		local_18.x = 0.0;
		local_18.y = 1.0;
		local_c.y = 0.0;
		local_c.x = 0.0;
		local_c.z = -1.0;
		math::Maths_Vector3DRotate(&local_18,&local_18,&local_c,theta);
	}
	else {
		local_18.x = dvector->x;
		local_18.y = dvector->y;
		local_18.z = dvector->z;
	}
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		res::Vehicle_SetOrientation(liveObj->vehicle,local_18.x,local_18.y,local_18.z);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			res::Creature_SetOrientation(liveObj->miniFigure,local_18.x,local_18.y);
		}
		else {
			if (OVar1 == OBJECT_ROCKMONSTER) {
				res::Creature_SetOrientation(liveObj->rockMonster,local_18.x,local_18.y);
			}
			else {
				if (OVar1 == OBJECT_BUILDING) {
					res::Building_SetOrientation(liveObj->building,local_18.x,local_18.y);
				}
				else {
					if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
						res::Container_SetOrientation
											(liveObj->other,NULL,local_18.x,local_18.y,local_18.z,0.0,0.0,-1.0);
					}
				}
			}
		}
	}
	liveObj->float_2b8 = 0.01;
	(liveObj->faceDirection).x = local_18.x;
	(liveObj->faceDirection).y = local_18.y;
	(liveObj->faceDirection).z = local_18.z;
	(liveObj->vector_2a0).x = (liveObj->faceDirection).x * -0.01;
	(liveObj->vector_2a0).y = (liveObj->faceDirection).y * -0.01;
	(liveObj->vector_2a0).z = (liveObj->faceDirection).z * -0.01;
	return;
}



float10 __cdecl lego::game::LiveObject_UnkRadians_FUN_00442740(LiveObject *liveObj)
{
	float10 fVar1;
	Point2F direction;
	
	LiveObject_GetFaceDirection(liveObj,&direction);
	fVar1 = std::acos((float10)direction.y /
										(SQRT((float10)1.0) *
										SQRT((float10)direction.y * (float10)direction.y +
												 (float10)direction.x * (float10)direction.x)));
	if (direction.x < 0.0) {
		fVar1 = (float10)6.283185 - fVar1;
	}
	return fVar1;
}



BOOL __cdecl lego::game::LiveObject_GetBlockPos(LiveObject *liveObj,int *out_bx,int *out_by)
{
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar1;
	Vector3F position;
	
	cont = LiveObject_GetContainer(liveObj);
	res::Container_GetPosition(cont,NULL,&position);
	surfMap = GetSurfaceMap();
	BVar1 = Map3D_WorldToBlockPos_NoZ(surfMap,position.x,position.y,out_bx,out_by);
	return BVar1;
}



float10 __cdecl lego::res::Res_GetSurfaceMapZ_Callback(float x,float y,SurfaceMap *surfMap)
{
	float10 fVar1;
	
	fVar1 = game::Map3D_GetWorldZ(surfMap,x,y);
	return fVar1;
}



float10 __cdecl
lego::game::SurfaceMap_LevelCallback_FUN_00442820(float in_x,float in_y,SurfaceMap *surfMap)
{
	BOOL BVar1;
	float10 fVar2;
	float local_c;
	int local_8;
	int local_4;
	
	local_c = 0.0;
	BVar1 = Map3D_WorldToBlockPos(surfMap,in_x,in_y,&local_8,&local_4,&local_c);
	if (BVar1 != 0) {
		if ((globs::gameGlobs.level)->blocks
				[((globs::gameGlobs.level)->dimensions).width * local_4 + local_8].terrain == TERRAIN_LAKE)
		{
			local_c = local_c * 8.0;
		}
		else {
			local_c = 0.0;
		}
	}
	fVar2 = Map3D_GetWorldZ(surfMap,in_x,in_y);
	return fVar2 + (float10)local_c;
}



void __cdecl lego::game::LiveObject_FUN_004428b0(LiveObject *liveObj,float x,float y)
{
	ObjectType OVar1;
	Container *cont;
	SurfaceMap *pSVar2;
	VehicleData *vehicle;
	float fVar3;
	float fVar4;
	float fVar5;
	Vector3F local_c;
	
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		cont = res::Vehicle_GetAEResource(liveObj->vehicle);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			cont = res::Object_GetActivityContainer((BasicObjectData *)liveObj->miniFigure);
		}
		else {
			cont = (Container *)y;
			if (OVar1 == OBJECT_ROCKMONSTER) {
				cont = res::Object_GetActivityContainer((BasicObjectData *)liveObj->rockMonster);
			}
		}
	}
	res::Container_GetPosition(cont,NULL,&local_c);
	if ((x != local_c.x) || (y != local_c.y)) {
		(liveObj->faceDirection).z = 0.0;
		(liveObj->faceDirection).x = x;
		(liveObj->faceDirection).y = y;
		(liveObj->vector_2a0).x = local_c.x;
		(liveObj->vector_2a0).y = local_c.y;
		(liveObj->vector_2a0).z = local_c.z;
		(liveObj->faceDirection).x = (liveObj->faceDirection).x - (liveObj->vector_2a0).x;
		(liveObj->faceDirection).y = (liveObj->faceDirection).y - (liveObj->vector_2a0).y;
		(liveObj->faceDirection).z = (liveObj->faceDirection).z - (liveObj->vector_2a0).z;
		(liveObj->faceDirection).z = 0.0;
		fVar4 = (liveObj->faceDirection).z;
		fVar3 = (liveObj->faceDirection).y;
		fVar5 = (liveObj->faceDirection).x;
		fVar4 = SQRT(fVar5 * fVar5 + fVar4 * fVar4 + fVar3 * fVar3);
		fVar5 = 1.0 / fVar4;
		liveObj->float_2b8 = fVar4;
		(liveObj->faceDirection).x = fVar5 * (liveObj->faceDirection).x;
		(liveObj->faceDirection).y = (liveObj->faceDirection).y * fVar5;
		(liveObj->faceDirection).z = (liveObj->faceDirection).z * fVar5;
	}
	OVar1 = liveObj->objType;
	if (OVar1 != OBJECT_VEHICLE) {
		if (OVar1 != OBJECT_MINIFIGURE) {
			if (OVar1 == OBJECT_ROCKMONSTER) {
				res::Creature_SetOrientation
									(liveObj->rockMonster,(liveObj->faceDirection).x,(liveObj->faceDirection).y);
				pSVar2 = GetSurfaceMap();
				res::Creature_SetPosition(liveObj->rockMonster,x,y,res::Res_GetSurfaceMapZ_Callback,pSVar2);
			}
			return;
		}
		if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_LIFTING) == 0) {
			fVar5 = (liveObj->faceDirection).y;
			fVar4 = (liveObj->faceDirection).x;
		}
		else {
			fVar5 = -(liveObj->faceDirection).y;
			fVar4 = -(liveObj->faceDirection).x;
		}
		res::Creature_SetOrientation(liveObj->miniFigure,fVar4,fVar5);
		pSVar2 = GetSurfaceMap();
		res::Creature_SetPosition(liveObj->miniFigure,x,y,SurfaceMap_LevelCallback_FUN_00442820,pSVar2);
		return;
	}
	if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_LIFTING) == 0) {
		fVar5 = (liveObj->faceDirection).z;
		fVar4 = (liveObj->faceDirection).y;
		fVar3 = (liveObj->faceDirection).x;
		vehicle = liveObj->vehicle;
	}
	else {
		vehicle = liveObj->vehicle;
		fVar5 = -(liveObj->faceDirection).z;
		fVar4 = -(liveObj->faceDirection).y;
		fVar3 = -(liveObj->faceDirection).x;
	}
	res::Vehicle_SetOrientation(vehicle,fVar3,fVar4,fVar5);
	pSVar2 = GetSurfaceMap();
	res::Vehicle_SetPosition(liveObj->vehicle,x,y,res::Res_GetSurfaceMapZ_Callback,pSVar2);
	return;
}



void __cdecl
lego::game::LiveObject_UnkUpdatePositioning
					(LiveObject *liveObj,float x,float y,float theta,BOOL includeRotation)
{
	ObjectType OVar1;
	SurfaceMap *pSVar2;
	float10 fVar3;
	float x_00;
	float y_00;
	Vector3F local_18;
	Vector3F local_c;
	
	if (includeRotation != 0) {
		local_18.z = 0.0;
		local_18.x = 0.0;
		local_18.y = 1.0;
		local_c.y = 0.0;
		local_c.x = 0.0;
		local_c.z = -1.0;
		math::Maths_Vector3DRotate(&local_18,&local_18,&local_c,theta);
	}
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		if (includeRotation != 0) {
			res::Vehicle_SetOrientation(liveObj->vehicle,local_18.x,local_18.y,local_18.z);
		}
		pSVar2 = GetSurfaceMap();
		res::Vehicle_SetPosition(liveObj->vehicle,x,y,res::Res_GetSurfaceMapZ_Callback,pSVar2);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			if (includeRotation != 0) {
				res::Creature_SetOrientation(liveObj->miniFigure,local_18.x,local_18.y);
			}
			pSVar2 = GetSurfaceMap();
			res::Creature_SetPosition
								(liveObj->miniFigure,x,y,SurfaceMap_LevelCallback_FUN_00442820,pSVar2);
		}
		else {
			if (OVar1 == OBJECT_ROCKMONSTER) {
				if (includeRotation != 0) {
					res::Creature_SetOrientation(liveObj->rockMonster,local_18.x,local_18.y);
				}
				pSVar2 = GetSurfaceMap();
				res::Creature_SetPosition(liveObj->rockMonster,x,y,res::Res_GetSurfaceMapZ_Callback,pSVar2);
			}
			else {
				if (OVar1 == OBJECT_BUILDING) {
					if (includeRotation != 0) {
						res::Building_SetOrientation(liveObj->building,local_18.x,local_18.y);
					}
					pSVar2 = GetSurfaceMap();
					res::Building_SetPosition(liveObj->building,x,y,res::Res_GetSurfaceMapZ_Callback,pSVar2);
				}
				else {
					if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
						if (includeRotation != 0) {
							res::Container_SetOrientation
												(liveObj->other,NULL,local_18.x,local_18.y,local_18.z,0.0,0.0,-1.0);
						}
						x_00 = x;
						y_00 = y;
						pSVar2 = GetSurfaceMap();
						fVar3 = Map3D_GetWorldZ(pSVar2,x_00,y_00);
						res::Container_SetPosition(liveObj->other,NULL,x,y,(float)fVar3);
					}
				}
			}
		}
	}
	if (includeRotation != 0) {
		(liveObj->faceDirection).x = local_18.x;
		(liveObj->faceDirection).y = local_18.y;
		(liveObj->faceDirection).z = local_18.z;
	}
	liveObj->float_2b8 = 0.01;
	(liveObj->vector_2a0).x = (liveObj->faceDirection).x * -0.01;
	(liveObj->vector_2a0).y = (liveObj->faceDirection).y * -0.01;
	(liveObj->vector_2a0).z = (liveObj->faceDirection).z * -0.01;
	(liveObj->vector_2a0).x = (liveObj->vector_2a0).x + x;
	(liveObj->vector_2a0).y = (liveObj->vector_2a0).y + y;
	(liveObj->vector_2a0).z = (liveObj->vector_2a0).z;
	return;
}



int __cdecl lego::game::LiveObject_FUN_00442dd0(LiveObject *in_liveObj,float param_2,float *param_3)
{
	ObjectType OVar1;
	bool bVar2;
	LiveObject *in_liveObj_00;
	Container *cont;
	LiveObject *liveObj;
	BOOL BVar3;
	int iVar4;
	uint uVar5;
	SurfaceMap *pSVar6;
	ObjectStatsFlags1 OVar7;
	CreatureData *creature;
	int iVar8;
	float fVar9;
	float fVar10;
	float fVar11;
	Point2F *out_x;
	code *getZcallback;
	float *out_y;
	uint local_50;
	float local_4c;
	uint local_48;
	float local_44;
	Point2F local_40;
	float local_38;
	float local_34;
	float local_30;
	float local_2c;
	float local_28;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	in_liveObj_00 = in_liveObj;
	cont = LiveObject_GetContainer(in_liveObj);
	iVar8 = 0;
	uVar5 = (uint)(in_liveObj_00->forwardSpeed_2c0 < 0);
	local_48 = uVar5;
	LiveObject_FUN_004468d0(in_liveObj_00,param_2,&local_4c,&local_44);
	res::Container_GetOrientation(cont,NULL,&local_24,&local_c);
	res::Container_GetPosition(cont,NULL,&local_18);
	local_38 = local_18.x;
	local_34 = local_18.y;
	if (in_liveObj_00->rotateSpeed_2c4 != 0.0) {
		fVar9 = 1.0;
		if (in_liveObj_00->objType == OBJECT_VEHICLE) {
			if (uVar5 == 0) {
				fVar9 = 1.0;
			}
			else {
				fVar9 = -1.0;
			}
		}
		res::Container_AddRotation
							(cont,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,fVar9 * param_2 * in_liveObj_00->rotateSpeed_2c4
							);
		iVar8 = 1;
		(in_liveObj_00->faceDirection).x = local_24.x;
		(in_liveObj_00->faceDirection).y = local_24.y;
		(in_liveObj_00->faceDirection).z = local_24.z;
	}
	if ((in_liveObj_00->strafeSpeed_2bc != 0) || (in_liveObj_00->forwardSpeed_2c0 != 0)) {
		fVar11 = (float)in_liveObj_00->forwardSpeed_2c0;
		fVar10 = (float)in_liveObj_00->strafeSpeed_2bc;
		local_2c = 0.0;
		fVar9 = 1.0 / SQRT(fVar11 * fVar11 + fVar10 * fVar10);
		local_28 = fVar9 * fVar11 * local_4c;
		local_30 = fVar9 * fVar10 * local_4c;
		res::Container_AddTranslation(cont,D3DRMCOMBINE_BEFORE,local_30,0.0,local_28);
		iVar8 = 1;
	}
	if (iVar8 == 0) goto LAB_00443210;
	bVar2 = false;
	LiveObject_GetBlockPos(in_liveObj_00,(int *)&local_50,(int *)&in_liveObj);
	LiveObject_GetPosition(in_liveObj_00,(float *)&local_40,&local_40.y);
	liveObj = (LiveObject *)
						LiveObject_DoCollisionCallbacks_FUN_00446030(in_liveObj_00,&local_40,0.0,1);
	if (liveObj != NULL) {
		LiveObject_GetPosition(liveObj,&local_30,&local_2c);
		local_30 = local_40.x - local_30;
		local_2c = local_40.y - local_2c;
		local_38 = local_40.x - local_38;
		local_34 = local_40.y - local_34;
		fVar10 = 1.0 / SQRT(local_34 * local_34 + local_38 * local_38);
		fVar9 = 1.0 / SQRT(local_2c * local_2c + local_30 * local_30);
		fVar9 = fVar9 * local_2c * fVar10 * local_34 + fVar9 * local_30 * fVar10 * local_38;
		if ((ushort)((ushort)(fVar9 < 0.0) << 8 | (ushort)(fVar9 == 0.0) << 0xe) != 0) {
			bVar2 = true;
		}
	}
	BVar3 = Game_IsNoclipOn();
	if ((BVar3 == 0) &&
		 (((iVar4 = LiveObject_FUN_00431cd0
													(in_liveObj_00,local_50,(int)in_liveObj,local_50,(int)in_liveObj,1),
			 iVar4 == 0 || (bVar2)) || (iVar4 = FUN_00432ac0(local_50,(int)in_liveObj), iVar4 != 0)))) {
		res::Container_SetPosition(cont,NULL,local_18.x,local_18.y,local_18.z);
		res::Container_SetOrientation
							(cont,NULL,local_24.x,local_24.y,local_24.z,local_c.x,local_c.y,local_c.z);
		(in_liveObj_00->faceDirection).x = local_24.x;
		(in_liveObj_00->faceDirection).y = local_24.y;
		(in_liveObj_00->faceDirection).z = local_24.z;
	}
	else {
		BVar3 = Level_GetBlockFlags1_10Not8(local_50,(uint)in_liveObj);
		if (BVar3 != 0) {
			out_y = &local_40.y;
			out_x = &local_40;
			fVar11 = 0.0;
			uVar5 = FUN_00432f00(local_50,(int)in_liveObj);
			fVar9 = local_40.x;
			fVar10 = local_40.y;
			pSVar6 = GetSurfaceMap();
			Map3D_FUN_0044fe50(pSVar6,fVar9,fVar10,uVar5,fVar11,(float *)out_x,out_y);
		}
		OVar1 = in_liveObj_00->objType;
		if (OVar1 == OBJECT_VEHICLE) {
			pSVar6 = GetSurfaceMap();
			res::Vehicle_SetPosition
								(in_liveObj_00->vehicle,local_40.x,local_40.y,res::Res_GetSurfaceMapZ_Callback,
								 pSVar6);
		}
		else {
			if (OVar1 == OBJECT_MINIFIGURE) {
				pSVar6 = GetSurfaceMap();
				creature = in_liveObj_00->miniFigure;
				getZcallback = SurfaceMap_LevelCallback_FUN_00442820;
			}
			else {
				if (OVar1 != OBJECT_ROCKMONSTER) goto LAB_004431a9;
				pSVar6 = GetSurfaceMap();
				creature = in_liveObj_00->rockMonster;
				getZcallback = res::Res_GetSurfaceMapZ_Callback;
			}
			res::Creature_SetPosition(creature,local_40.x,local_40.y,getZcallback,pSVar6);
		}
	}
LAB_004431a9:
	BVar3 = Level_GetBlockFlags1_10Not8(local_50,(uint)in_liveObj);
	if (((BVar3 != 0) &&
			(BVar3 = LiveObject_Check_FUN_004326a0(in_liveObj_00,local_50,(uint)in_liveObj,0,1),
			BVar3 != 0)) &&
		 ((in_liveObj_00->objType != OBJECT_MINIFIGURE ||
			(BVar3 = LiveObject_HasToolEquipped(in_liveObj_00,TOOL_DRILL), BVar3 != 0)))) {
		iVar8 = 3;
	}
	if ((local_48 != 0) &&
		 (OVar7 = LiveObject_GetStatsFlags1(in_liveObj_00), (OVar7 & STATS1_CROSSLAND) == STATS1_NONE))
	{
		iVar8 = 4;
	}
LAB_00443210:
	in_liveObj_00->strafeSpeed_2bc = 0;
	in_liveObj_00->forwardSpeed_2c0 = 0;
	in_liveObj_00->rotateSpeed_2c4 = 0.0;
	if (iVar8 != 0) {
		*param_3 = local_44;
	}
	return iVar8;
}



void __cdecl FUN_00443240(LiveObject *in_liveObj,float param_2)
{
	ObjectType OVar1;
	LiveFlags3 LVar2;
	LiveObject *liveObj;
	SurfaceMap *pSVar3;
	Container *pCVar4;
	BOOL BVar5;
	int iVar6;
	uint uVar7;
	float10 fVar8;
	longlong lVar9;
	float fVar10;
	float fVar11;
	float unkMultiplier;
	Vector3F *out_x;
	float *out_y;
	uint local_30;
	float local_2c;
	float local_28;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	lego::ai::AITask_LiveObject_FUN_00403a70(in_liveObj);
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		lego::game::LiveObject_GetPosition(liveObj,(float *)&in_liveObj,&param_2);
		pSVar3 = lego::game::GetSurfaceMap();
		lego::res::Vehicle_SetPosition
							(liveObj->vehicle,(float)in_liveObj,param_2,lego::res::Res_GetSurfaceMapZ_Callback,
							 pSVar3);
		return;
	}
	if (OVar1 == OBJECT_BUILDING) {
		lego::game::LiveObject_GetPosition(liveObj,(float *)&in_liveObj,&param_2);
		pSVar3 = lego::game::GetSurfaceMap();
		lego::res::Building_SetPosition
							(liveObj->building,(float)in_liveObj,param_2,lego::res::Res_GetSurfaceMapZ_Callback,
							 pSVar3);
		return;
	}
	if (OVar1 == OBJECT_ROCKMONSTER) {
		lego::game::LiveObject_GetPosition(liveObj,(float *)&in_liveObj,&param_2);
		pSVar3 = lego::game::GetSurfaceMap();
		lego::res::Creature_SetPosition
							(liveObj->rockMonster,(float)in_liveObj,param_2,lego::res::Res_GetSurfaceMapZ_Callback
							 ,pSVar3);
		return;
	}
	if (OVar1 == OBJECT_MINIFIGURE) {
		pCVar4 = lego::game::LiveObject_GetContainer(liveObj);
		lego::res::Container_GetPosition(pCVar4,NULL,&local_18);
		local_2c = local_18.x;
		local_28 = local_18.y;
		lego::game::LiveObject_GetBlockPos(liveObj,(int *)&local_30,(int *)&in_liveObj);
		BVar5 = lego::game::Level_GetBlockFlags1_10Not8(local_30,(uint)in_liveObj);
		if ((BVar5 != 0) && (iVar6 = FUN_00432ac0(local_30,(int)in_liveObj), iVar6 == 0)) {
			out_y = &local_24.y;
			out_x = &local_24;
			unkMultiplier = 0.0;
			uVar7 = FUN_00432f00(local_30,(int)in_liveObj);
			fVar10 = local_2c;
			fVar11 = local_28;
			pSVar3 = lego::game::GetSurfaceMap();
			lego::game::Map3D_FUN_0044fe50(pSVar3,fVar10,fVar11,uVar7,unkMultiplier,(float *)out_x,out_y);
			local_24.x = local_24.x - local_2c;
			local_24.y = local_24.y - local_28;
			fVar11 = param_2 * 0.5;
			fVar10 = SQRT(local_24.y * local_24.y + local_24.x * local_24.x);
			if ((ushort)((ushort)(fVar10 < fVar11) << 8 | (ushort)(fVar10 == fVar11) << 0xe) == 0) {
				local_2c = (fVar11 / fVar10) * local_24.x + local_2c;
				local_28 = (fVar11 / fVar10) * local_24.y + local_28;
			}
		}
		pSVar3 = lego::game::GetSurfaceMap();
		fVar11 = local_28;
		fVar10 = local_2c;
		fVar8 = lego::res::Res_GetSurfaceMapZ_Callback(local_2c,local_28,pSVar3);
		local_c.z = (float)fVar8;
		if (((local_18.x == local_2c) && (local_18.y == local_28)) && (local_18.z == local_c.z)) {
			return;
		}
		pSVar3 = lego::game::GetSurfaceMap();
		lego::res::Creature_SetPosition
							(liveObj->miniFigure,fVar10,fVar11,lego::game::SurfaceMap_LevelCallback_FUN_00442820,
							 pSVar3);
		return;
	}
	if ((((OVar1 != OBJECT_POWERCRYSTAL) && (OVar1 != OBJECT_ORE)) &&
			((OVar1 != OBJECT_BARRIER && ((OVar1 != OBJECT_DYNAMITE && (OVar1 != OBJECT_ELECTRICFENCE)))))
			) && (OVar1 != OBJECT_OOHSCARY)) {
		return;
	}
	if (liveObj->carryingThisObject != NULL) {
		return;
	}
	lego::game::LiveObject_GetBlockPos(liveObj,(int *)&local_30,(int *)&local_2c);
	if ((liveObj->objType == OBJECT_BARRIER) ||
		 (BVar5 = lego::game::Level_BlockIsFlags1_800(local_30,(uint)local_2c), BVar5 == 0)) {
LAB_00443554:
		if (liveObj->resData_2dc == NULL) goto LAB_00443614;
	}
	else {
		if (liveObj->resData_2dc == NULL) {
			pCVar4 = (Container *)lego::effect::Effect_Unk_RockFall_FUN_0040c4e0(local_30,(uint)local_2c);
			liveObj->resData_2dc = pCVar4;
			local_24.y = 0.0;
			local_24.x = local_2c;
			LVar2 = liveObj->flags3;
			(liveObj->point_2f4).x = (float)(ulonglong)local_30;
			liveObj->flags3 = LVar2 & ~LIVEOBJ3_UNK_100000;
			(liveObj->point_2f4).y = (float)(ulonglong)(uint)local_2c;
			goto LAB_00443554;
		}
	}
	lVar9 = __ftol((float10)(liveObj->point_2f4).y);
	uVar7 = (uint)lVar9;
	lVar9 = __ftol((float10)(liveObj->point_2f4).x);
	BVar5 = lego::game::Level_BlockIsFlags1_800((uint)lVar9,uVar7);
	if (BVar5 != 0) {
		lego::res::Container_GetPosition(liveObj->resData_2dc,NULL,&local_18);
		fVar10 = local_18.x;
		fVar11 = local_18.y;
		pSVar3 = lego::game::GetSurfaceMap();
		fVar8 = lego::game::Map3D_GetWorldZ(pSVar3,fVar10,fVar11);
		fVar8 = fVar8 - (float10)1.2285;
		if ((ushort)((ushort)((float10)local_18.z < fVar8) << 8 |
								(ushort)((float10)local_18.z == fVar8) << 0xe) == 0) {
			local_18.z = (float)fVar8;
		}
		lego::res::Container_SetPosition(liveObj->other,NULL,local_18.x,local_18.y,local_18.z);
		lego::res::Container_SetOrientation(liveObj->other,liveObj->resData_2dc,0.0,0.0,1.0,0.0,1.0,0.0)
		;
		return;
	}
LAB_00443614:
	liveObj->resData_2dc = NULL;
	lego::res::Container_GetPosition(liveObj->other,NULL,&local_24);
	fVar10 = local_24.x;
	fVar11 = local_24.y;
	pSVar3 = lego::game::GetSurfaceMap();
	fVar8 = lego::game::Map3D_GetWorldZ(pSVar3,fVar10,fVar11);
	in_liveObj = (LiveObject *)(float)(fVar8 - (float10)1.2285);
	fVar8 = (fVar8 - (float10)1.2285) - (float10)0.5;
	if ((ushort)((ushort)(fVar8 < (float10)local_24.z) << 8 |
							(ushort)(fVar8 == (float10)local_24.z) << 0xe) == 0) {
		local_24.z = local_24.z + param_2;
		if ((ushort)((ushort)(local_24.z < (float)in_liveObj) << 8 |
								(ushort)(local_24.z == (float)in_liveObj) << 0xe) == 0) {
			local_24.z = (float)in_liveObj;
		}
		lego::res::Container_SetPosition(liveObj->other,NULL,local_24.x,local_24.y,local_24.z);
	}
	if ((ushort)((ushort)(local_24.z < (float)in_liveObj - -0.5) << 8 |
							(ushort)(local_24.z == (float)in_liveObj - -0.5) << 0xe) == 0) {
		local_24.z = local_24.z - param_2;
		if (local_24.z < (float)in_liveObj) {
			local_24.z = (float)in_liveObj;
		}
		lego::res::Container_SetPosition(liveObj->other,NULL,local_24.x,local_24.y,local_24.z);
	}
	lego::res::Container_GetOrientation(liveObj->other,NULL,&local_18,&local_c);
	if (0.0 <= local_18.z) {
		if ((ushort)((ushort)(local_18.z < 0.0) << 8 | (ushort)(local_18.z == 0.0) << 0xe) == 0) {
			local_18.z = local_18.z - param_2 * 0.05;
			if (local_18.z < 0.0) {
				local_18.z = 0.0;
			}
			lego::res::Container_SetOrientation
								(liveObj->other,NULL,local_18.x,local_18.y,local_18.z,0.0,0.0,-1.0);
		}
		return;
	}
	local_18.z = local_18.z - param_2 * -0.05;
	if ((ushort)((ushort)(local_18.z < 0.0) << 8 | (ushort)(local_18.z == 0.0) << 0xe) == 0) {
		local_18.z = 0.0;
	}
	lego::res::Container_SetOrientation
						(liveObj->other,NULL,local_18.x,local_18.y,local_18.z,0.0,0.0,-1.0);
	return;
}



void __cdecl FUN_004437d0(LiveObject *liveObj)
{
	Container *cont;
	Container *cont_00;
	Vector3F local_48;
	Vector3F local_3c;
	Vector3F local_30;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	cont = lego::game::LiveObject_GetContainer(liveObj->drivenObject);
	if (liveObj->objType == OBJECT_VEHICLE) {
		cont_00 = lego::res::Vehicle_GetDriverNull(liveObj->vehicle);
		if (cont_00 != NULL) goto LAB_0044380f;
	}
	cont_00 = lego::game::LiveObject_GetContainer(liveObj);
LAB_0044380f:
	lego::res::Container_GetPosition(cont,NULL,&local_24);
	lego::res::Container_GetPosition(cont_00,NULL,&local_48);
	if (((local_24.x != local_48.x) || (local_24.y != local_48.y)) || (local_24.z != local_48.z)) {
		lego::res::Container_SetPosition(cont,NULL,local_48.x,local_48.y,local_48.z);
	}
	lego::res::Container_GetOrientation(cont,NULL,&local_18,&local_c);
	lego::res::Container_GetOrientation(cont_00,NULL,&local_30,&local_3c);
	if ((((local_18.x != local_30.x) || (local_18.y != local_30.y)) ||
			((local_18.z != local_30.z || ((local_c.x != local_3c.x || (local_c.y != local_3c.y)))))) ||
		 (local_c.z != local_3c.z)) {
		lego::res::Container_SetOrientation
							(cont,NULL,local_30.x,local_30.y,local_30.z,local_3c.x,local_3c.y,local_3c.z);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_00443930(LiveObject *liveObj)
{
	short sVar1;
	BOOL BVar2;
	uint uVar3;
	undefined4 unkbool2d8;
	
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
		BVar2 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj);
		if (BVar2 == 0) {
			uVar3 = 0;
			do {
				unkbool2d8 = 1;
				sVar1 = math::Maths_Rand();
				LiveObject_SetActivityUnk(liveObj,(int)sVar1 % 0x15 + ACTIVITY_WAITING1,unkbool2d8);
				BVar2 = LiveObject_Container_ActivityUpdate_Check(liveObj);
				if (BVar2 != 0) {
					liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_8000;
					return 1;
				}
				uVar3 += 1;
			} while (uVar3 < 5);
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_CheckRockMonsterAnd_FUN_004439b0(LiveObject *liveObj)
{
	if ((liveObj->objType == OBJECT_ROCKMONSTER) &&
		 ((liveObj->flags3 & LIVEOBJ3_CANGATHER) != LIVEOBJ3_NONE)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_FUN_004439d0
					(LiveObject *liveObj,Point2I *blockPos,Point2I *out_pointUnkForI,undefined4 unused)
{
	LiveObject *liveObj_00;
	Point2I *pPVar1;
	BOOL BVar2;
	BOOL local_8;
	void *local_4;
	
	pPVar1 = blockPos;
	liveObj_00 = liveObj;
	local_8 = 0;
	BVar2 = LiveObject_FUN_00443b00(liveObj,blockPos,&local_8);
	if (BVar2 != 0) {
		return 0;
	}
	BVar2 = LiveObject_FUN_004413b0
										(liveObj_00,pPVar1->x,pPVar1->y,0,0,&local_4,&blockPos,&liveObj,
										 LiveObject_FUN_00443b00,&local_8);
	if ((BVar2 == 0) &&
		 (BVar2 = LiveObject_FUN_004413b0
												(liveObj_00,pPVar1->x,pPVar1->y,0,0,&local_4,&blockPos,&liveObj,
												 LiveObject_FUN_00443b00,&local_8), BVar2 == 0)) {
		return 0;
	}
	out_pointUnkForI->x = *(int *)((int)local_4 + (int)liveObj * 4 + -4);
	out_pointUnkForI->y = *(int *)((int)blockPos + (int)liveObj * 4 + -4);
	std::free(local_4);
	std::free(blockPos);
	return TRUE;
}



void __cdecl lego::game::LiveObject_RockMonster_DoWakeUp(LiveObject *liveObj)
{
	if (((liveObj->objType == OBJECT_ROCKMONSTER) &&
			((liveObj->flags3 & LIVEOBJ3_POWEROFF) != LIVEOBJ3_NONE)) &&
		 ((liveObj->flags2 & LIVEOBJ2_UNK_20000000) == LIVEOBJ2_NONE)) {
		liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_20000000;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_WAKEUP,0);
		LiveObject_Container_ActivityUpdate_Check(liveObj);
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_FUN_00443b00
					(LiveObject *liveObj,Point2I *blockPos,BOOL *pAlsoCheckBlockFlags1_10Not8)
{
	BOOL BVar1;
	int iVar2;
	
	if ((*pAlsoCheckBlockFlags1_10Not8 == 0) &&
		 (BVar1 = Level_GetBlockFlags1_10Not8(blockPos->x,blockPos->y), BVar1 != 0)) {
		return 0;
	}
	iVar2 = LiveObject_FUN_00431cd0(liveObj,blockPos->x,blockPos->y,blockPos->x,blockPos->y,TRUE);
	if (((iVar2 != 0) &&
			(BVar1 = LiveObject_UnkGetDamage(liveObj,blockPos->x,blockPos->y,0.0,NULL), BVar1 == 0)) &&
		 (BVar1 = Level_BlockIsFlags1_180000(blockPos), BVar1 == 0)) {
		return TRUE;
	}
	return 0;
}



float __cdecl
lego::game::LiveObject_LargeFlagsSwitch_FUN_00443b70(LiveObject *in_liveObj,float param_2)
{
	float fVar1;
	float fVar2;
	char cVar3;
	void *pvVar4;
	LiveObject *liveObj;
	short sVar5;
	LiveFlags3 LVar6;
	LiveFlags1 LVar7;
	LiveObject *pLVar8;
	ObjectStatsFlags1 OVar9;
	SurfaceMap *surfMap;
	BOOL BVar10;
	uint uVar11;
	int iVar12;
	float10 in_ST0;
	float10 extraout_ST0;
	float10 extraout_ST0_00;
	float10 extraout_ST0_01;
	float10 extraout_ST0_02;
	float10 extraout_ST0_03;
	float10 extraout_ST0_04;
	float10 fVar13;
	float10 extraout_ST0_05;
	float10 extraout_ST0_06;
	float10 extraout_ST0_07;
	float10 extraout_ST0_08;
	float10 fVar14;
	float10 extraout_ST1;
	ulonglong uVar15;
	longlong lVar16;
	float *out_bx;
	float *out_by;
	uint local_2c;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	Point2F local_18;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	liveObj = in_liveObj;
	iVar12 = 0;
	pvVar4 = in_liveObj->routeptr_24;
	local_1c = param_2;
	BVar10 = 1;
	if (pvVar4 == NULL) {
		in_ST0 = (float10)LiveObject_UnkDoRouting_FUN_00441c00(in_liveObj,0);
	}
	else {
		if (in_liveObj->objType == OBJECT_VEHICLE) {
			in_liveObj->elapsedTime1 = 0.0;
		}
		if ((in_liveObj->vector_28c).x <= (in_liveObj->vector_28c).y) {
			LVar6 = in_liveObj->flags3;
			if ((LVar6 & 0x400) != LIVEOBJ3_NONE) {
				uVar11 = in_liveObj->routingBlocksCurrent;
				in_liveObj->flags3 = LVar6 & 0xfffffbff;
				switch(*(undefined *)((int)pvVar4 + uVar11 * 0x14 + 0x11)) {
				case 2:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_REINFORCING;
					break;
				case 3:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_UNK_200;
					break;
				case 4:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_CLEARING;
					break;
				case 5:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_UNK_800;
					break;
				case 6:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_UNK_1000000;
					break;
				case 7:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_UNK_2000;
					break;
				case 8:
					LiveObject_FUN_0043a130(in_liveObj,TRUE);
					break;
				case 9:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_PLACING;
					break;
				case 10:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_UNK_20000;
					break;
				case 0xb:
					in_liveObj->flags1 = in_liveObj->flags1 | LIVEOBJ1_EATING;
					break;
				case 0xc:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_4;
					break;
				case 0xd:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_40;
					break;
				case 0xe:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_TRAINING;
					break;
				case 0xf:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UPGRADING;
					break;
				case 0x10:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_200000;
					break;
				case 0x11:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_4000000;
					break;
				case 0x12:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_10000000;
					break;
				case 0x13:
					FUN_00444360(in_liveObj);
					break;
				case 0x14:
					ai::AITask_LiveObject_SetAITaskUnk(in_liveObj,AITASK_ATTACKOBJECT,NULL,1);
					break;
				case 0x15:
					in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_80000000;
				}
				if ((*(byte *)((int)pvVar4 + uVar11 * 0x14 + 0x10) & 0x20) != 0) {
					liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_80000;
				}
				in_ST0 = (float10)LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
				if ((liveObj->flags1 & 0x8000000) != LIVEOBJ1_NONE) {
					sVar5 = math::Maths_Rand();
					uVar15 = __ftol((float10)10.0 / (float10)param_2);
					if ((int)((ulonglong)(uint)(int)sVar5 % (uVar15 & 0xffffffff)) != 0) {
						LiveObject_FUN_00433b40(liveObj,150.0,1);
						return (float)extraout_ST0_00;
					}
					liveObj->flags1 = liveObj->flags1 & 0xf7ffffff;
					return (float)extraout_ST0;
				}
				goto LAB_004442ff;
			}
			if (in_liveObj->routingBlocksTotal < 2) {
				in_liveObj->flags3 = LVar6 | 0x400;
				*(byte *)((int)pvVar4 + in_liveObj->routingBlocksCurrent * 0x14 + 0x10) =
						 *(byte *)((int)pvVar4 + in_liveObj->routingBlocksCurrent * 0x14 + 0x10) | 8;
			}
			else {
				uVar11 = in_liveObj->routingBlocksCurrent + 1;
				in_liveObj->routingBlocksCurrent = uVar11;
				if (((*(byte *)((int)pvVar4 + uVar11 * 0x14 + 0x10) & 0x10) != 0) &&
					 (*(char *)((int)pvVar4 + uVar11 * 0x14 + 0x11) != '\x01')) {
					iVar12 = 1;
				}
			}
			uVar11 = in_liveObj->routingBlocksCurrent;
			if (iVar12 != 0) {
				uVar11 += 1;
			}
			if (*(char *)((int)pvVar4 + uVar11 * 0x14 + 0x11) == '\x05') {
				FUN_00447a90(in_liveObj);
			}
			BVar10 = LiveObject_RoutingUnk_FUN_00444940
												 (liveObj,iVar12,liveObj->flags3 & LIVEOBJ3_UNK_8,~liveObj->flags1 >> 10 & 1
												 );
			in_ST0 = extraout_ST0_01;
			if (liveObj->routingBlocksTotal - 1 <= liveObj->routingBlocksCurrent) {
				liveObj->flags3 = liveObj->flags3 | 0x400;
			}
		}
		if (BVar10 != 0) {
			if ((((((*(byte *)&liveObj->flags1 & 8) == 0) &&
						(*(char *)((int)pvVar4 + liveObj->routingBlocksCurrent * 0x14 + 0x11) == '\x01')) &&
					 (BVar10 = LiveObject_GetDrillNullPosition(liveObj,&local_20,&local_24), BVar10 != 0)) &&
					((BVar10 = Level_ToBlockCoordinatesNoZ
															 (local_20,local_24,(int *)&in_liveObj,(int *)&local_2c), BVar10 != 0
					 && (BVar10 = Level_GetBlockFlags1_10Not8((uint)in_liveObj,local_2c), BVar10 != 0)))) &&
				 ((in_liveObj == *(LiveObject **)((int)pvVar4 + liveObj->routingBlocksCurrent * 0x14) &&
					(local_2c == *(uint *)((int)pvVar4 + liveObj->routingBlocksCurrent * 0x14 + 4))))) {
				BVar10 = 1;
				LVar6 = liveObj->flags3 & LIVEOBJ3_UNK_2000000;
				lVar16 = __ftol((float10)(liveObj->point_2f4).y);
				uVar11 = (uint)lVar16;
				lVar16 = __ftol((float10)(liveObj->point_2f4).x);
				BVar10 = LiveObject_Check_FUN_004326a0(liveObj,(uint)lVar16,uVar11,LVar6,BVar10);
				if (BVar10 == 0) {
					LVar7 = liveObj->flags1 | LIVEOBJ1_UNK_80000000;
				}
				else {
					LVar7 = liveObj->flags1 | (LIVEOBJ1_UNK_8|LIVEOBJ1_UNK_10);
				}
				liveObj->flags1 = LVar7;
			}
			LiveObject_FUN_004468d0(liveObj,param_2,&local_28,&local_1c);
			if ((liveObj->flags3 & LIVEOBJ3_UNK_4000) == LIVEOBJ3_NONE) {
				(liveObj->vector_28c).y = local_28 + (liveObj->vector_28c).y;
			}
			fVar1 = (liveObj->vector_28c).y;
			fVar2 = (liveObj->vector_28c).x;
			if ((ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) == 0) {
				fVar1 = (liveObj->vector_28c).y;
				(liveObj->vector_28c).y = (liveObj->vector_28c).x;
				(liveObj->vector_28c).z = fVar1 - (liveObj->vector_28c).x;
			}
			Routing_Calculate_FUN_004067f0
								((RoutingData *)&liveObj->routing_count_0,(liveObj->vector_28c).y,&local_18);
			cVar3 = *(char *)((int)pvVar4 + liveObj->routingBlocksCurrent * 0x14 + 0x11);
			in_ST0 = extraout_ST0_02;
			if (cVar3 == '\x03') {
				if (liveObj->object_2fc != NULL) {
					LiveObject_GetPosition(liveObj->object_2fc,&local_8,&local_4);
					local_10 = local_8 - local_18.x;
					local_c = local_4 - local_18.y;
					fVar1 = SQRT(local_c * local_c + local_10 * local_10);
					in_ST0 = extraout_ST0_03;
					if ((ushort)((ushort)(fVar1 < 6.6) << 8 | (ushort)(fVar1 == 6.6) << 0xe) != 0) {
						liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_200;
						in_ST0 = (float10)LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
						if ((liveObj->objType == OBJECT_MINIFIGURE) && (fVar1 != 0.0)) {
							res::Creature_SetOrientation(liveObj->miniFigure,local_10,local_c);
							(liveObj->faceDirection).x = local_10;
							(liveObj->faceDirection).y = local_c;
							return (float)extraout_ST0_04;
						}
						goto LAB_004442ff;
					}
				}
			}
			else {
				if (cVar3 == '\f') {
					if (liveObj->object_2fc != NULL) {
						LiveObject_GetPosition(liveObj->object_2fc,&local_8,&local_4);
						fVar2 = local_18.x - local_8;
						fVar1 = local_18.y - local_4;
						fVar14 = LiveObject_GetCollRadius(liveObj->object_2fc);
						fVar13 = (float10)SQRT(fVar1 * fVar1 + fVar2 * fVar2);
						in_ST0 = extraout_ST1;
						if ((ushort)((ushort)(fVar13 < fVar14) << 8 | (ushort)(fVar13 == fVar14) << 0xe) != 0) {
							liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_4;
							fVar14 = (float10)LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
							return (float)fVar14;
						}
					}
				}
				else {
					if ((cVar3 == '\t') &&
						 ((*(byte *)((int)pvVar4 + liveObj->routingBlocksCurrent * 0x14 + 0x10) & 0xc) == 0)) {
						uVar11 = ((RoutingData *)&liveObj->routing_count_0)->count;
						local_8 = liveObj->routing_points_4[uVar11 - 1].x;
						local_4 = liveObj->routing_points_4[uVar11 - 1].y;
						fVar1 = SQRT((local_18.y - local_4) * (local_18.y - local_4) +
												 (local_18.x - local_8) * (local_18.x - local_8));
						if ((ushort)((ushort)(fVar1 < 6.0) << 8 | (ushort)(fVar1 == 6.0) << 0xe) != 0) {
							liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_PLACING;
							fVar14 = (float10)LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
							return (float)fVar14;
						}
					}
				}
			}
			if (((((liveObj->flags3 & 0x800) == LIVEOBJ3_NONE) &&
					 (cVar3 = *(char *)((int)pvVar4 + liveObj->routingBlocksCurrent * 0x14 + 0x11),
					 cVar3 != '\a')) && (cVar3 != '\x06')) &&
				 (((cVar3 != '\x03' && (cVar3 != '\x05')) &&
					(pLVar8 = (LiveObject *)
										LiveObject_DoCollisionCallbacks_FUN_00446030(liveObj,&local_18,0.0,0),
					in_ST0 = extraout_ST0_05, pLVar8 != NULL)))) {
				OVar9 = LiveObject_GetStatsFlags1(liveObj);
				if (((OVar9 & STATS1_BUMPDAMAGE) != STATS1_NONE) && (pLVar8->objType == OBJECT_VEHICLE)) {
					LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_REPAIR,0);
					LiveObject_Container_ActivityUpdate_Check(liveObj);
					liveObj->object_2fc = pLVar8;
					liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_40000;
					return (float)extraout_ST0_06;
				}
				LiveObject_RoutingUnk_FUN_00444940(liveObj,0,0,0);
				fVar1 = (liveObj->vector_28c).y;
				liveObj->flags3 = liveObj->flags3 | 0x800;
				(liveObj->vector_28c).y = local_28 + fVar1;
				in_ST0 = extraout_ST0_07;
			}
			if ((liveObj->flags3 & LIVEOBJ3_UNK_4000) == LIVEOBJ3_NONE) {
				in_ST0 = (float10)LiveObject_FUN_004428b0(liveObj,local_18.x,local_18.y);
			}
			if ((*(char *)((int)pvVar4 + liveObj->routingBlocksTotal * 0x14 + -3) == '\x04') &&
				 (liveObj->objType == OBJECT_VEHICLE)) {
				out_by = &local_4;
				out_bx = &local_8;
				surfMap = GetSurfaceMap();
				Map3D_WorldToBlockPos_NoZ(surfMap,local_18.x,local_18.y,(int *)out_bx,(int *)out_by);
				in_ST0 = extraout_ST0_08;
				if ((local_8 == *(float *)((int)pvVar4 + liveObj->routingBlocksTotal * 0x14 + -0x14)) &&
					 (local_4 == *(float *)((int)pvVar4 + liveObj->routingBlocksTotal * 0x14 + -0x10))) {
					liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_CLEARING;
					fVar14 = (float10)LiveObject_UnkDoRouting_FUN_00441c00(liveObj,1);
					return (float)fVar14;
				}
			}
		}
	}
LAB_004442ff:
	return (float)in_ST0;
}



void __cdecl FUN_00444360(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	
	pLVar1 = liveObj->object_2fc;
	if ((pLVar1 != NULL) && (pLVar1->objType == OBJECT_BUILDING)) {
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_40;
		pLVar1->flags4 = pLVar1->flags4 | LIVEOBJ4_UNK_40;
		lego::ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_DOCK,NULL,1);
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_004443b0(LiveObject *liveObj,float elapsed)
{
	BOOL BVar1;
	float10 fVar2;
	Point2I blockPos;
	
	if (((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) &&
		 ((liveObj->objType != OBJECT_ROCKMONSTER ||
			(liveObj->carriedObjects[0]->objType == OBJECT_BOULDER)))) {
		fVar2 = LiveObject_GetCarryMinHealth(liveObj);
		if ((fVar2 < (float10)liveObj->health) && ((*(byte *)&liveObj->flags4 & 0x20) == 0)) {
			fVar2 = LiveObject_GetRestPercent(liveObj);
			if ((((float)(fVar2 * (float10)0.01) != 0.0) && ((*(byte *)&liveObj->flags1 & 4) == 0)) &&
				 ((float)(fVar2 * (float10)0.01) * liveObj->health < liveObj->float_33c * 0.04)) {
				LiveObject_GetBlockPos(liveObj,(int *)&blockPos,&blockPos.y);
				BVar1 = Level_Block_IsLava(&blockPos);
				if (((BVar1 == 0) &&
						((globs::gameGlobs.level)->blocks
						 [((globs::gameGlobs.level)->dimensions).width * blockPos.y + blockPos.x].terrain !=
						 TERRAIN_LAKE)) && (liveObj->routingBlocksCurrent != liveObj->routingBlocksTotal - 1)) {
					liveObj->float_33c = 0.0;
					liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_4000;
					liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_REST;
					LiveObject_SetActivityUnk(liveObj,ACTIVITY_REST,FALSE);
					LiveObject_Container_ActivityUpdate_Check(liveObj);
				}
			}
			liveObj->float_33c = elapsed + liveObj->float_33c;
			return;
		}
		LiveObject_FUN_0043a130(liveObj,FALSE);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_00444520(LiveObject *liveObj)
{
	int iVar1;
	short sVar2;
	BOOL BVar3;
	int iVar4;
	int iVar5;
	SurfaceMap *surfMap;
	uint uVar6;
	uint y;
	float10 fVar7;
	Vector3F *out_vertices4;
	int local_90;
	float *local_8c;
	int local_88;
	float *local_84;
	uint local_80;
	uint local_7c;
	float local_78;
	float local_74;
	Point2I ANGLES [8];
	Vector3F local_30 [2];
	float local_18;
	float local_14;
	
	ANGLES[0].x = -1;
	ANGLES[0].y = 0;
	ANGLES[1].x = -1;
	ANGLES[1].y = 1;
	ANGLES[2].x = 0;
	ANGLES[2].y = 1;
	ANGLES[3].x = 1;
	ANGLES[3].y = 1;
	ANGLES[4].x = 1;
	ANGLES[4].y = 0;
	ANGLES[5].x = 1;
	ANGLES[5].y = -1;
	ANGLES[6].x = 0;
	ANGLES[6].y = -1;
	ANGLES[7].x = -1;
	ANGLES[7].y = -1;
	BVar3 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj);
	if (BVar3 != 0) {
		return 0;
	}
	LiveObject_GetBlockPos(liveObj,&local_90,&local_88);
	local_80 = 0;
	do {
		sVar2 = math::Maths_Rand();
		uVar6 = (int)sVar2 >> 0x1f;
										// positive modulus 8 (???)
		iVar4 = (((int)sVar2 ^ uVar6) - uVar6 & 7 ^ uVar6) - uVar6;
		iVar1 = ANGLES[iVar4].y;
		iVar4 = ANGLES[iVar4].x;
		iVar5 = LiveObject_FUN_00431cd0
											(liveObj,local_90 + iVar4,local_88 + iVar1,local_90 + iVar4,local_88 + iVar1,0
											);
		if (iVar5 != 0) {
			out_vertices4 = local_30;
			y = local_88 + iVar1;
			uVar6 = local_90 + iVar4;
			surfMap = GetSurfaceMap();
			Map3D_GetBlockVertexPositions(surfMap,uVar6,y,out_vertices4);
			fVar7 = math::Maths_RandRange(local_30[0].x - -1.0,local_18 - 1.0);
			local_78 = (float)fVar7;
			fVar7 = math::Maths_RandRange(local_30[0].y - -1.0,local_14 - 1.0);
			local_74 = (float)fVar7;
			BVar3 = LiveObject_FUN_004413b0
												(liveObj,local_90,local_88,local_90 + iVar4,local_88 + iVar1,&local_8c,
												 &local_84,&local_7c,0,0);
			if (BVar3 != 0) {
				BVar3 = LiveObject_FUN_004419c0(liveObj,local_7c,local_8c,local_84,&local_78);
				if (BVar3 != 0) {
					std::free(local_8c);
					std::free(local_84);
					return 1;
				}
				std::free(local_8c);
				std::free(local_84);
			}
		}
		local_80 += 1;
	} while (local_80 < 0x10);
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_00444720(LiveObject *liveObj,Point2F *param_2)
{
	BOOL BVar1;
	SurfaceMap *surfMap;
	float in_x;
	float in_y;
	char **out_bx;
	VehicleData **out_by;
	VehicleData **local_20;
	uint local_1c;
	float local_18;
	float local_14;
	char *local_10;
	VehicleData *local_c;
	char *local_8;
	VehicleData *local_4;
	LiveObject *liveObj_00;
	
	liveObj_00 = liveObj;
	LiveObject_GetBlockPos(liveObj,(int *)&local_10,(int *)&local_c);
	if (((((liveObj_00->flags1 & LIVEOBJ1_UNK_800000) == LIVEOBJ1_NONE) &&
			 (BVar1 = LiveObject_CheckCondition_FUN_00438870(liveObj_00,1), BVar1 != 0)) &&
			(BVar1 = LiveObject_Check_FUN_004294f0(liveObj_00), BVar1 == 0)) &&
		 ((liveObj_00->drivenObject == NULL &&
			(BVar1 = Level_GetBlockFlags1_10Not8((uint)local_10,(uint)local_c), BVar1 == 0)))) {
		LiveObject_FUN_00441df0(liveObj_00,1,1);
		LiveObject_GetPosition(liveObj_00,&local_18,&local_14);
		out_bx = &local_8;
		in_x = globs::gameGlobs.MiniFigureRunAway * param_2->x + local_18;
		out_by = &local_4;
		in_y = param_2->y * globs::gameGlobs.MiniFigureRunAway + local_14;
		local_18 = in_x;
		local_14 = in_y;
		surfMap = GetSurfaceMap();
		BVar1 = Map3D_WorldToBlockPos_NoZ(surfMap,in_x,in_y,(int *)out_bx,(int *)out_by);
		if (BVar1 != 0) {
			if ((local_8 == local_10) && (local_4 == local_c)) {
				liveObj = (LiveObject *)&local_10;
				local_20 = &local_c;
				local_1c = 1;
			}
			else {
				BVar1 = LiveObject_FUN_004413b0
													(liveObj_00,local_10,local_c,local_8,local_4,&liveObj,&local_20,&local_1c,
													 0,0);
				if (BVar1 == 0) {
					return;
				}
			}
			BVar1 = LiveObject_FUN_004419c0
												(liveObj_00,local_1c,(float *)liveObj,(float *)local_20,&local_18);
			if (BVar1 != 0) {
				*(byte *)((int)liveObj_00->routeptr_24 + liveObj_00->routingBlocksTotal * 0x14 + -4) =
						 *(byte *)((int)liveObj_00->routeptr_24 + liveObj_00->routingBlocksTotal * 0x14 + -4) |
						 0x40;
			}
			std::free(liveObj);
			std::free(local_20);
			liveObj_00->flags1 = liveObj_00->flags1 | LIVEOBJ1_UNK_800000;
			front::Bubble_LiveObject_MiniFigure_FUN_00407380(liveObj_00);
		}
	}
	return;
}



void __cdecl lego::ai::AI_LiveObject_DoSlip(LiveObject *liveObj)
{
	if (((liveObj->flags1 & LIVEOBJ1_UNK_4000000) == LIVEOBJ1_NONE) && (liveObj->drivenObject == NULL)
		 ) {
		game::LiveObject_FUN_00441df0(liveObj,FALSE,TRUE);
		liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_4000000;
		game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_SLIP,FALSE);
		game::LiveObject_Container_ActivityUpdate_Check(liveObj);
		AITask_DoAnimationWait(liveObj);
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_RoutingUnk_FUN_00444940
					(LiveObject *liveObj,int param_2,int param_3,int param_4)
{
	Vector3F *out_vector;
	uint *puVar1;
	byte bVar2;
	LiveFlags1 LVar3;
	LiveFlags3 LVar4;
	SurfaceMap *pSVar5;
	uint uVar6;
	float fVar7;
	BOOL BVar8;
	int iVar9;
	uint uVar10;
	Point2F *pPVar11;
	float fVar12;
	float10 fVar13;
	float fVar14;
	uint uVar15;
	uint by;
	float unkMultiplier;
	float *pfVar16;
	ActivityType AVar17;
	float *pfVar18;
	float local_74;
	float local_70;
	float local_6c;
	float local_68;
	undefined4 local_64;
	BOOL local_60;
	uint local_5c;
	uint local_58;
	Point2F local_54;
	Point2F local_4c;
	Point2F local_44;
	Point2F local_3c;
	float local_34;
	float local_30;
	Vector3F local_2c;
	Point2F local_20 [4];
	
	local_6c = 0.0;
	local_70 = 0.0;
	local_60 = 1;
	uVar10 = *(uint *)((int)liveObj->routeptr_24 + liveObj->routingBlocksCurrent * 0x14);
	by = *(uint *)((int)liveObj->routeptr_24 + liveObj->routingBlocksCurrent * 0x14 + 4);
	LiveObject_GetBlockPos(liveObj,(int *)&local_58,(int *)&local_5c);
	LiveObject_GetPosition(liveObj,(float *)&local_3c,&local_3c.y);
	local_44.x = (liveObj->faceDirection).x;
	local_44.y = (liveObj->faceDirection).y;
	out_vector = &liveObj->faceDirection;
	if (param_2 == 0) {
		pfVar18 = &local_4c.y;
		pPVar11 = &local_4c;
		pSVar5 = GetSurfaceMap();
		Map3D_BlockToWorldPos(pSVar5,uVar10,by,(float *)pPVar11,pfVar18);
	}
	else {
		pfVar18 = &local_30;
		uVar6 = *(uint *)((int)liveObj->routeptr_24 + liveObj->routingBlocksCurrent * 0x14 + 4);
		pfVar16 = &local_34;
		uVar15 = *(uint *)((int)liveObj->routeptr_24 + liveObj->routingBlocksCurrent * 0x14);
		pSVar5 = GetSurfaceMap();
		Map3D_BlockToWorldPos(pSVar5,uVar15,uVar6,pfVar16,pfVar18);
		uVar6 = liveObj->routingBlocksCurrent + 1;
		liveObj->routingBlocksCurrent = uVar6;
		pfVar18 = &local_4c.y;
		pPVar11 = &local_4c;
		puVar1 = (uint *)((int)liveObj->routeptr_24 + uVar6 * 0x14);
		uVar6 = *puVar1;
		uVar15 = puVar1[1];
		pSVar5 = GetSurfaceMap();
		Map3D_BlockToWorldPos(pSVar5,uVar6,uVar15,(float *)pPVar11,pfVar18);
		local_58 = uVar10;
		local_5c = by;
	}
	pfVar18 = &local_54.y;
	pPVar11 = &local_54;
	pSVar5 = GetSurfaceMap();
	Map3D_BlockToWorldPos(pSVar5,local_58,local_5c,(float *)pPVar11,pfVar18);
	fVar12 = local_6c;
	fVar7 = local_70;
	if (*(char *)((int)liveObj->routeptr_24 + liveObj->routingBlocksCurrent * 0x14 + 0x11) != '\x01')
	{
		pfVar18 = &local_74;
		pfVar16 = &local_70;
		fVar12 = local_4c.x;
		fVar7 = local_4c.y;
		pSVar5 = GetSurfaceMap();
		Map3D_WorldToBlockPos_NoZ(pSVar5,fVar12,fVar7,(int *)pfVar16,(int *)pfVar18);
		fVar7 = (float)FUN_00432f00((int)local_70,(int)local_74);
		BVar8 = Level_GetBlockFlags1_10Not8((uint)local_70,(uint)local_74);
		fVar12 = local_6c;
		if ((BVar8 != 0) &&
			 (iVar9 = FUN_00432ac0((int)local_70,(int)local_74), fVar12 = local_6c, iVar9 == 0)) {
			uVar10 = FUN_00432f30((int)local_70,(int)local_74);
			if (uVar10 != 0) {
				if (ABS(local_4c.x - local_54.x) <= ABS(local_4c.y - local_54.y)) {
					local_20[0].x = 0.1;
					local_20[0].y = 0.0;
					local_20[1].x = -0.1;
					local_20[1].y = 0.0;
					local_20[2].x = -0.1;
					local_20[2].y = 0.0;
					local_20[3].x = 0.1;
					local_20[3].y = 0.0;
					uVar10 = FUN_004331f0((int)local_70,(int)local_74);
					pPVar11 = local_20 + uVar10;
				}
				else {
					local_20[0].x = 0.0;
					local_20[0].y = -0.1;
					local_20[1].x = 0.0;
					local_20[1].y = -0.1;
					local_20[2].x = 0.0;
					local_20[2].y = 0.1;
					local_20[3].x = 0.0;
					local_20[3].y = 0.1;
					uVar10 = FUN_004331f0((int)local_70,(int)local_74);
					pPVar11 = local_20 + uVar10;
				}
				local_4c.x = pPVar11->x + local_4c.x;
				local_4c.y = pPVar11->y + local_4c.y;
			}
			pfVar18 = &local_4c.y;
			pPVar11 = &local_4c;
			unkMultiplier = 0.05;
			uVar10 = FUN_00432f00((int)local_70,(int)local_74);
			fVar12 = local_4c.x;
			fVar14 = local_4c.y;
			pSVar5 = GetSurfaceMap();
			Map3D_FUN_0044fe50(pSVar5,fVar12,fVar14,uVar10,unkMultiplier,(float *)pPVar11,pfVar18);
			fVar12 = 1.401298e-45;
		}
	}
	if (fVar12 == 0.0) {
		pSVar5 = GetSurfaceMap();
		fVar13 = Map3D_GetBlockSize(pSVar5);
		local_6c = (float)(((float10)*(float *)((int)liveObj->routeptr_24 +
																					 liveObj->routingBlocksCurrent * 0x14 + 8) - (float10)0.5)
											* fVar13);
		pSVar5 = GetSurfaceMap();
		fVar13 = Map3D_GetBlockSize(pSVar5);
		local_68 = (float)(((float10)*(float *)((int)liveObj->routeptr_24 +
																					 liveObj->routingBlocksCurrent * 0x14 + 0xc) -
											 (float10)0.5) * fVar13);
		local_4c.x = local_6c + local_4c.x;
		local_4c.y = local_68 + local_4c.y;
	}
	bVar2 = *(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksCurrent * 0x14 + 0x10);
	if ((bVar2 & 4) == 0) {
		if ((bVar2 & 0x40) == 0) {
			if (((bVar2 & 8) != 0) && ((local_6c != 0.0 || (local_68 != 0.0)))) {
				local_54.x = local_6c;
				local_54.y = local_68;
				goto LAB_00444e0b;
			}
			local_54.x = local_4c.x - local_54.x;
			fVar14 = local_4c.y - local_54.y;
			local_54.y = fVar14;
			if ((fVar12 != 0.0) && (fVar7 == 0.0)) {
				local_54.y = fVar7;
				if (ABS(local_54.x) <= ABS(fVar14)) {
					local_54.x = 0.0;
					local_54.y = fVar14;
				}
				goto LAB_00444e0b;
			}
			if ((local_54.x != 0.0) || (fVar14 != 0.0)) goto LAB_00444e0b;
		}
		local_54.x = local_4c.x - local_3c.x;
		local_54.y = local_4c.y - local_3c.y;
		goto LAB_00444e0b;
	}
	switch(bVar2 & 3) {
	case 0:
		local_54.x = 0.0;
		local_54.y = 1.0;
		param_3 = 0;
		goto LAB_00444e0b;
	case 1:
		local_54.x = 1.0;
		break;
	case 2:
		local_54.x = 0.0;
		local_54.y = -1.0;
		param_3 = 0;
		goto LAB_00444e0b;
	case 3:
		local_54.x = -1.0;
		break;
	default:
		goto switchD_00444cce_caseD_4;
	}
	local_54.y = 0.0;
switchD_00444cce_caseD_4:
	param_3 = 0;
LAB_00444e0b:
	if (param_3 != 0) {
		local_2c.x = local_4c.x - local_3c.x;
		fVar12 = local_4c.y - local_3c.y;
		local_2c.z = 0.0;
		local_64 = 0;
		local_2c.y = 1.0 / SQRT(fVar12 * fVar12 + local_2c.x * local_2c.x);
		local_68 = 1.0 / SQRT(local_44.y * local_44.y + local_44.x * local_44.x);
		fVar7 = 1.0 / SQRT(local_54.y * local_54.y + local_54.x * local_54.x);
		local_2c.x = local_2c.y * local_2c.x;
		local_2c.y = local_2c.y * fVar12;
		local_6c = local_68 * local_44.x;
		local_68 = local_68 * local_44.y;
		local_74 = fVar7 * local_54.y * local_68 + fVar7 * local_54.x * local_6c;
		local_70 = local_2c.y * local_68 + local_2c.x * local_6c + 0.0;
		if (((param_4 == 0) ||
				((ushort)((ushort)(local_74 < 0.7) << 8 | (ushort)(local_74 == 0.7) << 0xe) != 0)) ||
			 (-0.7 <= local_70)) {
			if (((((ushort)((ushort)(local_74 < 0.0) << 8 | (ushort)(local_74 == 0.0) << 0xe) != 0) &&
					 (local_70 < 0.7)) &&
					((ushort)((ushort)(ABS(local_70) < 0.1) << 8 | (ushort)(ABS(local_70) == 0.1) << 0xe) == 0
					)) || (BVar8 = FUN_00445860(liveObj), BVar8 != 0)) {
				if (-0.9 <= local_74) {
					fVar12 = local_2c.x * (liveObj->faceDirection).z;
					fVar7 = local_2c.x * (liveObj->faceDirection).y;
					fVar14 = out_vector->x * local_2c.y;
					local_2c.x = local_2c.y * (liveObj->faceDirection).z -
											 local_2c.z * (liveObj->faceDirection).y;
					local_2c.y = out_vector->x * local_2c.z - fVar12;
					local_2c.z = fVar7 - fVar14;
					math::Maths_Vector3DRotate(out_vector,out_vector,&local_2c,-1.570796);
					if (liveObj->objType != OBJECT_VEHICLE) {
						local_44.x = out_vector->x;
						local_44.y = (liveObj->faceDirection).y;
					}
					if ((ushort)((ushort)(local_2c.z < 0.0) << 8 | (ushort)(local_2c.z == 0.0) << 0xe) == 0) {
						if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
							AVar17 = ACTIVITY_TURNRIGHT;
						}
						else {
							AVar17 = ACTIVITY_CARRYTURNRIGHT;
						}
					}
					else {
						if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
							AVar17 = ACTIVITY_TURNLEFT;
						}
						else {
							AVar17 = ACTIVITY_CARRYTURNLEFT;
						}
					}
					LiveObject_SetActivityUnk(liveObj,AVar17,1);
				}
				else {
					if (liveObj->objType != OBJECT_VEHICLE) {
						local_44.x = -out_vector->x;
						out_vector->x = local_44.x;
						local_44.y = -(liveObj->faceDirection).y;
						(liveObj->faceDirection).y = local_44.y;
					}
					if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
						AVar17 = ACTIVITY_TURNRIGHT;
					}
					else {
						AVar17 = ACTIVITY_CARRYTURNRIGHT;
					}
					LiveObject_SetActivityUnk(liveObj,AVar17,0);
					if (liveObj->objType != OBJECT_VEHICLE) {
						liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_TURNRIGHT;
					}
				}
				LVar3 = liveObj->flags1;
				liveObj->flags1 = LVar3 | LIVEOBJ1_TURNING;
				if (liveObj->objType != OBJECT_VEHICLE) {
					local_60 = 0;
					liveObj->flags1 = LVar3 & ~LIVEOBJ1_MOVING | LIVEOBJ1_TURNING;
				}
			}
		}
		else {
			local_44.x = -local_44.x;
			local_44.y = -local_44.y;
			local_54.x = -local_54.x;
			local_54.y = -local_54.y;
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_LIFTING;
		}
	}
	local_6c = SQRT((local_3c.y - local_4c.y) * (local_3c.y - local_4c.y) +
									(local_3c.x - local_4c.x) * (local_3c.x - local_4c.x)) * 0.2;
	if ((ushort)((ushort)(local_6c < 0.1) << 8 | (ushort)(local_6c == 0.1) << 0xe) == 0) {
		fVar12 = (float)std::_finite((double)local_44.x);
		if (fVar12 == 0.0) {
			local_44.x = 1.0;
			local_44.y = fVar12;
		}
		math::Routing_Maths_Vector2DChangeLength(&local_44,local_6c);
		math::Routing_Maths_Vector2DChangeLength(&local_54,local_6c * 1.6);
		Routing_DoMath_FUN_00406750
							((RoutingData *)&liveObj->routing_count_0,&local_3c,&local_44,&local_4c,&local_54,0x32
							);
		LiveObject_FUN_004454a0(liveObj);
	}
	else {
		liveObj->routing_points_4[0].x = local_3c.x;
		liveObj->routing_points_4[0].y = local_3c.y;
		liveObj->routing_count_0 = 0;
	}
	fVar13 = Routing_UpdateDistances_RetTotal((RoutingData *)&liveObj->routing_count_0);
	LVar4 = liveObj->flags3;
	fVar12 = (liveObj->vector_28c).z;
	(liveObj->vector_28c).x = (float)fVar13;
	(liveObj->point_298).x = local_54.x;
	liveObj->flags3 = LVar4 & 0xfffff7ff;
	(liveObj->vector_28c).y = fVar12;
	(liveObj->point_298).y = local_54.y;
	return local_60;
}



void __cdecl lego::game::LiveObject_FUN_00445270(LiveObject *liveObj,Point2F *point)
{
	Vector3F *out_vector;
	float fVar1;
	float fVar2;
	float fVar3;
	LiveFlags1 LVar4;
	ActivityType actType;
	float10 fVar5;
	Vector3F local_c;
	
	if (liveObj->objType != OBJECT_MINIFIGURE) {
		return;
	}
	fVar1 = (liveObj->faceDirection).y;
	fVar2 = (liveObj->faceDirection).z;
	out_vector = &liveObj->faceDirection;
	local_c.x = point->x;
	fVar3 = point->y;
	local_c.z = 0.0;
	fVar1 = 1.0 / SQRT(out_vector->x * out_vector->x + fVar2 * fVar2 + fVar1 * fVar1);
	local_c.y = 1.0 / SQRT(fVar3 * fVar3 + local_c.x * local_c.x);
	local_c.x = local_c.y * local_c.x;
	out_vector->x = out_vector->x * fVar1;
	local_c.y = local_c.y * fVar3;
	(liveObj->faceDirection).y = fVar1 * (liveObj->faceDirection).y;
	(liveObj->faceDirection).z = fVar1 * (liveObj->faceDirection).z;
	fVar5 = std::acos((float10)(liveObj->faceDirection).y * (float10)local_c.y +
										(float10)(liveObj->faceDirection).z * (float10)0.0 +
										(float10)out_vector->x * (float10)local_c.x);
	fVar1 = (float)fVar5;
	LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
	if ((ushort)((ushort)(fVar1 < 2.356194) << 8 | (ushort)(fVar1 == 2.356194) << 0xe) == 0) {
		LVar4 = liveObj->flags1;
		out_vector->x = -out_vector->x;
		(liveObj->faceDirection).y = -(liveObj->faceDirection).y;
		liveObj->flags1 = LVar4 | LIVEOBJ1_TURNRIGHT;
	}
	else {
		if ((ushort)((ushort)(fVar1 < 0.7853982) << 8 | (ushort)(fVar1 == 0.7853982) << 0xe) != 0) {
			return;
		}
		fVar1 = local_c.x * (liveObj->faceDirection).z;
		fVar2 = local_c.x * (liveObj->faceDirection).y;
		fVar3 = out_vector->x * local_c.y;
		local_c.x = local_c.y * (liveObj->faceDirection).z - local_c.z * (liveObj->faceDirection).y;
		local_c.y = out_vector->x * local_c.z - fVar1;
		local_c.z = fVar2 - fVar3;
		math::Maths_Vector3DRotate(out_vector,out_vector,&local_c,-1.570796);
		actType = ACTIVITY_TURNLEFT;
		if (local_c.z < 0.0) goto LAB_00445461;
	}
	actType = ACTIVITY_TURNRIGHT;
LAB_00445461:
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		actType = (actType == ACTIVITY_TURNRIGHT) + ACTIVITY_CARRYTURNLEFT;
	}
	liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_TURNING;
	LiveObject_SetActivityUnk(liveObj,actType,0);
	LiveObject_Container_ActivityUpdate_Check(liveObj);
	return;
}



void __cdecl lego::game::LiveObject_FUN_004454a0(LiveObject *in_liveObj)
{
	char cVar1;
	LiveObject *liveObj;
	ObjectStatsFlags1 OVar2;
	SurfaceMap *pSVar3;
	BOOL BVar4;
	Point2F *pPVar5;
	uint uVar6;
	float10 fVar7;
	float fVar8;
	uint bx;
	float fVar9;
	LiveObject *by;
	uint *out_bx;
	float *out_x;
	LiveObject **out_by;
	float *out_y;
	uint local_14;
	LiveObject *local_10;
	float local_c;
	float local_8;
	float local_4;
	
	liveObj = in_liveObj;
	OVar2 = LiveObject_GetStatsFlags1(in_liveObj);
	if (((((OVar2 & STATS1_ROUTEAVOIDANCE) != STATS1_NONE) &&
			 (cVar1 = *(char *)((int)liveObj->routeptr_24 + liveObj->routingBlocksCurrent * 0x14 + 0x11),
			 cVar1 != '\a')) && (cVar1 != '\x03')) && ((cVar1 != '\x06' && (cVar1 != '\x05')))) {
		local_10 = liveObj;
		OVar2 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar2 & STATS1_COLLRADIUS) != STATS1_NONE) {
			Search_LiveObjects_SkipIgnoreMes(FUN_00445600,&local_10);
		}
		uVar6 = 0;
		if (liveObj->routing_count_0 != 0) {
			pPVar5 = liveObj->routing_points_4;
			do {
				fVar9 = pPVar5->y;
				out_by = &in_liveObj;
				out_bx = &local_14;
				fVar8 = pPVar5->x;
				pSVar3 = GetSurfaceMap();
				Map3D_WorldToBlockPos_NoZ(pSVar3,fVar8,fVar9,(int *)out_bx,(int *)out_by);
				BVar4 = Level_BlockIsFlags1_400_AndOptIsFlags2_4(local_14,(int)in_liveObj,0);
				if (BVar4 != 0) {
					out_y = &local_4;
					out_x = &local_8;
					bx = local_14;
					by = in_liveObj;
					pSVar3 = GetSurfaceMap();
					Map3D_BlockToWorldPos(pSVar3,bx,(uint)by,out_x,out_y);
					fVar8 = pPVar5->x - local_8;
					fVar9 = pPVar5->y - local_4;
					local_c = SQRT(fVar8 * fVar8 + fVar9 * fVar9);
					pPVar5->x = (1.0 / local_c) * fVar8;
					pPVar5->y = (1.0 / local_c) * fVar9;
					pSVar3 = GetSurfaceMap();
					fVar7 = Map3D_GetBlockSize(pSVar3);
					pPVar5->x = (float)(fVar7 * (float10)0.71 * (float10)pPVar5->x + (float10)local_8);
					pPVar5->y = (float)(fVar7 * (float10)0.71 * (float10)pPVar5->y + (float10)local_4);
				}
				uVar6 += 1;
				pPVar5 = pPVar5 + 1;
			} while (uVar6 < (uint)liveObj->routing_count_0);
		}
	}
	return;
}



BOOL __cdecl FUN_00445600(LiveObject *liveObj1,LiveObject **param_2)
{
	float fVar1;
	LiveObject *pLVar2;
	int iVar3;
	float fVar4;
	ObjectStatsFlags1 OVar5;
	uint uVar6;
	float *pfVar7;
	float10 fVar8;
	float10 fVar9;
	float10 fVar10;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pLVar2 = *param_2;
	if ((((liveObj1 != pLVar2) && (liveObj1->carryingThisObject != pLVar2)) &&
			(liveObj1->object_300 != pLVar2)) && ((liveObj1->flags3 & LIVEOBJ3_UNK_2000) == LIVEOBJ3_NONE)
		 ) {
		OVar5 = lego::game::LiveObject_GetStatsFlags1(liveObj1);
		if ((OVar5 & STATS1_CAUSESLIP) == STATS1_NONE) {
			pLVar2 = *param_2;
			fVar8 = lego::game::LiveObject_GetCollRadius(pLVar2);
			lego::game::LiveObject_GetPosition(liveObj1,&local_8,&local_4);
			uVar6 = 1;
			if (1 < pLVar2->routing_count_0 - 1U) {
				pfVar7 = &pLVar2->routing_points_4[1].y;
				do {
					fVar4 = local_4 - *pfVar7;
					fVar1 = local_8 - pfVar7[-1];
					fVar9 = lego::game::LiveObject_GetCollRadius(liveObj1);
					if ((float10)SQRT(fVar1 * fVar1 + fVar4 * fVar4) < fVar9 + (float10)(float)fVar8) {
						local_10 = pfVar7[-1] - local_8;
						fVar1 = *pfVar7 - local_4;
						local_c = SQRT(fVar1 * fVar1 + local_10 * local_10);
						if (local_c == 0.0) {
							fVar9 = lego::math::Maths_RandRange(0.0,1.0);
							fVar1 = (float)fVar9;
							fVar9 = lego::math::Maths_RandRange(0.0,1.0);
							fVar10 = (float10)1.0 /
											 SQRT(fVar9 * (float10)(float)fVar9 + (float10)fVar1 * (float10)fVar1);
							local_10 = (float)(fVar10 * (float10)fVar1);
							local_c = (float)(fVar10 * (float10)(float)fVar9);
						}
						else {
							local_c = 1.0 / local_c;
							local_10 = local_c * local_10;
							local_c = local_c * fVar1;
						}
						fVar9 = lego::game::LiveObject_GetCollRadius(liveObj1);
						fVar9 = fVar9 + (float10)(float)fVar8;
						pfVar7[-1] = (pfVar7[-3] +
												 pfVar7[1] + (float)(fVar9 * (float10)local_10 + (float10)local_8)) *
												 0.3333333;
						*pfVar7 = (pfVar7[-2] + pfVar7[2] + (float)fVar9 * local_c + local_4) * 0.3333333;
					}
					uVar6 += 1;
					pfVar7 = pfVar7 + 2;
				} while (uVar6 < pLVar2->routing_count_0 - 1U);
			}
			iVar3 = pLVar2->routing_count_0;
			fVar1 = pLVar2->routing_points_4[iVar3 + -2].y;
			pfVar7 = &pLVar2->routing_points_4[iVar3 + -1].y;
			pfVar7[-1] = (pLVar2->routing_points_4[iVar3 + -2].x - pLVar2->routing_points_4[iVar3 + -3].x)
									 + pfVar7[-3];
			*pfVar7 = pfVar7[-2] + (fVar1 - pfVar7[-4]);
		}
	}
	return 0;
}



BOOL __cdecl FUN_00445860(LiveObject *liveObj)
{
	BOOL BVar1;
	SurfaceMap *pSVar2;
	float10 fVar3;
	float fVar4;
	float in_y;
	uint *out_bx;
	uint *out_by;
	uint local_20;
	uint local_1c;
	uint local_18;
	uint local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	lego::game::LiveObject_GetBlockPos(liveObj,(int *)&local_14,(int *)&local_18);
	BVar1 = lego::game::Level_GetBlockFlags1_10Not8(local_14,local_18);
	if (BVar1 != 0) {
		return 0;
	}
	lego::game::LiveObject_GetPosition(liveObj,&local_8,&local_4);
	local_10 = (liveObj->faceDirection).x;
	local_c = (liveObj->faceDirection).y;
	fVar4 = 1.0 / SQRT(local_c * local_c + local_10 * local_10);
	pSVar2 = lego::game::GetSurfaceMap();
	fVar3 = lego::game::Map3D_GetBlockSize(pSVar2);
	out_by = &local_20;
	local_c = fVar4 * local_c * (float)(fVar3 * (float10)0.3333333);
	local_10 = fVar4 * local_10 * (float)(fVar3 * (float10)0.3333333);
	in_y = local_c + local_4;
	fVar4 = local_10 + local_8;
	out_bx = &local_1c;
	local_8 = fVar4;
	local_4 = in_y;
	pSVar2 = lego::game::GetSurfaceMap();
	lego::game::Map3D_WorldToBlockPos_NoZ(pSVar2,fVar4,in_y,(int *)out_bx,(int *)out_by);
	BVar1 = lego::game::Level_GetBlockFlags1_10Not8(local_1c,local_20);
	if ((BVar1 == 0) &&
		 (BVar1 = lego::game::Level_BlockIsFlags1_400_AndOptIsFlags2_4(local_1c,local_20,0), BVar1 == 0)
		 ) {
		return 0;
	}
	return 1;
}



void __cdecl lego::game::LiveObject_FUN_004459a0(LiveObject *liveObj)
{
	uint uVar1;
	float10 fVar2;
	
	if (liveObj->objType == OBJECT_ROCKMONSTER) {
		Search_LiveObjects_SkipIgnoreMes(LiveObject_FUN_00445af0,(undefined4 *)liveObj);
	}
	if (((liveObj->objType == OBJECT_DYNAMITE) || (liveObj->objType == OBJECT_OOHSCARY)) &&
		 ((liveObj->flags3 & LIVEOBJ3_UNK_10000) != LIVEOBJ3_NONE)) {
		uVar1 = res::Container_GetAnimationFrames(liveObj->other);
		fVar2 = res::Container_GetAnimationTime(liveObj->other);
		if ((float10)(ulonglong)uVar1 - (float10)75.0 < fVar2) {
			Search_LiveObjects_SkipIgnoreMes(LiveObject_FUN_00445a30,(undefined4 *)liveObj);
		}
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_00445a30(LiveObject *liveObj1,LiveObject *liveObj2)
{
	float fVar1;
	float fVar2;
	float fVar3;
	Vector3F local_18;
	Vector3F local_c;
	
	if ((liveObj1->objType == OBJECT_MINIFIGURE) &&
		 ((*(byte *)&liveObj1->flags5_3f0 & LIVEOBJ5_ABILITY_DYNAMITE) != 0)) {
		LiveObject_GetPosition(liveObj1,(float *)&local_18,&local_18.y);
		LiveObject_GetPosition(liveObj2,&local_18.z,(float *)&local_c);
		fVar3 = local_18.x - local_18.z;
		fVar1 = local_18.y - local_c.x;
		fVar2 = SQRT(fVar1 * fVar1 + fVar3 * fVar3);
		if (fVar2 < globs::gameGlobs.DynamiteDamageRadius) {
			fVar2 = 1.0 / fVar2;
			local_c.y = fVar2 * fVar3;
			local_c.z = fVar2 * fVar1;
			LiveObject_FUN_00444720(liveObj1,(Point2F *)&local_c.y);
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_00445af0(LiveObject *liveObj1,LiveObject *liveObj2)
{
	float fVar1;
	float fVar2;
	float fVar3;
	ObjectStatsFlags1 OVar4;
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar5;
	uint weaponType;
	float10 fVar6;
	float10 fVar7;
	float in_x;
	float in_y;
	LiveObject *liveObj;
	uint *puVar8;
	float *out_by;
	float fVar9;
	ObjectType local_34;
	int local_30;
	Point2F local_2c;
	Point2F local_24;
	Point2F local_1c;
	uint local_14;
	float local_10;
	Vector3F local_c;
	
	LiveObject_GetPosition(liveObj2,(float *)&local_1c,&local_1c.y);
	LiveObject_GetPosition(liveObj1,(float *)&local_24,&local_24.y);
	local_2c.x = local_24.x - local_1c.x;
	local_2c.y = local_24.y - local_1c.y;
	fVar2 = SQRT(local_2c.y * local_2c.y + local_2c.x * local_2c.x);
	fVar6 = LiveObject_GetAlertRadius(liveObj2);
	fVar1 = (float)fVar6;
	if ((liveObj2->flags3 & LIVEOBJ3_POWEROFF) == LIVEOBJ3_NONE) {
		if (((((liveObj1->flags2 & LIVEOBJ2_UNK_2) == LIVEOBJ2_NONE) &&
				 ((liveObj1->flags2 & LIVEOBJ2_UNK_100) == LIVEOBJ2_NONE)) &&
				((((byte)globs::gameGlobs.flags2 & 1) == 0 || ((*(byte *)&liveObj1->flags4 & 4) == 0)))) &&
			 (liveObj1->drivenObject == NULL)) {
			if (liveObj1->objType == OBJECT_MINIFIGURE) {
				OVar4 = LiveObject_GetStatsFlags1(liveObj2);
				if ((OVar4 & STATS1_GRABMINIFIGURE) != STATS1_NONE) {
					cont = LiveObject_GetContainer(liveObj2);
					res::Container_GetOrientation(cont,NULL,&local_c,NULL);
					out_by = &local_10;
					puVar8 = &local_14;
					fVar9 = 1.0 / SQRT(local_c.y * local_c.y + local_c.x * local_c.x);
					fVar3 = fVar9 * local_c.y * 15.0 + local_1c.y;
					fVar9 = fVar9 * local_c.x * 15.0 + local_1c.x;
					in_x = fVar9;
					in_y = fVar3;
					surfMap = GetSurfaceMap();
					Map3D_WorldToBlockPos_NoZ(surfMap,in_x,in_y,(int *)puVar8,(int *)out_by);
					BVar5 = Level_GetBlockFlags1_10Not8(local_14,(uint)local_10);
					if (BVar5 == 0) {
						BVar5 = Level_BlockIsFlags1_400_AndOptIsFlags2_4(local_14,(int)local_10,1);
						if (BVar5 == 0) {
							fVar9 = local_24.x - fVar9;
							fVar3 = local_24.y - fVar3;
							fVar6 = LiveObject_GetCollRadius(liveObj1);
							if ((float10)SQRT(fVar3 * fVar3 + fVar9 * fVar9) < fVar6) {
								ai::AI_LiveObject_DoThrowLegoman(liveObj2,liveObj1);
								return 0;
							}
						}
					}
				}
				OVar4 = LiveObject_GetStatsFlags1(liveObj2);
				if ((OVar4 & STATS1_CAUSESLIP) != STATS1_NONE) {
					fVar6 = LiveObject_GetCollRadius(liveObj2);
					fVar7 = LiveObject_GetCollRadius(liveObj1);
					if ((ushort)((ushort)(fVar7 + (float10)(float)fVar6 < (float10)fVar2) << 8 |
											(ushort)(fVar7 + (float10)(float)fVar6 == (float10)fVar2) << 0xe) == 0) {
						ai::AI_LiveObject_DoSlip(liveObj1);
						liveObj2->health = -1.0;
						liveObj2->flags3 = liveObj2->flags3 | LIVEOBJ3_UNK_800000;
					}
				}
				OVar4 = LiveObject_GetStatsFlags1(liveObj2);
				if (((OVar4 & STATS1_CANSCARE) != STATS1_NONE) && (fVar1 != 0.0)) {
					fVar6 = LiveObject_GetCollRadius(liveObj1);
					if ((float10)fVar2 < fVar6 + (float10)fVar1) {
						local_2c.x = (1.0 / fVar2) * local_2c.x;
						local_2c.y = (1.0 / fVar2) * local_2c.y;
						LiveObject_FUN_00444720(liveObj1,&local_2c);
					}
				}
			}
			if (((liveObj1->objType == OBJECT_VEHICLE) || (liveObj1->objType == OBJECT_MINIFIGURE)) &&
				 ((liveObj1->flags1 & LIVEOBJ1_UNK_200) == LIVEOBJ1_NONE)) {
				fVar6 = LiveObject_GetPainThreshold(liveObj2);
				if (fVar6 < (float10)liveObj2->health) {
					fVar6 = LiveObject_GetStampRadius(liveObj2);
					if ((ushort)((ushort)(fVar6 < (float10)fVar2) << 8 |
											(ushort)(fVar6 == (float10)fVar2) << 0xe) == 0) {
						LiveObject_FUN_0043acb0(liveObj2,liveObj1);
					}
				}
			}
			if ((liveObj1->objType == OBJECT_MINIFIGURE) || (liveObj1->objType == OBJECT_VEHICLE)) {
				OVar4 = LiveObject_GetStatsFlags1(liveObj2);
				if (((OVar4 & STATS1_SCAREDBYPLAYER) != STATS1_NONE) &&
					 ((liveObj2->flags1 & 0x8000000) == LIVEOBJ1_NONE)) {
					fVar6 = LiveObject_GetCollRadius(liveObj1);
					if ((float10)fVar2 < fVar6 + (float10)fVar1) {
						BVar5 = LiveObject_FUN_00444520(liveObj2);
						if (BVar5 != 0) {
							liveObj2->flags1 = liveObj2->flags1 | 0x8000000;
						}
					}
				}
			}
			if (liveObj1->objType == OBJECT_MINIFIGURE) {
				OVar4 = LiveObject_GetStatsFlags1(liveObj2);
				if ((OVar4 & STATS1_FLOCKS) != STATS1_NONE) {
					fVar3 = local_24.x - (float)liveObj2->flocksData_32c->field_18;
					local_10 = local_24.y - (float)liveObj2->flocksData_32c->field_20;
					fVar9 = local_10 * local_10;
					fVar6 = LiveObject_GetCollRadius(liveObj1);
					if ((float10)SQRT(fVar9 + fVar3 * fVar3) < fVar6 + (float10)fVar1) {
						fVar9 = 1.0;
						BVar5 = 1;
						liveObj = liveObj1;
						weaponType = tools::Weapon_GetWeaponTypeByName("BatAttack");
						fVar6 = Weapon_GetDamageForLiveObject(weaponType,liveObj);
						LiveObject_AddDamage2(liveObj1,(float)fVar6,BVar5,fVar9);
						liveObj2->flags2 =
								 liveObj2->flags2 |
								 ~(LIVEOBJ2_UNK_1|LIVEOBJ2_UNK_2|LIVEOBJ2_UNK_4|LIVEOBJ2_DRIVING|LIVEOBJ2_UNK_10|
									 LIVEOBJ2_UNK_20|LIVEOBJ2_UNK_40|LIVEOBJ2_UNK_100|LIVEOBJ2_UNK_200|
									 LIVEOBJ2_TRAINING|LIVEOBJ2_UNK_800|LIVEOBJ2_UNK_1000|LIVEOBJ2_UNK_2000|
									 LIVEOBJ2_UNK_4000|LIVEOBJ2_UPGRADING|LIVEOBJ2_UNK_10000|LIVEOBJ2_UNK_20000|
									 LIVEOBJ2_UNK_40000|LIVEOBJ2_UNK_80000|LIVEOBJ2_UNK_100000|LIVEOBJ2_UNK_200000|
									 LIVEOBJ2_UNK_400000|LIVEOBJ2_UNK_800000|LIVEOBJ2_UNK_1000000|LIVEOBJ2_UNK_2000000
									 |LIVEOBJ2_UNK_4000000|LIVEOBJ2_UNK_8000000|LIVEOBJ2_UNK_10000000|
									 LIVEOBJ2_UNK_20000000|LIVEOBJ2_UNK_40000000|LIVEOBJ2_UNK_80000000);
						if ((*(byte *)&liveObj2->flocksData_32c->field_24 & 1) == 0) {
							ai::AITask_DoFollow_Group(&liveObj2,1,liveObj1);
							puVar8 = &liveObj2->flocksData_32c->field_24;
							*puVar8 = *puVar8 | 1;
						}
					}
				}
			}
			OVar4 = LiveObject_GetStatsFlags1(liveObj2);
			if ((OVar4 & STATS1_CANSCARESCORPION) != STATS1_NONE) {
				BVar5 = Object_GetObjectByName("Scorpion",&local_34,&local_30,NULL);
				if (((BVar5 != 0) && (local_34 == liveObj1->objType)) &&
					 ((local_30 == liveObj1->objIndex && (fVar1 != 0.0)))) {
					fVar6 = LiveObject_GetCollRadius(liveObj1);
					if ((float10)fVar2 < fVar6 + (float10)fVar1) {
						local_2c.x = (1.0 / fVar2) * local_2c.x;
						local_2c.y = (1.0 / fVar2) * local_2c.y;
						LiveObject_FUN_00444720(liveObj1,&local_2c);
					}
				}
			}
		}
	}
	else {
		if ((liveObj1->objType == OBJECT_MINIFIGURE) || (liveObj1->objType == OBJECT_VEHICLE)) {
			fVar6 = LiveObject_GetWakeRadius(liveObj2);
			if ((ushort)((ushort)(fVar6 < (float10)fVar2) << 8 | (ushort)(fVar6 == (float10)fVar2) << 0xe)
					== 0) {
				LiveObject_RockMonster_DoWakeUp(liveObj2);
				return 1;
			}
		}
	}
	return 0;
}



LiveObject * __cdecl
lego::game::LiveObject_DoCollisionCallbacks_FUN_00446030
					(LiveObject *liveObj,Point2F *param_2,float param_3,BOOL param_4)
{
	ObjectStatsFlags1 OVar1;
	SearchCollision_14 search;
	
	search.pointf_4 = param_2;
	search.targetObj = liveObj;
	search.float_8 = param_3;
	search.result = NULL;
	search.bool_10 = param_4;
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_COLLBOX) != STATS1_NONE) {
		Search_LiveObjects_SkipIgnoreMes
							(LiveObject_CallbackCollisionBox_FUN_004463b0,(undefined4 *)&search);
	}
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_COLLRADIUS) != STATS1_NONE) {
		Search_LiveObjects_SkipIgnoreMes
							(LiveObject_CallbackCollisionRadius_FUN_004460b0,(undefined4 *)&search);
	}
	return search.result;
}



BOOL __cdecl
lego::game::LiveObject_CallbackCollisionRadius_FUN_004460b0(LiveObject *in_liveObj,int *search)
{
	LiveObject *liveObj;
	float fVar1;
	ObjectStatsFlags1 OVar2;
	Container *cont;
	float *pfVar3;
	int iVar4;
	BOOL BVar5;
	Vector3F *out_vector;
	Point2F *pPVar6;
	float10 fVar7;
	float10 fVar8;
	float10 fVar9;
	float local_60;
	float local_5c;
	Point2F local_58;
	Point2F local_50 [3];
	float local_38;
	float local_34;
	Vector3F local_30;
	float local_24;
	undefined4 local_20;
	float local_1c;
	float local_18;
	undefined4 local_14;
	float local_10;
	float local_c;
	undefined4 local_8;
	float local_4;
	
	liveObj = (LiveObject *)*search;
	if (((((search[4] == 0) ||
				(OVar2 = LiveObject_GetStatsFlags1(liveObj), (OVar2 & STATS1_STOREOBJECTS) == STATS1_NONE))
			 && (in_liveObj != liveObj)) &&
			((in_liveObj->carryingThisObject != liveObj && (liveObj->carryingThisObject != in_liveObj))))
		 && ((in_liveObj != liveObj->drivenObject &&
				 (((liveObj->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE &&
					((in_liveObj->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE)))))) {
		fVar7 = LiveObject_GetCollHeight(in_liveObj);
		if ((ushort)((ushort)(fVar7 < (float10)(float)search[2]) << 8 |
								(ushort)(fVar7 == (float10)(float)search[2]) << 0xe) == 0) {
			LiveObject_GetPosition(in_liveObj,&local_60,&local_5c);
			cont = LiveObject_GetContainer(in_liveObj);
			local_60 = local_60 - *(float *)search[1];
			local_5c = local_5c - ((float *)search[1])[1];
			fVar1 = SQRT(local_5c * local_5c + local_60 * local_60);
			OVar2 = LiveObject_GetStatsFlags1(in_liveObj);
			if ((OVar2 & STATS1_COLLRADIUS) == STATS1_NONE) {
				OVar2 = LiveObject_GetStatsFlags1(in_liveObj);
				if ((OVar2 & STATS1_COLLBOX) != STATS1_NONE) {
					fVar8 = LiveObject_GetCollRadius(liveObj);
					fVar9 = LiveObject_GetCollRadius(in_liveObj);
					fVar7 = (float10)fVar1;
					if ((ushort)((ushort)(fVar9 + (float10)(float)fVar8 < fVar7) << 8 |
											(ushort)(fVar9 + (float10)(float)fVar8 == fVar7) << 0xe) == 0) {
						pfVar3 = (float *)LiveObject_GetCollBox(in_liveObj);
						local_30.x = *pfVar3 * -0.5;
						iVar4 = LiveObject_GetCollBox(in_liveObj);
						local_30.z = *(float *)(iVar4 + 4) * 0.5;
						pfVar3 = (float *)LiveObject_GetCollBox(in_liveObj);
						local_24 = *pfVar3 * 0.5;
						iVar4 = LiveObject_GetCollBox(in_liveObj);
						local_1c = *(float *)(iVar4 + 4) * 0.5;
						pfVar3 = (float *)LiveObject_GetCollBox(in_liveObj);
						local_18 = *pfVar3 * 0.5;
						iVar4 = LiveObject_GetCollBox(in_liveObj);
						local_10 = *(float *)(iVar4 + 4) * -0.5;
						pfVar3 = (float *)LiveObject_GetCollBox(in_liveObj);
						local_c = *pfVar3 * -0.5;
						iVar4 = LiveObject_GetCollBox(in_liveObj);
						local_4 = *(float *)(iVar4 + 4) * -0.5;
						local_8 = 0;
						local_14 = 0;
						local_20 = 0;
						local_30.y = 0.0;
						pPVar6 = &local_58;
						out_vector = &local_30;
						iVar4 = 4;
						do {
							res::Container_Transform(cont,out_vector,out_vector);
							fVar1 = out_vector->y;
							pPVar6->x = out_vector->x;
							pPVar6->y = fVar1;
							out_vector = out_vector + 1;
							pPVar6 = pPVar6 + 1;
							iVar4 += -1;
						} while (iVar4 != 0);
						local_38 = local_58.x;
						local_34 = local_58.y;
						BVar5 = math::Maths_PointInsidePoly((Point2F *)search[1],&local_58,local_50,4);
						if (BVar5 == 0) {
							fVar7 = math::Collision_Maths_FUN_00408a30((Point2F *)search[1],&local_58,local_50,4);
							fVar8 = LiveObject_GetCollRadius(liveObj);
							if ((ushort)((ushort)(fVar8 < (float10)(float)fVar7) << 8 |
													(ushort)(fVar8 == (float10)(float)fVar7) << 0xe) == 0) {
								search[3] = (int)in_liveObj;
							}
						}
						else {
							search[3] = (int)in_liveObj;
						}
					}
				}
			}
			else {
				fVar8 = LiveObject_GetCollRadius(liveObj);
				fVar9 = LiveObject_GetCollRadius(in_liveObj);
				fVar7 = (float10)fVar1;
				if ((ushort)((ushort)(fVar9 + (float10)(float)fVar8 < fVar7) << 8 |
										(ushort)(fVar9 + (float10)(float)fVar8 == fVar7) << 0xe) == 0) {
					search[3] = (int)in_liveObj;
				}
			}
		}
		if (search[3] != 0) {
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_CallbackCollisionBox_FUN_004463b0
					(LiveObject *in_liveObj,SearchCollision_14 *search)
{
	float fVar1;
	LiveObject *liveObj;
	ObjectStatsFlags1 OVar2;
	float *pfVar3;
	int iVar4;
	BOOL BVar5;
	float *pfVar6;
	int iVar7;
	LiveObject **ppLVar8;
	Point2F *pPVar9;
	Vector3F *out_vector;
	Vector3F *pVVar10;
	float10 fVar11;
	float10 fVar12;
	float local_f8;
	float local_f4;
	Point2F local_f0;
	LiveObject *local_e8 [2];
	Container *local_e0;
	Container *local_dc;
	Vector3F local_d8;
	float local_cc;
	undefined4 local_c8;
	float local_c4;
	float local_c0;
	undefined4 local_bc;
	float local_b8;
	float local_b4;
	Point2F local_b0;
	Point2F local_a8 [4];
	Point2F local_88;
	Point2F local_80 [3];
	float local_68;
	float local_64;
	Vector3F local_60 [4];
	Vector3F local_30 [4];
	
	local_e8[1] = search->targetObj;
	if (((((search->bool_10 == 0) ||
				(OVar2 = LiveObject_GetStatsFlags1(local_e8[1]),
				(OVar2 & STATS1_STOREOBJECTS) == STATS1_NONE)) && (in_liveObj != local_e8[1])) &&
			((in_liveObj->carryingThisObject != local_e8[1] &&
			 (local_e8[1]->carryingThisObject != in_liveObj)))) &&
		 (((local_e8[1]->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE &&
			(((in_liveObj->flags1 & (LIVEOBJ1_UNK_200000|LIVEOBJ1_UNK_400000)) == LIVEOBJ1_NONE &&
			 (fVar11 = LiveObject_GetCollHeight(in_liveObj),
			 (ushort)((ushort)(fVar11 < (float10)search->float_8) << 8 |
							 (ushort)(fVar11 == (float10)search->float_8) << 0xe) == 0)))))) {
		LiveObject_GetPosition(in_liveObj,(float *)&local_f0,&local_f0.y);
		LiveObject_GetPosition(local_e8[1],&local_f8,&local_f4);
		local_f8 = local_f8 - search->pointf_4->x;
		local_f4 = local_f4 - search->pointf_4->y;
		local_dc = LiveObject_GetContainer(in_liveObj);
		local_e0 = LiveObject_GetContainer(local_e8[1]);
		OVar2 = LiveObject_GetStatsFlags1(in_liveObj);
		if ((OVar2 & STATS1_COLLRADIUS) == STATS1_NONE) {
			OVar2 = LiveObject_GetStatsFlags1(in_liveObj);
			if ((OVar2 & STATS1_COLLBOX) != STATS1_NONE) {
				local_f0.y = local_f0.y - search->pointf_4->y;
				local_f0.x = local_f0.x - search->pointf_4->x;
				fVar11 = LiveObject_GetCollRadius(in_liveObj);
				local_e8[0] = (LiveObject *)(float)fVar11;
				fVar11 = LiveObject_GetCollRadius(local_e8[1]);
				if ((float10)SQRT(local_f0.x * local_f0.x + local_f0.y * local_f0.y) <
						fVar11 + (float10)(float)local_e8[0]) {
					local_e8[0] = in_liveObj;
					ppLVar8 = local_e8;
					iVar4 = 2;
					pfVar3 = &local_60[0].z;
					do {
						liveObj = *ppLVar8;
						pfVar6 = (float *)LiveObject_GetCollBox(liveObj);
						pfVar3[-2] = *pfVar6 * -0.5;
						iVar7 = LiveObject_GetCollBox(liveObj);
						*pfVar3 = *(float *)(iVar7 + 4) * 0.5;
						pfVar6 = (float *)LiveObject_GetCollBox(liveObj);
						pfVar3[1] = *pfVar6 * 0.5;
						iVar7 = LiveObject_GetCollBox(liveObj);
						pfVar3[3] = *(float *)(iVar7 + 4) * 0.5;
						pfVar6 = (float *)LiveObject_GetCollBox(liveObj);
						pfVar3[4] = *pfVar6 * 0.5;
						iVar7 = LiveObject_GetCollBox(liveObj);
						pfVar3[6] = *(float *)(iVar7 + 4) * -0.5;
						pfVar6 = (float *)LiveObject_GetCollBox(liveObj);
						pfVar3[7] = *pfVar6 * -0.5;
						iVar7 = LiveObject_GetCollBox(liveObj);
						ppLVar8 = ppLVar8 + 1;
						iVar4 += -1;
						pfVar3[9] = *(float *)(iVar7 + 4) * -0.5;
						pfVar3[8] = 0.0;
						pfVar3[5] = 0.0;
						pfVar3[2] = 0.0;
						pfVar3[-1] = 0.0;
						pfVar3 = pfVar3 + 0xc;
					} while (iVar4 != 0);
					pPVar9 = &local_b0;
					pVVar10 = local_30;
					iVar4 = 4;
					do {
						res::Container_Transform(local_e0,pVVar10,pVVar10);
						fVar1 = pVVar10->y;
						pPVar9->x = pVVar10->x;
						pPVar9->y = fVar1;
						pVVar10 = pVVar10 + 1;
						pPVar9 = pPVar9 + 1;
						iVar4 += -1;
					} while (iVar4 != 0);
					pVVar10 = &local_d8;
					out_vector = local_60;
					iVar4 = 4;
					do {
						res::Container_Transform(local_dc,out_vector,out_vector);
						fVar1 = out_vector->y;
						pVVar10->x = out_vector->x;
						pVVar10->y = fVar1;
						out_vector = out_vector + 1;
						pVVar10 = (Vector3F *)&pVVar10->z;
						iVar4 += -1;
					} while (iVar4 != 0);
					pfVar3 = &local_b8;
					iVar4 = 2;
					do {
						*pfVar3 = pfVar3[-8];
						pfVar3[1] = pfVar3[-7];
						pfVar3 = pfVar3 + 10;
						iVar4 += -1;
					} while (iVar4 != 0);
					pVVar10 = &local_d8;
					iVar4 = 4;
					do {
						BVar5 = math::Maths_PointInsidePoly((Point2F *)pVVar10,&local_b0,local_a8,4);
						if (BVar5 != 0) {
							search->result = in_liveObj;
						}
						pVVar10 = (Vector3F *)&pVVar10->z;
						iVar4 += -1;
					} while (iVar4 != 0);
				}
			}
		}
		else {
			local_f0.y = local_f0.y - search->pointf_4->y;
			local_f0.x = local_f0.x - search->pointf_4->x;
			fVar11 = LiveObject_GetCollRadius(in_liveObj);
			local_e8[0] = (LiveObject *)(float)fVar11;
			fVar11 = LiveObject_GetCollRadius(local_e8[1]);
			if ((float10)SQRT(local_f0.x * local_f0.x + local_f0.y * local_f0.y) <
					fVar11 + (float10)(float)local_e8[0]) {
				pfVar3 = (float *)LiveObject_GetCollBox(local_e8[1]);
				local_d8.x = *pfVar3 * -0.5;
				iVar4 = LiveObject_GetCollBox(local_e8[1]);
				local_d8.z = *(float *)(iVar4 + 4) * 0.5;
				pfVar3 = (float *)LiveObject_GetCollBox(local_e8[1]);
				local_cc = *pfVar3 * 0.5;
				iVar4 = LiveObject_GetCollBox(local_e8[1]);
				local_c4 = *(float *)(iVar4 + 4) * 0.5;
				pfVar3 = (float *)LiveObject_GetCollBox(local_e8[1]);
				local_c0 = *pfVar3 * 0.5;
				iVar4 = LiveObject_GetCollBox(local_e8[1]);
				local_b8 = *(float *)(iVar4 + 4) * -0.5;
				pfVar3 = (float *)LiveObject_GetCollBox(local_e8[1]);
				local_b4 = *pfVar3 * -0.5;
				iVar4 = LiveObject_GetCollBox(local_e8[1]);
				local_b0.y = *(float *)(iVar4 + 4) * -0.5;
				local_b0.x = 0.0;
				local_bc = 0;
				local_c8 = 0;
				local_d8.y = 0.0;
				pVVar10 = &local_d8;
				iVar4 = 4;
				pPVar9 = &local_88;
				do {
					res::Container_Transform(local_e0,pVVar10,pVVar10);
					fVar1 = pVVar10->y;
					pPVar9->x = pVVar10->x;
					pPVar9->y = fVar1;
					pVVar10 = pVVar10 + 1;
					iVar4 += -1;
					pPVar9->x = local_f8 + pPVar9->x;
					pPVar9->y = local_f4 + pPVar9->y;
					pPVar9 = pPVar9 + 1;
				} while (iVar4 != 0);
				local_68 = local_88.x;
				local_64 = local_88.y;
				BVar5 = math::Maths_PointInsidePoly(&local_f0,&local_88,local_80,4);
				if (BVar5 == 0) {
					fVar11 = math::Collision_Maths_FUN_00408a30(&local_f0,&local_88,local_80,4);
					fVar12 = LiveObject_GetCollRadius(in_liveObj);
					if ((ushort)((ushort)(fVar12 < (float10)(float)fVar11) << 8 |
											(ushort)(fVar12 == (float10)(float)fVar11) << 0xe) == 0) {
						search->result = in_liveObj;
					}
				}
				else {
					search->result = in_liveObj;
				}
			}
		}
		if (search->result != NULL) {
			return TRUE;
		}
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_FUN_004468d0
					(LiveObject *in_liveObj,float elapsed,float *param_3,float *out_float_4)
{
	LiveFlags1 LVar1;
	ObjectType OVar2;
	ulonglong uVar3;
	LiveObject *liveObj;
	float *pfVar4;
	SurfaceMap *surfMap;
	BOOL BVar5;
	ObjectStatsFlags2 OVar6;
	float10 fVar7;
	Point2I *out_bx;
	int *out_by;
	float *out_unk_z;
	float local_1c;
	Point2I local_18;
	float local_10;
	float local_c;
	uint local_8;
	undefined4 uStack4;
	
	pfVar4 = param_3;
	liveObj = in_liveObj;
	LVar1 = in_liveObj->flags1;
	local_1c = (float)(LVar1 & LIVEOBJ1_CAUGHTINWEB);
	OVar2 = in_liveObj->objType;
	if (OVar2 == OBJECT_VEHICLE) {
		fVar7 = res::Vehicle_GetTransCoef(in_liveObj->vehicle);
		in_liveObj = (LiveObject *)(float)fVar7;
	}
	else {
		if (OVar2 == OBJECT_MINIFIGURE) {
			fVar7 = Creature_GetTransCoef(in_liveObj->miniFigure);
			in_liveObj = (LiveObject *)(float)fVar7;
		}
		else {
			if (OVar2 == OBJECT_ROCKMONSTER) {
				fVar7 = Creature_GetTransCoef(in_liveObj->rockMonster);
				in_liveObj = (LiveObject *)(float)fVar7;
			}
			else {
				if (OVar2 == OBJECT_BUILDING) {
					fVar7 = res::Building_GetAnimFloat14_zero(in_liveObj->building);
					in_liveObj = (LiveObject *)(float)fVar7;
				}
				else {
					if (((in_liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) ||
						 (OVar2 == OBJECT_UPGRADEPART)) {
						*out_float_4 = elapsed;
						return;
					}
				}
			}
		}
	}
	if ((LVar1 & LIVEOBJ1_UNK_8) == LIVEOBJ1_NONE) {
		if (((LVar1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) || (liveObj->objType == OBJECT_VEHICLE)) {
			fVar7 = LiveObject_GetRouteSpeed(liveObj);
			*param_3 = (float)fVar7;
			if ((LVar1 & LIVEOBJ1_LIFTING) != LIVEOBJ1_NONE) {
				*param_3 = (float)(fVar7 * (float10)0.5);
			}
		}
		else {
			fVar7 = LiveObject_GetRouteSpeed(liveObj);
			*param_3 = (float)(fVar7 * (float10)0.5);
		}
	}
	else {
		fVar7 = LiveObject_GetRouteSpeed(liveObj);
		*param_3 = (float)(fVar7 * (float10)0.05);
	}
	if (local_1c != 0.0) {
		*param_3 = *param_3 * 0.05;
	}
	local_1c = 1.0;
	LiveObject_GetPosition(liveObj,&local_10,&local_c);
	out_unk_z = &local_1c;
	out_by = &local_18.y;
	out_bx = &local_18;
	surfMap = GetSurfaceMap();
	BVar5 = Map3D_WorldToBlockPos(surfMap,local_10,local_c,(int *)out_bx,out_by,out_unk_z);
	if (BVar5 != 0) {
		local_8 = Level_GetBlockRubbleLevel_OrFlag200000(&local_18);
		uStack4 = 0;
		uVar3 = (ulonglong)local_8;
		fVar7 = LiveObject_GetRubbleCoef(liveObj);
		param_3 = (float *)(float)((float10)1.0 -
															((float10)1.0 - fVar7) * (float10)((float)uVar3 * 0.25));
		BVar5 = Level_Block_IsPowerPath(&local_18);
		if (BVar5 != 0) {
			fVar7 = LiveObject_GetPathCoef(liveObj);
			param_3 = (float *)(float)(fVar7 * (float10)(float)param_3);
		}
		if ((liveObj->objType == OBJECT_MINIFIGURE) &&
			 ((globs::gameGlobs.level)->blocks
				[((globs::gameGlobs.level)->dimensions).width * local_18.y + local_18.x].terrain ==
				TERRAIN_LAKE)) {
			param_3 = (float *)((1.0 - local_1c * 0.8) * (float)param_3);
		}
		BVar5 = Level_BlockIsFlags1_8(local_18.x,local_18.y);
		if (BVar5 != 0) {
			*pfVar4 = *pfVar4 * (float)param_3;
		}
	}
	if ((float)in_liveObj == 0.0) {
		*out_float_4 = 1.0;
	}
	else {
		*out_float_4 = *pfVar4 / (float)in_liveObj;
	}
	if (((liveObj->objType == OBJECT_BUILDING) &&
			(OVar6 = LiveObject_GetStatsFlags2(liveObj), (OVar6 & STATS2_UPGRADEBUILDING) != STATS2_NONE))
		 && ((liveObj->flags2 & LIVEOBJ2_UPGRADING) != LIVEOBJ2_NONE)) {
		fVar7 = LiveObject_GetFunctionCoef(liveObj);
		*out_float_4 = (float)(fVar7 * (float10)*out_float_4);
	}
	*out_float_4 = *out_float_4 * elapsed;
	*pfVar4 = *pfVar4 * elapsed;
	return;
}



BOOL __cdecl
lego::game::LiveObject_RoutingPtr_Important_FUN_00446b80
					(LiveObject *liveObj,int param_2,int param_3)
{
	uint uVar1;
	int iVar2;
	int iVar3;
	void *pvVar4;
	
	if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_MOVING) != 0) {
		uVar1 = liveObj->routingBlocksTotal;
		pvVar4 = liveObj->routeptr_24;
		iVar2 = *(int *)((int)pvVar4 + uVar1 * 0x14 + -0x14);
		iVar3 = *(int *)((int)pvVar4 + uVar1 * 0x14 + -0x10);
		if ((((param_2 == iVar2) && ((param_3 == iVar3 + -1 || (param_3 == iVar3 + 1)))) ||
				((param_3 == iVar3 && ((param_2 == iVar2 + -1 || (param_2 == iVar2 + 1)))))) &&
			 (pvVar4 = std::realloc(pvVar4,(uVar1 + 1) * 0x14), pvVar4 != NULL)) {
			liveObj->routeptr_24 = pvVar4;
			*(int *)((int)pvVar4 + liveObj->routingBlocksTotal * 0x14) = param_2;
			*(int *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + 4) = param_3;
			*(undefined4 *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + 8) =
					 0x3f000000;
			*(undefined4 *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + 0xc) =
					 0x3f000000;
			*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + 0x10) = 0;
			*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + 0x11) = 1;
			liveObj->routingBlocksTotal = liveObj->routingBlocksTotal + 1;
			liveObj->flags3 = liveObj->flags3 & 0xfffffbff;
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_FUN_00446c80
					(LiveObject *liveObj,uint param_2,uint param_3,int param_4,uint *param_5,int param_6)
{
	float fVar1;
	bool bVar2;
	SurfaceMap *pSVar3;
	BOOL BVar4;
	undefined4 uVar5;
	uint by;
	int iVar6;
	float **ppfVar7;
	uint uVar8;
	float *pfVar9;
	int *piVar10;
	uint uVar11;
	uint uVar12;
	longlong lVar13;
	float **ppfVar14;
	float **ppfVar15;
	uint *puVar16;
	float *out_x;
	undefined4 callback;
	undefined4 uVar17;
	int *local_11c;
	float *local_118;
	BOOL local_114;
	float local_110;
	float local_10c;
	uint local_108;
	float local_104;
	float local_100;
	undefined4 uStack252;
	uint local_f8;
	uint local_f4;
	float local_f0;
	float local_ec;
	float local_e8;
	float local_e4;
	float local_e0;
	undefined4 local_dc;
	undefined4 local_d8;
	undefined4 local_d4;
	undefined4 local_d0;
	undefined4 local_cc;
	undefined4 local_c8;
	undefined4 local_c4;
	float local_c0;
	undefined4 local_bc;
	undefined4 local_b8;
	undefined4 local_b4;
	undefined4 local_b0;
	undefined4 local_ac;
	undefined4 local_a8;
	undefined4 local_a4;
	undefined4 local_a0;
	undefined4 local_9c;
	undefined4 local_98;
	undefined4 local_94;
	undefined4 local_90;
	undefined4 local_8c;
	undefined4 local_88;
	undefined4 local_84;
	int local_80 [8];
	float *local_60 [8];
	float *local_40 [8];
	uint local_20 [8];
	
	local_108 = 0xffffffff;
	local_f8 = 0xffffffff;
	local_f4 = 0xffffffff;
	piVar10 = local_80;
	local_80[0] = 0;
	local_b8 = 0;
	for (iVar6 = 7; piVar10 = piVar10 + 1, iVar6 != 0; iVar6 += -1) {
		*piVar10 = 0;
	}
	local_a4 = 0;
	local_a0 = 0;
	local_8c = 0;
	local_e0 = 0.0;
	local_d4 = 0;
	local_d0 = 0;
	local_c4 = 0;
	local_114 = 0;
	local_c0 = -1.0;
	local_bc = 0xc0000000;
	local_b4 = 0xc0000000;
	local_b0 = 0x3f800000;
	local_ac = 0xbf800000;
	local_a8 = 0x3f800000;
	local_9c = 0x3f800000;
	local_98 = 0xbf800000;
	local_94 = 0x3f800000;
	local_90 = 0xc0000000;
	local_88 = 0xc0000000;
	local_84 = 0xbf800000;
	local_dc = 0xbf800000;
	local_d8 = 0x3f800000;
	local_cc = 0x3f800000;
	local_c8 = 0xbf800000;
	bVar2 = true;
	if (param_4 == 0) {
		local_118 = &local_e0;
		uVar8 = 4;
	}
	else {
		local_118 = &local_c0;
		uVar8 = 8;
	}
	LiveObject_GetBlockPos(liveObj,(int *)&local_110,(int *)&local_10c);
	if (param_6 == 0) {
		pfVar9 = &local_ec;
		out_x = &local_f0;
		uVar12 = param_2;
		uVar11 = param_3;
		pSVar3 = GetSurfaceMap();
		Map3D_BlockToWorldPos(pSVar3,uVar12,uVar11,out_x,pfVar9);
		LiveObject_GetPosition(liveObj,&local_e8,&local_e4);
		local_104 = SQRT((local_ec - local_e4) * (local_ec - local_e4) +
										 (local_f0 - local_e8) * (local_f0 - local_e8));
		pSVar3 = GetSurfaceMap();
		if (local_104 < pSVar3->BlockSize) {
			bVar2 = false;
		}
	}
	uVar11 = 0;
	uVar12 = local_f4;
	if (uVar8 != 0) {
		local_104 = (float)(ulonglong)param_2;
		uStack252 = 0;
		local_100 = (float)(ulonglong)param_3;
		pfVar9 = local_118;
		do {
			*pfVar9 = *pfVar9 + local_104;
			fVar1 = pfVar9[1];
			pfVar9[1] = fVar1 + local_100;
			if ((((*pfVar9 == (float)(int)local_110) && (fVar1 + local_100 == (float)(int)local_10c)) &&
					(bVar2)) &&
				 ((uVar12 = uVar11, param_4 != 0 ||
					(BVar4 = Level_GetBlockFlags1_10Not8((uint)local_110,(uint)local_10c), BVar4 == 0))))
			break;
			uVar11 += 1;
			pfVar9 = pfVar9 + 2;
			uVar12 = local_f4;
		} while (uVar11 < uVar8);
	}
	if (uVar12 != 0xffffffff) {
		BVar4 = LiveObject_FUN_004419c0(liveObj,1,&local_110,&local_10c,NULL);
		if (BVar4 == 0) {
			return 0;
		}
		if (param_5 != NULL) {
			*param_5 = uVar12;
		}
		return 1;
	}
	uVar12 = 0;
	if (uVar8 != 0) {
		local_11c = local_80;
		ppfVar7 = local_40;
		pfVar9 = local_118;
		do {
			if (((float)(int)local_110 != *pfVar9) || ((float)(int)local_10c != pfVar9[1])) {
				lVar13 = __ftol((float10)pfVar9[1]);
				uVar5 = (undefined4)lVar13;
				uVar17 = 0;
				puVar16 = local_20 + uVar12;
				callback = 0;
				ppfVar15 = local_60 + uVar12;
				ppfVar14 = ppfVar7;
				lVar13 = __ftol((float10)*pfVar9);
				BVar4 = LiveObject_FUN_004413b0
													(liveObj,local_110,local_10c,(int)lVar13,uVar5,ppfVar14,ppfVar15,puVar16,
													 callback,uVar17);
				if (BVar4 != 0) {
					*local_11c = 1;
				}
			}
			uVar12 += 1;
			pfVar9 = pfVar9 + 2;
			ppfVar7 = ppfVar7 + 1;
			local_11c = local_11c + 1;
		} while (uVar12 < uVar8);
	}
	uVar12 = 0;
	if (uVar8 != 0) {
		do {
			if ((local_108 != 0xffffffff) && (uVar12 == uVar8)) break;
			uVar11 = uVar12 % uVar8;
			if (local_80[uVar11] != 0) {
				if (uVar12 < uVar8) {
					lVar13 = __ftol((float10)local_118[uVar11 * 2 + 1]);
					by = (uint)lVar13;
					lVar13 = __ftol((float10)local_118[uVar11 * 2]);
					BVar4 = Level_GetBlockFlags1_10Not8((uint)lVar13,by);
					if (BVar4 != 0) goto LAB_0044704f;
				}
				if (local_20[uVar11] < local_f8) {
					local_108 = uVar11;
					local_f8 = local_20[uVar11];
				}
			}
LAB_0044704f:
			uVar12 += 1;
		} while (uVar12 < uVar8 * 2);
	}
	if (local_108 != 0xffffffff) {
		BVar4 = LiveObject_FUN_004419c0
											(liveObj,local_20[local_108],local_40[local_108],local_60[local_108],NULL);
		if (BVar4 == 0) {
			local_114 = 0;
		}
		else {
			if (param_5 != NULL) {
				*param_5 = local_108;
			}
			local_114 = 1;
		}
	}
	uVar12 = 0;
	if (uVar8 != 0) {
		ppfVar7 = local_60;
		do {
			if (local_80[uVar12] != 0) {
				std::free(local_40[uVar12]);
				std::free(*ppfVar7);
			}
			uVar12 += 1;
			ppfVar7 = ppfVar7 + 1;
		} while (uVar12 < uVar8);
	}
	return local_114;
}



BOOL __cdecl
lego::game::LiveObject_FUN_00447100(LiveObject *liveObj,uint param_2,uint param_3,int param_4)
{
	uint uVar1;
	void *pvVar2;
	undefined4 uVar3;
	LiveFlags3 LVar4;
	BOOL BVar5;
	float10 fVar6;
	uint local_84;
	int local_80 [4];
	undefined4 local_70;
	undefined4 local_6c;
	undefined4 local_68;
	undefined4 local_64;
	int local_60 [4];
	undefined4 local_50;
	undefined4 local_4c;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40 [4];
	undefined4 local_30;
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	BVar5 = LiveObject_Check_FUN_004326a0(liveObj,param_2,param_3,param_4,1);
	if (BVar5 != 0) {
		BVar5 = LiveObject_FUN_00446c80(liveObj,param_2,param_3,param_4,&local_84,1);
		if (BVar5 != 0) {
			if (param_4 != 0) {
				local_60[0] = 0;
				local_60[1] = 1;
				local_60[2] = 1;
				local_44 = 0;
				local_60[3] = 2;
				local_50 = 2;
				local_80[2] = 0;
				local_4c = 3;
				local_48 = 3;
				local_70 = 0;
				local_80[0] = -1;
				local_80[1] = 0xffffffff;
				local_80[3] = 0xffffffff;
				local_68 = 0xffffffff;
				local_6c = 0;
				local_64 = 0;
				local_40[0] = 0x3f666666;
				local_40[1] = 0x3f000000;
				local_40[2] = 0x3dcccccd;
				local_40[3] = 0x3f000000;
				local_30 = 0x3f000000;
				local_2c = 0x3dcccccd;
				local_28 = 0x3f000000;
				local_24 = 0x3f666666;
				local_20 = 0x3dcccccd;
				local_1c = 0x3f000000;
				local_18 = 0x3f666666;
				local_14 = 0x3f000000;
				local_10 = 0x3f000000;
				local_c = 0x3f666666;
				local_8 = 0x3f000000;
				local_4 = 0x3dcccccd;
				LiveObject_RoutingPtr_Important_FUN_00446b80
									(liveObj,local_80[local_60[local_84] * 2] + param_2,
									 local_80[local_60[local_84] * 2 + 1] + param_3);
				uVar1 = liveObj->routingBlocksTotal;
				pvVar2 = liveObj->routeptr_24;
				uVar3 = local_40[local_84 * 2 + 1];
				*(undefined4 *)((int)pvVar2 + uVar1 * 0x14 + -0xc) = local_40[local_84 * 2];
				*(undefined4 *)((int)pvVar2 + uVar1 * 0x14 + -8) = uVar3;
				LVar4 = liveObj->flags3;
				(liveObj->point_2f4).x = (float)(ulonglong)param_2;
				liveObj->flags3 = LVar4 | LIVEOBJ3_UNK_2000000;
				(liveObj->point_2f4).y = (float)(ulonglong)param_3;
				return 1;
			}
			LiveObject_RoutingPtr_Important_FUN_00446b80(liveObj,param_2,param_3);
			fVar6 = math::Maths_RandRange(0.3,0.7);
			*(float *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -0xc) =
					 (float)fVar6;
			fVar6 = math::Maths_RandRange(0.3,0.7);
			*(float *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -8) = (float)fVar6
			;
			LVar4 = liveObj->flags3;
			(liveObj->point_2f4).x = (float)(ulonglong)param_2;
			liveObj->flags3 = LVar4 & ~LIVEOBJ3_UNK_2000000;
			(liveObj->point_2f4).y = (float)(ulonglong)param_3;
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Game_PTL_GatherRock(LiveObject *in_liveObj)
{
	BOOL BVar1;
	LiveObject *liveObj;
	Container_Texture *contTexture;
	float10 fVar2;
	Point2I point;
	
	if ((in_liveObj->flags3 & LIVEOBJ3_CANGATHER) != LIVEOBJ3_NONE) {
		fVar2 = LiveObject_GetCarryMinHealth(in_liveObj);
		if (fVar2 < (float10)in_liveObj->health) {
			BVar1 = LiveObject_FUN_0044a890(in_liveObj,(int *)&point,&point.y,1,0,0);
			if (BVar1 != 0) {
				liveObj = LiveObject__Create((int **)globs::gameGlobs.RES_Boulder,OBJECT_BOULDER,0);
				LiveObject_UnkUpdatePositioning(liveObj,10000.0,10000.0,0,1);
				LiveObject_HideAll(liveObj,1);
				BVar1 = LiveObject_RoutingNoCarry_FUN_00447470(in_liveObj,point.x,point.y,liveObj);
				if (BVar1 != 0) {
					contTexture = FUN_00429090(&point);
					LiveObject_InitBoulderMesh_FUN_00440eb0(liveObj,contTexture);
					in_liveObj->float_33c = 0.0;
					return TRUE;
				}
				LiveObject_DestroyBoulder_AndCreateExplode(liveObj);
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_RoutingNoCarry_FUN_00447470
					(LiveObject *liveObj,uint x,uint y,LiveObject *liveObj2)
{
	BOOL BVar1;
	
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
		BVar1 = LiveObject_RoutingPointerBlocks_FUN_00449b40(liveObj,x,y,4.0);
		if (BVar1 != 0) {
			*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 3;
			liveObj->object_2fc = liveObj2;
			liveObj2->object_300 = liveObj;
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Game_PTL_AttackBuilding(LiveObject *liveObj1,LiveObject *targetObj)
{
	short sVar1;
	short sVar2;
	uint uVar3;
	BOOL BVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	uint uVar9;
	Point2I local_70;
	int local_68;
	int local_64;
	int local_60 [4];
	undefined4 local_50;
	undefined4 local_4c;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40;
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	undefined4 local_30;
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if (liveObj1->objType == OBJECT_ROCKMONSTER) {
		if (targetObj != NULL) {
			local_60[0] = 2;
			local_60[1] = 0;
			local_60[2] = 0;
			local_60[3] = 2;
			local_50 = 0xfffffffe;
			local_4c = 0;
			local_48 = 0;
			local_44 = 0xfffffffe;
			local_40 = 2;
			local_3c = 0xffffffff;
			local_38 = 2;
			local_34 = 1;
			local_30 = 1;
			local_2c = 2;
			local_28 = 0xffffffff;
			local_24 = 2;
			local_20 = 0xfffffffe;
			local_1c = 1;
			local_18 = 0xfffffffe;
			local_14 = 0xffffffff;
			local_10 = 0xffffffff;
			local_c = 0xfffffffe;
			local_8 = 1;
			local_4 = 0xfffffffe;
			sVar1 = math::Maths_Rand();
			sVar2 = math::Maths_Rand();
			uVar6 = (int)sVar2 >> 0x1f;
			LiveObject_GetBlockPos(targetObj,&local_68,&local_64);
			uVar9 = 0;
			do {
				uVar7 = 0;
				uVar8 = (int)sVar1 % 0xc;
				do {
					uVar3 = uVar8;
					if ((((int)sVar2 ^ uVar6) - uVar6 & 1 ^ uVar6) - uVar6 == 1) {
						uVar3 = 0x18 - uVar8;
					}
					local_70.x = local_60[(uVar3 % 0xc) * 2] + local_68;
					local_70.y = local_60[(uVar3 % 0xc) * 2 + 1] + local_64;
					if (((uVar9 == 1) || (BVar4 = Level_BlockIsFlags1_180000(&local_70), BVar4 == 0)) &&
						 (iVar5 = LiveObject_FUN_00447670
																(liveObj1,(float)local_70.x,(float *)local_70.y,targetObj),
						 iVar5 != 0)) {
						return 1;
					}
					uVar7 += 1;
					uVar8 += 1;
				} while (uVar7 < 0xc);
				uVar9 += 1;
				if (1 < uVar9) {
					return 0;
				}
			} while( true );
		}
		LiveObject_FUN_0043a130(liveObj1,0);
	}
	return 0;
}



int __cdecl
lego::game::LiveObject_FUN_00447670
					(LiveObject *in_liveObj,float param_2,float *param_3,LiveObject *liveObj2)
{
	LiveObject *liveObj;
	float fVar1;
	float *pfVar2;
	BOOL BVar3;
	BOOL BVar4;
	float *local_10;
	float local_c;
	float *local_8;
	uint local_4;
	
	liveObj = in_liveObj;
	BVar4 = 0;
	if ((in_liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		BVar3 = LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(in_liveObj);
		if (BVar3 == 0) {
			LiveObject_GetBlockPos(liveObj2,(int *)&local_c,(int *)&local_8);
			pfVar2 = param_3;
			fVar1 = param_2;
			if ((local_c != param_2) || (local_8 != param_3)) {
				LiveObject_GetBlockPos(liveObj,(int *)&param_2,(int *)&in_liveObj);
				if ((param_2 == fVar1) && (in_liveObj == (LiveObject *)pfVar2)) {
					BVar4 = LiveObject_FUN_004419c0(liveObj,1,&param_2,(float *)&in_liveObj,NULL);
				}
				else {
					BVar4 = LiveObject_FUN_004413b0
														(liveObj,param_2,in_liveObj,fVar1,pfVar2,&param_3,&local_10,&local_4,0,0
														);
					if (BVar4 == 0) {
						return 0;
					}
					BVar4 = LiveObject_FUN_004419c0(liveObj,local_4,param_3,local_10,NULL);
					std::free(param_3);
					std::free(local_10);
				}
				if (BVar4 != 0) {
					*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 5;
					liveObj->carriedObjects[0]->object_2fc = liveObj2;
					return BVar4;
				}
			}
		}
	}
	return BVar4;
}



void __cdecl lego::game::LiveObject_FUN_004477b0(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	float fVar1;
	float fVar2;
	float10 fVar3;
	float10 fVar4;
	Point2F local_18;
	Point2F local_10;
	Point2F local_8;
	
	liveObj = in_liveObj->object_2fc;
	in_liveObj->object_2fc = NULL;
	if (liveObj != NULL) {
		LiveObject_GetPosition(liveObj,(float *)&local_10,&local_10.y);
		LiveObject_GetPosition(in_liveObj,(float *)&local_8,&local_8.y);
		local_18.x = local_10.x - local_8.x;
		local_18.y = local_10.y - local_8.y;
		fVar2 = local_18.x * local_18.x;
		fVar1 = local_18.y * local_18.y;
		fVar3 = LiveObject_GetCollRadius(liveObj);
		fVar4 = LiveObject_GetCollRadius(in_liveObj);
		if ((float10)SQRT(fVar1 + fVar2) < fVar4 + fVar4 + (float10)(float)fVar3) {
			LiveObject_FUN_00447c10(liveObj,&local_18,1);
			LiveObject_AddDamage2(liveObj,10.0,1,1.0);
		}
	}
	return;
}



int __cdecl lego::game::LiveObject_FUN_00447880(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	int iVar3;
	float10 fVar4;
	
	iVar3 = 0;
	liveObj = in_liveObj->object_2fc;
	if ((liveObj != NULL) && ((liveObj->flags2 & LIVEOBJ2_UNK_100000) == LIVEOBJ2_NONE)) {
		OVar1 = LiveObject_GetStatsFlags2(in_liveObj);
		if ((OVar1 & STATS2_DRAINPOWER) == STATS2_NONE) {
			if ((in_liveObj->flags4 & 0x400000) == LIVEOBJ4_NONE) {
				if (in_liveObj->objType == OBJECT_ROCKMONSTER) {
					front::Info_FUN_00419ab0(INFO_UNDERATTACK,NULL,liveObj,NULL);
				}
				fVar4 = LiveObject_GetRepairValue(in_liveObj);
				if ((float10)0.0 <= fVar4) {
					liveObj->health = (float)(fVar4 + (float10)liveObj->health);
				}
				else {
					LiveObject_AddDamage2(liveObj,(float)-fVar4,1,1.0);
					liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_40000000;
				}
				if (liveObj->health < 100.0) {
					ai::AITask_DoRepair_Target(liveObj,0);
				}
				else {
					liveObj->health = (float)&DAT_42c80000;
					iVar3 = 1;
				}
			}
			else {
				LiveObject_FUN_00438ab0(liveObj);
				in_liveObj->flags4 = in_liveObj->flags4 & 0xffbfffff;
			}
		}
		else {
			BVar2 = LiveObject_CheckCondition_FUN_00438870(liveObj,0);
			if (BVar2 == 0) {
				return 1;
			}
			if (globs::gameGlobs.DrainTime <= in_liveObj->elapsedTime2) {
				LiveObject_Weapon_FUN_004375c0(in_liveObj,-1,1.0);
				in_liveObj->elapsedTime2 = 0.0;
			}
		}
		if ((ushort)((ushort)(liveObj->health < 0.0) << 8 | (ushort)(liveObj->health == 0.0) << 0xe) ==
				0) goto LAB_004479d1;
	}
	iVar3 = 1;
LAB_004479d1:
	if (iVar3 != 0) {
		in_liveObj->object_2fc = NULL;
	}
	return iVar3;
}



undefined4 __cdecl FUN_004479f0(int param_1)
{
	float fVar1;
	
	fVar1 = *(float *)(param_1 + 0x344) - -25.0;
	*(undefined4 *)(param_1 + 0x2fc) = 0;
	*(float *)(param_1 + 0x344) = fVar1;
	if ((ushort)((ushort)(fVar1 < *(float *)(param_1 + 0x340)) << 8 |
							(ushort)(fVar1 == *(float *)(param_1 + 0x340)) << 0xe) == 0) {
		*(undefined4 *)(param_1 + 0x344) = *(undefined4 *)(param_1 + 0x340);
		return 1;
	}
	return 0;
}



void __cdecl FUN_00447a40(LiveObject *liveObj)
{
	LiveObject *liveObj2;
	
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE) {
		liveObj2 = liveObj->carriedObjects[0];
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_CARRYING;
		liveObj->numCarriedObjects = 0;
		liveObj->carriedObjects[0] = NULL;
		liveObj2->flags3 = liveObj2->flags3 | LIVEOBJ3_UNK_2000;
		lego::ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_GATHER,liveObj2,1);
	}
	return;
}



void __cdecl FUN_00447a90(LiveObject *liveObj)
{
	void *pvVar1;
	LiveObject *pLVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	SurfaceMap *pSVar6;
	uint bx;
	uint uVar7;
	Point2F *pPVar8;
	Point2F *pPVar9;
	Point2F *pPVar10;
	float *out_y;
	Point2F local_20;
	float local_14;
	float local_10;
	float local_c;
	Point2F local_8;
	
	pLVar2 = liveObj->carriedObjects[0]->object_2fc;
	pvVar1 = (void *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14);
	out_y = &local_20.y;
	pPVar9 = &local_20;
	uVar7 = *(uint *)((int)pvVar1 + -0x10);
	bx = *(uint *)((int)pvVar1 + -0x14);
	pSVar6 = lego::game::GetSurfaceMap();
	lego::game::Map3D_BlockToWorldPos(pSVar6,bx,uVar7,(float *)pPVar9,out_y);
	lego::game::LiveObject_GetPosition(pLVar2,&local_10,&local_c);
	fVar3 = local_10 - local_20.x;
	fVar5 = local_c - local_20.y;
	pPVar9 = &local_8;
	pPVar8 = &local_20;
	pPVar10 = NULL;
	fVar4 = 1.0 / SQRT(fVar5 * fVar5 + fVar3 * fVar3);
	local_14 = fVar4 * fVar5 * 0.1;
	local_20.x = fVar4 * fVar3 * 0.1 + local_20.x;
	local_20.y = local_14 + local_20.y;
	pSVar6 = lego::game::GetSurfaceMap();
	lego::game::Map3D_FUN_0044fb30(pSVar6,pPVar8,pPVar10,pPVar9);
	uVar7 = liveObj->routingBlocksTotal;
	pvVar1 = liveObj->routeptr_24;
	*(float *)((int)pvVar1 + uVar7 * 0x14 + -0xc) = local_8.x;
	*(float *)((int)pvVar1 + uVar7 * 0x14 + -8) = local_8.y;
	*(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) =
			 *(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) | 8;
	pLVar2 = liveObj->carriedObjects[0];
	(pLVar2->point_2f4).x = local_10;
	(pLVar2->point_2f4).y = local_c;
	liveObj->carriedObjects[0]->object_2fc = NULL;
	return;
}



void __cdecl lego::game::LiveObject_FUN_00447bc0(LiveObject *liveObj)
{
	if (liveObj->objType == OBJECT_BUILDING) {
		Search_LiveObjects_SkipIgnoreMes(FUN_00447be0,(undefined4 *)liveObj);
	}
	return;
}



undefined4 __cdecl FUN_00447be0(int *param_1,int param_2)
{
	if (((*param_1 == 5) && (param_1[0xbf] == param_2)) && ((LiveObject *)param_1[0xc1] != NULL)) {
		lego::game::LiveObject_UnkDoRouting_FUN_00441c00((LiveObject *)param_1[0xc1],0);
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_00447c10(LiveObject *liveObj,Point2F *param_2,BOOL param_3)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	BOOL BVar5;
	ActivityType actType;
	float10 fVar6;
	
	if (((*(byte *)&liveObj->flags2 & LIVEOBJ2_UNK_2) != 0) && (liveObj->object_3c0 != NULL)) {
		liveObj = liveObj->object_3c0;
	}
	if ((liveObj->flags1 & LIVEOBJ1_UNK_1000) == LIVEOBJ1_NONE) {
		BVar5 = LiveObject_CheckCondition_FUN_00438870(liveObj,1);
		if (BVar5 != 0) {
			if (param_2 == NULL) {
				actType = (-(uint)(param_3 != 0) & 0xfffffff7) + ACTIVITY_STAMP;
			}
			else {
				fVar1 = (liveObj->faceDirection).x;
				fVar2 = (liveObj->faceDirection).y;
				fVar6 = (float10)fcos((float10)0.7853981852531433);
				fVar3 = 1.0 / SQRT(fVar2 * fVar2 + fVar1 * fVar1);
				fVar1 = fVar3 * fVar1;
				fVar3 = fVar3 * fVar2;
				fVar4 = 1.0 - (float)fVar6;
				fVar2 = fVar3 * param_2->y + fVar1 * param_2->x;
				if ((ushort)((ushort)(fVar2 < fVar4) << 8 | (ushort)(fVar2 == fVar4) << 0xe) == 0) {
					actType = ACTIVITY_HITBACK;
				}
				else {
					if (-fVar4 <= fVar2) {
						fVar1 = fVar3 * param_2->x - fVar1 * param_2->y;
						if ((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) == 0) {
							actType = ACTIVITY_HITRIGHT;
						}
						else {
							actType = ACTIVITY_HITLEFT;
						}
					}
					else {
						actType = ACTIVITY_HITFRONT;
					}
				}
			}
			LiveObject_FUN_00441df0(liveObj,0,1);
			LiveObject_SetActivityUnk(liveObj,actType,1);
			BVar5 = LiveObject_Container_ActivityUpdate_Check(liveObj);
			if (BVar5 == 0) {
				LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,1);
				LiveObject_Container_ActivityUpdate_Check(liveObj);
			}
			LiveObject_FUN_00447df0(liveObj,1.0);
			liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_1000;
			if (liveObj->objType == OBJECT_ROCKMONSTER) {
				liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_POWEROFF;
			}
		}
	}
	return;
}



void __cdecl lego::game::liveObject_UnkActivityTeleport_FUN_00447dc0(LiveObject *liveObj)
{
	LiveObject_SetActivityUnk(liveObj,ACTIVITY_TELEPORT,0);
	LiveObject_Container_ActivityUpdate_Check(liveObj);
	liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_UNK_200000;
	return;
}



float10 __cdecl lego::game::LiveObject_FUN_00447df0(LiveObject *in_liveObj,float elapsed)
{
	ObjectType OVar1;
	LiveObject *in_liveObj_00;
	float elapsed_00;
	float10 fVar2;
	
	elapsed_00 = elapsed;
	in_liveObj_00 = in_liveObj;
	LiveObject_FUN_004468d0(in_liveObj,elapsed,(float *)&in_liveObj,&elapsed);
	if ((in_liveObj_00->flags1 & LIVEOBJ1_UNK_4000) != LIVEOBJ1_NONE) goto LAB_00447ed1;
	OVar1 = in_liveObj_00->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		fVar2 = res::Vehicle_FUN_0046d480
											(in_liveObj_00->vehicle,elapsed,elapsed_00,in_liveObj_00->unkbool_2d8);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			fVar2 = res::Creature_FUN_00406c60
												(in_liveObj_00->miniFigure,elapsed,in_liveObj_00->unkbool_2d8);
		}
		else {
			if (OVar1 == OBJECT_ROCKMONSTER) {
				fVar2 = res::Creature_FUN_00406c60
													(in_liveObj_00->rockMonster,elapsed,in_liveObj_00->unkbool_2d8);
			}
			else {
				if (OVar1 == OBJECT_BUILDING) {
					fVar2 = res::Building_FUN_00408790
														(in_liveObj_00->building,elapsed,in_liveObj_00->unkbool_2d8);
				}
				else {
					if ((in_liveObj_00->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
						LiveObject_FUN_00448160(in_liveObj_00,elapsed_00);
						goto LAB_00447ed1;
					}
					if (OVar1 != OBJECT_UPGRADEPART) goto LAB_00447ed1;
					fVar2 = res::Upgrade_DoAnimElapsedCallbacks
														(in_liveObj_00->upgrade,elapsed,in_liveObj_00->unkbool_2d8);
				}
			}
		}
	}
	in_liveObj_00->float_2d4 = (float)fVar2;
LAB_00447ed1:
	if ((ushort)((ushort)(in_liveObj_00->float_2d4 < 0.0) << 8 |
							(ushort)(in_liveObj_00->float_2d4 == 0.0) << 0xe) == 0) {
		ai::AITask_LiveObject_Unk_UpdateAITask_AnimationWait(in_liveObj_00);
	}
	return (float10)elapsed;
}



BOOL __cdecl lego::game::LiveObject_Container_ActivityUpdate_Check(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	int iVar2;
	char *pcVar3;
	Container *pCVar4;
	BOOL BVar5;
	char *pcVar6;
	char local_100 [256];
	
	BVar5 = 0;
	pcVar6 = liveObj->aitaskName1;
	if (pcVar6 == liveObj->aitaskName2) {
		return 0;
	}
	if ((((pcVar6 != globs::liveGlobs.Activities_TABLE[0]) &&
			 (pcVar6 != globs::liveGlobs.Activities_TABLE[1])) &&
			(pcVar6 != globs::liveGlobs.Activities_TABLE[4])) &&
		 (((pcVar6 != globs::liveGlobs.Activities_TABLE[6] &&
			 (pcVar6 != globs::liveGlobs.Activities_TABLE[8])) &&
			((pcVar6 != globs::liveGlobs.Activities_TABLE[17] &&
			 ((pcVar6 != globs::liveGlobs.Activities_TABLE[22] &&
				(pcVar6 != globs::liveGlobs.Activities_TABLE[2])))))))) {
		ai::AITask_DoAnimationWait(liveObj);
	}
	switch(liveObj->objType) {
	case OBJECT_VEHICLE:
		BVar5 = res::Vehicle_SetActivity_AndRemoveCarryCameraFrames
											(liveObj->vehicle,liveObj->aitaskName1,liveObj->float_2d4);
		pCVar4 = res::Vehicle_GetCameraNull(liveObj->vehicle,liveObj->index_2e0);
		break;
	case OBJECT_MINIFIGURE:
		BVar5 = res::Creature_SetActivity_AndRemoveCarryCameraFrames
											(liveObj->miniFigure,liveObj->aitaskName1,liveObj->float_2d4);
		pCVar4 = res::Creature_GetCameraNull(liveObj->miniFigure,liveObj->index_2e0);
		break;
	case OBJECT_ROCKMONSTER:
		BVar5 = res::Creature_SetActivity_AndRemoveCarryCameraFrames
											(liveObj->rockMonster,liveObj->aitaskName1,liveObj->float_2d4);
		pCVar4 = res::Creature_GetCameraNull(liveObj->rockMonster,liveObj->index_2e0);
		break;
	case OBJECT_BUILDING:
		BVar5 = res::Building_SetActivity_AndRemoveCarryCameraFrames
											(liveObj->building,liveObj->aitaskName1,liveObj->float_2d4);
		pCVar4 = res::Building_GetCameraNull(liveObj->building,liveObj->index_2e0);
		break;
	default:
		goto switchD_00447f7d_caseD_4;
	}
	liveObj->resData_2dc = pCVar4;
switchD_00447f7d_caseD_4:
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	if ((((OVar1 & STATS1_CANBEDRIVEN) != STATS1_NONE) && (liveObj->drivenObject != NULL)) &&
		 (liveObj->drivenObject->objType == OBJECT_MINIFIGURE)) {
		iVar2 = std::_stricmp(globs::liveGlobs.Activities_TABLE[1],liveObj->aitaskName1);
		pcVar6 = "Activity_";
		if (iVar2 != 0) {
			pcVar6 = liveObj->aitaskName1;
		}
		pcVar3 = Object_GetTypeName(liveObj->objType,liveObj->objIndex);
		std::sprintf(local_100,"%s%s",pcVar6,pcVar3);
		res::Creature_SetActivity_AndRemoveCarryCameraFrames
							(liveObj->drivenObject->miniFigure,local_100,0.0);
		pCVar4 = res::Creature_GetCameraNull
											 (liveObj->drivenObject->miniFigure,liveObj->drivenObject->index_2e0);
		liveObj->drivenObject->resData_2dc = pCVar4;
		liveObj->drivenObject->aitaskName1 = liveObj->drivenObject->aitaskName2;
	}
	liveObj->float_2d4 = 0.0;
	liveObj->aitaskName2 = liveObj->aitaskName1;
	liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_20000;
	return BVar5;
}



void __cdecl lego::game::LiveObject_FUN_00448160(LiveObject *in_liveObj,float elapsed)
{
	LiveFlags2 *pLVar1;
	ObjectType OVar2;
	float fVar3;
	LiveObject *liveObj;
	SurfaceMap *pSVar4;
	LiveObject *pLVar5;
	uint uVar6;
	LiveFlags1 LVar7;
	int iVar8;
	int iVar9;
	LevelData *level;
	LiveFlags3 LVar10;
	float10 fVar11;
	float10 fVar12;
	float10 fVar13;
	longlong lVar14;
	float fVar15;
	BOOL BVar16;
	Point2I *out_bx;
	float fVar17;
	float *out_x;
	Container *cont;
	int *out_by;
	float *pfVar18;
	char *pcVar19;
	float local_4c;
	float local_48;
	Point2I local_44;
	Point2I local_3c;
	Point2F local_34;
	float local_2c;
	float local_28;
	Vector3F local_24;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	liveObj = in_liveObj;
	OVar2 = in_liveObj->objType;
	if (OVar2 == OBJECT_BOULDER) {
		if ((in_liveObj->flags3 & LIVEOBJ3_UNK_2000) != LIVEOBJ3_NONE) {
			res::Container_GetPosition(in_liveObj->other,NULL,&local_c);
			fVar17 = (liveObj->point_2f4).y;
			fVar15 = (liveObj->point_2f4).x;
			local_24.z = 0.0;
			local_24.x = fVar15;
			local_24.y = fVar17;
			pSVar4 = GetSurfaceMap();
			fVar11 = Map3D_GetWorldZ(pSVar4,fVar15,fVar17);
			in_liveObj = (LiveObject *)(float)fVar11;
			fVar12 = LiveObject_GetCollRadius(liveObj);
			fVar11 = (float10)(float)in_liveObj;
			fVar13 = (fVar11 - fVar12) - (float10)local_c.z;
			fVar17 = (float)((float10)local_24.x - (float10)local_c.x);
			fVar15 = (float)((float10)local_24.y - (float10)local_c.y);
			local_10 = (float)fVar13;
			in_liveObj = (LiveObject *)(elapsed * 3.5);
			local_4c = (float)SQRT(fVar13 * (float10)local_10 +
														 ((float10)local_24.y - (float10)local_c.y) * (float10)fVar15 +
														 ((float10)local_24.x - (float10)local_c.x) * (float10)fVar17);
			fVar3 = 1.0 / local_4c;
			local_18 = fVar3 * fVar17 * (float)in_liveObj;
			local_c.x = local_18 + local_c.x;
			local_14 = fVar3 * fVar15 * (float)in_liveObj;
			local_c.y = local_14 + local_c.y;
			local_c.z = fVar3 * local_10 * (float)in_liveObj + local_c.z;
			fVar17 = local_c.x;
			fVar15 = local_c.y;
			local_24.z = local_c.z;
			if (local_4c < (float)in_liveObj) {
				liveObj->carryingThisObject = NULL;
				liveObj->health = -1.0;
				liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_2000 | LIVEOBJ3_UNK_800000;
				fVar17 = local_24.x;
				fVar15 = local_24.y;
				local_24.z = (float)(fVar11 - fVar12);
			}
			local_24.y = fVar15;
			local_24.x = fVar17;
			local_34.x = local_24.x;
			out_by = &local_3c.y;
			out_bx = &local_3c;
			local_34.y = local_24.y;
			fVar17 = local_24.x;
			fVar15 = local_24.y;
			local_44.x = (int)in_liveObj;
			pSVar4 = GetSurfaceMap();
			Map3D_WorldToBlockPos_NoZ(pSVar4,fVar17,fVar15,(int *)out_bx,out_by);
			fVar17 = local_24.x;
			fVar15 = local_24.y;
			pSVar4 = GetSurfaceMap();
			fVar11 = Map3D_GetWorldZ(pSVar4,fVar17,fVar15);
			pLVar5 = (LiveObject *)
							 LiveObject_DoCollisionCallbacks_FUN_00446030
												 (liveObj,&local_34,(float)(fVar11 - (float10)local_24.z),1);
			if (pLVar5 != NULL) {
				liveObj->carryingThisObject = NULL;
				liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_2000;
				pfVar18 = &local_2c;
				fVar17 = 0.0;
				BVar16 = 1;
				local_28 = 1.0 / SQRT(local_14 * local_14 + local_18 * local_18);
				local_2c = local_28 * local_18;
				local_28 = local_28 * local_14;
				uVar6 = tools::Weapon_GetWeaponTypeByName("Boulder");
				LiveObject_FUN_0046f530(pLVar5,uVar6,BVar16,fVar17,pfVar18);
				liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
				liveObj->health = -1.0;
				res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(NULL,SFX_BOULDERHIT,0,0,&local_24);
			}
			res::Container_SetPosition(liveObj->other,NULL,local_24.x,local_24.y,local_24.z);
			return;
		}
	}
	else {
		if (OVar2 == OBJECT_POWERCRYSTAL) {
			if (in_liveObj->carryingThisObject == NULL) {
				res::Container_AddRotation(in_liveObj->other,D3DRMCOMBINE_BEFORE,0.0,1.0,0.0,elapsed * 0.01)
				;
				return;
			}
		}
		else {
			if ((OVar2 == OBJECT_DYNAMITE) || (OVar2 == OBJECT_OOHSCARY)) {
				if ((in_liveObj->flags3 & LIVEOBJ3_UNK_10000) == LIVEOBJ3_NONE) {
					if ((in_liveObj->flags1 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
						in_liveObj->flags1 = in_liveObj->flags1 & ~LIVEOBJ1_PLACING;
						in_liveObj->flags3 = in_liveObj->flags3 | LIVEOBJ3_UNK_10000;
						res::Container_SetActivity(in_liveObj->other,"TickDown");
						res::Container_SetAnimationTime(liveObj->other,0.0);
						LiveObject_GetBlockPos(liveObj,(int *)&local_44,&local_44.y);
						Level_BlockSetter_FUN_00432640(&local_44,1);
						front::Info_FUN_00419ab0(INFO_DYNAMITEPLACED,NULL,liveObj,NULL);
						lVar14 = __ftol((float10)(liveObj->point_2f4).y);
						iVar8 = (int)lVar14;
						lVar14 = __ftol((float10)(liveObj->point_2f4).x);
						iVar9 = (int)lVar14;
						pSVar4 = GetSurfaceMap();
						Map3D_Block_ClearHighlight(pSVar4,iVar9,iVar8);
						return;
					}
					res::Container_MoveAnimation(in_liveObj->other,elapsed);
				}
				else {
					if (((ushort)((ushort)(in_liveObj->health < 0.0) << 8 |
											 (ushort)(in_liveObj->health == 0.0) << 0xe) != 0) ||
						 (fVar11 = res::Container_MoveAnimation(in_liveObj->other,elapsed),
						 fVar11 != (float10)0.0)) {
						lVar14 = __ftol((float10)(liveObj->point_2f4).x);
						iVar8 = (int)lVar14;
						local_3c.x = iVar8;
						lVar14 = __ftol((float10)(liveObj->point_2f4).y);
						iVar9 = (int)lVar14;
						local_3c.y = iVar9;
						if ((iVar8 != 0) && (iVar9 != 0)) {
							BVar16 = 0;
							level = GetLevel();
							Level_DestroyWall(level,iVar8,iVar9,BVar16);
						}
						if (liveObj->objType == OBJECT_DYNAMITE) {
							LiveObject_GetBlockPos(liveObj,(int *)&local_3c,&local_3c.y);
							Level_BlockSetter_FUN_00432640(&local_3c,0);
							Game_DoDynamiteExplosionCallbacks
												(liveObj,globs::gameGlobs.DynamiteDamageRadius,
												 globs::gameGlobs.DynamiteMaxDamage,globs::gameGlobs.DynamiteWakeRadius);
							snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_DYNAMITE,0);
							lego::effect::Effect_Spawn_Explosion(liveObj,NULL);
							lego::view::Camera_SetFloata0_a4_Zeroa8(globs::gameGlobs.cameraMain,5.0,50.0);
						}
						else {
							if (liveObj->objType == OBJECT_OOHSCARY) {
								LiveObject_GetPosition(liveObj,(float *)&local_c,&local_c.y);
								LiveObject_GetBlockPos(liveObj,(int *)&local_44,&local_44.y);
								pSVar4 = GetSurfaceMap();
								fVar11 = Map3D_GetWorldZ(pSVar4,local_c.x,local_c.y);
								local_c.z = (float)fVar11;
								lego::effect::Effect_Spawn_Particle(MISCOBJECT_BIRDSCARER,&local_c,NULL);
								lego::view::Camera_SetFloata0_a4_Zeroa8
													(globs::gameGlobs.cameraMain,2.0,(float)&DAT_42c80000);
								Level_BlockSetter_FUN_00432640(&local_44,0);
							}
						}
						liveObj->health = -1.0;
						liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
						return;
					}
				}
			}
			else {
				if (OVar2 == OBJECT_ELECTRICFENCE) {
					if ((in_liveObj->flags1 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
						in_liveObj->flags1 = in_liveObj->flags1 & ~LIVEOBJ1_PLACING;
						ElectricFence_AssignBlockObject(in_liveObj);
						LiveObject_GetBlockPos(liveObj,(int *)&local_44,(int *)&in_liveObj);
						pfVar18 = &local_48;
						out_x = &local_4c;
						uVar6 = local_44.x;
						pLVar5 = in_liveObj;
						pSVar4 = GetSurfaceMap();
						Map3D_BlockToWorldPos(pSVar4,uVar6,(uint)pLVar5,out_x,pfVar18);
						fVar11 = LiveObject_UnkRadians_FUN_00442740(liveObj);
						BVar16 = 1;
						fVar12 = std::fmod((float10)(float)(fVar11 - (float10)-0.7853982),
															 (float10)1.570796370506287);
						LiveObject_UnkUpdatePositioning
											(liveObj,local_4c,local_48,
											 (float)((float10)(float)(fVar11 - (float10)-0.7853982) - fVar12),BVar16);
						Level_SetBlockFlag8(local_44.x,(int)in_liveObj,0);
						return;
					}
				}
				else {
					if (OVar2 == OBJECT_BARRIER) {
						fVar11 = res::Container_MoveAnimation(in_liveObj->other,elapsed);
						if (fVar11 == (float10)0.0) {
							return;
						}
						LVar7 = liveObj->flags1;
						if ((LVar7 & LIVEOBJ1_PLACING) != LIVEOBJ1_NONE) {
							pcVar19 = "Expand";
							liveObj->flags1 = LVar7 & ~LIVEOBJ1_PLACING | LIVEOBJ1_UNK_100;
							goto LAB_0044872d;
						}
						if ((LVar7 & LIVEOBJ1_UNK_100) != LIVEOBJ1_NONE) {
							liveObj->flags1 = LVar7 & ~LIVEOBJ1_UNK_100;
							liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_10000;
							pcVar19 = "Long";
							goto LAB_00448783;
						}
						LVar10 = liveObj->flags3;
						if ((LVar10 & LIVEOBJ3_UNK_800000) != LIVEOBJ3_NONE) {
							liveObj->health = (float)&DAT_42c80000;
							liveObj->flags3 = LVar10 & ~LIVEOBJ3_UNK_800000;
							liveObj->flags1 = LVar7 | LIVEOBJ1_UNK_200000;
							res::Container_SetActivity(liveObj->other,"Teleport");
							res::Container_SetAnimationTime(liveObj->other,0.0);
							return;
						}
					}
					else {
						if (OVar2 != OBJECT_SPIDERWEB) {
							if (OVar2 != OBJECT_ICECUBE) {
								if ((((OVar2 != OBJECT_ELECTRICFENCESTUD) && (OVar2 != OBJECT_PUSHER)) &&
										(OVar2 != OBJECT_FREEZER)) && (OVar2 != OBJECT_LASERSHOT)) {
									return;
								}
								res::Container_MoveAnimation(in_liveObj->other,elapsed);
								return;
							}
							fVar11 = res::Container_MoveAnimation(in_liveObj->other,elapsed);
							if (fVar11 == (float10)0.0) {
								return;
							}
							LVar7 = liveObj->flags1;
							if ((LVar7 & LIVEOBJ1_UNK_100) == LIVEOBJ1_NONE) {
								LVar10 = liveObj->flags3;
								if ((LVar10 & LIVEOBJ3_UNK_800000) == LIVEOBJ3_NONE) {
									if ((LVar7 & LIVEOBJ1_UNK_200000) == LIVEOBJ1_NONE) {
										return;
									}
									liveObj->flags1 = LVar7 & ~LIVEOBJ1_UNK_200000;
									liveObj->health = -1.0;
									liveObj->flags3 = LVar10 | LIVEOBJ3_UNK_800000;
									pLVar1 = &liveObj->object_364->flags2;
									*pLVar1 = *pLVar1 & ~LIVEOBJ2_UNK_8000000;
									return;
								}
								liveObj->health = (float)&DAT_42c80000;
								liveObj->flags3 = LVar10 & ~LIVEOBJ3_UNK_800000;
								liveObj->flags1 = LVar7 | LIVEOBJ1_UNK_200000;
								pcVar19 = "Melt";
LAB_00448783:
								res::Container_SetActivity(liveObj->other,pcVar19);
								res::Container_SetAnimationTime(liveObj->other,0.0);
								return;
							}
							liveObj->flags1 = LVar7 & ~LIVEOBJ1_UNK_100;
							liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_10000;
							pcVar19 = "Normal";
LAB_0044872d:
							res::Container_SetActivity(liveObj->other,pcVar19);
							res::Container_SetAnimationTime(liveObj->other,0.0);
							return;
						}
						if (((in_liveObj->flags1 & LIVEOBJ1_CAUGHTINWEB) == LIVEOBJ1_NONE) ||
							 ((in_liveObj->flags1 & LIVEOBJ1_UNK_100) != LIVEOBJ1_NONE)) {
							cont = in_liveObj->other;
						}
						else {
							cont = in_liveObj->other;
							elapsed = 0.0;
						}
						fVar11 = res::Container_MoveAnimation(cont,elapsed);
						if (fVar11 == (float10)0.0) {
							return;
						}
						LVar7 = liveObj->flags1;
						if ((LVar7 & LIVEOBJ1_UNK_100) != LIVEOBJ1_NONE) {
							liveObj->flags1 = LVar7 & ~LIVEOBJ1_UNK_100;
							liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_10000;
							pcVar19 = "FlapInWind";
							goto LAB_0044872d;
						}
						LVar10 = liveObj->flags3;
						if ((LVar10 & LIVEOBJ3_UNK_800000) != LIVEOBJ3_NONE) {
							liveObj->health = (float)&DAT_42c80000;
							liveObj->flags3 = LVar10 & ~LIVEOBJ3_UNK_800000;
							liveObj->flags1 = LVar7 | LIVEOBJ1_UNK_200000;
							pcVar19 = "Disintegrate";
							goto LAB_00448783;
						}
					}
					if ((LVar7 & LIVEOBJ1_UNK_200000) != LIVEOBJ1_NONE) {
						liveObj->flags1 = LVar7 & ~LIVEOBJ1_UNK_200000;
						liveObj->health = -1.0;
						liveObj->flags3 = LVar10 | LIVEOBJ3_UNK_800000;
						return;
					}
				}
			}
		}
	}
	return;
}



void __cdecl FUN_00448a80(int *param_1)
{
	if (((param_1[0xf8] & 0x400U) != 0) && (*(int *)param_1[0xc2] == 8)) {
		((int *)param_1[0xc2])[0xbe] = 0;
		*(undefined4 *)(param_1[0xc2] + 0x2f4) = 0;
		lego::game::LiveObject_FUN_0043a130((LiveObject *)param_1,1);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_TryDynamite_FUN_00448ac0(LiveObject *liveObj,Point2I *param_2)
{
	LiveObject *pLVar1;
	BOOL BVar2;
	
	if (liveObj->carriedObjects[0]->objType == OBJECT_DYNAMITE) {
		BVar2 = LiveObject_FUN_00432880(liveObj,param_2->x,param_2->y);
		if (BVar2 != 0) {
			BVar2 = LiveObject_RoutingPointerBlocks_FUN_00449b40(liveObj,param_2->x,param_2->y,7.0);
			if (BVar2 != 0) {
				pLVar1 = liveObj->carriedObjects[0];
				*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 9;
				(pLVar1->point_2f4).x = (float)param_2->x;
				(pLVar1->point_2f4).y = (float)param_2->y;
				return TRUE;
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_DoBirdScarer(LiveObject *liveObj,Point2I *position)
{
	float *pfVar1;
	LiveObject *pLVar2;
	Point2I *pPVar3;
	BOOL BVar4;
	uint local_c;
	int local_8;
	float local_4;
	LiveObject *liveObj_00;
	
	pPVar3 = position;
	liveObj_00 = liveObj;
	if (liveObj->carriedObjects[0]->objType == OBJECT_OOHSCARY) {
		pfVar1 = (float *)&position->y;
		BVar4 = Level_BlockCheck_FUN_00432900(liveObj,position->x,position->y);
		if (BVar4 != 0) {
			LiveObject_GetBlockPos(liveObj_00,&local_8,(int *)&local_4);
			if ((local_8 == pPVar3->x) && (local_4 == *pfVar1)) {
				LiveObject_FUN_004419c0(liveObj_00,1,(float *)pPVar3,pfVar1,NULL);
				return 0;
			}
			BVar4 = LiveObject_FUN_004413b0
												(liveObj_00,local_8,local_4,pPVar3->x,*pfVar1,&liveObj,&position,&local_c,0,
												 0);
			if (BVar4 != 0) {
				BVar4 = LiveObject_FUN_004419c0(liveObj_00,local_c,(float *)liveObj,(float *)position,NULL);
				std::free(liveObj);
				std::free(position);
				if (BVar4 != 0) {
					pLVar2 = liveObj_00->carriedObjects[0];
					*(undefined *)((int)liveObj_00->routeptr_24 + liveObj_00->routingBlocksTotal * 0x14 + -3)
							 = 9;
					(pLVar2->point_2f4).x = (float)pPVar3->x;
					(pLVar2->point_2f4).y = (float)(int)*pfVar1;
					return 1;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_00448c60(LiveObject *liveObj)
{
	BOOL BVar1;
	LiveObject *pLVar2;
	float10 fVar3;
	float local_10;
	float local_c;
	Point2I local_8;
	
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_BIRDSCARER);
	if (BVar1 != 0) {
		LiveObject_GetPosition(liveObj,&local_10,&local_c);
		LiveObject_GetBlockPos(liveObj,(int *)&local_8,&local_8.y);
		fVar3 = LiveObject_UnkRadians_FUN_00442740(liveObj);
		pLVar2 = Game_CreateLiveResourceObject
											 (globs::gameGlobs.RES_OohScary,OBJECT_OOHSCARY,0,0,local_10,local_c,
												(float)fVar3);
		Level_BlockSetter_FUN_00432640(&local_8,1);
		res::Container_SetActivity(pLVar2->other,"TickDown");
		res::Container_SetAnimationTime(pLVar2->other,0.0);
		pLVar2->flags3 = pLVar2->flags3 | LIVEOBJ3_UNK_10000;
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_TryElecFence_FUN_00448d20(LiveObject *liveObj,Point2I *blockPos)
{
	float *pfVar1;
	float fVar2;
	void *pvVar3;
	LiveObject *pLVar4;
	Point2I *pPVar5;
	short sVar6;
	BOOL BVar7;
	uint uVar8;
	float10 fVar9;
	float *local_18;
	uint local_14;
	float local_10;
	float local_c;
	int local_8;
	float local_4;
	
	pPVar5 = blockPos;
	if (liveObj->carriedObjects[0]->objType == OBJECT_ELECTRICFENCE) {
		pfVar1 = (float *)&blockPos->y;
		BVar7 = ElectricFence_Block_FUN_0040d170(blockPos->x,blockPos->y);
		if (BVar7 != 0) {
			LiveObject_GetBlockPos(liveObj,&local_8,(int *)&local_4);
			if ((local_8 == pPVar5->x) && (local_4 == *pfVar1)) {
				BVar7 = LiveObject_FUN_004419c0(liveObj,1,(float *)pPVar5,pfVar1,NULL);
			}
			else {
				BVar7 = LiveObject_FUN_004413b0
													(liveObj,local_8,local_4,pPVar5->x,*pfVar1,&blockPos,&local_18,&local_14,0
													 ,0);
				if (BVar7 == 0) {
					return 0;
				}
				BVar7 = LiveObject_FUN_004419c0(liveObj,local_14,(float *)blockPos,local_18,NULL);
				std::free(blockPos);
				std::free(local_18);
			}
			if (BVar7 != 0) {
				*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 9;
				if (liveObj->objType == OBJECT_VEHICLE) {
					fVar9 = math::Maths_RandRange(0.55,0.75);
					fVar2 = (float)fVar9;
					sVar6 = math::Maths_Rand();
					uVar8 = (int)sVar6 >> 0x1f;
					switch((((int)sVar6 ^ uVar8) - uVar8 & 3 ^ uVar8) - uVar8) {
					case 0:
						local_10 = 0.5;
						local_c = fVar2;
						break;
					case 1:
						local_c = 0.5;
						local_10 = fVar2;
						break;
					case 2:
						local_10 = 0.5;
						local_c = 1.0 - fVar2;
						break;
					case 3:
						local_c = 0.5;
						local_10 = 1.0 - fVar2;
					}
					uVar8 = liveObj->routingBlocksTotal;
					pvVar3 = liveObj->routeptr_24;
					*(float *)((int)pvVar3 + uVar8 * 0x14 + -0xc) = local_10;
					*(float *)((int)pvVar3 + uVar8 * 0x14 + -8) = local_c;
					*(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) =
							 *(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) | 8;
				}
				pLVar4 = liveObj->carriedObjects[0];
				(pLVar4->point_2f4).x = (float)pPVar5->x;
				(pLVar4->point_2f4).y = (float)(int)*pfVar1;
				return 1;
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_TryBuildPath_FUN_00448f10(LiveObject *liveObj)
{
	LiveObject_SetActivityUnk(liveObj,ACTIVITY_CLEAR,0);
	LiveObject_Container_ActivityUpdate_Check(liveObj);
	liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_200;
	return TRUE;
}



BOOL __cdecl
lego::game::LiveObject_TryUpgrade_FUN_00448f50
					(LiveObject *in_liveObj,LiveObject *targetObj,int targetObjLevel)
{
	byte *pbVar1;
	float fVar2;
	LiveObject *liveObj;
	LiveObject *liveObj_00;
	BOOL BVar3;
	Container *cont;
	SurfaceMap *surfMap;
	byte bVar4;
	BOOL BVar5;
	float *out_bx;
	float *out_by;
	uint local_30;
	float local_2c;
	float local_28;
	float local_24;
	float local_20;
	int local_1c;
	int local_18 [2];
	float local_10;
	Vector3F local_c;
	
	liveObj_00 = targetObj;
	liveObj = in_liveObj;
	BVar5 = 0;
	if (targetObj->objType == OBJECT_BUILDING) {
		if (in_liveObj->objType == OBJECT_MINIFIGURE) {
			BVar3 = LiveObject_TryTrain_FUN_00449170(in_liveObj,targetObj,1);
			if (BVar3 != 0) {
				return TRUE;
			}
		}
		else {
			if (in_liveObj->objType == OBJECT_VEHICLE) {
				cont = LiveObject_GetDepositNull(targetObj);
				res::Container_GetPosition(cont,NULL,&local_c);
				out_by = &local_28;
				out_bx = &local_2c;
				surfMap = GetSurfaceMap();
				Map3D_WorldToBlockPos_NoZ(surfMap,local_c.x,local_c.y,(int *)out_bx,(int *)out_by);
				LiveObject_GetBlockPos(liveObj,(int *)&local_24,(int *)&local_20);
				LiveObject_GetBlockPos(liveObj_00,&local_1c,local_18);
				fVar2 = (float)(int)local_2c - (float)local_1c;
				local_10 = (float)(int)local_28 - (float)local_18[0];
				if (ABS(fVar2) <= ABS(local_10)) {
					if ((ushort)((ushort)(local_10 < 0.0) << 8 | (ushort)(local_10 == 0.0) << 0xe) == 0) {
						bVar4 = 0;
					}
					else {
						bVar4 = 2;
					}
				}
				else {
					if ((ushort)((ushort)(fVar2 < 0.0) << 8 | (ushort)(fVar2 == 0.0) << 0xe) == 0) {
						bVar4 = 1;
					}
					else {
						bVar4 = 3;
					}
				}
				if ((local_24 == local_2c) && (local_20 == local_28)) {
					BVar5 = LiveObject_FUN_004419c0(liveObj,1,&local_2c,&local_28,NULL);
				}
				else {
					BVar5 = LiveObject_FUN_004413b0
														(liveObj,local_24,local_20,local_2c,local_28,&targetObj,&in_liveObj,
														 &local_30,0,0);
					if (BVar5 == 0) {
						return 0;
					}
					BVar5 = LiveObject_FUN_004419c0
														(liveObj,local_30,(float *)targetObj,(float *)in_liveObj,NULL);
					std::free(targetObj);
					std::free(in_liveObj);
				}
				if (BVar5 != 0) {
					*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 0xf;
					pbVar1 = (byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4);
					*pbVar1 = *pbVar1 | 4;
					*(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) =
							 *(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) |
							 bVar4;
					liveObj->field_404 = targetObjLevel;
					liveObj->object_2fc = liveObj_00;
					liveObj_00->object_300 = liveObj;
					return BVar5;
				}
			}
		}
	}
	return BVar5;
}



BOOL __cdecl
lego::game::LiveObject_TryTrain_FUN_00449170
					(LiveObject *liveObj,LiveObject *targetObj,BOOL set_0xE_or0xF)
{
	byte *pbVar1;
	uint uVar2;
	void *pvVar3;
	float fVar4;
	LiveObject *pLVar5;
	BOOL BVar6;
	SurfaceMap *surfMap;
	uint uVar7;
	float10 fVar8;
	uint local_28;
	uint local_24;
	float local_20 [4];
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pLVar5 = targetObj;
	if ((liveObj->objType == OBJECT_MINIFIGURE) && (targetObj->objType == OBJECT_BUILDING)) {
		LiveObject_GetBlockPos(targetObj,(int *)&local_28,(int *)&local_24);
		BVar6 = LiveObject_FUN_00446c80(liveObj,local_28,local_24,0,(uint *)&targetObj,1);
		if (BVar6 != 0) {
			surfMap = GetSurfaceMap();
			fVar8 = Map3D_GetBlockSize(surfMap);
			local_c = (float)((float10)4.0 / fVar8);
			fVar8 = math::Maths_RandRange(0.1,0.9);
			uVar2 = liveObj->routingBlocksTotal;
			local_20[0] = (float)fVar8;
			local_8 = local_c;
			uVar7 = (int)&targetObj[-1].pool_m_next + 2U & 3;
			local_20[3] = local_20[0];
			local_10 = local_20[0];
			local_4 = local_20[0];
			local_20[1] = 1.0 - local_c;
			local_20[2] = 1.0 - local_c;
			pvVar3 = liveObj->routeptr_24;
			fVar4 = local_20[uVar7 * 2 + 1];
			*(float *)((int)pvVar3 + uVar2 * 0x14 + -0xc) = local_20[uVar7 * 2];
			*(float *)((int)pvVar3 + uVar2 * 0x14 + -8) = fVar4;
			if (set_0xE_or0xF == 0) {
				*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 0xe;
			}
			else {
				*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 0xf;
			}
			*(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) =
					 *(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) | 4;
			pbVar1 = (byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4);
			targetObj._0_1_ = (byte)uVar7;
			*pbVar1 = *pbVar1 | (byte)targetObj;
			liveObj->object_2fc = pLVar5;
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_TryRecharge_FUN_004492d0(LiveObject *liveObj)
{
	BOOL BVar1;
	Point2I local_8;
	
	if ((((liveObj->objType == OBJECT_MINIFIGURE) &&
			 ((liveObj->flags1 & LIVEOBJ1_CARRYING) != LIVEOBJ1_NONE)) &&
			(liveObj->carriedObjects[0]->objType == OBJECT_POWERCRYSTAL)) &&
		 ((liveObj->carriedObjects[0]->flags3 & LIVEOBJ3_POWEROFF) != LIVEOBJ3_NONE)) {
		BVar1 = LiveObject_FindRechargeSeam_FUN_0044a690(liveObj,&local_8);
		if (BVar1 != 0) {
			BVar1 = LiveObject_RoutingPointerBlocks_FUN_00449b40(liveObj,local_8.x,local_8.y,3.0);
			if (BVar1 != 0) {
				*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 0x12;
				(liveObj->point_2f4).x = (float)local_8.x;
				(liveObj->point_2f4).y = (float)local_8.y;
				return TRUE;
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_TryRepair_FUN_00449360
					(LiveObject *in_liveObj,LiveObject *targetObj,BOOL param_3,BOOL param_4)
{
	byte *pbVar1;
	ObjectType OVar2;
	uint uVar3;
	void *pvVar4;
	float fVar5;
	bool bVar6;
	LiveObject *liveObj;
	ObjectStatsFlags2 OVar7;
	BOOL BVar8;
	SurfaceMap *surfMap;
	uint uVar9;
	float10 fVar10;
	uint local_28;
	uint local_24;
	float local_20 [4];
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	liveObj = targetObj;
	OVar2 = in_liveObj->objType;
	if ((OVar2 != OBJECT_MINIFIGURE) && (OVar2 != OBJECT_ROCKMONSTER)) {
		return 0;
	}
	if (targetObj->objType != OBJECT_BUILDING) {
		return 0;
	}
	if ((OVar2 == OBJECT_ROCKMONSTER) &&
		 (OVar7 = LiveObject_GetStatsFlags2(in_liveObj), (OVar7 & STATS2_DRAINPOWER) == STATS2_NONE)) {
		bVar6 = true;
	}
	else {
		bVar6 = false;
	}
	LiveObject_GetBlockPos(liveObj,(int *)&local_28,(int *)&local_24);
	BVar8 = LiveObject_FUN_00446c80
										(in_liveObj,local_28,local_24,0,(uint *)&targetObj,
										 (uint)(in_liveObj->objType != OBJECT_ROCKMONSTER));
	if (BVar8 == 0) {
		return 0;
	}
	surfMap = GetSurfaceMap();
	fVar10 = Map3D_GetBlockSize(surfMap);
	local_c = (float)((float10)4.0 / fVar10);
	if (bVar6) {
		fVar10 = (float10)0.5;
	}
	else {
		fVar10 = math::Maths_RandRange(0.2,0.8);
	}
	local_20[0] = (float)fVar10;
	local_8 = local_c;
	uVar9 = (int)&targetObj[-1].pool_m_next + 2U & 3;
	local_20[1] = 1.0 - local_c;
	local_20[2] = 1.0 - local_c;
	uVar3 = in_liveObj->routingBlocksTotal;
	local_20[3] = (float)fVar10;
	local_10 = (float)fVar10;
	local_4 = (float)fVar10;
	pvVar4 = in_liveObj->routeptr_24;
	fVar5 = local_20[uVar9 * 2 + 1];
	*(float *)((int)pvVar4 + uVar3 * 0x14 + -0xc) = local_20[uVar9 * 2];
	*(float *)((int)pvVar4 + uVar3 * 0x14 + -8) = fVar5;
	*(undefined *)((int)in_liveObj->routeptr_24 + in_liveObj->routingBlocksTotal * 0x14 + -3) = 6;
	*(byte *)((int)in_liveObj->routeptr_24 + in_liveObj->routingBlocksTotal * 0x14 + -4) =
			 *(byte *)((int)in_liveObj->routeptr_24 + in_liveObj->routingBlocksTotal * 0x14 + -4) | 4;
	targetObj._0_1_ = (byte)uVar9;
	pbVar1 = (byte *)((int)in_liveObj->routeptr_24 + in_liveObj->routingBlocksTotal * 0x14 + -4);
	*pbVar1 = *pbVar1 | (byte)targetObj;
	if (param_3 != 0) {
		pbVar1 = (byte *)((int)in_liveObj->routeptr_24 + in_liveObj->routingBlocksTotal * 0x14 + -4);
		*pbVar1 = *pbVar1 | 0x20;
	}
	if (param_4 != 0) {
		in_liveObj->flags4 = in_liveObj->flags4 | 0x400000;
	}
	in_liveObj->object_2fc = liveObj;
	return 1;
}



BOOL __cdecl lego::game::LiveObject_TryReinforce_FUN_00449500(LiveObject *liveObj,Point2I *blockPos)
{
	BOOL BVar1;
	
	BVar1 = LiveObject_CheckLevel_FUN_00432950(liveObj,blockPos->x,blockPos->y);
	if (BVar1 != 0) {
		BVar1 = LiveObject_RoutingPointerBlocks_FUN_00449b40(liveObj,blockPos->x,blockPos->y,3.0);
		if (BVar1 != 0) {
			*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 2;
			(liveObj->point_2f4).x = (float)blockPos->x;
			(liveObj->point_2f4).y = (float)blockPos->y;
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_TryClear_FUN_00449570(LiveObject *in_liveObj,Point2I *in_blockPos)
{
	LiveObject *liveObj;
	Point2I *blockPos;
	int iVar1;
	ObjectStatsFlags1 OVar2;
	BOOL BVar3;
	uint local_c;
	int local_8;
	int local_4;
	
	blockPos = in_blockPos;
	iVar1 = Level_GetBlockRubbleLevel_OrFlag200000(in_blockPos);
	liveObj = in_liveObj;
	if (iVar1 != 0) {
		OVar2 = LiveObject_GetStatsFlags1(in_liveObj);
		if ((OVar2 & STATS1_CANCLEARRUBBLE) == STATS1_NONE) {
			return 1;
		}
		LiveObject_GetBlockPos(liveObj,&local_8,&local_4);
		if ((local_8 == blockPos->x) && (local_4 == blockPos->y)) {
			BVar3 = LiveObject_FUN_004419c0(liveObj,1,(float *)blockPos,(float *)&blockPos->y,NULL);
		}
		else {
			BVar3 = LiveObject_FUN_004413b0
												(liveObj,local_8,local_4,blockPos->x,blockPos->y,&in_blockPos,&in_liveObj,
												 &local_c,0,0);
			if (BVar3 == 0) {
				return 0;
			}
			BVar3 = LiveObject_FUN_004419c0(liveObj,local_c,(float *)in_blockPos,(float *)in_liveObj,NULL)
			;
			std::free(in_blockPos);
			std::free(in_liveObj);
		}
		if (BVar3 == 0) {
			return 0;
		}
		*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 4;
		if (liveObj->objType == OBJECT_VEHICLE) {
			Level_BlockSetter_FUN_00432640(blockPos,1);
			Level_BlockSetFlags1_10000000(blockPos,1);
			return TRUE;
		}
	}
	return TRUE;
}



BOOL __cdecl lego::game::LiveObject_MiniFigureHasBeamEquipped(LiveObject *liveObj)
{
	BOOL BVar1;
	
	if (liveObj->objType != OBJECT_MINIFIGURE) {
		return 0;
	}
	BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_LASER);
	if (((BVar1 == 0) && (BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_PUSHERGUN), BVar1 == 0)) &&
		 (BVar1 = LiveObject_HasToolEquipped(liveObj,TOOL_FREEZERGUN), BVar1 == 0)) {
		return 0;
	}
	return 1;
}



BOOL __cdecl
lego::game::LiveObject_TryAttackRockMonster_FUN_004496f0(LiveObject *liveObj,LiveObject *targetObj)
{
	LiveObject *pLVar1;
	BOOL BVar2;
	float *local_18;
	uint local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pLVar1 = targetObj;
	LiveObject_GetBlockPos(targetObj,(int *)&local_10,(int *)&local_c);
	LiveObject_GetBlockPos(liveObj,(int *)&local_8,(int *)&local_4);
	if ((local_8 == local_10) && (local_4 == local_c)) {
		BVar2 = LiveObject_FUN_004419c0(liveObj,1,&local_10,&local_c,NULL);
	}
	else {
		BVar2 = LiveObject_FUN_004413b0
											(liveObj,local_8,local_4,local_10,local_c,&targetObj,&local_18,&local_14,0,0);
		if (BVar2 == 0) {
			return 0;
		}
		BVar2 = LiveObject_FUN_004419c0(liveObj,local_14,(float *)targetObj,local_18,NULL);
		std::free(targetObj);
		std::free(local_18);
	}
	if (BVar2 != 0) {
		*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 0x11;
		liveObj->object_2fc = pLVar1;
	}
	return BVar2;
}



BOOL __cdecl
lego::game::LiveObject_TryAttackObject_FUN_004497e0(LiveObject *in_liveObj,LiveObject *targetObj)
{
	LiveObject *liveObj;
	BOOL BVar1;
	float *local_18;
	uint local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	liveObj = in_liveObj;
	LiveObject_GetBlockPos(in_liveObj,(int *)&local_8,(int *)&local_4);
	LiveObject_GetBlockPos(targetObj,(int *)&local_10,(int *)&local_c);
	if ((local_8 == local_10) && (local_4 == local_c)) {
		BVar1 = LiveObject_FUN_004419c0(liveObj,1,&local_10,&local_c,NULL);
	}
	else {
		BVar1 = LiveObject_FUN_004413b0
											(liveObj,local_8,local_4,local_10,local_c,&in_liveObj,&local_18,&local_14,0,0)
		;
		if (BVar1 == 0) {
			return 0;
		}
		BVar1 = LiveObject_FUN_004419c0(liveObj,local_14,(float *)in_liveObj,local_18,NULL);
		std::free(in_liveObj);
		std::free(local_18);
	}
	if (BVar1 != 0) {
		*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 0x14;
	}
	return BVar1;
}



BOOL __cdecl
lego::game::LiveObject_TryAttackPath_FUN_004498d0(LiveObject *liveObj,Point2I *blockPos)
{
	LiveObject *liveObj_00;
	BOOL BVar1;
	float *local_10;
	uint local_c;
	int local_8;
	int local_4;
	
	liveObj_00 = liveObj;
	LiveObject_GetBlockPos(liveObj,&local_8,&local_4);
	if ((local_8 == blockPos->x) && (local_4 == blockPos->y)) {
		BVar1 = LiveObject_FUN_004419c0(liveObj_00,1,(float *)blockPos,(float *)&blockPos->y,NULL);
	}
	else {
		BVar1 = LiveObject_FUN_004413b0
											(liveObj_00,local_8,local_4,blockPos->x,blockPos->y,&liveObj,&local_10,
											 &local_c,0,0);
		if (BVar1 == 0) {
			return 0;
		}
		BVar1 = LiveObject_FUN_004419c0(liveObj_00,local_c,(float *)liveObj,local_10,NULL);
		std::free(liveObj);
		std::free(local_10);
	}
	if (BVar1 != 0) {
		*(undefined *)((int)liveObj_00->routeptr_24 + liveObj_00->routingBlocksTotal * 0x14 + -3) = 0x10
		;
		(liveObj_00->point_2f4).x = (float)blockPos->x;
		(liveObj_00->point_2f4).y = (float)blockPos->y;
	}
	return BVar1;
}



BOOL __cdecl lego::game::LiveObject_TryDepart_FUN_004499c0(LiveObject *liveObj)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	BOOL BVar3;
	float *local_18;
	uint local_14;
	Point2I local_10;
	float local_8;
	float local_4;
	LiveObject *liveObj_00;
	
	liveObj_00 = liveObj;
	BVar3 = 0;
	OVar1 = LiveObject_GetStatsFlags2(liveObj);
	if ((OVar1 & STATS2_USEHOLES) == STATS2_NONE) {
		BVar2 = LiveObject_FUN_0044a890(liveObj_00,(int *)&local_10,&local_10.y,1,0,1);
		if ((BVar2 != 0) &&
			 (BVar2 = LiveObject_RoutingPointerBlocks_FUN_00449b40(liveObj_00,local_10.x,local_10.y,3.0),
			 BVar2 != 0)) {
			BVar3 = TRUE;
			*(undefined *)((int)liveObj_00->routeptr_24 + liveObj_00->routingBlocksTotal * 0x14 + -3) = 10
			;
			(liveObj_00->point_2f4).x = (float)local_10.x;
			(liveObj_00->point_2f4).y = (float)local_10.y;
		}
	}
	else {
		BVar2 = LiveObject_NearestSlugHole_FUN_0044a7b0(liveObj_00,&local_10);
		if (BVar2 != 0) {
			LiveObject_GetBlockPos(liveObj_00,(int *)&local_8,(int *)&local_4);
			if ((local_8 == (float)local_10.x) && (local_4 == (float)local_10.y)) {
				BVar3 = LiveObject_FUN_004419c0(liveObj_00,1,(float *)&local_10,(float *)&local_10.y,NULL);
			}
			else {
				BVar3 = LiveObject_FUN_004413b0
													(liveObj_00,local_8,local_4,local_10.x,local_10.y,&liveObj,&local_18,
													 &local_14,0,0);
				if (BVar3 == 0) {
					BVar3 = 0;
				}
				else {
					BVar3 = LiveObject_FUN_004419c0(liveObj_00,local_14,(float *)liveObj,local_18,NULL);
					std::free(liveObj);
					std::free(local_18);
				}
			}
			if (BVar3 == 0) {
				return 0;
			}
			*(undefined *)((int)liveObj_00->routeptr_24 + liveObj_00->routingBlocksTotal * 0x14 + -3) = 10
			;
			(liveObj_00->point_2f4).x = (float)local_10.x;
			(liveObj_00->point_2f4).y = (float)local_10.y;
		}
	}
	if (BVar3 != 0) {
		ai::AITask_LiveObject_DoCallbacks_FUN_004029d0(liveObj_00);
	}
	return BVar3;
}



BOOL __cdecl
lego::game::LiveObject_RoutingPointerBlocks_FUN_00449b40
					(LiveObject *liveObj,uint x,uint y,float param_4)
{
	byte *pbVar1;
	uint uVar2;
	BOOL BVar3;
	SurfaceMap *surfMap;
	float10 fVar4;
	
	uVar2 = y;
	BVar3 = Level_GetBlockFlags1_10Not8(x,y);
	if ((BVar3 != 0) && (BVar3 = LiveObject_FUN_00446c80(liveObj,x,uVar2,0,&y,1), BVar3 != 0)) {
		surfMap = GetSurfaceMap();
		fVar4 = Map3D_GetBlockSize(surfMap);
		fVar4 = (float10)param_4 / fVar4;
		*(undefined4 *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -8) =
				 0x3f000000;
		*(undefined4 *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -0xc) =
				 0x3f000000;
		switch(y) {
		case 0:
			*(float *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -8) = (float)fVar4
			;
			break;
		case 1:
			*(float *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -0xc) =
					 (float)fVar4;
			break;
		case 2:
			*(float *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -8) =
					 (float)((float10)1.0 - fVar4);
			break;
		case 3:
			*(float *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -0xc) =
					 (float)((float10)1.0 - fVar4);
		}
		pbVar1 = (byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4);
		*pbVar1 = *pbVar1 | 8;
		return 1;
	}
	return 0;
}



BOOL __cdecl FUN_00449c40(LiveObject *liveObj,undefined4 param_2,BOOL *out_bool)
{
	BOOL BVar1;
	longlong lVar2;
	longlong lVar3;
	Point2I local_8;
	
	*out_bool = FALSE;
	if ((*(byte *)&liveObj->flags1 & 0x40) == 0) {
		return 0;
	}
	lVar2 = __ftol((float10)(liveObj->point_2f4).x);
	local_8.x = (uint)lVar2;
	lVar3 = __ftol((float10)(liveObj->point_2f4).y);
	local_8.y = (int)lVar3;
	BVar1 = lego::game::LiveObject_CheckLevel_FUN_00432950(liveObj,(uint)lVar2,local_8.y);
	if (BVar1 == 0) {
		lego::game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_CANTDO,1);
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_REINFORCING | LIVEOBJ1_UNK_80000000;
	}
	else {
		if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 |
								(ushort)(liveObj->float_2d4 == 0.0) << 0xe) != 0) {
			return 1;
		}
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_REINFORCING;
		lego::game::LiveObject_SetActivityUnk(liveObj,ACTIVITY_STAND,0);
		lego::game::Level_Block_Reinforce(local_8.x,local_8.y);
		(liveObj->point_2f4).y = -1.0;
		(liveObj->point_2f4).x = -1.0;
		*out_bool = TRUE;
	}
	lego::game::Level_Block_SetFlags1_8000000(&local_8,FALSE);
	return TRUE;
}



void __cdecl lego::game::LiveObject_GoEat_unk(LiveObject *liveObj)
{
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_800;
	}
	if ((liveObj->flags1 & LIVEOBJ1_CARRYING) == LIVEOBJ1_NONE) {
		liveObj->flags1 = liveObj->flags1 | LIVEOBJ1_EATING;
		LiveObject_SetActivityUnk(liveObj,ACTIVITY_EAT,0);
		LiveObject_Container_ActivityUpdate_Check(liveObj);
		ai::AITask_DoAnimationWait(liveObj);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_TryGoEat_FUN_00449d80(LiveObject *liveObj1,LiveObject *liveObj2)
{
	byte *pbVar1;
	uint uVar2;
	void *pvVar3;
	LiveObject *liveObj;
	BOOL BVar4;
	SurfaceMap *surfMap;
	uint uVar5;
	float10 fVar6;
	uint local_28;
	uint local_24;
	float local_20 [4];
	undefined4 local_10;
	float local_c;
	float local_8;
	undefined4 local_4;
	
	liveObj = liveObj1;
	if ((liveObj1->objType == OBJECT_MINIFIGURE) && (liveObj2->objType == OBJECT_BUILDING)) {
		LiveObject_GetBlockPos(liveObj2,(int *)&local_28,(int *)&local_24);
		BVar4 = LiveObject_FUN_00446c80(liveObj,local_28,local_24,0,(uint *)&liveObj1,1);
		if (BVar4 != 0) {
			surfMap = GetSurfaceMap();
			fVar6 = Map3D_GetBlockSize(surfMap);
			fVar6 = (float10)4.0 / fVar6;
			local_20[0] = 0.5;
			local_20[3] = 0.5;
			local_10 = 0x3f000000;
			local_4 = 0x3f000000;
			uVar5 = (int)&liveObj1[-1].pool_m_next + 2U & 3;
			uVar2 = liveObj->routingBlocksTotal;
			pvVar3 = liveObj->routeptr_24;
			local_20[1] = (float)((float10)1.0 - fVar6);
			local_20[2] = (float)((float10)1.0 - fVar6);
			local_c = (float)fVar6;
			local_8 = (float)fVar6;
			*(float *)((int)pvVar3 + uVar2 * 0x14 + -0xc) = local_20[uVar5 * 2];
			*(float *)((int)pvVar3 + uVar2 * 0x14 + -8) = local_20[uVar5 * 2 + 1];
			*(undefined *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -3) = 0xb;
			*(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) =
					 *(byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4) | 4;
			liveObj1._0_1_ = (byte)uVar5;
			pbVar1 = (byte *)((int)liveObj->routeptr_24 + liveObj->routingBlocksTotal * 0x14 + -4);
			*pbVar1 = *pbVar1 | (byte)liveObj1;
			liveObj->object_2fc = liveObj2;
			return TRUE;
		}
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_800;
	}
	return 0;
}



BOOL __cdecl FUN_00449ec0(void)
{
	BOOL BVar1;
	
	BVar1 = lego::game::Search_LiveObjects(lego::game::LiveObject_Callback_FUN_00449fb0,NULL,FALSE);
	return BVar1;
}



void __cdecl
lego::game::Flocks_CallbackFUN_00449ee0(FlockData *flockData,FlockSubdata *subdata,void *lpContext)
{
	Container *cont;
	SurfaceMap *surfMap;
	LevelData *pLVar1;
	BOOL BVar2;
	FlockSubdata **out_bx;
	uint *puVar3;
	uint local_10;
	Vector3F local_c;
	
	cont = subdata->resData_98;
	res::Container_GetPosition(cont,NULL,&local_c);
	puVar3 = &local_10;
	out_bx = &subdata;
	surfMap = GetSurfaceMap();
	Map3D_WorldToBlockPos_NoZ(surfMap,local_c.x,local_c.y,(int *)out_bx,(int *)puVar3);
	pLVar1 = GetLevel();
	if (subdata <= (FlockSubdata *)(pLVar1->dimensions).width) {
		pLVar1 = GetLevel();
		puVar3 = (uint *)&(pLVar1->dimensions).height;
		if (local_10 < *puVar3 || local_10 == *puVar3) {
			BVar2 = Level_Block_FUN_00433d60((int)subdata,local_10);
			if (BVar2 == 0) {
				BVar2 = Level_BlockIsNotFlags1_18((uint)subdata,local_10);
				if (BVar2 == 0) {
					res::Container_Hide(cont,0);
					return;
				}
			}
		}
	}
	res::Container_Hide(cont,1);
	return;
}



void __cdecl lego::game::LiveObject_Hide2(LiveObject *liveObj,BOOL hide2)
{
	Container *cont;
	
	cont = LiveObject_GetContainer(liveObj);
	if (cont != NULL) {
		res::Container_Hide2(cont,hide2);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_Callback_FUN_00449fb0(LiveObject *liveObj,void *unused)
{
	bool bVar1;
	ObjectStatsFlags1 OVar2;
	BOOL BVar3;
	ObjectStatsFlags2 OVar4;
	Point2I *pPVar5;
	Point2I *pPVar6;
	uint uVar7;
	Point2I *pPVar8;
	Direction rotation;
	uint uVar9;
	uint y;
	uint x;
	uint local_20;
	BOOL local_1c;
	Point2F local_18;
	Point2I local_10;
	float local_8;
	float local_4;
	
	uVar9 = 0;
	local_1c = 0;
	OVar2 = LiveObject_GetStatsFlags1(liveObj);
	if ((OVar2 & STATS1_FLOCKS) != STATS1_NONE) {
		Flocks_CallbackForAllSubdata(liveObj->flocksData_32c,Flocks_CallbackFUN_00449ee0,NULL);
		return 0;
	}
	BVar3 = LiveObject_GetBlockPos(liveObj,(int *)&x,(int *)&y);
	if (BVar3 == 0) {
		LiveObject_HideAll(liveObj,TRUE);
		return 0;
	}
	BVar3 = Level_BlockIsFlags1_8(x,y);
	if (BVar3 != 0) {
		liveObj->flags3 = liveObj->flags3 & ~LIVEOBJ3_UNK_100000;
	}
	BVar3 = Level_BlockIsNotFlags1_18(x,y);
	if (((BVar3 == 0) && ((liveObj->flags3 & LIVEOBJ3_UNK_100000) == LIVEOBJ3_NONE)) &&
		 ((liveObj->objType != OBJECT_MINIFIGURE ||
			((liveObj->drivenObject == NULL ||
			 (OVar4 = LiveObject_GetStatsFlags2(liveObj->drivenObject),
			 (OVar4 & STATS2_INVISIBLEDRIVER) == STATS2_NONE)))))) {
		BVar3 = 0;
	}
	else {
		BVar3 = 1;
	}
	LiveObject_HideAll(liveObj,BVar3);
	BVar3 = Level_Block_FUN_00433d60(x,y);
	if (((BVar3 != 0) || (BVar3 = Level_BlockIsNotFlags1_18(x,y), BVar3 != 0)) ||
		 ((liveObj->flags3 & LIVEOBJ3_UNK_100000) != LIVEOBJ3_NONE)) {
		rotation = DIRECTION_RIGHT;
		local_1c = 1;
		if (liveObj->objType == OBJECT_BUILDING) {
			LiveObject_GetFaceDirection(liveObj,&local_18);
			LiveObject_GetBlockPos(liveObj,(int *)&local_10,&local_10.y);
			LiveObject_GetPosition(liveObj,&local_8,&local_4);
			if (ABS(local_18.x) <= ABS(local_18.y)) {
				if ((ushort)((ushort)(local_18.y < 0.0) << 8 | (ushort)(local_18.y == 0.0) << 0xe) == 0) {
					rotation = DIRECTION_UP;
				}
				else {
					rotation = DIRECTION_DOWN;
				}
			}
			else {
				if ((ushort)((ushort)(local_18.x < 0.0) << 8 | (ushort)(local_18.x == 0.0) << 0xe) != 0) {
					rotation = DIRECTION_LEFT;
				}
			}
			pPVar5 = res::Building_GetShapePoints
												 (globs::gameGlobs.BuildingData_TABLE + liveObj->objIndex,&local_20);
			pPVar6 = Game_TransformShapePoints(&local_10,pPVar5,local_20,rotation);
			uVar7 = local_20;
			pPVar5 = pPVar6;
			if (local_20 != 0) {
				do {
					pPVar8 = pPVar5 + 1;
					if (((uVar9 == uVar7 - 1) || (pPVar6->x != pPVar8->x)) || (pPVar6->y != pPVar5[1].y)) {
						bVar1 = false;
						BVar3 = Level_Block_FUN_00433d60(pPVar6->x,pPVar6->y);
						uVar7 = local_20;
						if (BVar3 == 0) {
							local_1c = 0;
							break;
						}
					}
					else {
						bVar1 = true;
					}
					if (bVar1) {
						uVar9 += 1;
						pPVar8 = pPVar5 + 2;
						pPVar6 = pPVar6 + 1;
					}
					uVar9 += 1;
					pPVar6 = pPVar6 + 1;
					pPVar5 = pPVar8;
				} while (uVar9 < uVar7);
			}
		}
	}
	LiveObject_Hide2(liveObj,local_1c);
	return 0;
}



void __cdecl lego::game::LiveObject_HideAll(LiveObject *liveObj,BOOL hide)
{
	ObjectType OVar1;
	
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		res::Vehicle_HideAll(liveObj->vehicle,hide);
		return;
	}
	if (OVar1 == OBJECT_MINIFIGURE) {
		res::Object_HideAll((BasicObjectData *)liveObj->miniFigure,hide);
		return;
	}
	if (OVar1 == OBJECT_ROCKMONSTER) {
		res::Object_HideAll((BasicObjectData *)liveObj->rockMonster,hide);
		return;
	}
	if (OVar1 == OBJECT_BUILDING) {
		res::Building_HideAll(liveObj->building,hide);
		return;
	}
	if (OVar1 == OBJECT_UPGRADEPART) {
		res::Object_HideAll((BasicObjectData *)liveObj->upgrade,hide);
		return;
	}
	if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
		res::Container_Hide(liveObj->other,hide);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_IsHidden(LiveObject *liveObj)
{
	ObjectType OVar1;
	
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		OVar1 = res::Vehicle_GetFlag2(liveObj->vehicle);
		return OVar1;
	}
	if (OVar1 == OBJECT_MINIFIGURE) {
		OVar1 = res::Object_IsHidden((BasicObjectData *)liveObj->miniFigure);
		return OVar1;
	}
	if (OVar1 == OBJECT_ROCKMONSTER) {
		OVar1 = res::Object_IsHidden((BasicObjectData *)liveObj->rockMonster);
		return OVar1;
	}
	if (OVar1 == OBJECT_BUILDING) {
		OVar1 = res::Object_IsHidden((BasicObjectData *)liveObj->building);
		return OVar1;
	}
	if (OVar1 == OBJECT_UPGRADEPART) {
		OVar1 = res::Object_IsHidden((BasicObjectData *)liveObj->upgrade);
		return OVar1;
	}
	if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) != LIVEOBJ3_NONE) {
		OVar1 = res::Container_IsHidden(liveObj->other);
	}
	return OVar1;
}



void __cdecl
lego::game::LiveObject_UnkCameraFunc
					(LiveObject *liveObj,int param_2,Vector3F *param_3,Vector3F *param_4)
{
	ObjectType OVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	Container *pCVar5;
	LiveObject *pLVar6;
	Vector3F local_c;
	
	if ((liveObj->resData_2dc != NULL) && (liveObj->index_2e0 == param_2)) goto LAB_0044a3a2;
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		pCVar5 = res::Vehicle_GetCameraNull(liveObj->vehicle,param_2);
LAB_0044a371:
		liveObj->resData_2dc = pCVar5;
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			pCVar5 = res::Creature_GetCameraNull(liveObj->miniFigure,param_2);
			goto LAB_0044a371;
		}
		if (OVar1 != OBJECT_ROCKMONSTER) goto LAB_0044a3a2;
		pCVar5 = res::Creature_GetCameraNull(liveObj->rockMonster,param_2);
		liveObj->resData_2dc = pCVar5;
	}
	if (pCVar5 != NULL) {
		liveObj->index_2e0 = param_2;
	}
LAB_0044a3a2:
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		pLVar6 = (LiveObject *)res::Vehicle_IsCameraFlipDir(liveObj->vehicle);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			pLVar6 = (LiveObject *)res::Creature_IsCameraFlipDir(liveObj->miniFigure);
		}
		else {
			pLVar6 = liveObj;
			if (OVar1 == OBJECT_ROCKMONSTER) {
				pLVar6 = (LiveObject *)res::Creature_IsCameraFlipDir(liveObj->rockMonster);
			}
		}
	}
	if (liveObj->resData_2dc != NULL) {
		res::Container_GetPosition(liveObj->resData_2dc,NULL,param_3);
		res::Container_GetOrientation(liveObj->resData_2dc,NULL,param_4,&local_c);
		fVar2 = 1.0 / SQRT(param_4->x * param_4->x + param_4->z * param_4->z + param_4->y * param_4->y);
		fVar4 = fVar2 * param_4->x;
		fVar3 = fVar2 * param_4->y;
		fVar2 = fVar2 * param_4->z;
		param_4->x = fVar4;
		param_4->y = fVar3;
		param_4->z = fVar2;
		if (pLVar6 != NULL) {
			param_4->x = fVar4 * -1.0;
			param_4->y = fVar3 * -1.0;
			param_4->z = fVar2 * -1.0;
			return;
		}
	}
	return;
}



Container * __cdecl lego::game::LiveObject_GetContainer(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	
	if (true) {
		switch(liveObj->objType) {
		case OBJECT_VEHICLE:
			pLVar1 = (LiveObject *)res::Vehicle_GetAEResource(liveObj->vehicle);
			return (Container *)pLVar1;
		case OBJECT_MINIFIGURE:
			pLVar1 = (LiveObject *)
							 res::Object_GetActivityContainer((BasicObjectData *)liveObj->miniFigure);
			return (Container *)pLVar1;
		case OBJECT_ROCKMONSTER:
			pLVar1 = (LiveObject *)
							 res::Object_GetActivityContainer((BasicObjectData *)liveObj->rockMonster);
			return (Container *)pLVar1;
		case OBJECT_BUILDING:
			pLVar1 = (LiveObject *)res::Object_GetActivityContainer((BasicObjectData *)liveObj->building);
			return (Container *)pLVar1;
		case OBJECT_UPGRADEPART:
			pLVar1 = (LiveObject *)res::Object_GetActivityContainer((BasicObjectData *)liveObj->upgrade);
			return (Container *)pLVar1;
		}
	}
	if ((liveObj->flags3 & LIVEOBJ3_SIMPLEOBJECT) == LIVEOBJ3_NONE) {
		return (Container *)liveObj;
	}
	return (Container *)(LiveObject *)liveObj->other;
}



BOOL __cdecl
lego::game::LiveObject_GetDrillNullPosition(LiveObject *liveObj,float *out_x,float *out_y)
{
	ObjectType OVar1;
	Container *cont;
	CreatureData *creature;
	Vector3F vector;
	
	OVar1 = liveObj->objType;
	if (OVar1 == OBJECT_VEHICLE) {
		cont = res::Vehicle_GetDrillNull(liveObj->vehicle);
	}
	else {
		if (OVar1 == OBJECT_MINIFIGURE) {
			creature = liveObj->miniFigure;
		}
		else {
			if (OVar1 != OBJECT_ROCKMONSTER) {
				return 0;
			}
			creature = liveObj->rockMonster;
		}
		cont = res::Creature_GetDrillNull(creature);
	}
	if (cont == NULL) {
		return 0;
	}
	res::Container_GetPosition(cont,NULL,&vector);
	*out_x = vector.x;
	*out_y = vector.y;
	return 1;
}



void __cdecl lego::game::LiveObject_FPMove(LiveObject *liveObj,int forward,int strafe,float rotate)
{
	ObjectStatsFlags3 OVar1;
	
	if ((liveObj->objType == OBJECT_MINIFIGURE) && (liveObj->drivenObject != NULL)) {
		liveObj = liveObj->drivenObject;
	}
	if ((*(byte *)&liveObj->flags1 & LIVEOBJ1_MOVING) != 0) {
		LiveObject_UnkDoRouting_FUN_00441c00(liveObj,FALSE);
	}
	OVar1 = LiveObject_GetStatsFlags3(liveObj);
	if ((OVar1 & STATS3_CANSTRAFE) == STATS3_NONE) {
		strafe = 0;
	}
	liveObj->strafeSpeed_2bc = liveObj->strafeSpeed_2bc + strafe;
	liveObj->forwardSpeed_2c0 = liveObj->forwardSpeed_2c0 + forward;
	liveObj->rotateSpeed_2c4 = rotate + liveObj->rotateSpeed_2c4;
	return;
}



void __cdecl lego::game::Level_RegisterRechargeSeam(Point2I *blockPos)
{
	if (globs::liveGlobs.RechargeSeams_COUNT < 10) {
		globs::liveGlobs.RechargeSeams_TABLE[globs::liveGlobs.RechargeSeams_COUNT].x = blockPos->x;
		globs::liveGlobs.RechargeSeams_TABLE[globs::liveGlobs.RechargeSeams_COUNT].y = blockPos->y;
		globs::liveGlobs.RechargeSeams_COUNT += 1;
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_FindRechargeSeam_FUN_0044a690(LiveObject *liveObj,Point2I *out_seamBlockPos)
{
	float fVar1;
	SurfaceMap *surfMap;
	uint uVar2;
	uint uVar3;
	Point2I *pPVar4;
	uint bx;
	uint by;
	float *out_x;
	float *out_y;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	uVar2 = 0xffffffff;
	local_14 = 10000.0;
	LiveObject_GetPosition(liveObj,&local_10,&local_c);
	uVar3 = 0;
	if (globs::liveGlobs.RechargeSeams_COUNT != 0) {
		pPVar4 = globs::liveGlobs.RechargeSeams_TABLE;
		do {
			by = pPVar4->y;
			bx = pPVar4->x;
			out_y = &local_4;
			out_x = &local_8;
			surfMap = GetSurfaceMap();
			Map3D_BlockToWorldPos(surfMap,bx,by,out_x,out_y);
			fVar1 = SQRT((local_c - local_4) * (local_c - local_4) +
									 (local_10 - local_8) * (local_10 - local_8));
			if (fVar1 < local_14) {
				uVar2 = uVar3;
				local_14 = fVar1;
			}
			uVar3 += 1;
			pPVar4 = pPVar4 + 1;
		} while (uVar3 < globs::liveGlobs.RechargeSeams_COUNT);
	}
	if (uVar2 == 0xffffffff) {
		return 0;
	}
	if (out_seamBlockPos != NULL) {
		out_seamBlockPos->x = globs::liveGlobs.RechargeSeams_TABLE[uVar2].x;
		out_seamBlockPos->y = globs::liveGlobs.RechargeSeams_TABLE[uVar2].y;
	}
	return 1;
}



void __cdecl lego::game::Level_RegisterSlimySlugHole(Point2I *position)
{
	if (globs::liveGlobs.SlugHoles_COUNT < 20) {
		globs::liveGlobs.SlugHoles_TABLE[globs::liveGlobs.SlugHoles_COUNT].x = position->x;
		globs::liveGlobs.SlugHoles_TABLE[globs::liveGlobs.SlugHoles_COUNT].y = position->y;
		globs::liveGlobs.SlugHoles_COUNT += 1;
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_NearestSlugHole_FUN_0044a7b0(LiveObject *liveObj,Point2I *out_blockPos)
{
	float fVar1;
	SurfaceMap *surfMap;
	uint uVar2;
	uint uVar3;
	Point2I *pPVar4;
	uint bx;
	uint by;
	float *out_x;
	float *out_y;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	uVar2 = 0xffffffff;
	local_14 = 10000.0;
	LiveObject_GetPosition(liveObj,&local_10,&local_c);
	uVar3 = 0;
	if (globs::liveGlobs.SlugHoles_COUNT != 0) {
		pPVar4 = globs::liveGlobs.SlugHoles_TABLE;
		do {
			by = pPVar4->y;
			bx = pPVar4->x;
			out_y = &local_4;
			out_x = &local_8;
			surfMap = GetSurfaceMap();
			Map3D_BlockToWorldPos(surfMap,bx,by,out_x,out_y);
			fVar1 = SQRT((local_c - local_4) * (local_c - local_4) +
									 (local_10 - local_8) * (local_10 - local_8));
			if (fVar1 < local_14) {
				uVar2 = uVar3;
				local_14 = fVar1;
			}
			uVar3 += 1;
			pPVar4 = pPVar4 + 1;
		} while (uVar3 < globs::liveGlobs.SlugHoles_COUNT);
	}
	if (uVar2 == 0xffffffff) {
		return 0;
	}
	if (out_blockPos != NULL) {
		out_blockPos->x = globs::liveGlobs.SlugHoles_TABLE[uVar2].x;
		out_blockPos->y = globs::liveGlobs.SlugHoles_TABLE[uVar2].y;
	}
	return 1;
}



BOOL __cdecl
lego::game::LiveObject_FUN_0044a890
					(LiveObject *liveObj,int *param_2,int *param_3,BOOL param_4,BOOL param_5,BOOL param_6)
{
	float fVar1;
	BOOL BVar2;
	int iVar3;
	int iVar4;
	float *pfVar5;
	float *pfVar6;
	uint number;
	uint bx;
	uint by;
	longlong lVar7;
	int local_4cc;
	int local_4c8;
	SurfaceMap *local_4c4;
	float local_4c0;
	float local_4bc;
	float local_4b8;
	float local_4b4;
	float local_4b0;
	float local_4ac [299];
	
	local_4c4 = GetSurfaceMap();
	number = 0;
	LiveObject_GetPosition(liveObj,&local_4b8,&local_4b4);
	LiveObject_GetBlockPos(liveObj,&local_4cc,&local_4c8);
	by = local_4c8 - 10;
	iVar3 = local_4cc;
	iVar4 = local_4c8;
	if ((int)by < local_4c8 + 10) {
		do {
			bx = iVar3 - 10;
			if ((int)bx < iVar3 + 10) {
				pfVar5 = local_4ac + number * 3;
				do {
					BVar2 = Level_GetBlockFlags1_10Not8(bx,by);
					pfVar6 = pfVar5;
					if (((BVar2 != 0) &&
							((param_6 != 0 || (BVar2 = Level_Block_IsReinforced(bx,by), BVar2 == 0)))) &&
						 ((param_5 != 0 || (BVar2 = Level_Block_IsFlags1_c0(bx,by), BVar2 == 0)))) {
						Map3D_BlockToWorldPos(local_4c4,bx,by,&local_4c0,&local_4bc);
						fVar1 = SQRT((local_4bc - local_4b4) * (local_4bc - local_4b4) +
												 (local_4c0 - local_4b8) * (local_4c0 - local_4b8));
						if (((param_4 == 0) || (local_4c4->BlockSize <= fVar1)) && (number < 100)) {
							number += 1;
							pfVar6 = pfVar5 + 3;
							pfVar5[-1] = (float)bx;
							*pfVar5 = (float)by;
							pfVar5[1] = fVar1;
						}
					}
					bx += 1;
					iVar3 = local_4cc;
					iVar4 = local_4c8;
					pfVar5 = pfVar6;
				} while ((int)bx < local_4cc + 10);
			}
			by += 1;
		} while ((int)by < iVar4 + 10);
	}
	if (number == 0) {
		return 0;
	}
	std::qsort(&local_4b0,number,0xc,FUN_0044aa60);
	lVar7 = __ftol((float10)local_4b0);
	*param_2 = (int)lVar7;
	lVar7 = __ftol((float10)local_4ac[0]);
	*param_3 = (int)lVar7;
	return 1;
}



BOOL __cdecl FUN_0044aa60(int param_1,int param_2)
{
	if ((ushort)((ushort)(*(float *)(param_1 + 8) < *(float *)(param_2 + 8)) << 8 |
							(ushort)(*(float *)(param_1 + 8) == *(float *)(param_2 + 8)) << 0xe) == 0) {
		return 1;
	}
	if (*(float *)(param_1 + 8) < *(float *)(param_2 + 8)) {
		return -1;
	}
	return 0;
}



PolyMeshData * __cdecl
lego::res::Res_LoadPolyMesh
					(CFGProperty *aeRoot,char *rootName,char *dirname,PolyMode polyMode,uint numCameraFrames)
{
	char *pcVar1;
	CFGProperty *prop;
	int iVar2;
	PolyMeshData *lastPolyData;
	uint index;
	PolyMeshData *local_104;
	char local_100 [256];
	
	index = 0;
	lastPolyData = NULL;
	local_104 = NULL;
	if (polyMode != POLY_FP) {
		numCameraFrames = 1;
	}
	if (numCameraFrames != 0) {
		do {
			if (polyMode == POLY_FP) {
				std::sprintf(local_100,"FPPoly::Camera%i",index + 1);
			}
			else {
				if (polyMode == POLY_HIGH) {
					pcVar1 = "HighPoly";
				}
				else {
					if (polyMode != POLY_MEDIUM) goto LAB_0044ab0b;
					pcVar1 = "MediumPoly";
				}
				std::sprintf(local_100,pcVar1);
			}
LAB_0044ab0b:
			pcVar1 = cfg::CFG_JoinPath(rootName,local_100,0);
			for (prop = cfg::CFG_GetChildren(aeRoot,pcVar1); prop != NULL; prop = cfg::CFG_NextFlat(prop))
			{
				pcVar1 = prop->key;
				if (*pcVar1 == '!') {
					if ((globs::mainGlobs.flags & CMD_REDUCEPROMESHES) == CMD_NONE) {
						if (true) {
							pcVar1 = pcVar1 + 1;
						}
						goto LAB_0044ab53;
					}
				}
				else {
LAB_0044ab53:
					iVar2 = std::_stricmp("NULL",prop->value);
					if (iVar2 == 0) {
						lastPolyData = MeshPoly_CreateNullPolyMesh(lastPolyData,pcVar1,index);
					}
					else {
						lastPolyData = MeshPoly_CreatePolyMesh(lastPolyData,pcVar1,dirname,prop->value,index);
					}
					if (local_104 == NULL) {
						local_104 = lastPolyData;
					}
				}
			}
			index += 1;
		} while (index < numCameraFrames);
	}
	return local_104;
}



BOOL __cdecl
lego::game::Game_UnkBuildingPlaceDirection
					(ObjectType objType,int objIndex,BOOL param_3,BOOL param_4,Point2F *param_5,uint x,uint y,
					BOOL param_8,Container **pResData)
{
	float fVar1;
	float fVar2;
	BOOL BVar3;
	Point2I *pPVar4;
	int iVar5;
	SurfaceMap *surfMap;
	Point2I *pPVar6;
	undefined4 uVar7;
	LiveObject *pLVar8;
	ObjectStatsFlags1 OVar9;
	uint count;
	uint uVar10;
	Point2F *out_x;
	float *out_y;
	Point2I local_10;
	Point2F local_8;
	
	uVar10 = x;
	local_10.x = x;
	local_10.y = y;
	if (objType == OBJECT_BUILDING) {
		if (param_8 != 0) {
			BVar3 = Level_BlockIsFlags1_8(x,y);
			if (BVar3 == 0) {
				if ((param_4 == 0) &&
					 (front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_CANNOTBUILD), param_3 != 0)) {
					snd::Audio_FUN_00428730(1);
				}
				res::ResLp_Hide(pResData,1);
			}
			else {
				pPVar4 = res::Building_GetShapePoints(globs::gameGlobs.BuildingData_TABLE + objIndex,&x);
				iVar5 = Object_GetWaterEntrances(OBJECT_BUILDING,objIndex,0);
				res::ResLp_Hide(pResData,0);
				out_y = &local_8.y;
				out_x = &local_8;
				surfMap = GetSurfaceMap();
				Map3D_BlockToWorldPos(surfMap,uVar10,y,(float *)out_x,out_y);
				fVar1 = param_5->x - local_8.x;
				fVar2 = param_5->y - local_8.y;
				if (((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) != 0) ||
					 (fVar1 <= ABS(fVar2))) {
					if ((0.0 <= fVar1) ||
						 ((ushort)((ushort)(ABS(fVar1) < ABS(fVar2)) << 8 |
											(ushort)(ABS(fVar1) == ABS(fVar2)) << 0xe) != 0)) {
						if (((ushort)((ushort)(fVar2 < 0.0) << 8 | (ushort)(fVar2 == 0.0) << 0xe) != 0) ||
							 (fVar2 <= ABS(fVar1))) {
							if ((fVar2 < 0.0) &&
								 ((ushort)((ushort)(ABS(fVar2) < ABS(fVar1)) << 8 |
													(ushort)(ABS(fVar2) == ABS(fVar1)) << 0xe) == 0)) {
								globs::gameGlobs.placeObjDirection = DIRECTION_DOWN;
							}
						}
						else {
							globs::gameGlobs.placeObjDirection = DIRECTION_UP;
						}
					}
					else {
						globs::gameGlobs.placeObjDirection = DIRECTION_LEFT;
					}
				}
				else {
					globs::gameGlobs.placeObjDirection = DIRECTION_RIGHT;
				}
				uVar10 = 0;
				do {
					pPVar6 = (Point2I *)
									 res::ResLp_UnkSurfaceMap_FUN_00464480
														 (pResData,(int *)&local_10,(int)pPVar4,x,
															uVar10 + globs::gameGlobs.placeObjDirection & DIRECTION_LEFT,
															(globs::gameGlobs.level)->surfaceMap,iVar5);
					if (pPVar6 != NULL) {
						if ((param_4 == 0) &&
							 (front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_CANBUILD), param_3 != 0)) {
							uVar7 = Construction_FUN_004096c0
																(objIndex,&local_10,
																 uVar10 + globs::gameGlobs.placeObjDirection & DIRECTION_LEFT,pPVar6
																 ,x);
							pLVar8 = LiveObject_FUN_00438da0(NULL,&local_10,OBJECT_ORE,0);
							uVar10 = Object_GetCostRefinedOre(OBJECT_BUILDING,objIndex,0);
							OVar9 = Object_GetStatsFlags1(OBJECT_BUILDING,objIndex);
							if ((OVar9 & STATS1_STOREOBJECTS) == STATS1_NONE) {
								Construction_FUN_00408df0(&local_10,(uint *)pPVar6,x);
							}
							count = Object_GetCostCrystal(OBJECT_BUILDING,objIndex,0);
							Construction_SpawnCarryableObject(&local_10,OBJECT_POWERCRYSTAL,0,0,count);
							if ((pLVar8 == NULL) || (uVar10 == 0)) {
								uVar10 = Object_GetCostOre(OBJECT_BUILDING,objIndex,0);
								iVar5 = 0;
							}
							else {
								iVar5 = 1;
							}
							Construction_SpawnCarryableObject(&local_10,OBJECT_ORE,iVar5,0,uVar10);
							Construction_FUN_00408c10(uVar7,NULL);
							res::ResLp_Hide(pResData,TRUE);
							front::Interface_BackToMain();
							snd::Audio_FUN_00428730(0);
							return 0;
						}
						globs::gameGlobs.placeObjDirection =
								 uVar10 + globs::gameGlobs.placeObjDirection & DIRECTION_LEFT;
						break;
					}
					uVar10 += 1;
				} while (uVar10 < 5);
				if (uVar10 != 5) {
					return 1;
				}
				if ((param_4 == 0) &&
					 (front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_CANNOTBUILD), param_3 != 0)) {
					snd::Audio_FUN_00428730(1);
					front::Text_DisplayMessage(TEXT_CANNOTPLACEBUILDING,0,0);
					return 1;
				}
			}
			front::Text_DisplayMessage(TEXT_CANNOTPLACEBUILDING,0,0);
			return 1;
		}
		res::ResLp_Hide(pResData,1);
	}
	return 1;
}



void __cdecl lego::main::Main_LoadObjTtSFXs(CFGProperty *root,char *keyBasePath)
{
	char *keyPath;
	CFGProperty *prop;
	BOOL BVar1;
	int iVar2;
	int (*paiVar3) [15];
	ObjectType local_8;
	int local_4;
	
	paiVar3 = globs::liveGlobs.ObjTtSFX_TABLE;
	for (iVar2 = 300; iVar2 != 0; iVar2 += -1) {
		(*paiVar3)[0] = 0;
		paiVar3 = (int (*) [15])(*paiVar3 + 1);
	}
	iVar2 = 0x14;
	local_8 = 0x14;
	do {
		iVar2 += -1;
		local_4 = 0xf;
	} while (iVar2 != 0);
	keyPath = cfg::CFG_JoinPath(keyBasePath,"ObjTtSFXs",0);
	for (prop = cfg::CFG_GetChildren(root,keyPath); prop != NULL; prop = cfg::CFG_NextFlat(prop)) {
		BVar1 = game::Object_GetObjectByName(prop->key,&local_8,&local_4,NULL);
		if ((BVar1 != 0) && (BVar1 = snd::SFX_GetType(prop->value,(SFXType *)&keyBasePath), BVar1 != 0))
		{
			globs::liveGlobs.ObjTtSFX_TABLE[local_8][local_4] = (int)keyBasePath;
		}
	}
	return;
}



int __cdecl lego::game::LiveObject_GetObjTtSFX(LiveObject *liveObj)
{
	int local_4;
	
	LiveObject_GetTypeIndex(liveObj,(int *)&liveObj,&local_4);
	return *(int *)(local_4 * 4 + 0x4df814 + (int)liveObj * 0x3c);
}



void __cdecl lego::game::LiveManager_SetFlag20(BOOL state)
{
	if (state != 0) {
		globs::liveGlobs.flags = globs::liveGlobs.flags | LIVEMANAGER_UNK_20;
		return;
	}
	globs::liveGlobs.flags = globs::liveGlobs.flags & ~LIVEMANAGER_UNK_20;
	return;
}



void __cdecl lego::game::LiveObject_FUN_0044b0a0(LiveObject *liveObj)
{
	LiveObject *pLVar1;
	int crystalCount;
	uint uVar2;
	LiveObject *in_liveObj;
	
	pLVar1 = NULL;
	if (((((byte)globs::liveGlobs.flags & LIVEMANAGER_UNK_20) == 0) &&
			(liveObj->objType == OBJECT_VEHICLE)) &&
		 ((liveObj->flags4 & LIVEOBJ4_UNK_800) == LIVEOBJ4_NONE)) {
		if ((liveObj->flags4 & LIVEOBJ4_UNK_40) != LIVEOBJ4_NONE) {
			pLVar1 = liveObj->object_2fc;
		}
		in_liveObj = pLVar1;
		if (pLVar1 == NULL) {
			in_liveObj = liveObj;
		}
		uVar2 = (uint)(pLVar1 != NULL);
		crystalCount = Object_GetCostCrystal(OBJECT_VEHICLE,liveObj->objIndex,0);
		LiveObject_SpawnDropCrystals_FUN_0044b110(in_liveObj,crystalCount,uVar2);
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_800;
	}
	return;
}



void __cdecl
lego::game::LiveObject_SpawnDropCrystals_FUN_0044b110
					(LiveObject *in_liveObj,int crystalCount,BOOL param_3)
{
	Container *cont;
	SurfaceMap *surfMap;
	BOOL BVar1;
	LiveObject *liveObj;
	float10 fVar2;
	float in_x;
	float in_y;
	uint *out_bx;
	uint *out_by;
	float local_24;
	float local_20;
	float local_1c;
	float local_18;
	uint local_14;
	uint local_10;
	Vector3F local_c;
	
	if (crystalCount != 0) {
		do {
			if (((param_3 == 0) || (in_liveObj->objType != OBJECT_BUILDING)) ||
				 (cont = res::Building_GetEntranceNull(in_liveObj->building), cont == NULL)) {
				LiveObject_GetPosition(in_liveObj,&local_24,&local_20);
			}
			else {
				res::Container_GetPosition(cont,NULL,&local_c);
				local_24 = local_c.x;
				local_20 = local_c.y;
			}
			fVar2 = math::Maths_RandRange(-5.0,5.0);
			local_1c = (float)fVar2;
			fVar2 = math::Maths_RandRange(-5.0,5.0);
			local_18 = (float)fVar2;
			in_y = local_18 + local_20;
			out_by = &local_10;
			out_bx = &local_14;
			in_x = local_1c + local_24;
			surfMap = GetSurfaceMap();
			BVar1 = Map3D_WorldToBlockPos_NoZ(surfMap,in_x,in_y,(int *)out_bx,(int *)out_by);
			if ((BVar1 != 0) && (BVar1 = Level_BlockIsFlags1_8(local_14,local_10), BVar1 != 0)) {
				local_24 = local_1c + local_24;
				local_20 = local_18 + local_20;
			}
			liveObj = Game_CreateLiveResourceObject
													(globs::gameGlobs.RES_Crystal,OBJECT_POWERCRYSTAL,0,0,local_24,local_20,
													 0.0);
			ai::AITask_DoCollect(liveObj,0.0);
			crystalCount += -1;
		} while (crystalCount != 0);
	}
	return;
}



void __cdecl lego::game::LiveObject_CallsSpawnDropCrystals_FUN_0044b250(LiveObject *liveObj)
{
	if (liveObj->tableptr_348 != NULL) {
		LiveObject_SpawnDropCrystals_FUN_0044b110(liveObj,*liveObj->tableptr_348,0);
	}
	return;
}



void __cdecl lego::game::LiveObject_GenerateTinyRMs_FUN_0044b270(LiveObject *in_liveObj)
{
	short sVar1;
	BOOL BVar2;
	LiveObject *liveObj;
	bool bVar3;
	char *objName;
	uint uVar4;
	int out_objIndex;
	ObjectType out_objType;
	Container *local_c;
	float local_8;
	float local_4;
	
	bVar3 = false;
	BVar2 = Object_GetObjectByName("RockMonster",&out_objType,&out_objIndex,NULL);
	objName = (char *)in_liveObj;
	if (((BVar2 != 0) && (out_objType == in_liveObj->objType)) &&
		 (out_objIndex == in_liveObj->objIndex)) {
		objName = "TinyRM";
		bVar3 = true;
	}
	if (!bVar3) {
		BVar2 = Object_GetObjectByName("Lavamonster",&out_objType,&out_objIndex,NULL);
		if (((BVar2 != 0) && (out_objType == in_liveObj->objType)) &&
			 (out_objIndex == in_liveObj->objIndex)) {
			objName = "TinyRM";
			bVar3 = true;
		}
		if (((!bVar3) &&
				(BVar2 = Object_GetObjectByName("Icemonster",&out_objType,&out_objIndex,NULL), BVar2 != 0))
			 && ((out_objType == in_liveObj->objType && (out_objIndex == in_liveObj->objIndex)))) {
			objName = "TinyIM";
		}
	}
	BVar2 = Object_GetObjectByName(objName,&out_objType,&out_objIndex,&local_c);
	if (BVar2 != 0) {
		LiveObject_GetPosition(in_liveObj,&local_8,&local_4);
		uVar4 = 0;
		while( true ) {
			sVar1 = math::Maths_Rand();
			liveObj = Game_CreateLiveResourceObject
													(local_c,out_objType,out_objIndex,0,local_8,local_4,
													 (float)((int)sVar1 % 7));
			liveObj->health = -1.0;
			BVar2 = LiveObject_TryDepart_FUN_004499c0(liveObj);
			if (BVar2 == 0) break;
			uVar4 += 1;
			in_liveObj->flags2 = in_liveObj->flags2 | LIVEOBJ2_UNK_20;
			if (2 < uVar4) {
				return;
			}
		}
		pool::ReservedPool_LiveObject___Release(liveObj);
	}
	return;
}



void __cdecl lego::game::Level_GenerateSmallSpiders(uint x,uint y,uint randSeed)
{
	short sVar1;
	BOOL BVar2;
	SurfaceMap *surfMap;
	LiveObject *pLVar3;
	int iVar4;
	float10 fVar5;
	Vector3F *out_vertices4;
	int objIndex;
	ObjectType objType;
	Container *objRes;
	Point2F genPos;
	Point2F local_30;
	Point2F local_18;
	
	BVar2 = Object_GetObjectByName("SmallSpider",&objType,&objIndex,&objRes);
	if (BVar2 != 0) {
		out_vertices4 = (Vector3F *)&local_30;
		surfMap = GetSurfaceMap();
		Map3D_GetBlockVertexPositions(surfMap,x,y,out_vertices4);
		for (iVar4 = (randSeed & 3) + 2; iVar4 != 0; iVar4 += -1) {
			sVar1 = math::Maths_Rand();
			fVar5 = math::Maths_RandRange(local_30.x - -1.0,local_18.x - 1.0);
			genPos.x = (float)fVar5;
			fVar5 = math::Maths_RandRange(local_30.y - 1.0,local_18.y - -1.0);
			genPos.y = (float)fVar5;
			pLVar3 = Game_CreateLiveResourceObject
												 (objRes,objType,objIndex,0,genPos.x,genPos.y,(float)((int)sVar1 % 7));
			pLVar3->flags1 = pLVar3->flags1 | LIVEOBJ1_UNK_10000;
		}
	}
	return;
}



void __cdecl lego::ai::AI_LiveObject_DoThrowLegoman(LiveObject *liveObj1,LiveObject *liveObj2)
{
	BOOL BVar1;
	float10 fVar2;
	
	BVar1 = game::LiveObject_CheckCondition_FUN_00438870(liveObj2,1);
	if ((((BVar1 != 0) && ((liveObj2->flags2 & LIVEOBJ2_UNK_100) == LIVEOBJ2_NONE)) &&
			((*(byte *)&liveObj1->flags2 & 1) == 0)) &&
		 ((liveObj2->flags2 & LIVEOBJ2_UNK_2) == LIVEOBJ2_NONE)) {
		BVar1 = game::LiveObject_Check_LotsOfFlags1AndFlags2_FUN_0043bdb0(liveObj1);
		if (BVar1 == 0) {
			fVar2 = game::LiveObject_GetPainThreshold(liveObj1);
			if (fVar2 < (float10)liveObj1->health) {
				front::Interface_BackToMain_IfLiveObject_IsSelected_OrFlags3_200000(liveObj2);
				game::LiveObject_FUN_00441df0(liveObj2,0,1);
				game::LiveObject_FUN_00441df0(liveObj1,0,1);
				game::LiveObject_SetActivityUnk(liveObj1,ACTIVITY_THROWMAN,1);
				game::LiveObject_Container_ActivityUpdate_Check(liveObj1);
				game::LiveObject_SetActivityUnk(liveObj2,ACTIVITY_THROWNBYROCKMONSTER,1);
				game::LiveObject_Container_ActivityUpdate_Check(liveObj2);
				AITask_DoAnimationWait(liveObj1);
				AITask_DoAnimationWait(liveObj2);
				liveObj1->flags2 = liveObj1->flags2 | LIVEOBJ2_UNK_1;
				liveObj2->flags2 = liveObj2->flags2 | LIVEOBJ2_UNK_2;
				liveObj1->object_3c0 = liveObj2;
				liveObj2->object_3c0 = liveObj1;
			}
		}
	}
	return;
}



BOOL __cdecl lego::tools::Tool_IsBeamWeapon(ToolType toolType)
{
	if (((toolType != TOOL_LASER) && (toolType != TOOL_PUSHERGUN)) && (toolType != TOOL_FREEZERGUN)) {
		return 0;
	}
	return 1;
}



void __cdecl lego::game::MiniFigure_EquipTool(LiveObject *liveObj,ToolType toolType)
{
	uint uVar1;
	uint uVar2;
	BOOL BVar3;
	ToolType *pTVar4;
	uint uVar5;
	
	uVar1 = LiveObject_GetNumOfToolsCanCarry(liveObj);
	uVar5 = 0;
	liveObj->field_3f4 = 0;
	if (uVar1 != 0) {
		liveObj->flags4 = liveObj->flags4 & 0xfffffffb;
		uVar2 = LiveObject_GetEquippedBeam(liveObj);
		if ((uVar2 != 0) || (BVar3 = tools::Tool_IsBeamWeapon(toolType), BVar3 != 0)) {
			liveObj->flags4 = liveObj->flags4 | 4;
		}
		BVar3 = tools::Tool_IsBeamWeapon(toolType);
		if ((BVar3 != 0) && (liveObj->numCarriedTools != 0)) {
			pTVar4 = liveObj->carriedTools;
			do {
				BVar3 = tools::Tool_IsBeamWeapon(*pTVar4);
				if (BVar3 != 0) {
					liveObj->carriedTools[uVar5] = toolType;
					return;
				}
				uVar5 += 1;
				pTVar4 = pTVar4 + 1;
			} while (uVar5 < liveObj->numCarriedTools);
		}
		if (uVar1 != 0) {
			uVar5 = liveObj->numCarriedTools;
			if (uVar5 == uVar1) {
				uVar1 = 0;
				if (uVar5 != 1) {
					pTVar4 = liveObj->carriedTools;
					do {
						uVar1 += 1;
						*pTVar4 = pTVar4[1];
						pTVar4 = pTVar4 + 1;
					} while (uVar1 < liveObj->numCarriedTools - 1);
				}
				liveObj->carriedTools[liveObj->numCarriedTools - 1] = toolType;
				return;
			}
			liveObj->carriedTools[uVar5] = toolType;
			liveObj->numCarriedTools = liveObj->numCarriedTools + 1;
		}
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_HasToolEquipped(LiveObject *liveObj,ToolType toolType)
{
	uint uVar1;
	ToolType *pTVar2;
	
	uVar1 = 0;
	if (liveObj->numCarriedTools == 0) {
		return 0;
	}
	pTVar2 = liveObj->carriedTools;
	do {
		if (*pTVar2 == toolType) {
			return 1;
		}
		uVar1 += 1;
		pTVar2 = pTVar2 + 1;
	} while (uVar1 < liveObj->numCarriedTools);
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_TaskHasTool_FUN_0044b780(LiveObject *in_liveObj,AITaskType taskType)
{
	LiveObject *liveObj;
	BOOL BVar1;
	
	liveObj = in_liveObj;
	if (in_liveObj->objType == OBJECT_MINIFIGURE) {
		BVar1 = ai::AI_GetToolFromTaskType(taskType,(ToolType *)&in_liveObj);
		if (BVar1 != 0) {
			BVar1 = LiveObject_HasToolEquipped(liveObj,(ToolType)in_liveObj);
			return BVar1;
		}
	}
	return 1;
}



int __cdecl lego::game::LiveObject_DoGetTool(LiveObject *liveObj,ToolType toolType)
{
	LiveObject *pLVar1;
	Container *cont;
	SurfaceMap *pSVar2;
	BOOL BVar3;
	int iVar4;
	float *pfVar5;
	float *pfVar6;
	uint local_34;
	BOOL local_30;
	float local_2c;
	float local_28;
	Point2F local_24;
	float local_1c;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	LiveObject *liveObj_00;
	
	liveObj_00 = liveObj;
	local_30 = 0;
	iVar4 = 0;
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		LiveObject_GetPosition(liveObj,(float *)&local_24,&local_24.y);
		pLVar1 = Level_GetBuildingAtPosition(&local_24);
		if (pLVar1 != NULL) {
			cont = res::Building_GetToolNull
											 (pLVar1->building,globs::liveGlobs.ToolNullIndexes_TABLE[toolType]);
			res::Container_GetPosition(cont,NULL,&local_c);
			local_14 = local_c.x;
			pfVar6 = &local_28;
			pfVar5 = &local_2c;
			local_10 = local_c.y;
			pSVar2 = GetSurfaceMap();
			Map3D_WorldToBlockPos_NoZ(pSVar2,local_c.x,local_c.y,(int *)pfVar5,(int *)pfVar6);
			pfVar6 = &local_18;
			pfVar5 = &local_1c;
			pSVar2 = GetSurfaceMap();
			Map3D_WorldToBlockPos_NoZ(pSVar2,local_24.x,local_24.y,(int *)pfVar5,(int *)pfVar6);
			if ((local_1c == local_2c) && (local_18 == local_28)) {
				local_30 = LiveObject_FUN_004419c0(liveObj_00,1,&local_2c,&local_28,&local_14);
			}
			else {
				BVar3 = LiveObject_FUN_004413b0
													(liveObj_00,local_1c,local_18,local_2c,local_28,&liveObj,&toolType,
													 &local_34,0,0);
				if (BVar3 != 0) {
					BVar3 = LiveObject_FUN_004419c0
														(liveObj_00,local_34,(float *)liveObj,(float *)toolType,&local_14);
					std::free(liveObj);
					std::free((void *)toolType);
					local_30 = BVar3;
				}
			}
			iVar4 = local_30;
			if (local_30 != 0) {
				liveObj_00->object_2fc = pLVar1;
				*(undefined *)((int)liveObj_00->routeptr_24 + liveObj_00->routingBlocksTotal * 0x14 + -3) =
						 0xd;
			}
		}
	}
	return iVar4;
}



void __cdecl lego::game::LiveObject_Flocks_Initialise(LiveObject *in_liveObj)
{
	LiveObject *liveObj;
	LiveObject *pLVar1;
	Container *opt_parent;
	Container *in_child;
	Container *pCVar2;
	FlockData *pFVar3;
	FlockSubdata *subdata;
	float10 fVar4;
	float speed;
	float fVar5;
	float fVar6;
	LiveObject *resData;
	Vector3F vector2;
	Vector3F vector1;
	
	liveObj = in_liveObj;
	vector1.x = 0.0;
	vector1.y = 0.0;
	vector1.z = 0.0;
	vector2.x = 0.0;
	vector2.y = 0.0;
	vector2.z = 0.0;
	pLVar1 = (LiveObject *)LiveObject_GetFlocks_Size(in_liveObj);
	opt_parent = LiveObject_GetContainer(in_liveObj);
	in_child = res::Container_Create(opt_parent);
	pCVar2 = res::GetRoot();
	res::Container_SetParent(in_child,pCVar2);
	fVar6 = 0.0;
	resData = in_liveObj;
	fVar4 = LiveObject_GetFlocks_Speed(in_liveObj);
	fVar5 = (float)fVar4;
	fVar4 = LiveObject_GetFlocks_Turn(in_liveObj);
	pFVar3 = Flocks_LiveObject_Flocks_CreateData
										 (NULL,NULL,(float)fVar4,fVar5,fVar6,(Container *)resData);
	in_liveObj->flocksData_32c = pFVar3;
	pFVar3->flocksSubdata1->resData_98 = in_child;
	in_liveObj = pLVar1;
	if (0 < (int)pLVar1) {
		do {
			pCVar2 = res::Container_Clone(opt_parent);
			res::Container_SetParent(pCVar2,in_child);
			fVar4 = LiveObject_GetFlocks_GoalUpdate(liveObj);
			fVar5 = (float)fVar4;
			fVar4 = LiveObject_GetFlocks_Tightness(liveObj);
			fVar6 = (float)fVar4;
			fVar4 = LiveObject_GetFlocks_Speed(liveObj);
			speed = (float)fVar4;
			fVar4 = LiveObject_GetFlocks_Turn(liveObj);
			subdata = Flocks_LiveObject_Flocks_CreateSubdata
													(&vector1,&vector2,(float)fVar4,speed,fVar6,fVar5,pCVar2);
			Flocks_LiveObject_Flocks_AddSubdata(liveObj->flocksData_32c,subdata);
			in_liveObj = (LiveObject *)((int)&in_liveObj[-1].pool_m_next + 3);
		} while (in_liveObj != NULL);
	}
	return;
}



void __cdecl
lego::math::FlocksMatrix_FUN_0044ba60(Container *resData,Matrix4F *ref_matrix,float scalar)
{
	float fVar1;
	float fVar2;
	float fVar3;
	Vector3F vector;
	Matrix4F matrix_b;
	Matrix4F matrix_a;
	
	fVar1 = ref_matrix->values[3][1];
	fVar2 = ref_matrix->values[3][0];
	fVar3 = ref_matrix->values[3][2];
	ref_matrix->values[3][0] = 0.0;
	ref_matrix->values[3][1] = 0.0;
	ref_matrix->values[3][2] = 0.0;
										// M_PI / 2 (1.570796)
	Matrix_RotX(&matrix_b,1.570796);
	Matrix_Mult(&matrix_a,&matrix_b,ref_matrix);
	Matrix_Copy(ref_matrix,&matrix_a);
	ref_matrix->values[3][0] = fVar2;
	ref_matrix->values[3][1] = fVar3;
	ref_matrix->values[3][2] = -fVar1 - scalar;
	res::Container_AddTransform(resData,D3DRMCOMBINE_REPLACE,ref_matrix);
	return;
}



void __cdecl
lego::game::Flocks_Callback_SubdataOrientationAnim
					(FlockData *flocksData,FlockSubdata *subdata,float *pElapsed)
{
	Container *cont;
	float y;
	float x;
	SurfaceMap *pSVar1;
	float10 fVar2;
	float fVar3;
	float fVar4;
	Vector3F *out_vector;
	Vector3F local_30;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	cont = subdata->resData_98;
	if (pElapsed[3] == 0.0) {
		math::FlocksMatrix_FUN_0044ba60(cont,&subdata->matrix,pElapsed[1]);
		if (pElapsed[2] != 0.0) {
			res::Container_GetOrientation(cont,NULL,&local_24,&local_30);
			local_30.x = local_30.x * 0.5;
			local_30.y = local_30.y * 0.5;
			local_30.z = (local_30.z - 1.0) * 0.5;
			res::Container_SetOrientation
								(cont,NULL,local_24.x,local_24.y,local_24.z,local_30.x,local_30.y,local_30.z);
		}
	}
	else {
		y = (subdata->matrix).values[3][2];
		x = (subdata->matrix).values[3][0];
		local_c.x = 0.0;
		local_c.y = 1.0;
		local_c.z = 0.0;
		local_18.x = 0.0;
		local_18.y = 0.0;
		local_18.z = -1.0;
		fVar3 = x;
		fVar4 = y;
		pSVar1 = GetSurfaceMap();
		fVar2 = Map3D_GetWorldZ(pSVar1,fVar3,fVar4);
		out_vector = &local_30;
		fVar3 = x;
		fVar4 = y;
		pSVar1 = GetSurfaceMap();
		Map3D_FUN_0044fd70(pSVar1,fVar3,fVar4,out_vector);
		math::Maths_Vector3DRotate(&local_24,&local_c,&local_18,-subdata->rotationY_24);
		res::Container_SetOrientation
							(cont,NULL,local_30.x,local_30.y,local_30.z,local_24.x,local_24.y,local_24.z);
		res::Container_GetOrientation(cont,NULL,&local_30,&local_24);
		res::Container_SetOrientation
							(cont,NULL,local_24.x,local_24.y,local_24.z,local_30.x,local_30.y,local_30.z);
		res::Container_SetPosition(cont,NULL,x,y,(float)fVar2);
	}
	if (pElapsed[4] == 0.0) {
		res::Container_MoveAnimation(cont,*pElapsed);
	}
	else {
		if (0.0 <= subdata->rotationX_28) {
			res::Container_MoveAnimation(cont,*pElapsed);
			return;
		}
		fVar2 = res::Container_GetAnimationTime(cont);
		if (fVar2 != (float10)0.0) {
			fVar2 = res::Container_MoveAnimation(cont,*pElapsed);
			if ((ushort)((ushort)(fVar2 < (float10)0.0) << 8 | (ushort)(fVar2 == (float10)0.0) << 0xe) ==
					0) {
				res::Container_SetAnimationTime(cont,0.0);
				return;
			}
		}
	}
	return;
}



void __cdecl
lego::game::Flocks_Container_ReleaseCallback
					(FlockData *flockData,FlockSubdata *subdata,void *lpContext)
{
	Container *in_child;
	
	in_child = subdata->resData_98;
	if (in_child != NULL) {
		res::Container_SetParent(in_child,NULL);
		res::Container_Remove(in_child);
	}
	return;
}



void __cdecl lego::game::Flocks_Free(FlockData *flockData)
{
	Container *in_child;
	
	if (flockData != NULL) {
		Flocks_CallbackForAllSubdata(flockData,Flocks_Container_ReleaseCallback,NULL);
		in_child = flockData->flocksSubdata1->resData_98;
		res::Container_SetParent(in_child,NULL);
		res::Container_Remove(in_child);
		flockData->flocksSubdata1->resData_98 = NULL;
		Flocks_FreeData(flockData);
	}
	return;
}



void __cdecl lego::game::LiveObject_Flocks_SetParameters(LiveObject *liveObj,BOOL additive)
{
	FlockData *flocksData;
	float10 fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	
	flocksData = liveObj->flocksData_32c;
	if (additive != 0) {
		fVar1 = LiveObject_GetFlocks_Tightness(liveObj);
		fVar4 = (float)(fVar1 + fVar1);
		fVar1 = LiveObject_GetFlocks_Speed(liveObj);
		fVar3 = (float)(fVar1 + fVar1);
		fVar1 = LiveObject_GetFlocks_Turn(liveObj);
		Flocks_SetParameters1(flocksData,(float)(fVar1 + fVar1),fVar3,fVar4);
		fVar1 = LiveObject_GetFlocks_GoalUpdate(liveObj);
		fVar4 = (float)(fVar1 + fVar1);
		fVar1 = LiveObject_GetFlocks_Tightness(liveObj);
		fVar3 = (float)(fVar1 + fVar1);
		fVar1 = LiveObject_GetFlocks_Speed(liveObj);
		fVar2 = (float)(fVar1 * (float10)3.0);
		fVar1 = LiveObject_GetFlocks_Turn(liveObj);
		Flocks_SetGlobal_AndAllSubdataParameters
							(flocksData,(float)(fVar1 * (float10)4.0),fVar2,fVar3,fVar4);
		return;
	}
	fVar1 = LiveObject_GetFlocks_Tightness(liveObj);
	fVar4 = (float)fVar1;
	fVar1 = LiveObject_GetFlocks_Speed(liveObj);
	fVar3 = (float)fVar1;
	fVar1 = LiveObject_GetFlocks_Turn(liveObj);
	Flocks_SetParameters1(flocksData,(float)fVar1,fVar3,fVar4);
	fVar1 = LiveObject_GetFlocks_GoalUpdate(liveObj);
	fVar4 = (float)fVar1;
	fVar1 = LiveObject_GetFlocks_Tightness(liveObj);
	fVar3 = (float)fVar1;
	fVar1 = LiveObject_GetFlocks_Speed(liveObj);
	fVar2 = (float)fVar1;
	fVar1 = LiveObject_GetFlocks_Turn(liveObj);
	Flocks_SetGlobal_AndAllSubdataParameters(flocksData,(float)fVar1,fVar2,fVar3,fVar4);
	return;
}



void __cdecl lego::game::LiveObject_Flocks_FUN_0044bef0(LiveObject *liveObj,float elapsed)
{
	uint *puVar1;
	FlockData *pFVar2;
	ObjectStatsFlags1 OVar3;
	Container *pCVar4;
	BOOL BVar5;
	float10 fVar6;
	Container *opt_ref;
	Vector3F *out_pos;
	Vector3F local_2c;
	Vector3F local_20;
	float local_14;
	float local_10;
	uint local_c;
	uint local_8;
	uint local_4;
	
	OVar3 = LiveObject_GetStatsFlags1(liveObj);
	if ((OVar3 & STATS1_FLOCKS) != STATS1_NONE) {
		OVar3 = LiveObject_GetStatsFlags1(liveObj);
		if ((OVar3 & STATS1_FLOCKS_DEBUG) == STATS1_NONE) {
			pCVar4 = LiveObject_GetContainer(liveObj);
			BVar5 = res::Container_IsHidden(pCVar4);
			if (BVar5 == 0) {
				LiveObject_HideAll(liveObj,1);
			}
		}
		pFVar2 = liveObj->flocksData_32c;
		if ((*(byte *)&pFVar2->field_24 & 1) != 0) {
			pFVar2->field_14 = elapsed + (float)pFVar2->field_14;
		}
		fVar6 = LiveObject_GetFlocks_AttackTime(liveObj);
		if (((ushort)((ushort)(fVar6 < (float10)elapsed) << 8 |
								 (ushort)(fVar6 == (float10)elapsed) << 0xe) != 0) &&
			 ((*(byte *)&liveObj->flags2 & 0x80) == 0)) {
			ai::AITask_LiveObject_SetAITaskUnk(liveObj,AITASK_FOLLOW,NULL,1);
			puVar1 = &liveObj->flocksData_32c->field_24;
			*puVar1 = *puVar1 & 0xfffffffe;
		}
		out_pos = &local_20;
		opt_ref = NULL;
		pCVar4 = LiveObject_GetContainer(liveObj);
		res::Container_GetPosition(pCVar4,opt_ref,out_pos);
		local_2c.y = -local_20.z;
		local_2c.x = local_20.x;
		local_2c.z = local_20.y;
		BVar5 = res::AnimClone_IsLws((AnimClone *)liveObj->flocksData_32c);
		if (BVar5 == 0) {
			Flocks_SetVector1(liveObj->flocksData_32c,&local_2c);
			Flocks_SetAllSubdataVectorC(liveObj->flocksData_32c,&local_2c);
			Flocks_SetAllSubdataVector0(liveObj->flocksData_32c,&local_2c);
		}
		if ((*(byte *)&liveObj->flags2 & 0x80) == 0) {
			LiveObject_Flocks_SetParameters(liveObj,0);
		}
		else {
			LiveObject_Flocks_SetParameters(liveObj,TRUE);
			liveObj->flags2 =
					 liveObj->flags2 &
					 (LIVEOBJ2_UNK_1|LIVEOBJ2_UNK_2|LIVEOBJ2_UNK_4|LIVEOBJ2_DRIVING|LIVEOBJ2_UNK_10|
						LIVEOBJ2_UNK_20|LIVEOBJ2_UNK_40|LIVEOBJ2_UNK_100|LIVEOBJ2_UNK_200|LIVEOBJ2_TRAINING|
						LIVEOBJ2_UNK_800|LIVEOBJ2_UNK_1000|LIVEOBJ2_UNK_2000|LIVEOBJ2_UNK_4000|
						LIVEOBJ2_UPGRADING|LIVEOBJ2_UNK_10000|LIVEOBJ2_UNK_20000|LIVEOBJ2_UNK_40000|
						LIVEOBJ2_UNK_80000|LIVEOBJ2_UNK_100000|LIVEOBJ2_UNK_200000|LIVEOBJ2_UNK_400000|
						LIVEOBJ2_UNK_800000|LIVEOBJ2_UNK_1000000|LIVEOBJ2_UNK_2000000|LIVEOBJ2_UNK_4000000|
						LIVEOBJ2_UNK_8000000|LIVEOBJ2_UNK_10000000|LIVEOBJ2_UNK_20000000|LIVEOBJ2_UNK_40000000|
					 LIVEOBJ2_UNK_80000000);
		}
		Flocks_SetVector2(liveObj->flocksData_32c,&local_2c);
		fVar6 = LiveObject_GetFlocks_Randomness(liveObj);
		Flocks_FUN_0040fe80(liveObj->flocksData_32c,(float)fVar6);
		Flocks_Subdata_UpdateMove(liveObj->flocksData_32c,elapsed);
		local_14 = elapsed;
		fVar6 = LiveObject_GetFlocks_Height(liveObj);
		local_10 = (float)fVar6;
		OVar3 = LiveObject_GetStatsFlags1(liveObj);
		local_c = OVar3 >> 0x17 & 1;
		OVar3 = LiveObject_GetStatsFlags1(liveObj);
		local_8 = OVar3 >> 0x1a & 1;
		OVar3 = LiveObject_GetStatsFlags1(liveObj);
		local_4 = OVar3 >> 0x1c & 1;
		Flocks_CallbackForAllSubdata
							(liveObj->flocksData_32c,Flocks_Callback_SubdataOrientationAnim,&local_14);
	}
	return;
}



void __cdecl lego::game::LiveObject_FlocksDestroy(LiveObject *liveObj)
{
	ObjectStatsFlags1 OVar1;
	FlockData **ppFVar2;
	FlockData *pFVar3;
	float10 fVar4;
	Vector3F local_c;
	
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_FLOCKS_QUICKDESTROY) != STATS1_NONE) {
		Flocks_Free(liveObj->flocksData_32c);
		return;
	}
	ppFVar2 = (FlockData **)std::malloc(0x10);
	if (ppFVar2 == NULL) {
		Flocks_Free(liveObj->flocksData_32c);
		return;
	}
	pFVar3 = liveObj->flocksData_32c;
	local_c.x = (pFVar3->flocksSubdata1->vector_0).x;
	local_c.y = (pFVar3->flocksSubdata1->vector_0).y;
	local_c.z = (pFVar3->flocksSubdata1->vector_0).z;
	*ppFVar2 = pFVar3;
	pFVar3 = (FlockData *)LiveObject_GetStatsFlags1(liveObj);
	ppFVar2[2] = pFVar3;
	ppFVar2[1] = (FlockData *)globs::liveGlobs.s_FlocksDestroy_c640;
	fVar4 = LiveObject_GetFlocks_Height(liveObj);
	ppFVar2[3] = (FlockData *)(float)fVar4;
	globs::liveGlobs.s_FlocksDestroy_c640 = ppFVar2;
	Flocks_SetVector1(liveObj->flocksData_32c,&local_c);
	Flocks_SetAllSubdataVector0(liveObj->flocksData_32c,&local_c);
	return;
}



// WARNING: Type propagation algorithm not settling

void __cdecl lego::game::Flocks_Update_FUN_0044c1c0(float *pElapsed)
{
	FlockSubdata *pFVar1;
	BOOL BVar2;
	FlockSubdata *pFVar3;
	FlockSubdata *buffer;
	FlockSubdata *pFVar4;
	float local_14;
	FlockSubdata *local_10;
	uint local_c;
	uint local_8;
	uint local_4;
	
	pFVar3 = NULL;
	buffer = (FlockSubdata *)globs::liveGlobs.s_FlocksDestroy_c640;
	if (globs::liveGlobs.s_FlocksDestroy_c640 != NULL) {
		do {
			Flocks_CallbackForAllSubdata
								(*(FlockData **)&buffer->vector_0,Flocks_Callback_FUN_00410000,pElapsed);
			local_14 = *pElapsed;
			local_10 = *(FlockSubdata **)&buffer->vector_c;
			local_c = (uint)*(FlockSubdata **)((int)&buffer->vector_0 + 8) >> 0x17 & 1;
			local_8 = (uint)*(FlockSubdata **)((int)&buffer->vector_0 + 8) >> 0x1a & 1;
			local_4 = (uint)*(FlockSubdata **)((int)&buffer->vector_0 + 8) >> 0x1c & 1;
			Flocks_CallbackForAllSubdata
								(*(FlockData **)&buffer->vector_0,Flocks_Callback_SubdataOrientationAnim,&local_14);
			BVar2 = Flocks_CompareAllVecs_0_c(*(FlockData **)&buffer->vector_0);
			if (BVar2 == 0) {
				pFVar4 = *(FlockSubdata **)((int)&buffer->vector_0 + 4);
			}
			else {
				pFVar4 = *(FlockSubdata **)((int)&buffer->vector_0 + 4);
				pFVar1 = pFVar4;
				if (pFVar3 != NULL) {
					*(FlockSubdata **)((int)&pFVar3->vector_0 + 4) = pFVar4;
					pFVar1 = (FlockSubdata *)globs::liveGlobs.s_FlocksDestroy_c640;
				}
				globs::liveGlobs.s_FlocksDestroy_c640 = (void **)pFVar1;
				Flocks_Free(*(FlockData **)&buffer->vector_0);
				std::free(buffer);
				buffer = pFVar3;
			}
			pFVar3 = buffer;
			buffer = pFVar4;
		} while (pFVar4 != NULL);
	}
	return;
}



BOOL __cdecl lego::game::LiveObject_DestroyRockMonster_FUN_0044c290(LiveObject *liveObj)
{
	if ((ushort)((ushort)(liveObj->float_2d4 < 0.0) << 8 | (ushort)(liveObj->float_2d4 == 0.0) << 0xe)
			== 0) {
		liveObj->flags1 = liveObj->flags1 & ~LIVEOBJ1_UNK_100000;
		LiveObject_GenerateTinyRMs_FUN_0044b270(liveObj);
		LiveObject_CallsSpawnDropCrystals_FUN_0044b250(liveObj);
		liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
		nerps::NERPs_IncRockMonstersDestroyed();
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_0044c2f0(LiveObject *liveObj,float elapsed)
{
	LiveObject *pLVar1;
	float10 fVar2;
	float local_c;
	float local_8 [2];
	
	if (((liveObj->flags2 & LIVEOBJ2_UNK_8000000) == LIVEOBJ2_NONE) &&
		 (liveObj->objType == OBJECT_ROCKMONSTER)) {
		liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_8000000;
		liveObj->float_368 = elapsed * 25.0;
		LiveObject_GetPosition(liveObj,&local_c,local_8);
		fVar2 = LiveObject_UnkRadians_FUN_00442740(liveObj);
		pLVar1 = Game_CreateLiveResourceObject
											 (globs::gameGlobs.RES_IceCube,OBJECT_ICECUBE,0,0,local_c,local_8[0],
												(float)fVar2);
		res::Container_SetActivity(pLVar1->other,"Start");
		res::Container_SetAnimationTime(pLVar1->other,0.0);
		pLVar1->flags1 = pLVar1->flags1 | LIVEOBJ1_UNK_100;
		liveObj->object_364 = pLVar1;
		pLVar1->object_364 = liveObj;
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::LiveObject_FUN_0044c3d0(LiveObject *liveObj)
{
	LiveFlags3 *pLVar1;
	
	if ((liveObj->object_364->flags1 & LIVEOBJ1_UNK_200000) == LIVEOBJ1_NONE) {
										// 100.0
		liveObj->object_364->health = (float)&DAT_42c80000;
		pLVar1 = &liveObj->object_364->flags3;
		*pLVar1 = *pLVar1 | LIVEOBJ3_UNK_800000;
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_Unk_AndSetVector3B4(LiveObject *liveObj,Point2F *param_2,float param_3)
{
	ObjectType OVar1;
	
	OVar1 = liveObj->objType;
	if (((OVar1 != OBJECT_MINIFIGURE) && (OVar1 != OBJECT_ROCKMONSTER)) && (OVar1 != OBJECT_VEHICLE))
	{
		return 0;
	}
	LiveObject_FUN_00441df0(liveObj,0,1);
	(liveObj->vector_3b4).x = param_2->x;
	(liveObj->vector_3b4).y = param_2->y;
	(liveObj->vector_3b4).z = param_3;
	liveObj->flags2 = liveObj->flags2 | LIVEOBJ2_UNK_4000;
	return 1;
}



void __cdecl lego::game::LiveObject_FUN_0044c470(LiveObject *liveObj,float elapsed)
{
	float fVar1;
	SurfaceMap *pSVar2;
	int iVar3;
	float fVar4;
	float fVar5;
	int *piVar6;
	int *piVar7;
	Point2F local_18;
	float local_10;
	float local_c;
	int local_8;
	int local_4;
	
	LiveObject_GetPosition(liveObj,(float *)&local_18,&local_18.y);
	local_10 = (liveObj->vector_3b4).x * elapsed;
	piVar7 = &local_4;
	piVar6 = &local_8;
	local_c = (liveObj->vector_3b4).y * elapsed;
	fVar4 = local_10 + local_18.x;
	fVar5 = local_c + local_18.y;
	local_18.x = fVar4;
	local_18.y = fVar5;
	pSVar2 = GetSurfaceMap();
	Map3D_WorldToBlockPos_NoZ(pSVar2,fVar4,fVar5,piVar6,piVar7);
	iVar3 = LiveObject_FUN_00431cd0(liveObj,local_8,local_4,local_8,local_4,1);
	if (iVar3 == 0) {
LAB_0044c517:
		fVar5 = (liveObj->vector_3b4).x;
		fVar1 = (liveObj->vector_3b4).y;
		fVar4 = (liveObj->vector_3b4).y;
		fVar4 = 1.0 / SQRT(fVar5 * fVar5 + fVar4 * fVar4);
		fVar5 = SQRT(fVar5 * fVar5 + fVar1 * fVar1);
		(liveObj->vector_3b4).x = (liveObj->vector_3b4).x * fVar4;
		(liveObj->vector_3b4).y = fVar4 * (liveObj->vector_3b4).y;
		fVar4 = (liveObj->vector_3b4).x;
		if ((ushort)((ushort)(fVar4 < 0.5) << 8 | (ushort)(fVar4 == 0.5) << 0xe) == 0) {
			(liveObj->vector_3b4).x = 1.0;
			(liveObj->vector_3b4).y = 0.0;
		}
		else {
			if (-0.5 <= (liveObj->vector_3b4).x) {
				fVar4 = (liveObj->vector_3b4).y;
				if ((ushort)((ushort)(fVar4 < 0.5) << 8 | (ushort)(fVar4 == 0.5) << 0xe) == 0) {
					(liveObj->vector_3b4).x = 0.0;
					(liveObj->vector_3b4).y = 1.0;
				}
				else {
					if ((liveObj->vector_3b4).y < -0.5) {
						(liveObj->vector_3b4).x = 0.0;
						(liveObj->vector_3b4).y = -1.0;
					}
				}
			}
			else {
				(liveObj->vector_3b4).x = -1.0;
				(liveObj->vector_3b4).y = 0.0;
			}
		}
		(liveObj->vector_3b4).x = (liveObj->vector_3b4).x * fVar5;
		(liveObj->vector_3b4).y = (liveObj->vector_3b4).y * fVar5;
		LiveObject_GetPosition(liveObj,(float *)&local_18,&local_18.y);
		local_10 = (liveObj->vector_3b4).x * elapsed;
		piVar7 = &local_4;
		piVar6 = &local_8;
		local_c = (liveObj->vector_3b4).y * elapsed;
		fVar4 = local_10 + local_18.x;
		fVar5 = local_c + local_18.y;
		local_18.x = fVar4;
		local_18.y = fVar5;
		pSVar2 = GetSurfaceMap();
		Map3D_WorldToBlockPos_NoZ(pSVar2,fVar4,fVar5,piVar6,piVar7);
		iVar3 = LiveObject_FUN_00431cd0(liveObj,local_8,local_4,local_8,local_4,1);
		if (iVar3 != 0) {
			iVar3 = LiveObject_DoCollisionCallbacks_FUN_00446030(liveObj,&local_18,0.0,0);
			if (iVar3 == 0) goto LAB_0044c6eb;
		}
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_4000;
	}
	else {
		iVar3 = LiveObject_DoCollisionCallbacks_FUN_00446030(liveObj,&local_18,0.0,0);
		if (iVar3 != 0) goto LAB_0044c517;
LAB_0044c6eb:
		LiveObject_UnkUpdatePositioning(liveObj,local_18.x,local_18.y,0,0);
	}
	fVar4 = (liveObj->vector_3b4).z;
	if ((ushort)((ushort)(fVar4 < 0.0) << 8 | (ushort)(fVar4 == 0.0) << 0xe) != 0) {
		liveObj->flags2 = liveObj->flags2 & ~LIVEOBJ2_UNK_4000;
	}
	(liveObj->vector_3b4).z = (liveObj->vector_3b4).z - SQRT(local_c * local_c + local_10 * local_10);
	return;
}



void __cdecl lego::game::LiveObject_FUN_0044c760(LiveObject *liveObj)
{
	ObjectStatsFlags2 OVar1;
	ObjectStatsFlags1 OVar2;
	
	if ((*(byte *)&liveObj->flags4 & 2) != 0) {
		OVar1 = LiveObject_GetStatsFlags2(liveObj);
		if ((OVar1 & STATS2_CANDOUBLESELECT) != STATS2_NONE) {
			OVar2 = LiveObject_GetStatsFlags1(liveObj);
			if (((OVar2 & STATS1_CANBEDRIVEN) == STATS1_NONE) || (liveObj->drivenObject != NULL)) {
				globs::gameGlobs.flags1 |= GAME1_LASERTRACKER;
				liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_1;
			}
		}
	}
	front::Interface_BackToMain();
	return;
}



BOOL __cdecl lego::game::LiveObject_FUN_0044c7c0(LiveObject *liveObj)
{
	if ((*(byte *)&liveObj->flags4 & 1) != 0) {
		globs::gameGlobs.flags1 &= ~GAME1_LASERTRACKER;
	}
	liveObj->flags4 = liveObj->flags4 & ~LIVEOBJ4_UNK_1;
	return 0;
}



BOOL __cdecl lego::game::LiveObject_MiniFigureHasBeamEquipped(LiveObject *liveObj)
{
	uint uVar1;
	
	if (liveObj->objType == OBJECT_MINIFIGURE) {
		uVar1 = LiveObject_GetEquippedBeam(liveObj);
		if (uVar1 != 0) {
			return 1;
		}
	}
	return 0;
}



void __cdecl lego::game::LiveManager_CheckMouseIntersections_FUN_0044c810(void)
{
	BOOL BVar1;
	undefined4 local_4;
	
	globs::liveGlobs.flags |= 0x40;
	BVar1 = Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_CheckIntersections_FUN_0044c8b0,NULL)
	;
	if (BVar1 == 0) {
		if (globs::liveGlobs.countBuildingsOnly_c438 == 0) {
			local_4 = 1;
			BVar1 = Search_LiveObjects_SkipIgnoreMes
												(LiveObject_Callback_CheckIntersections_FUN_0044c8b0,&local_4);
			if ((BVar1 == 0) && (globs::liveGlobs.count_c434 != 0)) {
				globs::liveGlobs.count_c434 = 0;
				globs::liveGlobs.countBuildingsOnly_c438 = 0;
				Search_LiveObjects_SkipIgnoreMes
									(LiveObject_Callback_CheckIntersections_FUN_0044c8b0,&local_4);
				return;
			}
		}
		else {
			globs::liveGlobs.count_c434 = 0;
			globs::liveGlobs.countBuildingsOnly_c438 = 0;
			Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_CheckIntersections_FUN_0044c8b0,NULL);
		}
	}
	return;
}



BOOL __cdecl
lego::game::LiveObject_Callback_CheckIntersections_FUN_0044c8b0
					(LiveObject *liveObj,BOOL *pFalseForBuildings)
{
	int iVar1;
	uint uVar2;
	BOOL BVar3;
	LiveObject **ppLVar4;
	Vector3F worldMousePos;
	
	iVar1 = 0;
	if (pFalseForBuildings != NULL) {
		iVar1 = *pFalseForBuildings;
	}
	if (iVar1 == 0) {
		if (liveObj->objType != OBJECT_BUILDING) {
			return 0;
		}
	}
	else {
		if (liveObj->objType != OBJECT_MINIFIGURE) {
			return 0;
		}
	}
	uVar2 = 0;
	if (globs::liveGlobs.count_c434 != 0) {
		ppLVar4 = globs::liveGlobs.liveObjArray256_c034;
		do {
			if (*ppLVar4 == liveObj) {
				return 0;
			}
			uVar2 += 1;
			ppLVar4 = ppLVar4 + 1;
		} while (uVar2 < globs::liveGlobs.count_c434);
	}
	if (globs::liveGlobs.count_c434 < 0x100) {
		globs::liveGlobs.liveObjArray256_c034[globs::liveGlobs.count_c434] = liveObj;
		globs::liveGlobs.count_c434 += 1;
		if (liveObj->objType == OBJECT_BUILDING) {
			globs::liveGlobs.countBuildingsOnly_c438 += 1;
		}
		LiveObject_FUN_0042dd70(liveObj,NULL,FALSE);
		BVar3 = Map3D_GetIntersections
											((globs::gameGlobs.level)->surfaceMap,globs::gameGlobs.viewMain,
											 globs::INPUT.msx,globs::INPUT.msy,(uint *)&pFalseForBuildings,
											 (uint *)&liveObj,&worldMousePos);
		if (BVar3 != 0) {
			res::Container_SetPosition
								(globs::gameGlobs.resRootLight,NULL,worldMousePos.x,worldMousePos.y,
								 worldMousePos.z - 250.0);
			return TRUE;
		}
	}
	else {
		globs::liveGlobs.count_c434 = 0;
		globs::liveGlobs.countBuildingsOnly_c438 = 0;
	}
	return TRUE;
}



void __cdecl
lego::light::LightEffects_Initialise
					(Container *resRootSpotlight,Container *resRootLight,float initialRed,float initialGreen,
					float initialBlue)
{
	globs::lightGlobs.initialRGB.red = initialRed;
	globs::lightGlobs.initialRGB.green = initialGreen;
	globs::lightGlobs.currentRGB.red = initialRed;
	globs::lightGlobs.currentRGB.green = initialGreen;
	globs::lightGlobs.initialRGB.blue = initialBlue;
	globs::lightGlobs.currentRGB.blue = initialBlue;
	globs::lightGlobs.resSpotlight = resRootSpotlight;
	globs::lightGlobs.resRootLight = resRootLight;
	LightEffects_ResetColor();
	return;
}



// Resets LightEffects to its initialRGB colour value (hardcoded as 0.8:0.8:0.8)

void __cdecl lego::light::LightEffects_ResetColor(void)
{
	res::Container_SetColourAlpha
						(globs::lightGlobs.resSpotlight,globs::lightGlobs.initialRGB.red,
						 globs::lightGlobs.initialRGB.green,globs::lightGlobs.initialRGB.blue,1.0);
	return;
}



void __cdecl lego::light::LightEffects_SetDisabled(BOOL isDisabled)
{
	if (isDisabled != 0) {
		globs::lightGlobs.flags |= LIGHTEFFECTS_DISABLED;
		LightEffects_ResetColor();
		return;
	}
	globs::lightGlobs.flags = globs::lightGlobs.flags & ~LIGHTEFFECTS_DISABLED;
	return;
}



BOOL __cdecl lego::light::LightEffects_Load(CFGProperty *root,char *rootPath)
{
	BOOL BVar1;
	
	LightEffects_LoadBlink(root,rootPath);
	LightEffects_LoadFade(root,rootPath);
	BVar1 = LightEffects_LoadMove(root,rootPath);
	return BVar1;
}



BOOL __cdecl lego::light::LightEffects_LoadBlink(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	BOOL BVar2;
	char *pcVar3;
	int iVar4;
	float10 fVar5;
	float10 fVar6;
	float *out_r;
	float *out_g;
	float *out_b;
	float blink_blue;
	float blink_green;
	float blink_red;
	char *stringParts [10];
	
	pcVar3 = rootPath;
	out_b = &blink_blue;
	out_g = &blink_green;
	out_r = &blink_red;
	pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","BlinkRGBMax",0);
	BVar2 = cfg::CFG_ReadRGBF(root,pcVar1,out_r,out_g,out_b);
	if (BVar2 != 0) {
		pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","MaxChangeAllowed",0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		if (pcVar1 == NULL) {
			pcVar1 = ____EMPTYSTR__;
		}
		else {
			pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","MaxChangeAllowed",0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		}
		fVar5 = std::atof(pcVar1);
		rootPath = (char *)(float)fVar5;
		if ((float10)0.0 != fVar5) {
			rootPath = (char *)((float)rootPath * 0.003921569);
		}
		pcVar3 = cfg::CFG_JoinPath(pcVar3,"LightEffects","RandomRangeForTimeBetweenBlinks",0);
		pcVar3 = cfg::CFG_CopyString(root,pcVar3);
		if (pcVar3 != NULL) {
			iVar4 = util::Util_Tokenise(pcVar3,stringParts,":");
			if (iVar4 == 2) {
				fVar5 = std::atof(stringParts[0]);
				fVar6 = std::atof(stringParts[1]);
				std::free(pcVar3);
				LightEffects_SetBlink
									(blink_red,blink_green,blink_blue,(float)rootPath,(float)(fVar5 * (float10)25.0),
									 (float)(fVar6 * (float10)25.0));
				return 1;
			}
			std::free(pcVar3);
		}
	}
	return 0;
}



void __cdecl
lego::light::LightEffects_SetBlink
					(float red,float green,float blue,float maxChange,float minRange,float maxRange)
{
	globs::lightGlobs.BlinkRGBMax.red = red;
	globs::lightGlobs.BlinkRGBMax.green = green;
	globs::lightGlobs.BlinkRGBMax.blue = blue;
	globs::lightGlobs.RandomRangeForTimeBetweenBlinks.min = minRange;
	globs::lightGlobs.RandomRangeForTimeBetweenBlinks.max = maxRange;
	globs::lightGlobs.MaxChangeAllowed = maxChange;
	globs::lightGlobs.flags = globs::lightGlobs.flags | LIGHTEFFECTS_HASBLINK;
	return;
}



BOOL __cdecl lego::light::LightEffects_LoadFade(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	BOOL BVar2;
	int iVar3;
	float10 fVar4;
	float10 fVar5;
	float10 fVar6;
	float10 fVar7;
	float10 fVar8;
	float10 fVar9;
	float *pfVar10;
	float *pfVar11;
	float *pfVar12;
	float maxFade;
	float minFade;
	float maxTime;
	float minTime;
	float fadeMax_b;
	float fadeMax_g;
	float fadeMax_r;
	float fadeMin_b;
	float fadeMin_g;
	float fadeMin_r;
	char *stringParts [10];
	
	pfVar12 = &fadeMin_b;
	pfVar11 = &fadeMin_g;
	pfVar10 = &fadeMin_r;
	pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","FadeRGBMin",0);
	BVar2 = cfg::CFG_ReadRGBF(root,pcVar1,pfVar10,pfVar11,pfVar12);
	if (BVar2 != 0) {
		pfVar12 = &fadeMax_b;
		pfVar11 = &fadeMax_g;
		pfVar10 = &fadeMax_r;
		pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","FadeRGBMax",0);
		BVar2 = cfg::CFG_ReadRGBF(root,pcVar1,pfVar10,pfVar11,pfVar12);
		if (BVar2 != 0) {
			pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForTimeBetweenFades",0);
			pcVar1 = cfg::CFG_CopyString(root,pcVar1);
			if (pcVar1 != NULL) {
				iVar3 = util::Util_Tokenise(pcVar1,stringParts,":");
				if (iVar3 == 2) {
					fVar4 = std::atof(stringParts[0]);
					fVar5 = std::atof(stringParts[1]);
					std::free(pcVar1);
					pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForFadeTimeFade",0);
					pcVar1 = cfg::CFG_CopyString(root,pcVar1);
					if (pcVar1 == NULL) {
						return 0;
					}
					iVar3 = util::Util_Tokenise(pcVar1,stringParts,":");
					if (iVar3 == 2) {
						fVar6 = std::atof(stringParts[0]);
						fVar7 = std::atof(stringParts[1]);
						std::free(pcVar1);
						pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForHoldTimeOfFade",0);
						pcVar1 = cfg::CFG_CopyString(root,pcVar1);
						if (pcVar1 == NULL) {
							return 0;
						}
						iVar3 = util::Util_Tokenise(pcVar1,stringParts,":");
						if (iVar3 == 2) {
							fVar8 = std::atof(stringParts[0]);
							fVar9 = std::atof(stringParts[1]);
							std::free(pcVar1);
							LightEffects_SetFade
												(fadeMin_r,fadeMin_g,fadeMin_b,fadeMax_r,fadeMax_g,fadeMax_b,
												 (float)(fVar4 * (float10)25.0),(float)(fVar5 * (float10)25.0),
												 (float)(fVar6 * (float10)25.0),(float)(fVar7 * (float10)25.0),
												 (float)(fVar8 * (float10)25.0),(float)(fVar9 * (float10)25.0));
							return 1;
						}
					}
				}
										// this will free any of the 3 str mallocs above, if any numParts != 2
				std::free(pcVar1);
			}
		}
	}
	return 0;
}



void __cdecl
lego::light::LightEffects_SetFade
					(float minRed,float minGreen,float minBlue,float maxRed,float maxGreen,float maxBlue,
					float minTime,float maxTime,float minFade,float maxFade,float minHold,float maxHold)
{
	globs::lightGlobs.FadeRGBMin.red = minRed;
	globs::lightGlobs.FadeRGBMin.green = minGreen;
	globs::lightGlobs.FadeRGBMin.blue = minBlue;
	globs::lightGlobs.FadeRGBMax.red = maxRed;
	globs::lightGlobs.FadeRGBMax.green = maxGreen;
	globs::lightGlobs.FadeRGBMax.blue = maxBlue;
	globs::lightGlobs.RandomRangeForTimeBetweenFades.min = minTime;
	globs::lightGlobs.RandomRangeForTimeBetweenFades.max = maxTime;
	globs::lightGlobs.RandomRangeForFadeTimeFade.min = minFade;
	globs::lightGlobs.RandomRangeForFadeTimeFade.max = maxFade;
	globs::lightGlobs.RandomRangeForHoldTimeOfFade.min = minHold;
	globs::lightGlobs.RandomRangeForHoldTimeOfFade.max = maxHold;
	globs::lightGlobs.flags = globs::lightGlobs.flags | LIGHTEFFECTS_HASFADE;
	return;
}



BOOL __cdecl lego::light::LightEffects_LoadMove(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	int iVar2;
	float10 fVar3;
	float10 fVar4;
	float10 fVar5;
	float10 fVar6;
	float10 fVar7;
	float10 fVar8;
	float10 fVar9;
	float10 fVar10;
	float10 fVar11;
	float limitX;
	float maxDist;
	float minDist;
	float maxSpeed;
	float minSpeed;
	float maxTime;
	float minTime;
	char *stringParts [10];
	
	pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForTimeBetweenMoves",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		iVar2 = util::Util_Tokenise(pcVar1,stringParts,":");
		if (iVar2 == 2) {
			fVar3 = std::atof(stringParts[0]);
			fVar4 = std::atof(stringParts[1]);
			std::free(pcVar1);
			pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForSpeedOfMove",0);
			pcVar1 = cfg::CFG_CopyString(root,pcVar1);
			if (pcVar1 == NULL) {
				return 0;
			}
			iVar2 = util::Util_Tokenise(pcVar1,stringParts,":");
			if (iVar2 == 2) {
				fVar5 = std::atof(stringParts[0]);
				fVar6 = std::atof(stringParts[1]);
				std::free(pcVar1);
				pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","RandomRangeForDistOfMove",0);
				pcVar1 = cfg::CFG_CopyString(root,pcVar1);
				if (pcVar1 == NULL) {
					return 0;
				}
				iVar2 = util::Util_Tokenise(pcVar1,stringParts,":");
				if (iVar2 == 2) {
					fVar7 = std::atof(stringParts[0]);
					fVar8 = std::atof(stringParts[1]);
					std::free(pcVar1);
					pcVar1 = cfg::CFG_JoinPath(rootPath,"LightEffects","MoveLimit",0);
					pcVar1 = cfg::CFG_CopyString(root,pcVar1);
					if (pcVar1 == NULL) {
						return 0;
					}
					iVar2 = util::Util_Tokenise(pcVar1,stringParts,":");
					if (iVar2 == 3) {
						fVar9 = std::atof(stringParts[0]);
						fVar10 = std::atof(stringParts[1]);
						fVar11 = std::atof(stringParts[2]);
						std::free(pcVar1);
						LightEffects_SetMove
											((float)(fVar3 * (float10)25.0),(float)(fVar4 * (float10)25.0),
											 (float)(fVar5 * (float10)25.0),(float)(fVar6 * (float10)25.0),(float)fVar7,
											 (float)fVar8,(float)fVar9,(float)fVar10,(float)fVar11);
						return 1;
					}
				}
			}
		}
										// this will free any of the 4 str mallocs above, if any numParts != 2 (or
										// numParts != 3 for limit)
		std::free(pcVar1);
	}
	return 0;
}



void __cdecl
lego::light::LightEffects_SetMove
					(float minTime,float maxTime,float minSpeed,float maxSpeed,float minDist,float maxDist,
					float limitX,float limitY,float limitZ)
{
	globs::lightGlobs.RandomRangeForTimeBetweenMoves.min = minTime;
	globs::lightGlobs.RandomRangeForTimeBetweenMoves.max = maxTime;
	globs::lightGlobs.RandomRangeForSpeedOfMove.max = maxSpeed;
	globs::lightGlobs.RandomRangeForDistOfMove.min = minDist;
	globs::lightGlobs.RandomRangeForSpeedOfMove.min = minSpeed;
	globs::lightGlobs.RandomRangeForDistOfMove.max = maxDist;
										// Writes position to Vector3F globals::g_Light.resMoveLimit
	res::Container_GetPosition
						(globs::lightGlobs.resSpotlight,globs::lightGlobs.resRootLight,
						 &globs::lightGlobs.resPosition);
	globs::lightGlobs.MoveLimit.x = limitX;
	globs::lightGlobs.MoveLimit.y = limitY;
	globs::lightGlobs.MoveLimit.z = limitZ;
	globs::lightGlobs.flags = globs::lightGlobs.flags | LIGHTEFFECTS_HASMOVE;
	return;
}



// Forces the LightEffect to re-obtain the resRootSpotlight position, and also restarts movement
// effects.

void __cdecl lego::light::LightEffects_InvalidatePosition(void)
{
										// Writes position to Vector3F globals::g_Light.resMoveLimit
	res::Container_GetPosition
						(globs::lightGlobs.resSpotlight,globs::lightGlobs.resRootLight,
						 &globs::lightGlobs.resPosition);
	globs::lightGlobs.flags = globs::lightGlobs.flags & ~LIGHTEFFECTS_MOVING;
	return;
}



void __cdecl lego::light::LightEffects_Update(float elapsed)
{
	if (((globs::lightGlobs.flags & LIGHTEFFECTS_DISABLED) == LIGHTEFFECTS_NONE) &&
		 (globs::lightGlobs.resSpotlight != NULL)) {
		LightEffects_UpdateBlink(elapsed);
		LightEffects_UpdateFade(elapsed);
		LightEffects_UpdateMove(elapsed);
		LightEffects_UpdateDimmer(elapsed);
		LightEffects_UpdateResource();
	}
	return;
}



void __cdecl lego::light::LightEffects_UpdateResource(void)
{
	float b;
	float g;
	float r;
	
	r = globs::lightGlobs.currentRGB.red;
	g = globs::lightGlobs.currentRGB.green;
	b = globs::lightGlobs.currentRGB.blue;
	if (globs::lightGlobs.currentRGB.red < 0.0) {
		r = 0.0;
	}
	if ((ushort)((ushort)(r < 1.0) << 8 | (ushort)(r == 1.0) << 0xe) == 0) {
		r = 1.0;
	}
	if (globs::lightGlobs.currentRGB.green < 0.0) {
		g = 0.0;
	}
	if ((ushort)((ushort)(g < 1.0) << 8 | (ushort)(g == 1.0) << 0xe) == 0) {
		g = 1.0;
	}
	if (globs::lightGlobs.currentRGB.blue < 0.0) {
		b = 0.0;
	}
	if ((ushort)((ushort)(b < 1.0) << 8 | (ushort)(b == 1.0) << 0xe) == 0) {
		b = 1.0;
	}
	res::Container_SetColourAlpha(globs::lightGlobs.resSpotlight,r,g,b,1.0);
	return;
}



void __cdecl lego::light::LightEffects_UpdateBlink(float elapsed)
{
	float fVar1;
	float fVar2;
	bool bVar3;
	short sVar4;
	float10 fVar5;
	float local_8;
	float local_4;
	
	bVar3 = false;
	if (((byte)globs::lightGlobs.flags & LIGHTEFFECTS_HASBLINK) == 0) {
		return;
	}
	globs::lightGlobs.blinkTime = globs::lightGlobs.blinkTime - elapsed;
	if ((ushort)((ushort)(globs::lightGlobs.blinkTime < 0.0) << 8 |
							(ushort)(globs::lightGlobs.blinkTime == 0.0) << 0xe) == 0) {
		return;
	}
	fVar5 = math::Maths_RandRange
										(globs::lightGlobs.RandomRangeForTimeBetweenBlinks.min,
										 globs::lightGlobs.RandomRangeForTimeBetweenBlinks.max);
	globs::lightGlobs.blinkTime = (float)fVar5;
	sVar4 = math::Maths_Rand();
	fVar2 = (float)((int)sVar4 % 1000) * 0.001;
	elapsed = (globs::lightGlobs.BlinkRGBMax.red + globs::lightGlobs.BlinkRGBMax.red) * fVar2 -
						globs::lightGlobs.BlinkRGBMax.red;
	local_8 = (globs::lightGlobs.BlinkRGBMax.green + globs::lightGlobs.BlinkRGBMax.green) * fVar2 -
						globs::lightGlobs.BlinkRGBMax.green;
	fVar1 = elapsed + globs::lightGlobs.blinkChange;
	local_4 = (globs::lightGlobs.BlinkRGBMax.blue + globs::lightGlobs.BlinkRGBMax.blue) * fVar2 -
						globs::lightGlobs.BlinkRGBMax.blue;
	if (globs::lightGlobs.MaxChangeAllowed <= ABS(fVar1)) {
		LightEffects_UpdateBlink_FlipSign(&elapsed);
		LightEffects_UpdateBlink_FlipSign(&local_8);
		LightEffects_UpdateBlink_FlipSign(&local_4);
		fVar1 = elapsed + globs::lightGlobs.blinkChange;
		if (globs::lightGlobs.MaxChangeAllowed <= ABS(fVar1)) goto LAB_0044d4b5;
	}
	bVar3 = true;
LAB_0044d4b5:
	if (!bVar3) {
		return;
	}
	globs::lightGlobs.currentRGB.red = elapsed + globs::lightGlobs.currentRGB.red;
	globs::lightGlobs.currentRGB.green = local_8 + globs::lightGlobs.currentRGB.green;
	globs::lightGlobs.currentRGB.blue = local_4 + globs::lightGlobs.currentRGB.blue;
	globs::lightGlobs.blinkChange = fVar1;
	return;
}



// ref_value = -ref_value
// NOTES: This function is kind of dumb, the way it negates the value is different depending on the
// sign, but the end result will always be the same.

void __cdecl lego::light::LightEffects_UpdateBlink_FlipSign(float *ref_value)
{
	if (*ref_value < 0.0) {
		*ref_value = *ref_value * -1.0;
		return;
	}
	*ref_value = -*ref_value;
	return;
}



void __cdecl lego::light::LightEffects_UpdateFade(float elapsed)
{
	float fVar1;
	short sVar2;
	float10 fVar3;
	
	if ((globs::lightGlobs.flags & LIGHTEFFECTS_HASFADE) != LIGHTEFFECTS_NONE) {
		if ((globs::lightGlobs.flags & LIGHTEFFECTS_FADING) == LIGHTEFFECTS_NONE) {
			globs::lightGlobs.fadeTime = globs::lightGlobs.fadeTime - elapsed;
			if ((ushort)((ushort)(globs::lightGlobs.fadeTime < 0.0) << 8 |
									(ushort)(globs::lightGlobs.fadeTime == 0.0) << 0xe) != 0) {
				fVar3 = math::Maths_RandRange
													(globs::lightGlobs.RandomRangeForTimeBetweenFades.min,
													 globs::lightGlobs.RandomRangeForTimeBetweenFades.max);
				globs::lightGlobs.fadeTime = (float)fVar3;
				fVar3 = math::Maths_RandRange
													(globs::lightGlobs.RandomRangeForHoldTimeOfFade.min,
													 globs::lightGlobs.RandomRangeForHoldTimeOfFade.max);
				globs::lightGlobs.fadeHoldTime = (float)fVar3;
				sVar2 = math::Maths_Rand();
				globs::lightGlobs.fadePosRGB.red = 0.0;
				globs::lightGlobs.fadePosRGB.green = 0.0;
				globs::lightGlobs.fadePosRGB.blue = 0.0;
				fVar1 = (float)((int)sVar2 % 1000) * 0.001;
				globs::lightGlobs.fadeDestRGB.red =
						 ABS(globs::lightGlobs.FadeRGBMax.red - globs::lightGlobs.FadeRGBMin.red) * fVar1 +
						 globs::lightGlobs.FadeRGBMin.red;
				globs::lightGlobs.fadeDestRGB.green =
						 ABS(globs::lightGlobs.FadeRGBMax.green - globs::lightGlobs.FadeRGBMin.green) * fVar1 +
						 globs::lightGlobs.FadeRGBMin.green;
				globs::lightGlobs.fadeDestRGB.blue =
						 ABS(globs::lightGlobs.FadeRGBMax.blue - globs::lightGlobs.FadeRGBMin.blue) * fVar1 +
						 globs::lightGlobs.FadeRGBMin.blue;
				LightEffects_RandomizeFadeSpeedRGB();
				globs::lightGlobs.flags |= LIGHTEFFECTS_FADING|LIGHTEFFECTS_FADE_FORWARD;
			}
		}
		else {
			if ((globs::lightGlobs.flags & LIGHTEFFECTS_FADE_FORWARD) == LIGHTEFFECTS_NONE) {
				if ((globs::lightGlobs.flags & LIGHTEFFECTS_FADE_REVERSE) == LIGHTEFFECTS_NONE) {
					globs::lightGlobs.fadeHoldTime = globs::lightGlobs.fadeHoldTime - elapsed;
					if ((ushort)((ushort)(globs::lightGlobs.fadeHoldTime < 0.0) << 8 |
											(ushort)(globs::lightGlobs.fadeHoldTime == 0.0) << 0xe) != 0) {
						LightEffects_RandomizeFadeSpeedRGB();
						globs::lightGlobs.fadePosRGB.red = globs::lightGlobs.fadeDestRGB.red;
						globs::lightGlobs.fadePosRGB.green = globs::lightGlobs.fadeDestRGB.green;
						globs::lightGlobs.fadePosRGB.blue = globs::lightGlobs.fadeDestRGB.blue;
						globs::lightGlobs.flags = globs::lightGlobs.flags | LIGHTEFFECTS_FADE_REVERSE;
						return;
					}
				}
				else {
					fVar1 = elapsed * globs::lightGlobs.fadeSpeedRGB.red;
					globs::lightGlobs.currentRGB.red = globs::lightGlobs.currentRGB.red - fVar1;
					globs::lightGlobs.fadePosRGB.red = globs::lightGlobs.fadePosRGB.red - fVar1;
					globs::lightGlobs.currentRGB.green =
							 globs::lightGlobs.currentRGB.green - elapsed * globs::lightGlobs.fadeSpeedRGB.green;
					globs::lightGlobs.fadePosRGB.green =
							 globs::lightGlobs.fadePosRGB.green - elapsed * globs::lightGlobs.fadeSpeedRGB.green;
					globs::lightGlobs.currentRGB.blue =
							 globs::lightGlobs.currentRGB.blue - elapsed * globs::lightGlobs.fadeSpeedRGB.blue;
					globs::lightGlobs.fadePosRGB.blue =
							 globs::lightGlobs.fadePosRGB.blue - elapsed * globs::lightGlobs.fadeSpeedRGB.blue;
					if (fVar1 < 0.0) {
						if (globs::lightGlobs.fadePosRGB.red >= 0.0) {
							globs::lightGlobs.currentRGB.red =
									 globs::lightGlobs.currentRGB.red - globs::lightGlobs.fadePosRGB.red;
							globs::lightGlobs.currentRGB.green =
									 globs::lightGlobs.currentRGB.green - globs::lightGlobs.fadePosRGB.green;
							globs::lightGlobs.currentRGB.blue =
									 globs::lightGlobs.currentRGB.blue - globs::lightGlobs.fadePosRGB.blue;
							globs::lightGlobs.flags =
									 globs::lightGlobs.flags & ~(LIGHTEFFECTS_FADING|LIGHTEFFECTS_FADE_REVERSE);
							return;
						}
					}
					else {
						if ((ushort)((ushort)(globs::lightGlobs.fadePosRGB.red < 0.0) << 8 |
												(ushort)(globs::lightGlobs.fadePosRGB.red == 0.0) << 0xe) != 0) {
							globs::lightGlobs.currentRGB.red =
									 globs::lightGlobs.currentRGB.red - globs::lightGlobs.fadePosRGB.red;
							globs::lightGlobs.currentRGB.green =
									 globs::lightGlobs.currentRGB.green - globs::lightGlobs.fadePosRGB.green;
							globs::lightGlobs.currentRGB.blue =
									 globs::lightGlobs.currentRGB.blue - globs::lightGlobs.fadePosRGB.blue;
							globs::lightGlobs.flags =
									 globs::lightGlobs.flags & ~(LIGHTEFFECTS_FADING|LIGHTEFFECTS_FADE_REVERSE);
							return;
						}
					}
				}
			}
			else {
				fVar1 = elapsed * globs::lightGlobs.fadeSpeedRGB.red;
				globs::lightGlobs.currentRGB.red = fVar1 + globs::lightGlobs.currentRGB.red;
				globs::lightGlobs.currentRGB.green =
						 elapsed * globs::lightGlobs.fadeSpeedRGB.green + globs::lightGlobs.currentRGB.green;
				globs::lightGlobs.currentRGB.blue =
						 elapsed * globs::lightGlobs.fadeSpeedRGB.blue + globs::lightGlobs.currentRGB.blue;
				globs::lightGlobs.fadePosRGB.red = fVar1 + globs::lightGlobs.fadePosRGB.red;
				globs::lightGlobs.fadePosRGB.green =
						 elapsed * globs::lightGlobs.fadeSpeedRGB.green + globs::lightGlobs.fadePosRGB.green;
				globs::lightGlobs.fadePosRGB.blue =
						 elapsed * globs::lightGlobs.fadeSpeedRGB.blue + globs::lightGlobs.fadePosRGB.blue;
				if (fVar1 < 0.0) {
					if ((ushort)((ushort)(globs::lightGlobs.fadePosRGB.red < globs::lightGlobs.fadeDestRGB.red
															 ) << 8 |
											(ushort)(globs::lightGlobs.fadePosRGB.red == globs::lightGlobs.fadeDestRGB.red
															) << 0xe) != 0) {
						globs::lightGlobs.currentRGB.red =
								 (globs::lightGlobs.fadeDestRGB.red - globs::lightGlobs.fadePosRGB.red) +
								 globs::lightGlobs.currentRGB.red;
						globs::lightGlobs.currentRGB.green =
								 (globs::lightGlobs.fadeDestRGB.green - globs::lightGlobs.fadePosRGB.green) +
								 globs::lightGlobs.currentRGB.green;
						globs::lightGlobs.currentRGB.blue =
								 (globs::lightGlobs.fadeDestRGB.blue - globs::lightGlobs.fadePosRGB.blue) +
								 globs::lightGlobs.currentRGB.blue;
						globs::lightGlobs.flags = globs::lightGlobs.flags & ~LIGHTEFFECTS_FADE_FORWARD;
						return;
					}
				}
				else {
					if (globs::lightGlobs.fadePosRGB.red >= globs::lightGlobs.fadeDestRGB.red) {
						globs::lightGlobs.currentRGB.red =
								 globs::lightGlobs.currentRGB.red -
								 (globs::lightGlobs.fadePosRGB.red - globs::lightGlobs.fadeDestRGB.red);
						globs::lightGlobs.currentRGB.green =
								 globs::lightGlobs.currentRGB.green -
								 (globs::lightGlobs.fadePosRGB.green - globs::lightGlobs.fadeDestRGB.green);
						globs::lightGlobs.currentRGB.blue =
								 globs::lightGlobs.currentRGB.blue -
								 (globs::lightGlobs.fadePosRGB.blue - globs::lightGlobs.fadeDestRGB.blue);
						globs::lightGlobs.flags = globs::lightGlobs.flags & ~LIGHTEFFECTS_FADE_FORWARD;
						return;
					}
				}
			}
		}
	}
	return;
}



void __cdecl lego::light::LightEffects_RandomizeFadeSpeedRGB(void)
{
	float10 fVar1;
	
	fVar1 = math::Maths_RandRange
										(globs::lightGlobs.RandomRangeForFadeTimeFade.min,
										 globs::lightGlobs.RandomRangeForFadeTimeFade.max);
	globs::lightGlobs.fadeSpeedRGB.red = (float)((float10)globs::lightGlobs.fadeDestRGB.red / fVar1);
	globs::lightGlobs.fadeSpeedRGB.green =
			 (float)((float10)globs::lightGlobs.fadeDestRGB.green / fVar1);
	globs::lightGlobs.fadeSpeedRGB.blue = (float)((float10)globs::lightGlobs.fadeDestRGB.blue / fVar1)
	;
	return;
}



void __cdecl lego::light::LightEffects_UpdateMove(float elapsed)
{
	bool bVar1;
	float fVar2;
	BOOL BVar3;
	float10 fVar4;
	Vector3F newPosition;
	Vector3F lastPosition;
	
	bVar1 = false;
	if ((globs::lightGlobs.flags & LIGHTEFFECTS_HASMOVE) == LIGHTEFFECTS_NONE) {
		return;
	}
	if ((globs::lightGlobs.flags & LIGHTEFFECTS_MOVING) == LIGHTEFFECTS_NONE) {
		globs::lightGlobs.moveTime = globs::lightGlobs.moveTime - elapsed;
		if ((ushort)((ushort)(globs::lightGlobs.moveTime < 0.0) << 8 |
								(ushort)(globs::lightGlobs.moveTime == 0.0) << 0xe) == 0) {
			return;
		}
		fVar4 = math::Maths_RandRange
											(globs::lightGlobs.RandomRangeForTimeBetweenMoves.min,
											 globs::lightGlobs.RandomRangeForTimeBetweenMoves.max);
		globs::lightGlobs.moveTime = (float)fVar4;
		fVar4 = math::Maths_RandRange
											(globs::lightGlobs.RandomRangeForSpeedOfMove.min,
											 globs::lightGlobs.RandomRangeForSpeedOfMove.max);
		globs::lightGlobs.moveSpeed = (float)fVar4;
		fVar4 = math::Maths_RandRange
											(globs::lightGlobs.RandomRangeForDistOfMove.min,
											 globs::lightGlobs.RandomRangeForDistOfMove.max);
		globs::lightGlobs.moveDist = (float)fVar4;
										// Randomize + Normalize vector, multiplied by speed.
										// AKA: speed in a random 3D direction.
		math::Maths_Vector3DRandom(&globs::lightGlobs.vectorMove);
		fVar2 = 1.0 / SQRT(globs::lightGlobs.vectorMove.z * globs::lightGlobs.vectorMove.z +
											 globs::lightGlobs.vectorMove.y * globs::lightGlobs.vectorMove.y +
											 globs::lightGlobs.vectorMove.x * globs::lightGlobs.vectorMove.x);
		globs::lightGlobs.vectorMove.x =
				 fVar2 * globs::lightGlobs.vectorMove.x * globs::lightGlobs.moveSpeed;
		globs::lightGlobs.vectorMove.y =
				 fVar2 * globs::lightGlobs.vectorMove.y * globs::lightGlobs.moveSpeed;
		globs::lightGlobs.vectorMove.z =
				 fVar2 * globs::lightGlobs.vectorMove.z * globs::lightGlobs.moveSpeed;
		globs::lightGlobs.flags = globs::lightGlobs.flags | LIGHTEFFECTS_MOVING;
		return;
	}
	res::Container_GetPosition
						(globs::lightGlobs.resSpotlight,globs::lightGlobs.resRootLight,&lastPosition);
	newPosition.x = lastPosition.x + globs::lightGlobs.vectorMove.x;
	newPosition.y = lastPosition.y + globs::lightGlobs.vectorMove.y;
	newPosition.z = lastPosition.z + globs::lightGlobs.vectorMove.z;
	BVar3 = LightEffects_CheckMoveLimit(&newPosition);
	if (BVar3 == 0) {
										// This is the same deal as the `LightEffects_UpdateBlink_FlipSign(float*)`
										// tuple seen in UpdateBlink
										//  it's just that blink doesn't have extra math involved.
		newPosition.x = lastPosition.x - globs::lightGlobs.vectorMove.x;
		newPosition.y = lastPosition.y - globs::lightGlobs.vectorMove.y;
		newPosition.z = lastPosition.z - globs::lightGlobs.vectorMove.z;
		BVar3 = LightEffects_CheckMoveLimit(&newPosition);
		if (BVar3 == 0) goto LAB_0044dae5;
	}
	bVar1 = true;
LAB_0044dae5:
	if (!bVar1) {
		globs::lightGlobs.flags = globs::lightGlobs.flags & ~LIGHTEFFECTS_MOVING;
		return;
	}
	res::Container_SetPosition
						(globs::lightGlobs.resSpotlight,globs::lightGlobs.resRootLight,newPosition.x,
						 newPosition.y,newPosition.z);
	globs::lightGlobs.moveDist = globs::lightGlobs.moveDist - globs::lightGlobs.moveSpeed;
	if ((ushort)((ushort)(globs::lightGlobs.moveDist < 0.0) << 8 |
							(ushort)(globs::lightGlobs.moveDist == 0.0) << 0xe) == 0) {
		return;
	}
	globs::lightGlobs.flags = globs::lightGlobs.flags & ~LIGHTEFFECTS_MOVING;
	return;
}



BOOL __cdecl lego::light::LightEffects_CheckMoveLimit(Vector3F *vector)
{
	float fVar1;
	
	fVar1 = ABS(vector->x - globs::lightGlobs.resPosition.x);
	if ((ushort)((ushort)(fVar1 < globs::lightGlobs.MoveLimit.x) << 8 |
							(ushort)(fVar1 == globs::lightGlobs.MoveLimit.x) << 0xe) == 0) {
		return 0;
	}
	fVar1 = ABS(vector->y - globs::lightGlobs.resPosition.y);
	if ((ushort)((ushort)(fVar1 < globs::lightGlobs.MoveLimit.y) << 8 |
							(ushort)(fVar1 == globs::lightGlobs.MoveLimit.y) << 0xe) == 0) {
		return 0;
	}
	fVar1 = ABS(vector->z - globs::lightGlobs.resPosition.z);
	if ((ushort)((ushort)(fVar1 < globs::lightGlobs.MoveLimit.z) << 8 |
							(ushort)(fVar1 == globs::lightGlobs.MoveLimit.z) << 0xe) == 0) {
		return 0;
	}
	return 1;
}



void __cdecl lego::light::LightEffects_SetDimmerMode(BOOL isDimoutMode)
{
	if (isDimoutMode != 0) {
		globs::lightGlobs.flags =
				 globs::lightGlobs.flags & ~LIGHTEFFECTS_DIMIN_DONE | LIGHTEFFECTS_DIMOUT;
		return;
	}
	globs::lightGlobs.flags =
			 globs::lightGlobs.flags & ~(LIGHTEFFECTS_DIMOUT|LIGHTEFFECTS_DIMOUT_DONE);
	return;
}



void __cdecl lego::light::LightEffects_UpdateDimmer(float elapsed)
{
	float fVar1;
	
	if ((globs::lightGlobs.flags & LIGHTEFFECTS_DIMOUT) == LIGHTEFFECTS_NONE) {
		if ((globs::lightGlobs.flags & LIGHTEFFECTS_DIMIN_DONE) == LIGHTEFFECTS_NONE) {
			fVar1 = elapsed * 0.1;
			globs::lightGlobs.currentRGB.red = fVar1 + globs::lightGlobs.currentRGB.red;
			globs::lightGlobs.currentRGB.green = fVar1 + globs::lightGlobs.currentRGB.green;
			globs::lightGlobs.currentRGB.blue = fVar1 + globs::lightGlobs.currentRGB.blue;
			if (globs::lightGlobs.initialRGB.red <= globs::lightGlobs.currentRGB.red) {
				globs::lightGlobs.flags |= LIGHTEFFECTS_DIMIN_DONE;
										// Uhhh... assigning blue to red??? (this has to be a bug)
										// Actually... why is this only assigning red and no other colors???
				globs::lightGlobs.currentRGB.red = globs::lightGlobs.initialRGB.blue;
			}
		}
	}
	else {
		if ((globs::lightGlobs.flags & LIGHTEFFECTS_DIMOUT_DONE) != LIGHTEFFECTS_NONE) {
			globs::lightGlobs.currentRGB.red = 0.0;
			globs::lightGlobs.currentRGB.green = 0.0;
			globs::lightGlobs.currentRGB.blue = 0.0;
			return;
		}
		fVar1 = elapsed * 0.1;
		globs::lightGlobs.currentRGB.red = globs::lightGlobs.currentRGB.red - fVar1;
		globs::lightGlobs.currentRGB.green = globs::lightGlobs.currentRGB.green - fVar1;
		globs::lightGlobs.currentRGB.blue = globs::lightGlobs.currentRGB.blue - fVar1;
		if ((ushort)((ushort)(globs::lightGlobs.currentRGB.red < 0.0) << 8 |
								(ushort)(globs::lightGlobs.currentRGB.red == 0.0) << 0xe) != 0) {
			globs::lightGlobs.currentRGB.red = 0.0;
			globs::lightGlobs.flags = globs::lightGlobs.flags | LIGHTEFFECTS_DIMOUT_DONE;
			return;
		}
	}
	return;
}



void __cdecl
lego::front::Loader_Initialise
					(char *loadScreenName,char *shutdownScreenName,ImageFont *font5HI,char *profileName,
					Direction progressDirection,char *progressBarName,Rect2F *progressWindow,char *loadingText
					)
{
	char cVar1;
	char *pcVar2;
	undefined4 *puVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	File *f;
	LoaderSection *pLVar7;
	undefined4 *puVar8;
	Loader_Globs *pLVar9;
	char *pcVar10;
	char *stringParts [10];
	char buff [256];
	
	f = NULL;
	pLVar9 = &globs::loaderGlobs;
	for (iVar4 = 0xa4; iVar4 != 0; iVar4 += -1) {
		pLVar9->LoadScreen = NULL;
		pLVar9 = (Loader_Globs *)&pLVar9->font;
	}
	globs::loaderGlobs.LoadScreen = lego::image::Image_LoadBMPScaled(loadScreenName,0,0);
	globs::loaderGlobs.ShutdownScreen = lego::image::Image_LoadBMPScaled(shutdownScreenName,0,0);
	globs::loaderGlobs.font = font5HI;
	globs::loaderGlobs.current = NULL;
	globs::loaderGlobs.ProgressBar = lego::image::Image_LoadBMPScaled(progressBarName,0,0);
	globs::loaderGlobs.ProgressWindow.x = progressWindow->x;
	globs::loaderGlobs.ProgressWindow.y = progressWindow->y;
	globs::loaderGlobs.ProgressWindow.width = progressWindow->width;
	globs::loaderGlobs.ProgressWindow.height = progressWindow->height;
	globs::loaderGlobs.ProgressDirection = progressDirection;
	if (loadingText == NULL) {
		globs::loaderGlobs.LoadingText = NULL;
	}
	else {
		pcVar2 = std::_strdup(loadingText);
		cVar1 = *pcVar2;
		globs::loaderGlobs.LoadingText = pcVar2;
		while (cVar1 != '\0') {
			if (cVar1 == '_') {
				*pcVar2 = ' ';
			}
			pcVar10 = pcVar2 + 1;
			pcVar2 = pcVar2 + 1;
			cVar1 = *pcVar10;
		}
		lego::image::Font_GetStringInfo(font5HI,&globs::loaderGlobs.LoadingWidth,NULL,"%s",loadingText);
	}
	if (profileName != NULL) {
		f = lego::file::File_Open(profileName,"r");
	}
	pLVar7 = globs::loaderGlobs.sectionList;
	do {
		if (((f == NULL) || (pcVar2 = lego::file::File_GetS(buff,0x100,f), pcVar2 == NULL)) ||
			 (iVar4 = util::Util_Tokenise(buff,stringParts,"="), iVar4 != 2)) {
			pLVar7->name = NULL;
		}
		else {
			uVar5 = 0xffffffff;
			pcVar2 = stringParts[0];
			do {
				if (uVar5 == 0) break;
				uVar5 -= 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar2 + 1;
			} while (cVar1 != '\0');
			puVar3 = (undefined4 *)std::malloc(~uVar5);
			uVar5 = 0xffffffff;
			pLVar7->name = (char *)puVar3;
			pcVar2 = stringParts[0];
			do {
				pcVar10 = pcVar2;
				if (uVar5 == 0) break;
				uVar5 -= 1;
				pcVar10 = pcVar2 + 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar10;
			} while (cVar1 != '\0');
			uVar5 = ~uVar5;
			puVar8 = (undefined4 *)(pcVar10 + -uVar5);
			for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
				*puVar3 = *puVar8;
				puVar8 = puVar8 + 1;
				puVar3 = puVar3 + 1;
			}
			for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
				*(undefined *)puVar3 = *(undefined *)puVar8;
				puVar8 = (undefined4 *)((int)puVar8 + 1);
				puVar3 = (undefined4 *)((int)puVar3 + 1);
			}
			uVar5 = std::atoi(stringParts[1]);
			pLVar7->totalSize = uVar5;
			pLVar7->currentSize = 0;
		}
		pLVar7 = pLVar7 + 1;
		if ((LoaderSection *)((int)&globs::loaderGlobs.sectionList[0x31].totalSize + 3) < pLVar7) {
			if (f != NULL) {
				lego::file::File_Close(f);
			}
			lego::file::File_SetLoadCallback(Loader_FileLoadCallback,NULL);
			return;
		}
	} while( true );
}



void __cdecl lego::front::Loader_Shutdown(char *filename)
{
	File *f;
	uint uVar1;
	LoaderSection *pLVar2;
	
	if (filename == NULL) {
		f = NULL;
	}
	else {
		f = lego::file::File_Open(filename,"w");
	}
	pLVar2 = globs::loaderGlobs.sectionList;
	do {
		if (pLVar2->name != NULL) {
			uVar1 = pLVar2->currentSize;
			if (uVar1 == 0) {
				uVar1 = pLVar2->totalSize;
			}
			if (f != NULL) {
				lego::file::File_PrintF(f,"%s%s%i\n",pLVar2->name,"=",uVar1);
			}
			std::free(pLVar2->name);
		}
		pLVar2 = pLVar2 + 1;
	} while (pLVar2 < (LoaderSection *)&globs::loaderGlobs.current);
	if (f != NULL) {
		lego::file::File_Close(f);
	}
	lego::image::Image_Remove(globs::loaderGlobs.LoadScreen);
	if (globs::loaderGlobs.ShutdownScreen != NULL) {
		lego::image::Image_Remove(globs::loaderGlobs.ShutdownScreen);
	}
	return;
}



// Pass NULL to disable progress bar
// Section is either "Game Data" or "Levels::*".
//  But this is not hardcoded by the Loader module.

void __cdecl lego::front::Loader_display_loading_bar(char *section)
{
	char cVar1;
	int iVar2;
	undefined4 *puVar3;
	uint uVar4;
	uint uVar5;
	LoaderSection *pLVar6;
	LoaderSection *pLVar7;
	LoaderSection *pLVar8;
	undefined4 *puVar9;
	int iVar10;
	char *pcVar11;
	
	if (section == NULL) {
										// &= ~LOADER_FLAG_ENABLED; (~0x1)
		globs::loaderGlobs.flags = globs::loaderGlobs.flags & 0xfffffffe;
		return;
	}
	iVar10 = 0;
	pLVar8 = globs::loaderGlobs.sectionList;
	pLVar6 = NULL;
	do {
		pLVar7 = pLVar8;
		if ((pLVar8->name != NULL) &&
			 (iVar2 = std::_stricmp(pLVar8->name,section), pLVar7 = pLVar6, iVar2 == 0)) {
			globs::loaderGlobs.current = globs::loaderGlobs.sectionList + iVar10;
			globs::loaderGlobs.sectionList[iVar10].currentSize = 0;
			break;
		}
		pLVar8 = pLVar8 + 1;
		iVar10 += 1;
		pLVar6 = pLVar7;
	} while (pLVar8 < (LoaderSection *)&globs::loaderGlobs.current);
	if ((iVar10 == 50) && (pLVar7 != NULL)) {
		uVar4 = 0xffffffff;
		pcVar11 = section;
		do {
			if (uVar4 == 0) break;
			uVar4 -= 1;
			cVar1 = *pcVar11;
			pcVar11 = pcVar11 + 1;
		} while (cVar1 != '\0');
		puVar3 = (undefined4 *)std::malloc(~uVar4);
		uVar4 = 0xffffffff;
		pLVar7->name = (char *)puVar3;
		do {
			pcVar11 = section;
			if (uVar4 == 0) break;
			uVar4 -= 1;
			pcVar11 = section + 1;
			cVar1 = *section;
			section = pcVar11;
		} while (cVar1 != '\0');
		uVar4 = ~uVar4;
		puVar9 = (undefined4 *)(pcVar11 + -uVar4);
		for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
			*puVar3 = *puVar9;
			puVar9 = puVar9 + 1;
			puVar3 = puVar3 + 1;
		}
		for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
			*(undefined *)puVar3 = *(undefined *)puVar9;
			puVar9 = (undefined4 *)((int)puVar9 + 1);
			puVar3 = (undefined4 *)((int)puVar3 + 1);
		}
		pLVar7->currentSize = 0;
		pLVar7->totalSize = 0;
		globs::loaderGlobs.current = pLVar7;
	}
	globs::loaderGlobs.flags |= LOADER_FLAG_ENABLED;
	globs::loaderGlobs.progressLast = -1.0;
	Loader_FileLoadCallback(NULL,0,NULL);
	return;
}



void __cdecl lego::front::Loader_FileLoadCallback(char *filename,uint fileSize,void *data)
{
	float fVar1;
	int y;
	longlong lVar2;
	char *msg;
	char *pcVar3;
	Size2F barSize;
	Point2F barPosition;
	
	if (((byte)globs::loaderGlobs.flags & LOADER_FLAG_ENABLED) != 0) {
		if (((globs::loaderGlobs.current == NULL) ||
				((globs::loaderGlobs.current)->currentSize =
							(globs::loaderGlobs.current)->currentSize + fileSize,
				globs::loaderGlobs.current == NULL)) || ((globs::loaderGlobs.current)->totalSize == 0)) {
			fileSize = 0;
		}
		else {
			fileSize = (uint)((float)(ulonglong)(globs::loaderGlobs.current)->currentSize /
											 (float)(globs::loaderGlobs.current)->totalSize);
		}
										// // minimum increase since last update of progress bar
										// if (floatVal > (loaderGlobs.progressLast - 0.002f))
		if ((ushort)((ushort)((float)fileSize < globs::loaderGlobs.progressLast - -0.002) << 8 |
								(ushort)((float)fileSize == globs::loaderGlobs.progressLast - -0.002) << 0xe) == 0)
		{
			barPosition.y = globs::loaderGlobs.ProgressWindow.y;
			barPosition.x = globs::loaderGlobs.ProgressWindow.x;
			barSize.width = globs::loaderGlobs.ProgressWindow.width;
			barSize.height = globs::loaderGlobs.ProgressWindow.height;
			lego::image::Image_DisplayScaled(globs::loaderGlobs.LoadScreen,NULL,NULL,NULL);
										// if (floatVal > 1.0f) floatVal = 1.0f;
			if ((ushort)((ushort)((float)fileSize < 1.0) << 8 | (ushort)((float)fileSize == 1.0) << 0xe)
					== 0) {
				fileSize = 1065353216;
			}
			switch(globs::loaderGlobs.ProgressDirection) {
			case DIRECTION_UP:
				fVar1 = barSize.height + barPosition.y;
				barPosition.y = fVar1 - barSize.height * (float)fileSize;
				barSize.height = fVar1 - barPosition.y;
				break;
			case DIRECTION_RIGHT:
				barSize.width = barSize.width * (float)fileSize;
				break;
			case DIRECTION_DOWN:
				barSize.height = barSize.height * (float)fileSize;
				break;
			case DIRECTION_LEFT:
				fVar1 = barSize.width + barPosition.x;
				barPosition.x = fVar1 - barSize.width * (float)fileSize;
				barSize.width = fVar1 - barPosition.x;
			}
			if (globs::loaderGlobs.ProgressBar != NULL) {
				lego::image::Image_DisplayScaled(globs::loaderGlobs.ProgressBar,NULL,&barPosition,&barSize);
			}
			if (globs::loaderGlobs.LoadingText != NULL) {
				msg = "%s";
				pcVar3 = globs::loaderGlobs.LoadingText;
				lVar2 = __ftol((float10)globs::loaderGlobs.ProgressWindow.y);
				y = (int)lVar2 + -1;
				lVar2 = __ftol((float10)globs::loaderGlobs.ProgressWindow.width * (float10)0.5 +
											 (float10)globs::loaderGlobs.ProgressWindow.x);
				lego::image::Font_PrintF
									(globs::loaderGlobs.font,(int)lVar2 - (globs::loaderGlobs.LoadingWidth >> 1),y,msg
									 ,pcVar3);
			}
			main::Main_LoopUpdate(0);
			globs::loaderGlobs.progressLast = (float)fileSize;
		}
	}
	return;
}



void __cdecl lego::front::Loader_display_shutdown(void)
{
	if (globs::loaderGlobs.ShutdownScreen != NULL) {
		lego::image::Image_DisplayScaled(globs::loaderGlobs.ShutdownScreen,NULL,NULL,NULL);
		ddraw::DirectDraw_Flip();
		return;
	}
	return;
}



SurfaceMap * __cdecl
lego::game::Map3D_LoadSurfaceMap
					(Container *in_resData,char *filename,float blockSize,float roughLevel)
{
	int *out_height;
	Size2I *out_width;
	SurfaceMapStruct_28 *pSVar1;
	Point2F *pPVar2;
	ushort uVar3;
	MapFileInfo *mapFileInfo;
	SurfaceMap *surfMap;
	uint uVar4;
	IDirect3DRMMaterial2 *pIVar5;
	SurfaceMapStruct38 *pSVar6;
	Container *pCVar7;
	SurfaceMapStruct_28 *pSVar8;
	D3DRMGroupIndex group;
	int iVar9;
	uint uVar10;
	uint uVar11;
	SurfaceMapStruct38 *pSVar12;
	undefined4 *puVar13;
	uint uVar14;
	float10 fVar15;
	float10 fVar16;
	uint local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	uVar11 = 0;
	mapFileInfo = (MapFileInfo *)lego::file::File_LoadBinary(filename,NULL);
	if (mapFileInfo != NULL) {
		surfMap = (SurfaceMap *)std::malloc(0x73d4);
		if (surfMap != NULL) {
			out_height = &(surfMap->dimensions).height;
			out_width = &surfMap->dimensions;
			surfMap->BlockSize = blockSize;
			surfMap->RoughLevel = roughLevel;
			MapFile_GetDimensions(mapFileInfo,(int *)out_width,out_height);
			uVar4 = out_width->width - 1;
			uVar10 = *out_height - 1;
			(surfMap->smallDimensions).width = uVar4;
			(surfMap->smallDimensions).height = uVar10;
			(surfMap->blockDimensions_neg).width = -((float)(ulonglong)uVar4 * blockSize * 0.5);
			surfMap->field_2c = 0;
			(surfMap->blockDimensions_neg).height = (float)(ulonglong)uVar10 * blockSize * 0.5;
			puVar13 = (undefined4 *)surfMap->texsNum;
			for (iVar9 = 0x20; iVar9 != 0; iVar9 += -1) {
				*puVar13 = 0;
				puVar13 = puVar13 + 1;
			}
			surfMap->flags_73d0 = SURFMAP_NONE;
			surfMap->smallCoordsNum = 0;
			surfMap->largeCoordsNum = 0;
			surfMap->float_20 = 0.0;
			pIVar5 = res::Material_Create(1.0,1.0,1.0,0.0,0.0,0.0,0.0);
			pSVar6 = surfMap->table38_719c;
			surfMap->rmMaterial2 = pIVar5;
			pSVar12 = pSVar6;
			for (iVar9 = 0x8c; iVar9 != 0; iVar9 += -1) {
				pSVar12->groupID = D3DRMGROUP_0;
				pSVar12 = (SurfaceMapStruct38 *)&pSVar12->timer;
			}
			puVar13 = surfMap->flat_40b4;
			for (iVar9 = 0x80; iVar9 != 0; iVar9 += -1) {
				*puVar13 = 0;
				puVar13 = puVar13 + 1;
			}
			iVar9 = 10;
			do {
				pSVar6->groupID = D3DRMGROUP_ALLGROUPS;
				pSVar6 = pSVar6 + 1;
				iVar9 += -1;
			} while (iVar9 != 0);
			pCVar7 = res::Container_MakeMesh2(in_resData,CONTAINER_MESHTYPE_TRANSPARENT);
			surfMap->resMesh_73cc = pCVar7;
			pCVar7 = res::Container_MakeMesh2(in_resData,CONTAINER_MESHTYPE_IMMEDIATE);
			surfMap->resMesh_24 = pCVar7;
			if (pCVar7 != NULL) {
				pSVar8 = (SurfaceMapStruct_28 *)
								 std::malloc(out_width->width * (surfMap->dimensions).height * 0x28);
				surfMap->grid28_28 = pSVar8;
				if (pSVar8 != NULL) {
					local_18 = 0;
					local_14 = 1;
					local_10 = 3;
					local_c = 1;
					local_8 = 2;
					local_4 = 3;
					if ((surfMap->smallDimensions).width * (surfMap->smallDimensions).height != 0) {
						do {
							group = res::Container_Mesh_AddGroup(surfMap->resMesh_24,4,2,3,&local_18);
							res::Container_Mesh_HideGroup(surfMap->resMesh_24,group,TRUE);
							res::Container_Mesh_SetQuality(surfMap->resMesh_24,group,QUALITY_GOURAUD);
							uVar11 += 1;
						} while (uVar11 < (uint)((surfMap->smallDimensions).width *
																		(surfMap->smallDimensions).height));
					}
					uVar11 = 0;
					if ((surfMap->dimensions).height != 0) {
						do {
							uVar10 = out_width->width;
							uVar4 = 0;
							if (uVar10 != 0) {
								do {
									surfMap->grid28_28[uVar11 * uVar10 + uVar4].byteflags_19 = 0x60;
									surfMap->grid28_28[uVar11 * out_width->width + uVar4].texture = TEXTURE_GROUND;
									iVar9 = out_width->width;
									pSVar8 = surfMap->grid28_28;
									uVar3 = MapFile_GetBlock(mapFileInfo,uVar4,uVar11,iVar9);
									pSVar8[uVar11 * iVar9 + uVar4].byte_1a = (SurfaceMapStruct28Flags)uVar3;
									pPVar2 = &surfMap->grid28_28[uVar11 * out_width->width + uVar4].textuv_1c;
									fVar15 = math::Maths_RandRange(0.0,1.0);
									pPVar2->x = (float)fVar15;
									fVar15 = math::Maths_RandRange(0.0,1.0);
									fVar16 = (float10)1.0 /
													 SQRT((float10)pPVar2->x * (float10)pPVar2->x + fVar15 * fVar15);
									pPVar2->x = (float)(fVar16 * (float10)pPVar2->x);
									pPVar2->y = (float)(fVar16 * fVar15);
									iVar9 = uVar11 * out_width->width + uVar4;
									pPVar2 = &surfMap->grid28_28[iVar9].textuv_1c;
									pPVar2->x = surfMap->grid28_28[iVar9].textuv_1c.x * 0.3;
									pPVar2->y = pPVar2->y * 0.3;
									iVar9 = uVar11 * out_width->width + uVar4;
									uVar4 += 1;
									surfMap->grid28_28[iVar9].highlight = 0;
									uVar10 = out_width->width;
								} while (uVar4 < uVar10);
							}
							uVar11 += 1;
						} while (uVar11 < (uint)(surfMap->dimensions).height);
					}
					Map3D_LoadRough_FUN_0044e790(surfMap);
					filename = NULL;
					if ((surfMap->smallDimensions).height != 0) {
						do {
							blockSize = 0.0;
							if ((surfMap->smallDimensions).width != 0) {
								do {
									pSVar8 = surfMap->grid28_28 + (int)filename * out_width->width + (int)blockSize;
									pSVar1 = surfMap->grid28_28 +
													 (int)(filename + 1) * out_width->width + (int)blockSize;
									uVar11 = (uint)pSVar8->byte_1a - (uint)pSVar1[1].byte_1a;
									uVar14 = (uint)pSVar8[1].byte_1a - (uint)pSVar1->byte_1a;
									uVar10 = (int)uVar11 >> 0x1f;
									uVar4 = (int)uVar14 >> 0x1f;
									if ((uVar11 ^ uVar10) - uVar10 < (uVar14 ^ uVar4) - uVar4) {
										Map3D_FUN_0044f0b0(surfMap,(uint)blockSize,(uint)filename,TRUE);
									}
									else {
										Map3D_Block_InitPlaneNormals(surfMap,(uint)blockSize,(uint)filename);
									}
									blockSize = (float)((int)blockSize + 1);
								} while ((uint)blockSize < (uint)(surfMap->smallDimensions).width);
							}
							filename = filename + 1;
						} while (filename < (char *)(surfMap->smallDimensions).height);
					}
					std::free(mapFileInfo);
					return surfMap;
				}
				res::Container_Remove(surfMap->resMesh_24);
			}
			std::free(surfMap);
		}
		std::free(mapFileInfo);
	}
	return NULL;
}



void __cdecl lego::game::Map3D_LoadRough_FUN_0044e790(SurfaceMap *surfMap)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	int iVar6;
	float *pfVar7;
	float *pfVar8;
	float10 fVar9;
	float10 extraout_ST0;
	longlong lVar10;
	longlong lVar11;
	uint local_d8;
	uint local_d4;
	int local_d0;
	float local_b0 [5];
	undefined4 local_9c;
	undefined4 local_98;
	undefined4 local_94;
	D3DRMVertex local_90 [4];
	
	local_b0[0] = 0.0;
	fVar5 = surfMap->RoughLevel;
	local_b0[1] = 0.0;
	local_b0[2] = 1.0;
	local_b0[3] = 0.0;
	local_b0[4] = 1.0;
	local_9c = 0x3f800000;
	local_98 = 0;
	local_94 = 0x3f800000;
	local_d8 = 0;
	if ((surfMap->smallDimensions).height != 0) {
		do {
			local_d4 = 0;
			if ((surfMap->smallDimensions).width != 0) {
				do {
					pfVar7 = local_b0;
					fVar9 = (float10)(ulonglong)local_d4;
					pfVar8 = &local_90[0].position.y;
					local_d0 = 4;
					do {
						fVar1 = pfVar7[1];
						fVar2 = surfMap->BlockSize;
						fVar3 = pfVar7[1];
						fVar4 = (surfMap->blockDimensions_neg).height;
						pfVar8[-1] = (float)((fVar9 + (float10)*pfVar7) * (float10)surfMap->BlockSize +
																(float10)(surfMap->blockDimensions_neg).width);
						*pfVar8 = fVar4 - (fVar1 + (float)(ulonglong)local_d8) * fVar2;
						lVar10 = __ftol((float10)fVar3);
						iVar6 = (surfMap->dimensions).width;
						lVar11 = __ftol((float10)*pfVar7);
						fVar2 = -((float)(uint)surfMap->grid28_28
																	 [(local_d8 + (int)lVar10) * iVar6 + local_d4 + (int)lVar11].
																	 byte_1a * fVar5);
						fVar1 = surfMap->float_20;
						pfVar8[1] = fVar2;
						if (fVar2 < fVar1) {
							surfMap->float_20 = fVar2;
						}
						pfVar7 = pfVar7 + 2;
						pfVar8 = pfVar8 + 9;
						local_d0 += -1;
						fVar9 = extraout_ST0;
					} while (local_d0 != 0);
					res::Container_Mesh_SetVertices
										(surfMap->resMesh_24,local_d8 * (surfMap->smallDimensions).width + local_d4,0,4,
										 local_90);
					local_d4 += 1;
				} while (local_d4 < (uint)(surfMap->smallDimensions).width);
			}
			local_d8 += 1;
		} while (local_d8 < (uint)(surfMap->smallDimensions).height);
	}
	return;
}



void __cdecl lego::game::Map3D_Free(SurfaceMap *surfMap)
{
	res::Container_Remove(surfMap->resMesh_24);
	res::Container_Remove(surfMap->resMesh_73cc);
	std::free(surfMap->grid28_28);
	std::free(surfMap);
	return;
}



void __cdecl lego::game::Map3D_SetArray40B4_IndexToTrue(SurfaceMap *surfMap,uint index)
{
	surfMap->flat_40b4[index & 0xff] = 1;
	return;
}



void __cdecl
lego::game::Map3D_FadeInBlock(SurfaceMap *surfMap,int x,int y,uint param_4,uint param_5)
{
	SurfaceTexture SVar1;
	uint uVar2;
	D3DRMGroupIndex DVar3;
	float *pfVar4;
	Container_Texture *ref_itext;
	float *pfVar5;
	int iVar6;
	SurfaceMapStruct38 *pSVar7;
	uint local_a8;
	undefined4 local_a4;
	undefined4 local_a0;
	undefined4 local_9c;
	undefined4 local_98;
	undefined4 local_94;
	D3DRMVertex local_90 [4];
	
	local_a4 = 1;
	local_9c = 1;
	iVar6 = (surfMap->smallDimensions).width;
	local_a8 = 0;
	local_a0 = 3;
	local_98 = 2;
	local_94 = 3;
	SVar1 = surfMap->grid28_28[y * (surfMap->dimensions).width + x].texture;
	if ((SVar1 != (SurfaceTexture)param_4) && (surfMap->flat_40b4[SVar1] == 0)) {
		uVar2 = 0;
		pSVar7 = surfMap->table38_719c;
		do {
			if ((*(byte *)&pSVar7->flags & 1) == 0) {
				if (pSVar7->groupID == D3DRMGROUP_ALLGROUPS) {
					DVar3 = res::Container_Mesh_AddGroup(surfMap->resMesh_73cc,4,2,3,&local_a8);
					pSVar7->groupID = DVar3;
				}
				else {
					res::Container_Mesh_HideGroup(surfMap->resMesh_73cc,pSVar7->groupID,0);
				}
				res::Container_Mesh_GetVertices(surfMap->resMesh_24,y * iVar6 + x,0,4,local_90);
				pfVar5 = &pSVar7->pointfsTable_10[0].y;
				iVar6 = 4;
				pfVar4 = &local_90[0].tv;
				do {
					pfVar5[-1] = pfVar4[-1];
					*pfVar5 = *pfVar4;
					pfVar5 = pfVar5 + 2;
					iVar6 += -1;
					pfVar4 = pfVar4 + 9;
				} while (iVar6 != 0);
				ref_itext = res::DynamicPM_SurfaceTextureGrid_GetTexture
															((SurfaceTextureGrid *)surfMap->field_2c,
															 surfMap->grid28_28[y * (surfMap->dimensions).width + x].texture);
				res::Container_Mesh_SetTexture(surfMap->resMesh_73cc,pSVar7->groupID,ref_itext);
				uVar2 = pSVar7->flags;
				(pSVar7->blockPos).x = x;
				(pSVar7->blockPos).y = y;
				pSVar7->timer = 0.05;
				pSVar7->flags = uVar2 | 1;
				break;
			}
			uVar2 += 1;
			pSVar7 = pSVar7 + 1;
		} while (uVar2 < 10);
	}
	Map3D_UpdateBlockVisual(surfMap,x,y,param_4,param_5);
	return;
}



BOOL __cdecl lego::game::Map3D_IsBlockMeshHidden(SurfaceMap *surfMap,int bx,int by)
{
	BOOL BVar1;
	
	BVar1 = res::Container_Mesh_IsGroupHidden
										(surfMap->resMesh_24,(surfMap->smallDimensions).width * by + bx);
	return BVar1;
}



void __cdecl lego::game::Map3D_UpdateAll_BlockTexturesAndVertices(SurfaceMap *surfMap)
{
	uint y;
	uint x;
	
	y = 0;
	if ((surfMap->dimensions).height != 0) {
		do {
			x = 0;
			if ((surfMap->dimensions).width != 0) {
				do {
					Map3D_Block_UpdateTextureAndVertices(surfMap,x,y);
					x += 1;
				} while (x < (uint)(surfMap->dimensions).width);
			}
			y += 1;
		} while (y < (uint)(surfMap->dimensions).height);
	}
	return;
}



BOOL __cdecl
lego::game::Map3D_FUN_0044eb80
					(SurfaceMap *surfMap,uint *param_2,uint param_3,float buildTolerance,
					float buildMaxVariation)
{
	bool bVar1;
	int *piVar2;
	uint *puVar3;
	uint uVar4;
	float *pfVar5;
	float local_9c;
	float local_98;
	int local_90;
	uint local_8c;
	int local_80 [5];
	undefined4 local_6c;
	undefined4 local_68;
	undefined4 local_64;
	int local_60 [5];
	undefined4 local_4c;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40;
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	Vector3F local_30 [4];
	
	local_4c = 3;
	local_3c = 3;
	local_34 = 3;
	local_80[0] = 0;
	local_80[1] = 0;
	local_80[2] = 1;
	local_80[3] = 0;
	local_80[4] = 1;
	local_6c = 1;
	local_68 = 0;
	local_64 = 1;
	local_60[0] = 0;
	local_60[1] = 1;
	local_60[2] = 0;
	local_60[3] = 2;
	local_60[4] = 0;
	local_48 = 1;
	local_44 = 2;
	local_40 = 1;
	local_38 = 2;
	bVar1 = false;
	local_98 = 10000.0;
	local_9c = -10000.0;
	local_8c = 0;
	if (param_3 != 0) {
		puVar3 = param_2 + 2;
		do {
			if (((local_8c == param_3 - 1) || (*param_2 != *puVar3)) || (param_2[1] != puVar3[1])) {
				Map3D_GetBlockVertexPositions(surfMap,*param_2,param_2[1],local_30);
				uVar4 = 0;
				piVar2 = local_60 + 1;
				do {
					if (buildMaxVariation < ABS(local_30[piVar2[-1]].z - local_30[*piVar2].z)) {
						return 0;
					}
					uVar4 += 1;
					piVar2 = piVar2 + 2;
				} while (uVar4 < 6);
				pfVar5 = &local_30[0].z;
				piVar2 = local_80;
				local_90 = 4;
				do {
					if ((surfMap->grid28_28
							 [(piVar2[1] + param_2[1]) * (surfMap->dimensions).width + *piVar2 + *param_2].
							 byteflags_19 & 8) != 0) {
						if (*pfVar5 < local_98) {
							local_98 = *pfVar5;
						}
						if ((ushort)((ushort)(*pfVar5 < local_9c) << 8 | (ushort)(*pfVar5 == local_9c) << 0xe)
								== 0) {
							local_9c = *pfVar5;
						}
						bVar1 = true;
					}
					piVar2 = piVar2 + 2;
					pfVar5 = pfVar5 + 3;
					local_90 += -1;
				} while (local_90 != 0);
			}
			else {
				local_8c += 1;
				puVar3 = puVar3 + 2;
				param_2 = param_2 + 2;
			}
			local_8c += 1;
			puVar3 = puVar3 + 2;
			param_2 = param_2 + 2;
		} while (local_8c < param_3);
	}
	if ((bVar1) &&
		 ((ushort)((ushort)(local_9c - local_98 < buildTolerance) << 8 |
							(ushort)(local_9c - local_98 == buildTolerance) << 0xe) == 0)) {
		return 0;
	}
	return 1;
}



void __cdecl
lego::game::Map3D_FUN_0044ed90(SurfaceMap *surfMap,uint *param_2,uint param_3,float param_4)
{
	int iVar1;
	float *pfVar2;
	int iVar3;
	float fVar4;
	float fVar5;
	int *piVar6;
	int iVar7;
	int *piVar8;
	uint *puVar9;
	uint uVar10;
	Point2I *pPVar11;
	float local_230;
	Point2I *local_22c;
	uint local_228;
	uint local_224;
	uint local_220;
	uint local_218;
	float local_214;
	Vector3F *local_210;
	int local_200 [5];
	undefined4 local_1ec;
	undefined4 local_1e8;
	undefined4 local_1e4;
	Vector3F local_1e0 [40];
	
	fVar4 = param_4 * 0.5;
	local_200[2] = 1;
	local_200[4] = 1;
	local_1ec = 1;
	local_1e4 = 1;
	local_224 = 0;
	local_228 = 0;
	local_230 = 0.0;
	local_200[0] = 0;
	local_200[1] = 0;
	local_200[3] = 0;
	local_1e8 = 0;
	local_214 = 10000.0;
	local_22c = (Point2I *)0xc61c4000;
	local_220 = 0;
	local_218 = 0;
	if (param_3 != 0) {
		local_210 = local_1e0;
		puVar9 = param_2 + 2;
		pPVar11 = globs::s_SurfaceMap_Points10;
		do {
			if (((local_218 == param_3 - 1) || (*param_2 != *puVar9)) || (param_2[1] != puVar9[1])) {
				pPVar11->x = *param_2;
				uVar10 = param_2[1];
				pPVar11->y = uVar10;
				Map3D_GetBlockVertexPositions(surfMap,pPVar11->x,uVar10,local_210);
				uVar10 = 0;
				piVar8 = local_200;
				do {
					iVar3 = uVar10 + local_220 * 4;
					if ((surfMap->grid28_28
							 [(piVar8[1] + pPVar11->y) * (surfMap->dimensions).width + pPVar11->x + *piVar8].
							 byteflags_19 & 8) == 0) {
						local_230 = local_1e0[iVar3].z + local_230;
						local_224 += 1;
					}
					else {
						pfVar2 = &local_1e0[iVar3].z;
						if (local_1e0[iVar3].z < local_214) {
							local_214 = *pfVar2;
						}
						if ((ushort)((ushort)(*pfVar2 < (float)local_22c) << 8 |
												(ushort)(*pfVar2 == (float)local_22c) << 0xe) == 0) {
							local_22c = (Point2I *)*pfVar2;
						}
						local_228 += 1;
					}
					uVar10 += 1;
					piVar8 = piVar8 + 2;
				} while (uVar10 < 4);
				local_220 += 1;
				local_210 = local_210 + 4;
				pPVar11 = pPVar11 + 1;
			}
			else {
				local_218 += 1;
				puVar9 = puVar9 + 2;
				param_2 = param_2 + 2;
			}
			local_218 += 1;
			puVar9 = puVar9 + 2;
			param_2 = param_2 + 2;
		} while (local_218 < param_3);
	}
	local_230 = local_230 / (float)(ulonglong)local_224;
	if (local_228 != 0) {
		if ((ushort)((ushort)(fVar4 + local_230 < (float)local_22c) << 8 |
								(ushort)(fVar4 + local_230 == (float)local_22c) << 0xe) == 0) {
			local_230 = (float)local_22c - fVar4;
		}
		if (local_230 - fVar4 < local_214) {
			local_230 = fVar4 + local_214;
		}
	}
	local_218 = 0;
	if (local_220 != 0) {
		local_22c = globs::s_SurfaceMap_Points10;
		do {
			local_228 = 0;
			piVar8 = &local_22c->y;
			piVar6 = local_200;
			do {
				iVar3 = piVar6[1];
				iVar7 = *piVar6;
				if ((surfMap->grid28_28
						 [(iVar3 + *piVar8) * (surfMap->dimensions).width + local_22c->x + iVar7].byteflags_19 &
						8) == 0) {
					iVar1 = local_228 + local_218 * 4;
					fVar5 = local_1e0[iVar1].z - local_230;
					if (fVar4 < ABS(fVar5)) {
						Map3D_Unk_ChangeWallDepth
											(surfMap,local_22c->x + iVar7,*piVar8 + iVar3,
											 ((fVar5 / fVar5) * fVar4 + local_230) - local_1e0[iVar1].z);
					}
					iVar7 = (*piVar8 + iVar3) * (surfMap->dimensions).width + local_22c->x + iVar7;
					surfMap->grid28_28[iVar7].byteflags_19 = surfMap->grid28_28[iVar7].byteflags_19 | 8;
				}
				local_228 += 1;
				piVar6 = piVar6 + 2;
			} while (local_228 < 4);
			local_218 += 1;
			local_22c = local_22c + 1;
		} while (local_218 < local_220);
	}
	return;
}



void __cdecl
lego::game::Map3D_FUN_0044f0b0(SurfaceMap *surfMap,uint sx,uint sy,BOOL isNotStruct28_Flag1)
{
	SurfaceMapStruct28Flags *pSVar1;
	int iVar2;
	D3DRMGroupIndex groupID;
	D3DRMVertex *pDVar3;
	float *pfVar4;
	D3DRMVertex *pDVar5;
	D3DRMVertex vertices [4];
	float local_24 [9];
	SurfaceMapStruct28Flags bVar2;
	
	if (((isNotStruct28_Flag1 != 0) &&
			((surfMap->grid28_28[sy * (surfMap->dimensions).width + sx].byteflags_19 & 1) == 0)) ||
		 ((isNotStruct28_Flag1 == 0 &&
			((surfMap->grid28_28[sy * (surfMap->dimensions).width + sx].byteflags_19 & 1) != 0)))) {
		groupID = (surfMap->smallDimensions).width * sy + sx;
		res::Container_Mesh_GetVertices(surfMap->resMesh_24,groupID,0,4,vertices);
		iVar2 = sy * (surfMap->dimensions).width + sx;
		bVar2 = surfMap->grid28_28[iVar2].byteflags_19;
		pSVar1 = &surfMap->grid28_28[iVar2].byteflags_19;
		if ((bVar2 & SURFMAP_STRUCT28_UNK_1) == SURFMAP_STRUCT28_NONE) {
			*pSVar1 = bVar2 | SURFMAP_STRUCT28_UNK_1;
			pDVar3 = vertices + 3;
			pfVar4 = local_24;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				*pfVar4 = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pfVar4 = pfVar4 + 1;
			}
			pDVar3 = vertices + 2;
			pDVar5 = vertices + 3;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				(pDVar5->position).x = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pDVar5 = (D3DRMVertex *)&(pDVar5->position).y;
			}
			pDVar3 = vertices + 1;
			pDVar5 = vertices + 2;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				(pDVar5->position).x = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pDVar5 = (D3DRMVertex *)&(pDVar5->position).y;
			}
			pDVar3 = vertices;
			pDVar5 = vertices + 1;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				(pDVar5->position).x = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pDVar5 = (D3DRMVertex *)&(pDVar5->position).y;
			}
			pDVar3 = vertices;
		}
		else {
			*pSVar1 = bVar2 & ~SURFMAP_STRUCT28_UNK_1;
			pDVar3 = vertices;
			pfVar4 = local_24;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				*pfVar4 = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pfVar4 = pfVar4 + 1;
			}
			pDVar3 = vertices + 1;
			pDVar5 = vertices;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				(pDVar5->position).x = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pDVar5 = (D3DRMVertex *)&(pDVar5->position).y;
			}
			pDVar3 = vertices + 2;
			pDVar5 = vertices + 1;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				(pDVar5->position).x = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pDVar5 = (D3DRMVertex *)&(pDVar5->position).y;
			}
			pDVar3 = vertices + 3;
			pDVar5 = vertices + 2;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				(pDVar5->position).x = (pDVar3->position).x;
				pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
				pDVar5 = (D3DRMVertex *)&(pDVar5->position).y;
			}
			pDVar3 = vertices + 3;
		}
		pfVar4 = local_24;
		for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
			(pDVar3->position).x = *pfVar4;
			pfVar4 = pfVar4 + 1;
			pDVar3 = (D3DRMVertex *)&(pDVar3->position).y;
		}
		res::Container_Mesh_SetVertices(surfMap->resMesh_24,groupID,0,4,vertices);
		Map3D_Block_InitPlaneNormals(surfMap,sx,sy);
										// Perform action in a square: { { 0, 0 }, { 1, 0 },
										//                               { 0, 1 }, { 1, 1 } }
		Map3D_SetFlags2_AndStruct28_SetFlag19_4(surfMap,sx,sy);
		Map3D_SetFlags2_AndStruct28_SetFlag19_4(surfMap,sx + 1,sy);
		Map3D_SetFlags2_AndStruct28_SetFlag19_4(surfMap,sx + 1,sy + 1);
		Map3D_SetFlags2_AndStruct28_SetFlag19_4(surfMap,sx,sy + 1);
	}
	return;
}



void __cdecl lego::game::Map3D_SetFlags2_AndStruct28_SetFlag19_4(SurfaceMap *surfMap,int sx,int sy)
{
	SurfaceMapStruct28Flags *pbVar1;
	
	pbVar1 = &surfMap->grid28_28[(surfMap->dimensions).width * sy + sx].byteflags_19;
	*pbVar1 = *pbVar1 | SURFMAP_STRUCT28_UNK_4;
	surfMap->flags_73d0 = surfMap->flags_73d0 | SURFMAP_UNK_2;
	return;
}



void __cdecl lego::game::Map3D_Update(SurfaceMap *surfMap,float elapsedGame)
{
	int iVar1;
	uint uVar2;
	uint by;
	uint bx;
	
										// 0x2 = needs some UpdateBlockTextureAndVertices(?)
	if ((*(byte *)&surfMap->flags_73d0 & SURFMAP_UNK_2) != 0) {
		by = 0;
		if ((surfMap->dimensions).height != 0) {
			do {
				uVar2 = (surfMap->dimensions).width;
				bx = 0;
				if (uVar2 != 0) {
					do {
										// 0x4 = needs UpdateBlockTextureAndVertices
						if ((surfMap->grid28_28[by * uVar2 + bx].byteflags_19 & 4) != 0) {
							Map3D_Block_UpdateTextureAndVertices(surfMap,bx,by);
							iVar1 = by * (surfMap->dimensions).width + bx;
										// ~0x4
							surfMap->grid28_28[iVar1].byteflags_19 = surfMap->grid28_28[iVar1].byteflags_19 & 0xfb
							;
						}
						uVar2 = (surfMap->dimensions).width;
						bx += 1;
					} while (bx < uVar2);
				}
				by += 1;
			} while (by < (uint)(surfMap->dimensions).height);
		}
		surfMap->flags_73d0 = surfMap->flags_73d0 & ~SURFMAP_UNK_2;
	}
	Map3D_Update_Pass1_CoordsTextureUVs(surfMap,elapsedGame);
	Map3D_Update_Pass2_VertexColors(surfMap,elapsedGame);
	return;
}



void __cdecl lego::game::Map3D_Update_Pass2_VertexColors(SurfaceMap *surfMap,float elapsedGame)
{
	float fVar1;
	float *pfVar2;
	float *pfVar3;
	int iVar4;
	int index;
	float *pfVar5;
	D3DRMVertex vertices [4];
	
	index = 10;
	pfVar5 = (float *)&surfMap->table38_719c[0].blockPos.y;
	do {
		if ((*(byte *)(pfVar5 + 10) & 1) != 0) {
			res::Container_Mesh_GetVertices
								(surfMap->resMesh_24,
								 (surfMap->smallDimensions).width * (int)*pfVar5 + (int)pfVar5[-1],0,4,vertices);
			pfVar3 = &vertices[0].tv;
			iVar4 = 4;
			pfVar2 = pfVar5;
			do {
				pfVar3[-1] = pfVar2[1];
				*pfVar3 = pfVar2[2];
				pfVar3 = pfVar3 + 9;
				iVar4 += -1;
				pfVar2 = pfVar2 + 2;
			} while (iVar4 != 0);
			res::Container_Mesh_SetVertices
								(surfMap->resMesh_73cc,(D3DRMGroupIndex)pfVar5[-3],0,4,vertices);
			res::Container_Mesh_SetColourAlpha
								(surfMap->resMesh_73cc,(D3DRMGroupIndex)pfVar5[-3],1.0,1.0,1.0,1.0 - pfVar5[-2]);
			fVar1 = pfVar5[-2] - elapsedGame * -0.04;
			pfVar5[-2] = fVar1;
			if ((ushort)((ushort)(fVar1 < 1.0) << 8 | (ushort)(fVar1 == 1.0) << 0xe) == 0) {
				res::Container_Mesh_HideGroup(surfMap->resMesh_73cc,(D3DRMGroupIndex)pfVar5[-3],TRUE);
				pfVar5[10] = (float)((uint)pfVar5[10] & 0xfffffffe);
			}
		}
		pfVar5 = pfVar5 + 0xe;
		index += -1;
	} while (index != 0);
	return;
}



void __cdecl
lego::game::Map3D_AddTextureCoordMapping
					(SurfaceMap *surfMap,SurfaceTexture texA,SurfaceTexture texB)
{
	uint texNum;
	uint i;
	uint texId;
	
	texId = (uint)texA;
	i = 0;
	texNum = (uint)surfMap->texsNum[texId];
										// check if mapping has already been created. If so, end operation
	if (texNum != 0) {
		do {
										// mapping already exists at index?
			if (surfMap->texsGrid[texId][i] == texB) {
				return;
			}
			i += 1;
		} while (i < texNum);
	}
										// mapping not found, add texB to end of texA[] list
	surfMap->texsGrid[texId][texNum] = texB;
	surfMap->texsNum[texId] = surfMap->texsNum[texId] + 1;
										// now create the reverse mapping, add texA to end of texB[] list
	texId = (uint)texB;
	surfMap->texsGrid[texId][surfMap->texsNum[texId]] = texA;
	surfMap->texsNum[texId] = surfMap->texsNum[texId] + 1;
	return;
}



void __cdecl lego::game::Map3D_SetField_2c(SurfaceMap *surfMap,undefined4 field2c)
{
	surfMap->field_2c = field2c;
	return;
}



void __cdecl
lego::game::Map3D_UpdateBlockVisual(SurfaceMap *surfMap,uint x,uint y,uint param_4,uint param_5)
{
	byte bVar1;
	Container_Texture *ref_itext;
	uint uVar2;
	D3DRMGroupIndex groupID;
	float *pfVar3;
	byte local_94 [4];
	D3DRMVertex vertices [4];
	
	uVar2 = (surfMap->smallDimensions).width;
	if ((x < uVar2) && (y < (uint)(surfMap->smallDimensions).height)) {
		groupID = y * uVar2 + x;
		local_94[0] = 1;
		local_94[1] = 3;
		local_94[2] = 2;
		local_94[3] = 0;
		ref_itext = res::DynamicPM_SurfaceTextureGrid_GetTexture
													((SurfaceTextureGrid *)surfMap->field_2c,(SurfaceTexture)param_4);
		surfMap->grid28_28[y * (surfMap->dimensions).width + x].texture = (SurfaceTexture)param_4;
		if ((surfMap->grid28_28[y * (surfMap->dimensions).width + x].byteflags_19 & 1) != 0) {
			param_5 = (uint)(byte)((char)param_5 + 1);
		}
		res::Container_Mesh_SetTexture(surfMap->resMesh_24,groupID,ref_itext);
		if ((surfMap->grid28_28[y * (surfMap->dimensions).width + x].byteflags_19 & 0x10) == 0) {
			res::Container_Mesh_GetVertices(surfMap->resMesh_24,groupID,0,4,vertices);
			uVar2 = 0;
			pfVar3 = &vertices[0].tv;
			do {
				bVar1 = local_94[uVar2 - (param_5 & 0xff) & 3];
				uVar2 += 1;
				pfVar3[-1] = (float)(uint)(bVar1 >> 1);
				*pfVar3 = (float)(uint)(bVar1 & 1);
				pfVar3 = pfVar3 + 9;
			} while (uVar2 < 4);
			res::Container_Mesh_SetVertices(surfMap->resMesh_24,groupID,0,4,vertices);
		}
	}
	return;
}



void __cdecl
lego::game::Map3D_Unk_ChangeWallDepth(SurfaceMap *surfMap,uint bx,uint by,float digDepth)
{
	float *pfVar1;
	uint by_00;
	int i;
	uint uVar2;
	uint uVar3;
	Point2F *pPVar4;
	longlong lVar5;
	Vector3F vertPoses [1];
	Point2F OFFSETS_M1 [4];
	Vector3F *pVertPos;
	
	uVar2 = 0;
	vertPoses[0].z = digDepth;
	OFFSETS_M1[0].x = 0.0;
	OFFSETS_M1[0].y = 0.0;
	OFFSETS_M1[1].x = -1.0;
	OFFSETS_M1[1].y = 0.0;
	OFFSETS_M1[2].x = -1.0;
	OFFSETS_M1[2].y = -1.0;
	OFFSETS_M1[3].x = 0.0;
	OFFSETS_M1[3].y = -1.0;
	vertPoses[0].x = 0.0;
	vertPoses[0].y = 0.0;
										// for (uint i = 0; i < 4; i++)
										//   OFFSETS_M1[i].x += (float)bx, OFFSETS_M1[i].y += (float)by;
	i = 4;
	pfVar1 = &OFFSETS_M1[0].y;
	do {
		i += -1;
		pfVar1[-1] = (float)(ulonglong)bx + pfVar1[-1];
		*pfVar1 = *pfVar1 + (float)(ulonglong)by;
		pfVar1 = pfVar1 + 2;
	} while (i != 0);
										// for (uint vertIdx = 0; vertIdx < 4; vertIdx++)
										//   SurfaceMap_Block_SetIndexVertexPosition(surfMap,
										//           OFFSETS_M1[i].x, OFFSETS_M1[i].y, vertIdx, vertPoses);
	pPVar4 = OFFSETS_M1;
	do {
		pVertPos = vertPoses;
		uVar3 = uVar2;
		lVar5 = __ftol((float10)pPVar4->y);
		by_00 = (uint)lVar5;
		lVar5 = __ftol((float10)pPVar4->x);
		Map3D_Block_SetIndexVertexPosition(surfMap,(uint)lVar5,by_00,uVar3,pVertPos);
		uVar2 += 1;
		pPVar4 = pPVar4 + 1;
	} while (uVar2 < 4);
	for (uVar2 = by - 1; uVar2 <= by; uVar2 += 1) {
		for (uVar3 = bx - 1; uVar3 <= bx; uVar3 += 1) {
			Map3D_Block_InitPlaneNormals(surfMap,uVar3,uVar2);
		}
	}
	return;
}



void __cdecl lego::game::Map3D_SetPerspectiveCorrectionAll(SurfaceMap *surfMap,BOOL on)
{
	uint uVar1;
	uint uVar2;
	uint uVar3;
	
	uVar2 = 0;
	if ((surfMap->smallDimensions).height != 0) {
		do {
			uVar1 = (surfMap->smallDimensions).width;
			uVar3 = 0;
			if (uVar1 != 0) {
				do {
					res::Container_Mesh_SetPerspectiveCorrection(surfMap->resMesh_24,uVar2 * uVar1 + uVar3,on)
					;
					uVar1 = (surfMap->smallDimensions).width;
					uVar3 += 1;
				} while (uVar3 < uVar1);
			}
			uVar2 += 1;
		} while (uVar2 < (uint)(surfMap->smallDimensions).height);
	}
	return;
}



WallHighlightType __cdecl
lego::game::Map3D_Block_SetHighlightType
					(SurfaceMap *surfMap,int bx,int by,WallHighlightType highlightType)
{
	byte bVar1;
	int idx;
	
	idx = (surfMap->dimensions).width * by + bx;
	bVar1 = surfMap->grid28_28[idx].highlight;
	surfMap->grid28_28[idx].highlight = (byte)highlightType;
	Map3D_Block_SetColour
						(surfMap,bx,by,TRUE,globs::s_wallHighlightColours[highlightType].red,
						 globs::s_wallHighlightColours[highlightType].green,
						 globs::s_wallHighlightColours[highlightType].blue);
	return (uint)bVar1;
}



WallHighlightType __cdecl
lego::game::Map3D_Block_GetHighlightType(SurfaceMap *surfMap,int bx,int by)
{
	return (uint)surfMap->grid28_28[(surfMap->dimensions).width * by + bx].highlight;
}



void __cdecl lego::game::Map3D_Block_ClearHighlight(SurfaceMap *surfMap,int bx,int by)
{
										// clear block colour
	Map3D_Block_SetColour(surfMap,bx,by,FALSE,1.0,1.0,1.0);
	surfMap->grid28_28[(surfMap->dimensions).width * by + bx].highlight = WALLHIGHLIGHT_NONE;
	return;
}



void __cdecl
lego::game::Map3D_Block_SetColour
					(SurfaceMap *surfMap,int bx,int by,BOOL setColour,float r,float g,float b)
{
	D3DRMGroupIndex groupID;
	
	groupID = (surfMap->smallDimensions).width * by + bx;
	if (setColour != 0) {
		res::Container_Mesh_SetColourAlpha(surfMap->resMesh_24,groupID,r,g,b,1.0);
		return;
	}
	res::Container_Mesh_SetColourAlpha(surfMap->resMesh_24,groupID,1.0,1.0,1.0,1.0);
	surfMap->grid28_28[(surfMap->dimensions).width * by + bx].highlight = WALLHIGHLIGHT_NONE;
	return;
}



BOOL __cdecl
lego::game::Map3D_BlockToWorldPos(SurfaceMap *surfMap,uint bx,uint by,float *out_x,float *out_y)
{
	if ((bx < (uint)(surfMap->smallDimensions).width) &&
		 (by < (uint)(surfMap->smallDimensions).height)) {
		*out_x = surfMap->BlockSize * 0.5 +
						 (float)(ulonglong)bx * surfMap->BlockSize + (surfMap->blockDimensions_neg).width;
		*out_y = (surfMap->blockDimensions_neg).height -
						 (surfMap->BlockSize * 0.5 + (float)(ulonglong)by * surfMap->BlockSize);
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::game::Map3D_WorldToBlockPos_NoZ
					(SurfaceMap *surfMap,float in_x,float in_y,int *out_bx,int *out_by)
{
	BOOL BVar1;
	
										// The final argument here ((float *)&out_y) is a dummy argument that won't
										// output the pointed-to value
	BVar1 = Map3D_WorldToBlockPos(surfMap,in_x,in_y,out_bx,out_by,(float *)&out_by);
	return BVar1;
}



BOOL __cdecl
lego::game::Map3D_WorldToBlockPos
					(SurfaceMap *surfMap,float in_x,float in_y,int *out_bx,int *out_by,float *out_unk_z)
{
	float fVar1;
	int iVar2;
	int iVar3;
	longlong lVar4;
	
	lVar4 = __ftol(((float10)in_x - (float10)(surfMap->blockDimensions_neg).width) /
								 (float10)surfMap->BlockSize);
	iVar2 = (int)lVar4;
	lVar4 = __ftol(((float10)(surfMap->blockDimensions_neg).height - (float10)in_y) /
								 (float10)surfMap->BlockSize);
	iVar3 = (int)lVar4;
	if (out_bx != NULL) {
		*out_bx = iVar2;
	}
	if (out_by != NULL) {
		*out_by = iVar3;
	}
	if ((((-1 < iVar2) && (iVar2 < (surfMap->smallDimensions).width)) && (-1 < iVar3)) &&
		 (iVar3 < (surfMap->smallDimensions).height)) {
		if (out_unk_z != NULL) {
			fVar1 = surfMap->BlockSize * 0.5;
			in_x = (in_x - ((float)iVar2 * surfMap->BlockSize + (surfMap->blockDimensions_neg).width)) /
						 fVar1;
			fVar1 = -((in_y - ((surfMap->blockDimensions_neg).height - (float)iVar3 * surfMap->BlockSize))
							 / fVar1);
			if ((ushort)((ushort)(in_x < 1.0) << 8 | (ushort)(in_x == 1.0) << 0xe) == 0) {
				in_x = 2.0 - in_x;
			}
			if ((ushort)((ushort)(fVar1 < 1.0) << 8 | (ushort)(fVar1 == 1.0) << 0xe) == 0) {
				fVar1 = 2.0 - fVar1;
			}
			if (in_x < fVar1) {
				fVar1 = in_x;
			}
			*out_unk_z = fVar1;
		}
		return TRUE;
	}
	return 0;
}



void __cdecl
lego::game::Map3D_FUN_0044fad0(SurfaceMap *surfMap,float in_x,float in_y,int *out_x,int *out_y)
{
	int iVar1;
	int iVar2;
	int iVar3;
	longlong lVar4;
	
	lVar4 = __ftol(((float10)in_x - (float10)(surfMap->blockDimensions_neg).width) /
								 (float10)surfMap->BlockSize);
	iVar3 = (int)lVar4;
	lVar4 = __ftol(((float10)(surfMap->blockDimensions_neg).height - (float10)in_y) /
								 (float10)surfMap->BlockSize);
	iVar2 = (int)lVar4;
	if (iVar3 < 0) {
		iVar3 = 0;
	}
	iVar1 = (surfMap->smallDimensions).width;
	if (iVar1 <= iVar3) {
		iVar3 = iVar1 + -1;
	}
	if (iVar2 < 0) {
		iVar2 = 0;
	}
	iVar1 = (surfMap->smallDimensions).height;
	if (iVar1 <= iVar2) {
		iVar2 = iVar1 + -1;
	}
	if (out_x != NULL) {
		*out_x = iVar3;
	}
	if (out_y != NULL) {
		*out_y = iVar2;
	}
	return;
}



BOOL __cdecl
lego::game::Map3D_FUN_0044fb30
					(SurfaceMap *surfMap,Point2F *param_2,Point2F *param_3,Point2F *param_4)
{
	float fVar1;
	Point2F *pPVar2;
	BOOL BVar3;
	Point2F *local_8;
	float fStack4;
	SurfaceMap *surfMap_00;
	
	pPVar2 = param_2;
	surfMap_00 = surfMap;
	BVar3 = Map3D_WorldToBlockPos_NoZ(surfMap,param_2->x,param_2->y,(int *)&surfMap,(int *)&param_2);
	if (BVar3 != 0) {
		if (param_3 != NULL) {
			local_8 = param_2;
			fStack4 = 0.0;
			param_3->x = (float)ZEXT48(surfMap);
			param_3->y = (float)ZEXT48(param_2);
		}
		if (param_4 != NULL) {
			Map3D_BlockToWorldPos(surfMap_00,(uint)surfMap,(uint)param_2,(float *)&local_8,&fStack4);
			param_4->x = pPVar2->x - (float)local_8;
			param_4->y = pPVar2->y - fStack4;
			fVar1 = 1.0 / surfMap_00->BlockSize;
			param_4->x = fVar1 * param_4->x - -0.5;
			param_4->y = fVar1 * param_4->y - -0.5;
		}
	}
	return 0;
}



float10 __cdecl lego::game::Map3D_GetWorldZ(SurfaceMap *surfMap,float x,float y)
{
	SurfaceMap *surfMap_00;
	BOOL BVar1;
	float10 fVar2;
	uint local_38;
	float local_34;
	Vector3F local_30;
	float local_24;
	float local_20;
	float local_1c;
	float local_18;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	surfMap_00 = surfMap;
	local_34 = 0.0;
	BVar1 = Map3D_WorldToBlockPos_NoZ(surfMap,x,y,(int *)&local_38,(int *)&surfMap);
	if (BVar1 != 0) {
		BVar1 = Map3D_GetBlockVertexPositions(surfMap_00,local_38,(uint)surfMap,&local_30);
		if (BVar1 == 0) {
			if (surfMap_00->BlockSize <= (x - local_30.x) + (local_30.y - y)) {
				local_30.z = (local_4 - local_10) + (local_1c - local_10) + local_10;
			}
			else {
				local_10 = (local_4 - local_30.z) + (local_1c - local_30.z) + local_30.z;
			}
		}
		else {
			if (surfMap_00->BlockSize <= (local_24 - x) + (local_20 - y)) {
				local_1c = (local_10 - local_4) + (local_30.z - local_4) + local_4;
			}
			else {
				local_4 = (local_10 - local_1c) + (local_30.z - local_1c) + local_1c;
			}
		}
		fVar2 = ((float10)local_10 - (float10)local_4) *
						(((float10)local_18 - (float10)local_c) / ((float10)x - (float10)local_c)) +
						(float10)local_4;
		return (((float10)local_30.y - (float10)local_8) / ((float10)y - (float10)local_8)) *
					 ((((float10)local_1c - (float10)local_30.z) *
						 (((float10)x - (float10)local_30.x) / ((float10)local_24 - (float10)local_30.x)) +
						(float10)local_30.z) - fVar2) + fVar2;
	}
	return (float10)local_34;
}



void __cdecl
lego::game::Map3D_FUN_0044fd70(SurfaceMap *surfMap,float in_x,float in_y,Vector3F *out_vector)
{
	BOOL BVar1;
	int iVar2;
	SurfaceMapStruct_28 *pSVar3;
	uint local_34;
	Vector3F local_30;
	float local_24;
	float local_20;
	SurfaceMap *surfMap_00;
	
	surfMap_00 = surfMap;
	BVar1 = Map3D_WorldToBlockPos_NoZ(surfMap,in_x,in_y,(int *)&local_34,(int *)&surfMap);
	if (BVar1 == 0) {
		return;
	}
	BVar1 = Map3D_GetBlockVertexPositions(surfMap_00,local_34,(uint)surfMap,&local_30);
	if (BVar1 == 0) {
		iVar2 = (surfMap_00->dimensions).width;
		if ((local_30.y - in_y) + (in_x - local_30.x) < surfMap_00->BlockSize) {
LAB_0044fe14:
			pSVar3 = surfMap_00->grid28_28 + iVar2 * (int)surfMap + local_34;
			goto LAB_0044fe28;
		}
	}
	else {
		iVar2 = (surfMap_00->dimensions).width;
		if (surfMap_00->BlockSize <= (local_20 - in_y) + (local_24 - in_x)) goto LAB_0044fe14;
	}
	pSVar3 = (SurfaceMapStruct_28 *)&surfMap_00->grid28_28[iVar2 * (int)surfMap + local_34].vector_c;
LAB_0044fe28:
	out_vector->x = (pSVar3->vector_0).x;
	out_vector->y = (pSVar3->vector_0).y;
	out_vector->z = (pSVar3->vector_0).z;
	return;
}



BOOL __cdecl
lego::game::Map3D_FUN_0044fe50
					(SurfaceMap *surfMap,float in_x,float in_y,BOOL condition,float unkMultiplier,float *out_x
					,float *out_y)
{
	Vector3F *pVVar1;
	float fVar2;
	float fVar3;
	SurfaceMap *surfMap_00;
	BOOL BVar4;
	SurfaceMapStruct_28 *pSVar5;
	int iVar6;
	int iVar7;
	uint local_68;
	Point2F local_64;
	Point2F local_5c;
	Point2F local_54;
	Point2F local_4c;
	Point2F local_44;
	float local_3c;
	float local_38;
	float local_34;
	Vector3F local_30;
	float local_24 [9];
	
	surfMap_00 = surfMap;
	BVar4 = Map3D_WorldToBlockPos_NoZ(surfMap,in_x,in_y,(int *)&local_68,(int *)&surfMap);
	if (BVar4 == 0) {
		return 0;
	}
	BVar4 = Map3D_GetBlockVertexPositions(surfMap_00,local_68,(uint)surfMap,&local_30);
	if (BVar4 == 0) {
		iVar6 = (surfMap_00->dimensions).width;
		if ((in_x - local_30.x) + (local_30.y - in_y) < surfMap_00->BlockSize) {
			pSVar5 = surfMap_00->grid28_28 + iVar6 * (int)surfMap + local_68;
			local_3c = (pSVar5->vector_0).x;
			local_38 = (pSVar5->vector_0).y;
			local_34 = (pSVar5->vector_0).z;
			goto LAB_0044ff78;
		}
		pSVar5 = (SurfaceMapStruct_28 *)&surfMap_00->grid28_28[iVar6 * (int)surfMap + local_68].vector_c
		;
	}
	else {
		iVar6 = (surfMap_00->dimensions).width;
		if ((local_24[0] - in_x) + (local_24[1] - in_y) < surfMap_00->BlockSize) {
			pVVar1 = &surfMap_00->grid28_28[iVar6 * (int)surfMap + local_68].vector_c;
			local_3c = pVVar1->x;
			local_38 = pVVar1->y;
			local_34 = pVVar1->z;
			goto LAB_0044ff78;
		}
		pSVar5 = surfMap_00->grid28_28 + iVar6 * (int)surfMap + local_68;
	}
	local_3c = (pSVar5->vector_0).x;
	local_38 = (pSVar5->vector_0).y;
	local_34 = (pSVar5->vector_0).z;
LAB_0044ff78:
	if (condition == 0) {
		if (ABS(local_3c) <= ABS(local_38)) {
			if (0.0 <= local_38) {
				iVar6 = 0;
				iVar7 = 1;
			}
			else {
				iVar6 = 2;
				iVar7 = 3;
			}
		}
		else {
			if (0.0 <= local_3c) {
				iVar6 = 1;
				iVar7 = 2;
			}
			else {
				iVar6 = 0;
				iVar7 = 3;
			}
		}
	}
	else {
		if (BVar4 == 0) {
			iVar6 = 1;
			iVar7 = 3;
		}
		else {
			iVar6 = 0;
			iVar7 = 2;
		}
	}
	local_54.x = local_24[iVar6 * 3 + -3];
	local_54.y = (&local_30)[iVar6].y;
	local_4c.x = in_x;
	local_5c.x = local_24[iVar7 * 3 + -3] - local_54.x;
	local_5c.y = (&local_30)[iVar7].y - local_54.y;
	local_4c.y = in_y;
	local_64.x = local_3c;
	local_64.y = local_38;
	math::Maths_Vector2DIntersection(&local_44,&local_54,&local_5c,&local_4c,&local_64);
	fVar3 = unkMultiplier * surfMap_00->BlockSize;
	fVar2 = 1.0 / SQRT(local_64.y * local_64.y + local_64.x * local_64.x);
	*out_x = local_44.x - fVar2 * local_64.x * fVar3;
	*out_y = local_44.y - fVar2 * local_64.y * fVar3;
	return 1;
}



float10 __cdecl lego::game::Map3D_UnkCameraXYFunc_RetZunk(SurfaceMap *surfMap,float x,float y)
{
	SurfaceMap *pSVar1;
	BOOL BVar2;
	float *pfVar3;
	float *pfVar4;
	int iVar5;
	float10 fVar6;
	float10 extraout_ST0;
	longlong lVar7;
	uint local_68;
	int local_64;
	float local_60;
	undefined4 uStack92;
	float local_58;
	undefined4 uStack84;
	float local_50 [5];
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	float local_30;
	float local_2c;
	float local_28;
	float local_24;
	float local_20;
	float local_1c;
	float local_18;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pSVar1 = surfMap;
	local_58 = 0.0;
	BVar2 = Map3D_WorldToBlockPos_NoZ(surfMap,x,y,(int *)&local_68,(int *)&surfMap);
	if (BVar2 != 0) {
		uStack92 = 0;
		local_58 = (float)local_68;
		fVar6 = (float10)ZEXT48(surfMap);
		uStack84 = 0;
		local_60 = (float)(ulonglong)local_68;
		local_50[0] = 0.0;
		local_50[1] = 0.0;
		local_50[2] = 1.0;
		local_50[3] = 0.0;
		local_50[4] = 1.0;
		local_3c = 0x3f800000;
		local_38 = 0;
		local_34 = 0x3f800000;
		pfVar3 = local_50;
		local_64 = 4;
		pfVar4 = &local_2c;
		do {
			pfVar4[-1] = (*pfVar3 + local_60) * pSVar1->BlockSize + (pSVar1->blockDimensions_neg).width;
			*pfVar4 = (float)((float10)(pSVar1->blockDimensions_neg).height -
											 ((float10)pfVar3[1] + fVar6) * (float10)pSVar1->BlockSize);
			lVar7 = __ftol((float10)pfVar3[1]);
			iVar5 = (int)(surfMap->texsGrid[-1] + (int)lVar7 + 0x4c) * (pSVar1->dimensions).width +
							local_68;
			lVar7 = __ftol((float10)*pfVar3);
			pfVar3 = pfVar3 + 2;
			local_58 = (float)(uint)pSVar1->grid28_28[iVar5 + (int)lVar7].byte_1a;
			local_64 += -1;
			pfVar4[1] = -((float)(int)local_58 * pSVar1->RoughLevel);
			pfVar4 = pfVar4 + 3;
			fVar6 = extraout_ST0;
		} while (local_64 != 0);
		if (pSVar1->BlockSize <= (local_24 - x) + (local_20 - y)) {
			fVar6 = (float10)local_4;
			local_1c = (float)(((float10)local_10 - fVar6) + ((float10)local_28 - fVar6) + fVar6);
		}
		else {
			fVar6 = ((float10)local_10 - (float10)local_1c) + ((float10)local_28 - (float10)local_1c) +
							(float10)local_1c;
		}
		fVar6 = ((float10)local_10 - fVar6) *
						(((float10)local_18 - (float10)local_c) / ((float10)x - (float10)local_c)) + fVar6;
		return (((float10)local_2c - (float10)local_8) / ((float10)y - (float10)local_8)) *
					 ((((float10)local_1c - (float10)local_28) *
						 (((float10)x - (float10)local_30) / ((float10)local_24 - (float10)local_30)) +
						(float10)local_28) - fVar6) + fVar6;
	}
	return (float10)local_58;
}



void __cdecl lego::game::Map3D_FUN_00450320(SurfaceMap *surfMap,int sx,int sy,Vector3F *out_vector)
{
	D3DRMVertex local_24;
	
	res::Container_Mesh_GetVertices
						(surfMap->resMesh_24,sy * (surfMap->smallDimensions).width + sx,
						 surfMap->grid28_28[(surfMap->dimensions).width * sy + sx].byteflags_19 & 1,1,&local_24)
	;
	out_vector->x = local_24.position.x;
	out_vector->y = local_24.position.y;
	out_vector->z = local_24.position.z;
	return;
}



BOOL __cdecl
lego::game::Map3D_GetBlockVertexPositions(SurfaceMap *surfMap,uint x,uint y,Vector3F *out_vertices4)
{
	uint uVar1;
	D3DRMVertex vertices [4];
	
	uVar1 = (surfMap->smallDimensions).width;
	if ((x < uVar1) && (y < (uint)(surfMap->smallDimensions).height)) {
		res::Container_Mesh_GetVertices(surfMap->resMesh_24,y * uVar1 + x,0,4,vertices);
		if ((surfMap->grid28_28[(surfMap->dimensions).width * y + x].byteflags_19 & 1) != 0) {
			out_vertices4->x = vertices[1].position.x;
			out_vertices4->y = vertices[1].position.y;
			out_vertices4->z = vertices[1].position.z;
			out_vertices4[1].x = vertices[2].position.x;
			out_vertices4[1].y = vertices[2].position.y;
			out_vertices4[1].z = vertices[2].position.z;
			out_vertices4[2].x = vertices[3].position.x;
			out_vertices4[2].y = vertices[3].position.y;
			out_vertices4[2].z = vertices[3].position.z;
			out_vertices4[3].x = vertices[0].position.x;
			out_vertices4[3].y = vertices[0].position.y;
			out_vertices4[3].z = vertices[0].position.z;
			return TRUE;
		}
		out_vertices4->x = vertices[0].position.x;
		out_vertices4->y = vertices[0].position.y;
		out_vertices4->z = vertices[0].position.z;
		out_vertices4[1].x = vertices[1].position.x;
		out_vertices4[1].y = vertices[1].position.y;
		out_vertices4[1].z = vertices[1].position.z;
		out_vertices4[2].x = vertices[2].position.x;
		out_vertices4[2].y = vertices[2].position.y;
		out_vertices4[2].z = vertices[2].position.z;
		out_vertices4[3].x = vertices[3].position.x;
		out_vertices4[3].y = vertices[3].position.y;
		out_vertices4[3].z = vertices[3].position.z;
		uVar1 = 0;
	}
	return uVar1;
}



void __cdecl
lego::game::Map3D_FillLargeStruct_AtXY_FUN_004504e0
					(SurfaceMap *surfMap,int sx,int sy,undefined4 *out_struct)
{
	D3DRMVertex local_90;
	undefined4 local_6c;
	undefined4 local_68;
	undefined4 local_64;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	
	res::Container_Mesh_GetVertices
						(surfMap->resMesh_24,sy * (surfMap->smallDimensions).width + sx,0,4,&local_90);
	*out_struct = local_90.position.x;
	out_struct[1] = local_90.position.y;
	out_struct[2] = local_90.position.z;
	out_struct[3] = local_6c;
	out_struct[4] = local_68;
	out_struct[5] = local_64;
	out_struct[6] = local_48;
	out_struct[7] = local_44;
	out_struct[8] = local_40;
	out_struct[9] = local_24;
	out_struct[10] = local_20;
	out_struct[0xb] = local_1c;
	return;
}



BOOL __cdecl lego::game::Map3D_IsInsideDimensions(SurfaceMap *surfMap,uint sx,uint sy)
{
	if ((uint)(surfMap->smallDimensions).width <= sx) {
		return 0;
	}
	return (uint)(sy < (uint)(surfMap->smallDimensions).height);
}



BOOL __cdecl
lego::game::Map3D_GetIntersections
					(SurfaceMap *surfMap,Viewport *view,uint mouseX,uint mouseY,uint *out_bx,uint *out_by,
					Vector3F *out_vector)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	BOOL BVar5;
	int iVar6;
	float *pfVar7;
	Vector3F *vector;
	Point2I blockPos;
	Point2I loopOffset;
	Point2F mousePos;
	Vector3F xformVecZ1;
	Vector3F xformVecZ0;
	Vector4F xformPoly;
	Vector4F xformMouseZ0;
	Vector4F xformMouseZ1;
	Point2F polyPoints [5];
	Vector3F vertPoses [4];
	
	mousePos.x = (float)(ulonglong)mouseX;
	blockPos.x = mouseY;
	blockPos.y = 0;
	mousePos.y = (float)(ulonglong)mouseY;
										// xformMouseZ0 = Vector4F{mouseX, mouseY, 0.0, 1.0};
										// xformMouseZ1 = Vector4F{mouseX, mouseY, 1.0, 1.0};
	xformMouseZ0.z = 0.0;
	xformMouseZ0.w = 1.0;
	xformMouseZ1.z = 1.0;
	xformMouseZ1.w = 1.0;
	xformMouseZ0.x = mousePos.x;
	xformMouseZ0.y = mousePos.y;
	xformMouseZ1.x = mousePos.x;
	xformMouseZ1.y = mousePos.y;
	lego::view::Viewport_InverseTransform(view,&xformVecZ0,&xformMouseZ0);
	lego::view::Viewport_InverseTransform(view,&xformVecZ1,&xformMouseZ1);
	fVar2 = xformVecZ1.x - xformVecZ0.x;
	fVar1 = xformVecZ1.y - xformVecZ0.y;
	fVar3 = xformVecZ1.z - xformVecZ0.z;
	fVar4 = 1.0 / SQRT(fVar3 * fVar3 + fVar1 * fVar1 + fVar2 * fVar2);
	xformVecZ1.x = fVar4 * fVar2;
	xformVecZ1.y = fVar4 * fVar1;
	xformVecZ1.z = fVar4 * fVar3;
	BVar5 = Map3D_Intersections_Sub1_FUN_00450820
										(surfMap,&xformVecZ0,&xformVecZ1,out_vector,&blockPos,0x14);
	if (BVar5 == 0) {
		return 0;
	}
										// Do a 2D loop in range: (-2,-2) -> (2,2)
	loopOffset.y = -2;
	do {
		loopOffset.x = -2;
		do {
			if (((uint)(loopOffset.x + blockPos.x) < (uint)(surfMap->smallDimensions).width) &&
				 ((uint)(blockPos.y + loopOffset.y) < (uint)(surfMap->smallDimensions).height)) {
				Map3D_GetBlockVertexPositions
									(surfMap,loopOffset.x + blockPos.x,blockPos.y + loopOffset.y,vertPoses);
				vector = vertPoses;
				iVar6 = 4;
				pfVar7 = &polyPoints[0].y;
				do {
					lego::view::Viewport_Transform(view,&xformPoly,vector);
					vector = vector + 1;
					iVar6 += -1;
					pfVar7[-1] = xformPoly.x / xformPoly.w;
					*pfVar7 = xformPoly.y / xformPoly.w;
					pfVar7 = pfVar7 + 2;
				} while (iVar6 != 0);
				polyPoints[4].x = polyPoints[0].x;
				polyPoints[4].y = polyPoints[0].y;
				BVar5 = math::Maths_PointInsidePoly(&mousePos,polyPoints,polyPoints + 1,4);
				if (BVar5 != 0) {
					*out_bx = loopOffset.x + blockPos.x;
					*out_by = blockPos.y + loopOffset.y;
					Map3D_Intersections_Sub2_FUN_004518a0
										(surfMap,*out_bx,blockPos.y + loopOffset.y,&xformVecZ0,&xformVecZ1,out_vector);
					return TRUE;
				}
			}
			loopOffset.x += 1;
		} while (loopOffset.x < 3);
		loopOffset.y += 1;
		if (2 < loopOffset.y) {
			return 0;
		}
	} while( true );
}



BOOL __cdecl
lego::game::Map3D_Intersections_Sub1_FUN_00450820
					(SurfaceMap *surfMap,Vector3F *rayOrigin,Vector3F *ray,Vector3F *out_endPoint,
					Point2I *out_blockPos,int unkCount)
{
	BOOL BVar1;
	float10 fVar2;
	Vector3F planePoint;
	Vector3F planeNormal;
	
	planePoint.x = 0.0;
	planePoint.y = 0.0;
	planePoint.z = -50.0;
	planeNormal.x = 0.0;
	planeNormal.y = 0.0;
	planeNormal.z = -1.0;
	if (unkCount != 0) {
		do {
			math::Maths_RayPlaneIntersection(out_endPoint,rayOrigin,ray,&planePoint,&planeNormal);
			fVar2 = Map3D_GetWorldZ(surfMap,out_endPoint->x,out_endPoint->y);
			planePoint.z = (float)fVar2;
			unkCount += -1;
		} while (unkCount != 0);
	}
	BVar1 = Map3D_WorldToBlockPos_NoZ
										(surfMap,out_endPoint->x,out_endPoint->y,(int *)out_blockPos,&out_blockPos->y);
	return BVar1;
}



void __cdecl
lego::game::Map3D_AddCoordsInRadius_AndDoCallbacks
					(SurfaceMap *surfMap,int in_x,int in_y,int radius,XYCallback *opt_callback)
{
	int rel_y;
	int abs_x;
	int abs_y;
	int neg_radius;
	int rel_x;
	
	neg_radius = -radius;
	if (-radius == radius || SBORROW4(neg_radius,radius) != radius * -2 < 0) {
		abs_y = neg_radius + in_y;
		rel_y = neg_radius;
		do {
			if (neg_radius <= radius) {
				abs_x = neg_radius + in_x;
				rel_x = neg_radius;
				do {
					if ((((rel_x * rel_x + rel_y * rel_y <= radius * radius) && (-1 < abs_x)) &&
							(abs_x < (surfMap->smallDimensions).width)) &&
						 ((-1 < abs_y && (abs_y < (surfMap->smallDimensions).height)))) {
						Map3D_DoForBlockIndex_Mesh_FUN_00474df0(surfMap,abs_x,abs_y,0);
						if (opt_callback != NULL) {
							(*opt_callback)(abs_x,abs_y);
						}
						surfMap->smallCoordsTable[surfMap->smallCoordsNum].sx = (short)rel_x + (short)in_x;
						surfMap->smallCoordsTable[surfMap->smallCoordsNum].sy = (short)rel_y + (short)in_y;
						surfMap->smallCoordsNum = surfMap->smallCoordsNum + 1;
					}
					rel_x += 1;
					abs_x += 1;
				} while (rel_x <= radius);
			}
			rel_y += 1;
			abs_y += 1;
		} while (rel_y <= radius);
	}
	return;
}



void __cdecl
lego::game::Map3D_DoForBlockIndex_Mesh_FUN_00474df0(SurfaceMap *surfMap,int x,int y,BOOL state)
{
	res::Container_Mesh_HideGroup(surfMap->resMesh_24,y * (surfMap->smallDimensions).width + x,state);
	return;
}



void __cdecl lego::game::Map3D_AddBlockCoord(SurfaceMap *surfMap,int cx,int vy)
{
	Map3D_DoForBlockIndex_Mesh_FUN_00474df0(surfMap,cx,vy,0);
	surfMap->smallCoordsTable[surfMap->smallCoordsNum].sx = (short)cx;
	surfMap->smallCoordsTable[surfMap->smallCoordsNum].sy = (short)vy;
	surfMap->smallCoordsNum = surfMap->smallCoordsNum + 1;
	return;
}



void __cdecl lego::game::Map3D_DoForCoordsAndClear_Mesh_FUN_00474df0(SurfaceMap *surfMap)
{
	uint uVar1;
	Coord2I *coord;
	
	uVar1 = 0;
	if (surfMap->smallCoordsNum != 0) {
		coord = surfMap->smallCoordsTable;
		do {
			Map3D_DoForBlockIndex_Mesh_FUN_00474df0
								(surfMap,(uint)(ushort)coord->sx,(uint)(ushort)coord->sy,TRUE);
			uVar1 += 1;
			coord = coord + 1;
		} while (uVar1 < surfMap->smallCoordsNum);
	}
	surfMap->smallCoordsNum = 0;
	return;
}



void __cdecl
lego::game::Map3D_BlockVertexToWorldPos
					(SurfaceMap *surfMap,uint bx,uint by,float *out_x,float *out_y,float *out_z)
{
	uint uVar1;
	uint uVar2;
	uint index;
	D3DRMVertex vertices [1];
	
	uVar1 = (surfMap->dimensions).width;
	if (uVar1 <= bx) {
		return;
	}
	if ((uint)(surfMap->dimensions).height <= by) {
		return;
	}
	uVar2 = (surfMap->smallDimensions).width;
	index = 0;
	if (bx == uVar2) {
		if (by == (surfMap->smallDimensions).height) {
			bx -= 1;
			by -= 1;
			index = 2;
			goto LAB_00450ae4;
		}
		if (bx == uVar2) {
			bx -= 1;
			index = 1;
			goto LAB_00450ae4;
		}
	}
	if (by == (surfMap->smallDimensions).height) {
		by -= 1;
		index = 0xffffffff;
	}
LAB_00450ae4:
	if ((surfMap->grid28_28[by * uVar1 + bx].byteflags_19 & 1) != 0) {
		index += 1;
	}
	if (index == 0xffffffff) {
		index = 3;
	}
	res::Container_Mesh_GetVertices(surfMap->resMesh_24,by * uVar2 + bx,index,1,vertices);
	*out_x = vertices[0].position.x;
	*out_y = vertices[0].position.y;
	*out_z = vertices[0].position.z;
	return;
}



float10 __cdecl lego::game::Map3D_GetBlockSize(SurfaceMap *surfMap)
{
	return (float10)surfMap->BlockSize;
}



int __cdecl
lego::unk::Map3D_CheckComparison_FUN_00450b60(int param_1,int param_2,int param_3,int param_4)
{
	int iVar1;
	int iVar2;
	
	iVar2 = -1;
	if (param_1 == param_3) {
		if (param_2 + -1 == param_4) {
			return 0;
		}
		if (param_2 + 1 == param_4) {
			return 2;
		}
	}
	else {
		iVar1 = param_1 + 1;
		if (param_2 == param_4) {
			if (iVar1 == param_3) {
				return 1;
			}
			if (param_1 + -1 == param_3) {
				return 3;
			}
		}
		else {
			if (iVar1 == param_3) {
				if (param_2 + -1 == param_4) {
					return 4;
				}
				if ((iVar1 == param_3) && (param_2 + 1 == param_4)) {
					return 5;
				}
			}
			if (param_1 + -1 == param_3) {
				if (param_2 + 1 == param_4) {
					return 6;
				}
				if ((param_1 + -1 == param_3) && (param_2 + -1 == param_4)) {
					iVar2 = 7;
				}
			}
		}
	}
	return iVar2;
}



void __cdecl lego::game::Map3D_Block_FUN_00450c20(SurfaceMap *surfMap,uint bx,uint by,BOOL param_4)
{
	uint uVar1;
	int iVar2;
	uint uVar3;
	ushort *puVar4;
	
	if (param_4 == 0) {
		if ((surfMap->grid28_28[by * (surfMap->dimensions).width + bx].byteflags_19 & 0x10) != 0) {
			uVar1 = surfMap->largeCoordsNum;
			uVar3 = 0;
			if (uVar1 != 0) {
				puVar4 = (ushort *)&surfMap->largeCoordsTable[0].sy;
				while ((puVar4[-1] != bx || (*puVar4 != by))) {
					uVar3 += 1;
					puVar4 = puVar4 + 2;
					if (uVar1 <= uVar3) {
						return;
					}
				}
				surfMap->largeCoordsNum = uVar1 - 1;
				surfMap->largeCoordsTable[uVar3].sx = surfMap->largeCoordsTable[uVar1 - 1].sx;
				surfMap->largeCoordsTable[uVar3].sy = surfMap->largeCoordsTable[surfMap->largeCoordsNum].sy;
				iVar2 = by * (surfMap->dimensions).width + bx;
				surfMap->grid28_28[iVar2].byteflags_19 = surfMap->grid28_28[iVar2].byteflags_19 & 0xef;
			}
		}
	}
	else {
		if ((surfMap->grid28_28[by * (surfMap->dimensions).width + bx].byteflags_19 & 0x10) == 0) {
			surfMap->largeCoordsTable[surfMap->largeCoordsNum].sx = (short)bx;
			surfMap->largeCoordsTable[surfMap->largeCoordsNum].sy = (short)by;
			iVar2 = by * (surfMap->dimensions).width + bx;
			surfMap->largeCoordsNum = surfMap->largeCoordsNum + 1;
			surfMap->grid28_28[iVar2].byteflags_19 = surfMap->grid28_28[iVar2].byteflags_19 | 0x10;
			return;
		}
	}
	return;
}



void __cdecl lego::game::Map3D_Coords_SetEmissive(SurfaceMap *surfMap,BOOL doEmissive)
{
	uint uVar1;
	Coord2I *pCVar2;
	
	if ((doEmissive != 0) && ((*(byte *)&surfMap->flags_73d0 & 4) == 0)) {
		uVar1 = 0;
		if (surfMap->largeCoordsNum != 0) {
			pCVar2 = surfMap->largeCoordsTable;
			do {
				res::Container_Mesh_SetEmissive
									(surfMap->resMesh_24,
									 (uint)(ushort)pCVar2->sy * (surfMap->smallDimensions).width +
									 (uint)(ushort)pCVar2->sx,0.3,0.3,0.3);
				uVar1 += 1;
				pCVar2 = pCVar2 + 1;
			} while (uVar1 < surfMap->largeCoordsNum);
		}
		surfMap->flags_73d0 = surfMap->flags_73d0 | 4;
		return;
	}
	if ((doEmissive == 0) && ((*(byte *)&surfMap->flags_73d0 & 4) != 0)) {
		uVar1 = 0;
		if (surfMap->largeCoordsNum != 0) {
			pCVar2 = surfMap->largeCoordsTable;
			do {
				res::Container_Mesh_SetEmissive
									(surfMap->resMesh_24,
									 (uint)(ushort)pCVar2->sy * (surfMap->smallDimensions).width +
									 (uint)(ushort)pCVar2->sx,0.0,0.0,0.0);
				uVar1 += 1;
				pCVar2 = pCVar2 + 1;
			} while (uVar1 < surfMap->largeCoordsNum);
		}
		surfMap->flags_73d0 = surfMap->flags_73d0 & 0xfffffffb;
	}
	return;
}



void __cdecl lego::game::Map3D_Update_Pass1_CoordsTextureUVs(SurfaceMap *surfMap,float elapsedGame)
{
	Point2F *pPVar1;
	byte bVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	ushort *pCoordY;
	int sxOff;
	D3DRMGroupIndex groupID;
	uint dirOff;
	uint sx;
	uint sy;
	int syOff;
	float10 fVar8;
	float10 fVar9;
	float10 fVar10;
	uint local_11c;
	Point2F baseUV;
	Point2F randUV;
	Point2F *pOffset_F;
	Point2I *pOffset_I;
	uint dirIndex;
	uint tableIndex;
	Point2F OFFSETS_F [4];
	Point2I OFFSETS_I [4];
	D3DRMVertex vertices [4];
	int sxDiff;
	
	if ((ushort)((ushort)(elapsedGame < 0.001) << 8 | (ushort)(elapsedGame == 0.001) << 0xe) == 0) {
		OFFSETS_I[1].x = 1;
		OFFSETS_I[2].x = 1;
		OFFSETS_I[2].y = 1;
		OFFSETS_I[3].y = 1;
		OFFSETS_F[0].x = 0.0;
		OFFSETS_F[0].y = 1.0;
		OFFSETS_F[1].x = 1.0;
		OFFSETS_F[1].y = 1.0;
		OFFSETS_F[2].x = 1.0;
		OFFSETS_F[2].y = 0.0;
		OFFSETS_F[3].x = 0.0;
		OFFSETS_F[3].y = 0.0;
		OFFSETS_I[0].x = 0;
		OFFSETS_I[0].y = 0;
		OFFSETS_I[1].y = 0;
		OFFSETS_I[3].x = 0;
		tableIndex = 0;
		if (surfMap->largeCoordsNum != 0) {
			fVar5 = 50.0 / elapsedGame;
			pCoordY = (ushort *)&surfMap->largeCoordsTable[0].sy;
			fVar6 = 1.0 / (fVar5 - -1.0);
			do {
				sy = (uint)*pCoordY;
				sx = (uint)pCoordY[-1];
				groupID = (surfMap->smallDimensions).width * sy + sx;
				bVar2 = surfMap->grid28_28[sy * (surfMap->dimensions).width + sx].byteflags_19;
				res::Container_Mesh_GetVertices(surfMap->resMesh_24,groupID,0,4,vertices);
				pOffset_F = OFFSETS_F;
				pOffset_I = OFFSETS_I;
				dirIndex = 0;
				local_11c = 0;
				do {
					dirOff = dirIndex;
					if ((bVar2 & 1) != 0) {
						dirOff = dirIndex + 1 & 3;
					}
					syOff = sy + *(int *)((int)&OFFSETS_I[0].y + local_11c);
					sxDiff = pOffset_I->x;
					sxOff = syOff * (surfMap->dimensions).width + sx + sxDiff;
					fVar3 = vertices[dirOff].tu;
					randUV.x = surfMap->grid28_28[sxOff].textuv_1c.x + pOffset_F->x;
					fVar4 = vertices[dirOff].tv;
					randUV.y = surfMap->grid28_28[sxOff].textuv_1c.y +
										 *(float *)((int)&OFFSETS_F[0].y + local_11c);
					fVar7 = SQRT((fVar4 - randUV.y) * (fVar4 - randUV.y) +
											 (fVar3 - randUV.x) * (fVar3 - randUV.x));
					baseUV.x = randUV.x;
					baseUV.y = randUV.y;
					if (((ushort)((ushort)(fVar7 < 0.36) << 8 | (ushort)(fVar7 == 0.36) << 0xe) != 0) &&
						 (baseUV.x = fVar3, baseUV.y = fVar4, fVar7 < 0.05)) {
						fVar8 = math::Maths_RandRange(0.0,1.0);
						fVar3 = (float)fVar8;
						fVar8 = math::Maths_RandRange(0.0,1.0);
						pPVar1 = &surfMap->grid28_28[syOff * (surfMap->dimensions).width + sx + sxDiff].
											textuv_1c;
						fVar9 = (float10)1.0 /
										SQRT(fVar8 * (float10)(float)fVar8 + (float10)fVar3 * (float10)fVar3);
						fVar10 = ((float10)pPVar1->x + fVar9 * (float10)fVar3) * (float10)0.3;
						fVar3 = (pPVar1->y + (float)(fVar9 * (float10)(float)fVar8)) * 0.3;
						randUV.y = fVar3 + *(float *)((int)&OFFSETS_F[0].y + local_11c);
						randUV.x = (float)(fVar10 + (float10)pOffset_F->x);
						pPVar1->x = (float)fVar10;
						pPVar1->y = fVar3;
					}
					local_11c += 8;
					pOffset_I = pOffset_I + 1;
					pOffset_F = pOffset_F + 1;
					vertices[dirOff].tu = fVar6 * (fVar5 * baseUV.x + randUV.x);
					dirIndex += 1;
					vertices[dirOff].tv = fVar6 * (fVar5 * baseUV.y + randUV.y);
				} while (local_11c < 0x20);
				res::Container_Mesh_SetVertices(surfMap->resMesh_24,groupID,0,4,vertices);
				tableIndex += 1;
				pCoordY = pCoordY + 2;
			} while (tableIndex < surfMap->largeCoordsNum);
		}
	}
	return;
}



void __cdecl lego::game::Map3D_Block_UpdateTextureAndVertices(SurfaceMap *surfMap,uint bx,uint by)
{
	float fVar1;
	float fVar2;
	float *pfVar3;
	BOOL BVar4;
	uint by_00;
	int iVar5;
	float *pfVar6;
	Vector3F *pVVar7;
	Direction DVar8;
	float *pfVar9;
	uint uVar10;
	float *pfVar11;
	longlong lVar12;
	longlong lVar13;
	longlong lVar14;
	Direction direction;
	uint vertIndex;
	Vector3F *pVVar15;
	int local_a0;
	int local_94;
	float local_80 [5];
	undefined4 local_6c;
	undefined4 local_68;
	undefined4 local_64;
	Vector3F local_60;
	undefined4 local_54;
	undefined4 local_50;
	undefined4 local_4c;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40;
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	Vector3F local_30 [4];
	
	DVar8 = DIRECTION_UP;
	local_80[0] = 0.0;
	local_80[1] = 0.0;
	local_80[2] = -1.0;
	local_80[3] = 0.0;
	local_80[4] = -1.0;
	local_6c = 0xbf800000;
	local_68 = 0;
	local_64 = 0xbf800000;
	local_60.x = 0.0;
	local_60.y = 0.0;
	local_60.z = 0.0;
	local_54 = 0;
	local_50 = 0;
	local_4c = 0;
	local_48 = 0;
	local_44 = 0;
	local_40 = 0;
	local_3c = 0;
	local_38 = 0;
	local_34 = 0;
	iVar5 = 4;
	pfVar3 = local_80 + 1;
	do {
		iVar5 += -1;
		pfVar3[-1] = pfVar3[-1] + (float)(ulonglong)bx;
		*pfVar3 = (float)(ulonglong)by + *pfVar3;
		pfVar3 = pfVar3 + 2;
	} while (iVar5 != 0);
	pfVar3 = local_80;
	pVVar7 = local_30;
	do {
		direction = DVar8;
		pVVar15 = pVVar7;
		lVar12 = __ftol((float10)pfVar3[1]);
		uVar10 = (uint)lVar12;
		lVar12 = __ftol((float10)*pfVar3);
		Map3D_Block_GetUnkDirectionVector0_or_C(surfMap,(uint)lVar12,uVar10,direction,pVVar15);
		DVar8 += DIRECTION_RIGHT;
		pVVar7 = pVVar7 + 1;
		pfVar3 = pfVar3 + 2;
	} while (DVar8 < DIRECTION__COUNT);
	pfVar3 = local_80;
	local_a0 = 4;
	pfVar9 = &local_60.z;
	do {
		lVar12 = __ftol((float10)pfVar3[1]);
		lVar13 = __ftol((float10)*pfVar3);
		pfVar11 = local_80;
		pfVar6 = &local_30[0].z;
		local_94 = 4;
		do {
			lVar14 = __ftol((float10)pfVar11[1]);
			uVar10 = (uint)lVar14;
			lVar14 = __ftol((float10)*pfVar11);
			BVar4 = Map3D_BlockPair_HasTextureMatch(surfMap,(uint)lVar13,(uint)lVar12,(uint)lVar14,uVar10)
			;
			if (BVar4 == 0) {
				fVar1 = pfVar6[-1];
				fVar2 = *pfVar6;
				pfVar9[-2] = pfVar6[-2] + pfVar9[-2];
				pfVar9[-1] = fVar1 + pfVar9[-1];
				*pfVar9 = fVar2 + *pfVar9;
			}
			pfVar11 = pfVar11 + 2;
			pfVar6 = pfVar6 + 3;
			local_94 += -1;
		} while (local_94 != 0);
		pfVar3 = pfVar3 + 2;
		local_a0 += -1;
		fVar1 = 1.0 / SQRT(pfVar9[-2] * pfVar9[-2] + *pfVar9 * *pfVar9 + pfVar9[-1] * pfVar9[-1]);
		*pfVar9 = fVar1 * *pfVar9;
		pfVar9[-2] = fVar1 * pfVar9[-2];
		pfVar9[-1] = fVar1 * pfVar9[-1];
		pfVar9 = pfVar9 + 3;
	} while (local_a0 != 0);
	uVar10 = 0;
	pfVar3 = local_80;
	pVVar7 = &local_60;
	do {
		vertIndex = uVar10;
		pVVar15 = pVVar7;
		lVar12 = __ftol((float10)pfVar3[1]);
		by_00 = (uint)lVar12;
		lVar12 = __ftol((float10)*pfVar3);
		Map3D_Block_SetIndexVertexNormal(surfMap,(uint)lVar12,by_00,vertIndex,pVVar15);
		uVar10 += 1;
		pVVar7 = pVVar7 + 1;
		pfVar3 = pfVar3 + 2;
	} while (uVar10 < 4);
	return;
}



BOOL __cdecl
lego::game::Map3D_BlockPair_HasTextureMatch(SurfaceMap *surfMap,uint bx1,uint by1,uint bx2,uint by2)
{
	uint uVar1;
	int iVar2;
	uint uVar3;
	SurfaceTexture tex1;
	SurfaceTexture tex2;
	
	if (((((by1 != by2) || (bx1 != bx2)) && (uVar3 = (surfMap->smallDimensions).width, bx1 < uVar3))
			&& ((uVar1 = (surfMap->smallDimensions).height, by1 < uVar1 && (bx2 < uVar3)))) &&
		 (by2 < uVar1)) {
		iVar2 = (surfMap->dimensions).width;
		tex1 = surfMap->grid28_28[by1 * iVar2 + bx1].texture;
		tex2 = surfMap->grid28_28[by2 * iVar2 + bx2].texture;
										// Find a texture coord match for the 2 block positions
		by1 = (uint)tex1;
		if ((tex1 != TEXTURE__INVALID) && (tex2 != TEXTURE__INVALID)) {
			uVar3 = 0;
										// if (surfMap->texsNum[tex1] != 0)
			if (surfMap->texsNum[by1] != 0) {
				do {
										// if (surfMap->texsGrid[tex1][i] == tex2)
					if (surfMap->texsGrid[by1][uVar3] == tex2) {
						return TRUE;
					}
					uVar3 += 1;
				} while (uVar3 < surfMap->texsNum[by1]);
				return 0;
			}
		}
	}
	return 0;
}



void __cdecl
lego::game::Map3D_Block_SetIndexVertexNormal
					(SurfaceMap *surfMap,uint bx,uint by,uint vertIndex,Vector3F *vertNormal)
{
	D3DRMGroupIndex groupID;
	D3DRMVertex vertices [1];
	uint width;
	
	width = (surfMap->smallDimensions).width;
	groupID = by * width + bx;
	if ((bx < width) && (by < (uint)(surfMap->smallDimensions).height)) {
		if ((surfMap->grid28_28[(surfMap->dimensions).width * by + bx].byteflags_19 & 1) != 0) {
			vertIndex = vertIndex + 1 & 3;
		}
		res::Container_Mesh_GetVertices(surfMap->resMesh_24,groupID,vertIndex,1,vertices);
		vertices[0].normal.x = vertNormal->x;
		vertices[0].normal.y = vertNormal->y;
		vertices[0].normal.z = vertNormal->z;
		res::Container_Mesh_SetVertices(surfMap->resMesh_24,groupID,vertIndex,1,vertices);
	}
	return;
}



BOOL __cdecl
lego::game::Map3D_Block_GetUnkDirectionVector0_or_C
					(SurfaceMap *surfMap,uint bx,uint by,Direction direction,Vector3F *out_vector)
{
	SurfaceMapStruct_28 *pSVar1;
	Vector3F *pVVar2;
	float fVar3;
	int iVar4;
	
	if ((bx < (uint)(surfMap->smallDimensions).width) &&
		 (by < (uint)(surfMap->smallDimensions).height)) {
		pSVar1 = surfMap->grid28_28 + by * (surfMap->dimensions).width + bx;
		if ((pSVar1->byteflags_19 & 1) != 0) {
			direction = direction + DIRECTION_RIGHT & DIRECTION_LEFT;
		}
		if (direction == DIRECTION_UP) {
			out_vector->x = (pSVar1->vector_0).x;
			out_vector->y = (pSVar1->vector_0).y;
			out_vector->z = (pSVar1->vector_0).z;
		}
		if (direction == DIRECTION_DOWN) {
			pVVar2 = &surfMap->grid28_28[by * (surfMap->dimensions).width + bx].vector_c;
			out_vector->x = pVVar2->x;
			out_vector->y = pVVar2->y;
			out_vector->z = pVVar2->z;
		}
		if ((direction == DIRECTION_RIGHT) || (direction == DIRECTION_LEFT)) {
			pSVar1 = surfMap->grid28_28 + by * (surfMap->dimensions).width + bx;
			out_vector->x = (pSVar1->vector_0).x;
			out_vector->y = (pSVar1->vector_0).y;
			out_vector->z = (pSVar1->vector_0).z;
			iVar4 = by * (surfMap->dimensions).width + bx;
			pVVar2 = &surfMap->grid28_28[iVar4].vector_c;
			out_vector->x = surfMap->grid28_28[iVar4].vector_c.x + out_vector->x;
			out_vector->y = pVVar2->y + out_vector->y;
			fVar3 = pVVar2->z + out_vector->z;
			out_vector->z = fVar3;
			fVar3 = 1.0 / SQRT(out_vector->x * out_vector->x +
												 fVar3 * fVar3 + out_vector->y * out_vector->y);
			out_vector->x = fVar3 * out_vector->x;
			out_vector->y = fVar3 * out_vector->y;
			out_vector->z = fVar3 * out_vector->z;
		}
		return TRUE;
	}
	out_vector->z = 0.0;
	out_vector->y = 0.0;
	out_vector->x = 0.0;
	return 0;
}



void __cdecl
lego::game::Map3D_Block_SetIndexVertexPosition
					(SurfaceMap *surfMap,uint bx,uint by,uint vertIndex,Vector3F *vertPosition)
{
	D3DRMGroupIndex groupID;
	D3DRMVertex vertices [1];
	uint width;
	
	width = (surfMap->smallDimensions).width;
	groupID = by * width + bx;
	if ((bx < width) && (by < (uint)(surfMap->smallDimensions).height)) {
		if ((surfMap->grid28_28[(surfMap->dimensions).width * by + bx].byteflags_19 & 1) != 0) {
			vertIndex = vertIndex + 1 & 3;
		}
		res::Container_Mesh_GetVertices(surfMap->resMesh_24,groupID,vertIndex,1,vertices);
		vertices[0].position.x = vertPosition->x + vertices[0].position.x;
		vertices[0].position.y = vertPosition->y + vertices[0].position.y;
		vertices[0].position.z = vertPosition->z + vertices[0].position.z;
		res::Container_Mesh_SetVertices(surfMap->resMesh_24,groupID,vertIndex,1,vertices);
	}
	return;
}



void __cdecl lego::game::Map3D_Block_InitPlaneNormals(SurfaceMap *surfMap,uint bx,uint by)
{
	D3DRMVertex vertices [4];
	uint width;
	
	width = (surfMap->smallDimensions).width;
	if ((bx < width) && (by < (uint)(surfMap->smallDimensions).height)) {
		res::Container_Mesh_GetVertices(surfMap->resMesh_24,by * width + bx,0,4,vertices);
										// (&surfMap->ptr_28[sy * surfMap->dimensions.width + sx].vector_0,
										//   &vertices[0].position, &vertices[1].position, &vertices[2].position)
		math::Maths_PlaneNormal
							((Vector3F *)(surfMap->grid28_28 + by * (surfMap->dimensions).width + bx),
							 (Vector3F *)vertices,(Vector3F *)(vertices + 1),(Vector3F *)(vertices + 3));
										// (&surfMap->ptr_28[sy * surfMap->dimensions.width + sx].vector_c,
										//   &vertices[1].position, &vertices[2].position, &vertices[3].position)
										// 
										// NOTE: index is shift one after the previous call
		math::Maths_PlaneNormal
							(&surfMap->grid28_28[by * (surfMap->dimensions).width + bx].vector_c,
							 (Vector3F *)(vertices + 1),(Vector3F *)(vertices + 2),(Vector3F *)(vertices + 3));
	}
	return;
}



void __cdecl
lego::game::MapFile_GetDimensions(MapFileInfo *mapFileInfo,int *out_width,int *out_height)
{
	*out_width = (mapFileInfo->dimensions).width;
	*out_height = (mapFileInfo->dimensions).height;
	return;
}



ushort __cdecl lego::game::MapFile_GetBlock(MapFileInfo *mapFile,int x,int y,int width)
{
	return mapFile->blocks[width * y + x];
}



BOOL __cdecl
lego::game::Map3D_Intersections_Sub2_FUN_004518a0
					(SurfaceMap *surfMap,uint bx,uint by,Vector3F *param_4,Vector3F *param_5,
					Vector3F *out_vector)
{
	SurfaceMapStruct_28 *pSVar1;
	Vector3F *pVVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	bool bVar9;
	int iVar10;
	BOOL BVar11;
	Point2F local_88;
	Vector3F local_7c;
	Point2F local_70;
	Point2F local_68;
	float local_60;
	float local_5c;
	float local_58;
	float local_54;
	Vector3F local_50;
	Vector3F local_44;
	int local_38;
	BOOL local_34;
	Vector3F local_30;
	float local_24;
	float local_20;
	Vector3F local_18;
	float local_c;
	float local_8;
	
	local_34 = Map3D_GetBlockVertexPositions(surfMap,bx,by,&local_30);
	bVar9 = false;
	local_38 = 0;
	iVar10 = by * (surfMap->dimensions).width + bx;
	pSVar1 = surfMap->grid28_28 + iVar10;
	local_7c.x = surfMap->grid28_28[iVar10].vector_0.x;
	local_7c.y = (pSVar1->vector_0).y;
	local_7c.z = (pSVar1->vector_0).z;
	BVar11 = math::Maths_RayPlaneIntersection(&local_50,param_4,param_5,&local_30,&local_7c);
	if (BVar11 != 0) {
		if (local_34 == 0) {
			local_68.x = local_24;
			local_68.y = local_20;
		}
		else {
			local_68.x = local_18.x;
			local_68.y = local_18.y;
		}
		local_88.x = local_50.x;
		local_88.y = local_50.y;
		BVar11 = math::Maths_PointInsidePoly(&local_88,&local_70,&local_68,3);
		if (BVar11 != 0) {
			bVar9 = true;
		}
	}
	iVar10 = by * (surfMap->dimensions).width + bx;
	pVVar2 = &surfMap->grid28_28[iVar10].vector_c;
	local_7c.x = surfMap->grid28_28[iVar10].vector_c.x;
	local_7c.y = pVVar2->y;
	local_7c.z = pVVar2->z;
	BVar11 = math::Maths_RayPlaneIntersection(&local_44,param_4,param_5,&local_18,&local_7c);
	if (BVar11 != 0) {
		if (local_34 == 0) {
			local_68.x = local_18.x;
			local_68.y = local_18.y;
			local_60 = local_c;
			local_5c = local_8;
			local_58 = local_24;
			local_54 = local_20;
		}
		else {
			local_68.x = local_24;
			local_68.y = local_20;
			local_60 = local_18.x;
			local_5c = local_18.y;
			local_58 = local_30.x;
			local_54 = local_30.y;
		}
		local_88.x = local_44.x;
		local_88.y = local_44.y;
		local_70.x = local_58;
		local_70.y = local_54;
		BVar11 = math::Maths_PointInsidePoly(&local_88,&local_70,&local_68,3);
		if (BVar11 != 0) {
			local_38 = 1;
		}
	}
	if (!bVar9) {
		if (local_38 == 0) {
			return 0;
		}
		if (true) goto LAB_00451c3e;
	}
	if (local_38 == 0) {
		if (bVar9) {
			out_vector->x = local_50.x;
			out_vector->y = local_50.y;
			out_vector->z = local_50.z;
			return 1;
		}
	}
	else {
		fVar3 = local_50.x - param_4->x;
		fVar4 = local_44.x - param_4->x;
		fVar8 = local_50.y - param_4->y;
		fVar5 = local_44.y - param_4->y;
		fVar7 = local_50.z - param_4->z;
		fVar6 = local_44.z - param_4->z;
		fVar3 = SQRT(fVar7 * fVar7 + fVar8 * fVar8 + fVar3 * fVar3);
		fVar4 = SQRT(fVar6 * fVar6 + fVar5 * fVar5 + fVar4 * fVar4);
		if ((ushort)((ushort)(fVar4 < fVar3) << 8 | (ushort)(fVar4 == fVar3) << 0xe) == 0) {
			out_vector->x = local_50.x;
			out_vector->y = local_50.y;
			out_vector->z = local_50.z;
			return TRUE;
		}
	}
LAB_00451c3e:
	out_vector->x = local_44.x;
	out_vector->y = local_44.y;
	out_vector->z = local_44.z;
	return TRUE;
}



PolyMeshData * __cdecl
lego::res::MeshPoly_CreatePolyMesh
					(PolyMeshData *lastPolyData,char *partName,char *dirname,char *meshFilename,uint index)
{
	char cVar1;
	Container *pCVar2;
	PolyMeshData *pPVar3;
	undefined4 *puVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	char filenameBuffer [256];
	
	std::sprintf(filenameBuffer,"%s\\%s",dirname,meshFilename);
	pCVar2 = Container_Load(NULL,filenameBuffer,"LWO",1);
	if (pCVar2 == NULL) {
		pCVar2 = Container_Load(NULL,filenameBuffer,"MESH",1);
		if (pCVar2 == NULL) {
			return NULL;
		}
	}
	pPVar3 = (PolyMeshData *)std::malloc(0x18);
	pPVar3->flags = 2;
	if (lastPolyData != NULL) {
		lastPolyData->next = pPVar3;
	}
	pPVar3->contMeshOrigin = pCVar2;
	uVar5 = 0xffffffff;
	pPVar3->next = NULL;
	pPVar3->index = index;
	pcVar8 = partName;
	do {
		if (uVar5 == 0) break;
		uVar5 -= 1;
		cVar1 = *pcVar8;
		pcVar8 = pcVar8 + 1;
	} while (cVar1 != '\0');
	puVar4 = (undefined4 *)std::malloc(~uVar5);
	uVar5 = 0xffffffff;
	pPVar3->partName = (char *)puVar4;
	do {
		pcVar8 = partName;
		if (uVar5 == 0) break;
		uVar5 -= 1;
		pcVar8 = partName + 1;
		cVar1 = *partName;
		partName = pcVar8;
	} while (cVar1 != '\0');
	uVar5 = ~uVar5;
	puVar7 = (undefined4 *)(pcVar8 + -uVar5);
	for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
		*puVar4 = *puVar7;
		puVar7 = puVar7 + 1;
		puVar4 = puVar4 + 1;
	}
	for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
		*(undefined *)puVar4 = *(undefined *)puVar7;
		puVar7 = (undefined4 *)((int)puVar7 + 1);
		puVar4 = (undefined4 *)((int)puVar4 + 1);
	}
	pPVar3->contMeshTarget = NULL;
	return pPVar3;
}



PolyMeshData * __cdecl
lego::res::MeshPoly_CreateNullPolyMesh(PolyMeshData *lastPolyData,char *partName,uint index)
{
	char cVar1;
	PolyMeshData *pPVar2;
	undefined4 *puVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	
	pPVar2 = (PolyMeshData *)std::malloc(0x18);
	pPVar2->flags = 2;
	if (lastPolyData != NULL) {
		lastPolyData->next = pPVar2;
	}
	pPVar2->index = index;
	uVar4 = 0xffffffff;
	pPVar2->next = NULL;
	pPVar2->contMeshOrigin = NULL;
	pcVar7 = partName;
	do {
		if (uVar4 == 0) break;
		uVar4 -= 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar7 + 1;
	} while (cVar1 != '\0');
	puVar3 = (undefined4 *)std::malloc(~uVar4);
	uVar4 = 0xffffffff;
	pPVar2->partName = (char *)puVar3;
	do {
		pcVar7 = partName;
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar7 = partName + 1;
		cVar1 = *partName;
		partName = pcVar7;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar6 = (undefined4 *)(pcVar7 + -uVar4);
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar3 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar3 = puVar3 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar3 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar3 = (undefined4 *)((int)puVar3 + 1);
	}
	pPVar2->contMeshTarget = NULL;
	return pPVar2;
}



PolyMeshData * __cdecl lego::res::MeshPoly_Duplicate(PolyMeshData *polyData)
{
	PolyMeshData *pPVar1;
	int iVar2;
	int iVar3;
	uint *puVar4;
	PolyMeshData *pPVar5;
	Container **ppCVar6;
	
	iVar2 = 0;
	pPVar1 = polyData;
	if (polyData != NULL) {
		do {
			pPVar1 = pPVar1->next;
			iVar2 += 1;
		} while (pPVar1 != NULL);
	}
	if (iVar2 == 0) {
		return NULL;
	}
	pPVar1 = (PolyMeshData *)std::malloc(iVar2 * 0x18);
	iVar2 = 0;
	if (polyData != NULL) {
		puVar4 = &pPVar1->flags;
		do {
			pPVar5 = polyData;
			ppCVar6 = (Container **)(puVar4 + -4);
			for (iVar3 = 6; iVar3 != 0; iVar3 += -1) {
				*ppCVar6 = pPVar5->contMeshOrigin;
				pPVar5 = (PolyMeshData *)&pPVar5->contMeshTarget;
				ppCVar6 = ppCVar6 + 1;
			}
			puVar4[-3] = 0;
			iVar2 += 1;
			*puVar4 = *puVar4 & 0xfffffffd | 1;
			puVar4[1] = (uint)(puVar4 + 2);
			polyData = polyData->next;
			puVar4 = puVar4 + 6;
		} while (polyData != NULL);
	}
	pPVar1->flags = pPVar1->flags | 2;
	pPVar1[iVar2 + -1].next = NULL;
	return pPVar1;
}



void __cdecl
lego::res::MeshPoly_Container_SwapFrame
					(PolyMeshData *polyData,Container *contAct,BOOL restore,int frameIndex)
{
	char *name;
	Container *contTarget;
	
	if (polyData != NULL) {
		do {
			if (frameIndex == polyData->index) {
				if (polyData->contMeshTarget == NULL) {
					name = Container_FormatPartName(contAct,polyData->partName,NULL);
					contTarget = Container_SearchTree(contAct,name,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
					polyData->contMeshTarget = contTarget;
				}
				if (polyData->contMeshTarget != NULL) {
					Container_Mesh_Swap(polyData->contMeshTarget,polyData->contMeshOrigin,restore);
				}
			}
			polyData = polyData->next;
		} while (polyData != NULL);
	}
	return;
}



void __cdecl lego::res::MeshPoly_FUN_00451ef0(PolyMeshData *polyData)
{
	if (polyData != NULL) {
		do {
			polyData->contMeshTarget = NULL;
			polyData = polyData->next;
		} while (polyData != NULL);
	}
	return;
}



void __cdecl lego::res::MeshPoly_Destroy(PolyMeshData *polyData)
{
	PolyMeshData **ppPVar1;
	PolyMeshData *pPVar2;
	PolyMeshData *pPVar3;
	PolyMeshData *pPVar4;
	
	pPVar3 = NULL;
	pPVar2 = polyData;
	pPVar4 = pPVar3;
	if (polyData != NULL) {
		do {
			if ((*(byte *)&pPVar2->flags & 1) == 0) {
				if (pPVar2->partName != NULL) {
					std::free(pPVar2->partName);
				}
				if (pPVar2->contMeshOrigin != NULL) {
					Container_Remove(pPVar2->contMeshOrigin);
				}
			}
			pPVar3 = pPVar2;
			if (((*(byte *)&pPVar2->flags & 2) == 0) && (pPVar3 = pPVar4, pPVar4 != NULL)) {
				pPVar4->next = pPVar2->next;
			}
			ppPVar1 = &pPVar2->next;
			pPVar2 = *ppPVar1;
			pPVar4 = pPVar3;
		} while (*ppPVar1 != NULL);
	}
	if ((pPVar3 != NULL) && (polyData != NULL)) {
		do {
			pPVar2 = polyData->next;
			std::free(polyData);
			polyData = pPVar2;
		} while (pPVar2 != NULL);
	}
	return;
}



void __cdecl lego::game::Message_Initialise(void)
{
	globs::messageGlobs.messageName[0] = "Message_Null";
	globs::messageGlobs.messageName[1] = "Message_Select";
	globs::messageGlobs.messageName[2] = "Message_Selected";
	globs::messageGlobs.messageName[3] = "Message_ClearSelection";
	globs::messageGlobs.messageName[4] = "Message_Deselect";
	globs::messageGlobs.messageName[5] = "Message_Goto";
	globs::messageGlobs.messageName[6] = "Message_RockMonsterGoto";
	globs::messageGlobs.messageName[7] = "Message_RockMonsterGotoComplete";
	globs::messageGlobs.messageName[8] = "Message_UserGoto";
	globs::messageGlobs.messageName[9] = "Message_FirstPerson";
	globs::messageGlobs.messageName[10] = "Message_TrackObject";
	globs::messageGlobs.messageName[11] = "Message_TopView";
	globs::messageGlobs.messageName[12] = "Message_PlaySample";
	globs::messageGlobs.messageName[13] = "Message_Dig";
	globs::messageGlobs.messageName[14] = "Message_DigComplete";
	globs::messageGlobs.messageName[15] = "Message_Repair";
	globs::messageGlobs.messageName[16] = "Message_RepairComplete";
	globs::messageGlobs.messageName[17] = "Message_Reinforce";
	globs::messageGlobs.messageName[18] = "Message_ReinforceComplete";
	globs::messageGlobs.messageName[19] = "Message_RockFall";
	globs::messageGlobs.messageName[20] = "Message_RockFallComplete";
	globs::messageGlobs.messageName[21] = "Message_GenerateCrystal";
	globs::messageGlobs.messageName[22] = "Message_GenerateCrystalComplete";
	globs::messageGlobs.messageName[23] = "Message_CollectCrystal";
	globs::messageGlobs.messageName[24] = "Message_CollectCrystalComplete";
	globs::messageGlobs.messageName[25] = "Message_CrystalToRefinery";
	globs::messageGlobs.messageName[26] = "Message_CrystalToRefineryComplete";
	globs::messageGlobs.messageName[27] = "Message_GenerateOre";
	globs::messageGlobs.messageName[28] = "Message_GenerateOreComplete";
	globs::messageGlobs.messageName[29] = "Message_CollectOre";
	globs::messageGlobs.messageName[30] = "Message_CollectOreComplete";
	globs::messageGlobs.messageName[31] = "Message_GenerateRockMonster";
	globs::messageGlobs.messageName[32] = "Message_GenerateRockMonsterComplete";
	globs::messageGlobs.messageName[33] = "Message_GatherRock";
	globs::messageGlobs.messageName[34] = "Message_GatherRockComplete";
	globs::messageGlobs.messageName[35] = "Message_PickRandomFloor";
	globs::messageGlobs.messageName[36] = "Message_PickRandomFloorComplete";
	globs::messageGlobs.messageName[37] = "Message_AttackBuilding";
	globs::messageGlobs.messageName[38] = "Message_AttackBuildingComplete";
	globs::messageGlobs.messageName[39] = "Message_Clear";
	globs::messageGlobs.messageName[40] = "Message_ClearComplete";
	globs::messageGlobs.messageName[41] = "Message_GetIn";
	globs::messageGlobs.messageName[42] = "Message_ManSelectedAndMonsterClicked";
	globs::messageGlobs.messageName[43] = "Message_FollowAttack";
	globs::messageGlobs.messageName[44] = "Message_CollectTool";
	globs::messageGlobs.messageName[45] = "Message_ReduceSelection";
	globs::messageGlobs.messageName[46] = "Message_ClearFallIn";
	globs::messageGlobs.messageName[47] = "Message_ClearFallInComplete";
	globs::messageGlobs.messageName[48] = "Message_BuildPath";
	globs::messageGlobs.messageName[49] = "Message_BuildPathComplete";
	globs::messageGlobs.messageName[50] = "Message_Train";
	globs::messageGlobs.messageName[51] = "Message_TrainComplete";
	globs::messageGlobs.messageName[52] = "Message_GenerateCrystalAndOre";
	globs::messageGlobs.messageName[53] = "Message_GenerateCrystalAndOreComplete";
	globs::messageGlobs.messageName[54] = "Message_GenerateFromCryOre";
	globs::messageGlobs.messageName[55] = "Message_GenerateFromCryOreComplete";
	globs::messageGlobs.messageName[56] = "Message_Upgrade";
	globs::messageGlobs.messageName[57] = "Message_UpgradeComplete";
	globs::messageGlobs.messageName[58] = "Message_ClearBuilding";
	globs::messageGlobs.messageName[59] = "Message_ClearBuildingComplete";
	globs::messageGlobs.messageName[60] = "Message_ClearInitial";
	globs::messageGlobs.messageName[61] = "Message_ClearInitialComplete";
	globs::messageGlobs.messageName[62] = "Message_ClearRemovePath";
	globs::messageGlobs.messageName[63] = "Message_ClearRemovePathComplete";
	globs::messageGlobs.messageName[64] = "Message_Debug_DestroyAll";
	return;
}



void __cdecl lego::game::Message_LiveObject_FUN_00452220(LiveObject *liveObj)
{
	int iVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	MessageAction *pMVar5;
	MessageAction *pMVar6;
	
	uVar4 = 0;
	uVar2 = globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool];
	if (uVar2 != 0) {
		do {
			uVar3 = uVar2;
			if (liveObj ==
					globs::messageGlobs.messageTableX2[globs::messageGlobs.messageX2Bool][uVar4].argumentObj)
			{
				uVar3 = uVar2 - 1;
				pMVar5 = globs::messageGlobs.messageTableX2[globs::messageGlobs.messageX2Bool + -1] +
								 uVar2 + 0x7ff;
				pMVar6 = globs::messageGlobs.messageTableX2[globs::messageGlobs.messageX2Bool] + uVar4;
				for (iVar1 = 5; iVar1 != 0; iVar1 += -1) {
					pMVar6->event = pMVar5->event;
					pMVar5 = (MessageAction *)&pMVar5->argumentObj;
					pMVar6 = (MessageAction *)(&pMVar6->event + 1);
				}
				globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool] = uVar3;
			}
			uVar4 += 1;
			uVar2 = uVar3;
		} while (uVar4 < uVar3);
	}
	return;
}



int __cdecl lego::game::Message_LookupPTLEventIndex(char *ptlName)
{
	int cmpResult;
	char **ppcVar1;
	int index;
	
	index = 0;
	ppcVar1 = globs::messageGlobs.messageName;
	do {
		cmpResult = std::_stricmp(*ppcVar1 + 8,ptlName);
		if (cmpResult == 0) {
			return index;
		}
		ppcVar1 = ppcVar1 + 1;
		index += 1;
	} while (ppcVar1 < &globs::messageGlobs.reserved1);
	return cmpResult;
}



void __cdecl
lego::game::Message_Debug_RegisterSelectedUnitHotkey
					(KeysByte key,MessageType messageType,LiveObject *argumentObj,undefined4 argument2,
					Point2I *opt_position)
{
	uint uVar1;
	
	globs::messageGlobs.hotkeyList[globs::messageGlobs.hotkeyCount] = key;
	uVar1 = globs::messageGlobs.hotkeyCount;
	globs::messageGlobs.hotkeyMessages[globs::messageGlobs.hotkeyCount].event = messageType;
	globs::messageGlobs.hotkeyMessages[uVar1].argument2 = argument2;
	globs::messageGlobs.hotkeyMessages[uVar1].argumentObj = argumentObj;
	if (opt_position != NULL) {
		globs::messageGlobs.hotkeyMessages[uVar1].position.x = opt_position->x;
		globs::messageGlobs.hotkeyMessages[uVar1].position.y = opt_position->y;
	}
	globs::messageGlobs.hotkeyCount += 1;
	return;
}



void __cdecl
lego::game::Message_AddMessageAction
					(MessageType messageType,LiveObject *argument1Obj,undefined4 argument2,
					Point2I *opt_blockPos)
{
	MessageAction *pMVar1;
	uint uVar2;
	BOOL BVar3;
	
	BVar3 = globs::messageGlobs.messageX2Bool;
	uVar2 = globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool];
	if (uVar2 < 0x800) {
		globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool] = uVar2 + 1;
		pMVar1 = globs::messageGlobs.messageTableX2[BVar3] + uVar2;
		pMVar1->event = MESSAGE_NULL;
		globs::messageGlobs.messageTableX2[BVar3][uVar2].argumentObj = NULL;
		globs::messageGlobs.messageTableX2[BVar3][uVar2].argument2 = 0;
		globs::messageGlobs.messageTableX2[BVar3][uVar2].position.x = 0;
		globs::messageGlobs.messageTableX2[BVar3][uVar2].position.y = 0;
		pMVar1->event = messageType;
		globs::messageGlobs.messageTableX2[BVar3][uVar2].argumentObj = argument1Obj;
		globs::messageGlobs.messageTableX2[BVar3][uVar2].argument2 = argument2;
		if (opt_blockPos != NULL) {
			globs::messageGlobs.messageTableX2[BVar3][uVar2].position.x = opt_blockPos->x;
			globs::messageGlobs.messageTableX2[BVar3][uVar2].position.y = opt_blockPos->y;
		}
	}
	return;
}



void __cdecl lego::game::Message_PTL_Update(void)
{
	BOOL BVar1;
	undefined4 *puVar2;
	LiveObject **ppLVar3;
	uint uVar4;
	
	if (((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) == GAME1_NONE) &&
		 (uVar4 = 0, globs::messageGlobs.hotkeyCount != 0)) {
		puVar2 = &globs::messageGlobs.hotkeyMessages[0].argument2;
		do {
			if (globs::INPUT.Key_Map[globs::messageGlobs.hotkeyList[uVar4]] != false) {
				Message_AddMessageAction(puVar2[-2],puVar2[-1],*puVar2,(Point2I *)(puVar2 + 1));
			}
			uVar4 += 1;
			puVar2 = puVar2 + 5;
		} while (uVar4 < globs::messageGlobs.hotkeyCount);
	}
	uVar4 = 0;
	if (globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool] != 0) {
		do {
			Game_PTLEventToAction__0045db30
								(globs::messageGlobs.messageTableX2[globs::messageGlobs.messageX2Bool] + uVar4);
			uVar4 += 1;
		} while (uVar4 < globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool]);
	}
	BVar1 = globs::messageGlobs.messageX2Bool;
	uVar4 = globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool];
	globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool] = 0;
	globs::messageGlobs.messageX2Bool = ZEXT14(globs::messageGlobs.messageX2Bool == 0);
	globs::messageGlobs.messageCountX2[globs::messageGlobs.messageX2Bool] = 0;
	if (uVar4 != 0) {
		ppLVar3 = (LiveObject **)&globs::messageGlobs.messageTableX2[BVar1][0].argument2;
		do {
			if (true) {
				switch(ppLVar3[-2]) {
				case (LiveObject *)0x1:
					Message_PTL_Select_LiveObject(ppLVar3[-1],(int)*ppLVar3);
					break;
				case (LiveObject *)0x3:
					Message_PTL_ClearSelection();
					break;
				case (LiveObject *)0x4:
					Message_PTL_Deselect_LiveObject(ppLVar3[-1]);
					break;
				case (LiveObject *)0x5:
				case (LiveObject *)0x6:
					ai::AITask_Game_PTL_GotoOrRMGoto(ppLVar3[-1],(Point2I *)(ppLVar3 + 1),*ppLVar3);
					break;
				case (LiveObject *)0x8:
					ai::AITask_Game_PTL_UserGoto
										(globs::messageGlobs.selectedUnitList,globs::messageGlobs.selectedUnitCount,
										 (Point2I *)(ppLVar3 + 1),(BOOL)*ppLVar3);
					break;
				case (LiveObject *)0x9:
					Message_PTL_FirstPerson((int)*ppLVar3);
					break;
				case (LiveObject *)0xa:
					if (globs::messageGlobs.selectedUnitCount != 0) {
						Game_TrackObjectInRadar(globs::messageGlobs.selectedUnitList[0]);
					}
					break;
				case (LiveObject *)0xb:
					Game_SetViewMode(VIEW_TOPDOWN,NULL,0);
					break;
				case (LiveObject *)0xc:
					snd::SFX_Sample_Random_Play_OrAddToQueue((SFXType)*ppLVar3,FALSE);
					break;
				case (LiveObject *)0x13:
					Game_PTL_RockFall((uint)ppLVar3[1],(uint)ppLVar3[2],(uint)*ppLVar3 & 0xffff,
														(uint)*ppLVar3 >> 0x10);
					break;
				case (LiveObject *)0x15:
					Level_GenerateCrystal((Point2I *)(ppLVar3 + 1),0,NULL,TRUE);
					break;
				case (LiveObject *)0x17:
					ai::AITask_DoCollect(ppLVar3[-1],0.0);
					break;
				case (LiveObject *)0x19:
					ai::AITask_Game_PTL_CrystalToRefinery(ppLVar3[-1],*ppLVar3);
					break;
				case (LiveObject *)0x1b:
					Level_GenerateOre((Point2I *)(ppLVar3 + 1),0,NULL,TRUE);
					break;
				case (LiveObject *)0x1d:
					ai::AITask_DoCollect(ppLVar3[-1],0.0);
					break;
				case (LiveObject *)0x1f:
					Game_PTL_GenerateRockMonster();
					break;
				case (LiveObject *)0x21:
					Game_PTL_GatherRock(ppLVar3[-1]);
					break;
				case (LiveObject *)0x23:
					Message_PTL_PickRandomFloor(ppLVar3[-1]);
					break;
				case (LiveObject *)0x25:
					Game_PTL_AttackBuilding(ppLVar3[-1],*ppLVar3);
					break;
				case (LiveObject *)0x2b:
					ai::AITask_Game_PTL_FollowAttack(ppLVar3[-1],*ppLVar3);
					break;
				case (LiveObject *)0x2d:
					Message_PTL_ReduceSelection();
					break;
				case (LiveObject *)0x34:
					Game_PTL_GenerateCrystalsAndOre((Point2I *)(ppLVar3 + 1),0);
					break;
				case (LiveObject *)0x36:
					Game_PTL_GenerateFromCryOre((Point2I *)(ppLVar3 + 1));
					break;
				case (LiveObject *)0x40:
					Message_PTL_Debug_DestroyAll();
				}
			}
			ppLVar3 = ppLVar3 + 5;
			uVar4 -= 1;
		} while (uVar4 != 0);
	}
	return;
}



void __cdecl lego::game::Message_PTL_PickRandomFloor(LiveObject *liveObj)
{
	short rng;
	SurfaceMap *pSVar1;
	BOOL BVar2;
	uint uVar3;
	Point2I blockPos;
	int height;
	bool success;
	int width;
	
	pSVar1 = GetSurfaceMap();
	width = (pSVar1->smallDimensions).width;
	pSVar1 = GetSurfaceMap();
	height = (pSVar1->smallDimensions).height;
	success = false;
	uVar3 = 0;
	do {
		rng = math::Maths_Rand();
		blockPos.x = (int)rng % width;
		rng = math::Maths_Rand();
		blockPos.y = (int)rng % height;
		BVar2 = Level_BlockIsFlags1_8(blockPos.x,blockPos.y);
		if (BVar2 != 0) {
			success = true;
			break;
		}
		uVar3 += 1;
	} while (uVar3 < 1000);
	if (success) {
		Message_AddMessageAction(MESSAGE_PICKRANDOMFLOOR_COMPLETE,liveObj,0,&blockPos);
	}
	return;
}



void __cdecl lego::game::Message_LiveObject_FUN_00452770(LiveObject *liveObj)
{
	Message_LiveObject_FUN_00452220(liveObj);
	Message_PTL_Deselect_LiveObject(liveObj);
	if (globs::gameGlobs.objectFP == liveObj) {
		Game_SetViewMode(VIEW_TOPDOWN,NULL,0);
		globs::gameGlobs.objectFP = NULL;
	}
	if ((globs::gameGlobs.cameraRadar)->trackObj == liveObj) {
		(globs::gameGlobs.cameraRadar)->trackObj = NULL;
		LiveObject_GetPosition
							(liveObj,(float *)&globs::gameGlobs.tvFaceDirection_338,
							 &globs::gameGlobs.tvFaceDirection_338.y);
		globs::gameGlobs.flags1 |= GAME1_UNK_4000;
	}
	return;
}



BOOL __cdecl lego::game::Message_CopySelectedUnits(LiveObject **out_unitsTable,uint *out_unitsCount)
{
	LiveObject *pLVar1;
	uint uVar2;
	int iVar3;
	LiveObject **ppLVar4;
	
	if (globs::messageGlobs.selectedUnitCount != 0) {
		*out_unitsCount = globs::messageGlobs.selectedUnitCount;
		pLVar1 = (LiveObject *)std::malloc(globs::messageGlobs.selectedUnitCount * 4);
		*out_unitsTable = pLVar1;
		ppLVar4 = globs::messageGlobs.selectedUnitList;
		for (uVar2 = *out_unitsCount & 0x3fffffff; uVar2 != 0; uVar2 -= 1) {
			pLVar1->objType = (ObjectType)*ppLVar4;
			ppLVar4 = ppLVar4 + 1;
			pLVar1 = (LiveObject *)&pLVar1->objIndex;
		}
		for (iVar3 = 0; iVar3 != 0; iVar3 += -1) {
			*(undefined *)&pLVar1->objType = *(undefined *)ppLVar4;
			ppLVar4 = (LiveObject **)((int)ppLVar4 + 1);
			pLVar1 = (LiveObject *)((int)&pLVar1->objType + 1);
		}
		return TRUE;
	}
	return 0;
}



// Returns the table of selected units, and can return the number of units in the table with
// out_count

LiveObject ** __cdecl lego::game::Message_GetSelectedUnits(uint *out_count)
{
	if (globs::messageGlobs.selectedUnitCount != 0) {
		if (out_count != NULL) {
			*out_count = globs::messageGlobs.selectedUnitCount;
		}
		return globs::messageGlobs.selectedUnitList;
	}
	if (out_count != NULL) {
		*out_count = 0;
	}
	return NULL;
}



BOOL __cdecl lego::game::Message_IsAnyUnitsSelected(void)
{
	return (uint)(globs::messageGlobs.selectedUnitCount != 0);
}



LiveObject * __cdecl lego::game::Message_GetPrimarySelectedUnit(void)
{
										// Return the first-selected Object if count is non-zero (otherwise address is
										// masked against 0x0)
	return (LiveObject *)
				 (-(uint)(globs::messageGlobs.selectedUnitCount != 0) &
				 (uint)globs::messageGlobs.selectedUnitList[0]);
}



LiveObject ** __cdecl lego::game::Message_GetSelectedUnits(void)
{
	return globs::messageGlobs.selectedUnitList;
}



uint __cdecl lego::game::Message_GetNumSelectedUnits(void)
{
	return globs::messageGlobs.selectedUnitCount;
}



void __cdecl lego::game::Message_CleanupSelectedUnitsCount(void)
{
	globs::messageGlobs.selectedUnitCount = 0;
	return;
}



BOOL __cdecl
lego::game::Message_LiveObject_Check_IsSelected_OrFlags3_200000(LiveObject *liveObj,uint *out_index)
{
	LiveFlags3 LVar1;
	
	if (out_index != NULL) {
		LVar1 = LiveObject_FindIndexOfInTable
											(globs::messageGlobs.selectedUnitList,globs::messageGlobs.selectedUnitCount,
											 liveObj,out_index);
		return LVar1;
	}
	return liveObj->flags3 & LIVEOBJ3_UNK_200000;
}



BOOL __cdecl
lego::game::LiveObject_FindIndexOfInTable
					(LiveObject **objsTable,uint objsCount,LiveObject *thisObj,uint *out_index)
{
	uint i;
	
	i = 0;
	if (objsCount == 0) {
		return 0;
	}
	do {
		if (*objsTable == thisObj) {
			if (out_index != NULL) {
				*out_index = i;
			}
			return TRUE;
		}
		i += 1;
		objsTable = objsTable + 1;
	} while (i < objsCount);
	return 0;
}



BOOL __cdecl lego::game::Message_LiveObject_Check_FUN_00452950(LiveObject *liveObj)
{
	BOOL BVar1;
	
	BVar1 = Message_LiveObject_Check_IsSelected_OrFlags3_200000(liveObj,NULL);
	if ((BVar1 == 0) && ((*(byte *)&liveObj->flags4 & LIVEOBJ4_UNK_2) == 0)) {
		return 0;
	}
	return TRUE;
}



BOOL __cdecl lego::game::Message_PTL_Select_LiveObject(LiveObject *liveObj,int param_2)
{
	BOOL BVar1;
	
	BVar1 = Message_LiveObject_DoSelect_FUN_004529a0(liveObj,param_2,1);
	return BVar1;
}



BOOL __cdecl
lego::game::Message_LiveObject_DoSelect_FUN_004529a0(LiveObject *liveObj,int param_2,int param_3)
{
	BOOL BVar1;
	ObjectStatsFlags1 OVar2;
	Container *cont;
	Point2F local_14;
	Vector3F local_c;
	
	if (liveObj->carryingThisObject != NULL) {
		liveObj = liveObj->carryingThisObject;
	}
	BVar1 = Message_LiveObject_Check_FUN_00452b30(liveObj);
	if (BVar1 != 0) {
		if (param_2 == 0) {
			BVar1 = Message_LiveObject_Check_FUN_00452950(liveObj);
			if (BVar1 != 0) {
				LiveObject_FUN_0044c760(liveObj);
				return 0;
			}
		}
		BVar1 = Message_LiveObject_Check_IsSelected_OrFlags3_200000(liveObj,NULL);
		if ((BVar1 == 0) && (globs::messageGlobs.selectedUnitCount < 100)) {
			Search_LiveObjects_SkipIgnoreMes(LiveObject_FUN_0044c7c0,NULL);
			globs::messageGlobs.selectedUnitList[globs::messageGlobs.selectedUnitCount] = liveObj;
			globs::messageGlobs.selectedUnitCount += 1;
			liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_200000;
			if ((liveObj->objType != OBJECT_BUILDING) &&
				 (((liveObj->flags1 & (LIVEOBJ1_UNK_2000|LIVEOBJ1_UNK_4000000|LIVEOBJ1_REST)) ==
					 LIVEOBJ1_NONE && ((liveObj->flags2 & LIVEOBJ2_UNK_100) == LIVEOBJ2_NONE)))) {
				LiveObject_UnkDoRouting_FUN_00441c00(liveObj,FALSE);
				ai::AITask_VariousGatherTasks_FUN_00403a90(liveObj);
				if ((liveObj->objType == OBJECT_MINIFIGURE) && (param_3 != 0)) {
					res::Container_GetOrientation((globs::gameGlobs.cameraMain)->resData4,NULL,&local_c,NULL);
					local_14.x = -local_c.x;
					local_14.y = -local_c.y;
					LiveObject_FUN_00441df0(liveObj,FALSE,FALSE);
					LiveObject_FUN_00445270(liveObj,&local_14);
				}
			}
			if ((*(byte *)&liveObj->flags3 & LIVEOBJ3_UNK_80) != 0) {
				OVar2 = LiveObject_GetStatsFlags1(liveObj);
				if (((OVar2 & STATS1_CANBEDRIVEN) == STATS1_NONE) || (liveObj->drivenObject != NULL)) {
					cont = LiveObject_GetContainer(liveObj);
					res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(cont,SFX_YESSIR,FALSE,TRUE,NULL);
					return TRUE;
				}
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::Message_LiveObject_Check_FUN_00452b30(LiveObject *liveObj)
{
	BOOL BVar1;
	
	if ((liveObj->flags3 & LIVEOBJ3_CANSELECT) != LIVEOBJ3_NONE) {
		BVar1 = LiveObject_CheckCondition_FUN_00438870(liveObj,TRUE);
		if ((((BVar1 != 0) && ((*(byte *)&liveObj->flags2 & 10) == 0)) &&
				((liveObj->flags1 & (LIVEOBJ1_UNK_4000000|LIVEOBJ1_REST)) == LIVEOBJ1_NONE)) &&
			 ((liveObj->objType != OBJECT_VEHICLE ||
				((liveObj->flags1 & LIVEOBJ1_CLEARING) == LIVEOBJ1_NONE)))) {
			return TRUE;
		}
	}
	return 0;
}



void __cdecl lego::game::Message_PTL_ReduceSelection(void)
{
	LiveObject *pLVar1;
	ObjectType OVar2;
	LiveObject *pLVar3;
	bool bVar4;
	bool bVar5;
	bool bVar6;
	bool bVar7;
	bool bVar8;
	bool bVar9;
	bool bVar10;
	bool bVar11;
	int iVar12;
	ObjectStatsFlags1 OVar13;
	LiveObject **ppLVar14;
	uint uVar15;
	InterfaceMenuType interfaceMenuType;
	
	uVar15 = 0;
	bVar5 = false;
	bVar6 = false;
	bVar8 = false;
	bVar7 = false;
	bVar9 = false;
	bVar10 = false;
	bVar11 = false;
	if (globs::messageGlobs.selectedUnitCount != 0) {
		ppLVar14 = globs::messageGlobs.selectedUnitList;
		do {
			pLVar1 = *ppLVar14;
			if ((pLVar1->objType == OBJECT_MINIFIGURE) && (pLVar1->drivenObject == NULL)) {
				bVar5 = true;
				break;
			}
			OVar13 = LiveObject_GetStatsFlags1(pLVar1);
			if ((OVar13 & STATS1_CANBEDRIVEN) == STATS1_NONE) {
				OVar2 = pLVar1->objType;
				if (OVar2 == OBJECT_VEHICLE) {
					OVar13 = LiveObject_GetStatsFlags1(pLVar1);
					if (((OVar13 & STATS1_CROSSLAND) == STATS1_NONE) &&
						 ((*(byte *)&pLVar1->flags4 & 0x40) == 0)) {
						bVar7 = true;
					}
					else {
						bVar6 = true;
					}
				}
				else {
					if (OVar2 == OBJECT_BUILDING) {
						bVar9 = true;
					}
					else {
						if ((OVar2 == OBJECT_ELECTRICFENCE) &&
							 ((pLVar1->flags2 & LIVEOBJ2_UNK_2000000) != LIVEOBJ2_NONE)) {
							bVar10 = true;
						}
					}
				}
			}
			else {
				if (pLVar1->drivenObject == NULL) {
					bVar8 = true;
				}
				else {
					OVar13 = LiveObject_GetStatsFlags1(pLVar1);
					if (((OVar13 & STATS1_CROSSLAND) == STATS1_NONE) &&
						 ((*(byte *)&pLVar1->flags4 & 0x40) == 0)) {
						bVar7 = true;
					}
					else {
						bVar6 = true;
					}
				}
			}
			uVar15 += 1;
			ppLVar14 = ppLVar14 + 1;
		} while (uVar15 < globs::messageGlobs.selectedUnitCount);
	}
	uVar15 = 0;
	if (bVar5) {
		front::Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_LEGOMAN,NULL);
		bVar7 = false;
		bVar6 = false;
		bVar8 = false;
		bVar9 = false;
		bVar10 = false;
	}
	else {
		if (bVar6) {
			front::Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_VEHICLE,NULL);
			bVar7 = false;
			bVar8 = false;
			bVar9 = false;
			bVar10 = false;
		}
		else {
			if (bVar7) {
				front::Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_WATERVEHICLE,NULL);
				bVar8 = false;
				bVar9 = false;
				bVar10 = false;
			}
			else {
				if (bVar8) {
					front::Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_UNMANNEDVEHICLE,NULL);
					bVar9 = false;
					bVar10 = false;
				}
				else {
					if (bVar9) {
						front::Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_BUILDING,NULL);
						bVar10 = false;
					}
					else {
						bVar11 = !bVar10;
						if (bVar11) {
							interfaceMenuType = INTERFACE_MENU_MAIN;
						}
						else {
							interfaceMenuType = INTERFACE_MENU_ELECTRICFENCE;
						}
						front::Interface_OpenMenu_FUN_0041b200(interfaceMenuType,NULL);
					}
				}
			}
		}
	}
	if (globs::messageGlobs.selectedUnitCount != 0) {
		ppLVar14 = globs::messageGlobs.selectedUnitList;
		do {
			pLVar1 = *ppLVar14;
			bVar4 = false;
			if ((bVar5) && ((pLVar1->objType != OBJECT_MINIFIGURE || (pLVar1->drivenObject != NULL))))
			goto LAB_00452e44;
			if (bVar6) {
				OVar13 = LiveObject_GetStatsFlags1(pLVar1);
				if ((OVar13 & STATS1_CANBEDRIVEN) == STATS1_NONE) {
LAB_00452df3:
					if (pLVar1->objType != OBJECT_VEHICLE) goto LAB_00452e44;
				}
				else {
					OVar13 = LiveObject_GetStatsFlags1(pLVar1);
					if (((OVar13 & STATS1_CROSSLAND) == STATS1_NONE) &&
						 ((*(byte *)&pLVar1->flags4 & 0x40) == 0)) {
LAB_00452de2:
						bVar4 = true;
					}
LAB_00452de7:
					pLVar3 = pLVar1->drivenObject;
joined_r0x00452e42:
					if (pLVar3 == NULL) goto LAB_00452e44;
				}
			}
			else {
				if (bVar7) {
					OVar13 = LiveObject_GetStatsFlags1(pLVar1);
					if ((OVar13 & STATS1_CANBEDRIVEN) == STATS1_NONE) goto LAB_00452df3;
					OVar13 = LiveObject_GetStatsFlags1(pLVar1);
					if (((OVar13 & STATS1_CROSSLAND) != STATS1_NONE) ||
						 ((*(byte *)&pLVar1->flags4 & 0x40) != 0)) goto LAB_00452de2;
					goto LAB_00452de7;
				}
				if (bVar8) {
					OVar13 = LiveObject_GetStatsFlags1(pLVar1);
					if ((OVar13 & STATS1_CANBEDRIVEN) != STATS1_NONE) {
						pLVar3 = pLVar1->drivenObject;
						goto joined_r0x00452e42;
					}
				}
				else {
					if ((!bVar9) || (pLVar1->objType == OBJECT_BUILDING)) {
						if (!bVar10) goto LAB_00452e49;
						if (pLVar1->objType == OBJECT_ELECTRICFENCE) {
							pLVar3 = (LiveObject *)(pLVar1->flags2 & LIVEOBJ2_UNK_2000000);
							goto joined_r0x00452e42;
						}
					}
				}
LAB_00452e44:
				bVar4 = true;
			}
LAB_00452e49:
			if ((bVar4) || (bVar11)) {
				iVar12 = globs::messageGlobs.selectedUnitCount - 1;
				globs::messageGlobs.selectedUnitCount = globs::messageGlobs.selectedUnitCount - 1;
				*ppLVar14 = globs::messageGlobs.selectedUnitList[iVar12];
				uVar15 -= 1;
				pLVar1->flags3 = pLVar1->flags3 & ~LIVEOBJ3_UNK_200000;
				ppLVar14 = ppLVar14 + -1;
			}
			uVar15 += 1;
			ppLVar14 = ppLVar14 + 1;
		} while (uVar15 < globs::messageGlobs.selectedUnitCount);
	}
	return;
}



void __cdecl lego::game::Message_PTL_ClearSelection(void)
{
	LiveFlags4 *pLVar1;
	LiveObject **ppLVar2;
	uint uVar3;
	
	uVar3 = 0;
	if (globs::messageGlobs.selectedUnitCount != 0) {
		ppLVar2 = globs::messageGlobs.selectedUnitList;
		do {
			if (((*ppLVar2)->flags3 & LIVEOBJ3_UNK_200000) != LIVEOBJ3_NONE) {
				pLVar1 = &(*ppLVar2)->flags4;
				*pLVar1 = *pLVar1 | LIVEOBJ4_UNK_2;
			}
			(*ppLVar2)->flags3 = (*ppLVar2)->flags3 & ~LIVEOBJ3_UNK_200000;
			(*ppLVar2)->flags4 = (*ppLVar2)->flags4 & ~LIVEOBJ4_UNK_1;
			uVar3 += 1;
			ppLVar2 = ppLVar2 + 1;
		} while (uVar3 < globs::messageGlobs.selectedUnitCount);
	}
	globs::messageGlobs.selectedUnitCount = 0;
	return;
}



BOOL __cdecl lego::game::Message_PTL_Deselect_LiveObject(LiveObject *liveObj)
{
	int iVar1;
	LiveObject *pLVar2;
	BOOL BVar3;
	
	pLVar2 = liveObj;
	if (globs::messageGlobs.selectedUnitCount != 0) {
		BVar3 = Message_LiveObject_Check_IsSelected_OrFlags3_200000(liveObj,(uint *)&liveObj);
		if (BVar3 != 0) {
			if (liveObj == NULL) {
				front::Interface_OpenMenu_FUN_0041b200(INTERFACE_MENU_MAIN,NULL);
			}
										// param_1 is no longer liveObject, transformed by first function call of this
										// function
			iVar1 = globs::messageGlobs.selectedUnitCount - 1;
			globs::messageGlobs.selectedUnitCount = globs::messageGlobs.selectedUnitCount - 1;
			globs::messageGlobs.selectedUnitList[(int)liveObj] =
					 globs::messageGlobs.selectedUnitList[iVar1];
			pLVar2->flags3 = pLVar2->flags3 & ~LIVEOBJ3_UNK_200000;
			return TRUE;
		}
	}
	return 0;
}



uint __cdecl lego::game::Message_PTL_Debug_DestroyAll(void)
{
	LiveObject *pLVar1;
	ObjectStatsFlags1 OVar2;
	uint index;
	
	index = globs::messageGlobs.selectedUnitCount;
	if (globs::messageGlobs.selectedUnitCount != 0) {
		do {
			OVar2 = LiveObject_GetStatsFlags1(globs::messageGlobs.selectedUnitList[0]);
			if (((OVar2 & STATS1_CANBEDRIVEN) != STATS1_NONE) &&
				 (pLVar1 = globs::messageGlobs.selectedUnitList[0]->drivenObject, pLVar1 != NULL)) {
				pLVar1->flags2 = pLVar1->flags2 & ~LIVEOBJ2_DRIVING;
				globs::messageGlobs.selectedUnitList[0]->drivenObject->drivenObject = NULL;
			}
			if (globs::messageGlobs.selectedUnitList[0]->objType == OBJECT_BUILDING) {
				LiveObject_BuildingDestroy(globs::messageGlobs.selectedUnitList[0]);
			}
			else {
				if (globs::messageGlobs.selectedUnitList[0]->objType == OBJECT_ELECTRICFENCE) {
					ElectricFence_LiveObject_Destroy(globs::messageGlobs.selectedUnitList[0]);
				}
				pool::ReservedPool_LiveObject___Release(globs::messageGlobs.selectedUnitList[0]);
			}
			index -= 1;
		} while (index != 0);
	}
	return globs::messageGlobs.selectedUnitCount;
}



BOOL __cdecl lego::game::Message_PTL_FirstPerson(int camField14)
{
	LiveObject *liveObj;
	LiveObject **ppLVar1;
	uint uVar2;
	
	if (((globs::gameGlobs.objectFP != NULL) &&
			((*(byte *)&(globs::gameGlobs.objectFP)->flags3 & LIVEOBJ3_UNK_10) != 0)) &&
		 ((liveObj = globs::gameGlobs.objectFP,
			(globs::gameGlobs.objectFP)->objType == OBJECT_MINIFIGURE ||
			((globs::gameGlobs.objectFP)->drivenObject != NULL)))) {
LAB_00453096:
		Game_SetViewMode(VIEW_FIRSTPERSON,liveObj,camField14);
		return TRUE;
	}
	uVar2 = 0;
	if (globs::messageGlobs.selectedUnitCount != 0) {
		ppLVar1 = globs::messageGlobs.selectedUnitList;
		do {
			liveObj = *ppLVar1;
			if ((liveObj->objType == OBJECT_MINIFIGURE) && (liveObj->drivenObject != NULL)) {
				liveObj = liveObj->drivenObject;
			}
			if (((*(byte *)&liveObj->flags3 & LIVEOBJ3_UNK_10) != 0) &&
				 ((liveObj->objType == OBJECT_MINIFIGURE || (liveObj->drivenObject != NULL))))
			goto LAB_00453096;
			uVar2 += 1;
			ppLVar1 = ppLVar1 + 1;
		} while (uVar2 < globs::messageGlobs.selectedUnitCount);
	}
	return 0;
}



BOOL __cdecl lego::nerps::NERPs_Level_LoadNERPsFile(char *filename)
{
	int iVar1;
	BOOL *pBVar2;
	int *piVar3;
	int local_4;
	
	pBVar2 = &globals::nerps::g_NERPs_Camera_IsLockedOn;
	for (iVar1 = 0x2d; iVar1 != 0; iVar1 += -1) {
		*pBVar2 = 0;
		pBVar2 = pBVar2 + 1;
	}
	local_4 = 1;
	front::Text_FUN_0046ad50();
	globals::nerps::g_NERPs_FileLength = 0;
	piVar3 = globals::nerps::g_NERPs_REGISTERS_TABLE;
	for (iVar1 = 0xb; iVar1 != 0; iVar1 += -1) {
		*piVar3 = 0;
		piVar3 = piVar3 + 1;
	}
	globals::nerps::g_NERPs_FileData = NULL;
	globals::nerps::g_NERPs_IsLoaded = 1;
	funcs::NERPFunc__SetMessagePermit(&local_4);
	globals::nerps::g_NERPs_FileData =
			 lego::file::File_LoadBinary(filename,&globals::nerps::g_NERPs_FileLength);
	return (uint)((byte *)globals::nerps::g_NERPs_FileData != NULL);
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

BOOL __cdecl lego::nerps::NERPs_Level_LoadNERPMessageFile(char *filename)
{
	undefined4 *puVar1;
	NERPMessageSound *pNVar2;
	char cVar3;
	byte bVar4;
	IDirectDrawSurface4 **ppIVar5;
	char *buffer;
	ImageBMP *pIVar6;
	void *pvVar7;
	char *pcVar8;
	int iVar9;
	NERPMessageSound *pNVar10;
	uint uVar11;
	char **ppcVar12;
	char **ppcVar13;
	byte *pbVar14;
	uint uVar15;
	bool bVar16;
	uint uStack8464;
	byte *pbStack8460;
	char **ppcStack8456;
	int iStack8452;
	char acStack8448 [128];
	ImageBMP aIStack8320 [4];
	char acStack8192 [4096];
	char local_1000 [4092];
	undefined4 uStack4;
	
	uStack4 = 0x45313a;
	bVar16 = true;
	uStack8464 = 0;
	buffer = (char *)lego::file::File_LoadBinary(filename,(uint *)&pbStack8460);
	if (buffer == NULL) {
		globals::nerps::g_NERPMessageBuffer = buffer;
		globals::nerps::g_NERPMessageSounds_UNKCOUNT = globals::nerps::g_NERPMessageSounds_COUNT;
		return 0;
	}
	globals::nerps::g_NERPMessageBuffer = buffer;
	if (pbStack8460 != NULL) {
		iStack8452 = 0;
		pbVar14 = pbStack8460;
		do {
			if (*buffer == '_') {
				*buffer = ' ';
			}
			bVar4 = *buffer;
			pIVar6 = (ImageBMP *)((uint)pbVar14 & 0xffffff00 | (uint)bVar4);
			if (bVar4 < 0x20) {
				*buffer = 0;
				bVar16 = true;
			}
			else {
				if (bVar16) {
					if (bVar4 == ':') {
						pIVar6 = aIStack8320;
						pbVar14 = (byte *)buffer + 1;
						std::sscanf((char *)pbVar14,"%s",pIVar6);
						buffer = (char *)pbVar14;
						if (pIVar6 != NULL) {
							uVar15 = 0xffffffff;
							pIVar6 = aIStack8320;
							do {
								if (uVar15 == 0) break;
								uVar15 -= 1;
								ppIVar5 = &pIVar6->surface;
								pIVar6 = (ImageBMP *)((int)&pIVar6->surface + 1);
							} while (*(char *)ppIVar5 != '\0');
							bVar16 = false;
							buffer = (char *)(pbVar14 + (~uVar15 - 1));
							bVar4 = *buffer;
							for (; (pIVar6 = (ImageBMP *)(uint)bVar4, bVar4 < 0x21 &&
										 ((byte *)buffer + -(int)globals::nerps::g_NERPMessageBuffer < pbStack8460));
									buffer = (char *)((byte *)buffer + 1)) {
								if (bVar4 == '\r') {
									bVar16 = true;
								}
								*buffer = 0;
								bVar4 = ((byte *)buffer)[1];
							}
							std::sscanf(buffer,"%s",acStack8448);
							if ((pIVar6 != NULL) && (!bVar16)) {
								uVar15 = 0xffffffff;
								pcVar8 = acStack8448;
								do {
									if (uVar15 == 0) break;
									uVar15 -= 1;
									cVar3 = *pcVar8;
									pcVar8 = pcVar8 + 1;
								} while (cVar3 != '\0');
								buffer = (char *)((byte *)buffer + (~uVar15 - 1));
								pIVar6 = lego::image::Image_LoadBMPScaled(acStack8448,0,0);
								if (pIVar6 != NULL) {
									pvVar7 = std::malloc(globals::nerps::g_NERPMessages_COUNT * 8 + 8);
									uVar15 = 0;
									bVar16 = globals::nerps::g_NERPMessages_COUNT == 0;
									if (!bVar16) {
										do {
											puVar1 = (undefined4 *)
															 ((int)globals::nerps::g_NERPMessages_TABLE + uVar15 * 8);
											uVar15 += 1;
											*(undefined4 *)((int)pvVar7 + uVar15 * 8 + -8) = *puVar1;
											*(undefined4 *)((int)pvVar7 + uVar15 * 8 + -4) = puVar1[1];
										} while (uVar15 < (uint)globals::nerps::g_NERPMessages_COUNT);
										bVar16 = globals::nerps::g_NERPMessages_COUNT == 0;
									}
									if (!bVar16) {
										std::free(globals::nerps::g_NERPMessages_TABLE);
									}
									*(byte **)((int)pvVar7 + globals::nerps::g_NERPMessages_COUNT * 8) = pbVar14;
									*(ImageBMP **)((int)pvVar7 + globals::nerps::g_NERPMessages_COUNT * 8 + 4) =
											 pIVar6;
									pIVar6 = (ImageBMP *)(globals::nerps::g_NERPMessages_COUNT + 1);
									globals::nerps::g_NERPMessages_COUNT = (int)pIVar6;
									globals::nerps::g_NERPMessages_TABLE = pvVar7;
								}
							}
						}
					}
					iVar9 = iStack8452;
					if (*buffer == '$') {
						pbVar14 = (byte *)buffer + 1;
						std::sscanf((char *)pbVar14,"%s",local_1000);
						buffer = (char *)pbVar14;
						if (pIVar6 != NULL) {
							uVar15 = 0xffffffff;
							pcVar8 = local_1000;
							do {
								if (uVar15 == 0) break;
								uVar15 -= 1;
								cVar3 = *pcVar8;
								pcVar8 = pcVar8 + 1;
							} while (cVar3 != '\0');
							bVar16 = false;
							buffer = (char *)(pbVar14 + (~uVar15 - 1));
							bVar4 = *buffer;
							for (; (bVar4 < 0x21 &&
										 ((byte *)buffer + -(int)globals::nerps::g_NERPMessageBuffer < pbStack8460));
									buffer = (char *)((byte *)buffer + 1)) {
								if (bVar4 == '\r') {
									bVar16 = true;
								}
								*buffer = 0;
								bVar4 = ((byte *)buffer)[1];
							}
							pcVar8 = acStack8192;
							std::sscanf(buffer,"%s",pcVar8);
							if ((pcVar8 != NULL) && (!bVar16)) {
								uVar15 = 0xffffffff;
								pcVar8 = acStack8192;
								do {
									if (uVar15 == 0) break;
									uVar15 -= 1;
									cVar3 = *pcVar8;
									pcVar8 = pcVar8 + 1;
								} while (cVar3 != '\0');
								buffer = (char *)((byte *)buffer + (~uVar15 - 1));
								iVar9 = snd::Sound3D_Load(acStack8192,1,0,0);
								if (iVar9 != 0) {
									pNVar10 = (NERPMessageSound *)
														std::malloc(globals::nerps::g_NERPMessageSounds_COUNT * 8 + 8);
									bVar16 = globals::nerps::g_NERPMessageSounds_COUNT == 0;
									uVar15 = 0;
									if (!bVar16) {
										do {
											pNVar2 = globals::nerps::g_NERPMessageSounds_TABLE + uVar15;
											uVar11 = uVar15 + 1;
											pNVar10[uVar15].key = pNVar2->key;
											pNVar10[uVar15].sampleIndex = pNVar2->sampleIndex;
											uVar15 = uVar11;
										} while (uVar11 < (uint)globals::nerps::g_NERPMessageSounds_COUNT);
										bVar16 = globals::nerps::g_NERPMessageSounds_COUNT == 0;
									}
									if (!bVar16) {
										std::free(globals::nerps::g_NERPMessageSounds_TABLE);
									}
									pNVar10[globals::nerps::g_NERPMessageSounds_COUNT].key = (char *)pbVar14;
									pNVar10[globals::nerps::g_NERPMessageSounds_COUNT].sampleIndex = iVar9;
									globals::nerps::g_NERPMessageSounds_COUNT += 1;
									globals::nerps::g_NERPMessageSounds_TABLE = pNVar10;
									globals::nerps::g_NERPMessageSounds_UNKCOUNT =
											 globals::nerps::g_NERPMessageSounds_COUNT;
								}
							}
						}
					}
					else {
						ppcVar12 = (char **)std::malloc(iStack8452 + 4);
						if (iVar9 != 0) {
							ppcVar13 = ppcVar12;
							uVar15 = uStack8464;
							do {
								*ppcVar13 = *(char **)((int)((int)ppcStack8456 - (int)ppcVar12) + (int)ppcVar13);
								ppcVar13 = ppcVar13 + 1;
								uVar15 -= 1;
							} while (uVar15 != 0);
						}
						if (iVar9 != 0) {
							std::free(ppcStack8456);
						}
						*(char **)((int)ppcVar12 + iVar9) = buffer;
						uStack8464 += 1;
						iStack8452 = iVar9 + 4;
						ppcStack8456 = ppcVar12;
					}
				}
				bVar16 = false;
			}
			buffer = (char *)((byte *)buffer + 1);
			pbVar14 = (byte *)buffer + -(int)globals::nerps::g_NERPMessageBuffer;
		} while (pbVar14 < pbStack8460);
	}
	globals::g_NERPMessageLines_COUNT = uStack8464;
	globals::g_NERPMessageLines_TABLE = ppcStack8456;
	return 1;
}



char * __cdecl lego::nerps::NERPs_GetMessageLine(uint lineIndex)
{
	if (lineIndex < globals::g_NERPMessageLines_COUNT) {
		return globals::g_NERPMessageLines_TABLE[lineIndex];
	}
	return NULL;
}



BOOL __cdecl lego::nerps::NERPs_Cleanup(void)
{
	int iVar1;
	uint uVar2;
	BOOL *pBVar3;
	
	if (globals::nerps::g_NERPs_FileLength != 0) {
		std::free(globals::nerps::g_NERPs_FileData);
	}
	if (globals::nerps::g_NERPMessageBuffer != NULL) {
		std::free(globals::nerps::g_NERPMessageBuffer);
		if (globals::g_NERPMessageLines_TABLE != NULL) {
			std::free(globals::g_NERPMessageLines_TABLE);
		}
	}
	uVar2 = 0;
	globals::nerps::g_NERPMessageBuffer = NULL;
	globals::g_NERPMessageLines_TABLE = NULL;
	globals::g_NERPMessageLines_COUNT = 0;
	globals::nerps::g_NERPs_FileLength = 0;
	if (globals::nerps::g_NERPMessageSounds_COUNT != 0) {
		do {
			snd::Sound3D_Remove(globals::nerps::g_NERPMessageSounds_TABLE[uVar2].sampleIndex);
			uVar2 += 1;
		} while (uVar2 < (uint)globals::nerps::g_NERPMessageSounds_COUNT);
		if (globals::nerps::g_NERPMessageSounds_COUNT != 0) {
			if (globals::nerps::g_NERPMessageSounds_TABLE != NULL) {
				std::free(globals::nerps::g_NERPMessageSounds_TABLE);
				globals::nerps::g_NERPMessageSounds_TABLE = NULL;
			}
			globals::nerps::g_NERPMessageSounds_COUNT = 0;
		}
	}
	pBVar3 = &globals::nerps::g_NERPs_Camera_IsLockedOn;
	for (iVar1 = 0x2d; iVar1 != 0; iVar1 += -1) {
		*pBVar3 = 0;
		pBVar3 = pBVar3 + 1;
	}
	front::Text_FUN_0046ad50();
	return 1;
}



void __cdecl lego::nerps::NERPs_UnkReserveStack__004535a0(uint *param_1)
{
	uint uVar1;
	
	uVar1 = *param_1;
	if (((uVar1 & 0xffff0000) == 0x20000) &&
		 (globals::nerps::g_NERPs_FUNCTIONS_TABLE[uVar1 & 0xffff].arguments == NERPS_ARGS_0)) {
		uVar1 = (*globals::nerps::g_NERPs_FUNCTIONS_TABLE[uVar1 & 0xffff].function)(NULL);
	}
	*param_1 = uVar1;
	return;
}



void __cdecl lego::nerps::NERPs_Exec__004535e0(float param_1)
{
	NERPSFunctionArgs NVar1;
	void *pvVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	uint local_220;
	uint local_21c;
	uint local_210;
	uint local_20c;
	uint local_208;
	uint local_204;
	char local_200 [512];
	
	pvVar2 = globals::nerps::g_NERPs_FileData;
	uVar5 = 0;
	if (globals::nerps::g_NERPs_FileData != NULL) {
		local_204 = globals::nerps::g_NERPs_FileLength >> 2;
		local_220 = 0;
		uVar10 = 0;
		uVar8 = 0;
		uVar4 = local_21c;
		if (local_204 != 0) {
			do {
				iVar7 = 0;
				uVar3 = *(uint *)((int)pvVar2 + local_220 * 4);
				if ((uVar3 & 0x20000) == 0) {
					if ((uVar3 & 0x10000) == 0) {
						if ((uVar3 & 0x40000) == 0) {
							if ((uVar3 & 0x80000) == 0) {
								uVar4 = SEXT24(*(short *)((int)pvVar2 + local_220 * 4));
								if (uVar5 != 0) {
									uVar4 = (uint)(uVar4 == 0);
								}
								uVar5 = uVar4;
								local_21c = uVar4;
								if (uVar8 != 0) {
									if (uVar8 == 1) {
										if ((uVar10 == 0) || (uVar5 = uVar8, uVar4 == 0)) {
LAB_00453acb:
											uVar5 = 0;
										}
									}
									else {
										if (uVar8 == 2) {
											if ((uVar10 == 0) && (uVar4 == 0)) goto LAB_00453acb;
											uVar5 = 1;
										}
										else {
											if (uVar8 == 3) {
												uVar5 = (uint)(uVar4 < uVar10);
											}
											else {
												if (uVar8 == 4) {
													uVar5 = (uint)(uVar10 < uVar4);
												}
												else {
													if (uVar8 == 5) {
														uVar5 = (uint)(uVar10 == uVar4);
													}
													else {
														if (uVar8 == 6) {
															uVar5 = (uint)(uVar4 <= uVar10);
														}
														else {
															if (uVar8 != 7) goto joined_r0x00453b1b;
															uVar5 = (uint)(uVar10 <= uVar4);
														}
													}
												}
											}
										}
									}
								}
								goto LAB_00453b28;
							}
							if (uVar10 != 0) {
								local_220 = uVar3 & 0xffff;
							}
LAB_00453a74:
							uVar10 = 0;
							uVar5 = 0;
							uVar9 = 0;
						}
						else {
							uVar10 = 0;
							uVar5 = 0;
							uVar9 = 0;
						}
					}
					else {
						uVar6 = 0;
						uVar3 &= 0xffff;
						uVar5 = uVar10;
						if (uVar3 == 0) goto LAB_00453b28;
						uVar5 = uVar6;
						uVar9 = uVar3;
						if ((uVar3 != 2) && (uVar5 = uVar3, uVar9 = uVar8, uVar3 != 1)) {
							if (uVar3 == 5) {
								uVar5 = uVar6;
								uVar9 = 3;
							}
							else {
								if (uVar3 == 6) {
									uVar5 = uVar6;
									uVar9 = 4;
								}
								else {
									if (uVar3 == 7) {
										uVar5 = uVar6;
										uVar9 = 5;
									}
									else {
										if (uVar3 == 8) {
											uVar5 = uVar6;
											uVar9 = 6;
										}
										else {
											if (uVar3 == 9) {
												uVar5 = uVar6;
												uVar9 = 7;
											}
											else {
												uVar5 = uVar6;
												if (uVar3 == 10) {
													uVar9 = 8;
												}
											}
										}
									}
								}
							}
						}
					}
				}
				else {
					uVar3 &= 0xffff;
					if ((uVar3 == 0) && ((uVar10 != 0 || (uVar8 == 0)))) break;
					NVar1 = globals::nerps::g_NERPs_FUNCTIONS_TABLE[uVar3].arguments;
					if (NVar1 == NERPS_ARGS_0) {
LAB_0045383f:
						uVar4 = (*globals::nerps::g_NERPs_FUNCTIONS_TABLE[uVar3].function)(NULL);
						local_21c = uVar4;
					}
					else {
						if ((NVar1 != NERPS_ARGS_1) && (NVar1 != NERPS_ARGS_2)) {
							if (NVar1 == NERPS_ARGS_0_NORETURN) {
								if (uVar10 == 0) goto LAB_00453a74;
								if (DAT_00500998 != 0) {
									std::sprintf(local_200,"Func Call %s",
															 globals::nerps::g_NERPs_FUNCTIONS_TABLE[uVar3].name);
								}
								(*globals::nerps::g_NERPs_FUNCTIONS_TABLE
									[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)(NULL);
								uVar10 = 0;
								uVar4 = local_21c;
								uVar5 = 0;
								uVar9 = 0;
							}
							else {
								if (NVar1 == NERPS_ARGS_1_NORETURN) {
									if (uVar10 != 0) {
										if (DAT_00500998 != 0) {
											std::sprintf(local_200,"Func Call %s",
																	 globals::nerps::g_NERPs_FUNCTIONS_TABLE[uVar3].name);
										}
										local_210 = *(uint *)((int)pvVar2 + local_220 * 4 + 4);
										NERPs_UnkReserveStack__004535a0(&local_210);
										(*globals::nerps::g_NERPs_FUNCTIONS_TABLE
											[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)((int *)&local_210)
										;
										uVar4 = local_21c;
									}
									local_220 += 1;
								}
								else {
									if (NVar1 == NERPS_ARGS_2_NORETURN) {
										if (uVar10 != 0) {
											local_210 = *(uint *)((int)pvVar2 + local_220 * 4 + 4);
											local_20c = *(uint *)((int)pvVar2 + local_220 * 4 + 8);
											NERPs_UnkReserveStack__004535a0(&local_210);
											NERPs_UnkReserveStack__004535a0(&local_20c);
											(*globals::nerps::g_NERPs_FUNCTIONS_TABLE
												[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)
																((int *)&local_210);
											uVar4 = local_21c;
										}
										local_220 += 2;
									}
									else {
										uVar9 = uVar8;
										if (NVar1 != NERPS_ARGS_3_NORETURN) goto LAB_00453b2d;
										if (uVar10 != 0) {
											local_210 = *(uint *)((int)pvVar2 + local_220 * 4 + 4);
											local_20c = *(uint *)((int)pvVar2 + local_220 * 4 + 8);
											local_208 = *(uint *)((int)pvVar2 + local_220 * 4 + 0xc);
											NERPs_UnkReserveStack__004535a0(&local_210);
											NERPs_UnkReserveStack__004535a0(&local_20c);
											NERPs_UnkReserveStack__004535a0(&local_208);
											(*globals::nerps::g_NERPs_FUNCTIONS_TABLE
												[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)
																((int *)&local_210);
											uVar4 = local_21c;
										}
										local_220 += 3;
									}
								}
								uVar10 = 0;
								uVar5 = 0;
								uVar9 = 0;
							}
							goto LAB_00453b2d;
						}
						if (NVar1 == NERPS_ARGS_0) goto LAB_0045383f;
						if (NVar1 == NERPS_ARGS_1) {
							local_210 = *(uint *)((int)pvVar2 + local_220 * 4 + 4);
							NERPs_UnkReserveStack__004535a0(&local_210);
							uVar4 = (*globals::nerps::g_NERPs_FUNCTIONS_TABLE
												[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)
																((int *)&local_210);
							iVar7 = 1;
							local_21c = uVar4;
						}
						else {
							if (NVar1 == NERPS_ARGS_2) {
								local_210 = *(uint *)((int)pvVar2 + local_220 * 4 + 4);
								local_20c = *(uint *)((int)pvVar2 + local_220 * 4 + 8);
								NERPs_UnkReserveStack__004535a0(&local_210);
								NERPs_UnkReserveStack__004535a0(&local_20c);
								uVar4 = (*globals::nerps::g_NERPs_FUNCTIONS_TABLE
													[*(uint *)((int)pvVar2 + local_220 * 4) & 0xffff].function)
																	((int *)&local_210);
								iVar7 = 2;
								local_21c = uVar4;
							}
						}
					}
					local_220 += iVar7;
					if (uVar5 != 0) {
						uVar4 = (uint)(uVar4 == 0);
						local_21c = uVar4;
					}
					uVar5 = uVar4;
					if (uVar8 != 0) {
						if (uVar8 == 1) {
							if ((uVar10 == 0) || (uVar5 = uVar8, uVar4 == 0)) {
LAB_00453947:
								uVar5 = 0;
							}
						}
						else {
							if (uVar8 == 2) {
								if ((uVar10 == 0) && (uVar4 == 0)) goto LAB_00453947;
								uVar5 = 1;
							}
							else {
								if (uVar8 == 3) {
									uVar5 = (uint)(uVar4 < uVar10);
								}
								else {
									if (uVar8 == 4) {
										uVar5 = (uint)(uVar10 < uVar4);
									}
									else {
										if (uVar8 == 5) {
											uVar5 = (uint)(uVar10 == uVar4);
										}
										else {
											if (uVar8 == 6) {
												uVar5 = (uint)(uVar4 <= uVar10);
											}
											else {
												if (uVar8 == 7) {
													uVar5 = (uint)(uVar10 <= uVar4);
												}
												else {
joined_r0x00453b1b:
													uVar5 = uVar10;
													if (uVar8 == 8) {
														uVar5 = (uint)(uVar10 != uVar4);
													}
												}
											}
										}
									}
								}
							}
						}
					}
LAB_00453b28:
					uVar10 = uVar5;
					uVar5 = 0;
					uVar9 = 1;
				}
LAB_00453b2d:
				local_220 += 1;
				uVar8 = uVar9;
			} while (local_220 < local_204);
		}
		NERPs_FUN_00454060(param_1);
	}
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGameSpeed(int *stack)
{
	LevelData *pLVar1;
	
	if ((*stack == 0) && (pLVar1 = game::GetLevel(), pLVar1->status != LEVELSTATUS_NONE)) {
		return 0;
	}
	game::Game_LockGameSpeed(stack[1]);
	game::Game_SetGameSpeed((float)(ulonglong)(uint)*stack * 0.01);
	game::Game_LockGameSpeed(stack[1]);
	return 0;
}



void __cdecl lego::unk::NERPs_SetHasNextButton(BOOL hasNextButton)
{
	globals::g_NERPs_HasNextButton = hasNextButton;
	return;
}



void __cdecl lego::unk::NERPs_PlayUnkSampleIndex_IfDat_004a773c(void)
{
	if (globals::g_NERPs_HasNextButton != 0) {
		game::NERPs_PlayUnkSampleIndex();
		return;
	}
	return;
}



void __cdecl lego::nerps::NERPs_FUN_00453be0(void)
{
	char *text;
	TutorialFlags TVar1;
	int local_8;
	undefined4 local_4;
	
	local_8 = 100;
	local_4 = 0;
	snd::Audio_FUN_00428730(0);
	if (UINT_00556de4 != 0) {
		UINT_00556de4 -= 1;
		if (3 < (int)UINT_00556de4) {
			UINT_00556de4 = 3;
		}
		if ((int)UINT_00556de0 < (int)UINT_00556de4) {
			UINT_00556de4 = UINT_00556de0;
		}
		text = NERPs_GetMessageLine
										 ((&globals::nerps::g_NERPMessageSounds_UNKCOUNT)[UINT_00556de0 - UINT_00556de4]
										 );
		front::Text_SetMessage(text,0);
		if (UINT_00556de4 == 0) {
			game::Game_SetFlags2_40_And_2_unkCamera(0,1);
			TVar1 = funcs::NERPFunc__GetTutorialFlags(NULL);
			if (TVar1 != TUTORIAL_NONE) {
				funcs::NERPFunc__SetGameSpeed(&local_8);
			}
		}
		game::Game_SetFlags2_80(1);
		return;
	}
	if (BOOL_004a7740 != 0) {
		UINT_00556de8 += 1;
	}
	BOOL_004a7740 = 0;
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMessagesAreUpToDate(int *stack)
{
	return (uint)(globals::g_NERPMessageLines_COUNT <= UINT_00556de8);
}



int __cdecl lego::nerps::funcs::NERPFunc__SupressArrow(int *stack)
{
	DAT_005009b0 = *stack;
	if (UINT_00556de4 == 0) {
		game::Game_SetFlags2_40_And_2_unkCamera((uint)(DAT_005009b0 == 0),1);
		return 0;
	}
	game::Game_SetFlags2_40_And_2_unkCamera(1,1);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__AdvanceMessage(int *stack)
{
	if (1 < (int)UINT_00556de4) {
		UINT_00556de4 = 1;
	}
	NERPs_FUN_00453be0();
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__AllowCameraMovement(int *stack)
{
	DAT_005009b4 = *stack << 0xc;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__ClickOnlyObjects(int *stack)
{
	int local_4;
	
	local_4 = 0x1ff3 - DAT_005009b4;
	NERPFunc__SetTutorialFlags(&local_4);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__ClickOnlyMap(int *stack)
{
	int local_4;
	
	local_4 = 0x1ffb - DAT_005009b4;
	NERPFunc__SetTutorialFlags(&local_4);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__ClickOnlyIcon(int *stack)
{
	int local_4;
	
	local_4 = 0x1ffe - DAT_005009b4;
	NERPFunc__SetTutorialFlags(&local_4);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__ClickOnlyCalltoarms(int *stack)
{
	int local_4;
	
	local_4 = 0x1f7f - DAT_005009b4;
	NERPFunc__SetTutorialFlags(&local_4);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__DisallowAll(int *stack)
{
	int local_4;
	
	local_4 = 0x1fff - DAT_005009b4;
	NERPFunc__SetTutorialFlags(&local_4);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashCallToArmsIcon(int *stack)
{
	if (*stack != 0) {
		front::Panel_SetCurrentAdvisorFromButton(PANEL_TOPPANEL,2,TRUE);
		return 0;
	}
	front::Advisor_ClearFlag2();
	return 0;
}



void __cdecl lego::nerps::NERPs_FUN_00453e70(float elapsed)
{
	float fVar1;
	float *pfVar2;
	float *pfVar3;
	
	fVar1 = elapsed * 1000.0 * 0.04;
	pfVar2 = globals::nerps::g_NERPs_TIMERS_TABLE;
	do {
		pfVar3 = pfVar2 + 1;
		*pfVar2 = *pfVar2 + fVar1;
		pfVar2 = pfVar3;
	} while (pfVar3 < &DAT_005009b0);
	if (FLOAT_0050098c == 0.0) {
		return;
	}
	if (0.0 <= FLOAT_0050098c) {
		if ((globals::g_NERPs_HasNextButton == 0) || (DAT_00500988 != 0)) {
			FLOAT_0050098c = FLOAT_0050098c - fVar1;
			if ((ushort)((ushort)(FLOAT_0050098c < 0.0) << 8 | (ushort)(FLOAT_0050098c == 0.0) << 0xe) ==
					0) goto LAB_00453f3e;
		}
		else {
			if ((DAT_00500984 != 0) &&
				 (((0 < (int)UINT_00556de4 && (DAT_005009b0 != 0)) || (DAT_005009b0 == 0)))) {
				game::Game_SetFlags2_40_And_2_unkCamera(BOOL_004a7740,TRUE);
			}
			DAT_00500984 = BOOL_004a7740;
			if (BOOL_004a7740 != 0) goto LAB_00453f3e;
		}
	}
	FLOAT_0050098c = 0.0;
LAB_00453f3e:
	if ((globals::g_NERPs_AdvisorTalkingMode != 0) && (FLOAT_0050098c < 1000.0)) {
		front::Advisor_ClearFlag2();
		return;
	}
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTimer0(int *stack)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)globals::nerps::g_NERPs_TIMERS_TABLE[0]);
	return (int)lVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTimer1(int *stack)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)globals::nerps::g_NERPs_TIMERS_TABLE[1]);
	return (int)lVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTimer2(int *stack)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)globals::nerps::g_NERPs_TIMERS_TABLE[2]);
	return (int)lVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTimer3(int *stack)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)globals::nerps::g_NERPs_TIMERS_TABLE[3]);
	return (int)lVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTimer0(int *stack)
{
	globals::nerps::g_NERPs_TIMERS_TABLE[0] = (float)(ulonglong)(uint)*stack;
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTimer1(int *stack)
{
	globals::nerps::g_NERPs_TIMERS_TABLE[1] = (float)(ulonglong)(uint)*stack;
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTimer2(int *stack)
{
	globals::nerps::g_NERPs_TIMERS_TABLE[2] = (float)(ulonglong)(uint)*stack;
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTimer3(int *stack)
{
	globals::nerps::g_NERPs_TIMERS_TABLE[3] = (float)(ulonglong)(uint)*stack;
	return 1;
}



void __cdecl lego::nerps::NERPs_FUN_00454060(float param_1)
{
	float fVar1;
	BOOL BVar2;
	LevelData *pLVar3;
	float10 fVar4;
	LiveObject *local_10;
	undefined4 local_c;
	int local_8;
	int local_4;
	
	if (globals::nerps::g_NERPs_Camera_IsLockedOn == 0) goto LAB_00454114;
	if (LIVEOBJ_00556d50 == NULL) {
		if (&DAT_00000009 < globals::nerps::g_NERPs_Camera_LockedOnTarget) goto LAB_00454114;
		BVar2 = game::Game_GetRecordObject
											((uint)globals::nerps::g_NERPs_Camera_LockedOnTarget,&local_10);
		if (BVar2 == 0) {
			globals::nerps::g_NERPs_Camera_IsLockedOn = 0;
			goto LAB_00454114;
		}
		game::LiveObject_GetBlockPos(local_10,&local_8,&local_4);
		game::LiveObject_GetPosition(local_10,(float *)&Point2I_00556d48,(float *)&Point2I_00556d48.y);
	}
	else {
		game::LiveObject_GetBlockPos(LIVEOBJ_00556d50,&local_8,&local_4);
		game::LiveObject_GetPosition
							(LIVEOBJ_00556d50,(float *)&Point2I_00556d48,(float *)&Point2I_00556d48.y);
		local_10 = LIVEOBJ_00556d50;
	}
	game::LiveObject_FUN_0042dd70(local_10,NULL,1);
LAB_00454114:
	if (BOOL_00556d54 != 0) {
		fVar1 = FLOAT_00556d58 / (param_1 * 25.0);
		FLOAT_00556d5c = fVar1 + FLOAT_00556d5c;
		if (((ushort)((ushort)(FLOAT_00556d5c < FLOAT_00556d58 - 5.0) << 8 |
								 (ushort)(FLOAT_00556d5c == FLOAT_00556d58 - 5.0) << 0xe) == 0) &&
			 ((ushort)((ushort)(FLOAT_00556d58 - -5.0 < FLOAT_00556d5c) << 8 |
								(ushort)(FLOAT_00556d58 - -5.0 == FLOAT_00556d5c) << 0xe) == 0)) {
			BOOL_00556d54 = 0;
			FLOAT_00556d5c = 0.0;
		}
		lego::view::Camera_AddDist(globs::gameGlobs.cameraMain,fVar1);
	}
	if (BOOL_00556d60 != 0) {
		if ((ushort)((ushort)(FLOAT_00556d64 < 0.0) << 8 | (ushort)(FLOAT_00556d64 == 0.0) << 0xe) == 0)
		{
			fVar1 = FLOAT_00556d64 - FLOAT_00556d68;
		}
		else {
			fVar1 = FLOAT_00556d64 + FLOAT_00556d68;
		}
		fVar4 = game::Game_GetFloatFPS_e40();
		fVar4 = fVar4 * (float10)(fVar1 * 0.1666667) * (float10)0.3333333;
		FLOAT_00556d68 = (float)(fVar4 + (float10)FLOAT_00556d68);
		if ((((ushort)((ushort)(FLOAT_00556d64 < 0.0) << 8 | (ushort)(FLOAT_00556d64 == 0.0) << 0xe) ==
					0) && ((ushort)((ushort)(FLOAT_00556d68 < FLOAT_00556d64 - 1.0) << 8 |
												 (ushort)(FLOAT_00556d68 == FLOAT_00556d64 - 1.0) << 0xe) == 0)) ||
			 ((FLOAT_00556d64 < 0.0 && (FLOAT_00556d68 < FLOAT_00556d64 - -1.0)))) {
			BOOL_00556d60 = 0;
			FLOAT_00556d68 = 0.0;
		}
		lego::view::Camera_AddYaw(globs::gameGlobs.cameraMain,(float)(fVar4 * (float10)0.01745329));
	}
	pLVar3 = game::GetLevel();
	if (pLVar3->status != LEVELSTATUS_NONE) {
		local_10 = (LiveObject *)0x64;
		local_c = 0;
		funcs::NERPFunc__SetGameSpeed((int *)&local_10);
	}
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraLockOnMonster(int *stack)
{
	if (*stack != 0) {
		game::Search_LiveObjects_SkipIgnoreMes
							(NERPs_LiveObject_GetIfRockMonsterAnd_FUN_004542e0,&LIVEOBJ_00556d50);
		globals::nerps::g_NERPs_Camera_IsLockedOn = 1;
		return 0;
	}
	globals::nerps::g_NERPs_Camera_IsLockedOn = 0;
	LIVEOBJ_00556d50 = NULL;
	return 0;
}



BOOL __cdecl
lego::nerps::NERPs_LiveObject_GetIfRockMonsterAnd_FUN_004542e0
					(LiveObject *liveObj,LiveObject **out_liveObj)
{
	BOOL BVar1;
	
	if (liveObj != NULL) {
		BVar1 = game::LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj);
		if (BVar1 != 0) {
			*out_liveObj = liveObj;
			return 1;
		}
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraLockOnObject(int *stack)
{
	if (*stack != 0) {
		globals::nerps::g_NERPs_Camera_LockedOnTarget = (void *)(*stack + -1);
		globals::nerps::g_NERPs_Camera_IsLockedOn = 1;
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraUnlock(int *stack)
{
	globals::nerps::g_NERPs_Camera_IsLockedOn = 0;
	globals::nerps::g_NERPs_Camera_LockedOnTarget = (void *)0xffffffff;
	LIVEOBJ_00556d50 = NULL;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraZoomIn(int *stack)
{
	if (FLOAT_00556d5c != 0.0) {
		lego::view::Camera_AddDist(globs::gameGlobs.cameraMain,FLOAT_00556d58 - FLOAT_00556d5c);
		FLOAT_00556d5c = 0.0;
	}
	if (-(float)(ulonglong)(uint)*stack != 0.0) {
		BOOL_00556d54 = 1;
	}
	FLOAT_00556d58 = -(float)(ulonglong)(uint)*stack;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraZoomOut(int *stack)
{
	if (FLOAT_00556d5c != 0.0) {
		lego::view::Camera_AddDist(globs::gameGlobs.cameraMain,FLOAT_00556d58 - FLOAT_00556d5c);
	}
	if ((float)(ulonglong)(uint)*stack != 0.0) {
		BOOL_00556d54 = 1;
	}
	FLOAT_00556d58 = (float)(ulonglong)(uint)*stack;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__CameraRotate(int *stack)
{
	if (FLOAT_00556d68 != 0.0) {
		lego::view::Camera_AddYaw
							(globs::gameGlobs.cameraMain,(FLOAT_00556d64 - FLOAT_00556d68) * 0.01745329);
		FLOAT_00556d68 = 0.0;
	}
	FLOAT_00556d64 = (float)(ulonglong)(uint)*stack;
	if ((ushort)((ushort)(FLOAT_00556d64 < 180.0) << 8 | (ushort)(FLOAT_00556d64 == 180.0) << 0xe) ==
			0) {
		FLOAT_00556d64 = FLOAT_00556d64 - 360.0;
	}
	if (FLOAT_00556d64 != 0.0) {
		BOOL_00556d60 = 1;
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSelectedRecordObject(int *stack)
{
	BOOL BVar1;
	uint recordObjPtr;
	LiveObject *local_4;
	
	recordObjPtr = 0;
	do {
		local_4 = NULL;
		BVar1 = game::Game_GetRecordObject(recordObjPtr,&local_4);
		if (BVar1 != 0) {
			BVar1 = game::Message_LiveObject_Check_IsSelected_OrFlags3_200000(local_4,NULL);
			if (BVar1 != 0) {
				return recordObjPtr + 1;
			}
		}
		recordObjPtr += 1;
	} while (recordObjPtr < 10);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetCrystalPriority(int *stack)
{
	ai::AITask_Game_SetIsPriorityDisabled(0,(uint)(*stack == 0));
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMonsterAttackPowerstation(int *stack)
{
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if (*stack == 1) {
		local_c = 0x200;
		local_8 = 0xffffffff;
		local_4 = 1;
		game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_Callback_FUN_004545c0,&local_c);
		return 0;
	}
	local_c = 0;
	local_8 = 0xffffffff;
	local_4 = 0;
	game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_Callback_FUN_004545c0,&local_c);
	return 0;
}



BOOL __cdecl lego::nerps::NERPs_LiveObject_Callback_FUN_004545c0(LiveObject *liveObj,uint *param_2)
{
	BOOL BVar1;
	ObjectStatsFlags2 OVar2;
	int local_8;
	int local_4;
	
	if (liveObj != NULL) {
		game::LiveObject_GetBlockPos(liveObj,&local_8,&local_4);
		BVar1 = game::Level_BlockIsFlags1_400_AndOptIsFlags2_4(local_8,local_4,1);
		if (BVar1 != 0) {
			OVar2 = game::LiveObject_GetStatsFlags2(liveObj);
			if (((*param_2 & OVar2) != STATS2_NONE) || (param_2[1] != 0xffffffff)) {
				OVar2 = game::LiveObject_GetStatsFlags2(liveObj);
				if ((param_2[1] & OVar2) == STATS2_NONE) {
					return 0;
				}
				if (*param_2 != 0xffffffff) {
					return 0;
				}
			}
			if (param_2[2] == 0) {
				ai::AITask_DoRepair(liveObj);
			}
			else {
				if (param_2[2] == 1) {
					ai::AITask_LiveObject_FUN_00403490(liveObj);
					return 0;
				}
			}
		}
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMonsterAttackNowt(int *stack)
{
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if (*stack == 1) {
		local_c = 0;
		local_8 = 0xffffffff;
		local_4 = 1;
		game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_Callback_FUN_004545c0,&local_c);
		return 0;
	}
	local_c = 0;
	local_8 = 0xffffffff;
	local_4 = 0;
	game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_Callback_FUN_004545c0,&local_c);
	return 0;
}



void __cdecl lego::nerps::NERPs_FUN_004546d0(char *objName,undefined4 param_2)
{
	undefined4 local_8c [32];
	undefined4 local_c;
	ObjectType local_8;
	int local_4;
	
	std::sprintf((char *)local_8c,"%s",objName);
	local_c = param_2;
	game::Object_GetObjectByName(objName,&local_8,&local_4,NULL);
	game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_Callback_FUN_00454740,local_8c);
	return;
}



BOOL __cdecl lego::nerps::NERPs_LiveObject_Callback_FUN_00454740(LiveObject *liveObj,int param_2)
{
	if (((liveObj != NULL) && (liveObj->objType == *(ObjectType *)(param_2 + 0x84))) &&
		 (liveObj->objIndex == *(int *)(param_2 + 0x88))) {
		game::LiveObject_SetLevel(liveObj,*(uint *)(param_2 + 0x80));
	}
	return 0;
}



BOOL __cdecl
lego::nerps::NERPs_LiveObject_Callback_IsOnBlock_FUN_00454780
					(undefined4 param_1,int bx,int by,int *ref_param_4)
{
	LevelData *pLVar1;
	Point2I blockPos;
	float local_c;
	float local_8 [2];
	
	pLVar1 = game::GetLevel();
	game::LiveObject_GetPosition((LiveObject *)ref_param_4[1],&local_c,local_8);
	game::Map3D_WorldToBlockPos_NoZ
						(pLVar1->surfaceMap,local_c,local_8[0],(int *)&blockPos,&blockPos.y);
	if ((bx == blockPos.x) && (by == blockPos.y)) {
		*ref_param_4 = *ref_param_4 + 1;
	}
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRecordObjectAtTutorial(int *stack)
{
	int *piVar1;
	BOOL BVar2;
	uint recordObjPtr;
	int local_8;
	LiveObject *local_4;
	
	piVar1 = stack;
	recordObjPtr = 0;
	do {
		stack = NULL;
		BVar2 = game::Game_GetRecordObject(recordObjPtr,(LiveObject **)&stack);
		if (BVar2 != 0) {
			local_4 = (LiveObject *)stack;
			local_8 = 0;
			NERPs_BlockPointers_FUN_00456f70
								(*piVar1,NERPs_LiveObject_Callback_IsOnBlock_FUN_00454780,&local_8);
			if (local_8 != 0) {
				return recordObjPtr + 1;
			}
		}
		recordObjPtr += 1;
	} while (recordObjPtr < 10);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRecordObjectAmountAtTutorial(int *stack)
{
	int *piVar1;
	BOOL BVar2;
	uint recordObjPtr;
	int local_8;
	LiveObject *local_4;
	
	piVar1 = stack;
	local_8 = 0;
	recordObjPtr = 0;
	do {
		stack = NULL;
		BVar2 = game::Game_GetRecordObject(recordObjPtr,(LiveObject **)&stack);
		if (BVar2 != 0) {
			local_4 = (LiveObject *)stack;
			NERPs_BlockPointers_FUN_00456f70
								(*piVar1,NERPs_LiveObject_Callback_IsOnBlock_FUN_00454780,&local_8);
		}
		recordObjPtr += 1;
	} while (recordObjPtr < 10);
	return local_8;
}



void __cdecl
lego::nerps::NERPs_DrawTutorialIcon
					(LevelData *level,Viewport *viewMain,float elapsedGame,float elapsedAbs)
{
	BOOL BVar1;
	float10 fVar2;
	float10 fVar3;
	Point2F local_14;
	Vector3F local_c;
	
	fVar2 = (float10)fsin((float10)TIMER_005009b8);
	TIMER_005009b8 = TIMER_005009b8 - elapsedAbs * 25.0 * -0.01333333;
	if (globals::g_NERPs_RecordObjectPointer != 0) {
		BVar1 = game::Game_GetRecordObject
											(globals::g_NERPs_RecordObjectPointer - 1,(LiveObject **)&elapsedAbs);
		if (BVar1 != 0) {
			*(undefined4 *)((int)elapsedAbs + 0x3f8) = 1;
			game::LiveObject_GetPosition((LiveObject *)elapsedAbs,(float *)&local_c,&local_c.y);
			fVar3 = game::Map3D_GetWorldZ(level->surfaceMap,local_c.x,local_c.y);
			local_c.z = (float)fVar3;
			lego::view::Viewport_WorldToScreen(viewMain,&local_14,&local_c);
			local_14.x = local_14.x - (float)((int)(globs::gameGlobs.TutorialIcon)->width / 2);
			local_14.y = local_14.y -
									 ((float)fVar2 * 20.0 + (float)((globs::gameGlobs.TutorialIcon)->height << 1));
			lego::image::Image_DisplayScaled(globs::gameGlobs.TutorialIcon,NULL,&local_14,NULL);
		}
	}
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetRecordObjectPointer(int *stack)
{
	globals::g_NERPs_RecordObjectPointer = *stack;
	return *stack;
}



void __cdecl lego::nerps::NERPs_FUN_004549d0(int *param_1)
{
	front::Interface_GetIconClicked(*param_1);
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetOxygenLevel(int *stack)
{
	BOOL BVar1;
	longlong lVar2;
	float local_4;
	
	local_4 = (globs::gameGlobs.level)->oxygenLevel;
	if (local_4 < 1.0) {
		local_4 = 0.0;
	}
	if (local_4 == 0.0) {
		BVar1 = unk::Teleporter_FUN_0046a780
											(TELEPORT_SERVIVE_VEHICLE|TELEPORT_SERVIVE_MINIFIGURE|
											 TELEPORT_SERVIVE_BUILDING|TELEPORT_SERVIVE_ELECTRICFENCE);
		if (BVar1 == 0) {
			local_4 = 1.0;
		}
	}
	if (local_4 < 1.0) {
		local_4 = 1.0;
	}
	lVar2 = __ftol((float10)local_4);
	return (int)lVar2;
}



int __cdecl lego::nerps::funcs::NERPFunc__GenerateSlug(int *stack)
{
	uint local_c;
	Container *local_8;
	ObjectType local_4;
	
	game::Object_GetObjectByName("Slug",&local_4,(int *)&local_c,&local_8);
	FUN_0043b010(NULL,local_c);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetAttackDefer(int *stack)
{
	game::Game_SetAttackDefer(*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetCallToArms(int *stack)
{
	game::Game_SetCallToArmsOn(*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetCallToArmsButtonClicked(int *stack)
{
	return globs::gameGlobs.flags2 & GAME2_CALLTOARMS;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetRockMonster(int *stack)
{
	int objIndex;
	
	objIndex = game::Level_GetEmergeCreature();
	game::Game_TryGeneratedRockMonsterLiveObject
						((int **)(globs::gameGlobs.RockMonsterData_TABLE + objIndex),OBJECT_ROCKMONSTER,objIndex
						 ,*stack - 1,stack[1] - 1);
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRockMonstersDestroyed(int *stack)
{
	return globals::nerps::g_NERPs_RockMonstersDestroyed;
}



void __cdecl lego::nerps::NERPs_IncHiddenObjectsFound(ObjectType unused_objType)
{
	globals::nerps::g_NERPs_HiddenObjectsFound += 1;
	return;
}



void __cdecl lego::nerps::NERPs_ClearHiddenObjectsFound(void)
{
	globals::nerps::g_NERPs_HiddenObjectsFound = 0;
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetHiddenObjectsFound(int *stack)
{
	return globals::nerps::g_NERPs_HiddenObjectsFound;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetHiddenObjectsFound(int *stack)
{
	globals::nerps::g_NERPs_HiddenObjectsFound = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetUpgradeBuildingIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_UPGRADEBUILDING,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetUpgradeBuildingIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x41;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashUpgradeBuildingIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_UPGRADEBUILDING,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGoBackIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_BACKTODEFAULT,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGoBackIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGoBackIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_BACKTODEFAULT,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRockMonsterRunningAway(int *stack)
{
	undefined4 local_c;
	int local_8;
	
	local_c = 0;
	local_8 = 0;
	game::Search_LiveObjects_SkipIgnoreMes
						(NERPs_LiveObject_Callback_RockMonster_FUN_00454c70,&local_c);
	return local_8;
}



BOOL __cdecl
lego::nerps::NERPs_LiveObject_Callback_RockMonster_FUN_00454c70(LiveObject *liveObj,int *param_2)
{
	int iVar1;
	
	iVar1 = *param_2;
	if ((((iVar1 == 0) || (iVar1 == 1)) || (iVar1 == 2)) && (liveObj->objType == OBJECT_ROCKMONSTER))
	{
		if (iVar1 == 0) {
			if (((ushort)((ushort)(liveObj->health < 0.0) << 8 | (ushort)(liveObj->health == 0.0) << 0xe)
					 == 0) &&
				 (liveObj->health <
					liveObj->stats->PainThreshold - liveObj->stats->PainThreshold * 0.01 * 20.0)) {
				game::LiveObject_UnkDoRouting_FUN_00441c00(liveObj,0);
				param_2[1] = param_2[1] + 1;
			}
		}
		else {
			if (iVar1 == 1) {
				liveObj->stats->PainThreshold = (float)param_2[2];
				return 0;
			}
			if (iVar1 == 2) {
				liveObj->health = (float)param_2[2];
				return 0;
			}
		}
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetRockMonsterPainThreshold(int *stack)
{
	undefined4 local_c [2];
	float local_4;
	
	local_c[0] = 1;
	local_4 = (float)(ulonglong)(uint)*stack;
	game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_Callback_RockMonster_FUN_00454c70,local_c)
	;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetRockMonsterHealth(int *stack)
{
	undefined4 local_c [2];
	float local_4;
	
	local_c[0] = 2;
	local_4 = (float)(ulonglong)(uint)*stack;
	game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_Callback_RockMonster_FUN_00454c70,local_c)
	;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetPauseGame(int *stack)
{
	game::Game_SetPaused(0,*stack);
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetAnyKeyPressed(int *stack)
{
	uint uVar1;
	
	uVar1 = input::Input_AnyKeyPressed();
	return uVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetIconPos(int *stack)
{
	globals::nerps::g_NERPs_IconPos.x = (float)(ulonglong)(uint)*stack;
	globals::nerps::g_NERPs_IconPos.y = (float)(ulonglong)(uint)stack[1];
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetIconSpace(int *stack)
{
	globals::nerps::g_NERPs_IconSpace = *stack;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetIconWidth(int *stack)
{
	globals::nerps::g_NERPs_IconWidth = *stack;
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetLevelCompleted(int *stack)
{
	game::Objective_Level_SetCompleteStatus(LEVELSTATUS_COMPLETE);
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetLevelFail(int *stack)
{
	if ((globs::gameGlobs.flags1 & GAME1_UNK_8000000) == GAME1_NONE) {
		game::Objective_Level_SetCompleteStatus(LEVELSTATUS_FAILED);
	}
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGameFail(int *stack)
{
	game::Objective_Level_SetCompleteStatus(LEVELSTATUS_FAILED);
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialPointer(int *stack)
{
	NERPs_FUN_00457430(*stack,stack[1]);
	return 1;
}



void __cdecl lego::nerps::NERPs_SetSubmenuIconClicked__00454e90(char *itemName,BOOL state)
{
	ObjectType objType;
	
	game::Object_GetObjectByName(itemName,&objType,(int *)&itemName,NULL);
	front::Interface_SetSubmenuIconClicked(objType,(int)itemName,state);
	return;
}



int __cdecl lego::nerps::NERPs_FlashSubmenuIcon__00454ed0(char *itemName,BOOL state)
{
	int local_4;
	
	game::Object_GetObjectByName(itemName,(ObjectType *)&itemName,&local_4,NULL);
	front::Interface_SetSubmenuIconFlash((ObjectType)itemName,local_4,state);
	return (int)itemName;
}



BOOL __cdecl
lego::nerps::NERPs_Block_SetClickCount(undefined4 unused,int bx,int by,int *pClickCount)
{
	LevelData *pLVar1;
	
	pLVar1 = game::GetLevel();
	pLVar1->blocks[(pLVar1->dimensions).width * by + bx].clickCount = *pClickCount;
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialBlockClicks(int *stack)
{
	NERPs_BlockPointers_FUN_00456f70(*stack,NERPs_Block_SetClickCount,stack + 1);
	return 1;
}



BOOL __cdecl
lego::nerps::NERPs_GenTutorialCrystals_FUN_00454f60
					(undefined4 unused,uint bx,int by,int *pTutorialCrystals)
{
	LevelData *level;
	int iVar1;
	Point2I blockPos;
	
	level = game::GetLevel();
	blockPos.x = bx;
	blockPos.y = by;
	iVar1 = 0;
	level->blocks[(level->dimensions).width * by + bx].generateCrystals = *pTutorialCrystals;
	if (0 < *pTutorialCrystals) {
		do {
			game::Level_GenerateCrystal(&blockPos,0,NULL,1);
			iVar1 += 1;
		} while (iVar1 < *pTutorialCrystals);
	}
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialCrystals(int *stack)
{
	NERPs_BlockPointers_FUN_00456f70(*stack,NERPs_GenTutorialCrystals_FUN_00454f60,stack + 1);
	return 1;
}



BOOL __cdecl lego::nerps::NERPs_FUN_00454ff0(undefined4 unused,uint bx,int by,int *pGenerateOre)
{
	LevelData *level;
	Point2I blockPos;
	
	level = game::GetLevel();
	blockPos.x = bx;
	blockPos.y = by;
	level->blocks[(level->dimensions).width * by + bx].generateOre = *pGenerateOre;
	game::Level_GenerateOre(&blockPos,0,NULL,0);
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetOreAtIconPositions(int *stack)
{
	NERPs_BlockPointers_FUN_00456f70(*stack,NERPs_FUN_00454ff0,stack + 1);
	return 1;
}



int __cdecl lego::nerps::NERPs_CountSelectedUnits_ByObjectName(char *objName)
{
	LiveObject **ppLVar1;
	uint uVar2;
	int iVar3;
	uint uVar4;
	int local_4;
	
	iVar3 = 0;
	game::Object_GetObjectByName(objName,(ObjectType *)&objName,&local_4,NULL);
	ppLVar1 = game::Message_GetSelectedUnits();
	uVar4 = 0;
	uVar2 = game::Message_GetNumSelectedUnits();
	if (uVar2 != 0) {
		do {
			if (((char *)(*ppLVar1)->objType == objName) && ((*ppLVar1)->objIndex == local_4)) {
				iVar3 += 1;
			}
			uVar4 += 1;
			ppLVar1 = ppLVar1 + 1;
			uVar2 = game::Message_GetNumSelectedUnits();
		} while (uVar4 < uVar2);
	}
	return iVar3;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_CountSelectedUnits_ByObjectName("Pilot");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSmallTruckSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = front::Interface_GetPrimarySelectedUnit();
	if (pLVar1 == NULL) {
		return 0;
	}
	game::Object_GetObjectByName("SmallTruck",&local_4,&local_8,NULL);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSmallDiggerSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = front::Interface_GetPrimarySelectedUnit();
	if (pLVar1 == NULL) {
		return 0;
	}
	game::Object_GetObjectByName("SmallDigger",&local_4,&local_8,NULL);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRapidRiderSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = front::Interface_GetPrimarySelectedUnit();
	if (pLVar1 == NULL) {
		return 0;
	}
	game::Object_GetObjectByName("SmallCat",&local_4,&local_8,NULL);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSmallHelicopterSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = front::Interface_GetPrimarySelectedUnit();
	if (pLVar1 == NULL) {
		return 0;
	}
	game::Object_GetObjectByName("SmallHeli",&local_4,&local_8,NULL);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGraniteGrinderSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = front::Interface_GetPrimarySelectedUnit();
	if (pLVar1 == NULL) {
		return 0;
	}
	game::Object_GetObjectByName("WalkerDigger",&local_4,&local_8,NULL);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



int __cdecl lego::nerps::funcs::NERPFunc__GetChromeCrusherSelected(int *stack)
{
	LiveObject *pLVar1;
	int local_8;
	ObjectType local_4;
	
	pLVar1 = front::Interface_GetPrimarySelectedUnit();
	if (pLVar1 == NULL) {
		return 0;
	}
	game::Object_GetObjectByName("LargeDigger",&local_4,&local_8,NULL);
	if (pLVar1->objIndex != local_8) {
		return 0;
	}
	return (uint)(pLVar1->objType == local_4);
}



BOOL __cdecl lego::nerps::NERPs_Game_DoCallbacks_ByObjectName(char *objName)
{
	ObjectType local_c;
	int local_8;
	BOOL local_4;
	
	game::Object_GetObjectByName(objName,&local_c,&local_8,NULL);
	local_4 = 0;
	game::Search_LiveObjects_SkipIgnoreMes
						(NERPs_LiveObject_Callback_ByObjectTypeIndex_IsDriving,&local_c);
	return local_4;
}



BOOL __cdecl
lego::nerps::NERPs_LiveObject_Callback_ByObjectTypeIndex_IsDriving
					(LiveObject *liveObj1,LiveObject *liveObj_template)
{
	if (((liveObj1->objType == liveObj_template->objType) &&
			(liveObj1->objIndex == liveObj_template->objIndex)) && (liveObj1->drivenObject != NULL)) {
		liveObj_template->customName = liveObj_template->customName + 1;
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__AddPoweredCrystals(int *stack)
{
	uint uVar1;
	
	uVar1 = 0;
	if (*stack != 0) {
		do {
			game::Level_IncrementCrystals();
			uVar1 += 1;
		} while (uVar1 < (uint)*stack);
	}
	game::LiveManager_InitFlagsToggle_AndClearNumDrained();
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__AddStoredOre(int *stack)
{
	uint uVar1;
	
	uVar1 = 0;
	if (*stack != 0) {
		do {
			game::Level_IncOre(ORE_NORMAL);
			uVar1 += 1;
		} while (uVar1 < (uint)*stack);
	}
	return *stack;
}



BOOL __cdecl
lego::nerps::NERPs_GetBlockGenerateCrystals
					(undefined4 unused,int bx,int by,int *out_generateCrystals)
{
	LevelData *level;
	
	level = game::GetLevel();
	*out_generateCrystals =
			 *out_generateCrystals + level->blocks[(level->dimensions).width * by + bx].generateCrystals;
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTutorialCrystals(int *stack)
{
	int local_4;
	
	local_4 = 0;
	NERPs_BlockPointers_FUN_00456f70(*stack,NERPs_GetBlockGenerateCrystals,&local_4);
	return local_4;
}



BOOL __cdecl
lego::nerps::NERPs_Callback_Block_GetClickCount(undefined4 unused,int bx,int by,int *out_clickCount)
{
	LevelData *level;
	
	level = game::GetLevel();
	*out_clickCount = *out_clickCount + level->blocks[(level->dimensions).width * by + bx].clickCount;
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTutorialBlockClicks(int *stack)
{
	int local_4;
	
	local_4 = 0;
	NERPs_BlockPointers_FUN_00456f70(*stack,NERPs_Callback_Block_GetClickCount,&local_4);
	return local_4;
}



int __cdecl lego::nerps::NERPs_GetObjectsOfLevel(char *objName,int in_objLevel)
{
	int iVar1;
	uint uVar2;
	int iVar3;
	uint objLevel;
	ObjectType objType;
	ObjectType local_c;
	char *local_8;
	int local_4;
	
	game::Object_GetObjectByName(objName,&objType,(int *)&objName,NULL);
	if (in_objLevel < 0) {
		iVar3 = 0;
		objLevel = 0;
		iVar1 = game::Object_GetLevels(objType,(int)objName);
		if (iVar1 != 0) {
			do {
				if (in_objLevel == -1) {
					iVar1 = game::LiveObject_GetOrSubLevelsTable(objType,(int)objName,objLevel,1);
					iVar3 += iVar1;
				}
				if (in_objLevel == -2) {
					local_c = objType;
					local_8 = objName;
					local_4 = 0;
					game::Search_LiveObjects_SkipIgnoreMes
										(NERPs_LiveObject_CallbackCheck_FUN_00455580,&local_c);
					iVar3 += local_4;
				}
				objLevel += 1;
				uVar2 = game::Object_GetLevels(objType,(int)objName);
			} while (objLevel < uVar2);
		}
		return iVar3;
	}
	iVar1 = game::LiveObject_GetOrSubLevelsTable(objType,(int)objName,in_objLevel,1);
	return iVar1;
}



BOOL __cdecl
lego::nerps::NERPs_LiveObject_CallbackCheck_FUN_00455580
					(LiveObject *liveObj,LiveObject *liveObj_template)
{
	if ((liveObj->objType == liveObj_template->objType) &&
		 (liveObj->objIndex == liveObj_template->objIndex)) {
		if ((liveObj->flags3 & LIVEOBJ3_HASPOWER) != LIVEOBJ3_NONE) {
			liveObj_template->customName = liveObj_template->customName + 1;
			return 0;
		}
		liveObj_template->customName = NULL;
	}
	return 0;
}



uint __cdecl lego::nerps::NERPs_Game_GetPilotPreviousLevel(char *objName,int objLevel)
{
	uint uVar1;
	ObjectType objType;
	
	game::Object_GetObjectByName(objName,&objType,(int *)&objName,NULL);
	uVar1 = game::LiveObject_GetPreviousLevel(objType,(int)objName,objLevel);
	return uVar1;
}



BOOL __cdecl lego::nerps::NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName(char *objName)
{
	BOOL BVar1;
	ObjectType local_4;
	
	game::Object_GetObjectByName(objName,&local_4,(int *)&objName,NULL);
	BVar1 = front::Interface_GetSubmenuIconClicked(local_4,(int)objName);
	return BVar1;
}



BOOL __cdecl lego::game::NERPs_FlashIcon_FUN_00455630(MenuIcon menuIcon,int param_2)
{
	BOOL BVar1;
	
	if (param_2 == 1) {
		BVar1 = front::Interface_DoAdvisorIcon_FUN_0041e7c0(menuIcon,TRUE);
		if (BVar1 != 0) {
			front::Interface_SetIconFlash(menuIcon,TRUE);
			return TRUE;
		}
	}
	else {
		front::Advisor_ClearFlag2();
		front::Interface_SetIconFlash(menuIcon,FALSE);
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinGraniteGrinder(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPs_Game_DoCallbacks_ByObjectName("Walkerdigger");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinChromeCrusher(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPs_Game_DoCallbacks_ByObjectName("LargeDigger");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinSmallDigger(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPs_Game_DoCallbacks_ByObjectName("SmallDigger");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinRapidRider(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPs_Game_DoCallbacks_ByObjectName("SmallCat");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinSmallTruck(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPs_Game_DoCallbacks_ByObjectName("SmallTruck");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFigureinSmallHelicopter(int *stack)
{
	BOOL BVar1;
	
	BVar1 = NERPs_Game_DoCallbacks_ByObjectName("SmallHeli");
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetBarracksLevel(int *stack)
{
	NERPs_FUN_004546d0("Barracks",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetDocksLevel(int *stack)
{
	NERPs_FUN_004546d0("Docks",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGeoDomeLevel(int *stack)
{
	NERPs_FUN_004546d0("Geo-dome",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetPowerstationLevel(int *stack)
{
	NERPs_FUN_004546d0("Powerstation",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetToolStoreLevel(int *stack)
{
	NERPs_FUN_004546d0("Toolstation",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGunstationLevel(int *stack)
{
	NERPs_FUN_004546d0("Gunstation",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTeleportPadLevel(int *stack)
{
	NERPs_FUN_004546d0("TeleportPad",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetSuperTeleportLevel(int *stack)
{
	NERPs_FUN_004546d0("TeleportBIG",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetUpgradeStationLevel(int *stack)
{
	NERPs_FUN_004546d0("Upgrade",*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetBarracksSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_CountSelectedUnits_ByObjectName("Barracks");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDocksSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_CountSelectedUnits_ByObjectName("Docks");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGeoDomeSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_CountSelectedUnits_ByObjectName("Geo-Dome");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPowerstationSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_CountSelectedUnits_ByObjectName("Powerstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetToolStoreSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_CountSelectedUnits_ByObjectName("Toolstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGunstationSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_CountSelectedUnits_ByObjectName("Gunstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTeleportPadSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_CountSelectedUnits_ByObjectName("TeleportPad");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSuperTeleportSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_CountSelectedUnits_ByObjectName("TeleportBIG");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetUpgradeStationSelected(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_CountSelectedUnits_ByObjectName("Upgrade");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredBarracksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Barracks",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredDocksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Docks",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredGeodomeBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Geo-dome",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredPowerstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Powerstation",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredToolStoresBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Toolstation",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredGunstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("GunStation",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("TeleportPad",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredVehicleTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("TeleportBIG",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPoweredUpgradeStationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Upgrade",-2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetBarracksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Barracks",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDocksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Docks",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGeodomeBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Geo-dome",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPowerstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Powerstation",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetToolStoresBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Toolstation",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGunstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("GunStation",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("TeleportPad",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetVehicleTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("TeleportBIG",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetUpgradeStationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Upgrade",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1BarracksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Barracks",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1DocksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Docks",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1GeodomeBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Geo-dome",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1PowerstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Powerstation",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1ToolStoresBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Toolstation",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1GunstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("GunStation",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1TeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("TeleportPad",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1VehicleTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("TeleportBIG",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel1UpgradeStationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Upgrade",1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2BarracksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Barracks",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2DocksBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Docks",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2GeodomeBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Geo-dome",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2PowerstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Powerstation",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2ToolStoresBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Toolstation",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2GunstationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("GunStation",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2TeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("TeleportPad",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2VehicleTeleportsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("TeleportBIG",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLevel2UpgradeStationsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Upgrade",2);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetBarracksIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("Barracks");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGeodomeIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("Geo-dome");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPowerstationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("Powerstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetToolStoreIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("Toolstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGunstationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("Gunstation");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTeleportPadIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("TeleportPad");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetVehicleTransportIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("TeleportBIG");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetUpgradeStationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SubMenu_GetBuildingVehicleIcon_ByObjectName("Upgrade");
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetBarracksIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("Barracks",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGeodomeIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("Geo-dome",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetPowerstationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("Powerstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetToolStoreIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("Toolstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGunstationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("Gunstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTeleportPadIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("TeleportPad",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetVehicleTransportIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("TeleportBIG",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetUpgradeStationIconClicked(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_SetSubmenuIconClicked__00454e90("Upgrade",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashBarracksIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("Barracks",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGeodomeIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("Geo-dome",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashPowerStationIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("Powerstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashToolStoreIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("Toolstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGunstationIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("Gunstation",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTeleportPadIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("TeleportPad",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashVehicleTransportIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("TeleportBIG",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashUpgradeStationIcon(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_FlashSubmenuIcon__00454ed0("Upgrade",*stack);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPathsBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Path",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetStudCount(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("ProcessedOre",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSmallHelicoptersOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("SmallHeli",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGraniteGrindersOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("WalkerDigger",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRapidRidersOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("SmallCat",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSmallDiggersOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("SmallDigger",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetSlugsOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Slug",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMiniFiguresOnLevel(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Pilot",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetOreRefineriesBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("Refinery",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetCrystalRefineriesBuilt(int *stack)
{
	int iVar1;
	
	iVar1 = NERPs_GetObjectsOfLevel("CrystalRefinery",-1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTeleportIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 1;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDynamiteClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0xd;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMountIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x18;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTrainIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x39;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDropSonicBlasterIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x21;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGetToolIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x30;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGetPusherIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x36;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGetSonicBlasterIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x38;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTrainSailorIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x3e;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTrainPilotIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x3d;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTrainDriverIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x3a;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetGetLaserIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x35;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDismountIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0x19;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetDigIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0xb;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetBuildIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 2;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetLayPathIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 5;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetPlaceFenceIconClicked(int *stack)
{
	int iVar1;
	int local_4;
	
	local_4 = 0xe;
	iVar1 = NERPs_FUN_004549d0(&local_4);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTeleportIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_TEKEPORTMAN,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetDynamiteClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_DYNAMITE,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTrainIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_TRAINSKILL,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTrainDriverIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_TRAINDRIVER,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTrainSailorIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_TRAINSAILOR,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGetToolIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_GETTOOL,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetDropSonicBlasterIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_DROPBIRDSCARER,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGetLaserIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_GETLASER,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGetPusherIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_GETPUSHERGUN,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetGetSonicBlasterIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_GETBIRDSCARER,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetDismountIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_GETOUT,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTrainPilotIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_TRAINPILOT,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMountIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_GETIN,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetDigIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_DIG,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetBuildIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_BUILDBUILDING,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetLayPathIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_LAYPATH,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetPlaceFenceIconClicked(int *stack)
{
	BOOL BVar1;
	
	BVar1 = front::Interface_SetIconClicked(INTERFACE_MENUITEM_PLACEFENCE,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTeleportIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_TEKEPORTMAN,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashDynamiteIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_DYNAMITE,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashMountIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_GETIN,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTrainIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_TRAINSKILL,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTrainDriverIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_TRAINDRIVER,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTrainPilotIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_TRAINPILOT,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashTrainSailorIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_TRAINSAILOR,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashDismountIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_GETOUT,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGetToolIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_GETTOOL,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashDropSonicBlasterIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_DROPBIRDSCARER,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGetLaserIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_GETLASER,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGetPusherIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_GETPUSHERGUN,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashGetSonicBlasterIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_GETBIRDSCARER,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashDigIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_DIG,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashBuildIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_BUILDBUILDING,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashLayPathIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_LAYPATH,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__FlashPlaceFenceIcon(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::NERPs_FlashIcon_FUN_00455630(INTERFACE_MENUITEM_PLACEFENCE,*stack);
	return BVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRandom(int *stack)
{
	ushort uVar1;
	
	uVar1 = math::Maths_Rand();
	return uVar1 & 0xfff;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRandomTrueFalse(int *stack)
{
	ushort uVar1;
	
	uVar1 = math::Maths_Rand();
	return uVar1 & 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRandom10(int *stack)
{
	short sVar1;
	
	sVar1 = math::Maths_Rand();
	return (int)sVar1 % 10;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetRandom100(int *stack)
{
	short sVar1;
	
	sVar1 = math::Maths_Rand();
	return (int)sVar1 % 100;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetCrystalsPickedUp(int *stack)
{
	return (globs::gameGlobs.level)->field_94;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetCrystalsCurrentlyStored(int *stack)
{
	int iVar1;
	
	iVar1 = game::Level_GetCrystalCount(1);
	return iVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__False(int *stack)
{
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetOrePickedUp(int *stack)
{
	return (globs::gameGlobs.level)->field_a8;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetOreCurrentlyStored(int *stack)
{
	return (globs::gameGlobs.level)->numOre;
}



// NOTE: For the sake of Ghidra auto-completion, the return type
// will be `TutorialFlags`, rather than the required `int` type.

TutorialFlags __cdecl lego::nerps::funcs::NERPFunc__GetTutorialFlags(int *stack)
{
	return globals::nerps::g_NERPs_TutorialFlags;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR0(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[0];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR1(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[1];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR2(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[2];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR3(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[3];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR4(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[4];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR5(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[5];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR6(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[6];
}



int __cdecl lego::nerps::funcs::NERPFunc__GetR7(int *stack)
{
	return globals::nerps::g_NERPs_REGISTERS_TABLE[7];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR0(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[0] += *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[0];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR1(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[1] += *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[1];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR2(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[2] += *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[2];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR3(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[3] += *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[3];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR4(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[4] += *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[4];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR5(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[5] += *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[5];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR6(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[6] += *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[6];
}



int __cdecl lego::nerps::funcs::NERPFunc__AddR7(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[7] += *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[7];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR0(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[0] -= *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[0];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR1(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[1] -= *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[1];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR2(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[2] -= *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[2];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR3(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[3] -= *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[3];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR4(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[4] -= *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[4];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR5(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[5] -= *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[5];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR6(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[6] -= *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[6];
}



int __cdecl lego::nerps::funcs::NERPFunc__SubR7(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[7] -= *stack;
	return globals::nerps::g_NERPs_REGISTERS_TABLE[7];
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR0(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[0] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR1(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[1] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR2(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[2] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR3(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[3] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR4(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[4] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR5(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[5] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR6(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[6] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetR7(int *stack)
{
	globals::nerps::g_NERPs_REGISTERS_TABLE[7] = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialFlags(int *stack)
{
	globals::nerps::g_NERPs_TutorialFlags = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTrainFlags(int *stack)
{
	return globs::liveGlobs.NERPs_TrainFlags;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTrainFlags(int *stack)
{
	globs::liveGlobs.NERPs_TrainFlags = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMonstersOnLevel(int *stack)
{
	int iVar1;
	int iVar2;
	int iVar3;
	
	iVar1 = NERPs_GetObjectsOfLevel("LavaMonster",0);
	iVar2 = NERPs_GetObjectsOfLevel("RockMonster",0);
	iVar3 = NERPs_GetObjectsOfLevel("IceMonster",0);
	return iVar3 + iVar1 + iVar2;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetBuildingsTeleported(int *stack)
{
	return globs::liveGlobs.BuildingsTeleported;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetBuildingsTeleported(int *stack)
{
	game::LiveManage_SetNumBuildingsTeleported(*stack);
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMessagePermit(int *stack)
{
	globals::nerps::g_NERPs_IsLoaded = *stack;
	if (*stack == 1) {
		game::Game_SetFlags2_40_And_2_unkCamera(0,1);
		game::Game_SetFlags2_80(0);
	}
	FLAGS_00504610 = 0;
	DAT_00504614 = 0;
	return *stack;
}



BOOL __cdecl lego::nerps::NERPs_IsLoaded(void)
{
	return globals::nerps::g_NERPs_IsLoaded;
}



int __cdecl lego::nerps::NERPs_GetMessageWait(void)
{
	return globals::nerps::g_NERPs_MessageWait;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMessageWait(int *stack)
{
	globals::nerps::g_NERPs_MessageWait = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMessageTimerValues(int *stack)
{
	globals::nerps::g_NERPs_MessageTimerValues[0] = (float)(ulonglong)(uint)*stack;
	globals::nerps::g_NERPs_MessageTimerValues[1] = (float)(ulonglong)(uint)stack[1];
	globals::nerps::g_NERPs_MessageTimerValues[2] = (float)(ulonglong)(uint)stack[2];
	return 1;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMessageTimer(int *stack)
{
	longlong lVar1;
	
	lVar1 = __ftol((float10)FLOAT_0050098c);
	return (int)lVar1;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetMessage(int *stack)
{
	BOOL BVar1;
	char *text;
	int iVar2;
	uint lineIndex;
	
	BVar1 = NERPs_IsLoaded();
	if (BVar1 != 0) {
		return 0;
	}
	lineIndex = *stack;
	if (lineIndex != 0) {
		lineIndex -= 1;
	}
	text = NERPs_GetMessageLine(lineIndex);
	if (lineIndex != (&globals::nerps::g_NERPMessageSounds_UNKCOUNT)[UINT_00556de0]) {
		if (UINT_00556de0 == 8) {
			DAT_00556dc0 = DAT_00556dd0;
			DAT_00556dc4 = DAT_00556dd4;
			DAT_00556dcc = DAT_00556ddc;
			DAT_00556dc8 = DAT_00556dd8;
			UINT_00556de0 = 4;
		}
		(&DAT_00556dc0)[UINT_00556de0] = lineIndex;
		UINT_00556de0 += 1;
		if (UINT_00556de0 != 0) {
			game::Game_SetFlags2_80(1);
		}
		if (UINT_00556de4 != 0) {
			UINT_00556de4 += 1;
		}
	}
	front::Text_SetMessage(text,stack[1]);
	DAT_00500988 = stack[1];
	BOOL_004a7740 = 1;
	iVar2 = NERPs_GetMessageWait();
	if (iVar2 != 0) {
		ddraw::DirectDraw_Flip();
		while ((globs::INPUT.Key_Map[28] == false ||
					 (globs::INPUT.prevKey_Map[28] == globs::INPUT.Key_Map[28]))) {
			input::Input_ReadKeys();
		}
	}
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetObjectiveSwitch(int *stack)
{
	globals::g_NERPs_ObjectiveSwitch = *stack;
	return *stack;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetObjectiveSwitch(int *stack)
{
	if (globals::g_NERPs_ObjectiveSwitch != 0) {
		globals::g_NERPs_ObjectiveSwitch = 0;
		return 1;
	}
	return 0;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetObjectiveShowing(int *stack)
{
	BOOL BVar1;
	
	BVar1 = game::Objective_Level_IsObjectiveFinished();
	return (uint)(BVar1 != 0);
}



void __cdecl lego::game::NERPs_PlayUnkSampleIndex(void)
{
	if (globals::nerps::g_NERPs_UnkSampleIndex != -1) {
		snd::Sound3D_Play2(SOUND3D_PLAY_NORMAL,NULL,globals::nerps::g_NERPs_UnkSampleIndex,FALSE,NULL);
	}
	return;
}



// WARNING: Could not reconcile some variable overlaps

void __cdecl lego::nerps::NERPs_Level_NERPMessage_Parse(char *text,undefined4 *param_2,BOOL param_3)
{
	char cVar1;
	bool bVar2;
	byte bVar3;
	BOOL BVar4;
	TutorialFlags TVar5;
	int iVar6;
	uint uVar7;
	uint uVar8;
	undefined4 *puVar9;
	char *pcVar10;
	ImageBMP **ppIVar11;
	float10 fVar12;
	Point2F local_164;
	uint local_15c;
	undefined4 uStack344;
	float local_154;
	ImageBMP *local_150 [20];
	char local_100 [256];
	
	ppIVar11 = local_150;
	local_150[0] = NULL;
	local_15c &= 0xffffff00;
	for (iVar6 = 0x13; ppIVar11 = ppIVar11 + 1, iVar6 != 0; iVar6 += -1) {
		*ppIVar11 = NULL;
	}
	local_154 = globals::nerps::g_NERPs_MessageTimerValues[2];
	if (((globals::nerps::g_NERPMessages_COUNT == 0) &&
			(globals::nerps::g_NERPMessageSounds_COUNT == 0)) && (param_2 != NULL)) {
		uVar7 = 0xffffffff;
		do {
			pcVar10 = text;
			if (uVar7 == 0) break;
			uVar7 -= 1;
			pcVar10 = text + 1;
			cVar1 = *text;
			text = pcVar10;
		} while (cVar1 != '\0');
		uVar7 = ~uVar7;
		puVar9 = (undefined4 *)(pcVar10 + -uVar7);
		for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
			*param_2 = *puVar9;
			puVar9 = puVar9 + 1;
			param_2 = param_2 + 1;
		}
		for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
			*(undefined *)param_2 = *(undefined *)puVar9;
			puVar9 = (undefined4 *)((int)puVar9 + 1);
			param_2 = (undefined4 *)((int)param_2 + 1);
		}
	}
	else {
		cVar1 = *text;
		local_164.x = (float)param_2;
		while (cVar1 != '\0') {
			cVar1 = *text;
			if (cVar1 == '<') {
				cVar1 = text[1];
				text = text + 1;
				bVar2 = false;
				pcVar10 = local_100;
				while ((cVar1 != '\0' && (!bVar2))) {
					if (cVar1 == '>') {
						*pcVar10 = '\0';
						bVar3 = 0;
						if (globals::nerps::g_NERPMessages_COUNT != 0) {
							uVar7 = 0;
							do {
								iVar6 = std::_stricmp(*(char **)((int)globals::nerps::g_NERPMessages_TABLE +
																								uVar7 * 8),local_100);
								if (iVar6 == 0) {
									bVar2 = true;
									local_150[local_15c & 0xff] =
											 *(ImageBMP **)
												((int)globals::nerps::g_NERPMessages_TABLE + (uint)bVar3 * 8 + 4);
									local_15c = local_15c & 0xffffff00 | (uint)(byte)((char)local_15c + 1);
									break;
								}
								bVar3 += 1;
								uVar7 = (uint)bVar3;
							} while (uVar7 < (uint)globals::nerps::g_NERPMessages_COUNT);
						}
					}
					else {
						*pcVar10 = cVar1;
					}
					pcVar10 = pcVar10 + 1;
					text = text + 1;
					cVar1 = *text;
				}
			}
			else {
				if (cVar1 == '#') {
					cVar1 = text[1];
					text = text + 1;
					bVar2 = false;
					pcVar10 = local_100;
					while ((cVar1 != '\0' && (!bVar2))) {
						if (cVar1 == '#') {
							*pcVar10 = '\0';
							bVar3 = 0;
							if (globals::nerps::g_NERPMessageSounds_COUNT != 0) {
								uVar7 = 0;
								do {
									iVar6 = std::_stricmp(globals::nerps::g_NERPMessageSounds_TABLE[uVar7].key,
																				local_100);
									if (iVar6 == 0) {
										uVar7 = (uint)bVar3;
										iVar6 = globals::nerps::g_NERPMessageSounds_TABLE[uVar7].sampleIndex;
										if (globals::nerps::g_NERPMessageSounds_UNKCOUNT != uVar7) {
											globals::nerps::g_NERPMessageSounds_UNKCOUNT = uVar7;
											fVar12 = snd::Sound3D_GetSamplePlayTime(iVar6);
											local_154 = (float)(fVar12 * (float10)globals::nerps::
																														g_NERPs_MessageTimerValues[0] +
																				 (float10)globals::nerps::g_NERPs_MessageTimerValues[1]);
											BVar4 = snd::SFX_IsSoundOn();
											if (BVar4 != 0) {
												snd::SFX_StopGlobalSample();
												fVar12 = snd::Sound3D_GetSamplePlayTime(iVar6);
												snd::SFX_SetGlobalSampleDurationIfLE0_AndNullifyHandle
																	((float)(fVar12 * (float10)25.0));
												snd::Sound3D_Play2(SOUND3D_PLAY_NORMAL,NULL,iVar6,0,NULL);
												globals::nerps::g_NERPs_UnkSampleIndex = iVar6;
												TVar5 = funcs::NERPFunc__GetTutorialFlags(NULL);
												if (TVar5 == TUTORIAL_NONE) {
													front::Advisor_SetCurrentAdvisor(ADVISOR_TALKINGAME,TRUE);
													globals::g_NERPs_AdvisorTalkingMode = TRUE;
												}
											}
										}
										break;
									}
									bVar3 += 1;
									uVar7 = (uint)bVar3;
								} while (uVar7 < (uint)globals::nerps::g_NERPMessageSounds_COUNT);
							}
							bVar2 = true;
						}
						else {
							*pcVar10 = cVar1;
						}
						pcVar10 = pcVar10 + 1;
						text = text + 1;
						cVar1 = *text;
					}
				}
				else {
					if (param_2 != NULL) {
						*(char *)local_164.x = cVar1;
						local_164.x = (float)((int)local_164.x + 1);
					}
					text = text + 1;
				}
			}
			cVar1 = *text;
		}
		if (param_2 != NULL) {
			*(char *)local_164.x = '\0';
		}
		if ((char)local_15c != '\0') {
			ppIVar11 = local_150;
			uVar8 = local_15c & 0xff;
			iVar6 = 0;
			uVar7 = uVar8;
			do {
				local_15c = globals::nerps::g_NERPs_IconWidth * uVar8;
				local_164.y = globals::nerps::g_NERPs_IconPos.y;
				uStack344 = 0;
				local_164.x = (float)(ulonglong)(uint)(globals::nerps::g_NERPs_IconSpace * iVar6) +
											(globals::nerps::g_NERPs_IconPos.x - (float)(ulonglong)local_15c);
				lego::image::Image_DisplayScaled(*ppIVar11,NULL,&local_164,NULL);
				iVar6 += 1;
				ppIVar11 = ppIVar11 + 1;
				uVar7 -= 1;
			} while (uVar7 != 0);
		}
	}
	if (param_3 != 0) {
		FLOAT_0050098c = local_154;
	}
	return;
}



void __cdecl lego::nerps::NERPs_InitBlockPointersTable(LevelData *level)
{
	BlockPointer *pBVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	BlockPointer **ppBVar5;
	uint uVar6;
	
	uVar4 = 0;
	ppBVar5 = level->blockPointers;
	for (iVar2 = 0x37; iVar2 != 0; iVar2 += -1) {
		*ppBVar5 = NULL;
		ppBVar5 = ppBVar5 + 1;
	}
	if ((level->dimensions).width != 0) {
		do {
			uVar6 = 0;
			if ((level->dimensions).height != 0) {
				do {
					if (level->blocks[uVar6 * (level->dimensions).width + uVar4].blockpointer != 0) {
						pBVar1 = (BlockPointer *)std::malloc(0xc);
						uVar3 = (uint)level->blocks[uVar6 * (level->dimensions).width + uVar4].blockpointer;
						(pBVar1->position).x = uVar4;
						(pBVar1->position).y = uVar6;
						pBVar1->id = (uint)level->blockPointers[uVar3];
						level->blockPointers[uVar3] = pBVar1;
						level->blocks[uVar6 * (level->dimensions).width + uVar4].blockpointer = 0;
					}
					uVar6 += 1;
				} while (uVar6 < (uint)(level->dimensions).height);
			}
			uVar4 += 1;
		} while (uVar4 < (uint)(level->dimensions).width);
	}
	return;
}



BlockPointer * __cdecl lego::nerps::NERPs_GetBlockPointer(LevelData *level,int blockPointerIdx)
{
	if (((-1 < blockPointerIdx) && (blockPointerIdx < 0x37)) &&
		 (level->blockPointers[blockPointerIdx] != NULL)) {
		return level->blockPointers[blockPointerIdx];
	}
	return NULL;
}



void __cdecl lego::nerps::NERPs_BlockPointers_FUN_00456f20(void)
{
	BlockPointer *pBVar1;
	LevelData *level;
	BlockPointer *buffer;
	BlockPointer **ppBVar2;
	int blockPointerIdx;
	
	level = game::GetLevel();
	blockPointerIdx = 0;
	ppBVar2 = level->blockPointers;
	do {
		buffer = NERPs_GetBlockPointer(level,blockPointerIdx);
		while (buffer != NULL) {
			pBVar1 = (BlockPointer *)buffer->id;
			std::free(buffer);
			buffer = pBVar1;
		}
		*ppBVar2 = NULL;
		blockPointerIdx += 1;
		ppBVar2 = ppBVar2 + 1;
	} while (blockPointerIdx < 0x37);
	return;
}



void __cdecl
lego::nerps::NERPs_BlockPointers_FUN_00456f70
					(int blockPointerIdx,undefined *callback,void *lpContext)
{
	LevelData *level;
	BlockPointer *pBVar1;
	int iVar2;
	
	level = game::GetLevel();
	pBVar1 = NERPs_GetBlockPointer(level,blockPointerIdx);
	while ((pBVar1 != NULL &&
				 (iVar2 = (*(code *)callback)(pBVar1,(pBVar1->position).x,(pBVar1->position).y,lpContext),
				 iVar2 != 0))) {
		pBVar1 = (BlockPointer *)pBVar1->id;
	}
	return;
}



BOOL __cdecl
lego::nerps::NERPs_UnkTutorialBlock_DoAction(undefined4 unused,int x,int y,undefined4 *param_4)
{
	LevelData *level;
	BOOL BVar1;
	LiveObject *pLVar2;
	int iVar3;
	int *piVar4;
	Point2I local_48;
	uint local_40;
	uint local_3c;
	Vector3F local_38;
	int local_2c [5];
	int local_18;
	int local_14;
	undefined4 local_10;
	undefined4 local_c;
	LiveObject *local_8;
	undefined4 local_4;
	
	level = game::GetLevel();
	local_48.x = x;
	local_48.y = y;
	switch(*param_4) {
	case 1:
		param_4[2] = param_4[2] +
								 (level->blocks[(level->dimensions).width * y + x].flags1 & BLOCK1_UNK_8);
		return 1;
	case 2:
		BVar1 = 0;
		level = game::GetLevel();
		game::Level_DestroyWall(level,x,y,BVar1);
		return 1;
	case 3:
		BVar1 = game::Level_Block_IsPowerPath(&local_48);
		param_4[2] = param_4[2] + BVar1;
		return 1;
	case 4:
		iVar3 = (level->dimensions).width * y + x;
		level->blocks[iVar3].flags1 = level->blocks[iVar3].flags1 & ~BLOCK1_RUBBLE_FULL;
		game::Level_BlockProc_FUN_00432bc0(&local_48);
		game::Level_Block_FUN_00432530(&local_48);
		return 1;
	case 5:
		game::LiveObject_FUN_0042dd70(NULL,(uint *)&local_48,1);
		return 1;
	case 6:
		res::Container_GetPosition((globs::gameGlobs.cameraMain)->resData3,NULL,&local_38);
		game::Map3D_WorldToBlockPos_NoZ
							(level->surfaceMap,local_38.x,local_38.y,(int *)&local_40,(int *)&local_3c);
		if ((local_48.x == local_40) && (local_48.y == local_3c)) {
			param_4[2] = 1;
			return 1;
		}
		break;
	case 7:
		iVar3 = game::Level_GetEmergeCreature();
		pLVar2 = game::Game_TryGeneratedRockMonsterLiveObject
											 ((int **)(globs::gameGlobs.RockMonsterData_TABLE + iVar3),OBJECT_ROCKMONSTER,
												iVar3,local_48.x,local_48.y);
		if (pLVar2 != NULL) {
			pLVar2->stats->PainThreshold = 60.0;
			return 1;
		}
		break;
	case 8:
		ai::AITask_DoGoto_Congregate(&local_48);
		return 1;
	case 9:
		ai::AITask_FUN_00403360(&local_48);
		return 1;
	case 10:
		piVar4 = local_2c;
		for (iVar3 = 0xb; iVar3 != 0; iVar3 += -1) {
			*piVar4 = 0;
			piVar4 = piVar4 + 1;
		}
		local_18 = x;
		local_14 = y;
		game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_CallbackCheck_FUN_00457320,local_2c);
		param_4[2] = param_4[2] + local_2c[2];
		return 1;
	case 0xb:
		piVar4 = local_2c;
		for (iVar3 = 0xb; iVar3 != 0; iVar3 += -1) {
			*piVar4 = 0;
			piVar4 = piVar4 + 1;
		}
		local_18 = x;
		local_14 = y;
		local_10 = 1;
		game::Search_LiveObjects_SkipIgnoreMes
							(NERPs_LiveObject_Callback_SetField3f8_FUN_00457390,local_2c);
		return 1;
	case 0xc:
		piVar4 = local_2c;
		for (iVar3 = 0xb; iVar3 != 0; iVar3 += -1) {
			*piVar4 = 0;
			piVar4 = piVar4 + 1;
		}
		local_18 = x;
		local_14 = y;
		local_c = 1;
		local_4 = 2;
		game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_CallbackCheck_FUN_00457320,local_2c);
		pLVar2 = local_8;
		if (local_2c[2] != 0) {
			local_4 = 6;
			game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_CallbackCheck_FUN_00457320,local_2c);
			if (local_2c[2] != 0) {
				game::LiveObject_TryCollect_FUN_00439ce0(pLVar2,local_8);
				return 1;
			}
		}
		break;
	case 0xd:
		piVar4 = local_2c;
		for (iVar3 = 0xb; iVar3 != 0; iVar3 += -1) {
			*piVar4 = 0;
			piVar4 = piVar4 + 1;
		}
		local_18 = x;
		local_14 = y;
		game::Search_LiveObjects_SkipIgnoreMes(NERPs_LiveObject_CallbackCheck_FUN_00457320,local_2c);
		param_4[2] = param_4[2] + local_2c[2];
	}
	return 1;
}



BOOL __cdecl lego::nerps::NERPs_LiveObject_CallbackCheck_FUN_00457320(LiveObject *liveObj,int level)
{
	int local_8;
	int local_4;
	
	if (liveObj != NULL) {
		game::LiveObject_GetBlockPos(liveObj,&local_8,&local_4);
		if ((local_8 == *(int *)(level + 0x14)) && (local_4 == *(int *)(level + 0x18))) {
			if ((*(int *)(level + 0x20) != 0) && (liveObj->objType == *(ObjectType *)(level + 0x28))) {
				*(LiveObject **)(level + 0x24) = liveObj;
				*(undefined4 *)(level + 8) = 1;
				return 1;
			}
			*(int *)(level + 8) = *(int *)(level + 8) + 1;
		}
	}
	return 0;
}



BOOL __cdecl
lego::nerps::NERPs_LiveObject_Callback_SetField3f8_FUN_00457390(LiveObject *liveObj,int param_2)
{
	int local_8;
	int local_4;
	
	if (liveObj != NULL) {
		game::LiveObject_GetBlockPos(liveObj,&local_8,&local_4);
		if ((local_8 == *(int *)(param_2 + 0x14)) && (local_4 == *(int *)(param_2 + 0x18))) {
			liveObj->field_3f8 = 1;
			return 0;
		}
		liveObj->field_3f8 = 0;
	}
	return 0;
}



int __cdecl
lego::nerps::funcs::NERPFunc__MakeSomeoneOnThisBlockPickUpSomethingOnThisBlock(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_24 = 0;
	local_28 = *stack;
	local_2c = 0xc;
	NERPs_BlockPointers_FUN_00456f70(local_28,PTR_NERPs_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



void __cdecl lego::nerps::NERPs_FUN_00457430(int blockPointerIdx,int unkMode0_1)
{
	LevelData *level;
	BlockPointer *pBVar1;
	BOOL BVar2;
	int local_34;
	int local_30;
	undefined4 local_2c;
	int local_28;
	undefined4 local_24;
	int local_18;
	int local_14;
	
	level = game::GetLevel();
	for (pBVar1 = NERPs_GetBlockPointer(level,blockPointerIdx); pBVar1 != NULL;
			pBVar1 = (BlockPointer *)pBVar1->id) {
		if ((LiveObject *)unkMode0_1 == (LiveObject *)0x1) {
			level->blocks[(level->dimensions).width * (pBVar1->position).y + (pBVar1->position).x].
			blockpointer = (byte)blockPointerIdx;
			local_28 = blockPointerIdx;
			local_24 = 0;
			local_2c = 0xb;
			NERPs_BlockPointers_FUN_00456f70
								(blockPointerIdx,PTR_NERPs_UnkTutorialBlock_DoAction_004a776c,&local_2c);
		}
		if ((LiveObject *)unkMode0_1 == NULL) {
			level->blocks[(level->dimensions).width * (pBVar1->position).y + (pBVar1->position).x].
			blockpointer = 0;
		}
	}
	if ((globals::g_NERPs_RecordObjectPointer != 0) &&
		 (BVar2 = game::Game_GetRecordObject
												(globals::g_NERPs_RecordObjectPointer - 1,(LiveObject **)&unkMode0_1),
		 BVar2 != 0)) {
		game::LiveObject_GetBlockPos((LiveObject *)unkMode0_1,&local_34,&local_30);
		local_18 = local_34;
		local_14 = local_30;
		NERPs_LiveObject_Callback_SetField3f8_FUN_00457390((LiveObject *)unkMode0_1,(int)&local_2c);
	}
	return;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetCongregationAtTutorial(int *stack)
{
	int local_2c;
	int local_28;
	int local_24;
	
	local_24 = 0;
	local_28 = *stack;
	local_2c = 9 - (uint)(stack[1] != 0);
	NERPs_BlockPointers_FUN_00456f70(local_28,PTR_NERPs_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetRockMonsterAtTutorial(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 7;
	local_28 = *stack;
	local_24 = 0;
	NERPs_BlockPointers_FUN_00456f70(local_28,PTR_NERPs_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetCameraGotoTutorial(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 5;
	local_28 = *stack;
	local_24 = 0;
	NERPs_BlockPointers_FUN_00456f70(local_28,PTR_NERPs_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetCameraAtTutorial(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 6;
	local_28 = *stack;
	local_24 = 0;
	NERPs_BlockPointers_FUN_00456f70(local_28,PTR_NERPs_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTutorialBlockIsGround(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 1;
	local_28 = *stack;
	local_24 = 0;
	NERPs_BlockPointers_FUN_00456f70(local_28,PTR_NERPs_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetTutorialBlockIsPath(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 3;
	local_28 = *stack;
	local_24 = 0;
	NERPs_BlockPointers_FUN_00456f70(local_28,PTR_NERPs_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialBlockIsGround(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 2;
	local_28 = *stack;
	local_24 = 0;
	NERPs_BlockPointers_FUN_00456f70(local_28,PTR_NERPs_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__SetTutorialBlockIsPath(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 4;
	local_28 = *stack;
	local_24 = 0;
	NERPs_BlockPointers_FUN_00456f70(local_28,PTR_NERPs_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetUnitAtBlock(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 10;
	local_28 = *stack;
	local_24 = 0;
	NERPs_BlockPointers_FUN_00456f70(local_28,PTR_NERPs_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



int __cdecl lego::nerps::funcs::NERPFunc__GetMonsterAtTutorial(int *stack)
{
	undefined4 local_2c;
	int local_28;
	int local_24;
	
	local_2c = 0xd;
	local_28 = *stack;
	local_24 = 0;
	NERPs_BlockPointers_FUN_00456f70(local_28,PTR_NERPs_UnkTutorialBlock_DoAction_004a776c,&local_2c);
	return local_24;
}



void __cdecl
lego::game::Objective_Level_LoadObjectiveText
					(CFGProperty *root,undefined4 param_2,char *param_3,LevelData *level,char *filename)
{
	char cVar1;
	TextWindow *textWnd;
	uint uVar2;
	char *pcVar3;
	uint uVar4;
	char *pcVar5;
	int iVar6;
	int iVar7;
	TextWindow **ppTVar8;
	void **ppvVar9;
	undefined4 *puVar10;
	undefined4 *puVar11;
	char *pcVar12;
	bool bVar13;
	longlong lVar14;
	size_t _MaxCount;
	size_t local_cc8;
	int local_cc0;
	Rect2F local_cbc;
	int local_cac;
	int local_ca8;
	Rect2F local_ca4;
	char *local_c94;
	Rect2F local_c90;
	char local_c80 [126];
	char acStack3074 [1026];
	undefined4 local_800 [256];
	char local_400 [1024];
	
	local_ca4.x = (level->objective).ObjectiveImagePosition.x - -60.0;
	local_c90.y = (level->objective).ObjectiveImagePosition.y - -220.0;
	local_ca4.y = (level->objective).ObjectiveImagePosition.y - -60.0;
	local_cbc.x = (level->objective).ObjectiveImagePosition.x - -40.0;
	local_cbc.y = (level->objective).ObjectiveImagePosition.y - -34.0;
	local_c90.width = 320.0;
	local_c90.height = 20.0;
	local_ca4.width = 390.0;
	local_cac = 0;
	local_ca4.height = 180.0;
	local_cbc.width = 422.0;
	local_cbc.height = 21.0;
	local_cc0 = 0;
	iVar6 = 0;
	local_ca8 = 0;
	local_c90.x = local_ca4.x;
	std::sprintf(CHAR_ARRAY_00500bc8,"%s",filename);
	if (PTR_ARRAY_00500e08[0] != NULL) {
		front::TextWindow_Remove(PTR_ARRAY_00500e08[0]);
	}
	if (PTRTextWindow_00500e18 != NULL) {
		front::TextWindow_Remove(PTRTextWindow_00500e18);
	}
	if (PTRTextWindow_00500e1c != NULL) {
		front::TextWindow_Remove(PTRTextWindow_00500e1c);
	}
	if (PTRTextWindow_00500e20 != NULL) {
		front::TextWindow_Remove(PTRTextWindow_00500e20);
	}
	if (PTRTextWindow_00500e24 != NULL) {
		front::TextWindow_Remove(PTRTextWindow_00500e24);
	}
	ppTVar8 = PTR_ARRAY_00500e08;
	do {
		textWnd = front::TextWindow_Create(globs::gameGlobs.bmpMbriefFONT,&local_ca4,0x400);
		*ppTVar8 = textWnd;
		front::TextWindow_EnableCentering(textWnd,0);
		ppTVar8 = ppTVar8 + 1;
	} while (ppTVar8 < &PTRTextWindow_00500e18);
	PTRTextWindow_00500e24 =
			 front::TextWindow_Create(globs::gameGlobs.bmpMbriefFONT2,&local_c90,0x400);
	BOOL_00500e2c = 0;
	PTRFileStream_00500bc4 = lego::file::File_Open(CHAR_ARRAY_00500bc8,"r");
	ppvVar9 = (void **)&DAT_00500c48;
	do {
		if (*ppvVar9 != NULL) {
			std::free(*ppvVar9);
			*ppvVar9 = NULL;
		}
		ppvVar9[0x6c] = NULL;
		ppvVar9[0x68] = NULL;
		ppvVar9[100] = NULL;
		ppvVar9 = ppvVar9 + 1;
	} while (ppvVar9 < &DAT_00500c58);
	if (PTRFileStream_00500bc4 != NULL) {
		lego::file::File_Seek(PTRFileStream_00500bc4,0,0);
		uVar4 = 0xffffffff;
		pcVar3 = param_3;
		do {
			if (uVar4 == 0) break;
			uVar4 -= 1;
			cVar1 = *pcVar3;
			pcVar3 = pcVar3 + 1;
		} while (cVar1 != '\0');
		uVar2 = 0;
		if (~uVar4 != 1) {
			do {
				if (iVar6 == 2) {
					local_c94 = param_3 + uVar2;
					local_ca8 = 1;
					break;
				}
				if (param_3[uVar2] == ':') {
					iVar6 += 1;
				}
				uVar2 += 1;
			} while (uVar2 < ~uVar4 - 1);
		}
		pcVar3 = lego::file::File_GetS(acStack3074 + 2,0x400,PTRFileStream_00500bc4);
		while (pcVar3 != NULL) {
			if (local_ca8 != 0) {
				uVar4 = 0xffffffff;
				pcVar3 = local_c94;
				do {
					pcVar5 = pcVar3;
					if (uVar4 == 0) break;
					uVar4 -= 1;
					pcVar5 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar5;
				} while (cVar1 != '\0');
				uVar4 = ~uVar4;
				puVar10 = (undefined4 *)(pcVar5 + -uVar4);
				puVar11 = local_800;
				for (uVar2 = uVar4 >> 2; uVar2 != 0; uVar2 -= 1) {
					*puVar11 = *puVar10;
					puVar10 = puVar10 + 1;
					puVar11 = puVar11 + 1;
				}
				for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
					*(undefined *)puVar11 = *(undefined *)puVar10;
					puVar10 = (undefined4 *)((int)puVar10 + 1);
					puVar11 = (undefined4 *)((int)puVar11 + 1);
				}
				local_cc8 = std::sprintf(local_400,"[%s]",local_800);
				if (acStack3074[2] == '[') {
					local_cac = 0;
					local_cc0 = 0;
				}
				if (local_cac != 0) {
					uVar4 = 0xffffffff;
					uVar2 = 10;
					pcVar3 = acStack3074 + 2;
					do {
						if (uVar4 == 0) break;
						uVar4 -= 1;
						cVar1 = *pcVar3;
						pcVar3 = pcVar3 + 1;
					} while (cVar1 != '\0');
					_MaxCount = 10;
					iVar7 = 4;
					acStack3074[~uVar4] = '\0';
					iVar6 = std::_strnicmp(acStack3074 + 2,"Objective:",_MaxCount);
					if (iVar6 == 0) {
						iVar7 = 0;
					}
					else {
						uVar2 = 0xb;
						iVar6 = std::_strnicmp(acStack3074 + 2,"Completion:",0xb);
						if (iVar6 == 0) {
							iVar7 = 1;
						}
						else {
							uVar2 = 8;
							iVar6 = std::_strnicmp(acStack3074 + 2,"Failure:",8);
							if (iVar6 == 0) {
								iVar7 = 2;
							}
							else {
								uVar2 = 0xf;
								iVar6 = std::_strnicmp(acStack3074 + 2,"CrystalFailure:",0xf);
								if (iVar6 == 0) {
									iVar7 = 3;
								}
							}
						}
					}
					if (iVar7 != 4) {
						uVar4 = 0xffffffff;
						pcVar3 = acStack3074 + 2;
						do {
							if (uVar4 == 0) break;
							uVar4 -= 1;
							cVar1 = *pcVar3;
							pcVar3 = pcVar3 + 1;
						} while (cVar1 != '\0');
						if (uVar2 < ~uVar4 - 1) {
							do {
								if ((acStack3074[uVar2 + 2] != ' ') && (acStack3074[uVar2 + 2] != '\t')) break;
								uVar4 = 0xffffffff;
								uVar2 += 1;
								pcVar3 = acStack3074 + 2;
								do {
									if (uVar4 == 0) break;
									uVar4 -= 1;
									cVar1 = *pcVar3;
									pcVar3 = pcVar3 + 1;
								} while (cVar1 != '\0');
							} while (uVar2 < ~uVar4 - 1);
						}
						bVar13 = false;
						pcVar3 = acStack3074 + 2;
						cVar1 = acStack3074[2];
						while (cVar1 != '\0') {
							if ((bVar13) && ((*pcVar3 == 'a' || (*pcVar3 == 'n')))) {
								pcVar3[-1] = ' ';
								if (*pcVar3 == 'a') {
									iVar6 = (&DAT_00500df8)[iVar7];
									*pcVar3 = '\a';
									(&DAT_00500df8)[iVar7] = iVar6 + 1;
									bVar13 = false;
								}
								else {
									*pcVar3 = '\n';
									bVar13 = false;
								}
							}
							else {
								bVar13 = *pcVar3 == '\\';
							}
							pcVar5 = pcVar3 + 1;
							pcVar3 = pcVar3 + 1;
							cVar1 = *pcVar5;
						}
						front::TextWindow_PrintF(PTR_ARRAY_00500e08[iVar7],"%s",acStack3074 + uVar2 + 2);
						pcVar3 = std::_strdup(acStack3074 + uVar2 + 2);
						(&DAT_00500c48)[iVar7] = pcVar3;
					}
				}
				if (local_cc0 != 0) {
					uVar4 = 0xffffffff;
					pcVar3 = acStack3074 + 2;
					pcVar5 = acStack3074 + 2;
					do {
						if (uVar4 == 0) break;
						uVar4 -= 1;
						cVar1 = *pcVar5;
						pcVar5 = pcVar5 + 1;
					} while (cVar1 != '\0');
					acStack3074[~uVar4] = '\0';
					front::TextWindow_PrintF(PTRTextWindow_00500e24,"%s",pcVar3);
					local_cc0 = 0;
					BOOL_00500e2c = 1;
				}
				iVar6 = std::_strnicmp(local_400,acStack3074 + 2,local_cc8);
				if (iVar6 == 0) {
					local_cac = 1;
				}
				iVar6 = std::_strnicmp(acStack3074 + 2,"[BEGIN]",7);
				if (iVar6 == 0) {
					local_cc0 = 1;
				}
			}
			pcVar3 = lego::file::File_GetS(acStack3074 + 2,0x400,PTRFileStream_00500bc4);
		}
		lego::file::File_Close(PTRFileStream_00500bc4);
	}
	pcVar3 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MissionBriefingText",0);
	pcVar3 = cfg::CFG_ReadString(root,pcVar3);
	if (pcVar3 != NULL) {
		uVar4 = lego::image::Font_GetStringWidth(globs::gameGlobs.bmpMbriefFONT2,pcVar3);
		local_cbc.x = (local_cbc.width * 0.5 - (float)(uVar4 >> 1)) + local_cbc.x;
		local_cbc.width = (float)(ulonglong)uVar4;
		PTRTextWindow_00500e18 =
				 front::TextWindow_Create(globs::gameGlobs.bmpMbriefFONT2,&local_cbc,0x400);
		if (PTRTextWindow_00500e18 != NULL) {
			iVar6 = -1;
			uVar4 = 0;
			pcVar5 = pcVar3;
			do {
				if (iVar6 == 0) break;
				iVar6 += -1;
				cVar1 = *pcVar5;
				pcVar5 = pcVar5 + 1;
			} while (cVar1 != '\0');
			if (iVar6 != -1) {
				pcVar5 = pcVar3;
				do {
					cVar1 = *pcVar5;
					if (cVar1 == '_') {
						cVar1 = ' ';
					}
					pcVar5[(int)(local_c80 + -(int)pcVar3)] = cVar1;
					uVar4 += 1;
					uVar2 = 0xffffffff;
					pcVar5 = pcVar5 + 1;
					pcVar12 = pcVar3;
					do {
						if (uVar2 == 0) break;
						uVar2 -= 1;
						cVar1 = *pcVar12;
						pcVar12 = pcVar12 + 1;
					} while (cVar1 != '\0');
				} while (uVar4 < ~uVar2);
			}
			front::TextWindow_Clear(PTRTextWindow_00500e18);
			front::TextWindow_PrintF(PTRTextWindow_00500e18,"%s",local_c80);
		}
	}
	pcVar3 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MissionCompletedText",0);
	pcVar3 = cfg::CFG_ReadString(root,pcVar3);
	if (pcVar3 != NULL) {
		uVar4 = lego::image::Font_GetStringWidth(globs::gameGlobs.bmpMbriefFONT2,pcVar3);
		local_cbc.x = (local_cbc.width * 0.5 - (float)(uVar4 >> 1)) + local_cbc.x;
		local_cbc.width = (float)(ulonglong)uVar4;
		PTRTextWindow_00500e1c =
				 front::TextWindow_Create(globs::gameGlobs.bmpMbriefFONT2,&local_cbc,0x400);
		if (PTRTextWindow_00500e1c != NULL) {
			iVar6 = -1;
			uVar4 = 0;
			pcVar5 = pcVar3;
			do {
				if (iVar6 == 0) break;
				iVar6 += -1;
				cVar1 = *pcVar5;
				pcVar5 = pcVar5 + 1;
			} while (cVar1 != '\0');
			if (iVar6 != -1) {
				pcVar5 = pcVar3;
				do {
					cVar1 = *pcVar5;
					if (cVar1 == '_') {
						cVar1 = ' ';
					}
					pcVar5[(int)(local_c80 + -(int)pcVar3)] = cVar1;
					uVar4 += 1;
					uVar2 = 0xffffffff;
					pcVar5 = pcVar5 + 1;
					pcVar12 = pcVar3;
					do {
						if (uVar2 == 0) break;
						uVar2 -= 1;
						cVar1 = *pcVar12;
						pcVar12 = pcVar12 + 1;
					} while (cVar1 != '\0');
				} while (uVar4 < ~uVar2);
			}
			front::TextWindow_Clear(PTRTextWindow_00500e1c);
			front::TextWindow_PrintF(PTRTextWindow_00500e1c,"%s",local_c80);
		}
	}
	pcVar3 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,"Main","MissionFailedText",0);
	pcVar3 = cfg::CFG_ReadString(root,pcVar3);
	if (pcVar3 != NULL) {
		uVar4 = lego::image::Font_GetStringWidth(globs::gameGlobs.bmpMbriefFONT2,pcVar3);
		local_cbc.x = (local_cbc.width * 0.5 - (float)(uVar4 >> 1)) + local_cbc.x;
		local_cbc.width = (float)(ulonglong)uVar4;
		PTRTextWindow_00500e20 =
				 front::TextWindow_Create(globs::gameGlobs.bmpMbriefFONT2,&local_cbc,0x400);
		if (PTRTextWindow_00500e20 != NULL) {
			iVar6 = -1;
			uVar4 = 0;
			pcVar5 = pcVar3;
			do {
				if (iVar6 == 0) break;
				iVar6 += -1;
				cVar1 = *pcVar5;
				pcVar5 = pcVar5 + 1;
			} while (cVar1 != '\0');
			if (iVar6 != -1) {
				pcVar5 = pcVar3;
				do {
					cVar1 = *pcVar5;
					if (cVar1 == '_') {
						cVar1 = ' ';
					}
					pcVar5[(int)(local_c80 + -(int)pcVar3)] = cVar1;
					uVar4 += 1;
					uVar2 = 0xffffffff;
					pcVar5 = pcVar5 + 1;
					pcVar12 = pcVar3;
					do {
						if (uVar2 == 0) break;
						uVar2 -= 1;
						cVar1 = *pcVar12;
						pcVar12 = pcVar12 + 1;
					} while (cVar1 != '\0');
				} while (uVar4 < ~uVar2);
			}
			front::TextWindow_Clear(PTRTextWindow_00500e20);
			front::TextWindow_PrintF(PTRTextWindow_00500e20,"%s",local_c80);
		}
	}
	if (BOOL_00500e2c == 0) {
		local_ca4.height = local_ca4.height + local_c90.height;
		ppTVar8 = PTR_ARRAY_00500e08;
		do {
			lVar14 = __ftol((float10)local_ca4.height);
			uVar4 = (uint)lVar14;
			lVar14 = __ftol((float10)local_ca4.width);
			front::TextWindow_ChangeSize(*ppTVar8,(uint)lVar14,uVar4);
			ppTVar8 = ppTVar8 + 1;
		} while (ppTVar8 < PTR_ARRAY_00500e08 + 3);
	}
	return;
}



void __cdecl
lego::game::Objective_Level_LoadObjectiveInfo
					(CFGProperty *root,char *rootPath,char *levelName,LevelData *level,int screenWidth,
					int screenHeight)
{
	ObjectiveData *pOVar1;
	char *pcVar2;
	BOOL3 BVar3;
	ImageBMP *pIVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	char *pcVar9;
	BOOL BVar10;
	int iVar11;
	ObjectiveData *pOVar12;
	int local_500;
	ObjectType local_4fc;
	Point2I local_4f8;
	char *local_4f0;
	char *local_4ec;
	char *local_4e8;
	char *local_4e4;
	char *local_4e0;
	char *local_4dc;
	char local_400 [1024];
	
	pOVar1 = &level->objective;
	pOVar12 = pOVar1;
	for (iVar11 = 0x15; iVar11 != 0; iVar11 += -1) {
		pOVar12->ObjectiveImage = NULL;
		pOVar12 = (ObjectiveData *)&pOVar12->ObjectiveImagePosition;
	}
	globals::g_ObjectiveFlags = OBJECTIVE_NONE;
	globals::g_ObjectiveSwitch = 1;
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"DontShowObjectiveAdvisor",0);
	BVar3 = cfg::CFG_ReadBool(root,pcVar2);
	if (BVar3 != BOOL3_TRUE) {
		globals::g_ObjectiveFlags |= OBJECTIVE_SHOWADVISOR;
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"DontShowObjectiveAcheiveAdvisor",0);
	BVar3 = cfg::CFG_ReadBool(root,pcVar2);
	if (BVar3 != BOOL3_TRUE) {
		globals::g_ObjectiveFlags |= OBJECTIVE_SHOWACHEIVEADVISOR;
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"DontShowObjectiveFailedAdvisor",0);
	BVar3 = cfg::CFG_ReadBool(root,pcVar2);
	if (BVar3 != BOOL3_TRUE) {
		globals::g_ObjectiveFlags |= OBJECTIVE_SHOWFAILEDADVISOR;
	}
	std::sprintf(local_400,"ObjectiveImage%ix%i",screenWidth,screenHeight);
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,local_400,0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = std::_strdup(pcVar2);
		iVar11 = util::Util_Tokenise(pcVar2,&local_4f0,",");
		if (pOVar1->ObjectiveImage != NULL) {
			lego::image::Image_Remove(pOVar1->ObjectiveImage);
		}
		pIVar4 = lego::image::Image_LoadBMPScaled(local_4f0,0,0);
		pOVar1->ObjectiveImage = pIVar4;
		if (pIVar4 != NULL) {
			lego::image::Image_SetPenZeroTrans(pIVar4);
		}
		iVar5 = std::atoi(local_4ec);
		(level->objective).ObjectiveImagePosition.x = (float)iVar5;
		iVar5 = std::atoi(local_4e8);
		(level->objective).ObjectiveImagePosition.y = (float)iVar5;
		if ((iVar11 == 6) && (pOVar1->ObjectiveImage != NULL)) {
			uVar6 = std::atoi(local_4e4);
			uVar7 = std::atoi(local_4e0);
			uVar8 = std::atoi(local_4dc);
			lego::image::Image_SetupTrans
								(pOVar1->ObjectiveImage,(float)(ulonglong)(uVar6 / 0xff),
								 (float)(ulonglong)(uVar7 / 0xff),(float)(ulonglong)(uVar8 / 0xff),
								 (float)(ulonglong)(uVar6 / 0xff),(float)(ulonglong)(uVar7 / 0xff),
								 (float)(ulonglong)(uVar8 / 0xff));
		}
		std::free(pcVar2);
	}
	std::sprintf(local_400,"ObjectiveAcheivedImage%ix%i",screenWidth,screenHeight);
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,local_400,0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = std::_strdup(pcVar2);
		iVar11 = util::Util_Tokenise(pcVar2,&local_4f0,",");
		pIVar4 = (level->objective).ObjectiveAcheivedImage;
		if (pIVar4 != NULL) {
			lego::image::Image_Remove(pIVar4);
		}
		pIVar4 = lego::image::Image_LoadBMPScaled(local_4f0,0,0);
		(level->objective).ObjectiveAcheivedImage = pIVar4;
		if (pIVar4 != NULL) {
			lego::image::Image_SetPenZeroTrans(pIVar4);
		}
		iVar5 = std::atoi(local_4ec);
		(level->objective).ObjectiveAcheivedImagePosition.x = (float)iVar5;
		iVar5 = std::atoi(local_4e8);
		(level->objective).ObjectiveAcheivedImagePosition.y = (float)iVar5;
		if ((iVar11 == 6) && ((level->objective).ObjectiveAcheivedImage != NULL)) {
			uVar6 = std::atoi(local_4e4);
			uVar7 = std::atoi(local_4e0);
			uVar8 = std::atoi(local_4dc);
			lego::image::Image_SetupTrans
								(pOVar1->ObjectiveImage,(float)(ulonglong)(uVar6 / 0xff),
								 (float)(ulonglong)(uVar7 / 0xff),(float)(ulonglong)(uVar8 / 0xff),
								 (float)(ulonglong)(uVar6 / 0xff),(float)(ulonglong)(uVar7 / 0xff),
								 (float)(ulonglong)(uVar8 / 0xff));
		}
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"ObjectiveAcheivedAVI",0);
	pcVar2 = cfg::CFG_CopyString(root,pcVar2);
	if (pcVar2 != NULL) {
		iVar11 = util::Util_Tokenise(pcVar2,&local_4f0,",");
		pcVar9 = std::_strdup(local_4f0);
		(level->objective).ObjectiveAcheivedAVIFilename = pcVar9;
		if (iVar11 == 3) {
			iVar11 = std::atoi(local_4ec);
			(level->objective).ObjectiveAcheivedAVIPosition.x = (float)iVar11;
			iVar11 = std::atoi(local_4e8);
			(level->objective).ObjectiveAcheivedAVIPosition.y = (float)iVar11;
			std::free(pcVar2);
		}
		else {
			(level->objective).field_30 = 1;
			std::free(pcVar2);
		}
	}
	std::sprintf(local_400,"ObjectiveFailedImage%ix%i",screenWidth,screenHeight);
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,local_400,0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = std::_strdup(pcVar2);
		util::Util_Tokenise(pcVar2,&local_4f0,",");
		pIVar4 = (level->objective).ObjectiveFailedImage;
		if (pIVar4 != NULL) {
			lego::image::Image_Remove(pIVar4);
		}
		pIVar4 = lego::image::Image_LoadBMPScaled(local_4f0,0,0);
		(level->objective).ObjectiveFailedImage = pIVar4;
		if (pIVar4 != NULL) {
			lego::image::Image_SetPenZeroTrans(pIVar4);
		}
		iVar11 = std::atoi(local_4ec);
		(level->objective).ObjectiveFailedImagePosition.x = (float)iVar11;
		iVar11 = std::atoi(local_4e8);
		(level->objective).ObjectiveFailedImagePosition.y = (float)iVar11;
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"CrystalObjective",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"CrystalObjective",0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	}
	iVar11 = std::atoi(pcVar2);
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"OreObjective",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 == NULL) {
		pcVar2 = ____EMPTYSTR__;
	}
	else {
		pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"OreObjective",0);
		pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	}
	iVar5 = std::atoi(pcVar2);
	Objective_Level_SetCryOreObjectives(level,iVar11,iVar5);
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"TimerObjective",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = std::_strdup(pcVar2);
		util::Util_Tokenise(pcVar2,&local_4f0,":");
		iVar11 = std::atoi(local_4f0);
		iVar5 = std::_stricmp(local_4ec,"HitTimeFailObjective");
		Objective_Level_SetTimerObjective(level,(float)iVar11 * 25.0,(uint)(iVar5 == 0));
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"ConstructionObjective",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if ((pcVar2 != NULL) &&
		 (BVar10 = Object_GetObjectByName(pcVar2,&local_4fc,&local_500,NULL), BVar10 != 0)) {
		Objective_Level_SetConstructionObjective(level,local_4fc,local_500);
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"BlockObjective",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != NULL) {
		pcVar2 = std::_strdup(pcVar2);
		util::Util_Tokenise(pcVar2,&local_4f0,",");
		local_4f8.x = std::atoi(local_4f0);
		local_4f8.y = std::atoi(local_4ec);
		Objective_Level_SetBlockObjective(level,&local_4f8);
		std::free(pcVar2);
	}
	pcVar2 = cfg::CFG_JoinPath(rootPath,levelName,"ObjectiveText",0);
	pcVar2 = cfg::CFG_ReadString(root,pcVar2);
	if (pcVar2 != NULL) {
		Objective_Level_LoadObjectiveText(root,rootPath,levelName,level,pcVar2);
	}
	if (globals::g_ObjectiveFlags == OBJECTIVE_NONE) {
		globals::g_ObjectiveFlags = OBJECTIVE_SHOWADVISOR;
	}
	return;
}



void __cdecl
lego::game::Objective_Level_SetCryOreObjectives
					(LevelData *level,int crystalObjective,int oreObjective)
{
	if (crystalObjective != 0) {
		globals::g_ObjectiveFlags |= OBJECTIVE_CRYSTAL;
		(level->objective).CrystalObjective = crystalObjective;
	}
	if (oreObjective != 0) {
		globals::g_ObjectiveFlags |= OBJECTIVE_ORE;
		(level->objective).OreObjective = oreObjective;
	}
	return;
}



void __cdecl lego::game::Objective_Level_SetBlockObjective(LevelData *level,Point2I *position)
{
	globals::g_ObjectiveFlags |= OBJECTIVE_BLOCK;
	(level->objective).BlockObjective.x = position->x;
	(level->objective).BlockObjective.y = position->y;
	return;
}



void __cdecl
lego::game::Objective_Level_SetTimerObjective
					(LevelData *level,float timerObjective,BOOL hitTimeFailObjective)
{
	globals::g_ObjectiveFlags |= OBJECTIVE_TIMER;
	(level->objective).TimerObjective = timerObjective;
	if (hitTimeFailObjective != 0) {
		globals::g_ObjectiveFlags |= OBJECTIVE_SHOWACHEIVEADVISOR;
	}
	return;
}



void __cdecl
lego::game::Objective_Level_SetConstructionObjective(LevelData *level,int objType,int objIndex)
{
	globals::g_ObjectiveFlags |= OBJECTIVE_CONSTRUCTION;
	(level->objective).ConstructionObjectiveObjType = objType;
	(level->objective).ConstructionObjectiveObjIndex = objIndex;
	return;
}



BOOL __cdecl lego::game::Objective_Game_IsLevelComplete(void)
{
	return globals::g_LevelIsComplete;
}



void __cdecl lego::game::Objective_Game_SetEndTeleportEnabled(BOOL endTeleportEnabled)
{
	globals::g_IsEndTeleportEnabled = endTeleportEnabled;
	return;
}



void __cdecl lego::game::Objective_Level_SetCompleteStatus(LevelCompleteStatus status)
{
	bool bVar1;
	bool bVar2;
	LevelData *pLVar3;
	TutorialFlags TVar4;
	char *pcVar5;
	char *pcVar6;
	uint teleportFlags;
	char *pcVar7;
	char local_100 [256];
	
	pLVar3 = GetLevel();
	pcVar7 = NULL;
	bVar1 = true;
	bVar2 = true;
	TVar4 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if (TVar4 == TUTORIAL_NONE) {
		globs::gameGlobs.flags2 |= GAME2_INMENU;
	}
	DAT_00500dd8 = 0;
	DAT_00500ddc = 0;
	DAT_00500de0 = 0;
	DAT_00500de4 = 0;
	if ((globals::g_ObjectiveFlags & (OBJECTIVE_UNK_1|OBJECTIVE_COMPLETE|OBJECTIVE_FAILED)) !=
			OBJECTIVE_NONE) {
		DAT_00500dd8 = 0;
		DAT_00500ddc = 0;
		DAT_00500de0 = 0;
		DAT_00500de4 = 0;
		return;
	}
	if ((globals::g_ObjectiveFlags & OBJECTIVE_CRYSTAL) != OBJECTIVE_NONE) {
		DAT_00500dd8 = 0;
		DAT_00500ddc = 0;
		DAT_00500de0 = 0;
		DAT_00500de4 = 0;
		return;
	}
	while ((((globs::INPUT.mslb != 0 || (globs::INPUT.msrb != 0)) || (globs::INPUT.mslbheld != 0)) ||
				 (globs::INPUT.lClicked != 0))) {
		globs::INPUT.lClicked = 0;
		main::Main_LoopUpdate(1);
	}
	if (status == LEVELSTATUS_NONE) {
		pcVar7 = ____EMPTYSTR__;
		globals::g_ObjectiveFlags |= OBJECTIVE_UNK_1;
		bVar1 = false;
		pLVar3->status = LEVELSTATUS_NONE;
	}
	else {
		if (status == LEVELSTATUS_COMPLETE) {
			globals::g_LevelIsComplete = 1;
			globals::g_ObjectiveFlags |= OBJECTIVE_COMPLETE;
			pLVar3->status = LEVELSTATUS_COMPLETE;
			pcVar7 = "Acheived";
			lego::image::Image_GetScreenshot
								(&globals::g_Save_CaptureBMP,globals::g_Menu_SaveImage_BigSize.width,
								 globals::g_Menu_SaveImage_BigSize.height);
			globals::g_Save_HasCapture = 1;
		}
		else {
			if (status == LEVELSTATUS_FAILED) {
				globals::g_LevelIsComplete = 0;
				globals::g_ObjectiveFlags |= OBJECTIVE_FAILED;
				pcVar7 = "Failed";
				pLVar3->status = LEVELSTATUS_FAILED;
			}
			else {
				if (status != LEVELSTATUS_FAILED_CRYSTALS) goto LAB_00458a9a;
				globals::g_LevelIsComplete = 0;
				globals::g_ObjectiveFlags |= OBJECTIVE_FAILED|OBJECTIVE_CRYSTAL;
				pcVar7 = "FailedCrystals";
				pLVar3->status = LEVELSTATUS_FAILED;
				bVar2 = false;
			}
		}
		FUN_004262f0();
		unk::lego::reward::Reward_UnkLevelImportantPilot_FUN_004604e0();
	}
LAB_00458a9a:
	globals::g_ObjectiveFlags |= OBJECTIVE_UNK_8;
	if (bVar1) {
										// (globals::g_IsEndTeleportEnabled ? 2 : 4)
		teleportFlags = (-(uint)(globals::g_IsEndTeleportEnabled != 0) & 0xfffffffe) + 4;
		unk::Teleporter_Start(TELEPORT_SERVIVE_VEHICLE,2,teleportFlags);
		unk::Teleporter_Start(TELEPORT_SERVIVE_MINIFIGURE,2,teleportFlags);
		unk::Teleporter_Start(TELEPORT_SERVIVE_BUILDING,2,teleportFlags);
		unk::Teleporter_Start(TELEPORT_SERVIVE_ELECTRICFENCE,2,teleportFlags);
		Game_DisableCryOreDrop(TRUE);
		LiveManager_SetFlag20(TRUE);
	}
	if ((pcVar7 != NULL) && (((byte)globs::gameGlobs.flags1 & GAME1_SOUNDON) != 0)) {
		if (bVar2) {
			pcVar6 = pLVar3->levelName;
		}
		else {
			pcVar6 = ____EMPTYSTR__;
		}
		pcVar5 = "_";
		if (!bVar2) {
			pcVar5 = ____EMPTYSTR__;
		}
		std::sprintf(local_100,"Stream_Objective%s%s%s",pcVar7,pcVar5,pcVar6);
		if (globals::g_StreamObjective_Sample != NULL) {
			std::free(globals::g_StreamObjective_Sample);
		}
		globals::g_StreamObjective_Sample = std::_strdup(local_100);
		INT_00500e3c = -1;
		BOOL_00500e44 = 0;
		return;
	}
	globals::g_StreamObjective_Sample = NULL;
	return;
}



void __cdecl lego::game::Objective_FUN_00458ba0(void)
{
	TutorialFlags TVar1;
	
	if ((globals::g_ObjectiveFlags & OBJECTIVE_UNK_1) == OBJECTIVE_NONE) {
		if ((globals::g_ObjectiveFlags & OBJECTIVE_COMPLETE) == OBJECTIVE_NONE) {
			if ((globals::g_ObjectiveFlags & OBJECTIVE_FAILED) != OBJECTIVE_NONE) {
				globals::g_ObjectiveFlags &= ~(OBJECTIVE_FAILED|OBJECTIVE_CRYSTAL);
			}
		}
		else {
			globals::g_ObjectiveFlags &= ~OBJECTIVE_COMPLETE;
		}
	}
	else {
		nerps::funcs::NERPFunc__SetObjectiveSwitch(&globals::g_ObjectiveSwitch);
		globals::g_ObjectiveFlags &= ~OBJECTIVE_UNK_1;
		globals::g_ObjectiveSwitch = 0;
		if ((globs::gameGlobs.flags2 & GAME2_MUSICON) != GAME2_NONE) {
			snd::Music_PlayNext(1);
			globs::gameGlobs.flags2 &= ~GAME2_MUSICON;
		}
	}
	front::Advisor_ClearFlag2();
	if (INT_00500e3c != -1) {
		snd::Sound3D_Stream_Stop(0);
		INT_00500e3c = -1;
	}
	Game_SetPaused(0,0);
	snd::SFX_PlayQueuedInstances_SetFlag8To(0);
	TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if (TVar1 == TUTORIAL_NONE) {
		globs::gameGlobs.flags2 &= ~GAME2_INMENU;
	}
	return;
}



BOOL __cdecl lego::game::Objective_Level_IsObjectiveFinished(void)
{
	if (((byte)globals::g_ObjectiveFlags & 7) == 0) {
		return 0;
	}
	return 1;
}



void __cdecl lego::game::Objective_FUN_00458c80(int param_1,int param_2,uint *param_3)
{
	BOOL BVar1;
	uint uVar2;
	
	uVar2 = 4;
	if ((globals::g_ObjectiveFlags & OBJECTIVE_UNK_1) == OBJECTIVE_NONE) {
		if ((globals::g_ObjectiveFlags & OBJECTIVE_COMPLETE) == OBJECTIVE_NONE) {
			if ((globals::g_ObjectiveFlags & OBJECTIVE_FAILED) != OBJECTIVE_NONE) {
				uVar2 = (uint)((byte)(globals::g_ObjectiveFlags >> 8) & 1 | 2);
			}
		}
		else {
			uVar2 = 1;
		}
	}
	else {
		uVar2 = 0;
	}
	*param_3 = 0;
	if (((param_1 != 0) || (param_2 != 0)) && ((&DAT_00500dd8)[uVar2] == (&DAT_00500df8)[uVar2])) {
		if (((globs::INPUT.msx < 130) ||
				((int)((globs::gameGlobs.BackButton)->width + 130) <= globs::INPUT.msx)) ||
			 ((globs::INPUT.msy < 315 ||
				((int)((globs::gameGlobs.BackButton)->height + 315) <= globs::INPUT.msy)))) {
			if ((globals::g_ObjectiveFlags & OBJECTIVE_UNK_1) == OBJECTIVE_NONE) {
				if ((globals::g_ObjectiveFlags & (OBJECTIVE_COMPLETE|OBJECTIVE_FAILED)) != OBJECTIVE_NONE) {
					BVar1 = unk::Teleporter_FUN_0046a780
														(TELEPORT_SERVIVE_VEHICLE|TELEPORT_SERVIVE_MINIFIGURE|
														 TELEPORT_SERVIVE_BUILDING|TELEPORT_SERVIVE_ELECTRICFENCE);
					if (BVar1 != 0) {
						Objective_FUN_00458ba0();
						BVar1 = FUN_00435870();
						*param_3 = (uint)(BVar1 == 0);
					}
				}
			}
			else {
				Objective_FUN_00458ba0();
				Game_SetMenuNextPosition(NULL);
				Game_SetMenuPreviousPosition(NULL);
				Game_SetPaused(0,0);
				input::Input_SetCursorPos
									((int)globs::mainGlobs.appWidth / 2,(int)globs::mainGlobs.appHeight / 2);
				BVar1 = front::Bubble_GetObjectUIsAlwaysVisible();
				if (BVar1 != 0) {
					front::Bubble_ToggleObjectUIsAlwaysVisible();
				}
			}
		}
	}
	if (uVar2 == 4) goto LAB_00458e8c;
	if ((uint)(&DAT_00500dd8)[uVar2] < (uint)(&DAT_00500df8)[uVar2]) {
		if (((globs::INPUT.msx < 470) ||
				((int)((globs::gameGlobs.NextButton)->width + 470) <= globs::INPUT.msx)) ||
			 ((globs::INPUT.msy < 315 ||
				((int)((globs::gameGlobs.NextButton)->height + 315) <= globs::INPUT.msy)))) {
LAB_00458e07:
			if (param_1 == 0) goto LAB_00458e20;
			if (param_2 != 0) goto LAB_00458e0f;
		}
		else {
			front::ToolTip_AddFlag4(TOOLTIP_MORE);
			if (param_2 == 0) goto LAB_00458e07;
LAB_00458e0f:
			snd::Audio_FUN_00428730(0);
		}
		(&DAT_00500dd8)[uVar2] = (&DAT_00500dd8)[uVar2] + 1;
	}
LAB_00458e20:
	if (((((&DAT_00500dd8)[uVar2] != 0) && (0x81 < globs::INPUT.msx)) &&
			(globs::INPUT.msx < (int)((globs::gameGlobs.BackButton)->width + 0x82))) &&
		 ((0x13a < globs::INPUT.msy &&
			(globs::INPUT.msy < (int)((globs::gameGlobs.BackButton)->height + 0x13b))))) {
		front::ToolTip_AddFlag4(TOOLTIP_BACK);
		if (param_2 != 0) {
			snd::Audio_FUN_00428730(0);
			(&DAT_00500dd8)[uVar2] = (&DAT_00500dd8)[uVar2] + -1;
		}
	}
LAB_00458e8c:
	Objective_Level_IsObjectiveFinished();
	return;
}



void __cdecl
lego::game::Objective_FUN_00458ea0
					(TextWindow *param_1,LevelData *level,float elapsedGame,float elapsedAbs)
{
	ImageBMP *image;
	bool bVar1;
	bool bVar2;
	TextWindow *textWnd;
	BOOL BVar3;
	BOOL BVar4;
	float10 fVar5;
	Point2F *pPVar6;
	int local_10;
	Point2F local_c;
	int local_4;
	
	bVar1 = false;
	bVar2 = false;
	BVar4 = 0;
	local_c.x = 0.0;
	if (PROGRAMMER_MODE_3 < globs::mainGlobs.programmerLevel) {
		Objective_FUN_00458ba0();
	}
	if ((globals::g_ObjectiveFlags & OBJECTIVE_UNK_1) == OBJECTIVE_NONE) {
		if ((globals::g_ObjectiveFlags & OBJECTIVE_COMPLETE) == OBJECTIVE_NONE) {
			if ((globals::g_ObjectiveFlags & OBJECTIVE_FAILED) == OBJECTIVE_NONE) {
				BVar3 = Objective_Level_FUN_00459310(level,&local_4,elapsedGame);
				if (BVar3 == 0) {
					unk::Lego_AddToFloat_00556738__DecFloat_0055673c(elapsedGame);
				}
				else {
					if (local_4 == 0) {
						Objective_Level_SetCompleteStatus(LEVELSTATUS_FAILED);
					}
					else {
						Objective_Level_SetCompleteStatus(LEVELSTATUS_COMPLETE);
					}
				}
			}
			else {
				BVar3 = unk::Teleporter_FUN_0046a780
													(TELEPORT_SERVIVE_VEHICLE|TELEPORT_SERVIVE_MINIFIGURE|
													 TELEPORT_SERVIVE_BUILDING|TELEPORT_SERVIVE_ELECTRICFENCE);
				if (BVar3 != 0) {
					local_10 = 2;
					save::ObjectRecall_Save_CreateNewObjectRecall();
					if ((globals::g_ObjectiveFlags & OBJECTIVE_CRYSTAL) != OBJECTIVE_NONE) {
						local_10 = 3;
					}
					Game_SetPaused(0,1);
					bVar2 = true;
					if ((globals::g_ObjectiveFlags & OBJECTIVE_UNK_8) != OBJECTIVE_NONE) {
						if ((globals::g_ObjectiveFlags & OBJECTIVE_SHOWFAILEDADVISOR) != OBJECTIVE_NONE) {
							front::Advisor_SetCurrentAdvisor(ADVISOR_OBJECTIVE,1);
						}
						globals::g_ObjectiveFlags &= ~OBJECTIVE_UNK_8;
					}
					front::Text_DisplayMessage(TEXT_SPACETOCONTINUE,0,0);
					BVar4 = 1;
					bVar1 = true;
				}
			}
		}
		else {
			BVar3 = unk::Teleporter_FUN_0046a780
												(TELEPORT_SERVIVE_VEHICLE|TELEPORT_SERVIVE_MINIFIGURE|
												 TELEPORT_SERVIVE_BUILDING|TELEPORT_SERVIVE_ELECTRICFENCE);
			if (BVar3 != 0) {
				bVar1 = true;
				Game_SetPaused(0,1);
				save::ObjectRecall_Save_CopyToNewObjectRecallData();
				if ((level->objective).field_34 == 0) {
					if ((level->objective).field_30 == 0) {
						pPVar6 = &(level->objective).ObjectiveAcheivedAVIPosition;
					}
					else {
						pPVar6 = NULL;
					}
					video::VideoPlayer_OpenAndPlay((level->objective).ObjectiveAcheivedAVIFilename,pPVar6);
					(level->objective).field_34 = 1;
				}
				local_10 = 1;
				bVar2 = true;
				front::Text_DisplayMessage(TEXT_SPACETOCONTINUE,0,0);
				if ((globals::g_ObjectiveFlags & OBJECTIVE_UNK_8) != OBJECTIVE_NONE) {
					if ((globals::g_ObjectiveFlags & OBJECTIVE_SHOWACHEIVEADVISOR) != OBJECTIVE_NONE) {
						front::Advisor_SetCurrentAdvisor(ADVISOR_OBJECTIVE,1);
					}
					globals::g_ObjectiveFlags &= ~OBJECTIVE_UNK_8;
				}
				BVar4 = 1;
			}
		}
	}
	else {
		BVar4 = 1;
		Game_SetPaused(0,1);
		local_10 = 0;
		bVar2 = true;
		if ((globals::g_ObjectiveFlags & OBJECTIVE_UNK_8) != OBJECTIVE_NONE) {
			if ((globals::g_ObjectiveFlags & OBJECTIVE_SHOWADVISOR) != OBJECTIVE_NONE) {
				front::Advisor_SetCurrentAdvisor(ADVISOR_OBJECTIVE,1);
			}
			globals::g_ObjectiveFlags &= ~OBJECTIVE_UNK_8;
		}
		local_c.x = 1.401298e-45;
		front::Text_DisplayMessage(TEXT_SPACETOCONTINUE,0,0);
	}
	if ((INT_00500e3c != -1) &&
		 (FLOAT_00500e40 = FLOAT_00500e40 - elapsedAbs,
		 (ushort)((ushort)(FLOAT_00500e40 < 0.0) << 8 | (ushort)(FLOAT_00500e40 == 0.0) << 0xe) != 0)) {
		front::Advisor_ClearFlag2();
		INT_00500e3c = -1;
	}
	if (((bVar1) && ((globs::gameGlobs.flags2 & GAME2_MUSICON) == GAME2_NONE)) &&
		 (((byte)globs::gameGlobs.flags1 & GAME1_MUSICON) != 0)) {
		globs::gameGlobs.flags2 |= GAME2_MUSICON;
		snd::Music_PlayNext(FALSE);
	}
	if ((BOOL_00500e44 != 0) && (globals::g_StreamObjective_Sample != NULL)) {
		BVar3 = snd::SFX_GetType(globals::g_StreamObjective_Sample,(SFXType *)&elapsedAbs);
		if (BVar3 != 0) {
			snd::SFX_GetFlag8();
			snd::SFX_SetFlag8To_AndOptPlayQueuedInstances(0,0);
			INT_00500e3c = snd::SFX_Sample_Random_Play_OrAddToQueue((SFXType)elapsedAbs,0);
			fVar5 = snd::SFX_Sample_Random_GetSamplePlayTime((SFXType)elapsedAbs);
			FLOAT_00500e40 = (float)((fVar5 - (float10)1.5) * (float10)25.0);
			snd::SFX_PlayQueuedInstances_SetFlag8To(1);
		}
		std::free(globals::g_StreamObjective_Sample);
		globals::g_StreamObjective_Sample = NULL;
	}
	BOOL_00500e44 = BVar4;
	if (local_c.x != 0.0) {
		snd::SFX_PlayQueuedInstances_SetFlag8To(1);
	}
	if (bVar2) {
		if ((uint)(&DAT_00500dd8)[local_10] < (uint)(&DAT_00500df8)[local_10]) {
			pPVar6 = &local_c;
			local_c.x = 470.0;
			local_c.y = 315.0;
		}
		else {
			pPVar6 = NULL;
		}
		Game_SetMenuNextPosition(pPVar6);
		if ((&DAT_00500dd8)[local_10] == 0) {
			pPVar6 = NULL;
		}
		else {
			pPVar6 = &local_c;
			local_c.x = 130.0;
			local_c.y = 315.0;
		}
		Game_SetMenuPreviousPosition(pPVar6);
		if ((&DAT_00500dd8)[local_10] != (&DAT_00500de8)[local_10]) {
			front::TextWindow_Clear(PTR_ARRAY_00500e08[local_10]);
			front::TextWindow_PagePrintF
								(PTR_ARRAY_00500e08[local_10],(&DAT_00500dd8)[local_10],"%s",
								 (&DAT_00500c48)[local_10]);
			(&DAT_00500de8)[local_10] = (&DAT_00500dd8)[local_10];
		}
		image = (level->objective).ObjectiveImage;
		if (image != NULL) {
			lego::image::Image_DisplayScaled(image,NULL,&(level->objective).ObjectiveImagePosition,NULL);
		}
		textWnd = PTRTextWindow_00500e1c;
		if ((level->status != LEVELSTATUS_COMPLETE) &&
			 (textWnd = PTRTextWindow_00500e20, level->status != LEVELSTATUS_FAILED)) {
			textWnd = PTRTextWindow_00500e18;
		}
		if (textWnd != NULL) {
			front::TextWindow_Update(textWnd,0,elapsedGame,NULL);
		}
		if (PTR_ARRAY_00500e08[local_10] != NULL) {
			front::TextWindow_Update(PTR_ARRAY_00500e08[local_10],0,elapsedGame,NULL);
		}
		if (PTRTextWindow_00500e24 != NULL) {
			front::TextWindow_Update(PTRTextWindow_00500e24,0,elapsedGame,NULL);
		}
	}
	return;
}



BOOL __cdecl lego::game::Objective_Level_FUN_00459310(LevelData *level,BOOL *out_bool,float elapsed)
{
	float fVar1;
	BOOL BVar2;
	
	if ((globals::g_ObjectiveFlags & OBJECTIVE_SHOWADVISOR) != OBJECTIVE_NONE) {
		return 0;
	}
	*out_bool = 1;
	if ((globals::g_ObjectiveFlags & OBJECTIVE_TIMER) != OBJECTIVE_NONE) {
		fVar1 = (level->objective).TimerObjective - elapsed;
		(level->objective).TimerObjective = fVar1;
		if ((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) != 0) {
			if ((globals::g_ObjectiveFlags & OBJECTIVE_SHOWACHEIVEADVISOR) != OBJECTIVE_NONE) {
				*out_bool = 0;
			}
			return 1;
		}
	}
	if (((globals::g_ObjectiveFlags & OBJECTIVE_CRYSTAL) != OBJECTIVE_NONE) &&
		 ((uint)level->numCrystals < (uint)(level->objective).CrystalObjective)) {
		return 0;
	}
	if (((globals::g_ObjectiveFlags & OBJECTIVE_ORE) != OBJECTIVE_NONE) &&
		 ((uint)level->numOre < (uint)(level->objective).OreObjective)) {
		return 0;
	}
	BVar2 = Search_LiveObjects_SkipIgnoreMes(Objective_FUN_004593c0,(undefined4 *)&level->objective);
	return (uint)(BVar2 != 0);
}



BOOL __cdecl lego::game::Objective_FUN_004593c0(int *param_1,int param_2)
{
	int local_8;
	int local_4;
	
	if (((globals::g_ObjectiveFlags & OBJECTIVE_BLOCK) != OBJECTIVE_NONE) &&
		 ((*param_1 == 2 || (*param_1 == 1)))) {
		LiveObject_GetBlockPos((LiveObject *)param_1,&local_8,&local_4);
		if ((local_8 == *(int *)(param_2 + 0x40)) && (local_4 == *(int *)(param_2 + 0x44))) {
			return 1;
		}
	}
	if ((((globals::g_ObjectiveFlags & OBJECTIVE_CONSTRUCTION) != OBJECTIVE_NONE) &&
			(*(int *)(param_2 + 0x4c) == *param_1)) && (*(int *)(param_2 + 0x50) == param_1[1])) {
		return 1;
	}
	return 0;
}



void __cdecl lego::game::ObjectRecall_LiveObject_UnkRecallMiniFigureName(LiveObject *liveObj)
{
	SaveObjectRecall *pSVar1;
	
	if ((liveObj->objType == OBJECT_MINIFIGURE) &&
		 (((liveObj->flags5_3f0 != LIVEOBJ5_NONE || (liveObj->objLevel != 0)) ||
			(liveObj->customName != NULL)))) {
		if (globals::g_ObjectRecall_COUNT == globals::g_ObjectRecall_TOTAL) {
			globals::g_ObjectRecall_TOTAL += 10;
			globals::g_ObjectRecall_TABLE =
					 (SaveObjectRecall *)
					 std::realloc(globals::g_ObjectRecall_TABLE,globals::g_ObjectRecall_TOTAL * 0x14);
		}
		pSVar1 = globals::g_ObjectRecall_TABLE + globals::g_ObjectRecall_COUNT;
		globals::g_ObjectRecall_COUNT = globals::g_ObjectRecall_COUNT + 1;
		pSVar1->Flags5 = liveObj->flags5_3f0;
		pSVar1->Level = liveObj->objLevel;
		*(undefined4 *)pSVar1->CustomName = 0;
		*(undefined4 *)(pSVar1->CustomName + 4) = 0;
		*(undefined4 *)(pSVar1->CustomName + 8) = 0;
		if (liveObj->customName != NULL) {
			std::_strncpy(pSVar1->CustomName,liveObj->customName,0xb);
		}
	}
	return;
}



BOOL __cdecl lego::game::ObjectRecall_LiveObject_RecallMiniFigure(LiveObject *liveObj)
{
	SaveObjectRecall *pSVar1;
	
	if ((liveObj->objType == OBJECT_MINIFIGURE) && (globals::g_ObjectRecall_COUNT != 0)) {
		globals::g_ObjectRecall_COUNT -= 1;
		pSVar1 = globals::g_ObjectRecall_TABLE + globals::g_ObjectRecall_COUNT;
		liveObj->flags5_3f0 = globals::g_ObjectRecall_TABLE[globals::g_ObjectRecall_COUNT].Flags5;
		LiveObject_SetLevel(liveObj,pSVar1->Level);
		LiveObject_SetCustomName(liveObj,pSVar1->CustomName);
		return TRUE;
	}
	return 0;
}



void __cdecl lego::save::lego::save::ObjectRecall_Save_FreeObjectRecall(void)
{
	globals::g_ObjectRecall_COUNT = 0;
	globals::g_ObjectRecall_TOTAL = 0;
	if (globals::g_ObjectRecall_TABLE != NULL) {
		std::free(globals::g_ObjectRecall_TABLE);
	}
	globals::g_ObjectRecall_TABLE = NULL;
	return;
}



void __cdecl lego::save::ObjectRecall_Save_CopyToNewObjectRecallData(void)
{
	uint uVar1;
	int iVar2;
	SaveObjectRecall *pSVar3;
	SaveObjectRecall *pSVar4;
	
	if ((globals::g_ObjectRecall_COUNT != 0) && (globals::g_ObjectRecall_TABLE != NULL)) {
		if (globals::g_ObjectRecallNew_TABLE != NULL) {
			std::free(globals::g_ObjectRecallNew_TABLE);
		}
		globals::g_ObjectRecallNew_TABLE =
				 (SaveObjectRecall *)std::malloc(globals::g_ObjectRecall_COUNT * 0x14);
		pSVar3 = globals::g_ObjectRecall_TABLE;
		pSVar4 = globals::g_ObjectRecallNew_TABLE;
		for (uVar1 = globals::g_ObjectRecall_COUNT * 5 & 0x3fffffff; uVar1 != 0; uVar1 -= 1) {
			pSVar4->Flags5 = pSVar3->Flags5;
			pSVar3 = (SaveObjectRecall *)&pSVar3->Level;
			pSVar4 = (SaveObjectRecall *)&pSVar4->Level;
		}
		for (iVar2 = 0; iVar2 != 0; iVar2 += -1) {
			*(undefined *)&pSVar4->Flags5 = *(undefined *)&pSVar3->Flags5;
			pSVar3 = (SaveObjectRecall *)((int)&pSVar3->Flags5 + 1);
			pSVar4 = (SaveObjectRecall *)((int)&pSVar4->Flags5 + 1);
		}
		globals::g_ObjectRecallNew_COUNT = globals::g_ObjectRecall_COUNT;
		globals::g_Save_BOOL_00500e64 = 1;
	}
	return;
}



BOOL __cdecl lego::save::ObjectRecall_Save_CreateNewObjectRecall(void)
{
	uint uVar1;
	int iVar2;
	SaveObjectRecall *pSVar3;
	SaveObjectRecall *pSVar4;
	
	lego::save::ObjectRecall_Save_FreeObjectRecall();
	if ((globals::g_ObjectRecallNew_TABLE != NULL) && (globals::g_ObjectRecallNew_COUNT != 0)) {
		globals::g_ObjectRecall_TABLE =
				 (SaveObjectRecall *)std::malloc(globals::g_ObjectRecallNew_COUNT * 0x14);
		pSVar3 = globals::g_ObjectRecallNew_TABLE;
		pSVar4 = globals::g_ObjectRecall_TABLE;
		for (uVar1 = globals::g_ObjectRecallNew_COUNT * 5 & 0x3fffffff; uVar1 != 0; uVar1 -= 1) {
			pSVar4->Flags5 = pSVar3->Flags5;
			pSVar3 = (SaveObjectRecall *)&pSVar3->Level;
			pSVar4 = (SaveObjectRecall *)&pSVar4->Level;
		}
		for (iVar2 = 0; iVar2 != 0; iVar2 += -1) {
			*(undefined *)&pSVar4->Flags5 = *(undefined *)&pSVar3->Flags5;
			pSVar3 = (SaveObjectRecall *)((int)&pSVar3->Flags5 + 1);
			pSVar4 = (SaveObjectRecall *)((int)&pSVar4->Flags5 + 1);
		}
		globals::g_ObjectRecall_COUNT = globals::g_ObjectRecallNew_COUNT;
		globals::g_ObjectRecall_TOTAL = globals::g_ObjectRecallNew_COUNT;
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::save::ObjectRecall_Save_GetBool_00500e64(void)
{
	return globals::g_Save_BOOL_00500e64;
}



BOOL __cdecl lego::save::ObjectRecall_Save_SaveObjectRecallFile(char *filename)
{
	File *f;
	undefined4 local_8;
	uint local_4;
	
	f = lego::file::File_Open(filename,"wb");
	if (f != NULL) {
		local_8 = 1397707346;
		local_4 = globals::g_ObjectRecall_COUNT;
										// Write Header:
										// char[4] "RROS"
										// uint    count
		lego::file::File_Write(&local_8,4,2,f);
										// Write Payload:
										// RROSStruct14[count] data
		lego::file::File_Write(globals::g_ObjectRecall_TABLE,0x14,globals::g_ObjectRecall_COUNT,f);
		lego::file::File_Close(f);
		ObjectRecall_Save_CopyToNewObjectRecallData();
		globals::g_Save_BOOL_00500e64 = 0;
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::save::ObjectRecall_Save_LoadRROSFile(char *filename)
{
	File *f;
	int iVar1;
	BOOL BVar2;
	int local_8;
	uint local_4;
	
	BVar2 = 0;
	lego::save::ObjectRecall_Save_FreeObjectRecall();
	f = lego::file::File_Open(filename,"rb");
	if (f != NULL) {
		iVar1 = lego::file::File_Length(f);
		lego::file::File_Read(&local_8,4,2,f);
		if (local_8 == 1397707346) {
			if (iVar1 - 8U == local_4 * 0x14) {
				globals::g_ObjectRecall_COUNT = local_4;
				globals::g_ObjectRecall_TOTAL = local_4;
				globals::g_ObjectRecall_TABLE = (SaveObjectRecall *)std::malloc(local_4 * 0x14);
				lego::file::File_Read(globals::g_ObjectRecall_TABLE,0x14,globals::g_ObjectRecall_COUNT,f);
				ObjectRecall_Save_CopyToNewObjectRecallData();
				globals::g_Save_BOOL_00500e64 = 0;
			}
		}
		lego::file::File_Close(f);
		BVar2 = 1;
	}
	return BVar2;
}



void __cdecl lego::front::ObjInfo_LoadObjInfo(CFGProperty *root,char *keyBasePath)
{
	ObjInfo_LoadHealthBar(root,keyBasePath);
	ObjInfo_LoadHunger(root,keyBasePath);
	ObjInfo_LoadBubble(root,keyBasePath);
	return;
}



BOOL __cdecl lego::front::ObjInfo_LoadHealthBar(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	int iVar2;
	BOOL BVar3;
	BOOL3 BVar4;
	float *pfVar5;
	ColourRGBF *pCVar6;
	float *pfVar7;
	float *out_b;
	char *local_28;
	char *local_24;
	
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarPosition",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 == NULL) {
		return 0;
	}
	iVar2 = util::Util_Tokenise(pcVar1,&local_28,":");
	if (iVar2 == 2) {
		iVar2 = std::atoi(local_28);
		DAT_00500e6c = (float)iVar2;
		iVar2 = std::atoi(local_24);
		DAT_00500e70 = (float)iVar2;
		std::free(pcVar1);
		pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarWidthHeight",0);
		pcVar1 = cfg::CFG_CopyString(root,pcVar1);
		if (pcVar1 == NULL) {
			return 0;
		}
		iVar2 = util::Util_Tokenise(pcVar1,&local_28,":");
		if (iVar2 == 2) {
			iVar2 = std::atoi(local_28);
			globals::g_HealthBarWidthHeight_width = (float)iVar2;
			iVar2 = std::atoi(local_24);
			globals::g_HealthBarWidthHeight_height = (float)iVar2;
			std::free(pcVar1);
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarBorderSize",0);
			pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			if (pcVar1 == NULL) {
				pcVar1 = ____EMPTYSTR__;
			}
			else {
				pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarBorderSize",0);
				pcVar1 = cfg::CFG_ReadString(root,pcVar1);
			}
			globals::g_HealthBarBorderSize = std::atoi(pcVar1);
			out_b = &globals::g_HealthBarBorderRGB_blue;
			pfVar7 = &globals::g_HealthBarBorderRGB_green;
			pfVar5 = &globals::g_HealthBarBorderRGB_red;
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarBorderRGB",0);
			BVar3 = cfg::CFG_ReadRGBF(root,pcVar1,pfVar5,pfVar7,out_b);
			if (BVar3 == 0) {
				return 0;
			}
			globals::g_HealthBarBorderRGB_red_bright =
					 globals::g_HealthBarBorderRGB_red + globals::g_HealthBarBorderRGB_red * 0.4;
			globals::g_HealthBarBorderRGB_red_dark =
					 globals::g_HealthBarBorderRGB_red - globals::g_HealthBarBorderRGB_red * 0.4;
			globals::g_HealthBarBorderRGB_green_bright =
					 globals::g_HealthBarBorderRGB_green + globals::g_HealthBarBorderRGB_green * 0.4;
			globals::g_HealthBarBorderRGB_green_dark =
					 globals::g_HealthBarBorderRGB_green - globals::g_HealthBarBorderRGB_green * 0.4;
			globals::g_HealthBarBorderRGB_blue_bright =
					 globals::g_HealthBarBorderRGB_blue + globals::g_HealthBarBorderRGB_blue * 0.4;
			globals::g_HealthBarBorderRGB_blue_dark =
					 globals::g_HealthBarBorderRGB_blue - globals::g_HealthBarBorderRGB_blue * 0.4;
			pfVar5 = &globals::g_HealthBarBorderRGB_green;
			do {
				if ((ushort)((ushort)(pfVar5[-3] < 1.0) << 8 | (ushort)(pfVar5[-3] == 1.0) << 0xe) == 0) {
					pfVar5[-3] = 1.0;
				}
				if ((ushort)((ushort)(*pfVar5 < 1.0) << 8 | (ushort)(*pfVar5 == 1.0) << 0xe) == 0) {
					*pfVar5 = 1.0;
				}
				if ((ushort)((ushort)(pfVar5[3] < 1.0) << 8 | (ushort)(pfVar5[3] == 1.0) << 0xe) == 0) {
					pfVar5[3] = 1.0;
				}
				if (pfVar5[-3] < 0.0) {
					pfVar5[-3] = 0.0;
				}
				if (*pfVar5 < 0.0) {
					*pfVar5 = 0.0;
				}
				if (pfVar5[3] < 0.0) {
					pfVar5[3] = 0.0;
				}
				pfVar5 = pfVar5 + 1;
			} while (pfVar5 < &globals::g_HealthBarBorderRGB_blue);
			pfVar7 = &globals::g_HealthBarBackgroundRGB.blue;
			pfVar5 = &globals::g_HealthBarBackgroundRGB.green;
			pCVar6 = &globals::g_HealthBarBackgroundRGB;
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarBackgroundRGB",0);
			BVar3 = cfg::CFG_ReadRGBF(root,pcVar1,(float *)pCVar6,pfVar5,pfVar7);
			if (BVar3 == 0) {
				return 0;
			}
			pfVar7 = &globals::g_HealthBarRGB.blue;
			pfVar5 = &globals::g_HealthBarRGB.green;
			pCVar6 = &globals::g_HealthBarRGB;
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarRGB",0);
			BVar3 = cfg::CFG_ReadRGBF(root,pcVar1,(float *)pCVar6,pfVar5,pfVar7);
			if (BVar3 == 0) {
				return 0;
			}
			pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HealthBarVertical",0);
			BVar4 = cfg::CFG_ReadBool(root,pcVar1);
			if (BVar4 == BOOL3_TRUE) {
				globals::g_ObjInfoFlags__00500e68 |= 8;
			}
			globals::g_ObjInfoFlags__00500e68 = globals::g_ObjInfoFlags__00500e68 | 2;
			return 1;
		}
	}
	std::free(pcVar1);
	return 0;
}



BOOL __cdecl lego::front::ObjInfo_LoadHunger(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	int iVar2;
	char *local_28;
	char *local_24;
	
	ObjInfo_LoadHungerImages(root,keyBasePath);
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","HungerImagesPosition",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		iVar2 = util::Util_Tokenise(pcVar1,&local_28,":");
		if (iVar2 == 2) {
			iVar2 = std::atoi(local_28);
			globals::g_HungerImagesPosition_x = (float)iVar2;
			iVar2 = std::atoi(local_24);
			globals::g_HungerImagesPosition_y = (float)iVar2;
			std::free(pcVar1);
			globals::g_ObjInfoFlags__00500e68 = globals::g_ObjInfoFlags__00500e68 | 1;
			return 1;
		}
		std::free(pcVar1);
	}
	return 0;
}



void __cdecl lego::front::ObjInfo_LoadHungerImages(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	ImageBMP *image;
	ImageBMP **ppIVar2;
	int iVar3;
	uint width;
	uint height;
	char local_40 [64];
	
	iVar3 = 0;
	ppIVar2 = (ImageBMP **)&DAT_00500ec4;
	do {
		std::sprintf(local_40,"HungerImage%i",iVar3);
		height = 0;
		width = 0;
		pcVar1 = cfg::CFG_JoinPath(rootPath,"ObjInfo","HungerImages",local_40,0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		image = lego::image::Image_LoadBMPScaled(pcVar1,width,height);
		*ppIVar2 = image;
		if (image != NULL) {
			lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
		}
		ppIVar2 = ppIVar2 + 1;
		iVar3 += 1;
	} while (ppIVar2 < &globals::g_BubbleImagesPosition_x);
	return;
}



BOOL __cdecl lego::front::ObjInfo_LoadBubble(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	int iVar2;
	char *local_28;
	char *local_24;
	
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"ObjInfo","BubbleImagesPosition",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		iVar2 = util::Util_Tokenise(pcVar1,&local_28,":");
		if (iVar2 == 2) {
			iVar2 = std::atoi(local_28);
			globals::g_BubbleImagesPosition_x = (float)iVar2;
			iVar2 = std::atoi(local_24);
			globals::g_BubbleImagesPosition_y = (float)iVar2;
			std::free(pcVar1);
			globals::g_ObjInfoFlags__00500e68 = globals::g_ObjInfoFlags__00500e68 | 0x10;
			return 1;
		}
		std::free(pcVar1);
	}
	return 0;
}



void __cdecl
lego::front::ObjInfo_LiveObject_DrawObjInfoHealthBar_FUN_00459dc0
					(LiveObject *liveObj,int param_2,int param_3)
{
	undefined *puVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	BOOL BVar6;
	Point2F *pPVar7;
	float fVar8;
	Point2F *pPVar9;
	float *pfVar10;
	uint uVar11;
	float *pfVar12;
	uint count;
	Point2F *pPVar13;
	float *pfVar14;
	float fVar15;
	float fVar16;
	Rect2F local_17c;
	float *local_16c;
	uint local_168;
	Point2F *local_164;
	uint local_160;
	float local_15c;
	undefined4 uStack344;
	float local_154;
	float local_150;
	float local_14c;
	uint local_148;
	undefined4 uStack324;
	Point2F local_140;
	float local_138 [18];
	Point2F local_f0;
	float afStack232 [18];
	Point2F local_a0;
	float local_98 [18];
	Point2F local_50;
	float local_48 [18];
	
	count = 0;
	local_168 = 0;
	if ((((byte)globals::g_ObjInfoFlags__00500e68 & 2) != 0) &&
		 (BVar6 = DamageFont_LiveObject_CheckCanShowDamage_Unk(liveObj), BVar6 != 0)) {
		uStack344 = 0;
		local_15c = (float)(globals::g_HealthBarBorderSize * 2);
		fVar8 = globals::g_HealthBarWidthHeight_width + (float)(ulonglong)(uint)local_15c;
		fVar15 = globals::g_HealthBarWidthHeight_height + (float)(ulonglong)(uint)local_15c;
		local_17c.x = (float)param_2 + DAT_00500e6c;
		local_17c.y = (float)param_3 + DAT_00500e70;
		local_160 = 0;
		uVar11 = local_160;
		if (globals::g_HealthBarBorderSize != 0) {
			local_164 = &local_f0;
			local_16c = &local_f0.y;
			local_150 = (local_17c.y + fVar15) - 2.0;
			local_15c = (local_17c.x + fVar8) - 2.0;
			local_14c = (local_17c.x + fVar8) - 1.0;
			local_154 = (local_17c.y + fVar15) - 1.0;
			pPVar9 = &local_50;
			pfVar14 = &local_50.y;
			pfVar12 = &local_140.y;
			pPVar13 = &local_140;
			pfVar10 = &local_a0.y;
			pPVar7 = &local_a0;
			do {
				local_160 = uVar11;
				uStack324 = 0;
				fVar4 = (float)(ulonglong)local_160;
				fVar2 = local_17c.x + fVar4;
				fVar3 = local_17c.y + fVar4;
				fVar5 = local_154 - fVar4;
				pPVar7->x = fVar2;
				*pfVar10 = fVar3;
				fVar16 = pPVar7->x;
				pPVar9->x = fVar2;
				*pfVar12 = local_150 - fVar4;
				*pfVar14 = fVar5;
				pPVar7[1].x = local_14c - fVar4;
				pPVar13->x = fVar16;
				local_164->x = local_15c - fVar4;
				pfVar10[2] = fVar3;
				*local_16c = fVar5;
				pPVar9[1].x = local_14c - fVar4;
				pPVar13[1].x = fVar2 - -1.0;
				pfVar14[2] = fVar5;
				fVar16 = pPVar9[1].x;
				pfVar12[2] = fVar3;
				pPVar7 = pPVar7 + 2;
				pfVar10 = pfVar10 + 4;
				pPVar13 = pPVar13 + 2;
				pfVar14 = pfVar14 + 4;
				local_16c[2] = fVar3 - -1.0;
				pPVar9 = pPVar9 + 2;
				local_164[1].x = fVar16;
				count = local_168 + 2;
				local_164 = local_164 + 2;
				pfVar12 = pfVar12 + 4;
				local_16c = local_16c + 4;
				uVar11 = local_160 + 1;
				local_168 = count;
				local_148 = local_160;
			} while (uVar11 < globals::g_HealthBarBorderSize);
		}
		local_160 = uVar11;
		puVar1 = (undefined *)liveObj->health;
		if (0.0 <= (float)puVar1) {
			if ((ushort)((ushort)((float)puVar1 < 100.0) << 8 | (ushort)((float)puVar1 == 100.0) << 0xe)
					== 0) {
				puVar1 = &DAT_42c80000;
			}
		}
		else {
			puVar1 = NULL;
		}
		if (((byte)globals::g_ObjInfoFlags__00500e68 & 8) == 0) {
			local_17c.width = (float)puVar1 * fVar8 * 0.01;
			local_17c.height = fVar15;
			draw::Draw_RectListEx
								(&local_17c,1,globals::g_HealthBarRGB.red,globals::g_HealthBarRGB.green,
								 globals::g_HealthBarRGB.blue,DRAWEFFECT_NONE);
			local_17c.x = local_17c.x + local_17c.width;
			local_17c.width = fVar8 - local_17c.width;
			fVar8 = globals::g_HealthBarBackgroundRGB.red;
			fVar15 = globals::g_HealthBarBackgroundRGB.green;
			fVar16 = globals::g_HealthBarBackgroundRGB.blue;
		}
		else {
			local_17c.height = (1.0 - (float)puVar1 * 0.01) * fVar15;
			local_17c.width = fVar8;
			draw::Draw_RectListEx
								(&local_17c,1,globals::g_HealthBarBackgroundRGB.red,
								 globals::g_HealthBarBackgroundRGB.green,globals::g_HealthBarBackgroundRGB.blue,
								 DRAWEFFECT_NONE);
			local_17c.y = local_17c.y + local_17c.height;
			local_17c.height = fVar15 - local_17c.height;
			fVar8 = globals::g_HealthBarRGB.red;
			fVar15 = globals::g_HealthBarRGB.green;
			fVar16 = globals::g_HealthBarRGB.blue;
		}
		draw::Draw_RectListEx(&local_17c,1,fVar8,fVar15,fVar16,DRAWEFFECT_NONE);
		draw::Draw_LineListEx
							(&local_a0,&local_140,count,globals::g_HealthBarBorderRGB_red_bright,
							 globals::g_HealthBarBorderRGB_green_bright,globals::g_HealthBarBorderRGB_blue_bright,
							 DRAWEFFECT_NONE);
		draw::Draw_LineListEx
							(&local_50,&local_f0,count,globals::g_HealthBarBorderRGB_red_dark,
							 globals::g_HealthBarBorderRGB_green_dark,globals::g_HealthBarBorderRGB_blue_dark,
							 DRAWEFFECT_NONE);
	}
	return;
}



void __cdecl lego::front::ObjInfo_FUN_0045a210(int param_1,int param_2,int param_3)
{
	uint uVar1;
	longlong lVar2;
	Point2F local_8;
	
	if (((byte)globals::g_ObjInfoFlags__00500e68 & 1) != 0) {
		lVar2 = __ftol((float10)*(float *)(param_1 + 0x344) * (float10)0.01 * (float10)5.0);
		uVar1 = (uint)lVar2;
		if (4 < uVar1) {
			uVar1 = 4;
		}
		if ((ImageBMP *)(&DAT_00500ec4)[uVar1] != NULL) {
			local_8.x = (float)param_2 + globals::g_HungerImagesPosition_x;
			local_8.y = (float)param_3 + globals::g_HungerImagesPosition_y;
			lego::image::Image_DisplayScaled((ImageBMP *)(&DAT_00500ec4)[uVar1],NULL,&local_8,NULL);
		}
	}
	return;
}



void __cdecl lego::front::ObjInfo_FUN_0045a290(ImageBMP *image,int param_2,int param_3)
{
	Point2F local_8;
	
	if (((byte)globals::g_ObjInfoFlags__00500e68 & 0x10) != 0) {
		local_8.x = (float)param_2 + globals::g_BubbleImagesPosition_x;
		local_8.y = (float)param_3 + globals::g_BubbleImagesPosition_y;
		lego::image::Image_DisplayScaled(image,NULL,&local_8,NULL);
	}
	return;
}



void __cdecl lego::front::Panel_InitPanelButtons(void)
{
	globals::g_PanelTypes_TABLE[0] = "Panel_Radar";
	globals::g_PanelTypes_TABLE[1] = "Panel_RadarFill";
	globals::g_PanelTypes_TABLE[2] = "Panel_RadarOverlay";
	globals::g_PanelTypes_TABLE[3] = "Panel_Messages";
	globals::g_PanelTypes_TABLE[4] = "Panel_MessagesSide";
	globals::g_PanelTypes_TABLE[5] = "Panel_CrystalSideBar";
	globals::g_PanelTypes_TABLE[6] = "Panel_TopPanel";
	globals::g_PanelTypes_TABLE[7] = "Panel_Information";
	globals::g_PanelTypes_TABLE[8] = "Panel_PriorityList";
	globals::g_PanelTypes_TABLE[9] = "Panel_CameraControl";
	globals::g_PanelTypes_TABLE[10] = "Panel_InfoDock";
	globals::g_PanelTypes_TABLE[11] = "Panel_Encyclopedia";
	globals::g_PanelButtons_Radar_TABLE[0] = "PanelButton_Radar_Toggle";
	globals::g_PanelButtons_Radar_TABLE[1] = "PanelButton_Radar_TaggedObjectView";
	globals::g_PanelButtons_Radar_TABLE[2] = "PanelButton_Radar_ZoomIn";
	globals::g_PanelButtons_Radar_TABLE[3] = "PanelButton_Radar_ZoomOut";
	globals::g_PanelButtons_Radar_TABLE[4] = "PanelButton_Radar_MapView";
	globals::g_PanelButtons_CrystalSideBar_TABLE[0] = "PanelButton_CrystalSideBar_Ore";
	globals::g_PanelButtons_CrystalSideBar_TABLE[1] = "PanelButton_CrystalSideBar_Crystals";
	globals::g_PanelButtons_TopPanel_TABLE[0] = "PanelButton_TopPanel_Options";
	globals::g_PanelButtons_TopPanel_TABLE[1] = "PanelButton_TopPanel_Priorities";
	globals::g_PanelButtons_TopPanel_TABLE[2] = "PanelButton_TopPanel_CallToArms";
	globals::g_PanelButtons_Information_TABLE[0] = "PanelButton_Information_Toggle";
	globals::g_PanelButtons_Information_TABLE[1] = "PanelButton_Information_Function";
	globals::g_PanelButtons_PriorityList_TABLE[0] = "PanelButton_PriorityList_Disable1";
	globals::g_PanelButtons_PriorityList_TABLE[1] = "PanelButton_PriorityList_Disable2";
	globals::g_PanelButtons_PriorityList_TABLE[2] = "PanelButton_PriorityList_Disable3";
	globals::g_PanelButtons_PriorityList_TABLE[3] = "PanelButton_PriorityList_Disable4";
	globals::g_PanelButtons_PriorityList_TABLE[4] = "PanelButton_PriorityList_Disable5";
	globals::g_PanelButtons_PriorityList_TABLE[5] = "PanelButton_PriorityList_Disable6";
	globals::g_PanelButtons_PriorityList_TABLE[6] = "PanelButton_PriorityList_Disable7";
	globals::g_PanelButtons_PriorityList_TABLE[7] = "PanelButton_PriorityList_Disable8";
	globals::g_PanelButtons_PriorityList_TABLE[8] = "PanelButton_PriorityList_Disable9";
	globals::g_PanelButtons_PriorityList_TABLE[9] = "PanelButton_PriorityList_UpOne1";
	globals::g_PanelButtons_PriorityList_TABLE[10] = "PanelButton_PriorityList_UpOne2";
	globals::g_PanelButtons_PriorityList_TABLE[11] = "PanelButton_PriorityList_UpOne3";
	globals::g_PanelButtons_PriorityList_TABLE[12] = "PanelButton_PriorityList_UpOne4";
	globals::g_PanelButtons_PriorityList_TABLE[13] = "PanelButton_PriorityList_UpOne5";
	globals::g_PanelButtons_PriorityList_TABLE[14] = "PanelButton_PriorityList_UpOne6";
	globals::g_PanelButtons_PriorityList_TABLE[15] = "PanelButton_PriorityList_UpOne7";
	globals::g_PanelButtons_PriorityList_TABLE[16] = "PanelButton_PriorityList_UpOne8";
	globals::g_PanelButtons_PriorityList_TABLE[17] = "PanelButton_PriorityList_Close";
	globals::g_PanelButtons_PriorityList_TABLE[18] = "PanelButton_PriorityList_Reset";
	globals::g_PanelButtons_CameraControl_TABLE[0] = "PanelButton_CameraControl_ZoomIn";
	globals::g_PanelButtons_CameraControl_TABLE[1] = "PanelButton_CameraControl_ZoomOut";
	globals::g_PanelButtons_CameraControl_TABLE[2] = "PanelButton_CameraControl_CycleBuildings";
	globals::g_PanelButtons_CameraControl_TABLE[3] = "PanelButton_CameraControl_Rotate";
	globals::g_PanelButtons_InfoDock_TABLE[0] = "PanelButton_InfoDock_Goto";
	globals::g_PanelButtons_InfoDock_TABLE[1] = "PanelButton_InfoDock_Close";
	globals::g_PanelButtons_Encyclopedia_TABLE[0] = "PanelButton_Encyclopedia_Close";
	UINT_005017d0 = 0xc;
	UINT_005017d4 = 0x18;
	return;
}



void __cdecl lego::front::Panel_LoadInterfaceButtons_ScrollInfo(void)
{
	main::Main_LoadInterfaceButtons_ScrollInfo__internal();
	Panel_InitUnkRenderSurfacePtr_FUN_0045bb10();
	Panel_FUN_0045ae70(PANEL_TOPPANEL,1,1);
	Panel_FUN_0045ae70(PANEL_TOPPANEL,2,1);
	return;
}



void __cdecl lego::front::Panel_FUN_0045a530(void)
{
	char *pcVar1;
	char **ppcVar2;
	char *pcVar3;
	int iVar4;
	
	ppcVar2 = (char **)&globals::g_PanelDatas_TABLE[0].flags;
	do {
		ppcVar2[-5] = ppcVar2[-7];
		pcVar3 = NULL;
		*ppcVar2 = (char *)((uint)*ppcVar2 & 0xfffffff5 | 4);
		ppcVar2[-4] = ppcVar2[-6];
		if (ppcVar2[-1] != NULL) {
			iVar4 = 0;
			do {
				pcVar1 = ppcVar2[-2];
				*(undefined4 *)(pcVar1 + iVar4 + 0x24) = 0;
				pcVar1 = pcVar1 + iVar4;
				iVar4 += 0x2c;
				pcVar3 = pcVar3 + 1;
				*(uint *)(pcVar1 + 0x28) = *(uint *)(pcVar1 + 0x28) & 0xffffffb7;
			} while (pcVar3 < ppcVar2[-1]);
		}
		ppcVar2 = ppcVar2 + 0xc;
	} while (ppcVar2 < globals::g_PanelButtons_Radar_TABLE + 0xb);
	globals::g_Panel_FLOAT_00501820 = 0.0;
	return;
}



void __cdecl lego::front::Panel_LoadImage(char *filename,PanelType panelType,uint flags)
{
	uint uVar1;
	ImageBMP *image;
	BOOL BVar2;
	
	globals::g_PanelDatas_TABLE[panelType].field_28 = 0;
	globals::g_PanelDatas_TABLE[panelType].flags = flags;
	image = lego::image::Image_LoadBMPScaled(filename,0,0);
	globals::g_PanelDatas_TABLE[panelType].imageOrFlic = image;
	if (image != NULL) {
		globals::g_PanelDatas_TABLE[panelType].isFlic = 0;
		lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
		globals::g_PanelDatas_TABLE[panelType].flags = globals::g_PanelDatas_TABLE[panelType].flags | 1;
		return;
	}
	BVar2 = lego::image::Flic_Setup
										(filename,(ImageFlic **)(globals::g_PanelDatas_TABLE + panelType),
										 FLICMEMORY|FLICLOOPINGON);
	if (BVar2 != 0) {
		uVar1 = globals::g_PanelDatas_TABLE[panelType].flags;
		globals::g_PanelDatas_TABLE[panelType].isFlic = 1;
		globals::g_PanelDatas_TABLE[panelType].flags = uVar1 | 1;
	}
	return;
}



BOOL __cdecl lego::front::Panel_GetPanelType(char *panelName,PanelType *out_panelType)
{
	int iVar1;
	char **ppcVar2;
	int index;
	
	index = 0;
	ppcVar2 = globals::g_PanelTypes_TABLE;
	do {
		iVar1 = std::_stricmp(panelName,(char *)*(ImageBMP **)ppcVar2);
		if (iVar1 == 0) {
			*out_panelType = index;
			return TRUE;
		}
		ppcVar2 = (char **)((int)ppcVar2 + 4);
										// index++
		index += PANEL_RADARFILL;
										// index < PANEL__COUNT (12)
	} while (ppcVar2 < globals::g_PanelDatas_TABLE);
	return 0;
}



BOOL __cdecl lego::front::Panel_FUN_0045a670(PanelType panelType,int param_2,int param_3)
{
	PanelType PVar1;
	BOOL BVar2;
	uint y;
	PanelData *pPVar3;
	longlong lVar4;
	PanelType *out_colour;
	
	PVar1 = panelType;
	pPVar3 = globals::g_PanelDatas_TABLE + panelType;
	if (globals::g_PanelDatas_TABLE[panelType].isFlic == 0) {
		out_colour = &panelType;
		lVar4 = __ftol((float10)globals::g_PanelDatas_TABLE[panelType].xyOutIn.y);
		y = param_3 - (int)lVar4;
		lVar4 = __ftol((float10)globals::g_PanelDatas_TABLE[PVar1].xyOutIn.x);
		BVar2 = lego::image::Image_GetPixel(pPVar3->imageOrFlic,param_2 - (int)lVar4,y,out_colour);
		if (BVar2 != 0) {
			return (uint)(panelType == PANEL_RADAR);
		}
	}
	return TRUE;
}



BOOL __cdecl lego::front::Panel_GetButtonType(PanelType panelType,char *name,uint *out_buttonType)
{
	int iVar1;
	char **ppcVar2;
	uint uVar3;
	
	ppcVar2 = globals::g_PanelButtons_Radar_TABLE + panelType * 0x18;
	uVar3 = 0;
	do {
		if (*ppcVar2 != NULL) {
			iVar1 = std::_stricmp(name,*ppcVar2);
			if (iVar1 == 0) {
				*out_buttonType = uVar3;
				return TRUE;
			}
		}
		uVar3 += 1;
		ppcVar2 = ppcVar2 + 1;
	} while (uVar3 < 0x18);
	return 0;
}



void __cdecl
lego::front::Panel_FUN_0045a720
					(uint param_1,ImageFont *font,int param_3,int param_4,int param_5,char *format,...)
{
	uint uVar1;
	int y;
	float10 fVar2;
	longlong lVar3;
	va_list argptr;
	
	uVar1 = param_1;
	if (param_5 != 0) {
		lego::image::Font_VGetStringInfo(font,&param_1,NULL,format,&stack0x0000001c);
		param_3 -= param_1 >> 1;
	}
	argptr = &stack0x0000001c;
	fVar2 = __floor((double)((float)param_4 + globals::g_PanelDatas_TABLE[uVar1].xyOutIn.y));
	lVar3 = __ftol(fVar2);
	y = (int)lVar3;
	fVar2 = __floor((double)((float)param_3 + globals::g_PanelDatas_TABLE[uVar1].xyOutIn.x));
	lVar3 = __ftol(fVar2);
	lego::image::Font_VPrintF(font,(int)lVar3,y,format,argptr);
	return;
}



PanelTextWindow * __cdecl
lego::front::Panel_TextWindow_Create(PanelType panelType,ImageFont *font,Rect2F *rect,uint size)
{
	PanelTextWindow *panelWnd;
	TextWindow *textWnd;
	longlong lVar1;
	Rect2F area;
	
	area.x = 0.0;
	area.y = 0.0;
	area.width = rect->width;
	area.height = rect->height;
	panelWnd = (PanelTextWindow *)std::malloc(0x10);
	if (panelWnd != NULL) {
		panelWnd->textWindow = NULL;
		(panelWnd->position).x = 0.0;
		(panelWnd->position).y = 0.0;
		panelWnd->panel = NULL;
		textWnd = TextWindow_Create(font,&area,size);
		panelWnd->textWindow = textWnd;
		lVar1 = __ftol((float10)rect->x);
		(panelWnd->position).x = (float)lVar1;
		lVar1 = __ftol((float10)rect->y);
		(panelWnd->position).y = (float)lVar1;
		panelWnd->panel = globals::g_PanelDatas_TABLE + panelType;
	}
	return panelWnd;
}



void __cdecl lego::front::Panel_TextWindow_PrintF(PanelTextWindow *panelWnd,char *msg,...)
{
	TextWindow_VPrintF(panelWnd->textWindow,0,msg,&stack0x0000000c);
	return;
}



void __cdecl
lego::front::Panel_TextWindow_Update(PanelTextWindow *textWnd,uint posFromEnd,float elapsed)
{
	int ypos;
	float10 fVar1;
	longlong lVar2;
	
	fVar1 = __floor((double)((float)(int)(textWnd->position).y + (textWnd->panel->xyOutIn).y));
	lVar2 = __ftol(fVar1);
	ypos = (int)lVar2;
	fVar1 = __floor((double)((float)(int)(textWnd->position).x + (textWnd->panel->xyOutIn).x));
	lVar2 = __ftol(fVar1);
	TextWindow_ChangePosition(textWnd->textWindow,(int)lVar2,ypos);
	TextWindow_Update(textWnd->textWindow,posFromEnd,elapsed,NULL);
	return;
}



void __cdecl lego::front::Panel_TextWindow_Clear(PanelTextWindow *panelWnd)
{
	TextWindow_Clear(panelWnd->textWindow);
	return;
}



void __cdecl
lego::front::Panel_TextWindow_GetInfo
					(PanelTextWindow *panelWnd,uint *out_linesCount,uint *out_linesCapacity)
{
	TextWindow_GetInfo(panelWnd->textWindow,out_linesCount,out_linesCapacity);
	return;
}



void __cdecl lego::front::Panel_SetArea(PanelType panelType,int xOut,int yOut,int xIn,int yIn)
{
	byte bVar1;
	
	globals::g_PanelDatas_TABLE[panelType].xyOut.x = (float)xOut;
	globals::g_PanelDatas_TABLE[panelType].xyIn.x = (float)xIn;
	bVar1 = *(byte *)&globals::g_PanelDatas_TABLE[panelType].flags;
	globals::g_PanelDatas_TABLE[panelType].xyOut.y = (float)yOut;
	globals::g_PanelDatas_TABLE[panelType].xyIn.y = (float)yIn;
	globals::g_PanelDatas_TABLE[panelType].field_20 = 0;
	if ((bVar1 & 2) != 0) {
		globals::g_PanelDatas_TABLE[panelType].xyOutIn.x = (float)xOut;
		globals::g_PanelDatas_TABLE[panelType].xyOutIn.y = (float)yOut;
		return;
	}
	globals::g_PanelDatas_TABLE[panelType].xyOutIn.x = (float)xIn;
	globals::g_PanelDatas_TABLE[panelType].xyOutIn.y = (float)yIn;
	return;
}



void __cdecl lego::front::Panel_SetXYField3(PanelType panelType,float x,float y)
{
	globals::g_PanelDatas_TABLE[panelType].xyOutIn.x = x;
	globals::g_PanelDatas_TABLE[panelType].xyOutIn.y = y;
	return;
}



void __cdecl lego::front::Panel_GetXYField3(PanelType panelType,float *out_x,float *out_y)
{
	*out_x = globals::g_PanelDatas_TABLE[panelType].xyOutIn.x;
	*out_y = globals::g_PanelDatas_TABLE[panelType].xyOutIn.y;
	return;
}



void __cdecl lego::front::Panel_FUN_0045a9f0(PanelType panelType,float elapsedAbs)
{
	float fVar1;
	uint uVar2;
	PanelData *pPVar3;
	float10 fVar4;
	longlong lVar5;
	ulonglong uVar6;
	float local_28;
	float local_24;
	Point2F local_20;
	uint local_18;
	undefined4 uStack20;
	Rect2F local_10;
	
	pPVar3 = globals::g_PanelDatas_TABLE + panelType;
	if ((*(byte *)&globals::g_PanelDatas_TABLE[panelType].flags & 4) == 0) {
		local_28 = globals::g_PanelDatas_TABLE[panelType].xyOut.x;
		local_24 = globals::g_PanelDatas_TABLE[panelType].xyOut.y;
	}
	else {
		local_28 = globals::g_PanelDatas_TABLE[panelType].xyIn.x;
		local_24 = globals::g_PanelDatas_TABLE[panelType].xyIn.y;
	}
	if (elapsedAbs != 0.0) {
		fVar1 = ABS(globals::g_PanelDatas_TABLE[panelType].xyOutIn.x - local_28);
		if ((ushort)((ushort)(fVar1 < 1.0) << 8 | (ushort)(fVar1 == 1.0) << 0xe) == 0) {
			globals::g_PanelDatas_TABLE[panelType].xyOutIn.x =
					 ((4.0 / elapsedAbs) * globals::g_PanelDatas_TABLE[panelType].xyOutIn.x + local_28) /
					 (4.0 / elapsedAbs - -1.0);
		}
		else {
			globals::g_PanelDatas_TABLE[panelType].xyOutIn.x = local_28;
		}
		fVar1 = ABS(globals::g_PanelDatas_TABLE[panelType].xyOutIn.y - local_24);
		if ((ushort)((ushort)(fVar1 < 1.0) << 8 | (ushort)(fVar1 == 1.0) << 0xe) == 0) {
			globals::g_PanelDatas_TABLE[panelType].xyOutIn.y =
					 ((4.0 / elapsedAbs) * globals::g_PanelDatas_TABLE[panelType].xyOutIn.y + local_24) /
					 (4.0 / elapsedAbs - -1.0);
		}
		else {
			globals::g_PanelDatas_TABLE[panelType].xyOutIn.y = local_24;
		}
	}
	fVar4 = __floor((double)globals::g_PanelDatas_TABLE[panelType].xyOutIn.x);
	local_20.x = (float)fVar4;
	local_10.x = (float)fVar4;
	fVar4 = __floor((double)globals::g_PanelDatas_TABLE[panelType].xyOutIn.y);
	local_20.y = (float)fVar4;
	local_10.y = (float)fVar4;
	if (globals::g_PanelDatas_TABLE[panelType].isFlic == 0) {
		lego::image::Image_DisplayScaled(pPVar3->imageOrFlic,NULL,&local_20,NULL);
	}
	else {
		if (globals::g_PanelDatas_TABLE[panelType].isFlic == 1) {
			local_18 = res::AnimClone_IsLws((AnimClone *)pPVar3->imageOrFlic);
			uStack20 = 0;
			local_10.width = (float)(ulonglong)local_18;
			local_18 = lego::image::Flic_GetHeight((ImageFlic *)pPVar3->imageOrFlic);
			uStack20 = 0;
			local_10.height = (float)(ulonglong)local_18;
			uVar6 = CONCAT44(1,~globs::gameGlobs.flags1 >> 0x14) & 0xffffffff00000001;
			lego::image::Flic_Animate
								((ImageFlic *)pPVar3->imageOrFlic,&local_10,(BOOL)uVar6,(BOOL)(uVar6 >> 0x20));
		}
	}
	if (panelType == PANEL_CAMERACONTROL) {
		if ((FLAGS_00501860 & 0x10) != 0) {
			lego::image::Image_DisplayScaled
								(globals::g_PanelRotationControl_UpImage_bmp,NULL,
								 &g_PanelRotationControl_UpImage_position,NULL);
			FLAGS_00501860 &= 0xffffffef;
		}
		if ((FLAGS_00501860 & 0x20) != 0) {
			lego::image::Image_DisplayScaled
								(globals::g_PanelRotationControl_DownImage_bmp,NULL,
								 &g_PanelRotationControl_DownImage_position,NULL);
			FLAGS_00501860 &= 0xffffffdf;
		}
		if ((FLAGS_00501860 & 0x40) != 0) {
			lego::image::Image_DisplayScaled
								(globals::g_PanelRotationControl_LeftImage_bmp,NULL,
								 &g_PanelRotationControl_LeftImage_position,NULL);
			FLAGS_00501860 &= 0xffffffbf;
		}
		if ((FLAGS_00501860 & 0x80) != 0) {
			lego::image::Image_DisplayScaled
								(globals::g_PanelRotationControl_RightImage_bmp,NULL,
								 &g_PanelRotationControl_RightImage_position,NULL);
			FLAGS_00501860 &= 0xffffff7f;
		}
	}
	lVar5 = __ftol((float10)globals::g_PanelDatas_TABLE[panelType].xyOutIn.x - (float10)local_28);
	uVar2 = (int)(uint)lVar5 >> 0x1f;
	if (((int)(((uint)lVar5 ^ uVar2) - uVar2) < 2) &&
		 (lVar5 = __ftol((float10)globals::g_PanelDatas_TABLE[panelType].xyOutIn.y - (float10)local_24),
		 uVar2 = (int)(uint)lVar5 >> 0x1f, (int)(((uint)lVar5 ^ uVar2) - uVar2) < 2)) {
		globals::g_PanelDatas_TABLE[panelType].flags =
				 globals::g_PanelDatas_TABLE[panelType].flags & 0xfffffff7;
	}
	Panel_FUN_0045ac80(panelType);
	return;
}



void __cdecl lego::front::Panel_FUN_0045ac80(PanelType panelType)
{
	float fVar1;
	ImageBMP *image;
	BOOL BVar2;
	uint uVar3;
	int iVar4;
	uint uVar5;
	float *pfVar6;
	Point2F local_8;
	
	uVar5 = 0;
	if (globals::g_PanelDatas_TABLE[panelType].field_28 != 0) {
		iVar4 = 0;
		do {
			pfVar6 = (float *)(globals::g_PanelDatas_TABLE[panelType].field_24 + iVar4);
			local_8.x = *pfVar6 + globals::g_PanelDatas_TABLE[panelType].xyOutIn.x;
			local_8.y = pfVar6[1] + globals::g_PanelDatas_TABLE[panelType].xyOutIn.y;
			fVar1 = pfVar6[10];
			if (((uint)fVar1 & 0x10) == 0) {
				uVar3 = (uint)fVar1 & 0x40;
				if ((((uint)fVar1 & 8) == 0) && (((uint)fVar1 & 2) != 0)) {
					if (uVar3 == 0) {
LAB_0045ad31:
						image = (ImageBMP *)pfVar6[4];
					}
					else {
						BVar2 = Interface_GetBool_004ded1c();
						if (BVar2 == 0) goto LAB_0045ad5a;
						image = (ImageBMP *)pfVar6[4];
					}
				}
				else {
					if ((((uint)fVar1 & 4) == 0) && (((uint)fVar1 & 8) == 0)) {
						if ((uVar3 == 0) || (BVar2 = Interface_GetBool_004ded1c(), BVar2 == 0)) {
							image = (ImageBMP *)pfVar6[6];
						}
						else {
							image = (ImageBMP *)pfVar6[4];
						}
					}
					else {
						if ((uVar3 != 0) && (BVar2 = Interface_GetBool_004ded1c(), BVar2 != 0))
						goto LAB_0045ad31;
						image = (ImageBMP *)pfVar6[5];
					}
				}
				if (image != NULL) {
					lego::image::Image_DisplayScaled(image,NULL,&local_8,NULL);
				}
			}
LAB_0045ad5a:
			uVar5 += 1;
			iVar4 += 0x2c;
		} while (uVar5 < (uint)globals::g_PanelDatas_TABLE[panelType].field_28);
	}
	return;
}



void __cdecl lego::front::Panel_FUN_0045ad80(PanelType panelType,int buttonType,BOOL param_3)
{
	uint *puVar1;
	uint uVar2;
	
	puVar1 = (uint *)(globals::g_PanelDatas_TABLE[panelType].field_24 + 0x28 + buttonType * 0x2c);
	uVar2 = *(uint *)(globals::g_PanelDatas_TABLE[panelType].field_24 + 0x28 + buttonType * 0x2c);
	if (param_3 != 0) {
		*puVar1 = uVar2 | 0x10;
		return;
	}
	*puVar1 = uVar2 & 0xffffffef;
	return;
}



void __cdecl lego::front::Panel_FUN_0045adc0(PanelType panelType)
{
	uint uVar1;
	
	uVar1 = globals::g_PanelDatas_TABLE[panelType].flags;
	if ((uVar1 & 2) != 0) {
		globals::g_PanelDatas_TABLE[panelType].flags = uVar1 & 0xfffffffd | 0xc;
		return;
	}
	globals::g_PanelDatas_TABLE[panelType].flags = uVar1 & 0xfffffffb | 10;
	return;
}



BOOL __cdecl lego::front::Panel_IsFlags_4_AndNot8(PanelType panelType)
{
	if (((globals::g_PanelDatas_TABLE[panelType].flags & 4) != 0) &&
		 ((globals::g_PanelDatas_TABLE[panelType].flags & 8) == 0)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::front::Panel_FUN_0045ae20(PanelType panelType)
{
	if (((globals::g_PanelDatas_TABLE[panelType].flags & 2) != 0) &&
		 ((globals::g_PanelDatas_TABLE[panelType].flags & 8) == 0)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::front::Panel_IsFlag8(PanelType panelType)
{
	return globals::g_PanelDatas_TABLE[panelType].flags & 8;
}



void __cdecl lego::front::Panel_FUN_0045ae70(PanelType panelType,int param_2,BOOL setFlag20)
{
	int iVar1;
	
	iVar1 = globals::g_PanelDatas_TABLE[panelType].field_24 + param_2 * 0x2c;
	if (setFlag20 != 0) {
		*(uint *)(iVar1 + 0x28) = *(uint *)(iVar1 + 0x28) | 0x20;
		return;
	}
	*(uint *)(iVar1 + 0x28) = *(uint *)(iVar1 + 0x28) & 0xffffffdf;
	return;
}



void __cdecl lego::front::Panel_FUN_0045aeb0(PanelType panelType,int param_2,int param_3)
{
	int iVar1;
	uint uVar2;
	
	iVar1 = globals::g_PanelDatas_TABLE[panelType].field_24 + param_2 * 0x2c;
	uVar2 = *(uint *)(iVar1 + 0x28);
	if ((uVar2 & 0x20) != 0) {
		if (param_3 != 0) {
			*(uint *)(iVar1 + 0x28) = uVar2 | 8;
			return;
		}
		*(uint *)(iVar1 + 0x28) = uVar2 & 0xfffffff3;
	}
	return;
}



void __cdecl
lego::front::Panel_FUN_0045aef0
					(PanelType panelType,int param_2,int param_3,int param_4,int *param_5,int param_6,
					int param_7,int param_8)
{
	float *pfVar1;
	float fVar2;
	float fVar3;
	char *pcVar4;
	void *pvVar5;
	ImageBMP *pIVar6;
	float *pfVar7;
	char **ppcVar8;
	float *pfVar9;
	
	if (param_2 != 0) {
		pvVar5 = std::malloc(param_2 * 0x2c);
		globals::g_PanelDatas_TABLE[panelType].field_24 = pvVar5;
		globals::g_PanelDatas_TABLE[panelType].field_28 = param_2;
		if (param_2 != 0) {
			pfVar9 = (float *)(param_4 + 4);
			ppcVar8 = (char **)param_5;
			do {
				pfVar7 = (float *)((param_8 - (int)param_5) + (int)ppcVar8);
				pfVar1 = (float *)(globals::g_PanelDatas_TABLE[panelType].field_24 +
													*(int *)((int)pfVar7 + (param_3 - param_8)) * 0x2c);
				*pfVar1 = pfVar9[-1];
				pfVar1[1] = *pfVar9;
				pfVar1[2] = pfVar9[1] + pfVar9[-1];
				fVar2 = pfVar9[2];
				fVar3 = *pfVar9;
				pfVar1[6] = 0.0;
				pfVar1[4] = 0.0;
				pfVar1[5] = 0.0;
				pfVar1[3] = fVar2 + fVar3;
				pfVar1[8] = *pfVar7;
				if ((param_5 != NULL) && (*ppcVar8 != NULL)) {
					pIVar6 = lego::image::Image_LoadBMPScaled(*ppcVar8,0,0);
					pfVar1[6] = (float)pIVar6;
					if (pIVar6 != NULL) {
						lego::image::Image_SetupTrans(pIVar6,0.0,0.0,0.0,0.0,0.0,0.0);
					}
				}
				if ((param_6 != 0) &&
					 (pcVar4 = *(char **)((param_6 - (int)param_5) + (int)ppcVar8), pcVar4 != NULL)) {
					pIVar6 = lego::image::Image_LoadBMPScaled(pcVar4,0,0);
					pfVar1[4] = (float)pIVar6;
					if (pIVar6 != NULL) {
						lego::image::Image_SetupTrans(pIVar6,0.0,0.0,0.0,0.0,0.0,0.0);
					}
				}
				if ((param_7 != 0) &&
					 (pcVar4 = *(char **)((param_7 - (int)param_5) + (int)ppcVar8), pcVar4 != NULL)) {
					pIVar6 = lego::image::Image_LoadBMPScaled(pcVar4,0,0);
					pfVar1[5] = (float)pIVar6;
					if (pIVar6 != NULL) {
						lego::image::Image_SetupTrans(pIVar6,0.0,0.0,0.0,0.0,0.0,0.0);
					}
				}
				pfVar9 = pfVar9 + 4;
				ppcVar8 = ppcVar8 + 1;
				param_2 += -1;
				pfVar1[10] = 0.0;
			} while (param_2 != 0);
		}
	}
	return;
}



BOOL __cdecl
FUN_0045b070(float elapsedAbs,uint mouseX,uint mouseY,BOOL leftButton,BOOL param_5,int param_6)
{
	int *piVar1;
	uint uVar2;
	BOOL BVar3;
	BOOL BVar4;
	TutorialFlags TVar5;
	LevelData *pLVar6;
	BOOL BVar7;
	
	BVar3 = param_5;
	BVar7 = leftButton;
	uVar2 = mouseY;
	if (leftButton == 0) {
		FLAGS_00501860 &= 0xfffffffe;
	}
	BVar4 = FUN_0045b5d0((uint *)&param_6,(uint *)&leftButton,mouseX,mouseY,leftButton,param_5,
											 &param_5,(undefined4 *)param_6);
	if (BVar4 == 0) {
		BVar7 = FUN_00463b60((int *)&mouseY,mouseX,uVar2,BVar7,BVar3);
		if (BVar7 == 0) {
			return 0;
		}
		if (mouseY == 0) {
			lego::front::Info_FUN_0041a1c0();
		}
		if (param_5 == 0) {
			return 1;
		}
	}
	else {
		lego::globs::gameGlobs.flags1 |= GAME1_UNK_200;
		if ((param_6 == 0xc) || (leftButton == 0x18)) {
			return param_6;
		}
		TVar5 = lego::nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
		if (param_5 != 0) {
			piVar1 = (int *)(lego::globals::g_PanelDatas_TABLE[param_6].field_24 + 0x24 +
											leftButton * 0x2c);
			*piVar1 = *piVar1 + 1;
			if (((TVar5 & TUTORIAL_UNK_10) != TUTORIAL_NONE) && (param_6 == 0)) {
				lego::snd::Audio_FUN_00428730(1);
				return TRUE;
			}
			if ((((TVar5 & TUTORIAL_UNK_20) != TUTORIAL_NONE) && (param_6 == 6)) && (leftButton == 0)) {
				lego::front::Panel_FUN_0045aeb0(PANEL_TOPPANEL,0,0);
				lego::snd::Audio_FUN_00428730(1);
				return TRUE;
			}
			if ((((TVar5 & TUTORIAL_UNK_40) != TUTORIAL_NONE) && (param_6 == 6)) && (leftButton == 1)) {
				lego::front::Panel_FUN_0045aeb0(PANEL_TOPPANEL,1,0);
				lego::snd::Audio_FUN_00428730(1);
				return TRUE;
			}
			if ((((TVar5 & TUTORIAL_UNK_80) != TUTORIAL_NONE) && (param_6 == 6)) && (leftButton == 2)) {
				lego::front::Panel_FUN_0045aeb0(PANEL_TOPPANEL,2,0);
				lego::snd::Audio_FUN_00428730(1);
				return TRUE;
			}
			if ((((TVar5 & TUTORIAL_UNK_400) != TUTORIAL_NONE) && (param_6 == 9)) && (leftButton == 2)) {
				lego::snd::Audio_FUN_00428730(1);
				return TRUE;
			}
			if (((TVar5 & TUTORIAL_UNK_1000) != TUTORIAL_NONE) && (param_6 == 9)) {
				if ((leftButton == 0) || (leftButton == 1)) goto LAB_0045b57a;
				if (leftButton == 3) {
					lego::snd::Audio_FUN_00428730(1);
					return TRUE;
				}
			}
		}
		if (BVar7 != 0) {
			if (param_6 == 0) {
				if ((lego::globs::gameGlobs.flags1 & GAME1_RADAR_MAPVIEW) != GAME1_NONE) {
					if (leftButton == 2) {
						if (lego::globs::gameGlobs.tvTiltOrZoom_334 < 20.0) {
							lego::globs::gameGlobs.tvTiltOrZoom_334 =
									 elapsedAbs + lego::globs::gameGlobs.tvTiltOrZoom_334;
						}
						if ((ushort)((ushort)(lego::globs::gameGlobs.tvTiltOrZoom_334 < 20.0) << 8 |
												(ushort)(lego::globs::gameGlobs.tvTiltOrZoom_334 == 20.0) << 0xe) == 0) {
							lego::globs::gameGlobs.tvTiltOrZoom_334 = 20.0;
						}
					}
					else {
						if (leftButton == 3) {
							if ((ushort)((ushort)(lego::globs::gameGlobs.tvTiltOrZoom_334 < 10.0) << 8 |
													(ushort)(lego::globs::gameGlobs.tvTiltOrZoom_334 == 10.0) << 0xe) == 0) {
								lego::globs::gameGlobs.tvTiltOrZoom_334 =
										 lego::globs::gameGlobs.tvTiltOrZoom_334 - elapsedAbs;
							}
							if (lego::globs::gameGlobs.tvTiltOrZoom_334 < 10.0) {
								lego::globs::gameGlobs.tvTiltOrZoom_334 = 10.0;
							}
						}
					}
				}
			}
			else {
				if (((param_6 == 9) &&
						(TVar5 = lego::nerps::funcs::NERPFunc__GetTutorialFlags(NULL),
						(TVar5 & TUTORIAL_UNK_1000) == TUTORIAL_NONE)) &&
					 (lego::view::Camera_MoveGame_Cam24_Float90(leftButton,elapsedAbs), leftButton == 3)) {
					lego::front::Panel_RotationControl_FUN_0045bf90(mouseX,uVar2,elapsedAbs);
				}
			}
		}
		if (param_5 == 0) {
			return 1;
		}
		pLVar6 = lego::game::GetLevel();
		if (pLVar6->status == LEVELSTATUS_NONE) {
			lego::snd::Audio_FUN_00428730(0);
			if (false) {
				return 1;
			}
			switch(param_6) {
			case 0:
				if (leftButton == 0) {
					lego::front::Panel_FUN_0045adc0(PANEL_RADAR);
					lego::front::Panel_FUN_0045adc0(PANEL_RADARFILL);
					return TRUE;
				}
				if (leftButton != 1) {
					if (leftButton != 4) {
						return 1;
					}
					lego::globs::gameGlobs.flags1 =
							 lego::globs::gameGlobs.flags1 & ~GAME1_RADAR_TRACKOBJECTVIEW | GAME1_RADAR_MAPVIEW;
					lego::front::Panel_FUN_0045ad80(PANEL_RADAR,2,FALSE);
					lego::front::Panel_FUN_0045ad80(PANEL_RADAR,3,FALSE);
					return TRUE;
				}
				lego::globs::gameGlobs.flags1 =
						 lego::globs::gameGlobs.flags1 &
						 (GAME1_HIGHFOGCOLOURRGB|GAME1_UNK_20000|GAME1_UNK_40000|GAME1_DYNAMICPM|
							GAME1_CAMERADISABLED|GAME1_UNK_200000|GAME1_ONLYBUILDONPATHS|GAME1_ALWAYSROCKFALL|
							GAME1_DEBUG_NONERPS|GAME1_PAUSED|GAME1_STREAMNERPSSPEACH|GAME1_UNK_8000000|
							GAME1_LASERTRACKER|GAME1_UNK_20000000|GAME1_DEBUG_NOCLIP_FPS|GAME1_UNK_80000000) |
						 (ushort)((ushort)lego::globs::gameGlobs.flags1 | 0x2000) & ~GAME1_RADAR_MAPVIEW;
				lego::front::Panel_FUN_0045ad80(PANEL_RADAR,2,TRUE);
				lego::front::Panel_FUN_0045ad80(PANEL_RADAR,3,TRUE);
				return TRUE;
			default:
				return 1;
			case 6:
				goto switchD_0045b34e_caseD_6;
			case 8:
				if (leftButton == 0x12) {
					FUN_0045d1c0();
					return TRUE;
				}
				if (leftButton == 0x11) {
					if (((byte)lego::globals::g_PanelDatas_TABLE[8].flags & 4) != 0) {
						return 1;
					}
					lego::front::Interface_BackToMain();
					return TRUE;
				}
				lego::front::PriorityList_FUN_0045b8e0(leftButton);
				return TRUE;
			case 9:
				if (leftButton != 2) {
					return 1;
				}
				lego::game::LiveManager_CheckMouseIntersections_FUN_0044c810();
				return TRUE;
			case 10:
				if (leftButton == 1) {
					lego::front::Info_FUN_00419d90();
					return TRUE;
				}
				if (leftButton != 0) {
					return 1;
				}
				lego::front::Info_UpdateInstance_FUN_00419d10(0);
				lego::front::Info_FUN_00419cd0();
				return TRUE;
			case 0xb:
				if (leftButton != 0) {
					return 1;
				}
				if (((byte)lego::globals::g_PanelDatas_TABLE[11].flags & 4) != 0) {
					return 1;
				}
				lego::front::Interface_BackToMain();
				return TRUE;
			}
		}
	}
LAB_0045b57a:
	lego::snd::Audio_FUN_00428730(1);
	return TRUE;
switchD_0045b34e_caseD_6:
	if ((lego::globs::gameGlobs.viewMode != VIEW_FIRSTPERSON) && (leftButton == 1)) {
		if (((byte)lego::globals::g_PanelDatas_TABLE[8].flags & 4) == 0) {
			lego::front::Interface_BackToMain();
		}
		else {
			lego::game::Message_AddMessageAction(MESSAGE_CLEARSELECT,0,0,NULL);
			lego::front::Interface_OpenMenu_FUN_0041b200(0x16,NULL);
		}
	}
	if (leftButton == 0) {
		lego::game::Game_SetPaused(1,0);
		lego::globs::gameGlobs.flags2 = lego::globs::gameGlobs.flags2 ^ GAME2_INOPTIONSMENU;
		return TRUE;
	}
	if (leftButton != 2) {
		return 1;
	}
	if ((lego::globs::gameGlobs.flags2 & GAME2_CALLTOARMS) != GAME2_NONE) {
		lego::game::Game_SetCallToArmsOn(FALSE);
		return TRUE;
	}
	lego::game::Game_SetCallToArmsOn(TRUE);
	return TRUE;
}



BOOL __cdecl
FUN_0045b5d0(uint *param_1,uint *param_2,int mouseX,int mouseY,int param_5,int param_6,
						undefined4 *param_7,undefined4 *param_8)
{
	Rect2F *area;
	BOOL BVar1;
	int iVar2;
	BOOL BVar3;
	uint uVar4;
	float fVar5;
	PanelType local_4;
	
	BVar3 = 0;
	if (param_7 != NULL) {
		*param_7 = 0;
	}
	*param_2 = 0x18;
	*param_1 = 0xc;
	if (((byte)FLAGS_00501860 & 1) != 0) {
		*param_1 = 9;
		*param_2 = 3;
		return TRUE;
	}
	local_4 = PANEL_RADAR;
	do {
		if ((*(byte *)&lego::globals::g_PanelDatas_TABLE[local_4].flags & 1) != 0) {
			if ((((param_8 != NULL) && (local_4 != PANEL_RADARFILL)) && (local_4 != PANEL_RADAROVERLAY))
				 && (BVar1 = lego::front::Panel_FUN_0045a670(local_4,mouseX,mouseY), BVar1 == 0)) {
				*param_8 = 1;
			}
			uVar4 = 0;
			if (lego::globals::g_PanelDatas_TABLE[local_4].field_28 != 0) {
				do {
					area = (Rect2F *)(lego::globals::g_PanelDatas_TABLE[local_4].field_24 + uVar4 * 0x2c);
					if (BVar3 == 0) {
						if ((local_4 == PANEL_CAMERACONTROL) && (uVar4 == 3)) {
							iVar2 = FUN_0045bb60(mouseX,mouseY,
																	 lego::globals::g_PanelRotationControl_CenterPosition.x,
																	 lego::globals::g_PanelRotationControl_CenterPosition.y,
																	 lego::globals::g_PanelRotationControl_Radius);
						}
						else {
							iVar2 = lego::front::Panel_TestMouseInsideOutInArea_FUN_0045b850
																(lego::globals::g_PanelDatas_TABLE + local_4,area,mouseX,mouseY);
						}
						if ((false) || (iVar2 == 0)) goto LAB_0045b7eb;
						*param_1 = local_4;
						if (param_5 == 0) {
							fVar5 = area[2].x;
							if (((fVar5 == 3.643376e-44) && (lego::globs::liveGlobs.countBuildingsOnly_c438 == 0))
								 && (((byte)lego::globs::liveGlobs.flags & 0x40) != 0)) {
								fVar5 = 4.904545e-44;
							}
							lego::front::ToolTip_AddFlag4((ToolTipType)fVar5);
							if (UINT_005017d4 != 0x18) {
								if ((local_4 == UINT_005017d0) && (uVar4 == UINT_005017d4)) {
									*param_2 = uVar4;
									fVar5 = area[2].width;
									if (((uint)fVar5 & 0x20) != 0) {
										if (((uint)fVar5 & 8) == 0) {
											fVar5 = (float)((uint)fVar5 | 8);
										}
										else {
											fVar5 = (float)((uint)fVar5 & 0xfffffff7);
										}
										area[2].width = fVar5;
									}
									if (param_7 != NULL) {
										*param_7 = 1;
									}
									area[2].width = (float)((uint)area[2].width & 0xfffffffb | 2);
								}
								goto LAB_0045b7e4;
							}
							BVar3 = 1;
							*param_2 = uVar4;
							area[2].width = (float)((uint)area[2].width & 0xfffffffb | 2);
						}
						else {
							if (UINT_005017d4 == 0x18) {
								if (param_6 == 0) {
									UINT_005017d0 = local_4;
									BVar3 = 1;
									UINT_005017d4 = uVar4;
									*param_2 = uVar4;
									area[2].width = (float)((uint)area[2].width & 0xfffffffd | 4);
								}
								else {
LAB_0045b7e4:
									BVar3 = 1;
								}
							}
							else {
								if ((local_4 != UINT_005017d0) || (uVar4 != UINT_005017d4)) goto LAB_0045b7e4;
								BVar3 = 1;
								*param_2 = uVar4;
								area[2].width = (float)((uint)area[2].width & 0xfffffffd | 4);
							}
						}
					}
					else {
LAB_0045b7eb:
						fVar5 = area[2].width;
						area[2].width = (float)((uint)fVar5 & 0xfffffffd);
						if (((uint)fVar5 & 8) == 0) {
							fVar5 = (float)((uint)fVar5 & 0xfffffff9);
						}
						else {
							fVar5 = (float)((uint)fVar5 & 0xfffffffd | 4);
						}
						area[2].width = fVar5;
					}
					uVar4 += 1;
				} while (uVar4 < (uint)lego::globals::g_PanelDatas_TABLE[local_4].field_28);
			}
		}
		local_4 += PANEL_RADARFILL;
		if (PANEL_ENCYCLOPEDIA < local_4) {
			if (param_5 == 0) {
				UINT_005017d0 = 0xc;
				UINT_005017d4 = 0x18;
			}
			return BVar3;
		}
	} while( true );
}



BOOL __cdecl
lego::front::Panel_TestMouseInsideOutInArea_FUN_0045b850
					(PanelData *panel,Rect2F *area,int mouseX,int mouseY)
{
	float fVar1;
	float fVar2;
	longlong lVar3;
	longlong lVar4;
	
	lVar3 = __ftol((float10)(panel->xyOutIn).x);
	lVar4 = __ftol((float10)(panel->xyOutIn).y);
	fVar1 = (float)(mouseX - (int)lVar3);
	if ((((area->x <= fVar1) && (fVar2 = (float)(mouseY - (int)lVar4), fVar2 < area->height)) &&
			(area->y <= fVar2)) && (fVar1 < area->width)) {
		return TRUE;
	}
	return 0;
}



void __cdecl lego::unk::Lego_UnsetFlag6_00501860(void)
{
	FLAGS_00501860 = FLAGS_00501860 & 0xfffffff9;
	return;
}



void __cdecl lego::front::PriorityList_FUN_0045b8e0(undefined4 param_1)
{
	switch(param_1) {
	case 0:
		PriorityList_FUN_0045d7b0(0);
		return;
	case 1:
		PriorityList_FUN_0045d7b0(1);
		return;
	case 2:
		PriorityList_FUN_0045d7b0(2);
		return;
	case 3:
		PriorityList_FUN_0045d7b0(3);
		return;
	case 4:
		PriorityList_FUN_0045d7b0(4);
		return;
	case 5:
		PriorityList_FUN_0045d7b0(5);
		return;
	case 6:
		PriorityList_FUN_0045d7b0(6);
		return;
	case 7:
		PriorityList_FUN_0045d7b0(7);
		return;
	case 8:
		PriorityList_FUN_0045d7b0(8);
		return;
	case 9:
		PriorityList_FUN_0045d730(1);
		return;
	case 10:
		PriorityList_FUN_0045d730(2);
		return;
	case 0xb:
		PriorityList_FUN_0045d730(3);
		return;
	case 0xc:
		PriorityList_FUN_0045d730(4);
		return;
	case 0xd:
		PriorityList_FUN_0045d730(5);
		return;
	case 0xe:
		PriorityList_FUN_0045d730(6);
		return;
	case 0xf:
		PriorityList_FUN_0045d730(7);
		return;
	case 0x10:
		PriorityList_FUN_0045d730(8);
	}
	return;
}



void __cdecl lego::main::Main_LoadInterfaceButtons_ScrollInfo__internal(void)
{
	Rect2F rect;
	
	unk::Lego_LoadScrollInfoPanel__00463970("Interface\\InfoPanel\\scrollInfo.bmp",0,0,7,0);
	FUN_004639f0(0,8,0x21);
	rect.x = 0.0;
	rect.y = 0.0;
	rect.width = 18.0;
	rect.height = 11.0;
	FUN_00463a30(0,1,&rect,NULL,NULL);
	rect.x = 0.0;
	rect.y = 11.0;
	rect.width = 18.0;
	rect.height = 11.0;
	FUN_00463a30(0,0,&rect,NULL,NULL);
	rect.x = 0.0;
	rect.y = 0.0;
	rect.width = 0.0;
	rect.height = 0.0;
	FUN_00463ad0(0,(float *)&rect,1,0,"Interface\\Buttons\\scrollInfoSld.bmp");
	rect.x = 40.0;
	rect.y = 12.0;
	rect.width = 180.0;
	rect.height = 43.0;
	PTR_005017d8 = front::Panel_TextWindow_Create
													 (PANEL_INFORMATION,globs::gameGlobs.bmpFONT5_HI,&rect,0x100);
	return;
}



void __cdecl lego::front::Panel_InitUnkRenderSurfacePtr_FUN_0045bb10(void)
{
	Rect2F rect;
	
	rect.x = 21.0;
	rect.y = 11.0;
	rect.width = 221.0;
	rect.height = 227.0;
	PTR_005017dc = Panel_TextWindow_Create
													 (PANEL_ENCYCLOPEDIA,globs::gameGlobs.bmpFONT5_HI,&rect,0x400);
	return;
}



BOOL __cdecl FUN_0045bb60(int mouseX,int mouseY,int param_3,int param_4,int param_5)
{
	float fVar1;
	
	fVar1 = SQRT((float)(param_4 - mouseY) * (float)(param_4 - mouseY) +
							 (float)(param_3 - mouseX) * (float)(param_3 - mouseX));
	if ((ushort)((ushort)((float)param_5 < fVar1) << 8 | (ushort)((float)param_5 == fVar1) << 0xe) ==
			0) {
		return TRUE;
	}
	return 0;
}



void __cdecl lego::math::Math_XY_Div_Radius(int x,int y,int radius,float *out_x,float *out_y)
{
	*out_x = (float)x / (float)radius;
	*out_y = (float)y / (float)radius;
	return;
}



void __cdecl
lego::front::Panel_GetMouseXY_FUN_0045bbf0
					(int *out_mouseX,int *out_mouseY,int param_3,int param_4,int param_5)
{
	float fVar1;
	float10 extraout_ST0;
	float10 extraout_ST1;
	longlong lVar2;
	
	fVar1 = (float)((float10)*out_mouseX - (float10)param_3);
	lVar2 = __ftol(((float10)1.0 /
								 SQRT(((float10)*out_mouseY - (float10)param_4) *
											(float10)(float)((float10)*out_mouseY - (float10)param_4) +
											((float10)*out_mouseX - (float10)param_3) * (float10)fVar1)) * (float10)fVar1
								 * (float10)((float)param_5 - 1.0) + (float10)param_3);
	*out_mouseX = (int)lVar2;
	lVar2 = __ftol(extraout_ST0 + extraout_ST1);
	*out_mouseY = (int)lVar2;
	return;
}



void __cdecl lego::main::Main_LoadPanelRotationControl(CFGProperty *root,char *keyBasePath)
{
	char *pcVar1;
	float10 fVar2;
	char *local_28;
	char *local_24;
	char *local_20;
	
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"PanelRotationControl","CenterPositionX",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == NULL) {
		globals::g_PanelRotationControl_CenterPosition.x = 1;
	}
	else {
		globals::g_PanelRotationControl_CenterPosition.x = std::atoi(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"PanelRotationControl","CenterPositionY",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == NULL) {
		globals::g_PanelRotationControl_CenterPosition.y = 1;
	}
	else {
		globals::g_PanelRotationControl_CenterPosition.y = std::atoi(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"PanelRotationControl","Radius",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == NULL) {
		globals::g_PanelRotationControl_Radius = 1;
	}
	else {
		globals::g_PanelRotationControl_Radius = std::atoi(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"PanelRotationControl","LeftImage",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 == NULL) {
		globals::g_PanelRotationControl_LeftImage_bmp = NULL;
	}
	else {
		util::Util_Tokenise(pcVar1,&local_28,",");
		globals::g_PanelRotationControl_LeftImage_bmp = lego::image::Image_LoadBMPScaled(local_28,0,0);
		lego::image::Image_SetPenZeroTrans(globals::g_PanelRotationControl_LeftImage_bmp);
		fVar2 = std::atof(local_24);
		g_PanelRotationControl_LeftImage_position.x = (float)fVar2;
		fVar2 = std::atof(local_20);
		g_PanelRotationControl_LeftImage_position.y = (float)fVar2;
		std::free(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"PanelRotationControl","RightImage",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 == NULL) {
		globals::g_PanelRotationControl_RightImage_bmp = NULL;
	}
	else {
		util::Util_Tokenise(pcVar1,&local_28,",");
		globals::g_PanelRotationControl_RightImage_bmp = lego::image::Image_LoadBMPScaled(local_28,0,0);
		lego::image::Image_SetPenZeroTrans(globals::g_PanelRotationControl_RightImage_bmp);
		fVar2 = std::atof(local_24);
		g_PanelRotationControl_RightImage_position.x = (float)fVar2;
		fVar2 = std::atof(local_20);
		g_PanelRotationControl_RightImage_position.y = (float)fVar2;
		std::free(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"PanelRotationControl","UpImage",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 == NULL) {
		globals::g_PanelRotationControl_UpImage_bmp = NULL;
	}
	else {
		util::Util_Tokenise(pcVar1,&local_28,",");
		globals::g_PanelRotationControl_UpImage_bmp = lego::image::Image_LoadBMPScaled(local_28,0,0);
		lego::image::Image_SetPenZeroTrans(globals::g_PanelRotationControl_UpImage_bmp);
		fVar2 = std::atof(local_24);
		g_PanelRotationControl_UpImage_position.x = (float)fVar2;
		fVar2 = std::atof(local_20);
		g_PanelRotationControl_UpImage_position.y = (float)fVar2;
		std::free(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,"PanelRotationControl","DownImage",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		util::Util_Tokenise(pcVar1,&local_28,",");
		globals::g_PanelRotationControl_DownImage_bmp = lego::image::Image_LoadBMPScaled(local_28,0,0);
		lego::image::Image_SetPenZeroTrans(globals::g_PanelRotationControl_DownImage_bmp);
		fVar2 = std::atof(local_24);
		g_PanelRotationControl_DownImage_position.x = (float)fVar2;
		fVar2 = std::atof(local_20);
		g_PanelRotationControl_DownImage_position.y = (float)fVar2;
		std::free(pcVar1);
		return;
	}
	globals::g_PanelRotationControl_DownImage_bmp = NULL;
	return;
}



BOOL __cdecl lego::front::Panel_RotationControl_FUN_0045bf90(int param_1,int param_2,float param_3)
{
	float yawAmount;
	BOOL BVar1;
	float local_8;
	float local_4;
	
	BVar1 = FUN_0045bb60(param_1,param_2,globals::g_PanelRotationControl_CenterPosition.x,
											 globals::g_PanelRotationControl_CenterPosition.y,
											 globals::g_PanelRotationControl_Radius);
	if (BVar1 == 0) {
		if ((FLAGS_00501860 & 1) == 0) {
			return 0;
		}
		if (true) {
			Panel_GetMouseXY_FUN_0045bbf0
								(&param_1,&param_2,globals::g_PanelRotationControl_CenterPosition.x,
								 globals::g_PanelRotationControl_CenterPosition.y,
								 globals::g_PanelRotationControl_Radius);
			input::Input_SetCursorPos(param_1,param_2);
			goto LAB_0045c031;
		}
	}
	BVar1 = FUN_0045bb60(param_1,param_2,globals::g_PanelRotationControl_CenterPosition.x,
											 globals::g_PanelRotationControl_CenterPosition.y,4);
	if (BVar1 != 0) {
		return 1;
	}
LAB_0045c031:
	FLAGS_00501860 |= 1;
	math::Math_XY_Div_Radius
						(globals::g_PanelRotationControl_CenterPosition.x - param_1,
						 param_2 - globals::g_PanelRotationControl_CenterPosition.y,
						 globals::g_PanelRotationControl_Radius,&local_4,&local_8);
	BVar1 = FUN_0045bb60(param_1,globals::g_PanelRotationControl_CenterPosition.y,
											 globals::g_PanelRotationControl_CenterPosition.x,
											 globals::g_PanelRotationControl_CenterPosition.y,3);
	if (BVar1 != 0) {
		lego::view::Camera_AddTilt(globs::gameGlobs.cameraMain,local_8 * param_3 * 0.04);
		if (0.0 <= local_8) {
			FLAGS_00501860 = FLAGS_00501860 | 0x20;
			return 1;
		}
		FLAGS_00501860 = FLAGS_00501860 | 0x10;
		return 1;
	}
	BVar1 = FUN_0045bb60(globals::g_PanelRotationControl_CenterPosition.x,param_2,
											 globals::g_PanelRotationControl_CenterPosition.x,
											 globals::g_PanelRotationControl_CenterPosition.y,3);
	yawAmount = local_4 * param_3 * 0.04;
	if (BVar1 == 0) {
		lego::view::Camera_AddYaw(globs::gameGlobs.cameraMain,yawAmount);
		lego::view::Camera_AddTilt(globs::gameGlobs.cameraMain,local_8 * param_3 * 0.04);
		if (0.0 <= local_8) {
			FLAGS_00501860 |= 0x20;
		}
		else {
			FLAGS_00501860 |= 0x10;
		}
		if (local_4 < 0.0) {
			FLAGS_00501860 = FLAGS_00501860 | 0x80;
			return 1;
		}
	}
	else {
		lego::view::Camera_AddYaw(globs::gameGlobs.cameraMain,yawAmount);
		if (local_4 < 0.0) {
			FLAGS_00501860 = FLAGS_00501860 | 0x80;
			return 1;
		}
	}
	FLAGS_00501860 = FLAGS_00501860 | 0x40;
	return 1;
}



void __cdecl lego::view::Camera_MoveGame_Cam24_Float90(BOOL doAdd,float amount)
{
	if (doAdd == 0) {
		Camera_AddDist(globs::gameGlobs.cameraMain,amount * -3.0);
		return;
	}
	if (doAdd == 1) {
		Camera_AddDist(globs::gameGlobs.cameraMain,amount * 3.0);
	}
	return;
}



void __cdecl lego::front::Panel_FUN_0045c230(int param_1,int param_2,undefined4 *param_3)
{
	float *pfVar1;
	
	pfVar1 = (float *)(globals::g_PanelDatas_TABLE[param_1].field_24 + param_2 * 0x2c);
	*param_3 = *(undefined4 *)(globals::g_PanelDatas_TABLE[param_1].field_24 + param_2 * 0x2c);
	param_3[1] = pfVar1[1];
	param_3[2] = pfVar1[2] - *pfVar1;
	param_3[3] = pfVar1[3] - pfVar1[1];
	return;
}



void __cdecl
lego::main::Main_LoadRightPanelCrystals(char *smallCrystal,char *usedCrystal,char *noSmallCrystal)
{
	globals::g_RightPanel_SmallCrystal_bmp = lego::image::Image_LoadBMPScaled(smallCrystal,0,0);
	if (globals::g_RightPanel_SmallCrystal_bmp != NULL) {
		lego::image::Image_SetupTrans(globals::g_RightPanel_SmallCrystal_bmp,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	globals::g_RightPanel_UsedCrystal_bmp = lego::image::Image_LoadBMPScaled(usedCrystal,0,0);
	if (globals::g_RightPanel_UsedCrystal_bmp != NULL) {
		lego::image::Image_SetupTrans(globals::g_RightPanel_UsedCrystal_bmp,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	globals::g_RightPanel_NoSmallCrystal_bmp = lego::image::Image_LoadBMPScaled(noSmallCrystal,0,0);
	if (globals::g_RightPanel_NoSmallCrystal_bmp != NULL) {
		lego::image::Image_SetupTrans(globals::g_RightPanel_NoSmallCrystal_bmp,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	return;
}



void __cdecl
lego::game::Level_LoadRewardQuotaCrystals(CFGProperty *root,char *keyBasePath,char *levelName)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(keyBasePath,levelName,"Reward","Quota","Crystals",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == NULL) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(keyBasePath,levelName,"Reward","Quota","Crystals",0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	}
	globals::g_RewardsQuotaCrystals = std::atoi(pcVar1);
	if ((26 < globals::g_RewardsQuotaCrystals) || (globals::g_RewardsQuotaCrystals == 0)) {
		globals::g_RewardsQuotaCrystals = 26;
	}
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_0045c390(uint param_1,uint param_2,undefined4 param_3)
{
	undefined4 *puVar1;
	uint uVar2;
	int iVar3;
	uint *puVar4;
	undefined4 *puVar5;
	uint uVar6;
	uint *puVar7;
	uint uVar8;
	uint uVar9;
	ImageBMP *image;
	Point2F local_70;
	uint local_68 [26];
	
	local_68[2] = 0;
	local_68[0] = 0;
	puVar4 = local_68 + 3;
	for (iVar3 = 0x17; iVar3 != 0; iVar3 += -1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	local_68[1] = 0;
	puVar5 = &DAT_00501868;
	do {
		iVar3 = 2;
		puVar1 = puVar5;
		do {
			*puVar1 = puVar1[1];
			puVar1 = puVar1 + 6;
			iVar3 += -1;
		} while (iVar3 != 0);
		puVar5 = puVar5 + 1;
	} while (puVar5 < &DAT_0050187c);
	_DAT_0050187c = param_1;
	local_70.x = (float)(local_68 + 2);
	_DAT_00501894 = param_2;
	uVar6 = 0;
	puVar4 = local_68;
	do {
		uVar8 = 0;
		do {
			uVar9 = *puVar4;
			uVar2 = 0;
			if (uVar9 != 0) {
				puVar7 = (uint *)local_70.x;
				do {
					if (*puVar7 == (&DAT_00501868)[uVar8 + uVar6]) {
						local_68[(uVar2 + uVar6) * 2 + 3] = local_68[(uVar2 + uVar6) * 2 + 3] + 1;
						break;
					}
					uVar2 += 1;
					puVar7 = puVar7 + 2;
				} while (uVar2 < uVar9);
			}
			if (uVar2 == uVar9) {
				local_68[(uVar2 + uVar6) * 2 + 2] = (&DAT_00501868)[uVar8 + uVar6];
				local_68[(uVar2 + uVar6) * 2 + 3] = 1;
				*puVar4 = uVar9 + 1;
			}
			uVar8 += 1;
		} while (uVar8 < 6);
		uVar6 += 6;
		local_70.x = (float)((int)local_70.x + 0x30);
		puVar4 = puVar4 + 1;
		if (0xb < uVar6) {
			uVar6 = 0;
			do {
				uVar8 = local_68[uVar6];
				uVar9 = 0;
				if (uVar8 != 0) {
					puVar7 = local_68;
					puVar4 = local_68 + uVar6 * 0xc + 3;
					do {
						puVar7 = puVar7 + 2;
						uVar2 = *puVar4;
						if (uVar9 < uVar2) {
							uVar9 = uVar2;
							if (uVar6 == 0) {
								param_1 = *puVar7;
							}
							else {
								param_2 = puVar4[-1];
							}
						}
						puVar4 = puVar4 + 2;
						uVar8 -= 1;
					} while (uVar8 != 0);
				}
				uVar6 += 1;
			} while (uVar6 < 2);
			lego::front::Panel_FUN_0045a720
								(5,lego::globs::gameGlobs.bmpToolTipFont,0x29,0x1d5,1,"%i",param_1);
			if (lego::globals::g_RightPanel_NoSmallCrystal_bmp != NULL) {
				local_70.x = 624.0;
				local_70.y = 429.0;
				for (uVar6 = lego::globals::g_RewardsQuotaCrystals; uVar6 != 0; uVar6 -= 1) {
					lego::image::Image_DisplayScaled
										(lego::globals::g_RightPanel_NoSmallCrystal_bmp,NULL,&local_70,NULL);
					local_70.y = local_70.y - 17.0;
				}
			}
			if (lego::globals::g_RightPanel_SmallCrystal_bmp != NULL) {
				uVar6 = 0;
				if (lego::globals::g_RewardsQuotaCrystals < param_1) {
					param_1 = lego::globals::g_RewardsQuotaCrystals;
				}
				if (lego::globals::g_RewardsQuotaCrystals < param_2) {
					param_2 = lego::globals::g_RewardsQuotaCrystals;
				}
				local_70.x = 624.0;
				local_70.y = 429.0;
				image = lego::globals::g_RightPanel_SmallCrystal_bmp;
				uVar8 = param_2;
				if (lego::globals::g_RightPanel_UsedCrystal_bmp != NULL) {
					for (; image = lego::globals::g_RightPanel_UsedCrystal_bmp,
							lego::globals::g_RightPanel_UsedCrystal_bmp = image, uVar8 != 0; uVar8 = uVar8 - 1) {
						lego::image::Image_DisplayScaled
											(lego::globals::g_RightPanel_SmallCrystal_bmp,NULL,&local_70,NULL);
						local_70.y = local_70.y - 17.0;
						uVar6 = param_2;
					}
				}
				if (uVar6 < param_1) {
					iVar3 = param_1 - uVar6;
					do {
						lego::image::Image_DisplayScaled(image,NULL,&local_70,NULL);
						local_70.y = local_70.y - 17.0;
						iVar3 += -1;
					} while (iVar3 != 0);
				}
			}
			return;
		}
	} while( true );
}



void __cdecl
lego::front::AirMeter_Load
					(char *airJuice,uint value85,uint value6,uint meterLength,char *noAir,uint value21,
					uint value0)
{
	globals::g_AirMeter_JuiceImage = lego::image::Image_LoadBMPScaled(airJuice,0,0);
	globals::g_AirMeter_JuiceOffset.x = (float)(ulonglong)value85;
	globals::g_AirMeter_JuiceOffset.y = (float)(ulonglong)value6;
	globals::g_AirMeter_JuiceLength = meterLength;
	globals::g_AirMeter_NoAirImage = lego::image::Image_LoadBMPScaled(noAir,0,0);
	if (globals::g_AirMeter_NoAirImage != NULL) {
		lego::image::Image_SetupTrans(globals::g_AirMeter_NoAirImage,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	globals::g_AirMeter_NoAirOffset.x = (float)(ulonglong)value21;
	globals::g_AirMeter_NoAirOffset.y = (float)(ulonglong)value0;
	return;
}



void __cdecl lego::front::AirMeter_FUN_0045c6b0(PanelType panelType,float param_2)
{
	Point2F local_10;
	Size2F local_8;
	
	if ((globals::g_AirMeter_JuiceImage != NULL) &&
		 ((ushort)((ushort)(param_2 < 0.0) << 8 | (ushort)(param_2 == 0.0) << 0xe) == 0)) {
		local_8.height = (float)globals::g_AirMeter_JuiceImage->height;
		if ((ushort)((ushort)(param_2 < 100.0) << 8 | (ushort)(param_2 == 100.0) << 0xe) == 0) {
			param_2 = (float)&DAT_42c80000;
		}
		local_8.width = (float)(ulonglong)globals::g_AirMeter_JuiceLength * 0.01 * param_2;
		local_10.x = globals::g_PanelDatas_TABLE[panelType].xyOutIn.x +
								 globals::g_AirMeter_JuiceOffset.x;
		local_10.y = globals::g_PanelDatas_TABLE[panelType].xyOutIn.y +
								 globals::g_AirMeter_JuiceOffset.y;
		lego::image::Image_DisplayScaled(globals::g_AirMeter_JuiceImage,NULL,&local_10,&local_8);
	}
	return;
}



void __cdecl lego::front::AirMeter_SetAirBeat_UnkBool(BOOL state)
{
	globals::g_AirMeter_BeatUnkBool = state;
	return;
}



void __cdecl lego::front::AirMeter_FUN_0045c770(PanelType panelType)
{
	ImageBMP *image;
	BOOL BVar1;
	Point2F local_8;
	
	image = globals::g_AirMeter_NoAirImage;
	if (globals::g_AirMeter_NoAirImage != NULL) {
		local_8.x = globals::g_PanelDatas_TABLE[panelType].xyOutIn.x + globals::g_AirMeter_NoAirOffset.x
		;
		local_8.y = globals::g_PanelDatas_TABLE[panelType].xyOutIn.y + globals::g_AirMeter_NoAirOffset.y
		;
		if (globals::g_AirMeter_BeatUnkBool != 0) {
			BVar1 = Interface_GetBool_004ded1c();
			if (BVar1 != 0) {
				lego::image::Image_DisplayScaled(image,NULL,&local_8,NULL);
			}
		}
	}
	return;
}



void __cdecl
lego::main::Main_LoadRightPanel_CryOreSidebar(char *sidebar,uint param_2,uint param_3,uint param_4)
{
	globals::g_CryOreSidebarImage = lego::image::Image_LoadBMPScaled(sidebar,0,0);
	globals::g_RightPanel_CryOreSideBar_positionORsize.x = (float)(ulonglong)param_2;
	globals::g_RightPanel_CryOreSideBar_positionORsize.y = (float)(ulonglong)param_3;
	globals::g_Panel_UINT_0050181c = param_4;
	return;
}



void __cdecl FUN_0045c840(int param_1,int param_2)
{
	if (param_1 == 0) {
		if (param_2 != 0) {
			do {
				param_2 += -1;
				lego::globals::g_Panel_FLOAT_00501820 =
						 (lego::globals::g_Panel_FLOAT_00501820 - 0.05) * 20.0 * 0.05263158;
			} while (param_2 != 0);
		}
	}
	else {
		if (param_2 != 0) {
			do {
				param_2 += -1;
				lego::globals::g_Panel_FLOAT_00501820 =
						 lego::globals::g_Panel_FLOAT_00501820 -
						 (1.0 - lego::globals::g_Panel_FLOAT_00501820) * -0.05;
			} while (param_2 != 0);
		}
	}
	if (lego::globals::g_Panel_FLOAT_00501820 < 0.0) {
		lego::globals::g_Panel_FLOAT_00501820 = 0.0;
	}
	return;
}



void __cdecl lego::front::Panel_CryOreSidebar_Draw(void)
{
	Size2F local_10;
	Point2F local_8;
	
	if ((globals::g_CryOreSidebarImage != NULL) &&
		 ((ushort)((ushort)(globals::g_Panel_FLOAT_00501820 < 0.0) << 8 |
							(ushort)(globals::g_Panel_FLOAT_00501820 == 0.0) << 0xe) == 0)) {
		local_10.width = (float)globals::g_CryOreSidebarImage->width;
		local_8.x = globals::g_RightPanel_CryOreSideBar_positionORsize.x;
		local_10.height =
				 (float)(ulonglong)globals::g_Panel_UINT_0050181c * globals::g_Panel_FLOAT_00501820;
		local_8.y = globals::g_RightPanel_CryOreSideBar_positionORsize.y - local_10.height;
		lego::image::Image_DisplayScaled(globals::g_CryOreSidebarImage,NULL,&local_8,&local_10);
	}
	return;
}



BOOL __cdecl
lego::front::Panel_SetCurrentAdvisorFromButton(PanelType panelType,int buttonType,BOOL setFlag2)
{
	BOOL BVar1;
	
	BVar1 = Panel_GetAdvisorTypeFromButton(panelType,buttonType,(AdvisorType *)&buttonType);
	if (BVar1 != 0) {
		Advisor_SetCurrentAdvisor(buttonType,setFlag2);
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::front::Panel_GetAdvisorTypeFromButton
					(PanelType panelType,int buttonType,AdvisorType *out_advisorType)
{
										// max value is used as "invalid"
	*out_advisorType = ADVISOR__COUNT;
	if (true) {
		switch(panelType) {
		case PANEL_RADAR:
										// PANELBUTTON_RADAR_TOGGLE (0x0)
			if (buttonType == 0) {
				*out_advisorType = ADVISOR_PANELPOINT_RADARTOGGLE;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
										// PANELBUTTON_RADAR_TAGGEDOBJECTVIEW (0x1)
			if (buttonType == 1) {
				*out_advisorType = ADVISOR_PANELPOINT_RADARTOGGLEOBJECTVIEW;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
										// PANELBUTTON_RADAR_ZOOMIN (0x2)
			if (buttonType == 2) {
				*out_advisorType = ADVISOR_PANELPOINT_RADARZOOMIN;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
										// PANELBUTTON_RADAR_ZOOMOUT (0x3)
			if (buttonType == 3) {
				*out_advisorType = ADVISOR_PANELPOINT_RADARZOOMOUT;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
										// PANELBUTTON_RADAR_MAPVIEW (0x4)
			if (buttonType == 4) {
				*out_advisorType = ADVISOR_PANELPOINT_RADARMAPVIEW;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
			break;
		case PANEL_TOPPANEL:
										// PANELBUTTON_TOPPANEL_OPTIONS (0x0)
			if (buttonType == 0) {
				*out_advisorType = ADVISOR_PANELPOINT_TOPPANELOPTIONS;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
										// PANELBUTTON_TOPPANEL_PRIORITIES (0x1)
			if (buttonType == 1) {
				*out_advisorType = ADVISOR_PANELPOINT_TOPPANELPRIORITIES;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
										// PANELBUTTON_TOPPANEL_CALLTOARMS (0x2)
			if (buttonType == 2) {
				*out_advisorType = ADVISOR_PANELPOINT_TOPPANELCALLTOARMS;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
			break;
		case PANEL_CAMERACONTROL:
			if (buttonType == 0) {
				*out_advisorType = ADVISOR_PANELPOINT_CONTROLZOOMIN;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
			if (buttonType == 1) {
				*out_advisorType = ADVISOR_PANELPOINT_CONTROLZOOMOUT;
			}
			break;
		case PANEL_INFODOCK:
			if (buttonType == 0) {
				*out_advisorType = ADVISOR_PANELPOINT_INFODOCKGOTO;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
			if (buttonType == 1) {
				*out_advisorType = ADVISOR_PANELPOINT_INFODOCKCLOSE;
				return (uint)(*out_advisorType != ADVISOR__COUNT);
			}
		}
	}
	return (uint)(*out_advisorType != ADVISOR__COUNT);
}



void __cdecl lego::main::lego::front::Pointer_Initialise(void)
{
	globals::g_Pointers_TABLE[0] = "Pointer_Standard";
	globals::g_Pointers_TABLE[1] = "Pointer_Blank";
	globals::g_Pointers_TABLE[2] = "Pointer_Selected";
	globals::g_Pointers_TABLE[3] = "Pointer_Drill";
	globals::g_Pointers_TABLE[4] = "Pointer_CantDrill";
	globals::g_Pointers_TABLE[5] = "Pointer_Clear";
	globals::g_Pointers_TABLE[6] = "Pointer_Go";
	globals::g_Pointers_TABLE[7] = "Pointer_CantGo";
	globals::g_Pointers_TABLE[8] = "Pointer_Teleport";
	globals::g_Pointers_TABLE[9] = "Pointer_CantTeleport";
	globals::g_Pointers_TABLE[10] = "Pointer_Reinforce";
	globals::g_Pointers_TABLE[11] = "Pointer_CantReinforce";
	globals::g_Pointers_TABLE[12] = "Pointer_RadarPan";
	globals::g_Pointers_TABLE[13] = "Pointer_TrackObject";
	globals::g_Pointers_TABLE[14] = "Pointer_Help";
	globals::g_Pointers_TABLE[15] = "Pointer_CantHelp";
	globals::g_Pointers_TABLE[16] = "Pointer_PutDown";
	globals::g_Pointers_TABLE[17] = "Pointer_GetIn";
	globals::g_Pointers_TABLE[18] = "Pointer_GetOut";
	globals::g_Pointers_TABLE[19] = "Pointer_TutorialBlockInfo";
	globals::g_Pointers_TABLE[20] = "Pointer_Okay";
	globals::g_Pointers_TABLE[21] = "Pointer_NotOkay";
	globals::g_Pointers_TABLE[22] = "Pointer_CanBuild";
	globals::g_Pointers_TABLE[23] = "Pointer_CannotBuild";
	globals::g_Pointers_TABLE[24] = "Pointer_Dynamite";
	globals::g_Pointers_TABLE[25] = "Pointer_CantDynamite";
	globals::g_Pointers_TABLE[26] = "Pointer_PickUp";
	globals::g_Pointers_TABLE[27] = "Pointer_CantPickUp";
	globals::g_Pointers_TABLE[28] = "Pointer_PickUpOre";
	globals::g_Pointers_TABLE[29] = "Pointer_LegoManCantDig";
	globals::g_Pointers_TABLE[30] = "Pointer_VehicleCantDig";
	globals::g_Pointers_TABLE[31] = "Pointer_LegoManDig";
	globals::g_Pointers_TABLE[32] = "Pointer_VehicleDig";
	globals::g_Pointers_TABLE[33] = "Pointer_LegoManCantPickUp";
	globals::g_Pointers_TABLE[34] = "Pointer_VehicleCantPickUp";
	globals::g_Pointers_TABLE[35] = "Pointer_LegoManPickUp";
	globals::g_Pointers_TABLE[36] = "Pointer_VehiclePickUp";
	globals::g_Pointers_TABLE[37] = "Pointer_LegoManCantGo";
	globals::g_Pointers_TABLE[38] = "Pointer_VehicleCantGo";
	globals::g_Pointers_TABLE[39] = "Pointer_LegoManGo";
	globals::g_Pointers_TABLE[40] = "Pointer_VehicleGo";
	globals::g_Pointers_TABLE[41] = "Pointer_LegoManClear";
	globals::g_Pointers_TABLE[42] = "Pointer_VehicleClear";
	globals::g_Pointers_TABLE[43] = "Pointer_SurfaceType_Immovable";
	globals::g_Pointers_TABLE[44] = "Pointer_SurfaceType_Hard";
	globals::g_Pointers_TABLE[45] = "Pointer_SurfaceType_Medium";
	globals::g_Pointers_TABLE[46] = "Pointer_SurfaceType_Loose";
	globals::g_Pointers_TABLE[47] = "Pointer_SurfaceType_Soil";
	globals::g_Pointers_TABLE[48] = "Pointer_SurfaceType_Lava";
	globals::g_Pointers_TABLE[49] = "Pointer_SurfaceType_Water";
	globals::g_Pointers_TABLE[50] = "Pointer_SurfaceType_OreSeam";
	globals::g_Pointers_TABLE[51] = "Pointer_SurfaceType_Lake";
	globals::g_Pointers_TABLE[52] = "Pointer_SurfaceType_CrystalSeam";
	globals::g_Pointers_TABLE[53] = "Pointer_SurfaceType_RechargeSeam";
	globals::g_Pointers_TABLE[54] = "Pointer_CantZoom";
	globals::g_Pointers_TABLE[55] = "Pointer_Zoom";
	return;
}



// Load all Pointers in the CFG block (prop is the first child in the block)
// 
// USAGE: <PointerType><bmpPath>
// USAGE: <PointerType><flicPath>,<num1>,<num2>

void __cdecl lego::front::Pointer_LoadPointers(CFGProperty *prop)
{
	char cVar1;
	bool bVar2;
	PointerType PVar3;
	BOOL BVar4;
	int iVar;
	ImageBMP *pIVar5;
	char *pointerName;
	char *pcVar6;
	PointerType pointerType;
	char *stringParts [10];
	char local_400 [1024];
	
	if (prop != NULL) {
		do {
			pointerName = prop->key;
			bVar2 = true;
			if (pointerName != NULL) {
				iVar = -1;
				pcVar6 = pointerName;
				do {
					if (iVar == 0) break;
					iVar += -1;
					cVar1 = *pcVar6;
					pcVar6 = pcVar6 + 1;
				} while (cVar1 != '\0');
				if ((iVar != -2) && (*pointerName == '!')) {
					if ((globs::mainGlobs.flags & CMD_REDUCEIMAGES) == CMD_NONE) {
						pointerName = pointerName + 1;
					}
					else {
						bVar2 = false;
					}
				}
			}
			if ((bVar2) && (BVar4 = Pointer_GetType(pointerName,&pointerType), BVar4 != 0)) {
				std::sprintf(local_400,"%s",prop->value);
				iVar = util::Util_Tokenise(local_400,stringParts,",");
				PVar3 = pointerType;
				if (iVar == 1) {
					pIVar5 = lego::image::Image_LoadBMPScaled(stringParts[0],0,0);
					globals::g_PointerImages_TABLE[PVar3] = pIVar5;
					globals::g_PointerIsFlics_Table[PVar3] = 0;
				}
				else {
					lego::image::Flic_Setup
										(stringParts[0],(ImageFlic **)(globals::g_PointerImages_TABLE + pointerType),
										 FLICMEMORY|FLICLOOPINGON);
					globals::g_PointerIsFlics_Table[pointerType] = 1;
					iVar = std::atoi(stringParts[1]);
					globals::g_PointerFlicPoints_Table[pointerType].x = iVar;
					iVar = std::atoi(stringParts[2]);
					globals::g_PointerFlicPoints_Table[pointerType].y = iVar;
				}
				if (globals::g_PointerIsFlics_Table[pointerType] == 0) {
					lego::image::Image_SetupTrans
										(globals::g_PointerImages_TABLE[pointerType],0.0,0.0,0.0,0.0,0.0,0.0);
				}
			}
			prop = cfg::CFG_NextFlat(prop);
		} while (prop != NULL);
	}
	return;
}



BOOL __cdecl lego::front::Pointer_GetType(char *pointerName,PointerType *out_pointerType)
{
	int iVar1;
	char **ppcVar2;
	PointerType PVar3;
	
	PVar3 = POINTER_STANDARD;
	ppcVar2 = globals::g_Pointers_TABLE;
	do {
		iVar1 = std::_stricmp(*ppcVar2,pointerName);
		if (iVar1 == 0) {
			*out_pointerType = PVar3;
			return 1;
		}
		ppcVar2 = ppcVar2 + 1;
		PVar3 += POINTER_BLANK;
	} while (ppcVar2 < &globals::g_Pointer_UnkFloat);
	return 0;
}



ImageBMP * __cdecl lego::front::Pointers_GetImage(PointerType pointerType)
{
	return globals::g_PointerImages_TABLE[pointerType];
}



void __cdecl lego::front::Pointer_SetType_IfUnkFloatLessThan0(PointerType pointerType)
{
	if ((ushort)((ushort)(globals::g_Pointer_UnkFloat < 0.0) << 8 |
							(ushort)(globals::g_Pointer_UnkFloat == 0.0) << 0xe) != 0) {
		globals::g_PointerType = pointerType;
	}
	return;
}



void __cdecl lego::front::Pointer_SetTypeAndUnkFloat(PointerType pointerType,float unkFloat)
{
	globals::g_PointerType = pointerType;
	globals::g_Pointer_UnkFloat = unkFloat;
	return;
}



PointerType __cdecl lego::front::Pointer_GetCurrentType(void)
{
	return globals::g_PointerType;
}



void __cdecl lego::front::Pointer_DrawPointer(uint param_1,uint param_2)
{
	ImageBMP *image;
	Point2F local_20;
	uint local_18;
	undefined4 uStack20;
	Rect2F local_10;
	
	local_20.x = (float)(ulonglong)param_1;
	local_20.y = (float)(ulonglong)param_2;
	if (globals::g_PointerIsFlics_Table[globals::g_PointerType] != 1) {
										// Draw a BMP image pointer
		image = globals::g_PointerImages_TABLE[globals::g_PointerType];
		if (globals::g_PointerImages_TABLE[globals::g_PointerType] == NULL) {
			image = globals::g_PointerImages_TABLE[0];
		}
		lego::image::Image_DisplayScaled(image,NULL,&local_20,NULL);
		return;
	}
										// Draw a FLIC image pointer
	local_10.x = (float)globals::g_PointerFlicPoints_Table[globals::g_PointerType].x + local_20.x;
	local_10.y = (float)globals::g_PointerFlicPoints_Table[globals::g_PointerType].y + local_20.y;
	local_18 = res::AnimClone_IsLws
											 ((AnimClone *)globals::g_PointerImages_TABLE[globals::g_PointerType]);
	uStack20 = 0;
	local_10.width = (float)(ulonglong)local_18;
	local_18 = lego::image::Flic_GetHeight
											 ((ImageFlic *)globals::g_PointerImages_TABLE[globals::g_PointerType]);
	uStack20 = 0;
	local_10.height = (float)(ulonglong)local_18;
	lego::image::Image_DisplayScaled(globals::g_PointerImages_TABLE[1],NULL,&local_20,NULL);
	lego::image::Flic_Animate
						((ImageFlic *)globals::g_PointerImages_TABLE[globals::g_PointerType],&local_10,
						 ~globs::gameGlobs.flags1 >> 0x14 & 1,1);
	return;
}



void __cdecl lego::front::Pointer_SubUnkFloat_IfGreaterThan0(float value)
{
	if ((ushort)((ushort)(globals::g_Pointer_UnkFloat < 0.0) << 8 |
							(ushort)(globals::g_Pointer_UnkFloat == 0.0) << 0xe) == 0) {
		globals::g_Pointer_UnkFloat = globals::g_Pointer_UnkFloat - value;
	}
	return;
}



void __cdecl lego::main::Main_LoadPriorityImages(CFGProperty *root,char *keyBasePath)
{
	int iVar1;
	char *pcVar2;
	CFGProperty *prop;
	BOOL BVar3;
	int iVar4;
	ImageBMP *pIVar5;
	AIPriorityType local_254;
	char *local_250;
	char *local_24c;
	char *local_248;
	char *local_244;
	char *local_228;
	char *local_224;
	char local_200 [512];
	
	pcVar2 = cfg::CFG_JoinPath(keyBasePath,"PriorityImages",0);
	for (prop = cfg::CFG_GetChildren(root,pcVar2); prop != NULL; prop = cfg::CFG_NextFlat(prop)) {
		BVar3 = ai::AIPriority_GetType(prop->key,&local_254);
		if (BVar3 != 0) {
			std::sprintf(local_200,"%s",prop->value);
			util::Util_Tokenise(local_200,&local_250,":");
			iVar4 = util::Util_Tokenise(local_250,&local_228,"|");
			iVar1 = local_254 * 4;
			pcVar2 = std::_strdup(local_228);
			*(char **)(&DAT_00501f00 + iVar1) = pcVar2;
			if (iVar4 == 2) {
				snd::SFX_GetType(local_224,(SFXType *)(&DAT_005020b0 + iVar1));
			}
			pIVar5 = lego::image::Image_LoadBMPScaled(local_24c,0,0);
			*(ImageBMP **)(&DAT_00501f6c + local_254 * 4) = pIVar5;
			pIVar5 = lego::image::Image_LoadBMPScaled(local_248,0,0);
			*(ImageBMP **)(&DAT_00501fd8 + local_254 * 4) = pIVar5;
			pIVar5 = lego::image::Image_LoadBMPScaled(local_244,0,0);
			*(ImageBMP **)(&DAT_00502044 + local_254 * 4) = pIVar5;
		}
	}
	return;
}



void __cdecl FUN_0045d1c0(void)
{
	undefined4 *puVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (lego::globals::g_LevelPriorities_COUNT != 0) {
		puVar1 = lego::globals::g_Priorities_unk_TABLE;
		do {
			puVar1[-0x6c] = puVar1[-0x1b];
			lego::ai::AITask_Game_SetAITaskValue2(puVar1[-0x1b],*puVar1);
			lego::ai::AITask_Game_SetIsPriorityDisabled(puVar1[-0x6c],puVar1[0x1b]);
			uVar2 += 1;
			puVar1 = puVar1 + 1;
		} while (uVar2 < lego::globals::g_LevelPriorities_COUNT);
	}
	return;
}



BOOL __cdecl lego::game::Level_LoadPriorities(CFGProperty *root,char *keyBasePath,char *keyName)
{
	char *keyPath;
	CFGProperty *prop;
	BOOL BVar1;
	BOOL3 BVar2;
	
	globals::g_LevelPriorities_COUNT = 0;
	keyPath = cfg::CFG_JoinPath(keyBasePath,keyName,"Priorities",0);
	for (prop = cfg::CFG_GetChildren(root,keyPath); prop != NULL; prop = cfg::CFG_NextFlat(prop)) {
		BVar1 = ai::AIPriority_GetType(prop->key,(AIPriorityType *)&keyName);
		if (BVar1 != 0) {
			globals::g_PriorityNames_a_TABLE[globals::g_LevelPriorities_COUNT] = keyName;
			globals::g_PriorityNames_b_TABLE[globals::g_LevelPriorities_COUNT] = keyName;
			globals::g_Priorities_unk_TABLE[globals::g_LevelPriorities_COUNT] =
					 globals::g_LevelPriorities_COUNT * -5 + 0x50;
			ai::AITask_Game_SetAITaskValue2
								((int)keyName,globals::g_Priorities_unk_TABLE[globals::g_LevelPriorities_COUNT]);
			BVar2 = util::Util_GetBoolFromString(prop->value);
			if (BVar2 == BOOL3_TRUE) {
				ai::AITask_Game_SetIsPriorityDisabled((int)keyName,0);
				globals::g_Priorities_bool1_TABLE[globals::g_LevelPriorities_COUNT] = 0;
			}
			else {
				ai::AITask_Game_SetIsPriorityDisabled((int)keyName,1);
				globals::g_Priorities_bool1_TABLE[globals::g_LevelPriorities_COUNT] = 1;
			}
			globals::g_LevelPriorities_COUNT += 1;
		}
	}
	return 1;
}



void __cdecl lego::front::PriorityList_LoadImagePositions(CFGProperty *root,char *keyBasePath)
{
	char *keyPath1;
	char *pcVar1;
	int iVar2;
	int value;
	char **ppcVar3;
	char *local_40;
	char *local_3c;
	
	keyPath1 = keyBasePath;
	value = 0;
	ppcVar3 = (char **)&globals::g_PrioritiesImagePositions_TABLE[0].y;
	do {
		value += 1;
		std::itoa(value,(char *)&keyBasePath,10);
		pcVar1 = cfg::CFG_JoinPath(keyPath1,"PrioritiesImagePositions",&keyBasePath,0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
		if (pcVar1 != NULL) {
			util::Util_Tokenise(pcVar1,&local_40,",");
			iVar2 = std::atoi(local_40);
			ppcVar3[-1] = (char *)(float)iVar2;
			iVar2 = std::atoi(local_3c);
			*ppcVar3 = (char *)(float)iVar2;
		}
		ppcVar3 = ppcVar3 + 2;
	} while (ppcVar3 < globals::g_PriorityNames_b_TABLE + 1);
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOL __cdecl
lego::front::PriorityList_UnkUpdate_FUN_0045d3d0
					(uint mouseX,uint mouseY,BOOL leftButton,BOOL param_4,BOOL param_5)
{
	char *pcVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	float fVar5;
	BOOL BVar6;
	float *pfVar7;
	char **ppcVar8;
	uint uVar9;
	Point2F local_30;
	float local_28;
	float local_24;
	uint local_20;
	undefined4 uStack28;
	uint local_18;
	undefined4 uStack20;
	uint local_10;
	undefined4 uStack12;
	uint local_8;
	undefined4 uStack4;
	
	BVar6 = Panel_IsFlags_4_AndNot8(PANEL_PRIORITYLIST);
	if ((BVar6 == 0) && (BVar6 = Panel_IsFlag8(PANEL_PRIORITYLIST), BVar6 == 0)) {
		Panel_GetXYField3(PANEL_PRIORITYLIST,&local_28,&local_24);
		uVar9 = 0;
		if (globals::g_LevelPriorities_COUNT != 0) {
			pfVar7 = &globals::g_PrioritiesImagePositions_TABLE[0].y;
			ppcVar8 = globals::g_PriorityNames_a_TABLE;
			do {
				pcVar1 = *ppcVar8;
				iVar2 = *(int *)(&DAT_00501f6c + (int)pcVar1 * 4);
				if (iVar2 != 0) {
					uStack28 = 0;
					local_30.x = pfVar7[-1] + local_28;
					local_20 = mouseX;
					uVar3 = *(uint *)(iVar2 + 8);
					fVar5 = (float)(ulonglong)mouseX;
					uVar4 = *(uint *)(iVar2 + 4);
					local_30.y = local_24 + *pfVar7;
					if ((local_30.x <= fVar5) &&
						 (uStack20 = 0, local_18 = uVar4,
						 (ushort)((ushort)(fVar5 < (float)(ulonglong)uVar4 + local_30.x) << 8 |
										 (ushort)(fVar5 == (float)(ulonglong)uVar4 + local_30.x) << 0xe) != 0)) {
						uStack12 = 0;
						local_10 = mouseY;
						fVar5 = (float)(ulonglong)mouseY;
						if ((local_30.y <= fVar5) &&
							 (uStack4 = 0, local_8 = uVar3,
							 (ushort)((ushort)(fVar5 < (float)(ulonglong)uVar3 + local_30.y) << 8 |
											 (ushort)(fVar5 == (float)(ulonglong)uVar3 + local_30.y) << 0xe) != 0)) {
							FLAGS_005023bc |= 1;
							PriorityList_FUN_0045d630(&local_30,uVar4 - 1,uVar3 - 1);
							if (leftButton == 0) {
								if ((_DAT_004a9ee8 == uVar9) && (_DAT_004a9eec == pcVar1)) {
									ToolTip_SetText(TOOLTIP_PRIORITY,*(char **)(&DAT_00501f00 + (int)pcVar1 * 4));
									ToolTip_AddFlag4(TOOLTIP_PRIORITY);
									Interface_SetDat_004df1f4(*(undefined4 *)(&DAT_005020b0 + (int)pcVar1 * 4));
								}
								else {
									ToolTip_AddFlag4(TOOLTIP_NULL);
									_DAT_004a9ee8 = uVar9;
									_DAT_004a9eec = pcVar1;
								}
							}
							BVar6 = PriorityList_FUN_0045d5c0(uVar9,leftButton,param_4);
							if ((BVar6 != 0) && (param_5 != 0)) {
								PriorityList_FUN_0045d680(uVar9);
							}
							return TRUE;
						}
					}
				}
				uVar9 += 1;
				ppcVar8 = ppcVar8 + 1;
				pfVar7 = pfVar7 + 2;
			} while (uVar9 < globals::g_LevelPriorities_COUNT);
		}
		PriorityList_FUN_0045d5c0(0x1b,leftButton,param_4);
	}
	return 0;
}



BOOL __cdecl lego::front::PriorityList_FUN_0045d5c0(int param_1,int param_2,int param_3)
{
	int iVar1;
	
	iVar1 = DAT_005023b8;
	if (param_2 == 0) {
		DAT_005023b8 = 0x1b;
	}
	else {
		if (DAT_005023b8 == 0x1b) {
			if (param_3 == 0) {
				DAT_005023b8 = param_1;
				FLAGS_005023bc = FLAGS_005023bc | 2;
				return (uint)(param_1 == 0x1b);
			}
		}
		else {
			if (DAT_005023b8 == param_1) {
				FLAGS_005023bc = FLAGS_005023bc | 2;
				return (uint)(DAT_005023b8 == param_1);
			}
		}
	}
	return (uint)(iVar1 == param_1);
}



void __cdecl lego::front::PriorityList_FUN_0045d630(Point2F *param_1,uint param_2,uint param_3)
{
	FLOAT_005023a8 = param_1->x;
	FLOAT_005023ac = param_1->y;
	FLOAT_005023b0 = (float)(ulonglong)param_2;
	FLOAT_005023b4 = (float)(ulonglong)param_3;
	return;
}



void __cdecl lego::front::PriorityList_FUN_0045d680(uint param_1)
{
	if (((byte)FLAGS_00501860 & 2) != 0) {
		PriorityList_FUN_0045d6b0(param_1);
		return;
	}
	if (((byte)FLAGS_00501860 & 4) != 0) {
		PriorityList_FUN_0045d730(param_1);
	}
	return;
}



void __cdecl lego::front::PriorityList_FUN_0045d6b0(uint param_1)
{
	char *index;
	char *index_00;
	uint uVar1;
	int iVar2;
	int iVar3;
	
	if ((param_1 != 0) && (param_1 < globals::g_LevelPriorities_COUNT)) {
		index = globals::g_PriorityNames_a_TABLE[param_1];
		iVar3 = 0;
		if (param_1 != 0) {
			iVar2 = 0x50;
			uVar1 = param_1;
			do {
				index_00 = *(char **)(&DAT_00502118 + uVar1 * 4);
				globals::g_PriorityNames_a_TABLE[uVar1] = index_00;
				ai::AITask_Game_SetAITaskValue2((int)index_00,iVar2 + param_1 * -5);
				iVar3 += 1;
				iVar2 += 5;
				uVar1 = param_1 - iVar3;
			} while (uVar1 != 0);
		}
		globals::g_PriorityNames_a_TABLE[0] = index;
		ai::AITask_Game_SetAITaskValue2((int)index,0x50);
	}
	snd::Audio_FUN_00428730(3);
	return;
}



void __cdecl lego::front::PriorityList_FUN_0045d730(uint param_1)
{
	char *pcVar1;
	
	if ((param_1 != 0) && (param_1 < globals::g_LevelPriorities_COUNT)) {
		pcVar1 = globals::g_PriorityNames_a_TABLE[param_1];
		globals::g_PriorityNames_a_TABLE[param_1] = *(char **)(&DAT_00502118 + param_1 * 4);
		*(char **)(&DAT_00502118 + param_1 * 4) = pcVar1;
		ai::AITask_Game_SetAITaskValue2
							((int)globals::g_PriorityNames_a_TABLE[param_1],param_1 * -5 + 0x50);
		ai::AITask_Game_SetAITaskValue2(*(int *)(&DAT_00502118 + param_1 * 4),param_1 * -5 + 0x55);
		PriorityList_FUN_0045d810(param_1 - 1);
	}
	snd::Audio_FUN_00428730(0);
	return;
}



void __cdecl lego::front::PriorityList_FUN_0045d7b0(uint param_1)
{
	BOOL BVar1;
	
	if (param_1 < globals::g_LevelPriorities_COUNT) {
		BVar1 = ai::AITask_Game_IsPriorityDisabled((int)globals::g_PriorityNames_a_TABLE[param_1]);
		ai::AITask_Game_SetIsPriorityDisabled
							((int)globals::g_PriorityNames_a_TABLE[param_1],(uint)(BVar1 == 0));
		if (((BVar1 == 0) != 0) &&
			 ((globals::g_PriorityNames_a_TABLE[param_1] == NULL ||
				(globals::g_PriorityNames_a_TABLE[param_1] == (char *)0x1)))) {
			Text_DisplayMessage(TEXT_CRYSTALOREDISABLED,1,0);
		}
	}
	return;
}



void __cdecl lego::front::PriorityList_FUN_0045d810(undefined4 param_1)
{
	int iVar1;
	longlong lVar2;
	float local_18;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	switch(param_1) {
	case 0:
		PriorityList_FUN_0045d900(0);
		return;
	case 1:
		iVar1 = 9;
		break;
	case 2:
		iVar1 = 10;
		break;
	case 3:
		iVar1 = 0xb;
		break;
	case 4:
		iVar1 = 0xc;
		break;
	case 5:
		iVar1 = 0xd;
		break;
	case 6:
		iVar1 = 0xe;
		break;
	case 7:
		iVar1 = 0xf;
		break;
	case 8:
		iVar1 = 0x10;
		break;
	default:
		goto switchD_0045d821_caseD_9;
	}
	Panel_GetXYField3(PANEL_PRIORITYLIST,&local_18,&local_14);
	Panel_FUN_0045c230(8,iVar1,&local_10);
	lVar2 = __ftol((float10)local_4 * (float10)0.5 + (float10)local_c + (float10)local_14);
	iVar1 = (int)lVar2;
	lVar2 = __ftol((float10)local_8 * (float10)0.5 + (float10)local_10 + (float10)local_18);
	input::Input_SetCursorPos((int)lVar2,iVar1);
switchD_0045d821_caseD_9:
	return;
}



void __cdecl lego::front::PriorityList_FUN_0045d900(int priorityIndex)
{
	char *pcVar1;
	int iVar2;
	int y;
	longlong lVar3;
	float local_10;
	float local_c;
	uint local_8;
	undefined4 local_4;
	
	pcVar1 = globals::g_PriorityNames_a_TABLE[priorityIndex];
	if (*(int *)(&DAT_00501f6c + (int)pcVar1 * 4) != 0) {
		Panel_GetXYField3(PANEL_PRIORITYLIST,&local_10,&local_c);
		iVar2 = *(int *)(&DAT_00501f6c + (int)pcVar1 * 4);
		local_4 = 0;
		local_8 = *(uint *)(iVar2 + 8) >> 1;
		lVar3 = __ftol((float10)globals::g_PrioritiesImagePositions_TABLE[priorityIndex].y +
									 (float10)local_c + (float10)local_8);
		y = (int)lVar3;
		local_8 = *(uint *)(iVar2 + 4) >> 1;
		local_4 = 0;
		lVar3 = __ftol((float10)globals::g_PrioritiesImagePositions_TABLE[priorityIndex].x +
									 (float10)local_10 + (float10)local_8);
		input::Input_SetCursorPos((int)lVar3,y);
	}
	return;
}



void __cdecl lego::front::PriorityList_Update(void)
{
	char *priorityIndex;
	ImageBMP *image;
	BOOL BVar1;
	uint uVar2;
	char **ppcVar3;
	float *pfVar4;
	Point2F local_10;
	float local_8;
	float local_4;
	
	BVar1 = Panel_IsFlags_4_AndNot8(PANEL_PRIORITYLIST);
	if (BVar1 == 0) {
		Panel_GetXYField3(PANEL_PRIORITYLIST,&local_8,&local_4);
		uVar2 = 0;
		if (globals::g_LevelPriorities_COUNT != 0) {
			pfVar4 = &globals::g_PrioritiesImagePositions_TABLE[0].y;
			ppcVar3 = globals::g_PriorityNames_a_TABLE;
			do {
				local_10.x = pfVar4[-1] + local_8;
				local_10.y = local_4 + *pfVar4;
				priorityIndex = *ppcVar3;
				BVar1 = ai::AITask_Game_IsPriorityDisabled((int)priorityIndex);
				if (BVar1 == 0) {
					if (((FLAGS_005023bc & 2) == 0) || (DAT_005023b8 != uVar2)) {
						image = *(ImageBMP **)(&DAT_00501f6c + (int)priorityIndex * 4);
					}
					else {
						image = *(ImageBMP **)(&DAT_00501fd8 + (int)priorityIndex * 4);
					}
				}
				else {
					image = *(ImageBMP **)(&DAT_00502044 + (int)priorityIndex * 4);
				}
				if (image != NULL) {
					lego::image::Image_DisplayScaled(image,NULL,&local_10,NULL);
				}
				uVar2 += 1;
				ppcVar3 = ppcVar3 + 1;
				pfVar4 = pfVar4 + 2;
			} while (uVar2 < globals::g_LevelPriorities_COUNT);
		}
		if ((FLAGS_005023bc & 1) != 0) {
			Interface_Front_DrawLineListUnk_FUN_0041cc60((Rect2F *)&FLOAT_005023a8);
			FLAGS_005023bc &= 0xfffffffe;
		}
		FLAGS_005023bc &= 0xfffffffd;
	}
	return;
}



BOOL __cdecl lego::main::Main_loadPTLCFG__0045daa0(char *filename,char *keyBlockPath)
{
	uint uVar1;
	CFGProperty *prop;
	CFGProperty *prop_00;
	MessageType MVar2;
	
	globals::g_LEVEL_PTLEVENTS_COUNT = 0;
	prop = cfg::CFG_Open(filename);
	if (prop != NULL) {
		prop_00 = cfg::CFG_GetChildren(prop,keyBlockPath);
		uVar1 = globals::g_LEVEL_PTLEVENTS_COUNT;
		while (prop_00 != NULL) {
			globals::g_LEVEL_PTLEVENTS_COUNT = uVar1 + 1;
			MVar2 = game::Message_LookupPTLEventIndex(prop_00->key);
			globals::g_LEVEL_PTLEVENTS_TABLE[uVar1].eventIndex = MVar2;
			MVar2 = game::Message_LookupPTLEventIndex(prop_00->value);
			globals::g_LEVEL_PTLEVENTS_TABLE[uVar1].actionIndex = MVar2;
			prop_00 = cfg::CFG_NextFlat(prop_00);
			uVar1 = globals::g_LEVEL_PTLEVENTS_COUNT;
		}
		globals::g_LEVEL_PTLEVENTS_COUNT = uVar1;
		cfg::CFG_Close(prop);
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::Game_PTLEventToAction__0045db30(MessageAction *out_message)
{
	uint uVar1;
	PTLProperty *pPVar2;
	
	uVar1 = 0;
	if (globals::g_LEVEL_PTLEVENTS_COUNT != 0) {
		pPVar2 = globals::g_LEVEL_PTLEVENTS_TABLE;
		while (out_message->event != pPVar2->eventIndex) {
			uVar1 += 1;
			pPVar2 = pPVar2 + 1;
			if (globals::g_LEVEL_PTLEVENTS_COUNT <= uVar1) {
				return;
			}
		}
		out_message->event = pPVar2->actionIndex;
	}
	return;
}



void __cdecl lego::game::LevelStruct3C_SetFloat14(LevelStruct_3c *param_1,float param_2)
{
	param_1->float_14 = param_2;
	return;
}



void __cdecl lego::game::LevelStruct3C_InitUnkVectorTables(void)
{
	Vector3F *pVVar1;
	Vector3F *pVVar2;
	float *pfVar3;
	int iVar4;
	int iVar5;
	uint uVar6;
	float *pfVar7;
	
	pVVar1 = globals::g_UnkVector3F_30_TABLE;
	do {
		iVar5 = 3;
		pVVar2 = pVVar1;
		do {
			pVVar1 = (Vector3F *)&pVVar2->y;
			iVar5 += -1;
			pVVar2->x = pVVar2->x * 0.003921569;
			pVVar2 = pVVar1;
		} while (iVar5 != 0);
	} while (pVVar1 < &globals::g_UnkStructF_a_INT);
	pfVar3 = &globals::g_UnkStructF10_a_TABLE[0].float_c;
	do {
		pfVar3[0x50] = 1.0;
		*pfVar3 = 1.0;
		pfVar3 = pfVar3 + 4;
	} while (pfVar3 < &globals::g_UnkStructF10_b_TABLE[0].float_c);
	globals::g_UnkStructF10_a_TABLE[0].float_0 = 320.0;
	globals::g_UnkStructF10_a_TABLE[0].float_4 = 40.0;
	globals::g_UnkStructF10_b_TABLE[0].float_0 = 420.0;
	globals::g_UnkStructF10_b_TABLE[0].float_4 = 180.0;
	globals::g_UnkStructF10_a_TABLE[1].float_0 = 420.0;
	globals::g_UnkStructF10_a_TABLE[1].float_4 = 180.0;
	globals::g_UnkStructF10_b_TABLE[1].float_0 = 360.0;
	globals::g_UnkStructF10_b_TABLE[1].float_4 = 180.0;
	globals::g_UnkStructF10_a_TABLE[2].float_0 = 360.0;
	globals::g_UnkStructF10_a_TABLE[2].float_4 = 180.0;
	globals::g_UnkStructF10_b_TABLE[2].float_0 = 360.0;
	globals::g_UnkStructF10_b_TABLE[2].float_4 = 400.0;
	globals::g_UnkStructF10_a_TABLE[3].float_0 = 360.0;
	globals::g_UnkStructF10_a_TABLE[3].float_4 = 400.0;
	globals::g_UnkStructF10_b_TABLE[3].float_0 = 280.0;
	globals::g_UnkStructF10_b_TABLE[3].float_4 = 400.0;
	globals::g_UnkStructF10_a_TABLE[4].float_0 = 280.0;
	globals::g_UnkStructF10_a_TABLE[4].float_4 = 400.0;
	globals::g_UnkStructF10_b_TABLE[4].float_0 = 280.0;
	globals::g_UnkStructF10_b_TABLE[4].float_4 = 180.0;
	globals::g_UnkStructF10_a_TABLE[5].float_0 = 280.0;
	globals::g_UnkStructF10_a_TABLE[5].float_4 = 180.0;
	globals::g_UnkStructF10_b_TABLE[5].float_0 = 220.0;
	globals::g_UnkStructF10_b_TABLE[5].float_4 = 180.0;
	globals::g_UnkStructF10_a_TABLE[6].float_0 = 220.0;
	globals::g_UnkStructF10_a_TABLE[6].float_4 = 180.0;
	globals::g_UnkStructF10_b_TABLE[6].float_0 = 320.0;
	globals::g_UnkStructF10_b_TABLE[6].float_4 = 40.0;
	globals::g_UnkStructF10_a_COUNT = 7;
	uVar6 = 0;
	pfVar3 = &globals::g_UnkStructF10_a_TABLE[0].float_4;
	do {
		iVar5 = 2;
		pfVar7 = pfVar3;
		do {
			iVar4 = main::appWidth();
			pfVar7[-1] = (float)iVar4 * 0.0015625 * pfVar7[-1];
			iVar4 = main::appHeight();
			iVar5 += -1;
			*pfVar7 = (float)iVar4 * 0.002083333 * *pfVar7;
			pfVar7 = pfVar7 + 0x50;
		} while (iVar5 != 0);
		uVar6 += 1;
		pfVar3 = pfVar3 + 4;
	} while (uVar6 < globals::g_UnkStructF10_a_COUNT);
	globals::g_UnkStructF_a_INT = -1;
	globals::g_UnkStructF_b_INT = -1;
	return;
}



LevelStruct_3c * __cdecl
lego::game::LevelStruct3C_Create(SurfaceMap *surfMap,Rect2F *param_2,float param_3)
{
	float fVar1;
	LevelStruct_3c *pLVar2;
	float10 fVar3;
	
	pLVar2 = (LevelStruct_3c *)std::malloc(0x3c);
	if (pLVar2 != NULL) {
		(pLVar2->rectf_4).x = param_2->x;
		(pLVar2->rectf_4).y = param_2->y;
		(pLVar2->rectf_4).width = param_2->width;
		fVar1 = param_2->height;
		pLVar2->float_14 = param_3;
		(pLVar2->rectf_4).height = fVar1;
		fVar3 = Map3D_GetBlockSize(surfMap);
		pLVar2->float_18 = (float)fVar3;
		pLVar2->surfMap = surfMap;
		return pLVar2;
	}
	return NULL;
}



// Multiple-use function to free data

void __cdecl lego::game::LevelStruct3C_Free_Unwind(LevelStruct_3c *param_1)
{
	std::free(param_1);
	return;
}



void __cdecl
lego::game::LevelStruct3C_FUN_0045ddc0
					(LevelStruct_3c *param_1,Point2F *param_2,float param_3,float param_4)
{
	float b;
	longlong lVar1;
	Rect2F local_20;
	Rect2F local_10;
	
	local_20.height = 0.0;
	local_20.x = param_2->x;
	local_20.y = param_2->y;
	local_20.width = param_3;
	draw::Draw_GetClipWindow(&local_10);
	draw::Draw_SetClipWindow(&param_1->rectf_4);
	LevelStruct3C_FUN_0045ec00(param_1,&local_20);
	b = param_4 * 0.7 - -0.3;
	lVar1 = __ftol((float10)local_20.width);
	draw::Draw_DotCircle
						((Point2F *)&local_20,(uint)lVar1,(uint)lVar1 * 2,b * 0.7,b * 0.9,b,DRAWEFFECT_NONE);
	draw::Draw_SetClipWindow(&local_10);
	return;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

void __cdecl lego::game::LevelStruct3C_FUN_0045de80(LevelStruct_3c *param_1,Point2F *param_2)
{
	float fVar1;
	float fVar2;
	BOOL BVar3;
	uint uVar4;
	int iVar5;
	SurfaceMap *pSVar6;
	uint uVar7;
	float *pfVar8;
	Point2F *pPVar9;
	uint uVar10;
	Vector4F *transform4d;
	undefined4 *puVar11;
	float *pfVar12;
	float *pfVar13;
	Point2F *pPVar14;
	Vector3F *pVVar15;
	float *pfVar16;
	uint uStack46860;
	uint uStack46856;
	uint uStack46852;
	uint uStack46848;
	float *pfStack46844;
	Vector3F VStack46840;
	uint uStack46828;
	uint uStack46824;
	int iStack46820;
	int iStack46816;
	Rect2F RStack46812;
	Vector3F VStack46796;
	Vector3F VStack46784;
	Vector3F VStack46772;
	Vector4F VStack46760;
	float fStack46744;
	undefined4 uStack46740;
	undefined4 uStack46736;
	undefined4 uStack46732;
	float fStack46728;
	float fStack46724;
	undefined4 uStack46720;
	undefined4 uStack46716;
	undefined4 uStack46712;
	float fStack46708;
	undefined4 uStack46704;
	undefined4 uStack46700;
	undefined4 uStack46696;
	undefined4 uStack46692;
	undefined4 uStack46688;
	undefined4 uStack46684;
	float fStack46680;
	undefined4 uStack46676;
	undefined4 uStack46672;
	undefined4 uStack46668;
	float fStack46664;
	float fStack46660;
	undefined4 uStack46656;
	undefined4 uStack46652;
	undefined4 uStack46648;
	float fStack46644;
	undefined4 uStack46640;
	undefined4 uStack46636;
	Point2F PStack46632;
	Point2F aPStack46624 [3];
	float fStack46600;
	float fStack46596;
	Rect2F RStack46592;
	Vector3F aVStack46576 [8];
	Point2F aPStack46480 [20];
	Point2F aPStack46320 [20];
	float afStack46156 [59];
	Vector3F aVStack45920 [60];
	Point2F aPStack45200 [200];
	Point2F aPStack43600 [200];
	Draw_Rect aDStack42000 [1499];
	undefined4 uStack4;
	
	uStack4 = 0x45de8a;
	fVar1 = (param_1->rectf_4).width;
	param_1->float_1c = param_2->x;
	param_1->float_20 = param_2->y;
	uVar10 = 0;
	uVar7 = 0;
	uStack46856 = 0;
	uStack46860 = 0;
	uStack46824 = 0;
	uStack46828 = 0;
	VStack46840.x = ((fVar1 * 0.5) / param_1->float_14) * param_1->float_18;
	VStack46840.y = (((param_1->rectf_4).height * 0.5) / param_1->float_14) * param_1->float_18;
	Map3D_FUN_0044fad0(param_1->surfMap,param_2->x - VStack46840.x,VStack46840.y + param_2->y,
										 (int *)&uStack46828,(int *)&uStack46824);
	Map3D_FUN_0044fad0(param_1->surfMap,param_2->x + VStack46840.x,param_2->y - VStack46840.y,
										 &iStack46820,&iStack46816);
	draw::Draw_GetClipWindow(&RStack46592);
	draw::Draw_SetClipWindow(&param_1->rectf_4);
	uStack46852 = uStack46824;
	uStack46848 = uStack46828;
	iVar5 = iStack46820;
	if ((int)uStack46824 <= iStack46816) {
		do {
			uVar4 = uStack46848;
			if ((int)uStack46848 <= iVar5) {
				pfStack46844 = &aPStack45200[uVar7].y;
				pPVar9 = aPStack45200 + uVar7;
				pfVar8 = &aPStack43600[uVar7].y;
				pPVar14 = aPStack43600 + uVar7;
				pfVar13 = &aDStack42000[uVar10].rect.width;
				do {
					BVar3 = LevelStruct3C_FUN_0045eca0((int)(pfVar13 + -2),uStack46848,uStack46852);
					if (BVar3 != 0) {
						BVar3 = front::Interface_GetBool_004ded1c();
						if (((BVar3 != 0) && (uStack46848 == globals::g_UnkStructF_a_INT)) &&
							 (uStack46852 == globals::g_UnkStructF_b_INT)) {
							pfVar13[2] = 1.0;
							pfVar13[3] = 0.0;
							pfVar13[4] = 0.0;
						}
						pSVar6 = param_1->surfMap;
						fVar1 = param_1->float_18;
						fVar2 = param_1->float_18;
						((Rect2F *)(pfVar13 + -2))->x =
								 (float)uStack46848 * param_1->float_18 + (pSVar6->blockDimensions_neg).width;
						pfVar13[-1] = -((float)uStack46852 * fVar2) + (pSVar6->blockDimensions_neg).height;
						pfVar13[1] = fVar1;
						*pfVar13 = fVar1;
						LevelStruct3C_FUN_0045ec00(param_1,(Rect2F *)(pfVar13 + -2));
						*pfVar13 = *pfVar13 - 1.0;
						pfVar13[1] = pfVar13[1] - 1.0;
						BVar3 = Level_Block_IsReinforced(uStack46848,uStack46852);
						if ((BVar3 != 0) && (uStack46860 < 200)) {
							fVar1 = *pfVar13;
							fVar2 = pfVar13[-1];
							pPVar14->x = pfVar13[-2];
							*pfVar8 = fVar2;
							fVar1 = (fVar1 - 1.0) + pfVar13[-2];
							pPVar9->x = fVar1;
							pPVar14[1].x = fVar1;
							*pfStack46844 = fVar2;
							pfVar8[2] = fVar2;
							pPVar9[1].x = fVar1;
							fVar2 = (pfVar13[1] - 1.0) + pfVar13[-1];
							pfStack46844[2] = fVar2;
							pPVar14[2].x = fVar1;
							pfVar8[4] = fVar2;
							pPVar9[2].x = pfVar13[-2];
							pfStack46844[4] = fVar2;
							pPVar14[3].x = pfVar13[-2];
							pfVar8[6] = fVar2;
							pPVar9[3].x = pfVar13[-2];
							pfStack46844[6] = pfVar13[-1];
							uStack46860 += 4;
							pPVar14 = pPVar14 + 4;
							pfVar8 = pfVar8 + 8;
							pPVar9 = pPVar9 + 4;
							pfStack46844 = pfStack46844 + 8;
						}
						uStack46856 += 1;
						pfVar13 = pfVar13 + 7;
					}
					uStack46848 += 1;
					uVar4 = uStack46828;
					iVar5 = iStack46820;
					uVar7 = uStack46860;
					uVar10 = uStack46856;
				} while ((int)uStack46848 <= iStack46820);
			}
			uStack46852 += 1;
			uStack46848 = uVar4;
		} while ((int)uStack46852 <= iStack46816);
	}
	ddraw::DirectDraw_Clear(&param_1->rectf_4,0);
	draw::Draw_RectList2Ex(aDStack42000,uVar10,DRAWEFFECT_NONE);
	draw::Draw_LineListEx
						(aPStack43600,aPStack45200,uVar7,globals::g_UnkVector3F_30_TABLE[0].x,
						 globals::g_UnkVector3F_30_TABLE[0].y,globals::g_UnkVector3F_30_TABLE[0].z,
						 DRAWEFFECT_NONE);
	param_1->field_24 = param_2->x - VStack46840.x;
	param_1->field_28 = param_2->y - VStack46840.y;
	param_1->field_2c = param_2->x + VStack46840.x;
	fVar1 = param_2->y;
	param_1->field_34 = aDStack42000;
	param_1->field_38 = 0;
	param_1->field_30 = VStack46840.y + fVar1;
	Search_LiveObjects_SkipIgnoreMes
						(LevelStruct3C_LiveObject_Callback_FUN_0045e720,(undefined4 *)param_1);
	draw::Draw_RectList2Ex((Draw_Rect *)param_1->field_34,param_1->field_38,DRAWEFFECT_NONE);
	if (globs::gameGlobs.viewMode == VIEW_TOPDOWN) {
		VStack46760.x = 0.0;
		VStack46760.y = 0.0;
		VStack46760.z = 0.0;
		VStack46760.w = 1.0;
		iVar5 = main::appWidth();
		uStack46740 = 0;
		fStack46744 = (float)iVar5;
		uStack46736 = 0;
		uStack46732 = 0x3f800000;
		iVar5 = main::appWidth();
		fStack46728 = (float)iVar5;
		iVar5 = main::appHeight();
		uStack46720 = 0;
		fStack46724 = (float)iVar5;
		uStack46716 = 0x3f800000;
		uStack46712 = 0;
		iVar5 = main::appHeight();
		uStack46704 = 0;
		fStack46708 = (float)iVar5;
		uStack46700 = 0x3f800000;
		uStack46696 = 0;
		uStack46692 = 0;
		uStack46688 = 0x3f800000;
		uStack46684 = 0x3f800000;
		iVar5 = main::appWidth();
		uStack46676 = 0;
		fStack46680 = (float)iVar5;
		uStack46672 = 0x3f800000;
		uStack46668 = 0x3f800000;
		iVar5 = main::appWidth();
		fStack46664 = (float)iVar5;
		iVar5 = main::appHeight();
		uStack46656 = 0x3f800000;
		fStack46660 = (float)iVar5;
		uStack46652 = 0x3f800000;
		uStack46648 = 0;
		iVar5 = main::appHeight();
		uStack46640 = 0x3f800000;
		fStack46644 = (float)iVar5;
		uStack46636 = 0x3f800000;
		VStack46784.x = 0.0;
		VStack46784.y = 0.0;
		pSVar6 = GetSurfaceMap();
		VStack46772.x = 0.0;
		pVVar15 = aVStack46576;
		VStack46784.z = pSVar6->float_20 * 0.5;
		VStack46772.y = 0.0;
		VStack46772.z = -1.0;
		transform4d = &VStack46760;
		iVar5 = 8;
		do {
			lego::view::Viewport_InverseTransform(globs::gameGlobs.viewMain,pVVar15,transform4d);
			transform4d = transform4d + 1;
			pVVar15 = pVVar15 + 1;
			iVar5 += -1;
		} while (iVar5 != 0);
		uStack46856 = 0;
		uVar7 = globals::g_UnkStructF10_a_COUNT;
		do {
			uVar10 = 0;
			if (uVar7 != 0) {
				puVar11 = &globals::g_UnkStructF10_a_TABLE[0].field_8;
				pVVar15 = aVStack45920 + uStack46856 * 0x28;
				do {
					if (uStack46856 == 0) {
						puVar11[0x50] = 0;
						*puVar11 = 0;
					}
					else {
						puVar11[0x50] = 0x3f800000;
						*puVar11 = 0x3f800000;
					}
					lego::view::Viewport_InverseTransform
										(globs::gameGlobs.viewMain,pVVar15 + -0x14,(Vector4F *)(puVar11 + -2));
					lego::view::Viewport_InverseTransform
										(globs::gameGlobs.viewMain,pVVar15,(Vector4F *)(puVar11 + 0x4e));
					uVar10 += 1;
					pVVar15 = pVVar15 + 1;
					puVar11 = puVar11 + 4;
					uVar7 = globals::g_UnkStructF10_a_COUNT;
				} while (uVar10 < globals::g_UnkStructF10_a_COUNT);
			}
			uStack46856 += 1;
		} while (uStack46856 < 2);
		pfVar8 = afStack46156;
		pfVar13 = &aPStack46480[0].y;
		uStack46860 = 2;
		do {
			uVar10 = 0;
			pfVar12 = pfVar8;
			pfVar16 = pfVar13;
			if (uVar7 != 0) {
				do {
					VStack46840.x = pfVar12[0x77] - pfVar12[-1];
					VStack46840.y = pfVar12[0x78] - *pfVar12;
					VStack46840.z = pfVar12[0x79] - pfVar12[1];
					math::Maths_RayPlaneIntersection
										(&VStack46796,(Vector3F *)(pfVar12 + -1),&VStack46840,&VStack46784,&VStack46772)
					;
					RStack46812.x = VStack46796.x;
					RStack46812.y = VStack46796.y;
					LevelStruct3C_FUN_0045ec00(param_1,&RStack46812);
					pfVar16[-1] = RStack46812.x;
					*pfVar16 = RStack46812.y;
					uVar10 += 1;
					pfVar12 = pfVar12 + 3;
					pfVar16 = pfVar16 + 2;
					uVar7 = globals::g_UnkStructF10_a_COUNT;
				} while (uVar10 < globals::g_UnkStructF10_a_COUNT);
			}
			pfVar13 = pfVar13 + 0x28;
			pfVar8 = pfVar8 + 0x3c;
			uStack46860 += -1;
		} while (uStack46860 != 0);
		draw::Draw_LineListEx(aPStack46480,aPStack46320,uVar7,1.0,1.0,1.0,DRAWEFFECT_HALFTRANS);
		pfVar8 = &PStack46632.y;
		pfVar13 = &aVStack46576[0].y;
		iVar5 = 4;
		do {
			VStack46840.x = pfVar13[0xb] - pfVar13[-1];
			VStack46840.y = pfVar13[0xc] - *pfVar13;
			VStack46840.z = pfVar13[0xd] - pfVar13[1];
			math::Maths_RayPlaneIntersection
								(&VStack46796,(Vector3F *)(pfVar13 + -1),&VStack46840,&VStack46784,&VStack46772);
			RStack46812.x = VStack46796.x;
			RStack46812.y = VStack46796.y;
			LevelStruct3C_FUN_0045ec00(param_1,&RStack46812);
			pfVar8[-1] = RStack46812.x;
			*pfVar8 = RStack46812.y;
			pfVar13 = pfVar13 + 3;
			pfVar8 = pfVar8 + 2;
			iVar5 += -1;
		} while (iVar5 != 0);
		fStack46600 = PStack46632.x;
		fStack46596 = PStack46632.y;
		draw::Draw_LineListEx(&PStack46632,aPStack46624,4,0.7,0.7,0.7,DRAWEFFECT_HALFTRANS);
	}
	draw::Draw_SetClipWindow(&RStack46592);
	return;
}



BOOL __cdecl lego::game::LevelStruct3C_LiveObject_FUN_0045e6c0(LiveObject *liveObj)
{
	ObjectType OVar1;
	ObjectStatsFlags2 OVar2;
	
	OVar1 = liveObj->objType;
	if ((((((OVar1 != OBJECT_ELECTRICFENCESTUD) && (OVar1 != OBJECT_BOULDER)) &&
				(OVar1 != OBJECT_DYNAMITE)) && ((OVar1 != OBJECT_OOHSCARY && (OVar1 != OBJECT_PUSHER)))) &&
			((OVar1 != OBJECT_FREEZER && ((OVar1 != OBJECT_LASERSHOT && (OVar1 != OBJECT_BARRIER)))))) &&
		 ((OVar1 != OBJECT_ICECUBE && ((OVar1 != OBJECT_BUILDING && (OVar1 != OBJECT_SPIDERWEB)))))) {
		OVar2 = LiveObject_GetStatsFlags2(liveObj);
		return ~OVar2 >> 0x1d & 1;
	}
	return 0;
}



BOOL __cdecl
lego::game::LevelStruct3C_LiveObject_Callback_FUN_0045e720(LiveObject *liveObj,int param_2)
{
	ObjectType OVar1;
	float fVar2;
	BOOL BVar3;
	float local_8;
	float local_4;
	
	BVar3 = LevelStruct3C_LiveObject_FUN_0045e6c0(liveObj);
	if (BVar3 == 0) {
		return 0;
	}
	LiveObject_GetPosition(liveObj,&local_8,&local_4);
	if ((((*(float *)(param_2 + 0x24) <= local_8) &&
			 ((ushort)((ushort)(local_8 < *(float *)(param_2 + 0x2c)) << 8 |
								(ushort)(local_8 == *(float *)(param_2 + 0x2c)) << 0xe) != 0)) &&
			(*(float *)(param_2 + 0x28) <= local_4)) &&
		 ((ushort)((ushort)(local_4 < *(float *)(param_2 + 0x30)) << 8 |
							(ushort)(local_4 == *(float *)(param_2 + 0x30)) << 0xe) != 0)) {
		OVar1 = liveObj->objType;
		if (OVar1 == OBJECT_ROCKMONSTER) {
			*(float *)(*(int *)(param_2 + 0x34) + 0x10 + *(int *)(param_2 + 0x38) * 0x1c) =
					 globals::g_UnkVector3F_30_TABLE[15].x;
			*(float *)(*(int *)(param_2 + 0x34) + 0x14 + *(int *)(param_2 + 0x38) * 0x1c) =
					 globals::g_UnkVector3F_30_TABLE[15].y;
			*(float *)(*(int *)(param_2 + 0x34) + 0x18 + *(int *)(param_2 + 0x38) * 0x1c) =
					 globals::g_UnkVector3F_30_TABLE[15].z;
			fVar2 = 0.3333333;
		}
		else {
			if ((OVar1 == OBJECT_POWERCRYSTAL) || (OVar1 == OBJECT_ORE)) {
				*(float *)(*(int *)(param_2 + 0x34) + 0x10 + *(int *)(param_2 + 0x38) * 0x1c) =
						 globals::g_UnkVector3F_30_TABLE[16].x;
				*(float *)(*(int *)(param_2 + 0x34) + 0x14 + *(int *)(param_2 + 0x38) * 0x1c) =
						 globals::g_UnkVector3F_30_TABLE[16].y;
				*(float *)(*(int *)(param_2 + 0x34) + 0x18 + *(int *)(param_2 + 0x38) * 0x1c) =
						 globals::g_UnkVector3F_30_TABLE[16].z;
				fVar2 = 0.25;
			}
			else {
				*(float *)(*(int *)(param_2 + 0x34) + 0x10 + *(int *)(param_2 + 0x38) * 0x1c) =
						 globals::g_UnkVector3F_30_TABLE[14].x;
				*(float *)(*(int *)(param_2 + 0x34) + 0x14 + *(int *)(param_2 + 0x38) * 0x1c) =
						 globals::g_UnkVector3F_30_TABLE[14].y;
				*(float *)(*(int *)(param_2 + 0x34) + 0x18 + *(int *)(param_2 + 0x38) * 0x1c) =
						 globals::g_UnkVector3F_30_TABLE[14].z;
				fVar2 = 0.3333333;
			}
		}
		*(float *)(*(int *)(param_2 + 0x34) + *(int *)(param_2 + 0x38) * 0x1c) =
				 local_8 - fVar2 * 0.5 * *(float *)(param_2 + 0x18);
		*(float *)(*(int *)(param_2 + 0x34) + 4 + *(int *)(param_2 + 0x38) * 0x1c) =
				 fVar2 * 0.5 * *(float *)(param_2 + 0x18) + local_4;
		*(float *)(*(int *)(param_2 + 0x34) + 8 + *(int *)(param_2 + 0x38) * 0x1c) =
				 fVar2 * *(float *)(param_2 + 0x18);
		*(float *)(*(int *)(param_2 + 0x34) + 0xc + *(int *)(param_2 + 0x38) * 0x1c) =
				 fVar2 * *(float *)(param_2 + 0x18);
		LevelStruct3C_FUN_0045ec00
							((LevelStruct_3c *)param_2,
							 (Rect2F *)(*(int *)(param_2 + 0x34) + *(int *)(param_2 + 0x38) * 0x1c));
		*(int *)(param_2 + 0x38) = *(int *)(param_2 + 0x38) + 1;
	}
	return 0;
}



BOOL __cdecl
lego::game::LevelStruct3C_FUN_0045e920(LevelStruct_3c *param_1,uint param_2,uint param_3)
{
	if (((((param_1->rectf_4).x <= (float)(ulonglong)param_2) &&
			 ((float)(ulonglong)param_2 < (param_1->rectf_4).width + (param_1->rectf_4).x)) &&
			((param_1->rectf_4).y <= (float)(ulonglong)param_3)) &&
		 ((float)(ulonglong)param_3 < (param_1->rectf_4).height + (param_1->rectf_4).y)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::game::LevelStruct3C_FUN_0045e990
					(LevelStruct_3c *param_1,uint x,uint y,Point2F *out_pointf,int *out_blockx,int *out_blocky
					)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	BOOL BVar5;
	
	fVar1 = (float)(ulonglong)x;
	if (((param_1->rectf_4).x <= fVar1) &&
		 (fVar2 = (param_1->rectf_4).width + (param_1->rectf_4).x,
		 (ushort)((ushort)(fVar2 < fVar1) << 8 | (ushort)(fVar2 == fVar1) << 0xe) == 0)) {
		fVar2 = (float)(ulonglong)y;
		if (((param_1->rectf_4).y <= fVar2) &&
			 (fVar3 = (param_1->rectf_4).height + (param_1->rectf_4).y,
			 (ushort)((ushort)(fVar3 < fVar2) << 8 | (ushort)(fVar3 == fVar2) << 0xe) == 0)) {
			fVar3 = 1.0 / param_1->float_14;
			fVar4 = (param_1->rectf_4).width * 0.5;
			fVar2 = param_1->float_18 * (((param_1->rectf_4).y + fVar4) - fVar2) * fVar3 +
							param_1->float_20;
			fVar1 = param_1->float_1c +
							-(param_1->float_18 * (((param_1->rectf_4).x + fVar4) - fVar1) * fVar3);
			BVar5 = Map3D_WorldToBlockPos_NoZ(param_1->surfMap,fVar1,fVar2,out_blockx,out_blocky);
			if (BVar5 != 0) {
				if (out_pointf != NULL) {
					out_pointf->x = fVar1;
					out_pointf->y = fVar2;
				}
				return 1;
			}
		}
	}
	return 0;
}



BOOL __cdecl
lego::game::LevelStruct3C_FUN_0045eae0
					(LevelStruct_3c *param_1,uint x,uint y,undefined4 *param_4,undefined4 *param_5)
{
	BOOL BVar1;
	int local_18;
	int local_14;
	LiveObject *local_10;
	Point2F local_c;
	float local_4;
	
	local_c.x = 0.0;
	local_c.y = 0.0;
	local_4 = 0.0;
	local_10 = NULL;
	BVar1 = LevelStruct3C_FUN_0045e990(param_1,x,y,&local_c,&local_18,&local_14);
	if (BVar1 != 0) {
		BVar1 = Level_BlockIsFlags1_400_AndOptIsFlags2_4(local_18,local_14,1);
		if (BVar1 == 0) {
			local_4 = param_1->float_18 * 0.1666667;
		}
		else {
			local_4 = param_1->float_18;
		}
		BVar1 = Search_LiveObjects_SkipIgnoreMes(LevelStruct3C_FUN_0045eba0,&local_10);
		if (BVar1 != 0) {
			*param_4 = local_10;
			if (param_5 != NULL) {
				LiveObject_GetPosition(local_10,(float *)param_5,(float *)(param_5 + 1));
			}
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LevelStruct3C_FUN_0045eba0(LiveObject *liveObj,LiveObject **param_2)
{
	float local_8;
	float local_4;
	
	LiveObject_GetPosition(liveObj,&local_8,&local_4);
	if ((ABS(local_8 - (float)param_2[1]) <= (float)param_2[3]) &&
		 (ABS(local_4 - (float)param_2[2]) <= (float)param_2[3])) {
		*param_2 = liveObj;
		return 1;
	}
	return 0;
}



void __cdecl lego::game::LevelStruct3C_FUN_0045ec00(LevelStruct_3c *param_1,Rect2F *ref_param_2)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	
	fVar1 = (param_1->rectf_4).width;
	fVar2 = (param_1->rectf_4).height;
	fVar3 = (param_1->rectf_4).x;
	fVar4 = (param_1->rectf_4).y;
	ref_param_2->x = ref_param_2->x - param_1->float_1c;
	ref_param_2->y = ref_param_2->y - param_1->float_20;
	ref_param_2->x = (param_1->float_14 / param_1->float_18) * ref_param_2->x;
	ref_param_2->y = (param_1->float_14 / param_1->float_18) * ref_param_2->y;
	ref_param_2->width = (param_1->float_14 / param_1->float_18) * ref_param_2->width;
	fVar5 = param_1->float_14;
	fVar6 = param_1->float_18;
	ref_param_2->x = ref_param_2->x + fVar1 * 0.5 + fVar3;
	ref_param_2->y = (fVar2 * 0.5 + fVar4) - ref_param_2->y;
	ref_param_2->height = (fVar5 / fVar6) * ref_param_2->height;
	return;
}



BOOL __cdecl lego::game::LevelStruct3C_FUN_0045eca0(int param_1,uint param_2,uint param_3)
{
	BOOL BVar1;
	uint uVar2;
	Point2I local_8;
	
	uVar2 = param_2;
	local_8.x = param_2;
	local_8.y = param_3;
	FUN_00433260(param_2,param_3,&param_2);
	BVar1 = Level_GetBlockFlags1_10Not8(uVar2,param_3);
	if (BVar1 == 0) {
		BVar1 = Level_BlockIsNotFlags1_18(uVar2,param_3);
		if ((BVar1 != 0) && (BVar1 = FUN_00432ec0(uVar2,param_3), BVar1 != 0)) {
			if (((globs::gameGlobs.level)->blocks
					 [((globs::gameGlobs.level)->dimensions).width * param_3 + uVar2].flags1 & BLOCK1_HIDDEN)
					!= BLOCK1_NONE) {
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[29].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[29].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[29].z;
				return 1;
			}
			switch(param_2) {
			case 1:
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[8].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[8].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[8].z;
				return 1;
			case 2:
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[7].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[7].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[7].z;
				return 1;
			case 3:
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[6].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[6].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[6].z;
				return 1;
			case 4:
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[5].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[5].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[5].z;
				return 1;
			case 5:
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[4].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[4].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[4].z;
				return 1;
			case 6:
				goto switchD_0045ef37_caseD_6;
			case 7:
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[2].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[2].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[2].z;
				return 1;
			case 8:
switchD_0045ef37_caseD_8:
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[24].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[24].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[24].z;
				return 1;
			case 9:
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[27].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[27].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[27].z;
				return 1;
			case 10:
switchD_0045ef37_caseD_a:
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[25].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[25].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[25].z;
				return 1;
			case 0xb:
switchD_0045ef37_caseD_b:
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[26].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[26].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[26].z;
				return 1;
			default:
				goto switchD_0045ef37_caseD_b;
			}
		}
		BVar1 = Level_BlockIsFlags1_8(uVar2,param_3);
		if (BVar1 == 0) {
			return 0;
		}
		if (param_2 != 6) {
			if (param_2 == 7) {
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[2].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[2].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[2].z;
				return 1;
			}
			if (param_2 == 9) {
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[27].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[27].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[27].z;
				return 1;
			}
			if (((globs::gameGlobs.level)->blocks
					 [((globs::gameGlobs.level)->dimensions).width * param_3 + uVar2].flags1 &
					BLOCK1_UNK_100000) != BLOCK1_NONE) {
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[28].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[28].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[28].z;
				return 1;
			}
			BVar1 = Level_Block_IsPowerPath(&local_8);
			if (BVar1 != 0) {
				BVar1 = Level_BlockHasFlag2_100(&local_8);
				if (BVar1 != 0) {
					*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[22].x;
					*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[22].y;
					*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[22].z;
					return 1;
				}
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[23].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[23].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[23].z;
				return 1;
			}
			*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[1].x;
			*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[1].y;
			*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[1].z;
			return 1;
		}
switchD_0045ef37_caseD_6:
		*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[3].x;
		*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[3].y;
		*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[3].z;
	}
	else {
		uVar2 = FUN_00432b50(uVar2,param_3);
		if (uVar2 == 0) {
			if (true) {
				switch(param_2) {
				case 1:
					*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[13].x;
					*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[13].y;
					*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[13].z;
					return 1;
				case 2:
					*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[12].x;
					*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[12].y;
					*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[12].z;
					return 1;
				case 3:
					*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[11].x;
					*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[11].y;
					*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[11].z;
					return 1;
				case 4:
					*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[10].x;
					*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[10].y;
					*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[10].z;
					return 1;
				case 5:
					*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[9].x;
					*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[9].y;
					*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[9].z;
					return 1;
				case 8:
					goto switchD_0045ef37_caseD_8;
				case 10:
					goto switchD_0045ef37_caseD_a;
				case 0xb:
					goto switchD_0045ef37_caseD_b;
				}
			}
		}
		else {
			switch(param_2) {
			case 1:
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[21].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[21].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[21].z;
				return 1;
			case 2:
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[20].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[20].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[20].z;
				return 1;
			case 3:
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[19].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[19].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[19].z;
				return 1;
			case 4:
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[18].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[18].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[18].z;
				return 1;
			case 5:
				*(float *)(param_1 + 0x10) = globals::g_UnkVector3F_30_TABLE[17].x;
				*(float *)(param_1 + 0x14) = globals::g_UnkVector3F_30_TABLE[17].y;
				*(float *)(param_1 + 0x18) = globals::g_UnkVector3F_30_TABLE[17].z;
				return 1;
			}
		}
	}
switchD_0045ef37_caseD_b:
	return 1;
}



BOOL __cdecl lego::reward::Reward_LoadBaseFrontEnd(void)
{
	int iVar1;
	uint uVar2;
	RewardFrontEnd *pRVar3;
	char **ppcVar4;
	char *ITEM_NAMES [10];
	
	ITEM_NAMES[0] = "Crystals";
	ITEM_NAMES[1] = "Ore";
	ITEM_NAMES[2] = "Diggable";
	ITEM_NAMES[3] = "Constructions";
	ITEM_NAMES[4] = "Caverns";
	ITEM_NAMES[5] = "Figures";
	ITEM_NAMES[6] = "RockMonsters";
	ITEM_NAMES[7] = "Oxygen";
	ITEM_NAMES[8] = "Timer";
	ITEM_NAMES[9] = "Score";
	globals::g_RewardFrontBase = (RewardFrontEnd *)std::malloc(0x318c);
	pRVar3 = globals::g_RewardFrontBase;
										// std::memset(_, 0, 0x318c);
	for (iVar1 = 0xc63; iVar1 != 0; iVar1 += -1) {
		pRVar3->Enabled = 0;
		pRVar3 = (RewardFrontEnd *)&pRVar3->field_0x4;
	}
	uVar2 = 0;
	ppcVar4 = ITEM_NAMES;
	globals::g_RewardFrontBase->items_PTR = globals::g_RewardFrontBase->items_TABLE;
	globals::g_RewardFrontBase->items_COUNT = 10;
	do {
		std::sprintf(globals::g_RewardFrontBase->items_PTR->name + uVar2,"%s",*ppcVar4);
		uVar2 += 0x210;
		ppcVar4 = ppcVar4 + 1;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		RewardItem_LoadBaseImages
							((RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar2 - 4)));
		uVar2 += 0x210;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		RewardItem_LoadBaseText
							((RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar2 - 4)));
		uVar2 += 0x210;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		RewardItem_LoadBaseFlics
							((RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar2 - 4)));
		uVar2 += 0x210;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		RewardItem_LoadBaseFonts
							((RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar2 - 4)));
		uVar2 += 0x210;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		RewardItem_LoadBaseSounds
							((RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar2 - 4)));
		uVar2 += 0x210;
	} while (uVar2 < 0x14a0);
	uVar2 = 0;
	do {
		RewardItem_LoadBaseBoxImages
							((RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar2 - 4)));
		uVar2 += 0x210;
	} while (uVar2 < 0x14a0);
	return 1;
}



void __cdecl lego::reward::RewardItem_LoadBaseSounds(RewardFrontEndItem *rewardItem)
{
	char *pcVar1;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Sounds",rewardItem->name,0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
	rewardItem->SoundName = pcVar1;
	return;
}



void __cdecl lego::reward::RewardItem_LoadBaseFonts(RewardFrontEndItem *rewardItem)
{
	char *pcVar1;
	ImageFont *pIVar2;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Fonts",rewardItem->name,0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 != NULL) {
		pIVar2 = lego::image::Font_Load(pcVar1);
		rewardItem->Font = pIVar2;
		if (pIVar2 != NULL) {
			return;
		}
	}
	rewardItem->Font = globals::g_Reward_Font;
	return;
}



void __cdecl lego::reward::RewardItem_LoadBaseBoxImages(RewardFrontEndItem *rewardItem)
{
	char *pcVar1;
	int iVar2;
	ImageBMP *image;
	char reduceName [64];
	char valueBuffer [128];
	char *stringParts [100];
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","BoxImages",rewardItem->name,0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 == NULL) {
		if ((globs::mainGlobs.flags & CMD_REDUCEIMAGES) == CMD_NONE) {
			std::sprintf(reduceName,"!%s",rewardItem->name);
			pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Images",reduceName,0);
			pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
		}
		if (pcVar1 == NULL) {
			return;
		}
	}
	util::Util_Tokenise(pcVar1,stringParts,"|");
	std::sprintf(valueBuffer,"%s",stringParts[0]);
	iVar2 = std::atoi(stringParts[1]);
	(rewardItem->BoxImagePosition).x = iVar2;
	iVar2 = std::atoi(stringParts[2]);
	(rewardItem->BoxImagePosition).y = iVar2;
	image = lego::image::Image_LoadBMPScaled(valueBuffer,0,0);
	rewardItem->BoxImage = image;
	if (image != NULL) {
		lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
		rewardItem->flags = rewardItem->flags | REWARDITEM_BOXIMAGES;
		std::free(pcVar1);
	}
	return;
}



void __cdecl lego::reward::RewardItem_LoadBaseImages(RewardFrontEndItem *rewardItem)
{
	char *pcVar1;
	int iVar2;
	ImageBMP *image;
	char local_250 [64];
	char local_210 [128];
	char *local_190;
	char *local_18c;
	char *local_188;
	
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Images",rewardItem->name,0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 == NULL) {
		if ((globs::mainGlobs.flags & CMD_REDUCEIMAGES) == CMD_NONE) {
			std::sprintf(local_250,"!%s",rewardItem->name);
			pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Images",local_250,0);
			pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
		}
		if (pcVar1 == NULL) {
			return;
		}
	}
	util::Util_Tokenise(pcVar1,&local_190,"|");
	std::sprintf(local_210,"%s",local_190);
	iVar2 = std::atoi(local_18c);
	(rewardItem->ImagePosition).x = iVar2;
	iVar2 = std::atoi(local_188);
	(rewardItem->ImagePosition).y = iVar2;
	image = lego::image::Image_LoadBMPScaled(local_210,0,0);
	rewardItem->Image = image;
	if (image != NULL) {
		lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
		rewardItem->flags = rewardItem->flags | REWARDITEM_IMAGES;
		std::free(pcVar1);
	}
	return;
}



void __cdecl lego::reward::RewardItem_LoadBaseText(RewardFrontEndItem *rewardItem)
{
	RewardItemFlags RVar1;
	char *pcVar2;
	int iVar3;
	char *stringParts [100];
	
	pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Text",rewardItem->name,0);
	pcVar2 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar2);
	if (pcVar2 != NULL) {
		util::Util_Tokenise(pcVar2,stringParts,"|");
		std::sprintf(rewardItem->Text,"%s",stringParts[0]);
		util::stringReplaceChar(rewardItem->Text,'_',' ');
		iVar3 = std::atoi(stringParts[1]);
		(rewardItem->TextPosition).x = iVar3;
		iVar3 = std::atoi(stringParts[2]);
		RVar1 = rewardItem->flags;
		(rewardItem->TextPosition).y = iVar3;
		rewardItem->flags = RVar1 | (REWARDITEM_TEXT_1|REWARDITEM_TEXT_10|REWARDITEM_TEXT_20);
		std::free(pcVar2);
	}
	return;
}



void __cdecl lego::reward::RewardItem_LoadBaseFlics(RewardFrontEndItem *rewardItem)
{
	RewardItemFlags RVar1;
	char *pcVar2;
	int iVar3;
	char reduceName [64];
	char valueBuffer [128];
	char *stringParts [100];
	
	pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Flics",rewardItem->name,0);
	pcVar2 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar2);
	if (pcVar2 == NULL) {
		if ((globs::mainGlobs.flags & CMD_REDUCEFLICS) == CMD_NONE) {
			std::sprintf(reduceName,"!%s",rewardItem->name);
			pcVar2 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Flics",reduceName,0);
			pcVar2 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar2);
		}
		if (pcVar2 == NULL) {
			return;
		}
	}
	util::Util_Tokenise(pcVar2,stringParts,"|");
	std::sprintf(valueBuffer,"%s",stringParts[0]);
	std::sprintf(rewardItem->FlicName,"%s",valueBuffer);
	iVar3 = std::atoi(stringParts[1]);
	(rewardItem->FlicPosition).x = iVar3;
	iVar3 = std::atoi(stringParts[2]);
	(rewardItem->FlicPosition).y = iVar3;
	iVar3 = std::atoi(stringParts[3]);
	(rewardItem->FlicSize).width = iVar3;
	iVar3 = std::atoi(stringParts[4]);
	RVar1 = rewardItem->flags;
	(rewardItem->FlicSize).height = iVar3;
	rewardItem->flags = RVar1 | REWARDITEM_UNK_4;
	std::free(pcVar2);
	return;
}



void __cdecl lego::reward::Reward_CleanupBase(void)
{
	RewardFrontEndItem *rewardItem;
	uint uVar1;
	
	uVar1 = 0;
	do {
		if ((globals::g_RewardFrontBase->items_PTR->name[uVar1 - 4] & REWARDITEM_IMAGES) != 0) {
			RewardItem_CleanupBaseImage
								((RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar1 - 4)));
		}
		rewardItem = (RewardFrontEndItem *)(globals::g_RewardFrontBase->items_PTR->name + (uVar1 - 4));
		if ((*(byte *)&rewardItem->flags & REWARDITEM_TEXT_1) != 0) {
			Reward_CleanupBaseFont(rewardItem);
		}
		uVar1 += 0x210;
	} while (uVar1 < 0x14a0);
	std::free(globals::g_RewardFrontBase);
	return;
}



void __cdecl lego::reward::RewardItem_CleanupBaseImage(RewardFrontEndItem *rewardItem)
{
	lego::image::Image_Remove(rewardItem->Image);
	return;
}



void __cdecl lego::reward::Reward_CleanupBaseFont(RewardFrontEndItem *rewardItem)
{
	lego::image::Font_Remove(rewardItem->Font);
	return;
}



BOOL __cdecl lego::front::Reward_LoadBaseGraphics(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	float10 fVar2;
	uint width;
	uint height;
	char *stringParts [100];
	
	game::GetLevel();
	height = 0;
	width = 0;
	globals::g_Reward_LegoCfgRoot = root;
	globals::g_Reward_CfgRootName = rootPath;
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","Wallpaper",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	globals::g_Reward_Wallpaper = lego::image::Image_LoadBMPScaled(pcVar1,width,height);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","Display",0);
	globals::g_Reward_Display = cfg::CFG_ReadBool(root,pcVar1);
	if (globals::g_Reward_Display == BOOL3_ERROR) {
		globals::g_Reward_Display = 0;
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","CentreText",0);
	globals::g_Reward_CentreText = cfg::CFG_ReadBool(root,pcVar1);
	if (globals::g_Reward_CentreText == BOOL3_ERROR) {
		globals::g_Reward_CentreText = 0;
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","ScrollSpeed",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == NULL) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","ScrollSpeed",0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	}
	fVar2 = std::atof(pcVar1);
	globals::g_Reward_ScrollSpeed = (float)fVar2;
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","VertSpacing",0);
	pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	if (pcVar1 == NULL) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","VertSpacing",0);
		pcVar1 = cfg::CFG_ReadString(root,pcVar1);
	}
	fVar2 = std::atof(pcVar1);
	globals::g_Reward_VertSpacing = (float)fVar2;
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","Font",0);
	globals::g_Reward_Font_filename = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","TitleFont",0);
	globals::g_Reward_TitleFont_filename = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","BackFont",0);
	globals::g_Reward_BackFont_filename = cfg::CFG_CopyString(root,pcVar1);
	globals::g_Reward_Font = lego::image::Font_Load(globals::g_Reward_Font_filename);
	globals::g_Reward_TitleFont = lego::image::Font_Load(globals::g_Reward_TitleFont_filename);
	globals::g_Reward_BackFont = lego::image::Font_Load(globals::g_Reward_BackFont_filename);
	reward::Reward_LoadSaveAdvanceButtons(root,rootPath);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","CompleteText",0);
	globals::g_Reward_CompleteText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","FailedText",0);
	globals::g_Reward_FailedText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","QuitText",0);
	globals::g_Reward_QuitText = cfg::CFG_CopyString(root,pcVar1);
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","TextPos",0);
	pcVar1 = cfg::CFG_CopyString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 != NULL) {
		util::Util_Tokenise(pcVar1,stringParts,"|");
		globals::g_Reward_TextPos.x = std::atoi(stringParts[0]);
		globals::g_Reward_TextPos.y = std::atoi(stringParts[1]);
	}
	return 1;
}



BOOL __cdecl lego::reward::Reward_LoadSaveAdvanceButtons(CFGProperty *root,char *rootPath)
{
	char *pcVar1;
	int iVar2;
	char *parts [100];
	
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","SaveButton",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		util::Util_Tokenise(pcVar1,parts,"|");
		globals::g_Reward_SaveButton = lego::image::Image_LoadBMPScaled(parts[0],0,0);
		if (globals::g_Reward_SaveButton != NULL) {
			globals::g_Reward_SaveButton_hi = lego::image::Image_LoadBMPScaled(parts[1],0,0);
			globals::g_Reward_SaveButton_in = lego::image::Image_LoadBMPScaled(parts[2],0,0);
			globals::g_Reward_SaveButton_dim = lego::image::Image_LoadBMPScaled(parts[3],0,0);
			iVar2 = std::atoi(parts[4]);
			globals::g_Reward_SaveButtonPosition.x = (float)iVar2;
			iVar2 = std::atoi(parts[5]);
			globals::g_Reward_SaveButtonPosition.y = (float)iVar2;
			lego::image::Image_SetupTrans(globals::g_Reward_SaveButton,0.0,0.0,0.0,0.0,0.0,0.0);
			if (globals::g_Reward_SaveButton_hi != NULL) {
				lego::image::Image_SetupTrans(globals::g_Reward_SaveButton_hi,0.0,0.0,0.0,0.0,0.0,0.0);
			}
			if (globals::g_Reward_SaveButton_in != NULL) {
				lego::image::Image_SetupTrans(globals::g_Reward_SaveButton_in,0.0,0.0,0.0,0.0,0.0,0.0);
			}
		}
		std::free(pcVar1);
	}
	pcVar1 = cfg::CFG_JoinPath(rootPath,"Reward","AdvanceButton",0);
	pcVar1 = cfg::CFG_CopyString(root,pcVar1);
	if (pcVar1 != NULL) {
		util::Util_Tokenise(pcVar1,parts,"|");
		globals::g_Reward_AdvanceButton = lego::image::Image_LoadBMPScaled(parts[0],0,0);
		if (globals::g_Reward_AdvanceButton != NULL) {
			globals::g_Reward_AdvanceButton_hi = lego::image::Image_LoadBMPScaled(parts[1],0,0);
			globals::g_Reward_AdvanceButton_in = lego::image::Image_LoadBMPScaled(parts[2],0,0);
			globals::g_Reward_AdvanceButton_dim = lego::image::Image_LoadBMPScaled(parts[3],0,0);
			iVar2 = std::atoi(parts[4]);
			globals::g_Reward_AdvanceButtonPosition.x = (float)iVar2;
			iVar2 = std::atoi(parts[5]);
			globals::g_Reward_AdvanceButtonPosition.y = (float)iVar2;
			lego::image::Image_SetupTrans(globals::g_Reward_AdvanceButton,0.0,0.0,0.0,0.0,0.0,0.0);
			if (globals::g_Reward_AdvanceButton_hi != NULL) {
				lego::image::Image_SetupTrans(globals::g_Reward_AdvanceButton_hi,0.0,0.0,0.0,0.0,0.0,0.0);
			}
			if (globals::g_Reward_AdvanceButton_in != NULL) {
				lego::image::Image_SetupTrans(globals::g_Reward_AdvanceButton_in,0.0,0.0,0.0,0.0,0.0,0.0);
			}
		}
		std::free(pcVar1);
	}
	if ((globals::g_Reward_SaveButton != NULL) && (globals::g_Reward_AdvanceButton != NULL)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::reward::Reward_LoadLevelFrontEnd(void)
{
	int iVar1;
	LevelData *pLVar2;
	char *pcVar3;
	BOOL3 BVar4;
	uint uVar5;
	int iVar6;
	int iVar7;
	undefined4 *puVar8;
	RewardFrontEnd *pRVar9;
	undefined4 *puVar10;
	float10 fVar11;
	
	pLVar2 = game::GetLevel();
	globals::g_RewardFrontLevel = (RewardFrontEnd *)std::malloc(0x318c);
	pRVar9 = globals::g_RewardFrontLevel;
										// std:::memset(_, 0, 0x318c);
	for (iVar6 = 0xc63; iVar6 != 0; iVar6 += -1) {
		pRVar9->Enabled = 0;
		pRVar9 = (RewardFrontEnd *)&pRVar9->field_0x4;
	}
	pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,pLVar2->levelName,"Reward","Enable",0);
	BVar4 = cfg::CFG_ReadBool(globals::g_Reward_LegoCfgRoot,pcVar3);
	globals::g_RewardFrontLevel->Enabled = BVar4;
	if (globals::g_RewardFrontLevel->Enabled == 2) {
		globals::g_RewardFrontLevel->Enabled = 0;
	}
	pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,pLVar2->levelName,"Reward","Modifier",0);
	pcVar3 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar3);
	if (pcVar3 == NULL) {
		pcVar3 = ____EMPTYSTR__;
	}
	else {
		pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,pLVar2->levelName,"Reward","Modifier",0
															);
		pcVar3 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar3);
	}
	iVar6 = std::atoi(pcVar3);
	globals::g_RewardFrontLevel->Modifier = iVar6;
	pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Timer",0);
	pcVar3 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar3);
	if (pcVar3 == NULL) {
		pcVar3 = ____EMPTYSTR__;
	}
	else {
		pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","Timer",0);
		pcVar3 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar3);
	}
	fVar11 = std::atof(pcVar3);
	globals::g_Reward_Timer = (float)fVar11;
	if ((float10)0.0 == fVar11) {
		globals::g_Reward_Timer = 76.9375;
	}
	pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","DisplayText",0);
	globals::g_Reward_DisplayText = cfg::CFG_ReadBool(globals::g_Reward_LegoCfgRoot,pcVar3);
	if (globals::g_Reward_DisplayText == BOOL3_ERROR) {
		globals::g_Reward_DisplayText = 1;
	}
	pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","DisplayImages",0);
	globals::g_Reward_DisplayImages = cfg::CFG_ReadBool(globals::g_Reward_LegoCfgRoot,pcVar3);
	if (globals::g_Reward_DisplayImages == BOOL3_ERROR) {
		globals::g_Reward_DisplayImages = 1;
	}
	pcVar3 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,"Reward","DisplayFlics",0);
	globals::g_Reward_DisplayFlics = cfg::CFG_ReadBool(globals::g_Reward_LegoCfgRoot,pcVar3);
	if (globals::g_Reward_DisplayFlics == BOOL3_ERROR) {
		globals::g_Reward_DisplayFlics = 1;
	}
	globals::g_RewardFrontLevel->items_PTR = globals::g_RewardFrontLevel->items_TABLE;
	uVar5 = 0;
	globals::g_RewardFrontLevel->items_COUNT = 10;
	do {
		iVar6 = uVar5 - 4;
		iVar1 = uVar5 - 4;
		uVar5 += 0x210;
		puVar8 = (undefined4 *)(globals::g_RewardFrontBase->items_PTR->name + iVar6);
		puVar10 = (undefined4 *)(globals::g_RewardFrontLevel->items_PTR->name + iVar1);
		for (iVar7 = 0x84; iVar7 != 0; iVar7 += -1) {
			*puVar10 = *puVar8;
			puVar8 = puVar8 + 1;
			puVar10 = puVar10 + 1;
		}
	} while (uVar5 < 0x14a0);
	uVar5 = 0;
	do {
		RewardItem_LoadLevelImportance
							((RewardFrontEndItem *)(globals::g_RewardFrontLevel->items_PTR->name + (uVar5 - 4)));
		uVar5 += 0x210;
	} while (uVar5 < 0x14a0);
	uVar5 = 0;
	do {
		RewardItem_LoadLevelQuota
							((RewardFrontEndItem *)(globals::g_RewardFrontLevel->items_PTR->name + (uVar5 - 4)));
		uVar5 += 0x210;
	} while (uVar5 < 0x14a0);
										// HARDCODED: Set Caverns::Quota = 1, for Level03 ("Rubble Trouble!")
	iVar6 = std::_stricmp(pLVar2->levelName,"Levels::Level03");
	if (iVar6 == 0) {
		globals::g_RewardFrontLevel->items_PTR[4].Quota = 1;
	}
	return 1;
}



void __cdecl lego::reward::RewardItem_LoadLevelImportance(RewardFrontEndItem *rewardItem)
{
	LevelData *level;
	char *pcVar1;
	float10 fVar2;
	
	level = game::GetLevel();
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,level->levelName,"Reward","Importance",
														 rewardItem->name,0);
	pcVar1 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 != NULL) {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,level->levelName,"Reward","Importance",
															 rewardItem->name,0);
		pcVar1 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar1);
		fVar2 = std::atof(pcVar1);
		rewardItem->Importance = (float)fVar2;
		return;
	}
	fVar2 = std::atof(____EMPTYSTR__);
	rewardItem->Importance = (float)fVar2;
	return;
}



void __cdecl lego::reward::RewardItem_LoadLevelQuota(RewardFrontEndItem *rewardItem)
{
	LevelData *level;
	char *pcVar1;
	int iVar2;
	
	level = game::GetLevel();
	pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,level->levelName,"Reward","Quota",
														 rewardItem->name,0);
	pcVar1 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar1);
	if (pcVar1 != NULL) {
		pcVar1 = cfg::CFG_JoinPath(globals::g_Reward_CfgRootName,level->levelName,"Reward","Quota",
															 rewardItem->name,0);
		pcVar1 = cfg::CFG_ReadString(globals::g_Reward_LegoCfgRoot,pcVar1);
		iVar2 = std::atoi(pcVar1);
		rewardItem->Quota = iVar2;
		return;
	}
	iVar2 = std::atoi(____EMPTYSTR__);
	rewardItem->Quota = iVar2;
	return;
}



void __cdecl lego::reward::RewardFrontEnd_Free(void)
{
	std::free(globals::g_RewardFrontLevel);
	return;
}



RewardFrontEnd * __cdecl lego::reward::GetRewardFrontEnd(undefined4 unused_levelField10)
{
	return globals::g_RewardFrontLevel;
}



// No different from above (GetRewardFrontEnd(undefined4))

RewardFrontEnd * __cdecl lego::reward::GetCurrentRewardFrontEnd(void)
{
	LevelData *pLVar1;
	RewardFrontEnd *pRVar2;
	
	pLVar1 = game::GetLevel();
	if (pLVar1 == NULL) {
		return NULL;
	}
	pRVar2 = GetRewardFrontEnd(pLVar1->field_10);
	return pRVar2;
}



void __cdecl lego::unk::lego::reward::Reward_UnkLevelImportantPilot_FUN_004604e0(void)
{
	LevelData *pLVar1;
	RewardFrontEnd *pRVar2;
	undefined4 *puVar3;
	int iVar4;
	undefined4 *puVar5;
	undefined4 local_198 [102];
	
	pLVar1 = game::GetLevel();
	if (pLVar1 == NULL) {
		return;
	}
	pRVar2 = lego::reward::GetRewardFrontEnd(pLVar1->field_10);
	if (pRVar2 == NULL) {
		return;
	}
	puVar3 = (undefined4 *)lego::reward::Reward_FUN_00460550(local_198);
	puVar5 = UNKSTRUCT_198_005539c4;
	for (iVar4 = 0x66; iVar4 != 0; iVar4 += -1) {
		*puVar5 = *puVar3;
		puVar3 = puVar3 + 1;
		puVar5 = puVar5 + 1;
	}
	UINT_00556118 = nerps::NERPs_Game_GetPilotPreviousLevel("Pilot",0);
	return;
}



undefined4 * __cdecl lego::reward::Reward_FUN_00460550(undefined4 *param_1)
{
	uint uVar1;
	int iVar2;
	uint objLevel;
	undefined4 *puVar3;
	uint objIndex;
	undefined4 *puVar4;
	undefined4 local_198 [100];
	undefined4 local_8;
	int local_4;
	
	local_8 = 0;
	game::Search_LiveObjects_SkipIgnoreMes(Reward_Callback_FUN_004605d0,local_198);
	local_4 = 0;
	objIndex = 0;
	do {
		objLevel = 0;
		do {
			uVar1 = game::LiveObject_GetPreviousLevel(OBJECT_BUILDING,objIndex,objLevel);
			objLevel += 1;
			local_4 = local_4 + uVar1;
		} while (objLevel < 0x10);
		objIndex += 1;
	} while (objIndex < 0xf);
	puVar3 = local_198;
	puVar4 = param_1;
	for (iVar2 = 0x66; iVar2 != 0; iVar2 += -1) {
		*puVar4 = *puVar3;
		puVar3 = puVar3 + 1;
		puVar4 = puVar4 + 1;
	}
	return param_1;
}



BOOL __cdecl lego::reward::Reward_Callback_FUN_004605d0(LiveObject *liveObj,int param_2)
{
	char *pcVar1;
	int local_4;
	
	game::LiveObject_GetTypeIndex(liveObj,(int *)&liveObj,&local_4);
	if (liveObj == (LiveObject *)&DAT_00000004) {
		pcVar1 = game::Object_GetTypeName(OBJECT_BUILDING,local_4);
		*(char **)(param_2 + *(int *)(param_2 + 400) * 4) = pcVar1;
		*(int *)(param_2 + 400) = *(int *)(param_2 + 400) + 1;
	}
	return 0;
}



BOOL __cdecl lego::reward::Reward_FUN_00460620(void)
{
	undefined *puVar1;
	TerrainType TVar2;
	float fVar3;
	int iVar4;
	int iVar5;
	LevelData *pLVar6;
	RewardFrontEnd *pRVar7;
	SurfaceMap *pSVar8;
	int iVar9;
	ImageBMP *pIVar10;
	uint uVar11;
	undefined4 *puVar12;
	IDirectDrawSurface4 **ppIVar13;
	undefined4 *puVar14;
	uint uVar15;
	char *pcVar16;
	float10 fVar17;
	ulonglong uVar18;
	uint local_30;
	uint local_28;
	uint local_24;
	int local_20;
	int local_1c;
	Point2I local_18;
	uint local_10;
	undefined4 uStack12;
	uint local_8;
	undefined4 uStack4;
	
	pLVar6 = game::GetLevel();
	if (pLVar6 == NULL) {
		return 0;
	}
	pRVar7 = GetRewardFrontEnd(pLVar6->field_10);
	if (pRVar7 != NULL) {
		if (globals::g_Save_HasCapture != 0) {
			pIVar10 = &globals::g_Save_CaptureBMP;
			ppIVar13 = (IDirectDrawSurface4 **)&pRVar7->field_0x8;
			for (iVar9 = 8; iVar9 != 0; iVar9 += -1) {
				*ppIVar13 = pIVar10->surface;
				pIVar10 = (ImageBMP *)&pIVar10->width;
				ppIVar13 = ppIVar13 + 1;
			}
			*(undefined4 *)&pRVar7->field_0x4 = 1;
		}
		*(undefined4 *)&pRVar7->items_TABLE[0].field_0x30 = 0;
		*(undefined4 *)&pRVar7->items_TABLE[1].field_0x30 = 0;
		*(float *)&pRVar7->items_TABLE[2].field_0x34 = FLOAT_00555adc;
		*(float *)&pRVar7->items_TABLE[4].field_0x34 = FLOAT_00555efc;
		*(undefined4 *)&pRVar7->items_TABLE[2].field_0x30 = 0;
		*(undefined4 *)&pRVar7->field_0x1b04 = 0;
		*(undefined4 *)&pRVar7->field_0x1b08 = 0;
		iVar9 = Reward_FUN_00460bd0("Pilot",0,0);
		*(int *)&pRVar7->items_TABLE[5].field_0x3c = iVar9;
		*(uint *)&pRVar7->items_TABLE[5].field_0x40 = UINT_00556118;
		*(float *)&pRVar7->items_TABLE[5].field_0x48 = FLOAT_00556120;
		uVar15 = globals::g_NERPs_RockMonstersGenerated;
		*(uint *)&pRVar7->items_TABLE[6].field_0x3c = globals::g_NERPs_RockMonstersGenerated;
		*(int *)&pRVar7->items_TABLE[6].field_0x40 = globals::nerps::g_NERPs_RockMonstersDestroyed;
		fVar3 = (float)(ulonglong)(uVar15 * 100);
		if ((ushort)((ushort)(FLOAT_00556330 < fVar3) << 8 | (ushort)(FLOAT_00556330 == fVar3) << 0xe)
				!= 0) {
			fVar3 = FLOAT_00556330;
		}
		*(float *)&pRVar7->items_TABLE[6].field_0x48 = fVar3;
		*(uint *)&pRVar7->items_TABLE[6].field_0x44 = UINT_0055632c;
		puVar12 = UNKSTRUCT_198_005539c4;
		puVar14 = (undefined4 *)&pRVar7->field_0x28;
		for (iVar9 = 0x66; iVar9 != 0; iVar9 += -1) {
			*puVar14 = *puVar12;
			puVar12 = puVar12 + 1;
			puVar14 = puVar14 + 1;
		}
		uVar15 = 0;
		*(undefined4 *)&pRVar7->field_0x1c8 = 0;
		fVar3 = (globs::gameGlobs.level)->oxygenLevel;
		*(undefined **)&pRVar7->items_TABLE[7].field_0x30 = &DAT_42c80000;
		*(float *)&pRVar7->items_TABLE[7].field_0x34 = fVar3;
		*(float *)&pRVar7->items_TABLE[8].field_0x34 = FLOAT_0055673c;
		*(float *)&pRVar7->items_TABLE[8].field_0x30 =
				 FLOAT_00556738 / *(float *)&pRVar7->items_TABLE[8].field_0x34;
		pSVar8 = pLVar6->surfaceMap;
		if ((pSVar8->smallDimensions).width != 0) {
			do {
				uVar11 = 0;
				if ((pSVar8->smallDimensions).height != 0) {
					do {
						TVar2 = pLVar6->blocks[uVar11 * (pLVar6->dimensions).width + uVar15].terrain;
						*(int *)&pRVar7->field_0x1c8 = *(int *)&pRVar7->field_0x1c8 + 1;
						local_18.x = uVar15;
						local_18.y = uVar11;
						game::Level_GetBlockCryOre
											(&local_18,(int *)&local_28,&local_1c,(int *)&local_24,&local_20);
						local_10 = local_28;
						uStack12 = 0;
						uStack4 = 0;
						*(float *)&pRVar7->items_TABLE[0].field_0x30 =
								 (float)(ulonglong)local_28 + *(float *)&pRVar7->items_TABLE[0].field_0x30;
						local_8 = local_24;
						*(float *)&pRVar7->items_TABLE[1].field_0x30 =
								 (float)(ulonglong)local_24 + *(float *)&pRVar7->items_TABLE[1].field_0x30;
						if ((*(byte *)&pLVar6->blocks[uVar11 * (pLVar6->dimensions).width + uVar15].flags1 & 8)
								== 0) {
							if (TVar2 != TERRAIN_IMMOVABLE) {
								*(float *)&pRVar7->items_TABLE[2].field_0x30 =
										 *(float *)&pRVar7->items_TABLE[2].field_0x30 - -1.0;
								*(float *)&pRVar7->field_0x1b04 = *(float *)&pRVar7->field_0x1b04 - -1.0;
							}
							if (TVar2 == TERRAIN_CRYSTALSEAM) {
								*(float *)&pRVar7->items_TABLE[0].field_0x30 =
										 *(float *)&pRVar7->items_TABLE[0].field_0x30 - -4.0;
							}
						}
						else {
							if ((TVar2 != TERRAIN_WATER_unused) && (TVar2 != TERRAIN_LAVA)) {
								*(float *)&pRVar7->field_0x1b04 = *(float *)&pRVar7->field_0x1b04 - -1.0;
							}
						}
						if ((pLVar6->blocks[uVar11 * (pLVar6->dimensions).width + uVar15].flags1 & 0x61100000)
								!= BLOCK1_NONE) {
							*(float *)&pRVar7->field_0x1b08 = *(float *)&pRVar7->field_0x1b08 - -1.0;
							*(float *)&pRVar7->items_TABLE[2].field_0x30 =
									 *(float *)&pRVar7->items_TABLE[2].field_0x30 - -1.0;
						}
						uVar11 += 1;
					} while (uVar11 < (uint)(pLVar6->surfaceMap->smallDimensions).height);
				}
				pSVar8 = pLVar6->surfaceMap;
				uVar15 += 1;
			} while (uVar15 < (uint)(pSVar8->smallDimensions).width);
		}
		fVar3 = *(float *)&pRVar7->items_TABLE[2].field_0x30;
		iVar9 = *(int *)&pRVar7->field_0x1b8;
		*(int *)&pRVar7->field_0x1cc = iVar9;
		*(undefined4 *)&pRVar7->field_0x1d0 = *(undefined4 *)&pRVar7->field_0x1bc;
		local_30 = 0;
		*(float *)&pRVar7->items_TABLE[1].field_0x30 =
				 *(float *)&pRVar7->items_TABLE[1].field_0x30 - fVar3 * -4.0;
		if (iVar9 != 0) {
			pcVar16 = (char *)&pRVar7->field_0x1d4;
			puVar12 = (undefined4 *)&pRVar7->field_0x28;
			do {
				std::sprintf(pcVar16,"%s",*puVar12);
				local_30 += 1;
				puVar12 = puVar12 + 1;
				pcVar16 = pcVar16 + 0x40;
			} while (local_30 < *(uint *)&pRVar7->field_0x1cc);
		}
		uVar15 = *(uint *)&pRVar7->items_TABLE[5].field_0x3c;
		iVar9 = *(int *)&pRVar7->field_0x1d0;
		*(float *)&pRVar7->items_TABLE[0].field_0x34 = (float)(ulonglong)(uint)pLVar6->numCrystals;
		iVar4 = *(int *)&pRVar7->items_TABLE[5].field_0x40;
		*(float *)&pRVar7->items_TABLE[1].field_0x34 = (float)(ulonglong)(uint)pLVar6->numOre;
		iVar5 = *(int *)&pRVar7->items_TABLE[6].field_0x3c;
		*(float *)&pRVar7->items_TABLE[5].field_0x30 = (float)(ulonglong)uVar15;
		*(float *)&pRVar7->items_TABLE[5].field_0x34 = (float)(ulonglong)(uVar15 - iVar4);
		*(undefined4 *)&pRVar7->items_TABLE[6].field_0x34 =
				 *(undefined4 *)&pRVar7->items_TABLE[6].field_0x48;
		uVar15 = *(uint *)&pRVar7->field_0x1cc;
		*(float *)&pRVar7->items_TABLE[6].field_0x30 = (float)(ulonglong)(uint)(iVar5 * 100);
		uVar11 = (uVar15 - iVar9) + 1;
		local_8 = pRVar7->items_TABLE[8].Quota;
		*(float *)&pRVar7->items_TABLE[3].field_0x30 = (float)(ulonglong)uVar15;
		*(float *)&pRVar7->items_TABLE[3].field_0x34 = (float)(ulonglong)uVar11;
		if (local_8 == 0) {
			*(undefined4 *)&pRVar7->items_TABLE[8].field_0x38 = 0;
			local_8 = uVar11;
		}
		else {
			fVar17 = (float10)*(float *)&pRVar7->items_TABLE[8].field_0x34 * (float10)0.04;
			uStack4 = 0;
			if ((float10)(ulonglong)local_8 <= fVar17) {
				*(undefined **)&pRVar7->items_TABLE[8].field_0x38 = &DAT_42c80000;
			}
			else {
				uVar18 = __ftol(((float10)100.0 / (float10)(ulonglong)local_8) * fVar17);
				*(float *)&pRVar7->items_TABLE[8].field_0x38 = (float)(uVar18 & 0xffffffff);
				fVar3 = *(float *)&pRVar7->items_TABLE[8].field_0x38;
				if ((ushort)((ushort)(fVar3 < 100.0) << 8 | (ushort)(fVar3 == 100.0) << 0xe) == 0) {
					puVar1 = &DAT_42c80000;
				}
				else {
					puVar1 = *(undefined **)&pRVar7->items_TABLE[8].field_0x38;
				}
				*(undefined **)&pRVar7->items_TABLE[8].field_0x38 = puVar1;
				if ((float)puVar1 < 0.0) {
					puVar1 = NULL;
				}
				*(undefined **)&pRVar7->items_TABLE[8].field_0x38 = puVar1;
				local_8 = (uint)uVar18;
			}
		}
		uVar15 = pRVar7->items_TABLE[3].Quota;
		if (uVar15 != 0) {
			uVar18 = 100 / (ulonglong)uVar15;
			local_8 = (uint)uVar18;
			*(float *)&pRVar7->items_TABLE[3].field_0x38 =
					 (float)uVar18 * *(float *)&pRVar7->items_TABLE[3].field_0x34;
		}
		uVar15 = pRVar7->items_TABLE[4].Quota;
		if (uVar15 != 0) {
			uVar18 = 100 / (ulonglong)uVar15;
			local_8 = (uint)uVar18;
			*(float *)&pRVar7->items_TABLE[4].field_0x38 =
					 (float)uVar18 * *(float *)&pRVar7->items_TABLE[4].field_0x34;
		}
		uVar15 = pRVar7->items_TABLE[0].Quota;
		if (uVar15 != 0) {
			*(float *)&pRVar7->items_TABLE[0].field_0x30 = (float)(ulonglong)uVar15;
			local_8 = uVar15;
		}
		uStack4 = 0;
		uVar15 = 0;
		do {
			if (uVar15 != 0x1080) {
				pcVar16 = pRVar7->items_PTR->name + (uVar15 - 4);
				if ((ushort)((ushort)(*(float *)(pcVar16 + 0x38) < 100.0) << 8 |
										(ushort)(*(float *)(pcVar16 + 0x38) == 100.0) << 0xe) == 0) {
					puVar1 = &DAT_42c80000;
				}
				else {
					puVar1 = *(undefined **)(pcVar16 + 0x38);
				}
				*(undefined **)(pcVar16 + 0x38) = puVar1;
				if ((float)puVar1 < 0.0) {
					puVar1 = NULL;
				}
				*(undefined **)(pcVar16 + 0x38) = puVar1;
			}
			uVar15 += 0x210;
		} while (uVar15 < 0x14a0);
		Reward_FUN_00460c10();
		Reward_FUN_004611c0();
		puVar12 = &DATSTRUCT_318c_0055399c;
		for (iVar9 = 0xc63; iVar9 != 0; iVar9 += -1) {
			*puVar12 = 0;
			puVar12 = puVar12 + 1;
		}
		return 1;
	}
	return 0;
}



int __cdecl lego::reward::Reward_FUN_00460bd0(char *param_1,int param_2,int param_3)
{
	BOOL BVar1;
	int iVar2;
	ObjectType local_4;
	
	BVar1 = game::Object_GetObjectByName(param_1,&local_4,(int *)&param_1,NULL);
	if (BVar1 != 0) {
		iVar2 = game::LiveObject_GetOrSubLevelsTable(local_4,(int)param_1,param_2,param_3);
		return iVar2;
	}
	return 0;
}



BOOL __cdecl lego::reward::Reward_FUN_00460c10(void)
{
	float fVar1;
	float fVar2;
	float fVar3;
	undefined *puVar4;
	LevelData *pLVar5;
	RewardFrontEnd *pRVar6;
	uint uVar7;
	
	pLVar5 = game::GetLevel();
	if (pLVar5 == NULL) {
		return 0;
	}
	pRVar6 = GetRewardFrontEnd(pLVar5->field_10);
	if (pRVar6 == NULL) {
		return 0;
	}
	*(undefined4 *)&pRVar6->items_TABLE[9].field_0x34 = 0;
	*(undefined4 *)&pRVar6->items_TABLE[9].field_0x30 = 0;
	*(undefined4 *)&pRVar6->items_TABLE[9].field_0x38 = 0;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[0].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[0].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[0].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[0].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[0].field_0x38 = puVar4;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[1].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[1].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[1].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[1].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[1].field_0x38 = puVar4;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[2].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[2].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[2].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[2].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[2].field_0x38 = puVar4;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->field_0x1b04 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->field_0x1b04) * *(float *)&pRVar6->field_0x1b08);
	}
	*(undefined **)&pRVar6->field_0x1b0c = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->field_0x1b0c = puVar4;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[7].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[7].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[7].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[7].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[7].field_0x38 = puVar4;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[3].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[3].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[3].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[3].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[3].field_0x38 = puVar4;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[5].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[5].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[5].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[5].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[5].field_0x38 = puVar4;
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[6].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[6].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[6].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[6].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[6].field_0x38 = puVar4;
	uVar7 = 0;
	if (0.0 < pRVar6->items_TABLE[5].Importance) {
		do {
			uVar7 += 1;
			fVar1 = *(float *)&pRVar6->items_TABLE[5].field_0x38;
			fVar2 = pRVar6->items_TABLE[5].Importance;
			fVar3 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
			*(float *)&pRVar6->items_TABLE[9].field_0x30 =
					 *(float *)&pRVar6->items_TABLE[9].field_0x30 - -100.0;
			*(float *)&pRVar6->items_TABLE[9].field_0x34 = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items_TABLE[0].Importance) {
		do {
			uVar7 += 1;
			fVar1 = *(float *)&pRVar6->items_TABLE[0].field_0x38;
			fVar2 = pRVar6->items_TABLE[0].Importance;
			fVar3 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
			*(float *)&pRVar6->items_TABLE[9].field_0x30 =
					 *(float *)&pRVar6->items_TABLE[9].field_0x30 - -100.0;
			*(float *)&pRVar6->items_TABLE[9].field_0x34 = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items_TABLE[7].Importance) {
		do {
			uVar7 += 1;
			fVar1 = *(float *)&pRVar6->items_TABLE[7].field_0x38;
			fVar2 = pRVar6->items_TABLE[7].Importance;
			fVar3 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
			*(float *)&pRVar6->items_TABLE[9].field_0x30 =
					 *(float *)&pRVar6->items_TABLE[9].field_0x30 - -100.0;
			*(float *)&pRVar6->items_TABLE[9].field_0x34 = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items_TABLE[3].Importance) {
		do {
			uVar7 += 1;
			fVar1 = *(float *)&pRVar6->items_TABLE[3].field_0x38;
			fVar2 = pRVar6->items_TABLE[3].Importance;
			fVar3 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
			*(float *)&pRVar6->items_TABLE[9].field_0x30 =
					 *(float *)&pRVar6->items_TABLE[9].field_0x30 - -100.0;
			*(float *)&pRVar6->items_TABLE[9].field_0x34 = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items_TABLE[4].Importance) {
		do {
			uVar7 += 1;
			fVar1 = *(float *)&pRVar6->items_TABLE[4].field_0x38;
			fVar2 = pRVar6->items_TABLE[4].Importance;
			fVar3 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
			*(float *)&pRVar6->items_TABLE[9].field_0x30 =
					 *(float *)&pRVar6->items_TABLE[9].field_0x30 - -100.0;
			*(float *)&pRVar6->items_TABLE[9].field_0x34 = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items_TABLE[8].Importance) {
		fVar1 = *(float *)&pRVar6->items_TABLE[9].field_0x30;
		fVar2 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
		do {
			uVar7 += 1;
			fVar1 = fVar1 - -100.0;
			fVar2 = (100.0 - *(float *)&pRVar6->items_TABLE[8].field_0x38) + fVar2;
		} while ((float)(ulonglong)uVar7 < pRVar6->items_TABLE[8].Importance);
		*(float *)&pRVar6->items_TABLE[9].field_0x34 = fVar2;
		*(float *)&pRVar6->items_TABLE[9].field_0x30 = fVar1;
	}
	uVar7 = 0;
	if (0.0 < pRVar6->items_TABLE[6].Importance) {
		do {
			uVar7 += 1;
			fVar1 = *(float *)&pRVar6->items_TABLE[6].field_0x38;
			fVar2 = pRVar6->items_TABLE[6].Importance;
			fVar3 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
			*(float *)&pRVar6->items_TABLE[9].field_0x30 =
					 *(float *)&pRVar6->items_TABLE[9].field_0x30 - -100.0;
			*(float *)&pRVar6->items_TABLE[9].field_0x34 = fVar1 + fVar3;
		} while ((float)(ulonglong)uVar7 < fVar2);
	}
	fVar1 = *(float *)&pRVar6->items_TABLE[9].field_0x34;
	fVar2 = *(float *)&pRVar6->items_TABLE[9].field_0x30;
	if ((ushort)((ushort)(fVar1 < fVar2) << 8 | (ushort)(fVar1 == fVar2) << 0xe) == 0) {
		*(undefined4 *)&pRVar6->items_TABLE[9].field_0x34 =
				 *(undefined4 *)&pRVar6->items_TABLE[9].field_0x30;
	}
	if (*(float *)&pRVar6->items_TABLE[9].field_0x34 < 0.0) {
		*(undefined4 *)&pRVar6->items_TABLE[9].field_0x34 = 0;
	}
	puVar4 = &DAT_42c80000;
	if (*(float *)&pRVar6->items_TABLE[9].field_0x30 != 0.0) {
		puVar4 = (undefined *)
						 ((100.0 / *(float *)&pRVar6->items_TABLE[9].field_0x30) *
						 *(float *)&pRVar6->items_TABLE[9].field_0x34);
	}
	*(undefined **)&pRVar6->items_TABLE[9].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[9].field_0x38 = puVar4;
	puVar4 = (undefined *)
					 ((float)(ulonglong)(uint)pRVar6->Modifier + *(float *)&pRVar6->items_TABLE[9].field_0x38)
	;
	*(undefined **)&pRVar6->items_TABLE[9].field_0x38 = puVar4;
	if ((ushort)((ushort)((float)puVar4 < 100.0) << 8 | (ushort)((float)puVar4 == 100.0) << 0xe) == 0)
	{
		puVar4 = &DAT_42c80000;
	}
	*(undefined **)&pRVar6->items_TABLE[9].field_0x38 = puVar4;
	return 1;
}



BOOL __cdecl lego::reward::Reward_FUN_004611c0(void)
{
	LevelCompleteStatus LVar1;
	float fVar2;
	float fVar3;
	LevelData *level;
	RewardFrontEnd *rewardFront;
	char *pcVar4;
	
	fVar2 = (float)globs::mainGlobs.appHeight;
	fVar3 = (float)globs::mainGlobs.appWidth;
	level = game::GetLevel();
	if (level == NULL) {
		return 0;
	}
	rewardFront = GetRewardFrontEnd(level->field_10);
	if (rewardFront != NULL) {
		Reward_FUN_00461330();
		Reward_CreateStruct28
							(&REWARDSTRUCT28_00556b5c,0,fVar2 * 0.05,fVar3,fVar2 - fVar2 * 0.2857143,
							 globals::g_Reward_ScrollSpeed);
		Reward_Struct_SetFloat18(REWARDSTRUCT28_00556b5c,400.0);
		Reward_Struct_OrFlags24(REWARDSTRUCT28_00556b5c,0);
		front::Reward_FUN_00462c90
							(REWARDSTRUCT28_00556b5c,level->FullName,globals::g_Reward_TitleFont,0,
							 (int)((float)globs::mainGlobs.appHeight * 0.04),3);
		LVar1 = level->status;
		pcVar4 = globals::g_Reward_CompleteText;
		if (((LVar1 == LEVELSTATUS_COMPLETE) ||
				(pcVar4 = globals::g_Reward_FailedText, LVar1 == LEVELSTATUS_FAILED)) ||
			 (pcVar4 = globals::g_Reward_QuitText, LVar1 == LEVELSTATUS_FAILED_CRYSTALS)) {
			pcVar4 = util::Util_RemoveUnderscores(pcVar4);
			std::sprintf(globals::g_LevelStatusMessage_text,"%s",pcVar4);
		}
		front::Reward_FUN_00462c90
							(REWARDSTRUCT28_00556b5c,globals::g_LevelStatusMessage_text,globals::g_Reward_Font,0,
							 (int)globals::g_Reward_VertSpacing,1);
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::reward::Reward_FUN_00461330(void)
{
	char cVar1;
	undefined4 uVar2;
	LevelData *pLVar3;
	RewardFrontEnd *pRVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	undefined4 *puVar9;
	char *pcVar10;
	char *pcVar11;
	undefined4 *puVar12;
	float10 fVar13;
	longlong lVar14;
	ulonglong uVar15;
	char *pcVar16;
	undefined **format;
	char local_100 [128];
	char local_80 [128];
	
	pLVar3 = game::GetLevel();
	if (pLVar3 == NULL) {
		return 0;
	}
	pRVar4 = GetRewardFrontEnd(pLVar3->field_10);
	if (pRVar4 == NULL) {
		return 0;
	}
	lVar14 = __ftol((float10)*(float *)&pRVar4->items_TABLE[0].field_0x38);
	*(int *)&pRVar4->items_TABLE[0].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[0].Text + 0x80,"%d%%%%",(int)lVar14);
	lVar14 = __ftol((float10)*(float *)&pRVar4->items_TABLE[1].field_0x38);
	*(int *)&pRVar4->items_TABLE[1].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[1].Text + 0x80,"%d%%%%",(int)lVar14);
	lVar14 = __ftol((float10)*(float *)&pRVar4->items_TABLE[2].field_0x38);
	*(int *)&pRVar4->items_TABLE[2].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[2].Text + 0x80,"%d%%%%",(int)lVar14);
	lVar14 = __ftol((float10)*(float *)&pRVar4->field_0x1b0c);
	*(int *)&pRVar4->field_0x1b24 = (int)lVar14;
	std::sprintf((char *)&pRVar4->field_0x1ba8,"%d",(int)lVar14);
	uVar2 = *(undefined4 *)&pRVar4->field_0x1cc;
	*(undefined4 *)&pRVar4->items_TABLE[3].field_0x50 = uVar2;
	std::sprintf(pRVar4->items_TABLE[3].Text + 0x80,"%d",uVar2);
	lVar14 = __ftol((float10)*(float *)&pRVar4->items_TABLE[4].field_0x38);
	*(int *)&pRVar4->items_TABLE[4].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[4].Text + 0x80,"%d%%%%",(int)lVar14);
	lVar14 = __ftol((float10)*(float *)&pRVar4->items_TABLE[5].field_0x38);
	*(int *)&pRVar4->items_TABLE[5].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[5].Text + 0x80,"%d%%%%",(int)lVar14);
	if (100.0 <= *(float *)&pRVar4->items_TABLE[6].field_0x48) {
		fVar13 = (float10)100.0;
	}
	else {
		fVar13 = (float10)*(float *)&pRVar4->items_TABLE[6].field_0x48;
	}
	lVar14 = __ftol(fVar13);
	*(int *)&pRVar4->items_TABLE[6].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[6].Text + 0x80,"%d%%%%",(int)lVar14);
	lVar14 = __ftol((float10)*(float *)&pRVar4->items_TABLE[7].field_0x38);
	*(int *)&pRVar4->items_TABLE[7].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[7].Text + 0x80,"%d%%%%",(int)lVar14);
	uVar15 = __ftol((float10)*(float *)&pRVar4->items_TABLE[8].field_0x34 *
									(float10)*(float *)&pRVar4->items_TABLE[8].field_0x30 * (float10)0.04);
	*(int *)&pRVar4->items_TABLE[8].field_0x50 = (int)uVar15;
	uVar6 = (uint)((uVar15 & 0xffffffff) % 359999);
	std::sprintf(local_80,____EMPTYSTR__);
	if (uVar6 < 0xe11) {
		pcVar16 = "00:";
	}
	else {
		uVar7 = (uVar6 - 1) / 0xe10;
		uVar8 = uVar7;
		do {
			uVar6 -= 0xe10;
			uVar8 -= 1;
		} while (uVar8 != 0);
		if (uVar7 < 10) {
			pcVar16 = "0%d:";
		}
		else {
			pcVar16 = "%d:";
		}
		std::sprintf(local_100,pcVar16,uVar7);
		pcVar16 = local_100;
	}
	uVar8 = 0xffffffff;
	do {
		pcVar10 = pcVar16;
		if (uVar8 == 0) break;
		uVar8 -= 1;
		pcVar10 = pcVar16 + 1;
		cVar1 = *pcVar16;
		pcVar16 = pcVar10;
	} while (cVar1 != '\0');
	uVar8 = ~uVar8;
	iVar5 = -1;
	pcVar16 = local_80;
	do {
		pcVar11 = pcVar16;
		if (iVar5 == 0) break;
		iVar5 += -1;
		pcVar11 = pcVar16 + 1;
		cVar1 = *pcVar16;
		pcVar16 = pcVar11;
	} while (cVar1 != '\0');
	puVar9 = (undefined4 *)(pcVar10 + -uVar8);
	puVar12 = (undefined4 *)(pcVar11 + -1);
	for (uVar7 = uVar8 >> 2; uVar7 != 0; uVar7 -= 1) {
		*puVar12 = *puVar9;
		puVar9 = puVar9 + 1;
		puVar12 = puVar12 + 1;
	}
	for (uVar8 &= 3; uVar8 != 0; uVar8 -= 1) {
		*(undefined *)puVar12 = *(undefined *)puVar9;
		puVar9 = (undefined4 *)((int)puVar9 + 1);
		puVar12 = (undefined4 *)((int)puVar12 + 1);
	}
	if (uVar6 < 0x3d) {
		pcVar16 = "00.";
	}
	else {
		uVar7 = (uVar6 - 1) / 0x3c;
		uVar8 = uVar7;
		do {
			uVar6 -= 0x3c;
			uVar8 -= 1;
		} while (uVar8 != 0);
		if (uVar7 < 10) {
			pcVar16 = "0%d.";
		}
		else {
			pcVar16 = "%d.";
		}
		std::sprintf(local_100,pcVar16,uVar7);
		pcVar16 = local_100;
	}
	uVar8 = 0xffffffff;
	do {
		pcVar10 = pcVar16;
		if (uVar8 == 0) break;
		uVar8 -= 1;
		pcVar10 = pcVar16 + 1;
		cVar1 = *pcVar16;
		pcVar16 = pcVar10;
	} while (cVar1 != '\0');
	uVar8 = ~uVar8;
	iVar5 = -1;
	pcVar16 = local_80;
	do {
		pcVar11 = pcVar16;
		if (iVar5 == 0) break;
		iVar5 += -1;
		pcVar11 = pcVar16 + 1;
		cVar1 = *pcVar16;
		pcVar16 = pcVar11;
	} while (cVar1 != '\0');
	puVar9 = (undefined4 *)(pcVar10 + -uVar8);
	puVar12 = (undefined4 *)(pcVar11 + -1);
	for (uVar7 = uVar8 >> 2; uVar7 != 0; uVar7 -= 1) {
		*puVar12 = *puVar9;
		puVar9 = puVar9 + 1;
		puVar12 = puVar12 + 1;
	}
	for (uVar8 &= 3; uVar8 != 0; uVar8 -= 1) {
		*(undefined *)puVar12 = *(undefined *)puVar9;
		puVar9 = (undefined4 *)((int)puVar9 + 1);
		puVar12 = (undefined4 *)((int)puVar12 + 1);
	}
	if (uVar6 < 2) {
		pcVar16 = "00";
	}
	else {
		if (uVar6 - 1 < 10) {
			format = &PTR_checkGlobs_loadedList_810__848__004aa4a0;
		}
		else {
			format = (undefined **)"%d";
		}
		std::sprintf(local_100,(char *)format,uVar6 - 1);
		pcVar16 = local_100;
	}
	uVar6 = 0xffffffff;
	do {
		pcVar10 = pcVar16;
		if (uVar6 == 0) break;
		uVar6 -= 1;
		pcVar10 = pcVar16 + 1;
		cVar1 = *pcVar16;
		pcVar16 = pcVar10;
	} while (cVar1 != '\0');
	uVar6 = ~uVar6;
	iVar5 = -1;
	pcVar16 = local_80;
	do {
		pcVar11 = pcVar16;
		if (iVar5 == 0) break;
		iVar5 += -1;
		pcVar11 = pcVar16 + 1;
		cVar1 = *pcVar16;
		pcVar16 = pcVar11;
	} while (cVar1 != '\0');
	puVar9 = (undefined4 *)(pcVar10 + -uVar6);
	puVar12 = (undefined4 *)(pcVar11 + -1);
	for (uVar8 = uVar6 >> 2; uVar8 != 0; uVar8 -= 1) {
		*puVar12 = *puVar9;
		puVar9 = puVar9 + 1;
		puVar12 = puVar12 + 1;
	}
	for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
		*(undefined *)puVar12 = *(undefined *)puVar9;
		puVar9 = (undefined4 *)((int)puVar9 + 1);
		puVar12 = (undefined4 *)((int)puVar12 + 1);
	}
	std::sprintf(pRVar4->items_TABLE[8].Text + 0x80,"%s",local_80);
	lVar14 = __ftol((float10)*(float *)&pRVar4->items_TABLE[9].field_0x38);
	*(int *)&pRVar4->items_TABLE[9].field_0x50 = (int)lVar14;
	std::sprintf(pRVar4->items_TABLE[9].Text + 0x80,"%d%%%%",(int)lVar14);
	return 1;
}



BOOL __cdecl lego::reward::Reward_waitFrontEndRewards_FUN_004616d0(void)
{
	LevelData *pLVar1;
	RewardFrontEnd *pRVar2;
	BOOL BVar3;
	VideoPlayer_t *videoPlayer;
	uint uVar4;
	int iVar5;
	char *fName;
	int iVar6;
	uint local_34;
	int local_30;
	float local_2c;
	int local_28;
	float local_24;
	float local_20;
	undefined4 local_1c;
	LevelData *local_18;
	undefined4 uStack20;
	uint local_10;
	undefined4 uStack12;
	uint local_8;
	undefined4 uStack4;
	
	local_30 = 0;
	local_28 = 0;
	local_1c = 0;
	local_34 = 0;
	local_18 = (LevelData *)main::Main_GetTime();
	uStack20 = 0;
	local_2c = globals::g_Reward_Timer;
	local_24 = (float)ZEXT48(local_18);
	pLVar1 = game::GetLevel();
	if (pLVar1 == NULL) {
		return 0;
	}
	local_18 = pLVar1;
	pRVar2 = GetRewardFrontEnd(pLVar1->field_10);
	if (pRVar2 != NULL) {
		BVar3 = front::Reward_UIUpdate_FUN_00462a40();
		if (BVar3 != 0) {
			while (((local_30 < 4 || (globs::INPUT.mslb != 0)) || (globs::INPUT.lClicked != 0))) {
				local_10 = main::Main_GetTime();
				uStack12 = 0;
				local_20 = ((float)(ulonglong)local_10 - local_24) * 0.001;
				local_8 = main::Main_GetTime();
				uStack4 = 0;
				local_24 = (float)(ulonglong)local_8;
				local_2c = local_20 + local_2c;
				Reward_FUN_00462760((int *)&local_34,&local_30,&local_2c);
				if ((((globs::INPUT.Key_Map[57] == false) && (globs::INPUT.prevKey_Map[57] != false)) ||
						(globs::INPUT.lClicked != 0)) && (local_30 < 3)) {
					local_30 += 1;
					if (local_30 == 3) {
						local_30 = 2;
					}
					if ((local_30 < 2) || (pLVar1->status != LEVELSTATUS_COMPLETE)) {
						local_34 = 9;
					}
					else {
						local_34 = 10;
					}
				}
				if (globals::g_Reward_Wallpaper != NULL) {
					lego::image::Image_DisplayScaled(globals::g_Reward_Wallpaper,NULL,NULL,NULL);
				}
				iVar5 = 0;
				if (0 < (int)local_34) {
					iVar6 = 0;
					do {
						front::Reward_FUN_00461a50((uint *)(pRVar2->items_PTR->name + iVar6 + -4),2,local_34);
						iVar5 += 1;
						iVar6 += 0x210;
					} while (iVar5 < (int)local_34);
				}
				iVar6 = 0;
				iVar5 = 0;
				while( true ) {
					uVar4 = local_34;
					if (9 < (int)local_34) {
						uVar4 = 9;
					}
					if ((int)uVar4 <= iVar6) break;
					front::Reward_FUN_00461a50((uint *)(pRVar2->items_PTR->name + iVar5 + -4),0x40,local_34);
					iVar6 += 1;
					iVar5 += 0x210;
				}
				iVar5 = 0;
				if (0 < (int)local_34) {
					iVar6 = 0;
					do {
						front::Reward_FUN_00461a50((uint *)(pRVar2->items_PTR->name + iVar6 + -4),4,local_34);
						iVar5 += 1;
						iVar6 += 0x210;
					} while (iVar5 < (int)local_34);
				}
				Reward_FUN_004628c0(&local_34,&local_28);
				if ((local_28 != 0) && (Reward_FUN_00461f50(local_34), local_30 < 3)) {
					front::Reward_FUN_00462090(&local_30,&local_1c);
				}
				Reward_FUN_00462d90((float *)REWARDSTRUCT28_00556b5c);
				if (local_30 == 3) {
					local_30 = 4;
				}
				front::Reward_FUN_00462650(&local_34,&local_30,&local_28,&local_2c);
				unk::Lego_UnkUpdateAndRender_FUN_004629c0(local_20);
				pLVar1 = local_18;
			}
			front::Reward_FUN_00462c20(&REWARDSTRUCT28_00556b5c);
			iVar5 = 0;
			do {
				if ((pRVar2->items_PTR->name[iVar5 + -4] & 4U) != 0) {
					lego::image::Flic_Close(*(ImageFlic **)(&pRVar2->items_PTR->field_0x1fc + iVar5));
					*(undefined4 *)(&pRVar2->items_PTR->field_0x1fc + iVar5) = 0;
				}
				iVar5 += 0x210;
			} while (iVar5 < 0x14a0);
			snd::Sound3D_Stream_Stop(1);
			if ((pLVar1->status == LEVELSTATUS_COMPLETE) && (globs::gameGlobs.EndGameAVI1 != NULL)) {
				BVar3 = front::Front_FUN_00418050();
				if ((BVar3 == 0) ||
					 (fName = globs::gameGlobs.EndGameAVI2, globs::gameGlobs.EndGameAVI2 == NULL)) {
					fName = globs::gameGlobs.EndGameAVI1;
				}
				BVar3 = lego::file::File_Exists(fName);
				if (BVar3 != 0) {
					videoPlayer = video::VideoPlayer_Load(fName);
					video::VideoPlayer_Play(videoPlayer,0);
					video::VideoPlayer_Free(videoPlayer);
				}
				snd::SFX_Sample_AddToQueue(SFX_AMBIENTMUSICLOOP,1);
				front::MainMenuFull_TriggerShowCredits();
				snd::Sound3D_Stream_Stop(1);
			}
			return 1;
		}
		return 0;
	}
	return 0;
}



void __cdecl lego::front::Reward_FUN_00461a50(uint *param_1,uint param_2,uint param_3)
{
	char *pcVar1;
	RewardFrontEndItem *pRVar2;
	ImageFlic *fsp;
	int iVar3;
	uint uVar4;
	Point2F local_3c;
	undefined4 local_34;
	Point2F local_30;
	undefined4 local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	Rect2F local_10;
	
	if (param_3 == 0) {
		iVar3 = 0;
	}
	else {
		iVar3 = param_3 - 1;
	}
	pRVar2 = globals::g_RewardFrontLevel->items_PTR;
	if (((globals::g_Reward_DisplayImages != 0) && ((*(byte *)param_1 & 2) != 0)) &&
		 ((param_2 & 2) != 0)) {
		local_3c.x = (float)param_1[0x58];
		local_30.x = (float)(ulonglong)param_1[0x57];
		local_3c.y = 0.0;
		local_30.y = (float)(ulonglong)(uint)local_3c.x;
		lego::image::Image_DisplayScaled((ImageBMP *)param_1[0x80],NULL,&local_30,NULL);
	}
	if (((globals::g_Reward_DisplayImages != 0) && ((*(byte *)param_1 & 0x40) != 0)) &&
		 ((param_2 & 0x40) != 0)) {
		local_30.x = (float)param_1[0x5a];
		local_3c.x = (float)(ulonglong)param_1[0x59];
		local_30.y = 0.0;
		local_3c.y = (float)(ulonglong)(uint)local_30.x;
		lego::image::Image_DisplayScaled((ImageBMP *)param_1[0x83],NULL,&local_3c,NULL);
	}
	if (((globals::g_Reward_DisplayFlics != 0) && ((*(byte *)param_1 & 4) != 0)) &&
		 ((param_2 & 4) != 0)) {
		if (param_1[0x7f] == 0) {
			lego::image::Flic_Setup((char *)(param_1 + 0x5b),(ImageFlic **)(param_1 + 0x7f),FLICDISK);
		}
		local_10.x = (float)(ulonglong)param_1[0x7d];
		local_30.x = (float)param_1[0x7c];
		local_10.y = (float)(ulonglong)param_1[0x7e];
		local_10.width = (float)(ulonglong)param_1[0x7b];
		fsp = (ImageFlic *)param_1[0x7f];
		local_30.y = 0.0;
		local_10.height = (float)(ulonglong)(uint)local_30.x;
		lego::image::Flic_Animate(fsp,&local_10,(uint)(fsp->currentframe < 0x23),0);
	}
	if (globals::g_Reward_DisplayText != 0) {
		if (((*(byte *)param_1 & 1) != 0) && ((param_2 & 1) != 0)) {
			uVar4 = lego::image::Font_GetStringWidth((ImageFont *)param_1[0x81],(char *)(param_1 + 0x35));
			lego::image::Font_PrintF
								((ImageFont *)param_1[0x81],param_1[0x55] - (uVar4 >> 1),param_1[0x56],
								 (char *)(param_1 + 0x35));
			if (param_3 < 10) {
				pcVar1 = pRVar2[iVar3].Text;
				uVar4 = lego::image::Font_GetStringWidth(globals::g_Reward_TitleFont,pcVar1);
				lego::image::Font_PrintF
									(globals::g_Reward_TitleFont,globals::g_Reward_TextPos.x - (uVar4 >> 1),
									 globals::g_Reward_TextPos.y,pcVar1);
			}
		}
		if ((globals::g_Reward_DisplayText != 0) &&
			 ((((*param_1 & 0x10) != 0 && ((param_2 & 0x10) != 0)) ||
				(((*param_1 & 0x20) != 0 && ((param_2 & 0x20) != 0)))))) {
			local_1c = 0x3df0f0f1;
			local_18 = 0x3df0f0f1;
			local_14 = 0x3df0f0f1;
			local_28 = 0x3e70f0f1;
			local_24 = 0x3e70f0f1;
			local_20 = 0x3e70f0f1;
			local_3c.x = 0.0;
			local_3c.y = 0.0;
			local_34 = 0;
			uVar4 = lego::image::Font_GetStringWidth((ImageFont *)param_1[0x81],(char *)(param_1 + 0x35));
			local_30.x = (float)(uVar4 + 0x14);
			local_10.x = (float)(ulonglong)((param_1[0x55] - (uVar4 >> 1)) - 10);
			local_10.y = (float)(ulonglong)param_1[0x56];
			local_30.y = 0.0;
			local_10.width = (float)(ulonglong)(uint)local_30.x;
			local_30.x = (float)lego::image::Font_GetHeight((ImageFont *)param_1[0x81]);
			local_30.y = 0.0;
			local_10.height = (float)(ulonglong)(uint)local_30.x;
			ToolTip_DrawBox((Rect2F)CONCAT412(local_10.height,
																				CONCAT48(local_10.width,CONCAT44(local_10.y,local_10.x))),
											local_1c,local_18,local_14,local_28,local_24,local_20,local_3c.x,local_3c.y,
											local_34,param_2 & 0x20);
			lego::image::Font_PrintF
								((ImageFont *)param_1[0x81],param_1[0x55] - (uVar4 >> 1),param_1[0x56],
								 (char *)(param_1 + 0x35));
			if (param_3 < 10) {
				pcVar1 = pRVar2[iVar3].Text;
				uVar4 = lego::image::Font_GetStringWidth(globals::g_Reward_TitleFont,pcVar1);
				local_30.x = (float)(uVar4 + 0x14);
				local_10.x = (float)(ulonglong)((globals::g_Reward_TextPos.x - (uVar4 >> 1)) - 10);
				local_10.y = (float)(ulonglong)(uint)globals::g_Reward_TextPos.y;
				local_30.y = 0.0;
				local_10.width = (float)(ulonglong)(uint)local_30.x;
				local_30.x = (float)lego::image::Font_GetHeight(globals::g_Reward_TitleFont);
				local_30.y = 0.0;
				local_10.height = (float)(ulonglong)(uint)local_30.x;
				ToolTip_DrawBox((Rect2F)CONCAT412(local_10.height,
																					CONCAT48(local_10.width,CONCAT44(local_10.y,local_10.x))),
												local_1c,local_18,local_14,local_28,local_24,local_20,local_3c.x,local_3c.y,
												local_34,0);
				lego::image::Font_PrintF
									(globals::g_Reward_TitleFont,globals::g_Reward_TextPos.x - (uVar4 >> 1),
									 globals::g_Reward_TextPos.y,pcVar1);
			}
		}
	}
	return;
}



int __cdecl lego::reward::Reward_FUN_00461f50(uint param_1)
{
	char cVar1;
	LevelData *pLVar2;
	RewardFrontEnd *pRVar3;
	uint uVar4;
	RewardFrontEndItem *pRVar5;
	int iVar6;
	char *pcVar7;
	char local_40 [32];
	char local_20 [32];
	
	pLVar2 = game::GetLevel();
	if (pLVar2 == NULL) {
		return (int)NULL;
	}
	pRVar3 = GetRewardFrontEnd(pLVar2->field_10);
	if (pRVar3 == NULL) {
		return (int)NULL;
	}
	if (pLVar2->status == LEVELSTATUS_COMPLETE) {
		front::Reward_FUN_00461a50((uint *)(pRVar3->items_PTR + 9),1,param_1);
		std::sprintf(local_40,"%s",pRVar3->items_PTR[9].Text);
		pRVar5 = pRVar3->items_PTR;
		uVar4 = 0xffffffff;
		iVar6 = 0;
		pcVar7 = pRVar5[9].Text;
		do {
			if (uVar4 == 0) break;
			uVar4 -= 1;
			cVar1 = *pcVar7;
			pcVar7 = pcVar7 + 1;
		} while (cVar1 != '\0');
		if (0 < (int)(~uVar4 - 1)) {
			do {
				if (pRVar5[9].Text[iVar6] == ' ') {
					local_40[iVar6] = '\0';
					std::sprintf(local_20,"%s",local_40 + iVar6 + 1);
				}
				pRVar5 = pRVar3->items_PTR;
				uVar4 = 0xffffffff;
				iVar6 += 1;
				pcVar7 = pRVar5[9].Text;
				do {
					if (uVar4 == 0) break;
					uVar4 -= 1;
					cVar1 = *pcVar7;
					pcVar7 = pcVar7 + 1;
				} while (cVar1 != '\0');
			} while (iVar6 < (int)(~uVar4 - 1));
		}
		pcVar7 = local_40;
		iVar6 = pRVar3->items_PTR[9].TextPosition.y + -0x28;
		uVar4 = lego::image::Font_GetStringWidth(globals::g_Reward_BackFont,local_40);
		pRVar3 = (RewardFrontEnd *)
						 lego::image::Font_PrintF
											 (globals::g_Reward_BackFont,
												pRVar3->items_PTR[9].TextPosition.x - (uVar4 >> 1),iVar6,pcVar7);
	}
	return (int)pRVar3;
}



int __cdecl lego::front::Reward_FUN_00462090(undefined4 *param_1,undefined4 *param_2)
{
	bool bVar1;
	ImageBMP *pIVar2;
	float fVar3;
	float fVar4;
	bool bVar5;
	LevelData *pLVar6;
	RewardFrontEnd *pRVar7;
	ImageBMP *pIVar8;
	uint uVar9;
	ImageBMP *image;
	
	bVar5 = false;
	pLVar6 = game::GetLevel();
	if (pLVar6 == NULL) {
		return 0;
	}
	pRVar7 = reward::GetRewardFrontEnd(pLVar6->field_10);
	if (pRVar7 == NULL) {
		return 0;
	}
	if (pLVar6->status == LEVELSTATUS_COMPLETE) {
		fVar3 = (float)globs::INPUT.msx;
		pIVar2 = (ImageBMP *)((uint)pRVar7 & 0xffff0000);
		pIVar8 = pIVar2;
		image = globals::g_Reward_SaveButton;
		if (((((ushort)((ushort)(fVar3 < globals::g_Reward_SaveButtonPosition.x) << 8 |
									 (ushort)(fVar3 == globals::g_Reward_SaveButtonPosition.x) << 0xe) == 0) &&
				 (bVar1 = fVar3 < (float)(ulonglong)globals::g_Reward_SaveButton->width +
													globals::g_Reward_SaveButtonPosition.x,
				 pIVar8 = (ImageBMP *)((uint)CONCAT21((short)((uint)pIVar2 >> 0x10),bVar1) << 8), bVar1)) &&
				(fVar3 = (float)globs::INPUT.msy, pIVar8 = pIVar2,
				(ushort)((ushort)(fVar3 < globals::g_Reward_SaveButtonPosition.y) << 8 |
								(ushort)(fVar3 == globals::g_Reward_SaveButtonPosition.y) << 0xe) == 0)) &&
			 (bVar1 = fVar3 < (float)(ulonglong)globals::g_Reward_SaveButton->height +
												globals::g_Reward_SaveButtonPosition.y,
			 pIVar8 = (ImageBMP *)
								((uint)CONCAT21((short)(globals::g_Reward_SaveButton->height >> 0x10),bVar1) << 8),
			 bVar1)) {
			ToolTip_AddFlag4(TOOLTIP_REWARD_SAVE);
			if (((globs::INPUT.mslb != 0) &&
					(pIVar8 = globals::g_Reward_SaveButton_in, globals::g_Reward_SaveButton_in != NULL)) ||
				 (pIVar8 = globals::g_Reward_SaveButton_hi, globals::g_Reward_SaveButton_hi != NULL)) {
				lego::image::Image_DisplayScaled(pIVar8,NULL,&globals::g_Reward_SaveButtonPosition,NULL);
			}
			pIVar8 = (ImageBMP *)Front_LeftButtonInputUnk_FUN_00435480();
			if (pIVar8 != NULL) {
				bVar5 = true;
				pIVar8 = (ImageBMP *)snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_OKAY,0);
				SaveMenu_FUN_004622f0();
				*param_2 = 1;
				snd::SFX_Sample_Sound3D_StopSound(0x29);
				snd::SFX_Sample_AddToQueue(SFX_MUSICLOOP,1);
			}
		}
		else {
LAB_004621d9:
			lego::image::Image_DisplayScaled(image,NULL,&globals::g_Reward_SaveButtonPosition,NULL);
		}
	}
	else {
		pIVar8 = globals::g_Reward_SaveButton_dim;
		image = globals::g_Reward_SaveButton_dim;
		if (globals::g_Reward_SaveButton_dim != NULL) goto LAB_004621d9;
	}
	fVar3 = (float)globs::INPUT.msx;
	uVar9 = (uint)(ushort)((ushort)(fVar3 < globals::g_Reward_AdvanceButtonPosition.x) << 8 |
												(ushort)(fVar3 == globals::g_Reward_AdvanceButtonPosition.x) << 0xe);
	if (uVar9 == 0) {
		fVar4 = (float)(ulonglong)globals::g_Reward_AdvanceButton->width +
						globals::g_Reward_AdvanceButtonPosition.x;
		uVar9 = (uint)pIVar8 & 0xffff0000 |
						(uint)(ushort)((ushort)(fVar3 < fVar4) << 8 | (ushort)(fVar3 == fVar4) << 0xe);
		if (fVar3 < fVar4) {
			fVar3 = (float)globs::INPUT.msy;
			uVar9 = (uint)(ushort)((ushort)(fVar3 < globals::g_Reward_AdvanceButtonPosition.y) << 8 |
														(ushort)(fVar3 == globals::g_Reward_AdvanceButtonPosition.y) << 0xe);
			if (uVar9 != 0) goto LAB_004622b4;
			fVar4 = (float)(ulonglong)globals::g_Reward_AdvanceButton->height +
							globals::g_Reward_AdvanceButtonPosition.y;
			uVar9 = globals::g_Reward_AdvanceButton->height & 0xffff0000 |
							(uint)(ushort)((ushort)(fVar3 < fVar4) << 8 | (ushort)(fVar3 == fVar4) << 0xe);
			if (fVar3 < fVar4) {
				ToolTip_AddFlag4(TOOLTIP_REWARD_ADVANCE);
				if (((globs::INPUT.mslb != 0) &&
						(pIVar8 = globals::g_Reward_AdvanceButton_in, globals::g_Reward_AdvanceButton_in != NULL
						)) || (pIVar8 = globals::g_Reward_AdvanceButton_hi,
									globals::g_Reward_AdvanceButton_hi != NULL)) {
					lego::image::Image_DisplayScaled
										(pIVar8,NULL,&globals::g_Reward_AdvanceButtonPosition,NULL);
				}
				uVar9 = Front_LeftButtonInputUnk_FUN_00435480();
				if (uVar9 != 0) {
					bVar5 = true;
					*param_1 = 3;
					snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_OKAY,0);
					uVar9 = FUN_00462530();
				}
				goto LAB_004622c6;
			}
		}
	}
	else {
LAB_004622b4:
		uVar9 = (uint)pIVar8 & 0xffff0000 | uVar9;
	}
	lego::image::Image_DisplayScaled
						(globals::g_Reward_AdvanceButton,NULL,&globals::g_Reward_AdvanceButtonPosition,NULL);
LAB_004622c6:
	if ((!bVar5) && (uVar9 = Front_LeftButtonInputUnk_FUN_00435480(), uVar9 != 0)) {
		uVar9 = snd::SFX_Sample_Random_Play_OrAddToQueue(SFX_NOTOKAY,0);
	}
	return uVar9;
}



void __cdecl lego::front::SaveMenu_FUN_004622f0(void)
{
	LevelData *level2;
	BOOL BVar1;
	BOOL BVar2;
	LevelCollection *levelCol;
	int iVar3;
	SaveData *pSVar4;
	RewardFrontEnd *pRVar5;
	SaveData *pSVar6;
	LevelData *level;
	uint uVar7;
	SaveStruct_18 saveStruct18;
	SaveData saveData;
	char *levelName;
	
	level2 = game::GetLevel();
	unk::Lego_GetIntNotM1__00558020();
	BVar1 = Front_GetUnkTutoOrMissions();
	PausedMenu_UpdateUnkStruct_FromSliderValues();
	BVar2 = main::Config_IsFrontEndEnabled();
	if (BVar2 != 0) {
		levelName = level2->levelName;
		levelCol = LevelCollections_GetTutorialOrMissions();
		iVar3 = LevelCollection_IndexOf(levelCol,levelName);
		LevelIndex_FUN_00417ec0(iVar3);
		iVar3 = save::Save_GetSaveNumber();
		pSVar4 = save::Save_GetCurrentSaveNumber_StructB8();
		save::Save_CopyData(&saveData);
		pRVar5 = reward::GetCurrentRewardFrontEnd();
		if (BVar1 == 0) {
			BVar1 = game::Objective_Game_IsLevelComplete();
			if (BVar1 != 0) {
				do {
					Front_RunScreenMenuType(MENU_SCREEN_SAVE);
				} while (BOOL_00558508 != 0);
				if (globals::g_SaveMenu_IsLoadMode == 1) {
					BVar1 = Front_GetBool_00558500();
					if (BVar1 != 0) {
						Front_FUN_00417f30();
						Front_SetBool_00558500(0);
					}
					pSVar6 = save::Save_GetCurrentSaveNumber_StructB8();
					if (pSVar6 != NULL) {
						pSVar6 = save::Save_GetCurrentSaveNumber_StructB8();
						if ((pSVar6 != pSVar4) && (pSVar4 != NULL)) {
							Save_OverwriteData(&saveData);
							level = game::GetLevel();
							levelName = level->levelName;
							levelCol = LevelCollections_GetTutorialOrMissions();
							uVar7 = LevelCollection_IndexOf(levelCol,levelName);
							Front_FUN_00417de0(uVar7);
							levelName = level2->levelName;
							levelCol = LevelCollections_GetTutorialOrMissions();
							iVar3 = LevelCollection_IndexOf(levelCol,levelName);
							Front_FUN_00417e70(iVar3,(undefined4 *)pRVar5);
							save::Save_CopyStruct18(&saveStruct18);
							save::SaveStruct18_FUN_00417e50(&saveStruct18);
							Front_FUN_00417ef0();
							return;
						}
						level = game::GetLevel();
						levelName = level->levelName;
						levelCol = LevelCollections_GetTutorialOrMissions();
						uVar7 = LevelCollection_IndexOf(levelCol,levelName);
						Front_FUN_00417de0(uVar7);
						levelName = level2->levelName;
						levelCol = LevelCollections_GetTutorialOrMissions();
						iVar3 = LevelCollection_IndexOf(levelCol,levelName);
						Front_FUN_00417e70(iVar3,(undefined4 *)pRVar5);
						save::Save_CopyStruct18(&saveStruct18);
						save::SaveStruct18_FUN_00417e50(&saveStruct18);
						Front_FUN_00417ef0();
						return;
					}
					level2 = game::GetLevel();
					levelName = level2->levelName;
					levelCol = LevelCollections_GetTutorialOrMissions();
					LevelCollection_IndexOf(levelCol,levelName);
					return;
				}
				save::Save_SetSaveNumber(iVar3);
				pSVar4 = save::Save_GetCurrentSaveNumber_StructB8();
				if (pSVar4 != NULL) {
					level = game::GetLevel();
					levelName = level->levelName;
					levelCol = LevelCollections_GetTutorialOrMissions();
					uVar7 = LevelCollection_IndexOf(levelCol,levelName);
					Front_FUN_00417de0(uVar7);
					levelName = level2->levelName;
					levelCol = LevelCollections_GetTutorialOrMissions();
					iVar3 = LevelCollection_IndexOf(levelCol,levelName);
					Front_FUN_00417e70(iVar3,(undefined4 *)pRVar5);
					save::Save_CopyStruct18(&saveStruct18);
					save::SaveStruct18_FUN_00417e50(&saveStruct18);
				}
			}
		}
	}
	return;
}



void __cdecl FUN_00462530(void)
{
	LevelData *pLVar1;
	LevelCollection *pLVar2;
	uint uVar3;
	int iVar4;
	RewardFrontEnd *pRVar5;
	SaveData *pSVar6;
	uint uVar7;
	undefined4 *puVar8;
	MenuItemTrigger *pMVar9;
	char *levelName;
	undefined4 uVar10;
	
	pLVar1 = lego::game::GetLevel();
	levelName = pLVar1->levelName;
	pLVar2 = lego::front::LevelCollections_GetTutorialOrMissions();
	uVar3 = lego::front::LevelCollection_IndexOf(pLVar2,levelName);
	iVar4 = lego::save::Save_GetSaveNumber();
	if (iVar4 == -1) {
		lego::save::Save_SetSaveNumber(5);
	}
	pLVar1 = lego::game::GetLevel();
	if (pLVar1->status == LEVELSTATUS_COMPLETE) {
		lego::front::Front_FUN_00417de0(uVar3);
	}
	pRVar5 = lego::reward::GetCurrentRewardFrontEnd();
	lego::front::Front_FUN_00417e70(uVar3,(undefined4 *)pRVar5);
	if (iVar4 == -1) {
		pSVar6 = lego::save::Save_GetStructB8At(5);
		if (pSVar6 != NULL) {
			puVar8 = (undefined4 *)((int)pSVar6->table3190_34 + 0x3190);
			for (uVar7 = pSVar6->count_18 * 0x3190 - 0x3190 >> 2; uVar7 != 0; uVar7 -= 1) {
				*puVar8 = 0;
				puVar8 = puVar8 + 1;
			}
			for (iVar4 = 0; iVar4 != 0; iVar4 += -1) {
				*(undefined *)puVar8 = 0;
				puVar8 = (undefined4 *)((int)puVar8 + 1);
			}
			pLVar1 = lego::game::GetLevel();
			if (pLVar1->status == LEVELSTATUS_COMPLETE) {
				lego::front::Front_FUN_00417de0(uVar3);
			}
			pRVar5 = lego::reward::GetCurrentRewardFrontEnd();
			lego::front::Front_FUN_00417e70(uVar3,(undefined4 *)pRVar5);
		}
		lego::front::Front_FUN_00417ef0();
		lego::save::Save_ReadSaveFile(5,lego::globals::g_Struct_b8_TABLE__00558080 + 5,0);
	}
	uVar10 = 0;
	pMVar9 = *(MenuItemTrigger **)
						(lego::globals::menu::g_MainMenuFull->menus[1]->Items->length + 0x10);
	pLVar2 = &lego::globals::g_MissionLevels;
	pSVar6 = lego::save::Save_GetCurrentSaveNumber_StructB8();
	lego::front::LevelIdentifier_FUN_00417310
						(lego::globals::g_StartMissionLevel,(int)pSVar6->table3190_34,pLVar2,pMVar9,uVar10);
	lego::front::Front_SetBool_0055881c(0);
	return;
}



void __cdecl
lego::front::Reward_FUN_00462650
					(undefined4 *param_1,undefined4 *param_2,undefined4 *param_3,undefined4 *param_4)
{
	LevelData *pLVar1;
	RewardFrontEnd *pRVar2;
	int iVar3;
	
	pLVar1 = game::GetLevel();
	if (pLVar1 == NULL) {
		return;
	}
	pRVar2 = reward::GetRewardFrontEnd(pLVar1->field_10);
	if (pRVar2 == NULL) {
		return;
	}
	if (((byte)globs::gameGlobs.flags2 & GAME2_ALLOWDEBUGKEYS) != 0) {
										// IsKeyDown(KEY_SPACE) (57) && IsKeyPressed(KEY_ESCAPE) (1)
		if (((globs::INPUT.Key_Map[57] != false) && (globs::INPUT.Key_Map[1] != false)) &&
			 (globs::INPUT.prevKey_Map[1] != globs::INPUT.Key_Map[1])) {
			main::Game_Exit();
		}
										// IsKeyPressed(KEY_R) (19)
		if ((globs::INPUT.Key_Map[19] != false) &&
			 (globs::INPUT.prevKey_Map[19] != globs::INPUT.Key_Map[19])) {
			*param_1 = 0;
			*param_2 = 0;
			*param_4 = globals::g_Reward_Timer;
			*param_3 = 0;
			snd::SFX_Sample_Sound3D_StopSound(0x29);
			snd::SFX_Sample_AddToQueue(SFX_MUSICLOOP,1);
			iVar3 = 0;
			do {
				reward::Reward_FUN_00462720((byte *)(pRVar2->items_PTR->name + iVar3 + -4));
				iVar3 += 0x210;
			} while (iVar3 < 0x14a0);
		}
	}
	return;
}



void __cdecl lego::reward::Reward_FUN_00462720(byte *param_1)
{
	if ((*param_1 & 4) != 0) {
		lego::image::Flic_Close(*(ImageFlic **)(param_1 + 0x1fc));
		lego::image::Flic_Setup((char *)(param_1 + 0x16c),(ImageFlic **)(param_1 + 0x1fc),FLICDISK);
	}
	return;
}



void __cdecl lego::reward::Reward_FUN_00462760(int *param_1,int *param_2,float *param_3)
{
	char *sfxName;
	bool bVar1;
	LevelData *pLVar2;
	RewardFrontEnd *pRVar3;
	int iVar4;
	BOOL BVar5;
	bool bVar6;
	SFXType local_4;
	
	bVar1 = false;
	pLVar2 = game::GetLevel();
	if (pLVar2 == NULL) {
		return;
	}
	pRVar3 = GetRewardFrontEnd(pLVar2->field_10);
	if (pRVar3 == NULL) {
		return;
	}
	if (globals::g_Reward_Timer <= *param_3) {
		bVar6 = *param_2 == 0;
		if (!bVar6) goto LAB_004627c2;
		bVar1 = true;
	}
	bVar6 = *param_2 == 0;
LAB_004627c2:
	if ((!bVar6) && (globals::g_Reward_Timer + globals::g_Reward_Timer <= *param_3)) {
		pLVar2 = game::GetLevel();
		if ((pLVar2->status == LEVELSTATUS_COMPLETE) && (*param_1 < 10)) {
			bVar1 = true;
		}
	}
	if (bVar1) {
		*param_3 = *param_3 - globals::g_Reward_Timer;
		iVar4 = *param_1;
		if (iVar4 < 10) {
			iVar4 += 1;
		}
		*param_1 = iVar4;
		sfxName = pRVar3->items_PTR[iVar4 + -1].SoundName;
		if (sfxName != NULL) {
			BVar5 = snd::SFX_GetType(sfxName,&local_4);
			if (BVar5 != 0) {
				snd::SFX_Sample_AddToQueue(local_4,0);
			}
		}
		iVar4 = *param_1;
		if (9 < iVar4) {
			if (*param_2 == 0) {
				*param_1 = 9;
				*param_2 = *param_2 + 1;
				return;
			}
			if ((9 < iVar4) && (1 < *param_2)) {
				if (10 < iVar4) {
					*param_1 = 10;
					*param_2 = *param_2 + 1;
					return;
				}
				iVar4 = 0;
				do {
					Reward_FUN_00462720((byte *)(pRVar3->items_PTR->name + iVar4 + -4));
					iVar4 += 0x210;
				} while (iVar4 < 0x14a0);
			}
		}
	}
	return;
}



void __cdecl lego::reward::Reward_FUN_004628c0(uint *param_1,undefined4 *param_2)
{
	uint uVar1;
	LevelData *pLVar2;
	RewardFrontEnd *pRVar3;
	uint uVar4;
	int iVar5;
	int iVar6;
	
	pLVar2 = game::GetLevel();
	if (pLVar2 == NULL) {
		return;
	}
	pRVar3 = GetRewardFrontEnd(pLVar2->field_10);
	if (pRVar3 == NULL) {
		return;
	}
	if (((*param_1 == 10) || ((pLVar2->status != LEVELSTATUS_COMPLETE && (*param_1 == 9)))) &&
		 ((*(int *)&pRVar3->items_TABLE[9].field_0x1fc == 0 ||
			(((globals::g_Reward_DisplayFlics == 0 ||
				(0x21 < *(int *)(*(int *)&pRVar3->items_PTR[9].field_0x1fc + 0x624))) ||
			 (pLVar2->status != LEVELSTATUS_COMPLETE)))))) {
		*param_2 = 1;
	}
	iVar6 = 0;
	iVar5 = 0;
	while( true ) {
		uVar1 = *param_1;
		uVar4 = uVar1;
		if (9 < (int)uVar1) {
			uVar4 = 9;
		}
		if ((int)uVar4 <= iVar6) break;
		front::Reward_FUN_00461a50((uint *)(pRVar3->items_PTR->name + iVar5 + -4),1,uVar1);
		iVar6 += 1;
		iVar5 += 0x210;
	}
	lego::image::Font_GetStringWidth(globals::g_Reward_TitleFont,pLVar2->FullName);
	lego::image::Font_GetStringWidth(globals::g_Reward_TitleFont,globals::g_LevelStatusMessage_text);
	return;
}



void __cdecl lego::unk::Lego_UnkUpdateAndRender_FUN_004629c0(float elapsed)
{
	front::Pointer_SubUnkFloat_IfGreaterThan0(1.0);
	front::Pointer_SetType_IfUnkFloatLessThan0(POINTER_STANDARD);
	front::Pointer_DrawPointer(globs::INPUT.msx,globs::INPUT.msy);
	front::Front_LeftButtonInputUnk_FUN_00435480();
	globs::INPUT.lClicked = 0;
	snd::SFX_Update(elapsed);
										// param_1 / 25.0 * 1000.0 (related to milliseconds)
	front::ToolTip_Update(globs::INPUT.msx,globs::INPUT.msy,elapsed * 0.04 * 1000.0);
	main::Main_LoopUpdate(1);
	return;
}



BOOL __cdecl lego::front::Reward_UIUpdate_FUN_00462a40(void)
{
	LevelData *pLVar1;
	RewardFrontEnd *pRVar2;
	
	pLVar1 = game::GetLevel();
	if (pLVar1 != NULL) {
		pRVar2 = reward::GetRewardFrontEnd(pLVar1->field_10);
		if (pRVar2 != NULL) {
			if ((globals::g_Reward_Display != 0) && (pRVar2->Enabled != 0)) {
				while( true ) {
										// IsKeyUp(KEY_SPACE) && !IsKeyReleased(KEY_SPACE)  (57)
					if ((((globs::INPUT.Key_Map[57] == false) ||
							 (globs::INPUT.prevKey_Map[57] == globs::INPUT.Key_Map[57])) &&
							(globs::INPUT.Key_Map[57] == false)) &&
						 ((globs::INPUT.prevKey_Map[57] == false && (true)))) break;
					main::Main_LoopUpdate(TRUE);
				}
				globs::INPUT.lClicked = 0;
				snd::SFX_Sample_AddToQueue(SFX_MUSICLOOP,1);
				return 1;
			}
			FUN_00462530();
		}
	}
	return 0;
}



void __cdecl lego::unk::Lego_AddToFloat_00556738__DecFloat_0055673c(float param_1)
{
	FLOAT_00556738 = param_1 + FLOAT_00556738;
	FLOAT_0055673c = FLOAT_0055673c - -1.0;
	return;
}



void __cdecl lego::unk::Lego_DecFloat_00555adc(void)
{
	FLOAT_00555adc = FLOAT_00555adc - -1.0;
	return;
}



void __cdecl lego::unk::Lego_DecFloat_00555efc(void)
{
	FLOAT_00555efc = FLOAT_00555efc - -1.0;
	return;
}



void __cdecl lego::nerps::NERPs_IncRockMonstersGenerated(void)
{
	globals::g_NERPs_RockMonstersGenerated += 1;
	return;
}



void __cdecl lego::nerps::NERPs_IncRockMonstersDestroyed(void)
{
	globals::nerps::g_NERPs_RockMonstersDestroyed += 1;
	return;
}



void __cdecl lego::nerps::NERPs_IncInt_0055632c(void)
{
	UINT_0055632c += 1;
	return;
}



void __cdecl lego::nerps::NERPs_AddToFloat_00556330(float param_1)
{
	FLOAT_00556330 = param_1 + FLOAT_00556330;
	return;
}



void __cdecl lego::nerps::NERPs_AddToFloat_00556120(float param_1)
{
	FLOAT_00556120 = param_1 + FLOAT_00556120;
	return;
}



RewardStruct_28 * __cdecl
lego::reward::Reward_CreateStruct28
					(RewardStruct_28 **out_struct,undefined4 param_2,float param_3,float param_4,float param_5
					,float scrollSpeed)
{
	RewardStruct_28 *pRVar1;
	RewardSubstruct_20 **ppRVar2;
	RewardSubstruct_20 *pRVar3;
	int iVar4;
	RewardStruct_28 *pRVar5;
	
	pRVar1 = (RewardStruct_28 *)std::malloc(0x28);
	if (pRVar1 != NULL) {
		pRVar5 = pRVar1;
		for (iVar4 = 10; iVar4 != 0; iVar4 += -1) {
			pRVar5->field_0 = 0;
			pRVar5 = (RewardStruct_28 *)&pRVar5->field_4;
		}
		ppRVar2 = (RewardSubstruct_20 **)std::malloc(4);
		pRVar1->substruct_TABLE = ppRVar2;
		pRVar3 = (RewardSubstruct_20 *)std::malloc(0x20);
		*ppRVar2 = pRVar3;
		for (iVar4 = 8; iVar4 != 0; iVar4 += -1) {
			pRVar3->int_0 = 0;
			pRVar3 = (RewardSubstruct_20 *)&pRVar3->field_4;
		}
		pRVar1->scrollSpeed = scrollSpeed;
		pRVar1->field_4 = param_2;
		pRVar1->float_8 = param_3;
		pRVar1->float_c = param_4;
		pRVar1->float_10 = param_5;
		pRVar1->field_0 = param_3;
	}
	*out_struct = pRVar1;
	return pRVar1;
}



BOOL __cdecl lego::front::Reward_FUN_00462c20(RewardStruct_28 **param_1)
{
	char *buffer;
	RewardStruct_28 *pRVar1;
	uint uVar2;
	
	uVar2 = 0;
	pRVar1 = *param_1;
	if (pRVar1->substruct_COUNT != 0) {
		do {
			buffer = pRVar1->substruct_TABLE[uVar2]->text;
			if (buffer != NULL) {
				std::free(buffer);
			}
			std::free((*param_1)->substruct_TABLE[uVar2]);
			pRVar1 = *param_1;
			uVar2 += 1;
		} while (uVar2 < (uint)pRVar1->substruct_COUNT);
	}
	if ((*param_1)->substruct_TABLE != NULL) {
		std::free((*param_1)->substruct_TABLE);
	}
	std::free(*param_1);
	return 1;
}



RewardSubstruct_20 * __cdecl
lego::front::Reward_FUN_00462c90
					(RewardStruct_28 *param_1,char *text,ImageFont *font,undefined4 param_4,int vertSpacing,
					uint unkFlags)
{
	char cVar1;
	int iVar2;
	RewardSubstruct_20 **ppRVar3;
	RewardSubstruct_20 *pRVar4;
	char *pcVar5;
	int iVar6;
	uint uVar7;
	
	if (font == NULL) {
		return NULL;
	}
	iVar2 = param_1->substruct_COUNT;
	param_1->substruct_COUNT = iVar2 + 1;
	ppRVar3 = (RewardSubstruct_20 **)std::realloc(param_1->substruct_TABLE,(iVar2 + 1) * 4);
	param_1->substruct_TABLE = ppRVar3;
	pRVar4 = (RewardSubstruct_20 *)std::malloc(0x20);
	param_1->substruct_TABLE[iVar2] = pRVar4;
	pRVar4 = param_1->substruct_TABLE[iVar2];
	for (iVar6 = 8; iVar6 != 0; iVar6 += -1) {
		pRVar4->int_0 = 0;
		pRVar4 = (RewardSubstruct_20 *)&pRVar4->field_4;
	}
	param_1->substruct_TABLE[iVar2]->field_4 = param_4;
	param_1->substruct_TABLE[iVar2]->vertSpacing = (float)vertSpacing;
	uVar7 = 0xffffffff;
	pcVar5 = text;
	do {
		if (uVar7 == 0) break;
		uVar7 -= 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	pcVar5 = (char *)std::malloc(~uVar7);
	param_1->substruct_TABLE[iVar2]->text = pcVar5;
	std::sprintf(param_1->substruct_TABLE[iVar2]->text,"%s",text);
	param_1->substruct_TABLE[iVar2]->int_0 = 3;
	param_1->substruct_TABLE[iVar2]->font = font;
	param_1->substruct_TABLE[iVar2]->flags = param_1->substruct_TABLE[iVar2]->flags | unkFlags;
	return param_1->substruct_TABLE[iVar2];
}



void __cdecl lego::reward::Reward_Struct_SetFloat18(RewardStruct_28 *param_1,float param_2)
{
	param_1->float_18 = param_2;
	return;
}



void __cdecl lego::reward::Reward_Struct_OrFlags24(RewardStruct_28 *param_1,uint param_2)
{
	param_1->flags = param_1->flags | param_2;
	return;
}



BOOL __cdecl lego::reward::Reward_FUN_00462d90(float *param_1)
{
	int iVar1;
	float fVar2;
	float *pfVar3;
	int iVar4;
	int *piVar5;
	uint uVar6;
	float *pfVar7;
	longlong lVar8;
	ulonglong uVar9;
	int local_2c;
	float local_28;
	float *local_24;
	Size2F local_10;
	Point2F local_8;
	
	pfVar3 = param_1;
	local_28 = 0.0;
	if (param_1[7] != 0.0) {
		do {
			iVar4 = (int)local_28 * 4;
			piVar5 = *(int **)(iVar4 + (int)pfVar3[8]);
			lVar8 = __ftol((float10)(float)piVar5[1] + (float10)pfVar3[1]);
			local_2c = (int)lVar8;
			uVar9 = __ftol((float10)(float)piVar5[2] + (float10)pfVar3[2]);
			param_1 = (float *)uVar9;
			if ((*(byte *)(pfVar3 + 9) & 1) != 0) {
				if ((float)(int)param_1 < *pfVar3) {
					lVar8 = __ftol((float10)pfVar3[6] + (float10)pfVar3[4]);
					do {
						param_1 = (float *)((int)param_1 + (int)lVar8);
						uVar9 = ZEXT48(param_1);
					} while ((float)(int)param_1 < *pfVar3);
				}
				pfVar7 = (float *)uVar9;
				fVar2 = pfVar3[6] + *pfVar3 + pfVar3[4];
				if ((ushort)((ushort)((float)(int)param_1 < fVar2) << 8 |
										(ushort)((float)(int)param_1 == fVar2) << 0xe) == 0) {
					lVar8 = __ftol((float10)pfVar3[4]);
					do {
						pfVar7 = (float *)((int)pfVar7 - (int)lVar8);
						uVar9 = ZEXT48(pfVar7);
						param_1 = pfVar7;
					} while ((ushort)((ushort)((float)(int)pfVar7 < fVar2) << 8 |
													 (ushort)((float)(int)pfVar7 == fVar2) << 0xe) == 0);
				}
			}
			iVar1 = *piVar5;
			if (iVar1 == 1) {
				front::TextWindow_ChangePosition((TextWindow *)piVar5[3],local_2c,(int)uVar9);
				front::TextWindow_Update
									(*(TextWindow **)(*(int *)(iVar4 + (int)pfVar3[8]) + 0xc),0,
									 globs::mainGlobs.fixedFrameTiming,NULL);
LAB_00462e93:
				local_8.x = (float)local_2c;
				piVar5 = (int *)(iVar4 + (int)pfVar3[8]);
				local_8.y = (float)(int)param_1;
				local_10.width = (float)(ulonglong)*(uint *)(*(int *)(*piVar5 + 0x10) + 4);
				local_10.height = (float)(ulonglong)*(uint *)(*(int *)(*piVar5 + 0x10) + 8);
				lego::image::Image_DisplayScaled(*(ImageBMP **)(*piVar5 + 0x10),NULL,&local_8,&local_10);
LAB_00462ef7:
				iVar1 = *(int *)(iVar4 + (int)pfVar3[8]);
				if ((*(byte *)(iVar1 + 0x1c) & 1) != 0) {
					uVar6 = lego::image::Font_GetStringWidth
														(*(ImageFont **)(iVar1 + 0x18),*(char **)(iVar1 + 0x14));
					lVar8 = __ftol(((float10)pfVar3[3] - (float10)pfVar3[1]) * (float10)-0.5);
					local_2c += -(int)lVar8 - (uVar6 >> 1);
				}
				uVar9 &= 0xffffffff;
				iVar4 = *(int *)(iVar4 + (int)pfVar3[8]);
				uVar6 = *(uint *)(iVar4 + 0x1c) & 2;
				if (uVar6 != 0) {
					uVar9 = __ftol((float10)*(float *)(iVar4 + 8));
					param_1 = (float *)uVar9;
				}
				if ((uVar6 != 0) ||
					 ((fVar2 = (float)(int)param_1, fVar2 < pfVar3[4] + *pfVar3 &&
						((ushort)((ushort)(fVar2 < *pfVar3) << 8 | (ushort)(fVar2 == *pfVar3) << 0xe) == 0)))) {
					lego::image::Font_PrintF
										(*(ImageFont **)(iVar4 + 0x18),local_2c,(int)uVar9,*(char **)(iVar4 + 0x14));
				}
			}
			else {
				if (iVar1 == 2) goto LAB_00462e93;
				if (iVar1 == 3) goto LAB_00462ef7;
			}
			local_28 = (float)((int)local_28 + 1);
		} while ((uint)local_28 < (uint)pfVar3[7]);
	}
	pfVar3[2] = pfVar3[2] - pfVar3[5];
	if (((byte)globs::gameGlobs.flags2 & 0x10) != 0) {
		if (globs::INPUT.Key_Map[31] != false) {
			pfVar3[5] = 0.0;
		}
		if (globs::INPUT.Key_Map[19] != false) {
			pfVar3[2] = *pfVar3;
		}
		if (globs::INPUT.Key_Map[13] != false) {
			pfVar3[5] = pfVar3[5] - -0.01;
		}
		if (globs::INPUT.Key_Map[12] != false) {
			pfVar3[5] = pfVar3[5] - 0.01;
		}
		param_1 = NULL;
		local_24 = NULL;
		do {
			if (*(char *)((int)param_1 + 0x76bb82) != '\0') {
				pfVar7 = param_1;
				if (pfVar3[5] < 0.0) {
					pfVar7 = local_24;
				}
				pfVar3[5] = (float)(int)pfVar7 * 0.1;
			}
			param_1 = (float *)((int)param_1 + 1);
			local_24 = (float *)((int)local_24 + -1);
		} while (-10 < (int)local_24);
	}
	return 1;
}



BOOL __cdecl lego::game::WorldMesh_Create(Container *resData,int width,int height)
{
	uint uVar1;
	uint uVar2;
	
	globals::g_WorldMesh_Container = res::Container_MakeMesh2(resData,CONTAINER_MESHTYPE_IMMEDIATE);
	if (globals::g_WorldMesh_Container != NULL) {
		globals::g_WorldMesh_Texture = NULL;
		uVar2 = height * width;
		globals::g_WorldMesh_HideBool = 0;
		globals::g_WorldMesh_GRIDPTR = std::malloc(uVar2 * 8);
		if (globals::g_WorldMesh_GRIDPTR != NULL) {
			uVar1 = 0;
			if (uVar2 != 0) {
				do {
					*(undefined4 *)((int)globals::g_WorldMesh_GRIDPTR + uVar1 * 8) = 0;
					*(undefined *)((int)globals::g_WorldMesh_GRIDPTR + uVar1 * 8 + 4) = TRUE;
					uVar1 += 1;
				} while (uVar1 < uVar2);
			}
			globals::g_WorldMesh_Dimensions.width = width;
			globals::g_WorldMesh_Dimensions.height = height;
			globals::g_WorldMesh_BOOL_00553190 = TRUE;
			globals::g_WorldMesh_Structs_COUNT = 0;
			return TRUE;
		}
		res::Container_Remove(globals::g_WorldMesh_Container);
	}
	return 0;
}



BOOL __cdecl lego::game::WorldMesh_LoadTextures(char *filename)
{
	D3DRMGroupIndex count;
	D3DRMGroupIndex groupID;
	
	if (globals::g_WorldMesh_Texture != NULL) {
		res::Container_FreeTexture(globals::g_WorldMesh_Texture);
	}
	globals::g_WorldMesh_Texture = res::Container_LoadTexture2(filename,TRUE,NULL,NULL);
	if (globals::g_WorldMesh_Texture != NULL) {
		count = res::Container_Mesh_GetGroupCount(globals::g_WorldMesh_Container);
		groupID = D3DRMGROUP_0;
		if (count != D3DRMGROUP_0) {
			do {
				res::Container_Mesh_SetTexture
									(globals::g_WorldMesh_Container,groupID,globals::g_WorldMesh_Texture);
				groupID += 1;
			} while (groupID < count);
		}
		return TRUE;
	}
	return 0;
}



void __cdecl lego::game::WorldMesh_UnkFreeGridPtr_FUN_00463190(void)
{
	if (globals::g_WorldMesh_GRIDPTR != NULL) {
		std::free(globals::g_WorldMesh_GRIDPTR);
	}
	globals::g_WorldMesh_GRIDPTR = NULL;
	if (globals::g_WorldMesh_Container != NULL) {
		res::Container_Remove(globals::g_WorldMesh_Container);
	}
	globals::g_WorldMesh_Container = NULL;
	res::Container_FreeTexture(globals::g_WorldMesh_Texture);
	return;
}



void __cdecl
lego::game::Level_Block_SetVertexPositions
					(int bx,int by,Vector3F *param_3,Vector3F *param_4,Vector3F *param_5,Vector3F *param_6)
{
	D3DRMGroupIndex *pDVar1;
	ushort uVar2;
	bool bVar3;
	byte bVar4;
	D3DRMGroupIndex groupID;
	D3DRMVertex vertices [4];
	uint local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	pDVar1 = (D3DRMGroupIndex *)
					 ((int)globals::g_WorldMesh_GRIDPTR +
					 (by * globals::g_WorldMesh_Dimensions.width + bx) * 8);
	bVar3 = false;
	if ((*(byte *)(pDVar1 + 1) & 1) != 0) {
		local_18 = 0;
		local_10 = 3;
		local_4 = 3;
		local_14 = 1;
		local_c = 1;
		local_8 = 2;
		groupID = res::Container_Mesh_AddGroup(globals::g_WorldMesh_Container,4,2,3,&local_18);
		*pDVar1 = groupID;
		if (groupID != D3DRMGROUP_ALLGROUPS) {
			res::Container_Mesh_SetTexture
								(globals::g_WorldMesh_Container,groupID,globals::g_WorldMesh_Texture);
			res::Container_Mesh_SetPerspectiveCorrection(globals::g_WorldMesh_Container,*pDVar1,1);
			res::Container_Mesh_HideGroup(globals::g_WorldMesh_Container,*pDVar1,1);
			*(byte *)(pDVar1 + 1) = *(byte *)(pDVar1 + 1) & 0xfe;
		}
	}
	globals::g_WorldMesh_BOOL_00553190 = 1;
	*(byte *)(pDVar1 + 1) = *(byte *)(pDVar1 + 1) | 2;
	if (param_5->z <= param_3->z) {
		if ((ushort)((ushort)(param_5->z < param_4->z) << 8 | (ushort)(param_5->z == param_4->z) << 0xe)
				!= 0) {
			uVar2 = (ushort)(param_5->z < param_6->z) << 8 | (ushort)(param_5->z == param_6->z) << 0xe;
			goto joined_r0x0046334a;
		}
	}
	else {
		if ((ushort)((ushort)(param_3->z < param_4->z) << 8 | (ushort)(param_3->z == param_4->z) << 0xe)
				!= 0) {
			uVar2 = (ushort)(param_3->z < param_6->z) << 8 | (ushort)(param_3->z == param_6->z) << 0xe;
joined_r0x0046334a:
			if (uVar2 != 0) goto LAB_00463350;
		}
	}
	bVar3 = true;
LAB_00463350:
	if (bVar3) {
		vertices[3].position.x = param_4->x;
		vertices[3].position.y = param_4->y;
		vertices[3].position.z = param_4->z;
		vertices[2].position.x = param_5->x;
		vertices[2].position.y = param_5->y;
		vertices[2].position.z = param_5->z;
		vertices[1].position.x = param_6->x;
		vertices[1].position.y = param_6->y;
		vertices[1].position.z = param_6->z;
		vertices[0].position.x = param_3->x;
		vertices[0].position.y = param_3->y;
		vertices[0].position.z = param_3->z;
		bVar4 = *(byte *)(pDVar1 + 1) | 4;
	}
	else {
		vertices[3].position.x = param_3->x;
		vertices[3].position.y = param_3->y;
		vertices[3].position.z = param_3->z;
		vertices[2].position.x = param_4->x;
		vertices[2].position.y = param_4->y;
		vertices[2].position.z = param_4->z;
		vertices[1].position.x = param_5->x;
		vertices[1].position.y = param_5->y;
		vertices[1].position.z = param_5->z;
		vertices[0].position.x = param_6->x;
		vertices[0].position.y = param_6->y;
		vertices[0].position.z = param_6->z;
		bVar4 = *(byte *)(pDVar1 + 1) & 0xfb;
	}
	*(byte *)(pDVar1 + 1) = bVar4;
	vertices[3].normal.x = 0.0;
	vertices[3].normal.z = 0.0;
	vertices[2].normal.x = 0.0;
	vertices[2].normal.z = 0.0;
	vertices[1].normal.x = 0.0;
	vertices[1].normal.z = 0.0;
	vertices[0].normal.x = 0.0;
	vertices[0].normal.z = 0.0;
	vertices[3].normal.y = 0.0;
	vertices[2].normal.y = 0.0;
	vertices[1].normal.y = 0.0;
	vertices[0].normal.y = 0.0;
	vertices[3].colour = 0xffffffff;
	vertices[2].colour = 0xffffffff;
	vertices[1].colour = 0xffffffff;
	vertices[0].colour = 0xffffffff;
	vertices[3].tu = 0.0;
	vertices[3].tv = 1.0;
	vertices[2].tu = 1.0;
	vertices[2].tv = 1.0;
	vertices[1].tu = 1.0;
	vertices[1].tv = 0.0;
	vertices[0].tu = 0.0;
	vertices[0].tv = 0.0;
	res::Container_Mesh_SetVertices(globals::g_WorldMesh_Container,*pDVar1,0,4,vertices);
	return;
}



void __cdecl FUN_004634f0(void)
{
	D3DRMGroupIndex *pDVar1;
	float fVar2;
	uint uVar3;
	BOOL BVar4;
	uint uVar5;
	int iVar6;
	float *pfVar7;
	int *piVar8;
	uint local_134;
	uint local_130;
	int local_124;
	Vector3F local_11c;
	int local_110 [4];
	undefined4 local_100;
	undefined4 local_fc;
	undefined4 local_f8;
	undefined4 local_f4;
	undefined4 local_f0;
	undefined4 local_ec;
	undefined4 local_e8;
	undefined4 local_e4;
	undefined4 local_e0;
	undefined4 local_dc;
	undefined4 local_d8;
	undefined4 local_d4;
	undefined4 local_d0;
	undefined4 local_cc;
	undefined4 local_c8;
	undefined4 local_c4;
	undefined4 local_c0;
	undefined4 local_bc;
	undefined4 local_b8;
	undefined4 local_b4;
	undefined4 local_b0;
	undefined4 local_ac;
	undefined4 local_a8;
	undefined4 local_a4;
	undefined4 local_a0;
	undefined4 local_9c;
	undefined4 local_98;
	undefined4 local_94;
	D3DRMVertex local_90 [4];
	
	if (lego::globals::g_WorldMesh_BOOL_00553190 != 0) {
		lego::globals::g_WorldMesh_BOOL_00553190 = 0;
		local_130 = 0;
		uVar5 = lego::globals::g_WorldMesh_Dimensions.width;
		if (lego::globals::g_WorldMesh_Dimensions.height != 0) {
			do {
				local_134 = 0;
				if (uVar5 != 0) {
					do {
						iVar6 = local_130 * uVar5 + local_134;
						pDVar1 = (D3DRMGroupIndex *)((int)lego::globals::g_WorldMesh_GRIDPTR + iVar6 * 8);
						if ((*(byte *)((int)lego::globals::g_WorldMesh_GRIDPTR + iVar6 * 8 + 4) & 2) != 0) {
							local_fc = 1;
							local_f4 = 1;
							local_e8 = 1;
							local_e0 = 1;
							local_dc = 1;
							local_d4 = 1;
							local_c0 = 1;
							local_b8 = 1;
							local_110[2] = 0xffffffff;
							local_f8 = 0xffffffff;
							local_c4 = 0xffffffff;
							local_bc = 0xffffffff;
							local_a8 = 0xffffffff;
							local_a4 = 0xffffffff;
							local_9c = 0xffffffff;
							local_98 = 0xffffffff;
							local_110[0] = 0;
							local_110[1] = 0;
							local_110[3] = 0;
							local_100 = 0;
							local_f0 = 0;
							local_ec = 0;
							local_e4 = 0;
							local_d8 = 0;
							local_d0 = 0;
							local_cc = 0;
							local_c8 = 0;
							local_b4 = 0;
							local_b0 = 0;
							local_ac = 0;
							local_a0 = 0;
							local_94 = 0;
							lego::res::Container_Mesh_GetVertices
												(lego::globals::g_WorldMesh_Container,*pDVar1,0,4,local_90);
							uVar5 = 0;
							pfVar7 = &local_90[0].normal.z;
							do {
								uVar3 = uVar5;
								if ((*(byte *)(pDVar1 + 1) & 4) != 0) {
									uVar3 = uVar5 - 1 & 3;
								}
								local_124 = 4;
								piVar8 = local_110 + uVar3 * 8;
								do {
									BVar4 = FUN_00463850(local_134 + *piVar8,piVar8[1] + local_130,&local_11c);
									if (BVar4 != 0) {
										pfVar7[-2] = local_11c.x + pfVar7[-2];
										pfVar7[-1] = local_11c.y + pfVar7[-1];
										*pfVar7 = local_11c.z + *pfVar7;
									}
									piVar8 = piVar8 + 2;
									local_124 += -1;
								} while (local_124 != 0);
								uVar5 += 1;
								fVar2 = 1.0 / SQRT(pfVar7[-2] * pfVar7[-2] +
																	 *pfVar7 * *pfVar7 + pfVar7[-1] * pfVar7[-1]);
								*pfVar7 = fVar2 * *pfVar7;
								pfVar7[-2] = fVar2 * pfVar7[-2];
								pfVar7[-1] = fVar2 * pfVar7[-1];
								pfVar7 = pfVar7 + 9;
							} while (uVar5 < 4);
							lego::res::Container_Mesh_SetVertices
												(lego::globals::g_WorldMesh_Container,*pDVar1,0,4,local_90);
							*(byte *)(pDVar1 + 1) = *(byte *)(pDVar1 + 1) & 0xfd;
							uVar5 = lego::globals::g_WorldMesh_Dimensions.width;
						}
						local_134 += 1;
					} while (local_134 < uVar5);
				}
				local_130 += 1;
			} while (local_130 < (uint)lego::globals::g_WorldMesh_Dimensions.height);
		}
	}
	return;
}



void __cdecl lego::game::WorldMesh_Hide(BOOL hide)
{
	if (globals::g_WorldMesh_HideBool != hide) {
		globals::g_WorldMesh_HideBool = hide;
		if (hide != 0) {
			res::Container_Hide(globals::g_WorldMesh_Container,TRUE);
			return;
		}
		res::Container_Hide(globals::g_WorldMesh_Container,FALSE);
	}
	return;
}



void __cdecl lego::game::WorldMesh_FUN_004637b0(int bx,int by)
{
	void *pvVar1;
	int iVar2;
	
	iVar2 = by * globals::g_WorldMesh_Dimensions.width + bx;
	pvVar1 = (void *)((int)globals::g_WorldMesh_GRIDPTR + iVar2 * 8);
	res::Container_Mesh_HideGroup
						(globals::g_WorldMesh_Container,
						 *(D3DRMGroupIndex *)((int)globals::g_WorldMesh_GRIDPTR + iVar2 * 8),0);
	(&globals::g_WorldMesh_Structs_TABLE[0].groupID)[globals::g_WorldMesh_Structs_COUNT] =
			 (D3DRMGroupIndex)pvVar1;
	globals::g_WorldMesh_Structs_COUNT = globals::g_WorldMesh_Structs_COUNT + 1;
	return;
}



void __cdecl lego::game::WorldMesh_FUN_00463800(void)
{
	uint uVar1;
	WorldMeshStruct_8 *pWVar2;
	
	uVar1 = 0;
	if (globals::g_WorldMesh_Structs_COUNT != 0) {
		pWVar2 = globals::g_WorldMesh_Structs_TABLE;
		do {
			res::Container_Mesh_HideGroup
								(globals::g_WorldMesh_Container,*(D3DRMGroupIndex *)pWVar2->groupID,TRUE);
			uVar1 += 1;
			pWVar2 = (WorldMeshStruct_8 *)&pWVar2->flags;
		} while (uVar1 < globals::g_WorldMesh_Structs_COUNT);
	}
	globals::g_WorldMesh_Structs_COUNT = 0;
	return;
}



BOOL __cdecl FUN_00463850(uint x,uint y,Vector3F *out_vector)
{
	D3DRMGroupIndex *pDVar1;
	float fVar2;
	Vector3F local_a8;
	Vector3F local_9c;
	D3DRMVertex local_90;
	Vector3F local_6c [3];
	Vector3F local_48 [3];
	Vector3F local_24 [3];
	
	if (((x < (uint)lego::globals::g_WorldMesh_Dimensions.width) &&
			(y < (uint)lego::globals::g_WorldMesh_Dimensions.height)) &&
		 (pDVar1 = (D3DRMGroupIndex *)
							 ((int)lego::globals::g_WorldMesh_GRIDPTR +
							 (y * lego::globals::g_WorldMesh_Dimensions.width + x) * 8),
		 (*(byte *)(pDVar1 + 1) & 1) == 0)) {
		lego::res::Container_Mesh_GetVertices
							(lego::globals::g_WorldMesh_Container,*pDVar1,0,4,&local_90);
		lego::math::Maths_PlaneNormal(&local_a8,(Vector3F *)&local_90,local_6c,local_48);
		lego::math::Maths_PlaneNormal(&local_9c,local_48,local_24,(Vector3F *)&local_90);
		local_9c.y = local_9c.y + local_a8.y;
		local_9c.z = local_9c.z + local_a8.z;
		local_9c.x = local_9c.x + local_a8.x;
		fVar2 = 1.0 / SQRT(local_9c.x * local_9c.x + local_9c.z * local_9c.z + local_9c.y * local_9c.y);
		out_vector->x = fVar2 * local_9c.x;
		out_vector->y = fVar2 * local_9c.y;
		out_vector->z = fVar2 * local_9c.z;
		return 1;
	}
	return 0;
}



void __cdecl
lego::unk::Lego_LoadScrollInfoPanel__00463970
					(char *filename,int index,int param_3,int param_4,int param_5)
{
	ImageBMP *pIVar1;
	char **ppcVar2;
	int iVar3;
	
	ppcVar2 = (char **)&param_5;
	if (filename != NULL) {
		do {
			iVar3 = index * 0x20;
			*(undefined4 *)(&DAT_0055315c + iVar3) = 1;
			*(uint *)(&DAT_0055315c + iVar3) = (-(uint)((char *)param_3 != NULL) & 8) + 9;
			pIVar1 = lego::image::Image_LoadBMPScaled(filename,0,0);
			*(ImageBMP **)(&DAT_00553140 + iVar3) = pIVar1;
			if (pIVar1 != NULL) {
				*(uint *)(&DAT_0055315c + iVar3) = *(uint *)(&DAT_0055315c + iVar3) | 4;
			}
			filename = *ppcVar2;
			(&DAT_00553158)[index * 8] = param_4;
			index = (int)ppcVar2[1];
			param_3 = (int)ppcVar2[2];
			param_4 = (int)ppcVar2[3];
			ppcVar2 = ppcVar2 + 4;
		} while (filename != NULL);
	}
	return;
}



void __cdecl FUN_004639f0(int index,uint param_2,uint param_3)
{
	(&FLOAT_00553144)[index * 8] = (float)(ulonglong)param_2;
	(&FLOAT_00553148)[index * 8] = (float)(ulonglong)param_3;
	return;
}



void __cdecl
FUN_00463a30(int index,BOOL use50InsteadOf4c,Rect2F *rect,char *opt_filename1,char *opt_filename2)
{
	float fVar1;
	float fVar2;
	float *pfVar3;
	ImageBMP *pIVar4;
	
	if (use50InsteadOf4c == 0) {
		pfVar3 = (float *)std::malloc(0x1c);
		(&PTR_0055314c)[index * 8] = pfVar3;
	}
	else {
		pfVar3 = (float *)std::malloc(0x1c);
		(&PTR_00553150)[index * 8] = pfVar3;
	}
	*pfVar3 = rect->x;
	pfVar3[1] = rect->y;
	pfVar3[2] = rect->width + rect->x;
	fVar1 = rect->height;
	fVar2 = rect->y;
	pfVar3[4] = 0.0;
	pfVar3[5] = 0.0;
	pfVar3[3] = fVar1 + fVar2;
	if (opt_filename1 != NULL) {
		pIVar4 = lego::image::Image_LoadBMPScaled(opt_filename1,0,0);
		pfVar3[4] = (float)pIVar4;
	}
	if (opt_filename2 != NULL) {
		pIVar4 = lego::image::Image_LoadBMPScaled(opt_filename2,0,0);
		pfVar3[5] = (float)pIVar4;
	}
	pfVar3[6] = 0.0;
	return;
}



void __cdecl FUN_00463ad0(int param_1,float *param_2,int param_3,undefined4 param_4,char *filename)
{
	void *pvVar1;
	ImageBMP *pIVar2;
	
	pvVar1 = std::malloc(0x28);
	(&DAT_00553154)[param_1 * 8] = pvVar1;
	pIVar2 = lego::image::Image_LoadBMPScaled(filename,0,0);
	*(ImageBMP **)((&DAT_00553154)[param_1 * 8] + 0x18) = pIVar2;
	*(float *)(&DAT_00553154)[param_1 * 8] = *param_2;
	*(float *)((&DAT_00553154)[param_1 * 8] + 4) = param_2[1];
	*(float *)((&DAT_00553154)[param_1 * 8] + 8) = param_2[2] + *param_2;
	*(float *)((&DAT_00553154)[param_1 * 8] + 0xc) = param_2[3] + param_2[1];
	*(undefined4 *)((&DAT_00553154)[param_1 * 8] + 0x10) = 0;
	*(undefined4 *)((&DAT_00553154)[param_1 * 8] + 0x14) = 0;
	*(int *)((&DAT_00553154)[param_1 * 8] + 0x1c) = param_3 + -1;
	*(undefined4 *)((&DAT_00553154)[param_1 * 8] + 0x20) = param_4;
	return;
}



BOOL __cdecl FUN_00463b60(int *param_1,uint param_2,uint param_3,int param_4,int param_5)
{
	uint uVar1;
	PanelType PVar2;
	float fVar3;
	float fVar4;
	BOOL BVar5;
	int iVar6;
	BOOL BVar7;
	uint uVar8;
	float *pfVar9;
	longlong lVar10;
	int local_60;
	PanelType *local_5c;
	
	BVar7 = 0;
	local_60 = 0;
	local_5c = &DAT_00553158;
	do {
		if (((*(byte *)(local_5c + 1) & 4) != 0) &&
			 (BVar5 = lego::front::Panel_IsFlags_4_AndNot8(*local_5c), BVar5 == 0)) {
			uVar8 = 0;
			do {
				if (uVar8 == 0) {
					pfVar9 = (float *)local_5c[-3];
				}
				else {
					pfVar9 = (float *)local_5c[-2];
				}
				if ((BVar7 == 0) && (BVar5 = FUN_00463ec0(local_5c + -6,pfVar9,param_2,param_3), BVar5 != 0)
					 ) {
					*param_1 = local_60;
					if (param_4 == 0) {
						if (INT_00553160 != 3) {
							if (uVar8 != INT_00553160) goto LAB_00463c6b;
							PVar2 = local_5c[-1];
							uVar1 = *(uint *)(PVar2 + 0x20);
							if (uVar8 == 0) {
								if (uVar1 < *(uint *)(PVar2 + 0x1c)) {
									iVar6 = uVar1 + 1;
LAB_00463c54:
									*(int *)(PVar2 + 0x20) = iVar6;
								}
							}
							else {
								if (uVar1 != 0) {
									iVar6 = uVar1 - 1;
									goto LAB_00463c54;
								}
							}
							*(undefined4 *)(local_5c[-1] + 0x24) = 1;
							pfVar9[6] = (float)((uint)pfVar9[6] & 0xfffffffb | 2);
							goto LAB_00463c6b;
						}
						BVar7 = 1;
						pfVar9[6] = (float)((uint)pfVar9[6] & 0xfffffffb | 2);
					}
					else {
						if (INT_00553160 == 3) {
							if (param_5 == 0) {
								BVar7 = 1;
								INT_00553160 = uVar8;
								pfVar9[6] = (float)((uint)pfVar9[6] & 0xfffffffd | 4);
							}
							else {
LAB_00463c6b:
								BVar7 = 1;
							}
						}
						else {
							if (uVar8 != INT_00553160) goto LAB_00463c6b;
							BVar7 = 1;
							pfVar9[6] = (float)((uint)pfVar9[6] & 0xfffffffd | 4);
						}
					}
				}
				else {
					pfVar9[6] = (float)((uint)pfVar9[6] & 0xfffffff9);
				}
				uVar8 += 1;
			} while (uVar8 < 2);
			if ((BVar7 == 0) && (BVar5 = FUN_00463f50((int)(local_5c + -6),param_2,param_3), BVar5 != 0))
			{
				if (param_4 == 0) {
					if (INT_00553160 == 3) {
						INT_00553160 = 2;
					}
					BOOL_005023c0 = 1;
				}
				else {
					if (INT_00553160 == 2) {
						if ((*(byte *)(local_5c + 1) & 8) == 0) {
							pfVar9 = (float *)local_5c[-1];
							fVar3 = (float)(ulonglong)(uint)pfVar9[7] / (pfVar9[2] - *pfVar9);
							fVar4 = (((float)(ulonglong)param_2 -
											 lego::globals::g_PanelDatas_TABLE[*local_5c].xyOutIn.x) - (float)local_5c[-5]
											) - *pfVar9;
						}
						else {
							PVar2 = local_5c[-1];
							fVar3 = (float)(ulonglong)*(uint *)(PVar2 + 0x1c) /
											(*(float *)(PVar2 + PANEL__COUNT) - *(float *)(PVar2 + PANEL_MESSAGESIDE));
							fVar4 = (((float)(ulonglong)param_3 -
											 lego::globals::g_PanelDatas_TABLE[*local_5c].xyOutIn.y) - (float)local_5c[-4]
											) - *(float *)(PVar2 + PANEL_MESSAGESIDE);
						}
						lVar10 = lego::math::MathX_RoundToLL(fVar4 / fVar3);
						BVar7 = 1;
						*(int *)(local_5c[-1] + 0x20) = (int)lVar10;
						*(undefined4 *)(local_5c[-1] + 0x24) = 1;
						*param_1 = local_60;
						goto LAB_00463da4;
					}
				}
				BVar7 = 1;
				*param_1 = local_60;
			}
			else {
				BOOL_005023c0 = 0;
			}
LAB_00463da4:
			pfVar9 = (float *)local_5c[-1];
			if (pfVar9[9] != 0.0) {
				fVar3 = pfVar9[7];
				if ((*(byte *)(local_5c + 1) & 8) == 0) {
					if (fVar3 == 0.0) {
						fVar3 = *pfVar9 - (float)(ulonglong)*(uint *)((int)pfVar9[6] + 4);
					}
					else {
						fVar3 = (float)(ulonglong)(uint)pfVar9[8] *
										((float)(ulonglong)(uint)fVar3 /
										((pfVar9[2] - *pfVar9) - (float)(ulonglong)*(uint *)((int)pfVar9[6] + 4)));
					}
					pfVar9[4] = fVar3;
				}
				else {
					if (fVar3 == 0.0) {
						pfVar9[5] = 0.0;
					}
					else {
						pfVar9[5] = (float)(ulonglong)(uint)pfVar9[8] *
												((float)(ulonglong)(uint)fVar3 /
												((pfVar9[3] - pfVar9[1]) - (float)(ulonglong)*(uint *)((int)pfVar9[6] + 8)))
						;
					}
				}
				*(undefined4 *)(local_5c[-1] + 0x24) = 0;
			}
		}
		local_5c = local_5c + 8;
		local_60 += 1;
		if ((PanelType *)0x553177 < local_5c) {
			if ((param_4 == 0) && (BOOL_005023c0 == 0)) {
				INT_00553160 = 3;
			}
			return BVar7;
		}
	} while( true );
}



BOOL __cdecl FUN_00463ec0(int param_1,float *param_2,int param_3,int param_4)
{
	int iVar1;
	float fVar2;
	float fVar3;
	longlong lVar4;
	longlong lVar5;
	
	iVar1 = *(int *)(param_1 + 0x18);
	lVar4 = __ftol((float10)lego::globals::g_PanelDatas_TABLE[iVar1].xyOutIn.x +
								 (float10)*(float *)(param_1 + 4));
	lVar5 = __ftol((float10)lego::globals::g_PanelDatas_TABLE[iVar1].xyOutIn.y +
								 (float10)*(float *)(param_1 + 8));
	fVar2 = (float)(param_3 - (int)lVar4);
	if ((((*param_2 <= fVar2) && (fVar3 = (float)(param_4 - (int)lVar5), fVar3 < param_2[3])) &&
			(param_2[1] <= fVar3)) && (fVar2 < param_2[2])) {
		return 1;
	}
	return 0;
}



BOOL __cdecl FUN_00463f50(int param_1,int param_2,int param_3)
{
	int iVar1;
	float *pfVar2;
	float fVar3;
	float fVar4;
	longlong lVar5;
	longlong lVar6;
	
	iVar1 = *(int *)(param_1 + 0x18);
	lVar5 = __ftol((float10)lego::globals::g_PanelDatas_TABLE[iVar1].xyOutIn.x +
								 (float10)*(float *)(param_1 + 4));
	lVar6 = __ftol((float10)lego::globals::g_PanelDatas_TABLE[iVar1].xyOutIn.y +
								 (float10)*(float *)(param_1 + 8));
	fVar3 = (float)(param_2 - (int)lVar5);
	pfVar2 = *(float **)(param_1 + 0x14);
	if ((((*pfVar2 <= fVar3) && (fVar4 = (float)(param_3 - (int)lVar6), fVar4 < pfVar2[3])) &&
			(pfVar2[1] <= fVar4)) && (fVar3 < pfVar2[2])) {
		return 1;
	}
	return 0;
}



void __cdecl FUN_00463fe0(int index)
{
	float *pfVar1;
	uint uVar2;
	ImageBMP *image;
	Point2F local_10;
	Point2F local_8;
	
	local_10.x = (&FLOAT_00553144)[index * 8] +
							 lego::globals::g_PanelDatas_TABLE[(&DAT_00553158)[index * 8]].xyOutIn.x;
	local_10.y = (&FLOAT_00553148)[index * 8] +
							 lego::globals::g_PanelDatas_TABLE[(&DAT_00553158)[index * 8]].xyOutIn.y;
	lego::image::Image_DisplayScaled(*(ImageBMP **)(&DAT_00553140 + index * 0x20),NULL,&local_10,NULL)
	;
	uVar2 = 0;
	do {
		if (uVar2 == 0) {
			pfVar1 = (float *)(&PTR_0055314c)[index * 8];
		}
		else {
			pfVar1 = (float *)(&PTR_00553150)[index * 8];
		}
		if ((((uint)pfVar1[6] & 2) == 0) || (pfVar1[4] == 0.0)) {
			if ((((uint)pfVar1[6] & 4) != 0) && (pfVar1[5] != 0.0)) {
				local_8.x = *pfVar1;
				local_8.y = pfVar1[1];
				image = (ImageBMP *)pfVar1[5];
				goto LAB_004640a7;
			}
		}
		else {
			local_8.x = *pfVar1;
			local_8.y = pfVar1[1];
			image = (ImageBMP *)pfVar1[4];
LAB_004640a7:
			local_8.y = local_8.y + local_10.y;
			local_8.x = local_8.x + local_10.x;
			lego::image::Image_DisplayScaled(image,NULL,&local_8,NULL);
		}
		uVar2 += 1;
		if (1 < uVar2) {
			pfVar1 = (float *)(&DAT_00553154)[index * 8];
			local_8.x = pfVar1[4] + local_10.x + *pfVar1;
			local_8.y = pfVar1[1] + pfVar1[5] + local_10.y;
			lego::image::Image_DisplayScaled((ImageBMP *)pfVar1[6],NULL,&local_8,NULL);
			return;
		}
	} while( true );
}



longlong __cdecl lego::math::MathX_RoundToLL(float x)
{
	float10 fVar1;
	longlong lVar2;
	double x_;
	
	x_ = (double)x;
	fVar1 = __floor(x_);
	if ((float10)x - fVar1 < (float10)0.5) {
		fVar1 = __floor(x_);
		lVar2 = __ftol(fVar1);
		return lVar2;
	}
	fVar1 = std::ceil(x_);
	lVar2 = __ftol(fVar1);
	return lVar2;
}



void __cdecl
lego::draw::Draw_UnkFuncOfInterestTable__00464160
					(int index,undefined4 *out_param_2,undefined4 *out_param_3)
{
	*out_param_2 = *(undefined4 *)((&DAT_00553154)[index * 8] + 0x1c);
	*out_param_3 = *(undefined4 *)((&DAT_00553154)[index * 8] + 0x20);
	return;
}



void __cdecl FUN_00464190(int index,undefined4 param_2,undefined4 param_3)
{
	*(undefined4 *)((&DAT_00553154)[index * 8] + 0x1c) = param_2;
	*(undefined4 *)((&DAT_00553154)[index * 8] + 0x20) = param_3;
	*(undefined4 *)((&DAT_00553154)[index * 8] + 0x24) = 1;
	return;
}



int ** __cdecl lego::res::Res_FUN_004641c0(Container *in_resData,float param_2)
{
	int iVar1;
	DWORD DVar2;
	Container **buffer;
	Container *pCVar3;
	uint *puVar4;
	uint *puVar5;
	DWORD *pDVar6;
	int *piVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	int iVar11;
	DWORD *pDVar12;
	D3DRMGroupIndex local_184;
	DWORD local_17c [4];
	DWORD local_16c [4];
	int local_15c [4];
	undefined4 local_14c;
	undefined4 local_148;
	DWORD local_144;
	undefined4 local_140;
	undefined4 local_13c;
	undefined4 local_138;
	undefined4 local_134;
	undefined4 local_130;
	undefined4 local_12c;
	undefined4 local_128;
	undefined4 local_124;
	undefined4 local_120;
	undefined4 local_11c;
	undefined4 local_118;
	undefined4 local_114;
	undefined4 local_110;
	undefined4 local_10c;
	uint local_108 [30];
	D3DRMVertex local_90 [4];
	
	buffer = (Container **)std::malloc(8);
	if (buffer != NULL) {
		*buffer = NULL;
		buffer[1] = NULL;
		pCVar3 = Container_MakeMesh2(in_resData,CONTAINER_MESHTYPE_TRANSPARENT);
		*buffer = pCVar3;
		if (pCVar3 != NULL) {
			local_16c[0] = 0;
			local_15c[1] = 1;
			local_15c[3] = 1;
			local_16c[1] = 0x3f800000;
			local_16c[2] = 0x3f800000;
			local_16c[3] = 0;
			local_17c[0] = 0;
			local_17c[1] = 0;
			local_17c[2] = 0x3f800000;
			local_17c[3] = 0x3f800000;
			local_144 = 0;
			local_140 = 0;
			local_13c = 0xbf800000;
			local_138 = 0;
			local_134 = 0x3f800000;
			local_130 = 0;
			local_12c = 0x3f800000;
			local_128 = 0;
			local_124 = 0;
			local_120 = 0;
			local_11c = 0xbf800000;
			local_118 = 0;
			local_114 = 0xbf800000;
			local_110 = 0;
			local_10c = 0;
			local_15c[0] = 0;
			local_15c[2] = 3;
			local_14c = 2;
			local_148 = 3;
			uVar10 = 0;
			puVar4 = local_108;
			do {
				piVar7 = local_15c;
				iVar11 = 6;
				puVar5 = puVar4;
				do {
					puVar4 = puVar5 + 1;
					iVar1 = *piVar7;
					piVar7 = piVar7 + 1;
					iVar11 += -1;
					*puVar5 = uVar10 + iVar1;
					puVar5 = puVar4;
				} while (iVar11 != 0);
				uVar10 += 4;
			} while (uVar10 < 0x14);
			local_184 = D3DRMGROUP_0;
			buffer[1] = (Container *)param_2;
			do {
				Container_Mesh_AddGroup(*buffer,0x14,10,3,local_108);
				uVar10 = 0;
				pDVar12 = &local_144;
				do {
					pDVar6 = &local_90[0].colour;
					uVar8 = 0;
					do {
						uVar9 = uVar8 + 4;
						pDVar6[-5] = *pDVar12;
						pDVar6[-4] = pDVar12[1];
						pDVar6[-3] = pDVar12[2];
						DVar2 = *(DWORD *)((int)local_16c + uVar8);
						*pDVar6 = 0xffffffff;
						pDVar6[-2] = DVar2;
						pDVar6[-1] = *(DWORD *)((int)local_17c + uVar8);
						pDVar6 = pDVar6 + 9;
						uVar8 = uVar9;
					} while (uVar9 < 0x10);
					Container_Mesh_SetVertices(*buffer,local_184,uVar10,4,local_90);
					uVar10 += 4;
					pDVar12 = pDVar12 + 3;
				} while (uVar10 < 0x14);
				Container_Mesh_SetQuality(*buffer,local_184,QUALITY_GOURAUD);
				local_184 += 1;
			} while (local_184 < 10);
			Container_Hide(*buffer,1);
			return (int **)buffer;
		}
		std::free(buffer);
	}
	return (int **)NULL;
}



// Translate and rotate a set of integer points (max of 20).
// Returns a pointer to a temporary buffer that will be modified when this function is next called.
// 
// DIRECTION_UP is "no rotation"

Point2I * __cdecl
lego::game::Game_TransformShapePoints
					(Point2I *translation,Point2I *shapePoints,int shapeCount,Direction rotation)
{
	Point2I *dstPoint;
	uint signBit;
	int swapPoint_x;
	
	if (shapeCount != 0) {
		signBit = (int)(rotation + 0x8000) >> 0x1f;
		dstPoint = globals::tmp_TransformShapePoints;
		do {
										// POINTER MATH to get shapePoints[i] from dstPoints[i]
										// dstPoint->x = shapePoints[i].x;
										// dstPoint->y = shapePoints[i].y;
			dstPoint->x = *(int *)((int)&dstPoint->x + (int)&shapePoints[-0xa0479].x);
			dstPoint->y = *(int *)((int)((int)shapePoints + -0x5023c4) + (int)dstPoint);
										// apply rotation to dstPoints[i]
										// positive modulus (direction % 4)
			if (true) {
										// case DIRECTION_UP: // (x, y)  no change
				switch(((rotation + 0x8000 ^ signBit) - signBit & 3 ^ signBit) - signBit) {
				default:
					goto switchD_0046441a_caseD_0;
				case DIRECTION_RIGHT:
										// (-y, x)
					swapPoint_x = dstPoint->x;
					dstPoint->x = -dstPoint->y;
					goto LAB_00464440;
				case DIRECTION_DOWN:
										// (-x, -y)
					dstPoint->x = -dstPoint->x;
					swapPoint_x = dstPoint->y;
					break;
				case DIRECTION_LEFT:
										// (y, -x)
					swapPoint_x = dstPoint->x;
					dstPoint->x = dstPoint->y;
				}
				swapPoint_x = -swapPoint_x;
LAB_00464440:
				dstPoint->y = swapPoint_x;
			}
switchD_0046441a_caseD_0:
										// apply translation to dstPoints[i]
			dstPoint->x = dstPoint->x + translation->x;
			shapeCount += -1;
			dstPoint->y = dstPoint->y + translation->y;
			dstPoint = dstPoint + 1;
		} while (shapeCount != 0);
	}
	return globals::tmp_TransformShapePoints;
}



uint __cdecl
lego::res::ResLp_UnkSurfaceMap_FUN_00464480
					(Container **pResData,int *param_2,int param_3,uint param_4,Direction direction,
					SurfaceMap *surfMap,int param_7)
{
	int iVar1;
	D3DRMGroupIndex group;
	bool bVar2;
	bool bVar3;
	bool bVar4;
	bool bVar5;
	byte bVar6;
	Point2I *pPVar7;
	BOOL BVar8;
	uint uVar9;
	float *pfVar10;
	int *piVar11;
	D3DRMVertex *pDVar12;
	D3DRMVertex *pDVar13;
	uint uVar14;
	int iVar15;
	int *piVar16;
	Point2I *pPVar17;
	int iVar18;
	Point2I *pPVar19;
	float local_3d8;
	float local_3d4;
	uint local_3d0;
	Point2I *local_3cc;
	Point2I *local_3c8;
	float local_3c4;
	D3DRMGroupIndex local_3c0;
	Point2I local_3ac;
	BOOL local_3a4;
	int local_3a0 [5];
	undefined4 local_38c;
	undefined4 local_388;
	undefined4 local_384;
	int local_380 [4];
	undefined4 local_370;
	undefined4 local_36c;
	undefined4 local_368;
	undefined4 local_364;
	undefined4 local_360;
	undefined4 local_35c;
	undefined4 local_358;
	undefined4 local_354;
	undefined4 local_350;
	undefined4 local_34c;
	undefined4 local_348;
	undefined4 local_344;
	undefined4 local_340;
	undefined4 local_33c;
	undefined4 local_338;
	undefined4 local_334;
	float local_330 [24];
	D3DRMVertex local_2d0 [20];
	
	local_380[2] = 2;
	local_354 = 2;
	local_350 = 2;
	local_380[3] = 3;
	local_368 = 5;
	local_35c = 5;
	local_344 = 3;
	local_340 = 3;
	local_380[1] = 1;
	local_364 = 1;
	local_360 = 1;
	bVar6 = 1;
	local_348 = 7;
	local_33c = 7;
	local_358 = 6;
	local_34c = 6;
	uVar14 = 0;
	local_3c0 = D3DRMGROUP_0;
	local_380[0] = 0;
	local_370 = 0;
	local_36c = 4;
	local_338 = 4;
	local_334 = 0;
	pPVar7 = game::Game_TransformShapePoints((Point2I *)param_2,(Point2I *)param_3,param_4,direction);
	local_3a4 = game::Map3D_FUN_0044eb80
												((globs::gameGlobs.level)->surfaceMap,(uint *)pPVar7,param_4,
												 (globs::gameGlobs.level)->BuildingTolerance,
												 (globs::gameGlobs.level)->BuildingMaxVariation);
	bVar5 = false;
	bVar4 = false;
	bVar3 = false;
	if (param_4 != 0) {
		local_3a0[2] = 1;
		local_38c = 1;
		local_3a0[0] = 0;
		local_3a0[1] = 0xffffffff;
		local_3a0[3] = 0;
		local_3a0[4] = 0;
		local_388 = 0xffffffff;
		local_384 = 0;
		piVar11 = &pPVar7->y;
		pPVar19 = pPVar7;
		pPVar17 = pPVar7;
		do {
			local_3c8 = pPVar17 + 1;
			bVar2 = false;
			piVar16 = local_3a0 + 1;
			local_3cc = (Point2I *)0x4;
			do {
				local_3ac.x = piVar16[-1] + pPVar19->x;
				local_3ac.y = *piVar11 + *piVar16;
				BVar8 = game::Level_Block_IsPowerPath(&local_3ac);
				if ((BVar8 != 0) && (uVar9 = FUN_00432f60((int *)&local_3ac), uVar9 == 0)) {
					bVar4 = true;
					bVar2 = true;
				}
				piVar16 = piVar16 + 2;
				local_3cc = (Point2I *)((int)local_3cc + -1);
			} while (local_3cc != NULL);
			if (((uVar14 < param_4 - 1) && (pPVar19->x == local_3c8->x)) && (*piVar11 == pPVar17[1].y)) {
				if (bVar2) {
					bVar5 = true;
				}
				uVar14 += 1;
				pPVar19 = pPVar19 + 1;
				piVar11 = piVar11 + 2;
				bVar3 = true;
				local_3c8 = pPVar17 + 2;
			}
			uVar14 += 1;
			pPVar19 = pPVar19 + 1;
			piVar11 = piVar11 + 2;
			pPVar17 = local_3c8;
		} while (uVar14 < param_4);
	}
	if (bVar3) {
		bVar4 = bVar5;
	}
	local_3d0 = 0;
	group = D3DRMGROUP_0;
	if (param_4 != 0) {
		local_3ac.x = param_4 - 1;
		pPVar17 = pPVar7;
		pPVar19 = pPVar7;
		do {
			local_3cc = pPVar19 + 1;
			if (((local_3d0 < (uint)local_3ac.x) && (pPVar17->x == local_3cc->x)) &&
				 (pPVar17->y == pPVar19[1].y)) {
				iVar15 = 1;
				local_3c8 = (Point2I *)0x1;
				if (param_7 + 1 <= local_3c0) goto LAB_0046471f;
			}
			else {
				local_3c8 = NULL;
LAB_0046471f:
				iVar15 = 0;
			}
			BVar8 = game::Level_FUN_00431a50(pPVar17->x,pPVar17->y,(int)local_3c8,iVar15);
			if (((BVar8 == 0) || (!bVar4)) ||
				 (local_3d8 = (float)game::Level_BlockPointerCheck((Point2I *)param_2), local_3d8 != 0.0)) {
				bVar6 = 0;
				local_3d8 = 0.6;
				local_3d4 = 0.0;
LAB_004647ee:
				local_3c4 = 0.0;
			}
			else {
				if (iVar15 == 0) {
					if (local_3c8 != NULL) {
						local_3d8 = 0.7;
						local_3d4 = 0.7;
						goto LAB_004647ee;
					}
					if (local_3a4 == 0) {
						bVar6 = 0;
						local_3d8 = 0.7;
						local_3d4 = 0.0;
						local_3c4 = 0.7;
					}
					else {
						local_3d8 = 0.0;
						local_3d4 = 0.7;
						local_3c4 = 0.1;
					}
				}
				else {
					local_3d4 = 0.7;
					local_3c4 = 0.9;
				}
			}
			Container_Mesh_SetColourAlpha(*pResData,local_3c0,local_3d8,local_3d4,local_3c4,0.2);
			Container_Mesh_SetEmissive
								(*pResData,local_3c0,local_3d8 * 0.5,local_3d4 * 0.5,local_3c4 * 0.5);
			BVar8 = game::Map3D_IsInsideDimensions(surfMap,pPVar17->x,pPVar17->y);
			if (BVar8 == 0) {
				Container_Mesh_HideGroup(*pResData,local_3c0,1);
			}
			else {
				game::Map3D_FillLargeStruct_AtXY_FUN_004504e0(surfMap,pPVar17->x,pPVar17->y,local_330);
				iVar15 = 4;
				pfVar10 = local_330 + 2;
				do {
					iVar15 += -1;
					pfVar10[10] = pfVar10[-2];
					pfVar10[0xb] = pfVar10[-1];
					pfVar10[0xc] = *pfVar10;
					*pfVar10 = *pfVar10 - (float)pResData[1];
					pfVar10 = pfVar10 + 3;
				} while (iVar15 != 0);
				Container_Mesh_GetVertices(*pResData,local_3c0,0,0x14,local_2d0);
				piVar11 = local_380;
				pDVar12 = local_2d0;
				iVar15 = 5;
				do {
					iVar18 = 4;
					pDVar13 = pDVar12;
					do {
						iVar1 = *piVar11;
						piVar11 = piVar11 + 1;
						pDVar12 = pDVar13 + 1;
						iVar18 += -1;
						(pDVar13->position).x = local_330[iVar1 * 3];
						(pDVar13->position).y = local_330[iVar1 * 3 + 1];
						(pDVar13->position).z = local_330[iVar1 * 3 + 2];
						pDVar13 = pDVar12;
					} while (iVar18 != 0);
					iVar15 += -1;
				} while (iVar15 != 0);
				Container_Mesh_SetVertices(*pResData,local_3c0,0,0x14,local_2d0);
				Container_Mesh_HideGroup(*pResData,local_3c0,0);
			}
			local_3c0 += 1;
			if (local_3c8 != NULL) {
				local_3d0 += 1;
				pPVar17 = pPVar17 + 1;
				local_3cc = pPVar19 + 2;
			}
			local_3d0 += 1;
			pPVar17 = pPVar17 + 1;
			pPVar19 = local_3cc;
			group = local_3c0;
		} while (local_3d0 < param_4);
	}
	for (; group < 10; group = group + 1) {
		Container_Mesh_HideGroup(*pResData,group,1);
	}
	return -(uint)bVar6 & (uint)pPVar7;
}



void __cdecl lego::res::ResLp_Hide(Container **pResData,BOOL hide)
{
	Container_Hide(*pResData,hide);
	return;
}



void __cdecl lego::snd::SFX_InitHashNames(void)
{
	uint uVar1;
	
										// new uint[495]
	globals::g_SFXHashNames_TABLE = (uint *)std::malloc(0x7bc);
	uVar1 = util::Util_HashString("SFX_NULL",0,1);
	*globals::g_SFXHashNames_TABLE = uVar1;
	uVar1 = util::Util_HashString("SFX_Stamp",0,1);
	globals::g_SFXHashNames_TABLE[1] = uVar1;
	uVar1 = util::Util_HashString("SFX_Drill",0,1);
	globals::g_SFXHashNames_TABLE[2] = uVar1;
	uVar1 = util::Util_HashString("SFX_DrillFade",0,1);
	globals::g_SFXHashNames_TABLE[3] = uVar1;
	uVar1 = util::Util_HashString("SFX_RockBreak",0,1);
	globals::g_SFXHashNames_TABLE[4] = uVar1;
	uVar1 = util::Util_HashString("SFX_Drip",0,1);
	globals::g_SFXHashNames_TABLE[5] = uVar1;
	uVar1 = util::Util_HashString("SFX_Ambient",0,1);
	globals::g_SFXHashNames_TABLE[6] = uVar1;
	uVar1 = util::Util_HashString("SFX_AmbientLoop",0,1);
	globals::g_SFXHashNames_TABLE[7] = uVar1;
	uVar1 = util::Util_HashString("SFX_Step",0,1);
	globals::g_SFXHashNames_TABLE[8] = uVar1;
	uVar1 = util::Util_HashString("SFX_RockMonster",0,1);
	globals::g_SFXHashNames_TABLE[9] = uVar1;
	uVar1 = util::Util_HashString("SFX_RockMonster2",0,1);
	globals::g_SFXHashNames_TABLE[10] = uVar1;
	uVar1 = util::Util_HashString("SFX_RockMonsterStep",0,1);
	globals::g_SFXHashNames_TABLE[0xb] = uVar1;
	uVar1 = util::Util_HashString("SFX_MFDeposit",0,1);
	globals::g_SFXHashNames_TABLE[0xc] = uVar1;
	uVar1 = util::Util_HashString("SFX_ButtonPressed",0,1);
	globals::g_SFXHashNames_TABLE[0xd] = uVar1;
	uVar1 = util::Util_HashString("SFX_MFLift",0,1);
	globals::g_SFXHashNames_TABLE[0xe] = uVar1;
	uVar1 = util::Util_HashString("SFX_MFThrow",0,1);
	globals::g_SFXHashNames_TABLE[0xf] = uVar1;
	uVar1 = util::Util_HashString("SFX_Walker",0,1);
	globals::g_SFXHashNames_TABLE[0x10] = uVar1;
	uVar1 = util::Util_HashString("SFX_YesSir",0,1);
	globals::g_SFXHashNames_TABLE[0x11] = uVar1;
	uVar1 = util::Util_HashString("SFX_Build",0,1);
	globals::g_SFXHashNames_TABLE[0x12] = uVar1;
	uVar1 = util::Util_HashString("SFX_Okay",0,1);
	globals::g_SFXHashNames_TABLE[0x13] = uVar1;
	uVar1 = util::Util_HashString("SFX_NotOkay",0,1);
	globals::g_SFXHashNames_TABLE[0x14] = uVar1;
	uVar1 = util::Util_HashString("SFX_InterfaceSlideOnScreen",0,1);
	globals::g_SFXHashNames_TABLE[0x15] = uVar1;
	uVar1 = util::Util_HashString("SFX_InterfaceSlideOffScreen",0,1);
	globals::g_SFXHashNames_TABLE[0x16] = uVar1;
	uVar1 = util::Util_HashString("SFX_PanelSlideOnScreen",0,1);
	globals::g_SFXHashNames_TABLE[0x17] = uVar1;
	uVar1 = util::Util_HashString("SFX_PanelSlideOffScreen",0,1);
	globals::g_SFXHashNames_TABLE[0x18] = uVar1;
	uVar1 = util::Util_HashString("SFX_Siren",0,1);
	globals::g_SFXHashNames_TABLE[0x19] = uVar1;
	uVar1 = util::Util_HashString("SFX_CrystalRecharge",0,1);
	globals::g_SFXHashNames_TABLE[0x1a] = uVar1;
	uVar1 = util::Util_HashString("SFX_Laser",0,1);
	globals::g_SFXHashNames_TABLE[0x1b] = uVar1;
	uVar1 = util::Util_HashString("SFX_LaserHit",0,1);
	globals::g_SFXHashNames_TABLE[0x1c] = uVar1;
	uVar1 = util::Util_HashString("SFX_LazerRecharge",0,1);
	globals::g_SFXHashNames_TABLE[0x1d] = uVar1;
	uVar1 = util::Util_HashString("SFX_TopPriority",0,1);
	globals::g_SFXHashNames_TABLE[0x1e] = uVar1;
	uVar1 = util::Util_HashString("SFX_ImmovableRock",0,1);
	globals::g_SFXHashNames_TABLE[0x1f] = uVar1;
	uVar1 = util::Util_HashString("SFX_Wall",0,1);
	globals::g_SFXHashNames_TABLE[0x20] = uVar1;
	uVar1 = util::Util_HashString("SFX_Floor",0,1);
	globals::g_SFXHashNames_TABLE[0x21] = uVar1;
	uVar1 = util::Util_HashString("SFX_BoulderHit",0,1);
	globals::g_SFXHashNames_TABLE[0x22] = uVar1;
	uVar1 = util::Util_HashString("SFX_Place",0,1);
	globals::g_SFXHashNames_TABLE[0x23] = uVar1;
	uVar1 = util::Util_HashString("SFX_PlaceOre",0,1);
	globals::g_SFXHashNames_TABLE[0x24] = uVar1;
	uVar1 = util::Util_HashString("SFX_PlaceCrystal",0,1);
	globals::g_SFXHashNames_TABLE[0x25] = uVar1;
	uVar1 = util::Util_HashString("SFX_Lava",0,1);
	globals::g_SFXHashNames_TABLE[0x26] = uVar1;
	uVar1 = util::Util_HashString("SFX_RockWipe",0,1);
	globals::g_SFXHashNames_TABLE[0x27] = uVar1;
	uVar1 = util::Util_HashString("SFX_FallIn",0,1);
	globals::g_SFXHashNames_TABLE[0x28] = uVar1;
	uVar1 = util::Util_HashString("SFX_MusicLoop",0,1);
	globals::g_SFXHashNames_TABLE[0x29] = uVar1;
	uVar1 = util::Util_HashString("SFX_CaptainSlide",0,1);
	globals::g_SFXHashNames_TABLE[0x2a] = uVar1;
	uVar1 = util::Util_HashString("SFX_Dynamite",0,1);
	globals::g_SFXHashNames_TABLE[0x2b] = uVar1;
	uVar1 = util::Util_HashString("SFX_AmbientMusicLoop",0,1);
	globals::g_SFXHashNames_TABLE[0x2c] = uVar1;
	res::Container_SetSoundTriggerCallback(SFX_Container_SoundTriggerCallback,0);
	return;
}



void __cdecl
lego::snd::SFX_Container_SoundTriggerCallback(char *sampleName,Container *cont,void *data)
{
	BOOL BVar1;
	
	BVar1 = SFX_GetType(sampleName,(SFXType *)&sampleName);
	if (BVar1 != 0) {
		res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(cont,(SFXType)sampleName,FALSE,TRUE,NULL);
	}
	return;
}



void __cdecl lego::snd::SFX_SetSamplePopulateMode(BOOL populate)
{
	if (populate != 0) {
		globals::g_AudioFlags = globals::g_AudioFlags | AUDIO_POPULATEMODE;
		return;
	}
	globals::g_AudioFlags = globals::g_AudioFlags & ~AUDIO_POPULATEMODE;
	return;
}



BOOL __cdecl lego::snd::SFX_GetType(char *sfxName,SFXType *out_sfxType)
{
	SFXType SVar1;
	uint uVar2;
	SFXType SVar3;
	uint *puVar4;
	
	if (sfxName != NULL) {
										// hash_string(sfxName, false (!bIgnoreBlanks), true (bIgnoreCase))
		uVar2 = util::Util_HashString(sfxName,FALSE,TRUE);
		SVar3 = SFX_NULL;
		SVar1 = globals::g_SFXHashNames_COUNT + 0x2d;
		puVar4 = globals::g_SFXHashNames_TABLE;
		if (SVar1 != SFX_NULL) {
			do {
				if (uVar2 == *puVar4) {
					*out_sfxType = SVar3;
					return TRUE;
				}
				SVar3 += SFX_STAMP;
				puVar4 = puVar4 + 1;
			} while (SVar3 < SVar1);
		}
										// This flag presumably states the SFX table is still being built
		if (((byte)globals::g_AudioFlags & AUDIO_POPULATEMODE) != 0) {
			*out_sfxType = SVar1;
										// hash_string(sfxName, false (!bIgnoreBlanks), true (bIgnoreCase))
			uVar2 = util::Util_HashString(sfxName,FALSE,TRUE);
			globals::g_SFXHashNames_TABLE[SVar1] = uVar2;
			globals::g_SFXHashNames_COUNT = globals::g_SFXHashNames_COUNT + 1;
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::snd::SFX_Sample_LoadProperty(char *value,int index)
{
	char cVar1;
	uint uVar2;
	SampleProperty *pSVar3;
	char cVar4;
	int iVar5;
	char *pcVar6;
	BOOL stream;
	char *pcVar7;
	SampleProperty *pSVar8;
	char **local_1e0;
	int numParts;
	BOOL success;
	SampleProperty *lastItem;
	char pound_buffer [64];
	char *filename_parts [100];
	
	pSVar8 = globals::g_SampleProperties_TABLE + index;
	stream = 0;
	success = 1;
	lastItem = NULL;
	globals::g_SampleProperties_TABLE[index].next = NULL;
	numParts = util::Util_Tokenise(value,filename_parts,",");
	if (numParts != 0) {
		local_1e0 = filename_parts;
		do {
			pcVar7 = *local_1e0;
			cVar1 = *pcVar7;
			if (cVar1 == '*') {
				pcVar7 = pcVar7 + 1;
			}
			iVar5 = 0;
			if (*pcVar7 == '#') {
				cVar4 = pcVar7[1];
				pcVar7 = pcVar7 + 1;
				if (cVar4 != '#') {
					pcVar6 = pound_buffer;
					do {
						*pcVar6 = cVar4;
						cVar4 = pcVar7[1];
						pcVar6 = pcVar6 + 1;
						pcVar7 = pcVar7 + 1;
					} while (cVar4 != '#');
				}
				iVar5 = std::atoi(pound_buffer);
				pcVar7 = pcVar7 + 1;
			}
			if (*pcVar7 == '@') {
				stream = 1;
				pcVar7 = pcVar7 + 1;
			}
			iVar5 = Sound3D_Load(pcVar7,stream,(uint)(cVar1 == '*'),iVar5);
			pSVar8->sampleIndex = iVar5;
			uVar2 = globals::g_SampleGroups_COUNT;
			if (iVar5 == -1) {
				success = 0;
				pSVar3 = lastItem;
			}
			else {
				pSVar3 = pSVar8;
				if (lastItem != NULL) {
					pSVar8 = globals::g_SampleGroups_TABLE + globals::g_SampleGroups_COUNT;
					globals::g_SampleGroups_COUNT += 1;
					lastItem->next = pSVar8;
					globals::g_SampleGroups_TABLE[uVar2].next = NULL;
					pSVar3 = pSVar8;
				}
			}
			lastItem = pSVar3;
			local_1e0 = local_1e0 + 1;
			numParts += -1;
		} while (numParts != 0);
	}
	return success;
}



int __cdecl lego::snd::SFX_Sample_Random_GetSoundHandle(SFXType sfxType)
{
	SampleProperty *pSVar1;
	SampleProperty *pSVar2;
	int iVar3;
	short sVar4;
	uint uVar5;
	
	uVar5 = 0;
	if (sfxType != SFX_NULL) {
		if (globals::g_SampleProperties_TABLE[sfxType].next != NULL) {
			pSVar1 = globals::g_SampleProperties_TABLE + sfxType;
			for (pSVar2 = pSVar1; pSVar2 != NULL; pSVar2 = pSVar2->next) {
				uVar5 += 1;
			}
			sVar4 = math::Maths_Rand();
			pSVar2 = pSVar1;
			for (uVar5 = (uint)(int)sVar4 % uVar5; uVar5 != 0; uVar5 -= 1) {
				pSVar2 = pSVar2->next;
			}
			iVar3 = pSVar2->sampleIndex;
			pSVar2->sampleIndex = pSVar1->sampleIndex;
			pSVar1->sampleIndex = iVar3;
		}
		return globals::g_SampleProperties_TABLE[sfxType].sampleIndex;
	}
	return -1;
}



void __cdecl lego::snd::SFX_StopGlobalSample(void)
{
	if ((globals::g_GlobalSampleSoundHandle != -1) &&
		 ((ushort)((ushort)(globals::g_GlobalSampleDuration < 0.0) << 8 |
							(ushort)(globals::g_GlobalSampleDuration == 0.0) << 0xe) == 0)) {
		SFX_Sample_Sound3D_StopSound(globals::g_GlobalSampleSoundHandle);
		globals::g_GlobalSampleSoundHandle = -1;
		globals::g_GlobalSampleDuration = 0.0;
	}
	return;
}



BOOL __cdecl lego::snd::SFX_SetGlobalSampleDurationIfLE0_AndNullifyHandle(float duration)
{
	if ((ushort)((ushort)(globals::g_GlobalSampleDuration < 0.0) << 8 |
							(ushort)(globals::g_GlobalSampleDuration == 0.0) << 0xe) != 0) {
		globals::g_GlobalSampleDuration = duration;
		globals::g_GlobalSampleSoundHandle = -1;
		return TRUE;
	}
	return 0;
}



BOOL __cdecl lego::snd::SFX_Sample_Random_SetAndPlayGlobalSample(SFXType sfxType,int *out_handle)
{
	float10 fVar1;
	
	if ((ushort)((ushort)(globals::g_GlobalSampleDuration < 0.0) << 8 |
							(ushort)(globals::g_GlobalSampleDuration == 0.0) << 0xe) != 0) {
		globals::g_GlobalSampleSoundHandle = SFX_Sample_Random_Play_OrAddToQueue(sfxType,FALSE);
		if (globals::g_GlobalSampleSoundHandle != -1) {
			fVar1 = SFX_Sample_Random_GetSamplePlayTime(sfxType);
			globals::g_GlobalSampleSFXType = sfxType;
			globals::g_GlobalSampleDuration = (float)(fVar1 * (float10)25.0);
			if (out_handle != NULL) {
				*out_handle = globals::g_GlobalSampleSoundHandle;
			}
			return TRUE;
		}
	}
	return 0;
}



void __cdecl lego::snd::SFX_Sample_AddToQueue(SFXType sfxType,BOOL mode)
{
	if (globals::g_SoundQueue_Unk1_COUNT < 10) {
		globals::g_SoundQueueIndexes_Unk1_TABLE[globals::g_SoundQueue_Unk1_COUNT] = sfxType;
		globals::g_SoundQueueModes_Unk1_TABLE[globals::g_SoundQueue_Unk1_COUNT] = mode;
		globals::g_SoundQueue_Unk1_COUNT += 1;
	}
	return;
}



// The return value of this function is a sound3DHandle, BUT ONLY when AudioFlag 0x8 is unset!!!!

int __cdecl lego::snd::SFX_Sample_Random_Play_OrAddToQueue(SFXType sfxType,BOOL loop)
{
	Sound3DInstance *pSVar1;
	uint uVar2;
	Sound3DInstance *in_EAX;
	
	uVar2 = globals::g_Sound3DInstances_COUNT;
	if (((byte)globals::g_AudioFlags & AUDIO_UNK_8) == 0) {
		in_EAX = (Sound3DInstance *)sfxType;
		if ((sfxType != SFX_NULL) && (((byte)globals::g_AudioFlags & AUDIO_SOUNDON) != 0)) {
			in_EAX = (Sound3DInstance *)SFX_Sample_Random_GetSoundHandle(sfxType);
			if (in_EAX != NULL) {
				in_EAX = (Sound3DInstance *)Sound3D_Play2(SOUND3D_PLAY_NORMAL,NULL,(int)in_EAX,loop,NULL);
			}
		}
	}
	else {
		if (globals::g_Sound3DInstances_COUNT < 10) {
			pSVar1 = globals::g_Sound3DInstances_TABLE + globals::g_Sound3DInstances_COUNT;
			globals::g_Sound3DInstances_COUNT = globals::g_Sound3DInstances_COUNT + 1;
			pSVar1->sampleIndex = sfxType;
			globals::g_Sound3DInstances_TABLE[uVar2].flags =
					 globals::g_Sound3DInstances_TABLE[uVar2].flags & 0xfffffffe;
			return (int)pSVar1;
		}
	}
	return (int)in_EAX;
}



void __cdecl lego::snd::SFX_Sample_Random_SetBufferVolume(SFXType sfxType,int volume)
{
	int handle;
	
	handle = SFX_Sample_Random_GetSoundHandle(sfxType);
	Sound3D_SetBufferVolume(handle,volume);
	return;
}



int __cdecl lego::snd::SFX_Sample_Random_GetBufferVolume(SFXType sfxType)
{
	int sfxTypeRng;
	
	sfxTypeRng = SFX_Sample_Random_GetSoundHandle(sfxType);
	sfxTypeRng = Sound3D_GetBufferVolume(sfxTypeRng);
	return sfxTypeRng;
}



void __cdecl
lego::res::SFX_Sample_Container_Random_Play_OrInitSoundUnk
					(Container *cont,SFXType sfxType,BOOL loop,BOOL sound3D,Vector3F *opt_position)
{
	IDirect3DRMFrame3 *frame;
	
	if (cont == NULL) {
		frame = NULL;
	}
	else {
		frame = Container_GetMasterFrame(cont);
	}
	snd::SFX_Sample_Random_Play_OrInitSoundUnk(frame,sfxType,loop,sound3D,opt_position);
	return;
}



int __cdecl
lego::snd::SFX_Sample_Random_Play_OrInitSoundUnk
					(IDirect3DRMFrame3 *frame,SFXType sfxType,BOOL loop,BOOL sound3D,Vector3F *opt_position)
{
	Sound3DInstance *pSVar1;
	uint uVar2;
	int iVar3;
	
	uVar2 = globals::g_Sound3DInstances_COUNT;
	if (((byte)globals::g_AudioFlags & AUDIO_UNK_8) == 0) {
		if ((sfxType != SFX_NULL) && (((byte)globals::g_AudioFlags & AUDIO_SOUNDON) != 0)) {
			iVar3 = SFX_Sample_Random_GetSoundHandle(sfxType);
			if (iVar3 != 0) {
				if (sound3D != 0) {
					iVar3 = Sound3D_Play2(SOUND3D_PLAY_ONFRAME,frame,iVar3,loop,NULL);
					return iVar3;
				}
				iVar3 = Sound3D_Play2(SOUND3D_PLAY_ONPOS,NULL,iVar3,loop,opt_position);
				return iVar3;
			}
		}
	}
	else {
		if (globals::g_Sound3DInstances_COUNT < 10) {
			pSVar1 = globals::g_Sound3DInstances_TABLE + globals::g_Sound3DInstances_COUNT;
			globals::g_Sound3DInstances_COUNT = globals::g_Sound3DInstances_COUNT + 1;
			pSVar1->sampleIndex = sfxType;
			globals::g_Sound3DInstances_TABLE[uVar2].frame = frame;
			globals::g_Sound3DInstances_TABLE[uVar2].flags =
					 ((sound3D & 1U) << 1 | loop & 1U) << 1 |
					 globals::g_Sound3DInstances_TABLE[uVar2].flags & 0xfffffff9 | 1;
			if (opt_position != NULL) {
				globals::g_Sound3DInstances_TABLE[uVar2].position.x = opt_position->x;
				globals::g_Sound3DInstances_TABLE[uVar2].position.y = opt_position->y;
				globals::g_Sound3DInstances_TABLE[uVar2].position.z = opt_position->z;
				return 0;
			}
		}
	}
	return 0;
}



float10 __cdecl lego::snd::SFX_Sample_Random_GetSamplePlayTime(SFXType sfxType)
{
	int handle;
	float10 fVar1;
	
	handle = SFX_Sample_Random_GetSoundHandle(sfxType);
	if (handle != 0) {
		fVar1 = Sound3D_GetSamplePlayTime(handle);
		return fVar1;
	}
	return (float10)0.0;
}



void __cdecl lego::snd::SFX_Sample_Sound3D_StopSound(int handle)
{
	Sound3D_StopSound(handle);
	return;
}



void __cdecl lego::snd::SFX_Update(float elapsed)
{
	BOOL BVar1;
	SFXType *pSVar2;
	BOOL *pBVar3;
	uint uVar4;
	SFXType *pSVar5;
	BOOL *pBVar6;
	
	BVar1 = SFX_GetFlag8();
	globals::g_GlobalSampleDuration = globals::g_GlobalSampleDuration - elapsed;
	SFX_SetFlag8To_AndOptPlayQueuedInstances(0,0);
	uVar4 = 0;
	if (globals::g_SoundQueue_Unk2_COUNT != 0) {
		pSVar2 = globals::g_SoundQueueIndexes_Unk2_TABLE;
		do {
			SFX_Sample_Random_Play_OrAddToQueue(*pSVar2,pSVar2[10]);
			uVar4 += 1;
			pSVar2 = pSVar2 + 1;
		} while (uVar4 < globals::g_SoundQueue_Unk2_COUNT);
	}
	if (BVar1 != 0) {
		SFX_PlayQueuedInstances_SetFlag8To(1);
	}
										// std::memcpy(globals::g_SoundQueueIndexes_Unk2_TABLE,
										//             globals::g_SoundQueueIndexes_Unk1_TABLE,
										//             globals::g_SoundQueue_Unk1_COUNT * sizeof(int));
	pSVar2 = globals::g_SoundQueueIndexes_Unk1_TABLE;
	pSVar5 = globals::g_SoundQueueIndexes_Unk2_TABLE;
	for (uVar4 = globals::g_SoundQueue_Unk1_COUNT; uVar4 != 0; uVar4 -= 1) {
		*pSVar5 = *pSVar2;
		pSVar2 = pSVar2 + 1;
		pSVar5 = pSVar5 + 1;
	}
										// globals::g_SoundQueue_Unk2_COUNT = globals::g_SoundQueue_Unk1_COUNT;
										// 
										// std::memcpy(globals::g_SoundQueueModes_Unk2_TABLE,
										//             globals::g_SoundQueueModes_Unk1_TABLE,
										//             globals::g_SoundQueue_Unk1_COUNT * sizeof(int));
	pBVar3 = globals::g_SoundQueueModes_Unk1_TABLE;
	pBVar6 = globals::g_SoundQueueModes_Unk2_TABLE;
	for (uVar4 = globals::g_SoundQueue_Unk1_COUNT;
			globals::g_SoundQueue_Unk2_COUNT = globals::g_SoundQueue_Unk1_COUNT, uVar4 != 0; uVar4 -= 1) {
		*pBVar6 = *pBVar3;
		pBVar3 = pBVar3 + 1;
		pBVar6 = pBVar6 + 1;
	}
	globals::g_SoundQueue_Unk1_COUNT = 0;
	SFX_Sound3D_Update();
	return;
}



void __cdecl lego::snd::SFX_Sound3D_Update(void)
{
	Sound3D_SoundRecord *pSVar1;
	uint in_ECX;
	Sound3D_SoundRecord *pSVar2;
	IDirect3DRMFrame3 **ppIVar3;
	uint uStack4;
	
	pSVar2 = globs::sound3DGlobs.soundRecord;
	ppIVar3 = globs::sound3DGlobs.updateFrameList;
	uStack4 = in_ECX;
	do {
		if (*ppIVar3 != NULL) {
			Sound3D_SoundCallback(*ppIVar3,NULL,0.0);
		}
		ppIVar3 = ppIVar3 + 1;
	} while (ppIVar3 < &globs::sound3DGlobs.reserved1);
	if (pSVar2 != NULL) {
		do {
			pSVar1 = pSVar2->next;
			(*(code *)pSVar2->soundBuff->lpVtbl->GetStatus)(pSVar2->soundBuff,&uStack4);
			if ((uStack4 & 1) == 0) {
				Sound3D_RemoveSound(pSVar2->frame,pSVar2->sound3DBuff);
			}
			pSVar2 = pSVar1;
		} while (pSVar1 != NULL);
	}
	Sound3D_Stream_CheckPosition(0);
	Sound3D_Stream_CheckPosition(1);
	return;
}



void __cdecl lego::snd::SFX_SetSoundStates_IsOn_StopAll(BOOL isSoundOn,BOOL stopAll)
{
	if (isSoundOn != 0) {
		globals::g_AudioFlags = globals::g_AudioFlags | AUDIO_SOUNDON;
		return;
	}
	globals::g_AudioFlags &= ~AUDIO_SOUNDON;
	if (stopAll != 0) {
		Sound3D_StopAllSounds();
	}
	globals::g_GlobalSampleSFXType = SFX_NULL;
	return;
}



void __cdecl lego::snd::SFX_StopAll_AndSetSoundState_IsOn(BOOL isSoundOn)
{
	SFX_SetSoundStates_IsOn_StopAll(isSoundOn,TRUE);
	return;
}



BOOL __cdecl lego::snd::SFX_GetFlag8(void)
{
	return globals::g_AudioFlags & AUDIO_UNK_8;
}



void __cdecl lego::snd::SFX_PlayQueuedInstances_SetFlag8To(BOOL setFlag8)
{
	SFX_SetFlag8To_AndOptPlayQueuedInstances(setFlag8,TRUE);
	return;
}



void __cdecl lego::snd::SFX_SetFlag8To_AndOptPlayQueuedInstances(BOOL setFlag8,BOOL playQueued)
{
	uint uVar1;
	uint *puVar2;
	uint uVar3;
	
	if (setFlag8 != 0) {
		globals::g_AudioFlags = globals::g_AudioFlags | AUDIO_UNK_8;
		return;
	}
	globals::g_AudioFlags &= ~AUDIO_UNK_8;
	if (playQueued != 0) {
		uVar3 = 0;
		if (globals::g_Sound3DInstances_COUNT != 0) {
			puVar2 = &globals::g_Sound3DInstances_TABLE[0].flags;
			do {
				uVar1 = *puVar2;
				if ((uVar1 & 1) == 0) {
					SFX_Sample_Random_Play_OrAddToQueue(puVar2[-5],(int)(uVar1 << 0x1e) >> 0x1f);
				}
				else {
					SFX_Sample_Random_Play_OrInitSoundUnk
										((IDirect3DRMFrame3 *)puVar2[-4],puVar2[-5],(int)(uVar1 << 30) >> 31,
										 (int)(uVar1 << 29) >> 31,(Vector3F *)(puVar2 + -3));
				}
				uVar3 += 1;
				puVar2 = puVar2 + 6;
			} while (uVar3 < globals::g_Sound3DInstances_COUNT);
		}
		globals::g_Sound3DInstances_COUNT = 0;
	}
	return;
}



BOOL __cdecl lego::snd::SFX_IsSoundOn(void)
{
	return globals::g_AudioFlags & AUDIO_SOUNDON;
}



BOOL __cdecl lego::effect::Smoke_Initialise(void)
{
	globs::smokeGlobs.firstSmoke = NULL;
	globs::smokeGlobs.lastSmoke = NULL;
	globs::smokeGlobs.count = 0;
	return TRUE;
}



void __cdecl lego::effect::Smoke_LoadTextures(char *dirname,char *basename,uint count)
{
	Container_Texture *pCVar1;
	uint uVar2;
	Smoke_Globs *pSVar3;
	char buffBmp [260];
	char buffDir [260];
	
	uVar2 = 0;
	globs::smokeGlobs.count = count;
	if (count != 0) {
		pSVar3 = &globs::smokeGlobs;
		do {
			std::sprintf(buffDir,"%s\\",dirname);
			std::sprintf(buffBmp,"%s%i.bmp",basename,uVar2);
			pCVar1 = res::Mesh_LoadTexture(buffDir,buffBmp,0,0);
			pSVar3->textureList[0] = pCVar1;
			uVar2 += 1;
			pSVar3 = (Smoke_Globs *)(pSVar3->textureList + 1);
		} while (uVar2 < count);
	}
	return;
}



SurfaceMapStruct_2a8 * __cdecl
lego::effect::Smoke_CreateSmokeArea
					(int zero_1,uint bx,uint by,Vector3F *vector_pt1_pt1_m1,float r,float g,float b,
					float param_8,float param_9,int mode0,uint randomness,int value38)
{
	SurfaceMapStruct_3c *pSVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	SurfaceMapStruct_2a8 *data;
	SurfaceMap *surfMap;
	Container *pCVar5;
	Mesh *pMVar6;
	D3DRMGroupIndex DVar7;
	uint uVar8;
	int iVar9;
	SurfaceMapStruct_2a8 *pSVar10;
	uint uVar11;
	uint uVar12;
	float10 fVar13;
	ulonglong uVar14;
	longlong lVar15;
	float local_24;
	float local_20;
	float local_1c;
	uint faceData [6];
	
	uVar12 = 0;
	faceData[0] = 0;
	faceData[1] = 3;
	faceData[2] = 2;
	faceData[3] = 2;
	faceData[4] = 1;
	faceData[5] = 0;
	data = (SurfaceMapStruct_2a8 *)std::malloc(0x2a8);
	pSVar10 = data;
	for (iVar9 = 0xaa; iVar9 != 0; iVar9 += -1) {
		pSVar10->groupList[0].used_0 = 0;
		pSVar10 = (SurfaceMapStruct_2a8 *)&pSVar10->groupList[0].vector_4;
	}
	if ((mode0 == 0) || (mode0 == 2)) {
		surfMap = game::GetSurfaceMap();
		pCVar5 = res::GetRoot();
		uVar14 = __ftol((float10)surfMap->BlockSize * (float10)0.6);
		game::Map3D_BlockToWorldPos(surfMap,bx,by,&local_24,&local_20);
		fVar2 = (float)(uVar14 & 0xffffffff) * 0.5;
		local_24 = ((float)(((ulonglong)randomness % 0x109e) % (uVar14 & 0xffffffff)) - fVar2) +
							 local_24;
		local_20 = ((float)(((ulonglong)randomness % 0x5eb) % (uVar14 & 0xffffffff)) - fVar2) + local_20
		;
		fVar13 = game::Map3D_GetWorldZ(surfMap,local_24,local_20);
		local_1c = (float)fVar13;
		pCVar5 = res::Container_Create(pCVar5);
		data->resData_28c = pCVar5;
		res::Container_SetPosition(pCVar5,NULL,local_24,local_20,local_1c);
		data->flags_294 = SURFMAP_STRUCT2A8_UNK_2;
		(data->vector_25c).x = local_24;
		(data->vector_25c).y = local_20;
		(data->vector_25c).z = local_1c;
		if ((randomness & 3) == 0) {
			data->field_2a0 = value38;
		}
	}
	else {
		if (mode0 == 1) {
			data->flags_294 = SURFMAP_STRUCT2A8_UNK_4;
			data->resData_28c = (Container *)zero_1;
		}
	}
	(data->vector_268).x = vector_pt1_pt1_m1->x;
	fVar3 = vector_pt1_pt1_m1->y;
	(data->vector_268).y = fVar3;
	fVar4 = vector_pt1_pt1_m1->z;
	(data->vector_268).z = fVar4;
	fVar2 = (data->vector_268).x;
	fVar2 = 1.0 / SQRT(fVar2 * fVar2 + fVar4 * fVar4 + fVar3 * fVar3);
	(data->vector_268).x = fVar2 * (data->vector_268).x;
	(data->vector_268).y = fVar2 * (data->vector_268).y;
	(data->vector_268).z = fVar2 * (data->vector_268).z;
	(data->colour).red = r;
	(data->colour).green = g;
	(data->colour).blue = b;
	if (mode0 == 2) {
		data->groupCount = 4;
		data->int_284 = 0;
		data->flags_294 = data->flags_294 | SURFMAP_STRUCT2A8_UNK_8;
		data->float_288 = 2.0;
	}
	else {
		if (((ushort)((ushort)(param_8 < 0.0) << 8 | (ushort)(param_8 == 0.0) << 0xe) == 0) ||
			 (param_8 < 1.0)) {
			lVar15 = __ftol((float10)param_8 * (float10)10.0);
			data->groupCount = (uint)lVar15;
		}
		else {
			data->groupCount = 10;
		}
		data->float_288 = param_9;
	}
	pMVar6 = res::Mesh_CreateOnFrame
										 (data->resData_28c->activityFrame,Smoke_MeshRenderCallback,0x4800,data,
											MESH_TYPE_NORM);
	data->mesh = pMVar6;
	if (data->groupCount != 0) {
		do {
			DVar7 = res::Mesh_AddGroup(data->mesh,4,2,3,faceData);
			pSVar1 = data->groupList + DVar7;
			res::Mesh_SetGroupTexture
								(data->mesh,DVar7,globs::smokeGlobs.textureList[uVar12 % globs::smokeGlobs.count]);
			res::Mesh_SetGroupColour(data->mesh,DVar7,r,g,b,MATERIAL_DIFFUSE);
			res::Mesh_SetGroupColour(data->mesh,DVar7,r * 0.2,g * 0.2,b * 0.2,MATERIAL_EMISSIVE);
			res::Mesh_HideGroup(data->mesh,DVar7,1);
			uVar8 = std::rand();
			uVar11 = (int)uVar8 >> 0x1f;
			(&pSVar1->used_0)[10] =
					 (BOOL)((float)(((uVar8 ^ uVar11) - uVar11 & 3 ^ uVar11) - uVar11) - -6.0);
			uVar8 = std::rand();
			uVar11 = (int)uVar8 >> 0x1f;
			fVar2 = ((float)(((uVar8 ^ uVar11) - uVar11 & 3 ^ uVar11) - uVar11) +
							(float)(&pSVar1->used_0)[10]) - -2.0;
			(&pSVar1->used_0)[0xb] = (BOOL)fVar2;
			if ((*(byte *)&data->flags_294 & 8) == 0) {
				(&pSVar1->used_0)[10] = (BOOL)((float)(&pSVar1->used_0)[10] * 0.5);
			}
			else {
				(&pSVar1->used_0)[0xb] = (BOOL)(fVar2 + fVar2);
			}
			uVar12 += 1;
		} while (uVar12 < data->groupCount);
	}
	data->float_258 = 0.0;
	if (mode0 != 2) {
		iVar9 = 10;
		do {
			if ((ushort)((ushort)(data->float_258 < 0.0) << 8 | (ushort)(data->float_258 == 0.0) << 0xe)
					!= 0) {
				DVar7 = D3DRMGROUP_0;
				pSVar10 = data;
				if (data->groupCount != D3DRMGROUP_0) {
					do {
						if (pSVar10->groupList[0].used_0 == 0) {
							Smoke_Group_UpdateUnhide_FUN_00465f10(data,DVar7);
							break;
						}
						DVar7 += 1;
						pSVar10 = (SurfaceMapStruct_2a8 *)(pSVar10->groupList + 1);
					} while (DVar7 < data->groupCount);
				}
			}
			DVar7 = D3DRMGROUP_0;
			data->float_258 = data->float_258 - 5.0;
			pSVar10 = data;
			if (data->groupCount != 0) {
				do {
					if (pSVar10->groupList[0].used_0 != 0) {
						Smoke_Group_Update_FUN_004660c0(data,DVar7,5.0);
					}
					DVar7 += 1;
					pSVar10 = (SurfaceMapStruct_2a8 *)(pSVar10->groupList + 1);
				} while (DVar7 < data->groupCount);
			}
			iVar9 += -1;
		} while (iVar9 != 0);
	}
	data->previous = globs::smokeGlobs.lastSmoke;
	if (globs::smokeGlobs.firstSmoke != NULL) {
		(globs::smokeGlobs.lastSmoke)->next = data;
		globs::smokeGlobs.lastSmoke = data;
		return data;
	}
	globs::smokeGlobs.firstSmoke = data;
	globs::smokeGlobs.lastSmoke = data;
	return data;
}



void __cdecl lego::effect::Smoke_RemoveAll(void)
{
	SurfaceMapStruct_2a8 *pSVar1;
	SurfaceMapStruct_2a8 *pSVar2;
	
	pSVar2 = globs::smokeGlobs.firstSmoke;
	if (globs::smokeGlobs.firstSmoke != NULL) {
		do {
			pSVar1 = pSVar2->next;
			Smoke_Remove(pSVar2,pSVar2->resData_28c);
			pSVar2 = pSVar1;
		} while (pSVar1 != NULL);
	}
	globs::smokeGlobs.firstSmoke = NULL;
	return;
}



void __cdecl lego::effect::Smoke_Remove(SurfaceMapStruct_2a8 *param_1,Container *cont28c)
{
	if ((*(byte *)&param_1->flags_294 & 2) == 0) {
		res::Mesh_Remove(param_1->mesh,cont28c->activityFrame);
	}
	else {
		res::Mesh_Remove(param_1->mesh,param_1->resData_28c->activityFrame);
		res::Container_Remove(param_1->resData_28c);
	}
	if (globs::smokeGlobs.lastSmoke == param_1) {
		globs::smokeGlobs.lastSmoke = param_1->previous;
		if (globs::smokeGlobs.lastSmoke == NULL) {
			globs::smokeGlobs.firstSmoke = globs::smokeGlobs.lastSmoke;
			std::free(param_1);
			return;
		}
	}
	if (param_1->next != NULL) {
		param_1->next->previous = param_1->previous;
		if (param_1->next->previous == NULL) {
			globs::smokeGlobs.firstSmoke = param_1->next;
		}
	}
	if (param_1->previous != NULL) {
		param_1->previous->next = param_1->next;
	}
	if (param_1->soundHandle != 0) {
		snd::SFX_Sample_Sound3D_StopSound(param_1->soundHandle);
	}
	std::free(param_1);
	return;
}



void __cdecl lego::effect::Smoke_HideAll(BOOL hide)
{
	SurfaceMapStruct_2a8 **ppSVar1;
	SurfaceMapStruct_2a8 *pSVar2;
	
	pSVar2 = globs::smokeGlobs.firstSmoke;
	if (globs::smokeGlobs.firstSmoke != NULL) {
		do {
			Smoke_Hide(pSVar2,hide);
			ppSVar1 = &pSVar2->next;
			pSVar2 = *ppSVar1;
		} while (*ppSVar1 != NULL);
	}
	return;
}



void __cdecl lego::effect::Smoke_Hide(SurfaceMapStruct_2a8 *param_1,BOOL hide)
{
	res::Mesh_Hide(param_1->mesh,hide);
	if (hide != 0) {
		param_1->flags_294 = param_1->flags_294 | SURFMAP_STRUCT2A8_HIDDEN;
		return;
	}
	param_1->flags_294 = param_1->flags_294 & ~SURFMAP_STRUCT2A8_HIDDEN;
	return;
}



void __cdecl lego::effect::Smoke_Update(float elapsedGame)
{
	SurfaceMapStruct_2a8 *pSVar1;
	SurfaceMapStruct2A8Flags SVar2;
	bool bVar3;
	Vector3F *opt_position;
	D3DRMGroupIndex DVar4;
	SurfaceMapStruct_2a8 *pSVar5;
	SurfaceMapStruct_2a8 *pSVar6;
	
	pSVar6 = globs::smokeGlobs.firstSmoke;
	if (globs::smokeGlobs.firstSmoke != NULL) {
		do {
			pSVar1 = pSVar6->next;
			bVar3 = true;
			if (((*(byte *)&pSVar6->flags_294 & 0x20) == 0) && (pSVar6->soundHandle == 0)) {
				if (pSVar6->field_2a0 != 0) {
					opt_position = &pSVar6->vector_25c;
					res::SFX_Sample_Container_Random_Play_OrInitSoundUnk
										(NULL,pSVar6->field_2a0,1,0,opt_position);
					pSVar6->soundHandle = (int)opt_position;
				}
				if (pSVar6->soundHandle == 0) {
					pSVar6->flags_294 = pSVar6->flags_294 | 0x20;
				}
			}
			SVar2 = pSVar6->flags_294;
			if ((SVar2 & SURFMAP_STRUCT2A8_HIDDEN) == SURFMAP_STRUCT2A8_NONE) {
				if (((SVar2 & SURFMAP_STRUCT2A8_UNK_8) == SURFMAP_STRUCT2A8_NONE) ||
					 ((SVar2 & SURFMAP_STRUCT2A8_UNK_10) == SURFMAP_STRUCT2A8_NONE)) {
					if ((ushort)((ushort)(pSVar6->float_258 < 0.0) << 8 |
											(ushort)(pSVar6->float_258 == 0.0) << 0xe) != 0) {
						DVar4 = D3DRMGROUP_0;
						pSVar5 = pSVar6;
						if (pSVar6->groupCount != D3DRMGROUP_0) {
							do {
								if (pSVar5->groupList[0].used_0 == 0) {
									Smoke_Group_UpdateUnhide_FUN_00465f10(pSVar6,DVar4);
									break;
								}
								DVar4 += 1;
								pSVar5 = (SurfaceMapStruct_2a8 *)(pSVar5->groupList + 1);
							} while (DVar4 < pSVar6->groupCount);
						}
					}
					pSVar6->float_258 = pSVar6->float_258 - elapsedGame;
				}
				DVar4 = D3DRMGROUP_0;
				pSVar5 = pSVar6;
				if (pSVar6->groupCount != 0) {
					do {
						if (pSVar5->groupList[0].used_0 != 0) {
							Smoke_Group_Update_FUN_004660c0(pSVar6,DVar4,elapsedGame);
							bVar3 = false;
						}
						DVar4 += 1;
						pSVar5 = (SurfaceMapStruct_2a8 *)(pSVar5->groupList + 1);
					} while (DVar4 < pSVar6->groupCount);
				}
				if ((((pSVar6->flags_294 & SURFMAP_STRUCT2A8_UNK_8) != SURFMAP_STRUCT2A8_NONE) &&
						((pSVar6->flags_294 & SURFMAP_STRUCT2A8_UNK_10) != SURFMAP_STRUCT2A8_NONE)) && (bVar3))
				{
					Smoke_Remove(pSVar6,pSVar6->resData_28c);
				}
			}
			pSVar6 = pSVar1;
		} while (pSVar1 != NULL);
	}
	return;
}



int __cdecl
lego::effect::Smoke_Group_UpdateUnhide_FUN_00465f10
					(SurfaceMapStruct_2a8 *param_1,D3DRMGroupIndex groupID)
{
	SurfaceMapStruct_3c *pSVar1;
	float fVar2;
	int iVar3;
	Vector3F local_18;
	Vector3F local_c;
	
	pSVar1 = param_1->groupList + groupID;
	if ((param_1->flags_294 & SURFMAP_STRUCT2A8_UNK_8) != SURFMAP_STRUCT2A8_NONE) {
		if (param_1->int_284 == 3) {
			param_1->flags_294 = param_1->flags_294 | SURFMAP_STRUCT2A8_UNK_10;
		}
		param_1->int_284 = param_1->int_284 + 1;
	}
	pSVar1->used_0 = 1;
	res::Mesh_HideGroup(param_1->mesh,groupID,FALSE);
	math::Maths_Vector3DRandom(&local_18);
	local_18.z = -ABS(local_18.z) * 0.17 - 0.83;
	(&pSVar1->used_0)[1] = (BOOL)(local_18.x * 0.17);
	(&pSVar1->used_0)[2] = (BOOL)(local_18.y * 0.17);
	(&pSVar1->used_0)[3] = (BOOL)local_18.z;
	local_18.z = (param_1->vector_268).z + local_18.z;
	fVar2 = -param_1->float_288 / local_18.z;
	local_18.z = fVar2 * local_18.z;
	local_18.x = fVar2 * ((param_1->vector_268).x + local_18.x * 0.17);
	local_18.y = fVar2 * ((param_1->vector_268).y + local_18.y * 0.17);
	param_1->flags_294 = SURFMAP_STRUCT2A8_UNK_4;
	res::Container_GetPosition(param_1->resData_28c,NULL,&local_c);
	(&pSVar1->used_0)[7] = (BOOL)local_c.x;
	(&pSVar1->used_0)[0xc] = 0;
	(&pSVar1->used_0)[0xe] = 0;
	(&pSVar1->used_0)[8] = (BOOL)local_c.y;
	(&pSVar1->used_0)[9] = (BOOL)local_c.z;
	(&pSVar1->used_0)[4] = (BOOL)local_18.x;
	(&pSVar1->used_0)[5] = (BOOL)local_18.y;
	(&pSVar1->used_0)[6] = (BOOL)local_18.z;
	iVar3 = std::rand();
	(&pSVar1->used_0)[0xd] = iVar3 % 0x1e + 0x28;
	param_1->float_258 = (0.5 / param_1->float_288) * (float)(&pSVar1->used_0)[0xb];
	return iVar3 / 0x1e;
}



void __cdecl
lego::effect::Smoke_Group_Update_FUN_004660c0
					(SurfaceMapStruct_2a8 *param_1,D3DRMGroupIndex groupID,float elapsedGame)
{
	SurfaceMapStruct_3c *pSVar1;
	float fVar2;
	float fVar3;
	
	fVar2 = param_1->groupList[groupID].vector_10.y;
	pSVar1 = param_1->groupList + groupID;
	fVar3 = (float)(&pSVar1->used_0)[6] * elapsedGame;
	(&pSVar1->used_0)[7] =
			 (BOOL)(param_1->groupList[groupID].vector_10.x * elapsedGame + (float)(&pSVar1->used_0)[7]);
	(&pSVar1->used_0)[8] = (BOOL)((float)(&pSVar1->used_0)[8] + fVar2 * elapsedGame);
	(&pSVar1->used_0)[9] = (BOOL)((float)(&pSVar1->used_0)[9] + fVar3);
	fVar2 = ABS(fVar3) + (float)(&pSVar1->used_0)[0xe];
	(&pSVar1->used_0)[0xe] = (BOOL)fVar2;
	if ((float)(&pSVar1->used_0)[0xd] <= fVar2) {
		pSVar1->used_0 = 0;
		res::Mesh_HideGroup(param_1->mesh,groupID,TRUE);
		return;
	}
	(&pSVar1->used_0)[0xc] = (BOOL)(elapsedGame + (float)(&pSVar1->used_0)[0xc]);
	res::Mesh_SetGroupMaterialValues
						(param_1->mesh,groupID,0.7 - (fVar2 / (float)(&pSVar1->used_0)[0xd]) * 0.7,
						 MATERIAL_ALPHA);
	return;
}



void __cdecl
lego::effect::Smoke_MeshRenderCallback(Mesh *mesh,SurfaceMapStruct_2a8 *data,Viewport *view)
{
	Container *cont;
	SurfaceMapStruct_2a8 *pSVar1;
	D3DRMGroupIndex groupID;
	Vector3F lightPos;
	
	cont = game::Game_GetCurrentViewLight();
	res::Container_GetPosition(cont,NULL,&lightPos);
	groupID = D3DRMGROUP_0;
	pSVar1 = data;
	if (data->groupCount != 0) {
		do {
			if (pSVar1->groupList[0].used_0 != 0) {
				Smoke_Group_MeshRenderCallback(data,groupID,view,&lightPos);
			}
			groupID += 1;
			pSVar1 = (SurfaceMapStruct_2a8 *)(pSVar1->groupList + 1);
		} while (groupID < data->groupCount);
	}
	return;
}



void __cdecl
lego::effect::Smoke_Group_MeshRenderCallback
					(SurfaceMapStruct_2a8 *param_1,D3DRMGroupIndex groupID,Viewport *view,Vector3F *lightPos)
{
	SurfaceMapStruct_3c *pSVar1;
	float fVar2;
	float fVar3;
	Container *cont;
	Vector3F local_80;
	Vector3F local_74;
	Vector3F vertices [4];
	Vector3F local_38;
	Point2F textCoords [4];
	Vector3F local_c;
	
	textCoords[0].x = 0.0;
	textCoords[0].y = 1.0;
	textCoords[1].x = 0.0;
	textCoords[1].y = 0.0;
	textCoords[2].x = 1.0;
	textCoords[2].y = 0.0;
	textCoords[3].x = 1.0;
	textCoords[3].y = 1.0;
	pSVar1 = param_1->groupList + groupID;
	cont = lego::view::Viewport_GetCamera(view);
	res::Container_GetOrientation(cont,NULL,&local_38,&local_c);
	local_74.y = local_38.x * -1.0 - 0.0;
	local_74.x = 0.0 - local_38.y * -1.0;
	local_80.x = 0.0;
	local_80.y = 0.0;
	local_80.z = -1.0;
	local_74.z = 0.0;
	if ((ushort)((ushort)(local_38.z < 0.3) << 8 | (ushort)(local_38.z == 0.3) << 0xe) == 0) {
		math::Maths_Vector3DRotate(&local_80,&local_80,&local_74,0.7);
	}
	fVar3 = (float)(&pSVar1->used_0)[0xe] / (float)(&pSVar1->used_0)[0xd] - -1.0;
	fVar2 = (float)(&pSVar1->used_0)[10] * fVar3;
	fVar3 = (float)(&pSVar1->used_0)[0xb] * fVar3;
	local_74.x = fVar2 * local_74.x;
	local_74.y = fVar2 * local_74.y;
	local_74.z = fVar2 * local_74.z;
	vertices[0].x = (float)(&pSVar1->used_0)[7] + local_74.x;
	vertices[1].x = (float)(&pSVar1->used_0)[7] - local_74.x;
	vertices[0].y = (float)(&pSVar1->used_0)[8] + local_74.y;
	vertices[1].y = (float)(&pSVar1->used_0)[8] - local_74.y;
	local_80.x = fVar3 * local_80.x;
	vertices[0].z = (float)(&pSVar1->used_0)[9] + local_74.z;
	vertices[1].z = (float)(&pSVar1->used_0)[9] - local_74.z;
	local_80.y = fVar3 * local_80.y;
	local_80.z = fVar3 * local_80.z;
	vertices[2].x = vertices[1].x - local_80.x;
	vertices[3].x = vertices[0].x - local_80.x;
	vertices[2].y = vertices[1].y - local_80.y;
	vertices[3].y = vertices[0].y - local_80.y;
	vertices[2].z = vertices[1].z - local_80.z;
	vertices[3].z = vertices[0].z - local_80.z;
	res::Mesh_SetVertices_PointNormalAt(param_1->mesh,groupID,0,4,vertices,lightPos,textCoords);
	return;
}



void __cdecl lego::game::SpiderWeb_Initialise(LevelData *level)
{
	uint uVar1;
	int iVar2;
	BlockSpiderWeb *pBVar3;
	
	globs::spiderwebGlobs.webBlocks =
			 (BlockSpiderWeb *)std::malloc((level->dimensions).width * (level->dimensions).height * 0xc);
	if (globs::spiderwebGlobs.webBlocks != NULL) {
		pBVar3 = globs::spiderwebGlobs.webBlocks;
		for (uVar1 = (level->dimensions).width * (level->dimensions).height * 3 & 0x3fffffff; uVar1 != 0
				; uVar1 -= 1) {
			pBVar3->object = NULL;
			pBVar3 = (BlockSpiderWeb *)&pBVar3->health;
		}
		for (iVar2 = 0; iVar2 != 0; iVar2 += -1) {
			*(undefined *)&pBVar3->object = 0;
			pBVar3 = (BlockSpiderWeb *)((int)&pBVar3->object + 1);
		}
	}
	globs::spiderwebGlobs.level = level;
	return;
}



void __cdecl lego::game::SpiderWeb_Shutdown(void)
{
	if (globs::spiderwebGlobs.webBlocks != NULL) {
		std::free(globs::spiderwebGlobs.webBlocks);
		globs::spiderwebGlobs.webBlocks = NULL;
	}
	return;
}



void __cdecl lego::game::SpiderWeb_ResetAll(LevelData *level)
{
	SpiderWeb_Shutdown();
	SpiderWeb_Initialise(level);
	return;
}



BOOL __cdecl lego::game::SpiderWeb_SpawnAt(uint bx,uint by)
{
	BOOL BVar1;
	LiveObject *webObj;
	Point2F local_8;
	uint by_00;
	
	by_00 = by;
	if ((globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx].
			 flags & BLOCKWEB_ACTIVE) == BLOCKWEB_NONE) {
		BVar1 = SpiderWeb_GetAngle(bx,by,(float *)&by);
		if (BVar1 != 0) {
			Map3D_BlockToWorldPos
								((globs::spiderwebGlobs.level)->surfaceMap,bx,by_00,(float *)&local_8,&local_8.y);
			webObj = Game_CreateLiveResourceObject
												 (globs::gameGlobs.RES_SpiderWeb,OBJECT_SPIDERWEB,0,0,local_8.x,local_8.y,
													(float)by);
			SpiderWeb_Add(bx,by_00,webObj);
			(globs::spiderwebGlobs.webBlocks
			 [((globs::spiderwebGlobs.level)->dimensions).width * by_00 + bx].object)->flags1 =
					 (globs::spiderwebGlobs.webBlocks
						[((globs::spiderwebGlobs.level)->dimensions).width * by_00 + bx].object)->flags1 |
					 LIVEOBJ1_UNK_100;
			res::Container_SetActivity
								((globs::spiderwebGlobs.webBlocks
									[((globs::spiderwebGlobs.level)->dimensions).width * by_00 + bx].object)->other,
								 "Expand");
			res::Container_SetAnimationTime
								((globs::spiderwebGlobs.webBlocks
									[((globs::spiderwebGlobs.level)->dimensions).width * by_00 + bx].object)->other,
								 0.0);
			return TRUE;
		}
	}
	return 0;
}



void __cdecl lego::game::SpiderWeb_Add(int bx,int by,LiveObject *webObj)
{
	globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx].
	object = webObj;
	globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx].flags
			 = globs::spiderwebGlobs.webBlocks
				 [((globs::spiderwebGlobs.level)->dimensions).width * by + bx].flags | BLOCKWEB_ACTIVE;
										// 100.0f
	globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx].
	health = (float)&DAT_42c80000;
	return;
}



BOOL __cdecl lego::game::SpiderWeb_GetAngle(int bx,int by,float *out_theta)
{
	int idx;
	LevelBlock *blocks;
	int width;
	
	width = ((globs::spiderwebGlobs.level)->dimensions).width;
	blocks = (globs::spiderwebGlobs.level)->blocks;
	idx = by * width + bx;
	if ((*(byte *)&blocks[idx].flags1 & BLOCK1_UNK_8) == 0) {
		return 0;
	}
	if (((*(byte *)&(blocks + idx)[1].flags1 & BLOCK1_UNK_10) == 0) ||
		 ((*(byte *)&(blocks + idx)[-1].flags1 & BLOCK1_UNK_10) == 0)) {
		if ((*(byte *)&blocks[(by + 1) * width + bx].flags1 & BLOCK1_UNK_10) == 0) {
			return 0;
		}
		if ((*(byte *)&blocks[(by + -1) * width + bx].flags1 & BLOCK1_UNK_10) == 0) {
			return 0;
		}
		if (out_theta != NULL) {
			*out_theta = 0.0;
		}
	}
	else {
		if (out_theta != NULL) {
			*out_theta = 1.570796;
			return TRUE;
		}
	}
	return TRUE;
}



BOOL __cdecl lego::game::SpiderWeb_CheckCollision(LiveObject *liveObj)
{
	LiveObject *liveObj_00;
	BOOL BVar1;
	uint local_24;
	Point2F local_20;
	Point2F local_18;
	undefined4 local_10;
	Point2F local_c;
	undefined4 local_4;
	
	liveObj_00 = liveObj;
	BVar1 = LiveObject_GetBlockPos(liveObj,(int *)&local_24,(int *)&liveObj);
	if (BVar1 != 0) {
		if ((globs::spiderwebGlobs.webBlocks
				 [((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_24].flags &
				BLOCKWEB_ACTIVE) != BLOCKWEB_NONE) {
			Map3D_BlockToWorldPos
								((globs::spiderwebGlobs.level)->surfaceMap,local_24,(uint)liveObj,(float *)&local_c,
								 &local_c.y);
			LiveObject_GetFaceDirection
								(globs::spiderwebGlobs.webBlocks
								 [((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_24].
								 object,&local_20);
			local_18.x = local_20.x;
			local_18.y = local_20.y;
			local_4 = 0;
			local_10 = 0;
			BVar1 = LiveObject_Collision_FUN_00470520(liveObj_00,&local_c,&local_18,0);
			if (BVar1 != 0) {
				liveObj_00->flags1 = liveObj_00->flags1 | LIVEOBJ1_CAUGHTINWEB;
				(globs::spiderwebGlobs.webBlocks
				 [((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_24].object)->
				flags1 = (globs::spiderwebGlobs.webBlocks
									[((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_24].
								 object)->flags1 | LIVEOBJ1_CAUGHTINWEB;
				return TRUE;
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::game::SpiderWeb_Update(float elapsedGame)
{
	BOOL BVar1;
	
	BVar1 = Search_LiveObjects_SkipIgnoreMes(SpiderWeb_LiveObjectCallback,&elapsedGame);
	return BVar1;
}



BOOL __cdecl lego::game::SpiderWeb_LiveObjectCallback(LiveObject *liveObj,float *pElapsedGame)
{
	LiveObject *pLVar1;
	BOOL BVar2;
	int idx;
	uint weaponType;
	float10 damage;
	LiveObject *liveObj_00;
	int local_4;
	BlockSpiderWeb *webBlocks;
	
	pLVar1 = liveObj;
	if (liveObj->objType == OBJECT_SPIDERWEB) {
										// Remove inactive SpiderWebs
		LiveObject_GetBlockPos(liveObj,&local_4,(int *)&liveObj);
		if (((globs::spiderwebGlobs.webBlocks
					[((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_4].flags &
				 BLOCKWEB_ACTIVE) != BLOCKWEB_NONE) &&
			 (BVar2 = SpiderWeb_GetAngle(local_4,(int)liveObj,NULL), BVar2 == 0)) {
			SpiderWeb_Remove(local_4,(int)liveObj);
			return 0;
		}
	}
	else {
		if ((liveObj->flags1 & LIVEOBJ1_CAUGHTINWEB) != LIVEOBJ1_NONE) {
										// Object already caught in web, damage web (and remove if health is zeroed)
			LiveObject_GetBlockPos(liveObj,&local_4,(int *)&liveObj);
			webBlocks = globs::spiderwebGlobs.webBlocks;
			idx = ((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_4;
										// if false, object is not longer in a block with spider webs
			if ((globs::spiderwebGlobs.webBlocks[idx].flags & BLOCKWEB_ACTIVE) != BLOCKWEB_NONE) {
				liveObj_00 = pLVar1;
				weaponType = tools::Weapon_GetWeaponTypeByName("SpiderWeb");
				damage = Weapon_GetDamageForLiveObject(weaponType,liveObj_00);
				globs::spiderwebGlobs.webBlocks
				[((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_4].health =
						 (float)((float10)webBlocks[idx].health - damage * (float10)*pElapsedGame);
				if (0.0 <= globs::spiderwebGlobs.webBlocks
									 [((globs::spiderwebGlobs.level)->dimensions).width * (int)liveObj + local_4].
									 health) {
					return 0;
				}
				SpiderWeb_Remove(local_4,(int)liveObj);
			}
			pLVar1->flags1 = pLVar1->flags1 & ~LIVEOBJ1_CAUGHTINWEB;
			return 0;
		}
		SpiderWeb_CheckCollision(liveObj);
	}
	return 0;
}



void __cdecl lego::game::SpiderWeb_Remove(int bx,int by)
{
	int idx;
	
	(globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx].
	object)->flags3 =
			 (globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx]
			 .object)->flags3 | LIVEOBJ3_UNK_800000;
	(globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx].
	object)->flags1 =
			 (globs::spiderwebGlobs.webBlocks[((globs::spiderwebGlobs.level)->dimensions).width * by + bx]
			 .object)->flags1 & ~LIVEOBJ1_CAUGHTINWEB;
	idx = ((globs::spiderwebGlobs.level)->dimensions).width * by + bx;
	globs::spiderwebGlobs.webBlocks[idx].flags =
			 globs::spiderwebGlobs.webBlocks[idx].flags & ~BLOCKWEB_ACTIVE;
	return;
}


/*
Unable to decompile 'Stats_Initialise'
Cause: Exception while decompiling 00466aa0: process: timeout

*/


BOOL __cdecl lego::stats::Stats_Initialise(CFGProperty *root,char *rootPath)
{
	uint *puVar1;
	BOOL3 *pBVar2;
	float fVar3;
	char *pcVar4;
	CFGProperty *prop;
	BOOL BVar5;
	uint uVar6;
	ObjectStats **ppOVar7;
	ObjectStats *pOVar8;
	SFXType SVar9;
	BOOL3 BVar10;
	int iVar11;
	char **ppcVar12;
	uint uVar13;
	float10 fVar14;
	SFXType *pSVar15;
	ObjectType local_14c;
	int local_148;
	char *local_144;
	uint local_140;
	BOOL3 local_13c;
	char **local_138;
	char *local_134;
	char *local_130;
	char **local_12c;
	BOOL3 local_128;
	char *local_124;
	float local_120;
	float local_11c;
	char *local_118;
	float local_114;
	float local_110;
	float local_10c;
	float local_108;
	float local_104;
	float local_100;
	float local_fc;
	float local_f8;
	float local_f4;
	float local_f0;
	float local_ec;
	SFXType local_e8;
	SFXType local_e4;
	SFXType local_e0;
	int local_dc;
	int local_d8;
	int local_d4;
	uint local_d0;
	undefined4 uStack204;
	char *local_c8 [32];
	char *local_48;
	char *local_44 [4];
	char *local_34;
	char *local_28;
	char *local_20;
	
	local_48 = NULL;
	ppcVar12 = local_44;
	for (iVar11 = 0x11; iVar11 != 0; iVar11 += -1) {
		*ppcVar12 = NULL;
		ppcVar12 = ppcVar12 + 1;
	}
	pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",0);
	for (prop = cfg::CFG_GetChildren(root,pcVar4); prop != NULL; prop = cfg::CFG_NextFlat(prop)) {
		local_128 = BOOL3_FALSE;
		local_13c = BOOL3_FALSE;
		local_140 = 0;
		pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Levels",0);
		pcVar4 = cfg::CFG_ReadString(root,pcVar4);
		if (pcVar4 == NULL) {
			pcVar4 = ""/*EMPTYSTR*/;
		}
		else {
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Levels",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
		}
		local_134 = (char *)std::atoi(pcVar4);
		BVar5 = game::Object_GetObjectByName(prop->key,&local_14c,&local_148,NULL);
		if (BVar5 != 0) {
			if (globals::g_ObjectStats_TABLE[local_14c] == NULL) {
				uVar6 = game::Object_GetTypeCount(local_14c);
				ppOVar7 = (ObjectStats **)std::malloc(uVar6 * 4);
				globals::g_ObjectStats_TABLE[local_14c] = ppOVar7;
				for (uVar6 &= 0x3fffffff; uVar6 != 0; uVar6 -= 1) {
					*ppOVar7 = NULL;
					ppOVar7 = ppOVar7 + 1;
				}
				for (iVar11 = 0; iVar11 != 0; iVar11 += -1) {
					*(undefined *)ppOVar7 = 0;
					ppOVar7 = (ObjectStats **)((int)ppOVar7 + 1);
				}
			}
			globals::g_ObjectLevels_TABLE[local_14c][local_148] = (uint)local_134;
			uVar6 = (int)local_134 * 0x150;
			pOVar8 = (ObjectStats *)std::malloc(uVar6);
			globals::g_ObjectStats_TABLE[local_14c][local_148] = pOVar8;
			pOVar8 = globals::g_ObjectStats_TABLE[local_14c][local_148];
			for (uVar6 >>= 2; uVar6 != 0; uVar6 -= 1) {
				pOVar8->field_0 = 0;
				pOVar8 = (ObjectStats *)&pOVar8->field_4;
			}
			for (iVar11 = 0; iVar11 != 0; iVar11 += -1) {
				*(undefined *)&pOVar8->field_0 = 0;
				pOVar8 = (ObjectStats *)((int)&pOVar8->field_0 + 1);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RouteSpeed",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_12c = local_c8;
					local_144 = NULL;
					local_130 = local_134;
					do {
						fVar14 = std::atof(*local_12c);
						*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
											(int)local_144 + -4) = (float)fVar14;
						local_144 = (char *)((int)local_144 + 0x150);
						local_12c = local_12c + 1;
						local_130 = local_130 + -1;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SoilDrillTime",0);
			local_34 = cfg::CFG_CopyString(root,pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"LooseDrillTime",0);
			local_44[3] = cfg::CFG_CopyString(root,pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"MedDrillTime",0);
			local_44[2] = cfg::CFG_CopyString(root,pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"HardDrillTime",0);
			local_44[1] = cfg::CFG_CopyString(root,pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SeamDrillTime",0);
			local_28 = cfg::CFG_CopyString(root,pcVar4);
			if (local_28 == NULL) {
				local_20 = NULL;
			}
			else {
				local_20 = std::_strdup(local_28);
			}
			local_12c = &local_48;
			local_114 = (float)(0x24 - (int)&local_48);
			local_120 = 2.522337e-44;
			do {
				pcVar4 = *local_12c;
				local_118 = pcVar4;
				if (pcVar4 != NULL) {
					util::Util_Tokenise(pcVar4,local_c8,":");
					if (local_134 != NULL) {
						local_144 = (char *)((int)local_114 + (int)local_12c);
						ppcVar12 = local_c8;
						local_130 = local_134;
						do {
							fVar14 = std::atof(*ppcVar12);
							ppcVar12 = ppcVar12 + 1;
							*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
												(int)local_144 + -0x24) = (float)(fVar14 * (float10)25.0);
							local_144 = (char *)((int)local_144 + 0x150);
							local_130 = local_130 + -1;
							pcVar4 = local_118;
						} while (local_130 != NULL);
					}
					std::free(pcVar4);
				}
				local_12c = local_12c + 1;
				local_120 = (float)((int)local_120 + -1);
			} while (local_120 != 0.0);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"BuildingBase",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				local_144 = (char *)0xffffffff;
			}
			else {
				local_144 = (char *)game::Construction_GetBuildingBase(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CostCrystal",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CostCrystal",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_d8 = std::atoi(pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CostOre",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CostOre",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_d4 = std::atoi(pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CostRefinedOre",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CostRefinedOre",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_124 = (char *)std::atoi(pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrackDist",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrackDist",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_120 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"AlertRadius",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"AlertRadius",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_114 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CollHeight",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CollHeight",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_118 = (char *)(float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"HealthDecayRate",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"HealthDecayRate",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_110 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"EnergyDecayRate",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"EnergyDecayRate",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_100 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PickSphere",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PickSphere",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_130 = (char *)(float)fVar14;
			pSVar15 = &local_e0;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"DrillSound",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			BVar5 = snd::SFX_GetType(pcVar4,pSVar15);
			if (BVar5 == 0) {
				local_e0 = SFX_DRILL;
			}
			pSVar15 = &local_e8;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"DrillFadeSound",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			BVar5 = snd::SFX_GetType(pcVar4,pSVar15);
			if (BVar5 == 0) {
				local_e8 = SFX_DRILLFADE;
			}
			pSVar15 = &local_e4;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"EngineSound",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			SVar9 = snd::SFX_GetType(pcVar4,pSVar15);
			if (SVar9 == SFX_NULL) {
				local_e4 = SVar9;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RestPercent",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RestPercent",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_10c = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CarryMinHealth",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CarryMinHealth",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_104 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"StampRadius",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"StampRadius",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_fc = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"AttackRadius",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"AttackRadius",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_f8 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"WaterEntrances",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"WaterEntrances",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_f4 = (float)std::atoi(pcVar4);
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RubbleCoef",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RubbleCoef",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_11c = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PathCoef",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PathCoef",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_138 = (char **)(float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"OxygenCoef",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"OxygenCoef",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_108 = (float)fVar14;
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Capacity",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Capacity",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_dc = std::atoi(pcVar4);
			if (local_11c == 0.0) {
				local_11c = 1.0;
			}
			if ((float)local_138 == 0.0) {
				local_138 = (char **)0x3f800000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CollRadius",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CollRadius",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_12c = (char **)(float)fVar14;
			if ((float10)0.0 == fVar14) {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CollBox",0);
				pcVar4 = cfg::CFG_CopyString(root,pcVar4);
				if (pcVar4 != NULL) {
					util::Util_Tokenise(pcVar4,local_c8,",");
					fVar14 = std::atof(local_c8[0]);
					local_f0 = (float)fVar14;
					fVar14 = std::atof(local_c8[1]);
					local_ec = (float)fVar14;
					fVar3 = local_ec;
					if ((ushort)((ushort)(local_f0 < local_ec) << 8 | (ushort)(local_f0 == local_ec) << 0xe)
							== 0) {
						fVar3 = local_f0;
					}
					local_12c = (char **)(fVar3 * 0.5);
					local_140 = 0x100;
				}
			}
			else {
				local_140 = 0x80;
			}
			if (local_134 != NULL) {
				iVar11 = 0;
				pcVar4 = local_134;
				do {
					*(char ***)
					 ((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes + iVar11 + 0x48) =
							 local_12c;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x4c) = local_114;
					pOVar8 = globals::g_ObjectStats_TABLE[local_14c][local_148];
					*(float *)((int)pOVar8->DrillTimes + iVar11 + 0x7c) = local_f0;
					*(float *)((int)pOVar8->DrillTimes + iVar11 + 0x80) = local_ec;
					*(char **)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x54) = local_130;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x58) = local_120;
					*(char **)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x50) = local_118;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x5c) = local_110;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x60) = local_100;
					*(char **)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->BuildingBase + iVar11
										) = local_144;
					*(SFXType *)
					 ((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillSound + iVar11) =
							 local_e0;
					*(SFXType *)
					 ((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillFadeSound + iVar11) =
							 local_e8;
					*(SFXType *)
					 ((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->EngineSound + iVar11) =
							 local_e4;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x68) = local_10c;
					pcVar4 = pcVar4 + -1;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x6c) = local_104;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x70) = local_fc;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x74) = local_f8;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->WaterEntrances +
										iVar11) = local_f4;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->RubbleCoef + iVar11)
							 = local_11c;
					*(char ***)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->PathCoef + iVar11) =
							 local_138;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->OxygenCoef + iVar11)
							 = local_108;
					*(int *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Capacity + iVar11) =
							 local_dc;
					*(int *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->CostCrystal + iVar11) =
							 local_d8;
					*(int *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->CostOre + iVar11) =
							 local_d4;
					*(char **)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->CostRefinedOre +
										iVar11) = local_124;
					iVar11 = iVar11 + 0x150;
				} while (pcVar4 != NULL);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SingleWidthDig",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags1 + iVar11) =
									 *(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags1 +
														iVar11) | 1;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = local_124;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RepairValue",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						fVar14 = std::atof(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(float *)(local_144 +
											(int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->RepairValue) =
								 (float)fVar14;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SurveyRadius",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						iVar11 = std::atoi(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(int *)(local_144 +
										(int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->SurveyRadius) = iVar11
						;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"MaxCarry",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						iVar11 = std::atoi(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(int *)(local_144 + (int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->MaxCarry)
								 = iVar11;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CarryStart",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						iVar11 = std::atoi(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(int *)(local_144 +
										(int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->CarryStart) = iVar11;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CrystalDrain",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						iVar11 = std::atoi(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(int *)(local_144 +
										(int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->CrystalDrain) = iVar11
						;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"NumOfToolsCanCarry",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						iVar11 = std::atoi(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(int *)(local_144 +
										(int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->NumOfToolsCanCarry) =
								 iVar11;
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UpgradeTime",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						fVar14 = std::atof(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						*(float *)(local_144 +
											(int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->UpgradeTime) =
								 (float)(fVar14 * (float10)25.0);
						local_144 = local_144 + 0x150;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"FunctionCoef",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_124 = pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_144 = NULL;
					ppcVar12 = local_c8;
					local_130 = local_134;
					do {
						fVar14 = std::atof(*ppcVar12);
						ppcVar12 = ppcVar12 + 1;
						local_144 = local_144 + 0x150;
						*(float *)(local_144 +
											(int)&globals::g_ObjectStats_TABLE[local_14c][local_148][-1].FunctionCoef) =
								 (float)fVar14;
						local_130 = local_130 + -1;
						pcVar4 = local_124;
					} while (local_130 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UpgradeCostOre",0);
			local_144 = cfg::CFG_CopyString(root,pcVar4);
			if (local_144 != NULL) {
				util::Util_Tokenise(local_144,local_c8,":");
				local_138 = local_c8 + 3;
				uVar6 = 0;
				do {
					iVar11 = std::atoi(*local_138);
					uVar13 = uVar6 + 0x150;
					local_138 = local_138 + -1;
					*(int *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148][1].DrillTimes +
									(uVar6 - 0x78)) = iVar11;
					uVar6 = uVar13;
				} while (uVar13 < 0x540);
				std::free(local_144);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UpgradeCostStuds",0);
			local_144 = cfg::CFG_CopyString(root,pcVar4);
			if (local_144 != NULL) {
				util::Util_Tokenise(local_144,local_c8,":");
				local_138 = local_c8 + 3;
				uVar6 = 0;
				do {
					iVar11 = std::atoi(*local_138);
					uVar13 = uVar6 + 0x150;
					*(int *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148][1].DrillTimes +
									(uVar6 - 0x74)) = iVar11;
					local_138 = local_138 + -1;
					uVar6 = uVar13;
				} while (uVar13 < 0x540);
				std::free(local_144);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ProcessOre",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 2;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ProcessCrystal",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 4;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"StoreObjects",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 8;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ManTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x80000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SmallTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x10;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"BigTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x20;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"WaterTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x40;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SnaxULike",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x4000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ToolStore",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x100000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CauseSlip",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x200;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RandomMove",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x400;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanScare",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x800;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanScareScorpion",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x40000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RandomEnterWall",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x1000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ScaredByPlayer",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x2000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"GrabMinifigure",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x8000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanBeDriven",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x20000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanSteal",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x80000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanClearRubble",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x10000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RouteAvoidance",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x20000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"BumpDamage",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x40000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x200000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Debug",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x400000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Smooth",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x800000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CrossWater",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x1000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CrossLand",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x2000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_OnGround",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x4000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_QuickDestroy",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x8000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_AnimateByPitch",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_140 |= 0x10000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ScaredByBigBangs",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c = BVar10;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UpgradeBuilding",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= BOOL3_ERROR;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanBeShotAt",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x40000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UseBigTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x800;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UseSmallTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x1000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UseWaterTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x2000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UseLegoManTeleporter",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x400000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrainPilot",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 + iVar11) =
									 *(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 +
														iVar11) | 4;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrainSailor",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 + iVar11) =
									 *(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 +
														iVar11) | 8;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrainDriver",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 + iVar11) =
									 *(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 +
														iVar11) | 0x10;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrainDynamite",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 + iVar11) =
									 *(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 +
														iVar11) | 0x20;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrainRepair",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 + iVar11) =
									 *(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 +
														iVar11) | 0x40;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TrainScanner",0);
			pcVar4 = cfg::CFG_CopyString(root,pcVar4);
			local_12c = (char **)pcVar4;
			if (pcVar4 != NULL) {
				util::Util_Tokenise(pcVar4,local_c8,":");
				if (local_134 != NULL) {
					local_138 = local_c8;
					iVar11 = 0;
					local_144 = local_134;
					do {
						BVar10 = util::Util_GetBoolFromString(*local_138);
						if (BVar10 == BOOL3_TRUE) {
							*(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 + iVar11) =
									 *(uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 +
														iVar11) | 0x80;
						}
						local_138 = local_138 + 1;
						iVar11 += 0x150;
						local_144 = local_144 + -1;
						pcVar4 = (char *)local_12c;
					} while (local_144 != NULL);
				}
				std::free(pcVar4);
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Tracker",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x100;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PowerBuilding",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x600;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SelfPowered",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x400;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"AttackPaths",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x4000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"SplitOnZeroHealth",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x8000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanBeHitByFence",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x10000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanDoubleSelect",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x20000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"DrainPower",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x80000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"UseHoles",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x100000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CrossLava",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x200000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"DamageCausesCallToArms",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x800000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanFreeze",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x1000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanLaser",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x2000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanPush",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x4000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"DontShowDamage",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x8000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RemoveReinforcement",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x10000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"DontShowOnRadar",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x20000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"InvisibleDriver",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x40000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Unselectable",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_13c |= 0x80000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CarryVehicles",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 = BVar10;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"VehicleCanBeCarried",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= BOOL3_ERROR;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"CanStrafe",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 4;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ClassAsLarge",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 8;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"GetOutAtLand",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x10;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"GetInAtLand",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x20;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"TakeCarryingDrivers",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x40;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"ShowHealthBar",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x80;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"NeedsPilot",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x100;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"EnterToolStore",0);
			BVar10 = cfg::CFG_ReadBool(root,pcVar4);
			if (BVar10 == BOOL3_TRUE) {
				local_128 |= 0x200;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Turn",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Turn",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_138 = (char **)(float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_138 = (char **)&DAT_3d75c28f;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Speed",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Speed",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_11c = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_11c = 2.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Tightness",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Tightness",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_12c = (char **)(float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_12c = (char **)0x40000000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_GoalUpdate",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_GoalUpdate",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_108 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_108 = 2.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Height",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Height",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_f4 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_f4 = 30.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Randomness",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Randomness",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_f8 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_f8 = 2.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Size",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_Size",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			local_d0 = std::atoi(pcVar4);
			uStack204 = 0;
			local_114 = (float)local_d0;
			if ((float)(ulonglong)local_d0 == 0.0) {
				local_114 = 7.006492e-45;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_AttackTime",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"Flocks_AttackTime",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_fc = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_fc = 300.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"AwarenessRange",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"AwarenessRange",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_104 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_104 = 0.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PainThreshold",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PainThreshold",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_10c = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_10c = 0.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"FreezerTime",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"FreezerTime",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_130 = (char *)(float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_130 = NULL;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"FreezerDamage",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"FreezerDamage",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_120 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_120 = 0.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PusherDist",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PusherDist",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_110 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_110 = 0.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PusherDamage",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"PusherDamage",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_100 = (float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_100 = 0.0;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"LaserDamage",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"LaserDamage",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_118 = (char *)(float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_118 = NULL;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"WakeRadius",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"WakeRadius",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			local_144 = (char *)(float)fVar14;
			if (fVar14 == (float10)0.0) {
				local_144 = (char *)0x41a00000;
			}
			pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RandomMoveTime",0);
			pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			if (pcVar4 == NULL) {
				pcVar4 = ""/*EMPTYSTR*/;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootPath,"Stats",prop->key,"RandomMoveTime",0);
				pcVar4 = cfg::CFG_ReadString(root,pcVar4);
			}
			fVar14 = std::atof(pcVar4);
			if (fVar14 == (float10)0.0) {
				fVar14 = (float10)200.0;
			}
			if (local_134 != NULL) {
				iVar11 = 0;
				pcVar4 = local_134;
				do {
					puVar1 = (uint *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags1 +
													 iVar11);
					*puVar1 = *puVar1 | local_140;
					pBVar2 = (BOOL3 *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags2 +
														iVar11);
					*pBVar2 = *pBVar2 | local_13c;
					pBVar2 = (BOOL3 *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->flags3 +
														iVar11);
					*pBVar2 = *pBVar2 | local_128;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->RandomMoveTime +
										iVar11) = (float)fVar14;
					*(char ***)
					 ((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_Turn + iVar11) =
							 local_138;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_Speed + iVar11
										) = local_11c;
					*(char ***)
					 ((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_Tightness + iVar11) =
							 local_12c;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_GoalUpdate +
										iVar11) = local_108;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_Height +
										iVar11) = local_f4;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_Randomness +
										iVar11) = local_f8;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_Size + iVar11)
							 = local_114;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->Flocks_AttackTime +
										iVar11) = local_fc;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->AwarenessRange +
										iVar11) = local_104;
					pcVar4 = pcVar4 + -1;
					*(float *)((int)&globals::g_ObjectStats_TABLE[local_14c][local_148]->PainThreshold +
										iVar11) = local_10c;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148][1].DrillTimes +
										iVar11 + -0x5c) = local_100;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148][1].DrillTimes +
										iVar11 + -0x60) = local_110;
					*(char **)((int)globals::g_ObjectStats_TABLE[local_14c][local_148][1].DrillTimes +
										iVar11 + -0x58) = local_118;
					*(float *)((int)globals::g_ObjectStats_TABLE[local_14c][local_148][1].DrillTimes +
										iVar11 + -100) = local_120;
					*(char **)((int)globals::g_ObjectStats_TABLE[local_14c][local_148][1].DrillTimes +
										iVar11 + -0x68) = local_130;
					*(char **)((int)globals::g_ObjectStats_TABLE[local_14c][local_148]->DrillTimes +
										iVar11 + 0x78) = local_144;
					iVar11 = iVar11 + 0x150;
				} while (pcVar4 != NULL);
			}
		}
	}
	Stats_RegisterToolTask(TOOL_DRILL,AITASK_DIG);
	Stats_RegisterToolTask(TOOL_SPADE,AITASK_CLEAR);
	Stats_RegisterToolTask(TOOL_HAMMER,AITASK_REINFORCE);
	Stats_RegisterToolTask(TOOL_SPANNER,AITASK_REPAIR);
	return 1;
}



void __cdecl lego::stats::Stats_RegisterToolTask(ToolType toolType,AITaskType taskType)
{
	(&ToolData_ARRAY_005040d8[toolType].taskType)[ToolData_ARRAY_005040d8[toolType].count] = taskType;
	ToolData_ARRAY_005040d8[toolType].count = ToolData_ARRAY_005040d8[toolType].count + 1;
	return;
}



int __cdecl lego::game::Object_GetCostOre(ObjectType objType,int objIndex,int objLevel)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex][objLevel].CostOre;
}



int __cdecl lego::game::Object_GetCostCrystal(ObjectType objType,int objIndex,int objLevel)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex][objLevel].CostCrystal;
}



int __cdecl lego::game::Object_GetCostRefinedOre(ObjectType objType,int objIndex,int objLevel)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex][objLevel].CostRefinedOre;
}



int __cdecl lego::game::LiveObject_GetCrystalDrain(LiveObject *liveObj)
{
	return globals::g_ObjectStats_TABLE[liveObj->objType][liveObj->objIndex][liveObj->objLevel].
				 CrystalDrain;
}



int __cdecl lego::game::LiveObject_GetCapacity(LiveObject *liveObj)
{
	return globals::g_ObjectStats_TABLE[liveObj->objType][liveObj->objIndex][liveObj->objLevel].
				 Capacity;
}



int __cdecl lego::game::LiveObject_GetMaxCarry(LiveObject *liveObj)
{
	return globals::g_ObjectStats_TABLE[liveObj->objType][liveObj->objIndex][liveObj->objLevel].
				 MaxCarry;
}



int __cdecl lego::game::LiveObject_GetCarryStart(LiveObject *liveObj)
{
	return globals::g_ObjectStats_TABLE[liveObj->objType][liveObj->objIndex][liveObj->objLevel].
				 CarryStart;
}



BOOL __cdecl lego::game::LiveObject_SetLevel(LiveObject *liveObj,uint level)
{
	ObjectType objType;
	int objIndex;
	uint oldLevel;
	
	objType = liveObj->objType;
	objIndex = liveObj->objIndex;
	if (level < globals::g_ObjectLevels_TABLE[objType][objIndex]) {
		oldLevel = liveObj->objLevel;
		if (level != oldLevel) {
			globs::liveGlobs.ObjectLevels_Previous_TABLE[objType][objIndex][oldLevel] =
					 globs::liveGlobs.ObjectLevels_Previous_TABLE[objType][objIndex][oldLevel] + 1;
			globs::liveGlobs.ObjectLevels_Current_TABLE[liveObj->objType][liveObj->objIndex][level] =
					 globs::liveGlobs.ObjectLevels_Current_TABLE[liveObj->objType][liveObj->objIndex][level] +
					 1;
		}
		liveObj->objLevel = level;
		liveObj->stats = globals::g_ObjectStats_TABLE[liveObj->objType][liveObj->objIndex] + level;
		return TRUE;
	}
	return 0;
}



float10 __cdecl lego::game::LiveObject_GetRouteSpeed(LiveObject *liveObj)
{
	return (float10)liveObj->stats->RouteSpeed;
}



float10 __cdecl lego::game::LiveObject_GetDrillTimeType(LiveObject *liveObj,SurfaceType surfaceType)
{
	return (float10)liveObj->stats->DrillTimes[surfaceType];
}



float10 __cdecl lego::game::LiveObject_GetRubbleCoef(LiveObject *liveObj)
{
	return (float10)liveObj->stats->RubbleCoef;
}



float10 __cdecl lego::game::LiveObject_GetWakeRadius(LiveObject *liveObj)
{
	return (float10)liveObj->stats->WakeRadius;
}



float10 __cdecl lego::game::LiveObject_GetPathCoef(LiveObject *liveObj)
{
	return (float10)liveObj->stats->PathCoef;
}



float10 __cdecl lego::game::LiveObject_GetCollRadius(LiveObject *liveObj)
{
	return (float10)liveObj->stats->CollRadius;
}



float10 __cdecl lego::game::LiveObject_GetCollHeight(LiveObject *liveObj)
{
	return (float10)liveObj->stats->CollHeight;
}



float10 __cdecl lego::game::LiveObject_GetPickSphere(LiveObject *liveObj)
{
	return (float10)liveObj->stats->PickSphere;
}



float10 __cdecl lego::game::LiveObject_GetPainThreshold(LiveObject *liveObj)
{
	return (float10)liveObj->stats->PainThreshold;
}



float10 __cdecl lego::game::LiveObject_GetAlertRadius(LiveObject *liveObj)
{
	return (float10)liveObj->stats->AlertRadius;
}



int __cdecl lego::game::LiveObject_GetCollBox(LiveObject *liveObj)
{
	return (int)&liveObj->stats->CollBox;
}



float10 __cdecl lego::game::LiveObject_GetTrackDist(LiveObject *liveObj)
{
	return (float10)liveObj->stats->TrackDist;
}



float10 __cdecl lego::game::LiveObject_GetHealthDecayRate(LiveObject *liveObj)
{
	return (float10)liveObj->stats->HealthDecayRate;
}



float10 __cdecl lego::game::LiveObject_GetEnergyDecayRate(LiveObject *liveObj)
{
	return (float10)liveObj->stats->EnergyDecayRate;
}



float10 __cdecl lego::game::Object_GetOxygenCoef(ObjectType objType,int objIndex)
{
	return (float10)globals::g_ObjectStats_TABLE[objType][objIndex]->OxygenCoef;
}



float10 __cdecl lego::game::LiveObject_GetOxygenCoef(LiveObject *liveObj)
{
	return (float10)liveObj->stats->OxygenCoef;
}



int __cdecl lego::game::LiveObject_GetSurveyRadius(LiveObject *liveObj)
{
	return liveObj->stats->SurveyRadius;
}



ObjectStatsFlags1 __cdecl lego::game::LiveObject_GetStatsFlags1(LiveObject *liveObj)
{
	return liveObj->stats->flags1;
}



ObjectStatsFlags2 __cdecl lego::game::LiveObject_GetStatsFlags2(LiveObject *liveObj)
{
	return liveObj->stats->flags2;
}



ObjectStatsFlags3 __cdecl lego::game::LiveObject_GetStatsFlags3(LiveObject *liveObj)
{
	return liveObj->stats->flags3;
}



ObjectStatsFlags1 __cdecl lego::game::Object_GetStatsFlags1(ObjectType objType,int objIndex)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex]->flags1;
}



ObjectStatsFlags2 __cdecl lego::game::Object_GetStatsFlags2(ObjectType objType,int objIndex)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex]->flags2;
}



ObjectStatsFlags3 __cdecl lego::game::Object_GetStatsFlags3(ObjectType objType,int objIndex)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex]->flags3;
}



float10 __cdecl lego::game::LiveObject_GetRepairValue(LiveObject *liveObj)
{
	return (float10)liveObj->stats->RepairValue;
}



int __cdecl lego::game::Object_GetLevels(ObjectType objType,int objIndex)
{
	return globals::g_ObjectLevels_TABLE[objType][objIndex];
}



int __cdecl lego::game::Object_GetWaterEntrances(ObjectType objType,int objIndex,int objLevel)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex][objLevel].WaterEntrances;
}



int __cdecl lego::game::LiveObject_GetDrillSoundType(LiveObject *liveObj,BOOL isFade)
{
	if (isFade != 0) {
		return liveObj->stats->DrillFadeSound;
	}
	return liveObj->stats->DrillSound;
}



int __cdecl lego::game::LiveObject_GetEngineSound(LiveObject *liveObj)
{
	return liveObj->stats->EngineSound;
}



float10 __cdecl lego::game::LiveObject_GetRestPercent(LiveObject *liveObj)
{
	return (float10)liveObj->stats->RestPercent;
}



float10 __cdecl lego::game::LiveObject_GetCarryMinHealth(LiveObject *liveObj)
{
	return (float10)liveObj->stats->CarryMinHealth;
}



float10 __cdecl lego::game::LiveObject_GetAttackRadius(LiveObject *liveObj)
{
	return (float10)liveObj->stats->AttackRadius;
}



float10 __cdecl lego::game::LiveObject_GetStampRadius(LiveObject *liveObj)
{
	return (float10)liveObj->stats->StampRadius;
}



int __cdecl lego::game::LiveObject_GetNumOfToolsCanCarry(LiveObject *liveObj)
{
	return liveObj->stats->NumOfToolsCanCarry;
}



float10 __cdecl lego::game::LiveObject_GetUpgradeTime(LiveObject *liveObj)
{
	return (float10)liveObj->stats->UpgradeTime;
}



float10 __cdecl lego::game::LiveObject_GetFunctionCoef(LiveObject *liveObj)
{
	return (float10)liveObj->stats->FunctionCoef;
}



int __cdecl lego::game::Object_GetUpgradeCostOre(ObjectType objType,int objIndex,int objLevel)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex][objLevel].UpgradeCostOre;
}



int __cdecl lego::game::Object_GetUpgradeCostStuds(ObjectType objType,int objIndex,int objLevel)
{
	return globals::g_ObjectStats_TABLE[objType][objIndex][objLevel].UpgradeCostStuds;
}



BOOL __cdecl lego::ai::AI_GetToolFromTaskType(AITaskType taskType,ToolType *out_toolType)
{
	ToolData *pTVar1;
	uint uVar2;
	ToolData *pTVar3;
	ToolType TVar4;
	
	TVar4 = TOOL_DRILL;
	pTVar1 = ToolData_ARRAY_005040d8;
	do {
		uVar2 = 0;
		pTVar3 = pTVar1;
		if (pTVar1->count != 0) {
			do {
				if (taskType == pTVar3->taskType) {
					*out_toolType = TVar4;
					return TRUE;
				}
				uVar2 += 1;
				pTVar3 = (ToolData *)&pTVar3->field_4;
			} while (uVar2 < (uint)pTVar1->count);
		}
		pTVar1 = pTVar1 + 1;
		TVar4 += TOOL_SPADE;
	} while (pTVar1 < &globals::g_Teleporter_BOOL_00504188);
	return 0;
}



float10 __cdecl lego::game::LiveObject_GetFlocks_Height(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_Height;
}



float10 __cdecl lego::game::LiveObject_GetFlocks_Randomness(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_Randomness;
}



float10 __cdecl lego::game::LiveObject_GetFlocks_Turn(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_Turn;
}



float10 __cdecl lego::game::LiveObject_GetFlocks_Tightness(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_Tightness;
}



float10 __cdecl lego::game::LiveObject_GetFlocks_Speed(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_Speed;
}



int __cdecl lego::game::LiveObject_GetFlocks_Size(LiveObject *liveObj)
{
	return liveObj->stats->Flocks_Size;
}



float10 __cdecl lego::game::LiveObject_GetFlocks_GoalUpdate(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_GoalUpdate;
}



float10 __cdecl lego::game::LiveObject_GetFlocks_AttackTime(LiveObject *liveObj)
{
	return (float10)liveObj->stats->Flocks_AttackTime;
}



float10 __cdecl lego::game::LiveObject_GetAwarenessRange(LiveObject *liveObj)
{
	return (float10)liveObj->stats->AwarenessRange;
}



float10 __cdecl lego::game::LiveObject_GetPusherDist(LiveObject *liveObj)
{
	return (float10)liveObj->stats->PusherDist;
}



float10 __cdecl lego::game::LiveObject_GetPusherDamage(LiveObject *liveObj)
{
	return (float10)liveObj->stats->PusherDamage;
}



float10 __cdecl lego::game::LiveObject_GetLaserDamage(LiveObject *liveObj)
{
	return (float10)liveObj->stats->LaserDamage;
}



float10 __cdecl lego::game::LiveObject_GetFreezerDamage(LiveObject *liveObj)
{
	return (float10)liveObj->stats->FreezerDamage;
}



float10 __cdecl lego::game::LiveObject_GetFreezerTime(LiveObject *liveObj)
{
	return (float10)liveObj->stats->FreezerTime;
}



void __cdecl lego::debug::LiveObject_Debug_ToggleObjectPower(LiveObject *liveObj)
{
	ObjectStatsFlags2 stats2;
	ObjectStats *stats;
	
	stats = liveObj->stats;
	stats2 = stats->flags2;
	if ((stats2 & STATS2_SELFPOWERED) != STATS2_NONE) {
										// WTF Ghidra...
										// stats->flags2 &= ~STATS2_SELFPOWERED; // 0x400
		stats->flags2 =
				 stats2 & (STATS2_SCAREDBYBIGBANGS|STATS2_UPGRADEBUILDING|STATS2_TRAINPILOT|
									 STATS2_TRAINSAILOR|STATS2_TRAINDRIVER|STATS2_TRAINDYNAMITE|STATS2_TRAINREPAIR|
									 STATS2_TRAINSCANNER|STATS2_TRACKER|STATS2_GENERATEPOWER|STATS2_USEBIGTELEPORTER|
									 STATS2_USESMALLTELEPORTER|STATS2_USEWATERTELEPORTER|STATS2_ATTACKPATHS|
									 STATS2_SPLITONZEROHEALTH|STATS2_CANBEHITBYFENCE|STATS2_CANDOUBLESELECT|
									 STATS2_CANBESHOTAT|STATS2_DRAINPOWER|STATS2_USEHOLES|STATS2_CROSSLAVA|
									 STATS2_USELEGOMANTELEPORTER|STATS2_DAMAGECAUSESCALLTOARMS|STATS2_CANFREEZE|
									 STATS2_CANLASER|STATS2_CANPUSH|STATS2_DONTSHOWDAMAGE|STATS2_REMOVEREINFORCEMENT|
									 STATS2_DONTSHOWONRADAR|STATS2_INVISIBLEDRIVER|STATS2_UNSELECTABLE);
		game::LiveObject_UpdatePowerConsumption(liveObj);
		return;
	}
	stats->flags2 = stats2 | STATS2_SELFPOWERED;
	game::LiveObject_UpdatePowerConsumption(liveObj);
	return;
}



void __cdecl lego::unk::Teleporter_Free(TeleporterService *param_1)
{
	if (param_1 != NULL) {
		Teleporter_Free(param_1->next);
		std::free(param_1);
	}
	return;
}



void __cdecl lego::unk::Teleporter_RemoveAll(void)
{
	globs::teleporterGlobs.count = 0;
	Teleporter_Free(globs::teleporterGlobs.current);
	globs::teleporterGlobs.current = NULL;
	return;
}



BOOL __cdecl
lego::unk::Teleporter_LiveObjectCallback_Service(LiveObject *liveObj,SearchTeleporter_10 *search)
{
	uint *puVar1;
	
	if (liveObj->objType == search->objType) {
		liveObj->teleporter_field_390 = search->modeFlags;
		liveObj->teleporter_field_394 = search->teleportFlags;
		if ((*(byte *)&search->modeFlags & 2) != 0) {
			liveObj->teleporter_398 = search->teleporter;
			puVar1 = &search->teleporter->count;
			*puVar1 = *puVar1 + 1;
		}
		globs::teleporterGlobs.count += 1;
		liveObj->flags4 = liveObj->flags4 | LIVEOBJ4_UNK_8;
	}
	return 0;
}



// This function is weird, it returns EDX:EAX, but what for??

Point2F __cdecl lego::unk::Teleporter_GetCameraPosition(void)
{
	SurfaceMap *surfMap;
	CameraData *cam;
	Vector3F *out_surfPosition;
	Point2F local_14;
	Vector3F surfPosition;
	
	cam = globs::gameGlobs.cameraMain;
	if (globs::gameGlobs.viewMode != VIEW_TOPDOWN) {
		cam = globs::gameGlobs.cameraFP;
	}
	out_surfPosition = &surfPosition;
	surfMap = game::GetSurfaceMap();
	lego::view::Camera_GetSurfacePosition_IfTopdown(cam,surfMap,out_surfPosition);
	return (Point2F)CONCAT44(surfPosition.y,surfPosition.x);
}



void __cdecl lego::unk::Teleporter_Add(TeleporterService *param_1)
{
	param_1->next = globs::teleporterGlobs.current;
	globs::teleporterGlobs.current = param_1;
	return;
}



BOOL __cdecl
lego::unk::Teleporter_LiveObjectCallback_Unk(LiveObject *liveObj,TeleportObjectType teleportObjType)
{
	ObjectType OVar1;
	
	OVar1 = Teleporter_GetServiceObjectType(teleportObjType);
	if ((liveObj->objType == OVar1) && (liveObj->teleporter_field_390 != 0)) {
		globals::g_Teleporter_BOOL_00504188 = 0;
	}
	return 0;
}



BOOL __cdecl lego::unk::Teleporter_FUN_0046a780(TeleportObjectType teleportObjType)
{
	undefined4 *search;
	uint uVar1;
	
	uVar1 = 0;
	do {
		search = (undefined4 *)(1 << ((byte)uVar1 & 0x1f));
		globals::g_Teleporter_BOOL_00504188 = 1;
		if ((teleportObjType & (uint)search) != TELEPORT_SERVIVE_NONE) {
			game::Search_LiveObjects_SkipIgnoreMes(Teleporter_LiveObjectCallback_Unk,search);
			if (globals::g_Teleporter_BOOL_00504188 == 0) {
				return 0;
			}
		}
		uVar1 += 1;
	} while (uVar1 < 31);
	return 1;
}



void __cdecl
lego::unk::Teleporter_Start(TeleportObjectType teleportObjType,uint modeFlags,uint teleportFlags)
{
	Point2F cameraPos;
	SearchTeleporter_10 search;
	
	search.objType = Teleporter_GetServiceObjectType(teleportObjType);
	search.modeFlags = modeFlags;
	search.teleportFlags = teleportFlags;
	if ((modeFlags & 2) != 0) {
		search.teleporter = (TeleporterService *)std::malloc(0x20);
		Teleporter_Add(search.teleporter);
		(search.teleporter)->count = 0;
		if ((teleportFlags & 2) != 0) {
			cameraPos = Teleporter_GetCameraPosition();
			((search.teleporter)->cameraPos).x = SUB84(cameraPos,0);
			((search.teleporter)->cameraPos).y = (float)((ulonglong)cameraPos >> 0x20);
			(search.teleporter)->float_8 = 0.0;
			(search.teleporter)->float_c = globs::teleporterGlobs.floatValue_3_0;
		}
		if ((teleportFlags & 1) != 0) {
			(search.teleporter)->int_14 = globs::teleporterGlobs.intValue_40;
		}
		(search.teleporter)->flags = teleportFlags;
	}
	game::Search_LiveObjects_SkipIgnoreMes
						(Teleporter_LiveObjectCallback_Service,(undefined4 *)&search);
	return;
}



BOOL __cdecl lego::unk::Teleporter_LiveObjectCallback_Update(LiveObject *liveObj,void *data_unused)
{
	uint uVar1;
	float fVar2;
	float fVar3;
	short rng;
	Point2F position;
	TeleporterService *teleporter;
	
	if ((liveObj->teleporter_field_390 & 1) != 0) {
		liveObj->health = -1.0;
		liveObj->teleporter_field_394 = 0;
		liveObj->teleporter_field_390 = 4;
		globs::teleporterGlobs.count = globs::teleporterGlobs.count - 1;
		return 0;
	}
	if ((liveObj->teleporter_field_390 & 2) != 0) {
		uVar1 = liveObj->teleporter_field_394;
		if ((uVar1 & 2) == 0) {
			if ((uVar1 & 1) == 0) {
				if ((uVar1 & 4) != 0) {
					liveObj->health = -1.0;
					liveObj->flags3 = liveObj->flags3 | LIVEOBJ3_UNK_800000;
					globs::teleporterGlobs.count -= 1;
				}
			}
			else {
				teleporter = liveObj->teleporter_398;
				rng = math::Maths_Rand();
				if ((int)rng % teleporter->int_14 == 0) {
					liveObj->health = -1.0;
					teleporter->count = teleporter->count - 1;
					goto LAB_0046a960;
				}
			}
		}
		else {
			teleporter = liveObj->teleporter_398;
										// I think this teleports objects with priority to "near" the camera
										//  when the level completed, as time progresses, units farther away
										//  are teleported.
			game::LiveObject_GetPosition(liveObj,(float *)&position,&position.y);
			fVar3 = position.x - (teleporter->cameraPos).x;
			fVar2 = position.y - (teleporter->cameraPos).y;
			teleporter = liveObj->teleporter_398;
			if (SQRT(fVar2 * fVar2 + fVar3 * fVar3) < teleporter->float_8) {
				liveObj->health = -1.0;
				teleporter->count = teleporter->count - 1;
LAB_0046a960:
				liveObj->teleporter_field_390 = 4;
				liveObj->teleporter_398 = NULL;
				liveObj->teleporter_field_394 = 0;
				globs::teleporterGlobs.count = globs::teleporterGlobs.count - 1;
				return 0;
			}
		}
	}
	return 0;
}



BOOL __cdecl lego::unk::Teleporter_UpdateService(TeleporterService *teleporter,float elapsedGame)
{
	if (teleporter != NULL) {
		do {
			if ((teleporter->count != 0) && (teleporter->flags == 2)) {
				teleporter->float_8 = teleporter->float_c * elapsedGame + teleporter->float_8;
			}
			teleporter = teleporter->next;
		} while (teleporter != NULL);
	}
	return (BOOL)teleporter;
}



void __cdecl lego::unk::Teleporter_Update(float elapsedGame)
{
	Teleporter_UpdateService(globs::teleporterGlobs.current,elapsedGame);
	if (globs::teleporterGlobs.count != 0) {
		game::Search_LiveObjects_SkipIgnoreMes(Teleporter_LiveObjectCallback_Update,NULL);
	}
	return;
}



ObjectType __cdecl lego::unk::Teleporter_GetServiceObjectType(TeleportObjectType teleportObjType)
{
	if ((teleportObjType & TELEPORT_SERVIVE_VEHICLE) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_VEHICLE;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_MINIFIGURE) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_MINIFIGURE;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_ROCKMONSTER) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_ROCKMONSTER;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_BUILDING) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_BUILDING;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_BOULDER) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_BOULDER;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_POWERCRYSTAL) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_POWERCRYSTAL;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_ORE) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_ORE;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_DYNAMITE) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_DYNAMITE;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_BARRIER) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_BARRIER;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_UPGRADEPART) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_UPGRADEPART;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_ELECTRICFENCE) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_ELECTRICFENCE;
	}
	if ((teleportObjType & TELEPORT_SERVIVE_SPIDERWEB) != TELEPORT_SERVIVE_NONE) {
		return OBJECT_SPIDERWEB;
	}
										// OBJECT_OOHSCARY
	return -(uint)((teleportObjType & TELEPORT_SERVIVE_OOHSCARY) != TELEPORT_SERVIVE_NONE) & 0xd;
}



void __cdecl
lego::front::Text_Load
					(TextWindow *param_1,TextWindow *param_2,int imageX,int imageY,float pauseTime)
{
	if (pauseTime == 0.0) {
		globals::g_TextTypes_TABLE[0] = "Text_Walk";
		globals::g_TextTypes_TABLE[1] = "Text_Drill";
		globals::g_TextTypes_TABLE[2] = "Text_NoDrill";
		globals::g_TextTypes_TABLE[3] = "Text_CantDrill";
		globals::g_TextTypes_TABLE[4] = "Text_Reinforce";
		globals::g_TextTypes_TABLE[5] = "Text_NoReinforce";
		globals::g_TextTypes_TABLE[6] = "Text_CantReinforce";
		globals::g_TextTypes_TABLE[7] = "Text_PickupCrystal";
		globals::g_TextTypes_TABLE[8] = "Text_Encyclopedia";
		globals::g_TextTypes_TABLE[9] = "Text_RadarHelp";
		globals::g_TextTypes_TABLE[10] = "Text_BuildHelp";
		globals::g_TextTypes_TABLE[11] = "Text_SelectionHelp";
		globals::g_TextTypes_TABLE[12] = "Text_Drive";
		globals::g_TextTypes_TABLE[13] = "Text_CantDrive";
		globals::g_TextTypes_TABLE[14] = "Text_MakeTeleporter";
		globals::g_TextTypes_TABLE[15] = "Text_CannotPlaceBuilding";
		globals::g_TextTypes_TABLE[16] = "Text_CrystalOreDisabled";
		globals::g_TextTypes_TABLE[17] = "Text_CrystalFound";
		globals::g_TextTypes_TABLE[18] = "Text_CavernDiscovered";
		globals::g_TextTypes_TABLE[19] = "Text_OreFound";
		globals::g_TextTypes_TABLE[20] = "Text_AirSupplyLow";
		globals::g_TextTypes_TABLE[21] = "Text_AirSupplyRunningOut";
		globals::g_TextTypes_TABLE[22] = "Text_SpaceToContinue";
		globals::g_TextTypes_TABLE[23] = "Text_GameCompleted";
		globals::g_TextTypes_TABLE[24] = "Text_ManTrained";
		globals::g_TextTypes_TABLE[25] = "Text_UnitUpgraded";
		globals::g_TextCurrentType = TEXT__COUNT;
		globals::g_Texts_COUNT = 26;
		PTRTextWindow_0050461c = param_1;
		PTRTextWindow_00504620 = param_2;
		globals::g_TextImagePosition.x = imageX;
		globals::g_TextImagePosition.y = imageY;
		globals::g_TextPauseTime = (float)&DAT_42c80000;
										// 316 (passed from Game_Init)
										// 425 (passed from Game_Init)
										// 100.0
		return;
	}
	globals::g_TextTypes_TABLE[0] = "Text_Walk";
	globals::g_TextTypes_TABLE[1] = "Text_Drill";
	globals::g_TextTypes_TABLE[2] = "Text_NoDrill";
	globals::g_TextTypes_TABLE[3] = "Text_CantDrill";
	globals::g_TextTypes_TABLE[4] = "Text_Reinforce";
	globals::g_TextTypes_TABLE[5] = "Text_NoReinforce";
	globals::g_TextTypes_TABLE[6] = "Text_CantReinforce";
	globals::g_TextTypes_TABLE[7] = "Text_PickupCrystal";
	globals::g_TextTypes_TABLE[8] = "Text_Encyclopedia";
	globals::g_TextTypes_TABLE[9] = "Text_RadarHelp";
	globals::g_TextTypes_TABLE[10] = "Text_BuildHelp";
	globals::g_TextTypes_TABLE[11] = "Text_SelectionHelp";
	globals::g_TextTypes_TABLE[12] = "Text_Drive";
	globals::g_TextTypes_TABLE[13] = "Text_CantDrive";
	globals::g_TextTypes_TABLE[14] = "Text_MakeTeleporter";
	globals::g_TextTypes_TABLE[15] = "Text_CannotPlaceBuilding";
	globals::g_TextTypes_TABLE[16] = "Text_CrystalOreDisabled";
	globals::g_TextTypes_TABLE[17] = "Text_CrystalFound";
	globals::g_TextTypes_TABLE[18] = "Text_CavernDiscovered";
	globals::g_TextTypes_TABLE[19] = "Text_OreFound";
	globals::g_TextTypes_TABLE[20] = "Text_AirSupplyLow";
	globals::g_TextTypes_TABLE[21] = "Text_AirSupplyRunningOut";
	globals::g_TextTypes_TABLE[22] = "Text_SpaceToContinue";
	globals::g_TextTypes_TABLE[23] = "Text_GameCompleted";
	globals::g_TextTypes_TABLE[24] = "Text_ManTrained";
	globals::g_TextTypes_TABLE[25] = "Text_UnitUpgraded";
	globals::g_TextCurrentType = TEXT__COUNT;
	globals::g_Texts_COUNT = 26;
	PTRTextWindow_0050461c = param_1;
	PTRTextWindow_00504620 = param_2;
	globals::g_TextImagePosition.x = imageX;
	globals::g_TextImagePosition.y = imageY;
	globals::g_TextPauseTime = pauseTime;
	return;
}



void __cdecl
lego::front::Text_MsgPanel_Initialise
					(char *filename,uint param_2,uint param_3,uint unused_int,Rect2F *param_5,
					Rect2F *unused_rect,float param_7)
{
										// 409 (passed from Game_Init)
	UINT_00504628 = param_3;
	globals::g_MsgPanel_Rect1.x = param_5->x;
	globals::g_MsgPanel_Rect1.y = param_5->y;
	globals::g_MsgPanel_Rect1.width = param_5->width;
	globals::g_MsgPanel_Rect1.height = param_5->height;
	FLOAT_0050463c =
			 (globals::g_MsgPanel_Rect1.y + globals::g_MsgPanel_Rect1.height) -
			 (float)PTRTextWindow_0050461c->font->fontHeight;
										// 20.0 (passed from Game_Init)
										// 42   (passed from Game_Init)
	globals::g_MsgPanel_Float20 = param_7;
	globals::g_MsgPanel_Float42 = (float)(ulonglong)param_2;
	Text_Struct830_FUN_0046aca0();
	return;
}



void __cdecl lego::front::Text_Struct830_FUN_0046aca0(void)
{
	int ypos;
	uint height;
	longlong lVar1;
	
	FLOAT_00504648 = (float)(ulonglong)UINT_00504628;
	lVar1 = __ftol((float10)globals::g_MsgPanel_Rect1.y);
	ypos = (int)lVar1;
	lVar1 = __ftol((float10)globals::g_MsgPanel_Rect1.x);
	TextWindow_ChangePosition(PTRTextWindow_0050461c,(int)lVar1,ypos);
	lVar1 = __ftol((float10)globals::g_MsgPanel_Rect1.height);
	height = (uint)lVar1;
	lVar1 = __ftol((float10)globals::g_MsgPanel_Rect1.width);
	TextWindow_ChangeSize(PTRTextWindow_0050461c,(uint)lVar1,height);
	Rect2F_0050464c.x = globals::g_MsgPanel_Rect1.x;
	Rect2F_0050464c.y = globals::g_MsgPanel_Rect1.y;
	Rect2F_0050464c.width = globals::g_MsgPanel_Rect1.width;
	Rect2F_0050464c.height = globals::g_MsgPanel_Rect1.height;
	globals::g_TextPanelFlags = globals::g_TextPanelFlags & 0xfffffffe;
	return;
}



void __cdecl lego::front::Text_FUN_0046ad50(void)
{
	Text_Struct830_FUN_0046aca0();
	globals::g_TextCurrentType = TEXT__COUNT;
	FLAGS_00504610 = 0;
	DAT_00504614 = 0;
	globals::g_TextPanelFlags = 0;
	TextWindow_Clear(PTRTextWindow_0050461c);
	TextWindow_Clear(PTRTextWindow_00504620);
	return;
}



BOOL __cdecl lego::front::Text_GetTextType(char *textName,TextType *out_textType)
{
	int iVar1;
	char **ppcVar2;
	int index;
	
	index = 0;
	ppcVar2 = globals::g_TextTypes_TABLE;
	do {
		iVar1 = std::_stricmp(*ppcVar2,textName);
		if (iVar1 == 0) {
			*out_textType = index;
			return 1;
		}
		ppcVar2 = ppcVar2 + 1;
										// index++
		index += TEXT_DRILL;
										// index < TEXT__COUNT (26)
	} while (ppcVar2 < globals::g_TextMessages_TABLE);
	return 0;
}



void __cdecl lego::front::Text_SetMessage(TextType textType,char *textMessage)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	
	if (globals::g_TextMessages_TABLE[textType] != NULL) {
		std::free(globals::g_TextMessages_TABLE[textType]);
	}
	uVar4 = 0xffffffff;
	pcVar3 = textMessage;
	do {
		if (uVar4 == 0) break;
		uVar4 -= 1;
		cVar2 = *pcVar3;
		pcVar3 = pcVar3 + 1;
	} while (cVar2 != '\0');
	pcVar3 = (char *)std::malloc(~uVar4);
	globals::g_TextMessages_TABLE[textType] = pcVar3;
	cVar2 = *textMessage;
	while (cVar2 != '\0') {
		cVar2 = *textMessage;
		if (cVar2 == '_') {
			*pcVar3 = ' ';
		}
		else {
			if ((cVar2 == '\\') && (textMessage[1] == 'n')) {
				*pcVar3 = '\n';
				textMessage = textMessage + 1;
			}
			else {
				*pcVar3 = cVar2;
			}
		}
		pcVar1 = textMessage + 1;
		pcVar3 = pcVar3 + 1;
		textMessage = textMessage + 1;
		cVar2 = *pcVar1;
	}
	*pcVar3 = '\0';
	if (globals::g_TextImages_TABLE[textType] != NULL) {
		lego::image::Image_Remove(globals::g_TextImages_TABLE[textType]);
		globals::g_TextImages_TABLE[textType] = NULL;
	}
	return;
}



void __cdecl
lego::front::Text_SetMessageWithImage(TextType textType,char *message,char *filename,char *sfxName)
{
	ImageBMP *image;
	
	Text_SetMessage(textType,message);
	std::sprintf((char *)globals::g_TextImageSFXs_TABLE[textType],"%s",sfxName);
	image = lego::image::Image_LoadBMPScaled(filename,0,0);
	globals::g_TextImages_TABLE[textType] = image;
	if (image != NULL) {
		lego::image::Image_SetupTrans(image,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	return;
}



void __cdecl lego::front::Text_SetMessage(char *text,uint unkFlags)
{
	DAT_00504614 = text;
	if (unkFlags == 0) {
		unkFlags = 0x8000;
	}
	FLAGS_00504610 = unkFlags | 0x10000;
	nerps::NERPs_Level_NERPMessage_Parse(text,NULL,TRUE);
	globals::g_TextPanelFlags = globals::g_TextPanelFlags | 1;
	return;
}



void __cdecl lego::front::Text_DisplayMessage(TextType textType,BOOL changeTiming,BOOL setFlag4)
{
	TutorialFlags TVar1;
	BOOL BVar2;
	
	if (changeTiming == SFX_NULL) {
		if ((ushort)((ushort)(FLOAT_00504618 < 0.0) << 8 | (ushort)(FLOAT_00504618 == 0.0) << 0xe) != 0)
		{
			globals::g_TextCurrentType = textType;
		}
	}
	else {
		globals::g_TextCurrentType = textType;
		FLOAT_00504618 = globals::g_TextPauseTime;
	}
	TVar1 = nerps::funcs::NERPFunc__GetTutorialFlags(NULL);
	if (TVar1 == TUTORIAL_NONE) {
		BVar2 = snd::SFX_GetType((char *)globals::g_TextImageSFXs_TABLE[textType],
														 (SFXType *)&changeTiming);
		if (BVar2 != 0) {
			snd::SFX_Sample_Random_SetAndPlayGlobalSample(changeTiming,NULL);
		}
	}
	if ((globals::g_TextCurrentType == textType) && (setFlag4 != 0)) {
		globals::g_TextPanelFlags = globals::g_TextPanelFlags | 4;
		return;
	}
	globals::g_TextPanelFlags = globals::g_TextPanelFlags & 0xfffffffb;
	return;
}



void __cdecl lego::front::Text_Update(float elapsedAbs)
{
	char *format;
	float fVar1;
	TextType TVar2;
	int iVar3;
	BOOL BVar4;
	uint uVar5;
	ImageBMP *image;
	TextWindow *pTVar6;
	bool bVar7;
	longlong lVar8;
	int local_20c;
	Point2F local_208;
	undefined4 local_200 [128];
	
	TVar2 = globals::g_TextCurrentType;
	image = NULL;
	bVar7 = true;
	if (FLAGS_00504610 == 0) {
		BVar4 = nerps::NERPs_IsLoaded();
		if ((BVar4 != 0) && (globals::g_TextCurrentType != TEXT__COUNT)) {
			image = globals::g_TextImages_TABLE[globals::g_TextCurrentType];
			format = globals::g_TextMessages_TABLE[globals::g_TextCurrentType];
			bVar7 = image == NULL;
			pTVar6 = PTRTextWindow_0050461c;
			if (!bVar7) {
				local_208.x = (float)(ulonglong)(uint)globals::g_TextImagePosition.x;
				local_208.y = (float)(ulonglong)(uint)globals::g_TextImagePosition.y;
				pTVar6 = PTRTextWindow_00504620;
			}
			if (format != NULL) {
				iVar3 = 1;
				if ((globals::g_TextPanelFlags & 4) != 0) {
					iVar3 = Interface_GetBool_004ded1c();
				}
				if (iVar3 != 0) {
					TextWindow_PrintFOverlay(pTVar6,1,format);
				}
			}
			if ((ushort)((ushort)(FLOAT_00504618 < 0.0) << 8 | (ushort)(FLOAT_00504618 == 0.0) << 0xe) !=
					0) {
				globals::g_TextCurrentType = TEXT__COUNT;
			}
			FLOAT_00504618 = FLOAT_00504618 - elapsedAbs;
		}
	}
	else {
		if (DAT_00504614 == NULL) {
			FLAGS_00504610 = 0;
		}
		else {
			nerps::NERPs_Level_NERPMessage_Parse(DAT_00504614,local_200,0);
			TextWindow_PrintFOverlay(PTRTextWindow_0050461c,0,(char *)local_200);
			if ((FLAGS_00504610 & 0x8000) == 0) {
				FLAGS_00504610 -= 1;
			}
		}
	}
	if (((globs::gameGlobs.flags1 & GAME1_CAMERADISABLED) != GAME1_NONE) &&
		 (TVar2 != TEXT_SPACETOCONTINUE)) {
		Text_Struct830_FUN_0046aca0();
		Panel_SetXYField3(PANEL_MESSAGES,globals::g_MsgPanel_Float42,FLOAT_00504648);
		Panel_FUN_0045a9f0(PANEL_MESSAGES,0.0);
		AirMeter_FUN_0045c6b0(PANEL_MESSAGES,(globs::gameGlobs.level)->oxygenLevel);
		AirMeter_FUN_0045c770(PANEL_MESSAGES);
		return;
	}
	if (!bVar7) {
		Text_Struct830_FUN_0046aca0();
		Panel_SetXYField3(PANEL_MESSAGES,globals::g_MsgPanel_Float42,FLOAT_00504648);
		Panel_FUN_0045a9f0(PANEL_MESSAGES,0.0);
		AirMeter_FUN_0045c6b0(PANEL_MESSAGES,(globs::gameGlobs.level)->oxygenLevel);
		AirMeter_FUN_0045c770(PANEL_MESSAGES);
		TextWindow_Update(PTRTextWindow_00504620,0,elapsedAbs,NULL);
		lego::image::Image_DisplayScaled(image,NULL,&local_208,NULL);
		return;
	}
	Panel_SetXYField3(PANEL_MESSAGES,globals::g_MsgPanel_Float42,FLOAT_00504648);
	Panel_FUN_0045a9f0(PANEL_MESSAGES,0.0);
	AirMeter_FUN_0045c6b0(PANEL_MESSAGES,(globs::gameGlobs.level)->oxygenLevel);
	AirMeter_FUN_0045c770(PANEL_MESSAGES);
	BVar4 = TextWindow_Update(PTRTextWindow_0050461c,0,elapsedAbs,&local_20c);
	pTVar6 = PTRTextWindow_0050461c;
	if (BVar4 == 0) {
		if ((globals::g_TextPanelFlags & 1) != 0) {
			if (FLOAT_0050463c <= (float)local_20c) {
				globals::g_TextPanelFlags = globals::g_TextPanelFlags & 0xfffffffe;
				return;
			}
			fVar1 = (float)(ulonglong)PTRTextWindow_0050461c->font->fontHeight;
			FLOAT_00504648 = fVar1 + FLOAT_00504648;
			Rect2F_0050464c.y = fVar1 + Rect2F_0050464c.y;
			Rect2F_0050464c.height = Rect2F_0050464c.height - fVar1;
			lVar8 = __ftol((float10)Rect2F_0050464c.y);
			iVar3 = (int)lVar8;
			lVar8 = __ftol((float10)Rect2F_0050464c.x);
			TextWindow_ChangePosition(pTVar6,(int)lVar8,iVar3);
			lVar8 = __ftol((float10)Rect2F_0050464c.height);
			uVar5 = (uint)lVar8;
			lVar8 = __ftol((float10)Rect2F_0050464c.width);
			TextWindow_ChangeSize(PTRTextWindow_0050461c,(uint)lVar8,uVar5);
			if ((float)(ulonglong)UINT_00504628 <= FLOAT_00504648) {
				FLOAT_00504648 = (float)(ulonglong)UINT_00504628;
				globals::g_TextPanelFlags &= 0xfffffffe;
				Rect2F_0050464c.x = globals::g_MsgPanel_Rect1.x;
				Rect2F_0050464c.y = globals::g_MsgPanel_Rect1.y;
				Rect2F_0050464c.width = globals::g_MsgPanel_Rect1.width;
				Rect2F_0050464c.height = globals::g_MsgPanel_Rect1.height;
				lVar8 = __ftol((float10)globals::g_MsgPanel_Rect1.y);
				iVar3 = (int)lVar8;
				lVar8 = __ftol((float10)globals::g_MsgPanel_Rect1.x);
				TextWindow_ChangePosition(PTRTextWindow_0050461c,(int)lVar8,iVar3);
				lVar8 = __ftol((float10)Rect2F_0050464c.height);
				uVar5 = (uint)lVar8;
				lVar8 = __ftol((float10)Rect2F_0050464c.width);
				TextWindow_ChangeSize(PTRTextWindow_0050461c,(uint)lVar8,uVar5);
				return;
			}
		}
		return;
	}
	fVar1 = (float)(ulonglong)PTRTextWindow_0050461c->font->fontHeight;
	FLOAT_00504648 = FLOAT_00504648 - fVar1;
	Rect2F_0050464c.y = Rect2F_0050464c.y - fVar1;
	Rect2F_0050464c.height = fVar1 + Rect2F_0050464c.height;
	lVar8 = __ftol((float10)Rect2F_0050464c.y);
	iVar3 = (int)lVar8;
	lVar8 = __ftol((float10)Rect2F_0050464c.x);
	TextWindow_ChangePosition(pTVar6,(int)lVar8,iVar3);
	lVar8 = __ftol((float10)Rect2F_0050464c.height);
	uVar5 = (uint)lVar8;
	lVar8 = __ftol((float10)Rect2F_0050464c.width);
	TextWindow_ChangeSize(PTRTextWindow_0050461c,(uint)lVar8,uVar5);
	globals::g_TextPanelFlags = globals::g_TextPanelFlags & 0xfffffffe;
	return;
}



void __cdecl
lego::front::ToolTip_Initialise
					(ImageFont *font,int value2,int value1,float float1,uint width,uint height,int value32,
					float red,float green,float blue)
{
	float *pfVar1;
	int iVar2;
	ToolTipData *pTVar3;
	
	globs::toolTipGlobs.toolTipTexts[1] = "ToolTip_RadarBlock";
	globs::toolTipGlobs.toolTipTexts[2] = "ToolTip_UnitSelect";
	globs::toolTipGlobs.toolTipTexts[3] = "ToolTip_Construction";
	globs::toolTipGlobs.toolTipTexts[4] = "ToolTip_InterfaceMenu";
	globs::toolTipGlobs.toolTipTexts[5] = "ToolTip_InterfaceMenuBackButton";
	globs::toolTipGlobs.toolTipTexts[6] = "ToolTip_MapBlock";
	globs::toolTipGlobs.toolTipTexts[7] = "ToolTip_Priority";
	globs::toolTipGlobs.toolTipTexts[8] = "ToolTip_InfoMenuContinue";
	globs::toolTipGlobs.toolTipTexts[9] = "ToolTip_InfoMenuDisableFuture";
	globs::toolTipGlobs.toolTipTexts[10] = "ToolTip_RadarToggle";
	globs::toolTipGlobs.toolTipTexts[11] = "ToolTip_RadarObjectView";
	globs::toolTipGlobs.toolTipTexts[12] = "ToolTip_RadarZoomIn";
	globs::toolTipGlobs.toolTipTexts[13] = "ToolTip_RadarZoomOut";
	globs::toolTipGlobs.toolTipTexts[14] = "ToolTip_RadarMapView";
	globs::toolTipGlobs.toolTipTexts[15] = "ToolTip_InfoDockGoto";
	globs::toolTipGlobs.toolTipTexts[16] = "ToolTip_InfoDockClose";
	globs::toolTipGlobs.toolTipTexts[17] = "ToolTip_TopPanelCallToArms";
	globs::toolTipGlobs.toolTipTexts[18] = "ToolTip_TopPanelInfo";
	globs::toolTipGlobs.toolTipTexts[19] = "ToolTip_TopPanelOptions";
	globs::toolTipGlobs.toolTipTexts[20] = "ToolTip_TopPanelPriorities";
	globs::toolTipGlobs.toolTipTexts[21] = "ToolTip_PriorityDisable";
	globs::toolTipGlobs.toolTipTexts[22] = "ToolTip_PriorityUpOne";
	globs::toolTipGlobs.toolTipTexts[23] = "ToolTip_PriorityReset";
	globs::toolTipGlobs.toolTipTexts[24] = "ToolTip_CamControlZoomIn";
	globs::toolTipGlobs.toolTipTexts[25] = "ToolTip_CamControlZoomOut";
	globs::toolTipGlobs.toolTipTexts[26] = "ToolTip_CamControlCycle";
	globs::toolTipGlobs.toolTipTexts[27] = "ToolTip_CamControlRotate";
	globs::toolTipGlobs.toolTipTexts[28] = "ToolTip_SideBar_Ore";
	globs::toolTipGlobs.toolTipTexts[29] = "ToolTip_SideBar_Crystals";
	globs::toolTipGlobs.toolTipTexts[30] = "ToolTip_Close";
	globs::toolTipGlobs.toolTipTexts[31] = "ToolTip_PreviousMessage";
	globs::toolTipGlobs.toolTipTexts[32] = "ToolTip_NextMessage";
	globs::toolTipGlobs.toolTipTexts[33] = "ToolTip_More";
	globs::toolTipGlobs.toolTipTexts[34] = "ToolTip_Back";
	globs::toolTipGlobs.toolTipTexts[35] = "ToolTip_CamControlCycleMinifigures";
	globs::toolTipGlobs.toolTipTexts[36] = "ToolTip_Reward_Save";
	globs::toolTipGlobs.toolTipTexts[37] = "ToolTip_Reward_Advance";
	globs::toolTipGlobs.toolTipTexts[38] = "ToolTip_FrontEnd_Back";
	globs::toolTipGlobs.font = font;
	globs::toolTipGlobs.fontHeight = lego::image::Font_GetHeight(font);
	globs::toolTipGlobs.hoverTime = float1 * 25.0;
	globs::toolTipGlobs.int2_8 = value2;
	globs::toolTipGlobs.int1_c = value1;
	globs::toolTipGlobs.rgbFloats[1] = red + red * 0.4;
	globs::toolTipGlobs.width = width;
	globs::toolTipGlobs.height = height;
	globs::toolTipGlobs.int32_18 = value32;
	globs::toolTipGlobs.rgbFloats[0] = red;
	globs::toolTipGlobs.rgbFloats[3] = green;
	globs::toolTipGlobs.rgbFloats[6] = blue;
	globs::toolTipGlobs.rgbFloats[4] = green + green * 0.4;
	globs::toolTipGlobs.rgbFloats[7] = blue + blue * 0.4;
	globs::toolTipGlobs.rgbFloats[2] = red - red * 0.4;
	pfVar1 = globs::toolTipGlobs.rgbFloats + 3;
	globs::toolTipGlobs.rgbFloats[5] = green - green * 0.4;
	globs::toolTipGlobs.rgbFloats[8] = blue - blue * 0.4;
	do {
										// Do bounds checking for RGB values
		if ((ushort)((ushort)(pfVar1[-3] < 1.0) << 8 | (ushort)(pfVar1[-3] == 1.0) << 0xe) == 0) {
			pfVar1[-3] = 1.0;
		}
		if ((ushort)((ushort)(*pfVar1 < 1.0) << 8 | (ushort)(*pfVar1 == 1.0) << 0xe) == 0) {
			*pfVar1 = 1.0;
		}
		if ((ushort)((ushort)(pfVar1[3] < 1.0) << 8 | (ushort)(pfVar1[3] == 1.0) << 0xe) == 0) {
			pfVar1[3] = 1.0;
		}
		if (pfVar1[-3] < 0.0) {
			pfVar1[-3] = 0.0;
		}
		if (*pfVar1 < 0.0) {
			*pfVar1 = 0.0;
		}
		if (pfVar1[3] < 0.0) {
			pfVar1[3] = 0.0;
		}
		pfVar1 = pfVar1 + 1;
	} while (pfVar1 < globs::toolTipGlobs.rgbFloats + 6);
	pTVar3 = globs::toolTipGlobs.toolTipDatas;
	for (iVar2 = 0x1839; iVar2 != 0; iVar2 += -1) {
		pTVar3->timer = 0.0;
		pTVar3 = (ToolTipData *)pTVar3->textBuffer;
	}
	return;
}



BOOL __cdecl lego::front::ToolTip_GetType(char *toolTipName,ToolTipType *out_toolTipType)
{
	int iVar1;
	ToolTipData *pTVar2;
	ToolTipType TVar3;
	
	TVar3 = TOOLTIP_RADARBLOCK;
	pTVar2 = (ToolTipData *)(globs::toolTipGlobs.toolTipTexts + 1);
	do {
		iVar1 = std::_stricmp(toolTipName,(char *)pTVar2->timer);
		if (iVar1 == 0) {
			*out_toolTipType = TVar3;
			return TRUE;
		}
		pTVar2 = (ToolTipData *)pTVar2->textBuffer;
		TVar3 += TOOLTIP_RADARBLOCK;
	} while (pTVar2 < globs::toolTipGlobs.toolTipDatas);
	return 0;
}



void __cdecl lego::front::ToolTip_SetText(ToolTipType toolTipType,char *msg,...)
{
	char *msg_00;
	char *pcVar1;
	char cVar2;
	ToolTipFlags TVar3;
	int iVar4;
	int iVar5;
	ImageBMP *pIVar6;
	char *pcVar7;
	char *pcVar8;
	char filename [260];
	char tooltipText [512];
	
	std::vsprintf(tooltipText,msg,&stack0x0000000c);
										// Use @ to denote an image...
	if (tooltipText[0] == '@') {
		iVar5 = 1;
		while (tooltipText[1] != '\0') {
			filename[iVar5 + -1] = tooltipText[1];
			iVar4 = iVar5 + 1;
			iVar5 += 1;
			tooltipText[1] = tooltipText[iVar4];
		}
		filename[iVar5 + -1] = '\0';
		pIVar6 = lego::image::Image_LoadBMPScaled(filename,0,0);
		globs::toolTipGlobs.toolTipDatas[toolTipType].tooltipImage = pIVar6;
		globs::toolTipGlobs.toolTipDatas[toolTipType].flags =
				 globs::toolTipGlobs.toolTipDatas[toolTipType].flags | TOOLTIP_FLAG_UNK_8;
	}
	else {
		msg_00 = globs::toolTipGlobs.toolTipDatas[toolTipType].textBuffer;
		pcVar7 = tooltipText;
		pcVar8 = msg_00;
		while (tooltipText[0] != '\0') {
			cVar2 = *pcVar7;
										// an \n as a return character...
			if ((cVar2 == '\\') && (pcVar7[1] == 'n')) {
				*pcVar8 = '\n';
				pcVar7 = pcVar7 + 1;
			}
			else {
										// Use underscores as spaces
				if (cVar2 == '_') {
					*pcVar8 = ' ';
				}
				else {
					*pcVar8 = cVar2;
				}
			}
			pcVar1 = pcVar7 + 1;
			pcVar8 = pcVar8 + 1;
			pcVar7 = pcVar7 + 1;
			tooltipText[0] = *pcVar1;
		}
		*pcVar8 = '\0';
		lego::image::Font_GetStringInfo
							(globs::toolTipGlobs.font,&globs::toolTipGlobs.toolTipDatas[toolTipType].textWidth,
							 &globs::toolTipGlobs.toolTipDatas[toolTipType].textLineCount,msg_00);
		globs::toolTipGlobs.toolTipDatas[toolTipType].flags =
				 globs::toolTipGlobs.toolTipDatas[toolTipType].flags & ~TOOLTIP_FLAG_UNK_8;
	}
	TVar3 = globs::toolTipGlobs.toolTipDatas[toolTipType].flags;
	globs::toolTipGlobs.toolTipDatas[toolTipType].iconCount = 0;
	globs::toolTipGlobs.toolTipDatas[toolTipType].field_264 = 0;
	globs::toolTipGlobs.toolTipDatas[toolTipType].field_260 = 0;
	globs::toolTipGlobs.toolTipDatas[toolTipType].field_26c = 0;
	globs::toolTipGlobs.toolTipDatas[toolTipType].field_268 = 0;
	globs::toolTipGlobs.toolTipDatas[toolTipType].flags =
			 TVar3 | (TOOLTIP_FLAG_UNK_1|TOOLTIP_FLAG_UNK_2);
	return;
}



void __cdecl lego::front::ToolTip_AddIcon(ToolTipType toolTipType,ImageBMP *image)
{
	uint uVar1;
	int iVar2;
	
	if (image == NULL) {
		globs::toolTipGlobs.toolTipDatas[toolTipType].field_260 = 0;
		globs::toolTipGlobs.toolTipDatas[toolTipType].field_268 = 0;
	}
	else {
		iVar2 = globs::toolTipGlobs.toolTipDatas[toolTipType].field_260;
		if (iVar2 < (int)image->height) {
			iVar2 = globs::toolTipGlobs.toolTipDatas[toolTipType].field_264 - iVar2;
			globs::toolTipGlobs.toolTipDatas[toolTipType].field_264 = iVar2;
			uVar1 = image->height;
			globs::toolTipGlobs.toolTipDatas[toolTipType].field_260 = uVar1;
			globs::toolTipGlobs.toolTipDatas[toolTipType].field_264 = iVar2 + uVar1;
		}
		iVar2 = globs::toolTipGlobs.toolTipDatas[toolTipType].field_268 + image->width;
		globs::toolTipGlobs.toolTipDatas[toolTipType].field_268 = iVar2;
		if (globs::toolTipGlobs.toolTipDatas[toolTipType].field_26c < iVar2) {
			globs::toolTipGlobs.toolTipDatas[toolTipType].field_26c = iVar2;
		}
	}
										// globs::toolTipGlobs.toolTipDatas[toolTipType].imageList[.imageCount] = image;
	*(ImageBMP **)
	 (toolTipType * 0x27c + 0x54d20c + globs::toolTipGlobs.toolTipDatas[toolTipType].iconCount * 4) =
			 image;
	globs::toolTipGlobs.toolTipDatas[toolTipType].iconCount =
			 globs::toolTipGlobs.toolTipDatas[toolTipType].iconCount + 1;
	return;
}



void __cdecl lego::front::ToolTip_SetSFX(ToolTipType toolTipType,SFXType sfxType)
{
	ToolTipFlags TVar1;
	
	TVar1 = globs::toolTipGlobs.toolTipDatas[toolTipType].flags;
	globs::toolTipGlobs.toolTipDatas[toolTipType].sfxType = sfxType;
	globs::toolTipGlobs.toolTipDatas[toolTipType].flags =
			 TVar1 | (TOOLTIP_FLAG_UNK_1|TOOLTIP_FLAG_UNK_2);
	return;
}



void __cdecl lego::front::ToolTip_SetFlag10(ToolTipType toolTipType,BOOL state)
{
	ToolTipFlags TVar1;
	
	TVar1 = globs::toolTipGlobs.toolTipDatas[toolTipType].flags;
	if (state != 0) {
		globs::toolTipGlobs.toolTipDatas[toolTipType].flags = TVar1 | TOOLTIP_FLAG_UNK_10;
		return;
	}
	globs::toolTipGlobs.toolTipDatas[toolTipType].flags = TVar1 & ~TOOLTIP_FLAG_UNK_10;
	return;
}



void __cdecl lego::front::ToolTip_AddFlag4(ToolTipType toolTipType)
{
	globs::toolTipGlobs.toolTipDatas[toolTipType].flags =
			 globs::toolTipGlobs.toolTipDatas[toolTipType].flags | TOOLTIP_FLAG_UNK_4;
	return;
}



void __cdecl lego::front::ToolTip_ResetTimer(ToolTipType toolTipType)
{
	globs::toolTipGlobs.toolTipDatas[toolTipType].timer = globs::toolTipGlobs.hoverTime;
	return;
}



void __cdecl lego::front::ToolTip_Update(uint mousex,uint mousey,float elapsedAbs)
{
	ToolTipData *toolTip;
	bool bVar1;
	BOOL BVar2;
	uint uVar3;
	bool bVar4;
	WorldMeshStruct_8 *pWVar5;
	
	bVar4 = false;
	bVar1 = false;
	pWVar5 = (WorldMeshStruct_8 *)&globs::toolTipGlobs.toolTipDatas[1].flags;
	uVar3 = globals::g_ToolTipIsSFXPlaying;
	do {
		if ((pWVar5->groupID & 3) != 0) {
			if (((pWVar5->groupID & 4) == 0) || (bVar1)) {
				pWVar5[-0x4f].groupID = D3DRMGROUP_0;
			}
			else {
				toolTip = (ToolTipData *)(pWVar5 + -0x4f);
				if (((float)pWVar5[-0x4f].groupID < globs::toolTipGlobs.hoverTime) || (bVar4)) {
					uVar3 = TRUE;
					globals::g_ToolTipIsSFXPlaying = TRUE;
					bVar1 = true;
					toolTip->timer = elapsedAbs + toolTip->timer;
				}
				else {
					if (((pWVar5[-1].flags != SFX_NULL) && (uVar3 != 0)) &&
						 ((globs::gameGlobs.flags2 & GAME2_DISABLETOOLTIPSOUND) == GAME2_NONE)) {
						BVar2 = snd::SFX_Sample_Random_SetAndPlayGlobalSample(pWVar5[-1].flags,NULL);
						uVar3 = (uint)(BVar2 == 0);
						globals::g_ToolTipIsSFXPlaying = uVar3;
					}
					if (pWVar5 != (WorldMeshStruct_8 *)0x274) {
						ToolTip_Draw(toolTip,mousex,mousey);
						uVar3 = globals::g_ToolTipIsSFXPlaying;
					}
					bVar4 = true;
					bVar1 = true;
					toolTip->timer = elapsedAbs + toolTip->timer;
				}
			}
			pWVar5->groupID = pWVar5->groupID & 0xfffffffb;
		}
		pWVar5 = (WorldMeshStruct_8 *)&pWVar5[0x4f].flags;
	} while (pWVar5 < globals::g_WorldMesh_Structs_TABLE + 0x38);
	return;
}



void __cdecl
lego::front::ToolTip_DrawBox
					(Rect2F valueRect,float rcRed,float rcGreen,float rcBlue,float ln1Red,float ln1Green,
					float ln1Blue,float ln2Red,float ln2Green,float ln2Blue,BOOL halfTrans)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	Point2F *pPVar7;
	Point2F *pPVar8;
	float *pfVar9;
	float *pfVar10;
	uint count;
	Point2F *pPVar11;
	float *pfVar12;
	Point2F *local_168;
	float *local_164;
	uint local_160;
	uint local_15c;
	Point2F local_140;
	float local_138 [18];
	Point2F local_f0;
	float afStack232 [18];
	Point2F local_a0;
	float local_98 [18];
	Point2F local_50;
	float local_48 [18];
	
	count = 0;
	local_160 = 0;
	local_15c = 0;
	if (globs::toolTipGlobs.int2_8 != 0) {
		local_168 = &local_f0;
		local_164 = &local_f0.y;
		pPVar8 = &local_50;
		pfVar12 = &local_50.y;
		pfVar10 = &local_140.y;
		pPVar11 = &local_140;
		pfVar9 = &local_a0.y;
		pPVar7 = &local_a0;
		do {
			fVar4 = (float)(ulonglong)local_15c;
			fVar2 = valueRect.x + fVar4;
			fVar3 = valueRect.y + fVar4;
			fVar6 = ((valueRect.y + valueRect.height) - 1.0) - fVar4;
			fVar5 = ((valueRect.x + valueRect.width) - 1.0) - fVar4;
			pPVar7->x = fVar2;
			*pfVar9 = fVar3;
			fVar1 = pPVar7->x;
			pPVar8->x = fVar2;
			*pfVar10 = ((valueRect.y + valueRect.height) - 2.0) - fVar4;
			*pfVar12 = fVar6;
			pPVar7[1].x = fVar5;
			pPVar11->x = fVar1;
			local_168->x = ((valueRect.x + valueRect.width) - 2.0) - fVar4;
			pfVar9[2] = fVar3;
			*local_164 = fVar6;
			pPVar8[1].x = fVar5;
			pPVar11[1].x = fVar2 - -1.0;
			pfVar12[2] = fVar6;
			fVar1 = pPVar8[1].x;
			pfVar10[2] = fVar3;
			pPVar7 = pPVar7 + 2;
			pfVar9 = pfVar9 + 4;
			pPVar11 = pPVar11 + 2;
			pfVar12 = pfVar12 + 4;
			local_164[2] = fVar3 - -1.0;
			pPVar8 = pPVar8 + 2;
			local_168[1].x = fVar1;
			count = local_160 + 2;
			local_168 = local_168 + 2;
			pfVar10 = pfVar10 + 4;
			local_164 = local_164 + 4;
			local_15c += 1;
			local_160 = count;
		} while (local_15c < globs::toolTipGlobs.int2_8);
	}
	if (halfTrans == 0) {
		draw::Draw_RectListEx(&valueRect,1,rcRed,rcGreen,rcBlue,DRAWEFFECT_NONE);
		draw::Draw_LineListEx(&local_a0,&local_140,count,ln1Red,ln1Green,ln1Blue,DRAWEFFECT_NONE);
		draw::Draw_LineListEx(&local_50,&local_f0,count,ln2Red,ln2Green,ln2Blue,DRAWEFFECT_NONE);
		return;
	}
	draw::Draw_RectListEx(&valueRect,1,rcRed,rcGreen,rcBlue,DRAWEFFECT_HALFTRANS);
	draw::Draw_LineListEx(&local_a0,&local_140,count,ln1Red,ln1Green,ln1Blue,DRAWEFFECT_NONE);
	draw::Draw_LineListEx(&local_50,&local_f0,count,ln2Red,ln2Green,ln2Blue,DRAWEFFECT_NONE);
	return;
}



void __cdecl lego::front::ToolTip_Draw(ToolTipData *toolTip,uint x,uint y)
{
	uint uVar1;
	int iVar2;
	uint uVar3;
	ImageBMP **ppIVar4;
	uint uVar5;
	float10 extraout_ST0;
	float10 extraout_ST1;
	longlong lVar6;
	char *msg;
	char *pcVar7;
	Point2F local_44;
	uint local_3c;
	undefined4 uStack56;
	float local_34;
	float fStack48;
	float local_2c;
	float local_28;
	float fStack36;
	float local_20;
	float local_1c;
	float fStack24;
	float local_14;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	local_34 = globs::toolTipGlobs.rgbFloats[0];
	fStack48 = globs::toolTipGlobs.rgbFloats[3];
	local_28 = globs::toolTipGlobs.rgbFloats[1];
	fStack36 = globs::toolTipGlobs.rgbFloats[4];
	local_2c = globs::toolTipGlobs.rgbFloats[6];
	local_1c = globs::toolTipGlobs.rgbFloats[2];
	fStack24 = globs::toolTipGlobs.rgbFloats[5];
	local_20 = globs::toolTipGlobs.rgbFloats[7];
	iVar2 = (globs::toolTipGlobs.int1_c + globs::toolTipGlobs.int2_8) * 2;
	local_14 = globs::toolTipGlobs.rgbFloats[8];
	if ((toolTip->flags & TOOLTIP_FLAG_UNK_8) == TOOLTIP_FLAG_NONE) {
		uVar5 = toolTip->textWidth;
		if (toolTip->textWidth <= (uint)toolTip->field_26c) {
			uVar5 = toolTip->field_26c;
		}
		uVar3 = toolTip->textLineCount * globs::toolTipGlobs.fontHeight + toolTip->field_264;
	}
	else {
		uVar5 = toolTip->tooltipImage->width;
		uVar3 = toolTip->tooltipImage->height;
	}
	uVar3 = iVar2 + uVar3;
	local_44.x = (float)(iVar2 + uVar5);
	if ((toolTip->flags & TOOLTIP_FLAG_UNK_10) == TOOLTIP_FLAG_NONE) {
		if (globs::toolTipGlobs.width < (int)local_44.x + x) {
			local_10 = (float)(ulonglong)(globs::toolTipGlobs.width - (int)local_44.x);
		}
		else {
			local_10 = (float)(ulonglong)x;
		}
	}
	else {
		local_10 = (float)(ulonglong)x - -32.0;
		if ((ushort)((ushort)(local_10 < (float)(ulonglong)globs::toolTipGlobs.width) << 8 |
								(ushort)(local_10 == (float)(ulonglong)globs::toolTipGlobs.width) << 0xe) == 0) {
			local_10 = (float)(ulonglong)(globs::toolTipGlobs.width - (int)local_44.x);
		}
		else {
			local_10 = local_10 - (float)(ulonglong)(uint)local_44.x;
		}
	}
	local_c = (float)(ulonglong)(globs::toolTipGlobs.int32_18 + y);
	local_4 = (float)(ulonglong)uVar3;
	if ((float)(ulonglong)globs::toolTipGlobs.height < local_c + local_4) {
		local_c = (float)(ulonglong)(y - uVar3) - 1.0;
	}
	local_44.y = 0.0;
	local_8 = (float)(ulonglong)(uint)local_44.x;
	ToolTip_DrawBox((Rect2F)CONCAT412(local_4,CONCAT48(local_8,CONCAT44(local_c,local_10))),
									globs::toolTipGlobs.rgbFloats[0],globs::toolTipGlobs.rgbFloats[3],
									globs::toolTipGlobs.rgbFloats[6],globs::toolTipGlobs.rgbFloats[1],
									globs::toolTipGlobs.rgbFloats[4],globs::toolTipGlobs.rgbFloats[7],
									globs::toolTipGlobs.rgbFloats[2],globs::toolTipGlobs.rgbFloats[5],
									globs::toolTipGlobs.rgbFloats[8],0);
	if ((*(byte *)&toolTip->flags & TOOLTIP_FLAG_UNK_8) == 0) {
		x = toolTip->textLineCount * globs::toolTipGlobs.fontHeight;
		local_3c = globs::toolTipGlobs.int1_c;
		uStack56 = 0;
		pcVar7 = toolTip->textBuffer;
		uVar3 = 0;
		uVar5 = 0;
		msg = "%s";
		lVar6 = __ftol((float10)local_c + (float10)(ulonglong)(uint)globs::toolTipGlobs.int1_c +
									 (float10)(ulonglong)globs::toolTipGlobs.int2_8);
		iVar2 = (int)lVar6;
		lVar6 = __ftol((float10)local_10 + extraout_ST0 + extraout_ST1);
		lego::image::Font_PrintF(globs::toolTipGlobs.font,(int)lVar6,iVar2,msg,pcVar7);
		y = 0;
		if (toolTip->iconCount != 0) {
			ppIVar4 = toolTip->iconList;
			do {
				if (*ppIVar4 == NULL) {
					x += uVar5;
					uVar5 = 0;
					uVar3 = 0;
				}
				else {
					local_3c = globs::toolTipGlobs.int2_8;
					uStack56 = 0;
					local_34 = (float)globs::toolTipGlobs.int1_c;
					fStack48 = 0.0;
					fStack36 = 0.0;
					fStack24 = 0.0;
					local_1c = (float)x;
					local_44.x = (float)(ulonglong)uVar3 +
											 local_10 + (float)(ulonglong)(uint)globs::toolTipGlobs.int1_c +
											 (float)(ulonglong)globs::toolTipGlobs.int2_8;
					local_44.y = (float)(ulonglong)x +
											 local_c + (float)(ulonglong)(uint)globs::toolTipGlobs.int1_c +
											 (float)(ulonglong)globs::toolTipGlobs.int2_8;
					local_28 = (float)uVar3;
					lego::image::Image_DisplayScaled(*ppIVar4,NULL,&local_44,NULL);
					uVar1 = (*ppIVar4)->height;
					if ((int)uVar5 < (int)uVar1) {
						uVar5 = uVar1;
					}
					uVar3 += (*ppIVar4)->width;
				}
				y += 1;
				ppIVar4 = ppIVar4 + 1;
			} while (y < toolTip->iconCount);
		}
		return;
	}
	local_3c = globs::toolTipGlobs.int1_c;
	uStack56 = 0;
	local_44.x = local_10 + (float)(ulonglong)(uint)globs::toolTipGlobs.int1_c +
							 (float)(ulonglong)globs::toolTipGlobs.int2_8;
	local_44.y = local_c + (float)(ulonglong)(uint)globs::toolTipGlobs.int1_c +
							 (float)(ulonglong)globs::toolTipGlobs.int2_8;
	lego::image::Image_DisplayScaled(toolTip->tooltipImage,NULL,&local_44,NULL);
	return;
}



void __cdecl
lego::res::Upgrade_InitUnk_FUN_0046c2f0
					(UpgradeData *out_upgrade,int index,Container *resRoot,char *filename)
{
	Container *pCVar1;
	
	out_upgrade->objectIndex = 0;
	out_upgrade->aeResData = NULL;
	out_upgrade->object_8 = NULL;
	out_upgrade->field_c = 0;
	pCVar1 = Container_Load(resRoot,filename,"LWO",1);
	out_upgrade->aeResData = pCVar1;
	if (pCVar1 == NULL) {
		pCVar1 = Container_Load(resRoot,filename,"ACT",1);
		out_upgrade->aeResData = pCVar1;
	}
	if (out_upgrade->aeResData == NULL) {
		pCVar1 = Container_Load(resRoot,filename,"MESH",1);
		out_upgrade->aeResData = pCVar1;
	}
	out_upgrade->object_8 = NULL;
	out_upgrade->objectIndex = index;
	return;
}



void __cdecl lego::res::Upgrade_Duplicate(UpgradeData *in_upgrade,UpgradeData *out_upgrade)
{
	Container *pCVar1;
	
	out_upgrade->objectIndex = in_upgrade->objectIndex;
	out_upgrade->aeResData = in_upgrade->aeResData;
	out_upgrade->object_8 = in_upgrade->object_8;
	out_upgrade->field_c = in_upgrade->field_c;
	pCVar1 = Container_Clone(in_upgrade->aeResData);
	out_upgrade->aeResData = pCVar1;
	return;
}



void __cdecl lego::res::Upgrade_Destroy(UpgradeData *upgrade)
{
	Container_Remove(upgrade->aeResData);
	return;
}



float10 __cdecl
lego::res::Upgrade_DoAnimElapsedCallbacks(UpgradeData *upgrade,float elapsed,BOOL unused_bool)
{
	Container_MoveAnimation(upgrade->aeResData,elapsed);
	return (float10)0.0;
}



BOOL __cdecl lego::res::Upgrade_FUN_0046c3f0(UpgradeData *upgrade,char *activityName)
{
	BOOL BVar1;
	
	BVar1 = Container_SetActivity(upgrade->aeResData,activityName);
	if (BVar1 == 0) {
		BVar1 = Container_SetActivity(upgrade->aeResData,globs::liveGlobs.Activities_TABLE[0]);
	}
	return BVar1;
}



void __cdecl
lego::res::Upgrade_LoadUpgradeLevels
					(ObjectUpgradesData *upgrades,CFGProperty *aeRoot,char *rootName)
{
	char cVar1;
	ObjectUpgradePartData *pOVar2;
	char *pcVar3;
	CFGProperty *prop;
	undefined4 *puVar4;
	UpgradeData *pUVar5;
	int iVar6;
	uint uVar7;
	uint uVar8;
	undefined4 *puVar9;
	char *pcVar10;
	uint local_12c;
	char *local_128;
	char *local_124;
	char *local_120;
	char local_100 [256];
	
	upgrades->count = 0;
	pOVar2 = (ObjectUpgradePartData *)std::malloc(4000);
	upgrades->parts = pOVar2;
	for (iVar6 = 1000; iVar6 != 0; iVar6 += -1) {
		pOVar2->level = 0;
		pOVar2 = (ObjectUpgradePartData *)&pOVar2->NullInstance;
	}
	local_12c = 0;
	do {
		std::sprintf(local_100,"Level%i%i%i%i",local_12c >> 3 & 1,local_12c >> 2 & 1,local_12c >> 1 & 1,
								 local_12c & 1);
		pcVar3 = cfg::CFG_JoinPath(rootName,"Upgrades",local_100,0);
		prop = cfg::CFG_GetChildren(aeRoot,pcVar3);
		if (prop != NULL) {
			upgrades->levelsMask = upgrades->levelsMask | local_12c;
			for (; prop != NULL; prop = cfg::CFG_NextFlat(prop)) {
				uVar7 = 0xffffffff;
				pOVar2 = upgrades->parts + upgrades->count;
				pcVar3 = prop->value;
				do {
					pcVar10 = pcVar3;
					if (uVar7 == 0) break;
					uVar7 -= 1;
					pcVar10 = pcVar3 + 1;
					cVar1 = *pcVar3;
					pcVar3 = pcVar10;
				} while (cVar1 != '\0');
				uVar7 = ~uVar7;
				puVar4 = (undefined4 *)(pcVar10 + -uVar7);
				puVar9 = (undefined4 *)local_100;
				for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
					*puVar9 = *puVar4;
					puVar4 = puVar4 + 1;
					puVar9 = puVar9 + 1;
				}
				for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
					*(undefined *)puVar9 = *(undefined *)puVar4;
					puVar4 = (undefined4 *)((int)puVar4 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				iVar6 = util::Util_Tokenise(local_100,&local_128,",");
				if (iVar6 == 3) {
					uVar7 = 0xffffffff;
					pcVar3 = local_120;
					do {
						if (uVar7 == 0) break;
						uVar7 -= 1;
						cVar1 = *pcVar3;
						pcVar3 = pcVar3 + 1;
					} while (cVar1 != '\0');
					puVar4 = (undefined4 *)std::malloc(~uVar7);
					uVar7 = 0xffffffff;
					pOVar2->WeaponName = (char *)puVar4;
					pcVar3 = local_120;
					do {
						pcVar10 = pcVar3;
						if (uVar7 == 0) break;
						uVar7 -= 1;
						pcVar10 = pcVar3 + 1;
						cVar1 = *pcVar3;
						pcVar3 = pcVar10;
					} while (cVar1 != '\0');
					uVar7 = ~uVar7;
					puVar9 = (undefined4 *)(pcVar10 + -uVar7);
					for (uVar8 = uVar7 >> 2; uVar8 != 0; uVar8 -= 1) {
						*puVar4 = *puVar9;
						puVar9 = puVar9 + 1;
						puVar4 = puVar4 + 1;
					}
					for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
						*(undefined *)puVar4 = *(undefined *)puVar9;
						puVar9 = (undefined4 *)((int)puVar9 + 1);
						puVar4 = (undefined4 *)((int)puVar4 + 1);
					}
				}
				pcVar3 = std::_strdup(local_128);
				pOVar2->NullObjectName = pcVar3;
				pOVar2->level = local_12c;
				iVar6 = std::atoi(local_124);
				pOVar2->NullInstance = iVar6 + -1;
				pUVar5 = game::Game_GetUpgradeData(prop->key);
				pOVar2->upgradeData = pUVar5;
				upgrades->count = upgrades->count + 1;
			}
		}
		local_12c += 1;
		if (0xf < local_12c) {
			if (upgrades->count == 0) {
				std::free(upgrades->parts);
				upgrades->parts = NULL;
			}
			return;
		}
	} while( true );
}



void __cdecl lego::res::Upgrade_ChangeUpgradeParts(ObjectUpgradesData *upgrades,int objLevel)
{
	LiveObject *pLVar1;
	LiveObject *pLVar2;
	UpgradeData *pUVar3;
	int iVar4;
	uint objIndex;
	
	iVar4 = 0;
	pLVar2 = (LiveObject *)upgrades->upgradeObjs;
	pUVar3 = (UpgradeData *)objLevel;
	while (pLVar2 != NULL) {
		pUVar3 = pLVar2->upgrade;
		pLVar1 = pUVar3->object_8;
		pool::ReservedPool_LiveObject___Release(pLVar2);
		pLVar2 = pLVar1;
	}
	objIndex = 0;
	upgrades->currentLevel = objLevel;
	upgrades->upgradeObjs = NULL;
	if (upgrades->count != 0) {
		do {
			if (*(int *)((int)&upgrades->parts->level + iVar4) == objLevel) {
				pLVar2 = game::LiveObject__Create
													 (*(int ***)((int)&upgrades->parts->upgradeData + iVar4),
														OBJECT_UPGRADEPART,objIndex);
				if (upgrades->upgradeObjs == NULL) {
					upgrades->upgradeObjs = (LiveObject **)pLVar2;
				}
				else {
					pUVar3->object_8 = pLVar2;
				}
				pUVar3 = pLVar2->upgrade;
				pUVar3->field_c = (int)&upgrades->parts->level + iVar4;
			}
			objIndex += 1;
			iVar4 += 0x14;
		} while (objIndex < upgrades->count);
	}
	return;
}



BOOL __cdecl lego::res::Vehicle_IsCameraFlipDir(VehicleData *vehicle)
{
	return (uint)(vehicle->CameraFlipDir == BOOL3_TRUE);
}



BOOL __cdecl
lego::res::Vehicle_SetActivity_AndRemoveCarryCameraFrames
					(VehicleData *vehicle,char *activityName,float elapsed)
{
	uint uVar1;
	uint uVar2;
	BOOL BVar3;
	Container **ppCVar4;
	
	MeshPoly_FUN_00451ef0(vehicle->polyMedium_1);
	uVar1 = 0;
	vehicle->field_cc = 0;
	vehicle->field_d0 = 0;
	vehicle->resData_d4 = NULL;
	if (vehicle->CameraNullFrames != 0) {
		ppCVar4 = vehicle->cameraFramesTable_10c;
		do {
			*ppCVar4 = NULL;
			uVar1 += 1;
			ppCVar4 = ppCVar4 + 1;
		} while (uVar1 < vehicle->CameraNullFrames);
	}
	uVar1 = 0;
	if (vehicle->CarryNullFrames != 0) {
		ppCVar4 = vehicle->carryFramesTable_e4;
		do {
			*ppCVar4 = NULL;
			uVar1 += 1;
			ppCVar4 = ppCVar4 + 1;
		} while (uVar1 < vehicle->CarryNullFrames);
	}
	uVar2 = Container_SetActivity(vehicle->contAct_1,activityName);
	uVar1 = vehicle->flags;
	vehicle->flags = uVar1 & 0xfffffffb;
	if ((uVar2 == 0) && ((uVar1 & 8) != 0)) {
		BVar3 = Container_IsCurrentActivity(vehicle->contAct_1,activityName);
		if (BVar3 == 0) {
			vehicle->flags = vehicle->flags | 4;
		}
	}
	if (vehicle->contAct_2 != NULL) {
		uVar1 = Container_SetActivity(vehicle->contAct_2,activityName);
		uVar2 |= uVar1;
	}
	if ((*(byte *)&vehicle->flags & 4) == 0) {
		Container_SetAnimationTime(vehicle->contAct_1,elapsed);
	}
	if (vehicle->contAct_2 != NULL) {
		Container_SetAnimationTime(vehicle->contAct_2,elapsed);
	}
	Vehicle_Wheels_FUN_0046d520(vehicle);
	Vehicle_UnkUpgrades(vehicle,activityName);
	return uVar2;
}



void __cdecl lego::res::Vehicle_UnkUpgrades(VehicleData *vehicle,char *param_2)
{
	Container **opt_instance;
	LiveObject *pLVar1;
	VehicleData *vehicle_00;
	undefined4 *puVar2;
	Container *parent;
	Container *in_child;
	char *pcVar3;
	Container *pCVar4;
	undefined4 *puVar5;
	int iVar6;
	UpgradeData *upgrade;
	uint local_14;
	int local_10;
	int local_c;
	Container *local_8;
	UpgradeData *local_4;
	
	vehicle_00 = vehicle;
	iVar6 = 3;
	pLVar1 = (LiveObject *)(vehicle->upgrades).upgradeObjs;
	puVar2 = (undefined4 *)&vehicle->field_0x15c;
	puVar5 = (undefined4 *)&vehicle->field_0x138;
	do {
		puVar2[0x1a] = 0;
		*puVar2 = 0;
		puVar2[-3] = 0;
		*puVar5 = 0;
		puVar2 = puVar2 + 1;
		iVar6 += -1;
		puVar5[1] = 0;
		puVar5 = puVar5 + 2;
	} while (iVar6 != 0);
	vehicle->field_1dc = 0;
	do {
		if (pLVar1 == NULL) {
			return;
		}
		upgrade = pLVar1->upgrade;
		pCVar4 = (Container *)upgrade->field_c;
		local_8 = pCVar4;
		local_4 = upgrade;
		parent = Vehicle_GetNull(vehicle_00,pCVar4->hiddenFrame,pCVar4->activityFrame);
		in_child = Object_GetActivityContainer((BasicObjectData *)upgrade);
		Container_SetParent(in_child,parent);
		Container_ClearTransform(in_child);
		if (param_2 == NULL) {
			Container_SetActivity(upgrade->aeResData,globs::liveGlobs.Activities_TABLE[0]);
		}
		else {
			Upgrade_FUN_0046c3f0(upgrade,param_2);
		}
		if (pCVar4->typeData != NULL) {
			iVar6 = vehicle_00->field_1dc;
			local_10 = 0;
			vehicle_00->table6_1c4[iVar6 + -0x15] = NULL;
			local_14 = 0;
			opt_instance = vehicle_00->table6_1c4 + iVar6 + -0x15;
			vehicle = (VehicleData *)(vehicle_00->cameraFramesTable_10c + iVar6 * 2 + 0xb);
			local_c = iVar6;
			do {
				vehicle->objIndex = 0;
				pcVar3 = Container_FormatPartName
													 (vehicle_00->contAct_1,vehicle_00->FireNullName,(int *)opt_instance);
				pCVar4 = Container_SearchTree(in_child,pcVar3,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
				vehicle_00->cameraFramesTable_10c[(int)&(*opt_instance)->hiddenFrame + iVar6 * 2 + 3] =
						 pCVar4;
				pCVar4 = vehicle_00->cameraFramesTable_10c
								 [(int)&(*opt_instance)->hiddenFrame + iVar6 * 2 + 3];
				*opt_instance = (Container *)((int)&(*opt_instance)->masterFrame + 1);
				if (pCVar4 == NULL) break;
				local_14 += 1;
				vehicle = (VehicleData *)&vehicle->WheelNullName;
			} while (local_14 < 2);
			pcVar3 = Container_FormatPartName(vehicle_00->contAct_1,vehicle_00->xPivot,&local_10);
			pCVar4 = Container_SearchTree(in_child,pcVar3,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
			iVar6 = local_c;
			vehicle_00->cameraFramesTable_10c[local_c + 0x11] = pCVar4;
			pcVar3 = Container_FormatPartName(vehicle_00->contAct_1,vehicle_00->yPivot,&local_10);
			pCVar4 = Container_SearchTree(in_child,pcVar3,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
			vehicle_00->cameraFramesTable_10c[iVar6 + 0x14] = pCVar4;
			vehicle_00->table6_1c4[iVar6] = local_8;
			vehicle_00->field_1dc = vehicle_00->field_1dc + 1;
			upgrade = local_4;
		}
		pLVar1 = upgrade->object_8;
	} while( true );
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe
// WARNING: Could not reconcile some variable overlaps

BOOL __cdecl
lego::res::Vehicle_LoadActivityFile
					(VehicleData *vehicle,int objIndex,Container *resRoot,char *aeFilename,char *rootName)
{
	char cVar1;
	int iVar2;
	Container *pCVar3;
	CFGProperty *prop;
	char *pcVar4;
	BOOL3 BVar5;
	PolyMeshData *pPVar6;
	CFGProperty *aeRoot;
	int iVar7;
	uint uVar8;
	uint uVar9;
	int *piVar10;
	undefined4 *puVar11;
	VehicleData *pVVar12;
	Container **ppCVar13;
	char *pcVar14;
	undefined4 *puVar15;
	float10 fVar16;
	char *pcStack4560;
	char *pcStack4556;
	D3DRMBox DStack4520;
	char *pcStack4496;
	int aiStack4492 [99];
	undefined4 auStack4096 [256];
	char acStack3072 [1024];
	char buff2 [1024];
	char buff1 [1024];
	
	buff1._1020_4_ = 0x46c9ba;
	pVVar12 = vehicle;
	for (iVar7 = 0x7b; iVar7 != 0; iVar7 += -1) {
		pVVar12->objIndex = 0;
		pVVar12 = (VehicleData *)&pVVar12->WheelNullName;
	}
	uVar8 = 0xffffffff;
	do {
		pcVar4 = aeFilename;
		if (uVar8 == 0) break;
		uVar8 -= 1;
		pcVar4 = aeFilename + 1;
		cVar1 = *aeFilename;
		aeFilename = pcVar4;
	} while (cVar1 != '\0');
	uVar8 = ~uVar8;
	puVar11 = (undefined4 *)(pcVar4 + -uVar8);
	puVar15 = (undefined4 *)buff2;
	for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 -= 1) {
		*puVar15 = *puVar11;
		puVar11 = puVar11 + 1;
		puVar15 = puVar15 + 1;
	}
	for (uVar8 &= 3; uVar8 != 0; uVar8 -= 1) {
		*(undefined *)puVar15 = *(undefined *)puVar11;
		puVar11 = (undefined4 *)((int)puVar11 + 1);
		puVar15 = (undefined4 *)((int)puVar15 + 1);
	}
	iVar7 = util::Util_Tokenise(buff2,&pcStack4560,",");
	pCVar3 = Container_Load(resRoot,pcStack4560,"ACT",TRUE);
	vehicle->contAct_1 = pCVar3;
	if (pCVar3 != NULL) {
		if (iVar7 == 2) {
			pCVar3 = Container_Load(pCVar3,pcStack4556,"ACT",TRUE);
			vehicle->contAct_2 = pCVar3;
		}
		else {
			vehicle->contAct_2 = NULL;
		}
		uVar8 = 0xffffffff;
		pcVar4 = pcStack4560;
		do {
			pcVar14 = pcVar4;
			if (uVar8 == 0) break;
			uVar8 -= 1;
			pcVar14 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar14;
		} while (cVar1 != '\0');
		uVar8 = ~uVar8;
		puVar11 = (undefined4 *)(pcVar14 + -uVar8);
		puVar15 = auStack4096;
		for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 -= 1) {
			*puVar15 = *puVar11;
			puVar11 = puVar11 + 1;
			puVar15 = puVar15 + 1;
		}
		for (uVar8 &= 3; uVar8 != 0; uVar8 -= 1) {
			*(undefined *)puVar15 = *(undefined *)puVar11;
			puVar11 = (undefined4 *)((int)puVar11 + 1);
			puVar15 = (undefined4 *)((int)puVar15 + 1);
		}
		uVar8 = util::Util_Tokenise((char *)auStack4096,&pcStack4496,"\\");
		if (1 < uVar8) {
			piVar10 = aiStack4492;
			iVar7 = uVar8 - 1;
			do {
				iVar2 = *piVar10;
				piVar10 = piVar10 + 1;
				iVar7 += -1;
				*(undefined *)(iVar2 + -1) = '\\';
			} while (iVar7 != 0);
		}
		std::sprintf(acStack3072,"%s\\%s.%s",(char *)auStack4096,(char *)(&DStack4520.max.z)[uVar8],"ae"
								);
		prop = cfg::CFG_Open(acStack3072);
		if (prop != NULL) {
			pcVar4 = cfg::CFG_JoinPath(rootName,"CameraNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->CameraNullName = pcVar4;
			if (pcVar4 == NULL) {
				vehicle->CameraNullFrames = 0;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 == NULL) {
					pcVar4 = ____EMPTYSTR__;
				}
				else {
					pcVar4 = cfg::CFG_JoinPath(rootName,"CameraNullFrames",0);
					pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				}
				uVar8 = std::atoi(pcVar4);
				vehicle->CameraNullFrames = uVar8;
				pcVar4 = cfg::CFG_JoinPath(rootName,"CameraFlipDir",0);
				BVar5 = cfg::CFG_ReadBool(prop,pcVar4);
				vehicle->CameraFlipDir = BVar5;
			}
			pcVar4 = cfg::CFG_JoinPath(rootName,"CarryNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->CarryNullName = pcVar4;
			if (pcVar4 == NULL) {
				vehicle->CarryNullFrames = 0;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"CarryNullFrames",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 == NULL) {
					uVar8 = std::atoi(____EMPTYSTR__);
					vehicle->CarryNullFrames = uVar8;
				}
				else {
					pcVar4 = cfg::CFG_JoinPath(rootName,"CarryNullFrames",0);
					pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
					uVar8 = std::atoi(pcVar4);
					vehicle->CarryNullFrames = uVar8;
				}
			}
			pcVar4 = cfg::CFG_JoinPath(rootName,"DrillNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->DrillNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"DepositNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->DepositNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"DriverNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->DriverNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"FireNullName",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->FireNullName = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"yPivot",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->yPivot = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"xPivot",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			vehicle->xPivot = pcVar4;
			pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
			pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
			if (pcVar4 == NULL) {
				vehicle->PivotMaxZ = 1.0;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 == NULL) {
					fVar16 = std::atof(____EMPTYSTR__);
					vehicle->PivotMaxZ = (float)fVar16;
				}
				else {
					pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMaxZ",0);
					pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
					fVar16 = std::atof(pcVar4);
					vehicle->PivotMaxZ = (float)fVar16;
				}
			}
			pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
			pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
			if (pcVar4 == NULL) {
				vehicle->PivotMinZ = -1.0;
			}
			else {
				pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
				pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
				if (pcVar4 == NULL) {
					fVar16 = std::atof(____EMPTYSTR__);
					vehicle->PivotMinZ = (float)fVar16;
				}
				else {
					pcVar4 = cfg::CFG_JoinPath(rootName,"PivotMinZ",0);
					pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
					fVar16 = std::atof(pcVar4);
					vehicle->PivotMinZ = (float)fVar16;
				}
			}
			Upgrade_LoadUpgradeLevels(&vehicle->upgrades,prop,rootName);
			pcVar4 = cfg::CFG_JoinPath(rootName,"WheelMesh",0);
			pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
			if (pcVar4 != NULL) {
				std::sprintf(buff1,"%s\\%s",(char *)auStack4096,pcVar4);
				std::free(pcVar4);
				pcVar4 = cfg::CFG_JoinPath(rootName,"WheelNullName",0);
				pcVar4 = cfg::CFG_CopyString(prop,pcVar4);
				vehicle->WheelNullName = pcVar4;
				if (pcVar4 != NULL) {
					ppCVar13 = vehicle->WheelMeshes;
					for (iVar7 = 6; iVar7 != 0; iVar7 += -1) {
						*ppCVar13 = NULL;
						ppCVar13 = ppCVar13 + 1;
					}
					pCVar3 = Container_Load(vehicle->contAct_1,buff1,"LWO",0);
					vehicle->WheelMeshes[0] = pCVar3;
					vehicle->numWheelNulls = 1;
					puVar11 = vehicle->wheel_fields_28;
					for (iVar7 = 6; iVar7 != 0; iVar7 += -1) {
						*puVar11 = 0;
						puVar11 = puVar11 + 1;
					}
					if (vehicle->WheelMeshes[0] == NULL) {
						vehicle->WheelRadius = 0.0;
						vehicle->WheelMeshes[1] = NULL;
						vehicle->WheelMeshes[2] = NULL;
						vehicle->WheelMeshes[3] = NULL;
						vehicle->WheelMeshes[4] = NULL;
						vehicle->WheelMeshes[5] = NULL;
					}
					else {
						pcVar4 = cfg::CFG_JoinPath(rootName,"WheelRadius",0);
						pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
						if (pcVar4 == NULL) {
							pcVar4 = ____EMPTYSTR__;
						}
						else {
							pcVar4 = cfg::CFG_JoinPath(rootName,"WheelRadius",0);
							pcVar4 = cfg::CFG_ReadString(prop,pcVar4);
						}
						fVar16 = std::atof(pcVar4);
						vehicle->WheelRadius = (float)fVar16;
						if ((float)fVar16 == 0.0) {
							if (vehicle->WheelMeshes[0]->type == RESOURCE_MESH) {
								Container_Mesh_GetBox(vehicle->WheelMeshes[0],&DStack4520);
								vehicle->WheelRadius = (DStack4520.max.y - DStack4520.min.y) * 0.5;
								Container_Mesh_SetQuality(vehicle->WheelMeshes[0],D3DRMGROUP_0,QUALITY_GOURAUD);
							}
							else {
								vehicle->WheelRadius = 3.0;
							}
						}
					}
					pPVar6 = Res_LoadPolyMesh(prop,rootName,pcStack4560,POLY_MEDIUM,1);
					vehicle->polyMedium_1 = pPVar6;
					if (vehicle->contAct_2 != NULL) {
						uVar8 = 0xffffffff;
						pcVar4 = pcStack4556;
						do {
							pcVar14 = pcVar4;
							if (uVar8 == 0) break;
							uVar8 -= 1;
							pcVar14 = pcVar4 + 1;
							cVar1 = *pcVar4;
							pcVar4 = pcVar14;
						} while (cVar1 != '\0');
						uVar8 = ~uVar8;
						puVar11 = (undefined4 *)(pcVar14 + -uVar8);
						puVar15 = auStack4096;
						for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 -= 1) {
							*puVar15 = *puVar11;
							puVar11 = puVar11 + 1;
							puVar15 = puVar15 + 1;
						}
						for (uVar8 &= 3; uVar8 != 0; uVar8 -= 1) {
							*(undefined *)puVar15 = *(undefined *)puVar11;
							puVar11 = (undefined4 *)((int)puVar11 + 1);
							puVar15 = (undefined4 *)((int)puVar15 + 1);
						}
						uVar8 = util::Util_Tokenise((char *)auStack4096,&pcStack4496,"\\");
						if (1 < uVar8) {
							piVar10 = aiStack4492;
							iVar7 = uVar8 - 1;
							do {
								iVar2 = *piVar10;
								piVar10 = piVar10 + 1;
								iVar7 += -1;
								*(undefined *)(iVar2 + -1) = '\\';
							} while (iVar7 != 0);
						}
						std::sprintf(acStack3072,"%s\\%s.%s",(char *)auStack4096,
												 (char *)(&DStack4520.max.z)[uVar8],"ae");
						aeRoot = cfg::CFG_Open(acStack3072);
						if (aeRoot != NULL) {
							pPVar6 = Res_LoadPolyMesh(aeRoot,rootName,pcStack4556,POLY_MEDIUM,1);
							vehicle->polyMedium_2 = pPVar6;
						}
					}
					vehicle->flags = 1;
					pcVar4 = cfg::CFG_JoinPath(rootName,"HoldMissing",0);
					BVar5 = cfg::CFG_ReadBool(prop,pcVar4);
					if (BVar5 == BOOL3_TRUE) {
						vehicle->flags = vehicle->flags | 8;
					}
					vehicle->field_60 = 0;
					vehicle->field_5c = 0;
					vehicle->float_64 = -1.0;
					vehicle->objIndex = objIndex;
					cfg::CFG_Close(prop);
					return TRUE;
				}
			}
			cfg::CFG_Close(prop);
		}
	}
	return 0;
}



void __cdecl lego::res::Vehicle_Destroy(VehicleData *vehicle)
{
	int iVar1;
	Container **ppCVar2;
	
	Vehicle_ChangeUpgradeParts(vehicle,-1);
	if ((*(byte *)&vehicle->flags & 1) != 0) {
		if (vehicle->CameraNullName != NULL) {
			std::free(vehicle->CameraNullName);
		}
		if (vehicle->WheelNullName != NULL) {
			std::free(vehicle->WheelNullName);
		}
		if (vehicle->DrillNullName != NULL) {
			std::free(vehicle->DrillNullName);
		}
		if (vehicle->FireNullName != NULL) {
			std::free(vehicle->FireNullName);
		}
	}
	ppCVar2 = (Container **)vehicle->wheel_fields_28;
	iVar1 = 6;
	do {
		if (ppCVar2[-6] != NULL) {
			Container_Remove(ppCVar2[-6]);
		}
		if (*ppCVar2 != NULL) {
			Container_Remove(*ppCVar2);
		}
		ppCVar2 = ppCVar2 + 1;
		iVar1 += -1;
	} while (iVar1 != 0);
	Container_Remove(vehicle->contAct_1);
	if (vehicle->contAct_2 != NULL) {
		Container_Remove(vehicle->contAct_2);
	}
	return;
}



void __cdecl lego::res::Vehicle_SwapPolyMedium(VehicleData *vehicle,BOOL swap)
{
	MeshPoly_Container_SwapFrame(vehicle->polyMedium_1,vehicle->contAct_1,(uint)(swap == 0),0);
	if ((vehicle->contAct_2 != NULL) && (vehicle->polyMedium_2 != NULL)) {
		MeshPoly_Container_SwapFrame(vehicle->polyMedium_2,vehicle->contAct_2,(uint)(swap == 0),0);
	}
	return;
}



// There's no stored HighPoly data, this just calls `Vehicle_SwapPolyMedium`

void __cdecl lego::res::Vehicle_SwapPolyHigh(VehicleData *vehicle,BOOL swap)
{
	Vehicle_SwapPolyMedium(vehicle,swap);
	return;
}



BOOL __cdecl lego::res::Vehicle_FUN_0046d200(VehicleData *vehicle,int levelBit,BOOL condition)
{
	uint uVar1;
	uint uVar2;
	
	uVar2 = 1 << ((byte)levelBit & 0x1f);
	if (condition != 0) {
		uVar1 = game::Vehicle_GetUpgradesCurrentLevel(vehicle);
		if ((uVar2 & uVar1) != 0) {
			return 0;
		}
	}
	return (vehicle->upgrades).levelsMask & uVar2;
}



int __cdecl lego::game::Vehicle_GetUpgradesCurrentLevel(VehicleData *vehicle)
{
	return (vehicle->upgrades).currentLevel;
}



void __cdecl lego::res::Vehicle_ChangeUpgradeParts(VehicleData *vehicle,int objLevel)
{
	Upgrade_ChangeUpgradeParts(&vehicle->upgrades,objLevel);
	Vehicle_UnkUpgrades(vehicle,NULL);
	return;
}



void __cdecl lego::res::Vehicle_FUN_0046d280(VehicleData *vehicle,BOOL param_2)
{
	Container **ppCVar1;
	int iVar2;
	
	ppCVar1 = vehicle->WheelMeshes;
	iVar2 = 6;
	do {
		if (*ppCVar1 != NULL) {
			Container_Hide(*ppCVar1,param_2);
		}
		ppCVar1 = ppCVar1 + 1;
		iVar2 += -1;
	} while (iVar2 != 0);
	return;
}



BOOL __cdecl lego::res::Vehicle_Duplicate(VehicleData *in_vehicle,VehicleData *out_vehicle)
{
	Container *pCVar1;
	PolyMeshData *pPVar2;
	int iVar3;
	VehicleData *pVVar4;
	Container **ppCVar5;
	VehicleData *pVVar6;
	uint uVar7;
	
	pVVar4 = in_vehicle;
	pVVar6 = out_vehicle;
	for (iVar3 = 0x7b; iVar3 != 0; iVar3 += -1) {
		pVVar6->objIndex = pVVar4->objIndex;
		pVVar4 = (VehicleData *)&pVVar4->WheelNullName;
		pVVar6 = (VehicleData *)&pVVar6->WheelNullName;
	}
	out_vehicle->flags = out_vehicle->flags & 0xfffffffe;
	pCVar1 = Container_Clone(in_vehicle->contAct_1);
	out_vehicle->contAct_1 = pCVar1;
	if (pCVar1 != NULL) {
		if (in_vehicle->contAct_2 != NULL) {
			pCVar1 = Container_Clone(in_vehicle->contAct_2);
			out_vehicle->contAct_2 = pCVar1;
			Container_SetParent(pCVar1,out_vehicle->contAct_1);
			Container_SetPosition(out_vehicle->contAct_2,out_vehicle->contAct_1,0.0,0.0,0.0);
			Container_SetOrientation
								(out_vehicle->contAct_2,out_vehicle->contAct_1,0.0,0.0,1.0,0.0,1.0,0.0);
			Container_SetPerspectiveCorrection(out_vehicle->contAct_2,1);
		}
		pPVar2 = MeshPoly_Duplicate(in_vehicle->polyMedium_1);
		out_vehicle->polyMedium_1 = pPVar2;
		if (in_vehicle->polyMedium_2 != NULL) {
			pPVar2 = MeshPoly_Duplicate(in_vehicle->polyMedium_2);
			out_vehicle->polyMedium_2 = pPVar2;
		}
		Container_SetPerspectiveCorrection(out_vehicle->contAct_1,1);
		Vehicle_Wheels_FUN_0046d520(out_vehicle);
		if ((in_vehicle->WheelMeshes[0] != NULL) && (uVar7 = 0, out_vehicle->numWheelNulls != 0)) {
			ppCVar5 = out_vehicle->WheelMeshes;
			do {
				pCVar1 = Container_Clone(in_vehicle->WheelMeshes[0]);
				*ppCVar5 = pCVar1;
				if (pCVar1 != NULL) {
					Container_SetParent(pCVar1,out_vehicle->contAct_1);
					Container_SetPerspectiveCorrection(*ppCVar5,1);
				}
				uVar7 += 1;
				ppCVar5 = ppCVar5 + 1;
			} while (uVar7 < out_vehicle->numWheelNulls);
		}
		return 1;
	}
	return 0;
}



void __cdecl lego::res::Vehicle_SetOwnerObject(VehicleData *vehicle,void *liveObj)
{
	Container **ppCVar1;
	uint uVar2;
	
	Container_SetUserData(vehicle->contAct_1,liveObj);
	if (vehicle->contAct_2 != NULL) {
		Container_SetUserData(vehicle->contAct_2,liveObj);
	}
	uVar2 = 0;
	if (vehicle->numWheelNulls != 0) {
		ppCVar1 = vehicle->WheelMeshes;
		do {
			if (*ppCVar1 != NULL) {
				Container_SetUserData(*ppCVar1,liveObj);
			}
			uVar2 += 1;
			ppCVar1 = ppCVar1 + 1;
		} while (uVar2 < vehicle->numWheelNulls);
	}
	return;
}



float10 __cdecl lego::res::Vehicle_GetAnimFloat10(VehicleData *vehicle)
{
	float10 fVar1;
	
	fVar1 = Container_GetAnimationTime(vehicle->contAct_1);
	return fVar1;
}



float10 __cdecl
lego::res::Vehicle_FUN_0046d480(VehicleData *vehicle,float elapsed,float elapsed2,uint param_4)
{
	float fVar1;
	uint uVar2;
	float10 fVar3;
	
	if ((*(byte *)&vehicle->flags & 4) == 0) {
		fVar3 = Container_MoveAnimation(vehicle->contAct_1,elapsed);
	}
	else {
		fVar3 = (float10)0.0;
	}
	if (vehicle->contAct_2 != NULL) {
		fVar3 = Container_MoveAnimation(vehicle->contAct_2,elapsed2);
	}
	fVar1 = (float)fVar3;
	if ((1 < param_4) && (fVar1 != 0.0)) {
		uVar2 = Container_GetAnimationFrames(vehicle->contAct_1);
		return (float10)fVar1 - (float10)(ulonglong)(uVar2 * (param_4 - 1));
	}
	return (float10)fVar1;
}



void __cdecl lego::res::Vehicle_Wheels_FUN_0046d520(VehicleData *vehicle)
{
	VehicleData *pVVar1;
	char *name;
	Container *pCVar2;
	
	pVVar1 = vehicle;
	vehicle = NULL;
	pVVar1->numWheelNulls = 0;
	do {
		name = Container_FormatPartName(pVVar1->contAct_1,pVVar1->WheelNullName,(int *)&vehicle);
		pCVar2 = Container_SearchTree(pVVar1->contAct_1,name,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
		pVVar1->wheel_fields_28[(int)vehicle] = pCVar2;
		if (pVVar1->wheel_fields_28[(int)vehicle] != 0) {
			pVVar1->numWheelNulls = pVVar1->numWheelNulls + 1;
		}
		vehicle = (VehicleData *)((int)&vehicle->objIndex + 1);
	} while (vehicle < (VehicleData *)0x6);
	return;
}



void __cdecl lego::res::Vehicle_HideAll(VehicleData *vehicle,BOOL hide)
{
	Container **ppCVar1;
	uint uVar2;
	
	if (hide == 0) {
		uVar2 = vehicle->flags & 0xfffffffd;
	}
	else {
		uVar2 = vehicle->flags | 2;
	}
	vehicle->flags = uVar2;
	Container_Hide(vehicle->contAct_1,hide);
	if (vehicle->contAct_2 != NULL) {
		Container_Hide(vehicle->contAct_2,hide);
	}
	uVar2 = 0;
	if (vehicle->numWheelNulls != 0) {
		ppCVar1 = vehicle->WheelMeshes;
		do {
			if (*ppCVar1 != NULL) {
				Container_Hide(*ppCVar1,hide);
			}
			uVar2 += 1;
			ppCVar1 = ppCVar1 + 1;
		} while (uVar2 < vehicle->numWheelNulls);
	}
	return;
}



BOOL __cdecl lego::res::Vehicle_GetFlag2(VehicleData *vehicle)
{
	return (vehicle->flags & 0xff) >> 1 & 1;
}



void __cdecl lego::res::Vehicle_SetOrientation(VehicleData *vehicle,float x,float y,float z)
{
	Container_SetOrientation(vehicle->contAct_1,NULL,x,y,z,0.0,0.0,-1.0);
	return;
}



void __cdecl
lego::res::Vehicle_SetPosition
					(VehicleData *vehicle,float x,float y,GetSurfaceZCallback *getZcallback,
					SurfaceMap *surfMap)
{
	float fVar1;
	int iVar2;
	uint uVar3;
	Container **ppCVar4;
	float *pfVar5;
	Vector3F *pVVar6;
	float10 fVar7;
	Vector3F local_a4;
	float local_98;
	float local_94;
	float local_90;
	float local_8c;
	Vector3F local_88;
	float local_7c;
	float local_78;
	float local_74;
	Vector3F local_70;
	Vector3F local_64;
	uint local_58;
	Vector3F local_54;
	float local_48;
	float local_44;
	float local_40;
	float local_3c;
	float local_38;
	float local_34;
	float local_30;
	float local_2c;
	float local_28;
	Vector3F local_c;
	
	fVar7 = (*getZcallback)(x,y,surfMap);
	Container_SetPosition(vehicle->contAct_1,NULL,x,y,(float)fVar7);
	Container_GetOrientation(vehicle->contAct_1,NULL,&local_88,&local_c);
	Container_SetOrientation(vehicle->contAct_1,NULL,local_88.x,local_88.y,local_88.z,0.0,0.0,-1.0);
	if (vehicle->numWheelNulls != 0) {
		uVar3 = 0;
		if (vehicle->numWheelNulls != 0) {
			pVVar6 = &local_54;
			ppCVar4 = (Container **)vehicle->wheel_fields_28;
			do {
				Container_GetPosition(*ppCVar4,NULL,pVVar6);
				fVar7 = (*getZcallback)(pVVar6->x,pVVar6->y,surfMap);
				pVVar6->z = (float)fVar7;
				uVar3 += 1;
				ppCVar4 = ppCVar4 + 1;
				pVVar6 = pVVar6 + 1;
			} while (uVar3 < vehicle->numWheelNulls);
		}
		local_98 = local_48 - local_3c;
		local_94 = local_44 - local_38;
		local_90 = local_40 - local_34;
		local_7c = local_48 - local_54.x;
		local_78 = local_44 - local_54.y;
		local_74 = local_40 - local_54.z;
		local_70.x = local_90 * local_78 - local_94 * local_74;
		local_70.y = local_98 * local_74 - local_90 * local_7c;
		local_70.z = local_94 * local_7c - local_98 * local_78;
		math::Maths_Vector3DScale
							(&local_70,&local_70,
							 1.0 / SQRT(local_70.z * local_70.z +
													local_70.y * local_70.y + local_70.x * local_70.x));
		local_7c = local_30 - local_3c;
		local_78 = local_2c - local_38;
		local_74 = local_28 - local_34;
		local_98 = local_30 - local_54.x;
		local_94 = local_2c - local_54.y;
		local_64.x = (local_28 - local_54.z) * local_78 - local_94 * local_74;
		local_64.y = local_98 * local_74 - (local_28 - local_54.z) * local_7c;
		local_64.z = local_94 * local_7c - local_98 * local_78;
		math::Maths_Vector3DScale
							(&local_64,&local_64,
							 1.0 / SQRT(local_64.z * local_64.z +
													local_64.y * local_64.y + local_64.x * local_64.x));
		local_a4.x = local_64.x + local_70.x;
		local_a4.y = local_64.y + local_70.y;
		local_a4.z = local_64.z + local_70.z;
		math::Maths_Vector3DScale
							(&local_a4,&local_a4,
							 1.0 / SQRT(local_a4.z * local_a4.z +
													local_a4.y * local_a4.y + local_a4.x * local_a4.x));
		pfVar5 = (float *)&vehicle->field_5c;
		iVar2 = std::_finite((double)(float)vehicle->field_5c);
		if (((iVar2 == 0) || (iVar2 = std::_finite((double)(float)vehicle->field_60), iVar2 == 0)) ||
			 (iVar2 = std::_finite((double)(float)vehicle->field_60), iVar2 == 0)) {
			*pfVar5 = local_a4.x;
			vehicle->field_60 = local_a4.y;
			vehicle->float_64 = local_a4.z;
		}
		local_a4.x = *pfVar5 * 0.4 + local_a4.x;
		local_a4.y = (float)vehicle->field_60 * 0.4 + local_a4.y;
		local_a4.z = vehicle->float_64 * 0.4 + local_a4.z;
		local_8c = 1.0 / SQRT(local_a4.z * local_a4.z +
													local_a4.y * local_a4.y + local_a4.x * local_a4.x);
		local_a4.x = local_8c * local_a4.x;
		local_a4.y = local_8c * local_a4.y;
		local_a4.z = local_8c * local_a4.z;
		fVar1 = local_88.z * local_a4.z + local_88.y * local_a4.y + local_88.x * local_a4.x;
		*pfVar5 = local_a4.x;
		local_88.x = local_88.x - fVar1 * local_a4.x;
		local_88.y = local_88.y - fVar1 * local_a4.y;
		local_88.z = local_88.z - fVar1 * local_a4.z;
		vehicle->field_60 = local_a4.y;
		vehicle->float_64 = local_a4.z;
		Container_SetOrientation
							(vehicle->contAct_1,NULL,local_88.x,local_88.y,local_88.z,-local_a4.x,-local_a4.y,
							 -local_a4.z);
		uVar3 = 0;
		if (vehicle->numWheelNulls != 0) {
			pVVar6 = &local_54;
			ppCVar4 = (Container **)vehicle->wheel_fields_28;
			do {
				Container_GetPosition(*ppCVar4,NULL,pVVar6);
				fVar7 = (*getZcallback)(pVVar6->x,pVVar6->y,surfMap);
				Container_AddTranslation
									(*ppCVar4,D3DRMCOMBINE_AFTER,0.0,
									 (float)-((fVar7 - (float10)pVVar6->z) - (float10)vehicle->WheelRadius),0.0);
				uVar3 += 1;
				ppCVar4 = ppCVar4 + 1;
				pVVar6 = pVVar6 + 1;
			} while (uVar3 < vehicle->numWheelNulls);
		}
		uVar3 = 0;
		if (vehicle->numWheelNulls != 0) {
			ppCVar4 = vehicle->WheelMeshes;
			do {
				if (*ppCVar4 != NULL) {
					Container_SetPosition(*ppCVar4,ppCVar4[6],0.0,0.0,0.0);
				}
				uVar3 += 1;
				ppCVar4 = ppCVar4 + 1;
			} while (uVar3 < vehicle->numWheelNulls);
		}
		local_58 = 0;
		if (vehicle->numWheelNulls != 0) {
			pVVar6 = &local_54;
			ppCVar4 = vehicle->WheelMeshes;
			pfVar5 = (float *)&vehicle->field_0x74;
			do {
				if (*ppCVar4 != NULL) {
					Container_GetPosition(*ppCVar4,NULL,pVVar6);
					local_98 = pVVar6->x - pfVar5[-2];
					local_94 = pVVar6->y - pfVar5[-1];
					local_90 = pVVar6->z - *pfVar5;
					local_8c = SQRT(local_90 * local_90 + local_94 * local_94 + local_98 * local_98) /
										 vehicle->WheelRadius;
					if (local_90 * local_88.z + local_94 * local_88.y + local_98 * local_88.x < 0.0) {
						local_8c = -local_8c;
					}
					Container_AddRotation(*ppCVar4,D3DRMCOMBINE_BEFORE,1.0,0.0,0.0,local_8c);
				}
				local_58 += 1;
				ppCVar4 = ppCVar4 + 1;
				pfVar5 = pfVar5 + 3;
				pVVar6 = pVVar6 + 1;
			} while (local_58 < vehicle->numWheelNulls);
		}
		uVar3 = 0;
		if (vehicle->numWheelNulls != 0) {
			ppCVar4 = vehicle->WheelMeshes;
			pVVar6 = (Vector3F *)&vehicle->field_0x6c;
			do {
				if (*ppCVar4 != NULL) {
					Container_GetPosition(*ppCVar4,NULL,pVVar6);
				}
				uVar3 += 1;
				pVVar6 = pVVar6 + 1;
				ppCVar4 = ppCVar4 + 1;
			} while (uVar3 < vehicle->numWheelNulls);
		}
		return;
	}
	return;
}



Container * __cdecl lego::res::Vehicle_GetAEResource(VehicleData *vehicle)
{
	return vehicle->contAct_1;
}



Container * __cdecl lego::res::Vehicle_GetNull(VehicleData *vehicle,char *nullName,int nullIndex)
{
	Container *pCVar1;
	char *pcVar2;
	
	pCVar1 = NULL;
	if (vehicle->contAct_2 != NULL) {
		pcVar2 = Container_FormatPartName(vehicle->contAct_2,nullName,&nullIndex);
		pCVar1 = Container_SearchTree(vehicle->contAct_2,pcVar2,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
	}
	if (pCVar1 == NULL) {
		pcVar2 = Container_FormatPartName(vehicle->contAct_1,nullName,&nullIndex);
		pCVar1 = Container_SearchTree(vehicle->contAct_1,pcVar2,CONTAINER_SEARCHMODE_FIRSTMATCH,NULL);
	}
	return pCVar1;
}



Container * __cdecl lego::res::Vehicle_GetCameraNull(VehicleData *vehicle,int cameraIndex)
{
	Container *pCVar1;
	
	if (vehicle->CameraNullName == NULL) {
		return NULL;
	}
	if (vehicle->cameraFramesTable_10c[cameraIndex] != NULL) {
		return vehicle->cameraFramesTable_10c[cameraIndex];
	}
	pCVar1 = Vehicle_GetNull(vehicle,vehicle->CameraNullName,cameraIndex);
	vehicle->cameraFramesTable_10c[cameraIndex] = pCVar1;
	return pCVar1;
}



Container * __cdecl lego::res::Vehicle_GetDrillNull(VehicleData *vehicle)
{
	Container *pCVar1;
	
	if (vehicle->DrillNullName == NULL) {
		pCVar1 = NULL;
	}
	else {
		pCVar1 = (Container *)vehicle->field_cc;
		if (pCVar1 == NULL) {
			pCVar1 = Vehicle_GetNull(vehicle,vehicle->DrillNullName,0);
			vehicle->field_cc = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Vehicle_GetDepositNull(VehicleData *vehicle)
{
	Container *pCVar1;
	
	if (vehicle->DepositNullName == NULL) {
		pCVar1 = NULL;
	}
	else {
		pCVar1 = (Container *)vehicle->field_d0;
		if (pCVar1 == NULL) {
			pCVar1 = Vehicle_GetNull(vehicle,vehicle->DepositNullName,0);
			vehicle->field_d0 = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Vehicle_GetDriverNull(VehicleData *vehicle)
{
	Container *pCVar1;
	
	if (vehicle->DriverNullName == NULL) {
		pCVar1 = NULL;
	}
	else {
		pCVar1 = vehicle->resData_d4;
		if (pCVar1 == NULL) {
			pCVar1 = Vehicle_GetNull(vehicle,vehicle->DriverNullName,0);
			vehicle->resData_d4 = pCVar1;
			return pCVar1;
		}
	}
	return pCVar1;
}



Container * __cdecl lego::res::Vehicle_GetCarryNull(VehicleData *vehicle,int carryIndex)
{
	Container *pCVar1;
	
	if (vehicle->CarryNullName == NULL) {
		return NULL;
	}
	if (vehicle->carryFramesTable_e4[carryIndex] != NULL) {
		return vehicle->carryFramesTable_e4[carryIndex];
	}
	pCVar1 = Vehicle_GetNull(vehicle,vehicle->CarryNullName,carryIndex);
	vehicle->carryFramesTable_e4[carryIndex] = pCVar1;
	return pCVar1;
}



int __cdecl lego::res::Vehicle_GetCarryNullFrames(VehicleData *vehicle)
{
	return vehicle->CarryNullFrames;
}



float10 __cdecl lego::res::Vehicle_GetTransCoef(VehicleData *vehicle)
{
	float10 fVar1;
	
	fVar1 = Container_GetTransCoef(vehicle->contAct_1);
	return fVar1;
}



void __cdecl lego::game::LevelStruct428_Load_FUN_0046de50(Container *resRoot,LevelData *level)
{
	Struct_428 *pSVar1;
	Struct_428 *pSVar2;
	uint uVar3;
	int iVar4;
	uint *puVar5;
	uint uVar6;
	uint uVar7;
	Struct_428 **ppSVar8;
	uint uVar9;
	Struct_428 *pSVar10;
	uint unkParam_x;
	Point2F *pPVar11;
	uint local_4;
	
	uVar7 = 0;
	Struct_428_COUNT_0054ceb0 = 0;
	PairStruct_428_COUNT_0054cf04 = 0;
	globals::g_LevelUnk_DigDepth = level->DigDepth;
	if ((level->dimensions).height != 0) {
		do {
			uVar9 = 0;
			unkParam_x = 0;
			uVar6 = 0;
			uVar3 = (level->dimensions).width;
			if (uVar3 != 0) {
				do {
					if (level->blocks[uVar7 * uVar3 + uVar6].terrain == TERRAIN_WATER_unused) {
						if (unkParam_x == uVar9) {
							unkParam_x = uVar6;
						}
						uVar9 = uVar6 + 1;
					}
					else {
						if (unkParam_x != uVar9) {
							pSVar2 = LevelStruct428_LoadSearchStruct428(uVar7,unkParam_x,uVar9);
							if (pSVar2 == NULL) {
								LevelStruct428_LoadAddFirstStruct428(uVar7,unkParam_x,uVar9);
							}
							else {
								LevelStruct428_LoadAddStruct428(pSVar2,uVar7,unkParam_x,uVar9);
							}
						}
						uVar9 = 0;
						unkParam_x = 0;
					}
					uVar3 = (level->dimensions).width;
					uVar6 += 1;
				} while (uVar6 < uVar3);
			}
			uVar7 += 1;
		} while (uVar7 < (uint)(level->dimensions).height);
	}
	local_4 = 0;
	if (PairStruct_428_COUNT_0054cf04 != 0) {
		ppSVar8 = &PairStruct_428_ARRAY_0054ceb4[0].second;
		do {
			pSVar2 = *ppSVar8;
			pSVar1 = ppSVar8[-1];
			if (pSVar2->pointsCount != 0) {
				pSVar10 = pSVar2;
				pPVar11 = pSVar1->points + pSVar1->pointsCount;
				for (uVar7 = (pSVar2->pointsCount << 3) >> 2; uVar7 != 0; uVar7 -= 1) {
					pPVar11->x = pSVar10->points[0].x;
					pSVar10 = (Struct_428 *)&pSVar10->points[0].y;
					pPVar11 = (Point2F *)(&pPVar11->x + 1);
				}
				for (iVar4 = 0; iVar4 != 0; iVar4 += -1) {
					*(undefined *)&pPVar11->x = *(undefined *)&pSVar10->points[0].x;
					pSVar10 = (Struct_428 *)((int)&pSVar10->points[0].x + 1);
					pPVar11 = (Point2F *)((int)&pPVar11->x + 1);
				}
				pSVar1->pointsCount = pSVar1->pointsCount + pSVar2->pointsCount;
				pSVar2->pointsCount = 0;
			}
			local_4 += 1;
			ppSVar8 = ppSVar8 + 2;
		} while (local_4 < PairStruct_428_COUNT_0054cf04);
	}
	std::qsort(Struct_428_ARRAY_0054a520,Struct_428_COUNT_0054ceb0,0x428,LevelStruct428_CompareCount);
	uVar7 = 0;
	if (Struct_428_COUNT_0054ceb0 != 0) {
		puVar5 = &Struct_428_ARRAY_0054a520[0].pointsCount;
		uVar9 = Struct_428_COUNT_0054ceb0;
		do {
			if (*puVar5 == 0) {
				uVar9 = uVar7;
				Struct_428_COUNT_0054ceb0 = uVar7;
			}
			uVar7 += 1;
			puVar5 = puVar5 + 0x10a;
		} while (uVar7 < uVar9);
	}
	LevelStruct428_InitSub_Pass1_FUN_0046dfd0(resRoot,level);
	LevelStruct428_InitSub_Pass1_FUN_0046e140(resRoot,level);
	return;
}



void __cdecl
lego::game::LevelStruct428_InitSub_Pass1_FUN_0046dfd0(Container *resData,LevelData *level)
{
	TerrainType TVar1;
	int iVar2;
	int iVar3;
	int iVar4;
	uint uVar5;
	float *pfVar6;
	longlong lVar7;
	Point2F *local_30;
	uint local_2c;
	uint *local_28;
	uint index;
	Point2F DIRECTIONS [4];
	
	DIRECTIONS[0].x = 0.0;
	DIRECTIONS[0].y = -1.0;
	DIRECTIONS[1].x = 1.0;
	DIRECTIONS[1].y = 0.0;
	DIRECTIONS[2].x = 0.0;
	DIRECTIONS[2].y = 1.0;
	DIRECTIONS[3].x = -1.0;
	DIRECTIONS[3].y = 0.0;
	index = 0;
	if (Struct_428_COUNT_0054ceb0 != 0) {
		local_28 = &Struct_428_ARRAY_0054a520[0].pointsCount;
		do {
			local_30 = (Point2F *)(local_28 + -200);
			local_28[0x3d] = 0;
			local_2c = 0;
			if (*local_28 != 0) {
				do {
					uVar5 = 0;
					pfVar6 = &DIRECTIONS[0].y;
					do {
						lVar7 = __ftol((float10)pfVar6[-1] + (float10)local_30->x);
						iVar3 = (int)lVar7;
						lVar7 = __ftol((float10)local_30->y + (float10)*pfVar6);
						iVar4 = (int)lVar7;
						if ((((-1 < iVar3) && (iVar2 = (level->dimensions).width, iVar3 < iVar2)) &&
								(-1 < iVar4)) &&
							 (((iVar4 < (level->dimensions).height &&
								 (TVar1 = level->blocks[iVar4 * iVar2 + iVar3].terrain,
								 TVar1 != TERRAIN_WATER_unused)) && (TVar1 != TERRAIN_IMMOVABLE)))) {
							local_28[local_28[0x3d] * 6 + 1] = local_2c;
							local_28[local_28[0x3d] * 6 + 2] = uVar5;
							local_28[0x3d] = local_28[0x3d] + 1;
							break;
						}
						uVar5 += 1;
						pfVar6 = pfVar6 + 2;
					} while (uVar5 < 4);
					local_30 = local_30 + 1;
					local_2c += 1;
				} while (local_2c < *local_28);
			}
			index += 1;
			local_28 = local_28 + 0x10a;
		} while (index < Struct_428_COUNT_0054ceb0);
	}
	return;
}



void __cdecl
lego::game::LevelStruct428_InitSub_Pass1_FUN_0046e140(Container *in_resData,LevelData *level)
{
	int iVar1;
	float fVar2;
	uint uVar3;
	Container *cont;
	D3DRMGroupIndex groupID;
	float *pfVar4;
	uint uVar5;
	float *pfVar6;
	float *pfVar7;
	longlong lVar8;
	longlong lVar9;
	Vector3F *pVVar10;
	D3DRMGroupIndex local_138;
	D3DRMGroupIndex *local_134;
	float *local_130;
	int local_12c;
	uint local_128;
	float local_118 [4];
	float local_108 [4];
	uint local_f8;
	undefined4 local_f4;
	undefined4 local_f0;
	undefined4 local_ec;
	undefined4 local_e8;
	undefined4 local_e4;
	float local_e0 [5];
	undefined4 local_cc;
	undefined4 local_c8;
	undefined4 local_c4;
	Vector3F local_c0 [4];
	D3DRMVertex vertices [4];
	
	local_f4 = 1;
	local_ec = 1;
	local_e0[0] = 0.0;
	local_e0[1] = 0.0;
	local_e0[2] = 1.0;
	local_e0[3] = 0.0;
	local_e0[4] = 1.0;
	local_cc = 1065353216;
	local_c8 = 0;
	local_c4 = 1065353216;
	local_f8 = 0;
	local_f0 = 3;
	local_e8 = 2;
	local_e4 = 3;
	local_118[0] = 0.0;
	local_118[1] = 1.0;
	local_118[2] = 1.0;
	local_118[3] = 0.0;
	local_108[0] = 0.0;
	local_108[1] = 0.0;
	local_108[2] = 1.0;
	local_108[3] = 1.0;
	local_128 = 0;
	if (Struct_428_COUNT_0054ceb0 != 0) {
		local_134 = &Struct_428_ARRAY_0054a520[0].pointsCount;
		do {
			pfVar7 = (float *)(local_134 + -200);
										// -10000.0
			local_134[0x3e] = 0xc61c4000;
			local_138 = D3DRMGROUP_0;
			pfVar6 = pfVar7;
			if (*local_134 != D3DRMGROUP_0) {
				do {
					pVVar10 = local_c0;
					lVar8 = __ftol((float10)pfVar6[1]);
					uVar3 = (uint)lVar8;
					lVar8 = __ftol((float10)*pfVar6);
					Map3D_GetBlockVertexPositions(level->surfaceMap,(uint)lVar8,uVar3,pVVar10);
					local_130 = &local_c0[0].z;
					pfVar4 = local_e0;
					local_12c = 4;
					do {
						lVar8 = __ftol((float10)pfVar4[1] + (float10)pfVar6[1]);
						iVar1 = (level->dimensions).width;
						lVar9 = __ftol((float10)*pfVar6 + (float10)*pfVar4);
						if (level->blocks[(int)lVar8 * iVar1 + (int)lVar9].predug == PREDUG_WALL) {
							if ((ushort)((ushort)(*local_130 < (float)local_134[0x3e]) << 8 |
													(ushort)(*local_130 == (float)local_134[0x3e]) << 0xe) == 0) {
								local_134[0x3e] = (D3DRMGroupIndex)*local_130;
							}
						}
						else {
							local_134[0x41] = local_134[0x41] | 1;
						}
						pfVar4 = pfVar4 + 2;
						local_130 = local_130 + 3;
						local_12c += -1;
					} while (local_12c != 0);
					local_138 += 1;
					pfVar6 = pfVar6 + 2;
				} while (local_138 < *local_134);
			}
			local_134[0x3f] = local_134[0x3e];
			cont = res::Container_MakeMesh2(in_resData,CONTAINER_MESHTYPE_TRANSPARENT);
			local_134[0x40] = (D3DRMGroupIndex)cont;
			res::Container_Hide(cont,~local_134[0x41] & 1);
			local_138 = D3DRMGROUP_0;
			if (*local_134 != D3DRMGROUP_0) {
				do {
					groupID = res::Container_Mesh_AddGroup((Container *)local_134[0x40],4,2,3,&local_f8);
					res::Container_Mesh_SetColourAlpha((Container *)local_134[0x40],groupID,0.0,0.3,0.8,0.6);
					pVVar10 = local_c0;
					lVar8 = __ftol((float10)pfVar7[1]);
					uVar3 = (uint)lVar8;
					lVar8 = __ftol((float10)*pfVar7);
					Map3D_GetBlockVertexPositions(level->surfaceMap,(uint)lVar8,uVar3,pVVar10);
					pfVar6 = &local_c0[0].y;
					pfVar4 = &vertices[0].position.y;
					uVar3 = 0;
					do {
						pfVar4[-1] = pfVar6[-1];
						*pfVar4 = *pfVar6;
						pfVar4[1] = (float)local_134[0x3e];
						uVar5 = uVar3 + 4;
						pfVar6 = pfVar6 + 3;
						pfVar4[2] = 0.0;
						pfVar4[3] = 0.0;
						pfVar4[4] = -1.0;
						fVar2 = *(float *)((int)local_118 + uVar3);
						pfVar4[7] = 0.0;
						pfVar4[5] = fVar2;
						pfVar4[6] = *(float *)((int)local_108 + uVar3);
						pfVar4 = pfVar4 + 9;
						uVar3 = uVar5;
					} while (uVar5 < 0x10);
					res::Container_Mesh_SetVertices((Container *)local_134[0x40],local_138,0,4,vertices);
					local_138 += 1;
					pfVar7 = pfVar7 + 2;
				} while (local_138 < *local_134);
			}
			local_128 += 1;
			local_134 = local_134 + 0x10a;
		} while (local_128 < Struct_428_COUNT_0054ceb0);
	}
	return;
}



// This function can be completely ignored, since there's not actual information on what
// logf_removed is doing.

void __cdecl lego::debug::LevelStruct428_Debug_Log_LevelStruct428Floats(BOOL logWithValues)
{
	Container **ppCVar1;
	uint uVar2;
	Container *message;
	undefined4 uVar3;
	undefined4 uVar4;
	
	uVar2 = 0;
	if (Struct_428_COUNT_0054ceb0 != 0) {
		ppCVar1 = &Struct_428_ARRAY_0054a520[0].resMeshTrans;
		do {
			if (logWithValues == 0) {
										// resMeshTrans (Container*), 0.0, 0.0
				message = *ppCVar1;
				uVar4 = 0;
				uVar3 = 0;
			}
			else {
				message = *ppCVar1;
										// resMeshTrans (Container*), 0.12, 0.32
				uVar4 = 1050924810;
				uVar3 = 1039516304;
			}
			util::logf_removed((char *)message,0,uVar3,uVar4);
			uVar2 += 1;
			ppCVar1 = ppCVar1 + 0x10a;
		} while (uVar2 < Struct_428_COUNT_0054ceb0);
	}
	return;
}



void __cdecl lego::game::LevelStruct428_FUN_0046e4e0(LevelData *level,int param_2,uint param_3)
{
	undefined4 *puVar1;
	int iVar2;
	float fVar3;
	undefined4 *puVar4;
	uint y;
	longlong lVar5;
	Vector3F *out_vertices4;
	int local_50 [4];
	undefined4 local_40;
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	Vector3F local_30 [4];
	
	local_50[3] = 2;
	local_40 = 2;
	local_3c = 3;
	local_38 = 3;
	local_50[0] = 0;
	local_50[1] = 1;
	local_50[2] = 1;
	local_34 = 0;
	puVar4 = LevelStruct428_FUN_0046eb60(param_2,param_3,&param_3);
	if (puVar4 != NULL) {
		puVar4[0x109] = puVar4[0x109] & 0xfffffffb | 1;
		res::Container_Hide((Container *)puVar4[0x108],0);
		out_vertices4 = local_30;
		iVar2 = puVar4[param_3 * 6 + 0xc9];
		puVar1 = puVar4 + param_3 * 6 + 0xc9;
		puVar1[5] = 1;
		puVar1[3] = 0;
		puVar1[4] = 0;
		lVar5 = __ftol((float10)(float)(puVar4 + iVar2 * 2)[1]);
		y = (uint)lVar5;
		lVar5 = __ftol((float10)(float)puVar4[iVar2 * 2]);
		Map3D_GetBlockVertexPositions(level->surfaceMap,(uint)lVar5,y,out_vertices4);
		fVar3 = -local_30[local_50[puVar1[1] * 2]].z;
		if (-local_30[local_50[puVar1[1] * 2 + 1]].z <= -local_30[local_50[puVar1[1] * 2]].z) {
			fVar3 = -local_30[local_50[puVar1[1] * 2 + 1]].z;
		}
		puVar1[2] = -fVar3;
	}
	return;
}



void __cdecl lego::game::LevelStruct428_FUN_0046e5f0(int param_1,uint param_2)
{
	undefined4 *puVar1;
	
	puVar1 = LevelStruct428_FUN_0046eb60(param_1,param_2,&param_2);
	if (puVar1 != NULL) {
		puVar1[0x109] = puVar1[0x109] & 0xfffffffd | 1;
		res::Container_Hide((Container *)puVar1[0x108],0);
		puVar1[param_2 * 6 + 0xce] = 0;
	}
	return;
}



void __cdecl lego::game::LevelStruct428_FUN_0046e650(LevelData *level,float elapsedGame)
{
	float fVar1;
	float fVar2;
	float fVar3;
	bool bVar4;
	bool bVar5;
	float *pfVar6;
	int iVar7;
	uint uVar8;
	uint *puVar9;
	D3DRMGroupIndex groupID;
	bool bVar10;
	uint local_a0;
	uint local_9c;
	D3DRMVertex local_90 [4];
	
	local_a0 = 0;
	local_9c = 0;
	if (Struct_428_COUNT_0054ceb0 != 0) {
		puVar9 = &Struct_428_ARRAY_0054a520[0].itemsCount;
		do {
			bVar5 = false;
			fVar1 = (float)puVar9[1];
			bVar10 = (*(byte *)(puVar9 + 4) & 2) == 0;
			uVar8 = 0;
			if (*puVar9 != 0) {
				pfVar6 = (float *)(puVar9 + -0x3a);
				do {
					bVar4 = false;
					if ((pfVar6[3] == 0.0) ||
						 ((ushort)((ushort)((float)puVar9[2] < *pfVar6) << 8 |
											(ushort)((float)puVar9[2] == *pfVar6) << 0xe) == 0)) {
LAB_0046e6eb:
						bVar4 = true;
					}
					else {
						if (fVar1 < *pfVar6) {
							fVar1 = *pfVar6;
						}
						bVar10 = false;
						local_a0 += 1;
						bVar5 = true;
						if ((float)puVar9[2] == *pfVar6) goto LAB_0046e6eb;
					}
					fVar3 = pfVar6[1] + elapsedGame * 1.5;
					pfVar6[1] = fVar3;
					if (bVar4) {
						pfVar6[2] = elapsedGame * 0.5 + pfVar6[2];
					}
					if ((ushort)((ushort)(fVar3 < 240.0) << 8 | (ushort)(fVar3 == 240.0) << 0xe) == 0) {
						pfVar6[1] = 240.0;
					}
					if ((ushort)((ushort)(pfVar6[2] < 240.0) << 8 | (ushort)(pfVar6[2] == 240.0) << 0xe) == 0)
					{
						pfVar6[2] = 240.0;
					}
					uVar8 += 1;
					pfVar6 = pfVar6 + 6;
				} while (uVar8 < *puVar9);
			}
			uVar8 = puVar9[4];
			if ((uVar8 & 4) != 0) {
				bVar5 = false;
			}
			if ((bVar5) || (bVar10)) {
				fVar3 = ((float)puVar9[2] - (float)puVar9[1]) / level->DigDepth;
				if (bVar5) {
					puVar9[4] = uVar8 & 0xfffffffd;
					fVar2 = ((float)(ulonglong)local_a0 * elapsedGame * 0.3) / (fVar3 - -1.0) +
									(float)puVar9[2];
					puVar9[2] = (uint)fVar2;
					if (fVar1 <= fVar2) {
						puVar9[2] = (uint)fVar1;
						puVar9[4] = uVar8 & 0xfffffffd | 4;
					}
				}
				else {
					puVar9[4] = uVar8 & 0xfffffffb;
					fVar2 = (float)puVar9[2] - elapsedGame * 0.05;
					puVar9[2] = (uint)fVar2;
					if ((ushort)((ushort)(fVar2 < fVar1) << 8 | (ushort)(fVar2 == fVar1) << 0xe) != 0) {
						puVar9[2] = (uint)fVar1;
						puVar9[4] = uVar8 & 0xfffffffb | 2;
					}
				}
				res::Container_SetColourAlpha((Container *)puVar9[3],0.0,0.3,0.8,0.6 - fVar3 * 0.4);
				groupID = D3DRMGROUP_0;
				if (puVar9[-0x3d] != 0) {
					do {
						res::Container_Mesh_GetVertices((Container *)puVar9[3],groupID,0,4,local_90);
						pfVar6 = &local_90[0].position.z;
						iVar7 = 4;
						do {
							*pfVar6 = (float)puVar9[2];
							pfVar6 = pfVar6 + 9;
							iVar7 += -1;
						} while (iVar7 != 0);
						res::Container_Mesh_SetVertices((Container *)puVar9[3],groupID,0,4,local_90);
						groupID += 1;
					} while (groupID < puVar9[-0x3d]);
				}
			}
			local_9c += 1;
			puVar9 = puVar9 + 0x10a;
		} while (local_9c < Struct_428_COUNT_0054ceb0);
	}
	LevelStruct428_FUN_0046e8d0(level);
	return;
}



void __cdecl lego::game::LevelStruct428_FUN_0046e8d0(LevelData *level)
{
	uint uVar1;
	uint uVar2;
	uint *puVar3;
	uint *puVar4;
	longlong lVar5;
	Vector3F *pVVar6;
	int *local_9c;
	int *local_98;
	uint local_94;
	uint local_90;
	float local_8c;
	float local_88;
	int local_80 [4];
	undefined4 local_70;
	undefined4 local_6c;
	undefined4 local_68;
	undefined4 local_64;
	float local_60 [4];
	undefined4 local_50;
	undefined4 local_4c;
	undefined4 local_48;
	undefined4 local_44;
	undefined4 local_40;
	undefined4 local_3c;
	undefined4 local_38;
	undefined4 local_34;
	Vector3F local_30 [4];
	
	local_80[1] = 1;
	local_80[2] = 1;
	local_60[0] = 0.0;
	local_80[3] = 2;
	local_70 = 2;
	local_60[1] = 1.0;
	local_6c = 3;
	local_68 = 3;
	local_60[2] = 0.0;
	local_60[3] = 1.0;
	local_50 = 0;
	local_4c = 0;
	local_48 = 0;
	local_44 = 0xbf800000;
	local_40 = 0;
	local_3c = 0xbf800000;
	local_38 = 0;
	local_34 = 0;
	local_80[0] = 0;
	local_64 = 0;
	local_94 = 0;
	if (Struct_428_COUNT_0054ceb0 != 0) {
		puVar3 = &Struct_428_ARRAY_0054a520[0].itemsCount;
		do {
			local_90 = 0;
			if (*puVar3 != 0) {
				puVar4 = puVar3 + -0x3b;
				do {
					uVar1 = puVar4[-1];
					pVVar6 = local_30;
					lVar5 = __ftol((float10)(float)puVar3[uVar1 * 2 + -0x104]);
					uVar2 = (uint)lVar5;
					lVar5 = __ftol((float10)(float)puVar3[uVar1 * 2 + -0x105]);
					Map3D_GetBlockVertexPositions(level->surfaceMap,(uint)lVar5,uVar2,pVVar6);
					uVar1 = *puVar4;
					local_8c = (local_30[local_80[uVar1 * 2 + 1]].x + local_30[local_80[uVar1 * 2]].x) * 0.5 +
										 local_60[uVar1 * 3] * (float)puVar4[2];
					local_88 = local_60[uVar1 * 3 + 1] * (float)puVar4[2] +
										 (local_30[local_80[uVar1 * 2]].y + local_30[local_80[uVar1 * 2 + 1]].y) * 0.5;
					Map3D_WorldToBlockPos_NoZ
										(level->surfaceMap,local_8c,local_88,(int *)&local_98,(int *)&local_9c);
					FUN_0042f210(level,local_98,local_9c,1);
					uVar1 = puVar4[-1];
					pVVar6 = local_30;
					lVar5 = __ftol((float10)(float)puVar3[uVar1 * 2 + -0x104]);
					uVar2 = (uint)lVar5;
					lVar5 = __ftol((float10)(float)puVar3[uVar1 * 2 + -0x105]);
					Map3D_GetBlockVertexPositions(level->surfaceMap,(uint)lVar5,uVar2,pVVar6);
					uVar1 = *puVar4;
					local_8c = (local_30[local_80[uVar1 * 2 + 1]].x + local_30[local_80[uVar1 * 2]].x) * 0.5 +
										 local_60[uVar1 * 3] * (float)puVar4[3];
					local_88 = local_60[uVar1 * 3 + 1] * (float)puVar4[3] +
										 (local_30[local_80[uVar1 * 2]].y + local_30[local_80[uVar1 * 2 + 1]].y) * 0.5;
					Map3D_WorldToBlockPos_NoZ
										(level->surfaceMap,local_8c,local_88,(int *)&local_98,(int *)&local_9c);
					FUN_0042f210(level,local_98,local_9c,0);
					local_90 += 1;
					puVar4 = puVar4 + 6;
				} while (local_90 < *puVar3);
			}
			local_94 += 1;
			puVar3 = puVar3 + 0x10a;
		} while (local_94 < Struct_428_COUNT_0054ceb0);
	}
	return;
}



undefined4 * __cdecl lego::game::LevelStruct428_FUN_0046eb60(int bx,int by,uint *out_index)
{
	uint uVar1;
	ItemStruct_428 *pIVar2;
	ItemStruct_428 *pIVar3;
	float10 extraout_ST0;
	longlong lVar4;
	uint local_24;
	Point2F DIRECTIONS_F [4];
	
	DIRECTIONS_F[0].x = 0.0;
	DIRECTIONS_F[0].y = -1.0;
	DIRECTIONS_F[1].x = 1.0;
	DIRECTIONS_F[1].y = 0.0;
	DIRECTIONS_F[2].x = 0.0;
	DIRECTIONS_F[2].y = 1.0;
	DIRECTIONS_F[3].x = -1.0;
	DIRECTIONS_F[3].y = 0.0;
	local_24 = 0;
	if (Struct_428_COUNT_0054ceb0 == 0) {
		return NULL;
	}
	pIVar2 = Struct_428_ARRAY_0054a520[0].items;
	do {
		uVar1 = 0;
		pIVar3 = pIVar2;
		if (pIVar2[10].index != 0) {
			do {
				lVar4 = __ftol((float10)(float)(&pIVar2[-0x22].field_c)[pIVar3->index * 2] +
											 (float10)DIRECTIONS_F[pIVar3->direction].x);
				if ((bx == (int)lVar4) && (lVar4 = __ftol(extraout_ST0), by == (int)lVar4)) {
					if (out_index != NULL) {
						*out_index = uVar1;
					}
					return &pIVar2[-0x22].field_c;
				}
				uVar1 += 1;
				pIVar3 = pIVar3 + 1;
			} while (uVar1 < pIVar2[10].index);
		}
		local_24 += 1;
		pIVar2 = (ItemStruct_428 *)&pIVar2[0x2c].field_8;
		if (Struct_428_COUNT_0054ceb0 <= local_24) {
			return NULL;
		}
	} while( true );
}



int __cdecl lego::game::LevelStruct428_CompareCount(Struct_428 *a,Struct_428 *b)
{
	if (b->pointsCount < a->pointsCount) {
		return 0xffffffff;
	}
	return (uint)(a->pointsCount < b->pointsCount);
}



Struct_428 * __cdecl
lego::game::LevelStruct428_LoadSearchStruct428(int y,uint unkParam_x,uint unkParam_xMax)
{
	Struct_428 *pSVar1;
	Struct_428 *pSVar2;
	uint uVar3;
	Struct_428 *pSVar4;
	Struct_428 *pSVar5;
	uint uVar6;
	
	pSVar4 = NULL;
	if ((y != 0) && (unkParam_x < unkParam_xMax)) {
		do {
			uVar3 = 0;
			if (Struct_428_COUNT_0054ceb0 != 0) {
				pSVar1 = Struct_428_ARRAY_0054a520;
				do {
					uVar6 = 0;
					if (pSVar1->pointsCount != 0) {
						pSVar2 = pSVar1;
						pSVar5 = pSVar4;
						do {
							pSVar4 = pSVar5;
							if (((((float)(ulonglong)unkParam_x == pSVar2->points[0].x) &&
									 ((float)(ulonglong)(y - 1) == pSVar2->points[0].y)) &&
									(pSVar4 = pSVar1, pSVar5 != NULL)) && (pSVar4 = pSVar5, pSVar5 != pSVar1)) {
								PairStruct_428_ARRAY_0054ceb4[PairStruct_428_COUNT_0054cf04].first = pSVar5;
								PairStruct_428_ARRAY_0054ceb4[PairStruct_428_COUNT_0054cf04].second = pSVar1;
								PairStruct_428_COUNT_0054cf04 += 1;
							}
							uVar6 += 1;
							pSVar2 = (Struct_428 *)(pSVar2->points + 1);
							pSVar5 = pSVar4;
						} while (uVar6 < pSVar1->pointsCount);
					}
					uVar3 += 1;
					pSVar1 = pSVar1 + 1;
				} while (uVar3 < Struct_428_COUNT_0054ceb0);
			}
			unkParam_x += 1;
		} while (unkParam_x < unkParam_xMax);
	}
	return pSVar4;
}



void __cdecl
lego::game::LevelStruct428_LoadAddStruct428
					(Struct_428 *struct428,uint y,uint unkParam_x,uint unkParam_xMax)
{
	if (unkParam_x < unkParam_xMax) {
		do {
			struct428->points[struct428->pointsCount].x = (float)(ulonglong)unkParam_x;
			struct428->points[struct428->pointsCount].y = (float)(ulonglong)y;
			unkParam_x += 1;
			struct428->pointsCount = struct428->pointsCount + 1;
		} while (unkParam_x < unkParam_xMax);
	}
	return;
}



void __cdecl
lego::game::LevelStruct428_LoadAddFirstStruct428(uint y,uint unkParam_x,uint unkParam_xMax)
{
	Struct_428 *struct428;
	
	struct428 = Struct_428_ARRAY_0054a520 + Struct_428_COUNT_0054ceb0;
	Struct_428_ARRAY_0054a520[Struct_428_COUNT_0054ceb0].pointsCount = 0;
	LevelStruct428_LoadAddStruct428(struct428,y,unkParam_x,unkParam_xMax);
	Struct_428_COUNT_0054ceb0 = Struct_428_COUNT_0054ceb0 + 1;
	return;
}



BOOL __cdecl lego::tools::Weapon_LoadWeaponTypes(CFGProperty *root,char *rootPath)
{
	char cVar1;
	CFGProperty *prop;
	char *pcVar2;
	CFGProperty *pCVar3;
	int iVar4;
	BOOL BVar5;
	void *pvVar6;
	uint uVar7;
	int iVar8;
	uint uVar9;
	int iVar10;
	char **ppcVar11;
	int iVar12;
	undefined4 *puVar13;
	uint uVar14;
	undefined4 *puVar15;
	float10 fVar16;
	ObjectType local_d8;
	uint local_d4;
	CFGProperty *local_d0;
	int local_cc;
	int local_c8;
	int local_c4;
	char *local_c0 [16];
	char local_80 [128];
	
	uVar14 = 0;
	globals::g_LegoCfgRoot_WeaponTypes = root;
	globals::g_WeaponTypes_COUNT = 0;
	pcVar2 = cfg::CFG_JoinPath(rootPath,"WeaponTypes",0);
	pCVar3 = cfg::CFG_GetChildren(root,pcVar2);
	if (pCVar3 != NULL) {
		do {
			globals::g_WeaponTypes_COUNT += 1;
			pCVar3 = cfg::CFG_NextFlat(pCVar3);
		} while (pCVar3 != NULL);
		globals::g_WeaponTypes_TABLE = (WeaponStats *)std::malloc(globals::g_WeaponTypes_COUNT * 0x4b68)
		;
		if (globals::g_WeaponTypes_TABLE != NULL) {
			if (globals::g_WeaponTypes_COUNT != 0) {
				iVar12 = 0;
				iVar10 = 0;
				do {
					local_d8 = OBJECT_NONE;
					do {
						local_d4 = 0;
						do {
							uVar9 = 0;
							do {
								uVar7 = uVar9 + 1;
								globals::g_WeaponTypes_TABLE->ObjectRatios[local_d8][local_d4][uVar9 + iVar10] =
										 -1.0;
								uVar9 = uVar7;
							} while (uVar7 < 0x10);
							local_d4 += 1;
						} while (local_d4 < 0xf);
						local_d8 += OBJECT_VEHICLE;
					} while (local_d8 < 0x14);
					*(undefined4 *)((int)globals::g_WeaponTypes_TABLE->WallDestroyTimes + iVar12 + -0x20) = 0;
					*(undefined4 *)((int)globals::g_WeaponTypes_TABLE->WallDestroyTimes + iVar12 + -0x14) = 0;
					*(undefined4 *)((int)globals::g_WeaponTypes_TABLE->WallDestroyTimes + iVar12 + -0x10) = 0;
					iVar8 = 0x12;
										// 150.0
					*(undefined4 *)((int)globals::g_WeaponTypes_TABLE->WallDestroyTimes + iVar12 + -4) =
							 0x43160000;
					iVar4 = iVar12 + 0x4b20;
					do {
						iVar8 += -1;
										// 5.0
						*(undefined4 *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar4) = 1084227584;
						iVar4 = iVar4 + 4;
					} while (iVar8 != 0);
					uVar14 += 1;
					iVar10 += 0x12da;
					iVar12 += 0x4b68;
				} while (uVar14 < globals::g_WeaponTypes_COUNT);
			}
			globals::g_WeaponNames_TABLE = (char **)std::malloc(globals::g_WeaponTypes_COUNT * 4);
			if (globals::g_WeaponNames_TABLE != NULL) {
				pcVar2 = cfg::CFG_JoinPath(rootPath,"WeaponTypes",0);
				local_d0 = cfg::CFG_GetChildren(root,pcVar2);
				if (local_d0 != NULL) {
					iVar10 = 0x4b04;
					local_c8 = 0;
					local_cc = 0;
					local_c4 = 0x4b04;
LAB_0046f010:
					prop = local_d0;
					pcVar2 = cfg::CFG_JoinPath(rootPath,"WeaponTypes",local_d0->key,0);
					pCVar3 = cfg::CFG_GetChildren(root,pcVar2);
joined_r0x0046f044:
					do {
						if (pCVar3 == NULL) goto LAB_0046f2cb;
						iVar12 = std::_stricmp(pCVar3->key,"SlowDeath");
						if (iVar12 == 0) {
							util::Util_Tokenise(pCVar3->value,local_c0,":");
							*(undefined4 *)
							 ((int)globals::g_WeaponTypes_TABLE->ObjectRatios[-1][0xe] + iVar10 + 0x3c) = 1;
							fVar16 = std::atof(local_c0[0]);
							*(float *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10) = (float)fVar16;
							fVar16 = std::atof(local_c0[1]);
							*(float *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10 + 4) =
									 (float)fVar16;
							goto LAB_0046f2b4;
						}
						iVar12 = std::_stricmp(pCVar3->key,"RechargeTime");
						if (iVar12 == 0) {
							fVar16 = std::atof(pCVar3->value);
							*(float *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10 + 8) =
									 (float)fVar16;
							goto LAB_0046f2b4;
						}
						iVar12 = std::_stricmp(pCVar3->key,"DefaultDamage");
						if (iVar12 == 0) {
							fVar16 = std::atof(pCVar3->value);
							*(float *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10 + 0xc) =
									 (float)fVar16;
							goto LAB_0046f2b4;
						}
						iVar12 = std::_stricmp(pCVar3->key,"DischargeRate");
						if (iVar12 == 0) {
							fVar16 = std::atof(pCVar3->value);
							*(float *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10 + 0x10) =
									 (float)fVar16;
							goto LAB_0046f2b4;
						}
						iVar12 = std::_stricmp(pCVar3->key,"WeaponRange");
						if (iVar12 == 0) {
							fVar16 = std::atof(pCVar3->value);
							*(float *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10 + 0x18) =
									 (float)fVar16;
							goto LAB_0046f2b4;
						}
						iVar12 = 0;
						ppcVar11 = globs::gameGlobs.SurfaceTypes_TABLE;
						do {
							std::sprintf(local_80,"WallDestroyTime_%s",*ppcVar11 + 0x11);
							iVar4 = std::_stricmp(pCVar3->key,local_80);
							if (iVar4 == 0) {
								fVar16 = std::atof(pCVar3->value);
								globals::g_WeaponTypes_TABLE->WallDestroyTimes[iVar12 + local_cc] = (float)fVar16;
								pCVar3 = cfg::CFG_NextFlat(pCVar3);
								break;
							}
							ppcVar11 = ppcVar11 + 1;
							iVar12 += 1;
						} while (ppcVar11 < globs::gameGlobs.SurfaceTypeDescriptions_name_TABLE);
						prop = local_d0;
						if (iVar12 == 0x12) {
							iVar12 = std::_stricmp(pCVar3->key,"Ammo");
							if (iVar12 == 0) {
								iVar12 = std::atoi(pCVar3->value);
								*(int *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10 + 0x14) = iVar12;
							}
							else {
								*(undefined4 *)((int)globals::g_WeaponTypes_TABLE->ObjectRatios + iVar10 + 0x14) = 0
								;
								BVar5 = game::Object_GetObjectByName(pCVar3->key,&local_d8,(int *)&local_d4,NULL);
								prop = local_d0;
								if (BVar5 == 0) goto joined_r0x0046f044;
								uVar14 = game::Object_GetLevels(local_d8,local_d4);
								util::Util_Tokenise(pCVar3->value,local_c0,":");
								if (uVar14 != 0) {
									ppcVar11 = local_c0;
									uVar9 = 0;
									do {
										fVar16 = std::atof(*ppcVar11);
										ppcVar11 = ppcVar11 + 1;
										uVar7 = uVar9 + 1;
										globals::g_WeaponTypes_TABLE->ObjectRatios[local_d8][local_d4][uVar9 + local_cc]
												 = (float)fVar16;
										iVar10 = local_c4;
										uVar9 = uVar7;
									} while (uVar7 < uVar14);
								}
							}
LAB_0046f2b4:
							pCVar3 = cfg::CFG_NextFlat(pCVar3);
							prop = local_d0;
						}
					} while( true );
				}
LAB_0046f345:
				if (local_d0 == NULL) {
					return 1;
				}
				std::free(globals::g_WeaponNames_TABLE);
			}
			std::free(globals::g_WeaponTypes_TABLE);
		}
	}
	return 0;
LAB_0046f2cb:
	uVar14 = 0xffffffff;
	pcVar2 = prop->key;
	do {
		if (uVar14 == 0) break;
		uVar14 -= 1;
		cVar1 = *pcVar2;
		pcVar2 = pcVar2 + 1;
	} while (cVar1 != '\0');
	pvVar6 = std::malloc(~uVar14);
	iVar10 += 0x4b68;
	*(void **)((int)globals::g_WeaponNames_TABLE + local_c8) = pvVar6;
	uVar14 = 0xffffffff;
	puVar13 = (undefined4 *)prop->key;
	do {
		if (uVar14 == 0) break;
		uVar14 -= 1;
		cVar1 = *(char *)puVar13;
		puVar13 = (undefined4 *)((int)puVar13 + 1);
	} while (cVar1 != '\0');
	puVar13 = (undefined4 *)prop->key;
	puVar15 = *(undefined4 **)((int)globals::g_WeaponNames_TABLE + local_c8);
	for (uVar9 = ~uVar14 >> 2; uVar9 != 0; uVar9 -= 1) {
		*puVar15 = *puVar13;
		puVar13 = puVar13 + 1;
		puVar15 = puVar15 + 1;
	}
	local_cc += 0x12da;
	for (uVar14 = ~uVar14 & 3; uVar14 != 0; uVar14 -= 1) {
		*(undefined *)puVar15 = *(undefined *)puVar13;
		puVar13 = (undefined4 *)((int)puVar13 + 1);
		puVar15 = (undefined4 *)((int)puVar15 + 1);
	}
	local_c8 = local_c8 + 4;
	local_c4 = iVar10;
	local_d0 = cfg::CFG_NextFlat(prop);
	if (local_d0 == NULL) goto LAB_0046f345;
	goto LAB_0046f010;
}



// On failure, returns g_WeaponTypes_COUNT

uint __cdecl lego::tools::Weapon_GetWeaponTypeByName(char *weaponName)
{
	int iVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (globals::g_WeaponTypes_COUNT == 0) {
		return 1;
	}
	do {
		iVar1 = std::_stricmp(globals::g_WeaponNames_TABLE[uVar2],weaponName);
		if (iVar1 == 0) {
			return uVar2;
		}
		uVar2 += 1;
	} while (uVar2 < globals::g_WeaponTypes_COUNT);
	return globals::g_WeaponTypes_COUNT + 1;
}



float10 __cdecl lego::tools::Weapon_GetRechargeTime(int weaponType)
{
	return (float10)globals::g_WeaponTypes_TABLE[weaponType].RechargeTime;
}



float10 __cdecl lego::tools::Weapon_GetDischargeRate(int weaponType)
{
	return (float10)globals::g_WeaponTypes_TABLE[weaponType].DischargeRate;
}



float10 __cdecl lego::tools::Weapon_GetWeaponRange(int weaponType)
{
	return (float10)globals::g_WeaponTypes_TABLE[weaponType].WeaponRange;
}



float10 __cdecl lego::tools::Weapon_GetWallDestroyTime(int weaponType,SurfaceType surfaceType)
{
	return (float10)globals::g_WeaponTypes_TABLE[weaponType].WallDestroyTimes[surfaceType];
}



float10 __cdecl lego::game::Weapon_GetDamageForLiveObject(int weaponType,LiveObject *liveObj)
{
	ObjectType OVar1;
	
	OVar1 = liveObj->objType;
	if (globals::g_WeaponTypes_TABLE[weaponType].ObjectRatios
			[OVar1 * 3 + liveObj->objIndex + OVar1 * 0xc][liveObj->objLevel] == -1.0) {
		return (float10)globals::g_WeaponTypes_TABLE[weaponType].DefaultDamage;
	}
	return (float10)globals::g_WeaponTypes_TABLE[weaponType].ObjectRatios[OVar1][liveObj->objIndex]
									[liveObj->objLevel];
}



void __cdecl
lego::game::LiveObject_FUN_0046f530
					(LiveObject *liveObj,int weaponType,BOOL param_3,float param_4,float *param_5)
{
	float fVar1;
	BOOL BVar2;
	float10 fVar3;
	
	fVar3 = Weapon_GetDamageForLiveObject(weaponType,liveObj);
	fVar1 = (float)fVar3;
	if ((liveObj->flags3 & LIVEOBJ3_UNK_40000) != LIVEOBJ3_NONE) {
		BVar2 = LiveObject_CheckCondition_FUN_00438870(liveObj,1);
		if (BVar2 != 0) {
			if (globals::g_WeaponTypes_TABLE[weaponType].isSlowDeath != 0) {
				if (param_3 != 0) {
					LiveObject_AddDamage2
										(liveObj,globals::g_WeaponTypes_TABLE[weaponType].SlowDeath_initial * fVar1,1,
										 param_4);
					fVar1 = globals::g_WeaponTypes_TABLE[weaponType].SlowDeath_duration;
					liveObj->field_35c = weaponType;
					liveObj->field_358 = fVar1;
					LiveObject_FUN_00447c10(liveObj,(Point2F *)param_5,1);
					return;
				}
				LiveObject_AddDamage2(liveObj,fVar1 * param_4,1,param_4);
				return;
			}
			if (liveObj->objType == OBJECT_ROCKMONSTER) {
				nerps::NERPs_IncInt_0055632c();
			}
			LiveObject_AddDamage2(liveObj,fVar1,1,param_4);
			if (param_3 != 0) {
				LiveObject_FUN_00447c10(liveObj,(Point2F *)param_5,1);
			}
		}
	}
	return;
}



void __cdecl lego::game::LiveObject_FUN_0046f640(LiveObject *liveObj,float param_2,int param_3)
{
	LiveObject_AddDamage2(liveObj,param_2,1,1.0);
	LiveObject_FUN_00447c10(liveObj,NULL,param_3);
	return;
}



void __cdecl lego::res::Struct2B0_FUN_0046f670(Struct_2b0 *param_1)
{
	float10 fVar1;
	float10 fVar2;
	float10 fVar3;
	float10 fVar4;
	Vector3F local_30;
	Vector3F local_24;
	SearchData18_2 local_18;
	
	if (param_1->object_2a4 != NULL) {
		local_18.field_14 = param_1->field_2a0;
		local_18.vectorp_c = &local_24;
		local_18.field_0 = NULL;
		local_18.ref_float_4 = 1.0;
		local_18.field_10 = 0;
		local_18.vectorp_8 = &param_1->position_280;
		fVar1 = tools::Weapon_GetWeaponRange(param_1->weaponType);
		if (fVar1 != (float10)0.0) {
			fVar2 = (float10)(param_1->vector_268).x - (float10)(param_1->vector_274).x;
			fVar3 = (float10)(param_1->vector_268).y - (float10)(param_1->vector_274).y;
			fVar4 = (float10)(param_1->vector_268).z - (float10)(param_1->vector_274).z;
			local_30.y = (float)fVar3;
			local_30.z = (float)fVar4;
			if (fVar1 <= SQRT(fVar4 * (float10)local_30.z + fVar3 * (float10)local_30.y + fVar2 * fVar2))
			{
				pool::ReservedPool_LiveObject___Release(param_1->object_2a4);
				param_1->object_2a4 = NULL;
				return;
			}
		}
		local_24.x = (param_1->vector_274).x - (param_1->position_280).x;
		local_24.y = (param_1->vector_274).y - (param_1->position_280).y;
		local_24.z = (param_1->vector_274).z - (param_1->position_280).z;
		game::Search_LiveObjects_SkipIgnoreMes
							(game::LiveObject_Callback_FUN_00471630,(undefined4 *)&local_18);
		FUN_004718f0(&local_18);
		if (local_18.field_10 != 0) {
			pool::ReservedPool_LiveObject___Release(param_1->object_2a4);
			param_1->object_2a4 = NULL;
			if (local_18.field_0 != NULL) {
				local_30.x = (local_18.vectorp_c)->x * local_18.ref_float_4 + (local_18.vectorp_8)->x;
				local_30.y = (local_18.vectorp_8)->y + (local_18.vectorp_c)->y * local_18.ref_float_4;
				local_30.z = (local_18.vectorp_8)->z + (local_18.vectorp_c)->z * local_18.ref_float_4;
				game::LiveObject_FUN_0046fa30
									(local_18.field_0,(int **)&param_1->vector_290,&local_30,
									 (int *)param_1->weaponType,param_1->field_2ac);
			}
		}
	}
	return;
}



void __cdecl lego::res::Struct2B0_Table_FUN_0046f810(float elapsedGame)
{
	Struct_2b0 *pSVar1;
	ItemStruct_34 *pIVar2;
	
	pSVar1 = globals::g_Struct2B0Unk_TABLE;
	do {
		if (pSVar1->object_2a4 != NULL) {
			Struct2B0_FUN_0046fbe0(pSVar1,elapsedGame);
		}
		pSVar1 = pSVar1 + 1;
	} while (pSVar1 < &globals::g_LegoCfgRoot_WeaponTypes);
	game::Search_LiveObjects_SkipIgnoreMes(game::LiveObject_Callback_FUN_0046f8d0,&elapsedGame);
	pSVar1 = globals::g_Struct2B0Unk_TABLE;
	do {
		Struct2B0_FUN_0046f670(pSVar1);
		pSVar1 = pSVar1 + 1;
	} while (pSVar1 < &globals::g_LegoCfgRoot_WeaponTypes);
	pIVar2 = globals::g_ItemStruct34Unk_TABLE;
	do {
		if ((Mesh *)((Struct_2b0 *)pIVar2)->unseen_0 != NULL) {
			if ((((Struct_2b0 *)pIVar2)->routing).points[0].y < 0.0) {
				Mesh_Remove((Mesh *)((Struct_2b0 *)pIVar2)->unseen_0,
										*(IDirect3DRMFrame3 **)((int)(((Struct_2b0 *)pIVar2)->routing).points[0].x + 4))
				;
				Mesh_Remove((Mesh *)(((Struct_2b0 *)pIVar2)->routing).count,
										*(IDirect3DRMFrame3 **)((int)(((Struct_2b0 *)pIVar2)->routing).points[0].x + 4))
				;
				((Struct_2b0 *)pIVar2)->unseen_0 = 0;
			}
			(((Struct_2b0 *)pIVar2)->routing).points[0].y =
					 (((Struct_2b0 *)pIVar2)->routing).points[0].y - elapsedGame;
		}
		pIVar2 = (ItemStruct_34 *)((((Struct_2b0 *)pIVar2)->routing).points + 1);
	} while (pIVar2 < globals::g_Struct2B0Unk_TABLE);
	return;
}



BOOL __cdecl lego::game::LiveObject_Callback_FUN_0046f8d0(LiveObject *liveObj,float *lpElapsed)
{
	float fVar1;
	void *pvVar2;
	Container *cont;
	uint uVar3;
	float10 fVar4;
	float10 fVar5;
	Container *opt_ref;
	uint uVar6;
	Vector3F *out_pos;
	Vector3F local_c;
	
	if ((ushort)((ushort)((float)liveObj->field_360 < 0.0) << 8 |
							(ushort)((float)liveObj->field_360 == 0.0) << 0xe) == 0) {
		liveObj->field_360 = (float)liveObj->field_360 - *lpElapsed;
	}
	pvVar2 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
	if (pvVar2 != NULL) {
		uVar3 = 0;
		pvVar2 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
		if (*(int *)((int)pvVar2 + 0xa4) != 0) {
			do {
				fVar4 = LiveObject_PtrGetter_FUN_004715b0(liveObj,uVar3);
				if ((ushort)((ushort)(fVar4 < (float10)0.0) << 8 | (ushort)(fVar4 == (float10)0.0) << 0xe)
						== 0) {
					uVar6 = uVar3;
					fVar5 = LiveObject_PtrGetter_FUN_004715b0(liveObj,uVar3);
					LiveObject_PtrSetter_FUN_004715d0(liveObj,(float)(fVar5 - (float10)*lpElapsed),uVar6);
					fVar5 = snd::SFX_Sample_Random_GetSamplePlayTime(SFX_LAZERRECHARGE);
					fVar1 = (float)(fVar5 * (float10)25.0 * (float10)globs::gameGlobs.gameSpeed);
					fVar5 = LiveObject_PtrGetter_FUN_004715b0(liveObj,uVar3);
					if ((fVar5 < (float10)fVar1) &&
						 ((ushort)((ushort)((float)fVar4 < fVar1) << 8 | (ushort)((float)fVar4 == fVar1) << 0xe)
							== 0)) {
						out_pos = &local_c;
						opt_ref = NULL;
						cont = LiveObject_GetContainer(liveObj);
						res::Container_GetPosition(cont,opt_ref,out_pos);
						res::SFX_Sample_Container_Random_Play_OrInitSoundUnk
											(NULL,SFX_LAZERRECHARGE,0,0,&local_c);
					}
				}
				uVar3 += 1;
				pvVar2 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
			} while (uVar3 < *(uint *)((int)pvVar2 + 0xa4));
		}
	}
	if ((ushort)((ushort)((float)liveObj->field_358 < 0.0) << 8 |
							(ushort)((float)liveObj->field_358 == 0.0) << 0xe) == 0) {
		LiveObject_FUN_0046f530(liveObj,liveObj->field_35c,0,*lpElapsed,NULL);
		liveObj->field_358 = (float)liveObj->field_358 - *lpElapsed;
	}
	return 0;
}



void __cdecl
lego::game::LiveObject_FUN_0046fa30
					(LiveObject *liveObj,int **param_2,Vector3F *param_3,int *param_4,int param_5)
{
	BOOL BVar1;
	ObjectStatsFlags2 OVar2;
	float10 fVar3;
	float10 fVar4;
	Point2F local_8;
	
	local_8.x = (float)*param_2;
	local_8.y = (float)param_2[1];
	BVar1 = LiveObject_CheckRockMonsterAnd_FUN_004439b0(liveObj);
	if (BVar1 != 0) {
		lego::effect::Effect_Spawn_BoulderExplode_AtWorldPos(param_3);
	}
	if (param_5 == 1) {
		OVar2 = LiveObject_GetStatsFlags2(liveObj);
		if ((OVar2 & STATS2_CANLASER) != STATS2_NONE) {
			fVar3 = LiveObject_GetLaserDamage(liveObj);
			LiveObject_FUN_0046f640(liveObj,(float)fVar3,1);
		}
		if (param_3 != NULL) {
			lego::effect::Effect_Spawn_Particle(MISCOBJECT_LAZERHIT,param_3,NULL);
		}
	}
	else {
		if (param_5 == 2) {
			OVar2 = LiveObject_GetStatsFlags2(liveObj);
			if ((OVar2 & STATS2_CANPUSH) != STATS2_NONE) {
				fVar3 = LiveObject_GetPusherDist(liveObj);
				fVar4 = LiveObject_GetPusherDamage(liveObj);
				local_8.x = local_8.x * 1.5;
				local_8.y = local_8.y * 1.5;
				LiveObject_FUN_0046f640(liveObj,(float)fVar4,1);
				LiveObject_Unk_AndSetVector3B4(liveObj,&local_8,(float)fVar3);
			}
			if (param_3 != NULL) {
				lego::effect::Effect_Spawn_Particle(MISCOBJECT_PUSHERHIT,param_3,NULL);
				return;
			}
		}
		else {
			if (param_5 != 3) {
				LiveObject_FUN_0046f530(liveObj,(int)param_4,1,0.0,(float *)&local_8);
				return;
			}
			param_2 = (int **)0x41200000;
			OVar2 = LiveObject_GetStatsFlags2(liveObj);
			if ((OVar2 & STATS2_CANFREEZE) != STATS2_NONE) {
				fVar3 = LiveObject_GetFreezerTime(liveObj);
				if ((ushort)((ushort)(fVar3 < (float10)0.0) << 8 | (ushort)(fVar3 == (float10)0.0) << 0xe)
						== 0) {
					param_2 = (int **)(float)fVar3;
				}
				fVar3 = LiveObject_GetFreezerDamage(liveObj);
				LiveObject_FUN_0046f640(liveObj,(float)fVar3,0);
				LiveObject_FUN_0044c2f0(liveObj,(float)param_2);
			}
			if (param_3 != NULL) {
				lego::effect::Effect_Spawn_Particle(MISCOBJECT_FREEZERHIT,param_3,NULL);
				return;
			}
		}
	}
	return;
}



void __cdecl lego::res::Struct2B0_FUN_0046fbe0(Struct_2b0 *param_1,float elapsed)
{
	float fVar1;
	float dirx;
	Container *cont;
	float fVar2;
	Point2F local_14;
	float local_8;
	
	cont = game::LiveObject_GetContainer(param_1->object_2a4);
	Container_GetPosition(cont,NULL,&param_1->position_280);
	fVar2 = param_1->float_28c * elapsed;
	if (param_1->unseen_0 == 0) {
		local_8 = (param_1->vector_290).y * fVar2;
		fVar1 = (param_1->vector_290).z;
		(param_1->vector_274).x = (param_1->vector_290).x * fVar2 + (param_1->vector_274).x;
		(param_1->vector_274).y = (param_1->vector_274).y + local_8;
		(param_1->vector_274).z = (param_1->vector_274).z + fVar1 * fVar2;
		Container_SetPosition
							(cont,NULL,(param_1->vector_274).x,(param_1->vector_274).y,(param_1->vector_274).z);
		fVar2 = (param_1->vector_290).z;
		fVar1 = (param_1->vector_290).y;
		dirx = (param_1->vector_290).x;
	}
	else {
		fVar2 = fVar2 + param_1->float_264;
		param_1->float_264 = fVar2;
		game::Routing_Calculate_FUN_004067f0(&param_1->routing,fVar2,&local_14);
		fVar2 = (param_1->vector_290).y;
		(param_1->vector_274).x = (param_1->vector_290).x * local_14.x + (param_1->vector_268).x;
		(param_1->vector_274).y = (param_1->vector_268).y + fVar2 * local_14.x;
		(param_1->vector_274).z = (param_1->vector_268).z + local_14.y;
		Container_SetPosition
							(cont,NULL,(param_1->vector_274).x,(param_1->vector_274).y,(param_1->vector_274).z);
		fVar2 = ((param_1->vector_274).z - (param_1->position_280).z) * 0.25;
		fVar1 = (param_1->vector_274).y - (param_1->position_280).y;
		dirx = (param_1->vector_274).x - (param_1->position_280).x;
	}
	Container_SetOrientation(cont,NULL,dirx,fVar1,fVar2,0.0,0.0,-1.0);
	return;
}



BOOL __cdecl
lego::unk::Struct2B0_FUN_0046fdb0
					(LiveObject *liveObj,Vector3F *param_2,Vector3F *param_3,uint weaponType,uint param_5)
{
	Vector3F *pVVar1;
	float fVar2;
	float fVar3;
	uint uVar4;
	uint knownWeapon;
	BOOL BVar5;
	int iVar6;
	LiveObject *pLVar7;
	
	knownWeapon = param_5;
	uVar4 = weaponType;
	pLVar7 = liveObj;
	if (param_5 == 1) {
		game::LiveObject_Weapon_FUN_004375c0(liveObj,weaponType,1.0);
	}
	tools::Weapon_GetObjectTypeIndex_ByKnownWeaponType(knownWeapon,&weaponType,(int *)&param_5);
	BVar5 = game::Object_GetTypeResource(weaponType,param_5,(Container **)&liveObj);
	if (BVar5 != 0) {
		iVar6 = Lego_GetNextIndex_Struct2b0_TABLE_00504bc0();
		if (iVar6 != -1) {
			globals::g_Struct2B0Unk_TABLE[iVar6].unseen_0 = 0;
			globals::g_Struct2B0Unk_TABLE[iVar6].weaponType = uVar4;
			globals::g_Struct2B0Unk_TABLE[iVar6].field_2ac = knownWeapon;
			globals::g_Struct2B0Unk_TABLE[iVar6].vector_274.x = param_2->x;
			globals::g_Struct2B0Unk_TABLE[iVar6].vector_274.y = param_2->y;
			globals::g_Struct2B0Unk_TABLE[iVar6].vector_274.z = param_2->z;
			globals::g_Struct2B0Unk_TABLE[iVar6].vector_268.x = param_2->x;
			globals::g_Struct2B0Unk_TABLE[iVar6].vector_268.y = param_2->y;
			fVar3 = param_2->z;
			globals::g_Struct2B0Unk_TABLE[iVar6].float_28c = 5.0;
			globals::g_Struct2B0Unk_TABLE[iVar6].vector_268.z = fVar3;
			pVVar1 = &globals::g_Struct2B0Unk_TABLE[iVar6].vector_290;
			pVVar1->x = param_3->x;
			globals::g_Struct2B0Unk_TABLE[iVar6].vector_290.y = param_3->y;
			globals::g_Struct2B0Unk_TABLE[iVar6].vector_290.z = param_3->z;
			fVar3 = globals::g_Struct2B0Unk_TABLE[iVar6].vector_290.y;
			fVar2 = globals::g_Struct2B0Unk_TABLE[iVar6].vector_290.z;
			fVar3 = 1.0 / SQRT(pVVar1->x * pVVar1->x + fVar2 * fVar2 + fVar3 * fVar3);
			pVVar1->x = pVVar1->x * fVar3;
			globals::g_Struct2B0Unk_TABLE[iVar6].vector_290.y =
					 fVar3 * globals::g_Struct2B0Unk_TABLE[iVar6].vector_290.y;
			globals::g_Struct2B0Unk_TABLE[iVar6].vector_290.z =
					 fVar3 * globals::g_Struct2B0Unk_TABLE[iVar6].vector_290.z;
			globals::g_Struct2B0Unk_TABLE[iVar6].field_2a0 = pLVar7;
			globals::g_Struct2B0Unk_TABLE[iVar6].field_29c = 0;
			pLVar7 = game::Game_CreateLiveResourceObject
												 ((Container *)liveObj,weaponType,param_5,0,param_2->x,param_2->y,0.0);
			globals::g_Struct2B0Unk_TABLE[iVar6].object_2a4 = pLVar7;
			res::Struct2B0_FUN_0046fbe0(globals::g_Struct2B0Unk_TABLE + iVar6,0.0);
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl
lego::tools::Weapon_UpdateRoutingUnk_FUN_0046ff30
					(undefined4 param_1,Vector3F *param_2,Vector3F *param_3,int param_4,
					WeaponKnownType knownWeapon)
{
	float fVar1;
	float fVar2;
	float fVar3;
	BOOL BVar4;
	int iVar5;
	LiveObject *pLVar6;
	float10 fVar7;
	int objIndex;
	ObjectType objType;
	Container *local_24;
	Point2F local_20;
	Point2F local_18;
	Point2F local_10;
	Point2F local_8;
	
	local_8.x = 0.0;
	local_8.y = 0.0;
	local_18.x = 1.0;
	local_18.y = -1.3;
	local_20.x = 0.3;
	local_20.y = 1.0;
	Weapon_GetObjectTypeIndex_ByKnownWeaponType(knownWeapon,&objType,&objIndex);
	BVar4 = game::Object_GetTypeResource(objType,objIndex,&local_24);
	if (BVar4 != 0) {
		iVar5 = unk::Lego_GetNextIndex_Struct2b0_TABLE_00504bc0();
		if (iVar5 != -1) {
			globals::g_Struct2B0Unk_TABLE[iVar5].field_2ac = knownWeapon;
			globals::g_Struct2B0Unk_TABLE[iVar5].weaponType = param_4;
			globals::g_Struct2B0Unk_TABLE[iVar5].unseen_0 = 1;
			globals::g_Struct2B0Unk_TABLE[iVar5].vector_268.x = param_2->x;
			globals::g_Struct2B0Unk_TABLE[iVar5].vector_268.y = param_2->y;
			globals::g_Struct2B0Unk_TABLE[iVar5].vector_268.z = param_2->z;
			globals::g_Struct2B0Unk_TABLE[iVar5].vector_274.x = param_2->x;
			globals::g_Struct2B0Unk_TABLE[iVar5].vector_274.y = param_2->y;
			globals::g_Struct2B0Unk_TABLE[iVar5].vector_274.z = param_2->z;
			globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.x = param_3->x - param_2->x;
			globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.y = param_3->y - param_2->y;
			globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.z = param_3->z - param_2->z;
			fVar1 = globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.y;
			fVar2 = globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.z;
			fVar3 = globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.x;
			fVar2 = 1.0 / SQRT(fVar3 * fVar3 + fVar2 * fVar2 + fVar1 * fVar1);
			globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.x =
					 globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.x * fVar2;
			fVar1 = globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.z;
			globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.y =
					 fVar2 * globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.y;
			globals::g_Struct2B0Unk_TABLE[iVar5].vector_290.z = fVar2 * fVar1;
			globals::g_Struct2B0Unk_TABLE[iVar5].float_28c = 4.0;
			fVar3 = param_2->y - param_3->y;
			fVar1 = param_2->z - param_3->z;
			fVar2 = param_2->x - param_3->x;
			local_10.y = param_3->z - param_2->z;
			fVar1 = SQRT(fVar2 * fVar2 + fVar1 * fVar1 + fVar3 * fVar3);
			local_10.x = fVar1;
			math::Routing_Maths_Vector2DChangeLength(&local_18,fVar1 * 0.2);
			math::Routing_Maths_Vector2DChangeLength(&local_20,fVar1 * 0.3333333);
			game::Routing_DoMath_FUN_00406750
								(&globals::g_Struct2B0Unk_TABLE[iVar5].routing,&local_8,&local_18,&local_10,
								 &local_20,50);
			fVar7 = game::Routing_UpdateDistances_RetTotal(&globals::g_Struct2B0Unk_TABLE[iVar5].routing);
			globals::g_Struct2B0Unk_TABLE[iVar5].unseen_260 = (float)fVar7;
			globals::g_Struct2B0Unk_TABLE[iVar5].float_264 = 0.0;
			globals::g_Struct2B0Unk_TABLE[iVar5].field_2a0 = param_1;
			globals::g_Struct2B0Unk_TABLE[iVar5].field_29c = 0;
			pLVar6 = game::Game_CreateLiveResourceObject
												 (local_24,objType,objIndex,0,param_2->x,param_2->y,0.0);
			globals::g_Struct2B0Unk_TABLE[iVar5].object_2a4 = pLVar6;
			res::Struct2B0_FUN_0046fbe0(globals::g_Struct2B0Unk_TABLE + iVar5,0.0);
			return TRUE;
		}
	}
	return 0;
}



void __cdecl
lego::tools::Weapon_GetObjectTypeIndex_ByKnownWeaponType
					(WeaponKnownType knownWeapon,ObjectType *out_objType,int *out_objIndex)
{
	switch(knownWeapon) {
	case WEAPONKNOWN_LAZER_1:
		*out_objType = OBJECT_LASERSHOT;
		*out_objIndex = 0;
		return;
	case WEAPONKNOWN_PUSHER:
		*out_objType = OBJECT_PUSHER;
		*out_objIndex = 0;
		return;
	case WEAPONKNOWN_FREEZER:
		*out_objType = OBJECT_FREEZER;
		*out_objIndex = 0;
		return;
	case WEAPONKNOWN_LAZER_4:
		*out_objType = OBJECT_BOULDER;
		*out_objIndex = 0;
	}
	return;
}



int __cdecl lego::unk::Lego_GetNextIndex_Struct2b0_TABLE_00504bc0(void)
{
	int iVar1;
	LiveObject **ppLVar2;
	
	iVar1 = 0;
	ppLVar2 = &globals::g_Struct2B0Unk_TABLE[0].object_2a4;
	do {
		if (*ppLVar2 == NULL) {
			return iVar1;
		}
		ppLVar2 = ppLVar2 + 0xac;
		iVar1 += 1;
	} while (ppLVar2 < globs::s_FormatPartName_name + 0x2a0);
	return -1;
}



int __cdecl lego::res::ItemStruct34_GetTableCount(void)
{
	int iVar1;
	ItemStruct_34 *pIVar2;
	
	iVar1 = 0;
	pIVar2 = globals::g_ItemStruct34Unk_TABLE;
	do {
		if (((Struct_2b0 *)pIVar2)->unseen_0 == 0) {
			return iVar1;
		}
		pIVar2 = (ItemStruct_34 *)((((Struct_2b0 *)pIVar2)->routing).points + 1);
		iVar1 += 1;
	} while (pIVar2 < globals::g_Struct2B0Unk_TABLE);
	return -1;
}



LiveObject * __cdecl
lego::tools::Weapon_DoLaserUnk_FUN_00470270
					(Vector3F *sndPosition,Vector3F *param_2,LiveObject *in_liveObj,float param_4,
					float param_5,int param_6,float param_7)
{
	TerrainType TVar1;
	Container *resData;
	SurfaceMap *surfMap;
	BOOL BVar2;
	LevelData *level;
	float10 fVar3;
	float fVar4;
	float fVar5;
	LiveObject *opt_position;
	Point2F *pPVar6;
	Vector3F *vector2;
	float *out_by;
	float local_24;
	Point2F local_20;
	Vector3F local_18;
	Vector3F local_c;
	
	opt_position = (LiveObject *)sndPosition;
	local_24 = 1.0;
	sndPosition = NULL;
	res::SFX_Sample_Container_Random_Play_OrInitSoundUnk
						(NULL,SFX_LASER,FALSE,FALSE,(Vector3F *)opt_position);
	local_18.x = param_5 * param_2->x;
	local_18.y = param_5 * param_2->y;
	local_18.z = param_2->z * param_5;
	game::Game_DoCallbacksSearch_FUN_00471b20
						((Vector3F *)opt_position,&local_18,(LiveObject **)&sndPosition,&local_24,in_liveObj);
	local_18.x = local_24 * local_18.x;
	local_18.y = local_24 * local_18.y;
	local_18.z = local_24 * local_18.z;
	local_c.x = local_18.x + ((Vector3F *)opt_position)->x;
	local_c.y = ((Vector3F *)opt_position)->y + local_18.y;
	local_c.z = (float)((Vector3F *)opt_position)->z + local_18.z;
	vector2 = &local_c;
	resData = game::LiveObject_GetContainer(in_liveObj);
	res::ItemStruct34_FUN_00470950(resData,(Vector3F *)opt_position,vector2);
	if (((LiveObject *)sndPosition != NULL) || (1.0 <= local_24)) {
		if ((LiveObject *)sndPosition != NULL) {
			effect::Effect_Spawn_Particle(MISCOBJECT_LAZERHIT,&local_c,NULL);
			res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(NULL,SFX_LASERHIT,0,0,&local_c);
			if ((LiveObject *)sndPosition != NULL) {
				if ((in_liveObj == NULL) || (in_liveObj->objType != OBJECT_MINIFIGURE)) {
					pPVar6 = NULL;
				}
				else {
					local_20.x = param_2->x;
					local_20.y = param_2->y;
					pPVar6 = &local_20;
				}
				game::LiveObject_FUN_00447c10((LiveObject *)sndPosition,pPVar6,1);
			}
		}
	}
	else {
		effect::Effect_Spawn_BoulderExplode_AtWorldPos(&local_c);
		res::SFX_Sample_Container_Random_Play_OrInitSoundUnk(NULL,SFX_LASERHIT,0,0,&local_c);
		out_by = &local_20.y;
		pPVar6 = &local_20;
		fVar4 = local_c.x;
		fVar5 = local_c.y;
		surfMap = game::GetSurfaceMap();
		game::Map3D_WorldToBlockPos_NoZ(surfMap,fVar4,fVar5,(int *)pPVar6,(int *)out_by);
		BVar2 = game::Level_GetBlockFlags1_10Not8((uint)local_20.x,(uint)local_20.y);
		if (BVar2 != 0) {
			BVar2 = game::Level_Block_IsImmovable((Point2I *)&local_20);
			if ((BVar2 == 0) &&
				 (TVar1 = (globs::gameGlobs.level)->blocks
									[((globs::gameGlobs.level)->dimensions).width * (int)local_20.y + (int)local_20.x]
									.terrain, TVar1 != TERRAIN_RECHARGESEAM)) {
				fVar3 = Weapon_GetWallDestroyTime(param_6,(uint)TVar1);
				BVar2 = game::Level_Block_GetUnkField14Test
													((int)local_20.x,(int)local_20.y,(float)fVar3,param_4);
				if (BVar2 != 0) {
					BVar2 = 0;
					fVar4 = local_20.x;
					fVar5 = local_20.y;
					level = game::GetLevel();
					game::Level_DestroyWall(level,(int)fVar4,(int)fVar5,BVar2);
				}
				goto LAB_004704fa;
			}
		}
		BVar2 = game::Level_Block_IsPowerPath((Point2I *)&local_20);
		if (BVar2 != 0) {
			ai::AITask_DoClearTypeAction((Point2I *)&local_20,MESSAGE_CLEARREMOVEPATH_COMPLETE);
			game::Level_UpdateBlockSurfaceUnk(globs::gameGlobs.level,(int)local_20.x,(int)local_20.y,0);
		}
	}
LAB_004704fa:
	game::LiveObject_Weapon_FUN_004375c0(in_liveObj,param_6,param_7);
	return (LiveObject *)sndPosition;
}



BOOL __cdecl
lego::game::LiveObject_Collision_FUN_00470520
					(LiveObject *liveObj,Point2F *param_2,Point2F *param_3,BOOL param_4)
{
	ObjectStatsFlags1 OVar1;
	BOOL BVar2;
	
	OVar1 = LiveObject_GetStatsFlags1(liveObj);
	if ((OVar1 & STATS1_COLLBOX) != STATS1_NONE) {
		BVar2 = LiveObject_CollisionBox_FUN_00470570(liveObj,param_2,param_3,NULL,param_4);
		return BVar2;
	}
	BVar2 = LiveObject_CollisionRadius_FUN_00470800(liveObj,param_2,param_3,param_4);
	return BVar2;
}



BOOL __cdecl
lego::game::LiveObject_CollisionBox_FUN_00470570
					(LiveObject *liveObj,Point2F *param_2,Point2F *param_3,Point2F *optout_point,BOOL param_5)
{
	float fVar1;
	ushort uVar2;
	Container *cont;
	BOOL BVar3;
	float *pfVar4;
	int iVar5;
	Point2F *pPVar6;
	Vector3F *out_vector;
	Point2F *pPVar7;
	uint uVar8;
	Point2F local_78;
	Point2F local_70;
	Point2F local_68;
	Point2F local_60;
	Point2F local_58;
	float local_50 [6];
	float local_38;
	float local_34;
	Vector3F local_30;
	float local_24;
	undefined4 local_20;
	float local_1c;
	float local_18;
	undefined4 local_14;
	float local_10;
	float local_c;
	undefined4 local_8;
	float local_4;
	
	cont = LiveObject_GetContainer(liveObj);
	local_68.x = param_2->x;
	local_68.y = param_2->y;
	local_70.x = param_3->x;
	local_70.y = param_3->y;
	if ((param_5 != 0) &&
		 (BVar3 = LiveObject_TestCollision_FUN_004708f0(liveObj,&local_68,&local_70), BVar3 != 0)) {
		return 0;
	}
	pfVar4 = (float *)LiveObject_GetCollBox(liveObj);
	local_30.x = *pfVar4 * -0.5;
	iVar5 = LiveObject_GetCollBox(liveObj);
	local_30.z = *(float *)(iVar5 + 4) * 0.5;
	pfVar4 = (float *)LiveObject_GetCollBox(liveObj);
	local_24 = *pfVar4 * 0.5;
	iVar5 = LiveObject_GetCollBox(liveObj);
	local_1c = *(float *)(iVar5 + 4) * 0.5;
	pfVar4 = (float *)LiveObject_GetCollBox(liveObj);
	local_18 = *pfVar4 * 0.5;
	iVar5 = LiveObject_GetCollBox(liveObj);
	local_10 = *(float *)(iVar5 + 4) * -0.5;
	pfVar4 = (float *)LiveObject_GetCollBox(liveObj);
	local_c = *pfVar4 * -0.5;
	iVar5 = LiveObject_GetCollBox(liveObj);
	local_4 = *(float *)(iVar5 + 4) * -0.5;
	local_8 = 0;
	local_14 = 0;
	local_20 = 0;
	local_30.y = 0.0;
	pPVar7 = &local_58;
	out_vector = &local_30;
	iVar5 = 4;
	do {
		res::Container_Transform(cont,out_vector,out_vector);
		fVar1 = out_vector->y;
		pPVar7->x = out_vector->x;
		pPVar7->y = fVar1;
		out_vector = out_vector + 1;
		pPVar7 = pPVar7 + 1;
		iVar5 += -1;
	} while (iVar5 != 0);
	local_38 = local_58.x;
	local_34 = local_58.y;
	uVar8 = 0;
	pPVar7 = &local_58;
	do {
		local_60.x = pPVar7->x - pPVar7[1].x;
		local_60.y = pPVar7->y - pPVar7[1].y;
		pPVar6 = math::Maths_Vector2DIntersection(&local_78,&local_68,&local_70,pPVar7,&local_60);
		if (pPVar6 != NULL) {
			if (ABS(pPVar7->x - pPVar7[1].x) <= ABS(pPVar7->y - pPVar7[1].y)) {
				if (((ushort)((ushort)(local_78.y < pPVar7->y) << 8 |
										 (ushort)(local_78.y == pPVar7->y) << 0xe) == 0) && (local_78.y < pPVar7[1].y))
				goto LAB_004707ca;
				if (local_78.y < pPVar7->y) {
					uVar2 = (ushort)(local_78.y < pPVar7[1].y) << 8 |
									(ushort)(local_78.y == pPVar7[1].y) << 0xe;
					goto joined_r0x004707b1;
				}
			}
			else {
				if (((ushort)((ushort)(local_78.x < pPVar7->x) << 8 |
										 (ushort)(local_78.x == pPVar7->x) << 0xe) == 0) && (local_78.x < pPVar7[1].x))
				goto LAB_004707ca;
				if (local_78.x < pPVar7->x) {
					uVar2 = (ushort)(local_78.x < pPVar7[1].x) << 8 |
									(ushort)(local_78.x == pPVar7[1].x) << 0xe;
joined_r0x004707b1:
					if (uVar2 == 0) {
LAB_004707ca:
						if (optout_point != NULL) {
							optout_point->x = local_78.x;
							optout_point->y = local_78.y;
						}
						return TRUE;
					}
				}
			}
		}
		uVar8 += 1;
		pPVar7 = pPVar7 + 1;
		if (3 < uVar8) {
			return 0;
		}
	} while( true );
}



BOOL __cdecl
lego::game::LiveObject_CollisionRadius_FUN_00470800
					(LiveObject *liveObj,Point2F *param_2,Point2F *param_3,BOOL param_4)
{
	BOOL BVar1;
	float10 fVar2;
	Point2F local_28;
	Point2F local_20;
	Point2F local_18;
	Point2F local_10;
	Point2F local_8;
	
	local_28.x = param_2->x;
	local_28.y = param_2->y;
	local_20.x = param_3->x;
	local_20.y = param_3->y;
	if ((param_4 != 0) &&
		 (BVar1 = LiveObject_TestCollision_FUN_004708f0(liveObj,&local_28,&local_20), BVar1 != 0)) {
		return 0;
	}
	local_10.x = local_20.x + local_28.x;
	local_10.y = local_20.y + local_28.y;
	LiveObject_GetPosition(liveObj,(float *)&local_18,&local_18.y);
	Collision_Maths_FUN_00408a90(&local_28,&local_10,&local_18,&local_8);
	fVar2 = LiveObject_GetCollRadius(liveObj);
	if (fVar2 <= (float10)SQRT((local_8.y - local_18.y) * (local_8.y - local_18.y) +
														 (local_8.x - local_18.x) * (local_8.x - local_18.x))) {
		return 0;
	}
	return TRUE;
}



BOOL __cdecl
lego::game::LiveObject_TestCollision_FUN_004708f0
					(LiveObject *liveObj,Point2F *param_2,Point2F *param_3)
{
	float local_8;
	float local_4;
	
	LiveObject_GetPosition(liveObj,&local_8,&local_4);
	if ((local_8 - param_2->x) * param_3->x + (local_4 - param_2->y) * param_3->y < 0.0) {
		return TRUE;
	}
	return 0;
}



void __cdecl
lego::res::ItemStruct34_FUN_00470950(Container *resData,Vector3F *vector1,Vector3F *vector2)
{
	int iVar1;
	Mesh *pMVar2;
	
	iVar1 = ItemStruct34_GetTableCount();
	if (iVar1 != -1) {
		pMVar2 = Mesh_CreateOnFrame(resData->activityFrame,NULL,0x4400,NULL,MESH_TYPE_NORM);
		globals::g_ItemStruct34Unk_TABLE[iVar1].struct34_1 = pMVar2;
		pMVar2 = Mesh_CreateOnFrame(resData->activityFrame,NULL,0x4400,NULL,MESH_TYPE_NORM);
		globals::g_ItemStruct34Unk_TABLE[iVar1].struct34_2 = pMVar2;
		Struct34_FUN_00470a20
							(globals::g_ItemStruct34Unk_TABLE[iVar1].struct34_1,0.3,vector1,vector2,0.6,0.6,0.6,
							 1.0);
		Struct34_FUN_00470a20
							(globals::g_ItemStruct34Unk_TABLE[iVar1].struct34_2,1.0,vector1,vector2,0.1,0.2,0.5,
							 1.0);
		globals::g_ItemStruct34Unk_TABLE[iVar1].resData = resData;
		globals::g_ItemStruct34Unk_TABLE[iVar1].time = 5.0;
	}
	return;
}



void __cdecl
lego::res::Struct34_FUN_00470a20
					(Mesh *param_1,float scalar,Vector3F *vector1,Vector3F *vector2,float param_5,
					float param_6,float param_7,float param_8)
{
	float *pfVar1;
	float *pfVar2;
	float *pfVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	float fVar9;
	float fVar10;
	float fVar11;
	float fVar12;
	float fVar13;
	Vector3F *pVVar14;
	D3DRMGroupIndex groupID;
	uint uVar15;
	uint uVar16;
	float local_404;
	float local_400;
	uint local_3e0;
	undefined4 local_3dc;
	undefined4 local_3d8;
	undefined4 local_3d4;
	undefined4 local_3d0;
	undefined4 local_3cc;
	undefined4 local_3c8;
	undefined4 local_3c4;
	undefined4 local_3c0;
	undefined4 local_3bc;
	undefined4 local_3b8;
	undefined4 local_3b4;
	undefined4 local_3b0;
	undefined4 local_3ac;
	undefined4 local_3a8;
	undefined4 local_3a4;
	undefined4 local_3a0;
	undefined4 local_39c;
	undefined4 local_398;
	undefined4 local_394;
	undefined4 local_390;
	undefined4 local_38c;
	undefined4 local_388;
	undefined4 local_384;
	undefined4 local_380;
	undefined4 local_37c;
	undefined4 local_378;
	undefined4 local_374;
	undefined4 local_370;
	undefined4 local_36c;
	undefined4 local_368;
	undefined4 local_364;
	undefined4 local_360;
	undefined4 local_35c;
	undefined4 local_358;
	undefined4 local_354;
	undefined4 local_350;
	undefined4 local_34c;
	undefined4 local_348;
	undefined4 local_344;
	undefined4 local_340;
	undefined4 local_33c;
	undefined4 local_338;
	undefined4 local_334;
	undefined4 local_330;
	undefined4 local_32c;
	undefined4 local_328;
	undefined4 local_324;
	Point2F local_320;
	undefined4 local_318;
	undefined4 local_314;
	undefined4 local_310;
	undefined4 local_30c;
	undefined4 local_308;
	undefined4 local_304;
	undefined4 local_300;
	undefined4 local_2fc;
	undefined4 local_2f8;
	undefined4 local_2f4;
	undefined4 local_2f0;
	undefined4 local_2ec;
	undefined4 local_2e8;
	undefined4 local_2e4;
	undefined4 local_2e0;
	undefined4 local_2dc;
	undefined4 local_2d8;
	undefined4 local_2d4;
	undefined4 local_2d0;
	undefined4 local_2cc;
	undefined4 local_2c8;
	undefined4 local_2c4;
	undefined4 local_2c0;
	undefined4 local_2bc;
	undefined4 local_2b8;
	undefined4 local_2b4;
	undefined4 local_2b0;
	undefined4 local_2ac;
	undefined4 local_2a8;
	undefined4 local_2a4;
	undefined4 local_2a0;
	undefined4 local_29c;
	undefined4 local_298;
	undefined4 local_294;
	undefined4 local_290;
	undefined4 local_28c;
	undefined4 local_288;
	undefined4 local_284;
	undefined4 local_280;
	undefined4 local_27c;
	undefined4 local_278;
	undefined4 local_274;
	undefined4 local_270;
	undefined4 local_26c;
	undefined4 local_268;
	undefined4 local_264;
	undefined4 local_260;
	undefined4 local_25c;
	undefined4 local_258;
	undefined4 local_254;
	undefined4 local_250;
	undefined4 local_24c;
	undefined4 local_248;
	undefined4 local_244;
	undefined4 local_240;
	undefined4 local_23c;
	undefined4 local_238;
	undefined4 local_234;
	undefined4 local_230;
	undefined4 local_22c;
	undefined4 local_228;
	undefined4 local_224;
	undefined4 local_220;
	undefined4 local_21c;
	undefined4 local_218;
	undefined4 local_214;
	undefined4 local_210;
	undefined4 local_20c;
	undefined4 local_208;
	undefined4 local_204;
	undefined4 local_200;
	undefined4 local_1fc;
	undefined4 local_1f8;
	undefined4 local_1f4;
	undefined4 local_1f0;
	undefined4 local_1ec;
	undefined4 local_1e8;
	undefined4 local_1e4;
	undefined4 local_1e0;
	undefined4 local_1dc;
	undefined4 local_1d8;
	undefined4 local_1d4;
	undefined4 local_1d0;
	undefined4 local_1cc;
	undefined4 local_1c8;
	undefined4 local_1c4;
	undefined4 local_1c0;
	undefined4 local_1bc;
	undefined4 local_1b8;
	undefined4 local_1b4;
	undefined4 local_1b0;
	undefined4 local_1ac;
	undefined4 local_1a8;
	undefined4 local_1a4;
	undefined4 local_1a0;
	undefined4 local_19c;
	undefined4 local_198;
	undefined4 local_194;
	undefined4 local_190;
	undefined4 local_18c;
	undefined4 local_188;
	undefined4 local_184;
	undefined4 local_180;
	undefined4 local_17c;
	undefined4 local_178;
	undefined4 local_174;
	undefined4 local_170;
	undefined4 local_16c;
	undefined4 local_168;
	undefined4 local_164;
	undefined4 local_160;
	undefined4 local_15c;
	undefined4 local_158;
	undefined4 local_154;
	undefined4 local_150;
	undefined4 local_14c;
	undefined4 local_148;
	undefined4 local_144;
	undefined4 local_140;
	undefined4 local_13c;
	undefined4 local_138;
	undefined4 local_134;
	undefined4 local_130;
	undefined4 local_12c;
	undefined4 local_128;
	undefined4 local_124;
	Vector3F local_120;
	float local_114;
	float local_110;
	float local_10c;
	float local_108;
	float local_104;
	float local_100;
	float local_fc;
	float local_f8;
	float local_f4;
	float local_f0;
	float local_ec;
	float local_e8;
	float local_e4;
	float local_e0;
	float local_dc;
	float local_d8;
	float local_d4;
	float local_d0;
	float local_cc;
	float local_c8;
	float local_c4;
	float afStack192 [24];
	Vector3F local_60 [8];
	
	local_320.y = 1.0;
	local_310 = 0x3f800000;
	local_308 = 0x3f800000;
	local_304 = 0x3f800000;
	local_2fc = 0x3f800000;
	local_2f0 = 0x3f800000;
	local_2e8 = 0x3f800000;
	local_2e4 = 0x3f800000;
	local_2dc = 0x3f800000;
	local_2d0 = 0x3f800000;
	local_2c8 = 0x3f800000;
	local_2c4 = 0x3f800000;
	local_2bc = 0x3f800000;
	local_2b0 = 0x3f800000;
	local_2a8 = 0x3f800000;
	local_2a4 = 0x3f800000;
	local_29c = 0x3f800000;
	local_290 = 0x3f800000;
	local_288 = 0x3f800000;
	local_284 = 0x3f800000;
	local_27c = 0x3f800000;
	local_270 = 0x3f800000;
	local_268 = 0x3f800000;
	local_264 = 0x3f800000;
	local_25c = 0x3f800000;
	local_250 = 0x3f800000;
	local_248 = 0x3f800000;
	local_244 = 0x3f800000;
	local_23c = 0x3f800000;
	local_230 = 0x3f800000;
	local_228 = 0x3f800000;
	local_224 = 0x3f800000;
	local_21c = 0x3f800000;
	local_210 = 0x3f800000;
	local_208 = 0x3f800000;
	local_204 = 0x3f800000;
	local_1fc = 0x3f800000;
	local_320.x = 0.0;
	local_318 = 0;
	local_314 = 0;
	local_30c = 0;
	local_300 = 0;
	local_2f8 = 0;
	local_2f4 = 0;
	local_2ec = 0;
	local_2e0 = 0;
	local_2d8 = 0;
	local_2d4 = 0;
	local_2cc = 0;
	local_2c0 = 0;
	local_2b8 = 0;
	local_2b4 = 0;
	local_2ac = 0;
	local_2a0 = 0;
	local_298 = 0;
	local_294 = 0;
	local_28c = 0;
	local_280 = 0;
	local_278 = 0;
	local_274 = 0;
	local_26c = 0;
	local_260 = 0;
	local_258 = 0;
	local_254 = 0;
	local_24c = 0;
	local_240 = 0;
	local_238 = 0;
	local_234 = 0;
	local_22c = 0;
	local_220 = 0;
	local_218 = 0;
	local_214 = 0;
	local_20c = 0;
	local_200 = 0;
	local_1f8 = 0;
	local_1f4 = 0;
	local_1f0 = 0x3f800000;
	local_1e8 = 0x3f800000;
	local_1e4 = 0x3f800000;
	local_1dc = 0x3f800000;
	local_1d0 = 0x3f800000;
	local_1c8 = 0x3f800000;
	local_1c4 = 0x3f800000;
	local_1bc = 0x3f800000;
	local_1b0 = 0x3f800000;
	local_1a8 = 0x3f800000;
	local_1a4 = 0x3f800000;
	local_19c = 0x3f800000;
	local_190 = 0x3f800000;
	local_188 = 0x3f800000;
	local_184 = 0x3f800000;
	local_17c = 0x3f800000;
	local_170 = 0x3f800000;
	local_168 = 0x3f800000;
	local_164 = 0x3f800000;
	local_15c = 0x3f800000;
	local_150 = 0x3f800000;
	local_148 = 0x3f800000;
	local_144 = 0x3f800000;
	local_13c = 0x3f800000;
	local_130 = 0x3f800000;
	local_128 = 0x3f800000;
	local_124 = 0x3f800000;
	local_3dc = 1;
	local_3d8 = 9;
	local_3d4 = 9;
	local_3c8 = 1;
	local_3c0 = 10;
	local_3bc = 10;
	local_3b8 = 9;
	local_3b4 = 1;
	local_3a0 = 10;
	local_1ec = 0;
	local_1e0 = 0;
	local_1d8 = 0;
	local_1d4 = 0;
	local_1cc = 0;
	local_1c0 = 0;
	local_1b8 = 0;
	local_1b4 = 0;
	local_1ac = 0;
	local_1a0 = 0;
	local_198 = 0;
	local_194 = 0;
	local_18c = 0;
	local_180 = 0;
	local_178 = 0;
	local_174 = 0;
	local_16c = 0;
	local_160 = 0;
	local_158 = 0;
	local_154 = 0;
	local_14c = 0;
	local_140 = 0;
	local_138 = 0;
	local_134 = 0;
	local_12c = 0;
	local_3e0 = 0;
	local_3d0 = 8;
	local_3cc = 0;
	local_3c4 = 2;
	local_3b0 = 2;
	local_3ac = 3;
	local_3a8 = 0xb;
	local_3a4 = 0xb;
	local_39c = 2;
	local_398 = 3;
	local_394 = 4;
	local_384 = 3;
	local_390 = 0xc;
	local_38c = 0xc;
	local_370 = 0xc;
	local_378 = 0xd;
	local_374 = 0xd;
	local_358 = 0xd;
	local_360 = 0xe;
	local_35c = 0xe;
	local_340 = 0xe;
	local_348 = 0xf;
	local_344 = 0xf;
	local_328 = 0xf;
	local_388 = 0xb;
	fVar6 = vector2->x - vector1->x;
	fVar7 = vector2->y - vector1->y;
	fVar5 = vector2->z - vector1->z;
	local_380 = 4;
	local_36c = 4;
	local_37c = 5;
	local_368 = 5;
	local_364 = 6;
	local_354 = 5;
	local_350 = 6;
	local_34c = 7;
	local_33c = 6;
	local_338 = 7;
	local_334 = 0;
	local_330 = 8;
	local_32c = 8;
	local_324 = 7;
	fVar4 = 1.0 / SQRT(fVar5 * fVar5 + fVar7 * fVar7 + fVar6 * fVar6);
	fVar7 = fVar4 * fVar7;
	fVar5 = fVar4 * fVar5;
	if ((fVar7 == 0.0) && (fVar5 == 0.0)) {
		local_400 = 1.0;
		local_404 = 0.0;
	}
	else {
		if (fVar7 == 0.0) {
			local_404 = 1.0;
			local_400 = 0.0;
		}
		else {
			local_400 = SQRT(1.0 / ((fVar5 * fVar5) / (fVar7 * fVar7) - -1.0));
			local_404 = -((fVar5 / fVar7) * local_400);
		}
	}
	fVar8 = local_404 * scalar;
	fVar9 = local_400 * scalar;
	fVar5 = (local_400 * fVar7 - local_404 * fVar5) * scalar;
	fVar7 = -(local_400 * fVar4 * fVar6) * scalar;
	fVar6 = local_404 * fVar4 * fVar6 * scalar;
	fVar12 = fVar8 * 0.4142136;
	fVar4 = fVar5 * 0.4142136;
	fVar10 = fVar7 * 0.4142136;
	fVar11 = fVar6 * 0.4142136;
	fVar13 = fVar9 * 0.4142136;
	local_120.x = fVar4 + 0.0;
	local_120.y = fVar8 + fVar10;
	local_120.z = fVar9 + fVar11;
	local_114 = fVar5 + 0.0;
	local_110 = fVar7 + fVar12;
	local_10c = fVar6 + fVar13;
	local_108 = fVar5 + -0.0;
	local_104 = fVar7 + -fVar12;
	local_100 = fVar6 + -fVar13;
	local_fc = fVar4 - 0.0;
	local_f8 = fVar10 - fVar8;
	local_f4 = fVar11 - fVar9;
	local_f0 = -0.0 - fVar4;
	local_ec = -fVar8 - fVar10;
	local_e8 = -fVar9 - fVar11;
	local_e4 = -0.0 - fVar5;
	local_e0 = -fVar12 - fVar7;
	local_dc = -fVar13 - fVar6;
	local_d8 = 0.0 - fVar5;
	local_d4 = fVar12 - fVar7;
	local_d0 = fVar13 - fVar6;
	local_cc = 0.0 - fVar4;
	local_c8 = fVar8 - fVar10;
	local_c4 = fVar9 - fVar11;
	pVVar14 = &local_120;
	uVar15 = 0;
	do {
		fVar4 = vector2->x;
		pfVar3 = (float *)((int)&local_60[0].z + uVar15);
		fVar5 = pVVar14->x;
		fVar6 = pVVar14->y;
		*(float *)((int)&local_60[0].x + uVar15) = pVVar14->x;
		pfVar1 = &pVVar14->y;
		fVar7 = pVVar14->z;
		uVar16 = uVar15 + 0xc;
		*(float *)((int)&local_60[0].y + uVar15) = fVar6;
		pfVar2 = &pVVar14->z;
		*pfVar3 = fVar7;
		fVar7 = *(float *)((int)&local_60[0].y + uVar15);
		fVar6 = *(float *)((int)&local_60[0].x + uVar15);
		fVar8 = *pfVar3;
		*(float *)((int)afStack192 + uVar15) = fVar4 + fVar5;
		fVar9 = 1.0 / SQRT(fVar6 * fVar6 + fVar8 * fVar8 + fVar7 * fVar7);
		*(float *)((int)afStack192 + uVar15 + 4) = *pfVar1 + vector2->y;
		fVar4 = vector1->x;
		pVVar14[8].z = *pfVar2 + vector2->z;
		fVar5 = *(float *)((int)&local_60[0].x + uVar15);
		pVVar14->x = fVar4 + pVVar14->x;
		fVar4 = *(float *)((int)&local_60[0].y + uVar15);
		fVar6 = *pfVar3;
		*pfVar1 = *pfVar1 + vector1->y;
		fVar7 = *pfVar2;
		fVar8 = vector1->z;
		*(float *)((int)&local_60[0].x + uVar15) = fVar9 * fVar5;
		*(float *)((int)&local_60[0].y + uVar15) = fVar9 * fVar4;
		*pfVar3 = fVar9 * fVar6;
		*pfVar2 = fVar7 + fVar8;
		pVVar14 = pVVar14 + 1;
		uVar15 = uVar16;
	} while (uVar16 < 0x60);
	groupID = Mesh_AddGroup(param_1,0x10,0x10,3,&local_3e0);
	Mesh_SetGroupColour(param_1,groupID,param_5,param_6,param_7,MATERIAL_EMISSIVE);
	Mesh_SetGroupMaterialValues(param_1,groupID,param_8,MATERIAL_ALPHA);
	Mesh_SetVertices_SameNormal(param_1,groupID,0,0x10,&local_120,local_60,&local_320);
	return;
}



void * __cdecl lego::game::LiveObject_GetBuildingVehicleFields_138_a0(LiveObject *liveObj)
{
	if (liveObj->objType == OBJECT_VEHICLE) {
		return (void *)&liveObj->vehicle->field_0x138;
	}
	if (liveObj->objType != OBJECT_BUILDING) {
		return NULL;
	}
	return (void *)&liveObj->building->field_0xa0;
}



float10 __cdecl lego::game::LiveObject_PtrGetter_FUN_004715b0(LiveObject *liveObj,int param_2)
{
	void *pvVar1;
	
	pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
	return (float10)*(float *)((int)pvVar1 + param_2 * 4 + 0x98);
}



void __cdecl
lego::game::LiveObject_PtrSetter_FUN_004715d0(LiveObject *liveObj,undefined4 param_2,int param_3)
{
	void *pvVar1;
	
	pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
	*(undefined4 *)((int)pvVar1 + param_3 * 4 + 0x98) = param_2;
	return;
}



BOOL __cdecl
lego::math::MathUnk_CheckVectorsZScalar_InRange
					(Vector3F *vectorPos,Vector3F *vectorScaled,float minZ,float maxZ,float scalar)
{
	float fVar1;
	
	fVar1 = vectorScaled->z * scalar + vectorPos->z;
	if (((ushort)((ushort)(fVar1 < maxZ) << 8 | (ushort)(fVar1 == maxZ) << 0xe) != 0) &&
		 (maxZ - minZ <= fVar1)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_Callback_FUN_00471630(LiveObject *liveObj,SearchData18_2 *search)
{
	float fVar1;
	SearchData18_2 *pSVar2;
	SurfaceMap *surfMap;
	BOOL BVar3;
	float10 fVar4;
	float fVar5;
	float maxZ;
	float fVar6;
	float scalar;
	SearchData18_2 *scalar_00;
	Point2F local_28;
	float local_20;
	float local_1c;
	Point2F local_18;
	Point2F local_10;
	Point2F local_8;
	
	pSVar2 = search;
	local_8.x = search->vectorp_8->x;
	local_8.y = search->vectorp_8->y;
	local_28.x = search->vectorp_c->x;
	local_28.y = search->vectorp_c->y;
	fVar1 = SQRT(local_28.y * local_28.y + local_28.x * local_28.x);
	if ((liveObj != (LiveObject *)search->field_14) &&
		 (((ushort)((ushort)(fVar1 < -1e-05) << 8 | (ushort)(fVar1 == -1e-05) << 0xe) != 0 ||
			(1e-05 <= fVar1)))) {
		LiveObject_GetPosition(liveObj,(float *)&local_18,&local_18.y);
		fVar5 = local_18.x;
		fVar6 = local_18.y;
		surfMap = GetSurfaceMap();
		fVar4 = Map3D_GetWorldZ(surfMap,fVar5,fVar6);
		fVar5 = (float)fVar4;
		math::Collision_MathUnk_Vector2D_FUN_00408b20(&local_8,&local_28,&local_18,&local_10);
		local_18.x = local_10.x - local_18.x;
		local_18.y = local_10.y - local_18.y;
		fVar4 = LiveObject_GetCollRadius(liveObj);
		if ((float10)SQRT(local_18.y * local_18.y + local_18.x * local_18.x) <= fVar4) {
			local_20 = local_10.x - local_8.x;
			local_1c = local_10.y - local_8.y;
			fVar6 = SQRT(local_1c * local_1c + local_20 * local_20);
			if (((ushort)((ushort)(fVar6 < -1e-05) << 8 | (ushort)(fVar6 == -1e-05) << 0xe) == 0) &&
				 (fVar6 < 1e-05)) {
				scalar = 0.0;
				maxZ = fVar5;
				fVar4 = LiveObject_GetCollHeight(liveObj);
				BVar3 = math::MathUnk_CheckVectorsZScalar_InRange
													(search->vectorp_8,search->vectorp_c,(float)fVar4,maxZ,scalar);
				if (BVar3 != 0) {
					search->field_0 = liveObj;
					search->ref_float_4 = 0.0;
					search->field_10 = 1;
					return 0;
				}
			}
			search = (SearchData18_2 *)(fVar6 / fVar1);
			if (((((ushort)((ushort)(local_28.x < -1e-05) << 8 | (ushort)(local_28.x == -1e-05) << 0xe) !=
						 0) || (1e-05 <= local_28.x)) ||
					((ushort)((ushort)(local_20 < -1e-05) << 8 | (ushort)(local_20 == -1e-05) << 0xe) != 0))
				 || (1e-05 <= local_20)) {
				fVar1 = local_28.x / local_20;
			}
			else {
				if ((((ushort)((ushort)(local_28.y < -1e-05) << 8 | (ushort)(local_28.y == -1e-05) << 0xe)
							== 0) && (local_28.y < 1e-05)) &&
					 (((ushort)((ushort)(local_1c < -1e-05) << 8 | (ushort)(local_1c == -1e-05) << 0xe) == 0
						&& (local_1c < 1e-05)))) {
					return 0;
				}
				fVar1 = local_28.y / local_1c;
			}
			if (fVar1 < 0.0) {
				search = (SearchData18_2 *)((float)search * -1.0);
			}
			if (((ushort)((ushort)((float)search < 0.0) << 8 | (ushort)((float)search == 0.0) << 0xe) == 0
					) && ((float)search < pSVar2->ref_float_4)) {
				scalar_00 = search;
				fVar4 = LiveObject_GetCollHeight(liveObj);
				BVar3 = math::MathUnk_CheckVectorsZScalar_InRange
													(pSVar2->vectorp_8,pSVar2->vectorp_c,(float)fVar4,fVar5,(float)scalar_00);
				if (BVar3 != 0) {
					pSVar2->field_0 = liveObj;
					pSVar2->ref_float_4 = (float)search;
					pSVar2->field_10 = TRUE;
				}
			}
		}
	}
	return 0;
}



void __cdecl FUN_004718f0(SearchData18_2 *search)
{
	SurfaceMap *pSVar1;
	BOOL BVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	uint uVar7;
	float fVar8;
	float fVar9;
	Vector3F *pVVar10;
	uint *puVar11;
	uint *puVar12;
	Vector3F *pVVar13;
	Vector3F *pVVar14;
	uint local_34;
	uint local_30;
	uint local_2c;
	uint local_28;
	float local_24;
	float local_20;
	float local_1c;
	Vector3F local_18;
	float local_8;
	float local_4;
	
	lego::game::GetSurfaceMap();
	lego::game::GetSurfaceMap();
	puVar11 = &local_28;
	pVVar14 = search->vectorp_c;
	pVVar13 = search->vectorp_8;
	local_18.x = pVVar14->x + pVVar13->x;
	local_18.y = pVVar13->y + pVVar14->y;
	local_18.z = pVVar13->z + pVVar14->z;
	puVar12 = &local_30;
	fVar9 = pVVar13->y;
	fVar8 = pVVar13->x;
	pSVar1 = lego::game::GetSurfaceMap();
	BVar2 = lego::game::Map3D_WorldToBlockPos_NoZ(pSVar1,fVar8,fVar9,(int *)puVar11,(int *)puVar12);
	if (BVar2 == 0) {
		pSVar1 = lego::game::GetSurfaceMap();
		if ((uint)(pSVar1->smallDimensions).width <= local_28) {
			pSVar1 = lego::game::GetSurfaceMap();
			local_28 = (pSVar1->smallDimensions).width - 1;
		}
		pSVar1 = lego::game::GetSurfaceMap();
		if ((uint)(pSVar1->smallDimensions).height <= local_30) {
			pSVar1 = lego::game::GetSurfaceMap();
			local_30 = (pSVar1->smallDimensions).height - 1;
		}
	}
	puVar11 = &local_34;
	puVar12 = &local_2c;
	fVar9 = local_18.x;
	fVar8 = local_18.y;
	pSVar1 = lego::game::GetSurfaceMap();
	BVar2 = lego::game::Map3D_WorldToBlockPos_NoZ(pSVar1,fVar9,fVar8,(int *)puVar12,(int *)puVar11);
	if (BVar2 == 0) {
		pSVar1 = lego::game::GetSurfaceMap();
		if ((uint)(pSVar1->smallDimensions).width <= local_2c) {
			pSVar1 = lego::game::GetSurfaceMap();
			local_2c = (pSVar1->smallDimensions).width - 1;
		}
		pSVar1 = lego::game::GetSurfaceMap();
		if ((uint)(pSVar1->smallDimensions).height <= local_34) {
			pSVar1 = lego::game::GetSurfaceMap();
			local_34 = (pSVar1->smallDimensions).height - 1;
		}
	}
	uVar4 = local_2c;
	uVar3 = local_34;
	if (local_2c < local_28) {
		local_2c = local_28;
		local_28 = uVar4;
	}
	if (local_34 < local_30) {
		local_34 = local_30;
		local_30 = uVar3;
	}
	uVar3 = local_34;
	uVar4 = local_2c;
	uVar5 = local_28;
	uVar6 = local_30;
	if (local_28 <= local_2c) {
		do {
			uVar7 = uVar6;
			if (uVar6 <= uVar3) {
				do {
					pVVar13 = search->vectorp_c;
					pVVar10 = search->vectorp_8;
					pVVar14 = &local_18;
					uVar3 = uVar5;
					uVar4 = uVar6;
					pSVar1 = lego::game::GetSurfaceMap();
					BVar2 = lego::game::Map3D_Intersections_Sub2_FUN_004518a0
														(pSVar1,uVar3,uVar4,pVVar10,pVVar13,pVVar14);
					if (BVar2 != 0) {
						pVVar14 = search->vectorp_8;
						pVVar13 = search->vectorp_c;
						fVar9 = local_18.x - pVVar14->x;
						local_8 = local_18.y - pVVar14->y;
						local_4 = local_18.z - pVVar14->z;
						local_24 = pVVar13->z;
						local_20 = pVVar13->x;
						local_1c = SQRT(local_20 * local_20 + local_24 * local_24 + pVVar13->y * pVVar13->y);
						fVar9 = SQRT(local_4 * local_4 + local_8 * local_8 + fVar9 * fVar9) / local_1c;
						if (fVar9 < search->ref_float_4) {
							search->ref_float_4 = fVar9;
							search->field_10 = 1;
							search->field_0 = 0;
						}
					}
					uVar6 += 1;
					uVar3 = local_34;
					uVar4 = local_2c;
					uVar7 = local_30;
				} while (uVar6 <= local_34);
			}
			uVar5 += 1;
			uVar6 = uVar7;
		} while (uVar5 <= uVar4);
	}
	return;
}



BOOL __cdecl
lego::game::Game_DoCallbacksSearch_FUN_00471b20
					(Vector3F *vecCector,Vector3F *vecDistance,LiveObject **out_liveObj,float *ref_float_4,
					undefined4 param_5)
{
	SearchData18_2 search;
	
	search.field_0 = NULL;
	search.field_10 = 0;
	search.ref_float_4 = *ref_float_4;
	search.vectorp_8 = vecCector;
	search.vectorp_c = vecDistance;
	search.field_14 = param_5;
	Search_LiveObjects_SkipIgnoreMes(LiveObject_Callback_FUN_00471630,(undefined4 *)&search);
	FUN_004718f0(&search);
	*ref_float_4 = search.ref_float_4;
	*out_liveObj = search.field_0;
	return search.field_10;
}



BOOL __cdecl
lego::game::LiveObject_DoCallbacksSearch_FUN_00471b90(LiveObject *liveObj1,LiveObject *liveObj2)
{
	BOOL BVar1;
	float local_28;
	Vector3F collCenter1;
	Vector3F collCenter2;
	Vector3F collDiff;
	LiveObject *liveObj1_00;
	
	liveObj1_00 = liveObj1;
	local_28 = 1.0;
	LiveObject_GetCollCenterPosition(liveObj1,&collCenter1);
	LiveObject_GetCollCenterPosition(liveObj2,&collCenter2);
	collDiff.x = collCenter2.x - collCenter1.x;
	collDiff.y = collCenter2.y - collCenter1.y;
	collDiff.z = collCenter2.z - collCenter1.z;
	BVar1 = Game_DoCallbacksSearch_FUN_00471b20
										(&collCenter1,&collDiff,&liveObj1,&local_28,liveObj1_00);
	if ((BVar1 != 0) && (liveObj1 != liveObj2)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::game::LiveObject_SeeThroughWalls_FUN_00471c20(LiveObject *liveObj,LiveObject *liveObj2)
{
	LevelData *pLVar1;
	BOOL3 BVar2;
	char *pcVar3;
	undefined4 uVar4;
	Vector3F local_3c;
	Vector3F local_30;
	Vector3F local_24;
	SearchData18_2 local_18;
	
	local_18.vectorp_8 = &local_3c;
	local_18.vectorp_c = &local_24;
	uVar4 = 0;
	pcVar3 = "SeeThroughWalls";
	local_18.field_0 = 0;
	local_18.ref_float_4 = 1.0;
	local_18.field_10 = 0;
	local_18.field_14 = 0;
	pLVar1 = GetLevel();
	pcVar3 = cfg::CFG_JoinPath(globs::gameGlobs.CfgRootName,pLVar1->levelName,pcVar3,uVar4);
	BVar2 = cfg::CFG_ReadBool(globals::g_LegoCfgRoot_WeaponTypes,pcVar3);
	if (BVar2 != BOOL3_FALSE) {
		return 0;
	}
	LiveObject_GetCollCenterPosition(liveObj,&local_3c);
	LiveObject_GetCollCenterPosition(liveObj2,&local_30);
	local_24.x = local_30.x - local_3c.x;
	local_24.y = local_30.y - local_3c.y;
	local_24.z = local_30.z - local_3c.z;
	FUN_004718f0(&local_18);
	return local_18.field_10;
}



undefined4 __cdecl lego::unk::UnkStruct_Getter_FUN_00471ce0(int param_1,int param_2,int param_3)
{
	return *(undefined4 *)(param_1 + param_2 * 8 + param_3 * 4);
}



undefined4 __cdecl lego::unk::UnkStruct_Getter_FUN_00471d00(int param_1,int param_2)
{
	return *(undefined4 *)(param_1 + 0x18 + param_2 * 4);
}



undefined4 __cdecl lego::unk::UnkStruct_Getter_FUN_00471d10(int param_1,int param_2)
{
	return *(undefined4 *)(param_1 + 0x24 + param_2 * 4);
}



void __cdecl
lego::unk::UnkStruct_FUN_00471d20
					(int param_1,undefined4 *param_2,float param_3,int param_4,int param_5)
{
	int iVar1;
	undefined4 *puVar2;
	float fVar3;
	float fVar4;
	Container *cont;
	Container *cont_00;
	Vector3F local_c;
	
	if (param_4 != 0) {
		puVar2 = (undefined4 *)(param_1 + 0x68 + param_5 * 0xc);
		*puVar2 = *param_2;
		puVar2[1] = param_2[1];
		puVar2[2] = param_2[2];
	}
	cont = (Container *)UnkStruct_Getter_FUN_00471d00(param_1,param_5);
	if ((cont != NULL) &&
		 ((ushort)((ushort)(param_3 < 1e-05) << 8 | (ushort)(param_3 == 1e-05) << 0xe) == 0)) {
		res::Container_GetPosition(cont,NULL,&local_c);
		fVar3 = 5.0 / param_3;
		iVar1 = param_1 + param_5 * 0xc;
		local_c.x = *(float *)(iVar1 + 0x68) - local_c.x;
		local_c.y = *(float *)(iVar1 + 0x6c) - local_c.y;
		local_c.z = *(float *)(iVar1 + 0x70) - local_c.z;
		fVar4 = 1.0 / SQRT(local_c.z * local_c.z + local_c.y * local_c.y + local_c.x * local_c.x);
		*(float *)(iVar1 + 0x44) = *(float *)(iVar1 + 0x44) * fVar3;
		*(float *)(iVar1 + 0x48) = *(float *)(iVar1 + 0x48) * fVar3;
		*(float *)(iVar1 + 0x4c) = *(float *)(iVar1 + 0x4c) * fVar3;
		*(float *)(iVar1 + 0x44) = fVar4 * local_c.x + *(float *)(iVar1 + 0x44);
		*(float *)(iVar1 + 0x48) = fVar4 * local_c.y + *(float *)(iVar1 + 0x48);
		*(float *)(iVar1 + 0x4c) = fVar4 * local_c.z + *(float *)(iVar1 + 0x4c);
		fVar3 = 1.0 / SQRT(*(float *)(iVar1 + 0x44) * *(float *)(iVar1 + 0x44) +
											 *(float *)(iVar1 + 0x4c) * *(float *)(iVar1 + 0x4c) +
											 *(float *)(iVar1 + 0x48) * *(float *)(iVar1 + 0x48));
		*(float *)(iVar1 + 0x44) = *(float *)(iVar1 + 0x44) * fVar3;
		*(float *)(iVar1 + 0x48) = fVar3 * *(float *)(iVar1 + 0x48);
		*(float *)(iVar1 + 0x4c) = fVar3 * *(float *)(iVar1 + 0x4c);
		if ((ushort)((ushort)(*(float *)(iVar1 + 0x4c) < *(float *)(param_1 + 0x30)) << 8 |
								(ushort)(*(float *)(iVar1 + 0x4c) == *(float *)(param_1 + 0x30)) << 0xe) == 0) {
			*(undefined4 *)(iVar1 + 0x4c) = *(undefined4 *)(param_1 + 0x30);
		}
		cont_00 = (Container *)UnkStruct_Getter_FUN_00471d10(param_1,param_5);
		if (cont_00 != NULL) {
			res::Container_SetOrientation
								(cont_00,NULL,*(float *)(iVar1 + 0x44),*(float *)(param_1 + (param_5 + 6) * 0xc),0.0
								 ,0.0,0.0,-1.0);
		}
		res::Container_SetOrientation
							(cont,NULL,*(float *)(iVar1 + 0x44),*(float *)(param_1 + (param_5 + 6) * 0xc),
							 *(float *)(iVar1 + 0x4c),0.0,0.0,-1.0);
	}
	return;
}



void __cdecl
lego::unk::UnkStructC_GetTable44_Vector_FUN_00471f30(int param_1,Vector3F *out_vector44,int index)
{
	float *pfVar1;
	
	pfVar1 = (float *)(param_1 + 0x44 + index * 0xc);
	out_vector44->x = *pfVar1;
	out_vector44->y = pfVar1[1];
	out_vector44->z = pfVar1[2];
	return;
}



BOOL __cdecl lego::game::LiveObject_GetCollCenterPosition(LiveObject *liveObj,Vector3F *out_vector)
{
	Container *cont;
	float10 fVar1;
	
	cont = LiveObject_GetContainer(liveObj);
	res::Container_GetPosition(cont,NULL,out_vector);
	fVar1 = LiveObject_GetCollHeight(liveObj);
	out_vector->z = (float)((float10)out_vector->z - fVar1 * (float10)0.5);
	return TRUE;
}



BOOL __cdecl lego::game::LiveObject_UnkTracker_FUN_00471fa0(LiveObject *liveObj)
{
	ObjectStatsFlags2 OVar1;
	BOOL BVar2;
	
	OVar1 = LiveObject_GetStatsFlags2(liveObj);
	if ((OVar1 & STATS2_TRACKER) != STATS2_NONE) {
		BVar2 = LiveObject_CheckCondition_FUN_00438870
											(liveObj,(uint)(liveObj->objType != OBJECT_BUILDING));
		if (BVar2 != 0) {
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_00471fe0(LiveObject *in_liveObj,float param_2,float param_3)
{
	LiveObject *liveObj;
	float fVar1;
	void *pvVar2;
	BOOL BVar3;
	uint uVar4;
	uint mouseX;
	Container *cont;
	LiveObject *pLVar5;
	float10 fVar6;
	Vector3F *pVVar7;
	float fVar8;
	int iVar9;
	float fVar10;
	LiveObject **ref_param_3;
	LiveObject *local_34;
	float local_30;
	float local_2c;
	float local_28;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	fVar1 = param_3;
	liveObj = in_liveObj;
	Game_GetVector_45c(&local_18);
	pVVar7 = &local_18;
	iVar9 = 1;
	fVar8 = param_2;
	fVar10 = param_3;
	pvVar2 = LiveObject_GetBuildingVehicleFields_138_a0(in_liveObj);
	unk::UnkStruct_FUN_00471d20((int)pvVar2,(undefined4 *)pVVar7,fVar8,iVar9,(int)fVar10);
	BVar3 = input::mslb();
	if (((BVar3 != 0) && ((globs::gameGlobs.flags2 & GAME2_MOUSE_INSIDEGAMEVIEW) != GAME2_NONE)) &&
		 (fVar6 = LiveObject_PtrGetter_FUN_004715b0(in_liveObj,(int)param_3),
		 (ushort)((ushort)(fVar6 < (float10)0.0) << 8 | (ushort)(fVar6 == (float10)0.0) << 0xe) != 0)) {
		ref_param_3 = &local_34;
		uVar4 = input::msy();
		mouseX = input::msx();
		iVar9 = LiveManager_DoPickSphereCallbacks_MouseXY(mouseX,uVar4,ref_param_3);
		if ((iVar9 == 0) || (local_34 != in_liveObj)) {
			in_liveObj = NULL;
			do {
				iVar9 = Level_GetCrystalCount(1);
				if (iVar9 != 0) {
					fVar8 = fVar1;
					pLVar5 = in_liveObj;
					pvVar2 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
					cont = (Container *)unk::UnkStruct_Getter_FUN_00471ce0((int)pvVar2,(int)fVar8,(int)pLVar5)
					;
					if (cont == NULL) {
						return 1;
					}
					pvVar2 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
					uVar4 = tools::Weapon_GetWeaponTypeByName
														(*(char **)(*(int *)((int)pvVar2 + (int)fVar1 * 4 + 0x8c) + 0xc));
					fVar6 = tools::Weapon_GetWeaponRange(uVar4);
					local_30 = (float)fVar6;
					fVar6 = LiveObject_GetFunctionCoef(liveObj);
					param_3 = (float)fVar6;
					if (fVar6 == (float10)0.0) {
						param_3 = 1.0;
					}
					if (in_liveObj == NULL) {
						fVar8 = fVar1;
						fVar6 = tools::Weapon_GetRechargeTime(uVar4);
						LiveObject_PtrSetter_FUN_004715d0(liveObj,(float)fVar6,(int)fVar8);
						pVVar7 = &local_24;
						fVar8 = fVar1;
						pvVar2 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
						unk::UnkStructC_GetTable44_Vector_FUN_00471f30((int)pvVar2,pVVar7,(int)fVar8);
						snd::Audio_FUN_00428730(0);
					}
					res::Container_GetPosition(cont,NULL,&local_c);
					pLVar5 = tools::Weapon_DoLaserUnk_FUN_00470270
														 (&local_c,&local_24,liveObj,param_2,local_30,uVar4,param_3);
					if (pLVar5 != NULL) {
						local_2c = local_24.x;
						local_28 = local_24.y;
						LiveObject_FUN_0046f530(pLVar5,uVar4,1,0.0,&local_2c);
						liveObj->object_3c4 = pLVar5;
					}
				}
				in_liveObj = (LiveObject *)((int)&in_liveObj->objType + 1);
			} while (in_liveObj < (LiveObject *)0x2);
		}
	}
	return TRUE;
}



BOOL __cdecl lego::game::LiveObject_FUN_004721c0(LiveObject *liveObj,float param_2,int param_3)
{
	Container *cont;
	void *pvVar1;
	float *pfVar2;
	int iVar3;
	Vector3F local_30;
	Vector3F local_24;
	float local_18;
	float local_14;
	float local_10;
	Vector3F local_c;
	
	cont = LiveObject_GetContainer(liveObj);
	if (cont != NULL) {
		res::Container_GetOrientation(cont,NULL,&local_30,&local_c);
		res::Container_GetPosition(cont,NULL,&local_24);
		local_30.x = local_30.x * 10000.0;
		pfVar2 = &local_18;
		local_30.y = local_30.y * 10000.0;
		iVar3 = 1;
		local_30.z = local_30.z * 10000.0;
		local_18 = local_30.x + local_24.x;
		local_14 = local_30.y + local_24.y;
		local_10 = local_30.z + local_24.z;
		pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
		unk::UnkStruct_FUN_00471d20((int)pvVar1,pfVar2,param_2,iVar3,param_3);
	}
	return 1;
}



BOOL __cdecl lego::game::LiveObject_FUN_00472280(LiveObject *liveObj,float param_2)
{
	void *pvVar1;
	float fVar2;
	uint uVar3;
	
	if ((*(byte *)&liveObj->flags4 & 1) == 0) {
		uVar3 = 0;
		pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
		if (*(int *)((int)pvVar1 + 0xa4) != 0) {
			do {
				LiveObject_FUN_004721c0(liveObj,param_2,uVar3);
				uVar3 += 1;
				pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
			} while (uVar3 < *(uint *)((int)pvVar1 + 0xa4));
		}
	}
	else {
		fVar2 = 0.0;
		pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
		if (*(int *)((int)pvVar1 + 0xa4) != 0) {
			do {
				LiveObject_FUN_00471fe0(liveObj,param_2,fVar2);
				fVar2 = (float)((int)fVar2 + 1);
				pvVar1 = LiveObject_GetBuildingVehicleFields_138_a0(liveObj);
			} while ((uint)fVar2 < (uint)*(float *)((int)pvVar1 + 0xa4));
			return TRUE;
		}
	}
	return TRUE;
}



BOOL __cdecl lego::game::LiveObject_SetField_3c4(LiveObject *liveObj,int field3c4)
{
	if (liveObj->object_3c4 == (LiveObject *)field3c4) {
		liveObj->object_3c4 = NULL;
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_00472340(LiveObject *liveObj,undefined4 *param_2)
{
	uint weaponType;
	float10 fVar1;
	Vector3F local_18;
	Vector3F local_c;
	
	weaponType = LiveObject_GetEquippedBeam(liveObj);
	if (((liveObj != NULL) && (param_2 != NULL)) && (weaponType != 0)) {
		fVar1 = tools::Weapon_GetWeaponRange(weaponType);
		LiveObject_GetCollCenterPosition(liveObj,&local_c);
		LiveObject_GetCollCenterPosition((LiveObject *)param_2,&local_18);
		if (SQRT((local_18.z - local_c.z) * (local_18.z - local_c.z) +
						 (local_18.y - local_c.y) * (local_18.y - local_c.y) +
						 (local_18.x - local_c.x) * (local_18.x - local_c.x)) < (float)fVar1) {
			return 1;
		}
	}
	return 0;
}



BOOL __cdecl lego::game::LiveObject_FUN_004723f0(LiveObject *liveObj,undefined4 *param_2)
{
	uint uVar1;
	float10 fVar2;
	Vector3F local_18;
	Vector3F local_c;
	
	uVar1 = LiveObject_GetEquippedBeam(liveObj);
	if (((liveObj != NULL) && (param_2 != NULL)) && (uVar1 != 0)) {
		fVar2 = LiveObject_GetAwarenessRange(liveObj);
		LiveObject_GetCollCenterPosition(liveObj,&local_c);
		LiveObject_GetCollCenterPosition((LiveObject *)param_2,&local_18);
		if (SQRT((local_18.z - local_c.z) * (local_18.z - local_c.z) +
						 (local_18.y - local_c.y) * (local_18.y - local_c.y) +
						 (local_18.x - local_c.x) * (local_18.x - local_c.x)) < (float)fVar2) {
			return 1;
		}
	}
	return 0;
}



bool __thiscall
lego::video::VideoPlayer__CreateSampleDDrawStreams
					(VideoPlayer *this,IAMMultiMediaStream *amMediaStream)
{
	IMediaStream **ppIVar1;
	IAMMultiMediaStreamVtbl *pIVar2;
	IDirectDrawMediaStream *This;
	IDirectDrawStreamSample *This_00;
	IDirectDrawSurface *This_01;
	HRESULT HVar3;
	
	pIVar2 = amMediaStream->lpVtbl;
	ppIVar1 = &this->mediaStream;
	HVar3 = (*pIVar2->GetMediaStream)(amMediaStream,&idl::MSPID_PrimaryVideo,ppIVar1);
	this->errorCode = HVar3;
	if (-1 < HVar3) {
		HVar3 = (*(*ppIVar1)->lpVtbl->QueryInterface)
											(*ppIVar1,&idl::IID_IDirectDrawMediaStream,&this->ddMediaStream);
		this->errorCode = HVar3;
		if (-1 < HVar3) {
			This = this->ddMediaStream;
										// IDirectDrawMediaStream->CreateSample(this, IDirectDrawSurface* pSurface,
										// const RECT* pRect, DWORD dwFlags, IDirectDrawStreamSample** ppSample)
			HVar3 = (*(code *)This->lpVtbl->CreateSample)(This,NULL,NULL,0,&this->ddStreamSample);
			this->errorCode = HVar3;
			if (-1 < HVar3) {
				This_00 = this->ddStreamSample;
										// IDirectDrawStreamSample->GetSurface(this, IDirectDrawSurface**
										// ppDirectDrawSurface, RECT* pRect)
				HVar3 = (*(code *)This_00->lpVtbl->GetSurface)(This_00,&this->ddSampleSurface,&this->rect);
				this->errorCode = HVar3;
				if (-1 < HVar3) {
					This_01 = this->ddSampleSurface;
					HVar3 = (*This_01->lpVtbl->QueryInterface)
														(This_01,&idl::IID_IDirectDrawSurface3,(IUnknown **)&this->ddDrawSurface
														);
					this->errorCode = HVar3;
					if (-1 < HVar3) {
										// STREAMSTATE_RUN (0x1)
						HVar3 = (*pIVar2->SetState)(amMediaStream,STREAMSTATE_RUN);
						this->errorCode = HVar3;
						if (-1 < HVar3) {
							return true;
						}
					}
				}
			}
		}
	}
	(*(*ppIVar1)->lpVtbl->Release)(*ppIVar1);
	(*this->ddMediaStream->lpVtbl->Release)(this->ddMediaStream);
	(*this->ddStreamSample->lpVtbl->Release)(this->ddStreamSample);
	(*this->ddSampleSurface->lpVtbl->Release)(this->ddSampleSurface);
	return -1 < this->errorCode;
}



bool __thiscall
lego::video::VideoPlayer__CreateAMMultiMediaStream
					(VideoPlayer *this,char *filename,IAMMultiMediaStream **lplpAMMMStream,
					IDirectDraw2 *ddraw2)
{
	IAMMultiMediaStreamVtbl *pIVar1;
	HRESULT HVar2;
	IAMMultiMediaStream *amMMStream;
	WCHAR wfilenameBuffer [260];
	
										// CLSCTX_INPROC_HANDLER (0x1)
	HVar2 = CoCreateInstance((IID *)&idl::CLSID_AMMultiMediaStream,NULL,1,
													 (IID *)&idl::IID_IAMMultiMediaStream,&amMMStream);
	if (-1 < HVar2) {
										//  STREAMTYPE_READ (0x0)
		HVar2 = (*amMMStream->lpVtbl->Initialize)(amMMStream,STREAMTYPE_READ,0,NULL);
		if (-1 < HVar2) {
			HVar2 = (*amMMStream->lpVtbl->AddMediaStream)
												(amMMStream,(IUnknown *)ddraw2,&idl::MSPID_PrimaryVideo,0,NULL);
			if (-1 < HVar2) {
										// AMMSF_ADDDEFAULTRENDERER (0x1)
				HVar2 = (*amMMStream->lpVtbl->AddMediaStream)
													(amMMStream,NULL,&idl::MSPID_PrimaryAudio,1,NULL);
				if (HVar2 < 0) {
										// failure is just outright ignored here?
					HVar2 = 0;
				}
										// The IAMMultiMediaStream::OpenFile function only supports unicode,
										// so convert our filename to wide chars.
				MultiByteToWideChar(CP_ACP,0,filename,-1,wfilenameBuffer,0x104);
				(*amMMStream->lpVtbl->OpenFile)(amMMStream,wfilenameBuffer,0);
				pIVar1 = amMMStream->lpVtbl;
				*lplpAMMMStream = amMMStream;
				(*pIVar1->AddRef)(amMMStream);
			}
		}
	}
	(*amMMStream->lpVtbl->Release)(amMMStream);
	return -1 < HVar2;
}



VideoPlayer * __thiscall
lego::video::VideoPlayer___ctor
					(VideoPlayer *this,char *filename,IDirectDrawSurface3 *ddSurface3,IDirectDraw2 *ddraw2)
{
	char cVar1;
	bool bVar2;
	undefined4 *puVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	char *pcVar9;
	
	this->mediaStream = NULL;
	this->ddMediaStream = NULL;
	this->ddSampleSurface = NULL;
	this->ddDrawSurface = NULL;
	this->ddStreamSample = NULL;
	this->ddRenderSurface = ddSurface3;
	this->ddraw2 = ddraw2;
	CoInitialize(NULL);
	if (filename != NULL) {
										// *(char **)((int)this + 0x30) = std::_strdup(filename);
		iVar4 = -1;
		pcVar8 = filename;
		do {
			if (iVar4 == 0) break;
			iVar4 += -1;
			cVar1 = *pcVar8;
			pcVar8 = pcVar8 + 1;
		} while (cVar1 != '\0');
										// if (std::strlen(filename) != 0)
		if (iVar4 != -2) {
			uVar5 = 0xffffffff;
			pcVar8 = filename;
			do {
				if (uVar5 == 0) break;
				uVar5 -= 1;
				cVar1 = *pcVar8;
				pcVar8 = pcVar8 + 1;
			} while (cVar1 != '\0');
			puVar3 = (undefined4 *)std::malloc(~uVar5);
			uVar5 = 0xffffffff;
			this->filename = (char *)puVar3;
			pcVar8 = filename;
			do {
				pcVar9 = pcVar8;
				if (uVar5 == 0) break;
				uVar5 -= 1;
				pcVar9 = pcVar8 + 1;
				cVar1 = *pcVar8;
				pcVar8 = pcVar9;
			} while (cVar1 != '\0');
			uVar5 = ~uVar5;
			puVar7 = (undefined4 *)(pcVar9 + -uVar5);
			for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
				*puVar3 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar3 = puVar3 + 1;
			}
			for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
				*(undefined *)puVar3 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar3 = (undefined4 *)((int)puVar3 + 1);
			}
										// end of std::_strdup
			bVar2 = VideoPlayer__CreateAMMultiMediaStream
												(this,filename,(IAMMultiMediaStream **)this,ddraw2);
			if (bVar2 != false) {
				VideoPlayer__CreateSampleDDrawStreams(this,this->amMediaStream);
			}
		}
	}
	return this;
}



void __thiscall lego::video::VideoPlayer___dtor(VideoPlayer *this)
{
	IMediaStream *This;
	IDirectDrawMediaStream *This_00;
	IDirectDrawStreamSample *This_01;
	IDirectDrawSurface *This_02;
	IDirectDrawSurface3 *This_03;
	IDirectDraw2 *This_04;
	IAMMultiMediaStream *This_05;
	
	This = this->mediaStream;
	if (This != NULL) {
		(*This->lpVtbl->Release)((IUnknown *)This);
	}
	This_00 = this->ddMediaStream;
	if (This_00 != NULL) {
		(*This_00->lpVtbl->Release)((IUnknown *)This_00);
	}
	This_01 = this->ddStreamSample;
	if (This_01 != NULL) {
		(*This_01->lpVtbl->Release)((IUnknown *)This_01);
	}
	This_02 = this->ddSampleSurface;
	if (This_02 != NULL) {
		(*This_02->lpVtbl->Release)((IUnknown *)This_02);
	}
	This_03 = this->ddRenderSurface;
	if (This_03 != NULL) {
		(*This_03->lpVtbl->Release)((IUnknown *)This_03);
	}
	This_04 = this->ddraw2;
	if (This_04 != NULL) {
		(*This_04->lpVtbl->Release)((IUnknown *)This_04);
	}
	This_05 = this->amMediaStream;
	if (This_05 != NULL) {
		(*This_05->lpVtbl->Release)((IUnknown *)This_05);
	}
	if (this->filename != NULL) {
		std::free(this->filename);
	}
	return;
}



bool __thiscall lego::video::VideoPlayer__Update(VideoPlayer *this,float speed,RECT *rect)
{
	IDirectDrawStreamSample *pIVar1;
	IAMMultiMediaStream *pIVar2;
	HRESULT HVar3;
	
	pIVar1 = this->ddStreamSample;
	if (pIVar1 != NULL) {
		HVar3 = (*(code *)pIVar1->lpVtbl->Update)(pIVar1,0,NULL,NULL,NULL);
		if (HVar3 == 0) {
										// DDBLT_WAIT (0x1000000)
			HVar3 = (*(code *)this->ddRenderSurface->lpVtbl->Blt)
												(this->ddRenderSurface,rect,this->ddDrawSurface,NULL,0x1000000,NULL);
			return HVar3 == 0;
		}
										// On failure... SHUTDOWN EVERYTHING!
		(*this->mediaStream->lpVtbl->Release)(this->mediaStream);
		this->mediaStream = NULL;
		(*this->ddMediaStream->lpVtbl->Release)(this->ddMediaStream);
		this->ddMediaStream = NULL;
		(*this->ddStreamSample->lpVtbl->Release)(this->ddStreamSample);
		this->ddStreamSample = NULL;
		(*this->ddSampleSurface->lpVtbl->Release)(this->ddSampleSurface);
		pIVar2 = this->amMediaStream;
		this->ddSampleSurface = NULL;
		if (pIVar2 != NULL) {
			(*pIVar2->lpVtbl->Release)(pIVar2);
			this->amMediaStream = NULL;
			return false;
		}
	}
	return false;
}



// WARNING: Could not reconcile some variable overlaps

longlong __thiscall lego::video::VideoPlayer__GetDuration(VideoPlayer *this)
{
	longlong lVar1;
	longlong duration;
	
	(*this->amMediaStream->lpVtbl->GetDuration)(this->amMediaStream,&duration);
										// __alldiv - 64-bit integer division in 32-bit environments
	lVar1 = __alldiv((uint)duration,duration._4_4_,10000,0);
	return lVar1;
}



VideoPlayer_t * __cdecl lego::video::VideoPlayer_Load(char *filenameNoDataDir)
{
	char *filename;
	IDirectDraw4 *pIVar1;
	IDirectDrawSurface4 *pIVar2;
	FILE *stream;
	BOOL BVar3;
	VideoPlayer *videoPlayer;
	undefined4 *in_FS_OFFSET;
	IDirectDrawSurface3 *ddSurface3;
	IDirectDraw2 *ddraw2;
	VideoPlayer *This;
	char cdFileBuffer [512];
	undefined4 local_c;
	undefined *puStack8;
	undefined4 local_4;
	
										// C++ function start guards (ignore these)
	local_c = *in_FS_OFFSET;
	local_4 = 0xffffffff;
	puStack8 = &LAB_0049e06c;
	*in_FS_OFFSET = &local_c;
										// actual start of C++ function
	filename = lego::file::File_VerifyFilename(filenameNoDataDir);
	videoPlayer = NULL;
	pIVar1 = ddraw::DirectDraw();
	(*pIVar1->lpVtbl->QueryInterface)(pIVar1,&idl::IID_IDirectDraw2,(IUnknown **)&ddraw2);
	pIVar2 = ddraw::DirectDraw_bSurf();
	(*pIVar2->lpVtbl->QueryInterface)(pIVar2,&idl::IID_IDirectDrawSurface3,(IUnknown **)&ddSurface3);
	stream = std::fopen(filename,"r");
	if (stream == NULL) {
										// File not found in local Data folder, Try open in CDROM/Data folder
		BVar3 = lego::file::File_GetCDFilePath(cdFileBuffer,filenameNoDataDir);
		if (BVar3 == 0) goto LAB_0047290d;
		This = (VideoPlayer *)std::operator_new(0x38);
		local_4 = 1;
		if (This != NULL) {
			videoPlayer = VideoPlayer___ctor(This,cdFileBuffer,ddSurface3,ddraw2);
			goto LAB_0047290d;
		}
	}
	else {
										// Open file in local Data folder
		std::fclose(stream);
		This = (VideoPlayer *)std::operator_new(0x38);
		local_4 = 0;
		if (This != NULL) {
			videoPlayer = VideoPlayer___ctor(This,filename,ddSurface3,ddraw2);
			goto LAB_0047290d;
		}
	}
	videoPlayer = NULL;
LAB_0047290d:
										// C++ function end guard (ignore this)
	*in_FS_OFFSET = local_c;
	return (VideoPlayer_t *)videoPlayer;
}



void __cdecl
lego::video::VideoPlayer_GetSize(VideoPlayer_t *videoPlayer,uint *out_width,uint *out_height)
{
	DDSURFACEDESC *pDVar1;
	int iVar2;
	DDSURFACEDESC surfDesc;
	
	pDVar1 = &surfDesc;
	for (iVar2 = 0x1b; iVar2 != 0; iVar2 += -1) {
		*(undefined4 *)pDVar1 = 0;
		pDVar1 = (DDSURFACEDESC *)((int)pDVar1 + 4);
	}
	surfDesc.dwSize = 0x6c;
	(*(code *)videoPlayer->ddDrawSurface->lpVtbl->GetSurfaceDesc)
						(videoPlayer->ddDrawSurface,&surfDesc);
	*out_width = surfDesc.dwWidth;
	*out_height = surfDesc.dwHeight;
	return;
}



longlong __cdecl lego::video::VideoPlayer_GetLength(VideoPlayer_t *videoPlayer)
{
	longlong lVar1;
	
	lVar1 = VideoPlayer__GetDuration((VideoPlayer *)videoPlayer);
	return lVar1;
}



BOOL __cdecl lego::video::VideoPlayer_Update(VideoPlayer_t *videoPlayer,float speed,RECT *rect)
{
	bool bVar1;
	
	bVar1 = VideoPlayer__Update((VideoPlayer *)videoPlayer,speed,rect);
	return (uint)(bVar1 != false);
}



void __cdecl lego::video::VideoPlayer_Free(VideoPlayer_t *videoPlayer)
{
	if (videoPlayer != NULL) {
		VideoPlayer___dtor((VideoPlayer *)videoPlayer);
										// This function is multi-purpose (the linker assigned functions with the same
										// functionality to different areas). So distinguishing is annoying
		game::LevelStruct3C_Free_Unwind((LevelStruct_3c *)videoPlayer);
	}
	return;
}



Container * __cdecl lego::res::Container_Initialise(char *gameName)
{
	Container *pCVar1;
	int iVar2;
	Container_Globs *pCVar3;
	
	pCVar3 = &globs::containerGlobs;
	for (iVar2 = 0x806; iVar2 != 0; iVar2 += -1) {
		pCVar3->listSet[0] = NULL;
		pCVar3 = (Container_Globs *)(pCVar3->listSet + 1);
	}
	pCVar3 = &globs::containerGlobs;
	for (iVar2 = 0x14; iVar2 != 0; iVar2 += -1) {
		pCVar3->listSet[0] = NULL;
		pCVar3 = (Container_Globs *)(pCVar3->listSet + 1);
	}
	globs::containerGlobs.extensionName[1] = "x";
	globs::containerGlobs.extensionName[2] = "x";
	globs::containerGlobs.extensionName[3] = "x";
	globs::containerGlobs.typeName[0] = "NULL";
	globs::containerGlobs.typeName[1] = "MESH";
	globs::containerGlobs.typeName[2] = "FRAME";
	globs::containerGlobs.typeName[3] = "ANIM";
	globs::containerGlobs.typeName[7] = "LWS";
	globs::containerGlobs.typeName[8] = "LWO";
	globs::containerGlobs.typeName[4] = "ACT";
	globs::containerGlobs.typeName[5] = NULL;
	globs::containerGlobs.extensionName[0] = ____EMPTYSTR__;
	globs::containerGlobs.extensionName[4] = "ae";
	globs::containerGlobs.extensionName[5] = ____EMPTYSTR__;
	globs::containerGlobs.gameName = gameName;
	globs::containerGlobs.freeList = NULL;
	globs::containerGlobs.listCount = 0;
	globs::containerGlobs.flags = RESMANAGER_ISINIT;
	globs::containerGlobs.textureCount = 0;
	globs::containerGlobs.sharedDir = NULL;
	pCVar1 = Container_Create(NULL);
										// D3DRMSORT_NONE (0x1)
	globs::containerGlobs.rootContainer = pCVar1;
	(*pCVar1->masterFrame->lpVtbl->SetSortMode)(pCVar1->masterFrame,D3DRMSORT_NONE);
	return pCVar1;
}



void __cdecl lego::res::Container_Shutdown(void)
{
	int iVar1;
	Container *in_cont;
	byte bVar2;
	int iVar3;
	Container_TextureRef *pCVar4;
	Container_Globs *pCVar5;
	uint uVar6;
	
	bVar2 = 0;
	pCVar5 = &globs::containerGlobs;
	do {
		if (pCVar5->listSet[0] != NULL) {
			iVar1 = 1 << (bVar2 & 0x1f);
			if (iVar1 != 0) {
				iVar3 = 0;
				do {
					in_cont = (Container *)((int)&pCVar5->listSet[0]->masterFrame + iVar3);
					if ((in_cont != NULL) && (in_cont->nextFree == in_cont)) {
						Container_Remove2(in_cont,TRUE);
					}
					iVar3 += 0x2c;
					iVar1 += -1;
				} while (iVar1 != 0);
			}
			std::free(pCVar5->listSet[0]);
		}
		pCVar5 = (Container_Globs *)(pCVar5->listSet + 1);
		bVar2 += 1;
	} while (pCVar5 < (Container_Globs *)&globs::containerGlobs.freeList);
	uVar6 = 0;
	globs::containerGlobs.freeList = NULL;
	globs::containerGlobs.flags = RESMANAGER_NONE;
	if (globs::containerGlobs.textureCount != 0) {
		pCVar4 = globs::containerGlobs.textureSet;
		do {
			if (pCVar4->filename != NULL) {
				std::free(pCVar4->filename);
			}
			uVar6 += 1;
			pCVar4 = pCVar4 + 1;
		} while (uVar6 < globs::containerGlobs.textureCount);
	}
	if (globs::containerGlobs.sharedDir != NULL) {
		std::free(globs::containerGlobs.sharedDir);
	}
	return;
}



void __cdecl lego::res::Container_SetSharedTextureDirectory(char *path)
{
	globs::containerGlobs.sharedDir = std::_strdup(path);
	return;
}



void __cdecl lego::res::Container_EnableSoundTriggers(BOOL on)
{
	if (on != 0) {
		globs::containerGlobs.flags = globs::containerGlobs.flags | RESMANAGER_SOUNDCALLBACK;
		return;
	}
	globs::containerGlobs.flags = globs::containerGlobs.flags & ~RESMANAGER_SOUNDCALLBACK;
	return;
}



void __cdecl
lego::res::Container_SetTriggerFrameCallback(ContainerTriggerFrameCallback callback,void *data)
{
	globs::containerGlobs.triggerFrameCallback = callback;
	globs::containerGlobs.triggerFrameData = data;
	return;
}



void __cdecl
lego::res::Container_SetSoundTriggerCallback(ContainerSoundTriggerCallback callback,void *data)
{
	globs::containerGlobs.soundTriggerCallback = callback;
	globs::containerGlobs.soundTriggerData = data;
	globs::containerGlobs.flags = globs::containerGlobs.flags | RESMANAGER_SOUNDCALLBACK;
	return;
}



// OFFICIAL: Container_GetRoot(void)

Container * __cdecl lego::res::GetRoot(void)
{
	return globs::containerGlobs.rootContainer;
}



Container * __cdecl lego::res::Container_Create(Container *opt_parent)
{
	Container *cont;
	HRESULT HVar1;
	int iVar2;
	IDirect3DRMFrame3 *parentFrame1;
	IDirect3DRMFrame3 *parentFrame3;
	Container *pCVar3;
	
	parentFrame1 = NULL;
	parentFrame3 = NULL;
	if (opt_parent != NULL) {
		parentFrame1 = opt_parent->masterFrame;
		parentFrame3 = opt_parent->hiddenFrame;
	}
	if (globs::containerGlobs.freeList == NULL) {
		Container_AddList();
	}
	cont = globs::containerGlobs.freeList;
	pCVar3 = globs::containerGlobs.freeList;
	globs::containerGlobs.freeList = (globs::containerGlobs.freeList)->nextFree;
	for (iVar2 = 0xb; iVar2 != 0; iVar2 += -1) {
		pCVar3->masterFrame = NULL;
		pCVar3 = (Container *)&pCVar3->activityFrame;
	}
	cont->nextFree = cont;
	HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
										(globs::mainGlobs.lpD3DRM,parentFrame1,(IDirect3DRMFrame3 **)cont);
	if (HVar1 == 0) {
		HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
											(globs::mainGlobs.lpD3DRM,cont->masterFrame,&cont->activityFrame);
		if (HVar1 == 0) {
			HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
												(globs::mainGlobs.lpD3DRM,parentFrame3,&cont->hiddenFrame);
			if (HVar1 == 0) {
				Container_Frame_SetAppData
									(cont->masterFrame,cont,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
				Container_Frame_SetAppData
									(cont->activityFrame,cont,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
				Container_Frame_SetAppData
									(cont->hiddenFrame,cont,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
				return cont;
			}
		}
	}
	Container_Remove(cont);
	return NULL;
}



void __cdecl lego::res::Container_Remove(Container *cont)
{
	Container_Remove2(cont,FALSE);
	return;
}



void __cdecl lego::res::Container_Remove2(Container *in_cont,BOOL kill)
{
	Container_CloneData *pCVar1;
	ResourceType RVar2;
	Container_TypeData *pCVar3;
	IDirect3DRMVisual *pIVar4;
	Container *cont;
	uint uVar5;
	AnimClone **out_acList;
	IDirect3DRMFrame3 **out_frameList;
	void **buffer;
	AnimClone *actFrameRes;
	void *pvVar6;
	IDirect3DRMFrame3 **ppIVar7;
	
	cont = in_cont;
	if (in_cont->type != RESOURCE_REFERENCE) {
		Container_SetParent(in_cont,NULL);
	}
	if (((cont->type == RESOURCE_ACT) || (cont->type == RESOURCE_ANIM)) &&
		 (pCVar1 = cont->cloneData, pCVar1 != NULL)) {
		if (kill == 0) {
			pCVar1->used = 0;
			return;
		}
		if (pCVar1->cloneTable != NULL) {
			std::free(pCVar1->cloneTable);
		}
		std::free(cont->cloneData);
	}
	RVar2 = cont->type;
	if (RVar2 == RESOURCE_ACT) {
		uVar5 = Container_GetActivities(cont,NULL,NULL,NULL);
		out_acList = (AnimClone **)std::malloc(uVar5 * 4);
		out_frameList = (IDirect3DRMFrame3 **)std::malloc(uVar5 * 4);
		Container_GetActivities(cont,out_frameList,out_acList,NULL);
		if (uVar5 != 0) {
			ppIVar7 = out_frameList;
			do {
				AnimClone_Remove(*(AnimClone **)((int)((int)out_acList - (int)out_frameList) + (int)ppIVar7)
												);
				Container_Frame_FreeName(*ppIVar7);
				Container_Frame_RemoveAppData(*ppIVar7);
				(*(*ppIVar7)->lpVtbl->Release)((IUnknown *)*ppIVar7);
				ppIVar7 = ppIVar7 + 1;
				uVar5 -= 1;
			} while (uVar5 != 0);
		}
		std::free(out_acList);
		std::free(out_frameList);
	}
	else {
		if (RVar2 == RESOURCE_MESH) {
			pCVar3 = cont->typeData;
			if (pCVar3 != NULL) {
				if (pCVar3->transMesh == NULL) {
					buffer = (*pCVar3->mesh->lpVtbl->GetAppData)(pCVar3->mesh);
					if (buffer != NULL) {
						pvVar6 = NULL;
						if (buffer[1] != NULL) {
							do {
								pIVar4 = *(IDirect3DRMVisual **)((int)*buffer + (int)pvVar6 * 4);
								(*cont->activityFrame->lpVtbl->DeleteVisual)(cont->activityFrame,pIVar4);
								(*pIVar4->lpVtbl->Release)(pIVar4);
								pvVar6 = (void *)((int)pvVar6 + 1);
							} while (pvVar6 < buffer[1]);
						}
						std::free(*buffer);
						std::free(buffer);
					}
				}
				else {
					Mesh_Remove(pCVar3->transMesh,cont->activityFrame);
				}
			}
		}
		else {
			if ((RVar2 == RESOURCE_ANIM) &&
				 (actFrameRes = Container_Frame_GetAnimClone(cont->activityFrame), actFrameRes != NULL)) {
				AnimClone_Remove(actFrameRes);
			}
		}
	}
	Container_FreeTypeData(cont);
	if ((cont->type != RESOURCE_REFERENCE) || ((*(byte *)&cont->flags & RESDATA_UNK_10) == 0)) {
		Container_Frame_RemoveAppData(cont->masterFrame);
	}
	if (cont->type != RESOURCE_REFERENCE) {
		Container_Frame_RemoveAppData(cont->activityFrame);
	}
	Container_Frame_RemoveAppData(cont->hiddenFrame);
	if (cont->type == RESOURCE_REFERENCE) {
		(*cont->hiddenFrame->lpVtbl->Release)(cont->hiddenFrame);
	}
	else {
		(*cont->masterFrame->lpVtbl->GetParent)(cont->masterFrame,(IDirect3DRMFrame3 **)&in_cont);
		if (in_cont != NULL) {
										// IDirect3DRMFrame3->DeleteChild(this, IDirect3DRMFrame3* lpChild)
										//  (this = resData->frame1->GetParent, lpChild = resData->frame1)
			(*(code *)in_cont->masterFrame[0x25].lpVtbl)((IDirect3DRMFrame3 *)in_cont,cont->masterFrame);
										// IDirect3DRMFrame3->Release(this)
										//  (this = resData->frame1->GetParent)
			(*(code *)in_cont->masterFrame[2].lpVtbl)((IDirect3DRMFrame3 *)in_cont);
		}
		(*cont->masterFrame->lpVtbl->Release)(cont->masterFrame);
		(*cont->activityFrame->lpVtbl->Release)(cont->activityFrame);
		(*cont->hiddenFrame->lpVtbl->GetParent)(cont->hiddenFrame,(IDirect3DRMFrame3 **)&in_cont);
		if (in_cont != NULL) {
										// IDirect3DRMFrame3->DeleteChild(this, IDirect3DRMFrame3* lpChild)
										//  (this = resData->frame3->GetParent, lpChild = resData->frame3)
			(*(code *)in_cont->masterFrame[0x25].lpVtbl)((IDirect3DRMFrame3 *)in_cont,cont->hiddenFrame);
										// IDirect3DRMFrame3->Release(this)
										//  (this = resData->frame3->GetParent)
			(*(code *)in_cont->masterFrame[2].lpVtbl)((IDirect3DRMFrame3 *)in_cont);
		}
		(*cont->hiddenFrame->lpVtbl->Release)(cont->hiddenFrame);
	}
	cont->nextFree = globs::containerGlobs.freeList;
	globs::containerGlobs.freeList = cont;
	return;
}



Container * __cdecl
lego::res::Container_Load(Container *parent,char *filename,char *typestr,BOOL looping)
{
	char cVar1;
	ResourceType RVar2;
	int iVar3;
	CFGProperty *prop;
	CFGProperty *prop_00;
	char *pcVar4;
	BOOL3 BVar5;
	BOOL3 BVar6;
	char *pcVar7;
	BOOL BVar8;
	Container *pCVar9;
	byte *file_data;
	IDirect3DRMMesh *mesh;
	Mesh *transMesh;
	AnimClone *animClone;
	uint uVar10;
	uint uVar11;
	undefined4 *puVar12;
	undefined4 *puVar13;
	float10 fVar14;
	Container *local_864;
	float local_860;
	char *local_85c;
	BOOL isNoTexture;
	char filenameBuffer [512];
	char local_650 [508];
	char *apcStack1108 [21];
	char filenameBuffer2 [512];
	char local_200 [512];
	
	local_864 = NULL;
	RVar2 = Container_ParseTypeString(typestr,&isNoTexture);
	uVar10 = 0xffffffff;
	do {
		pcVar4 = filename;
		if (uVar10 == 0) break;
		uVar10 -= 1;
		pcVar4 = filename + 1;
		cVar1 = *filename;
		filename = pcVar4;
	} while (cVar1 != '\0');
	uVar10 = ~uVar10;
	puVar12 = (undefined4 *)(pcVar4 + -uVar10);
	puVar13 = (undefined4 *)filenameBuffer2;
	for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
		*puVar13 = *puVar12;
		puVar12 = puVar12 + 1;
		puVar13 = puVar13 + 1;
	}
	for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
		*(undefined *)puVar13 = *(undefined *)puVar12;
		puVar12 = (undefined4 *)((int)puVar12 + 1);
		puVar13 = (undefined4 *)((int)puVar13 + 1);
	}
	if (RVar2 == RESOURCE_ACT) {
		uVar10 = 0xffffffff;
		pcVar4 = filenameBuffer2;
		do {
			pcVar7 = pcVar4;
			if (uVar10 == 0) break;
			uVar10 -= 1;
			pcVar7 = pcVar4 + 1;
			cVar1 = *pcVar4;
			pcVar4 = pcVar7;
		} while (cVar1 != '\0');
		uVar10 = ~uVar10;
		puVar12 = (undefined4 *)(pcVar7 + -uVar10);
		puVar13 = (undefined4 *)local_200;
		for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
			*puVar13 = *puVar12;
			puVar12 = puVar12 + 1;
			puVar13 = puVar13 + 1;
		}
		for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
			*(undefined *)puVar13 = *(undefined *)puVar12;
			puVar12 = (undefined4 *)((int)puVar12 + 1);
			puVar13 = (undefined4 *)((int)puVar13 + 1);
		}
		iVar3 = util::Util_Tokenise(filenameBuffer2,apcStack1108 + 1,"\\");
		std::sprintf(filenameBuffer,"%s\\%s.%s",local_200,apcStack1108[iVar3],
								 globs::containerGlobs.extensionName[4]);
		prop = cfg::CFG_Open(filenameBuffer);
		if (prop != NULL) {
			std::sprintf(filenameBuffer,"%s%s%s",globs::containerGlobs.gameName,"::","Activities");
			prop_00 = cfg::CFG_GetChildren(prop,filenameBuffer);
			if (prop_00 != NULL) {
				local_864 = Container_Create(parent);
				local_864->type = RESOURCE_ACT;
				do {
					local_85c = prop_00->key;
					if (*local_85c == '!') {
						if ((globs::mainGlobs.flags & CMD_REDUCEANIMATION) == CMD_NONE) {
							if (true) {
								local_85c = local_85c + 1;
							}
							goto LAB_004730ee;
						}
					}
					else {
LAB_004730ee:
						std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value,
												 "::","FILE");
						pcVar4 = cfg::CFG_ReadString(prop,local_650);
						if (pcVar4 != NULL) {
							std::sprintf(filenameBuffer,"%s\\%s",local_200,pcVar4);
							std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value
													 ,"::","TRANSCOEF");
							pcVar4 = cfg::CFG_ReadString(prop,local_650);
							if (pcVar4 == NULL) {
								pcVar4 = ____EMPTYSTR__;
							}
							else {
								pcVar4 = cfg::CFG_ReadString(prop,local_650);
							}
							fVar14 = std::atof(pcVar4);
							local_860 = (float)fVar14;
							std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value
													 ,"::","TRIGGER");
							pcVar4 = cfg::CFG_ReadString(prop,local_650);
							if (pcVar4 == NULL) {
								pcVar4 = ____EMPTYSTR__;
							}
							else {
								pcVar4 = cfg::CFG_ReadString(prop,local_650);
							}
							uVar10 = std::atoi(pcVar4);
							std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value
													 ,"::","LWSFILE");
							BVar5 = cfg::CFG_ReadBool(prop,local_650);
							std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value
													 ,"::","LOOPING");
							BVar6 = cfg::CFG_ReadBool(prop,local_650);
							std::sprintf(local_650,"%s%s%s%s%s",globs::containerGlobs.gameName,"::",prop_00->value
													 ,"::","SAMPLE");
							pcVar7 = cfg::CFG_CopyString(prop,local_650);
							pcVar4 = local_85c;
							BVar8 = Container_AddActivity2
																(local_864,filenameBuffer,local_85c,local_860,uVar10,pcVar7,NULL,
																 (uint)(BVar5 == BOOL3_TRUE),(uint)(BVar6 != BOOL3_FALSE));
							if ((BVar8 != 0) && (local_864->typeData == NULL)) {
								Container_SetActivity(local_864,pcVar4);
							}
						}
					}
					prop_00 = cfg::CFG_NextFlat(prop_00);
				} while (prop_00 != NULL);
			}
			std::sprintf(filenameBuffer,"%s%s%s",globs::containerGlobs.gameName,"::","SCALE");
			pcVar4 = cfg::CFG_ReadString(prop,filenameBuffer);
			if (pcVar4 == NULL) {
				pcVar4 = ____EMPTYSTR__;
			}
			else {
				pcVar4 = cfg::CFG_ReadString(prop,filenameBuffer);
			}
			fVar14 = std::atof(pcVar4);
			local_85c = (char *)(float)fVar14;
			if ((float)local_85c != 0.0) {
				(*local_864->activityFrame->lpVtbl->AddScale)
									(local_864->activityFrame,D3DRMCOMBINE_REPLACE,(float)local_85c,(float)local_85c,
									 (float)local_85c);
			}
			cfg::CFG_Close(prop);
			return local_864;
		}
	}
	else {
		if (RVar2 == RESOURCE_FRAME) {
			pCVar9 = Container_Create(parent);
			pCVar9->type = RESOURCE_FRAME;
			std::sprintf(filenameBuffer,"%s.%s",filenameBuffer2,globs::containerGlobs.extensionName[2]);
			Container_FrameLoad(filenameBuffer,pCVar9->activityFrame);
			return pCVar9;
		}
		if (RVar2 == RESOURCE_MESH) {
			std::sprintf(filenameBuffer,"%s.%s",filenameBuffer2,globs::containerGlobs.extensionName[1]);
			file_data = lego::file::File_LoadBinary(filenameBuffer,(uint *)&local_860);
			if (file_data != NULL) {
				pCVar9 = Container_Create(parent);
				pCVar9->type = RESOURCE_MESH;
				mesh = Container_MeshLoad(file_data,(uint)local_860,filenameBuffer,pCVar9->activityFrame,
																	isNoTexture);
				if (mesh != NULL) {
					Container_SetTypeData(pCVar9,NULL,NULL,mesh,NULL);
				}
				std::free(file_data);
				return pCVar9;
			}
		}
		else {
			if ((RVar2 == RESOURCE_ANIM) || (RVar2 == RESOURCE_LWS)) {
				pCVar9 = Container_Create(parent);
				pCVar9->type = RESOURCE_ANIM;
				std::sprintf(filenameBuffer,"%s.%s",filenameBuffer2,globs::containerGlobs.extensionName[3]);
				animClone = Container_LoadAnimSet
															(filenameBuffer,pCVar9->activityFrame,(uint *)&local_860,
															 (uint)(RVar2 == RESOURCE_LWS),looping);
				if (animClone != NULL) {
					Container_Frame_SetAppData
										(pCVar9->activityFrame,pCVar9,animClone,filenameBuffer2,(uint *)&local_860,NULL,
										 NULL,NULL,NULL,NULL,NULL);
					return pCVar9;
				}
			}
			else {
				if (RVar2 != RESOURCE_LWO) {
					return NULL;
				}
				pCVar9 = Container_Create(parent);
				pCVar9->type = RESOURCE_LWO;
				transMesh = Mesh_Load(filenameBuffer2,pCVar9->activityFrame,isNoTexture);
				if (transMesh != NULL) {
					Container_SetTypeData(pCVar9,NULL,NULL,NULL,transMesh);
					return pCVar9;
				}
			}
			Container_Remove(pCVar9);
		}
	}
	return NULL;
}



BOOL __cdecl lego::res::Container_IsCurrentActivity(Container *cont,char *actname)
{
	IDirect3DRMFrame3 *frame;
	
	if (cont->type == RESOURCE_ACT) {
		frame = Container_Frame_Find(cont,actname,0);
		if (frame != NULL) {
			return TRUE;
		}
	}
	return 0;
}



BOOL __cdecl lego::res::Container_SetActivity(Container *cont,char *actname)
{
	char cVar1;
	IDirect3DRMFrame3 *child;
	IDirect3DRMFrame3 *child_00;
	undefined4 *name;
	uint uVar2;
	uint uVar3;
	char *buffer;
	BOOL BVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	BVar4 = 0;
	if (cont->type == RESOURCE_ACT) {
		child = Container_Frame_Find(cont,actname,1);
		if (child == NULL) {
			BVar4 = 0;
		}
		else {
			buffer = NULL;
			if (((cont->typeData != NULL) && (pcVar6 = cont->typeData->name, pcVar6 != NULL)) &&
				 (child_00 = Container_Frame_Find(cont,pcVar6,0), buffer = pcVar6, child_00 != NULL)) {
				Container_Frame_SafeAddChild(cont->hiddenFrame,child_00);
			}
			Container_Frame_SafeAddChild(cont->activityFrame,child);
			uVar2 = 0xffffffff;
			pcVar6 = actname;
			do {
				if (uVar2 == 0) break;
				uVar2 -= 1;
				cVar1 = *pcVar6;
				pcVar6 = pcVar6 + 1;
			} while (cVar1 != '\0');
			name = (undefined4 *)std::malloc(~uVar2);
			uVar2 = 0xffffffff;
			do {
				pcVar6 = actname;
				if (uVar2 == 0) break;
				uVar2 -= 1;
				pcVar6 = actname + 1;
				cVar1 = *actname;
				actname = pcVar6;
			} while (cVar1 != '\0');
			uVar2 = ~uVar2;
			puVar5 = (undefined4 *)(pcVar6 + -uVar2);
			puVar7 = name;
			for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
				*puVar7 = *puVar5;
				puVar5 = puVar5 + 1;
				puVar7 = puVar7 + 1;
			}
			for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
				*(undefined *)puVar7 = *(undefined *)puVar5;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
				puVar7 = (undefined4 *)((int)puVar7 + 1);
			}
			Container_SetTypeData(cont,(char *)name,NULL,NULL,NULL);
			BVar4 = 1;
			cont->flags = cont->flags | RESDATA_UNK_2;
			if (buffer != NULL) {
				std::free(buffer);
			}
		}
		if (cont->activityCallback != NULL) {
			(*cont->activityCallback)(cont,cont->activityCallbackData);
		}
	}
	return BVar4;
}



BOOL __cdecl lego::res::Container_Light_SetSpotPenumbra(Container *spotlight,float angle)
{
	IDirect3DRMLight *This;
	HRESULT HVar1;
	
	This = spotlight->typeData->light;
	HVar1 = (*This->lpVtbl->SetPenumbra)(This,angle);
	return (uint)(HVar1 == 0);
}



BOOL __cdecl lego::res::Container_Light_SetSpotUmbra(Container *spotlight,float angle)
{
	IDirect3DRMLight *This;
	HRESULT HVar1;
	
	This = spotlight->typeData->light;
	HVar1 = (*This->lpVtbl->SetUmbra)(This,angle);
	return (uint)(HVar1 == 0);
}



BOOL __cdecl lego::res::Container_Light_SetSpotRange(Container *spotlight,float dist)
{
	IDirect3DRMLight *This;
	HRESULT HVar1;
	
	This = spotlight->typeData->light;
	HVar1 = (*This->lpVtbl->SetRange)(This,dist);
	return (uint)(HVar1 == 0);
}



void __cdecl lego::res::Container_Light_SetEnableContainer(Container *light,Container *enable)
{
	IDirect3DRMLight *This;
	
										// IDirect3DRMFrame3->QueryInterface(this, IID_IDirect3DRMFrame,
										// IDirect3DRMFrame** lplpOut)
										//  (downcast: IDirect3DRMFrame3 -> IDirect3DRMFrame)
	(*enable->masterFrame->lpVtbl->QueryInterface)
						((IUnknown *)enable->masterFrame,(IID *)&idl::IID_IDirect3DRMFrame,
						 (IDirect3DRMFrame **)&enable);
	This = light->typeData->light;
										// IDirect3DRMLight->SetEnableFrame(this, IDirect3DRMFrame* lpEnableFrame)
	(*This->lpVtbl->SetEnableFrame)(This,(IDirect3DRMFrame *)enable);
	return;
}



Container * __cdecl
lego::res::Container_MakeLight(Container *parent,D3DRMLightType type,float r,float g,float b)
{
	Container *cont;
	HRESULT HVar1;
	IDirect3DRM3 *light;
	
	cont = Container_Create(parent);
	if (cont != NULL) {
		cont->type = RESOURCE_LIGHT;
										// IDirect3DRM3->CreateLightRGB(this, TD3DRMLightType ltLightType, float vRed,
										// float vGreen, float vBlue, IDirect3DRMLight** lplpD3DRMLight)
		light = globs::mainGlobs.lpD3DRM;
		HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateLightRGB)
											(globs::mainGlobs.lpD3DRM,type,r,g,b,(IDirect3DRMLight **)&parent);
		if (HVar1 == 0) {
										// IDirect3DRMFrame3->AddLight(this, IDirect3DRMLight* lpD3DRMLight)
			(*cont->activityFrame->lpVtbl->AddLight)(cont->activityFrame,(IDirect3DRMLight *)r);
			Container_SetTypeData(cont,NULL,(IDirect3DRMLight *)light,NULL,NULL);
		}
	}
	return cont;
}



Container * __cdecl lego::res::Container_MakeMesh2(Container *parent,ContainerMeshType type)
{
	Container *cont;
	HRESULT HVar1;
	void **data;
	void *pvVar2;
	uint renderFlags;
	Mesh *transMesh;
	IDirect3DRMMesh *unaff_ESI;
	
	cont = Container_Create(parent);
	if (cont != NULL) {
		cont->type = RESOURCE_MESH;
		if (((type == CONTAINER_MESHTYPE_TRANSPARENT) || (type == CONTAINER_MESHTYPE_IMMEDIATE)) ||
			 (type == CONTAINER_MESHTYPE_ADDITIVE)) {
			renderFlags = 0x2000;
			if (type == CONTAINER_MESHTYPE_TRANSPARENT) {
				renderFlags = 0x3000;
			}
			else {
				if (type == CONTAINER_MESHTYPE_ADDITIVE) {
					renderFlags = 0x2800;
				}
			}
			transMesh = Mesh_CreateOnFrame(cont->activityFrame,NULL,renderFlags,NULL,MESH_TYPE_NORM);
			Container_SetTypeData(cont,NULL,NULL,NULL,transMesh);
		}
		else {
			HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateMesh)
												(globs::mainGlobs.lpD3DRM,(IDirect3DRMMesh **)&parent);
			if (HVar1 == 0) {
				(*cont->activityFrame->lpVtbl->AddVisual)(cont->activityFrame,(IDirect3DRMVisual *)parent);
				Container_SetTypeData(cont,NULL,NULL,unaff_ESI,NULL);
				if (type == CONTAINER_MESHTYPE_SEPARATEMESHES) {
					data = (void **)std::malloc(0x14);
					data[2] = &DAT_00000014;
					data[1] = NULL;
					pvVar2 = std::malloc(0x50);
					*data = pvVar2;
					data[3] = NULL;
					data[4] = (void *)0x1;
					(*unaff_ESI->lpVtbl->SetAppData)((IUnknown *)unaff_ESI,(DWORD)data);
					return cont;
				}
				(*unaff_ESI->lpVtbl->SetAppData)((IUnknown *)unaff_ESI,0);
				return cont;
			}
		}
	}
	return cont;
}



IDirect3DRMFrame3 * __cdecl lego::res::Container_GetMasterFrame(Container *cont)
{
	return cont->masterFrame;
}



// WARNING: Type propagation algorithm not settling

Container * __cdecl lego::res::Container_Clone(Container *orig)
{
	char cVar1;
	IDirect3DRMMesh *pIVar2;
	Container_TypeData *pCVar3;
	ResourceType RVar4;
	Container *pCVar5;
	Container *parent;
	Container **ppCVar6;
	Container_TypeData *pCVar7;
	char *pcVar8;
	Container_CloneData *pCVar9;
	float fVar10;
	IDirect3DRMFrame3 **out_frameList;
	char **out_nameList;
	char *pcVar11;
	AnimClone *pAVar12;
	Mesh *pMVar13;
	uint uVar14;
	uint uVar15;
	Container *cont;
	undefined4 *puVar16;
	IDirect3DRMFrame3 **ppIVar17;
	Container *pCVar18;
	undefined4 *puVar19;
	float10 fVar20;
	IDirect3DRMFrame3 *This;
	float fVar21;
	char **ppcVar22;
	char **ppcVar23;
	IDirect3DRMFrame3 **ppIVar24;
	undefined local_54 [52];
	float fStack32;
	int *piStack28;
	IDirect3DRMFrame3 *pIStack4;
	
	cont = orig;
	pCVar18 = NULL;
	if (orig->type == RESOURCE_MESH) {
		pIVar2 = orig->typeData->mesh;
		(*pIVar2->lpVtbl->GetAppData)((IUnknown *)pIVar2);
	}
	if ((cont->type == RESOURCE_ACT) || (cont->type == RESOURCE_ANIM)) {
		if ((cont->cloneData != NULL) && (pCVar5 = cont->cloneData->clonedFrom, pCVar5 != NULL)) {
			cont = pCVar5;
		}
		pCVar9 = cont->cloneData;
		if (pCVar9 == NULL) {
			pCVar5 = Container_GetParent(cont);
			pCVar5 = Container_Create(pCVar5);
			pCVar9 = (Container_CloneData *)std::malloc(0x14);
			cont->cloneData = pCVar9;
			pCVar9->cloneCount = 1;
			ppCVar6 = (Container **)std::malloc(4);
			cont->cloneData->cloneTable = ppCVar6;
			((Container *)cont->cloneData->cloneTable)->masterFrame = (IDirect3DRMFrame3 *)pCVar5;
			cont->cloneData->clonedFrom = NULL;
			cont->cloneData->cloneNumber = NULL;
			cont->cloneData->used = 1;
		}
		else {
			pCVar5 = cont;
			if (pCVar9->used != 0) {
				uVar14 = 0;
				pCVar5 = pCVar18;
				if (pCVar9->cloneCount != 0) {
					ppCVar6 = pCVar9->cloneTable;
					do {
						pCVar5 = *ppCVar6;
						if ((pCVar5 != NULL) && (pCVar5->cloneData->used == 0)) break;
						uVar14 += 1;
						ppCVar6 = ppCVar6 + 1;
						pCVar5 = pCVar18;
					} while (uVar14 < pCVar9->cloneCount);
				}
			}
			pCVar18 = pCVar5;
			if (pCVar5 == NULL) {
				pCVar5 = Container_GetParent(cont);
				pCVar5 = Container_Create(pCVar5);
				uVar14 = cont->cloneData->cloneCount;
				cont->cloneData->cloneCount = uVar14 + 1;
				ppCVar6 = (Container **)
									std::realloc(cont->cloneData->cloneTable,cont->cloneData->cloneCount << 2);
				cont->cloneData->cloneTable = ppCVar6;
				cont->cloneData->cloneTable[uVar14] = pCVar5;
			}
			else {
				pCVar5->cloneData->used = 1;
				parent = Container_GetParent(cont);
				Container_SetParent(pCVar5,parent);
				Container_SetAnimationTime(pCVar5,0.0);
			}
		}
	}
	else {
		pCVar5 = Container_GetParent(cont);
		pCVar5 = Container_Create(pCVar5);
	}
	(*cont->activityFrame->lpVtbl->GetParent)(cont->activityFrame,(IDirect3DRMFrame3 **)&orig);
	This = cont->activityFrame;
	(*This->lpVtbl->GetTransform)(This,pIStack4,(Matrix4F *)(local_54 + 0xc));
	(*pCVar5->activityFrame->lpVtbl->AddTransform)
						(pCVar5->activityFrame,D3DRMCOMBINE_REPLACE,(Matrix4F *)local_54);
	(**(code **)(*piStack28 + 8))(piStack28);
	if (pCVar18 == NULL) {
		pCVar5->type = cont->type;
		if (cont->typeData == NULL) {
			pCVar5->typeData = NULL;
		}
		else {
			pCVar7 = (Container_TypeData *)std::malloc(0x10);
			pCVar5->typeData = pCVar7;
			pCVar3 = cont->typeData;
			pCVar7->name = pCVar3->name;
			pCVar7->light = pCVar3->light;
			pCVar7->mesh = pCVar3->mesh;
			pCVar7->transMesh = pCVar3->transMesh;
			pcVar8 = cont->typeData->name;
			if (pcVar8 != NULL) {
				uVar14 = 0xffffffff;
				do {
					if (uVar14 == 0) break;
					uVar14 -= 1;
					cVar1 = *pcVar8;
					pcVar8 = pcVar8 + 1;
				} while (cVar1 != '\0');
				pcVar8 = (char *)std::malloc(~uVar14);
				pCVar5->typeData->name = pcVar8;
				uVar14 = 0xffffffff;
				pcVar8 = cont->typeData->name;
				do {
					pcVar11 = pcVar8;
					if (uVar14 == 0) break;
					uVar14 -= 1;
					pcVar11 = pcVar8 + 1;
					cVar1 = *pcVar8;
					pcVar8 = pcVar11;
				} while (cVar1 != '\0');
				uVar14 = ~uVar14;
				puVar16 = (undefined4 *)(pcVar11 + -uVar14);
				puVar19 = (undefined4 *)pCVar5->typeData->name;
				for (uVar15 = uVar14 >> 2; uVar15 != 0; uVar15 -= 1) {
					*puVar19 = *puVar16;
					puVar16 = puVar16 + 1;
					puVar19 = puVar19 + 1;
				}
				for (uVar14 &= 3; uVar14 != 0; uVar14 -= 1) {
					*(undefined *)puVar19 = *(undefined *)puVar16;
					puVar16 = (undefined4 *)((int)puVar16 + 1);
					puVar19 = (undefined4 *)((int)puVar19 + 1);
				}
			}
		}
		if ((cont->type == RESOURCE_ACT) || (cont->type == RESOURCE_ANIM)) {
			pCVar9 = (Container_CloneData *)std::malloc(0x14);
			pCVar5->cloneData = pCVar9;
			pCVar9->cloneTable = NULL;
			pCVar5->cloneData->cloneCount = 0;
			pCVar5->cloneData->clonedFrom = cont;
			pCVar5->cloneData->cloneNumber = This;
			pCVar5->cloneData->used = 1;
		}
		RVar4 = pCVar5->type;
		if (RVar4 == RESOURCE_MESH) {
			pIVar2 = pCVar5->typeData->mesh;
			(*pCVar5->activityFrame->lpVtbl->AddVisual)(pCVar5->activityFrame,(IDirect3DRMVisual *)pIVar2)
			;
			(*pIVar2->lpVtbl->AddRef)((IUnknown *)pIVar2);
			return pCVar5;
		}
		if (RVar4 == RESOURCE_ACT) {
			fVar10 = (float)Container_GetActivities(cont,NULL,NULL,NULL);
			uVar14 = (int)fVar10 * 4;
			out_frameList = (IDirect3DRMFrame3 **)std::malloc(uVar14);
			ppIVar24 = out_frameList;
			out_nameList = (char **)std::malloc(uVar14);
			ppcVar23 = out_nameList;
			Container_GetActivities(cont,out_frameList,NULL,out_nameList);
			fStack32 = 0.0;
			if (fVar10 != 0.0) {
				ppIVar17 = out_frameList;
				ppcVar22 = (char **)((int)out_nameList - (int)out_frameList);
				out_nameList = ppcVar23;
				out_frameList = ppIVar24;
				do {
					pcVar8 = Container_Frame_GetAnimSetFileName(*ppIVar17);
					fVar20 = Container_Frame_GetTransCo(*ppIVar17);
					fVar21 = (float)fVar20;
					pcVar11 = Container_Frame_GetSample(*ppIVar17);
					pAVar12 = Container_Frame_GetAnimClone(*ppIVar17);
					uVar14 = Container_Frame_GetTrigger(*ppIVar17);
					Container_Frame_SetAppData(*ppIVar17,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
					ppcVar23 = ppcVar22;
					Container_AddActivity2
										(pCVar5,pcVar8,(char *)(*(int *)((int)ppcVar22 + (int)ppIVar17) + 9),fVar21,
										 uVar14,pcVar11,pAVar12,0,0);
					std::free(*(void **)((int)ppcVar22 + (int)ppIVar17));
					fVar21 = fStack32;
					if ((uint)fStack32 % 0x19 == 0) {
						snd::Sound3D_Update();
					}
					fStack32 = (float)((int)fVar21 + 1);
					ppIVar17 = ppIVar17 + 1;
					ppcVar22 = ppcVar23;
				} while ((uint)fStack32 < (uint)fVar10);
			}
			std::free(out_frameList);
			std::free(out_nameList);
			if (pCVar5->typeData != NULL) {
				Container_SetActivity(pCVar5,pCVar5->typeData->name);
				return pCVar5;
			}
		}
		else {
			if (RVar4 == RESOURCE_ANIM) {
				pcVar8 = Container_Frame_GetAnimSetFileName(cont->activityFrame);
				pAVar12 = Container_Frame_GetAnimClone(cont->activityFrame);
				pAVar12 = AnimClone_Make(pAVar12,pCVar5->activityFrame,(uint *)&fStack32);
				Container_Frame_SetAppData
									(pCVar5->activityFrame,pCVar5,pAVar12,pcVar8,(uint *)&fStack32,NULL,NULL,NULL,NULL
									 ,NULL,NULL);
				return pCVar5;
			}
			if (RVar4 == RESOURCE_LWO) {
				pMVar13 = Mesh_Clone(pCVar5->typeData->transMesh,pCVar5->activityFrame);
				pCVar5->typeData->transMesh = pMVar13;
			}
		}
	}
	return pCVar5;
}



void __cdecl lego::res::Container_Hide2(Container *cont,BOOL hide)
{
	if (hide != 0) {
		cont->flags = cont->flags | RESDATA_UNK_80;
		return;
	}
	cont->flags = cont->flags & ~RESDATA_UNK_80;
	return;
}



void __cdecl lego::res::Container_Hide(Container *cont,BOOL hide)
{
	ResourceDataFlags RVar1;
	
	RVar1 = cont->flags & RESDATA_UNK_8;
	if (hide != 0) {
		if (RVar1 == RESDATA_NONE) {
			Container_Frame_SafeAddChild(cont->hiddenFrame,cont->activityFrame);
			cont->flags = cont->flags | RESDATA_UNK_8;
			return;
		}
		if (hide != 0) {
			return;
		}
	}
	if (RVar1 != RESDATA_NONE) {
		Container_Frame_SafeAddChild(cont->masterFrame,cont->activityFrame);
		cont->flags = cont->flags & ~RESDATA_UNK_8;
	}
	return;
}



BOOL __cdecl lego::res::Container_IsHidden(Container *cont)
{
	return (cont->flags & 0xff) >> 3 & 1;
}



Container * __cdecl
lego::res::Container_SearchTree
					(Container *root,char *name,ContainerSearchMode mode,undefined4 *ref_count)
{
	char cVar1;
	Container *pCVar2;
	uint uVar3;
	Container_SearchData search;
	
	uVar3 = 0xffffffff;
	search.string = name;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *name;
		name = name + 1;
	} while (cVar1 != '\0');
	search.stringLen = ~uVar3 - 1;
	search.caseSensitive = 0;
	search.resultFrame = NULL;
	search.count = 0;
	search.mode = mode;
	if (ref_count == NULL) {
		search.matchNumber = 0;
	}
	else {
		search.matchNumber = *ref_count;
	}
	Container_Frame_WalkTree(root->masterFrame,0,Container_Frame_SearchCallback,&search);
	if ((mode == CONTAINER_SEARCHMODE_FIRSTMATCH) || (mode == CONTAINER_SEARCHMODE_NTHMATCH)) {
		if (search.resultFrame != NULL) {
			pCVar2 = Container_Frame_GetContainer(search.resultFrame);
			return pCVar2;
		}
	}
	else {
		if (mode == CONTAINER_SEARCHMODE_MATCHCOUNT) {
			*ref_count = search.count;
			return NULL;
		}
	}
	return NULL;
}



// Returns a temporary buffer that must be used immediately before the next call to this function.

char * __cdecl lego::res::Container_FormatPartName(Container *cont,char *partname,int *opt_instance)
{
	char *pcVar1;
	AnimClone *clone;
	BOOL BVar2;
	char *pcVar3;
	char *pcVar4;
	IDirect3DRMFrame3 *frame;
	char tempString [1024];
	
	if (cont->type == RESOURCE_ACT) {
		frame = Container_Frame_Find(cont,cont->typeData->name,0);
	}
	else {
		if (cont->type == RESOURCE_ANIM) {
			frame = cont->activityFrame;
		}
	}
	clone = Container_Frame_GetAnimClone(frame);
	BVar2 = AnimClone_IsLws(clone);
	if (BVar2 == 0) {
		pcVar3 = Container_Frame_GetAnimSetFileName(frame);
		std::sprintf(tempString,"%s",pcVar3);
		std::_strlwr(tempString);
		pcVar4 = tempString;
		pcVar3 = tempString;
		while (tempString[0] != '\0') {
			if (tempString[0] == '\\') {
				pcVar3 = pcVar4 + 1;
			}
			pcVar1 = pcVar4 + 1;
			pcVar4 = pcVar4 + 1;
			tempString[0] = *pcVar1;
		}
		if (opt_instance != NULL) {
			std::sprintf(globs::s_FormatPartName_name,"xf_????????_%s_%s_%0.2d_DDc_00",partname,pcVar3,
									 *opt_instance);
			return globs::s_FormatPartName_name;
		}
		pcVar4 = "xf_????????_%s_%s_??_DDc_00";
	}
	else {
		if (opt_instance == NULL) {
			std::sprintf(globs::s_FormatPartName_name,"%s_??",partname);
			return globs::s_FormatPartName_name;
		}
		pcVar3 = (char *)*opt_instance;
		pcVar4 = "%s_%0.2i";
	}
	std::sprintf(globs::s_FormatPartName_name,pcVar4,partname,(int)pcVar3);
	return globs::s_FormatPartName_name;
}



void __cdecl lego::res::Container_SetUserData(Container *cont,void *data)
{
	cont->userData = data;
	return;
}



void * __cdecl lego::res::Container_GetUserData(Container *cont)
{
	return cont->userData;
}



void __cdecl lego::res::Container_EnableFog(BOOL on)
{
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneFogEnable)
						((globs::containerGlobs.rootContainer)->masterFrame,on);
	if (on != 0) {
		(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneBackground)
							((globs::containerGlobs.rootContainer)->masterFrame,globs::containerGlobs.fogColour);
		return;
	}
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneBackground)
						((globs::containerGlobs.rootContainer)->masterFrame,0);
	return;
}



void __cdecl lego::res::Container_SetFogColour(float r,float g,float b)
{
	longlong lVar1;
	longlong lVar2;
	longlong lVar3;
	
	lVar1 = __ftol((float10)g * (float10)255.0);
	lVar2 = __ftol((float10)r * (float10)255.0);
	lVar3 = __ftol((float10)b * (float10)255.0);
	globs::containerGlobs.fogColour =
			 ((uint)lVar1 | ((uint)lVar2 | 0xffffff00) << 8) << 8 | (uint)lVar3;
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneFogColor)
						((globs::containerGlobs.rootContainer)->masterFrame,globs::containerGlobs.fogColour);
	return;
}



void __cdecl lego::res::Container_SetFogMode(D3DRMSceneFogMethod mode)
{
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneFogMode)
						((globs::containerGlobs.rootContainer)->masterFrame,mode);
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneFogMethod)
						((globs::containerGlobs.rootContainer)->masterFrame,globs::mainGlobs.fogMethod);
	return;
}



void __cdecl lego::res::Container_SetFogParams(float start,float end,float density)
{
	(*(globs::containerGlobs.rootContainer)->masterFrame->lpVtbl->SetSceneFogParams)
						((globs::containerGlobs.rootContainer)->masterFrame,start,end,density);
	return;
}



void __cdecl lego::res::Container_SetPerspectiveCorrection(Container *cont,BOOL on)
{
	uint uVar1;
	IDirect3DRMFrame3 **out_frameList;
	D3DRMGroupIndex DVar2;
	IDirect3DRMFrame3 **ppIVar3;
	D3DRMGroupIndex groupID;
	
	if (cont->type == RESOURCE_ACT) {
		uVar1 = Container_GetActivities(cont,NULL,NULL,NULL);
		out_frameList = (IDirect3DRMFrame3 **)std::malloc(uVar1 * 4);
		Container_GetActivities(cont,out_frameList,NULL,NULL);
		ppIVar3 = out_frameList;
		for (; uVar1 != 0; uVar1 -= 1) {
			Container_Frame_WalkTree(*ppIVar3,0,Container_SetPerspectiveCorrectionCallback,&on);
			ppIVar3 = ppIVar3 + 1;
		}
		std::free(out_frameList);
		return;
	}
	if (cont->type == RESOURCE_MESH) {
		DVar2 = Container_Mesh_GetGroupCount(cont);
		groupID = D3DRMGROUP_0;
		if (DVar2 != D3DRMGROUP_0) {
			do {
				Container_Mesh_SetPerspectiveCorrection(cont,groupID,on);
				groupID += 1;
			} while (groupID < DVar2);
		}
	}
	return;
}



BOOL __cdecl
lego::res::Container_SetPerspectiveCorrectionCallback(IDirect3DRMFrame3 *frame,BOOL *lpArg_on)
{
	BOOL BVar1;
	HRESULT HVar2;
	IDirect3DRMVisual *pIVar3;
	IDirect3DRMVisual **ppIVar4;
	int *unaff_ESI;
	IDirect3DRMVisual *lpD3DRMVisual;
	BOOL *local_8;
	LPVOID local_4;
	
	BVar1 = *lpArg_on;
										// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount,
										// IDirect3DRMVisualArray** lplpVisuals)
										// 
										// First get count of array, to confirm its non-zero
	(*frame->lpVtbl->GetVisuals)(frame,(DWORD *)&lpArg_on,NULL);
	if (lpArg_on != NULL) {
										// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount,
										// IDirect3DRMVisualArray** lplpVisuals)
										// 
										// Then get the actual array
		(*frame->lpVtbl->GetVisuals)
							(frame,(DWORD *)&lpArg_on,(IDirect3DRMVisualArray **)globs::containerGlobs.visualArray
							);
		local_8 = NULL;
		if (lpArg_on != NULL) {
			ppIVar4 = globs::containerGlobs.visualArray;
			do {
				pIVar3 = *ppIVar4;
				HVar2 = (*pIVar3->lpVtbl->QueryInterface)
													((IUnknown *)pIVar3,(IID *)&idl::IID_IDirect3DRMMeshBuilder2,&local_4);
				if (HVar2 == 0) {
					(**(code **)(*unaff_ESI + 0x7c))(unaff_ESI,BVar1);
				}
				else {
					HVar2 = (*pIVar3->lpVtbl->QueryInterface)
														((IUnknown *)pIVar3,(IID *)&idl::IID_IDirect3DRMMesh,&local_8);
					if (HVar2 == 0) {
						pIVar3 = (IDirect3DRMVisual *)(*frame->lpVtbl->GetMaterialMode)(frame);
						lpD3DRMVisual = NULL;
						if (pIVar3 != NULL) {
							do {
								(*frame->lpVtbl->AddVisual)(frame,lpD3DRMVisual);
								lpD3DRMVisual =
										 (IDirect3DRMVisual *)((int)&lpD3DRMVisual->lpVtbl + D3DRMMATERIAL_FROMPARENT);
							} while (lpD3DRMVisual < pIVar3);
						}
					}
				}
				local_8 = (BOOL *)((int)local_8 + 1);
				ppIVar4 = ppIVar4 + 1;
			} while (local_8 < lpArg_on);
		}
	}
	return 0;
}



// WARNING: Type propagation algorithm not settling

IDirectDrawSurface4 * __cdecl
lego::res::Container_LoadTextureSurface
					(char *fname,BOOL managed,uint *out_width,uint *out_height,BOOL *out_trans)
{
	BITMAP_FILE_INFO_STRUCT *data;
	HRESULT HVar1;
	BOOL BVar2;
	IDirectDrawSurface4 *pIVar3;
	int iVar4;
	uint uVar5;
	DDSURFACEDESC2 *pDVar6;
	undefined4 *puVar7;
	DDSURFACEDESC2 *pDVar8;
	DDPIXELFORMAT *pDVar9;
	undefined4 *puVar10;
	IDirectDrawSurface4 *ddSurface4;
	uint local_14c;
	DDCOLORKEY local_148;
	IDirectDrawPalette *ddPal2;
	uint length;
	D3DRMImage d3dImage;
	DDSURFACEDESC2 surfDesc;
	DDSURFACEDESC2 local_7c;
	
	ddSurface4 = NULL;
	local_148.dwColorSpaceLowValue = 0;
	data = (BITMAP_FILE_INFO_STRUCT *)lego::file::File_LoadBinary(fname,&length);
	if (data != NULL) {
		lego::image::BMP_Parse(data,length,&d3dImage);
		if ((d3dImage.rgb == 0) && (d3dImage.depth == 8)) {
			pDVar6 = &surfDesc;
			for (iVar4 = 0x1f; iVar4 != 0; iVar4 += -1) {
				pDVar6->dwSize = 0;
				pDVar6 = (DDSURFACEDESC2 *)&pDVar6->dwFlags;
			}
			surfDesc.dwSize = 0x7c;
										// CMD_NM 0x20
			surfDesc.dwFlags = 0x1007;
			surfDesc.dwWidth = d3dImage.width;
			surfDesc.dwHeight = d3dImage.height;
			surfDesc.ddsCaps.dwCaps = 0x1000;
			if ((((byte)globs::mainGlobs.flags & 0x20) == 0) && (managed != 0)) {
				surfDesc.ddsCaps.dwCaps2 = 0x10;
			}
			else {
				surfDesc.ddsCaps.dwCaps = 0x5000;
			}
			surfDesc.ddpfPixelFormat.dwSize = 0x20;
			HVar1 = (*(globs::mainGlobs.device)->lpVtbl->FindPreferredTextureFormat)
												(globs::mainGlobs.device,0x800,4,&surfDesc.ddpfPixelFormat);
			if (HVar1 != 0) {
				pDVar6 = &surfDesc;
				pDVar8 = &local_7c;
				for (iVar4 = 0x1f; iVar4 != 0; iVar4 += -1) {
					pDVar8->dwSize = pDVar6->dwSize;
					pDVar6 = (DDSURFACEDESC2 *)&pDVar6->dwFlags;
					pDVar8 = (DDSURFACEDESC2 *)&pDVar8->dwFlags;
				}
				pDVar9 = &surfDesc.ddpfPixelFormat;
				for (iVar4 = 8; iVar4 != 0; iVar4 += -1) {
					pDVar9->dwSize = 0;
					pDVar9 = (DDPIXELFORMAT *)&pDVar9->dwFlags;
				}
				surfDesc.ddsCaps.dwCaps2 &= 0xffffffef;
				surfDesc.ddsCaps.dwCaps = surfDesc.ddsCaps.dwCaps & 0xffffafff | 0x840;
				surfDesc.ddpfPixelFormat.dwSize = 0x20;
				surfDesc.ddpfPixelFormat.dwFlags = 0x60;
				surfDesc.ddpfPixelFormat.dwRGBBitCount = 8;
				local_148.dwColorSpaceLowValue = 1;
			}
			HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
												(globs::directDrawGlobs.lpDirectDraw,&surfDesc,&ddSurface4,NULL);
			if (HVar1 == 0) {
				pDVar6 = &surfDesc;
				for (iVar4 = 0x1f; iVar4 != 0; iVar4 += -1) {
					pDVar6->dwSize = 0;
					pDVar6 = (DDSURFACEDESC2 *)&pDVar6->dwFlags;
				}
				surfDesc.dwSize = 0x7c;
				HVar1 = (*ddSurface4->lpVtbl->Lock)(ddSurface4,NULL,&surfDesc,1,NULL);
				if (HVar1 == 0) {
					iVar4 = 0;
					if (0 < d3dImage.height) {
						do {
							puVar7 = (undefined4 *)d3dImage.buffer1;
							puVar10 = (undefined4 *)surfDesc.lpSurface;
							for (uVar5 = (uint)d3dImage.bytes_per_line >> 2; uVar5 != 0; uVar5 -= 1) {
								*puVar10 = *puVar7;
								puVar7 = puVar7 + 1;
								puVar10 = puVar10 + 1;
							}
							for (uVar5 = d3dImage.bytes_per_line & 3; uVar5 != 0; uVar5 -= 1) {
								*(undefined *)puVar10 = *(undefined *)puVar7;
								puVar7 = (undefined4 *)((int)puVar7 + 1);
								puVar10 = (undefined4 *)((int)puVar10 + 1);
							}
							surfDesc.lpSurface = (LPVOID)((int)surfDesc.lpSurface + surfDesc.lPitch);
							d3dImage.buffer1 = (byte *)((int)d3dImage.buffer1 + d3dImage.bytes_per_line);
							iVar4 += 1;
						} while (iVar4 < d3dImage.height);
					}
					(*ddSurface4->lpVtbl->Unlock)(ddSurface4,NULL);
					HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreatePalette)
														(globs::directDrawGlobs.lpDirectDraw,0x4c,
														 (D3DRMPaletteEntry *)d3dImage.alpha_mask,
														 (IDirectDrawPalette **)&local_148.dwColorSpaceHighValue,NULL);
					if (HVar1 == 0) {
						HVar1 = (*ddSurface4->lpVtbl->SetPalette)(ddSurface4,ddPal2);
						if (HVar1 == 0) {
							if (local_148.dwColorSpaceLowValue != 0) {
								puVar7 = (undefined4 *)&local_7c.ddpfPixelFormat;
								for (iVar4 = 8; iVar4 != 0; iVar4 += -1) {
									*puVar7 = 0;
									puVar7 = puVar7 + 1;
								}
								local_7c.ddpfPixelFormat.dwSize = 0x20;
								HVar1 = (*(globs::mainGlobs.device)->lpVtbl->FindPreferredTextureFormat)
																	(globs::mainGlobs.device,0x400,0,&local_7c.ddpfPixelFormat);
								pIVar3 = ddSurface4;
								if ((HVar1 == 0) &&
									 (HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
																			(globs::directDrawGlobs.lpDirectDraw,&local_7c,&ddSurface4,
																			 NULL), HVar1 == 0)) {
									if (local_7c.ddpfPixelFormat.dwRGBBitCount == 0x10) {
										ddraw::DirectDraw_Blt8To16(ddSurface4,pIVar3,d3dImage.palette);
									}
									(*pIVar3->lpVtbl->Release)(pIVar3);
								}
							}
							if (out_trans != NULL) {
								BVar2 = Container_GetDecalColour(fname,&local_14c);
								if (BVar2 == 0) {
									*out_trans = 0;
								}
								else {
									if (local_148.dwColorSpaceLowValue != 0) {
										local_14c = ddraw::DirectDraw_GetColour
																					(ddSurface4,
																					 (uint)CONCAT21(CONCAT11(d3dImage.palette[local_14c].red,
																																	 d3dImage.palette[local_14c].green
																																	),d3dImage.palette[local_14c].blue
																												 ));
									}
									local_148.dwColorSpaceLowValue = local_14c;
									local_148.dwColorSpaceHighValue = local_14c;
									(*ddSurface4->lpVtbl->SetColorKey)(ddSurface4,8,&local_148);
									*out_trans = 1;
								}
							}
							if (out_width != NULL) {
								*out_width = d3dImage.width;
							}
							if (out_height != NULL) {
								*out_height = d3dImage.height;
							}
							(*ddSurface4->lpVtbl->AddRef)((IUnknown *)ddSurface4);
						}
						(*ddPal2->lpVtbl->Release)(ddPal2);
					}
				}
				pIVar3 = (IDirectDrawSurface4 *)(*ddSurface4->lpVtbl->Release)(ddSurface4);
				if (pIVar3 == NULL) {
					ddSurface4 = pIVar3;
				}
			}
		}
		lego::image::BMP_Cleanup(&d3dImage);
		std::free(data);
	}
	return ddSurface4;
}



BOOL __cdecl lego::res::Container_GetDecalColour(char *fname,uint *out_colour)
{
	char *pcVar1;
	byte *str;
	char cVar2;
	uint uVar3;
	char *pcVar4;
	
	cVar2 = *fname;
	pcVar4 = fname;
	while (cVar2 != '\0') {
		if (cVar2 == '\\') {
			pcVar4 = fname + 1;
		}
		pcVar1 = fname + 1;
		fname = fname + 1;
		cVar2 = *pcVar1;
	}
	if ((*pcVar4 == 'a') || (*pcVar4 == 'A')) {
		str = (byte *)(pcVar4 + 1);
										// std::isdigit(c)
		if (std::globals::_pcharwidth < 2) {
			uVar3 = *(byte *)(std::globals::_pctype + *str) & C1_DIGIT;
		}
		else {
			uVar3 = std::_isctype((uint)*str,4);
		}
		if (uVar3 != 0) {
										// std::isdigit(c)
			if (std::globals::_pcharwidth < 2) {
				uVar3 = *(byte *)(std::globals::_pctype + (byte)pcVar4[2]) & C1_DIGIT;
			}
			else {
				uVar3 = std::_isctype((uint)(byte)pcVar4[2],4);
			}
			if (uVar3 != 0) {
										// std::isdigit(c)
				if (std::globals::_pcharwidth < 2) {
					uVar3 = *(byte *)(std::globals::_pctype + (byte)pcVar4[3]) & C1_DIGIT;
				}
				else {
					uVar3 = std::_isctype((uint)(byte)pcVar4[3],4);
				}
				if ((uVar3 != 0) && (pcVar4[4] == '_')) {
					uVar3 = std::atoi((char *)str);
					*out_colour = uVar3;
					return TRUE;
				}
			}
		}
	}
	return 0;
}



// WARNING: Type propagation algorithm not settling

Container_Texture * __cdecl
lego::res::Container_LoadTexture2(char *fname,BOOL immediate,uint *out_width,uint *out_height)
{
	byte bVar1;
	byte bVar2;
	D3DRMPaletteEntry *pDVar3;
	int *piVar4;
	char *fname_00;
	char *lpFileName;
	Container_Texture *buffer;
	IDirectDrawSurface4 *This;
	HRESULT HVar5;
	BOOL BVar6;
	D3DRMImage *pDVar7;
	int *piVar8;
	byte bVar9;
	undefined uVar10;
	ushort uVar11;
	undefined uVar12;
	undefined uVar13;
	undefined2 uVar14;
	IDirect3DRMTexture3 *local_c;
	undefined4 uStack4;
	
	fname_00 = fname;
	local_c = NULL;
	lpFileName = lego::file::File_VerifyFilename(fname);
	buffer = (Container_Texture *)std::malloc(0xc);
	if (buffer != NULL) {
		if (immediate == 0) {
			HVar5 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->LoadTexture)
												(globs::mainGlobs.lpD3DRM,lpFileName,&local_c);
			if (HVar5 == 0) {
				pDVar7 = (*local_c->lpVtbl->GetImage)(local_c);
				if (pDVar7 != NULL) {
					BVar6 = Container_GetDecalColour(fname_00,(uint *)&fname);
					if (BVar6 != 0) {
						pDVar3 = pDVar7->palette;
						bVar9 = pDVar3[(int)fname].red;
						bVar1 = pDVar3[(int)fname].blue;
						bVar2 = pDVar3[(int)fname].green;
						(*local_c->lpVtbl->SetDecalTransparency)(local_c,1);
						(*local_c->lpVtbl->SetDecalTransparentColor)
											(local_c,(uint)CONCAT21(CONCAT11(bVar9,bVar2),bVar1));
					}
					if (out_width != NULL) {
						*out_width = pDVar7->width;
					}
					if ((IDirectDrawPalette *)out_height != NULL) {
						*out_height = (uint)((IDirectDrawPalette *)&pDVar7->height)->lpVtbl;
					}
				}
				buffer->surface = NULL;
				buffer->texture = local_c;
				(*local_c->lpVtbl->SetAppData)((IUnknown *)local_c,(DWORD)buffer);
				return buffer;
			}
		}
		else {
			This = Container_LoadTextureSurface(fname_00,immediate,out_width,out_height,NULL);
			if (This != NULL) {
				HVar5 = (*This->lpVtbl->QueryInterface)
													((IUnknown *)This,(IID *)&idl::IID_IDirectDrawSurface,&out_width);
				if (HVar5 == 0) {
					HVar5 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateTextureFromSurface)
														(globs::mainGlobs.lpD3DRM,(IDirectDrawSurface4 *)out_width,&local_c);
					if (HVar5 == 0) {
						(**(code **)(*out_width + 8))((IUnknown *)out_width);
						BVar6 = Container_GetDecalColour(fname_00,(uint *)&fname);
						if (BVar6 != 0) {
							(*This->lpVtbl->GetPalette)(This,(IDirectDrawPalette **)&out_height);
							uVar12 = 1;
							uVar13 = 0;
							uVar14 = 0;
							bVar9 = (byte)uStack4;
							uVar10 = (undefined)((uint)uStack4 >> 8);
							uVar11 = (ushort)((uint)uStack4 >> 0x10);
							piVar8 = NULL;
										// IDirectDrawPalette::GetEntries(THIS_ DWORD dwFlags, DWORD dwBase, DWORD
										// dwNumEntries, D3DRMPALETTEENTRY* lpEntries)
							(**(code **)(*(int *)immediate + 0x10))(immediate,0,bVar9,1,&stack0xfffffff0);
							(*local_c->lpVtbl->Release)((IUnknown *)local_c);
							piVar4 = (int *)CONCAT22(uVar14,CONCAT11(uVar13,uVar12));
							(**(code **)(*piVar4 + 0x50))(piVar4,1);
							(**(code **)(*piVar8 + 0x54))
												(piVar8,((uint)bVar9 << 8 | CONCAT21(uVar11,uVar10) & 0xff) << 8 |
																uVar11 & 0xff);
						}
						buffer->surface = This;
						buffer->texture = local_c;
						(*local_c->lpVtbl->SetAppData)((IUnknown *)local_c,(DWORD)buffer);
						return buffer;
					}
					(**(code **)(*out_width + 8))();
				}
				(*This->lpVtbl->Release)((IUnknown *)This);
				std::free(buffer);
				return NULL;
			}
		}
		std::free(buffer);
	}
	return NULL;
}



void __cdecl lego::res::Container_FreeTexture(Container_Texture *text)
{
	IDirectDrawSurface4 *pIVar1;
	IDirect3DRMTexture3 *pIVar2;
	ULONG UVar3;
	
	if (text != NULL) {
		pIVar1 = text->surface;
		if (pIVar1 != NULL) {
			UVar3 = (*pIVar1->lpVtbl->Release)(pIVar1);
			while (UVar3 != 0) {
				UVar3 = (*text->surface->lpVtbl->Release)(text->surface);
			}
		}
		pIVar2 = text->texture;
		if (pIVar2 != NULL) {
			UVar3 = (*pIVar2->lpVtbl->Release)(pIVar2);
			while (UVar3 != 0) {
				UVar3 = (*text->texture->lpVtbl->Release)(text->texture);
			}
		}
	}
	return;
}



void __cdecl lego::res::Container_Mesh_Swap(Container *target,Container *origin,BOOL restore)
{
	IDirect3DRMVisual *pIVar1;
	IDirect3DRMMesh *lpD3DRMVisual;
	int unaff_EBX;
	uint uVar2;
	IDirect3DRMVisual **ppIVar3;
	IDirect3DRMFrame3 *This;
	
	if (target->type == RESOURCE_REFERENCE) {
		This = target->masterFrame;
	}
	else {
		This = target->activityFrame;
	}
	if (restore != 0) {
										// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount,
										// IDirect3DRMVisualArray** lplpVisuals)
										// 
										// First get count of array, to confirm its non-zero
		(*This->lpVtbl->GetVisuals)(This,(DWORD *)&restore,NULL);
		if (restore != 0) {
										// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount,
										// IDirect3DRMVisualArray** lplpVisuals)
										// 
										// Then get the actual array
			(*This->lpVtbl->GetVisuals)(This,(DWORD *)&restore,globs::containerGlobs.visualArray);
			uVar2 = 0;
			if (restore != 0) {
				ppIVar3 = globs::containerGlobs.visualArray;
				do {
					(*This->lpVtbl->DeleteVisual)(This,*ppIVar3);
					uVar2 += 1;
					ppIVar3 = ppIVar3 + 1;
				} while (uVar2 < (uint)restore);
			}
		}
		(*target->hiddenFrame->lpVtbl->GetVisuals)(target->hiddenFrame,(DWORD *)&restore,NULL);
		if (restore != 0) {
			(*target->hiddenFrame->lpVtbl->GetVisuals)
								(target->hiddenFrame,(DWORD *)&restore,globs::containerGlobs.visualArray);
			uVar2 = 0;
			if (restore != 0) {
				ppIVar3 = globs::containerGlobs.visualArray;
				do {
					pIVar1 = *ppIVar3;
					(*This->lpVtbl->AddVisual)(This,pIVar1);
					(**(code **)(**(int **)(unaff_EBX + 8) + 0xa0))(*(int **)(unaff_EBX + 8),pIVar1);
					uVar2 += 1;
					ppIVar3 = ppIVar3 + 1;
				} while (uVar2 < (uint)restore);
			}
		}
		target->flags = target->flags & 0xfffffffb;
		return;
	}
	(*This->lpVtbl->GetVisuals)(This,(DWORD *)&restore,NULL);
	if (restore != 0) {
		(*This->lpVtbl->GetVisuals)(This,(DWORD *)&restore,(IDirect3DRMVisual **)0x76be24);
		uVar2 = 0;
		if (restore != 0) {
			ppIVar3 = globs::containerGlobs.visualArray;
			do {
				pIVar1 = *ppIVar3;
				(*target->hiddenFrame->lpVtbl->AddVisual)(target->hiddenFrame,pIVar1);
				(*This->lpVtbl->DeleteVisual)(This,pIVar1);
				uVar2 += 1;
				ppIVar3 = ppIVar3 + 1;
			} while (uVar2 < (uint)restore);
		}
	}
	if (origin != NULL) {
		lpD3DRMVisual = origin->typeData->mesh;
		if (lpD3DRMVisual == NULL) {
			(*This->lpVtbl->AddVisual)(This,(IDirect3DRMVisual *)origin->typeData->transMesh->uv);
			target->flags = target->flags | 4;
			return;
		}
		(*This->lpVtbl->AddVisual)(This,(IDirect3DRMVisual *)lpD3DRMVisual);
	}
	target->flags = target->flags | 4;
	return;
}



uint __cdecl
lego::res::Container_Mesh_AddGroup
					(Container *cont,uint vertexCount,uint faceCount,uint vPerFace,uint *faceData)
{
	Mesh *mesh;
	Container *pCVar1;
	void *pvVar2;
	void **ppvVar3;
	HRESULT HVar4;
	int iVar5;
	int *unaff_EDI;
	IDirect3DRMVisual *local_4;
	
	pCVar1 = cont;
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		pvVar2 = (void *)Mesh_AddGroup(mesh,vertexCount,faceCount,vPerFace,faceData);
		return (uint)pvVar2;
	}
	cont = (Container *)cont->typeData->mesh;
	ppvVar3 = (void **)(*((IDirect3DRMMeshVtbl *)cont->masterFrame)->GetAppData)((IUnknown *)cont);
	if (ppvVar3 != NULL) {
		if (ppvVar3[4] == NULL) {
			if (ppvVar3[1] == ppvVar3[2]) {
				return (uint)(void *)0xffffffff;
			}
			HVar4 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateMesh)
												(globs::mainGlobs.lpD3DRM,(IDirect3DRMMesh **)&cont);
			if (HVar4 != 0) {
				return (uint)(void *)0xffffffff;
			}
			*(IDirect3DRMVisual **)((int)*ppvVar3 + (int)ppvVar3[1] * 4) = local_4;
			ppvVar3[1] = (void *)((int)ppvVar3[1] + 1);
			(*pCVar1->activityFrame->lpVtbl->AddVisual)(pCVar1->activityFrame,local_4);
			(**(code **)(*unaff_EDI + 0x18))(unaff_EDI,(uint)ppvVar3[1] | 0x80000000);
			if ((ppvVar3[1] == ppvVar3[2]) &&
				 (pvVar2 = std::realloc(*ppvVar3,(int)ppvVar3[2] * 4 + 0x50), pvVar2 != NULL)) {
				*ppvVar3 = pvVar2;
				ppvVar3[2] = (void *)((int)ppvVar3[2] + 0x14);
			}
		}
		else {
			ppvVar3[4] = NULL;
		}
	}
	iVar5 = (*(code *)cont->masterFrame[0xe].lpVtbl)
										(cont,vertexCount,faceCount,vPerFace,faceData,&local_4);
	if (iVar5 != 0) {
		return (uint)(void *)0xffffffff;
	}
	if (ppvVar3 == NULL) {
		return (uint)(void *)faceCount;
	}
	return (uint)ppvVar3[1];
}



uint __cdecl lego::res::Container_Mesh_GetGroupCount(Container *cont)
{
	Mesh *mesh;
	IDirect3DRMMesh *pIVar1;
	uint uVar2;
	DWORD DVar3;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		uVar2 = Mesh_GetGroupCount(mesh);
		return uVar2;
	}
	pIVar1 = cont->typeData->mesh;
	DVar3 = (*pIVar1->lpVtbl->GetAppData)((IUnknown *)pIVar1);
	if (DVar3 != 0) {
		return *(int *)(DVar3 + 4) + 1;
	}
	pIVar1 = cont->typeData->mesh;
	uVar2 = (*pIVar1->lpVtbl->GetGroupCount)(pIVar1);
	return uVar2;
}



void __cdecl
lego::res::Container_Mesh_SetQuality
					(Container *cont,D3DRMGroupIndex groupID,GraphicsQuality quality)
{
	Container *pCVar1;
	D3DRMRenderQuality uVar2;
	
	pCVar1 = cont;
	if (cont->typeData->transMesh == NULL) {
										// D3DRM render quality, same as seen with Main::Quality
		uVar2 = 0x40;
		if (quality != QUALITY_WIREFRAME) {
			uVar2 = groupID;
		}
		if (quality == QUALITY_UNLITFLAT) {
			uVar2 = D3DRMRENDER_UNLITFLAT;
		}
		if (quality == QUALITY_FLAT) {
			uVar2 = 0x88;
		}
		if (quality == QUALITY_GOURAUD) {
			uVar2 = 0x89;
		}
		cont = (Container *)cont->typeData->mesh;
		Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
		(*pCVar1->typeData->mesh->lpVtbl->SetGroupQuality)((IDirect3DRMMesh *)cont,groupID,uVar2);
	}
	return;
}



BOOL __cdecl lego::res::Container_Mesh_IsGroupHidden(Container *cont,D3DRMGroupIndex group)
{
	Mesh *mesh;
	IDirect3DRMMesh *This;
	Container *pCVar1;
	int *piVar2;
	uint uVar3;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		pCVar1 = (Container *)Mesh_IsGroupHidden(mesh,group);
		return (BOOL)pCVar1;
	}
	This = cont->typeData->mesh;
	piVar2 = (int *)(*This->lpVtbl->GetAppData)((IUnknown *)This);
	if (piVar2 != NULL) {
		if (cont != NULL) {
			piVar2 = *(int **)(*piVar2 + -4 + (int)cont * 4);
			uVar3 = (**(code **)(*piVar2 + 0x1c))(piVar2);
			return (BOOL)(~uVar3 >> 0x1f);
		}
		return (BOOL)(Container *)piVar2[3];
	}
	return (BOOL)cont;
}



void __cdecl lego::res::Container_Mesh_HideGroup(Container *cont,D3DRMGroupIndex group,BOOL hide)
{
	Mesh *mesh;
	int *piVar1;
	DWORD DVar2;
	uint uVar3;
	IDirect3DRMMesh *This;
	IDirect3DRMMesh *This_00;
	int unaff_retaddr;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		Mesh_HideGroup(mesh,group,hide);
		return;
	}
	This_00 = cont->typeData->mesh;
	piVar1 = (int *)(*This_00->lpVtbl->GetAppData)((IUnknown *)This_00);
	if (piVar1 == NULL) {
		return;
	}
	if (cont == NULL) {
		uVar3 = piVar1[3];
		This = NULL;
	}
	else {
		This = *(IDirect3DRMMesh **)(*piVar1 + -4 + (int)cont * 4);
		DVar2 = (*This->lpVtbl->GetAppData)((IUnknown *)This);
		uVar3 = ~DVar2 >> 0x1f;
		This_00 = This;
	}
	if (group != D3DRMGROUP_0) {
		if (uVar3 == 0) {
			(**(code **)(**(int **)(unaff_retaddr + 4) + 0xa0))(*(int **)(unaff_retaddr + 4),This_00);
			goto LAB_00474e84;
		}
		if (group != D3DRMGROUP_0) goto LAB_00474e84;
	}
	if (uVar3 != 0) {
		(**(code **)(**(int **)(unaff_retaddr + 4) + 0x48))(*(int **)(unaff_retaddr + 4),This_00);
	}
LAB_00474e84:
	if (This == NULL) {
		piVar1[3] = group;
		return;
	}
	DVar2 = (*This->lpVtbl->GetAppData)((IUnknown *)This);
	if (group == D3DRMGROUP_0) {
		(*This->lpVtbl->SetAppData)((IUnknown *)This,DVar2 & 0x7fffffff | 0x80000000);
		return;
	}
	(*This->lpVtbl->SetAppData)((IUnknown *)This,DVar2 & 0x7fffffff);
	return;
}



BOOL __cdecl
lego::res::Container_Mesh_HandleSeperateMeshGroups
					(IDirect3DRMMesh **ref_mesh,D3DRMGroupIndex *ref_groupID)
{
	int *piVar1;
	
	piVar1 = (int *)(*(*ref_mesh)->lpVtbl->GetAppData)(*ref_mesh);
	if (piVar1 != NULL) {
		if (*ref_groupID != D3DRMGROUP_0) {
			*ref_mesh = *(IDirect3DRMMesh **)(*piVar1 + -4 + *ref_groupID * 4);
		}
		*ref_groupID = D3DRMGROUP_0;
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::res::Container_Mesh_GetGroup
					(Container *cont,D3DRMGroupIndex groupID,uint *out_vertexCount,uint *out_faceCount,
					uint *out_vPerFace,uint *out_faceDataSize,uint *out_faceData)
{
	Mesh *mesh;
	Mesh_Group *pMVar1;
	int iVar2;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		pMVar1 = Mesh_GetGroup(mesh,groupID,out_vertexCount,out_faceCount,out_vPerFace,out_faceDataSize,
													 out_faceData);
		return (BOOL)pMVar1;
	}
	cont = (Container *)cont->typeData->mesh;
	Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
	iVar2 = (*(code *)cont->masterFrame[0x17].lpVtbl)
										(cont,groupID,out_vertexCount,out_faceCount,out_vPerFace,out_faceDataSize,
										 out_faceData);
	return (BOOL)(Mesh_Group *)(uint)(iVar2 == 0);
}



// Returns -1 on failure, and 0 on success

uint __cdecl
lego::res::Container_Mesh_GetVertices
					(Container *cont,D3DRMGroupIndex groupID,uint index,uint count,D3DRMVertex *out_retArray)
{
	Mesh *mesh;
	D3DRMGroupIndex DVar1;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		Mesh_GetVertices(mesh,groupID,index,count,out_retArray);
		return groupID;
	}
	cont = (Container *)cont->typeData->mesh;
	Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
	DVar1 = (*(code *)cont->masterFrame[0x18].lpVtbl)(cont,groupID,index,count,out_retArray);
	if (DVar1 != D3DRMGROUP_0) {
		DVar1 = D3DRMGROUP_ALLGROUPS;
	}
	return DVar1;
}



uint __cdecl
lego::res::Container_Mesh_SetVertices
					(Container *cont,D3DRMGroupIndex groupID,uint index,uint count,D3DRMVertex *values)
{
	Mesh *mesh;
	D3DRMGroupIndex DVar1;
	
										// Returns 0 on success and -1 on failure
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		Mesh_SetVertices(mesh,groupID,index,count,values);
		return groupID;
	}
	cont = (Container *)cont->typeData->mesh;
	Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
	DVar1 = (*(code *)cont->masterFrame[0xf].lpVtbl)(cont,groupID,index,count,values);
	if (DVar1 != D3DRMGROUP_0) {
		DVar1 = D3DRMGROUP_ALLGROUPS;
	}
	return DVar1;
}



void __cdecl
lego::res::Container_Mesh_SetTexture
					(Container *cont,D3DRMGroupIndex groupID,Container_Texture *ref_itext)
{
	Mesh *mesh;
	IDirect3DRMTexture3 *This;
	int *unaff_retaddr;
	
	if (ref_itext == NULL) {
		This = NULL;
	}
	else {
		This = ref_itext->texture;
	}
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		Mesh_SetGroupTexture(mesh,groupID,ref_itext);
		return;
	}
	cont = (Container *)cont->typeData->mesh;
	Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
	if (This == NULL) {
		ref_itext = NULL;
	}
	else {
		(*This->lpVtbl->QueryInterface)((IUnknown *)This,(IID *)&idl::IID_IDirect3DRMTexture,&ref_itext)
		;
	}
										// IDirect3DRMMesh->SetGroupTexture(this, D3DRMGroupIndex id,
										// IDirect3DRMTexture* lpTexture)
	(*(code *)cont->masterFrame[0x15].lpVtbl)(cont,groupID,ref_itext);
	if (unaff_retaddr != NULL) {
		(**(code **)(*unaff_retaddr + 8))(unaff_retaddr);
	}
	return;
}



void __cdecl
lego::res::Container_Mesh_SetPerspectiveCorrection(Container *cont,D3DRMGroupIndex groupID,BOOL on)
{
	if (cont->typeData->transMesh == NULL) {
		cont = (Container *)cont->typeData->mesh;
		Container_Mesh_HandleSeperateMeshGroups((IDirect3DRMMesh **)&cont,&groupID);
										// IDirect3DRMMesh->SetGroupMapping(this, int id, D3DRMMapping value)
										//   D3DRMMAP_WRAPU        = 0x1,
										//   D3DRMMAP_WRAPV        = 0x2,
										//   D3DRMMAP_PERSPCORRECT = 0x4,
		if (on != 0) {
			(*(code *)cont->masterFrame[0x12].lpVtbl)((IDirect3DRMMesh *)cont,groupID,4);
			return;
		}
		(*(code *)cont->masterFrame[0x12].lpVtbl)((IDirect3DRMMesh *)cont,groupID,0);
	}
	return;
}



BOOL __cdecl lego::res::Container_Mesh_Scale(Container *cont,float x,float y,float z)
{
	Mesh *mesh;
	IDirect3DRMMesh *This;
	int *piVar1;
	int *piVar2;
	undefined4 unaff_ESI;
	uint uVar3;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		Mesh_Scale(mesh,x,y,z);
		return 0;
	}
	This = cont->typeData->mesh;
	(*This->lpVtbl->Scale)(This,x,y,z);
	piVar2 = (int *)(*This->lpVtbl->GetAppData)((IUnknown *)This);
	if ((piVar2 != NULL) && (uVar3 = 0, piVar2[1] != 0)) {
		do {
			piVar1 = *(int **)(*piVar2 + uVar3 * 4);
			(**(code **)(*piVar1 + 0x2c))(piVar1,unaff_ESI,y,z);
			uVar3 += 1;
		} while (uVar3 < (uint)piVar2[1]);
	}
	return 0;
}



BOOL __cdecl lego::res::Container_Mesh_GetBox(Container *cont,D3DRMBox *out_box)
{
	float fVar1;
	IDirect3DRMMesh *This;
	int *piVar2;
	int *piVar3;
	float unaff_EBX;
	float unaff_ESI;
	float unaff_EDI;
	uint uVar4;
	float local_18;
	float local_14;
	float local_10;
	
	This = cont->typeData->mesh;
	(*This->lpVtbl->GetBox)(This,out_box);
	piVar3 = (int *)(*This->lpVtbl->GetAppData)((IUnknown *)This);
	if ((piVar3 != NULL) && (uVar4 = 0, piVar3[1] != 0)) {
		do {
			piVar2 = *(int **)(*piVar3 + uVar4 * 4);
			(**(code **)(*piVar2 + 0x34))(piVar2,&stack0xffffffdc);
			if (unaff_EDI < (out_box->min).x) {
				(out_box->min).x = unaff_EDI;
			}
			if (unaff_ESI < (out_box->min).y) {
				(out_box->min).y = unaff_ESI;
			}
			if (unaff_EBX < (out_box->min).z) {
				(out_box->min).z = unaff_EBX;
			}
			fVar1 = (out_box->max).x;
			if ((ushort)((ushort)(local_18 < fVar1) << 8 | (ushort)(local_18 == fVar1) << 0xe) == 0) {
				(out_box->max).x = local_18;
			}
			fVar1 = (out_box->max).y;
			if ((ushort)((ushort)(local_14 < fVar1) << 8 | (ushort)(local_14 == fVar1) << 0xe) == 0) {
				(out_box->max).y = local_14;
			}
			fVar1 = (out_box->max).z;
			if ((ushort)((ushort)(local_10 < fVar1) << 8 | (ushort)(local_10 == fVar1) << 0xe) == 0) {
				(out_box->max).z = local_10;
			}
			uVar4 += 1;
		} while (uVar4 < (uint)piVar3[1]);
	}
	return 0;
}



void __cdecl
lego::res::Container_Mesh_SetEmissive
					(Container *cont,D3DRMGroupIndex groupID,float r,float g,float b)
{
	Mesh *mesh;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		Mesh_SetGroupColour(mesh,groupID,r,g,b,MATERIAL_EMISSIVE);
	}
	return;
}



void __cdecl
lego::res::Container_Mesh_SetColourAlpha
					(Container *cont,D3DRMGroupIndex groupID,float r,float g,float b,float a)
{
	Mesh *mesh;
	
	mesh = cont->typeData->transMesh;
	if (mesh != NULL) {
		Mesh_SetGroupColour(mesh,groupID,r,g,b,MATERIAL_DIFFUSE);
		Mesh_SetGroupMaterialValues(mesh,groupID,a,MATERIAL_ALPHA);
	}
	return;
}



void __cdecl
lego::res::Container_Transform(Container *cont,Vector3F *out_vector,Vector3F *in_vector)
{
	(*(code *)cont->masterFrame->lpVtbl->Transform)(cont->masterFrame,out_vector,in_vector);
	return;
}



void __cdecl
lego::res::Container_InverseTransform(Container *cont,Vector3F *out_vector,Vector3F *in_vector)
{
	(*cont->masterFrame->lpVtbl->InverseTransform)(cont->masterFrame,out_vector,in_vector);
	return;
}



void __cdecl lego::res::Container_SetColourAlpha(Container *cont,float r,float g,float b,float a)
{
	IDirect3DRMLight *This;
	longlong lVar1;
	longlong lVar2;
	longlong lVar3;
	longlong lVar4;
	
	lVar1 = __ftol((float10)r * (float10)255.0);
	lVar2 = __ftol((float10)a * (float10)255.0);
	lVar3 = __ftol((float10)g * (float10)255.0);
	lVar4 = __ftol((float10)b * (float10)255.0);
	if (cont->type == RESOURCE_LIGHT) {
		This = cont->typeData->light;
		(*This->lpVtbl->SetColor)
							(This,(((uint)lVar1 | (int)lVar2 << 8) << 8 | (uint)lVar3) << 8 | (uint)lVar4);
	}
	return;
}



float10 __cdecl lego::res::Container_MoveAnimation(Container *cont,float delta)
{
	float10 fVar1;
	
	fVar1 = Container_GetAnimationTime(cont);
	fVar1 = Container_SetAnimationTime(cont,(float)(fVar1 + (float10)delta));
	return fVar1;
}



float10 __cdecl lego::res::Container_SetAnimationTime(Container *cont,float time)
{
	float fVar1;
	IDirect3DRMFrame3 *frame;
	char *sampleName;
	uint uVar2;
	uint uVar3;
	ResourceDataFlags RVar4;
	float10 fVar5;
	AnimClone *local_14;
	float local_10;
	
	local_14 = NULL;
	local_10 = 0.0;
	if (cont->type == RESOURCE_ACT) {
		frame = Container_Frame_Find(cont,cont->typeData->name,0);
		if ((frame != NULL) &&
			 (local_14 = Container_Frame_GetAnimClone(frame), (*(byte *)&cont->flags & RESDATA_UNK_2) != 0
			 )) {
			sampleName = Container_Frame_GetSample(frame);
			if ((sampleName != NULL) &&
				 ((globs::containerGlobs.soundTriggerCallback != NULL &&
					(((byte)globs::containerGlobs.flags & RESMANAGER_SOUNDCALLBACK) != 0)))) {
				(*globs::containerGlobs.soundTriggerCallback)
									(sampleName,cont,globs::containerGlobs.soundTriggerData);
			}
			cont->flags = cont->flags & ~RESDATA_UNK_2;
		}
	}
	else {
		frame = (IDirect3DRMFrame3 *)time;
		if (cont->type == RESOURCE_ANIM) {
			local_14 = Container_Frame_GetAnimClone(cont->activityFrame);
			frame = cont->activityFrame;
		}
	}
	if (local_14 != NULL) {
		RVar4 = cont->flags & RESDATA_UNK_8;
		fVar5 = Container_GetAnimationTime(cont);
		uVar2 = Container_Frame_GetFrameCount(frame);
		Container_Frame_SetAppData(frame,NULL,NULL,NULL,NULL,NULL,&time,NULL,NULL,NULL,NULL);
		if (uVar2 != 0) {
			uVar2 -= 1;
			fVar1 = (float)(ulonglong)uVar2;
			if ((ushort)((ushort)(time < fVar1) << 8 | (ushort)(time == fVar1) << 0xe) == 0) {
				local_10 = time - fVar1;
				RVar4 = RESDATA_NONE;
			}
		}
		if (RVar4 == RESDATA_NONE) {
			uVar3 = Container_Frame_GetTrigger(frame);
			fVar1 = (float)(ulonglong)uVar3;
			if ((((uVar2 != 1) &&
					 (AnimClone_SetTime(local_14,time,NULL),
					 globs::containerGlobs.triggerFrameCallback != NULL)) && (fVar1 != 0.0)) &&
				 (((float)fVar5 < fVar1 && (fVar1 <= time)))) {
				(*globs::containerGlobs.triggerFrameCallback)(cont,globs::containerGlobs.triggerFrameData);
				return (float10)local_10;
			}
		}
		else {
			cont->flags = cont->flags | RESDATA_UNK_20;
		}
	}
	return (float10)local_10;
}



void __cdecl lego::res::Container_ForceAnimationUpdate(Container *cont)
{
	IDirect3DRMFrame3 *frame;
	Container *pCVar1;
	float10 fVar2;
	
	if ((*(byte *)&cont->flags & RESDATA_UNK_20) != 0) {
		pCVar1 = cont;
		if (cont->type == RESOURCE_ACT) {
			frame = Container_Frame_Find(cont,cont->typeData->name,0);
			if (frame != NULL) {
				pCVar1 = (Container *)Container_Frame_GetAnimClone(frame);
				fVar2 = Container_Frame_GetCurrTime(frame);
				cont = (Container *)(float)fVar2;
			}
		}
		else {
			if (cont->type == RESOURCE_ANIM) {
				pCVar1 = (Container *)Container_Frame_GetAnimClone(cont->activityFrame);
				fVar2 = Container_Frame_GetCurrTime(cont->activityFrame);
				cont = (Container *)(float)fVar2;
			}
		}
		if (pCVar1 != NULL) {
			AnimClone_SetTime((AnimClone *)pCVar1,(float)cont,NULL);
		}
	}
	return;
}



float10 __cdecl lego::res::Container_GetAnimationTime(Container *cont)
{
	IDirect3DRMFrame3 *frame;
	float10 fVar1;
	
	fVar1 = (float10)0.0;
	if (cont->type == RESOURCE_ACT) {
		frame = Container_Frame_Find(cont,cont->typeData->name,0);
		if (frame != NULL) {
			fVar1 = Container_Frame_GetCurrTime(frame);
			return fVar1;
		}
		fVar1 = (float10)(float)fVar1;
	}
	else {
		if (cont->type == RESOURCE_ANIM) {
			fVar1 = Container_Frame_GetCurrTime(cont->activityFrame);
			return fVar1;
		}
	}
	return fVar1;
}



uint __cdecl lego::res::Container_GetAnimationFrames(Container *cont)
{
	IDirect3DRMFrame3 *frame;
	uint uVar1;
	
	frame = NULL;
	if (cont->type == RESOURCE_ACT) {
		frame = Container_Frame_Find(cont,cont->typeData->name,0);
	}
	else {
		if (cont->type == RESOURCE_ANIM) {
			frame = cont->activityFrame;
		}
	}
	if (frame != NULL) {
		uVar1 = Container_Frame_GetFrameCount(frame);
		return uVar1;
	}
	return 0;
}



void __cdecl
lego::res::Container_SetPosition(Container *cont,Container *opt_ref,float x,float y,float z)
{
										// IDirect3DRMFrame3->SetPosition(this, IDirect3DRMFrame3* lpRef, float rvX,
										// float rvY, float rvZ)
	Container_GetFrames(cont,opt_ref,(IDirect3DRMFrame3 **)&opt_ref,(IDirect3DRMFrame3 **)&cont);
	(*(code *)opt_ref->masterFrame[0x3c].lpVtbl)(opt_ref,cont,x,y,z);
	return;
}



void __cdecl
lego::res::Container_SetOrientation
					(Container *cont,Container *opt_ref,float dirx,float diry,float dirz,float upx,float upy,
					float upz)
{
	Container_GetFrames(cont,opt_ref,(IDirect3DRMFrame3 **)&opt_ref,(IDirect3DRMFrame3 **)&cont);
										// IDirect3DRMFrame3->SetOrientation(this, IDirect3DRMFrame3* lpRef, float rvDx,
										// float rvDy, float rvDz, float rvUx, float rvUy, float rvUz)
	(*(code *)opt_ref->masterFrame[0x3b].lpVtbl)(opt_ref,cont,dirx,diry,dirz,upx,upy,upz);
	return;
}



void __cdecl lego::res::Container_GetPosition(Container *cont,Container *opt_ref,Vector3F *out_pos)
{
	Container_GetFrames(cont,opt_ref,(IDirect3DRMFrame3 **)&opt_ref,(IDirect3DRMFrame3 **)&cont);
										// IDirect3DRMFrame3->GetPosition(this, IDirect3DRMFrame3* lpRef, Vector3F*
										// lprvPos)
	(*(code *)opt_ref->masterFrame[0x18].lpVtbl)(opt_ref,cont,out_pos);
	return;
}



void __cdecl
lego::res::Container_GetOrientation
					(Container *cont,Container *opt_ref,Vector3F *out_dir,Vector3F *out_up)
{
	Vector3F **unaff_retaddr;
	Vector3F *pVVar1;
	Vector3F *pVVar2;
	Vector3F dvector;
	Vector3F uvector;
	
	Container_GetFrames(cont,opt_ref,(IDirect3DRMFrame3 **)&opt_ref,(IDirect3DRMFrame3 **)&cont);
	pVVar1 = &dvector;
	pVVar2 = &uvector;
										// IDirect3DRMFrame3->GetOrientation(this, IDirect3DRMFrame3* lpRef, Vector3F*
										// lprvDir, Vector3F* lprvUp)
	(*(code *)opt_ref->masterFrame[0x1f].lpVtbl)();
	if (uvector.z != 0.0) {
		*(Container **)uvector.z = opt_ref;
		*(Container **)((int)uvector.z + 4) = cont;
		*(Vector3F **)((int)uvector.z + 8) = pVVar1;
	}
	if (unaff_retaddr != NULL) {
		*unaff_retaddr = pVVar2;
		unaff_retaddr[1] = (Vector3F *)dvector.x;
		unaff_retaddr[2] = (Vector3F *)dvector.y;
	}
	return;
}



void __cdecl
lego::res::Container_AddRotation
					(Container *cont,D3DRMCombineType combine,float x,float y,float z,float angle)
{
										// enum D3DRMCombineType
										//   D3DRMCOMBINE_REPLACE = 0,
										//   D3DRMCOMBINE_BEFORE  = 1,
										//   D3DRMCOMBINE_AFTER   = 2,
										// 
										// IDirect3DRMFrame3->AddRotation(this, D3DRMCombineType rctCombine, float rvX,
										// float rvY, float rvZ, float rvTheta)
	(*cont->masterFrame->lpVtbl->AddRotation)(cont->masterFrame,combine,x,y,z,angle);
	return;
}



void __cdecl
lego::res::Container_AddScale(Container *cont,D3DRMCombineType combine,float x,float y,float z)
{
										// enum D3DRMCombineType
										//   D3DRMCOMBINE_REPLACE = 0,
										//   D3DRMCOMBINE_BEFORE  = 1,
										//   D3DRMCOMBINE_AFTER   = 2,
										// 
										// IDirect3DRMFrame3->AddScale(this, D3DRMCombineType rctCombine, float rvX,
										// float rvY, float rvZ)
	(*cont->masterFrame->lpVtbl->AddScale)(cont->masterFrame,combine,x,y,z);
	return;
}



void __cdecl
lego::res::Container_AddTranslation
					(Container *cont,D3DRMCombineType combine,float x,float y,float z)
{
										// enum D3DRMCombineType
										//   D3DRMCOMBINE_REPLACE = 0,
										//   D3DRMCOMBINE_BEFORE  = 1,
										//   D3DRMCOMBINE_AFTER   = 2,
										// 
										// IDirect3DRMFrame3->AddTranslation(this, D3DRMCombineType rctCombine, float
										// rvX, float rvY, float rvZ)
	(*cont->masterFrame->lpVtbl->AddTranslation)(cont->masterFrame,combine,x,y,z);
	return;
}



void __cdecl lego::res::Container_ClearTransform(Container *cont)
{
	Matrix4F identity;
	
	identity.values[0][0] = 1.0;
	identity.values[1][0] = 0.0;
	identity.values[2][0] = 0.0;
	identity.values[3][0] = 0.0;
	identity.values[0][1] = 0.0;
	identity.values[1][1] = 1.0;
	identity.values[2][1] = 0.0;
	identity.values[3][1] = 0.0;
	identity.values[0][2] = 0.0;
	identity.values[1][2] = 0.0;
	identity.values[2][2] = 1.0;
	identity.values[3][2] = 0.0;
	identity.values[0][3] = 0.0;
	identity.values[1][3] = 0.0;
	identity.values[2][3] = 0.0;
	identity.values[3][3] = 1.0;
	Container_AddTransform(cont,D3DRMCOMBINE_REPLACE,&identity);
	return;
}



void __cdecl
lego::res::Container_AddTransform(Container *cont,D3DRMCombineType combine,Matrix4F *mat)
{
										// IDirect3DRMFrame3->AddTransform(this, D3DRMCombineType rctCombine,
										// D3DRMMatrix4D* rmMatrix)
	(*cont->masterFrame->lpVtbl->AddTransform)(cont->masterFrame,combine,mat);
	return;
}



float10 __cdecl lego::res::Container_GetZXRatio(Container *cont)
{
	IDirect3DRMFrame3 *pIVar1;
	float unaff_ESI;
	Matrix4F mat;
	
	pIVar1 = cont->masterFrame;
	(*pIVar1->lpVtbl->GetParent)(pIVar1,(IDirect3DRMFrame3 **)&cont);
	(*pIVar1->lpVtbl->GetTransform)(pIVar1,(IDirect3DRMFrame3 *)cont,&mat);
	(*(code *)cont->masterFrame[2].lpVtbl)(cont);
										// Decompile is wrong. This is correct: mat[2][2] / mat[0][0];
	return (float10)mat.values[2][1] / (float10)unaff_ESI;
}



// When resParent is NULL, resChild's current parent will be removed instead.

void __cdecl lego::res::Container_SetParent(Container *in_child,Container *parent)
{
	IDirect3DRMFrame3 *child;
	IDirect3DRMFrame3 *child_00;
	
	child = in_child->masterFrame;
	child_00 = in_child->hiddenFrame;
	if (parent == NULL) {
										// IDirect3DRMFrame3->GetParent(this, IDirect3DRMFrame3** lplpParent)
										//  (for resData1->frame1)
		(*child->lpVtbl->GetParent)(child,(IDirect3DRMFrame3 **)&in_child);
		if (in_child != NULL) {
										// IDirect3DRMFrame3->DeleteChild(this, IDIrect3DRMFrame3* lpChild)
			(*(code *)in_child->masterFrame[0x25].lpVtbl)((IDirect3DRMFrame3 *)in_child,child);
										// IDirect3DRMFrame3->Release(this)
										//  (releasing GetParent frame)
			(*(code *)in_child->masterFrame[2].lpVtbl)((IDirect3DRMFrame3 *)in_child);
		}
										// IDirect3DRMFrame3->GetParent(this, IDirect3DRMFrame3** lplpParent)
										//  (for resData1->frame3)
		(*child->lpVtbl->GetParent)(child_00,(IDirect3DRMFrame3 **)&in_child);
		if (in_child != NULL) {
			(*(code *)in_child->masterFrame[0x25].lpVtbl)((IDirect3DRMFrame3 *)in_child,child_00);
			(*(code *)in_child->masterFrame[2].lpVtbl)((IDirect3DRMFrame3 *)in_child);
			return;
		}
	}
	else {
		in_child = (Container *)parent->masterFrame;
		Container_Frame_SafeAddChild((IDirect3DRMFrame3 *)in_child,child);
		in_child = (Container *)parent->hiddenFrame;
		Container_Frame_SafeAddChild((IDirect3DRMFrame3 *)in_child,child_00);
	}
	return;
}



Container * __cdecl lego::res::Container_GetParent(Container *cont)
{
	Container *pCVar1;
	
	if (cont == globs::containerGlobs.rootContainer) {
		return NULL;
	}
	(*cont->masterFrame->lpVtbl->GetParent)(cont->masterFrame,(IDirect3DRMFrame3 **)&cont);
	if (cont != NULL) {
		pCVar1 = Container_Frame_GetContainer((IDirect3DRMFrame3 *)cont);
		(*(code *)cont->masterFrame[2].lpVtbl)((IDirect3DRMFrame3 *)cont);
		return pCVar1;
	}
	return NULL;
}



float10 __cdecl lego::res::Container_GetTransCoef(Container *cont)
{
	char *findName;
	IDirect3DRMFrame3 *frame;
	float10 fVar1;
	
	if (((cont->type == RESOURCE_ACT) && (cont->typeData != NULL)) &&
		 (findName = cont->typeData->name, findName != NULL)) {
		frame = Container_Frame_Find(cont,findName,0);
		if (frame != NULL) {
			fVar1 = Container_Frame_GetTransCo(frame);
			return fVar1;
		}
	}
	return (float10)0.0;
}



Container * __cdecl lego::res::Container_SearchOwner(IDirect3DRMFrame3 *in_frame)
{
	Container *pCVar1;
	IDirect3DRMFrame3 *frame;
	Container *pCVar2;
	
	pCVar2 = NULL;
	frame = in_frame;
	do {
		if (frame == NULL) {
			return pCVar2;
		}
		pCVar1 = Container_Frame_GetOwner(frame);
		if ((pCVar1 != NULL) && (pCVar1->type != RESOURCE_REFERENCE)) {
			pCVar2 = pCVar1;
		}
		(*frame->lpVtbl->GetParent)(frame,&in_frame);
		frame = in_frame;
		if (in_frame == NULL) {
			frame = NULL;
		}
		else {
			(*in_frame->lpVtbl->Release)(in_frame);
		}
	} while (pCVar2 == NULL);
	return pCVar2;
}



Container * __cdecl lego::res::Container_Frame_GetContainer(IDirect3DRMFrame3 *frame)
{
	Container *owner;
	
	owner = Container_Frame_GetOwner(frame);
	if (owner == NULL) {
		owner = Container_Create(NULL);
		if (owner != NULL) {
			(*owner->masterFrame->lpVtbl->Release)((IUnknown *)owner->masterFrame);
			(*owner->activityFrame->lpVtbl->Release)((IUnknown *)owner->activityFrame);
			owner->masterFrame = frame;
			owner->activityFrame = NULL;
			owner->type = RESOURCE_REFERENCE;
			(*frame->lpVtbl->AddDestroyCallback)
								((IUnknown *)frame,Container_Frame_ReferenceDestroyCallback,NULL);
			Container_Frame_SetAppData(frame,owner,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
		}
	}
	return owner;
}



// #ifndef CONTAINER_MATCHHIDDENHIERARCHY

void __cdecl
lego::res::Container_GetFrames
					(Container *cont,Container *opt_ref,IDirect3DRMFrame3 **out_contFrame,
					IDirect3DRMFrame3 **out_refFrame)
{
	*out_contFrame = cont->masterFrame;
	if (opt_ref == NULL) {
		*out_refFrame = (globs::containerGlobs.rootContainer)->masterFrame;
		return;
	}
	*out_refFrame = opt_ref->masterFrame;
	return;
}



ResourceType __cdecl lego::res::Container_ParseTypeString(char *str,BOOL *out_noTexture)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char **ppcVar6;
	char *pcVar7;
	undefined4 *puVar8;
	ResourceType RVar9;
	undefined4 local_50 [10];
	char *local_28;
	char *local_24;
	
	if (str == NULL) {
		return RESOURCE__INVALID;
	}
	uVar3 = 0xffffffff;
	do {
		pcVar7 = str;
		if (uVar3 == 0) break;
		uVar3 -= 1;
		pcVar7 = str + 1;
		cVar1 = *str;
		str = pcVar7;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	puVar5 = (undefined4 *)(pcVar7 + -uVar3);
	puVar8 = local_50;
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
		*puVar8 = *puVar5;
		puVar5 = puVar5 + 1;
		puVar8 = puVar8 + 1;
	}
	for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)puVar8 = *(undefined *)puVar5;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
		puVar8 = (undefined4 *)((int)puVar8 + 1);
	}
	uVar3 = util::Util_Tokenise((char *)local_50,&local_28,":");
	if (1 < uVar3) {
		iVar2 = std::_stricmp(local_24,"NOTEXTURE");
		if (iVar2 == 0) {
			*out_noTexture = 1;
			goto LAB_00475c6a;
		}
	}
	*out_noTexture = 0;
LAB_00475c6a:
	RVar9 = RESOURCE_NULL;
	ppcVar6 = globs::containerGlobs.typeName;
	do {
		if (*ppcVar6 != NULL) {
			iVar2 = std::_stricmp(*ppcVar6,(char *)local_50);
			if (iVar2 == 0) {
				return RVar9;
			}
		}
		ppcVar6 = ppcVar6 + 1;
		RVar9 += RESOURCE_MESH;
	} while (ppcVar6 < globs::containerGlobs.extensionName);
	return RESOURCE__INVALID;
}



void __cdecl lego::res::Container_AddList(void)
{
	Container *pCVar1;
	Container *pCVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::containerGlobs.listCount & 0x1f);
	pCVar2 = (Container *)std::malloc(uVar4 * 0x2c);
	globs::containerGlobs.listSet[globs::containerGlobs.listCount] = pCVar2;
	pCVar2 = globs::containerGlobs.listSet[globs::containerGlobs.listCount];
	if (pCVar2 != NULL) {
		globs::containerGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pCVar1 = pCVar2;
			do {
				pCVar1->nextFree = pCVar1 + 1;
				iVar3 += -1;
				pCVar1 = pCVar1 + 1;
			} while (iVar3 != 0);
		}
		pCVar2[uVar4 - 1].nextFree = globs::containerGlobs.freeList;
		globs::containerGlobs.freeList = pCVar2;
	}
	return;
}



// WARNING: Exceeded maximum restarts with more pending

uint __cdecl
lego::res::Container_GetActivities
					(Container *cont,IDirect3DRMFrame3 **out_frameList,AnimClone **out_acList,
					char **out_nameList)
{
	HRESULT HVar1;
	char *lpName;
	int iVar2;
	AnimClone *pAVar3;
	uint uVar4;
	int unaff_EBP;
	Container *pCVar5;
	AnimClone **ppAVar6;
	IUnknown *pIVar7;
	AnimClone **ppAVar8;
	Container *unaff_retaddr;
	IDirect3DRMFrame3 *frame;
	uint length;
	IDirect3DRMFrameArray *This;
	IUnknown *local_20;
	IDirect3DRMFrame3 *local_1c;
	IDirect3DRMFrameArray *local_18;
	IDirect3DRMFrame3 *local_14;
	AnimClone **local_10;
	AnimClone **local_c;
	DWORD local_8;
	
	pIVar7 = NULL;
	local_20 = NULL;
	local_1c = NULL;
	if (cont->type == RESOURCE_ACT) {
		local_c = NULL;
		pCVar5 = cont;
		do {
			ppAVar6 = local_c;
			if (local_c == NULL) {
				local_14 = pCVar5->activityFrame;
			}
			if (local_c == (AnimClone **)0x1) {
				local_14 = pCVar5->hiddenFrame;
			}
			HVar1 = (*local_14->lpVtbl->GetChildren)(local_14,&local_18);
			if (HVar1 == 0) {
				This = local_18;
				local_8 = (*local_18->lpVtbl->GetSize)();
				uVar4 = 0;
				if (local_8 != 0) {
					local_c = (AnimClone **)((int)out_acList - (int)out_frameList);
					ppAVar8 = (AnimClone **)(out_frameList + (int)pIVar7);
					pCVar5 = unaff_retaddr;
					do {
						frame = local_1c;
						length = uVar4;
						(*local_1c->lpVtbl->AddDestroyCallback)();
						(*local_20->lpVtbl->QueryInterface)
											(local_20,(IID *)&idl::IID_IDirect3DRMFrame3,(LPVOID *)&stack0xffffffcc);
						(*local_20->lpVtbl->Release)(local_20);
						(*This->lpVtbl[1].GetElement)(This,(DWORD)&stack0xffffffcc,NULL);
						if (length != 0) {
							lpName = (char *)std::malloc(length);
							(*frame->lpVtbl->GetName)((IUnknown *)frame,(LPDWORD)&stack0xffffffc0,lpName);
							iVar2 = std::_strnicmp(lpName,"ActFrame",8);
							if (iVar2 == 0) {
								if (local_18 != NULL) {
									*(IDirect3DRMFrame3 **)
									 ((int)&((Container *)((int)cont - (int)out_frameList))->masterFrame +
									 (int)ppAVar8) = frame;
								}
								if (local_14 != NULL) {
									pAVar3 = Container_Frame_GetAnimClone(frame);
									*ppAVar8 = pAVar3;
								}
								if (local_10 != NULL) {
									*(char **)(unaff_EBP + (int)ppAVar8) = lpName;
								}
								ppAVar8 = ppAVar8 + 1;
								if (local_10 != NULL) goto LAB_00475e74;
							}
							std::free(lpName);
						}
LAB_00475e74:
						(*frame->lpVtbl->Release)((IUnknown *)frame);
						uVar4 += 1;
						ppAVar6 = local_10;
						pIVar7 = local_20;
						unaff_retaddr = pCVar5;
					} while (uVar4 < local_8);
				}
				(*local_1c->lpVtbl->Release)();
			}
			local_c = (AnimClone **)((int)ppAVar6 + 1);
		} while (local_c < (AnimClone **)0x2);
	}
	return (uint)pIVar7;
}



// If non-null, `name` will be owned by this Resource.

void __cdecl
lego::res::Container_SetTypeData
					(Container *cont,char *name,IDirect3DRMLight *light,IDirect3DRMMesh *mesh,Mesh *transMesh)
{
	Container_TypeData *pCVar1;
	
	if (cont->typeData == NULL) {
		pCVar1 = (Container_TypeData *)std::malloc(0x10);
		cont->typeData = pCVar1;
		pCVar1->name = name;
		cont->typeData->light = light;
		cont->typeData->mesh = mesh;
		cont->typeData->transMesh = transMesh;
	}
	else {
		if (name != NULL) {
			cont->typeData->name = name;
		}
		if (light != NULL) {
			cont->typeData->light = light;
		}
		if (mesh != NULL) {
			cont->typeData->mesh = mesh;
		}
		if (transMesh != NULL) {
			cont->typeData->transMesh = transMesh;
			return;
		}
	}
	return;
}



void __cdecl lego::res::Container_FreeTypeData(Container *cont)
{
	Container_TypeData *pCVar1;
	ResourceType RVar2;
	IDirect3DRMMesh *This;
	
	pCVar1 = cont->typeData;
	if (pCVar1 != NULL) {
		RVar2 = cont->type;
		if (RVar2 == RESOURCE_ACT) {
			std::free(pCVar1->name);
		}
		else {
			if (RVar2 == RESOURCE_LIGHT) {
				(*pCVar1->light->lpVtbl->Release)((IUnknown *)pCVar1->light);
			}
			else {
				if (RVar2 == RESOURCE_MESH) {
					if (pCVar1->mesh != NULL) {
						(*cont->activityFrame->lpVtbl->DeleteVisual)
											(cont->activityFrame,(IDirect3DRMVisual *)pCVar1->mesh);
						This = cont->typeData->mesh;
						(*This->lpVtbl->Release)((IUnknown *)This);
					}
				}
				else {
					if ((RVar2 == RESOURCE_LWO) && (pCVar1->transMesh != NULL)) {
						Mesh_Remove(pCVar1->transMesh,cont->activityFrame);
					}
				}
			}
		}
		std::free(cont->typeData);
		cont->typeData = NULL;
	}
	return;
}



// ALSO: Container_AddActivity(<same args>)

BOOL __cdecl
lego::res::Container_AddActivity2
					(Container *cont,char *filename,char *actname,float transCo,uint trigger,char *sample,
					AnimClone *origClone,BOOL lws,BOOL looping)
{
	HRESULT HVar1;
	AnimClone *animClone;
	IDirect3DRMFrame3 *local_208;
	uint local_204;
	char local_200 [512];
	
	std::sprintf(local_200,"%s.%s",filename,globs::containerGlobs.extensionName[3]);
	HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
										(globs::mainGlobs.lpD3DRM,cont->hiddenFrame,&local_208);
	if (HVar1 == 0) {
		Container_Frame_FormatName(local_208,"%s_%s","ActFrame",actname);
		if (origClone == NULL) {
			animClone = Container_LoadAnimSet(local_200,local_208,&local_204,lws,looping);
		}
		else {
			animClone = AnimClone_Make(origClone,local_208,&local_204);
		}
		Container_Frame_SetAppData
							(local_208,cont,animClone,filename,&local_204,NULL,NULL,&transCo,sample,NULL,&trigger)
		;
		return TRUE;
	}
	return 0;
}



void __cdecl
lego::res::Container_Frame_ReferenceDestroyCallback(IDirect3DRMFrame3 *lpD3DRMobj,void *lpArg)
{
	Container *pCVar1;
	
	pCVar1 = Container_Frame_GetOwner(lpD3DRMobj);
	if (pCVar1 != NULL) {
		pCVar1->flags = pCVar1->flags | RESDATA_UNK_10;
		Container_Frame_RemoveAppData(lpD3DRMobj);
	}
	return;
}



// WARNING: Exceeded maximum restarts with more pending

IDirect3DRMFrame3 * __cdecl
lego::res::Container_Frame_Find(Container *cont,char *findName,BOOL hidden)
{
	IDirect3DRMFrame3 *pIVar1;
	HRESULT HVar2;
	uint uVar3;
	char *lpName;
	int iVar4;
	IDirect3DRMFrame3 *unaff_EBP;
	IDirect3DRMFrame3 *pIVar5;
	uint uVar6;
	uint uVar7;
	IDirect3DRMFrame3 *pIVar8;
	IDirect3DRMFrame3 *rmFrame3;
	IDirect3DRMFrameArray *rmArray;
	IUnknown *rmFrameBase;
	uint dwNameSize;
	uint dwSize;
	char nameBuffer [512];
	
	pIVar5 = NULL;
	if (hidden == 0) {
		pIVar1 = cont->activityFrame;
	}
	else {
		pIVar1 = cont->hiddenFrame;
	}
										// IDirect3DRMFrame3->GetChildren(this, IDirect3DRMFrameArray** lplpChildren)
	HVar2 = (*pIVar1->lpVtbl->GetChildren)(pIVar1,&rmArray);
	if (HVar2 == 0) {
										// DWORD IDirect3DRMFrameArray->GetSize(this)
		uVar3 = (*rmArray->lpVtbl->GetSize)();
		uVar6 = 0;
		if (uVar3 != 0) {
			do {
										// IDirect3DRMFrameArray->GetElement(this, DWORD index, IDirect3DRMFrame**
										// lplpD3DRMFrame)
				pIVar1 = rmFrame3;
				uVar7 = uVar6;
				(*rmFrame3->lpVtbl->AddDestroyCallback)();
										// IDirect3DRMFrame->QueryInterface(this, IID_IDirect3DRMFrame3,
										// IDirect3DRMFrame3** lplpOut)
				pIVar8 = unaff_EBP;
				(*unaff_EBP->lpVtbl->QueryInterface)
									((IUnknown *)unaff_EBP,(IID *)&idl::IID_IDirect3DRMFrame3,
									 (LPVOID *)&stack0xfffffddc);
										// IDirect3DRMFrame->Release(this)
				(*rmArray->lpVtbl->Release)((IUnknown *)rmArray);
										// IDirect3DRMFrame3->GetName(this, DWORD* lpdwSize, LPSTR lpName)
				(*pIVar1->lpVtbl->GetName)((IUnknown *)pIVar1,(LPDWORD)&stack0xfffffdd8,NULL);
				if (pIVar1 != NULL) {
					lpName = (char *)std::malloc((int)&pIVar1->lpVtbl + 1);
										// IDirect3DRMFrame3->GetName(this, DWORD* lpdwSize, LPSTR lpName)
					(*unaff_EBP->lpVtbl->GetName)((IUnknown *)unaff_EBP,(LPDWORD)&stack0xfffffdcc,lpName);
					std::sprintf(&stack0xfffffdd4,"%s_%s","ActFrame",cont);
					iVar4 = std::_stricmp(lpName,&stack0xfffffdd4);
					if (iVar4 == 0) {
						pIVar5 = unaff_EBP;
					}
					uVar3 = uVar7;
					std::free(lpName);
				}
										// IDirect3DRMFrame3->Release(this)
				(*unaff_EBP->lpVtbl->Release)((IUnknown *)unaff_EBP);
			} while ((pIVar5 == NULL) && (uVar6 += 1, unaff_EBP = pIVar8, uVar6 < uVar3));
		}
										// IDirect3DRMFrameArray->Release(this)
		(*rmFrame3->lpVtbl->Release)();
	}
	return pIVar5;
}



void __cdecl
lego::res::Container_Frame_SetAppData
					(IDirect3DRMFrame3 *frame,Container *owner,AnimClone *animClone,char *asfname,
					uint *frameCount,char *frameName,float *currTime,float *transCo,char *actSample,
					Sound3D_SoundFrameRecord *soundRecord,uint *trigger)
{
	char cVar1;
	Container_AppData *appData;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData == NULL) {
		appData = (Container_AppData *)std::malloc(0x28);
		appData->animClone = animClone;
		appData->ownerContainer = owner;
		appData->animSetFileName = NULL;
		if (frameCount == NULL) {
			appData->frameCount = 0;
		}
		else {
			appData->frameCount = *frameCount;
		}
		appData->frameName = frameName;
		if (currTime == NULL) {
			appData->currTime = 0.0;
		}
		else {
			appData->currTime = *currTime;
		}
		if (transCo == NULL) {
			appData->transCo = 0.0;
		}
		else {
			appData->transCo = *transCo;
		}
		if (trigger == NULL) {
			appData->trigger = 0;
		}
		else {
			appData->trigger = *trigger;
		}
		appData->activitySample = actSample;
		appData->soundList = soundRecord;
		(*frame->lpVtbl->SetAppData)(frame,appData);
	}
	else {
		if (owner != NULL) {
			appData->ownerContainer = owner;
		}
		if (animClone != NULL) {
			appData->animClone = animClone;
		}
		if ((asfname != NULL) && (appData->animSetFileName != NULL)) {
			std::free(appData->animSetFileName);
		}
		if (frameCount != NULL) {
			appData->frameCount = *frameCount;
		}
		if (frameName != NULL) {
			appData->frameName = frameName;
		}
		if (currTime != NULL) {
			appData->currTime = *currTime;
		}
		if (transCo != NULL) {
			appData->transCo = *transCo;
		}
		if (actSample != NULL) {
			appData->activitySample = actSample;
		}
		if (soundRecord != NULL) {
			appData->soundList = soundRecord;
		}
		if (trigger != NULL) {
			appData->trigger = *trigger;
		}
	}
	if (asfname != NULL) {
		uVar3 = 0xffffffff;
		pcVar6 = asfname;
		do {
			if (uVar3 == 0) break;
			uVar3 -= 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
		puVar2 = (undefined4 *)std::malloc(~uVar3);
		uVar3 = 0xffffffff;
		appData->animSetFileName = (char *)puVar2;
		do {
			pcVar6 = asfname;
			if (uVar3 == 0) break;
			uVar3 -= 1;
			pcVar6 = asfname + 1;
			cVar1 = *asfname;
			asfname = pcVar6;
		} while (cVar1 != '\0');
		uVar3 = ~uVar3;
		puVar5 = (undefined4 *)(pcVar6 + -uVar3);
		for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
			*puVar2 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar2 = puVar2 + 1;
		}
		for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
			*(undefined *)puVar2 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar2 = (undefined4 *)((int)puVar2 + 1);
		}
	}
	return;
}



void __cdecl lego::res::Container_Frame_RemoveAppData(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		if (appData->animSetFileName != NULL) {
			std::free(appData->animSetFileName);
		}
		std::free(appData);
	}
	(*frame->lpVtbl->SetAppData)(frame,NULL);
	return;
}



// ACCESSOR: ResourceAppData->resData (field_0)

Container * __cdecl lego::res::Container_Frame_GetOwner(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return appData->ownerContainer;
	}
	return NULL;
}



// ACCESSOR: ResourceAppData->filename (field_4)

char * __cdecl lego::res::Container_Frame_GetAnimSetFileName(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return appData->animSetFileName;
	}
	return NULL;
}



// ACCESSOR: ResourceAppData->actFrameRes (field_1c)

AnimClone * __cdecl lego::res::Container_Frame_GetAnimClone(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return appData->animClone;
	}
	return NULL;
}



// ACCESSOR: ResourceAppData->field_c (field_c)

uint __cdecl lego::res::Container_Frame_GetFrameCount(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return appData->frameCount;
	}
	return 0;
}



// ACCESSOR: ResourceAppData->float_10 (field_10)

float10 __cdecl lego::res::Container_Frame_GetCurrTime(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return (float10)appData->currTime;
	}
	return (float10)0.0;
}



// ACCESSOR: ResourceAppData->float_14 (field_14)

float10 __cdecl lego::res::Container_Frame_GetTransCo(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return (float10)appData->transCo;
	}
	return (float10)0.0;
}



// ACCESSOR: ResourceAppData->sampleName (field_18)

char * __cdecl lego::res::Container_Frame_GetSample(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return appData->activitySample;
	}
	return NULL;
}



// ACCESSOR: ResourceAppData->field_20 (field_20)

uint __cdecl lego::res::Container_Frame_GetTrigger(IDirect3DRMFrame3 *frame)
{
	Container_AppData *appData;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	if (appData != NULL) {
		return appData->trigger;
	}
	return 0;
}



void __cdecl
lego::res::Container_Frame_SafeAddChild(IDirect3DRMFrame3 *parent,IDirect3DRMFrame3 *child)
{
	IDirect3DRMFrame3 *lpD3DRMFrameChild;
	Matrix4F matrix;
	
	lpD3DRMFrameChild = child;
										// IDirect3DRMFrame3->GetParent(this, IDirect3DRMFrame3** lplpParent)
	(*child->lpVtbl->GetParent)(child,&child);
										// IDirect3DRMFrame3->GetTransform(this, IDirect3DRMFrame3* lpRefFrame,
										// Matrix4F** rmMatrix)
										// (this = frame2, lpRefFrame = GetParent)
	(*lpD3DRMFrameChild->lpVtbl->GetTransform)(lpD3DRMFrameChild,child,&matrix);
	if (child != NULL) {
										// IDirect3DRMFrame3->Release(this)
										//  (this = GetParent)
		(*child->lpVtbl->Release)(child);
	}
										// IDirect3DRMFrame3->AddChild(this, IDirect3DRMFrame3* lpD3DRMFrameChild)
										//  (this = frame1, lpChild = frame2)
	(*parent->lpVtbl->AddChild)(parent,lpD3DRMFrameChild);
										// IDirect3DRMFrame3->AddTransform(this, TD3DRMCombineType rctCombine, Matrix4F*
										// rmMatrix)
										//  (this = frame2)
	(*lpD3DRMFrameChild->lpVtbl->AddTransform)(lpD3DRMFrameChild,D3DRMCOMBINE_REPLACE,&matrix);
	return;
}



void __cdecl lego::res::Container_Frame_FormatName(IDirect3DRMFrame3 *frame,char *msg,...)
{
	int iVar1;
	char *buffer;
	char local_400 [1024];
	
	iVar1 = std::vsprintf(local_400,msg,&stack0x0000000c);
	buffer = (char *)std::malloc(iVar1 + 1);
	std::vsprintf(buffer,msg,&stack0x0000000c);
	(*frame->lpVtbl->SetName)((IUnknown *)frame,buffer);
	Container_Frame_SetAppData(frame,NULL,NULL,NULL,NULL,buffer,NULL,NULL,NULL,NULL,NULL);
	return;
}



void __cdecl lego::res::Container_Frame_FreeName(IDirect3DRMFrame3 *frame)
{
	char *buffer;
	
	buffer = Container_Frame_GetName(frame);
	if (buffer != NULL) {
		std::free(buffer);
	}
	return;
}



char * __cdecl lego::res::Container_Frame_GetName(IDirect3DRMFrame3 *frame)
{
	DWORD DVar1;
	
	DVar1 = (*frame->lpVtbl->GetAppData)((IUnknown *)frame);
	if (DVar1 != 0) {
		return *(char **)(DVar1 + 8);
	}
	return NULL;
}



BOOL __cdecl
lego::res::Container_Frame_WalkTree
					(IDirect3DRMFrame3 *frame,uint level,ContainerWalkTreeCallback Callback,void *data)
{
	IDirect3DRMFrame3 *This;
	BOOL BVar1;
	uint uVar2;
	code **unaff_EBX;
	uint uVar3;
	IDirect3DRMFrame3 *unaff_EDI;
	int *local_8;
	int *local_4;
	
	This = frame;
	local_8 = NULL;
	BVar1 = (*Callback)(frame,data);
	if (BVar1 != 0) {
		return (BOOL)(IDirect3DRMFrame3 *)TRUE;
	}
	(*This->lpVtbl->GetChildren)(This,(IDirect3DRMFrameArray **)&frame);
	uVar2 = (**(code **)(*local_4 + 0xc))(local_4);
	uVar3 = 0;
	if (uVar2 != 0) {
		do {
			(**(code **)(*local_8 + 0x10))(local_8,uVar3,register0x00000010);
			(**(code **)*unaff_EBX)(unaff_EBX,&idl::IID_IDirect3DRMFrame3,&local_8);
			(*unaff_EDI->lpVtbl->Release)((IUnknown *)unaff_EDI);
			BVar1 = Container_Frame_WalkTree(unaff_EDI,(int)local_4 + 1,Callback,data);
			if (BVar1 != 0) {
				(*unaff_EDI->lpVtbl->Release)((IUnknown *)unaff_EDI);
				break;
			}
			(*unaff_EDI->lpVtbl->Release)((IUnknown *)unaff_EDI);
			uVar3 += 1;
		} while (uVar3 < uVar2);
	}
	(**(code **)(*local_8 + 8))(local_8);
	return (BOOL)unaff_EDI;
}



BOOL __cdecl
lego::res::Container_Frame_SearchCallback(IDirect3DRMFrame3 *frame,Container_SearchData *search)
{
	byte bVar1;
	ContainerSearchMode CVar2;
	IDirect3DRMFrame3 *This;
	byte *lpName;
	uint uVar3;
	byte *pbVar4;
	int iVar5;
	uint unaff_EBP;
	byte *pbVar6;
	bool bVar7;
	
	This = frame;
	(*frame->lpVtbl->GetName)((IUnknown *)frame,(LPDWORD)&frame,NULL);
	if ((int)&frame[-1].lpVtbl + 3U != search->stringLen) {
		return 0;
	}
	lpName = (byte *)std::malloc((uint)frame);
	*lpName = 0;
	(*This->lpVtbl->GetName)((IUnknown *)This,(LPDWORD)&frame,(LPSTR)lpName);
	uVar3 = 0;
	if (unaff_EBP != 0) {
		do {
			if (search->string[uVar3] == '?') {
				lpName[uVar3] = 0x3f;
			}
			uVar3 += 1;
		} while (uVar3 < unaff_EBP);
	}
	CVar2 = search->mode;
	if (CVar2 == CONTAINER_SEARCHMODE_FIRSTMATCH) {
		search->resultFrame = NULL;
		if (search->caseSensitive == 0) {
			iVar5 = std::_stricmp((char *)lpName,search->string);
		}
		else {
			pbVar6 = (byte *)search->string;
			pbVar4 = lpName;
			do {
				bVar1 = *pbVar4;
				bVar7 = bVar1 < *pbVar6;
				if (bVar1 != *pbVar6) {
LAB_0047676f:
					if (1 - bVar7 != (uint)(bVar7 != 0)) goto LAB_00476856;
					goto LAB_00476853;
				}
				if (bVar1 == 0) break;
				bVar1 = pbVar4[1];
				bVar7 = bVar1 < pbVar6[1];
				if (bVar1 != pbVar6[1]) goto LAB_0047676f;
				pbVar4 = pbVar4 + 2;
				pbVar6 = pbVar6 + 2;
			} while (bVar1 != 0);
			iVar5 = 0;
		}
		if (iVar5 != 0) goto LAB_00476856;
	}
	else {
		if (CVar2 == CONTAINER_SEARCHMODE_MATCHCOUNT) {
			if (search->caseSensitive == 0) {
				iVar5 = std::_stricmp((char *)lpName,search->string);
			}
			else {
				pbVar6 = (byte *)search->string;
				pbVar4 = lpName;
				do {
					bVar1 = *pbVar4;
					bVar7 = bVar1 < *pbVar6;
					if (bVar1 != *pbVar6) {
LAB_004767d0:
						if (1 - bVar7 == (uint)(bVar7 != 0)) {
							search->count = search->count + 1;
						}
						goto LAB_00476856;
					}
					if (bVar1 == 0) break;
					bVar1 = pbVar4[1];
					bVar7 = bVar1 < pbVar6[1];
					if (bVar1 != pbVar6[1]) goto LAB_004767d0;
					pbVar4 = pbVar4 + 2;
					pbVar6 = pbVar6 + 2;
				} while (bVar1 != 0);
				iVar5 = 0;
			}
			if (iVar5 == 0) {
				search->count = search->count + 1;
			}
			goto LAB_00476856;
		}
		if (CVar2 != CONTAINER_SEARCHMODE_NTHMATCH) goto LAB_00476856;
		search->resultFrame = NULL;
		if (search->caseSensitive == 0) {
			iVar5 = std::_stricmp((char *)lpName,search->string);
		}
		else {
			pbVar6 = (byte *)search->string;
			pbVar4 = lpName;
			do {
				bVar1 = *pbVar4;
				bVar7 = bVar1 < *pbVar6;
				if (bVar1 != *pbVar6) {
LAB_0047682a:
					iVar5 = (1 - (uint)bVar7) - (uint)(bVar7 != 0);
					goto joined_r0x00476843;
				}
				if (bVar1 == 0) break;
				bVar1 = pbVar4[1];
				bVar7 = bVar1 < pbVar6[1];
				if (bVar1 != pbVar6[1]) goto LAB_0047682a;
				pbVar4 = pbVar4 + 2;
				pbVar6 = pbVar6 + 2;
			} while (bVar1 != 0);
			iVar5 = 0;
		}
joined_r0x00476843:
		if (iVar5 == 0) {
			search->count = search->count + 1;
		}
		if (search->count != search->matchNumber + 1) goto LAB_00476856;
	}
LAB_00476853:
	search->resultFrame = This;
LAB_00476856:
	std::free(lpName);
	if (search->resultFrame == NULL) {
		return 0;
	}
	return TRUE;
}



AnimClone * __cdecl
lego::res::Container_LoadAnimSet
					(char *fname,IDirect3DRMFrame3 *frame,uint *out_frameCount,BOOL lws,BOOL looping)
{
	char cVar1;
	Lws_Info *scene;
	HRESULT HVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	IDirect3DRMFrame3 *unaff_EBX;
	AnimClone *pAVar6;
	IDirect3DRMAnimationSet2 *unaff_EBP;
	undefined4 *puVar7;
	undefined4 *puVar8;
	char *pcVar9;
	IDirect3DRMAnimationSet2 *local_11c;
	IDirect3DRMFrame3 *local_118;
	byte *local_114;
	uint local_110 [2];
	char acStack263 [3];
	char local_104 [260];
	
	pAVar6 = NULL;
	local_11c = NULL;
	if (lws == 0) {
		local_114 = lego::file::File_LoadBinary(fname,local_110);
		if (local_114 != NULL) {
										// IDirect3DRM3->CreateFrame(this, IDirect3DRMFrame3* lpD3DRMFrame,
										// IDirect3DRMFrame3** lplpD3DRMFrame)
			HVar2 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
												(globs::mainGlobs.lpD3DRM,frame,&local_118);
			if (HVar2 == 0) {
										// IDirect3DRM3->CreateAnimationSet(this, IDirect3DRMAnimationSet2**
										// lplpD3DRMAnimationSet)
				HVar2 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateAnimationSet)
													(globs::mainGlobs.lpD3DRM,&local_11c);
				if (HVar2 == 0) {
					local_114 = (byte *)fname;
					local_110[0] = 0;
										// IDirect3DRMAnimationSet2->Load(this, void* lpvObjSource, void* lpvObjID,
										// TD3DRMLoadOptions drd3mLOFlags, TD3DRMLoadTexture3Callback
										// d3drmLoadTextureProc, void* lpArgLTP, IDirect3DRMFrame3* lpParentFrame)
					iVar3 = (*(code *)unaff_EBP->lpVtbl->Load)
														(unaff_EBP,&local_11c,0,2,Container_TextureLoadCallback,&local_114,
														 unaff_EBX);
					if (iVar3 == 0) {
										// IDirect3DRMAnimationSet2->SetTime(this, float rvTime)
						(*(code *)unaff_EBP->lpVtbl->SetTime)(unaff_EBP,0);
						uVar4 = Container_GetAnimFileFrameCount((char *)local_11c);
						if (fname != NULL) {
							*(uint *)fname = uVar4;
						}
						pAVar6 = AnimClone_Register(unaff_EBP,unaff_EBX,uVar4);
					}
					std::free(local_11c);
				}
										// IDirect3DRMFrame3->Release(this)
				(*unaff_EBX->lpVtbl->Release)((IUnknown *)unaff_EBX);
			}
		}
	}
	else {
		uVar4 = 0xffffffff;
		do {
			pcVar9 = fname;
			if (uVar4 == 0) break;
			uVar4 -= 1;
			pcVar9 = fname + 1;
			cVar1 = *fname;
			fname = pcVar9;
		} while (cVar1 != '\0');
		uVar4 = ~uVar4;
		puVar7 = (undefined4 *)(pcVar9 + -uVar4);
		puVar8 = (undefined4 *)local_104;
		for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
			*puVar8 = *puVar7;
			puVar7 = puVar7 + 1;
			puVar8 = puVar8 + 1;
		}
		for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
			*(undefined *)puVar8 = *(undefined *)puVar7;
			puVar7 = (undefined4 *)((int)puVar7 + 1);
			puVar8 = (undefined4 *)((int)puVar8 + 1);
		}
		uVar4 = 0xffffffff;
		pcVar9 = local_104;
		do {
			if (uVar4 == 0) break;
			uVar4 -= 1;
			cVar1 = *pcVar9;
			pcVar9 = pcVar9 + 1;
		} while (cVar1 != '\0');
		acStack263[~uVar4] = '\0';
		scene = Lws_Parse(local_104,looping);
		if (scene != NULL) {
			Lws_LoadMeshes(scene,frame);
			Lws_SetTime(scene,0.0);
			if (out_frameCount != NULL) {
				uVar4 = Lws_GetFrameCount(scene);
				*out_frameCount = uVar4;
			}
			pAVar6 = AnimClone_RegisterLws(scene,frame,*out_frameCount);
			return pAVar6;
		}
	}
	return pAVar6;
}



uint __cdecl lego::res::Container_GetAnimFileFrameCount(char *fileData)
{
	byte *str;
	uint uVar1;
	
	uVar1 = 0;
	str = (byte *)std::strstr(fileData,"DDiScene");
	if (str != NULL) {
		while( true ) {
										// int std::isdigit(int c)
			if (std::globals::_pcharwidth < 2) {
										// C1_DIGIT (0x4)
				uVar1 = *(byte *)(std::globals::_pctype + *str) & C1_DIGIT;
			}
			else {
										// C1_DIGIT (0x4)
				uVar1 = std::_isctype((uint)*str,C1_DIGIT);
			}
			if (uVar1 != 0) break;
			str = str + 1;
		}
		uVar1 = std::atoi((char *)str);
	}
	if (uVar1 == 0) {
		uVar1 = 1;
	}
	return uVar1;
}



BOOL __cdecl lego::res::Container_FrameLoad(char *fname,IDirect3DRMFrame3 *frame)
{
	int iVar1;
	uint uVar2;
	void *buffer;
	byte *local_10;
	uint fileSize;
	char *local_8;
	undefined4 local_4;
	
	uVar2 = 0;
	local_10 = lego::file::File_LoadBinary(fname,&fileSize);
	if (local_10 != NULL) {
		buffer = NULL;
		local_8 = fname;
		local_4 = 0;
		iVar1 = (*(code *)frame->lpVtbl->Load)
											(frame,&local_10,0,2,Container_TextureLoadCallback,&local_8);
		uVar2 = (uint)(iVar1 == 0);
		std::free(buffer);
	}
	return uVar2;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

IDirect3DRMMesh * __cdecl
lego::res::Container_MeshLoad
					(void *file_data,uint file_size,char *file_name,IDirect3DRMFrame3 *frame,BOOL noTexture)
{
	int iVar1;
	int *piVar2;
	IDirect3DRMMesh **ppIVar3;
	IDirect3DRMMesh *local_10;
	HRESULT local_c;
	IDirect3DRMMeshBuilder3 *local_8;
	uint local_4;
	
	local_8 = (IDirect3DRMMeshBuilder3 *)file_data;
	local_4 = file_size;
										// IDirect3DRM3->CreateMeshBuilder(this, IDirect3DRMMeshBuilder3**
										// lplpD3DRMMeshBuilder)
	local_c = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateMeshBuilder)
											(globs::mainGlobs.lpD3DRM,(IDirect3DRMMeshBuilder3 **)&file_data);
	ppIVar3 = &local_10;
	if (local_c == 0) {
		local_10 = (IDirect3DRMMesh *)file_name;
		if (noTexture != 0) {
			local_c = 1;
		}
										// WARNING: Load size is inaccurate
		piVar2 = (int *)0x2;
										// IDirect3DRMMeshBuilder3->Load(this, void* lpvObjSource, void* lpvObjID,
										// TD3DRMLoadOptions d3drmLOFlags, TD3DRMLoadTexture3Callback
										// d3drmLoadTextureProc, void* lpvArg)
										//   D3DRMLOAD_FROMMEMORY (0x2)
		iVar1 = (**(code **)((int)*file_data + 0x2c))
											(file_data,&local_8,0,2,Container_TextureLoadCallback);
		if (iVar1 == 0) {
										// IDirect3DRMMeshBuilder3->CreateMesh(this, IDirect3DRMMesh** lplpD3DRMMesh)
			(**(code **)((int)*ppIVar3 + 0xc0))(ppIVar3,&local_10);
			(**(code **)(*piVar2 + 8))(piVar2);
										// IDirect3DRMFrame3->AddVisual(this, IDirect3DRMVisual* lpD3DRMVisual)
			iVar1 = (**(code **)((int)*ppIVar3 + 0x48))(ppIVar3,piVar2);
			if (iVar1 == 0) {
				return local_10;
			}
		}
		(**(code **)((int)*ppIVar3 + 8))(ppIVar3);
	}
	return NULL;
}



HRESULT __cdecl
lego::res::Container_TextureLoadCallback
					(char *name,Container_TextureData *textureData,IDirect3DRMTexture3 **texture)
{
	byte bVar1;
	IDirect3DRMTexture3 *pIVar2;
	char cVar3;
	byte *pbVar4;
	Container_Texture *pCVar5;
	char **ppcVar6;
	uint uVar7;
	int iVar8;
	uint uVar9;
	uint uVar10;
	char *pcVar11;
	char *pcVar12;
	Container_TextureRef *pCVar13;
	undefined4 *puVar14;
	byte *pbVar15;
	char **ppcVar16;
	char *pcVar17;
	char *pcVar18;
	char *pcVar19;
	undefined4 *puVar20;
	char **ppcVar21;
	bool bVar22;
	char *local_410;
	char *local_40c;
	int local_408;
	char *local_404;
	char local_400 [1024];
	
	if ((*(byte *)&textureData->flags & 1) == 0) {
		pcVar12 = textureData->xFileName;
		pcVar11 = local_400;
		local_410 = NULL;
		local_40c = pcVar12;
		local_404 = pcVar11;
		local_408 = 0;
		if ((globs::containerGlobs.sharedDir != NULL) != 0xffffffff) {
LAB_00476c0f:
			if (local_408 == 0) {
				cVar3 = *pcVar12;
				if (cVar3 != '\0') {
					do {
						if (cVar3 == '\\') {
							if (local_410 != NULL) {
								*local_410 = '\\';
							}
							*pcVar11 = '\0';
							local_410 = pcVar11;
						}
						else {
							*pcVar11 = cVar3;
						}
						cVar3 = pcVar12[1];
						pcVar12 = pcVar12 + 1;
						pcVar11 = pcVar11 + 1;
					} while (cVar3 != '\0');
					local_404 = pcVar11;
					local_40c = pcVar12;
				}
				if (local_410 == NULL) {
					uVar7 = 0xffffffff;
					pcVar18 = name;
					do {
						pcVar17 = pcVar18;
						if (uVar7 == 0) break;
						uVar7 -= 1;
						pcVar17 = pcVar18 + 1;
						cVar3 = *pcVar18;
						pcVar18 = pcVar17;
					} while (cVar3 != '\0');
					uVar7 = ~uVar7;
					puVar14 = (undefined4 *)(pcVar17 + -uVar7);
					puVar20 = (undefined4 *)local_400;
					for (uVar9 = uVar7 >> 2; uVar9 != 0; uVar9 -= 1) {
						*puVar20 = *puVar14;
						puVar14 = puVar14 + 1;
						puVar20 = puVar20 + 1;
					}
					for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
						*(undefined *)puVar20 = *(undefined *)puVar14;
						puVar14 = (undefined4 *)((int)puVar14 + 1);
						puVar20 = (undefined4 *)((int)puVar20 + 1);
					}
				}
				else {
					uVar7 = 0xffffffff;
					pcVar18 = "\\";
					do {
						pcVar17 = pcVar18;
						if (uVar7 == 0) break;
						uVar7 -= 1;
						pcVar17 = pcVar18 + 1;
						cVar3 = *pcVar18;
						pcVar18 = pcVar17;
					} while (cVar3 != '\0');
					uVar7 = ~uVar7;
					iVar8 = -1;
					puVar14 = (undefined4 *)local_400;
					do {
						puVar20 = puVar14;
						if (iVar8 == 0) break;
						iVar8 += -1;
						puVar20 = (undefined4 *)((int)puVar14 + 1);
						cVar3 = *(char *)puVar14;
						puVar14 = puVar20;
					} while (cVar3 != '\0');
					puVar14 = (undefined4 *)(pcVar17 + -uVar7);
					puVar20 = (undefined4 *)((int)puVar20 + -1);
					for (uVar9 = uVar7 >> 2; uVar9 != 0; uVar9 -= 1) {
						*puVar20 = *puVar14;
						puVar14 = puVar14 + 1;
						puVar20 = puVar20 + 1;
					}
					for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
						*(undefined *)puVar20 = *(undefined *)puVar14;
						puVar14 = (undefined4 *)((int)puVar14 + 1);
						puVar20 = (undefined4 *)((int)puVar20 + 1);
					}
					uVar7 = 0xffffffff;
					pcVar18 = name;
					do {
						pcVar17 = pcVar18;
						if (uVar7 == 0) break;
						uVar7 -= 1;
						pcVar17 = pcVar18 + 1;
						cVar3 = *pcVar18;
						pcVar18 = pcVar17;
					} while (cVar3 != '\0');
					uVar7 = ~uVar7;
					iVar8 = -1;
					pcVar18 = local_400;
					do {
						pcVar19 = pcVar18;
						if (iVar8 == 0) break;
						iVar8 += -1;
						pcVar19 = pcVar18 + 1;
						cVar3 = *pcVar18;
						pcVar18 = pcVar19;
					} while (cVar3 != '\0');
					puVar14 = (undefined4 *)(pcVar17 + -uVar7);
					puVar20 = (undefined4 *)(pcVar19 + -1);
					for (uVar9 = uVar7 >> 2; uVar9 != 0; uVar9 -= 1) {
						*puVar20 = *puVar14;
						puVar14 = puVar14 + 1;
						puVar20 = puVar20 + 1;
					}
					for (uVar7 &= 3; uVar7 != 0; uVar7 -= 1) {
						*(undefined *)puVar20 = *(undefined *)puVar14;
						puVar14 = (undefined4 *)((int)puVar14 + 1);
						puVar20 = (undefined4 *)((int)puVar20 + 1);
					}
				}
			}
			else {
				std::sprintf(local_400,"%s\\%s",globs::containerGlobs.sharedDir,name);
			}
			uVar7 = 0;
			*texture = NULL;
			if (globs::containerGlobs.textureCount != 0) {
				pCVar13 = globs::containerGlobs.textureSet;
				do {
					pbVar4 = (byte *)pCVar13->filename;
					if (pbVar4 != NULL) {
						pbVar15 = (byte *)local_400;
						do {
							bVar1 = *pbVar4;
							bVar22 = bVar1 < *pbVar15;
							if (bVar1 != *pbVar15) {
LAB_00476d3e:
								iVar8 = (1 - (uint)bVar22) - (uint)(bVar22 != 0);
								goto LAB_00476d43;
							}
							if (bVar1 == 0) break;
							bVar1 = pbVar4[1];
							bVar22 = bVar1 < pbVar15[1];
							if (bVar1 != pbVar15[1]) goto LAB_00476d3e;
							pbVar4 = pbVar4 + 2;
							pbVar15 = pbVar15 + 2;
						} while (bVar1 != 0);
						iVar8 = 0;
LAB_00476d43:
						pcVar11 = local_404;
						if (iVar8 == 0) {
							pIVar2 = globs::containerGlobs.textureSet[uVar7].texture;
							*texture = pIVar2;
							(*pIVar2->lpVtbl->AddRef)((IUnknown *)pIVar2);
							return 0;
						}
					}
					uVar7 += 1;
					pCVar13 = pCVar13 + 1;
					pcVar12 = local_40c;
				} while (uVar7 < globs::containerGlobs.textureCount);
			}
			pCVar5 = Container_LoadTexture2(local_400,0,NULL,NULL);
			if (pCVar5 == NULL) {
				local_408 += 1;
				if ((int)((globs::containerGlobs.sharedDir != NULL) + 1) <= local_408) {
					return -0x7789fcef;
				}
				goto LAB_00476c0f;
			}
			pIVar2 = pCVar5->texture;
			*texture = pIVar2;
			Container_YFlipTexture(pIVar2);
			if (((byte)globs::mainGlobs.flags & CMD_MIPMAP) != 0) {
				(*(code *)(*texture)->lpVtbl->GenerateMIPMap)(*texture,0);
			}
			if (globs::containerGlobs.textureCount == 1000) {
				std::qsort(globs::containerGlobs.textureSet,1000,8,Container_TextureSetSort);
				while (globs::containerGlobs.visualArray[globs::containerGlobs.textureCount * 2 + 2] == NULL
							) {
					globs::containerGlobs.textureCount -= 1;
				}
			}
			uVar7 = globs::containerGlobs.textureCount;
			if (globs::containerGlobs.textureCount < 1000) {
				pCVar13 = globs::containerGlobs.textureSet + globs::containerGlobs.textureCount;
				(*(*texture)->lpVtbl->AddDestroyCallback)
									((IUnknown *)*texture,Container_TextureDestroyCallback,pCVar13);
				uVar9 = 0xffffffff;
				ppcVar6 = &local_40c;
				do {
					if (uVar9 == 0) break;
					uVar9 -= 1;
					cVar3 = *(char *)ppcVar6;
					ppcVar6 = (char **)((int)ppcVar6 + 1);
				} while (cVar3 != '\0');
				ppcVar6 = (char **)std::malloc(~uVar9);
				uVar9 = 0xffffffff;
				pCVar13->filename = (char *)ppcVar6;
				ppcVar16 = &local_40c;
				do {
					ppcVar21 = ppcVar16;
					if (uVar9 == 0) break;
					uVar9 -= 1;
					ppcVar21 = (char **)((int)ppcVar16 + 1);
					cVar3 = *(char *)ppcVar16;
					ppcVar16 = ppcVar21;
				} while (cVar3 != '\0');
				uVar9 = ~uVar9;
				ppcVar16 = (char **)((int)ppcVar21 - uVar9);
				for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 -= 1) {
					*ppcVar6 = *ppcVar16;
					ppcVar16 = ppcVar16 + 1;
					ppcVar6 = ppcVar6 + 1;
				}
				for (uVar9 &= 3; uVar9 != 0; uVar9 -= 1) {
					*(undefined *)ppcVar6 = *(undefined *)ppcVar16;
					ppcVar16 = (char **)((int)ppcVar16 + 1);
					ppcVar6 = (char **)((int)ppcVar6 + 1);
				}
				globs::containerGlobs.textureSet[uVar7].texture = *texture;
				globs::containerGlobs.textureCount += 1;
			}
			return 0;
		}
	}
	return -0x7789fcef;
}



void __cdecl lego::res::Container_YFlipTexture(IDirect3DRMTexture3 *texture)
{
	D3DRMImage *pDVar1;
	int iVar2;
	undefined4 *buffer;
	uint uVar3;
	undefined4 *puVar4;
	undefined4 *puVar5;
	uint length;
	undefined4 *puVar6;
	undefined4 *puVar7;
	int local_c;
	
	pDVar1 = (*texture->lpVtbl->GetImage)(texture);
	if (pDVar1 != NULL) {
		iVar2 = pDVar1->depth * pDVar1->width;
		length = (int)(iVar2 + (iVar2 >> 0x1f & 7U)) >> 3;
		buffer = (undefined4 *)std::malloc(length);
		if (buffer != NULL) {
			puVar4 = (undefined4 *)pDVar1->buffer1;
			local_c = 0;
			puVar5 = (undefined4 *)((pDVar1->height + -1) * pDVar1->bytes_per_line + (int)puVar4);
			if (0 < pDVar1->height / 2) {
				do {
					puVar6 = puVar5;
					puVar7 = buffer;
					for (uVar3 = length >> 2; uVar3 != 0; uVar3 -= 1) {
						*puVar7 = *puVar6;
						puVar6 = puVar6 + 1;
						puVar7 = puVar7 + 1;
					}
					for (uVar3 = length & 3; uVar3 != 0; uVar3 -= 1) {
						*(undefined *)puVar7 = *(undefined *)puVar6;
						puVar6 = (undefined4 *)((int)puVar6 + 1);
						puVar7 = (undefined4 *)((int)puVar7 + 1);
					}
					puVar6 = puVar4;
					puVar7 = puVar5;
					for (uVar3 = length >> 2; uVar3 != 0; uVar3 -= 1) {
						*puVar7 = *puVar6;
						puVar6 = puVar6 + 1;
						puVar7 = puVar7 + 1;
					}
					for (uVar3 = length & 3; uVar3 != 0; uVar3 -= 1) {
						*(undefined *)puVar7 = *(undefined *)puVar6;
						puVar6 = (undefined4 *)((int)puVar6 + 1);
						puVar7 = (undefined4 *)((int)puVar7 + 1);
					}
					puVar6 = buffer;
					puVar7 = puVar4;
					for (uVar3 = length >> 2; uVar3 != 0; uVar3 -= 1) {
						*puVar7 = *puVar6;
						puVar6 = puVar6 + 1;
						puVar7 = puVar7 + 1;
					}
					for (uVar3 = length & 3; uVar3 != 0; uVar3 -= 1) {
						*(undefined *)puVar7 = *(undefined *)puVar6;
						puVar6 = (undefined4 *)((int)puVar6 + 1);
						puVar7 = (undefined4 *)((int)puVar7 + 1);
					}
					puVar4 = (undefined4 *)((int)puVar4 + pDVar1->bytes_per_line);
					puVar5 = (undefined4 *)((int)puVar5 - pDVar1->bytes_per_line);
					local_c += 1;
				} while (local_c < pDVar1->height / 2);
			}
			std::free(buffer);
		}
	}
	return;
}



// if (*param_1 && !*param_2) return -1;
// if (!*param_1 && *param_2) return  1;
// else                       return  0;

int __cdecl lego::res::Container_TextureSetSort(Container_TextureRef *a,Container_TextureRef *b)
{
	if ((a->filename != NULL) && (b->filename == NULL)) {
		return -1;
	}
	if ((a->filename == NULL) && (b->filename != NULL)) {
		return 1;
	}
	return 0;
}



void __cdecl
lego::res::Container_TextureDestroyCallback
					(IDirect3DRMTexture3 *lpD3DRMobj,Container_TextureRef *textRef)
{
	void *buffer;
	
	buffer = (*textRef->texture->lpVtbl->GetAppData)(textRef->texture);
	std::free(buffer);
	std::free(textRef->filename);
	textRef->filename = NULL;
	textRef->texture = NULL;
	return;
}



void __cdecl lego::view::Viewport_Initialise(void)
{
	int iVar1;
	Viewport_Globs *pVVar2;
	
	pVVar2 = &globs::viewportGlobs;
	for (iVar1 = 0x20; iVar1 != 0; iVar1 += -1) {
		pVVar2->listSet[0] = NULL;
		pVVar2 = (Viewport_Globs *)(pVVar2->listSet + 1);
	}
	globs::viewportGlobs.freeList = NULL;
	globs::viewportGlobs.listCount = 0;
	globs::viewportGlobs.flags = 1;
	return;
}



void __cdecl lego::view::Viewport_Shutdown(void)
{
	Viewport_Globs *pVVar1;
	
	Viewport_RemoveAll();
	pVVar1 = &globs::viewportGlobs;
	do {
		if (pVVar1->listSet[0] != NULL) {
			std::free(pVVar1->listSet[0]);
		}
		pVVar1 = (Viewport_Globs *)(pVVar1->listSet + 1);
	} while (pVVar1 < (Viewport_Globs *)&globs::viewportGlobs.freeList);
	globs::viewportGlobs.freeList = NULL;
	globs::viewportGlobs.flags = 0;
	return;
}



// Creates a viewport, where the float arguments are positions between 0.0 and 1.0
//  (rather than between 0,0 and rmWidth,rmHeight)

Viewport * __cdecl
lego::view::Viewport_Create(float xposf,float yposf,float widthf,float heightf,Container *resData)
{
	uint uVar1;
	uint uVar2;
	int yPos;
	Viewport *pVVar3;
	float10 extraout_ST0;
	longlong lVar4;
	float unaff_retaddr;
	float fVar5;
	float fStack4;
	
	uVar1 = (*(code *)(globs::mainGlobs.device)->lpVtbl->GetWidth)(globs::mainGlobs.device);
	uVar2 = (*(code *)(globs::mainGlobs.device)->lpVtbl->GetHeight)(globs::mainGlobs.device);
	fVar5 = (float)(ulonglong)uVar1;
	lVar4 = __ftol((float10)yposf * (float10)(ulonglong)uVar2);
	uVar1 = (uint)lVar4;
	lVar4 = __ftol((float10)xposf * (float10)fVar5);
	uVar2 = (uint)lVar4;
	lVar4 = __ftol((float10)unaff_retaddr * extraout_ST0);
	yPos = (int)lVar4;
	lVar4 = __ftol((float10)fStack4 * (float10)fVar5);
	pVVar3 = Viewport_CreatePixel((int)lVar4,yPos,uVar2,uVar1,(Container *)widthf);
	return pVVar3;
}



Viewport * __cdecl
lego::view::Viewport_CreatePixel(int xPos,int yPos,uint width,uint height,Container *resCamera)
{
	IDirect3DRMViewport2 **lplpD3DRMViewport;
	Viewport **ppVVar1;
	IDirect3DRMViewport2 *This;
	Viewport *appData;
	uint uVar2;
	uint uVar3;
	HRESULT HVar4;
	uint unaff_EBX;
	uint unaff_retaddr;
	
	uVar2 = (*(code *)(globs::mainGlobs.device)->lpVtbl->GetWidth)(globs::mainGlobs.device);
	uVar3 = (*(code *)(globs::mainGlobs.device)->lpVtbl->GetHeight)(globs::mainGlobs.device);
	if ((int)unaff_EBX < 0) {
		unaff_EBX += uVar2;
	}
	if ((int)unaff_retaddr < 0) {
		unaff_retaddr += uVar3;
	}
	if ((xPos + unaff_EBX <= uVar2) && (yPos + unaff_retaddr <= uVar3)) {
		if (globs::viewportGlobs.freeList == NULL) {
			Viewport_AddList();
		}
		appData = globs::viewportGlobs.freeList;
		lplpD3DRMViewport = &(globs::viewportGlobs.freeList)->lpVP;
		ppVVar1 = &(globs::viewportGlobs.freeList)->nextFree;
		globs::viewportGlobs.freeList = (globs::viewportGlobs.freeList)->nextFree;
		*ppVVar1 = NULL;
										// IDirect3DRM3->CreateViewport(this, IDirect3DRMDevice3* lpDev,
										// IDirect3DRMFrame3* lpCamera, DWORD dwXPos, DWORD dwYPos, DWORD dwWidth, DWORD
										// dwHeight, IDirect3DRMViewport2** lplpD3DRMViewport)
		HVar4 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateViewport)
											(globs::mainGlobs.lpD3DRM,globs::mainGlobs.device,*(IDirect3DRMFrame3 **)width
											 ,unaff_EBX,unaff_retaddr,xPos,yPos,lplpD3DRMViewport);
		if (HVar4 == 0) {
			This = *lplpD3DRMViewport;
										// IDirect3DRMViewport2->SetAppData(this, ViewportData* appData)
			(*This->lpVtbl->SetAppData)(This,appData);
			appData->smoothFOV = 0.0;
			return appData;
		}
	}
	return NULL;
}



void __cdecl lego::view::Viewport_GetSize(Viewport *view,uint *out_width,uint *out_height)
{
	DWORD DVar1;
	
	if (out_width != NULL) {
		DVar1 = (*view->lpVP->lpVtbl->GetWidth)(view->lpVP);
		*out_width = DVar1;
	}
	if (out_height != NULL) {
		DVar1 = (*view->lpVP->lpVtbl->GetHeight)(view->lpVP);
		*out_height = DVar1;
	}
	return;
}



void __cdecl lego::view::Viewport_SetCamera(Viewport *view,Container *resCamera)
{
	(*view->lpVP->lpVtbl->SetCamera)(view->lpVP,resCamera->masterFrame);
	return;
}



Container * __cdecl lego::view::Viewport_GetCamera(Viewport *view)
{
	HRESULT HVar1;
	Container *pCVar2;
	Container *pCVar3;
	
	pCVar3 = NULL;
										// IDirect3DRMViewport2->GetCamera(this, IDirect3DRMFrame3** lplpCamera)
	HVar1 = (*view->lpVP->lpVtbl->GetCamera)(view->lpVP,(IDirect3DRMFrame3 **)&view);
	if (HVar1 == 0) {
										// ResourceData* IDirect3DRMFrame3->GetAppData(this)
		pCVar2 = (**(code **)((int)view->xoffset + 0x1c))((IDirect3DRMFrame3 *)view);
		if (pCVar2 != NULL) {
			pCVar3 = (Container *)pCVar2->masterFrame;
		}
										// IDirect3DRMFrame3->Release(this)
		(**(code **)((int)view->xoffset + 8))(view);
	}
	return pCVar3;
}



void __cdecl lego::view::Viewport_SetBackClip(Viewport *view,float dist)
{
	(*view->lpVP->lpVtbl->SetBack)(view->lpVP,dist);
	return;
}



float10 __cdecl lego::view::Viewport_GetBackClip(Viewport *view)
{
	float10 fVar1;
	
										// float IDirect3DRMViewport2->GetBack(this)
	fVar1 = (*view->lpVP->lpVtbl->GetBack)(view->lpVP);
	return fVar1;
}



float10 __cdecl lego::view::Viewport_GetFrontClip(Viewport *view)
{
	float10 fVar1;
	
										// float IDirect3DRMViewport2->GetFront(this)
	fVar1 = (*view->lpVP->lpVtbl->GetFront)(view->lpVP);
	return fVar1;
}



void __cdecl lego::view::Viewport_Clear(Viewport *view,BOOL full)
{
	Viewport *pVVar1;
	IDirect3DRMFrame3 *pIVar2;
	DWORD DVar3;
	longlong lVar4;
	RECT local_20;
	float local_10;
	float local_c;
	float local_8;
	float local_4;
	
	pVVar1 = view;
	if ((IDirect3DViewport3 *)full != NULL) {
		pIVar2 = Viewport_GetScene(view);
		DVar3 = 0;
		view = (Viewport *)(*pVVar1->lpVP->lpVtbl->GetX)(pVVar1->lpVP);
		local_10 = (float)(int)view;
		view = (Viewport *)(*pVVar1->lpVP->lpVtbl->GetY)(pVVar1->lpVP);
		local_c = (float)(int)view;
		local_20.left = (*pVVar1->lpVP->lpVtbl->GetWidth)(pVVar1->lpVP);
		local_20.top = 0;
		local_8 = (float)(ulonglong)(uint)local_20.left;
		local_20.left = (*pVVar1->lpVP->lpVtbl->GetHeight)(pVVar1->lpVP);
		local_20.top = 0;
		local_4 = (float)(ulonglong)(uint)local_20.left;
		if (pIVar2 != NULL) {
			DVar3 = (*pIVar2->lpVtbl->GetSceneBackground)(pIVar2);
		}
		lVar4 = __ftol((float10)local_10);
		local_20.left = (LONG)lVar4;
		lVar4 = __ftol((float10)local_c);
		local_20.top = (LONG)lVar4;
		lVar4 = __ftol((float10)local_10 + (float10)local_8);
		local_20.right = (LONG)lVar4;
		lVar4 = __ftol((float10)local_c + (float10)local_4);
		local_20.bottom = (LONG)lVar4;
		(*pVVar1->lpVP->lpVtbl->GetDirect3DViewport)(pVVar1->lpVP,(IDirect3DViewport **)&view);
		(**(code **)view->xoffset)
							((IDirect3DViewport *)view,&idl::IID_IDirect3DViewport3,(IDirect3DViewport3 **)&full);
		(**(code **)((int)view->xoffset + 8))((IDirect3DViewport *)view);
		(**(code **)((int)*(IDirect3DViewport3 *)full + 0x50))
							((IDirect3DViewport3 *)full,1,&local_20,3,DVar3,1.0,0);
		(**(code **)((int)*(IDirect3DViewport3 *)full + 8))((IDirect3DViewport3 *)full);
		return;
	}
	(*view->lpVP->lpVtbl->Clear)(view->lpVP,D3DRMCLEAR_ALL);
	return;
}



void __cdecl lego::view::Viewport_Render(Viewport *view,Container *resRoot,float delta)
{
	float fVar1;
	HRESULT err;
	float10 fVar2;
	
	view->rendering = 1;
	if (view->smoothFOV != 0.0) {
										// float IDirect3DRMViewport2->GetField(this)
		fVar2 = (*view->lpVP->lpVtbl->GetField)(view->lpVP);
		fVar1 = (1.0 / delta) * 4.0;
		fVar1 = (1.0 / (fVar1 - -1.0)) * (float)(fVar2 * (float10)fVar1 + (float10)view->smoothFOV);
										// IDirect3DRMViewport2->SetField(this, float rvField)
		(*view->lpVP->lpVtbl->SetField)(view->lpVP,fVar1);
		if (fVar1 == view->smoothFOV) {
			view->smoothFOV = 0.0;
		}
	}
										// IDirect3DRMViewport2->Render(this, IDirect3DRMFrame3* lpD3DRMFrame)
	err = (*view->lpVP->lpVtbl->Render)(view->lpVP,resRoot->masterFrame);
	if (err == 0) {
		Mesh_PostRenderAll(view);
		view->rendering = 0;
		return;
	}
	debug::Error_SetDXError(err,1,"C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Viewports.c",286);
	view->rendering = 0;
	return;
}



void __cdecl lego::view::Viewport_Remove(Viewport *view)
{
	view->nextFree = globs::viewportGlobs.freeList;
	globs::viewportGlobs.freeList = view;
	(*view->lpVP->lpVtbl->Release)(view->lpVP);
	return;
}



void __cdecl lego::view::Viewport_SmoothSetField(Viewport *view,float fov)
{
	view->smoothFOV = fov;
	return;
}



void __cdecl lego::view::Viewport_SetField(Viewport *view,float fov)
{
	(*view->lpVP->lpVtbl->SetField)(view->lpVP,fov);
	view->smoothFOV = 0.0;
	return;
}



float10 __cdecl lego::view::Viewport_GetField(Viewport *view)
{
	float10 fVar1;
	
	fVar1 = (*view->lpVP->lpVtbl->GetField)(view->lpVP);
	return fVar1;
}



void __cdecl
lego::view::Viewport_InverseTransform(Viewport *view,Vector3F *out_vector,Vector4F *transform4d)
{
										// IDirect3DRMViewport2->InverseTransform(this, Vector3F* out_lprvDst, const
										// Vector4F* lprvSrc)
	(*view->lpVP->lpVtbl->InverseTransform)(view->lpVP,out_vector,transform4d);
	return;
}



void __cdecl
lego::view::Viewport_Transform(Viewport *view,Vector4F *out_transform4d,Vector3F *vector)
{
										// IDirect3DRMViewport2->Transform(this, Vector4F** lplprvDst, Vector3F*
										// lprvSrc)
	(*view->lpVP->lpVtbl->Transform)(view->lpVP,out_transform4d,vector);
	return;
}



Point2F * __cdecl
lego::view::Viewport_WorldToScreen(Viewport *view,Point2F *out_screenPt,Vector3F *in_worldVec)
{
	Vector4F transform4d;
	
										// IDirect3DRMViewport2->Transform(this, Vector4F** lplprvDst, Vector3F*
										// lprvSrc)
	(*view->lpVP->lpVtbl->Transform)(view->lpVP,&transform4d,in_worldVec);
										// out_point.x = (transform4d.x / transform4d.w)
										// out_point.y = (transform4d.y / transform4d.w)
	out_screenPt->x = transform4d.x / transform4d.w;
	out_screenPt->y = transform4d.y / transform4d.w;
	return out_screenPt;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

IDirect3DRMFrame3 * __cdecl lego::view::Viewport_GetScene(Viewport *view)
{
	IDirect3DRMFrame3 *local_8;
	IDirect3DRMFrame3 *local_4;
	
	local_8 = NULL;
	local_4 = NULL;
	(*view->lpVP->lpVtbl->GetCamera)(view->lpVP,&local_8);
	if (local_8 != NULL) {
		(*local_8->lpVtbl->Release)((IUnknown *)local_8);
		(*local_8->lpVtbl->GetScene)((IDirect3DRMViewport2 *)local_8,(IDirect3DRMDevice3 **)&local_4);
		(*local_4->lpVtbl->Release)((IUnknown *)local_4);
	}
	return local_4;
}



void __cdecl lego::view::Viewport_AddList(void)
{
	Viewport *pVVar1;
	Viewport *pVVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::viewportGlobs.listCount & 0x1f);
	pVVar2 = (Viewport *)std::malloc(uVar4 * 0x20);
	globs::viewportGlobs.listSet[globs::viewportGlobs.listCount] = pVVar2;
	pVVar2 = globs::viewportGlobs.listSet[globs::viewportGlobs.listCount];
	if (pVVar2 != NULL) {
		globs::viewportGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pVVar1 = pVVar2;
			do {
				pVVar1->nextFree = pVVar1 + 1;
				iVar3 += -1;
				pVVar1 = pVVar1 + 1;
			} while (iVar3 != 0);
		}
		pVVar2[uVar4 - 1].nextFree = globs::viewportGlobs.freeList;
		globs::viewportGlobs.freeList = pVVar2;
	}
	return;
}



void __cdecl lego::view::Viewport_RemoveAll(void)
{
	int iVar1;
	int iVar2;
	Viewport_Globs *pVVar3;
	uint uVar4;
	int iVar5;
	
	uVar4 = 0;
	if (globs::viewportGlobs.listCount != 0) {
		pVVar3 = &globs::viewportGlobs;
		do {
			if ((pVVar3->listSet[0] != NULL) && (iVar1 = 1 << ((byte)uVar4 & 0x1f), iVar1 != 0)) {
				iVar5 = 0;
				do {
					iVar2 = (int)&pVVar3->listSet[0]->xoffset + iVar5;
					if ((iVar2 != 0) && (*(int *)(iVar2 + 0x1c) == iVar2)) {
										// IDirect3DRMViewport2->Release(this)
						(*(*(IDirect3DRMViewport2 **)(iVar2 + 0x10))->lpVtbl->Release)
											(*(IDirect3DRMViewport2 **)(iVar2 + 0x10));
					}
					iVar5 += 0x20;
					iVar1 += -1;
				} while (iVar1 != 0);
			}
			uVar4 += 1;
			pVVar3 = (Viewport_Globs *)(pVVar3->listSet + 1);
		} while (uVar4 < globs::viewportGlobs.listCount);
	}
	return;
}



int __cdecl lego::util::Util_Tokenise(char *input,char **out_parts,char *delimiter)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	int numParts;
	char *pcVar4;
	char **ppcVar5;
	
	uVar3 = 0xffffffff;
	pcVar4 = delimiter;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar4;
		pcVar4 = pcVar4 + 1;
	} while (cVar1 != '\0');
	if (*input == '\0') {
		return 0;
	}
	numParts = 1;
	*out_parts = input;
	if (*input != '\0') {
		ppcVar5 = out_parts + 1;
		do {
			iVar2 = std::strncmp(delimiter,input,~uVar3 - 1);
			if (iVar2 == 0) {
				*input = '\0';
				*ppcVar5 = input + (~uVar3 - 1);
				numParts += 1;
				ppcVar5 = ppcVar5 + 1;
			}
			pcVar4 = input + 1;
			input = input + 1;
		} while (*pcVar4 != '\0');
	}
	return numParts;
}



int __cdecl lego::util::Util_WSTokenise(char *input,char **out_parts)
{
	uint uVar1;
	int iVar2;
	byte **ppbVar3;
	
	if (*input != '\0') {
		*out_parts = input;
		iVar2 = 1;
		if (*input != '\0') {
			ppbVar3 = (byte **)(out_parts + 1);
			do {
										// int std::isspace(int c)
				if (std::globals::_pcharwidth < 2) {
										// C1_SPACE (0x8)
					uVar1 = *(byte *)(std::globals::_pctype + (byte)*input) & C1_SPACE;
				}
				else {
										// C1_SPACE (0x8)
					uVar1 = std::_isctype((uint)(byte)*input,C1_SPACE);
				}
				if (uVar1 == 0) {
					input = (char *)((byte *)input + 1);
				}
				else {
					*input = 0;
					do {
						input = (char *)((byte *)input + 1);
										// int std::isspace(int c)
						if (std::globals::_pcharwidth < 2) {
										// C1_SPACE (0x8)
							uVar1 = *(byte *)(std::globals::_pctype + (byte)*input) & C1_SPACE;
						}
						else {
										// C1_SPACE (0x8)
							uVar1 = std::_isctype((uint)(byte)*input,C1_SPACE);
						}
					} while (uVar1 != 0);
					*ppbVar3 = (byte *)input;
					iVar2 += 1;
					ppbVar3 = ppbVar3 + 1;
				}
			} while (*input != 0);
		}
		return iVar2;
	}
	return 0;
}



// OFFICIAL: Util_StrCpy
// C RUNTIME: ::_strdup

char * __cdecl std::_strdup(char *strSource)
{
	char cVar1;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	uVar3 = 0xffffffff;
	pcVar6 = strSource;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar6;
		pcVar6 = pcVar6 + 1;
	} while (cVar1 != '\0');
	puVar2 = (undefined4 *)malloc(~uVar3);
	uVar3 = 0xffffffff;
	do {
		pcVar6 = strSource;
		if (uVar3 == 0) break;
		uVar3 -= 1;
		pcVar6 = strSource + 1;
		cVar1 = *strSource;
		strSource = pcVar6;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	puVar5 = (undefined4 *)(pcVar6 + -uVar3);
	puVar7 = puVar2;
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
		*puVar7 = *puVar5;
		puVar5 = puVar5 + 1;
		puVar7 = puVar7 + 1;
	}
	for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)puVar7 = *(undefined *)puVar5;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
		puVar7 = (undefined4 *)((int)puVar7 + 1);
	}
	return (char *)puVar2;
}



char * __cdecl lego::util::Util_RemoveUnderscores(char *text,...)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	char *pcVar4;
	char fmtBuffer [256];
	char replBuffer [256];
	
	std::vsprintf(fmtBuffer,text,&stack0x00000008);
	pcVar3 = fmtBuffer;
	pcVar4 = replBuffer;
	while (fmtBuffer[0] != '\0') {
		cVar2 = *pcVar3;
		if ((cVar2 == '\\') && (pcVar3[1] == 'n')) {
			*pcVar4 = '\n';
			pcVar3 = pcVar3 + 1;
		}
		else {
			if (cVar2 == '_') {
				*pcVar4 = ' ';
			}
			else {
				*pcVar4 = cVar2;
			}
		}
		pcVar1 = pcVar3 + 1;
		pcVar4 = pcVar4 + 1;
		pcVar3 = pcVar3 + 1;
		fmtBuffer[0] = *pcVar1;
	}
	*pcVar4 = '\0';
	pcVar4 = std::_strdup(replBuffer);
	return pcVar4;
}



char * __cdecl lego::util::Util_StrIStr(char *str,char *strSearch)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	char *pcVar5;
	uint uVar6;
	
	uVar3 = 0xffffffff;
	pcVar5 = str;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	uVar4 = 0xffffffff;
	pcVar5 = strSearch;
	do {
		if (uVar4 == 0) break;
		uVar4 -= 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	if (((uVar3 != 1) && (~uVar4 - 1 != 0)) && (uVar6 = 0, uVar3 != 1)) {
		do {
			iVar2 = std::_strnicmp(str,strSearch,~uVar4 - 1);
			if (iVar2 == 0) {
				return str;
			}
			uVar6 += 1;
			str = str + 1;
		} while (uVar6 < uVar3 - 1);
		return NULL;
	}
	return NULL;
}



// https://github.com/microsoft/Windows-classic-samples/blob/master/Samples/Win7Samples/begin/sdkdiff/utils.cpp
// 
// hash_string()

uint __cdecl lego::util::Util_HashString(char *str,BOOL bIgnoreBlanks,BOOL upperCase)
{
	byte bVar1;
	uint uVar2;
	int iVar3;
	int iVar4;
	uint uVar5;
	byte *pbVar6;
	int iVar7;
	
	uVar5 = 0;
	iVar7 = 0x600937;
	iVar4 = 1;
	bVar1 = *str;
	pbVar6 = (byte *)str;
	while (bVar1 != 0) {
		if (bIgnoreBlanks != 0) {
			while( true ) {
										// int std::isspace(int c)
				if (std::globals::_pcharwidth < 2) {
										// C1_SPACE (0x8)
					uVar2 = *(byte *)(std::globals::_pctype + *pbVar6) & C1_SPACE;
				}
				else {
										// C1_SPACE (0x8)
					uVar2 = std::_isctype((uint)*pbVar6,C1_SPACE);
				}
				if (uVar2 == 0) break;
				pbVar6 = pbVar6 + 1;
			}
		}
		bVar1 = *pbVar6;
		pbVar6 = pbVar6 + 1;
		str = (char *)(uint)bVar1;
		if (upperCase != 0) {
			uVar2 = std::toupper((int)str);
			str = (char *)(uVar2 & 0xff);
		}
		iVar3 = iVar4 * iVar7;
		iVar7 *= 0x600937;
		uVar5 += iVar3 * (int)str;
		iVar4 += 1;
		bVar1 = *pbVar6;
	}
	return uVar5;
}



BOOL3 __cdecl lego::util::Util_GetBoolFromString(char *str)
{
	int iVar1;
	
	iVar1 = std::_stricmp(str,"YES");
	if (iVar1 == 0) {
		return BOOL3_TRUE;
	}
	iVar1 = std::_stricmp(str,"TRUE");
	if (iVar1 == 0) {
		return BOOL3_TRUE;
	}
	iVar1 = std::_stricmp(str,"ON");
	if (iVar1 == 0) {
		return BOOL3_TRUE;
	}
	iVar1 = std::_stricmp(str,"NO");
	if (iVar1 == 0) {
		return BOOL3_FALSE;
	}
	iVar1 = std::_stricmp(str,"FALSE");
	if (iVar1 == 0) {
		return BOOL3_FALSE;
	}
	iVar1 = std::_stricmp(str,"OFF");
	return -(uint)(iVar1 != 0) & BOOL3_ERROR;
}



int lego::WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nShowCmd)
{
	char cVar1;
	DWORD DVar2;
	LPSTR pCVar3;
	char *pcVar4;
	BOOL BVar5;
	CmdlineFlags CVar6;
	DWORD DVar7;
	uint uVar8;
	uint uVar9;
	int iVar10;
	undefined4 *puVar11;
	char *pcVar12;
	undefined4 *puVar13;
	float fpsSync;
	BOOL insistOnCD;
	BOOL nosound;
	uint local_c88;
	undefined4 uStack3204;
	char mutexName [128];
	char fullCmdLine [1024];
	char errorMessage [1024];
	char standardParameters [1024];
	
	nosound = 0;
	insistOnCD = 0;
	if (true) {
		std::sprintf(mutexName,"%s Mutex","Lego Rock Raiders");
		CreateMutexA(NULL,TRUE,mutexName);
		DVar2 = GetLastError();
		if (DVar2 == ERROR_ALREADY_EXISTS) {
			return 0;
		}
	}
	pCVar3 = GetCommandLineA();
	cVar1 = *pCVar3;
	pcVar4 = pCVar3;
	while (cVar1 != '\0') {
		if (cVar1 == '\\') {
			pcVar4 = pCVar3 + 1;
		}
		pcVar12 = pCVar3 + 1;
		pCVar3 = pCVar3 + 1;
		cVar1 = *pcVar12;
	}
	uVar8 = 0xffffffff;
	do {
		pcVar12 = pcVar4;
		if (uVar8 == 0) break;
		uVar8 -= 1;
		pcVar12 = pcVar4 + 1;
		cVar1 = *pcVar4;
		pcVar4 = pcVar12;
	} while (cVar1 != '\0');
	uVar8 = ~uVar8;
	puVar11 = (undefined4 *)(pcVar12 + -uVar8);
	puVar13 = (undefined4 *)globs::mainGlobs.programName;
	for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 -= 1) {
		*puVar13 = *puVar11;
		puVar11 = puVar11 + 1;
		puVar13 = puVar13 + 1;
	}
	pcVar4 = globs::mainGlobs.programName;
	for (uVar8 &= 3; cVar1 = globs::mainGlobs.programName[0], uVar8 != 0; uVar8 -= 1) {
		*(undefined *)puVar13 = *(undefined *)puVar11;
		puVar11 = (undefined4 *)((int)puVar11 + 1);
		puVar13 = (undefined4 *)((int)puVar13 + 1);
	}
	while (cVar1 != '\0') {
		if (*pcVar4 == '\"') {
			*pcVar4 = '\0';
		}
		pcVar12 = pcVar4 + 1;
		pcVar4 = pcVar4 + 1;
		cVar1 = *pcVar12;
	}
	iVar10 = 0x506814;
	pcVar4 = globs::mainGlobs.programName;
	cVar1 = globs::mainGlobs.programName[0];
	while (cVar1 != '\0') {
		if (cVar1 == '.') {
			pcVar4 = (char *)(iVar10 + 1);
		}
		pcVar12 = (char *)(iVar10 + 1);
		iVar10 += 1;
		cVar1 = *pcVar12;
	}
	if (pcVar4 != globs::mainGlobs.programName) {
										// to upper
		std::_strupr(pcVar4);
		pcVar4 = std::strstr(globs::mainGlobs.programName,".EXE");
		if (pcVar4 != NULL) {
			*pcVar4 = '\0';
		}
	}
	globs::mainGlobs.className = globs::mainGlobs.programName;
	globs::mainGlobs.active = 0;
	globs::mainGlobs.exit = 0;
	globs::mainGlobs.stateSet = 0;
	globs::mainGlobs.hInst = hInstance;
	globs::mainGlobs.fixedFrameTiming = 0.0;
	globs::mainGlobs.flags = CMD_NONE;
	BVar5 = registry::Registry_GetValue
										("SOFTWARE\\LEGO Media\\Games\\Rock Raiders","StandardParameters",
										 REGISTRY_STRING_VALUE,standardParameters,0x400);
	if (BVar5 == 0) {
		std::sprintf(fullCmdLine,"%s",lpCmdLine);
	}
	else {
		std::sprintf(fullCmdLine,"%s %s",lpCmdLine,standardParameters);
	}
	main::Main_ParseCommandLine(fullCmdLine,&nosound,&insistOnCD);
	BVar5 = registry::Registry_GetValue
										("SOFTWARE\\LEGO Media\\Games\\Rock Raiders","NoHALMessage",
										 REGISTRY_STRING_VALUE,errorMessage,0x400);
	if (BVar5 == 0) {
		std::sprintf(errorMessage,"No DirectX 3D accelerator could be found.");
	}
	debug::Error_Initialise();
	file::Mem_Initialise();
	file::File_Initialise
						(globs::mainGlobs.programName,insistOnCD,"SOFTWARE\\LEGO Media\\Games\\Rock Raiders");
	cfg::Config_Initialise();
	input::Input_InitKeysAndDI();
	BVar5 = main::Main_InitApp(hInstance);
	if (BVar5 != 0) {
		ddraw::DirectDraw_Initialise(globs::mainGlobs.hWnd);
		BVar5 = snd::Sound_Initialise(nosound);
		if ((BVar5 != 0) &&
			 (BVar5 = setup::Init_Initialise
													(TRUE,globs::mainGlobs.flags & CMD_DEBUG,globs::mainGlobs.flags & CMD_BEST
													 ,globs::mainGlobs.flags & CMD_WINDOW,errorMessage), BVar5 != 0)) {
			video::Animation_Initialise(globs::directDrawGlobs.lpDirectDraw);
			draw::Draw_Initialise(NULL);
			main::LRR_Go(globs::mainGlobs.programName);
			if (globs::mainGlobs.stateSet != 0) {
				if ((globs::mainGlobs.currState.Initialise != NULL) &&
					 (BVar5 = (*globs::mainGlobs.currState.Initialise)(), BVar5 == 0)) {
					globs::mainGlobs.currState.Initialise = NULL;
					globs::mainGlobs.currState.MainLoop = NULL;
					globs::mainGlobs.currState.Shutdown = NULL;
				}
				if (globs::mainGlobs.currState.MainLoop != NULL) {
					fpsSync = 1.0;
					DVar2 = timeGetTime();
					while (globs::mainGlobs.exit == 0) {
						globs::INPUT.lClicked = 0;
						globs::INPUT.rClicked = 0;
						globs::INPUT.lDoubleClicked = 0;
						globs::INPUT.rDoubleClicked = 0;
						main::Main_HandleIO();
						if ((globs::mainGlobs.flags & CMD_FULLSCREEN) != CMD_NONE) {
							globs::mainGlobs.active = TRUE;
						}
						input::Input_ReadKeys();
						input::Input_ReadMouse2();
						BVar5 = (*globs::mainGlobs.currState.MainLoop)(fpsSync);
						if (BVar5 == 0) {
							globs::mainGlobs.exit = TRUE;
						}
						main::Main_Finalise3D();
						ddraw::DirectDraw_Flip();
						CVar6 = globs::mainGlobs.flags & ~CMD_D3DRMUPDATED;
						if ((globs::mainGlobs.flags & CMD_FPSLOCK30) == CMD_NONE) {
							if ((globs::mainGlobs.flags & CMD_NOFPSLOCK) == CMD_NONE) {
								if (globs::mainGlobs.fixedFrameTiming != 0.0) {
									fpsSync = globs::mainGlobs.fixedFrameTiming;
									goto LAB_00477e2a;
								}
								globs::mainGlobs.flags = CVar6;
								DVar7 = timeGetTime();
								uStack3204 = 0;
								local_c88 = DVar7 - DVar2;
								fpsSync = (float)(ulonglong)local_c88 * 0.025;
								DVar2 = DVar7;
								if ((ushort)((ushort)(fpsSync < 3.0) << 8 | (ushort)(fpsSync == 3.0) << 0xe) == 0) {
									fpsSync = 3.0;
								}
							}
							else {
								fpsSync = 0.0;
LAB_00477e2a:
								globs::mainGlobs.flags = CVar6;
								DVar2 = timeGetTime();
							}
						}
						else {
							fpsSync = 0.8333333;
							globs::mainGlobs.flags = CVar6;
						}
					}
				}
				if (globs::mainGlobs.currState.Shutdown != NULL) {
					(*globs::mainGlobs.currState.Shutdown)();
				}
			}
		}
		ddraw::DirectDraw_Shutdown();
		DestroyWindow(globs::mainGlobs.hWnd);
	}
	input::Input_ReleaseKeysAndDI();
	cfg::Config_Shutdown();
	util::logf_removed(NULL);
	debug::Error_CloseLog();
	debug::Error_Shutdown();
	return 0;
}



// Sets the "-nm" commandline option only if the "-ftm" option is not set.
//  (The "-ftm" option is intended to be set when running on Voodoo2-based graphics cards, as is
// shown by CLGen.exe)
// This is called when Lego.cfg/Lego*::Main::TextureUsage (units in pixels) is valid and <=
// available video memory.

void __cdecl lego::main::Main_DisableTextureManagement(void)
{
	if ((globs::mainGlobs.flags & CMD_FTM) == CMD_NONE) {
		globs::mainGlobs.flags |= CMD_NM;
	}
	return;
}



void __cdecl
lego::main::Main_ParseCommandLine(char *lpszCmdLine,BOOL *out_nosound,BOOL *out_insistOnCD)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	int iVar5;
	
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-insistOnCD");
	if (pcVar3 != NULL) {
		*out_insistOnCD = 1;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-nosound");
	if (pcVar3 != NULL) {
		*out_nosound = 1;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-debug");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_DEBUG;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-nm");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_NM;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-ftm");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_FTM;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-fvf");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_FVF;
	}
										// "best fit" for screen mode selection
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-best");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_BEST;
	}
										// Only used when "-best" is specified
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-window");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_WINDOW;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-dualmouse");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_DUALMOUSE;
	}
										// Automatically triggers "-debug" command line option as well
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-debugcomplete");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_DEBUGCOMPLETE;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-testercall");
	if (pcVar3 != NULL) {
		globs::mainGlobs.programmerLevel = PROGRAMMER_MODE_2;
		globs::mainGlobs.flags |= CMD_TESTERCALL;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-testlevels");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_TESTLEVELS;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-reducesamples");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_REDUCESAMPLES;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-showversion");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_SHOWVERSION;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-reduceanimation");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_REDUCEANIMATION;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-reducepromeshes");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_REDUCEPROMESHES;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-reduceflics");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_REDUCEFLICS;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-reduceimages");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_REDUCEIMAGES;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-startlevel");
	if (pcVar3 != NULL) {
		pcVar3 = pcVar3 + 0xb;
		iVar5 = 0;
		cVar2 = *pcVar3;
		while ((cVar2 != '\0' && (cVar2 == ' '))) {
			pcVar1 = pcVar3 + 1;
			pcVar3 = pcVar3 + 1;
			cVar2 = *pcVar1;
		}
		cVar2 = *pcVar3;
		while ((cVar2 != '\0' && (cVar2 != ' '))) {
			globs::mainGlobs.startLevel[iVar5] = cVar2;
			pcVar1 = pcVar3 + 1;
			iVar5 += 1;
			pcVar3 = pcVar3 + 1;
			cVar2 = *pcVar1;
		}
		globs::mainGlobs.startLevel[iVar5] = '\0';
		globs::mainGlobs.flags |= CMD_STARTLEVEL;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-flags");
	if (pcVar3 != NULL) {
		globs::mainGlobs.clFlags = std::atoi(pcVar3 + 6);
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-fpslock");
	if ((pcVar3 != NULL) && (uVar4 = std::atoi(pcVar3 + 8), uVar4 != 0)) {
		globs::mainGlobs.fixedFrameTiming = 25.0 / (float)(ulonglong)uVar4;
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-programmer");
	if (pcVar3 == NULL) {
		globs::mainGlobs.programmerLevel = PROGRAMMER_OFF;
	}
	else {
		globs::mainGlobs.programmerLevel = std::atoi(pcVar3 + 0xb);
		if (globs::mainGlobs.programmerLevel == PROGRAMMER_OFF) {
			globs::mainGlobs.programmerLevel = PROGRAMMER_MODE_1;
		}
	}
	pcVar3 = util::Util_StrIStr(lpszCmdLine,"-cleansaves");
	if (pcVar3 != NULL) {
		globs::mainGlobs.flags |= CMD_CLEANSAVES;
	}
	return;
}



void __cdecl lego::main::Main_LoopUpdate(BOOL clear)
{
	Main_HandleIO();
	input::Input_ReadKeys();
	input::Input_ReadMouse2();
	Main_Finalise3D();
	ddraw::DirectDraw_Flip();
	if (clear != 0) {
		ddraw::DirectDraw_Clear(NULL,0);
	}
	globs::mainGlobs.flags = globs::mainGlobs.flags & ~CMD_D3DRMUPDATED;
	return;
}



FeatureFlags __cdecl lego::main::Main_GetCLFlags(void)
{
	return globs::mainGlobs.clFlags;
}



int __cdecl lego::main::Main_GetWindowsBitDepth(void)
{
	HDC hdc;
	int iVar1;
	
	iVar1 = BITSPIXEL;
	hdc = GetDC(globs::mainGlobs.hWnd);
	iVar1 = GetDeviceCaps(hdc,iVar1);
	return iVar1;
}



void __cdecl lego::main::Main_Finalise3D(void)
{
	if ((globs::mainGlobs.flags & CMD_D3DRMUPDATED) == CMD_NONE) {
		(*(code *)(globs::mainGlobs.device)->lpVtbl->Update)(globs::mainGlobs.device);
		globs::mainGlobs.flags |= CMD_D3DRMUPDATED;
	}
	return;
}



BOOL __cdecl lego::main::Main_SetState(Main_State *state)
{
	if (state != NULL) {
		globs::mainGlobs.currState.Initialise = state->Initialise;
		globs::mainGlobs.currState.MainLoop = state->MainLoop;
		globs::mainGlobs.currState.Shutdown = state->Shutdown;
		globs::mainGlobs.stateSet = TRUE;
		return TRUE;
	}
	return 0;
}



uint __cdecl lego::main::Main_GetTime(void)
{
	DWORD DVar1;
	
										// WARNING: Could not recover jumptable at 0x004782c0. Too many branches
										// WARNING: Treating indirect jump as call
	DVar1 = timeGetTime();
	return DVar1;
}



BOOL __cdecl lego::main::Main_DispatchMessage(MSG *msg)
{
	UINT UVar1;
	
	if ((((byte)globs::mainGlobs.flags & CMD_FULLSCREEN) != 0) &&
		 (((UVar1 = msg->message, UVar1 == WM_ACTIVATEAPP || (UVar1 == WM_SYSKEYDOWN)) ||
			(UVar1 == WM_SYSKEYUP)))) {
		return 0;
	}
	return 1;
}



void __cdecl lego::main::Main_HandleIO(void)
{
	int iVar1;
	BOOL BVar2;
	MSG msg;
	
	iVar1 = PeekMessageA((LPMSG)&msg,NULL,0,0,1);
	while (iVar1 != 0) {
		BVar2 = Main_DispatchMessage(&msg);
		if (BVar2 != 0) {
			TranslateMessage(&msg);
			DispatchMessageA(&msg);
		}
		iVar1 = PeekMessageA((LPMSG)&msg,NULL,0,0,1);
	}
	return;
}



void __cdecl
lego::main::Main_SetupDisplay(BOOL fullScreen,uint xPos,uint yPos,uint width,uint height)
{
	HWND hWnd;
	RECT rect;
	
	globs::mainGlobs.appWidth = width;
	globs::mainGlobs.appHeight = height;
	if (fullScreen != 0) {
		globs::mainGlobs.flags |= CMD_FULLSCREEN;
	}
	debug::Error_FullScreen(fullScreen);
	if (fullScreen == 0) {
		rect.left = xPos;
		rect.right = width + xPos;
		rect.bottom = height + yPos;
										// WS_POPUPWINDOW | WS_CAPTION (0x80880000 | 0xc00000)
										// WS_POPUP | WS_BORDER | WS_DLGFRAME | WS_SYSMENU (0x80000000 | 0x800000 |
										// 0x400000 | 0x80000)
		globs::mainGlobs.style = 0x80c80000;
		rect.top = yPos;
		Main_AdjustWindowRect((LPRECT)&rect);
		SetWindowLongA(globs::mainGlobs.hWnd,-0x10,globs::mainGlobs.style);
										// HWND_TOP (0x0) and SWP_NOZORDER (0x4)
										// Then hide system cursor since game draws its own
		SetWindowPos(globs::mainGlobs.hWnd,NULL,rect.left,rect.top,rect.right - rect.left,
								 rect.bottom - rect.top,SWP_NOZORDER);
		ShowCursor(0);
	}
	else {
		hWnd = GetDesktopWindow();
		GetWindowRect(hWnd,(LPRECT)&rect);
										// HWND_TOP (0x0) and SWP_NOZORDER (0x4)
										// Then hide system cursor since game draws its own
		SetWindowPos(globs::mainGlobs.hWnd,NULL,rect.left,rect.top,rect.right - rect.left,
								 rect.bottom - rect.top,SWP_NOZORDER);
		SetCursor(NULL);
	}
	ShowWindow(globs::mainGlobs.hWnd,SW_SHOW);
	SetActiveWindow(globs::mainGlobs.hWnd);
	return;
}



BOOL __cdecl
lego::main::Main_SetupDirect3D
					(DirectDraw_Device *dev,IDirectDraw *ddraw1,IDirectDrawSurface4 *backSurf,
					BOOL doubleBuffered)
{
	HRESULT HVar1;
	DirectDraw_Device *err;
	DirectDraw_Device *pDVar2;
	code ***ppvObj;
	DirectDraw_Device **ppDVar3;
	IUnknown *local_8;
	code **local_4;
	
	pDVar2 = NULL;
	if ((dev != NULL) &&
		 (pDVar2 = dev,
		 (dev->flags & DIRECTDRAW_FLAG_DEVICE_VIDEOTEXTURE) != DIRECTDRAW_FLAG_DEVICE_NONE)) {
		globs::mainGlobs.flags |= CMD_TEXTUREVIDEOMEMORY;
	}
										// Direct3DRMFrame3::SetSceneFogMethod
										// D3DRMFOGMETHOD_VERTEX = 0x1
										// D3DRMFOGMETHOD_TABLE  = 0x2
										// D3DRMFOGMETHOD_ANY    = 0x4
	if (((globs::mainGlobs.flags & CMD_FVF) != CMD_NONE) ||
		 (globs::mainGlobs.fogMethod = D3DRMFOGMETHOD_TABLE,
		 (dev->flags & DIRECTDRAW_FLAG_DEVICE_HARDWARE) == DIRECTDRAW_FLAG_DEVICE_NONE)) {
		globs::mainGlobs.fogMethod = D3DRMFOGMETHOD_VERTEX;
	}
	HVar1 = Direct3DRMCreate(&local_8);
	err = dev;
	if ((HVar1 == 0) &&
		 (HVar1 = (*local_8->lpVtbl->QueryInterface)
												(local_8,(IID *)&idl::IID_IDirect3DRM3,(void **)0x506914), err = dev,
		 HVar1 == 0)) {
		ppvObj = &local_4;
		(*backSurf->lpVtbl->QueryInterface)
							((IUnknown *)backSurf,(IID *)&idl::IID_IDirectDrawSurface,ppvObj);
		err = (DirectDraw_Device *)
					(*(code *)(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateDeviceFromSurface)
										(globs::mainGlobs.lpD3DRM,pDVar2,local_4,ppvObj,0,0x506918);
		if (err == NULL) {
			ppDVar3 = &dev;
			(*(code *)(globs::mainGlobs.device)->lpVtbl->GetDirect3DDevice2)(globs::mainGlobs.device);
			(**(code **)*local_4)(local_4,&idl::IID_IDirect3DDevice3,0x50691c);
			(**(code **)((*ppDVar3)->guid).Data4)(ppDVar3);
			if (local_8 != NULL) {
				(*(code *)(globs::mainGlobs.device)->lpVtbl->SetBufferCount)(globs::mainGlobs.device,2);
			}
			return TRUE;
		}
		debug::Error_SetDXError
							((HRESULT)err,3,"C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Main.c",568);
	}
	if (err != NULL) {
		debug::Error_SetDXError
							((HRESULT)err,1,"C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Main.c",576);
	}
	return 0;
}



void __cdecl lego::main::Main_AdjustWindowRect(LPRECT lpRect)
{
										// Adjust rectangle to client coordinates only in windowed mode
	if (((byte)globs::mainGlobs.flags & CMD_FULLSCREEN) == 0) {
		AdjustWindowRect(lpRect,globs::mainGlobs.style,0);
	}
	return;
}



void __cdecl
lego::main::Main_Setup3D
					(GraphicsQuality renderQuality,BOOL dither,BOOL linearFilter,BOOL mipMap,BOOL mipMapLinear
					,BOOL blendTransparency,BOOL sortTransparency)
{
	char cVar1;
	DWORD quality;
	
										// D3DRMRENDER_WIREFRAME 0x40
										// (D3DRMSHADE_FLAT|D3DRMLIGHT_OFF|D3DRMFILL_WIREFRAME)
	quality = 0x40;
	if (renderQuality == QUALITY_FLAT) {
										// D3DRMRENDER_FLAT 0x88 (D3DRMSHADE_FLAT|D3DRMLIGHT_ON|D3DRMFILL_SOLID)
		quality = 0x88;
	}
	if (renderQuality == QUALITY_UNLITFLAT) {
										// D3DRMRENDER_UNLITFLAT 0x80 (D3DRMSHADE_FLAT|D3DRMLIGHT_OFF|D3DRMFILL_SOLID)
		quality = 0x80;
	}
	if (renderQuality == QUALITY_GOURAUD) {
										// D3DRMRENDER_GOURAUD 0x89 (D3DRMSHADE_GOURAUD|D3DRMLIGHT_ON|D3DRMFILL_SOLID)
		quality = 0x89;
	}
	if (linearFilter == 0) {
										// D3DRMTEXTURE_NEAREST 0
		cVar1 = '\0';
	}
	else {
		if (mipMap == 0) {
										// D3DRMTEXTURE_LINEAR 1
			cVar1 = '\x01';
		}
		else {
										// D3DRMTEXTURE_MIPLINEAR 3 (!linearmipmap), D3DRMTEXTURE_LINEARMIPLINEAR 5
			cVar1 = (-(mipMapLinear != 0) & 2U) + 3;
			globs::mainGlobs.flags |= CMD_MIPMAP;
		}
	}
	if (globs::mainGlobs.device != NULL) {
										// IDirect3DRMDevice3::SetDither(THIS_ BOOL)
		(*(globs::mainGlobs.device)->lpVtbl->SetDither)(globs::mainGlobs.device,dither);
										// IDirect3DRMDevice3::SetQuality(THIS_ D3DRMRENDERQUALITY)
		(*(globs::mainGlobs.device)->lpVtbl->SetQuality)(globs::mainGlobs.device,quality);
										// IDirect3DRMDevice3::SetTextureQuality(THIS_ D3DRMTEXTUREQUALITY)
		(*(globs::mainGlobs.device)->lpVtbl->SetTextureQuality)(globs::mainGlobs.device,(DWORD)cVar1);
	}
	return;
}



void __cdecl lego::main::Main_SetTitle(char *title)
{
	SetWindowTextA(globs::mainGlobs.hWnd,title);
	return;
}



BOOL __cdecl lego::main::Main_InitApp(HINSTANCE hInstance)
{
	ATOM AVar1;
	WNDCLASSA wndClass;
	
	wndClass.style = CS_DBLCLKS;
	wndClass.lpfnWndProc = Main_WndProc;
	wndClass.cbClsExtra = 0;
	wndClass.cbWndExtra = 0;
	wndClass.hInstance = hInstance;
	wndClass.hIcon = NULL;
	wndClass.hCursor = NULL;
	wndClass.hbrBackground = NULL;
	wndClass.lpszMenuName = NULL;
	wndClass.lpszClassName = globs::mainGlobs.className;
	AVar1 = RegisterClassA(&wndClass);
	if (AVar1 == 0) {
		MessageBoxA(NULL,"Unable to register window class","Fatal Error",0);
		return 0;
	}
										// WS_POPUP | WS_SYSMENU
	globs::mainGlobs.hWnd =
			 CreateWindowExA(WS_EX_APPWINDOW,globs::mainGlobs.className,____EMPTYSTR__,0x80080000,0,0,100,
											 100,NULL,NULL,hInstance,NULL);
	if (globs::mainGlobs.hWnd != NULL) {
		SetFocus(globs::mainGlobs.hWnd);
		return TRUE;
	}
	MessageBoxA(NULL,"Unable to Create Main Window","Fatal Error",0);
	return 0;
}



LRESULT __cdecl
lego::main::Main_WndProc_Fullscreen(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	LRESULT LVar1;
	
	if (message < 0x11) {
		if (message != 0x10) {
			if (true) {
				switch(message) {
				default:
					break;
				case 2:
					goto switchD_00478794_caseD_2;
				case 3:
				case 5:
				case 6:
					goto switchD_00478830_caseD_200;
				}
			}
			goto switchD_00478830_caseD_207;
		}
	}
	else {
		if (WM_ACTIVATEAPP < message) {
			if (message < WM_NCACTIVATE + 1) {
				if (message == WM_NCACTIVATE) {
switchD_00478830_caseD_200:
					return 0;
				}
				if (message == WM_WINDOWPOSCHANGING) {
					*(uint *)(lParam + 0x18) = *(uint *)(lParam + 0x18) & 0xfffffdff;
					return 0;
				}
			}
			else {
				if (message < WM_SYSKEYDOWN + 1) {
					if (message == WM_SYSKEYDOWN) {
						return 0;
					}
					if ((0xff < message) && (message < 0x102)) {
						return 0;
					}
				}
				else {
					if (true) {
						switch(message) {
						case 0x200:
						case 0x211:
						case 0x212:
							goto switchD_00478830_caseD_200;
						case 0x201:
						case 0x202:
						case 0x204:
						case 0x205:
							if ((globs::mainGlobs.flags & CMD_DUALMOUSE) == CMD_NONE) {
								if (true) {
									switch(message) {
									case 0x201:
									case 0x204:
										if (globs::INPUT.mslb == 0) {
											globs::INPUT.lClicked = 1;
											globs::INPUT.rClicked = 1;
										}
										globs::INPUT.mslb = 1;
										globs::INPUT.msrb = 1;
										globs::INPUT.lDoubleClicked = 1;
										return 0;
									case 0x202:
									case 0x205:
										globs::INPUT.lClicked = 0;
										globs::INPUT.rClicked = 0;
										globs::INPUT.msrb = 0;
										globs::INPUT.mslb = 0;
									}
								}
							}
							else {
								if (true) {
									switch(message) {
									case 0x201:
										globs::INPUT.mslb = 1;
										globs::INPUT.lClicked = 1;
										return 0;
									case 0x202:
										globs::INPUT.mslb = 0;
										globs::INPUT.lClicked = 0;
										return 0;
									case 0x204:
										globs::INPUT.msrb = 1;
										globs::INPUT.rClicked = 1;
										return 0;
									case 0x205:
										globs::INPUT.msrb = 0;
										globs::INPUT.rClicked = 0;
										return 0;
									}
								}
							}
						case 0x203:
							globs::INPUT.lDoubleClicked = 1;
							return 0;
						case 0x206:
							globs::INPUT.rDoubleClicked = 1;
							return 0;
						}
					}
				}
			}
			goto switchD_00478830_caseD_207;
		}
		if (message == WM_ACTIVATEAPP) {
										// True if this window is being activated
			globs::mainGlobs.active = wParam;
			return 0;
		}
		if (message != WM_QUIT) goto switchD_00478830_caseD_207;
	}
switchD_00478794_caseD_2:
	globs::mainGlobs.exit = 1;
switchD_00478830_caseD_207:
	LVar1 = DefWindowProcA(hWnd,message,wParam,lParam);
	return LVar1;
}



LRESULT __cdecl
lego::main::Main_WndProc_Windowed(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	int iVar1;
	LRESULT LVar2;
	UINT UVar3;
	
	if (message < WM_ACTIVATE + 1) {
		UVar3 = message;
		if (message == WM_ACTIVATE) {
			return 0;
		}
	}
	else {
		if (WM_ACTIVATEAPP < message) {
										// Handle mouse button input (0x201 is WM_LBUTTONDOWN)
			iVar1 = message - 0x201;
			switch(iVar1) {
			case 0:
			case 1:
			case 3:
			case 4:
										// WM_LBUTTONDOWN (0x201) or WM_LBUTTONUP (0x202) or  WM_RBUTTONDOWN (0x204) or
										// WM_RBUTTONUP (0x205)
				if ((globs::mainGlobs.flags & CMD_DUALMOUSE) == CMD_NONE) {
					if (true) {
						switch(iVar1) {
						case 0:
						case 3:
										// WM_LBUTTONDOWN (0x201) or WM_RBUTTONDOWN (0x204)
							SetCapture(hWnd);
							if (globs::INPUT.mslb == 0) {
								globs::INPUT.lClicked = 1;
								globs::INPUT.rClicked = 1;
							}
							globs::INPUT.mslb = 1;
							globs::INPUT.msrb = 1;
							globs::INPUT.lDoubleClicked = 1;
							return 0;
						case 1:
						case 4:
										// WM_LBUTTONUP (0x202) or WM_RBUTTONUP (0x205)
							ReleaseCapture();
							globs::INPUT.lClicked = 0;
							globs::INPUT.rClicked = 0;
							globs::INPUT.msrb = 0;
							globs::INPUT.mslb = 0;
						}
					}
				}
				else {
					if (true) {
						switch(iVar1) {
						case 0:
										// WM_LBUTTONDOWN (0x201)
							SetCapture(hWnd);
							globs::INPUT.mslb = 1;
							globs::INPUT.lClicked = 1;
							globs::INPUT.lDoubleClicked = 1;
							return 0;
						case 1:
										// WM_LBUTTONUP (0x202)
							ReleaseCapture();
							globs::INPUT.mslb = 0;
							globs::INPUT.lClicked = 0;
							globs::INPUT.lDoubleClicked = 1;
							return 0;
						case 3:
							globs::INPUT.msrb = 1;
							globs::INPUT.rClicked = 1;
							globs::INPUT.lDoubleClicked = 1;
							return 0;
						case 4:
										// WM_RBUTTONUP (0x205)
							globs::INPUT.msrb = 0;
							globs::INPUT.rClicked = 0;
							globs::INPUT.lDoubleClicked = 1;
							return 0;
						}
					}
				}
			case 2:
										// WM_LBUTTONDBLCLK (0x203)
				globs::INPUT.lDoubleClicked = 1;
										// WM_RBUTTONDBLCLK (0x206)
				return 0;
			case 5:
				globs::INPUT.rDoubleClicked = 1;
				return 0;
			}
			goto switchD_004789e8_caseD_6;
		}
		if (message == WM_ACTIVATEAPP) {
										// True if this window is being activated
			globs::mainGlobs.active = wParam;
			return 0;
		}
										// WM_CLOSE (0x10)  -0x10, is closing
		UVar3 = message - 0x10;
		if (message - 0x10 == 0) {
			globs::mainGlobs.exit = 1;
			return 0;
		}
	}
										// WM_QUIT (0x12)
	if (UVar3 == WM_DESTROY) {
		globs::mainGlobs.exit = 1;
		return 0;
	}
switchD_004789e8_caseD_6:
	LVar2 = DefWindowProcA(hWnd,message,wParam,lParam);
	return LVar2;
}



LRESULT lego::main::Main_WndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	LRESULT LVar1;
	
	if (((byte)globs::mainGlobs.flags & CMD_FULLSCREEN) != 0) {
		LVar1 = Main_WndProc_Fullscreen(hWnd,message,wParam,lParam);
		return LVar1;
	}
	LVar1 = Main_WndProc_Windowed(hWnd,message,wParam,lParam);
	return LVar1;
}



void __cdecl
lego::main::Main_ChangeRenderState
					(D3DRenderStateType dwRenderStateType,D3DRenderStateType dwRenderState)
{
	D3DRenderStateType DVar1;
	
	DVar1 = dwRenderStateType;
										// IDirect3DDevice3->GetRenderState(this, D3DRenderStateType dwRenderStateType,
										// DWORD* lpdwRenderState)
	(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetRenderState)
						(globs::mainGlobs.imDevice,dwRenderStateType,&dwRenderStateType);
	if (dwRenderStateType != dwRenderState) {
										// IDirect3DDevice3->SetRenderState(this, D3DRenderStateType dwRenderStateType,
										// DWORD dwRenderState)
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetRenderState)
							(globs::mainGlobs.imDevice,DVar1,dwRenderState);
		if (globs::mainGlobs.renderStateData[DVar1].changed == 0) {
			globs::mainGlobs.renderStateData[DVar1].changed = 1;
			globs::mainGlobs.renderStateData[DVar1].origValue = dwRenderStateType;
		}
		else {
			if (globs::mainGlobs.renderStateData[DVar1].origValue == dwRenderStateType) {
				globs::mainGlobs.renderStateData[DVar1].changed = 0;
				return;
			}
		}
	}
	return;
}



void __cdecl lego::main::Main_RestoreStates(void)
{
	CmdlineFlags *pCVar1;
	D3DRenderStateType DVar2;
	
	DVar2 = 0;
	pCVar1 = (CmdlineFlags *)&globs::mainGlobs.renderStateData[0].changed;
	do {
		if (*pCVar1 != CMD_NONE) {
										// IDirect3DDevice3->SetRenderState(this, D3DRenderStateType dwRenderStateType,
										// DWORD dwRenderState)
			(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetRenderState)
								(globs::mainGlobs.imDevice,DVar2,pCVar1[-1]);
			*pCVar1 = CMD_NONE;
		}
		pCVar1 = pCVar1 + 2;
		DVar2 += D3DRENDERSTATE_TEXTUREHANDLE;
	} while (pCVar1 < &globs::mainGlobs.flags);
	return;
}



BOOL __cdecl lego::main::Main_SetCDVolume(float leftVolume,float rightVolume)
{
	BOOL BVar1;
	
	BVar1 = Main_CDVolume(&leftVolume,&rightVolume,1);
	return BVar1;
}



BOOL __cdecl lego::game::Main_GetCDVolume(float *out_leftVolume,float *out_rightVolume)
{
	BOOL BVar1;
	
	BVar1 = main::Main_CDVolume(out_leftVolume,out_rightVolume,0);
	return BVar1;
}



BOOL __cdecl lego::main::Main_CDVolume(float *ref_leftVolume,float *ref_rightVolume,BOOL set)
{
	UINT UVar1;
	MMRESULT MVar2;
	LPMIXERCONTROLA buffer;
	uint *buffer_00;
	uint uVar3;
	int iVar4;
	uint *puVar5;
	uint uVar6;
	uint uVar7;
	_union_1085 *p_Var8;
	UINT_PTR uMxId;
	tagMIXERCAPSA *ptVar9;
	tagMIXERLINEA *ptVar10;
	tagMIXERLINECONTROLSA *ptVar11;
	tMIXERCONTROLDETAILS *ptVar12;
	float10 extraout_ST0;
	longlong lVar13;
	HMIXEROBJ local_154;
	BOOL local_150;
	uint local_14c;
	uint local_148;
	uint local_144;
	uint local_140;
	UINT local_13c;
	uint local_138;
	LPMIXERCONTROLA local_134;
	uint local_130;
	undefined4 uStack300;
	int local_128;
	undefined4 local_124;
	tMIXERCONTROLDETAILS local_120;
	int local_108;
	undefined4 local_104;
	uint local_100;
	undefined4 uStack252;
	uint local_f8;
	undefined4 uStack244;
	tagMIXERLINECONTROLSA local_f0;
	tagMIXERLINEA local_d8;
	tagMIXERCAPSA local_30;
	
	UVar1 = mixerGetNumDevs();
	local_150 = 0;
	if (set != 0) {
		if ((ushort)((ushort)(*ref_leftVolume < 1.0) << 8 | (ushort)(*ref_leftVolume == 1.0) << 0xe) ==
				0) {
			*ref_leftVolume = 1.0;
		}
		if (*ref_leftVolume < 0.0) {
			*ref_leftVolume = 0.0;
		}
		if ((ushort)((ushort)(*ref_rightVolume < 1.0) << 8 | (ushort)(*ref_rightVolume == 1.0) << 0xe)
				== 0) {
			*ref_rightVolume = 1.0;
		}
		if (*ref_rightVolume < 0.0) {
			*ref_rightVolume = 0.0;
		}
	}
	local_140 = 0;
	local_13c = UVar1;
	if (UVar1 != 0) {
		do {
			uMxId = local_140;
			MVar2 = mixerOpen((LPHMIXER)&local_154,local_140,0,0,0);
			if (MVar2 == 0) {
				ptVar9 = &local_30;
				for (iVar4 = 0xc; iVar4 != 0; iVar4 += -1) {
					*(undefined4 *)ptVar9 = 0;
					ptVar9 = (tagMIXERCAPSA *)&ptVar9->vDriverVersion;
				}
				mixerGetDevCapsA(uMxId,(LPMIXERCAPSA)&local_30,0x30);
				local_148 = 0;
				if (local_30.cDestinations != 0) {
					do {
						uVar3 = local_148;
						ptVar10 = &local_d8;
						for (iVar4 = 0x2a; iVar4 != 0; iVar4 += -1) {
							ptVar10->cbStruct = 0;
							ptVar10 = (tagMIXERLINEA *)&ptVar10->dwDestination;
						}
						local_d8.cbStruct = 0xa8;
						local_d8.dwDestination = local_148;
						MVar2 = mixerGetLineInfoA(local_154,(LPMIXERLINEA)&local_d8,0);
						if (MVar2 == 0) {
							local_138 = local_d8.cConnections;
							local_144 = 0;
							uMxId = local_140;
							if (local_d8.cConnections != 0) {
								do {
									uVar7 = local_144;
									local_d8.cbStruct = 0xa8;
									local_d8.dwDestination = uVar3;
									local_d8.dwSource = local_144;
									MVar2 = mixerGetLineInfoA(local_154,(LPMIXERLINEA)&local_d8,1);
									if ((MVar2 == 0) && (local_d8.dwComponentType == 0x1005)) {
										ptVar11 = &local_f0;
										for (iVar4 = 6; iVar4 != 0; iVar4 += -1) {
											ptVar11->cbStruct = 0;
											ptVar11 = (tagMIXERLINECONTROLSA *)&ptVar11->dwLineID;
										}
										local_f0.cbStruct = 0x18;
										local_f0.dwLineID = local_d8.dwLineID;
										local_f0.cControls = local_d8.cControls;
										local_f0.cbmxctrl = 0x94;
										buffer = (LPMIXERCONTROLA)std::malloc(local_d8.cControls * 0x94);
										local_134 = buffer;
										local_f0.pamxctrl = buffer;
										MVar2 = mixerGetLineControlsA(local_154,(LPMIXERLINECONTROLSA)&local_f0,0);
										if ((MVar2 == 0) && (local_14c = 0, local_d8.cControls != 0)) {
											p_Var8 = &buffer->Bounds;
											do {
												if (((*(uint *)&p_Var8[-4].field_0x4 & 0x50000000) != 0) &&
													 ((*(uint *)&p_Var8[-4].field_0x4 & 0x50030001) != 0)) {
													local_120.dwControlID = *(DWORD *)(p_Var8 + -4);
													ptVar12 = &local_120;
													for (iVar4 = 6; iVar4 != 0; iVar4 += -1) {
														ptVar12->cbStruct = 0;
														ptVar12 = (tMIXERCONTROLDETAILS *)&ptVar12->dwControlID;
													}
													local_120.cbStruct = 0x18;
													local_120.cChannels = local_d8.cChannels;
													local_120.cbDetails = 4;
													local_120.u = 0;
													buffer_00 = (uint *)std::malloc(local_d8.cChannels << 2);
													local_120.paDetails = buffer_00;
													if (set == 0) {
														MVar2 = mixerGetControlDetailsA
																							(local_154,(LPMIXERCONTROLDETAILS)&local_120,0);
														if (MVar2 == 0) {
															local_100 = *buffer_00 - *(int *)p_Var8;
															uStack252 = 0;
															local_108 = *(int *)&p_Var8->field_0x4 - *(int *)p_Var8;
															local_104 = 0;
															*ref_leftVolume = (float)(ulonglong)local_100 / (float)local_108;
															if (local_d8.cChannels == 2) {
																local_130 = buffer_00[1] - *(int *)p_Var8;
																uStack300 = 0;
																local_128 = *(int *)&p_Var8->field_0x4 - *(int *)p_Var8;
																local_124 = 0;
																local_150 = 1;
																*ref_rightVolume = (float)(ulonglong)local_130 / (float)local_128;
															}
															else {
																local_150 = 1;
																*ref_rightVolume = (float)(ulonglong)local_100 / (float)local_108;
															}
														}
													}
													else {
														iVar4 = *(int *)p_Var8;
														local_f8 = *(int *)&p_Var8->field_0x4 - iVar4;
														uStack244 = 0;
														lVar13 = __ftol((float10)*ref_leftVolume * (float10)(ulonglong)local_f8)
														;
														uVar7 = (int)lVar13 + iVar4;
														lVar13 = __ftol((float10)*ref_rightVolume * extraout_ST0);
														uVar3 = (int)lVar13 + iVar4;
														if (local_d8.cChannels == 2) {
															*buffer_00 = uVar7;
															buffer_00[1] = uVar3;
														}
														else {
															uVar6 = 0;
															if (local_d8.cChannels != 0) {
																puVar5 = buffer_00;
																do {
																	*puVar5 = uVar3 + uVar7 >> 1;
																	uVar6 += 1;
																	puVar5 = puVar5 + 1;
																} while (uVar6 < local_d8.cChannels);
															}
														}
														MVar2 = mixerSetControlDetails
																							(local_154,(LPMIXERCONTROLDETAILS)&local_120,0);
														if (MVar2 == 0) {
															local_150 = 1;
														}
													}
													std::free(buffer_00);
													buffer = local_134;
												}
												local_14c += 1;
												p_Var8 = (_union_1085 *)&p_Var8[6].field_0x4;
												uVar3 = local_148;
												uVar7 = local_144;
											} while (local_14c < local_d8.cControls);
										}
										std::free(buffer);
									}
									local_144 = uVar7 + 1;
									uMxId = local_140;
								} while (local_144 < local_138);
							}
						}
						local_148 = uVar3 + 1;
					} while (local_148 < local_30.cDestinations);
				}
				mixerClose((HMIXER)local_154);
				UVar1 = local_13c;
			}
			local_140 = uMxId + 1;
		} while (local_140 < UVar1);
	}
	return local_150;
}



void __cdecl lego::cfg::Config_Initialise(void)
{
	int iVar1;
	CFGProperty **ppCVar2;
	
	ppCVar2 = globs::configGlobs.listSet;
	for (iVar1 = 0x20; iVar1 != 0; iVar1 += -1) {
		*ppCVar2 = NULL;
		ppCVar2 = ppCVar2 + 1;
	}
	globs::configGlobs.freeList = NULL;
	globs::configGlobs.listCount = 0;
	globs::configGlobs.flags = 1;
	return;
}



void __cdecl lego::cfg::Config_Shutdown(void)
{
	CFGProperty **ppCVar1;
	
	ppCVar1 = globs::configGlobs.listSet;
	do {
		if (*ppCVar1 != NULL) {
			std::free(*ppCVar1);
		}
		ppCVar1 = ppCVar1 + 1;
	} while (ppCVar1 < &globs::configGlobs.freeList);
	globs::configGlobs.freeList = NULL;
	globs::configGlobs.flags = 0;
	return;
}



CFGProperty * __cdecl lego::cfg::CFG_Open(char *filename)
{
	char cVar1;
	CFGProperty *current;
	uint uVar2;
	char *pcVar3;
	CFGProperty *root;
	char *text;
	char *pcVar4;
	char *pcVar5;
	bool isComment;
	char c;
	
	root = NULL;
	isComment = false;
	text = (char *)lego::file::File_LoadBinary(filename,(uint *)&filename);
	if ((byte *)text != NULL) {
		root = Config_Create(NULL);
		pcVar4 = NULL;
		root->fileData = text;
		if (filename != NULL) {
			do {
				c = *text;
				if (c == ';') {
					isComment = true;
				}
				else {
					if (c == '\n') {
						isComment = false;
					}
				}
				if ((((isComment) || (c == '\t')) || (c == '\n')) || ((c == '\r' || (c == ' ')))) {
					*text = 0;
				}
				text = (char *)((byte *)text + 1);
				pcVar4 = pcVar4 + 1;
			} while (pcVar4 < filename);
		}
		pcVar4 = root->fileData;
		pcVar5 = NULL;
		current = root;
		pcVar3 = filename;
		if (filename != NULL) {
			do {
				if (*pcVar4 == '\0') {
					pcVar4 = pcVar4 + 1;
				}
				else {
					if ((*pcVar4 == '}') && (pcVar4[1] == '\0')) {
						uVar2 = current->depth - 1;
LAB_004791e1:
						current->depth = uVar2;
					}
					else {
						if (current->key == NULL) {
							current->key = pcVar4;
						}
						else {
							current->value = pcVar4;
							current = Config_Create(current);
							if ((*pcVar4 == '{') && (pcVar4[1] == '\0')) {
								uVar2 = current->depth + 1;
								goto LAB_004791e1;
							}
						}
					}
					while ((pcVar3 = filename, pcVar5 < filename &&
								 (cVar1 = *pcVar4, pcVar4 = pcVar4 + 1, cVar1 != '\0'))) {
						pcVar5 = pcVar5 + 1;
					}
				}
				pcVar5 = pcVar5 + 1;
			} while (pcVar5 < pcVar3);
		}
	}
	return root;
}



// Variadic function to join a path used for all CFGProperty lookup functions
// NULL must be specified as the final argument, to signal the end of path arguments.
// The returned buffer is TEMPORARY, and must be used immediately before the next
// call to this function.

char * __cdecl lego::cfg::CFG_JoinPath(char *keyPath1,...)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	int iVar4;
	char **ppcVar5;
	undefined4 *puVar6;
	char *pcVar7;
	char *pcVar8;
	Config_Globs *pCVar9;
	Config_Globs *pCVar10;
	undefined4 *puVar11;
	char *in_stack_00000008;
	
	uVar2 = 0xffffffff;
	do {
		pcVar8 = keyPath1;
		if (uVar2 == 0) break;
		uVar2 -= 1;
		pcVar8 = keyPath1 + 1;
		cVar1 = *keyPath1;
		keyPath1 = pcVar8;
	} while (cVar1 != '\0');
	uVar2 = ~uVar2;
	ppcVar5 = (char **)&stack0x0000000c;
	puVar6 = (undefined4 *)(pcVar8 + -uVar2);
	pCVar9 = &globs::configGlobs;
	for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
		*(undefined4 *)pCVar9->s_JoinPath_string = *puVar6;
		puVar6 = puVar6 + 1;
		pCVar9 = (Config_Globs *)(pCVar9->s_JoinPath_string + 4);
	}
	for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
		pCVar9->s_JoinPath_string[0] = *(char *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		pCVar9 = (Config_Globs *)(pCVar9->s_JoinPath_string + 1);
	}
	if (in_stack_00000008 != NULL) {
		do {
			uVar2 = 0xffffffff;
			pcVar8 = "::";
			do {
				pcVar7 = pcVar8;
				if (uVar2 == 0) break;
				uVar2 -= 1;
				pcVar7 = pcVar8 + 1;
				cVar1 = *pcVar8;
				pcVar8 = pcVar7;
			} while (cVar1 != '\0');
			uVar2 = ~uVar2;
			iVar4 = -1;
			pCVar9 = &globs::configGlobs;
			do {
				pCVar10 = pCVar9;
				if (iVar4 == 0) break;
				iVar4 += -1;
				pCVar10 = (Config_Globs *)(pCVar9->s_JoinPath_string + 1);
				pcVar8 = pCVar9->s_JoinPath_string;
				pCVar9 = pCVar10;
			} while (*pcVar8 != '\0');
			puVar6 = (undefined4 *)(pcVar7 + -uVar2);
			puVar11 = (undefined4 *)((int)&pCVar10[-1].flags + 3);
			for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
				*puVar11 = *puVar6;
				puVar6 = puVar6 + 1;
				puVar11 = puVar11 + 1;
			}
			for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
				*(undefined *)puVar11 = *(undefined *)puVar6;
				puVar6 = (undefined4 *)((int)puVar6 + 1);
				puVar11 = (undefined4 *)((int)puVar11 + 1);
			}
			uVar2 = 0xffffffff;
			do {
				pcVar8 = in_stack_00000008;
				if (uVar2 == 0) break;
				uVar2 -= 1;
				pcVar8 = in_stack_00000008 + 1;
				cVar1 = *in_stack_00000008;
				in_stack_00000008 = pcVar8;
			} while (cVar1 != '\0');
			uVar2 = ~uVar2;
			iVar4 = -1;
			pCVar9 = &globs::configGlobs;
			do {
				pCVar10 = pCVar9;
				if (iVar4 == 0) break;
				iVar4 += -1;
				pCVar10 = (Config_Globs *)(pCVar9->s_JoinPath_string + 1);
				pcVar7 = pCVar9->s_JoinPath_string;
				pCVar9 = pCVar10;
			} while (*pcVar7 != '\0');
			puVar6 = (undefined4 *)(pcVar8 + -uVar2);
			puVar11 = (undefined4 *)((int)&pCVar10[-1].flags + 3);
			for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
				*puVar11 = *puVar6;
				puVar6 = puVar6 + 1;
				puVar11 = puVar11 + 1;
			}
			in_stack_00000008 = *ppcVar5;
			for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
				*(undefined *)puVar11 = *(undefined *)puVar6;
				puVar6 = (undefined4 *)((int)puVar6 + 1);
				puVar11 = (undefined4 *)((int)puVar11 + 1);
			}
			ppcVar5 = ppcVar5 + 1;
		} while (in_stack_00000008 != NULL);
	}
	return (char *)&globs::configGlobs;
}



CFGProperty * __cdecl lego::cfg::CFG_GetChildren(CFGProperty *prop,char *keyPath)
{
	CFGProperty *getProp;
	
	getProp = CFG_GetProperty(prop,keyPath);
	if ((getProp != NULL) && (getProp->depth < getProp->linkNext->depth)) {
		return getProp->linkNext;
	}
	return NULL;
}



// Returns the next CFGProperty in the same block, and at the same depth
// Returns NULL if there are no more properties, or if prop is NULL

CFGProperty * __cdecl lego::cfg::CFG_NextFlat(CFGProperty *prop)
{
	uint nextDepth;
	uint currentDepth;
	
	currentDepth = prop->depth;
	nextDepth = currentDepth;
	if (prop != NULL) {
		do {
			if (nextDepth < currentDepth) {
				return NULL;
			}
			prop = prop->linkNext;
			if (prop->depth == currentDepth) {
				return prop;
			}
			nextDepth = prop->depth;
		} while (prop != NULL);
	}
	return NULL;
}



char * __cdecl lego::cfg::CFG_CopyString(CFGProperty *prop,char *keyPath)
{
	char cVar1;
	CFGProperty *pCVar2;
	undefined4 *puVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	char *pcVar8;
	undefined4 *puVar9;
	
	pCVar2 = CFG_GetProperty(prop,keyPath);
	if ((pCVar2 == NULL) || (pCVar2->value == NULL)) {
		return (char *)NULL;
	}
	uVar4 = 0xffffffff;
	pcVar7 = pCVar2->value;
	do {
		if (uVar4 == 0) break;
		uVar4 -= 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar7 + 1;
	} while (cVar1 != '\0');
	puVar3 = (undefined4 *)std::malloc(~uVar4);
	uVar4 = 0xffffffff;
	pcVar7 = pCVar2->value;
	do {
		pcVar8 = pcVar7;
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar8 = pcVar7 + 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar8;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar6 = (undefined4 *)(pcVar8 + -uVar4);
	puVar9 = puVar3;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar9 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar9 = puVar9 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar9 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar9 = (undefined4 *)((int)puVar9 + 1);
	}
	return (char *)puVar3;
}



char * __cdecl lego::cfg::CFG_ReadString(CFGProperty *prop,char *keyPath)
{
	CFGProperty *getProp;
	
	getProp = CFG_GetProperty(prop,keyPath);
	if (getProp != NULL) {
		return getProp->value;
	}
	return NULL;
}



BOOL3 __cdecl lego::cfg::CFG_ReadBool(CFGProperty *prop,char *keyPath)
{
	char *str;
	BOOL3 BVar1;
	
	BVar1 = BOOL3_ERROR;
	str = CFG_CopyString(prop,keyPath);
	if (str != NULL) {
		BVar1 = util::Util_GetBoolFromString(str);
		std::free(str);
	}
	return BVar1;
}



// Reads a CFG float property specified in degrees, and returns the value in radians

float10 __cdecl lego::cfg::CFG_ReadRadians(CFGProperty *prop,char *keyPath)
{
	char *pcVar1;
	float10 fVar2;
	
	pcVar1 = CFG_ReadString(prop,keyPath);
	if (pcVar1 == NULL) {
		pcVar1 = ____EMPTYSTR__;
	}
	else {
		pcVar1 = CFG_ReadString(prop,keyPath);
	}
	fVar2 = std::atof(pcVar1);
	if (fVar2 != (float10)0.0) {
										// value / 360.0 * (M_PI * 2.0)
		return fVar2 * (float10)0.002777778 * (float10)6.283185;
	}
	return (float10)0.0;
}



BOOL __cdecl
lego::cfg::CFG_ReadRGBF(CFGProperty *prop,char *keyPath,float *out_r,float *out_g,float *out_b)
{
	char *input;
	int numParts;
	int channel;
	uint result;
	char *parts_0;
	char *parts_1;
	char *parts_2;
	
	result = 0;
	input = CFG_CopyString(prop,keyPath);
	if (input != NULL) {
		numParts = util::Util_Tokenise(input,&parts_0,":");
		if (numParts == 3) {
			channel = std::atoi(parts_0);
										// channel / 255.0
			*out_r = (float)channel * 0.003921569;
			channel = std::atoi(parts_1);
			*out_g = (float)channel * 0.003921569;
			channel = std::atoi(parts_2);
			*out_b = (float)channel * 0.003921569;
		}
		result = (uint)(numParts == 3);
		std::free(input);
	}
	return result;
}



void __cdecl lego::cfg::CFG_Close(CFGProperty *root)
{
	CFGProperty *prop;
	
	std::free(root->fileData);
	if (root != NULL) {
		do {
			prop = root->linkNext;
			Config_Remove(root);
			root = prop;
		} while (prop != NULL);
	}
	return;
}



CFGProperty * __cdecl lego::cfg::Config_Create(CFGProperty *prev)
{
	uint uVar1;
	CFGProperty *pCVar2;
	CFGProperty *pCVar3;
	CFGProperty *next;
	
	if (globs::configGlobs.freeList == NULL) {
		Config_AddList();
	}
	pCVar2 = globs::configGlobs.freeList;
	next = globs::configGlobs.freeList;
	pCVar3 = (globs::configGlobs.freeList)->nextFree;
	(globs::configGlobs.freeList)->nextFree = globs::configGlobs.freeList;
	globs::configGlobs.freeList = pCVar3;
	pCVar2->key = NULL;
	pCVar2->value = NULL;
	pCVar2->linkNext = NULL;
	if (prev != NULL) {
		prev->linkNext = pCVar2;
		pCVar2->linkPrev = prev;
		uVar1 = prev->depth;
		pCVar2->fileData = NULL;
		pCVar2->depth = uVar1;
		return next;
	}
	pCVar2->depth = 0;
	pCVar2->linkPrev = NULL;
	return next;
}



void __cdecl lego::cfg::Config_Remove(CFGProperty *prop)
{
	prop->nextFree = globs::configGlobs.freeList;
	globs::configGlobs.freeList = prop;
	return;
}



CFGProperty * __cdecl lego::cfg::CFG_GetProperty(CFGProperty *prop,char *keyPath)
{
	char *pcVar1;
	int numParts;
	int tmpCmp;
	uint uVar2;
	char *pcVar3;
	uint uVar4;
	undefined4 *puVar5;
	size_t sVar6;
	char *pcVar7;
	undefined4 *puVar8;
	bool isWildcard;
	CFGProperty *result;
	char *input_parts [101];
	char c;
	uint depth;
	CFGProperty *previous;
	
	depth = 0xffffffff;
	pcVar7 = keyPath;
	do {
		if (depth == 0) break;
		depth -= 1;
		c = *pcVar7;
		pcVar7 = pcVar7 + 1;
	} while (c != '\0');
	result = NULL;
	input_parts[0] = (char *)std::malloc(~depth);
	depth = 0xffffffff;
	do {
		pcVar7 = keyPath;
		if (depth == 0) break;
		depth -= 1;
		pcVar7 = keyPath + 1;
		c = *keyPath;
		keyPath = pcVar7;
	} while (c != '\0');
	depth = ~depth;
	puVar5 = (undefined4 *)(pcVar7 + -depth);
	puVar8 = (undefined4 *)input_parts[0];
	for (uVar2 = depth >> 2; uVar2 != 0; uVar2 -= 1) {
		*puVar8 = *puVar5;
		puVar5 = puVar5 + 1;
		puVar8 = puVar8 + 1;
	}
	for (depth &= 3; depth != 0; depth -= 1) {
		*(undefined *)puVar8 = *(undefined *)puVar5;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
		puVar8 = (undefined4 *)((int)puVar8 + 1);
	}
	numParts = util::Util_Tokenise(input_parts[0],input_parts + 1,"::");
	if (prop != NULL) {
		do {
			if (prop->depth == numParts - 1U) {
										// CFG_IsKeyMatch
				isWildcard = false;
				if (numParts == 1) {
					pcVar7 = prop->key;
					sVar6 = 0;
					c = *pcVar7;
					pcVar3 = pcVar7;
					while ((c != '\0' && (c != '*'))) {
						pcVar1 = pcVar3 + 1;
						sVar6 += 1;
						pcVar3 = pcVar3 + 1;
						c = *pcVar1;
					}
					if (*pcVar3 == '*') {
						tmpCmp = std::_strnicmp(input_parts[1],pcVar7,sVar6);
						isWildcard = tmpCmp == 0;
					}
				}
				if ((isWildcard) || (tmpCmp = std::_stricmp(input_parts[numParts],prop->key), tmpCmp == 0))
				{
					isWildcard = false;
					depth = numParts - 1U;
					for (previous = prop; previous != NULL; previous = previous->linkPrev) {
										// CFG_IsKeyMatch
						uVar2 = depth - 1;
						uVar4 = depth;
						if (previous->depth == uVar2) {
							if (depth == 1) {
								pcVar7 = previous->key;
								sVar6 = 0;
								c = *pcVar7;
								pcVar3 = pcVar7;
								while ((c != '\0' && (c != '*'))) {
									pcVar1 = pcVar3 + 1;
									sVar6 += 1;
									pcVar3 = pcVar3 + 1;
									c = *pcVar1;
								}
								if (*pcVar3 == '*') {
									tmpCmp = std::_strnicmp(input_parts[1],pcVar7,sVar6);
									isWildcard = tmpCmp == 0;
								}
							}
							uVar4 = uVar2;
							if ((!isWildcard) &&
								 (tmpCmp = std::_stricmp(input_parts[depth],previous->key), tmpCmp != 0)) break;
						}
						depth = uVar4;
					}
					if ((depth == 0) && (result = prop, !isWildcard)) break;
				}
			}
			prop = prop->linkNext;
		} while (prop != NULL);
	}
	std::free(input_parts[0]);
	return result;
}



void __cdecl lego::cfg::Config_AddList(void)
{
	CFGProperty *pCVar1;
	CFGProperty *pCVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::configGlobs.listCount & 0x1f);
	pCVar2 = (CFGProperty *)std::malloc(uVar4 * 0x20);
	globs::configGlobs.listSet[globs::configGlobs.listCount] = pCVar2;
	pCVar2 = globs::configGlobs.listSet[globs::configGlobs.listCount];
	if (pCVar2 != NULL) {
		globs::configGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pCVar1 = pCVar2;
			do {
				pCVar1->nextFree = pCVar1 + 1;
				iVar3 += -1;
				pCVar1 = pCVar1 + 1;
			} while (iVar3 != 0);
		}
		pCVar2[uVar4 - 1].nextFree = globs::configGlobs.freeList;
		globs::configGlobs.freeList = pCVar2;
	}
	return;
}



// out_vector = norm({ rand(), rand(), rand() })

Vector3F * __cdecl lego::math::Maths_Vector3DRandom(Vector3F *out_vector)
{
	Vector3F *pVVar1;
	
	pVVar1 = D3DRMVectorRandom(out_vector);
	return pVVar1;
}



// out_vector = ::D3DRMVectorRotate(out_vector, v, axis, theta)

Vector3F * __cdecl
lego::math::Maths_Vector3DRotate(Vector3F *out_vector,Vector3F *v,Vector3F *axis,float theta)
{
	Vector3F *pVVar1;
	
	pVVar1 = D3DRMVectorRotate(out_vector,v,axis,theta);
	return pVVar1;
}



// out_vector = norm(cross_product((c - b), (b - a)))

Vector3F * __cdecl
lego::math::Maths_PlaneNormal(Vector3F *out_vector,Vector3F *p1,Vector3F *p2,Vector3F *p3)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	
	fVar1 = p3->x - p2->x;
	fVar4 = p2->x - p1->x;
	fVar3 = p3->y - p2->y;
	fVar5 = p3->z - p2->z;
	fVar6 = p2->y - p1->y;
	fVar7 = p2->z - p1->z;
	fVar2 = fVar1 * fVar7 - fVar5 * fVar4;
	fVar4 = fVar3 * fVar4 - fVar1 * fVar6;
	fVar3 = fVar5 * fVar6 - fVar3 * fVar7;
	fVar1 = 1.0 / SQRT(fVar3 * fVar3 + fVar4 * fVar4 + fVar2 * fVar2);
	out_vector->x = fVar1 * fVar3;
	out_vector->y = fVar1 * fVar2;
	out_vector->z = fVar1 * fVar4;
	return out_vector;
}



float10 __cdecl lego::math::Maths_TriangleAreaZ(Vector3F *p1,Vector3F *p2,Vector3F *p3,BOOL bfc)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	Vector3F *pVVar5;
	Vector3F *pVVar6;
	int iVar7;
	float *pfVar8;
	Vector3F *pVVar9;
	Vector3F **ppVVar10;
	uint uVar11;
	float10 fVar12;
	float local_8c;
	uint local_88;
	float local_7c;
	Vector3F local_78;
	Vector3F local_6c;
	Vector3F local_60;
	Vector3F *local_54 [5];
	Vector3F *local_40;
	Vector3F local_3c;
	Vector3F local_30 [3];
	
	local_54[0] = &local_78;
	local_54[1] = &local_6c;
	local_54[3] = &local_60;
	local_54[2] = &local_6c;
	local_54[4] = &local_60;
	local_78.x = p1->x;
	local_40 = &local_78;
	local_78.y = p1->y;
	local_6c.x = p2->x;
	local_6c.y = p2->y;
	local_60.x = p3->x;
	local_60.y = p3->y;
	local_7c = 0.0;
	local_8c = 0.0;
	local_78.z = 0.0;
	local_6c.z = 0.0;
	local_60.z = 0.0;
	if (bfc == 0) {
		local_3c.z = -1.0;
	}
	else {
		Maths_PlaneNormal(&local_3c,&local_78,&local_6c,&local_60);
	}
	if (local_3c.z < 0.0) {
		uVar11 = 0;
		pVVar9 = local_30;
		ppVVar10 = local_54 + 1;
		pfVar8 = &local_30[1].z;
		do {
			pVVar5 = *ppVVar10;
			pVVar6 = ppVVar10[-1];
			fVar1 = pVVar5->y;
			fVar2 = pVVar5->z;
			fVar3 = pVVar6->y;
			fVar4 = pVVar6->z;
			pfVar8[-2] = pVVar5->x - pVVar6->x;
			pfVar8[-1] = fVar1 - fVar3;
			*pfVar8 = fVar2 - fVar4;
			fVar2 = SQRT(pfVar8[-2] * pfVar8[-2] + *pfVar8 * *pfVar8 + pfVar8[-1] * pfVar8[-1]);
			fVar3 = 1.0 / fVar2;
			fVar1 = pfVar8[-2];
			pVVar9->x = fVar2;
			fVar2 = pVVar9->x;
			pfVar8[-2] = fVar3 * fVar1;
			pfVar8[-1] = fVar3 * pfVar8[-1];
			*pfVar8 = fVar3 * *pfVar8;
			if ((ushort)((ushort)(fVar2 < local_8c) << 8 | (ushort)(fVar2 == local_8c) << 0xe) == 0) {
				local_8c = pVVar9->x;
				local_88 = uVar11;
			}
			uVar11 += 1;
			ppVVar10 = ppVVar10 + 2;
			pfVar8 = pfVar8 + 3;
			pVVar9 = (Vector3F *)&pVVar9->y;
		} while (uVar11 < 3);
		uVar11 = (local_88 + 1) % 3;
		local_30[local_88 + 1].x = local_30[local_88 + 1].x * -1.0;
		local_30[local_88 + 1].y = local_30[local_88 + 1].y * -1.0;
		local_30[local_88 + 1].z = local_30[local_88 + 1].z * -1.0;
										// Standard library math functions have some nasty ASM in them.
										// I believe the second function is testing against FPU control word results(?)
		fVar12 = std::acos((float10)local_30[uVar11 + 1].x * (float10)local_30[local_88 + 1].x +
											 (float10)local_30[local_88 + 1].z * (float10)local_30[uVar11 + 1].z +
											 (float10)local_30[local_88 + 1].y * (float10)local_30[uVar11 + 1].y);
		iVar7 = std::_finite((double)fVar12);
		if (iVar7 != 0) {
			fVar12 = (float10)fsin((float10)(float)fVar12);
			local_7c = (float)((float10)(&local_30[0].x)[local_88] * (float10)0.5 *
												fVar12 * (float10)(&local_30[0].x)[uVar11]);
		}
	}
	return (float10)local_7c;
}



short __cdecl lego::math::Maths_Rand(void)
{
	globals::g_RAND = globals::g_RAND * 0x343fd + 0x269ec3;
	return (short)((ushort)(globals::g_RAND >> 0x10) & 0x7fff);
}



float10 __cdecl lego::math::Maths_RandRange(float low,float high)
{
	short sVar1;
	
	sVar1 = Maths_Rand();
	return (float10)(int)sVar1 * (float10)3.051851e-05 * ((float10)high - (float10)low) + (float10)low
	;
}



// out_vector = a + (norm(b) * (dot_product((c - a), norm(d)) / dot_product(norm(b), norm(d)))
// CONDITION: dot_product(norm(b), norm(d)) != 0.0

BOOL __cdecl
lego::math::Maths_RayPlaneIntersection
					(Vector3F *out_endPoint,Vector3F *rayOrigin,Vector3F *ray,Vector3F *planePoint,
					Vector3F *planeNormal)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	BOOL BVar8;
	Vector3F norm_b;
	Vector3F norm_d;
	
	fVar1 = planeNormal->x;
	fVar2 = ray->x;
	fVar3 = planeNormal->y;
	fVar4 = ray->y;
	fVar5 = ray->z;
	fVar6 = planeNormal->z;
	fVar7 = 1.0 / SQRT(fVar5 * fVar5 + fVar4 * fVar4 + fVar2 * fVar2);
	ray = (Vector3F *)(1.0 / SQRT(fVar6 * fVar6 + fVar3 * fVar3 + fVar1 * fVar1));
	norm_b.x = fVar7 * fVar2;
	norm_b.y = fVar7 * fVar4;
	norm_b.z = fVar7 * fVar5;
	norm_d.x = (float)ray * fVar1;
	norm_d.y = (float)ray * fVar3;
	norm_d.z = (float)ray * fVar6;
	BVar8 = Maths_RayPlaneDistance((float *)&ray,rayOrigin,&norm_b,planePoint,&norm_d);
	if (BVar8 != 0) {
		Maths_RayEndPoint(out_endPoint,rayOrigin,&norm_b,(float)ray);
		return TRUE;
	}
	return 0;
}



// out_value = dot_product((c - a), d) / dot_product(b, d)
// CONDITION: dot_product(b, d) != 0.0

BOOL __cdecl
lego::math::Maths_RayPlaneDistance
					(float *out_dist,Vector3F *rayOrigin,Vector3F *ray,Vector3F *planePoint,
					Vector3F *planeNormal)
{
	float dot_product;
	
										// Vector3_DotProduct(b, d)
	dot_product = planeNormal->x * ray->x + ray->z * planeNormal->z + ray->y * planeNormal->y;
	if (dot_product != 0.0) {
										// Vector3_Multiply((Vector3_Subtract(c, a), d)
		*out_dist = ((planePoint->x - rayOrigin->x) * planeNormal->x +
								(planePoint->y - rayOrigin->y) * planeNormal->y +
								(planePoint->z - rayOrigin->z) * planeNormal->z) / dot_product;
		return TRUE;
	}
	return 0;
}



// out_vector = a + (b * scalar)

Vector3F * __cdecl
lego::math::Maths_RayEndPoint(Vector3F *out_endPoint,Vector3F *rayOrigin,Vector3F *ray,float dist)
{
	float fVar1;
	float fVar2;
	
	fVar1 = ray->y;
	fVar2 = ray->z;
	out_endPoint->x = dist * ray->x + rayOrigin->x;
	out_endPoint->y = rayOrigin->y + fVar1 * dist;
	out_endPoint->z = rayOrigin->z + fVar2 * dist;
	return out_endPoint;
}



// out_point = a + (b * dot_product((a - c), (perpendicular(d) / dot_product(perpendicular(b), d))))
// CONDITION: dot_product(perpendicular(b), d) != 0.0

Point2F * __cdecl
lego::math::Maths_Vector2DIntersection
					(Point2F *out_intersection,Point2F *start1,Point2F *vector1,Point2F *start2,
					Point2F *vector2)
{
	float fVar1;
	
	fVar1 = -vector1->y * vector2->x - -vector1->x * vector2->y;
	if (fVar1 != 0.0) {
		fVar1 = (start1->x - start2->x) * -(vector2->y / fVar1) +
						(vector2->x / fVar1) * (start1->y - start2->y);
		out_intersection->x = fVar1 * vector1->x;
		out_intersection->y = fVar1 * vector1->y;
		out_intersection->x = start1->x + out_intersection->x;
		out_intersection->y = out_intersection->y + start1->y;
		return out_intersection;
	}
	return NULL;
}



BOOL __cdecl
lego::math::Maths_PointInsidePoly(Point2F *point,Point2F *fromList,Point2F *toList,uint count)
{
	float fVar1;
	float *pfVar2;
	uint uVar3;
	Point2F *pPVar4;
	
	uVar3 = 0;
	if (count != 0) {
		pfVar2 = &fromList->y;
		pPVar4 = (Point2F *)((int)toList - (int)fromList);
		do {
			if (((((ushort)((ushort)(*pfVar2 < point->y) << 8 | (ushort)(*pfVar2 == point->y) << 0xe) != 0
						) && (point->y <= *(float *)((int)&pPVar4->x + (int)pfVar2))) ||
					((point->y <= *pfVar2 &&
					 (fVar1 = *(float *)((int)&pPVar4->x + (int)pfVar2),
					 (ushort)((ushort)(fVar1 < point->y) << 8 | (ushort)(fVar1 == point->y) << 0xe) != 0))))
				 && (fVar1 = (toList->x - pfVar2[-1]) *
										 ((*(float *)((int)&pPVar4->x + (int)pfVar2) - *pfVar2) / (point->y - *pfVar2))
										 + pfVar2[-1],
						(ushort)((ushort)(fVar1 < point->x) << 8 | (ushort)(fVar1 == point->x) << 0xe) == 0)) {
				uVar3 += 1;
			}
			toList = toList + 1;
			pfVar2 = pfVar2 + 2;
			count -= 1;
		} while (count != 0);
	}
	return uVar3 & 1;
}



BOOL __cdecl
lego::math::Maths_RaySphereIntersection
					(Vector3F *center,float radius,Vector3F *camera,Vector3F *line)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float fVar4;
	
	fVar1 = camera->y - center->y;
	fVar4 = camera->z - center->z;
	fVar3 = camera->x - center->x;
	fVar2 = (line->z + line->z) * fVar4 + (line->y + line->y) * fVar1 + (line->x + line->x) * fVar3;
	fVar1 = fVar2 * fVar2 - ((fVar3 * fVar3 + fVar4 * fVar4 + fVar1 * fVar1) * 4.0 - radius * radius);
	if ((ushort)((ushort)(fVar1 < 0.0) << 8 | (ushort)(fVar1 == 0.0) << 0xe) == 0) {
		return TRUE;
	}
	return 0;
}



// out_matrix = { {
//                  l[0,0]*r[0,0] + l[0,1]*r[1,0] + l[0,2]*r[2,0] + l[0,3]*r[3,0],
//                  l[0,0]*r[0,1] + l[0,1]*r[1,1] + l[0,2]*r[2,1] + l[0,3]*r[3,1],
//                  l[0,0]*r[0,2] + l[0,1]*r[1,2] + l[0,2]*r[2,2] + l[0,3]*r[3,2],
//                  l[0,0]*r[0,3] + l[0,1]*r[1,3] + l[0,2]*r[2,3] + l[0,3]*r[3,3]
//                },{
//                  l[1,0]*r[0,0] + l[1,1]*r[1,0] + l[1,2]*r[2,0] + l[1,3]*r[3,0],
//                  l[1,0]*r[0,1] + l[1,1]*r[1,1] + l[1,2]*r[2,1] + l[1,3]*r[3,1],
//                  l[1,0]*r[0,2] + l[1,1]*r[1,2] + l[1,2]*r[2,2] + l[1,3]*r[3,2],
//                  l[1,0]*r[0,3] + l[1,1]*r[1,3] + l[1,2]*r[2,3] + l[1,3]*r[3,3]
//                },{
//                  l[2,0]*r[0,0] + l[2,1]*r[1,0] + l[2,2]*r[2,0] + l[2,3]*r[3,0],
//                  l[2,0]*r[0,1] + l[2,1]*r[1,1] + l[2,2]*r[2,1] + l[2,3]*r[3,1],
//                  l[2,0]*r[0,2] + l[2,1]*r[1,2] + l[2,2]*r[2,2] + l[2,3]*r[3,2],
//                  l[2,0]*r[0,3] + l[2,1]*r[1,3] + l[2,2]*r[2,3] + l[2,3]*r[3,3]
//                },{
//                  l[3,0]*r[0,0] + l[3,1]*r[1,0] + l[3,2]*r[2,0] + l[3,3]*r[3,0],
//                  l[3,0]*r[0,1] + l[3,1]*r[1,1] + l[3,2]*r[2,1] + l[3,3]*r[3,1],
//                  l[3,0]*r[0,2] + l[3,1]*r[1,2] + l[3,2]*r[2,2] + l[3,3]*r[3,2],
//                  l[3,0]*r[0,3] + l[3,1]*r[1,3] + l[3,2]*r[2,3] + l[3,3]*r[3,3]
//              } }
// NOTE: right and left operands are ordered in reverse in the parameter list.

void __cdecl lego::math::Matrix_Mult(Matrix4F *out_matrix,Matrix4F *right,Matrix4F *left)
{
	float (*pafVar1) [4];
	float (*pafVar2) [4];
	Matrix4F *pMVar3;
	Matrix4F *pMVar4;
	Matrix4F *pMVar5;
	float *pfVar6;
	int iVar7;
	int iVar8;
	Matrix4F *pMVar9;
	
	Matrix_Zero(out_matrix);
	pMVar5 = (Matrix4F *)((int)out_matrix - (int)left);
	out_matrix = (Matrix4F *)&DAT_00000004;
	do {
		pfVar6 = (float *)((int)pMVar5->values + (int)left->values);
		iVar7 = 4;
		pMVar9 = right;
		do {
			iVar8 = 4;
			pMVar3 = pMVar9;
			pMVar4 = left;
			do {
				pafVar1 = pMVar4->values;
				pafVar2 = pMVar3->values;
				pMVar3 = (Matrix4F *)pMVar3->values[1];
				pMVar4 = (Matrix4F *)(pMVar4->values + 1);
				iVar8 += -1;
				*pfVar6 = (*pafVar1)[0] * (*pafVar2)[0] + *pfVar6;
			} while (iVar8 != 0);
			pfVar6 = pfVar6 + 1;
			pMVar9 = (Matrix4F *)(pMVar9->values + 1);
			iVar7 += -1;
		} while (iVar7 != 0);
		left = (Matrix4F *)left->values[1];
		out_matrix = (Matrix4F *)((int)out_matrix[-1].values[3] + 0xf);
	} while (out_matrix != NULL);
	return;
}



// out_matrix = { { 1,      0,       0, 0 },
//                { 0, cos(t), -sin(t), 0 },
//                { 0, sin(t),  cos(t), 0 },
//                { 0,      0,       0, 1 } }

void __cdecl lego::math::Matrix_RotX(Matrix4F *out_matrix,float rot)
{
	float10 cosine;
	float10 sine;
	
	cosine = (float10)fcos((float10)rot);
	sine = (float10)fsin((float10)rot);
	Matrix_Identity(out_matrix);
	out_matrix->values[1][2] = -(float)sine;
	out_matrix->values[1][1] = (float)cosine;
	out_matrix->values[2][2] = (float)cosine;
	out_matrix->values[2][1] = (float)sine;
	return;
}



// out_matrix = { {  cos(t), 0, sin(t), 0 },
//                {       0, 1,      0, 0 },
//                { -sin(t), 0, cos(t), 0 },
//                {       0, 0,      0, 1 } }

void __cdecl lego::math::Matrix_RotY(Matrix4F *out_matrix,float rot)
{
	float10 cosine;
	float10 sine;
	
	cosine = (float10)fcos((float10)rot);
	sine = (float10)fsin((float10)rot);
	Matrix_Identity(out_matrix);
	out_matrix->values[2][0] = -(float)sine;
	out_matrix->values[0] = (float)cosine;
	out_matrix->values[2][2] = (float)cosine;
	out_matrix->values[2] = (float)sine;
	return;
}



// out_matrix = { { cos(t), -sin(t), 0, 0 },
//                { sin(t),  cos(t), 0, 0 },
//                {      0,       0, 1, 0 },
//                {      0,       0, 0, 1 } }

void __cdecl lego::math::Matrix_RotZ(Matrix4F *out_matrix,float rot)
{
	float10 cosine;
	float10 sine;
	
	cosine = (float10)fcos((float10)rot);
	sine = (float10)fsin((float10)rot);
	Matrix_Identity(out_matrix);
	out_matrix->values[1] = -(float)sine;
	out_matrix->values[0] = (float)cosine;
	out_matrix->values[1][1] = (float)cosine;
	out_matrix->values[1][0] = (float)sine;
	return;
}



// out_matrix = { { 1, 0, 0, 0 },
//                { 0, 1, 0, 0 },
//                { 0, 0, 1, 0 },
//                { x, y, z, 1 } }

void __cdecl lego::math::Matrix_Translate(Matrix4F *out_matrix,Vector3F *trans)
{
	Matrix_Identity(out_matrix);
	out_matrix->values[3][0] = trans->x;
	out_matrix->values[3][1] = trans->y;
	out_matrix->values[3][2] = trans->z;
	return;
}



// out_matrix = { { 1, 0, 0, 0 },
//                { 0, 1, 0, 0 },
//                { 0, 0, 1, 0 },
//                { 0, 0, 0, 1 } }

void __cdecl lego::math::Matrix_Identity(Matrix4F *out_matrix)
{
	float fVar1;
	int iVar2;
	int iVar3;
	
	iVar3 = 0;
	do {
		iVar2 = 0;
		do {
			if (iVar3 == iVar2) {
				fVar1 = 1.0;
			}
			else {
				fVar1 = 0.0;
			}
			out_matrix->values[0] = fVar1;
			iVar2 += 1;
			out_matrix = (Matrix4F *)(out_matrix->values + 1);
		} while (iVar2 < 4);
		iVar3 += 1;
	} while (iVar3 < 4);
	return;
}



// out_matrix = { { 0, 0, 0, 0 },
//                { 0, 0, 0, 0 },
//                { 0, 0, 0, 0 },
//                { 0, 0, 0, 0 } }

void __cdecl lego::math::Matrix_Zero(Matrix4F *out_matrix)
{
	int iVar1;
	
	for (iVar1 = 0x10; iVar1 != 0; iVar1 += -1) {
		out_matrix->values[0] = 0.0;
		out_matrix = (Matrix4F *)(out_matrix->values + 1);
	}
	return;
}



// out_matrix = a

void __cdecl lego::math::Matrix_Copy(Matrix4F *out_matrix,Matrix4F *src)
{
	Matrix4F *pMVar1;
	int iVar2;
	int iVar3;
	
	iVar3 = 4;
	pMVar1 = out_matrix;
	do {
		iVar2 = 4;
		do {
			pMVar1->values[0] =
					 *(float *)((int)((Matrix4F *)((int)src - (int)out_matrix))->values + (int)pMVar1->values)
			;
			pMVar1 = (Matrix4F *)(pMVar1->values + 1);
			iVar2 += -1;
		} while (iVar2 != 0);
		iVar3 += -1;
	} while (iVar3 != 0);
	return;
}



ImageFont * __cdecl lego::image::Font_Load(char *fname)
{
	uint uVar1;
	uint uVar2;
	ImageBMP *image;
	ImageFont *font;
	void *pvVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	float *pfVar7;
	float *pfVar8;
	float10 fVar9;
	float10 fVar10;
	float10 extraout_ST0;
	float10 extraout_ST1;
	longlong lVar11;
	longlong lVar12;
	int local_58;
	uint local_50;
	int local_48;
	uint local_38;
	uint local_34;
	uint local_30;
	uint local_2c;
	uint local_28;
	float *local_24;
	undefined4 uStack32;
	ImageBMP *local_1c;
	uint local_18;
	undefined4 uStack20;
	char *local_10;
	undefined4 uStack12;
	uint local_8;
	undefined4 uStack4;
	
	image = Image_LoadBMPScaled(fname,0,0);
	if (image != NULL) {
		local_1c = image;
		font = Font_Create(image);
		if (font != NULL) {
			Image_SetPenZeroTrans(image);
			uVar5 = (int)image->width / 10;
			uVar2 = (int)image->height / 0x13;
			local_28 = uVar5;
			local_2c = Image_GetPen255(image);
			local_30 = Image_GetPixelMask(image);
			pvVar3 = Image_LockSurface(image,&local_34,&local_38);
			if (pvVar3 != NULL) {
				fVar9 = (float10)(ulonglong)uVar5;
				uStack32 = 0;
				uVar1 = uVar5 - 1;
				pfVar7 = &font->posSet[0].width;
				local_50 = 0;
				local_48 = 0x13;
				local_24 = pfVar7;
				do {
					uStack20 = 0;
					fVar10 = (float10)(ulonglong)local_50;
					fname = NULL;
					local_58 = 10;
					pfVar8 = pfVar7;
					local_18 = local_50;
					do {
						uStack12 = 0;
						local_10 = fname;
						pfVar8[-2] = (float)ZEXT48(fname);
						pfVar8[-1] = (float)fVar10;
						*pfVar8 = (float)fVar9;
						pfVar8[1] = (float)(ulonglong)uVar2;
						if (uVar1 != 0) {
							lVar11 = __ftol(fVar10);
							uVar6 = uVar1;
							do {
								uStack4 = 0;
								local_8 = uVar6;
								lVar12 = __ftol((float10)(ulonglong)uVar6 + (float10)ZEXT48(fname));
								iVar4 = (int)lVar12 * (local_38 >> 3) + local_34 * (int)lVar11;
								uVar5 = local_28;
								fVar10 = extraout_ST0;
								fVar9 = extraout_ST1;
								if ((CONCAT31(CONCAT21(CONCAT11(*(undefined *)(iVar4 + (int)pvVar3),
																								*(undefined *)(iVar4 + 1 + (int)pvVar3)),
																			 *(undefined *)(iVar4 + 2 + (int)pvVar3)),
															*(undefined *)(iVar4 + 3 + (int)pvVar3)) & local_30) != local_2c)
								break;
								uVar6 -= 1;
								*pfVar8 = *pfVar8 - 1.0;
							} while (uVar6 != 0);
						}
						pfVar8 = pfVar8 + 0x4c;
						fname = fname + uVar5;
						local_58 += -1;
					} while (local_58 != 0);
					local_50 += uVar2;
					pfVar7 = pfVar7 + 4;
					local_48 += -1;
					if (local_48 == 0) {
						lVar11 = __ftol((float10)font->posSet[0].height);
						font->fontHeight = (uint)lVar11;
						lVar11 = __ftol((float10)*local_24);
						font->tabWidth = (int)lVar11 << 3;
						Image_UnlockSurface(local_1c);
						return font;
					}
				} while( true );
			}
			Font_Remove(font);
		}
		Image_Remove(image);
	}
	return NULL;
}



void __cdecl
lego::image::Font_VGetStringInfo
					(ImageFont *font,uint *out_width,uint *out_lineCount,char *msg,va_list argptr)
{
	uint uVar1;
	
	uVar1 = Font_VPrintF2(font,0,0,FALSE,out_lineCount,msg,argptr);
	if (out_width != NULL) {
		*out_width = uVar1;
	}
	return;
}



uint __cdecl lego::image::Font_PrintF(ImageFont *font,int x,int y,char *msg,...)
{
	uint uVar1;
	
	uVar1 = Font_VPrintF2(font,x,y,TRUE,NULL,msg,&stack0x00000014);
	return uVar1;
}



uint __cdecl lego::image::Font_VPrintF(ImageFont *font,int x,int y,char *msg,va_list argptr)
{
	uint uVar1;
	
	uVar1 = Font_VPrintF2(font,x,y,TRUE,NULL,msg,argptr);
	return uVar1;
}



uint __cdecl
lego::image::Font_VPrintF2
					(ImageFont *font,int x,int y,BOOL render,uint *out_lineCount,char *msg,va_list argptr)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	ImageBMP *image;
	byte bVar7;
	uint local_828;
	uint local_824;
	uint local_820;
	uint local_81c;
	uint local_818;
	Point2F local_808;
	char local_800 [12];
	char acStack2036 [1012];
	char local_400 [1024];
	
	cVar2 = *msg;
	local_824 = font->fontHeight;
	local_818 = 1;
	local_828 = 0;
	local_81c = 0;
	pcVar3 = local_400;
	while (cVar2 != '\0') {
		if ((*msg == '%') && (msg[1] == 'b')) {
			*pcVar3 = '@';
			pcVar3[1] = '[';
			pcVar3[2] = '0';
			pcVar3[3] = 'x';
			pcVar3[4] = '%';
			pcVar3[5] = '0';
			pcVar3[6] = '.';
			pcVar3[7] = '8';
			pcVar3[8] = 'x';
			pcVar3 = pcVar3 + 9;
			msg = msg + 1;
			*pcVar3 = ']';
		}
		else {
			*pcVar3 = *msg;
		}
		pcVar1 = msg + 1;
		msg = msg + 1;
		pcVar3 = pcVar3 + 1;
		cVar2 = *pcVar1;
	}
	*pcVar3 = '\0';
	uVar4 = std::vsprintf(local_800,local_400,argptr);
	local_820 = 0;
	uVar6 = 0;
	if (uVar4 != 0) {
		do {
			cVar2 = local_800[local_820];
			if (cVar2 == '\n') {
				if (local_81c < local_828) {
					local_81c = local_828;
				}
				y += local_824;
				local_824 = font->fontHeight;
				local_828 = 0;
				local_818 += 1;
			}
			else {
				if (cVar2 == '\t') {
					uVar6 = font->tabWidth - local_828 % font->tabWidth;
				}
				else {
					if ((((local_820 < uVar4 - 0xc) && (cVar2 == '@')) && (local_800[local_820 + 1] == '['))
						 && (((local_800[local_820 + 2] == '0' && (local_800[local_820 + 3] == 'x')) &&
								 (acStack2036[local_820] == ']')))) {
						image = NULL;
						uVar6 = 0;
						pcVar3 = local_800 + local_820 + 4;
						bVar7 = 0x1c;
						do {
										// int std::isdigit(int c)
							if (std::globals::_pcharwidth < 2) {
								uVar5 = *(byte *)(std::globals::_pctype + (byte)pcVar3[uVar6]) & C1_DIGIT;
							}
							else {
										// C1_DIGIT (0x4)
								uVar5 = std::_isctype((uint)(byte)pcVar3[uVar6],C1_DIGIT);
							}
							image = (ImageBMP *)
											((uint)image |
											(uint)(byte)pcVar3[uVar6] - ((-(uint)(uVar5 != 0) & 0xffffffd9) + 0x57) <<
											(bVar7 & 0x1f));
							uVar6 += 1;
							bVar7 = bVar7 - 4;
						} while (uVar6 < 8);
						if (image != NULL) {
							local_808.x = (float)(ulonglong)(local_828 + x);
							local_808.y = (float)y;
							local_828 += image->width;
							if (local_824 < image->height) {
								local_824 = image->height;
							}
							Image_DisplayScaled(image,NULL,&local_808,NULL);
						}
						local_820 += 0xc;
						goto LAB_0047a6f3;
					}
					uVar6 = Font_OutputChar(font,local_828 + x,y,cVar2,render);
				}
				local_828 += uVar6;
			}
LAB_0047a6f3:
			local_820 += 1;
			uVar6 = local_828;
		} while (local_820 < uVar4);
	}
	if (out_lineCount != NULL) {
		*out_lineCount = local_818;
	}
	if (local_81c < uVar6) {
		local_81c = uVar6;
	}
	return local_81c;
}



uint __cdecl lego::image::Font_OutputChar(ImageFont *font,int x,int y,char c,BOOL render)
{
	uint uVar1;
	uint uVar2;
	longlong lVar3;
	Point2F local_8;
	
	local_8.x = (float)x;
	local_8.y = (float)y;
	uVar1 = (byte)(c - 0x20) / 10;
	uVar2 = (uint)(byte)(c - 0x20) % 10;
	if (uVar1 < 0x13) {
		if (render != 0) {
			Image_DisplayScaled(font->image,font->posSet[uVar2] + uVar1,&local_8,NULL);
		}
		lVar3 = __ftol((float10)font->posSet[uVar2][uVar1].width);
		return (uint)lVar3;
	}
	return 0;
}



uint __cdecl lego::image::Font_GetCharWidth(ImageFont *font,char c)
{
	uint uVar1;
	
	uVar1 = Font_OutputChar(font,0,0,c,FALSE);
	return uVar1;
}



uint __cdecl lego::image::Font_GetHeight(ImageFont *font)
{
	return font->fontHeight;
}



void __cdecl lego::image::Font_Remove(ImageFont *font)
{
	Image_Remove(font->image);
	font->nextFree = globs::fontGlobs.freeList;
	globs::fontGlobs.freeList = font;
	return;
}



ImageFont * __cdecl lego::image::Font_Create(ImageBMP *image)
{
	int iVar1;
	ImageFont *pIVar2;
	ImageFont *pIVar3;
	
	pIVar2 = globs::fontGlobs.freeList;
	if (globs::fontGlobs.freeList == NULL) {
		Font_AddList();
		pIVar2 = globs::fontGlobs.freeList;
	}
	globs::fontGlobs.freeList = pIVar2->nextFree;
	pIVar3 = pIVar2;
	for (iVar1 = 0x2fd; iVar1 != 0; iVar1 += -1) {
		pIVar3->image = NULL;
		pIVar3 = (ImageFont *)pIVar3->posSet;
	}
	pIVar2->nextFree = pIVar2;
	pIVar2->image = image;
	return pIVar2;
}



void __cdecl lego::image::Font_AddList(void)
{
	ImageFont *pIVar1;
	ImageFont *pIVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::fontGlobs.listCount & 0x1f);
	pIVar2 = (ImageFont *)std::malloc(uVar4 * 0xbf4);
	globs::fontGlobs.listSet[globs::fontGlobs.listCount] = pIVar2;
	pIVar2 = globs::fontGlobs.listSet[globs::fontGlobs.listCount];
	if (pIVar2 != NULL) {
		globs::fontGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pIVar1 = pIVar2;
			do {
				pIVar1->nextFree = pIVar1 + 1;
				iVar3 += -1;
				pIVar1 = pIVar1 + 1;
			} while (iVar3 != 0);
		}
		pIVar2[uVar4 - 1].nextFree = globs::fontGlobs.freeList;
		globs::fontGlobs.freeList = pIVar2;
	}
	return;
}



BOOL __cdecl lego::snd::Sound3D_Initialise(HWND hWnd)
{
	HRESULT HVar1;
	WAVEFORMATEX *pWVar2;
	int iVar3;
	WAVEFORMATEX wfx;
	DSBUFFERDESC dsbd;
	
	globs::sound3DGlobs.intialised = 0;
	globs::sound3DGlobs.listenerFrame = NULL;
	do {
		HVar1 = DirectSoundCreate(NULL,(IDirectSound **)&globs::sound3DGlobs,NULL);
		if (HVar1 == 0) {
										// DSSCL_PRIORITY (0x2)
			pWVar2 = (WAVEFORMATEX *)
							 (*(code *)(globs::sound3DGlobs.lpDSnd)->lpVtbl->SetCooperativeLevel)
												 (globs::sound3DGlobs.lpDSnd,hWnd,2);
			if (pWVar2 == NULL) {
				dsbd.dwSize = 0x14;
										// DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRL3D | DSBCAPS_CTRLVOLUME
				dsbd.dwFlags = 0x91;
				dsbd.dwBufferBytes = (DWORD)pWVar2;
				dsbd.dwReserved = (DWORD)pWVar2;
				dsbd.lpwfxFormat = pWVar2;
				HVar1 = (*(code *)(globs::sound3DGlobs.lpDSnd)->lpVtbl->CreateSoundBuffer)
													(globs::sound3DGlobs.lpDSnd,&dsbd,
													 (IDirectSoundBuffer *)&globs::sound3DGlobs.lpDSBuff,NULL);
				if (HVar1 == 0) {
					wfx.wFormatTag = 1;
					wfx.nChannels = 2;
					wfx.wBitsPerSample = 0x10;
					wfx.nSamplesPerSec = 22050;
										// wfx.wBitsPerSample / 8 * wfx.nChannels
					wfx.nBlockAlign = 4;
										// wfx.nSamplesPerSec * wfx.nBlockAlign
					wfx.nAvgBytesPerSec = 88200;
					wfx.cbSize = 0;
					(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->SetFormat)
										(globs::sound3DGlobs.lpDSBuff,&wfx);
					HVar1 = (*(globs::sound3DGlobs.lpDSBuff)->lpVtbl->QueryInterface)
														(globs::sound3DGlobs.lpDSBuff,&idl::IID_IDirectSound3DListener,
														 &globs::sound3DGlobs.lp3DListenerInfo);
					if (HVar1 == 0) {
						(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetDopplerFactor)
											(globs::sound3DGlobs.lp3DListenerInfo,(float)&DAT_42c80000,0);
						goto LAB_0047aa15;
					}
					(*(globs::sound3DGlobs.lpDSBuff)->lpVtbl->Release)(globs::sound3DGlobs.lpDSBuff);
					goto LAB_0047aa04;
				}
				(*(globs::sound3DGlobs.lpDSnd)->lpVtbl->Release)(globs::sound3DGlobs.lpDSnd);
			}
			else {
LAB_0047aa04:
				(*(globs::sound3DGlobs.lpDSnd)->lpVtbl->Release)(globs::sound3DGlobs.lpDSnd);
			}
			globs::sound3DGlobs.lpDSnd = NULL;
		}
LAB_0047aa15:
		if (globs::sound3DGlobs.lpDSnd == NULL) {
			iVar3 = 5;
		}
		else {
			iVar3 = 1;
			globs::sound3DGlobs.intialised = 1;
		}
		if (iVar3 != 4) {
			if (globs::sound3DGlobs.intialised != 0) {
										// SET THE PRIMARY BUFFER TO CONTINUOUSLY PLAY - OPTIMISATION FOR FREQUENT
										// STARTING AND STOPPING OF PLAYBACK
										// 
										// DSBPLAY_LOOPING (0x1)
				(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->Play)(globs::sound3DGlobs.lpDSBuff,0,0,1);
										// DEFAULT VALUES
										// 
										// DS3D_DEFERRED (0x1)
				(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetRolloffFactor)
									(globs::sound3DGlobs.lp3DListenerInfo,1.0,1);
										// DISABLE DOPPLER - DONT NEED TO SET VELOCITY ON SOUNDS
										// 
										// DS3D_DEFERRED (0x1)
				(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetDopplerFactor)
									(globs::sound3DGlobs.lp3DListenerInfo,0.0,1);
				(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->CommitDeferredSettings)
									(globs::sound3DGlobs.lp3DListenerInfo);
				globs::sound3DGlobs.minDistanceForAttentuation = 1.0;
				globs::sound3DGlobs.maxDistance = 800.0;
				(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->GetVolume)
									(globs::sound3DGlobs.lpDSBuff,&globs::sound3DGlobs.windowsVolume);
				Sound3D_SetVolumeToDefault();
			}
			return 1;
		}
	} while( true );
}



void __cdecl lego::snd::Sound3D_ShutDown(void)
{
	if (globs::sound3DGlobs.intialised != 0) {
		Sound3D_SetGlobalVolume(globs::sound3DGlobs.windowsVolume);
		(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->Stop)(globs::sound3DGlobs.lpDSBuff);
		(*(globs::sound3DGlobs.lpDSBuff)->lpVtbl->Release)((IUnknown *)globs::sound3DGlobs.lpDSBuff);
		(*(globs::sound3DGlobs.lpDSnd)->lpVtbl->Release)((IUnknown *)globs::sound3DGlobs.lpDSnd);
		globs::sound3DGlobs.lpDSnd = NULL;
		globs::sound3DGlobs.intialised = 0;
	}
	return;
}



BOOL __cdecl lego::snd::Sound3D_CheckVolumeLimits(int vol)
{
										// is volume in range [-10000 to 0], inclusive
	if ((vol < 1) && (-10001 < vol)) {
		return 1;
	}
	return 0;
}



int __cdecl lego::snd::Sound3D_Load(char *fName,BOOL stream,BOOL simultaneous,int volume)
{
	char cVar1;
	BOOL BVar2;
	char *pcVar3;
	FILE *pFVar4;
	uint uVar5;
	uint uVar6;
	LPCSTR finalFilename;
	SampleFlags SVar7;
	undefined4 *puVar8;
	char *pcVar9;
	Sound3D_SoundData *pSVar10;
	uint sfxIndex;
	char wavFilename [260];
	char cdromFilename [260];
	bool success;
	
	success = false;
	if ((globs::sound3DGlobs.intialised != 0) &&
		 (BVar2 = Sound3D_GetFreeSoundIndex(&sfxIndex), BVar2 != 0)) {
		globs::sound3DGlobs.soundTable[sfxIndex].flags = SAMPLE_NONE;
		std::sprintf(wavFilename,"%s.wav",fName);
		if (stream == 0) {
			BVar2 = Sound3D_LoadSample(globs::sound3DGlobs.soundTable + sfxIndex,wavFilename,simultaneous)
			;
			if (BVar2 != 0) {
				SVar7 = globs::sound3DGlobs.soundTable[sfxIndex].flags & ~SAMPLE_STREAMED;
				globs::sound3DGlobs.soundTable[sfxIndex].flags = SVar7;
				if (simultaneous != 0) {
					globs::sound3DGlobs.soundTable[sfxIndex].flags = SVar7 | SAMPLE_MULTIPLE;
				}
				success = true;
			}
		}
		else {
			pcVar3 = lego::file::File_VerifyFilename(wavFilename);
			finalFilename = NULL;
			pFVar4 = std::fopen(pcVar3,"r");
			if (pFVar4 == NULL) {
				BVar2 = lego::file::File_GetCDFilePath(cdromFilename,wavFilename);
				if (BVar2 != 0) {
					finalFilename = cdromFilename;
				}
			}
			else {
				std::fclose(pFVar4);
				finalFilename = pcVar3;
			}
			if ((finalFilename != NULL) && (pFVar4 = std::fopen(finalFilename,"r"), pFVar4 != NULL)) {
				std::fseek(pFVar4,0,2);
				uVar5 = std::ftell(pFVar4);
				uVar6 = sfxIndex;
				globs::sound3DGlobs.soundTable[sfxIndex].size = uVar5;
				uVar5 = GetWaveAvgBytesPerSec(finalFilename);
				globs::sound3DGlobs.soundTable[uVar6].avgBytesPerSec = uVar5;
				globs::sound3DGlobs.soundTable[uVar6].flags =
						 globs::sound3DGlobs.soundTable[uVar6].flags | SAMPLE_STREAMED;
				std::fclose(pFVar4);
				success = true;
			}
		}
		if (success) {
			uVar6 = 0xffffffff;
			pcVar3 = wavFilename;
			do {
				pcVar9 = pcVar3;
				if (uVar6 == 0) break;
				uVar6 -= 1;
				pcVar9 = pcVar3 + 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar9;
			} while (cVar1 != '\0');
			uVar6 = ~uVar6;
			puVar8 = (undefined4 *)(pcVar9 + -uVar6);
			pSVar10 = globs::sound3DGlobs.soundTable + sfxIndex;
			for (uVar5 = uVar6 >> 2; uVar5 != 0; uVar5 -= 1) {
				*(undefined4 *)pSVar10->filename = *puVar8;
				puVar8 = puVar8 + 1;
				pSVar10 = (Sound3D_SoundData *)(pSVar10->filename + 4);
			}
			for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
				pSVar10->filename[0] = *(char *)puVar8;
				puVar8 = (undefined4 *)((int)puVar8 + 1);
				pSVar10 = (Sound3D_SoundData *)(pSVar10->filename + 1);
			}
			BVar2 = Sound3D_CheckVolumeLimits(volume);
			if (BVar2 == 0) {
				globs::sound3DGlobs.soundTable[sfxIndex].volume = 0;
				globs::sound3DGlobs.soundTable[sfxIndex].flags =
						 globs::sound3DGlobs.soundTable[sfxIndex].flags | (SAMPLE_ISUSED|SAMPLE_VOLUME);
				return sfxIndex;
			}
			globs::sound3DGlobs.soundTable[sfxIndex].volume = volume;
			globs::sound3DGlobs.soundTable[sfxIndex].flags =
					 globs::sound3DGlobs.soundTable[sfxIndex].flags | (SAMPLE_ISUSED|SAMPLE_VOLUME);
			return sfxIndex;
		}
	}
	return -1;
}



BOOL __cdecl lego::snd::Sound3D_GetFreeSoundIndex(uint *out_soundTableIndex)
{
	SampleFlags *pSVar1;
	uint uVar2;
	
	uVar2 = 0;
	pSVar1 = &globs::sound3DGlobs.soundTable[0].flags;
	do {
		if ((*(byte *)pSVar1 & 1) == 0) {
			*out_soundTableIndex = uVar2;
			return 1;
		}
		pSVar1 = pSVar1 + 0x4d;
		uVar2 += 1;
	} while (pSVar1 < globs::fileGlobs.wadBasePath + 8);
	return 0;
}



BOOL __cdecl lego::snd::Sound3D_Remove(int soundTableIndex)
{
	WAVEFORMATEX *hMem;
	IDirectSoundBuffer *This;
	IDirectSoundBuffer **ppIVar1;
	int iVar2;
	
	if ((globs::sound3DGlobs.intialised != 0) && (soundTableIndex != -1)) {
		hMem = globs::sound3DGlobs.soundTable[soundTableIndex].waveFormat;
		globs::sound3DGlobs.soundTable[soundTableIndex].flags =
				 globs::sound3DGlobs.soundTable[soundTableIndex].flags & ~SAMPLE_ISUSED;
		if (hMem != NULL) {
			GlobalFree(hMem);
			globs::sound3DGlobs.soundTable[soundTableIndex].waveFormat = NULL;
		}
		ppIVar1 = globs::sound3DGlobs.soundTable[soundTableIndex].dSoundBuffers;
		iVar2 = 3;
		do {
			This = *ppIVar1;
			if (This != NULL) {
				(*This->lpVtbl->Release)((IUnknown *)This);
				*ppIVar1 = NULL;
			}
			ppIVar1 = ppIVar1 + 1;
			iVar2 += -1;
		} while (iVar2 != 0);
		return 1;
	}
	return 0;
}



void __cdecl lego::snd::Sound3D_MakeListener(IDirect3DRMFrame3 *frame)
{
	if (globs::sound3DGlobs.intialised != 0) {
		globs::sound3DGlobs.listenerFrame = frame;
	}
	return;
}



void __cdecl lego::snd::Sound3D_UpdateListener(void)
{
	if ((globs::sound3DGlobs.intialised != 0) && (globs::sound3DGlobs.listenerFrame != NULL)) {
		Sound3D_ListenerCallback(globs::sound3DGlobs.listenerFrame,NULL,0.0);
	}
	return;
}



void __cdecl lego::snd::Sound3D_ListenerCallback(IDirect3DRMFrame3 *obj,void *arg,float delta)
{
	IDirect3DRMFrame3 *This;
	BOOL BVar1;
	bool bVar2;
	Vector3F local_18;
	Vector3F local_c;
	
	This = obj;
	(*obj->lpVtbl->GetScene)(obj,&obj);
	(*This->lpVtbl->GetPosition)(This,obj,&local_18);
	BVar1 = Sound3D_D3DVectorEqual(&local_18,&globs::sound3DGlobs.s_ListenerCallback_oldPos);
	bVar2 = BVar1 == 0;
	if (bVar2) {
										// IDirectSound3DListener->SetPosition(float x, float y, float z, DWORD dwApply)
		(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetPosition)
							(globs::sound3DGlobs.lp3DListenerInfo,local_18.x,local_18.y,local_18.z,1);
		globs::sound3DGlobs.s_ListenerCallback_oldPos.x = local_18.x;
		globs::sound3DGlobs.s_ListenerCallback_oldPos.y = local_18.y;
		globs::sound3DGlobs.s_ListenerCallback_oldPos.z = local_18.z;
	}
	(*This->lpVtbl->GetOrientation)(This,obj,&local_18,&local_c);
	BVar1 = Sound3D_D3DVectorEqual(&local_18,&globs::sound3DGlobs.s_ListenerCallback_oldOrien);
	if (BVar1 != 0) {
		BVar1 = Sound3D_D3DVectorEqual(&local_c,&globs::sound3DGlobs.s_ListenerCallback_oldOrienUp);
		if (BVar1 != 0) goto LAB_0047afa5;
	}
	(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetOrientation)
						(globs::sound3DGlobs.lp3DListenerInfo,local_18.x,local_18.y,local_18.z,local_c.x,
						 local_c.y,local_c.z,1);
	globs::sound3DGlobs.s_ListenerCallback_oldOrien.x = local_18.x;
	globs::sound3DGlobs.s_ListenerCallback_oldOrien.y = local_18.y;
	globs::sound3DGlobs.s_ListenerCallback_oldOrien.z = local_18.z;
	globs::sound3DGlobs.s_ListenerCallback_oldOrienUp.x = local_c.x;
	globs::sound3DGlobs.s_ListenerCallback_oldOrienUp.y = local_c.y;
	globs::sound3DGlobs.s_ListenerCallback_oldOrienUp.z = local_c.z;
	bVar2 = true;
LAB_0047afa5:
	if (bVar2) {
		(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->CommitDeferredSettings)
							(globs::sound3DGlobs.lp3DListenerInfo);
	}
	(*obj->lpVtbl->Release)(obj);
	return;
}



void __cdecl
lego::snd::Sound3D_SetWorldPos(IDirectSound3DBuffer *sound3DBuff,Vector3F *wPos,Vector3F *vel)
{
										// IDirectSound3DBuffer->SetPosition(float x, float y, float z, DWORD dwApply)
	(*(code *)sound3DBuff->lpVtbl->SetPosition)(sound3DBuff,wPos->x,wPos->y,wPos->z,0);
	return;
}



BOOL __cdecl
lego::snd::Sound3D_CheckAlreadyExists(IDirect3DRMFrame3 *frame,IDirectSound3DBuffer *sound3DBuff)
{
	Sound3D_SoundRecord *pSVar1;
	
	pSVar1 = globs::sound3DGlobs.soundRecord;
	if (globs::sound3DGlobs.soundRecord == NULL) {
		return (BOOL)NULL;
	}
	do {
		if (sound3DBuff == pSVar1->sound3DBuff) {
			Sound3D_RemoveSound(pSVar1->frame,pSVar1->sound3DBuff);
			return (BOOL)(Sound3D_SoundRecord *)0x1;
		}
		pSVar1 = pSVar1->next;
	} while (pSVar1 != NULL);
	return (BOOL)pSVar1;
}



int __cdecl
lego::snd::Sound3D_Play2
					(Sound3DPlayMode mode,IDirect3DRMFrame3 *frame,int soundTableIndex,BOOL loop,
					Vector3F *opt_wPos)
{
	SampleFlags SVar1;
	char *filename;
	FILE *stream;
	BOOL BVar2;
	IDirect3DRMFrame3 *This;
	uint uVar3;
	int *unaff_EBP;
	IDirectSound3DBuffer *unaff_ESI;
	char *fName;
	IDirectSound3DBuffer *soundBuff;
	float rvZ;
	undefined4 uVar4;
	IDirectSound3DBuffer *sound3DBuff;
	IDirectSound3DBuffer *local_118;
	IDirect3DRMFrame3 *local_114;
	Vector3F local_110;
	char local_104 [244];
	IDirect3DRMFrame3 *pIStack16;
	int iStack8;
	
	fName = NULL;
	if ((globs::sound3DGlobs.intialised != 0) && (soundTableIndex != -1)) {
		SVar1 = globs::sound3DGlobs.soundTable[soundTableIndex].flags;
		if ((SVar1 & SAMPLE_VOLUME) != SAMPLE_NONE) {
			if ((SVar1 & SAMPLE_STREAMED) == SAMPLE_NONE) {
				if ((SVar1 & SAMPLE_MULTIPLE) == SAMPLE_NONE) {
					soundBuff = (IDirectSound3DBuffer *)
											globs::sound3DGlobs.soundTable[soundTableIndex].dSoundBuffers[0];
				}
				else {
					uVar3 = globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex + 1;
					globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex = uVar3;
					if (2 < uVar3) {
						globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex = 0;
					}
					soundBuff = *(IDirectSound3DBuffer **)
											 (soundTableIndex * 0x134 + 0x5077b8 +
											 globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex * 4);
				}
				(*soundBuff->lpVtbl->QueryInterface)
									((IUnknown *)soundBuff,(IID *)&idl::IID_IDirectSound3DBuffer,&local_118);
				This = (IDirect3DRMFrame3 *)globs::sound3DGlobs.soundTable[soundTableIndex].volume;
				if (mode == SOUND3D_PLAY_NORMAL) {
					This = This + -200;
				}
				sound3DBuff = soundBuff;
				(*(code *)soundBuff->lpVtbl->SetConeOutsideVolume)();
				uVar4 = 1;
										// IDirectSound3DBuffer->SetMinDistance(float flMinDistance, DWORD dwApply)
				rvZ = globs::sound3DGlobs.minDistanceForAttentuation;
				(**(code **)(*unaff_EBP + 0x44))(unaff_EBP,globs::sound3DGlobs.minDistanceForAttentuation,1)
				;
										// IDirectSound3DBuffer->SetMaxDistance(float flMaxDistance, DWORD dwApply)
				(*This->lpVtbl->AddScale)
									(This,(D3DRMCombineType)globs::sound3DGlobs.maxDistance,1.401298e-45,
									 (float)unaff_EBP,rvZ);
				if (mode == SOUND3D_PLAY_ONFRAME) {
										// IDirectSound3DBuffer->SetMode(DWORD dwMode, DWORD dwApply)
										//  (dwMode = DS3DMODE_NORMAL (0x0), dwApply = TRUE (0x1))
					(*(code *)unaff_ESI->lpVtbl->SetMode)(unaff_ESI,0,1);
										// IDirect3DRMFrame3->GetScene(this, IDirect3DRMFrame3** lplpRoot)
										//  (this = param_2 (rmFrame3), lplpRoot => local_114)
					(*pIStack16->lpVtbl->GetScene)(pIStack16,(IDirect3DRMFrame3 **)&stack0xfffffed4);
					Sound3D_CheckAlreadyExists(pIStack16,sound3DBuff);
					res::Sound3D_AttachSound(pIStack16,sound3DBuff);
					Sound3D_AddSoundRecord(pIStack16,(IDirectSoundBuffer *)soundBuff,sound3DBuff);
										// IDirect3DRMFrame3->GetPosition(this, IDirect3DRMFrame3* lpRef, Vector3F*
										// lprvPos)
										//  (this = param_2 (rmFrame3), lpRef = GetScene)
					(*pIStack16->lpVtbl->GetPosition)(pIStack16,This,(Vector3F *)&stack0xfffffed8);
										// IDirectSound3DBuffer->SetPosition(float x, float y, float z, DWORD dwApply)
					(**(code **)(*(int *)mode + 0x4c))(mode,uVar4,sound3DBuff,This,1);
										// IDirect3DRMFrame3->Release(this)
										//  (this = GetScene)
					(*pIStack16->lpVtbl->Release)((IUnknown *)pIStack16);
				}
				else {
					if (mode == SOUND3D_PLAY_ONPOS) {
										// IDirectSound3DBuffer->SetMode(DWORD dwMode, DWORD dwApply)
										//  (dwMode = DS3DMODE_NORMAL (0x0), dwApply = TRUE (0x1))
						(*(code *)unaff_ESI->lpVtbl->SetMode)(unaff_ESI,0,1);
						Sound3D_SetWorldPos(unaff_ESI,(Vector3F *)frame,NULL);
						Sound3D_CheckAlreadyExists(NULL,unaff_ESI);
					}
					else {
						if (mode != SOUND3D_PLAY_NORMAL) goto LAB_0047b26d;
										// IDirectSound3DBuffer->SetMode(DWORD dwMode, DWORD dwApply)
										//  (dwMode = DS3DMODE_DISABLE (0x2), dwApply = TRUE (0x1))
						(*(code *)unaff_ESI->lpVtbl->SetMode)(unaff_ESI,2,1);
						Sound3D_CheckAlreadyExists(NULL,unaff_ESI);
					}
					Sound3D_AddSoundRecord(NULL,(IDirectSoundBuffer *)soundBuff,unaff_ESI);
				}
LAB_0047b26d:
				(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->CommitDeferredSettings)
									(globs::sound3DGlobs.lp3DListenerInfo);
				(*(code *)soundBuff->lpVtbl->SetConeAngles)(soundBuff,0);
				if (iStack8 != 0) {
					(*(code *)soundBuff->lpVtbl->SetAllParameters)(soundBuff,0,0,1);
					return soundTableIndex * 3 + globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex;
				}
				(*(code *)soundBuff->lpVtbl->SetAllParameters)(soundBuff,0,0,0);
				return soundTableIndex * 3 + globs::sound3DGlobs.soundTable[soundTableIndex].bufferIndex;
			}
			filename = lego::file::File_VerifyFilename
													 ((char *)(globs::sound3DGlobs.soundTable + soundTableIndex));
			stream = std::fopen(filename,"r");
			if (stream == NULL) {
				BVar2 = lego::file::File_GetCDFilePath
													(local_104,(char *)(globs::sound3DGlobs.soundTable + soundTableIndex));
				if (BVar2 != 0) {
					fName = local_104;
				}
			}
			else {
				std::fclose(stream);
				fName = filename;
			}
			if (fName != NULL) {
				Sound3D_Stream_Play(fName,loop,globs::sound3DGlobs.soundTable[soundTableIndex].volume);
				return soundTableIndex * 3;
			}
		}
	}
	return -1;
}



void __cdecl
lego::snd::Sound3D_AddSoundRecord
					(IDirect3DRMFrame3 *frame,IDirectSoundBuffer *soundBuff,IDirectSound3DBuffer *sound3DBuff)
{
	Sound3D_SoundRecord *pSVar1;
	
	pSVar1 = (Sound3D_SoundRecord *)std::malloc(0x10);
	pSVar1->next = globs::sound3DGlobs.soundRecord;
	pSVar1->frame = frame;
	pSVar1->sound3DBuff = sound3DBuff;
	pSVar1->soundBuff = soundBuff;
	globs::sound3DGlobs.soundRecord = pSVar1;
	return;
}



void __cdecl lego::snd::Sound3D_SetBufferVolume(int handle,int newvolume)
{
	byte bVar1;
	IDirectSoundBuffer *pIVar2;
	BOOL BVar3;
	uint uVar4;
	int iVar5;
	IDirectSoundBuffer **ppIVar6;
	
	BVar3 = Sound3D_CheckVolumeLimits(newvolume);
	bVar1 = *(byte *)&globs::sound3DGlobs.soundTable[handle].flags;
	uVar4 = -(uint)(BVar3 != 0) & newvolume;
	globs::sound3DGlobs.soundTable[handle].volume = uVar4;
	if ((bVar1 & 4) != 0) {
		ppIVar6 = globs::sound3DGlobs.soundTable[handle].dSoundBuffers;
		iVar5 = 3;
		do {
			pIVar2 = *ppIVar6;
			if (pIVar2 != NULL) {
				(*(code *)pIVar2->lpVtbl->SetVolume)(pIVar2,globs::sound3DGlobs.soundTable[handle].volume);
			}
			ppIVar6 = ppIVar6 + 1;
			iVar5 += -1;
		} while (iVar5 != 0);
		return;
	}
	pIVar2 = globs::sound3DGlobs.soundTable[handle].dSoundBuffers[0];
	if (pIVar2 != NULL) {
		(*(code *)pIVar2->lpVtbl->SetVolume)(pIVar2,uVar4);
	}
	return;
}



int __cdecl lego::snd::Sound3D_GetBufferVolume(int handle)
{
	return globs::sound3DGlobs.soundTable[handle].volume;
}



IDirectSoundBuffer * __cdecl lego::snd::Sound3D_GetSoundBuffer(int handle)
{
	if (handle == -1) {
		return NULL;
	}
										// globals::g_SampleDatas_TABLE[sfxType / 3].dSoundBuffers[sfxType % 3]
	return *(IDirectSoundBuffer **)
					((handle % 3) * 4 + 0x5077b8 + ((uint)(handle - handle % 3) / 3) * 0x134);
}



void __cdecl lego::snd::Sound3D_StopSound(int handle)
{
	IDirectSoundBuffer *dSoundBuffer;
	
	dSoundBuffer = Sound3D_GetSoundBuffer(handle);
	if (((globs::sound3DGlobs.intialised != 0) && (handle != -1)) && (dSoundBuffer != NULL)) {
		(*(code *)dSoundBuffer->lpVtbl->Stop)(dSoundBuffer);
	}
	return;
}



void __cdecl lego::snd::Sound3D_StopAllSounds(void)
{
	Sound3D_SoundRecord *pSVar1;
	
	pSVar1 = globs::sound3DGlobs.soundRecord;
	if (globs::sound3DGlobs.soundRecord != NULL) {
		do {
			(*(code *)pSVar1->soundBuff->lpVtbl->Stop)(pSVar1->soundBuff);
			pSVar1 = pSVar1->next;
		} while (pSVar1 != NULL);
	}
	Sound3D_Stream_Stop(FALSE);
	Sound3D_Stream_Stop(TRUE);
	return;
}



void __cdecl
lego::res::Sound3D_AttachSound(IDirect3DRMFrame3 *frame,IDirectSound3DBuffer *sound3DBuff)
{
	Container_AppData *appData;
	Sound3D_SoundFrameRecord *soundRecord;
	IDirect3DRMFrame3 **ppIVar1;
	int iVar2;
	
	appData = (*frame->lpVtbl->GetAppData)(frame);
	soundRecord = (Sound3D_SoundFrameRecord *)std::malloc(0x14);
	if (appData == NULL) {
		soundRecord->next = NULL;
	}
	else {
		soundRecord->next = appData->soundList;
	}
	soundRecord->sound3DBuff = sound3DBuff;
	(soundRecord->pos).x = 0.0;
	(soundRecord->pos).y = 0.0;
	(soundRecord->pos).z = 0.0;
	Container_Frame_SetAppData(frame,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,soundRecord,NULL);
	iVar2 = 0;
	ppIVar1 = globs::sound3DGlobs.updateFrameList;
	do {
		if (*ppIVar1 == NULL) {
			globs::sound3DGlobs.updateFrameList[iVar2] = frame;
			return;
		}
		ppIVar1 = ppIVar1 + 1;
		iVar2 += 1;
	} while (ppIVar1 < &globs::sound3DGlobs.reserved1);
	return;
}



void __cdecl
lego::snd::Sound3D_RemoveSound(IDirect3DRMFrame3 *frame,IDirectSound3DBuffer *sound3DBuff)
{
	Sound3D_SoundFrameRecord *buffer;
	Container_AppData *appData;
	BOOL BVar1;
	IDirect3DRMFrame3 **ppIVar2;
	
	(*sound3DBuff->lpVtbl->Release)(sound3DBuff);
	if (frame == NULL) {
		Sound3D_RemoveSoundRecord(NULL,sound3DBuff);
		return;
	}
	appData = (*frame->lpVtbl->GetAppData)(frame);
	BVar1 = Sound3D_RecurseRemoveSound(frame,sound3DBuff,appData->soundList);
	if (BVar1 != 0) {
		Sound3D_RemoveSoundRecord(frame,sound3DBuff);
		buffer = appData->soundList;
		appData->soundList = buffer->next;
		std::free(buffer);
	}
	ppIVar2 = globs::sound3DGlobs.updateFrameList;
	do {
		if (frame == *ppIVar2) {
			*ppIVar2 = NULL;
		}
		ppIVar2 = ppIVar2 + 1;
	} while (ppIVar2 < &globs::sound3DGlobs.reserved1);
	return;
}



void __cdecl
lego::snd::Sound3D_RemoveSoundRecord(IDirect3DRMFrame3 *frame,IDirectSound3DBuffer *sound3DBuff)
{
	Sound3D_SoundRecord *buffer;
	BOOL BVar1;
	
	BVar1 = Sound3D_RecurseRemoveSoundRecord(frame,sound3DBuff,globs::sound3DGlobs.soundRecord);
	buffer = globs::sound3DGlobs.soundRecord;
	if (BVar1 != 0) {
		globs::sound3DGlobs.soundRecord = (globs::sound3DGlobs.soundRecord)->next;
		std::free(buffer);
	}
	return;
}



BOOL __cdecl
lego::snd::Sound3D_RecurseRemoveSoundRecord
					(IDirect3DRMFrame3 *owner,IDirectSound3DBuffer *sound3DBuff,Sound3D_SoundRecord *record)
{
	Sound3D_SoundRecord *buffer;
	BOOL BVar1;
	
	if (record == NULL) {
		return 0;
	}
	BVar1 = Sound3D_RecurseRemoveSoundRecord(owner,sound3DBuff,record->next);
	if (BVar1 != 0) {
		buffer = record->next;
		record->next = buffer->next;
		std::free(buffer);
	}
	return (uint)(sound3DBuff == record->sound3DBuff);
}



BOOL __cdecl
lego::snd::Sound3D_RecurseRemoveSound
					(IDirect3DRMFrame3 *owner,IDirectSound3DBuffer *sound3DBuff,
					Sound3D_SoundFrameRecord *record)
{
	Sound3D_SoundFrameRecord *buffer;
	BOOL BVar1;
	
	if (record == NULL) {
		return 0;
	}
	BVar1 = Sound3D_RecurseRemoveSound(owner,sound3DBuff,record->next);
	if (BVar1 != 0) {
		Sound3D_RemoveSoundRecord(owner,sound3DBuff);
		buffer = record->next;
		record->next = buffer->next;
		std::free(buffer);
	}
	return (uint)(sound3DBuff == record->sound3DBuff);
}



void __cdecl lego::snd::Sound3D_Update(void)
{
	Sound3D_SoundRecord *pSVar1;
	uint in_ECX;
	Sound3D_SoundRecord *pSVar2;
	IDirect3DRMFrame3 **lpSndBufFrame;
	uint local_4;
	
	pSVar2 = globs::sound3DGlobs.soundRecord;
	lpSndBufFrame = globs::sound3DGlobs.updateFrameList;
	local_4 = in_ECX;
	do {
										// (inlined) Sound3D_UpdateFrames();
		if (*lpSndBufFrame != NULL) {
			Sound3D_SoundCallback(*lpSndBufFrame,NULL,0.0);
		}
		lpSndBufFrame = lpSndBufFrame + 1;
	} while (lpSndBufFrame < &globs::sound3DGlobs.reserved1);
	if (pSVar2 != NULL) {
		do {
			pSVar1 = pSVar2->next;
			(*(code *)pSVar2->soundBuff->lpVtbl->GetStatus)(pSVar2->soundBuff,&local_4);
			if ((local_4 & 1) == 0) {
				Sound3D_RemoveSound(pSVar2->frame,pSVar2->sound3DBuff);
			}
			pSVar2 = pSVar1;
		} while (pSVar1 != NULL);
	}
	Sound3D_Stream_CheckPosition(FALSE);
	Sound3D_Stream_CheckPosition(1);
	return;
}



void __cdecl lego::snd::Sound3D_SoundCallback(IDirect3DRMFrame3 *tFrame,void *arg,float delay)
{
	Container_AppData *appData;
	BOOL BVar1;
	Vector3F position;
	IDirect3DRMFrame3 *rmFrame3_00;
	Sound3D_SoundFrameRecord *sndRes;
	
	rmFrame3_00 = tFrame;
	appData = (*tFrame->lpVtbl->GetAppData)(tFrame);
	sndRes = appData->soundList;
	(*rmFrame3_00->lpVtbl->GetScene)(rmFrame3_00,&tFrame);
	for (; sndRes != NULL; sndRes = sndRes->next) {
		(*rmFrame3_00->lpVtbl->GetPosition)(rmFrame3_00,tFrame,&position);
		BVar1 = Sound3D_D3DVectorEqual(&position,&sndRes->pos);
		if (BVar1 == 0) {
										// IDirectSound3DBuffer->SetPosition(this, float x, float y, float z, DWORD
										// dwApply)
			(*(code *)sndRes->sound3DBuff->lpVtbl->SetPosition)
								(sndRes->sound3DBuff,position.x,position.y,position.z,0);
			(sndRes->pos).x = position.x;
			(sndRes->pos).y = position.y;
			(sndRes->pos).z = position.z;
		}
	}
	(*tFrame->lpVtbl->Release)(tFrame);
	return;
}



void __cdecl lego::snd::Sound3D_SetMinDistForAtten(float dist)
{
	Sound3D_SoundRecord **ppSVar1;
	Sound3D_SoundRecord *pSVar2;
	
	globs::sound3DGlobs.minDistanceForAttentuation = dist;
	pSVar2 = globs::sound3DGlobs.soundRecord;
	if (globs::sound3DGlobs.soundRecord != NULL) {
		do {
			(*(code *)pSVar2->sound3DBuff->lpVtbl->SetMinDistance)(pSVar2->sound3DBuff,dist,0);
			ppSVar1 = &pSVar2->next;
			pSVar2 = *ppSVar1;
		} while (*ppSVar1 != NULL);
	}
	return;
}



void __cdecl lego::snd::Sound3D_SetMaxDist(float dist)
{
	Sound3D_SoundRecord **ppSVar1;
	Sound3D_SoundRecord *pSVar2;
	
	globs::sound3DGlobs.maxDistance = dist;
	pSVar2 = globs::sound3DGlobs.soundRecord;
	if (globs::sound3DGlobs.soundRecord != NULL) {
		do {
			(*(code *)pSVar2->sound3DBuff->lpVtbl->SetMaxDistance)(pSVar2->sound3DBuff,dist,0);
			ppSVar1 = &pSVar2->next;
			pSVar2 = *ppSVar1;
		} while (*ppSVar1 != NULL);
	}
	return;
}



void __cdecl lego::snd::Sound3D_SetGlobalVolume(int vol)
{
	BOOL BVar1;
	
	if (globs::sound3DGlobs.intialised != 0) {
		BVar1 = Sound3D_CheckVolumeLimits(vol);
		if (BVar1 != 0) {
			globs::sound3DGlobs.volume = vol;
			(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->SetVolume)(globs::sound3DGlobs.lpDSBuff,vol)
			;
		}
	}
	return;
}



void __cdecl lego::snd::Sound3D_SetGlobalVolumePrescaled(int vol_0_10)
{
	if ((-1 < vol_0_10) && (vol_0_10 < 0xb)) {
		Sound3D_SetGlobalVolume(globs::s_SetGlobalVolumePrescaled_realVol[vol_0_10]);
	}
	return;
}



void __cdecl lego::snd::Sound3D_SetVolumeToDefault(void)
{
	if (globs::sound3DGlobs.intialised != 0) {
		globs::sound3DGlobs.volume = -300;
		(*(code *)(globs::sound3DGlobs.lpDSBuff)->lpVtbl->SetVolume)(globs::sound3DGlobs.lpDSBuff,-NAN);
	}
	return;
}



BOOL __cdecl
lego::snd::Sound3D_LoadSample(Sound3D_SoundData *out_sound,char *fName,BOOL simultaneous)
{
	Sound3D_SoundData *sound;
	byte *fileData;
	byte *pbDest;
	BOOL BVar1;
	int iVar2;
	Sound3D_SoundData *pSVar3;
	uint local_2c;
	MMCKINFO local_28;
	MMCKINFO local_14;
	
	sound = out_sound;
	pSVar3 = out_sound;
	for (iVar2 = 0x4d; iVar2 != 0; iVar2 += -1) {
		*(undefined4 *)pSVar3->filename = 0;
		pSVar3 = (Sound3D_SoundData *)(pSVar3->filename + 4);
	}
	fileData = lego::file::File_LoadBinary(fName,(uint *)&fName);
	if (fileData != NULL) {
		iVar2 = WaveOpenFile(fileData,(uint)fName,(HMMIO *)&out_sound,&sound->waveFormat,&local_14);
		if (iVar2 == 0) {
			iVar2 = WaveStartDataRead((HMMIO *)&out_sound,&local_28,&local_14);
			if (iVar2 == 0) {
				pbDest = (byte *)GlobalAlloc(0,local_28.cksize);
				sound->data = pbDest;
				if (pbDest != NULL) {
					iVar2 = WaveReadFile((HMMIO)out_sound,local_28.cksize,pbDest,&local_28,&local_2c);
					if (iVar2 == 0) {
						sound->size = local_2c;
						if (out_sound != NULL) {
							mmioClose((HMMIO)out_sound,0);
							out_sound = NULL;
						}
						BVar1 = Sound3D_CreateSoundBuffer(sound);
						if (BVar1 != 0) {
							BVar1 = Sound3D_SendSoundToBuffer(sound);
							if (BVar1 != 0) {
								if (sound->data != NULL) {
									GlobalFree(sound->data);
									sound->data = NULL;
								}
								std::free(fileData);
								return 1;
							}
						}
					}
				}
			}
		}
	}
	if (sound->data != NULL) {
		GlobalFree(sound->data);
		sound->data = NULL;
	}
	return 0;
}



BOOL __cdecl lego::snd::Sound3D_CreateSoundBuffer(Sound3D_SoundData *sound)
{
	int iVar1;
	IDirectSoundBuffer **ppIVar2;
	uint uVar3;
	undefined4 local_14;
	undefined4 local_10;
	uint local_c;
	int local_8;
	WAVEFORMATEX *local_4;
	
	local_4 = sound->waveFormat;
	local_c = sound->size;
	local_8 = 0;
	local_14 = 0x14;
	local_10 = 0x200f2;
	iVar1 = (*(code *)(globs::sound3DGlobs.lpDSnd)->lpVtbl->CreateSoundBuffer)
										(globs::sound3DGlobs.lpDSnd,&local_14,sound->dSoundBuffers,0);
	if (iVar1 != 0) {
		return 0;
	}
	sound->bufferIndex = 0;
	if (local_8 != 0) {
		uVar3 = 1;
		ppIVar2 = sound->dSoundBuffers;
		do {
			ppIVar2 = ppIVar2 + 1;
			iVar1 = (*(code *)(globs::sound3DGlobs.lpDSnd)->lpVtbl->DuplicateSoundBuffer)
												(globs::sound3DGlobs.lpDSnd,sound->dSoundBuffers[0],ppIVar2);
			if (iVar1 != 0) {
				return 0;
			}
			uVar3 += 1;
		} while (uVar3 < 3);
		return TRUE;
	}
	return TRUE;
}



BOOL __cdecl lego::snd::Sound3D_SendSoundToBuffer(Sound3D_SoundData *sound)
{
	Sound3D_SoundData *pSVar1;
	int iVar2;
	uint uVar3;
	Sound3D_SoundData *pSVar4;
	undefined4 *puVar5;
	Sound3D_SoundData **ppSVar6;
	undefined4 *puVar7;
	uint uStack48;
	undefined *puStack44;
	undefined4 *puStack40;
	Sound3D_SoundData **ppSStack36;
	undefined4 *puStack32;
	undefined4 *puStack28;
	undefined4 local_c;
	undefined4 local_8;
	undefined local_4 [4];
	
	pSVar1 = sound;
	puStack32 = &local_8;
	puStack28 = NULL;
	ppSStack36 = &sound;
	puStack40 = &local_c;
	local_c = 0;
	puStack44 = local_4;
	uStack48 = sound->size;
	local_8 = 0;
	iVar2 = (*(code *)sound->dSoundBuffers[0]->lpVtbl->Lock)(sound->dSoundBuffers[0],sound->offset);
	if (iVar2 == -0x7787ff6a) {
		(*(code *)pSVar1->dSoundBuffers[0]->lpVtbl->Restore)(pSVar1->dSoundBuffers[0]);
		(*(code *)pSVar1->dSoundBuffers[0]->lpVtbl->Lock)
							(pSVar1->dSoundBuffers[0],pSVar1->offset,pSVar1->size,&puStack40,&uStack48,&puStack32,
							 &puStack44,0);
	}
	else {
		if (iVar2 != 0) {
			return 0;
		}
	}
	pSVar4 = (Sound3D_SoundData *)pSVar1->data;
	ppSVar6 = ppSStack36;
	for (uVar3 = (uint)puStack44 >> 2; uVar3 != 0; uVar3 -= 1) {
		*ppSVar6 = *(Sound3D_SoundData **)pSVar4;
		pSVar4 = (Sound3D_SoundData *)((int)pSVar4 + 4);
		ppSVar6 = ppSVar6 + 1;
	}
	for (uVar3 = (uint)puStack44 & 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)ppSVar6 = *(undefined *)pSVar4;
		pSVar4 = (Sound3D_SoundData *)((int)pSVar4 + 1);
		ppSVar6 = (Sound3D_SoundData **)((int)ppSVar6 + 1);
	}
	if (puStack28 != NULL) {
		puVar5 = (undefined4 *)(puStack44 + (int)pSVar1->data);
		puVar7 = puStack28;
		for (uVar3 = (uint)puStack40 >> 2; uVar3 != 0; uVar3 -= 1) {
			*puVar7 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar7 = puVar7 + 1;
		}
		for (uVar3 = (uint)puStack40 & 3; uVar3 != 0; uVar3 -= 1) {
			*(undefined *)puVar7 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar7 = (undefined4 *)((int)puVar7 + 1);
		}
	}
	iVar2 = (*(code *)pSVar1->dSoundBuffers[0]->lpVtbl->Unlock)
										(pSVar1->dSoundBuffers[0],ppSStack36,puStack44,puStack28,puStack40);
	if (iVar2 == 0) {
		iVar2 = (*(code *)pSVar1->dSoundBuffers[0]->lpVtbl->GetFrequency)
											(pSVar1->dSoundBuffers[0],&pSVar1->frequency);
		if (iVar2 == 0) {
			iVar2 = (*(code *)pSVar1->dSoundBuffers[0]->lpVtbl->GetVolume)
												(pSVar1->dSoundBuffers[0],&pSVar1->volume);
			return (uint)(iVar2 == 0);
		}
		return 0;
	}
	return 0;
}



float10 __cdecl lego::snd::Sound3D_GetSamplePlayTime(int handle)
{
	uint uVar1;
	
	if (handle == -1) {
		return (float10)0.0;
	}
	uVar1 = globs::sound3DGlobs.soundTable[handle].size;
	if ((*(byte *)&globs::sound3DGlobs.soundTable[handle].flags & 8) != 0) {
		return (float10)(ulonglong)uVar1 /
					 (float10)globs::sound3DGlobs.soundTable[handle].avgBytesPerSec;
	}
	return (float10)(ulonglong)uVar1 /
				 (float10)(globs::sound3DGlobs.soundTable[handle].waveFormat)->nAvgBytesPerSec;
}



BOOL __cdecl lego::snd::Sound3D_Stream_Play(char *fName,BOOL loop,int volume)
{
	BOOL BVar1;
	IDirectSoundBuffer *pIVar2;
	Sound3D_StreamData *pSVar3;
	
	pSVar3 = &globs::sound3DGlobs.loopStreamData;
	if (loop == 0) {
		pSVar3 = &globs::sound3DGlobs.streamData;
	}
	if ((pSVar3->playing != 0) || (pSVar3->fileOpen != 0)) {
		Sound3D_Stream_Stop(loop);
	}
	BVar1 = Sound3D_Stream_BufferSetup(fName,loop,volume);
	if (BVar1 != 0) {
		pIVar2 = globs::sound3DGlobs.lpDSStreamBuff;
		if (loop != 0) {
			pIVar2 = globs::sound3DGlobs.lpDSLoopStreamBuff;
		}
		(*(code *)pIVar2->lpVtbl->SetCurrentPosition)(pIVar2,0);
		pIVar2 = globs::sound3DGlobs.lpDSStreamBuff;
		if (loop != 0) {
			pIVar2 = globs::sound3DGlobs.lpDSLoopStreamBuff;
		}
										// DSBPLAY_LOOPING (0x1)
		(*(code *)pIVar2->lpVtbl->Play)(pIVar2,0,0,1);
		pSVar3->playing = 1;
		return TRUE;
	}
	pSVar3->playing = 0;
	return 0;
}



BOOL __cdecl lego::snd::Sound3D_Stream_Stop(BOOL looping)
{
	IDirectSoundBuffer *pIVar1;
	Sound3D_StreamData *pSVar2;
	
	pSVar2 = &globs::sound3DGlobs.loopStreamData;
	if (looping == 0) {
		pSVar2 = &globs::sound3DGlobs.streamData;
	}
	pSVar2->playing = 0;
	if (pSVar2->fileOpen != 0) {
		pIVar1 = globs::sound3DGlobs.lpDSStreamBuff;
		if (looping != 0) {
			pIVar1 = globs::sound3DGlobs.lpDSLoopStreamBuff;
		}
		(*(code *)pIVar1->lpVtbl->Stop)(pIVar1);
		WaveCloseReadFile(&(pSVar2->wiWave).hmmio,(WAVEFORMATEX **)&pSVar2->wiWave);
		pIVar1 = globs::sound3DGlobs.lpDSStreamBuff;
		if (looping != 0) {
			pIVar1 = globs::sound3DGlobs.lpDSLoopStreamBuff;
		}
		(*pIVar1->lpVtbl->Release)((IUnknown *)pIVar1);
		pSVar2->fileOpen = 0;
	}
	return 1;
}



BOOL __cdecl lego::snd::Sound3D_Stream_BufferSetup(char *waveFName,BOOL loop,int volume)
{
	MMCKINFO *out_pckInRIFF;
	Sound3D_WaveData *out_ppwfxInfo;
	HMMIO *out_phmmioIn;
	WAVEFORMATEX *pWVar1;
	DWORD looping;
	int iVar2;
	uint uVar3;
	Sound3D_StreamData *pSVar4;
	DSBUFFERDESC sndBuffer;
	
	pSVar4 = &globs::sound3DGlobs.loopStreamData;
	if (loop == 0) {
		pSVar4 = &globs::sound3DGlobs.streamData;
	}
	out_pckInRIFF = &(pSVar4->wiWave).mmckInRIFF;
	out_ppwfxInfo = &pSVar4->wiWave;
	out_phmmioIn = &(pSVar4->wiWave).hmmio;
	iVar2 = WaveOpenFile2(waveFName,out_phmmioIn,(WAVEFORMATEX **)out_ppwfxInfo,out_pckInRIFF);
	if (iVar2 != 0) {
		return 0;
	}
	if (out_ppwfxInfo->waveFormat->wFormatTag != WAVE_FORMAT_PCM) {
		WaveCloseReadFile(out_phmmioIn,(WAVEFORMATEX **)out_ppwfxInfo);
		return 0;
	}
	iVar2 = WaveStartDataRead(out_phmmioIn,&(pSVar4->wiWave).mmck,out_pckInRIFF);
	if (iVar2 == 0) {
		pWVar1 = out_ppwfxInfo->waveFormat;
		uVar3 = pWVar1->nSamplesPerSec * (uint)pWVar1->nBlockAlign * 3 >> 2;
		(pSVar4->wiWave).dwNotifySize = uVar3;
		uVar3 %= (uint)pWVar1->nBlockAlign;
		if (uVar3 != 0) {
			(pSVar4->wiWave).dwNotifySize = (pSVar4->wiWave).dwNotifySize + (pWVar1->nBlockAlign - uVar3);
		}
		sndBuffer.dwSize = 0x14;
		sndBuffer.dwFlags = 0x100e0;
		sndBuffer.dwBufferBytes = (pSVar4->wiWave).dwNotifySize << 2;
		sndBuffer.dwReserved = 0;
		(pSVar4->wiWave).dwBufferSize = sndBuffer.dwBufferBytes;
		sndBuffer.lpwfxFormat = out_ppwfxInfo->waveFormat;
		iVar2 = (*(code *)(globs::sound3DGlobs.lpDSnd)->lpVtbl->CreateSoundBuffer)
											(globs::sound3DGlobs.lpDSnd,&sndBuffer,&waveFName,0);
		looping = sndBuffer.dwReserved;
		if (iVar2 == 0) {
			if (sndBuffer.dwReserved == 0) {
				globs::sound3DGlobs.lpDSStreamBuff = (IDirectSoundBuffer *)sndBuffer.dwBufferBytes;
			}
			else {
				globs::sound3DGlobs.lpDSLoopStreamBuff = (IDirectSoundBuffer *)sndBuffer.dwBufferBytes;
			}
			(**(code **)(*(int *)sndBuffer.dwBufferBytes + 0x3c))
								(sndBuffer.dwBufferBytes,sndBuffer.lpwfxFormat);
			(pSVar4->wiWave).bFoundEnd = 0;
			(pSVar4->wiWave).dwNextWriteOffset = 0;
			(pSVar4->wiWave).dwNextProgressCheck = (pSVar4->wiWave).dwNotifySize << 1;
			(pSVar4->wiWave).bLoopFile = looping;
			Sound3D_Stream_FillDataBuffer(looping);
			(pSVar4->wiWave).bDonePlaying = 0;
			pSVar4->fileOpen = 1;
			return 1;
		}
		return 0;
	}
	WaveCloseReadFile(out_phmmioIn,(WAVEFORMATEX **)out_ppwfxInfo);
	return 0;
}



BOOL __cdecl lego::snd::Sound3D_Stream_FillDataBuffer(BOOL looping)
{
	MMCKINFO *pckIn;
	HMMIO *phmmioIn;
	undefined2 uVar1;
	int iVar2;
	uint uVar3;
	IDirectSoundBuffer *pIVar4;
	undefined *puVar5;
	uint uVar6;
	char cVar7;
	int unaff_EBP;
	int iVar8;
	uint *puVar9;
	undefined *puStack44;
	undefined4 uStack40;
	undefined local_14 [4];
	undefined local_10 [8];
	undefined local_8 [4];
	uint local_4;
	
	iVar8 = 0x507628;
	if (looping == 0) {
		iVar8 = 0x5075cc;
	}
	pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
	if (looping != 0) {
		pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
	}
	puStack44 = local_8;
	uStack40 = 0;
	iVar2 = (*(code *)pIVar4->lpVtbl->Lock)(pIVar4,0,*(undefined4 *)(iVar8 + 0x34),local_10);
	if (iVar2 != 0) {
		return 0;
	}
	pckIn = (MMCKINFO *)(iVar8 + 0xc);
	phmmioIn = (HMMIO *)(iVar8 + 8);
	WaveReadFile(*phmmioIn,(uint)local_14,(byte *)&local_4,pckIn,(uint *)&puStack44);
	if (puStack44 < local_14) {
		puVar5 = puStack44;
		iVar2 = unaff_EBP;
		if (*(int *)(iVar8 + 0x50) == 0) {
			if (puStack44 < *(undefined **)(iVar8 + 0x38)) {
				*(undefined4 *)(iVar8 + 0x54) = 1;
			}
			puVar5 = local_14 + -(int)puStack44;
			cVar7 = (*(short *)(*(int *)(iVar8 + 4) + 0xe) != 8) + -1;
			uVar1 = CONCAT11(cVar7,cVar7);
			uVar3 = CONCAT22(uVar1,uVar1) & 0x80808080;
			puVar9 = (uint *)((int)&local_4 + (int)puStack44);
			for (uVar6 = (uint)puVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
				*puVar9 = uVar3;
				puVar9 = puVar9 + 1;
			}
			for (uVar6 = (uint)puVar5 & 3; uVar6 != 0; uVar6 -= 1) {
				*(char *)puVar9 = (char)uVar3;
				puVar9 = (uint *)((int)puVar9 + 1);
			}
		}
		else {
			do {
				looping = iVar2;
				WaveStartDataRead(phmmioIn,pckIn,(MMCKINFO *)(iVar8 + 0x20));
				WaveReadFile(*phmmioIn,(uint)(local_14 + -(int)puVar5),puVar5 + (int)&local_4,pckIn,
										 (uint *)&puStack44);
				puVar5 = puVar5 + (int)puStack44;
				iVar2 = looping;
			} while (puVar5 < local_14);
		}
	}
	pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
	if (looping != 0) {
		pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
	}
	iVar2 = 0;
	(*(code *)pIVar4->lpVtbl->Unlock)(pIVar4,&local_4,local_14,0);
	uVar3 = *(uint *)(iVar8 + 0x34);
	uVar6 = *(int *)(iVar8 + 0x3c) + iVar2;
	*(uint *)(iVar8 + 0x3c) = uVar6;
	if (uVar3 <= uVar6) {
		*(uint *)(iVar8 + 0x3c) = uVar6 - uVar3;
		uVar6 = uVar3;
	}
	*(undefined4 *)(iVar8 + 0x40) = 0;
	*(undefined4 *)(iVar8 + 0x48) = 0;
	return uVar6;
}



void __cdecl lego::snd::Sound3D_Stream_CheckPosition(BOOL looping)
{
	MMCKINFO *pckIn;
	HMMIO *phmmioIn;
	byte bVar1;
	void *pvVar2;
	HRESULT HVar3;
	IDirectSoundBuffer *pIVar4;
	uint uVar5;
	uint unaff_EBX;
	uint *unaff_EBP;
	uint unaff_ESI;
	Sound3D_StreamData *pSVar6;
	uint uVar7;
	uint *puVar8;
	DWORD local_18;
	void *local_14;
	undefined4 local_10;
	uint local_c;
	int local_8;
	DWORD local_4;
	
	pSVar6 = &globs::sound3DGlobs.loopStreamData;
	if (looping == 0) {
		pSVar6 = &globs::sound3DGlobs.streamData;
	}
	if ((pSVar6->playing != 0) && (pSVar6->fileOpen != 0)) {
		pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
		if (looping != 0) {
			pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
		}
										// IDirectSoundBuffer->GetCurrentPosition(this, DWORD* pdwCurrentPlayCursor,
										// DWORD* pdwCurrentWriteCursor)
		(*(code *)pIVar4->lpVtbl->GetCurrentPosition)(pIVar4,&local_c,&local_4);
		uVar7 = (pSVar6->wiWave).dwLastPos;
		uVar5 = local_c;
		if (local_c < uVar7) {
			uVar5 = (pSVar6->wiWave).dwBufferSize + local_c;
		}
		uVar7 = (pSVar6->wiWave).dwProgress + (uVar5 - uVar7);
		(pSVar6->wiWave).dwLastPos = local_c;
		(pSVar6->wiWave).dwProgress = uVar7;
		pvVar2 = NULL;
		if ((pSVar6->wiWave).dwNextProgressCheck < uVar7) {
			while ((local_10 = 0, (pSVar6->wiWave).bDonePlaying == 0 || (pvVar2 != NULL))) {
				local_8 = 1;
				if ((pSVar6->wiWave).bFoundEnd == 0) {
					pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
					if (looping != 0) {
						pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
					}
										// IDirectSoundBuffer->Lock(this, DWORD dwOffset, DWORD dwBytes, void**
										// ppvAudioPtr1, DWORD* pdwAudioBytes1)
					HVar3 = (*(code *)pIVar4->lpVtbl->Lock)
														(pIVar4,(pSVar6->wiWave).dwNextWriteOffset,(pSVar6->wiWave).dwNotifySize
														 ,&local_14,&local_18);
					if (HVar3 != 0) {
						return;
					}
					pckIn = &(pSVar6->wiWave).mmck;
					phmmioIn = &(pSVar6->wiWave).hmmio;
					WaveReadFile(*phmmioIn,unaff_ESI,(byte *)unaff_EBP,pckIn,(uint *)&stack0xffffffe4);
					uVar7 = unaff_EBX;
					if (unaff_EBX < unaff_ESI) {
						if ((pSVar6->wiWave).bLoopFile == 0) {
							(pSVar6->wiWave).bFoundEnd = 1;
							bVar1 = (((pSVar6->wiWave).waveFormat)->wBitsPerSample != 8) - 1;
							puVar8 = (uint *)(unaff_EBX + (int)unaff_EBP);
							for (uVar5 = unaff_ESI - unaff_EBX >> 2; uVar5 != 0; uVar5 -= 1) {
								*puVar8 = CONCAT22(CONCAT11(bVar1,bVar1),CONCAT11(bVar1,bVar1)) & 0x80808080;
								puVar8 = puVar8 + 1;
							}
							for (uVar5 = unaff_ESI - unaff_EBX & 3; uVar5 != 0; uVar5 -= 1) {
								*(byte *)puVar8 = bVar1 & 0x80;
								puVar8 = (uint *)((int)puVar8 + 1);
							}
						}
						else {
							do {
								WaveStartDataRead(phmmioIn,pckIn,&(pSVar6->wiWave).mmckInRIFF);
								WaveReadFile(*phmmioIn,unaff_ESI - unaff_EBX,(byte *)(unaff_EBX + (int)unaff_EBP),
														 pckIn,(uint *)&stack0xffffffe4);
								unaff_EBX += uVar7;
							} while (unaff_EBX < unaff_ESI);
						}
					}
					unaff_EBX = uVar7;
					pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
					if (local_8 != 0) {
						pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
					}
										// IDirectSoundBuffer->Unlock(this, void* pvAudioPtr1, DWORD dwAudioBytes1,
										// void* pvAudioPtr2, DWORD dwAudioBytes2)
					(*(code *)pIVar4->lpVtbl->Unlock)(pIVar4,unaff_EBP,unaff_ESI,NULL,0);
					uVar5 = (pSVar6->wiWave).dwNextWriteOffset + unaff_ESI;
					uVar7 = (pSVar6->wiWave).dwBufferSize;
					(pSVar6->wiWave).dwNextWriteOffset = uVar5;
					(pSVar6->wiWave).dwNextProgressCheck = (pSVar6->wiWave).dwNextProgressCheck + unaff_ESI;
					looping = local_8;
					if (uVar7 <= uVar5) {
						(pSVar6->wiWave).dwNextWriteOffset = uVar5 - uVar7;
					}
				}
				else {
					pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
					if (looping != 0) {
						pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
					}
					(*(code *)pIVar4->lpVtbl->Lock)
										(pIVar4,(pSVar6->wiWave).dwNextWriteOffset,(pSVar6->wiWave).dwNotifySize,
										 &local_14,&local_18);
					bVar1 = (((pSVar6->wiWave).waveFormat)->wBitsPerSample != 8) - 1;
					puVar8 = unaff_EBP;
					for (uVar7 = unaff_ESI >> 2; uVar7 != 0; uVar7 -= 1) {
						*puVar8 = CONCAT22(CONCAT11(bVar1,bVar1),CONCAT11(bVar1,bVar1)) & 0x80808080;
						puVar8 = puVar8 + 1;
					}
					for (uVar7 = unaff_ESI & 3; uVar7 != 0; uVar7 -= 1) {
						*(byte *)puVar8 = bVar1 & 0x80;
						puVar8 = (uint *)((int)puVar8 + 1);
					}
					pIVar4 = globs::sound3DGlobs.lpDSStreamBuff;
					if (looping != 0) {
						pIVar4 = globs::sound3DGlobs.lpDSLoopStreamBuff;
					}
					(*(code *)pIVar4->lpVtbl->Unlock)(pIVar4,unaff_EBP,unaff_ESI,NULL,0);
					uVar7 = (pSVar6->wiWave).mmckInRIFF.cksize;
					uVar5 = (pSVar6->wiWave).dwNotifySize;
					if (((uVar5 < uVar7) && (uVar7 - uVar5 <= (pSVar6->wiWave).dwProgress)) ||
						 (uVar7 <= (pSVar6->wiWave).dwProgress)) {
						(pSVar6->wiWave).bDonePlaying = 1;
					}
					(pSVar6->wiWave).dwNextProgressCheck = (pSVar6->wiWave).dwNextProgressCheck + unaff_ESI;
				}
				pvVar2 = local_14;
				if ((pSVar6->wiWave).dwProgress <= (pSVar6->wiWave).dwNextProgressCheck) {
					return;
				}
			}
			Sound3D_Stream_Stop(looping);
		}
	}
	return;
}



// return (a.x == b.x) && (a.y == b.y) && (a.z == b.z)

BOOL __cdecl lego::snd::Sound3D_D3DVectorEqual(Vector3F *a,Vector3F *b)
{
	if (((a->x == b->x) && (a->y == b->y)) && (a->z == b->z)) {
		return 1;
	}
	return 0;
}



float10 __cdecl lego::snd::Sound3D_SetRollOffFactor(float rollOff)
{
	if (globs::sound3DGlobs.intialised != 0) {
		if (rollOff < 0.0) {
			rollOff = 0.0;
		}
		if ((ushort)((ushort)(rollOff < 10.0) << 8 | (ushort)(rollOff == 10.0) << 0xe) == 0) {
			rollOff = 10.0;
		}
		(*(code *)(globs::sound3DGlobs.lp3DListenerInfo)->lpVtbl->SetRolloffFactor)
							(globs::sound3DGlobs.lp3DListenerInfo,rollOff,0);
	}
	return (float10)rollOff;
}



int __cdecl lego::snd::Sound3D_MinVolume(void)
{
	return -10000;
}



void __cdecl lego::ddraw::DirectDraw_Initialise(HWND hWnd)
{
	globs::directDrawGlobs.hWnd = hWnd;
	globs::directDrawGlobs.lpDirectDraw = NULL;
	globs::directDrawGlobs.fSurf = NULL;
	globs::directDrawGlobs.bSurf = NULL;
	globs::directDrawGlobs.zSurf = NULL;
	globs::directDrawGlobs.lpFrontClipper = NULL;
	globs::directDrawGlobs.driverList = NULL;
	globs::directDrawGlobs.deviceList = NULL;
	globs::directDrawGlobs.modeList = NULL;
	globs::directDrawGlobs.driverCount = 0;
	globs::directDrawGlobs.deviceCount = 0;
	globs::directDrawGlobs.modeCount = 0;
	return;
}



BOOL __cdecl lego::ddraw::DirectDraw_EnumDrivers(DirectDraw_Driver *ref_list,uint *out_count)
{
	globs::directDrawGlobs.driverList = ref_list;
	DirectDrawEnumerateA(DirectDraw_EnumDriverCallback,NULL);
	*out_count = globs::directDrawGlobs.driverCount;
	return 1;
}



BOOL lego::ddraw::DirectDraw_EnumDriverCallback
							 (LPGUID lpGUID,LPSTR lpDriverDescription,LPSTR lpDriverName,LPVOID lpContext)
{
	DirectDraw_Driver *pDVar1;
	
	globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].flags =
			 DIRECTDRAW_FLAG_DRIVER_VALID;
	if (lpGUID == NULL) {
		globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].flags =
				 globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].flags |
				 DIRECTDRAW_FLAG_DRIVER_PRIMARY;
		globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].flags =
				 globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].flags |
				 DIRECTDRAW_FLAG_DRIVER_WINDOWOK;
	}
	else {
		pDVar1 = globs::directDrawGlobs.driverList + globs::directDrawGlobs.driverCount;
		(pDVar1->guid).Data1 = lpGUID->Data1;
		*(undefined4 *)&(pDVar1->guid).Data2 = *(undefined4 *)&lpGUID->Data2;
		*(undefined4 *)(pDVar1->guid).Data4 = *(undefined4 *)lpGUID->Data4;
		*(undefined4 *)((pDVar1->guid).Data4 + 4) = *(undefined4 *)(lpGUID->Data4 + 4);
	}
	std::sprintf(globs::directDrawGlobs.driverList[globs::directDrawGlobs.driverCount].desc,"%s (%s)",
							 lpDriverDescription,lpDriverName);
	globs::directDrawGlobs.driverCount = globs::directDrawGlobs.driverCount + 1;
	return 1;
}



BOOL __cdecl
lego::ddraw::DirectDraw_EnumDevices
					(DirectDraw_Driver *driver,DirectDraw_Device *ref_list,uint *out_count)
{
	HRESULT HVar1;
	uint uVar2;
	GUID *pGVar3;
	IUnknown *local_8;
	DirectDraw_Device *local_4;
	
	uVar2 = 0;
	globs::directDrawGlobs.deviceCount = 0;
	HVar1 = DirectDrawCreate((LPGUID)driver,(IDirectDraw **)&local_4,NULL);
	if (HVar1 == 0) {
		HVar1 = (**(code **)(local_4->guid).Data1)
											((IUnknown *)local_4,(IID *)&idl::IID_IDirectDraw4,&local_8);
		if (HVar1 == 0) {
			pGVar3 = &idl::IID_IDirect3D3;
			HVar1 = (*local_8->lpVtbl->QueryInterface)(local_8,(IID *)&idl::IID_IDirect3D3,&driver);
			if (HVar1 == 0) {
				globs::directDrawGlobs.deviceList = local_4;
				(*local_8->lpVtbl[1].QueryInterface)(local_8,(IID *)DirectDraw_EnumDeviceCallback,NULL);
				(**(code **)(*(int *)pGVar3 + 8))(pGVar3);
			}
			uVar2 = (uint)(HVar1 == 0);
			(**(code **)(*(int *)pGVar3 + 8))(pGVar3);
		}
		(**(code **)((local_4->guid).Data1 + 8))(local_4);
	}
	*out_count = globs::directDrawGlobs.deviceCount;
	return uVar2;
}



HRESULT lego::ddraw::DirectDraw_EnumDeviceCallback
									(LPGUID lpGuid,LPSTR lpDeviceDescription,LPSTR lpDeviceName,
									D3DDEVICEDESC_V1 *lpHWDesc,D3DDEVICEDESC_V1 *lpHELDesc,LPVOID lpContext)
{
	DirectDraw_Device *pDVar1;
	DirectDraw_DeviceFlags DVar2;
	
	pDVar1 = globs::directDrawGlobs.deviceList + globs::directDrawGlobs.deviceCount;
	pDVar1->flags = DIRECTDRAW_FLAG_DEVICE_VALID;
	if (lpHWDesc->dcmColorModel != 0) {
		pDVar1->flags = DIRECTDRAW_FLAG_DEVICE_VALID|DIRECTDRAW_FLAG_DEVICE_HARDWARE;
		lpHELDesc = lpHWDesc;
	}
										// D3DDD_COLORMODEL (0x1) and D3DCOLOR_RGB (0x2)
	if (((*(byte *)&lpHELDesc->dwFlags & 1) != 0) && (lpHELDesc->dcmColorModel == 2)) {
		pDVar1->flags = pDVar1->flags | DIRECTDRAW_FLAG_DEVICE_COLOUR;
	}
										// D3DDD_DEVICERENDERBITDEPTH (0x80)
	if ((*(byte *)&lpHELDesc->dwFlags & 0x80) != 0) {
										// <https://github.com/github/VisualStudio/blob/263aac11f57d53c5f9fe64ba9916f77c058974d7/tools/Debugging%20Tools%20for%20Windows/winext/manifest/ddraw.h#L1421>
										// DDBD_8 (0x800) 8 bpp
		if ((lpHELDesc->dwDeviceRenderBitDepth & 0x800) != 0) {
			pDVar1->flags = pDVar1->flags | DIRECTDRAW_FLAG_DEVICE_DEPTH8;
		}
										// DDBD_16 (0x400) 16 bpp
		if ((lpHELDesc->dwDeviceRenderBitDepth & 0x400) != 0) {
			pDVar1->flags = pDVar1->flags | DIRECTDRAW_FLAG_DEVICE_DEPTH16;
		}
										// DDBD_24 (0x200) 24 bpp
		if ((lpHELDesc->dwDeviceRenderBitDepth & 0x200) != 0) {
			pDVar1->flags = pDVar1->flags | DIRECTDRAW_FLAG_DEVICE_DEPTH24;
		}
										// DDBD_32 (0x100) 32 bpp
		if ((lpHELDesc->dwDeviceRenderBitDepth & 0x100) != 0) {
			pDVar1->flags = pDVar1->flags | DIRECTDRAW_FLAG_DEVICE_DEPTH32;
		}
	}
										// D3DDD_DEVCAPS (0x2)
	if ((*(byte *)&lpHELDesc->dwFlags & 2) != 0) {
										// D3DDEVCAPS_TEXTUREVIDEOMEMORY (0x200)
		if ((lpHELDesc->dwDevCaps & 0x200) == 0) {
										// D3DDEVCAPS_TEXTURESYSTEMMEMORY (0x100)
			if ((lpHELDesc->dwDevCaps & 0x100) == 0) goto LAB_0047c71d;
			DVar2 = pDVar1->flags | DIRECTDRAW_FLAG_DEVICE_SYSTEMTEXTURE;
		}
		else {
			DVar2 = pDVar1->flags | DIRECTDRAW_FLAG_DEVICE_VIDEOTEXTURE;
		}
		pDVar1->flags = DVar2;
	}
LAB_0047c71d:
	(pDVar1->guid).Data1 = lpGuid->Data1;
	*(undefined4 *)&(pDVar1->guid).Data2 = *(undefined4 *)&lpGuid->Data2;
	*(undefined4 *)(pDVar1->guid).Data4 = *(undefined4 *)lpGuid->Data4;
	*(undefined4 *)((pDVar1->guid).Data4 + 4) = *(undefined4 *)(lpGuid->Data4 + 4);
	std::sprintf(pDVar1->desc,"%s (%s)",lpDeviceName,lpDeviceDescription);
										// DIENUM_CONTINUE (0x1)
	globs::directDrawGlobs.deviceCount = globs::directDrawGlobs.deviceCount + 1;
	return 1;
}



BOOL __cdecl
lego::ddraw::DirectDraw_EnumModes
					(DirectDraw_Driver *driver,BOOL fullScreen,DirectDraw_Mode *ref_list,uint *out_count)
{
	HRESULT HVar1;
	uint uVar2;
	IDirectDraw *ddraw1;
	
	uVar2 = 0;
	globs::directDrawGlobs.modeCount = 0;
	if ((driver != NULL) &&
		 ((driver->flags & DIRECTDRAW_FLAG_DRIVER_VALID) != DIRECTDRAW_FLAG_DRIVER_NONE)) {
		HVar1 = DirectDrawCreate((LPGUID)(~-(uint)((driver->flags & DIRECTDRAW_FLAG_DRIVER_PRIMARY) !=
																							DIRECTDRAW_FLAG_DRIVER_NONE) & (uint)driver),&ddraw1,
														 NULL);
		if (HVar1 == 0) {
			HVar1 = (*ddraw1->lpVtbl->QueryInterface)
												(ddraw1,&idl::IID_IDirectDraw4,(IDirectDraw4 **)&driver);
			if (HVar1 == 0) {
				globs::directDrawGlobs.modeList = ref_list;
										// IDirectDraw4->EnumDisplayModes(this, DWORD dwFlags, DDSURFACEDESC2*
										// lpDDSurfaceDesc, void* lpContext, DDENUMMODESCALLBACK2* lpEnumModesCallback)
				(**(code **)((driver->guid).Data1 + 0x20))
									((IDirectDraw4 *)driver,0,NULL,&fullScreen,DirectDraw_EnumModeCallback);
				(**(code **)((driver->guid).Data1 + 8))((IDirectDraw4 *)driver);
			}
			uVar2 = (uint)(HVar1 == 0);
			(*ddraw1->lpVtbl->Release)(ddraw1);
		}
	}
	*out_count = globs::directDrawGlobs.modeCount;
	return uVar2;
}



HRESULT lego::ddraw::DirectDraw_EnumModeCallback(DDSURFACEDESC2 *lpDDSurfaceDesc,LPVOID lpContext)
{
	uint uVar1;
	DirectDraw_Mode *pDVar2;
	
	pDVar2 = globs::directDrawGlobs.modeList + globs::directDrawGlobs.modeCount;
	pDVar2->flags = DIRECTDRAW_FLAG_MODE_VALID;
	pDVar2->width = lpDDSurfaceDesc->dwWidth;
	pDVar2->height = lpDDSurfaceDesc->dwHeight;
	pDVar2->bitDepth = (lpDDSurfaceDesc->ddpfPixelFormat).dwRGBBitCount;
										// WARNING: Load size is inaccurate
										// lpContext (BOOL* isFullScreen)
	if (*lpContext == 0) {
		std::sprintf(pDVar2->desc,"%ix%i",lpDDSurfaceDesc->dwWidth,lpDDSurfaceDesc->dwHeight);
	}
	else {
		std::sprintf(pDVar2->desc,"%ix%i (%i bit)",lpDDSurfaceDesc->dwWidth,lpDDSurfaceDesc->dwHeight,
								 (lpDDSurfaceDesc->ddpfPixelFormat).dwRGBBitCount);
	}
										// WARNING: Load size is inaccurate
										// lpContext (BOOL* isFullScreen)
	if ((*lpContext == 0) && (globs::directDrawGlobs.modeCount != 0)) {
		uVar1 = main::Main_GetWindowsBitDepth();
		if (pDVar2->bitDepth != uVar1) {
										// Bit depth doesn't match system, we can't use this in windowed
			pDVar2->flags = pDVar2->flags & 0xfffffffe;
										// DDENUMRET_OK (0x1)
										// skip incrementing COUNT and return
			return 1;
		}
	}
										// DDENUMRET_OK (0x1)
	globs::directDrawGlobs.modeCount = globs::directDrawGlobs.modeCount + 1;
	return 1;
}



BOOL __cdecl
lego::ddraw::DirectDraw_Setup
					(BOOL fullscreen,DirectDraw_Driver *driver,DirectDraw_Device *device,
					DirectDraw_Mode *screen,uint xPos,uint yPos,uint width,uint height)
{
	HRESULT HVar1;
	int iVar2;
	BOOL BVar3;
	LPGUID lpGUID;
	DDSURFACEDESC2 *pDVar4;
	IDirectDraw *ddraw1;
	uint dwBPP;
	DDSCAPS2 caps;
	DDSURFACEDESC2 surf;
	
	lpGUID = NULL;
	dwBPP = 0x10;
	if ((driver != NULL) && ((*(byte *)&driver->flags & DIRECTDRAW_FLAG_DRIVER_VALID) == 0)) {
		driver = NULL;
	}
	if ((device != NULL) && ((*(byte *)&device->flags & DIRECTDRAW_FLAG_DEVICE_VALID) == 0)) {
		device = NULL;
	}
	if (screen != NULL) {
		if ((*(byte *)&screen->flags & DIRECTDRAW_FLAG_MODE_VALID) == 0) {
			screen = NULL;
		}
		if (screen != NULL) {
			width = screen->width;
			height = screen->height;
			dwBPP = screen->bitDepth;
		}
	}
	globs::directDrawGlobs.fullScreen = fullscreen;
	if (driver != NULL) {
		lpGUID = (LPGUID)(~-(uint)((driver->flags & DIRECTDRAW_FLAG_DRIVER_PRIMARY) !=
															DIRECTDRAW_FLAG_DRIVER_NONE) & (uint)driver);
	}
	globs::directDrawGlobs.width = width;
	globs::directDrawGlobs.height = height;
	main::Main_SetupDisplay(fullscreen,xPos,yPos,width,height);
	HVar1 = DirectDrawCreate(lpGUID,&ddraw1,NULL);
	if (HVar1 == 0) {
		HVar1 = (*ddraw1->lpVtbl->QueryInterface)
											(ddraw1,&idl::IID_IDirectDraw4,&globs::directDrawGlobs.lpDirectDraw);
		if (HVar1 == 0) {
										// IDirectDraw4->SetCooperativeLevel(this, HWND hWnd, DWORD dwFlags)
										// 
										// FullScreen = DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN (0x11)
										// Windowed   = DDSCL_NORMAL (0x8)
			HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->SetCooperativeLevel)
												(globs::directDrawGlobs.lpDirectDraw,globs::directDrawGlobs.hWnd,
												 (-(uint)(fullscreen != 0) & 9) + 8);
			if (HVar1 == 0) {
				if (fullscreen == 0) {
					iVar2 = 0;
				}
				else {
										// IDirectDraw4->SetDisplayMode(this, DWORD dwWidth, DWORD dwHeight, DWORD
										// dwBPP, DWORD dwRefreshRate, DWORD dwFlags)
					iVar2 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->SetDisplayMode)
														(globs::directDrawGlobs.lpDirectDraw,width,height,dwBPP,0,0);
				}
				if (iVar2 == 0) {
					pDVar4 = &surf;
					for (iVar2 = 0x1f; iVar2 != 0; iVar2 += -1) {
						pDVar4->dwSize = 0;
						pDVar4 = (DDSURFACEDESC2 *)&pDVar4->dwFlags;
					}
					surf.dwSize = 0x7c;
					surf.dwFlags = 1;
					surf.ddsCaps.dwCaps = 0x2200;
					if (fullscreen != 0) {
						surf.dwFlags = 0x21;
						surf.dwBackBufferCount_Depth = 1;
						surf.ddsCaps.dwCaps = 0x2218;
					}
										// IDirectDraw4->CreateSurface(this, DDSURFACEDESC2* lpDDSurfaceDesc,
										// IDirectDrawSurface4** lplpDDSurface, IUnknown* pUnkOuter)
					HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
														(globs::directDrawGlobs.lpDirectDraw,&surf,&globs::directDrawGlobs.fSurf
														 ,NULL);
					if (HVar1 == 0) {
						if (fullscreen == 0) {
							surf.ddsCaps.dwCaps = surf.ddsCaps.dwCaps & 0xfffffdff | 0x40;
							surf.dwFlags |= 6;
										// IDirectDraw4->CreateSurface(this, DDSURFACEDESC2* lpDDSurfaceDesc,
										// IDirectDrawSurface4** lplpDDSurface, IUnknown* pUnkOuter)
							surf.dwHeight = height;
							surf.dwWidth = width;
							iVar2 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
																(globs::directDrawGlobs.lpDirectDraw,&surf,
																 &globs::directDrawGlobs.bSurf,NULL);
						}
						else {
							caps.dwCaps = 4;
							caps.dwCaps2 = 0;
							caps.dwCaps3 = 0;
							caps.dwCaps4_VolumeDepth = 0;
										// IDirectDrawSurface4->GetAttachedSurface(this, DDSCAPS2* lpDDSCaps,
										// IDirectDrawSurface4** lplpDDAttachedSurface)
							iVar2 = (*(globs::directDrawGlobs.fSurf)->lpVtbl->GetAttachedSurface)
																(globs::directDrawGlobs.fSurf,&caps,&globs::directDrawGlobs.bSurf);
						}
						if (iVar2 == 0) {
							BVar3 = DirectDraw_CreateClipper(fullscreen,width,height);
							if ((BVar3 != 0) &&
								 (BVar3 = main::Main_SetupDirect3D
																		(device,ddraw1,globs::directDrawGlobs.bSurf,fullscreen),
								 BVar3 != 0)) {
								(*ddraw1->lpVtbl->Release)(ddraw1);
								if (fullscreen != 0) {
									ShowCursor(0);
								}
								return 1;
							}
							(*(globs::directDrawGlobs.bSurf)->lpVtbl->Release)(globs::directDrawGlobs.bSurf);
							globs::directDrawGlobs.bSurf = NULL;
						}
						(*(globs::directDrawGlobs.fSurf)->lpVtbl->Release)(globs::directDrawGlobs.fSurf);
						globs::directDrawGlobs.fSurf = NULL;
					}
				}
			}
			(*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->Release)(globs::directDrawGlobs.lpDirectDraw)
			;
			globs::directDrawGlobs.lpDirectDraw = NULL;
		}
		(*ddraw1->lpVtbl->Release)(ddraw1);
	}
	return 0;
}



void __cdecl lego::ddraw::DirectDraw_Flip(void)
{
	if (globs::directDrawGlobs.fullScreen != 0) {
										// DDFLIP_WAIT (0x1)
		(*(globs::directDrawGlobs.fSurf)->lpVtbl->Flip)(globs::directDrawGlobs.fSurf,NULL,1);
		return;
	}
	DirectDraw_BlitBuffers();
	return;
}



BOOL __cdecl lego::ddraw::DirectDraw_SaveBMP(IDirectDrawSurface4 *surface,char *fname)
{
	uint uVar1;
	char cVar2;
	char cVar3;
	File *f;
	HRESULT HVar4;
	undefined4 *puVar5;
	int iVar6;
	uint uVar7;
	int iVar8;
	byte bVar9;
	BOOL BVar10;
	DDSURFACEDESC2 *pDVar11;
	uint length;
	undefined4 *puVar12;
	int local_e8;
	uint local_d8;
	undefined uStack180;
	undefined auStack179 [9];
	undefined4 local_aa;
	undefined4 local_a6;
	uint local_a2;
	uint local_9e;
	undefined2 local_9a;
	undefined2 uStack152;
	undefined4 local_96;
	undefined4 local_92;
	undefined4 local_8e;
	undefined4 local_8a;
	undefined4 local_86;
	undefined4 uStack130;
	DDSURFACEDESC2 local_7c;
	
	bVar9 = 0;
	uStack180 = 0;
	BVar10 = 0;
	puVar5 = (undefined4 *)auStack179;
	for (iVar6 = 0xd; iVar6 != 0; iVar6 += -1) {
		*puVar5 = 0;
		puVar5 = puVar5 + 1;
	}
	*(undefined *)puVar5 = 0;
	cVar3 = '\0';
	cVar2 = '\0';
	f = lego::file::File_Open(fname,"wb");
	if (f != NULL) {
		pDVar11 = &local_7c;
		for (iVar6 = 0x1f; iVar6 != 0; iVar6 += -1) {
			pDVar11->dwSize = 0;
			pDVar11 = (DDSURFACEDESC2 *)&pDVar11->dwFlags;
		}
		local_7c.dwSize = 0x7c;
		HVar4 = (*surface->lpVtbl->Lock)(surface,NULL,&local_7c,1,NULL);
		if (HVar4 == 0) {
			iVar6 = (-(uint)((local_7c.dwWidth * 3 & 3) != 0) & 4) + (local_7c.dwWidth * 3 & 0xfffffffc);
			length = iVar6 * local_7c.dwHeight;
			puVar5 = (undefined4 *)std::malloc(length);
			if (puVar5 != NULL) {
				puVar12 = puVar5;
				for (uVar7 = length >> 2; uVar7 != 0; uVar7 -= 1) {
					*puVar12 = 0;
					puVar12 = puVar12 + 1;
				}
				for (iVar8 = 0; iVar8 != 0; iVar8 += -1) {
					*(undefined *)puVar12 = 0;
					puVar12 = (undefined4 *)((int)puVar12 + 1);
				}
				uVar7 = 0;
				do {
					if ((local_7c.ddpfPixelFormat.dwRBitMask >> ((byte)uVar7 & 0x1f) & 1) != 0) {
						cVar3 += '\x01';
					}
					uVar7 += 1;
				} while (uVar7 < 0x20);
				uVar7 = 0;
				do {
					if ((local_7c.ddpfPixelFormat.dwGBitMask >> ((byte)uVar7 & 0x1f) & 1) != 0) {
						cVar2 += '\x01';
					}
					uVar7 += 1;
				} while (uVar7 < 0x20);
				uVar7 = 0;
				do {
					if ((local_7c.ddpfPixelFormat.dwBBitMask >> ((byte)uVar7 & 0x1f) & 1) != 0) {
						bVar9 += 1;
					}
					uVar7 += 1;
				} while (uVar7 < 0x20);
				uVar7 = 0;
				if (local_7c.dwHeight != 0) {
					do {
						iVar8 = 0;
						local_d8 = 0;
						if (local_7c.dwWidth != 0) {
							local_e8 = 0;
							do {
								iVar8 += 3;
								uVar1 = *(uint *)((int)local_7c.lpSurface + local_e8 + uVar7 * local_7c.lPitch);
								*(char *)((int)puVar5 + iVar8 + ((local_7c.dwHeight - uVar7) + -1) * iVar6 + -1) =
										 (char)(uVar1 >> (bVar9 + cVar2 & 0x1f)) << (8U - cVar3 & 0x1f);
								*(char *)((int)puVar5 + iVar8 + ((local_7c.dwHeight - uVar7) + -1) * iVar6 + -2) =
										 (char)(uVar1 >> (bVar9 & 0x1f)) << (8U - cVar2 & 0x1f);
								*(char *)((int)puVar5 + iVar8 + ((local_7c.dwHeight - uVar7) + -1) * iVar6 + -3) =
										 (char)uVar1 << (8 - bVar9 & 0x1f);
								local_e8 += local_7c.ddpfPixelFormat.dwRGBBitCount >> 3;
								local_d8 += 1;
							} while (local_d8 < local_7c.dwWidth);
						}
						uVar7 += 1;
					} while (uVar7 < local_7c.dwHeight);
				}
				BVar10 = 1;
			}
			(*surface->lpVtbl->Unlock)(surface,NULL);
			auStack179._1_4_ = length + 0x36;
			uStack180 = 0x42;
			auStack179[0] = 0x4d;
			local_aa = 0x36;
			local_a6 = 0x28;
			local_a2 = local_7c.dwWidth;
			local_9e = local_7c.dwHeight;
			local_9a = 1;
			uStack152 = 0x18;
			local_96 = 0;
			local_92 = 0;
			local_8e = 1;
			local_8a = 1;
			local_86 = 0;
			uStack130 = 0;
			if (BVar10 != 0) {
				lego::file::File_Write(&uStack180,0x36,1,f);
				lego::file::File_Write(puVar5,length,1,f);
			}
			std::free(puVar5);
		}
		lego::file::File_Close(f);
	}
	return BVar10;
}



void __cdecl lego::ddraw::DirectDraw_ReturnFrontBuffer(void)
{
	if (globs::directDrawGlobs.fullScreen != 0) {
										// DDBLT_WAIT (0x1000000)
		(*(globs::directDrawGlobs.bSurf)->lpVtbl->Blt)
							(globs::directDrawGlobs.bSurf,NULL,globs::directDrawGlobs.fSurf,NULL,0x1000000,NULL);
	}
	return;
}



void __cdecl lego::ddraw::DirectDraw_BlitBuffers(void)
{
	POINT ptClient;
	RECT dstRect;
	RECT srcRect;
	
	dstRect.right = globs::directDrawGlobs.width;
	ptClient.y = 0;
	ptClient.x = 0;
	dstRect.left = 0;
	dstRect.top = 0;
	dstRect.bottom = globs::directDrawGlobs.height;
	ClientToScreen(globs::directDrawGlobs.hWnd,(LPPOINT)&ptClient);
	OffsetRect((LPRECT)&dstRect,ptClient.x,ptClient.y);
	srcRect.bottom = globs::directDrawGlobs.height;
	srcRect.left = 0;
	srcRect.top = 0;
	srcRect.right = globs::directDrawGlobs.width;
										// DDBLT_WAIT (0x1000000)
	(*(globs::directDrawGlobs.fSurf)->lpVtbl->Blt)
						(globs::directDrawGlobs.fSurf,(LPRECT)&dstRect,globs::directDrawGlobs.bSurf,
						 (LPRECT)&srcRect,0x1000000,NULL);
	return;
}



void __cdecl lego::ddraw::DirectDraw_Shutdown(void)
{
	if (globs::directDrawGlobs.fSurf != NULL) {
		(*(globs::directDrawGlobs.fSurf)->lpVtbl->Release)((IUnknown *)globs::directDrawGlobs.fSurf);
	}
	if (globs::directDrawGlobs.lpFrontClipper != NULL) {
		(*(globs::directDrawGlobs.lpFrontClipper)->lpVtbl->Release)
							((IUnknown *)globs::directDrawGlobs.lpFrontClipper);
	}
	if (globs::directDrawGlobs.lpBackClipper != NULL) {
		(*(globs::directDrawGlobs.lpBackClipper)->lpVtbl->Release)
							((IUnknown *)globs::directDrawGlobs.lpBackClipper);
	}
	if (globs::directDrawGlobs.lpDirectDraw != NULL) {
		if (globs::directDrawGlobs.fullScreen != 0) {
			(*(code *)(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->RestoreDisplayMode)
								(globs::directDrawGlobs.lpDirectDraw);
		}
		if (globs::directDrawGlobs.lpDirectDraw != NULL) {
			(*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->Release)
								((IUnknown *)globs::directDrawGlobs.lpDirectDraw);
		}
	}
	return;
}



void __cdecl lego::ddraw::DirectDraw_AdjustTextureUsage(uint *ref_textureUsage)
{
	HRESULT HVar1;
	int iVar2;
	uint unaff_EDI;
	DDPIXELFORMAT *pDVar3;
	DDPIXELFORMAT pixFmt;
	
	pDVar3 = &pixFmt;
	for (iVar2 = 8; iVar2 != 0; iVar2 += -1) {
		*(undefined4 *)pDVar3 = 0;
		pDVar3 = (DDPIXELFORMAT *)((int)pDVar3 + 4);
	}
	pixFmt.dwSize = 0x20;
										// DDBD_8 (0x800), D3DRMFPTF_PALETTIZED (0x4)
	HVar1 = (*(globs::mainGlobs.device)->lpVtbl->FindPreferredTextureFormat)
										(globs::mainGlobs.device,0x800,4,&pixFmt);
	if (HVar1 != 0) {
		pDVar3 = &pixFmt;
		for (iVar2 = 8; iVar2 != 0; iVar2 += -1) {
			pDVar3->dwSize = 0;
			pDVar3 = (DDPIXELFORMAT *)&pDVar3->dwFlags;
		}
		pixFmt.dwSize = 0x20;
										// DDBD_16 (0x400), <no flags> (0x0)
		HVar1 = (*(globs::mainGlobs.device)->lpVtbl->FindPreferredTextureFormat)
											(globs::mainGlobs.device,0x400,0,&pixFmt);
		if (HVar1 == 0) {
			*(uint *)pixFmt.dwGBitMask = (unaff_EDI >> 3) * *(int *)pixFmt.dwGBitMask;
		}
	}
	return;
}



BOOL __cdecl lego::ddraw::DirectDraw_GetAvailTextureMem(uint *out_total,uint *out_avil)
{
	int iVar1;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	local_c = 0;
	local_8 = 0;
										// DDSCAPS_TEXTURE (0x1000)
	local_10 = 0x1000;
	local_4 = 0;
	*out_total = 0;
	*out_avil = 0;
	iVar1 = (*(code *)(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->GetAvailableVidMem)
										(globs::directDrawGlobs.lpDirectDraw,&local_10,out_total,out_avil);
	return (uint)(iVar1 == 0);
}



HRESULT __cdecl lego::ddraw::DirectDraw_Clear(Rect2F *window,uint colour)
{
	HRESULT HVar1;
	int iVar2;
	undefined4 *puVar3;
	longlong lVar4;
	tagRECT local_74;
	undefined4 local_64 [20];
	uint local_14;
	
	puVar3 = local_64;
	for (iVar2 = 0x19; iVar2 != 0; iVar2 += -1) {
		*puVar3 = 0;
		puVar3 = puVar3 + 1;
	}
	local_64[0] = 100;
	local_14 = DirectDraw_GetColour(globs::directDrawGlobs.bSurf,colour);
	if (window != NULL) {
		lVar4 = __ftol((float10)window->x);
		local_74.left = (LONG)lVar4;
		lVar4 = __ftol((float10)window->y);
		local_74.top = (LONG)lVar4;
		lVar4 = __ftol((float10)window->width + (float10)window->x);
		local_74.right = (LONG)lVar4;
		lVar4 = __ftol((float10)window->height + (float10)window->y);
		local_74.bottom = (LONG)lVar4;
										// DDBLT_WAIT | DDBLT_COLORFILL (0x1000000 | 0x400)
		HVar1 = (*(globs::directDrawGlobs.bSurf)->lpVtbl->Blt)
											(globs::directDrawGlobs.bSurf,(LPRECT)&local_74,NULL,NULL,0x1000400,local_64);
		return HVar1;
	}
										// DDBLT_WAIT | DDBLT_COLORFILL (0x1000000 | 0x400)
	HVar1 = (*(globs::directDrawGlobs.bSurf)->lpVtbl->Blt)
										(globs::directDrawGlobs.bSurf,NULL,NULL,NULL,0x1000400,local_64);
	return HVar1;
}



BOOL __cdecl lego::ddraw::DirectDraw_CreateClipper(BOOL fullscreen,uint width,uint height)
{
	int iVar1;
	HRGN hrgn;
	DWORD length;
	LPRGNDATA lpRgnData;
	int unaff_EBX;
	int unaff_EBP;
	IDirectDraw4 *pIVar2;
	
	pIVar2 = globs::directDrawGlobs.lpDirectDraw;
	iVar1 = (*(code *)(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateClipper)
										(globs::directDrawGlobs.lpDirectDraw,0,0x76bc98,0);
	if (iVar1 == 0) {
		hrgn = CreateRectRgn(0,0,unaff_EBP,unaff_EBX);
		length = GetRegionData(hrgn,0,NULL);
		lpRgnData = (LPRGNDATA)std::malloc(length);
		GetRegionData(hrgn,length,lpRgnData);
		iVar1 = (*(code *)(globs::directDrawGlobs.lpBackClipper)->lpVtbl->SetClipList)
											(globs::directDrawGlobs.lpBackClipper,lpRgnData,0);
		if (iVar1 == 0) {
			std::free(lpRgnData);
			iVar1 = (*(code *)(globs::directDrawGlobs.bSurf)->lpVtbl->SetClipper)
												(globs::directDrawGlobs.bSurf,globs::directDrawGlobs.lpBackClipper);
			if (iVar1 == 0) {
				if (pIVar2 != NULL) {
					return 1;
				}
				iVar1 = (*(code *)(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateClipper)
													(globs::directDrawGlobs.lpDirectDraw,0,0x76bc94,0);
				if (iVar1 == 0) {
					iVar1 = (*(code *)(globs::directDrawGlobs.lpFrontClipper)->lpVtbl->SetHWnd)
														(globs::directDrawGlobs.lpFrontClipper,0,globs::directDrawGlobs.hWnd);
					if (iVar1 == 0) {
						iVar1 = (*(code *)(globs::directDrawGlobs.fSurf)->lpVtbl->SetClipper)
															(globs::directDrawGlobs.fSurf,globs::directDrawGlobs.lpFrontClipper);
						if (iVar1 == 0) {
							return 1;
						}
					}
				}
			}
			(*(globs::directDrawGlobs.lpBackClipper)->lpVtbl->Release)
								((IUnknown *)globs::directDrawGlobs.lpBackClipper);
			globs::directDrawGlobs.lpBackClipper = NULL;
		}
		std::free(lpRgnData);
	}
	return 0;
}



// WARNING: Could not reconcile some variable overlaps

void __cdecl
lego::ddraw::DirectDraw_Blt8To16
					(IDirectDrawSurface4 *target,IDirectDrawSurface4 *source,D3DRMPaletteEntry *palette)
{
	uint uVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	bool bVar5;
	HRESULT HVar6;
	int iVar7;
	char cVar8;
	uint uVar9;
	uint uVar10;
	char cVar11;
	byte bVar12;
	DDSURFACEDESC2 *pDVar13;
	uint uStack296;
	int iStack288;
	uint uStack272;
	byte bStack256;
	byte bStack252;
	DDSURFACEDESC2 local_f8;
	DDSURFACEDESC2 local_7c;
	
	pDVar13 = &local_7c;
	for (iVar7 = 0x1f; iVar7 != 0; iVar7 += -1) {
		pDVar13->dwSize = 0;
		pDVar13 = (DDSURFACEDESC2 *)&pDVar13->dwFlags;
	}
	pDVar13 = &local_f8;
	for (iVar7 = 0x1f; iVar7 != 0; iVar7 += -1) {
		pDVar13->dwSize = 0;
		pDVar13 = (DDSURFACEDESC2 *)&pDVar13->dwFlags;
	}
	local_7c.dwSize = 0x7c;
	local_f8.dwSize = 0x7c;
	HVar6 = (*source->lpVtbl->Lock)(source,NULL,&local_f8,1,NULL);
	if (HVar6 == 0) {
		if ((local_f8.ddpfPixelFormat.dwRGBBitCount == 8) &&
			 (HVar6 = (*target->lpVtbl->Lock)(target,NULL,&local_7c,1,NULL), HVar6 == 0)) {
			if ((local_7c.ddpfPixelFormat.dwRGBBitCount == 0x10) &&
				 ((local_7c.dwWidth == local_f8.dwWidth && (local_7c.dwHeight == local_f8.dwHeight)))) {
				iVar7 = 0;
				cVar8 = '\0';
				do {
					if ((local_7c.ddpfPixelFormat.dwRBitMask >> ((byte)iVar7 & 0x1f) & 1) != 0) {
						cVar8 += '\x01';
					}
					iVar7 += 1;
				} while (iVar7 < 0x20);
				iVar7 = 0;
				cVar11 = '\0';
				do {
					if ((local_7c.ddpfPixelFormat.dwGBitMask >> ((byte)iVar7 & 0x1f) & 1) != 0) {
						cVar11 += '\x01';
					}
					iVar7 += 1;
				} while (iVar7 < 0x20);
				iVar7 = 0;
				bVar12 = 0;
				do {
					if ((local_7c.ddpfPixelFormat.dwBBitMask >> ((byte)iVar7 & 0x1f) & 1) != 0) {
						bVar12 += 1;
					}
					iVar7 += 1;
				} while (iVar7 < 0x20);
				uStack296 = 0;
				if (local_f8.dwHeight != 0) {
					do {
						uVar10 = 0;
						if (local_f8.dwWidth != 0) {
							bStack256 = 8 - cVar8;
							bStack252 = 8 - cVar11;
							uStack272._0_1_ = 8 - bVar12;
							do {
								iStack288 = 0x18;
								uVar1 = *(uint *)(uStack296 * local_f8.lPitch + uVar10 + (int)local_f8.lpSurface);
								uVar9 = 3;
								bVar5 = true;
								do {
									uVar2 = uVar1 >> ((byte)iStack288 & 0x1f) & 0xff;
									uVar3 = (uint)(palette[uVar2].red >> (bStack256 & 0x1f));
									uVar4 = (uint)(palette[uVar2].green >> (bStack252 & 0x1f));
									uVar2 = (uint)(palette[uVar2].blue >> ((byte)uStack272 & 0x1f));
									if (bVar5) {
										uStack272 = (uVar3 << (bVar12 + cVar11 & 0x1f) | uVar4 << (bVar12 & 0x1f) |
																uVar2) << 0x10;
									}
									else {
										uStack272 |= uVar3 << (cVar11 + bVar12 & 0x1f) | uVar4 << (bVar12 & 0x1f) |
																 uVar2;
										*(uint *)((int)local_7c.lpSurface +
														 (uVar10 + (uVar9 >> 1 & 1) * 2) * 2 + uStack296 * local_7c.lPitch) =
												 uStack272;
									}
									uVar9 -= 1;
									bVar5 = (bool)(bVar5 ^ 1);
									iStack288 += -8;
								} while (-1 < iStack288);
								uVar10 += 4;
							} while (uVar10 < local_f8.dwWidth);
						}
						uStack296 += 1;
					} while (uStack296 < local_f8.dwHeight);
				}
			}
			(*target->lpVtbl->Unlock)(target,NULL);
		}
		(*source->lpVtbl->Unlock)(source,NULL);
	}
	return;
}



uint __cdecl lego::ddraw::DirectDraw_GetColour(IDirectDrawSurface4 *surf,uint colour)
{
	IDirectDrawSurface4Vtbl *pIVar1;
	byte bVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	byte *pbVar8;
	uint unaff_EBP;
	int *unaff_ESI;
	DDPIXELFORMAT *pDVar9;
	DWORD *pDVar10;
	uint local_428;
	IDirectDrawPalette *ddPal;
	DDPIXELFORMAT pixFmt;
	D3DRMPaletteEntry palEntries [256];
	
	local_428 = colour >> 0x10 & 0xff;
	uVar6 = colour >> 8 & 0xff;
	pIVar1 = surf->lpVtbl;
	pDVar9 = &pixFmt;
	for (iVar7 = 8; iVar7 != 0; iVar7 += -1) {
		pDVar9->dwSize = 0;
		pDVar9 = (DDPIXELFORMAT *)&pDVar9->dwFlags;
	}
	pixFmt.dwSize = 0x20;
	(*pIVar1->GetPixelFormat)(surf,&pixFmt);
	if (((byte)ddPal & 0x40) == 0) {
		(*surf->lpVtbl->GetPalette)(surf,(IDirectDrawPalette **)&stack0xfffffbd4);
		pDVar10 = &pixFmt.dwRBitMask;
		(**(code **)(*unaff_ESI + 0x10))(unaff_ESI,0,0,0x100);
		uVar3 = 0;
		pbVar8 = (byte *)((int)&ddPal + 1);
		while ((((DWORD *)(uint)pbVar8[-1] != pDVar10 || (*pbVar8 != uVar6)) ||
					 ((uint)pbVar8[1] != (colour & 0xff)))) {
			uVar3 += 1;
			pbVar8 = pbVar8 + 4;
			if (0xff < uVar3) {
				return 0;
			}
		}
		return uVar3;
	}
	uVar3 = DirectDraw_GetNumberOfBits(pixFmt.dwFourCC);
	uVar4 = DirectDraw_GetNumberOfBits(pixFmt.dwRGBBitCount);
	uVar5 = DirectDraw_GetNumberOfBits(pixFmt.dwRBitMask);
	bVar2 = (byte)uVar5;
	return (unaff_EBP >> (8U - (char)uVar3 & 0x1f)) << (bVar2 + (char)uVar4 & 0x1f) |
				 (uVar6 >> (8U - (char)uVar4 & 0x1f)) << (bVar2 & 0x1f) |
				 (colour & 0xff) >> (8 - bVar2 & 0x1f);
}



uint __cdecl lego::ddraw::DirectDraw_GetNumberOfBits(uint mask)
{
	uint uVar1;
	
	uVar1 = 0;
	if (mask != 0) {
		do {
			mask &= mask - 1;
			uVar1 += 1;
		} while (mask != 0);
	}
	return uVar1;
}



void __cdecl lego::image::Image_Initialise(void)
{
	int iVar1;
	Image_Globs *pIVar2;
	
	pIVar2 = &globs::imageGlobs;
	for (iVar1 = 0x20; iVar1 != 0; iVar1 += -1) {
		pIVar2->listSet[0] = NULL;
		pIVar2 = (Image_Globs *)(pIVar2->listSet + 1);
	}
	globs::imageGlobs.flags = 1;
	return;
}



void __cdecl lego::image::Image_Shutdown(void)
{
	Image_Globs *pIVar1;
	
	Image_RemoveAll();
	pIVar1 = &globs::imageGlobs;
	do {
		if (pIVar1->listSet[0] != NULL) {
			std::free(pIVar1->listSet[0]);
		}
		pIVar1 = (Image_Globs *)(pIVar1->listSet + 1);
	} while (pIVar1 < (Image_Globs *)&globs::imageGlobs.freeList);
	globs::imageGlobs.freeList = NULL;
	globs::imageGlobs.flags = 0;
	return;
}



void __cdecl lego::image::Image_Remove(ImageBMP *image)
{
	(*image->surface->lpVtbl->Release)((IUnknown *)image->surface);
	image->nextFree = globs::imageGlobs.freeList;
	globs::imageGlobs.freeList = image;
	return;
}



BOOL __cdecl lego::image::Image_CopyToDataToSurface(IDirectDrawSurface4 *surface,D3DRMImage *image)
{
	HRESULT HVar1;
	int iVar2;
	DWORD *pDVar3;
	DDSURFACEDESC2 local_7c;
	
	pDVar3 = &local_7c.dwFlags;
	for (iVar2 = 0x1e; iVar2 != 0; iVar2 += -1) {
		*pDVar3 = 0;
		pDVar3 = pDVar3 + 1;
	}
										// IDirectDrawSurface4::Lock(IDirectDrawSurface4* This, RECT* a, DDSURFACEDESC2*
										// b, DWORD c, HANDLE d)
										// DDLOCK_WRITEONLY | DDLOCK_WAIT (0x20 | 0x1)
	local_7c.dwSize = 0x7c;
	HVar1 = (*surface->lpVtbl->Lock)(surface,NULL,&local_7c,0x21,NULL);
	if (HVar1 == 0) {
		iVar2 = image->depth;
		if (7 < iVar2) {
			if (iVar2 == 8) {
				Image_8BitSourceCopy(&local_7c,image);
			}
			else {
				if ((iVar2 != 0x10) && (iVar2 == 0x18)) {
					Image_24BitSourceCopy(&local_7c,image);
				}
			}
		}
										// IDirectDrawSurface4::Unock(IDirectDrawSurface4* This, RECT* a)
		(*surface->lpVtbl->Unlock)(surface,NULL);
		return 1;
	}
	return 0;
}



BOOL __cdecl lego::image::Image_8BitSourceCopy(DDSURFACEDESC2 *desc,D3DRMImage *image)
{
	DWORD DVar1;
	int iVar2;
	D3DRMPaletteEntry *pDVar3;
	uint uVar4;
	uint uVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	uint uVar11;
	uint uVar12;
	uint uVar13;
	int iVar14;
	undefined2 *puVar15;
	undefined2 *puVar16;
	byte *pbVar17;
	int local_30;
	byte local_2c;
	byte local_18;
	byte local_10;
	
	DVar1 = (desc->ddpfPixelFormat).dwRGBBitCount;
	if (DVar1 == 8) {
		return 0;
	}
	if (DVar1 == 0x10) {
		uVar9 = (desc->ddpfPixelFormat).dwGBitMask;
		puVar16 = (undefined2 *)desc->lpSurface;
		iVar2 = image->bytes_per_line;
		pDVar3 = image->palette;
		uVar4 = desc->lPitch;
		pbVar17 = image->buffer1;
		uVar10 = (desc->ddpfPixelFormat).dwBBitMask;
		uVar8 = (desc->ddpfPixelFormat).dwRBitMask;
		uVar5 = Image_CountMaskBits(uVar8);
		uVar6 = Image_CountMaskBits(uVar9);
		uVar7 = Image_CountMaskBits(uVar10);
		uVar8 = Image_CountMaskBitShift(uVar8);
		uVar9 = Image_CountMaskBitShift(uVar9);
		uVar10 = Image_CountMaskBitShift(uVar10);
		local_30 = 0;
		if (0 < image->height) {
			do {
				iVar14 = 0;
				if (0 < image->width) {
					local_2c = 8 - (char)uVar7;
					local_10 = 8 - (char)uVar6;
					uVar11 = 8 - uVar5;
					uVar13 = uVar7;
					puVar15 = puVar16;
					do {
						uVar12 = (uint)*pbVar17;
						pbVar17 = pbVar17 + 1;
						puVar16 = puVar15 + 1;
						local_18 = (byte)(8 - uVar5);
						uVar13 = (uVar13 & 0xffff0000 | (uint)(pDVar3[uVar12].blue >> (local_2c & 0x1f))) <<
										 ((byte)uVar10 & 0x1f) |
										 ((uint)pDVar3 & 0xffff0000 | (uint)(pDVar3[uVar12].red >> (local_18 & 0x1f)))
										 << ((byte)uVar8 & 0x1f) |
										 (uVar11 & 0xffff0000 | (uint)(pDVar3[uVar12].green >> (local_10 & 0x1f))) <<
										 ((byte)uVar9 & 0x1f);
						iVar14 += 1;
						*puVar15 = (short)uVar13;
						uVar11 = image->width;
						puVar15 = puVar16;
					} while (iVar14 < (int)uVar11);
				}
				pbVar17 = pbVar17 + (iVar2 - image->width);
				puVar16 = puVar16 + ((uVar4 >> 1) - image->width);
				local_30 += 1;
			} while (local_30 < image->height);
		}
		Image_FlipSurface(desc);
		return 1;
	}
	if (DVar1 == 0x18) {
		return 0;
	}
	if (DVar1 != 0x20) {
		return 1;
	}
	return 0;
}



uint __cdecl lego::image::Image_CountMaskBits(uint mask)
{
	uint uVar1;
	uint uVar2;
	
	uVar1 = 0;
	uVar2 = 0;
	do {
		if ((mask & 1 << ((byte)uVar2 & 0x1f)) != 0) {
			uVar1 += 1;
		}
		uVar2 += 1;
	} while (uVar2 < 0x20);
	return uVar1;
}



uint __cdecl lego::image::Image_CountMaskBitShift(uint mask)
{
	uint uVar1;
	
	uVar1 = 0;
	do {
		if ((mask & 1 << ((byte)uVar1 & 0x1f)) != 0) {
			return uVar1;
		}
		uVar1 += 1;
	} while (uVar1 < 0x20);
	return 0xffffffff;
}



void __cdecl lego::image::Image_FlipSurface(DDSURFACEDESC2 *desc)
{
	uint length;
	int iVar1;
	undefined4 *buffer;
	uint uVar2;
	undefined4 *puVar3;
	undefined4 *puVar4;
	undefined4 *puVar5;
	undefined4 *local_8;
	uint local_4;
	
	puVar3 = (undefined4 *)desc->lpSurface;
	iVar1 = (int)desc->lPitch / 2;
	length = iVar1 * 2;
	local_8 = (undefined4 *)((int)puVar3 + (desc->dwHeight - 1) * iVar1 * 2);
	buffer = (undefined4 *)std::malloc(length);
	local_4 = 0;
	if ((desc->dwHeight & 0xfffffffe) != 0) {
		do {
			puVar4 = puVar3;
			puVar5 = buffer;
			for (uVar2 = length >> 2; uVar2 != 0; uVar2 -= 1) {
				*puVar5 = *puVar4;
				puVar4 = puVar4 + 1;
				puVar5 = puVar5 + 1;
			}
			for (uVar2 = length & 3; uVar2 != 0; uVar2 -= 1) {
				*(undefined *)puVar5 = *(undefined *)puVar4;
				puVar4 = (undefined4 *)((int)puVar4 + 1);
				puVar5 = (undefined4 *)((int)puVar5 + 1);
			}
			puVar4 = local_8;
			puVar5 = puVar3;
			for (uVar2 = length >> 2; uVar2 != 0; uVar2 -= 1) {
				*puVar5 = *puVar4;
				puVar4 = puVar4 + 1;
				puVar5 = puVar5 + 1;
			}
			for (uVar2 = length & 3; uVar2 != 0; uVar2 -= 1) {
				*(undefined *)puVar5 = *(undefined *)puVar4;
				puVar4 = (undefined4 *)((int)puVar4 + 1);
				puVar5 = (undefined4 *)((int)puVar5 + 1);
			}
			puVar4 = buffer;
			puVar5 = local_8;
			for (uVar2 = length >> 2; uVar2 != 0; uVar2 -= 1) {
				*puVar5 = *puVar4;
				puVar4 = puVar4 + 1;
				puVar5 = puVar5 + 1;
			}
			for (uVar2 = length & 3; uVar2 != 0; uVar2 -= 1) {
				*(undefined *)puVar5 = *(undefined *)puVar4;
				puVar4 = (undefined4 *)((int)puVar4 + 1);
				puVar5 = (undefined4 *)((int)puVar5 + 1);
			}
			local_4 += 1;
			puVar3 = (undefined4 *)((int)puVar3 + length);
			local_8 = (undefined4 *)((int)local_8 + iVar1 * -2);
		} while (local_4 < desc->dwHeight >> 1);
	}
	std::free(buffer);
	return;
}



BOOL __cdecl lego::image::Image_24BitSourceCopy(DDSURFACEDESC2 *desc,D3DRMImage *image)
{
	byte *pbVar1;
	byte *pbVar2;
	byte bVar3;
	DWORD DVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	uint uVar11;
	uint uVar12;
	uint uVar13;
	uint uVar14;
	D3DRMImage *pDVar15;
	int iVar16;
	byte *pbVar17;
	undefined2 *puVar18;
	undefined2 *puVar19;
	int local_2c;
	byte local_18;
	byte local_10;
	
	DVar4 = (desc->ddpfPixelFormat).dwRGBBitCount;
	if (DVar4 == 8) {
		return 0;
	}
	if (DVar4 == 0x10) {
		uVar11 = (desc->ddpfPixelFormat).dwGBitMask;
		uVar12 = (desc->ddpfPixelFormat).dwBBitMask;
		puVar19 = (undefined2 *)desc->lpSurface;
		iVar5 = image->bytes_per_line;
		pbVar17 = image->buffer1;
		uVar6 = desc->lPitch;
		uVar10 = (desc->ddpfPixelFormat).dwRBitMask;
		uVar7 = Image_CountMaskBits(uVar10);
		uVar8 = Image_CountMaskBits(uVar11);
		uVar9 = Image_CountMaskBits(uVar12);
		uVar10 = Image_CountMaskBitShift(uVar10);
		uVar11 = Image_CountMaskBitShift(uVar11);
		uVar12 = Image_CountMaskBitShift(uVar12);
		local_2c = 0;
		if (0 < image->height) {
			do {
				iVar16 = 0;
				if (0 < image->width) {
					local_10 = 8 - (char)uVar7;
					local_18 = 8 - (char)uVar9;
					uVar13 = uVar8;
					uVar14 = uVar7;
					pDVar15 = image;
					puVar18 = puVar19;
					do {
						bVar3 = *pbVar17;
						pbVar1 = pbVar17 + 1;
						puVar19 = puVar18 + 1;
						pbVar2 = pbVar17 + 2;
						pbVar17 = pbVar17 + 3;
						uVar14 = (uVar14 & 0xffff0000 | (uint)(bVar3 >> (local_18 & 0x1f))) <<
										 ((byte)uVar12 & 0x1f);
						pDVar15 = (D3DRMImage *)
											(((uint)pDVar15 & 0xffff0000 | (uint)(*pbVar1 >> (8U - (char)uVar8 & 0x1f)))
											 << ((byte)uVar11 & 0x1f) | uVar14 |
											(uVar13 & 0xffff0000 | (uint)(*pbVar2 >> (local_10 & 0x1f))) <<
											((byte)uVar10 & 0x1f));
						iVar16 += 1;
						*puVar18 = (short)pDVar15;
						uVar13 = image->width;
						puVar18 = puVar19;
					} while (iVar16 < (int)uVar13);
				}
				pbVar17 = pbVar17 + iVar5 + image->width * -3;
				local_2c += 1;
				puVar19 = puVar19 + ((uVar6 >> 1) - image->width);
			} while (local_2c < image->height);
		}
		Image_FlipSurface(desc);
		return 1;
	}
	if (DVar4 == 0x18) {
		return 0;
	}
	if (DVar4 != 0x20) {
		return 1;
	}
	return 0;
}



ImageBMP * __cdecl lego::image::Image_LoadBMPScaled(char *fileName,uint width,uint height)
{
	COLORREF pen255;
	BITMAP_FILE_INFO_STRUCT *data;
	HRESULT HVar1;
	BOOL BVar2;
	ImageBMP *pIVar3;
	int iVar4;
	uint unaff_EBX;
	COLORREF unaff_ESI;
	IDirectDrawSurface4 *unaff_EDI;
	int *piVar5;
	DWORD *pDVar6;
	DDSURFACEDESC2 *pDVar7;
	IDirectDrawSurface4 *local_4c4;
	COLORREF local_4c0;
	uint length;
	D3DRMImage local_4b8;
	DDSURFACEDESC2 surfaceDesc;
	char local_400 [1024];
	
	local_4b8.width = 0;
	piVar5 = &local_4b8.height;
	for (iVar4 = 0xe; iVar4 != 0; iVar4 += -1) {
		*piVar5 = 0;
		piVar5 = piVar5 + 1;
	}
	surfaceDesc.dwSize = 0;
	pDVar6 = &surfaceDesc.dwFlags;
	for (iVar4 = 0x1e; iVar4 != 0; iVar4 += -1) {
		*pDVar6 = 0;
		pDVar6 = pDVar6 + 1;
	}
	length = 0;
	local_4c4 = NULL;
	pen255 = Image_RGB2CR(0,0,0);
	local_4c0 = pen255;
	data = (BITMAP_FILE_INFO_STRUCT *)lego::file::File_LoadBinary(fileName,&length);
	if (data != NULL) {
		BMP_Parse(data,length,&local_4b8);
		if (local_4b8.rgb == 0) {
			local_4c0 = Image_RGB2CR((local_4b8.palette)->red,(local_4b8.palette)->green,
															 (local_4b8.palette)->blue);
			if (local_4b8.rgb == 0) {
				pen255 = Image_RGB2CR(local_4b8.palette[0xff].red,local_4b8.palette[0xff].green,
															local_4b8.palette[0xff].blue);
			}
		}
		std::sprintf(local_400,"Data\\%s",fileName);
		pDVar7 = &surfaceDesc;
		for (iVar4 = 0x1f; iVar4 != 0; iVar4 += -1) {
			pDVar7->dwSize = 0;
			pDVar7 = (DDSURFACEDESC2 *)&pDVar7->dwFlags;
		}
		surfaceDesc.dwWidth = local_4b8.width;
		surfaceDesc.dwHeight = local_4b8.height;
		surfaceDesc.dwSize = 0x7c;
		surfaceDesc.dwFlags = 7;
		surfaceDesc.ddsCaps.dwCaps = 0x840;
										// IDirectDraw4::CreateSurface(IDirectDraw4* This, DDSURFACEDESC2*
										// lpDDSurfaceDesc, IDirectDrawSurface4** lplpDDSurface, IUnknown* pUnkOuter)
		HVar1 = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
											(globs::directDrawGlobs.lpDirectDraw,&surfaceDesc,&local_4c4,NULL);
		if (HVar1 == 0) {
			BVar2 = Image_CopyToDataToSurface(unaff_EDI,(D3DRMImage *)&stack0xfffffb38);
			if (BVar2 != 0) {
				pIVar3 = Image_Create(unaff_EDI,unaff_EBX,(uint)local_4c4,unaff_ESI,pen255);
				if (pIVar3 != NULL) {
					BMP_Cleanup((D3DRMImage *)&stack0xfffffb38);
					std::free(data);
					return pIVar3;
				}
			}
		}
		if (unaff_EDI != NULL) {
			(*unaff_EDI->lpVtbl->Release)((IUnknown *)unaff_EDI);
		}
		BMP_Cleanup((D3DRMImage *)&stack0xfffffb38);
		std::free(data);
	}
	return NULL;
}



COLORREF __cdecl lego::image::Image_RGB2CR(byte red,byte green,byte blue)
{
	_red = (uint)CONCAT12(blue,CONCAT11(green,red));
	return _red;
}



void __cdecl lego::image::Image_SetPenZeroTrans(ImageBMP *image)
{
	DDCOLORKEY colorKey;
	
	colorKey.dwColorSpaceLowValue = image->penZero;
	colorKey.dwColorSpaceHighValue = colorKey.dwColorSpaceLowValue;
	(*image->surface->lpVtbl->SetColorKey)(image->surface,8,&colorKey);
	image->flags = image->flags | IMAGE_FLAG_TRANS;
	return;
}



void __cdecl
lego::image::Image_SetupTrans
					(ImageBMP *image,float red_low,float green_low,float blue_low,float red_high,
					float green_high,float blue_high)
{
	byte bVar1;
	COLORREF rgb;
	COLORREF rgb_00;
	longlong lVar2;
	byte bVar3;
	DDCOLORKEY colorKey;
	
	lVar2 = __ftol((float10)blue_low * (float10)255.0);
	bVar3 = (byte)lVar2;
	lVar2 = __ftol((float10)green_low * (float10)255.0);
	bVar1 = (byte)lVar2;
	lVar2 = __ftol((float10)red_low * (float10)255.0);
	rgb = Image_RGB2CR((byte)lVar2,bVar1,bVar3);
	lVar2 = __ftol((float10)blue_high * (float10)255.0);
	bVar3 = (byte)lVar2;
	lVar2 = __ftol((float10)green_high * (float10)255.0);
	bVar1 = (byte)lVar2;
	lVar2 = __ftol((float10)red_high * (float10)255.0);
	rgb_00 = Image_RGB2CR((byte)lVar2,bVar1,bVar3);
	colorKey.dwColorSpaceLowValue = Image_DDColorMatch(image->surface,rgb);
	colorKey.dwColorSpaceHighValue = Image_DDColorMatch(image->surface,rgb_00);
										// IDirectDrawSurface4::SetColorKey(DWORD a, LPDDCOLORKEY b)
	(*image->surface->lpVtbl->SetColorKey)(image->surface,8,&colorKey);
	image->flags = image->flags | IMAGE_FLAG_TRANS;
	return;
}



// Image_Blt

void __cdecl
lego::image::Image_DisplayScaled(ImageBMP *image,Rect2F *src,Point2F *destPos,Size2F *destSize)
{
	float fVar1;
	float10 fVar2;
	longlong lVar3;
	DWORD DVar4;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined4 local_10;
	undefined4 local_c;
	undefined4 local_8;
	undefined4 local_4;
	
	if (src != NULL) {
		fVar2 = __floor((double)src->x);
		lVar3 = __ftol(fVar2);
		local_10 = (undefined4)lVar3;
		fVar2 = __floor((double)src->y);
		lVar3 = __ftol(fVar2);
		local_c = (undefined4)lVar3;
		fVar2 = __floor((double)(src->width + src->x));
		lVar3 = __ftol(fVar2);
		local_8 = (undefined4)lVar3;
		fVar2 = __floor((double)(src->height + src->y));
		lVar3 = __ftol(fVar2);
		local_4 = (undefined4)lVar3;
	}
	if (destPos != NULL) {
		fVar2 = __floor((double)destPos->x);
		lVar3 = __ftol(fVar2);
		local_20 = (undefined4)lVar3;
		fVar2 = __floor((double)destPos->y);
		lVar3 = __ftol(fVar2);
		local_1c = (undefined4)lVar3;
		if (destSize == NULL) {
			if (src == NULL) {
				fVar2 = __floor((double)((float)(ulonglong)image->width + destPos->x));
				lVar3 = __ftol(fVar2);
				local_18 = (undefined4)lVar3;
				fVar1 = (float)(ulonglong)image->height;
			}
			else {
				fVar2 = __floor((double)(src->width + destPos->x));
				lVar3 = __ftol(fVar2);
				local_18 = (undefined4)lVar3;
				fVar1 = src->height;
			}
		}
		else {
			fVar2 = __floor((double)(destSize->width + destPos->x));
			lVar3 = __ftol(fVar2);
			local_18 = (undefined4)lVar3;
			fVar1 = destSize->height;
		}
		fVar2 = __floor((double)(fVar1 + destPos->y));
		lVar3 = __ftol(fVar2);
		local_14 = (undefined4)lVar3;
	}
	if ((*(byte *)&image->flags & 2) == 0) {
		DVar4 = 0x1000000;
	}
	else {
		DVar4 = 0x1008000;
	}
	(*(globs::directDrawGlobs.bSurf)->lpVtbl->Blt)
						(globs::directDrawGlobs.bSurf,(LPRECT)(-(uint)(destPos != NULL) & (uint)&local_20),
						 image->surface,(LPRECT)(-(uint)(src != NULL) & (uint)&local_10),DVar4,NULL);
	return;
}



void * __cdecl lego::image::Image_LockSurface(ImageBMP *image,uint *out_pitch,uint *out_bpp)
{
	DDSURFACEDESC2 *pDVar1;
	HRESULT HVar2;
	int iVar3;
	DDSURFACEDESC2 s;
	
	pDVar1 = &s;
	for (iVar3 = 0x1f; iVar3 != 0; iVar3 += -1) {
		*(undefined4 *)pDVar1 = 0;
		pDVar1 = (DDSURFACEDESC2 *)((int)pDVar1 + 4);
	}
	s.dwSize = 0x7c;
	HVar2 = (*image->surface->lpVtbl->Lock)(image->surface,NULL,&s,1,NULL);
	if (HVar2 == 0) {
		*out_pitch = s.lPitch;
		*out_bpp = s.ddpfPixelFormat.dwRGBBitCount;
		return s.lpSurface;
	}
	return NULL;
}



void __cdecl lego::image::Image_UnlockSurface(ImageBMP *image)
{
	(*image->surface->lpVtbl->Unlock)(image->surface,NULL);
	return;
}



// WARNING: Could not reconcile some variable overlaps

uint __cdecl lego::image::Image_GetPen255(ImageBMP *image)
{
	int iVar1;
	DDPIXELFORMAT *pDVar2;
	uint local_24;
	DDPIXELFORMAT pixelFmt;
	
	pDVar2 = &pixelFmt;
	for (iVar1 = 8; iVar1 != 0; iVar1 += -1) {
		pDVar2->dwSize = 0;
		pDVar2 = (DDPIXELFORMAT *)&pDVar2->dwFlags;
	}
	pixelFmt.dwSize = 0x20;
	local_24 = (*image->surface->lpVtbl->GetPixelFormat)(image->surface,&pixelFmt);
	if (local_24 == 0) {
		local_24 = CONCAT13(*(undefined *)&image->pen255,
												CONCAT12(*(undefined *)((int)&image->pen255 + 1),
																 CONCAT11(*(undefined *)((int)&image->pen255 + 2),
																					*(undefined *)((int)&image->pen255 + 3))));
	}
	return local_24;
}



uint __cdecl lego::image::Image_GetPixelMask(ImageBMP *image)
{
	DDPIXELFORMAT *pDVar1;
	HRESULT HVar2;
	int iVar3;
	DDPIXELFORMAT pixelFmt;
	
	pDVar1 = &pixelFmt;
	for (iVar3 = 8; iVar3 != 0; iVar3 += -1) {
		*(undefined4 *)pDVar1 = 0;
		pDVar1 = (DDPIXELFORMAT *)((int)pDVar1 + 4);
	}
	pixelFmt.dwSize = 0x20;
	HVar2 = (*image->surface->lpVtbl->GetPixelFormat)(image->surface,&pixelFmt);
	if (HVar2 == 0) {
		return -1 << (0x20U - (char)pixelFmt.dwRGBBitCount & 0x1f);
	}
	return 0;
}



BOOL __cdecl lego::image::Image_GetPixel(ImageBMP *image,uint x,uint y,uint *out_colour)
{
	HRESULT HVar1;
	int iVar2;
	DDSURFACEDESC2 *pDVar3;
	DDSURFACEDESC2 local_7c;
	
	pDVar3 = &local_7c;
	for (iVar2 = 0x1f; iVar2 != 0; iVar2 += -1) {
		pDVar3->dwSize = 0;
		pDVar3 = (DDSURFACEDESC2 *)&pDVar3->dwFlags;
	}
	local_7c.dwSize = 0x7c;
	if ((x < image->width) && (y < image->height)) {
		HVar1 = (*image->surface->lpVtbl->Lock)(image->surface,NULL,&local_7c,0x11,NULL);
		if (HVar1 == 0) {
			*out_colour = *(uint *)((int)local_7c.lpSurface +
														 (local_7c.ddpfPixelFormat.dwRGBBitCount >> 3) * x + local_7c.lPitch * y
														 ) >> (0x20U - (char)local_7c.ddpfPixelFormat.dwRGBBitCount & 0x1f);
			(*image->surface->lpVtbl->Unlock)(image->surface,NULL);
			return 1;
		}
	}
	return 0;
}



ImageBMP * __cdecl
lego::image::Image_Create
					(IDirectDrawSurface4 *surface,uint width,uint height,COLORREF penZero,COLORREF pen255)
{
	ImageBMP *pIVar1;
	ImageBMP *pIVar2;
	DWORD DVar3;
	
	if (globs::imageGlobs.freeList == NULL) {
		Image_AddList();
	}
	pIVar1 = globs::imageGlobs.freeList;
	pIVar2 = (globs::imageGlobs.freeList)->nextFree;
	(globs::imageGlobs.freeList)->nextFree = globs::imageGlobs.freeList;
	globs::imageGlobs.freeList = pIVar2;
	pIVar1->flags = IMAGE_FLAG_NONE;
	pIVar1->width = width;
	pIVar1->height = height;
	pIVar1->surface = surface;
	pIVar1->penZeroRGB = penZero;
	DVar3 = Image_DDColorMatch(surface,penZero);
	pIVar1->penZero = DVar3;
	DVar3 = Image_DDColorMatch(surface,pen255);
	pIVar1->pen255 = DVar3;
	return pIVar1;
}



void __cdecl lego::image::Image_AddList(void)
{
	ImageBMP *pIVar1;
	ImageBMP *pIVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::imageGlobs.listCount & 0x1f);
	pIVar2 = (ImageBMP *)std::malloc(uVar4 * 0x20);
	globs::imageGlobs.listSet[globs::imageGlobs.listCount] = pIVar2;
	pIVar2 = globs::imageGlobs.listSet[globs::imageGlobs.listCount];
	if (pIVar2 != NULL) {
		globs::imageGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pIVar1 = pIVar2;
			do {
				pIVar1->nextFree = pIVar1 + 1;
				iVar3 += -1;
				pIVar1 = pIVar1 + 1;
			} while (iVar3 != 0);
		}
		pIVar2[uVar4 - 1].nextFree = globs::imageGlobs.freeList;
		globs::imageGlobs.freeList = pIVar2;
	}
	return;
}



void __cdecl lego::image::Image_RemoveAll(void)
{
	int iVar1;
	ImageBMP *image;
	Image_Globs *pIVar2;
	uint uVar3;
	int iVar4;
	
	uVar3 = 0;
	if (globs::imageGlobs.listCount != 0) {
		pIVar2 = &globs::imageGlobs;
		do {
			if ((pIVar2->listSet[0] != NULL) && (iVar1 = 1 << ((byte)uVar3 & 0x1f), iVar1 != 0)) {
				iVar4 = 0;
				do {
					image = (ImageBMP *)((int)&pIVar2->listSet[0]->surface + iVar4);
					if ((image != NULL) && (image->nextFree == image)) {
						Image_Remove(image);
					}
					iVar4 += 0x20;
					iVar1 += -1;
				} while (iVar1 != 0);
			}
			uVar3 += 1;
			pIVar2 = (Image_Globs *)(pIVar2->listSet + 1);
		} while (uVar3 < globs::imageGlobs.listCount);
	}
	return;
}



DWORD __cdecl lego::image::Image_DDColorMatch(IDirectDrawSurface4 *pdds,DWORD rgb)
{
	byte bVar1;
	HRESULT HVar2;
	uint uVar3;
	uint uVar4;
	int iVar6;
	uint unaff_ESI;
	DWORD DVar7;
	DWORD *pDVar8;
	DDSURFACEDESC2 *lpDDSurfaceDesc;
	char cVar9;
	char cVar10;
	byte out_red;
	byte out_blue;
	byte out_green;
	DDSURFACEDESC2 s;
	uint uVar5;
	
	pDVar8 = &s.dwFlags;
	for (iVar6 = 0x1e; iVar6 != 0; iVar6 += -1) {
		*pDVar8 = 0;
		pDVar8 = pDVar8 + 1;
	}
	DVar7 = 0;
	s.dwSize = 0x7c;
	Image_CR2RGB(rgb,&out_red,&out_green,&out_blue);
	lpDDSurfaceDesc = &s;
	HVar2 = (*pdds->lpVtbl->Lock)(pdds,NULL,lpDDSurfaceDesc,1,NULL);
	if (HVar2 == 0) {
		uVar3 = Image_CountMaskBits(s.ddckCKSrcBlt.dwColorSpaceHighValue);
		uVar4 = Image_CountMaskBits(s.ddpfPixelFormat.dwSize);
		cVar9 = (char)uVar4;
		uVar4 = Image_CountMaskBits(s.ddpfPixelFormat.dwFlags);
		cVar10 = (char)uVar4;
		uVar4 = Image_CountMaskBitShift(s.ddckCKSrcBlt.dwColorSpaceHighValue);
		uVar5 = Image_CountMaskBitShift(s.ddpfPixelFormat.dwSize);
		bVar1 = (byte)uVar5;
		uVar5 = Image_CountMaskBitShift(s.ddpfPixelFormat.dwFlags);
		DVar7 = ((_out_red & 0xff) >> (8U - cVar9 & 0x1f)) << (bVar1 & 0x1f) |
						(((uint)lpDDSurfaceDesc & 0xff) >> (8U - (char)uVar3 & 0x1f)) << ((byte)uVar4 & 0x1f) |
						((unaff_ESI & 0xff) >> (8U - cVar10 & 0x1f)) << ((byte)uVar5 & 0x1f);
		if (s.ddckCKSrcBlt.dwColorSpaceLowValue < 0x20) {
			DVar7 &= (1 << ((byte)s.ddckCKSrcBlt.dwColorSpaceLowValue & 0x1f)) - 1U;
		}
		(**(code **)(*(int *)s.ddsCaps.dwCaps2 + 0x80))(s.ddsCaps.dwCaps2,0);
	}
	return DVar7;
}



void __cdecl lego::image::Image_CR2RGB(COLORREF cr,byte *out_r,byte *out_g,byte *out_b)
{
	if (out_r != NULL) {
		*out_r = (byte)cr;
	}
	if (out_g != NULL) {
		*out_g = (byte)(cr >> 8);
	}
	if (out_b != NULL) {
		*out_b = cr._2_1_;
	}
	return;
}



void __cdecl lego::image::Image_GetScreenshot(ImageBMP *ref_image,uint xsize,uint ysize)
{
	HRESULT err;
	int iVar1;
	DDSURFACEDESC2 *pDVar2;
	IDirectDrawSurface4 *ddSurface4;
	RECT dstRect;
	DDSURFACEDESC2 surfDesc;
	
	pDVar2 = &surfDesc;
	for (iVar1 = 0x1f; iVar1 != 0; iVar1 += -1) {
		pDVar2->dwSize = 0;
		pDVar2 = (DDSURFACEDESC2 *)&pDVar2->dwFlags;
	}
	surfDesc.dwSize = 0x7c;
	surfDesc.dwWidth = xsize;
	surfDesc.dwHeight = ysize;
	surfDesc.ddsCaps.dwCaps = 0x840;
	surfDesc.dwFlags = 7;
	err = (*(globs::directDrawGlobs.lpDirectDraw)->lpVtbl->CreateSurface)
									(globs::directDrawGlobs.lpDirectDraw,&surfDesc,&ddSurface4,NULL);
	if (err != 0) {
		debug::Error_SetDXError(err,3,"C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Images.c",1140);
		return;
	}
	dstRect.left = 0;
	dstRect.top = 0;
	dstRect.right = xsize;
	dstRect.bottom = ysize;
	(*ddSurface4->lpVtbl->Blt)(ddSurface4,&dstRect,globs::directDrawGlobs.bSurf,NULL,0,NULL);
	Image_InitFromSurface(ref_image,ddSurface4,xsize,ysize,0,0);
	return;
}



void __cdecl
lego::image::Image_InitFromSurface
					(ImageBMP *ref_newImage,IDirectDrawSurface4 *surface,uint width,uint height,
					COLORREF penZero,COLORREF pen255)
{
	DWORD DVar1;
	
	if (globs::imageGlobs.freeList == NULL) {
		Image_AddList();
	}
	ref_newImage->width = width;
	ref_newImage->nextFree = ref_newImage;
	ref_newImage->flags = IMAGE_FLAG_NONE;
	ref_newImage->height = height;
	ref_newImage->surface = surface;
	ref_newImage->penZeroRGB = penZero;
	DVar1 = Image_DDColorMatch(surface,penZero);
	ref_newImage->penZero = DVar1;
	DVar1 = Image_DDColorMatch(surface,pen255);
	ref_newImage->pen255 = DVar1;
	return;
}



BOOL __cdecl lego::image::Image_SaveBMP(ImageBMP *image,char *fname)
{
	BOOL BVar1;
	
	BVar1 = ddraw::DirectDraw_SaveBMP(image->surface,fname);
	return BVar1;
}



G98CSurface * __thiscall lego::video::G98CSurface___deletor(void *this,G98CSurface *This,byte flag)
{
	G98CSurface___dtor((G98CSurface *)this);
	if (((uint)This & 1) != 0) {
										// Function shared between multiple uses that just calls std::free(void* ptr)
		game::LevelStruct3C_Free_Unwind((LevelStruct_3c *)this);
	}
	return (G98CSurface *)this;
}



void __thiscall lego::video::G98CSurface___dtor(G98CSurface *this)
{
	IDirectDrawSurface4 *ddSurface4;
	IDirectDrawPalette *This;
	
	this->vftable = &G98CSurface___vftable;
	ddSurface4 = this->m_surf;
	if (ddSurface4 != NULL) {
		(*ddSurface4->lpVtbl->Release)(ddSurface4);
		this->m_surf = NULL;
	}
	This = this->m_palette;
	if (This != NULL) {
		(*This->lpVtbl->Release)((IUnknown *)This);
		this->m_palette = NULL;
	}
	return;
}



G98CSurface * __thiscall
lego::video::G98CSurface___ctor
					(G98CSurface *this,int width,int height,int bpp,bool vram,bool fullScreen)
{
	bool bVar1;
	
	this->m_clipper = NULL;
	this->m_squashToEdge = false;
	this->m_15bit = false;
	this->m_surf = NULL;
	this->m_surfaceInited = false;
	this->vftable = &G98CSurface___vftable;
	G98CSurface__PreInit(this,fullScreen);
	bVar1 = G98CSurface__Init(this,width,height,bpp,vram);
	if (bVar1 != false) {
		this->m_surfaceInited = true;
	}
	return this;
}



bool __thiscall
lego::video::G98CSurface__Init(G98CSurface *this,int width,int height,int bpp,bool vram)
{
	IDirectDrawSurface4 *This;
	HRESULT HVar1;
	byte *pbVar2;
	int iVar3;
	int iVar4;
	DWORD DVar5;
	int iVar6;
	uint uVar7;
	D3DRMPaletteEntry palette [256];
	
										// (dwFlags should initially be 0)
										// dwFlags = DDSD_CAPS (0x1)
										// if (width  != 0) dwFlags |= DDSD_WIDTH (0x4)
										// if (height != 0) dwFlags |= DDSD_HEIGHT (0x2)
	uVar7 = (this->m_desc).dwFlags | -(uint)(height != 0) & 2 | -(uint)(width != 0) & 4 | 1;
	(this->m_desc).dwFlags = uVar7;
	this->m_bpp = bpp;
	if (width != 0) {
		(this->m_desc).dwWidth = width;
	}
	if (height != 0) {
		(this->m_desc).dwHeight = height;
	}
	if ((width == 0) && (height == 0)) {
										// DDSCAPS_PRIMARYSURFACE (0x200)
		(this->m_desc).ddsCaps.dwCaps = 0x200;
	}
	else {
										// DDSCAPS_OFFSCREENPLAIN (0x40)
		(this->m_desc).ddsCaps.dwCaps = 0x40;
										// if (useVideoMemory)
										//   DDSCAPS_VIDEOMEMORY | DDSCAPS_OFFSCREENPLAIN (0x4000 | 0x40)
										// else
										//   DDSCAPS_SYSTEMMEMORY | DDSCAPS_OFFSCREENPLAIN (0x800 | 0x40)
		(this->m_desc).ddsCaps.dwCaps = (-(uint)(vram != false) & 0x3800) + 0x840;
	}
	if (bpp != 0) {
										// DDSD_PIXELFORMAT (0x1000)
		(this->m_desc).dwFlags = uVar7 | 0x1000;
		(this->m_desc).ddpfPixelFormat.dwSize = 0x20;
										// specify as 16-bpp when proper depth is 15-bpp
		DVar5 = 0x10;
		if (bpp != 0xf) {
			DVar5 = bpp;
		}
		(this->m_desc).ddpfPixelFormat.dwRGBBitCount = DVar5;
		if (bpp == 24) {
										// 24-bpp
			(this->m_desc).ddpfPixelFormat.dwRBitMask = 0xff0000;
			(this->m_desc).ddpfPixelFormat.dwGBitMask = 0xff00;
			(this->m_desc).ddpfPixelFormat.dwBBitMask = 0xff;
										// DDPF_RGB (0x40)
			(this->m_desc).ddpfPixelFormat.dwFlags = 0x40;
		}
		else {
			if (bpp == 0x10) {
										// 16-bpp (proper)
				(this->m_desc).ddpfPixelFormat.dwRBitMask = 0xf800;
				(this->m_desc).ddpfPixelFormat.dwGBitMask = 0x7e0;
				(this->m_desc).ddpfPixelFormat.dwBBitMask = 0x1f;
										// DDPF_RGB (0x40)
				(this->m_desc).ddpfPixelFormat.dwFlags = 0x40;
			}
			else {
				if (bpp == 0xf) {
										// 15-bpp (treated as 16-bpp)
					(this->m_desc).ddpfPixelFormat.dwRBitMask = 0x7c00;
					(this->m_desc).ddpfPixelFormat.dwGBitMask = 0x3e0;
					(this->m_desc).ddpfPixelFormat.dwBBitMask = 0x1f;
										// DDPF_RGB (0x40)
					(this->m_desc).ddpfPixelFormat.dwFlags = 0x40;
				}
				else {
					if (bpp == 8) {
										// 8-bpp (indexed)
						(this->m_desc).ddpfPixelFormat.dwRBitMask = 0xff0000;
						(this->m_desc).ddpfPixelFormat.dwGBitMask = 0xff00;
						(this->m_desc).ddpfPixelFormat.dwBBitMask = 0xff;
										// DDPF_RGB | DDPF_PALETTEINDEXED8 (0x40 | 0x20)
						(this->m_desc).ddpfPixelFormat.dwFlags = 0x60;
					}
				}
			}
		}
	}
	HVar1 = (*(globs::animationGlobs.ddraw)->lpVtbl->CreateSurface)
										(globs::animationGlobs.ddraw,&this->m_desc,&this->m_surf,NULL);
	if (HVar1 == 0) {
		G98CSurface__Lock(this);
		G98CSurface__Unlock(this);
		if ((this->m_desc).ddpfPixelFormat.dwRGBBitCount != 8) {
LAB_0047e975:
			if ((this->m_desc).ddpfPixelFormat.dwRGBBitCount == 0x10) {
										// Count number of bits to check if we're actually using 15-bpp handling (when
										// surface considers it as 16-bpp)
				iVar6 = G98CSurface__CountMaskBits(this,(this->m_desc).ddpfPixelFormat.dwGBitMask);
				iVar3 = G98CSurface__CountMaskBits(this,(this->m_desc).ddpfPixelFormat.dwBBitMask);
				iVar4 = G98CSurface__CountMaskBits(this,(this->m_desc).ddpfPixelFormat.dwRBitMask);
				if (iVar6 + iVar3 + iVar4 == 0xf) {
					this->m_15bit = true;
				}
			}
			return true;
		}
		pbVar2 = &palette[0].green;
		iVar6 = 0x100;
		do {
			pbVar2[-1] = 0;
			*pbVar2 = 0;
			pbVar2[1] = 0;
			pbVar2[2] = 0;
			pbVar2 = pbVar2 + 4;
			iVar6 += -1;
		} while (iVar6 != 0);
										// DDPCAPS_8BIT (0x4)
		HVar1 = (*(globs::animationGlobs.ddraw)->lpVtbl->CreatePalette)
											(globs::animationGlobs.ddraw,4,palette,&this->m_palette,NULL);
		if (HVar1 == 0) {
			This = this->m_surf;
			HVar1 = (*This->lpVtbl->SetPalette)(This,this->m_palette);
			if (HVar1 == 0) goto LAB_0047e975;
		}
	}
	return false;
}



void __thiscall lego::video::G98CSurface__PreInit(G98CSurface *this,bool fullscreen)
{
	int iVar1;
	DDSURFACEDESC2 *pDVar2;
	
	pDVar2 = &this->m_desc;
	for (iVar1 = 0x1f; iVar1 != 0; iVar1 += -1) {
		pDVar2->dwSize = 0;
		pDVar2 = (DDSURFACEDESC2 *)&pDVar2->dwFlags;
	}
	(this->m_desc).dwSize = 0x7c;
	this->m_surf = NULL;
	this->m_palette = NULL;
	this->m_surfaceLocked = false;
	this->m_colourKeyed = false;
	return;
}



int __thiscall lego::video::G98CSurface__Width(void *this,G98CSurface *This)
{
	return *(int *)((int)this + 0x28);
}



int __thiscall lego::video::G98CSurface__Height(void *this,G98CSurface *This)
{
	return *(int *)((int)this + 0x24);
}



bool __thiscall lego::video::G98CSurface__Lock(G98CSurface *this)
{
	DDSURFACEDESC2 *pDVar1;
	IDirectDrawSurface4 *pIVar2;
	IDirectDrawSurface4Vtbl *pIVar3;
	HRESULT HVar4;
	int iVar5;
	DDSURFACEDESC2 *pDVar6;
	
	if (this->m_surfaceLocked == false) {
		pDVar1 = &this->m_desc;
		pDVar6 = pDVar1;
		for (iVar5 = 0x1f; iVar5 != 0; iVar5 += -1) {
			pDVar6->dwSize = 0;
			pDVar6 = (DDSURFACEDESC2 *)&pDVar6->dwFlags;
		}
		pIVar2 = this->m_surf;
		pIVar3 = pIVar2->lpVtbl;
		pDVar1->dwSize = 0x7c;
		HVar4 = (*pIVar3->Lock)(pIVar2,NULL,pDVar1,0x801,NULL);
		if (HVar4 == 0) {
			this->m_surfaceLocked = true;
			return true;
		}
	}
	return false;
}



bool __thiscall lego::video::G98CSurface__Unlock(G98CSurface *this)
{
	HRESULT HVar1;
	
	if (this->m_surfaceLocked != false) {
		HVar1 = (*this->m_surf->lpVtbl->Unlock)(this->m_surf,NULL);
		if (HVar1 == 0) {
			this->m_surfaceLocked = false;
			return true;
		}
	}
	return false;
}



int __thiscall lego::video::G98CSurface__CountMaskBits(G98CSurface *this,uint mask)
{
	int count;
	uint i;
	
	count = 0;
	i = 0;
	do {
		if ((mask & 1 << ((byte)i & 0x1f)) != 0) {
			count += 1;
		}
		i += 1;
	} while (i < 32);
	return count;
}



G98CAnimation * __thiscall lego::video::G98CAnimation___ctor(G98CAnimation *this,char *filename)
{
	IAVIStream **lplpIAVIStream;
	LONG LVar1;
	LONG LVar2;
	LONG LVar3;
	char *szFile;
	HRESULT HVar4;
	IGetFrame *pIVar5;
	DWORD DVar6;
	G98CSurface *pGVar7;
	int iVar8;
	AVISTREAMINFOA *pAVar9;
	undefined4 *in_FS_OFFSET;
	undefined4 local_c;
	undefined *puStack8;
	undefined4 local_4;
	
	local_c = *in_FS_OFFSET;
	local_4 = 0xffffffff;
	puStack8 = &LAB_0049e08b;
	*in_FS_OFFSET = &local_c;
	this->m_colourKeySet = false;
	this->m_init = false;
	this->m_movieSurf = NULL;
	this->vftable = &G98CAnimation___vftable;
	szFile = lego::file::File_VerifyFilename(filename);
	lplpIAVIStream = &this->m_aviStream;
	this->m_decompressFn = NULL;
	*lplpIAVIStream = NULL;
	pAVar9 = &this->m_aviStreamInfo;
	for (iVar8 = 0x23; iVar8 != 0; iVar8 += -1) {
		pAVar9->fccType = 0;
		pAVar9 = (AVISTREAMINFOA *)&pAVar9->fccHandler;
	}
	(this->m_movieRect).top = 0;
	(this->m_movieRect).bottom = 0;
	(this->m_movieRect).left = 0;
	(this->m_movieRect).right = 0;
	if (globs::animationGlobs.g98NoAvis == false) {
										// fccType "sdiv" (as DWORD)
		HVar4 = AVIStreamOpenFromFileA(lplpIAVIStream,szFile,1935960438,0,0,NULL);
		if (HVar4 == 0) {
										// AVIGETFRAMEF_BESTDISPLAYFMT (0x1)
			pIVar5 = AVIStreamGetFrameOpen(*lplpIAVIStream,(BITMAPINFOHEADER *)0x1);
			this->m_decompressFn = pIVar5;
			if (pIVar5 != NULL) {
				HVar4 = AVIStreamInfoA(*lplpIAVIStream,&this->m_aviStreamInfo,0x8c);
				if (HVar4 == 0) {
					DVar6 = timeGetTime();
					LVar1 = (this->m_aviStreamInfo).rcFrame.bottom;
					LVar2 = (this->m_aviStreamInfo).rcFrame.left;
					(this->m_movieRect).top = (this->m_aviStreamInfo).rcFrame.top;
					LVar3 = (this->m_aviStreamInfo).rcFrame.right;
					this->m_init = true;
					this->m_currFrame = 0;
					(this->m_movieRect).bottom = LVar1;
					(this->m_movieRect).left = LVar2;
					(this->m_movieRect).right = LVar3;
					this->m_startTime = (float)(ulonglong)DVar6 * 0.001;
					pGVar7 = (G98CSurface *)std::operator_new(0x98);
					local_4 = 0;
					if (pGVar7 == NULL) {
						pGVar7 = NULL;
					}
					else {
						pGVar7 = G98CSurface___ctor(pGVar7,(this->m_movieRect).right - (this->m_movieRect).left,
																				(this->m_movieRect).bottom - (this->m_movieRect).top,0,false
																				,false);
					}
					this->m_movieSurf = pGVar7;
				}
			}
		}
	}
	*in_FS_OFFSET = local_c;
	return this;
}



G98CAnimation * __thiscall
lego::video::G98CAnimation___deletor(void *this,G98CAnimation *This,byte flag)
{
	G98CAnimation___dtor((G98CAnimation *)this);
	if (((uint)This & 1) != 0) {
		game::LevelStruct3C_Free_Unwind((LevelStruct_3c *)this);
	}
	return (G98CAnimation *)this;
}



void __thiscall lego::video::G98CAnimation___dtor(G98CAnimation *this)
{
	G98CSurface *This;
	
	this->vftable = &G98CAnimation___vftable;
	if (globs::animationGlobs.g98NoAvis == false) {
		if (this->m_aviStream != NULL) {
			AVIStreamRelease(this->m_aviStream);
		}
		This = this->m_movieSurf;
		if (This != NULL) {
			(*This->vftable->deletor)(This,1);
		}
	}
	return;
}



void __thiscall lego::video::G98CAnimation__BMICopy(G98CAnimation *this,BITMAPINFO *bmi)
{
	G98CSurface *this_00;
	G98CSurface *pGVar1;
	uint uVar2;
	bool bVar3;
	bool bVar4;
	int stride;
	int height;
	uint uVar5;
	DWORD depth;
	undefined4 *puVar6;
	int width;
	undefined4 *puVar7;
	undefined4 *puVar8;
	BYTE *pBVar9;
	undefined4 *puVar10;
	bool local_8;
	
	bVar3 = false;
	this_00 = this->m_movieSurf;
	if ((this_00->m_surfaceLocked == false) && (bVar4 = G98CSurface__Lock(this_00), bVar4 != false)) {
		bVar3 = true;
	}
	puVar7 = (undefined4 *)(this_00->m_desc).lpSurface;
	width = (this->m_movieRect).right - (this->m_movieRect).left;
	pGVar1 = this->m_movieSurf;
	height = (this->m_movieRect).bottom - (this->m_movieRect).top;
	pBVar9 = &bmi->bmiColors[-10].rgbBlue + (bmi->bmiHeader).biSize;
	stride = (int)(pGVar1->m_desc).lPitch / 2;
	depth = 0xf;
	if (pGVar1->m_15bit == false) {
		depth = (pGVar1->m_desc).ddpfPixelFormat.dwRGBBitCount;
	}
	if (depth == 0xf) {
		puVar6 = (undefined4 *)(pBVar9 + (height + -1) * stride * 2);
		if (0 < height) {
			uVar2 = width * 2;
			do {
				puVar8 = puVar6;
				puVar10 = puVar7;
				for (uVar5 = uVar2 >> 2; uVar5 != 0; uVar5 -= 1) {
					*puVar10 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar10 = puVar10 + 1;
				}
				for (uVar5 = uVar2 & 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar10 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar10 = (undefined4 *)((int)puVar10 + 1);
				}
				puVar6 = (undefined4 *)((int)puVar6 + stride * -2);
				puVar7 = (undefined4 *)((int)puVar7 + stride * 2);
				height += -1;
			} while (height != 0);
		}
	}
	else {
										// "Corporate needs you to find the differences between these two code blocks."
										// 
										// (swap out the first `depth == 0xf` confition for `depth == 15 || depth ==
										// 16`)
		if (pGVar1->m_15bit == false) {
			depth = (pGVar1->m_desc).ddpfPixelFormat.dwRGBBitCount;
		}
		else {
			depth = 0xf;
		}
		if ((depth == 0x10) &&
			 (puVar6 = (undefined4 *)(pBVar9 + (height + -1) * stride * 2), 0 < height)) {
			uVar2 = width * 2;
			do {
				puVar8 = puVar6;
				puVar10 = puVar7;
				for (uVar5 = uVar2 >> 2; uVar5 != 0; uVar5 -= 1) {
					*puVar10 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar10 = puVar10 + 1;
				}
				for (uVar5 = uVar2 & 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar10 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar10 = (undefined4 *)((int)puVar10 + 1);
				}
				puVar6 = (undefined4 *)((int)puVar6 + stride * -2);
				puVar7 = (undefined4 *)((int)puVar7 + stride * 2);
				height += -1;
			} while (height != 0);
		}
	}
	if (bVar3) {
		G98CSurface__Unlock(this_00);
	}
	return;
}



bool __thiscall lego::video::G98CAnimation__Update(G98CAnimation *this)
{
	BITMAPINFO *bmi;
	DWORD DVar1;
	float10 fVar2;
	longlong lVar3;
	
	if (this->m_init == false) {
		return false;
	}
	if (globs::animationGlobs.g98NoAvis != false) {
		return false;
	}
	bmi = (BITMAPINFO *)AVIStreamGetFrame(this->m_decompressFn,this->m_currFrame);
	if (bmi != NULL) {
		G98CAnimation__BMICopy(this,bmi);
		DVar1 = timeGetTime();
		fVar2 = (float10)(ulonglong)(this->m_aviStreamInfo).dwRate /
						(float10)(ulonglong)(this->m_aviStreamInfo).dwScale;
		this->m_aviTimeScale = (float)fVar2;
		this->m_currTime = (float)((float10)(ulonglong)DVar1 * (float10)0.001);
		lVar3 = __ftol(((float10)(ulonglong)DVar1 * (float10)0.001 - (float10)this->m_startTime) * fVar2
									);
		this->m_currFrame = (uint)lVar3;
	}
	return true;
}



uint __thiscall lego::video::G98CAnimation__Length(G98CAnimation *this)
{
	if (globs::animationGlobs.g98NoAvis != false) {
		return 0;
	}
	return (this->m_aviStreamInfo).dwLength;
}



void __thiscall lego::video::G98CAnimation__SetTime(G98CAnimation *this,uint time)
{
	DWORD DVar1;
	
	if (globs::animationGlobs.g98NoAvis == false) {
		this->m_currFrame = time;
		DVar1 = timeGetTime();
		this->m_currTime = (float)(ulonglong)DVar1 * 0.001;
		this->m_startTime =
				 (float)(ulonglong)DVar1 * 0.001 -
				 (float)(ulonglong)this->m_currFrame / this->m_aviTimeScale;
	}
	return;
}



uint __thiscall lego::video::G98CAnimation__GetTime(G98CAnimation *this)
{
	return ~-(uint)(globs::animationGlobs.g98NoAvis != false) & this->m_currFrame;
}



void __cdecl lego::video::Animation_Initialise(IDirectDraw4 *directDraw)
{
	globs::animationGlobs.ddraw = directDraw;
										// WARNING: Could not recover jumptable at 0x0049b9ac. Too many branches
										// WARNING: Treating indirect jump as call
	AVIFileInit();
	return;
}



Animation_t * __cdecl lego::video::Animation_Load(char *fName)
{
	G98CAnimation *pGVar1;
	undefined4 *in_FS_OFFSET;
	undefined4 local_c;
	undefined *puStack8;
	undefined4 local_4;
	
	local_4 = 0xffffffff;
	puStack8 = &LAB_0049e0ab;
	local_c = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_c;
	pGVar1 = (G98CAnimation *)std::operator_new(0xc4);
	local_4 = 0;
	if (pGVar1 != NULL) {
		pGVar1 = G98CAnimation___ctor(pGVar1,fName);
		*in_FS_OFFSET = local_c;
		return (Animation_t *)pGVar1;
	}
	*in_FS_OFFSET = local_c;
	return (Animation_t *)NULL;
}



BOOL __cdecl lego::video::Animation_Update(Animation_t *aviPlayer)
{
	bool bVar1;
	
	bVar1 = G98CAnimation__Update((G98CAnimation *)aviPlayer);
	return (uint)bVar1;
}



void __cdecl lego::video::Animation_BlitToBackBuffer(Animation_t *anim,RECT *dest)
{
	IDirectDrawSurface4 *lpDDSrcSurface;
	IDirectDrawSurface4 *This;
	
	if (anim->m_init != false) {
		lpDDSrcSurface = anim->m_movieSurf->m_surf;
		This = ddraw::DirectDraw_bSurf();
										// DDBLT_WAIT (0x1000000)
		(*This->lpVtbl->Blt)(This,(LPRECT)dest,lpDDSrcSurface,NULL,0x1000000,NULL);
	}
	return;
}



void __cdecl lego::video::Animation_SetTime(Animation_t *anim,uint time)
{
	G98CAnimation__SetTime((G98CAnimation *)anim,time);
	return;
}



uint __cdecl lego::video::Animation_GetTime(Animation_t *anim)
{
	uint uVar1;
	
	uVar1 = G98CAnimation__GetTime((G98CAnimation *)anim);
	return uVar1;
}



uint __cdecl lego::video::Animation_GetLength(Animation_t *anim)
{
	uint uVar1;
	
	uVar1 = G98CAnimation__Length((G98CAnimation *)anim);
	return uVar1;
}



void __cdecl lego::video::Animation_Free(Animation_t *anim)
{
	if (anim != NULL) {
		(*anim->vftable->deletor)((G98CAnimation *)anim,1);
	}
	return;
}



BOOL __cdecl lego::video::Animation_IsOk(Animation_t *anim)
{
	return (uint)anim->m_init;
}



BOOL __cdecl lego::input::Input_InitKeysAndDI(void)
{
	HRESULT HVar1;
	int iVar2;
	char *pcVar3;
	int iVar4;
	GUID guidSysKeyboard;
	
										// GUID_SysKeyboard {6F1D2B61-D5A0-11CF-BFC7-444553540000}
	guidSysKeyboard._4_4_ = 0x11cfd5a0;
	guidSysKeyboard._0_4_ = 0x6f1d2b61;
	guidSysKeyboard._8_4_ = 0x4544c7bf;
	guidSysKeyboard._12_4_ = 0x5453;
	HVar1 = DirectInputCreateA(globs::mainGlobs.hInst,0x500,(IUnknown **)&globs::INPUT.lpdi,NULL);
	if (HVar1 != 0) {
		iVar4 = 118;
		pcVar3 = "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Input.c";
		iVar2 = 2;
		HVar1 = DirectInputCreateA(globs::mainGlobs.hInst,0x500,(IUnknown **)&globs::INPUT.lpdi,NULL);
		debug::Error_SetDXError(HVar1,iVar2,pcVar3,iVar4);
		return 0;
	}
	HVar1 = (*(globs::INPUT.lpdi)->lpVtbl->CreateDevice)
										(globs::INPUT.lpdi,(LPGUID)&guidSysKeyboard,&globs::INPUT.lpdiKeyboard,NULL);
	if (HVar1 != 0) {
		iVar4 = 121;
		pcVar3 = "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Input.c";
		iVar2 = 2;
		HVar1 = (*(globs::INPUT.lpdi)->lpVtbl->CreateDevice)
											(globs::INPUT.lpdi,(LPGUID)&guidSysKeyboard,&globs::INPUT.lpdiKeyboard,NULL);
		debug::Error_SetDXError(HVar1,iVar2,pcVar3,iVar4);
		return 0;
	}
	HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->SetDataFormat)
										(globs::INPUT.lpdiKeyboard,&idl::c_dfDIKeyboard);
	if (HVar1 != 0) {
		iVar4 = 124;
		pcVar3 = "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Input.c";
		iVar2 = 2;
		HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->SetDataFormat)
											(globs::INPUT.lpdiKeyboard,&idl::c_dfDIKeyboard);
		debug::Error_SetDXError(HVar1,iVar2,pcVar3,iVar4);
		return 0;
	}
										// DISCL_FOREGROUND | DISCL_NONEXCLUSIVE (0x4 | 0x2)
	HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->SetCooperativeLevel)
										(globs::INPUT.lpdiKeyboard,globs::mainGlobs.hWnd,6);
	if (HVar1 != 0) {
		iVar4 = 127;
		pcVar3 = "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Input.c";
		iVar2 = 2;
										// DISCL_FOREGROUND | DISCL_NONEXCLUSIVE (0x4 | 0x2)
		HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->SetCooperativeLevel)
											(globs::INPUT.lpdiKeyboard,globs::mainGlobs.hWnd,6);
		debug::Error_SetDXError(HVar1,iVar2,pcVar3,iVar4);
		return 0;
	}
	HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->Acquire)(globs::INPUT.lpdiKeyboard);
	globs::INPUT.fKeybdAcquired = (uint)(HVar1 == 0);
	return 1;
}



void __cdecl lego::input::Input_ReadKeys(void)
{
	IDirectInputDeviceA *This;
	HRESULT HVar1;
	int iVar2;
	undefined4 *puVar3;
	Input_Globs *pIVar4;
	
	This = globs::INPUT.lpdiKeyboard;
	iVar2 = 1;
	if (((byte)globs::mainGlobs.flags & CMD_FULLSCREEN) == 0) {
		iVar2 = globs::mainGlobs.active;
	}
	if (iVar2 == 0) {
		puVar3 = (undefined4 *)globs::INPUT.Key_Map;
		for (iVar2 = 0x40; iVar2 != 0; iVar2 += -1) {
			*puVar3 = 0;
			puVar3 = puVar3 + 1;
		}
		pIVar4 = &globs::INPUT;
		for (iVar2 = 0x40; iVar2 != 0; iVar2 += -1) {
			*(undefined4 *)pIVar4->prevKey_Map = 0;
			pIVar4 = (Input_Globs *)(pIVar4->prevKey_Map + 4);
		}
		(*(globs::INPUT.lpdiKeyboard)->lpVtbl->Unacquire)(globs::INPUT.lpdiKeyboard);
		return;
	}
	if (globs::INPUT.lpdiKeyboard != NULL) {
		if (globs::INPUT.fKeybdAcquired == 0) {
			iVar2 = -0x7ff8ffe2;
		}
		else {
			puVar3 = (undefined4 *)globs::INPUT.Key_Map;
			pIVar4 = &globs::INPUT;
			for (iVar2 = 0x40; iVar2 != 0; iVar2 += -1) {
				*(undefined4 *)pIVar4->prevKey_Map = *puVar3;
				puVar3 = puVar3 + 1;
				pIVar4 = (Input_Globs *)(pIVar4->prevKey_Map + 4);
			}
			puVar3 = (undefined4 *)globs::INPUT.Key_Map;
			for (iVar2 = 0x40; iVar2 != 0; iVar2 += -1) {
				*puVar3 = 0;
				puVar3 = puVar3 + 1;
			}
			iVar2 = (*This->lpVtbl->GetDeviceState)(This,0x100,(LPVOID)0x76bb80);
		}
		if (iVar2 != 0) {
			globs::INPUT.fKeybdAcquired = 0;
			HVar1 = (*(globs::INPUT.lpdiKeyboard)->lpVtbl->Acquire)(globs::INPUT.lpdiKeyboard);
			if (HVar1 == 0) {
				globs::INPUT.fKeybdAcquired = 1;
			}
		}
	}
	return;
}



uint __cdecl lego::input::Input_AnyKeyPressed(void)
{
	uint uVar1;
	bool *pbVar2;
	int iVar3;
	
	uVar1 = 0;
	pbVar2 = globs::INPUT.Key_Map;
	iVar3 = 0x100;
	do {
		if (*pbVar2 != false) {
			uVar1 += 1;
		}
		pbVar2 = pbVar2 + 1;
		iVar3 += -1;
	} while (iVar3 != 0);
	return uVar1;
}



void __cdecl lego::input::Input_ReleaseKeysAndDI(void)
{
	if (globs::INPUT.fKeybdAcquired != 0) {
		(*(globs::INPUT.lpdiKeyboard)->lpVtbl->Unacquire)(globs::INPUT.lpdiKeyboard);
		globs::INPUT.fKeybdAcquired = 0;
	}
	if (globs::INPUT.lpdiKeyboard != NULL) {
		(*(globs::INPUT.lpdiKeyboard)->lpVtbl->Release)((IUnknown *)globs::INPUT.lpdiKeyboard);
	}
	if (globs::INPUT.lpdi != NULL) {
		(*(globs::INPUT.lpdi)->lpVtbl->Release)((IUnknown *)globs::INPUT.lpdi);
	}
	return;
}



void __cdecl lego::input::Input_ReadMouse2(void)
{
	BOOL BVar1;
	tagPOINT clientPos;
	tagPOINT mousePos;
	tagRECT clientRect;
	
	BVar1 = GetClientRect(globs::mainGlobs.hWnd,(LPRECT)&clientRect);
	if (BVar1 != 0) {
		clientPos.y = 0;
		clientPos.x = 0;
		ClientToScreen(globs::mainGlobs.hWnd,(LPPOINT)&clientPos);
		GetCursorPos((LPPOINT)&mousePos);
		mousePos.x -= clientPos.x;
		mousePos.y -= clientPos.y;
		if ((int)globs::mainGlobs.appWidth <= mousePos.x) {
			mousePos.x = globs::mainGlobs.appWidth - 1;
		}
		if ((int)globs::mainGlobs.appHeight <= mousePos.y) {
			mousePos.y = globs::mainGlobs.appHeight - 1;
		}
		if (mousePos.x < 0) {
			mousePos.x = 0;
		}
		if (mousePos.y < 0) {
			mousePos.y = 0;
		}
		globs::INPUT.diffx = mousePos.x - globs::INPUT.msx;
		globs::INPUT.diffy = mousePos.y - globs::INPUT.msy;
		globs::INPUT.msx = mousePos.x;
		globs::INPUT.msy = mousePos.y;
	}
	return;
}



BOOL __cdecl lego::input::Input_SetCursorPos(int x,int y)
{
	BOOL BVar1;
	tagPOINT client;
	
	client.y = 0;
	client.x = 0;
	ClientToScreen(globs::mainGlobs.hWnd,(LPPOINT)&client);
	globs::INPUT.msy = y;
	globs::INPUT.msx = x;
	globs::INPUT.diffx = 0;
	globs::INPUT.diffy = 0;
	BVar1 = SetCursorPos(client.x + x,client.y + y);
	return BVar1;
}



// WARNING: Could not reconcile some variable overlaps

void __cdecl lego::file::File_Initialise(char *programName,BOOL insistOnCD,char *registryLocation)
{
	char cVar1;
	bool bVar2;
	int iVar3;
	BOOL BVar4;
	HANDLE handle;
	FILE *pFVar5;
	uint uVar6;
	uint uVar7;
	undefined4 *puVar8;
	char *pcVar9;
	char *pcVar10;
	char *pcVar11;
	undefined4 *puVar12;
	BOOL failed;
	char cwd [260];
	_finddata32_t fileinfo;
	char dataDir [260];
	char msgError [1024];
	char fname [1024];
	char msgNoCD [1024];
	
	bVar2 = false;
	failed = 0;
	std::_getcwd(cwd,MAX_PATH);
	uVar6 = 0xffffffff;
	pcVar10 = cwd;
	do {
		if (uVar6 == 0) break;
		uVar6 -= 1;
		cVar1 = *pcVar10;
		pcVar10 = pcVar10 + 1;
	} while (cVar1 != '\0');
	if (cwd[~uVar6 - 2] == '\\') {
		uVar6 = 0xffffffff;
		pcVar10 = cwd;
		do {
			if (uVar6 == 0) break;
			uVar6 -= 1;
			cVar1 = *pcVar10;
			pcVar10 = pcVar10 + 1;
		} while (cVar1 != '\0');
		cwd[~uVar6 - 2] = '\0';
	}
	std::sprintf(globs::fileGlobs.dataDir,"%s\\%s",cwd,"Data");
	uVar6 = 0;
	do {
		std::sprintf((char *)&fileinfo,"%s%i.wad",programName,uVar6);
		iVar3 = File_LoadWad((char *)&fileinfo);
		if (iVar3 != -1) {
			bVar2 = true;
		}
		uVar6 += 1;
	} while (uVar6 < 10);
	std::_getcwd(dataDir,MAX_PATH);
	uVar6 = 0xffffffff;
	pcVar10 = "\\Data";
	do {
		pcVar9 = pcVar10;
		if (uVar6 == 0) break;
		uVar6 -= 1;
		pcVar9 = pcVar10 + 1;
		cVar1 = *pcVar10;
		pcVar10 = pcVar9;
	} while (cVar1 != '\0');
	uVar6 = ~uVar6;
	iVar3 = -1;
	pcVar10 = dataDir;
	do {
		pcVar11 = pcVar10;
		if (iVar3 == 0) break;
		iVar3 += -1;
		pcVar11 = pcVar10 + 1;
		cVar1 = *pcVar10;
		pcVar10 = pcVar11;
	} while (cVar1 != '\0');
	puVar8 = (undefined4 *)(pcVar9 + -uVar6);
	puVar12 = (undefined4 *)(pcVar11 + -1);
	for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
		*puVar12 = *puVar8;
		puVar8 = puVar8 + 1;
		puVar12 = puVar12 + 1;
	}
	for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
		*(undefined *)puVar12 = *(undefined *)puVar8;
		puVar8 = (undefined4 *)((int)puVar8 + 1);
		puVar12 = (undefined4 *)((int)puVar12 + 1);
	}
	File_SetBaseSearchPath(dataDir);
	iVar3 = File_FindDataCD();
	while ((iVar3 == 0 && (insistOnCD != 0))) {
		msgError._0_4_ = 0x6f727245;
		msgError._4_2_ = 0x72;
		puVar8 = (undefined4 *)(msgError + 6);
		for (iVar3 = 0xfe; iVar3 != 0; iVar3 += -1) {
			*puVar8 = 0;
			puVar8 = puVar8 + 1;
		}
		*(undefined2 *)puVar8 = 0;
		BVar4 = registry::Registry_GetValue
											(registryLocation,"CDMissing",REGISTRY_STRING_VALUE,msgNoCD,0x400);
		if (BVar4 == 0) {
LAB_0047f59b:
			std::exit(0);
		}
		else {
			registry::Registry_GetValue
								(registryLocation,"SetupError",REGISTRY_STRING_VALUE,msgError,0x400);
			iVar3 = MessageBoxA(NULL,msgNoCD,msgError,1);
			if (iVar3 == 2) goto LAB_0047f59b;
		}
		iVar3 = File_FindDataCD();
	}
	if ((iVar3 == 0) && (!bVar2)) {
		failed = 1;
		handle = std::_findfirst32("*.*",&fileinfo);
		if (handle != (HANDLE)0xffffffff) {
			do {
				if ((((byte)fileinfo.attrib & 0x10) != 0) &&
					 (iVar3 = std::_stricmp(fileinfo.name,"Data"), iVar3 == 0)) {
					failed = 0;
					break;
				}
				iVar3 = std::_findnext32(handle,&fileinfo);
			} while (iVar3 == 0);
			std::_findclose(handle);
		}
	}
	if (insistOnCD != 0) {
		std::sprintf(fname,"%s\\%s","Data","cd.key");
		pFVar5 = std::fopen(fname,"r");
		if (pFVar5 != NULL) {
			std::fclose(pFVar5);
			failed = 1;
		}
	}
	if (failed == 0) {
		std::_mkdir("Data");
		std::sprintf(fname,"%s\\%s","Data","delme.dat");
		pFVar5 = std::fopen(fname,"r");
		if (pFVar5 != NULL) {
			std::fclose(pFVar5);
			std::_chmod(fname,FILE_ATTRIBUTE_NORMAL);
			std::remove(fname);
			return;
		}
	}
	else {
		msgError._0_4_ = 0x6f727245;
		msgError._4_2_ = 0x72;
		puVar8 = (undefined4 *)(msgError + 6);
		for (iVar3 = 0xfe; iVar3 != 0; iVar3 += -1) {
			*puVar8 = 0;
			puVar8 = puVar8 + 1;
		}
		*(undefined2 *)puVar8 = 0;
		BVar4 = registry::Registry_GetValue
											(registryLocation,"DataMissing",REGISTRY_STRING_VALUE,msgNoCD,0x400);
		if (BVar4 != 0) {
			registry::Registry_GetValue
								(registryLocation,"SetupError",REGISTRY_STRING_VALUE,msgError,0x400);
			MessageBoxA(NULL,msgNoCD,msgError,0);
		}
		std::exit(0);
	}
	return;
}



BOOL __cdecl lego::file::File_FindDataCD(void)
{
	UINT driveType;
	FILE *stream;
	char letter;
	uint rootName;
	char buffer [260];
	
	letter = 0x43;
	rootName = 0x5c3a41;
	do {
		rootName = rootName & 0xffffff00 | (uint)(byte)letter;
		driveType = GetDriveTypeA((LPCSTR)&rootName);
		if (driveType == DRIVE_CDROM) {
			std::sprintf(buffer,"%c:\\%s\\%s",letter,"Data","cd.key");
			stream = std::fopen(buffer,"r");
			if (stream != NULL) {
				std::fclose(stream);
				globs::fileGlobs.cdLetter = letter;
				return TRUE;
			}
		}
		letter += 1;
	} while ((byte)letter < 0x5b);
	return 0;
}



// This allows the translation from File paths into Wad names.

BOOL __cdecl lego::file::File_SetBaseSearchPath(char *basePath)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	int iVar4;
	undefined4 *puVar5;
	char *pcVar6;
	File_Globs *pFVar7;
	
	if (basePath != NULL) {
		uVar2 = 0xffffffff;
		pcVar6 = basePath;
		do {
			if (uVar2 == 0) break;
			uVar2 -= 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
										// if (std::strlen(dirname) != 0 && std::strlen(dirname) < 0x400)
		if (((int)(~uVar2 - 1) < 0x401) && (~uVar2 != 1)) {
										// std::strcpy(globals::g_FILEPATH_DATADIR_STRIP, dirname);
			uVar2 = 0xffffffff;
			do {
				pcVar6 = basePath;
				if (uVar2 == 0) break;
				uVar2 -= 1;
				pcVar6 = basePath + 1;
				cVar1 = *basePath;
				basePath = pcVar6;
			} while (cVar1 != '\0');
			uVar2 = ~uVar2;
			puVar5 = (undefined4 *)(pcVar6 + -uVar2);
			pFVar7 = &globs::fileGlobs;
			for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
				*(undefined4 *)pFVar7->wadBasePath = *puVar5;
				puVar5 = puVar5 + 1;
				pFVar7 = (File_Globs *)(pFVar7->wadBasePath + 4);
			}
			for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
				pFVar7->wadBasePath[0] = *(char *)puVar5;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
				pFVar7 = (File_Globs *)(pFVar7->wadBasePath + 1);
			}
			globs::fileGlobs.basePathSet = TRUE;
			return TRUE;
		}
	}
	globs::fileGlobs.basePathSet = 0;
	pFVar7 = &globs::fileGlobs;
	for (iVar4 = 0x100; iVar4 != 0; iVar4 += -1) {
		*(undefined4 *)pFVar7->wadBasePath = 0;
		pFVar7 = (File_Globs *)(pFVar7->wadBasePath + 4);
	}
	return 0;
}



void __cdecl lego::file::File_Error(char *msg,...)
{
	char buffer [1024];
	
	std::vsprintf(buffer,msg,&stack0x00000008);
	OutputDebugStringA(buffer);
	return;
}



int __cdecl lego::file::File_LoadWad(char *fName)
{
	int iVar1;
	
										// File_ErrorFile(0); // Open the wad error log
	util::logf_removed(NULL);
	iVar1 = wad::Wad_Load(fName);
	return iVar1;
}



BOOL __cdecl lego::file::File_GetCDFilePath(char *out_path,char *fname)
{
	if ((char)globs::fileGlobs._2580_4_ != '\0') {
		std::sprintf(out_path,"%c:\\%s\\%s",globs::fileGlobs._2580_4_ & 0xff,"Data",fname);
		return TRUE;
	}
	return 0;
}



int __cdecl lego::file::File_MakeDir(char *path)
{
	int iVar1;
	char buffer [260];
	
	std::sprintf(buffer,"%s\\%s","Data",path);
	iVar1 = std::_mkdir(buffer);
	return iVar1;
}



File * __cdecl lego::file::File_Open(char *fName,char *mode)
{
	char *pcVar1;
	FileSystemType FVar2;
	File *file;
	FILE *pFVar3;
	char *pcVar4;
	BOOL BVar5;
	char buffer [160];
	
	pcVar1 = File_VerifyFilename(fName);
	FVar2 = _File_CheckSystem(pcVar1,mode);
	if (FVar2 == FILESYSTEM_WAD) {
		file = _File_Alloc(FILESYSTEM_WAD);
		if (file == NULL) {
			return NULL;
		}
		pcVar4 = _File_GetWadName(pcVar1);
		BVar5 = _File_OpenWad((WADFILE *)file->stream,pcVar4);
		if (BVar5 != 0) {
			pcVar1 = _File_GetWadName(pcVar1);
			util::logf_removed("WAD Load %s\n",pcVar1);
			return file;
		}
		pcVar1 = _File_GetWadName(pcVar1);
		pcVar4 = "WAD Fail %s\n";
	}
	else {
		if (FVar2 != FILESYSTEM_STD) {
			File_Error("%s(%i) : Error in call to %s\n",
								 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",330,"File_Open");
			return NULL;
		}
		file = _File_Alloc(FILESYSTEM_STD);
		if (file == NULL) {
			return NULL;
		}
		pFVar3 = std::fopen(pcVar1,mode);
		file->stream = pFVar3;
		if (pFVar3 != NULL) {
			util::logf_removed("STD Load %s\n",pcVar1);
			return file;
		}
		pcVar4 = util::Util_StrIStr(mode,"w");
		if ((pcVar4 == NULL) && (BVar5 = File_GetCDFilePath(buffer,fName), BVar5 != 0)) {
			pFVar3 = std::fopen(buffer,mode);
			file->stream = pFVar3;
			if (pFVar3 != NULL) {
				return file;
			}
		}
		pcVar4 = "STD Fail %s\n";
	}
	util::logf_removed(pcVar4,pcVar1);
	_File_Dealloc(file);
	return NULL;
}



int __cdecl lego::file::File_Seek(File *f,int pos,int origin)
{
	int *piVar1;
	FileSystemType FVar2;
	int iVar3;
	
	FVar2 = _File_GetSystem(f);
	if (FVar2 != FILESYSTEM_WAD) {
		if (FVar2 != FILESYSTEM_STD) {
			File_Error("%s(%i) : Unknown file system in call to %s",
								 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",368,"File_Seek");
			return 0;
		}
		iVar3 = std::fseek((FILE *)f->stream,pos,origin);
		return iVar3;
	}
	if (origin == 0) {
		*(int *)(f->stream + 4) = pos;
		piVar1 = (int *)f->stream;
		iVar3 = wad::Wad_hLength(*piVar1);
		if (iVar3 < piVar1[1]) {
			iVar3 = wad::Wad_hLength(*piVar1);
			*(int *)(f->stream + 4) = iVar3;
		}
		if (*(int *)(f->stream + 4) < 0) {
			*(undefined4 *)(f->stream + 4) = 0;
		}
	}
	else {
		if (origin != 1) {
			if (origin != 2) {
				File_Error("Uknown seek mode (%i)",origin);
				return 0;
			}
			iVar3 = wad::Wad_hLength(*(int *)f->stream);
			*(int *)(f->stream + 4) = iVar3 + pos;
			return 0;
		}
		*(int *)(f->stream + 4) = *(int *)(f->stream + 4) + pos;
		piVar1 = (int *)f->stream;
		iVar3 = wad::Wad_hLength(*piVar1);
		if (iVar3 < piVar1[1]) {
			iVar3 = wad::Wad_hLength(*piVar1);
			*(int *)(f->stream + 4) = iVar3;
		}
		if (*(int *)(f->stream + 4) < 0) {
			*(undefined4 *)(f->stream + 4) = 0;
			return 0;
		}
	}
	return 0;
}



int __cdecl lego::file::File_Read(void *out_buffer,int size,int count,File *f)
{
	int iVar1;
	FileSystemType FVar2;
	size_t sVar3;
	int iVar4;
	void *pvVar5;
	uint uVar6;
	uint uVar7;
	undefined4 *puVar8;
	
	FVar2 = _File_GetSystem(f);
	if (FVar2 == FILESYSTEM_WAD) {
		iVar4 = wad::Wad_hLength(*(int *)f->stream);
		uVar6 = count * size;
		iVar1 = ((int *)f->stream)[1];
		if (iVar4 < (int)(iVar1 + uVar6)) {
			uVar6 = iVar4 - iVar1;
		}
		pvVar5 = wad::Wad_hData(*(int *)f->stream);
		puVar8 = (undefined4 *)((int)pvVar5 + *(int *)(f->stream + 4));
		for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
			*(undefined4 *)out_buffer = *puVar8;
			puVar8 = puVar8 + 1;
			out_buffer = (undefined4 *)((int)out_buffer + 4);
		}
		for (uVar7 = uVar6 & 3; uVar7 != 0; uVar7 -= 1) {
			*(undefined *)out_buffer = *(undefined *)puVar8;
			puVar8 = (undefined4 *)((int)puVar8 + 1);
			out_buffer = (undefined4 *)((int)out_buffer + 1);
		}
		*(uint *)(f->stream + 4) = *(int *)(f->stream + 4) + uVar6;
		return (int)uVar6 / size;
	}
	if (FVar2 == FILESYSTEM_STD) {
		sVar3 = std::fread(out_buffer,size,count,(FILE *)f->stream);
		return sVar3;
	}
	File_Error("%s(%i) : Unknown file system in call to %s",
						 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",395,____EMPTYSTR__);
	return 0;
}



int __cdecl lego::file::File_Write(void *buffer,int size,int count,File *f)
{
	FileSystemType FVar1;
	size_t sVar2;
	
	FVar1 = _File_GetSystem(f);
	if (FVar1 == FILESYSTEM_WAD) {
		File_Error("Cannot write to a file stored in a Wad!");
		return 0;
	}
	if (FVar1 != FILESYSTEM_STD) {
		File_Error("%s(%i) : Unknown file system in call to %s",
							 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",414,"File_Write");
		return 0;
	}
	sVar2 = std::fwrite(buffer,size,count,(FILE *)f->stream);
	return sVar2;
}



int __cdecl lego::file::File_Close(File *f)
{
	FileSystemType FVar1;
	
	FVar1 = _File_GetSystem(f);
	if ((-1 < (int)FVar1) && ((int)FVar1 < 2)) {
		_File_Dealloc(f);
		return 0;
	}
	File_Error("%s(%i) : Unknown file system in call to %s",
						 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",431,"File_Close");
	return 0;
}



int __cdecl lego::file::File_Tell(File *f)
{
	FileSystemType FVar1;
	int iVar2;
	
	FVar1 = _File_GetSystem(f);
	if (FVar1 == FILESYSTEM_WAD) {
		return *(int *)(f->stream + 4);
	}
	if (FVar1 != FILESYSTEM_STD) {
		File_Error("%s(%i) : Unknown file system in call to %s",
							 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",469,"File_Tell");
		return 0;
	}
	iVar2 = std::ftell((FILE *)f->stream);
	return iVar2;
}



BOOL __cdecl lego::file::File_Exists(char *fName)
{
	char *fName_00;
	FileSystemType FVar1;
	FILE *pFVar2;
	BOOL BVar3;
	char cdName [260];
	
	fName_00 = File_VerifyFilename(fName);
	FVar1 = _File_CheckSystem(fName_00,"r");
	if (FVar1 == FILESYSTEM_STD) {
		pFVar2 = std::fopen(fName_00,"r");
		if (pFVar2 != NULL) {
			std::fclose(pFVar2);
			return TRUE;
		}
		BVar3 = File_GetCDFilePath(cdName,fName);
		if (BVar3 != 0) {
			pFVar2 = std::fopen(cdName,"r");
			if (pFVar2 != NULL) {
				std::fclose(pFVar2);
				return TRUE;
			}
		}
	}
	else {
		if (FVar1 == FILESYSTEM_WAD) {
			BVar3 = wad::Wad_IsFileInWad(fName_00,globs::currWadHandle);
			return BVar3;
		}
	}
	return 0;
}



int __cdecl lego::file::File_GetC(File *f)
{
	int iVar1;
	int iVar2;
	FileSystemType FVar3;
	int iVar4;
	void *pvVar5;
	
	FVar3 = _File_GetSystem(f);
	if (FVar3 == FILESYSTEM_WAD) {
		iVar4 = wad::Wad_hLength(*(int *)f->stream);
		if (iVar4 + -1 <= ((int *)f->stream)[1]) {
			return -1;
		}
		iVar4 = f->stream;
		iVar1 = *(int *)(iVar4 + 4);
		pvVar5 = wad::Wad_hData(*(int *)f->stream);
		iVar2 = *(int *)((int)pvVar5 + iVar1);
		*(int *)(iVar4 + 4) = iVar1 + 1;
		return iVar2;
	}
	if (FVar3 != FILESYSTEM_STD) {
		File_Error("%s(%i) : Unknown file system in call to %s",
							 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",545,"File_GetC");
		return 0;
	}
	iVar4 = std::fgetc((FILE *)f->stream);
	return iVar4;
}



int __cdecl lego::file::File_Length(File *f)
{
	int pos;
	int iVar1;
	
	pos = File_Tell(f);
	File_Seek(f,0,SEEK_END);
	iVar1 = File_Tell(f);
	File_Seek(f,pos,SEEK_SET);
	return iVar1;
}



char * __cdecl lego::file::File_InternalFGetS(char *out_str,int num,File *f)
{
	char cVar1;
	int iVar2;
	int iVar3;
	
	iVar3 = 0;
	iVar2 = File_GetC(f);
	cVar1 = (char)iVar2;
	*out_str = cVar1;
	while ((((cVar1 != '\0' && (out_str[iVar3] != '\n')) && (out_str[iVar3] != -1)) && (iVar3 != num))
				) {
		iVar3 += 1;
		iVar2 = File_GetC(f);
		cVar1 = (char)iVar2;
		out_str[iVar3] = cVar1;
	}
	out_str[iVar3 + 1] = '\0';
	return (char *)(-(uint)(iVar3 != 0) & (uint)out_str);
}



char * __cdecl lego::file::File_GetS(char *out_str,int num,File *f)
{
	FileSystemType FVar1;
	char *pcVar2;
	
	FVar1 = _File_GetSystem(f);
	if (FVar1 == FILESYSTEM_WAD) {
		pcVar2 = File_InternalFGetS(out_str,num,f);
		return pcVar2;
	}
	if (FVar1 != FILESYSTEM_STD) {
		File_Error("%s(%i) : Unknown file system in call to %s",
							 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",587,"File_GetS");
		return NULL;
	}
	pcVar2 = std::fgets(out_str,num,(FILE *)f->stream);
	return pcVar2;
}



int __cdecl lego::file::File_PrintF(File *f,char *msg,...)
{
	FileSystemType FVar1;
	
	FVar1 = _File_GetSystem(f);
	if (FVar1 == FILESYSTEM_WAD) {
		File_Error("\"fprintf\" is unsupprted for wad files");
		return 0;
	}
	if (FVar1 != FILESYSTEM_STD) {
		File_Error("%s(%i) : Unknown file system in call to %s",
							 "C:\\Dev\\SourceSafe\\gods98_dx6\\gods98\\src\\Files.c",612,"File_PrintF");
		return 0;
	}
	std::vfprintf((FILE *)f->stream,msg,&stack0x0000000c);
	return 0;
}



FileSystemType __cdecl lego::file::_File_GetSystem(File *f)
{
	return f->type;
}



FileSystemType __cdecl lego::file::_File_CheckSystem(char *fName,char *mode)
{
	char cVar1;
	char *pcVar2;
	int iVar3;
	
	if ((fName != NULL) && (mode != NULL)) {
		iVar3 = -1;
		pcVar2 = fName;
		do {
			if (iVar3 == 0) break;
			iVar3 += -1;
			cVar1 = *pcVar2;
			pcVar2 = pcVar2 + 1;
		} while (cVar1 != '\0');
		if (iVar3 != -2) {
			iVar3 = -1;
			pcVar2 = mode;
			do {
				if (iVar3 == 0) break;
				iVar3 += -1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar2 + 1;
			} while (cVar1 != '\0');
			if (iVar3 != -2) {
				if ((*mode != 'w') && (*mode != 'W')) {
					iVar3 = globs::currWadHandle;
					pcVar2 = _File_GetWadName(fName);
					iVar3 = wad::Wad_IsFileInWad(pcVar2,iVar3);
					return (uint)(iVar3 == -1);
				}
				return FILESYSTEM_STD;
			}
		}
	}
	return FILESYSTEM_ERR;
}



BOOL __cdecl lego::file::_File_OpenWad(WADFILE *wad,char *fName)
{
	int iVar1;
	
	wad->eof = 0;
	wad->streamPos = 0;
	iVar1 = lego::wad::Wad_FileOpen(fName,globs::currWadHandle);
	wad->hFile = iVar1;
	return (uint)(iVar1 != -1);
}



File * __cdecl lego::file::_File_Alloc(FileSystemType fType)
{
	File *pFVar1;
	File *file;
	WADFILE *wadStream;
	
	if (fType == FILESYSTEM_STD) {
		pFVar1 = (File *)_File_Malloc(8);
		pFVar1->type = FILESYSTEM_STD;
		return pFVar1;
	}
	if (fType == FILESYSTEM_WAD) {
		file = (File *)_File_Malloc(8);
		if (file != NULL) {
			file->type = FILESYSTEM_WAD;
			wadStream = (WADFILE *)_File_Malloc(0xc);
			file->stream = wadStream;
			if (wadStream != NULL) {
				return file;
			}
			_File_Free(file);
		}
	}
	return NULL;
}



// (Change to whatever is required)

void * __cdecl lego::file::_File_Malloc(int size)
{
	void *pvVar1;
	
	pvVar1 = std::malloc(size);
	return pvVar1;
}



// (Change to whatever is required)

void __cdecl lego::file::_File_Free(void *ptr)
{
	std::free(ptr);
	return;
}



void __cdecl lego::file::_File_Dealloc(File *file)
{
	FileSystemType FVar1;
	
	if (file != NULL) {
		FVar1 = _File_GetSystem(file);
		if (FVar1 == FILESYSTEM_STD) {
			if ((FILE *)file->stream != NULL) {
				std::fclose((FILE *)file->stream);
				_File_Free(file);
				return;
			}
		}
		else {
			FVar1 = _File_GetSystem(file);
			if (FVar1 != FILESYSTEM_WAD) {
				return;
			}
			if ((int *)file->stream != NULL) {
				wad::Wad_FileClose(*(int *)file->stream);
				_File_Free((void *)file->stream);
			}
		}
		_File_Free(file);
	}
	return;
}



char * __cdecl lego::file::_File_GetWadName(char *fName)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	int iVar5;
	char *pcVar6;
	File_Globs *pFVar7;
	
	if (globs::fileGlobs.basePathSet == 0) {
		return fName;
	}
	uVar3 = 0xffffffff;
	pcVar6 = fName;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar6;
		pcVar6 = pcVar6 + 1;
	} while (cVar1 != '\0');
	uVar4 = 0xffffffff;
	pFVar7 = &globs::fileGlobs;
	do {
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar6 = pFVar7->wadBasePath;
		pFVar7 = (File_Globs *)(pFVar7->wadBasePath + 1);
	} while (*pcVar6 != '\0');
	iVar5 = ~uVar4 - 1;
	if ((int)(~uVar3 - 1) <= iVar5) {
		return fName;
	}
	cVar1 = fName[iVar5];
	fName[iVar5] = '\0';
	iVar2 = std::_stricmp(fName,(char *)&globs::fileGlobs);
	if (iVar2 == 0) {
		std::sprintf(globs::fileGlobs.s_GetWadName_wadedName,"%s",fName + ~uVar4);
		fName[iVar5] = cVar1;
		return globs::fileGlobs.s_GetWadName_wadedName;
	}
	fName[iVar5] = cVar1;
	return fName;
}



char * __cdecl lego::file::File_GetLine(char *out_str,uint size,File *file)
{
	char cVar1;
	char *pcVar2;
	uint uVar3;
	int iVar4;
	char *pcVar5;
	
	pcVar2 = File_GetS(out_str,size,file);
	uVar3 = 0xffffffff;
	pcVar5 = out_str;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	iVar4 = uVar3 - 2;
	if (out_str[iVar4] == '\n') {
		out_str[iVar4] = '\0';
	}
	if ((iVar4 != 0) && (out_str[uVar3 - 3] == '\r')) {
		out_str[uVar3 - 3] = '\0';
	}
	return pcVar2;
}



byte * __cdecl lego::file::File_LoadBinary(char *filename,uint *out_size)
{
	byte *buffer;
	
	buffer = (byte *)File_Load(filename,out_size,TRUE);
	return buffer;
}



void * __cdecl lego::file::File_Load(char *filename,uint *out_size,BOOL binary)
{
	char *mode;
	File *file;
	uint length;
	void *out_buffer;
	
	mode = "rb";
	if (binary == 0) {
		mode = "r";
	}
	file = File_Open(filename,mode);
	if (file != NULL) {
		File_Seek(file,0,SEEK_END);
		length = File_Tell(file);
		if (globs::fileGlobs.loadCallback != NULL) {
			(*globs::fileGlobs.loadCallback)(filename,length,globs::fileGlobs.loadCallbackData);
		}
		out_buffer = std::malloc(length);
		if (out_buffer != NULL) {
			File_Seek(file,0,0);
			File_Read(out_buffer,1,length,file);
			if (out_size != NULL) {
				*out_size = length;
			}
			File_Close(file);
			return out_buffer;
		}
		File_Close(file);
	}
	return NULL;
}



uint __cdecl lego::file::File_LoadBinaryHandle(char *filename,uint *out_size)
{
	File *f;
	uint fileSize;
	int bufferIndex;
	void *out_buffer;
	
	f = File_Open(filename,"rb");
	if (f != NULL) {
		File_Seek(f,0,SEEK_END);
		fileSize = File_Tell(f);
		if (globs::fileGlobs.loadCallback != NULL) {
			(*globs::fileGlobs.loadCallback)(filename,fileSize,globs::fileGlobs.loadCallbackData);
		}
		bufferIndex = Mem_AllocHandle(fileSize);
		if (bufferIndex != -1) {
			out_buffer = Mem_AddressHandle(bufferIndex);
			File_Seek(f,0,SEEK_SET);
			File_Read(out_buffer,1,fileSize,f);
			if (out_size != NULL) {
				*out_size = fileSize;
			}
			File_Close(f);
			return bufferIndex;
		}
		File_Close(f);
	}
	return 0xffffffff;
}



char * __cdecl lego::file::File_VerifyFilename(char *filename)
{
	char cVar1;
	char *pcVar2;
	int iVar3;
	uint uVar4;
	char part [260];
	
	if (filename != NULL) {
		if (*filename == '\\') {
			filename = filename + 1;
		}
		std::sprintf(part,"%s\\%s",0x5352a8,filename);
		pcVar2 = std::_fullpath(globs::fileGlobs.s_VerifyFilename_full,part,MAX_PATH);
		if (pcVar2 != NULL) {
			uVar4 = 0xffffffff;
			pcVar2 = globs::fileGlobs.dataDir;
			do {
				if (uVar4 == 0) break;
				uVar4 -= 1;
				cVar1 = *pcVar2;
				pcVar2 = pcVar2 + 1;
			} while (cVar1 != '\0');
			iVar3 = std::strncmp(globs::fileGlobs.s_VerifyFilename_full,globs::fileGlobs.dataDir,
													 ~uVar4 - 1);
			if (iVar3 == 0) {
				return globs::fileGlobs.s_VerifyFilename_full;
			}
		}
	}
	return NULL;
}



void __cdecl lego::file::File_SetLoadCallback(FileLoadCallback callback,void *data)
{
	globs::fileGlobs.loadCallback = callback;
	globs::fileGlobs.loadCallbackData = data;
	return;
}



void __cdecl lego::file::File_CheckRedundantFiles(char *logName)
{
	char cVar1;
	FILE *stream;
	int iVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	char *pcVar7;
	char (*pacVar8) [1024];
	char buffer [1024];
	
	stream = (FILE *)File_Open(logName,"r");
	if (stream != NULL) {
		globs::checkGlobs.numInList = 0;
		iVar2 = std::fscanf(stream,"%s",buffer);
		while (iVar2 != -1) {
			uVar3 = 0xffffffff;
			pacVar8 = globs::checkGlobs.loadedList[globs::checkGlobs.numInList];
			globs::checkGlobs.numInList += 1;
			pcVar6 = buffer;
			do {
				pcVar7 = pcVar6;
				if (uVar3 == 0) break;
				uVar3 -= 1;
				pcVar7 = pcVar6 + 1;
				cVar1 = *pcVar6;
				pcVar6 = pcVar7;
			} while (cVar1 != '\0');
			uVar3 = ~uVar3;
			puVar5 = (undefined4 *)(pcVar7 + -uVar3);
			for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
				*(undefined4 *)*pacVar8 = *puVar5;
				puVar5 = puVar5 + 1;
				pacVar8 = (char (*) [1024])(*pacVar8 + 4);
			}
			for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
				(*pacVar8)[0] = *(char *)puVar5;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
				pacVar8 = (char (*) [1024])(*pacVar8 + 1);
			}
			iVar2 = std::fscanf(stream,"%s",buffer);
		}
		File_CheckDirectory(globs::fileGlobs.dataDir);
		std::fclose(stream);
	}
	return;
}



void __cdecl lego::file::File_CheckDirectory(char *dirName)
{
	char cVar1;
	byte bVar2;
	HANDLE handle;
	byte *pbVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	char *pcVar7;
	undefined4 *puVar8;
	char *pcVar9;
	char *pcVar10;
	undefined4 *puVar11;
	bool bVar12;
	byte local_518;
	char local_504 [260];
	char name [1024];
	
	uVar4 = 0xffffffff;
	pcVar7 = dirName;
	do {
		pcVar9 = pcVar7;
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar9 = pcVar7 + 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar9;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar8 = (undefined4 *)(pcVar9 + -uVar4);
	puVar11 = (undefined4 *)name;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar11 = *puVar8;
		puVar8 = puVar8 + 1;
		puVar11 = puVar11 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar11 = *(undefined *)puVar8;
		puVar8 = (undefined4 *)((int)puVar8 + 1);
		puVar11 = (undefined4 *)((int)puVar11 + 1);
	}
	uVar4 = 0xffffffff;
	pcVar7 = "\\*.*";
	do {
		pcVar9 = pcVar7;
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar9 = pcVar7 + 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar9;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	iVar6 = -1;
	pcVar7 = name;
	do {
		pcVar10 = pcVar7;
		if (iVar6 == 0) break;
		iVar6 += -1;
		pcVar10 = pcVar7 + 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar10;
	} while (cVar1 != '\0');
	puVar8 = (undefined4 *)(pcVar9 + -uVar4);
	puVar11 = (undefined4 *)(pcVar10 + -1);
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar11 = *puVar8;
		puVar8 = puVar8 + 1;
		puVar11 = puVar11 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar11 = *(undefined *)puVar8;
		puVar8 = (undefined4 *)((int)puVar8 + 1);
		puVar11 = (undefined4 *)((int)puVar11 + 1);
	}
	handle = std::_findfirst32(name,(_finddata32_t *)&local_518);
	if (handle != (HANDLE)0xffffffff) {
		do {
			pcVar7 = ".";
			pbVar3 = (byte *)local_504;
			do {
				bVar2 = *pbVar3;
				bVar12 = bVar2 < (byte)*pcVar7;
				if (bVar2 != *pcVar7) {
LAB_00480709:
					iVar6 = (1 - (uint)bVar12) - (uint)(bVar12 != 0);
					goto LAB_0048070e;
				}
				if (bVar2 == 0) break;
				bVar2 = pbVar3[1];
				bVar12 = bVar2 < ((byte *)pcVar7)[1];
				if (bVar2 != ((byte *)pcVar7)[1]) goto LAB_00480709;
				pbVar3 = pbVar3 + 2;
				pcVar7 = (char *)((byte *)pcVar7 + 2);
			} while (bVar2 != 0);
			iVar6 = 0;
LAB_0048070e:
			if (iVar6 != 0) {
				pcVar7 = "..";
				pbVar3 = (byte *)local_504;
				do {
					bVar2 = *pbVar3;
					bVar12 = bVar2 < (byte)*pcVar7;
					if (bVar2 != *pcVar7) {
LAB_00480743:
						iVar6 = (1 - (uint)bVar12) - (uint)(bVar12 != 0);
						goto LAB_00480748;
					}
					if (bVar2 == 0) break;
					bVar2 = pbVar3[1];
					bVar12 = bVar2 < ((byte *)pcVar7)[1];
					if (bVar2 != ((byte *)pcVar7)[1]) goto LAB_00480743;
					pbVar3 = pbVar3 + 2;
					pcVar7 = (char *)((byte *)pcVar7 + 2);
				} while (bVar2 != 0);
				iVar6 = 0;
LAB_00480748:
				if (iVar6 != 0) {
					uVar4 = 0xffffffff;
					pcVar7 = dirName;
					do {
						pcVar9 = pcVar7;
						if (uVar4 == 0) break;
						uVar4 -= 1;
						pcVar9 = pcVar7 + 1;
						cVar1 = *pcVar7;
						pcVar7 = pcVar9;
					} while (cVar1 != '\0');
					uVar4 = ~uVar4;
					puVar8 = (undefined4 *)(pcVar9 + -uVar4);
					puVar11 = (undefined4 *)name;
					for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
						*puVar11 = *puVar8;
						puVar8 = puVar8 + 1;
						puVar11 = puVar11 + 1;
					}
					for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
						*(undefined *)puVar11 = *(undefined *)puVar8;
						puVar8 = (undefined4 *)((int)puVar8 + 1);
						puVar11 = (undefined4 *)((int)puVar11 + 1);
					}
					uVar4 = 0xffffffff;
					pcVar7 = "\\";
					do {
						pcVar9 = pcVar7;
						if (uVar4 == 0) break;
						uVar4 -= 1;
						pcVar9 = pcVar7 + 1;
						cVar1 = *pcVar7;
						pcVar7 = pcVar9;
					} while (cVar1 != '\0');
					uVar4 = ~uVar4;
					iVar6 = -1;
					pcVar7 = name;
					do {
						pcVar10 = pcVar7;
						if (iVar6 == 0) break;
						iVar6 += -1;
						pcVar10 = pcVar7 + 1;
						cVar1 = *pcVar7;
						pcVar7 = pcVar10;
					} while (cVar1 != '\0');
					puVar8 = (undefined4 *)(pcVar9 + -uVar4);
					puVar11 = (undefined4 *)(pcVar10 + -1);
					for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
						*puVar11 = *puVar8;
						puVar8 = puVar8 + 1;
						puVar11 = puVar11 + 1;
					}
					for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
						*(undefined *)puVar11 = *(undefined *)puVar8;
						puVar8 = (undefined4 *)((int)puVar8 + 1);
						puVar11 = (undefined4 *)((int)puVar11 + 1);
					}
					uVar4 = 0xffffffff;
					pcVar7 = local_504;
					do {
						pcVar9 = pcVar7;
						if (uVar4 == 0) break;
						uVar4 -= 1;
						pcVar9 = pcVar7 + 1;
						cVar1 = *pcVar7;
						pcVar7 = pcVar9;
					} while (cVar1 != '\0');
					uVar4 = ~uVar4;
					iVar6 = -1;
					pcVar7 = name;
					do {
						pcVar10 = pcVar7;
						if (iVar6 == 0) break;
						iVar6 += -1;
						pcVar10 = pcVar7 + 1;
						cVar1 = *pcVar7;
						pcVar7 = pcVar10;
					} while (cVar1 != '\0');
					puVar8 = (undefined4 *)(pcVar9 + -uVar4);
					puVar11 = (undefined4 *)(pcVar10 + -1);
					for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
						*puVar11 = *puVar8;
						puVar8 = puVar8 + 1;
						puVar11 = puVar11 + 1;
					}
					for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
						*(undefined *)puVar11 = *(undefined *)puVar8;
						puVar8 = (undefined4 *)((int)puVar8 + 1);
						puVar11 = (undefined4 *)((int)puVar11 + 1);
					}
					if ((local_518 & 0x10) == 0) {
						File_CheckFile(name);
					}
					else {
						File_CheckDirectory(name);
					}
				}
			}
			iVar6 = std::_findnext32(handle,(_finddata32_t *)&local_518);
		} while (iVar6 == 0);
		std::_findclose(handle);
	}
	return;
}



void __cdecl lego::file::File_CheckFile(char *fileName)
{
	int iVar1;
	uint uVar2;
	FileCheck_Globs *_Str2;
	
	uVar2 = 0;
	if (globs::checkGlobs.numInList != 0) {
		_Str2 = &globs::checkGlobs;
		do {
			iVar1 = std::_stricmp(fileName,(char *)_Str2);
			if (iVar1 == 0) {
				return;
			}
			uVar2 += 1;
			_Str2 = (FileCheck_Globs *)_Str2->loadedList[1];
		} while (uVar2 < globs::checkGlobs.numInList);
	}
	return;
}



BOOL __cdecl lego::res::Mesh_Initialise(char *sharedTextureDir)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	int iVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	undefined4 *puVar8;
	Mesh **ppMVar9;
	
	globs::meshGlobs.postRenderMeshList = NULL;
	Mesh_ClearPostRenderList();
	if (sharedTextureDir != NULL) {
		uVar2 = 0xffffffff;
		pcVar7 = sharedTextureDir;
		do {
			if (uVar2 == 0) break;
			uVar2 -= 1;
			cVar1 = *pcVar7;
			pcVar7 = pcVar7 + 1;
		} while (cVar1 != '\0');
		uVar2 = ~uVar2;
		uVar5 = uVar2 - 1;
		if (sharedTextureDir[uVar2 - 2] != '\\') {
			uVar5 = uVar2;
		}
		globs::meshGlobs.sharedTextureDir = (char *)std::malloc(uVar5 + 1);
		uVar2 = 0xffffffff;
		do {
			pcVar7 = sharedTextureDir;
			if (uVar2 == 0) break;
			uVar2 -= 1;
			pcVar7 = sharedTextureDir + 1;
			cVar1 = *sharedTextureDir;
			sharedTextureDir = pcVar7;
		} while (cVar1 != '\0');
		uVar2 = ~uVar2;
		puVar6 = (undefined4 *)(pcVar7 + -uVar2);
		puVar8 = (undefined4 *)globs::meshGlobs.sharedTextureDir;
		for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
			*puVar8 = *puVar6;
			puVar6 = puVar6 + 1;
			puVar8 = puVar8 + 1;
		}
		for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
			*(undefined *)puVar8 = *(undefined *)puVar6;
			puVar6 = (undefined4 *)((int)puVar6 + 1);
			puVar8 = (undefined4 *)((int)puVar8 + 1);
		}
		globs::meshGlobs.sharedTextureDir[uVar5 - 1] = '\\';
		globs::meshGlobs.sharedTextureDir[uVar5] = '\0';
	}
	ppMVar9 = globs::meshGlobs.listSet;
	for (iVar4 = 0x14; iVar4 != 0; iVar4 += -1) {
		*ppMVar9 = NULL;
		ppMVar9 = ppMVar9 + 1;
	}
	globs::meshGlobs.freeList = NULL;
	globs::meshGlobs.listCount = 0;
	Mesh_CreateGlobalMaterial();
	return 1;
}



BOOL __cdecl lego::res::Mesh_CreateGlobalMaterial(void)
{
	HRESULT HVar1;
	IDirect3D3 *d3d3;
	D3DMaterial material;
	
	material.dwSize = 0x50;
	material.diffuse.red = 1.0;
	material.diffuse.green = 1.0;
	material.diffuse.blue = 1.0;
	material.diffuse.alpha = 1.0;
	material.ambient.red = 0.0;
	material.ambient.green = 0.0;
	material.ambient.blue = 0.0;
	material.ambient.alpha = 0.0;
	material.specular.red = 0.0;
	material.specular.green = 0.0;
	material.specular.blue = 0.0;
	material.specular.alpha = 0.0;
	material.emissive.red = 0.0;
	material.emissive.green = 0.0;
	material.emissive.blue = 0.0;
	material.emissive.alpha = 0.0;
	material.power = 0.0;
	material.hTexture = 0;
	material.dwRampSize = 0;
										// IDirect3DDevice3->GetDirect3D(this, IDirect3D3** lplpD3D)
	(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetDirect3D)(globs::mainGlobs.imDevice,&d3d3);
										// IDirect3D3->CreateMaterial(this, IDirect3DMaterial3** lplpDirect3DMaterial3,
										// IUnknown* pUnkOuter)
	HVar1 = (**(code **)((int)*d3d3 + 0x14))(d3d3,&globs::meshGlobs.imMat,NULL);
	if (HVar1 == 0) {
										// IDirect3DMaterial3->GetHandle(this, IDirect3DDevice3* lpDirect3DDevice,
										// DWORD* lpHandle)
		HVar1 = (*(code *)(globs::meshGlobs.imMat)->lpVtbl->GetHandle)
											(globs::meshGlobs.imMat,globs::mainGlobs.imDevice,&globs::meshGlobs.matHandle)
		;
		if (HVar1 == 0) {
			Mesh_SetMaterial(&material);
			if (d3d3 != NULL) {
				(**(code **)((int)*d3d3 + 8))(d3d3);
			}
			return 1;
		}
		if (d3d3 != NULL) {
			(**(code **)((int)*d3d3 + 8))(d3d3);
		}
	}
	else {
		if (d3d3 != NULL) {
			(**(code **)((int)*d3d3 + 8))(d3d3);
			return 0;
		}
	}
	return 0;
}



BOOL __cdecl lego::res::Mesh_SetMaterial(D3DMaterial *newMaterial)
{
	HRESULT HVar1;
	
	HVar1 = (*(code *)(globs::meshGlobs.imMat)->lpVtbl->SetMaterial)
										(globs::meshGlobs.imMat,newMaterial);
	return (uint)(HVar1 == 0);
}



Mesh * __cdecl lego::res::Mesh_ObtainFromList(void)
{
	Mesh *pMVar1;
	int iVar2;
	Mesh *pMVar3;
	
	if (globs::meshGlobs.freeList == NULL) {
		Mesh_AddList();
	}
	pMVar1 = globs::meshGlobs.freeList;
	pMVar3 = globs::meshGlobs.freeList;
	globs::meshGlobs.freeList = (globs::meshGlobs.freeList)->nextFree;
	for (iVar2 = 0xd; iVar2 != 0; iVar2 += -1) {
		pMVar3->groupCount = 0;
		pMVar3 = (Mesh *)&pMVar3->listSize;
	}
	pMVar1->nextFree = pMVar1;
	return pMVar1;
}



void __cdecl lego::res::Mesh_ReturnToList(Mesh *mesh)
{
	mesh->nextFree = globs::meshGlobs.freeList;
	globs::meshGlobs.freeList = mesh;
	return;
}



void __cdecl lego::res::Mesh_AddList(void)
{
	Mesh *pMVar1;
	Mesh *pMVar2;
	int iVar3;
	uint uVar4;
	
	uVar4 = 1 << ((byte)globs::meshGlobs.listCount & 0x1f);
	pMVar2 = (Mesh *)std::malloc(uVar4 * 0x34);
	globs::meshGlobs.listSet[globs::meshGlobs.listCount] = pMVar2;
	pMVar2 = globs::meshGlobs.listSet[globs::meshGlobs.listCount];
	if (pMVar2 != NULL) {
		globs::meshGlobs.listCount += 1;
		if (1 < uVar4) {
			iVar3 = uVar4 - 1;
			pMVar1 = pMVar2;
			do {
				pMVar1->nextFree = pMVar1 + 1;
				iVar3 += -1;
				pMVar1 = pMVar1 + 1;
			} while (iVar3 != 0);
		}
		pMVar2[uVar4 - 1].nextFree = globs::meshGlobs.freeList;
		globs::meshGlobs.freeList = pMVar2;
	}
	return;
}



Mesh * __cdecl
lego::res::Mesh_CreateOnFrame
					(IDirect3DRMFrame3 *frame,_MeshRenderCallback *renderFunc,uint renderFlags,void *data,
					MeshType type)
{
	IDirect3DRMUserVisual **ppIVar1;
	Mesh *meshData;
	
	meshData = Mesh_ObtainFromList();
	GetRoot();
	ppIVar1 = &meshData->uv;
										// IDirect3DRM3->CreateUserVisual(this, TD3DRMUserVisualCallback fn, void*
										// lpArg, IDirect3DRMUserVisual** lplpD3DRMUV)
	(*(code *)(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateUserVisual)
						(globs::mainGlobs.lpD3DRM,Mesh_RenderCallback,meshData,ppIVar1);
										// IDirect3DRMFrame3->AddVisual(this, IDirect3DRMVisual* lpD3DRMVisual)
	(*frame->lpVtbl->AddVisual)(frame,(IDirect3DRMVisual *)*ppIVar1);
										// IDirect3DRMUserVisual->SetAppData(this, Struct_34* ulData)
	(*(*ppIVar1)->lpVtbl->SetAppData)((IDirect3DRMVisual *)*ppIVar1,meshData);
	(meshData->renderDesc).renderCallbackData = data;
	meshData->frameCreatedOn = frame;
	(meshData->renderDesc).renderCallback = (MeshRenderCallback)renderFunc;
	(meshData->renderDesc).renderFlags = renderFlags;
	if (type == MESH_TYPE_POSTEFFECT) {
		meshData->numOfRefs = 1;
		meshData->flags = meshData->flags | 2;
		return meshData;
	}
	if (type == MESH_TYPE_LIGHTWAVEOBJECT) {
		meshData->flags = meshData->flags | 4;
	}
	meshData->numOfRefs = 1;
	return meshData;
}



Mesh * __cdecl lego::res::Mesh_Clone(Mesh *mesh,IDirect3DRMFrame3 *frame)
{
	IDirect3DRMUserVisual **ppIVar1;
	Mesh *mesh_00;
	Mesh_Group *pMVar2;
	int iVar3;
	uint uVar4;
	IDirect3DRMFrame3 *unaff_EBP;
	Mesh *pMVar5;
	Mesh_Group *pMVar6;
	D3DRMGroupIndex groupID;
	Mesh *pMVar7;
	
	mesh_00 = Mesh_ObtainFromList();
	if (mesh->clonedFrom != NULL) {
		mesh = mesh->clonedFrom;
	}
	pMVar5 = mesh;
	pMVar7 = mesh_00;
	for (iVar3 = 0xd; iVar3 != 0; iVar3 += -1) {
		pMVar7->groupCount = pMVar5->groupCount;
		pMVar5 = (Mesh *)&pMVar5->listSize;
		pMVar7 = (Mesh *)&pMVar7->listSize;
	}
	mesh_00->clonedFrom = mesh;
	mesh_00->listSize = mesh_00->groupCount;
	pMVar2 = (Mesh_Group *)std::malloc(mesh_00->groupCount * 0x70);
	mesh_00->groupList = pMVar2;
	pMVar6 = mesh->groupList;
	for (uVar4 = mesh_00->groupCount * 0x70 >> 2; uVar4 != 0; uVar4 -= 1) {
		pMVar2->faceDataSize = pMVar6->faceDataSize;
		pMVar6 = (Mesh_Group *)&pMVar6->vertexCount;
		pMVar2 = (Mesh_Group *)&pMVar2->vertexCount;
	}
	for (iVar3 = 0; iVar3 != 0; iVar3 += -1) {
		*(undefined *)&pMVar2->faceDataSize = *(undefined *)&pMVar6->faceDataSize;
		pMVar6 = (Mesh_Group *)((int)&pMVar6->faceDataSize + 1);
		pMVar2 = (Mesh_Group *)((int)&pMVar2->faceDataSize + 1);
	}
	groupID = D3DRMGROUP_0;
	if (mesh_00->groupCount != 0) {
		iVar3 = 0;
		do {
			Mesh_CreateGroupMaterial(mesh_00,groupID);
			Mesh_SetGroupMaterial
								(mesh_00,groupID,(D3DMaterial *)((int)&(mesh->groupList->material).dwSize + iVar3));
			groupID += 1;
			iVar3 += 0x70;
		} while (groupID < mesh_00->groupCount);
	}
	ppIVar1 = &mesh_00->uv;
										// IDirect3DRM3->CreateUserVisual(this, TD3DRMUserVisualCallback fn, void*
										// lpArg, IDirect3DRMUserVisual** lplpD3DRMUV)
	(*(code *)(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateUserVisual)
						(globs::mainGlobs.lpD3DRM,Mesh_RenderCallback,mesh_00,ppIVar1);
										// IDirect3DRMFrame3->AddVisual(this, IDirect3DRMVisual* lpD3DRMVisual)
	(*unaff_EBP->lpVtbl->AddVisual)(unaff_EBP,(IDirect3DRMVisual *)*ppIVar1);
										// IDirect3DRMUserVisual->SetAppData(this, Struct_3c* ulData)
	(*(*ppIVar1)->lpVtbl->SetAppData)((IUnknown *)*ppIVar1,(DWORD)mesh_00);
	mesh_00->frameCreatedOn = unaff_EBP;
	mesh->numOfRefs = mesh->numOfRefs + 1;
	mesh->flags = mesh->flags | 0x200000;
	mesh_00->numOfRefs = 0;
	return mesh_00;
}



Mesh * __cdecl lego::res::Mesh_Load(char *filename,IDirect3DRMFrame3 *frame,BOOL noTextures)
{
	char *pcVar1;
	char cVar2;
	BOOL BVar3;
	Mesh *mesh;
	uint uVar4;
	uint uVar5;
	char *pcVar6;
	char *pcVar7;
	undefined4 *puVar8;
	undefined4 *puVar9;
	void *struct20;
	char filenameBuffer [260];
	
	uVar4 = 0xffffffff;
	pcVar7 = filename;
	do {
		pcVar6 = pcVar7;
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar6 = pcVar7 + 1;
		cVar2 = *pcVar7;
		pcVar7 = pcVar6;
	} while (cVar2 != '\0');
	uVar4 = ~uVar4;
	pcVar7 = filenameBuffer;
	puVar8 = (undefined4 *)(pcVar6 + -uVar4);
	puVar9 = (undefined4 *)filenameBuffer;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar9 = *puVar8;
		puVar8 = puVar8 + 1;
		puVar9 = puVar9 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar9 = *(undefined *)puVar8;
		puVar8 = (undefined4 *)((int)puVar8 + 1);
		puVar9 = (undefined4 *)((int)puVar9 + 1);
	}
	pcVar6 = filenameBuffer;
	while (filenameBuffer[0] != '\0') {
		if (filenameBuffer[0] == '\\') {
			pcVar7 = pcVar6;
		}
		pcVar1 = pcVar6 + 1;
		pcVar6 = pcVar6 + 1;
		filenameBuffer[0] = *pcVar1;
	}
	pcVar7[pcVar7 != filenameBuffer] = '\0';
	BVar3 = lw::LoadAppObj(filename,(APPOBJ **)&struct20,0);
	if (BVar3 == 0) {
		return NULL;
	}
	mesh = Mesh_CreateOnFrame(frame,NULL,0x3000,NULL,MESH_TYPE_LIGHTWAVEOBJECT);
	Mesh_ParseLWO(filenameBuffer,mesh,(APPOBJ *)struct20,noTextures);
	lw::FreeLWOB((APPOBJ *)struct20);
	return mesh;
}



// WARNING: Type propagation algorithm not settling

BOOL __cdecl
lego::res::Mesh_ParseLWO(char *basePath,Mesh *mesh,APPOBJ *lightWaveObject,BOOL noTextures)
{
	float r;
	uint uVar1;
	LWPOLY *pLVar2;
	Vector3F *buffer;
	Vector3F **buffer_00;
	uint *buffer_01;
	undefined4 *buffer_02;
	uint *buffer_03;
	uint *buffer_04;
	void *buffer_05;
	undefined4 *buffer_06;
	Mesh_LightWave_Surface *pMVar3;
	D3DRMGroupIndex groupID;
	char *pcVar4;
	Container_Texture *pCVar5;
	uint uVar6;
	int iVar7;
	float *pfVar8;
	int iVar9;
	float *pfVar10;
	uint *puVar11;
	int iVar12;
	int iVar13;
	int iVar14;
	int iVar15;
	uint uVar16;
	undefined4 *puVar17;
	int iVar18;
	float g;
	float fVar19;
	Point2F *textCoords;
	Point2F *local_ac;
	uint local_a8;
	uint local_a4;
	uint *local_a0;
	int *local_9c;
	Vector3F *local_98;
	uint *local_8c;
	Vector3F **local_88;
	Point2F *local_78;
	Point2F *local_74;
	int local_3c [4];
	undefined4 local_2c;
	undefined4 local_28;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	uVar6 = (lightWaveObject->aoSize).lwVertCount;
	local_3c[2] = 2;
	local_2c = 2;
	uVar1 = (lightWaveObject->aoSize).lwPolyCount;
	iVar12 = uVar6 * 2;
	iVar15 = uVar1 * 6;
	local_3c[0] = 0;
	local_3c[1] = 1;
	local_3c[3] = 0;
	local_28 = 3;
	local_74 = NULL;
	if (lightWaveObject->aoFileUV == NULL) {
		local_78 = (Point2F *)std::malloc(uVar6 * 0x10);
	}
	else {
		local_74 = (Point2F *)std::malloc(uVar6 * 0x140);
		Mesh_UViewMesh(lightWaveObject,local_74);
		iVar12 = (lightWaveObject->aoSize).lwVertCount * 2;
		local_78 = (Point2F *)std::malloc((lightWaveObject->aoSize).lwSurfaceCount * iVar12 * 8);
	}
	uVar16 = iVar12 * (lightWaveObject->aoSize).lwSurfaceCount;
	buffer = (Vector3F *)std::malloc(uVar16 * 0xc);
	buffer_00 = (Vector3F **)std::malloc(uVar16 * 4);
	buffer_01 = (uint *)std::malloc((lightWaveObject->aoSize).lwSurfaceCount << 2);
	buffer_02 = (undefined4 *)std::malloc(uVar16 * 4);
	buffer_03 = (uint *)std::malloc(iVar15 * (lightWaveObject->aoSize).lwSurfaceCount * 4);
	buffer_04 = (uint *)std::malloc((lightWaveObject->aoSize).lwSurfaceCount << 2);
	buffer_05 = std::malloc((lightWaveObject->aoSize).lwPolyCount * 0xc);
	buffer_06 = (undefined4 *)std::malloc(iVar12 * 0xc);
	puVar11 = buffer_01;
	for (uVar6 = (lightWaveObject->aoSize).lwSurfaceCount & 0x3fffffff; uVar6 != 0; uVar6 -= 1) {
		*puVar11 = 0;
		puVar11 = puVar11 + 1;
	}
	for (iVar7 = 0; iVar7 != 0; iVar7 += -1) {
		*(undefined *)puVar11 = 0;
		puVar11 = (uint *)((int)puVar11 + 1);
	}
	puVar17 = buffer_02;
	for (uVar16 &= 0x3fffffff; uVar16 != 0; uVar16 -= 1) {
		*puVar17 = 0xffffffff;
		puVar17 = puVar17 + 1;
	}
	for (iVar7 = 0; iVar7 != 0; iVar7 += -1) {
		*(undefined *)puVar17 = 0xff;
		puVar17 = (undefined4 *)((int)puVar17 + 1);
	}
	puVar11 = buffer_04;
	for (uVar6 = (lightWaveObject->aoSize).lwSurfaceCount & 0x3fffffff; uVar6 != 0; uVar6 -= 1) {
		*puVar11 = 0;
		puVar11 = puVar11 + 1;
	}
	for (iVar7 = 0; iVar7 != 0; iVar7 += -1) {
		*(undefined *)puVar11 = 0;
		puVar11 = (uint *)((int)puVar11 + 1);
	}
	puVar17 = buffer_06;
	for (uVar6 = iVar12 * 3 & 0x3fffffff; uVar6 != 0; uVar6 -= 1) {
		*puVar17 = 0;
		puVar17 = puVar17 + 1;
	}
	for (iVar7 = 0; iVar7 != 0; iVar7 += -1) {
		*(undefined *)puVar17 = 0;
		puVar17 = (undefined4 *)((int)puVar17 + 1);
	}
	pMVar3 = (Mesh_LightWave_Surface *)std::malloc((lightWaveObject->aoSize).lwSurfaceCount * 0x3c);
	mesh->lightWaveSurf = pMVar3;
	for (uVar6 = (lightWaveObject->aoSize).lwSurfaceCount * 0xf & 0x3fffffff; uVar6 != 0; uVar6 -= 1)
	{
		pMVar3->textureSeq = NULL;
		pMVar3 = (Mesh_LightWave_Surface *)&pMVar3->texture;
	}
	for (iVar7 = 0; iVar7 != 0; iVar7 += -1) {
		*(undefined *)&pMVar3->textureSeq = 0;
		pMVar3 = (Mesh_LightWave_Surface *)((int)&pMVar3->textureSeq + 1);
	}
	local_8c = NULL;
	if ((lightWaveObject->aoSize).lwPolyCount != 0) {
		local_9c = NULL;
		do {
			pLVar2 = lightWaveObject->aoPoly;
			pfVar10 = lightWaveObject->aoVerts;
			pfVar8 = &local_24.y;
			uVar6 = 0;
			do {
				uVar16 = uVar6 + 2;
				uVar6 = (uint)*(ushort *)(uVar6 + *(int *)((int)&pLVar2->plyData + (int)local_9c));
				pfVar8[-1] = pfVar10[uVar6 * 3];
				*pfVar8 = pfVar10[uVar6 * 3 + 1];
				pfVar8[1] = pfVar10[uVar6 * 3 + 2];
				pfVar8 = pfVar8 + 3;
				uVar6 = uVar16;
			} while (uVar16 < 6);
			math::Maths_PlaneNormal
								((Vector3F *)((int)buffer_05 + (int)local_9c),&local_24,&local_18,&local_c);
			local_8c = (uint *)((int)local_8c + 1);
			local_9c = (int *)((int)local_9c + 0xc);
		} while (local_8c < (lightWaveObject->aoSize).lwPolyCount);
	}
	Mesh_GetSurfInfo(basePath,lightWaveObject,mesh->lightWaveSurf,noTextures);
	iVar7 = 0;
	local_8c = NULL;
	if ((lightWaveObject->aoSize).lwPolyCount != 0) {
		pfVar10 = (float *)((int)buffer_05 + 8);
		do {
			iVar9 = *(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7);
			iVar13 = iVar15 * iVar9;
			iVar9 = iVar12 * iVar9;
			if (*(int *)((int)&lightWaveObject->aoPoly->plyCount + iVar7) == 3) {
				local_a4 = 0;
				do {
					iVar14 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
					uVar6 = (uint)*(ushort *)(*(int *)(iVar14 + 8) + local_a4);
					if (buffer_02[uVar6 + iVar9] == -1) {
						buffer[buffer_01[*(int *)(iVar14 + 4)] + iVar9].x = lightWaveObject->aoVerts[uVar6 * 3];
						buffer[buffer_01[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + iVar9].y
								 = lightWaveObject->aoVerts[uVar6 * 3 + 1];
						buffer[buffer_01[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + iVar9].z
								 = lightWaveObject->aoVerts[uVar6 * 3 + 2];
						if (lightWaveObject->aoFileUV != NULL) {
							iVar14 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
							uVar16 = (uint)*(ushort *)(*(int *)(iVar14 + 8) + local_a4);
							uVar6 = buffer_01[*(int *)(iVar14 + 4)];
							local_78[uVar6 + iVar9].x = local_74[uVar16].x;
							local_78[uVar6 + iVar9].y = local_74[uVar16].y;
						}
						uVar6 = (uint)*(ushort *)
													 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) + local_a4);
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						*pfVar8 = pfVar10[-2] + (float)buffer_06[uVar6 * 3];
						pfVar8[1] = pfVar8[1] + pfVar10[-1];
						pfVar8[2] = pfVar8[2] + *pfVar10;
						uVar6 = (uint)*(ushort *)
													 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) + local_a4);
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						fVar19 = 1.0 / SQRT(*pfVar8 * *pfVar8 +
																pfVar8[2] * pfVar8[2] +
																(float)buffer_06[uVar6 * 3 + 1] * (float)buffer_06[uVar6 * 3 + 1]);
						*pfVar8 = fVar19 * *pfVar8;
						pfVar8[1] = fVar19 * pfVar8[1];
						pfVar8[2] = fVar19 * pfVar8[2];
						iVar14 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_00[buffer_01[*(int *)(iVar14 + 4)] + iVar9] =
								 (Vector3F *)(buffer_06 + (uint)*(ushort *)(*(int *)(iVar14 + 8) + local_a4) * 3);
						iVar14 = *(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7);
						buffer_03[buffer_04[iVar14] + iVar13] = buffer_01[iVar14];
						buffer_04[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] =
								 buffer_04[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + 1;
						iVar14 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_02[(uint)*(ushort *)(*(int *)(iVar14 + 8) + local_a4) + iVar9] =
								 buffer_01[*(int *)(iVar14 + 4)];
						iVar14 = *(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7);
						puVar11 = buffer_01;
					}
					else {
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						*pfVar8 = pfVar10[-2] + (float)buffer_06[uVar6 * 3];
						pfVar8[1] = pfVar8[1] + pfVar10[-1];
						pfVar8[2] = pfVar8[2] + *pfVar10;
						pfVar8 = (float *)(buffer_06 +
															(uint)*(ushort *)
																		 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) +
																		 local_a4) * 3);
						fVar19 = 1.0 / SQRT(*pfVar8 * *pfVar8 + pfVar8[2] * pfVar8[2] + pfVar8[1] * pfVar8[1]);
						*pfVar8 = fVar19 * *pfVar8;
						pfVar8[1] = fVar19 * pfVar8[1];
						pfVar8[2] = fVar19 * pfVar8[2];
						iVar14 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_03[buffer_04[*(int *)(iVar14 + 4)] + iVar13] =
								 buffer_02[(uint)*(ushort *)(*(int *)(iVar14 + 8) + local_a4) + iVar9];
						iVar14 = *(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7);
						puVar11 = buffer_04;
					}
					local_a4 += 2;
					puVar11[iVar14] = puVar11[iVar14] + 1;
				} while (local_a4 < 6);
			}
			else {
				local_9c = local_3c;
				local_a8 = 6;
				do {
					iVar18 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
					iVar14 = *local_9c * 2;
					uVar6 = (uint)*(ushort *)(*(int *)(iVar18 + 8) + iVar14);
					if (buffer_02[iVar9 + uVar6] == -1) {
						buffer[buffer_01[*(int *)(iVar18 + 4)] + iVar9].x = lightWaveObject->aoVerts[uVar6 * 3];
						buffer[buffer_01[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + iVar9].y
								 = lightWaveObject->aoVerts[uVar6 * 3 + 1];
						buffer[buffer_01[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + iVar9].z
								 = lightWaveObject->aoVerts[uVar6 * 3 + 2];
						if (lightWaveObject->aoFileUV != NULL) {
							iVar18 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
							uVar16 = (uint)*(ushort *)(*(int *)(iVar18 + 8) + iVar14);
							uVar6 = buffer_01[*(int *)(iVar18 + 4)];
							local_78[uVar6 + iVar9].x = local_74[uVar16].x;
							local_78[uVar6 + iVar9].y = local_74[uVar16].y;
						}
						uVar6 = (uint)*(ushort *)
													 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) + iVar14);
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						*pfVar8 = pfVar10[-2] + (float)buffer_06[uVar6 * 3];
						pfVar8[1] = pfVar8[1] + pfVar10[-1];
						pfVar8[2] = pfVar8[2] + *pfVar10;
						uVar6 = (uint)*(ushort *)
													 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) + iVar14);
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						fVar19 = 1.0 / SQRT(*pfVar8 * *pfVar8 +
																(float)buffer_06[uVar6 * 3 + 2] * (float)buffer_06[uVar6 * 3 + 2] +
																(float)buffer_06[uVar6 * 3 + 1] * (float)buffer_06[uVar6 * 3 + 1]);
						*pfVar8 = fVar19 * *pfVar8;
						pfVar8[1] = fVar19 * pfVar8[1];
						pfVar8[2] = fVar19 * pfVar8[2];
						iVar18 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_00[buffer_01[*(int *)(iVar18 + 4)] + iVar9] =
								 (Vector3F *)(buffer_06 + (uint)*(ushort *)(*(int *)(iVar18 + 8) + iVar14) * 3);
						iVar18 = *(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7);
						buffer_03[buffer_04[iVar18] + iVar13] = buffer_01[iVar18];
						buffer_04[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] =
								 buffer_04[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + 1;
						iVar18 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_02[(uint)*(ushort *)(*(int *)(iVar18 + 8) + iVar14) + iVar9] =
								 buffer_01[*(int *)(iVar18 + 4)];
						puVar11 = buffer_01;
					}
					else {
						pfVar8 = (float *)(buffer_06 + uVar6 * 3);
						*pfVar8 = pfVar10[-2] + (float)buffer_06[uVar6 * 3];
						pfVar8[1] = pfVar8[1] + pfVar10[-1];
						pfVar8[2] = pfVar8[2] + *pfVar10;
						pfVar8 = (float *)(buffer_06 +
															(uint)*(ushort *)
																		 (*(int *)((int)&lightWaveObject->aoPoly->plyData + iVar7) +
																		 iVar14) * 3);
						fVar19 = 1.0 / SQRT(*pfVar8 * *pfVar8 + pfVar8[2] * pfVar8[2] + pfVar8[1] * pfVar8[1]);
						*pfVar8 = *pfVar8 * fVar19;
						pfVar8[1] = fVar19 * pfVar8[1];
						pfVar8[2] = fVar19 * pfVar8[2];
						iVar18 = (int)&lightWaveObject->aoPoly->plyCount + iVar7;
						buffer_03[buffer_04[*(int *)(iVar18 + 4)] + iVar13] =
								 buffer_02[(uint)*(ushort *)(*(int *)(iVar18 + 8) + iVar14) + iVar9];
						puVar11 = buffer_04;
					}
					puVar11[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] =
							 puVar11[*(int *)((int)&lightWaveObject->aoPoly->plySurface + iVar7)] + 1;
					local_9c = local_9c + 1;
					local_a8 += -1;
				} while (local_a8 != 0);
			}
			local_8c = (uint *)((int)local_8c + 1);
			iVar7 += 0xc;
			pfVar10 = pfVar10 + 3;
		} while (local_8c < (lightWaveObject->aoSize).lwPolyCount);
	}
	iVar15 = 0;
	local_a8 = 0;
	if ((lightWaveObject->aoSize).lwSurfaceCount != 0) {
		local_a4 = 0;
		local_ac = local_78;
		local_a0 = buffer_01;
		local_98 = buffer;
		local_8c = buffer_03;
		local_88 = buffer_00;
		do {
			uVar6 = *(uint *)((int)((int)buffer_04 - (int)buffer_01) + (int)local_a0);
			groupID = Mesh_AddGroup(mesh,uVar6,uVar6 / 3,3,local_8c);
			if (lightWaveObject->aoFileUV == NULL) {
				pcVar4 = lightWaveObject->aoSurface->srfTCLR + local_a4 + -0x10;
				Mesh_GetTextureUVsWrap
									(*local_a0,local_98,local_78,*(float *)(pcVar4 + 0x24),*(float *)(pcVar4 + 0x28),
									 *(float *)(pcVar4 + 0x2c),*(float *)(pcVar4 + 0x30),*(float *)(pcVar4 + 0x34),
									 *(float *)(pcVar4 + 0x38),*(LWTEXFLAGS *)(pcVar4 + 0x14));
				uVar6 = *local_a0;
				textCoords = local_78;
			}
			else {
				uVar6 = *local_a0;
				textCoords = local_ac;
			}
			Mesh_SetVertices_VNT(mesh,groupID,0,uVar6,local_98,local_88,(Point2I *)textCoords);
			if ((*(uint *)((int)&mesh->lightWaveSurf->flags + iVar15) & 0x200) == 0) {
				uVar6 = 0x3000;
			}
			else {
				Mesh_AlterGroupRenderFlags(mesh,groupID,0x2800);
				uVar6 = 0x2800;
			}
			if ((*(uint *)((int)&mesh->lightWaveSurf->flags + iVar15) & 0x100) != 0) {
				uVar6 |= 0x4000000;
				Mesh_AlterGroupRenderFlags(mesh,groupID,uVar6);
			}
			if ((*(byte *)((int)&mesh->lightWaveSurf->texFlags + iVar15) & 0x20) == 0) {
				Mesh_AlterGroupRenderFlags(mesh,groupID,uVar6 | 0x800000);
			}
			if ((lightWaveObject->aoSurface->srfTCLR[local_a4 + 4] & 0x80U) == 0) {
				pCVar5 = *(Container_Texture **)((int)&mesh->lightWaveSurf->texture + iVar15);
				if (pCVar5 != NULL) goto LAB_004818c5;
			}
			else {
				pCVar5 = *(Container_Texture **)((int)&mesh->lightWaveSurf->textureSeq + iVar15);
				if (pCVar5 != NULL) {
					pCVar5 = (Container_Texture *)pCVar5->surface;
LAB_004818c5:
					Mesh_SetGroupTexture(mesh,groupID,pCVar5);
				}
			}
			pMVar3 = mesh->lightWaveSurf;
			iVar7 = (int)&pMVar3->textureSeq + iVar15;
			Mesh_SetGroupColour(mesh,groupID,*(float *)(iVar7 + 0xc) * *(float *)(iVar7 + 0x1c),
													*(float *)(iVar7 + 0x10) * *(float *)(iVar7 + 0x1c),
													*(float *)((int)&(pMVar3->colour).blue + iVar15) *
													*(float *)((int)&pMVar3->diffuse + iVar15),MATERIAL_DIFFUSE);
			iVar7 = (int)&mesh->lightWaveSurf->textureSeq + iVar15;
			Mesh_SetGroupColour(mesh,groupID,*(float *)(iVar7 + 0xc) * *(float *)(iVar7 + 0x20),
													*(float *)(iVar7 + 0x10) * *(float *)(iVar7 + 0x20),
													*(float *)(iVar7 + 0x14) * *(float *)(iVar7 + 0x20),MATERIAL_EMISSIVE);
			iVar7 = (int)&mesh->lightWaveSurf->textureSeq + iVar15;
			if ((*(byte *)((int)&mesh->lightWaveSurf->flags + iVar15) & 8) == 0) {
				fVar19 = *(float *)(iVar7 + 0x24);
				g = *(float *)(iVar7 + 0x24);
				r = *(float *)(iVar7 + 0x24);
			}
			else {
				fVar19 = *(float *)(iVar7 + 0x14) * *(float *)(iVar7 + 0x24);
				g = *(float *)(iVar7 + 0x10) * *(float *)(iVar7 + 0x24);
				r = *(float *)(iVar7 + 0xc) * *(float *)(iVar7 + 0x24);
			}
			Mesh_SetGroupColour(mesh,groupID,r,g,fVar19,MATERIAL_SPECULAR);
			Mesh_SetGroupMaterialValues
								(mesh,groupID,*(float *)((int)&mesh->lightWaveSurf->power + iVar15) * 10.0,
								 MATERIAL_POWER);
			Mesh_SetGroupMaterialValues
								(mesh,groupID,1.0 - *(float *)((int)&mesh->lightWaveSurf->transparency + iVar15),
								 MATERIAL_ALPHA);
			pMVar3 = (Mesh_LightWave_Surface *)((int)&mesh->lightWaveSurf->textureSeq + iVar15);
			iVar15 += 0x3c;
			mesh->groupList[groupID].lightWaveSurfaceInfo = pMVar3;
			local_ac = local_ac + iVar12;
			local_88 = local_88 + iVar12;
			local_98 = local_98 + iVar12;
			local_8c = local_8c + uVar1 * 6;
			local_a0 = local_a0 + 1;
			local_a8 += 1;
			local_a4 += 0x54;
		} while (local_a8 < (lightWaveObject->aoSize).lwSurfaceCount);
	}
	std::free(buffer);
	std::free(buffer_00);
	std::free(local_78);
	std::free(buffer_01);
	std::free(buffer_02);
	std::free(buffer_03);
	std::free(buffer_04);
	std::free(buffer_05);
	std::free(buffer_06);
	if (local_74 != NULL) {
		std::free(local_74);
	}
	return 1;
}



void __cdecl
lego::res::Mesh_GetSurfInfo
					(char *basePath,APPOBJ *param_2,Mesh_LightWave_Surface *lightWaveSurf,BOOL noTextures)
{
	byte bVar1;
	char *path;
	BOOL BVar2;
	void *pvVar3;
	Container_Texture *pCVar4;
	float fVar5;
	ColourRGBAF *pCVar6;
	int iVar7;
	uint local_618;
	uint local_614;
	uint local_610;
	uint local_60c;
	char local_608 [4];
	char local_604 [260];
	char local_500 [256];
	char local_400 [256];
	char local_300 [256];
	char local_200 [256];
	char local_100 [256];
	
	local_614 = 0;
	if ((param_2->aoSize).lwSurfaceCount != 0) {
		pCVar6 = &lightWaveSurf->colour;
		iVar7 = 0;
		do {
			path = *(char **)(param_2->aoSurface->srfTCLR + iVar7 + -8);
			if ((path == NULL) || (noTextures != 0)) {
				pCVar6->red = (float)(uint)(byte)param_2->aoSurface->srfTCLR[iVar7 + -4] * 0.00390625;
				pCVar6->green = (float)(uint)(byte)param_2->aoSurface->srfTCLR[iVar7 + -3] * 0.00390625;
				bVar1 = param_2->aoSurface->srfTCLR[iVar7 + -2];
LAB_00481d09:
				local_618 = (uint)bVar1;
				pCVar6->blue = (float)local_618 * 0.00390625;
			}
			else {
				std::_splitpath(path,local_608,local_100,local_400,local_500);
				if ((param_2->aoSurface->srfTCLR[iVar7 + 4] & 0x80U) == 0) {
					std::sprintf(local_604,"%s%s",local_400,local_500);
					pCVar4 = Mesh_LoadTexture(basePath,local_604,0,0);
					pCVar6[-1].blue = (float)pCVar4;
				}
				else {
					BVar2 = Mesh_GetTextureSeqInfo(local_400,local_200,(int *)&local_60c,(int *)&local_610);
					if (BVar2 != 0) {
						pvVar3 = std::malloc(400);
						pCVar6[-1].green = (float)pvVar3;
						fVar5 = 0.0;
						do {
							Mesh_GetNextInSequence(local_200,local_300,&local_60c,local_610);
							std::sprintf(local_604,"%s%s",local_300,local_500);
							pCVar4 = Mesh_LoadTexture(basePath,local_604,0,0);
							*(Container_Texture **)((int)pCVar6[-1].green + (int)fVar5 * 4) = pCVar4;
							if (*(int *)((int)pCVar6[-1].green + (int)fVar5 * 4) == 0) break;
							fVar5 = (float)((int)fVar5 + 1);
						} while ((uint)fVar5 < 100);
						pCVar6[-1].alpha = fVar5;
						pvVar3 = std::realloc((void *)pCVar6[-1].green,(int)fVar5 * 4);
						pCVar6[-1].green = (float)pvVar3;
					}
				}
				if ((param_2->aoSurface->srfTCLR[iVar7 + 8] & 0x80U) != 0) {
					pCVar6->red = (float)(uint)(byte)param_2->aoSurface->srfTCLR[iVar7 + -4] * 0.00390625;
					pCVar6->green = (float)(uint)(byte)param_2->aoSurface->srfTCLR[iVar7 + -3] * 0.00390625;
					bVar1 = param_2->aoSurface->srfTCLR[iVar7 + -2];
					goto LAB_00481d09;
				}
				pCVar6->red = 1.0;
				pCVar6->green = 1.0;
				pCVar6->blue = 1.0;
			}
			pCVar6[1].green = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 0x2c);
			pCVar6[2].red = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 0x30);
			pCVar6[1].red = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 0x34);
			pCVar6[1].blue = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 0x3c);
			pCVar6[1].alpha = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 0x40);
			pCVar6[2].green = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 8);
			pCVar6[2].blue = *(float *)(param_2->aoSurface->srfTCLR + iVar7 + 4);
			local_614 += 1;
			pCVar6 = (ColourRGBAF *)&pCVar6[3].alpha;
			iVar7 = iVar7 + 0x54;
		} while (local_614 < (param_2->aoSize).lwSurfaceCount);
	}
	return;
}



BOOL __cdecl
lego::res::Mesh_GetTextureSeqInfo(char *tname,char *out_tfname,int *out_tstart,int *out_tnumlen)
{
	char cVar1;
	byte bVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	int iVar7;
	undefined4 *puVar8;
	char *pcVar9;
	char *pcVar10;
	undefined4 *puVar11;
	bool bVar12;
	int local_4;
	
	pcVar9 = tname;
	uVar3 = 0xffffffff;
	pcVar10 = tname;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar10;
		pcVar10 = pcVar10 + 1;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	iVar6 = 1;
	local_4 = 0;
	if ((0x2f < (byte)tname[uVar3 - 2]) && ((byte)tname[uVar3 - 2] < 0x3a)) {
		iVar7 = uVar3 - 2;
		bVar12 = iVar7 == 0;
		if (!bVar12) {
			do {
				bVar2 = pcVar9[iVar7];
				tname = (char *)(uint)bVar2;
				if ((bVar2 < 0x30) || (0x39 < bVar2)) break;
				local_4 += (int)(tname + -0x30) * iVar6;
				iVar6 *= 10;
				iVar7 += -1;
			} while (iVar7 != 0);
			bVar12 = iVar7 == 0;
		}
		if (!bVar12) {
			uVar4 = 0xffffffff;
			do {
				pcVar10 = pcVar9;
				if (uVar4 == 0) break;
				uVar4 -= 1;
				pcVar10 = pcVar9 + 1;
				cVar1 = *pcVar9;
				pcVar9 = pcVar10;
			} while (cVar1 != '\0');
			uVar4 = ~uVar4;
			puVar8 = (undefined4 *)(pcVar10 + -uVar4);
			puVar11 = (undefined4 *)out_tfname;
			for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
				*puVar11 = *puVar8;
				puVar8 = puVar8 + 1;
				puVar11 = puVar11 + 1;
			}
			for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
				*(undefined *)puVar11 = *(undefined *)puVar8;
				puVar8 = (undefined4 *)((int)puVar8 + 1);
				puVar11 = (undefined4 *)((int)puVar11 + 1);
			}
			out_tfname[iVar7 + 1] = '\0';
			*out_tnumlen = (uVar3 - iVar7) + -2;
			*out_tstart = local_4;
			return (BOOL)out_tnumlen;
		}
	}
	return (BOOL)NULL;
}



void __cdecl
lego::res::Mesh_GetNextInSequence
					(char *baseName,char *out_nextTextName,uint *out_texNum,uint tnumlen)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	int iVar5;
	undefined4 *puVar6;
	char *pcVar7;
	char *pcVar8;
	char *pcVar9;
	undefined4 *puVar10;
	char local_10 [16];
	
	uVar3 = 0xffffffff;
	do {
		pcVar8 = baseName;
		if (uVar3 == 0) break;
		uVar3 -= 1;
		pcVar8 = baseName + 1;
		cVar1 = *baseName;
		baseName = pcVar8;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	puVar6 = (undefined4 *)(pcVar8 + -uVar3);
	puVar10 = (undefined4 *)out_nextTextName;
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
		*puVar10 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar10 = puVar10 + 1;
	}
	for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)puVar10 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar10 = (undefined4 *)((int)puVar10 + 1);
	}
	std::sprintf(local_10,"%d",*out_texNum);
	uVar3 = 0xffffffff;
	pcVar8 = local_10;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar8;
		pcVar8 = pcVar8 + 1;
	} while (cVar1 != '\0');
	iVar2 = tnumlen - (~uVar3 - 1);
	while (iVar2 != 0) {
		uVar3 = 0xffffffff;
		pcVar8 = "0";
		do {
			pcVar7 = pcVar8;
			if (uVar3 == 0) break;
			uVar3 -= 1;
			pcVar7 = pcVar8 + 1;
			cVar1 = *pcVar8;
			pcVar8 = pcVar7;
		} while (cVar1 != '\0');
		uVar3 = ~uVar3;
		iVar5 = -1;
		pcVar8 = out_nextTextName;
		do {
			pcVar9 = pcVar8;
			if (iVar5 == 0) break;
			iVar5 += -1;
			pcVar9 = pcVar8 + 1;
			cVar1 = *pcVar8;
			pcVar8 = pcVar9;
		} while (cVar1 != '\0');
		puVar6 = (undefined4 *)(pcVar7 + -uVar3);
		puVar10 = (undefined4 *)(pcVar9 + -1);
		for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
			*puVar10 = *puVar6;
			puVar6 = puVar6 + 1;
			puVar10 = puVar10 + 1;
		}
		iVar2 += -1;
		for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
			*(undefined *)puVar10 = *(undefined *)puVar6;
			puVar6 = (undefined4 *)((int)puVar6 + 1);
			puVar10 = (undefined4 *)((int)puVar10 + 1);
		}
	}
	uVar3 = 0xffffffff;
	*out_texNum = *out_texNum + 1;
	pcVar8 = local_10;
	do {
		pcVar7 = pcVar8;
		if (uVar3 == 0) break;
		uVar3 -= 1;
		pcVar7 = pcVar8 + 1;
		cVar1 = *pcVar8;
		pcVar8 = pcVar7;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	iVar2 = -1;
	do {
		pcVar8 = out_nextTextName;
		if (iVar2 == 0) break;
		iVar2 += -1;
		pcVar8 = out_nextTextName + 1;
		cVar1 = *out_nextTextName;
		out_nextTextName = pcVar8;
	} while (cVar1 != '\0');
	puVar6 = (undefined4 *)(pcVar7 + -uVar3);
	puVar10 = (undefined4 *)(pcVar8 + -1);
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
		*puVar10 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar10 = puVar10 + 1;
	}
	for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)puVar10 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar10 = (undefined4 *)((int)puVar10 + 1);
	}
	return;
}



void __cdecl lego::res::Mesh_UViewMesh(APPOBJ *lightWaveObject,Point2F *textCoords)
{
	ushort *puVar1;
	float fVar2;
	float fVar3;
	char cVar4;
	File *file;
	bool bVar5;
	undefined4 *buffer;
	char *pcVar6;
	float *pfVar7;
	uint uVar8;
	int iVar9;
	uint uVar10;
	undefined4 *puVar11;
	char *pcVar12;
	undefined4 *puVar13;
	float10 fVar14;
	int local_840;
	int local_83c;
	int local_838;
	uint local_834;
	int local_830;
	int local_820;
	char *local_814;
	char *local_810;
	char local_800 [1024];
	undefined4 local_400 [256];
	
	file = lightWaveObject->aoFileUV;
	local_838 = -1;
	local_83c = -1;
	local_830 = 0;
	local_840 = -2;
	local_834 = 0;
	buffer = (undefined4 *)std::malloc((lightWaveObject->aoSize).lwVertCount << 3);
	puVar11 = buffer;
	for (uVar8 = ((lightWaveObject->aoSize).lwVertCount << 3) >> 2; uVar8 != 0; uVar8 -= 1) {
		*puVar11 = 0;
		puVar11 = puVar11 + 1;
	}
	for (iVar9 = 0; iVar9 != 0; iVar9 += -1) {
		*(undefined *)puVar11 = 0;
		puVar11 = (undefined4 *)((int)puVar11 + 1);
	}
	pcVar6 = lego::file::File_GetLine(local_800,0x400,file);
	do {
		if (pcVar6 == NULL) {
			std::free(buffer);
			return;
		}
		uVar8 = 0xffffffff;
		pcVar6 = local_800;
		do {
			pcVar12 = pcVar6;
			if (uVar8 == 0) break;
			uVar8 -= 1;
			pcVar12 = pcVar6 + 1;
			cVar4 = *pcVar6;
			pcVar6 = pcVar12;
		} while (cVar4 != '\0');
		uVar8 = ~uVar8;
		puVar11 = (undefined4 *)(pcVar12 + -uVar8);
		puVar13 = local_400;
		for (uVar10 = uVar8 >> 2; uVar10 != 0; uVar10 -= 1) {
			*puVar13 = *puVar11;
			puVar11 = puVar11 + 1;
			puVar13 = puVar13 + 1;
		}
		for (uVar8 &= 3; uVar8 != 0; uVar8 -= 1) {
			*(undefined *)puVar13 = *(undefined *)puVar11;
			puVar11 = (undefined4 *)((int)puVar11 + 1);
			puVar13 = (undefined4 *)((int)puVar13 + 1);
		}
		iVar9 = util::Util_WSTokenise((char *)local_400,&local_814);
		if (iVar9 != 0) {
			if (local_830 == 2) {
				local_838 = 0;
			}
			if (local_838 != -1) {
				uVar8 = (lightWaveObject->aoSize).lwSurfaceCount;
				if (local_838 < (int)(uVar8 * 2)) {
					if ((int)uVar8 <= local_838) {
						pcVar6 = std::_strdup(local_814);
						lightWaveObject->aoSurface[local_838 - (lightWaveObject->aoSize).lwSurfaceCount].srfPath
								 = pcVar6;
					}
					local_838 += 1;
				}
				else {
					local_838 = -1;
					local_840 = -1;
				}
			}
			if (local_840 != -2) {
				if (local_840 == -1) {
					local_840 = 0;
				}
				else {
					uVar8 = (lightWaveObject->aoSize).lwPolyCount;
					if ((int)uVar8 <= local_840) {
						return;
					}
					if ((local_83c == -1) || ((int)lightWaveObject->aoPoly[local_820].plyCount <= local_83c))
					{
						if (local_840 < (int)(uVar8 - 1)) {
							local_820 = std::atoi(local_814);
							if (local_83c != -1) {
								local_840 += 1;
							}
							local_83c = 0;
						}
					}
					else {
						fVar14 = std::atof(local_814);
						fVar2 = (float)fVar14;
						fVar14 = std::atof(local_810);
						fVar3 = (float)-fVar14;
						uVar8 = (uint)lightWaveObject->aoPoly[local_820].plyData[local_83c];
						if ((textCoords[uVar8].x == fVar2) && (textCoords[uVar8].y == fVar3)) {
							bVar5 = false;
						}
						else {
							bVar5 = true;
						}
						if (buffer[uVar8] == 0) {
							textCoords[uVar8].x = fVar2;
							textCoords[lightWaveObject->aoPoly[local_820].plyData[local_83c]].y = fVar3;
							puVar1 = lightWaveObject->aoPoly[local_820].plyData + local_83c;
							local_83c += 1;
							buffer[*puVar1] = 1;
						}
						else {
							if (bVar5) {
								if (local_834 == 0) {
									pfVar7 = (float *)std::realloc(lightWaveObject->aoVerts,
																								 ((lightWaveObject->aoSize).lwVertCount + 0xb) * 0xc
																								);
									lightWaveObject->aoVerts = pfVar7;
								}
								uVar10 = (uint)lightWaveObject->aoPoly[local_820].plyData[local_83c];
								uVar8 = (lightWaveObject->aoSize).lwVertCount;
								lightWaveObject->aoVerts[uVar8 * 3] = lightWaveObject->aoVerts[uVar10 * 3];
								lightWaveObject->aoVerts[uVar8 * 3 + 1] = lightWaveObject->aoVerts[uVar10 * 3 + 1];
								lightWaveObject->aoVerts[uVar8 * 3 + 2] = lightWaveObject->aoVerts[uVar10 * 3 + 2];
								lightWaveObject->aoPoly[local_820].plyData[local_83c] =
										 *(ushort *)&(lightWaveObject->aoSize).lwVertCount;
								textCoords[lightWaveObject->aoPoly[local_820].plyData[local_83c]].x = fVar2;
								textCoords[lightWaveObject->aoPoly[local_820].plyData[local_83c]].y = fVar3;
								local_834 += 1;
								(lightWaveObject->aoSize).lwVertCount = (lightWaveObject->aoSize).lwVertCount + 1;
								if (9 < local_834) {
									local_834 = 0;
								}
							}
							local_83c += 1;
						}
					}
				}
			}
			local_830 += 1;
		}
		pcVar6 = lego::file::File_GetLine(local_800,0x400,file);
	} while( true );
}



void __cdecl
lego::res::Mesh_GetTextureUVsWrap
					(uint vertexCount,Vector3F *vertices,Point2F *coords,float sx,float sy,float sz,float px,
					float py,float pz,LWTEXFLAGS flags)
{
	float fVar1;
	float fVar2;
	float fVar3;
	float *pfVar4;
	
	if (vertexCount != 0) {
		pfVar4 = &vertices->z;
		do {
			fVar1 = pfVar4[-1];
			fVar2 = *pfVar4;
			if ((flags & TFM_AXIS_X) == 0) {
				fVar3 = (pfVar4[-2] - px) / sx;
			}
			else {
				fVar3 = (fVar2 - pz) / sz;
			}
			coords->x = fVar3 - -0.5;
			if ((flags & TFM_AXIS_Y) == 0) {
				fVar1 = (fVar1 - py) / sy;
			}
			else {
				fVar1 = (fVar2 - pz) / sz;
			}
			pfVar4 = pfVar4 + 3;
			vertexCount -= 1;
			coords->y = fVar1 - -0.5;
			coords = coords + 1;
		} while (vertexCount != 0);
	}
	return;
}



BOOL __cdecl lego::res::Mesh_SetTextureTime2(Mesh *mesh,float frame)
{
	int *piVar1;
	int iVar2;
	int iVar3;
	D3DRMGroupIndex groupID;
	float10 fVar4;
	longlong lVar5;
	
	fVar4 = std::fmod((float10)frame,(float10)1.0);
	lVar5 = __ftol((float10)frame - fVar4);
	if ((*(byte *)&mesh->flags & 4) == 0) {
		return 0;
	}
	groupID = D3DRMGROUP_0;
	if (mesh->groupCount != 0) {
		iVar3 = 0;
		do {
			piVar1 = *(int **)((int)&mesh->groupList->lightWaveSurfaceInfo + iVar3);
			if (((*(byte *)(piVar1 + 0xd) & 0x80) != 0) && (piVar1[2] != 0)) {
				iVar2 = (piVar1[0xe] + (int)lVar5) % piVar1[2];
				if (iVar2 < 0) {
					iVar2 = 0;
				}
				Mesh_SetGroupTexture(mesh,groupID,*(Container_Texture **)(*piVar1 + iVar2 * 4));
			}
			groupID += 1;
			iVar3 += 0x70;
		} while (groupID < mesh->groupCount);
	}
	return 1;
}



void __cdecl lego::res::Mesh_Remove(Mesh *mesh,IDirect3DRMFrame3 *frame)
{
	Mesh *pMVar1;
	IDirect3DRMUserVisual *pIVar2;
	uint uVar3;
	D3DRMGroupIndex groupID;
	int iVar4;
	int iVar5;
	
	(*frame->lpVtbl->DeleteVisual)(frame,(IDirect3DRMVisual *)mesh->uv);
	pMVar1 = mesh->clonedFrom;
	groupID = D3DRMGROUP_0;
	if (pMVar1 != NULL) {
		pIVar2 = mesh->uv;
		if (pIVar2 != NULL) {
			(*pIVar2->lpVtbl->Release)((IUnknown *)pIVar2);
			mesh->uv = NULL;
		}
		std::free(mesh->groupList);
		Mesh_ReturnToList(mesh);
		mesh = pMVar1;
	}
	uVar3 = mesh->numOfRefs - 1;
	mesh->numOfRefs = uVar3;
	if (uVar3 == 0) {
		pIVar2 = mesh->uv;
		if (pIVar2 != NULL) {
			(*pIVar2->lpVtbl->Release)((IUnknown *)pIVar2);
			mesh->uv = NULL;
		}
		if (mesh->groupCount != 0) {
			iVar4 = 0;
			do {
				iVar5 = (int)&mesh->groupList->faceDataSize + iVar4;
				Mesh_RemoveGroupTexture(mesh,groupID);
				std::free(*(void **)(iVar5 + 8));
				std::free(*(void **)(iVar5 + 0xc));
				groupID += 1;
				iVar4 += 0x70;
			} while (groupID < mesh->groupCount);
		}
		if (mesh->lightWaveSurf != NULL) {
			std::free(mesh->lightWaveSurf);
		}
		std::free(mesh->groupList);
		Mesh_ReturnToList(mesh);
	}
	return;
}



Mesh_Group * __cdecl
lego::res::Mesh_GetGroup
					(Mesh *mesh,D3DRMGroupIndex groupID,uint *out_vertexCount,uint *unused_out_faceCount,
					uint *out_vPerFace,uint *out_faceDataSize,uint *out_faceData)
{
	ushort *puVar1;
	Mesh_Group *pMVar2;
	uint uVar3;
	
	pMVar2 = mesh->groupList + groupID;
	if (out_vertexCount != NULL) {
		*out_vertexCount = pMVar2->vertexCount;
	}
	if (out_vPerFace != NULL) {
		*out_vPerFace = 3;
	}
	if (out_faceDataSize != NULL) {
		*out_faceDataSize = pMVar2->faceDataSize;
	}
	if ((out_faceData != NULL) && (uVar3 = 0, pMVar2->faceDataSize != 0)) {
		do {
			puVar1 = pMVar2->faceData + uVar3;
			uVar3 += 1;
			*out_faceData = (uint)*puVar1;
			out_faceData = out_faceData + 1;
		} while (uVar3 < pMVar2->faceDataSize);
	}
	return pMVar2;
}



uint __cdecl lego::res::Mesh_GetGroupCount(Mesh *mesh)
{
	return mesh->groupCount;
}



int __cdecl
lego::res::Mesh_AddGroup(Mesh *mesh,uint vertexCount,uint faceCount,uint vPerFace,uint *faceData)
{
	ushort uVar1;
	Mesh_Group *pMVar2;
	ushort *puVar3;
	uint uVar4;
	Mesh_Vertex *pMVar5;
	int iVar6;
	Mesh_Group *pMVar7;
	uint uVar8;
	
	if (mesh->groupList == NULL) {
		mesh->listSize = 10;
		mesh->groupCount = 1;
		pMVar2 = (Mesh_Group *)std::malloc(0x460);
		mesh->groupList = pMVar2;
	}
	else {
		uVar4 = mesh->groupCount;
		mesh->groupCount = uVar4 + 1;
		if (uVar4 == mesh->listSize) {
			uVar4 = (mesh->listSize * 0x96) / 100;
			pMVar2 = (Mesh_Group *)std::realloc(mesh->groupList,uVar4 * 0x70);
			if (pMVar2 == NULL) {
				return -1;
			}
			mesh->groupList = pMVar2;
			mesh->listSize = uVar4;
		}
	}
	pMVar2 = mesh->groupList + (mesh->groupCount - 1);
	pMVar7 = pMVar2;
	for (iVar6 = 0x1c; iVar6 != 0; iVar6 += -1) {
		pMVar7->faceDataSize = 0;
		pMVar7 = (Mesh_Group *)&pMVar7->vertexCount;
	}
	uVar8 = vPerFace * faceCount;
	puVar3 = (ushort *)std::malloc(uVar8 * 2);
	pMVar2->faceData = puVar3;
	uVar4 = 0;
	pMVar2->faceDataSize = uVar8;
	if (uVar8 != 0) {
		do {
			uVar1 = *(ushort *)faceData;
			faceData = faceData + 1;
			pMVar2->faceData[uVar4] = uVar1;
			uVar4 += 1;
		} while (uVar4 < pMVar2->faceDataSize);
	}
	pMVar5 = (Mesh_Vertex *)std::malloc(vertexCount << 5);
	pMVar2->vertices = pMVar5;
	for (uVar4 = (vertexCount << 5) >> 2; uVar4 != 0; uVar4 -= 1) {
		(pMVar5->position).x = 0.0;
		pMVar5 = (Mesh_Vertex *)&(pMVar5->position).y;
	}
	for (iVar6 = 0; iVar6 != 0; iVar6 += -1) {
		*(undefined *)&(pMVar5->position).x = 0;
		pMVar5 = (Mesh_Vertex *)((int)&(pMVar5->position).x + 1);
	}
	pMVar2->vertexCount = vertexCount;
	pMVar2->flags = 0;
	Mesh_CreateGroupMaterial(mesh,mesh->groupCount + D3DRMGROUP_ALLGROUPS);
	return mesh->groupCount - 1;
}



void __cdecl lego::res::Mesh_AlterGroupRenderFlags(Mesh *mesh,D3DRMGroupIndex groupID,uint newFlags)
{
	mesh->groupList[groupID].renderFlags = newFlags;
	return;
}



void __cdecl lego::res::Mesh_Scale(Mesh *mesh,float x,float y,float z)
{
	float *pfVar1;
	float *pfVar2;
	Mesh_Group *iVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	int iVar7;
	
	uVar5 = 0;
	if (mesh->groupCount != 0) {
		iVar7 = 0;
		do {
			uVar6 = 0;
			iVar3 = (Mesh_Group *)((int)&mesh->groupList->faceDataSize + iVar7);
			if (iVar3->vertexCount != 0) {
				iVar4 = 0;
				do {
					uVar6 += 1;
					*(float *)((int)&(iVar3->vertices->position).x + iVar4) =
							 x * *(float *)((int)&(iVar3->vertices->position).x + iVar4);
					*(float *)((int)&(iVar3->vertices->position).y + iVar4) =
							 y * *(float *)((int)&(iVar3->vertices->position).y + iVar4);
					pfVar1 = (float *)((int)&(iVar3->vertices->position).z + iVar4);
					pfVar2 = (float *)((int)&(iVar3->vertices->position).z + iVar4);
					iVar4 += 0x20;
					*pfVar2 = z * *pfVar1;
				} while (uVar6 < iVar3->vertexCount);
			}
			uVar5 += 1;
			iVar7 += 0x70;
		} while (uVar5 < mesh->groupCount);
	}
	return;
}



void __cdecl
lego::res::Mesh_SetVertices
					(Mesh *mesh,D3DRMGroupIndex groupID,uint index,uint count,D3DRMVertex *vertices)
{
	int iVar1;
	float *pfVar2;
	Mesh_Group *pMVar3;
	float *pfVar4;
	
	pMVar3 = mesh->groupList + groupID;
	if (count != 0) {
		iVar1 = index << 5;
		pfVar2 = &vertices->tu;
		do {
			pfVar4 = (float *)((int)&(pMVar3->vertices->position).x + iVar1);
			*pfVar4 = pfVar2[-6];
			pfVar4[1] = pfVar2[-5];
			pfVar4[2] = pfVar2[-4];
			pfVar4 = (float *)((int)&(pMVar3->vertices->normal).x + iVar1);
			count -= 1;
			*pfVar4 = pfVar2[-3];
			pfVar4[1] = pfVar2[-2];
			pfVar4[2] = pfVar2[-1];
			*(float *)((int)&pMVar3->vertices->tu + iVar1) = *pfVar2;
			*(float *)((int)&pMVar3->vertices->tv + iVar1) = pfVar2[1];
			iVar1 = iVar1 + 0x20;
			pfVar2 = pfVar2 + 9;
		} while (count != 0);
	}
	return;
}



void __cdecl
lego::res::Mesh_GetVertices
					(Mesh *mesh,D3DRMGroupIndex groupID,uint index,uint count,D3DRMVertex *out_vertices)
{
	int iVar1;
	float *pfVar2;
	Mesh_Group *pMVar3;
	float *pfVar4;
	
	pMVar3 = mesh->groupList + groupID;
	if (count != 0) {
		iVar1 = index << 5;
		pfVar2 = &out_vertices->tu;
		do {
			pfVar4 = (float *)((int)&(pMVar3->vertices->position).x + iVar1);
			pfVar2[-6] = *pfVar4;
			pfVar2[-5] = pfVar4[1];
			pfVar2[-4] = pfVar4[2];
			pfVar4 = (float *)((int)&(pMVar3->vertices->normal).x + iVar1);
			count -= 1;
			pfVar2[-3] = *pfVar4;
			pfVar2[-2] = pfVar4[1];
			pfVar2[-1] = pfVar4[2];
			*pfVar2 = *(float *)((int)&pMVar3->vertices->tu + iVar1);
			pfVar2[1] = *(float *)((int)&pMVar3->vertices->tv + iVar1);
			iVar1 = iVar1 + 0x20;
			pfVar2 = pfVar2 + 9;
		} while (count != 0);
	}
	return;
}



void __cdecl
lego::res::Mesh_SetVertices_PointNormalAt
					(Mesh *mesh,D3DRMGroupIndex groupID,uint index,uint count,Vector3F *vertices,
					Vector3F *position,Point2F *textCoords)
{
	float *pfVar1;
	float fVar2;
	Vector3F *pVVar3;
	int iVar4;
	int iVar5;
	Mesh_Group *pMVar6;
	float *pfVar7;
	
	pVVar3 = position;
	pMVar6 = mesh->groupList + groupID;
	if (count != 0) {
		position = (Vector3F *)count;
		iVar5 = index << 5;
		pfVar7 = &vertices->z;
		do {
			*(float *)((int)&(pMVar6->vertices->position).x + iVar5) = pfVar7[-2];
			*(float *)((int)&(pMVar6->vertices->position).y + iVar5) = pfVar7[-1];
			*(float *)((int)&(pMVar6->vertices->position).z + iVar5) = *pfVar7;
			iVar4 = (int)&(pMVar6->vertices->position).x + iVar5;
			*(float *)(iVar4 + 0xc) = pVVar3->x - *(float *)((int)&(pMVar6->vertices->position).x + iVar5)
			;
			*(float *)(iVar4 + 0x10) = pVVar3->y - *(float *)(iVar4 + 4);
			*(float *)(iVar4 + 0x14) = pVVar3->z - *(float *)(iVar4 + 8);
			fVar2 = *(float *)((int)&(pMVar6->vertices->normal).y + iVar5);
			pfVar1 = (float *)((int)&(pMVar6->vertices->normal).x + iVar5);
			fVar2 = 1.0 / SQRT(*pfVar1 * *pfVar1 + pfVar1[2] * pfVar1[2] + fVar2 * fVar2);
			*pfVar1 = *pfVar1 * fVar2;
			pfVar1[1] = fVar2 * pfVar1[1];
			pfVar1[2] = fVar2 * pfVar1[2];
			*(float *)((int)&pMVar6->vertices->tu + iVar5) = textCoords->x;
			*(float *)((int)&pMVar6->vertices->tv + iVar5) = textCoords->y;
			position = (Vector3F *)((int)&position[-1].z + 3);
			iVar5 = iVar5 + 0x20;
			textCoords = textCoords + 1;
			pfVar7 = pfVar7 + 3;
		} while (position != NULL);
	}
	return;
}



void __cdecl
lego::res::Mesh_SetVertices_SameNormal
					(Mesh *mesh,D3DRMGroupIndex groupID,uint index,uint count,Vector3F *vertices,
					Vector3F *normal,Point2F *textCoords)
{
	float *pfVar1;
	int iVar2;
	Mesh_Group *pMVar3;
	float *pfVar4;
	
	pMVar3 = mesh->groupList + groupID;
	if (count != 0) {
		groupID = count;
		iVar2 = index << 5;
		pfVar4 = &vertices->z;
		do {
			*(float *)((int)&(pMVar3->vertices->position).x + iVar2) = pfVar4[-2];
			*(float *)((int)&(pMVar3->vertices->position).y + iVar2) = pfVar4[-1];
			*(float *)((int)&(pMVar3->vertices->position).z + iVar2) = *pfVar4;
			pfVar1 = (float *)((int)&(pMVar3->vertices->normal).x + iVar2);
			*pfVar1 = normal->x;
			pfVar1[1] = normal->y;
			pfVar1[2] = normal->z;
			*(float *)((int)&pMVar3->vertices->tu + iVar2) = textCoords->x;
			*(float *)((int)&pMVar3->vertices->tv + iVar2) = textCoords->y;
			groupID += D3DRMGROUP_ALLGROUPS;
			iVar2 = iVar2 + 0x20;
			pfVar4 = pfVar4 + 3;
			textCoords = textCoords + 1;
		} while (groupID != D3DRMGROUP_0);
	}
	return;
}



void __cdecl
lego::res::Mesh_SetVertices_VNT
					(Mesh *mesh,D3DRMGroupIndex groupID,uint index,uint count,Vector3F *vertices,
					Vector3F **normal,Point2I *textCoords)
{
	int iVar1;
	Mesh_Group *pMVar2;
	float *pfVar3;
	
	pMVar2 = mesh->groupList + groupID;
	if (count != 0) {
		groupID = count;
		iVar1 = index << 5;
		pfVar3 = &vertices->z;
		do {
			*(float *)((int)&(pMVar2->vertices->position).x + iVar1) = pfVar3[-2];
			*(float *)((int)&(pMVar2->vertices->position).y + iVar1) = pfVar3[-1];
			*(float *)((int)&(pMVar2->vertices->position).z + iVar1) = *pfVar3;
			*(float *)((int)&(pMVar2->vertices->normal).x + iVar1) = (*normal)->x;
			*(float *)((int)&(pMVar2->vertices->normal).y + iVar1) = (*normal)->y;
			*(float *)((int)&(pMVar2->vertices->normal).z + iVar1) = (*normal)->z;
			*(int *)((int)&pMVar2->vertices->tu + iVar1) = textCoords->x;
			*(int *)((int)&pMVar2->vertices->tv + iVar1) = textCoords->y;
			groupID += D3DRMGROUP_ALLGROUPS;
			iVar1 = iVar1 + 0x20;
			pfVar3 = pfVar3 + 3;
			normal = normal + 1;
			textCoords = textCoords + 1;
		} while (groupID != D3DRMGROUP_0);
	}
	return;
}



BOOL __cdecl lego::res::Mesh_IsGroupHidden(Mesh *mesh,D3DRMGroupIndex groupID)
{
	return mesh->groupList[groupID].flags & 1;
}



void __cdecl lego::res::Mesh_HideGroup(Mesh *mesh,D3DRMGroupIndex groupID,BOOL hide)
{
	Mesh_Group *pMVar1;
	
	pMVar1 = mesh->groupList + groupID;
	if (hide != 0) {
		pMVar1->flags = pMVar1->flags | 1;
		return;
	}
	pMVar1->flags = pMVar1->flags & 0xfffffffe;
	return;
}



void __cdecl lego::res::Mesh_Hide(Mesh *mesh,BOOL hide)
{
	if (hide != 0) {
		mesh->flags = mesh->flags | 1;
		return;
	}
	mesh->flags = mesh->flags & 0xfffffffe;
	return;
}



BOOL __cdecl
lego::res::Mesh_RenderCallback
					(IDirect3DRMUserVisual *lpD3DRMUV,Mesh *lpArg,D3DRMUserVisualReason lpD3DRMUVreason,
					IUnknown *lpD3DRMDev,IDirect3DRMViewport *lpD3DRMview)
{
	Mesh *mesh;
	IDirect3DRMViewport *This;
	Container *pCVar1;
	Viewport *pVVar2;
	Mesh *view;
	BOOL BVar3;
	bool bVar4;
	uint uVar5;
	int iVar6;
	IDirect3DRMViewport2 *unaff_ESI;
	Mesh_Group *pMVar7;
	int unaff_retaddr;
	IDirect3DRMViewport2 *rmView2;
	Matrix4F transform4d;
	
	mesh = lpArg;
	uVar5 = 0;
	if (lpD3DRMUVreason == D3DRMUSERVISUAL_CANSEE) {
		if (((globs::mainGlobs.imDevice != NULL) && ((*(byte *)&lpArg->flags & 1) == 0)) &&
			 ((pCVar1 = Container_SearchOwner(lpArg->frameCreatedOn), pCVar1 == NULL ||
				((*(byte *)&pCVar1->flags & 0x80) == 0)))) {
			if ((mesh->flags & 0x1000000) == 0) {
				return 1;
			}
			if ((mesh->flags & 0x2000000) != 0) {
				return 1;
			}
										// DWORD IDirect3DRMViewport->GetAppData(this)
										// struct with field_28 -> IDirect3DRMFrame3*
			pVVar2 = (*((IDirect3DRMFrame3Vtbl *)lpD3DRMview->lpVtbl)->GetAppData)(lpD3DRMview);
			if (pVVar2->rendering == 0) {
				return 1;
			}
										// IDirect3DRMFrame3->GetScene(this, IDirect3DRMFrame3** lplpRoot)
			(*mesh->frameCreatedOn->lpVtbl->GetScene)(mesh->frameCreatedOn,(IDirect3DRMFrame3 **)&lpArg);
										// IDirect3DRMViewport2->GetCamera(this, IDirect3DRMFrame3** lplpCamera)
			(*pVVar2->lpVP->lpVtbl->GetCamera)(pVVar2->lpVP,(IDirect3DRMFrame3 **)&lpD3DRMview);
										// IDirect3DRMFrame3->LookAt(this, IDirect3DRMFrame3* lpTarget,
										// IDirect3DRMFrame3* lpRef, TD3DRMFrameConstraint rfcConstraint)
										// 
										//  D3DRMCONSTRAIN_Z (0x0)
			(*mesh->frameCreatedOn->lpVtbl->LookAt)
								(mesh->frameCreatedOn,(IDirect3DRMFrame3 *)lpD3DRMview,(IDirect3DRMFrame3 *)lpArg,
								 D3DRMCONSTRAIN_Z);
			mesh->flags = mesh->flags | 0x2000000;
			return 1;
		}
	}
	else {
		if (lpD3DRMUVreason == D3DRMUSERVISUAL_RENDER) {
			if (globs::mainGlobs.imDevice != NULL) {
				bVar4 = false;
				lpArg->flags = lpArg->flags & 0xfdffffff;
										// IDirect3DDevice3->GetTransform(this, D3DTransformStateType
										// dtstTransformStateType, Matrix4F* lpD3DMatrix)
				(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetTransform)
									(globs::mainGlobs.imDevice,D3DTRANSFORMSTATE_WORLD,&transform4d);
				This = lpD3DRMview;
				Mesh_SetCurrentViewport(lpD3DRMview);
										// IDirect3DRMViewport->QueryInterface(this, IID_IDirect3DRMViewport2,
										// IDirect3DRMViewport2** lplpOut)
				(*((IDirect3DRMFrame3Vtbl *)This->lpVtbl)->QueryInterface)
									((IUnknown *)This,(IID *)&idl::IID_IDirect3DRMViewport2,&rmView2);
										// DWORD IDirect3DRMViewport2->GetAppData(this)
				view = (Mesh *)(*unaff_ESI->lpVtbl->GetAppData)(unaff_ESI);
				lpArg = view;
				if ((*(byte *)&mesh->flags & 2) == 0) {
					if (((mesh->renderDesc).renderFlags & 0x1c00) == 0) {
						Mesh_StoreTextureAndMat();
						Mesh_SetMeshRenderDesc(mesh,(Viewport *)view,(Matrix4F *)&stack0xffffffb4,0);
						bVar4 = true;
						Mesh_RenderMesh(mesh,(Matrix4F *)&stack0xffffffb4,0);
					}
					else {
						if (mesh->groupCount != 0) {
							transform4d.values[3][3] = 0.0;
							do {
								pMVar7 = (Mesh_Group *)
												 ((int)&mesh->groupList->faceDataSize + (int)transform4d.values[3][3]);
								BVar3 = Mesh_CanRenderGroup(pMVar7);
								if (BVar3 != 0) {
									if ((pMVar7->flags & 0x80000) == 0) {
										if (pMVar7->renderFlags == 0) {
											if (!bVar4) {
												Mesh_StoreTextureAndMat();
												Mesh_SetMeshRenderDesc
																	(mesh,(Viewport *)lpArg,(Matrix4F *)&stack0xffffffb4,0);
												bVar4 = true;
											}
											Mesh_RenderGroup(mesh,pMVar7,(Matrix4F *)&stack0xffffffb4,0);
										}
									}
									else {
										unaff_retaddr = 1;
									}
								}
								uVar5 += 1;
								transform4d.values[3][3] = (float)((int)transform4d.values[3][3] + 0x70);
							} while (uVar5 < mesh->groupCount);
						}
						iVar6 = 0;
						transform4d.values[3][3] = 0.0;
						if (mesh->groupCount != 0) {
							do {
								pMVar7 = (Mesh_Group *)((int)&mesh->groupList->faceDataSize + iVar6);
								BVar3 = Mesh_CanRenderGroup(pMVar7);
								if (BVar3 != 0) {
									if ((pMVar7->flags & 0x80000) == 0) {
										if (pMVar7->renderFlags != 0) {
											if (!bVar4) {
												Mesh_StoreTextureAndMat();
												Mesh_SetMeshRenderDesc
																	(mesh,(Viewport *)lpArg,(Matrix4F *)&stack0xffffffb4,0);
												bVar4 = true;
											}
											Mesh_RenderGroup(mesh,pMVar7,(Matrix4F *)&stack0xffffffb4,0);
										}
									}
									else {
										unaff_retaddr = 1;
									}
								}
								transform4d.values[3][3] = (float)((int)transform4d.values[3][3] + 1);
								iVar6 += 0x70;
							} while ((uint)transform4d.values[3][3] < mesh->groupCount);
						}
						if (unaff_retaddr != 0) {
							Mesh_AddToPostRenderList(mesh,(Matrix4F *)&stack0xffffffb4);
						}
					}
				}
				else {
					Mesh_AddToPostRenderList(mesh,(Matrix4F *)&stack0xffffffb4);
				}
				if (bVar4) {
					main::Main_RestoreStates();
					Mesh_RestoreTextureAndMat();
				}
				if (unaff_ESI != NULL) {
										// IDirect3DRMViewport2->Release(this)
					(*unaff_ESI->lpVtbl->Release)((IUnknown *)unaff_ESI);
				}
			}
			return 1;
		}
	}
	return 0;
}



void __cdecl
lego::res::Mesh_SetMeshRenderDesc(Mesh *mesh,Viewport *view,Matrix4F *matWorld,BOOL alphaBlend)
{
	MeshRenderCallback p_Var1;
	
	p_Var1 = (mesh->renderDesc).renderCallback;
	if (p_Var1 != NULL) {
		(*p_Var1)(mesh,(mesh->renderDesc).renderCallbackData,view);
	}
										// D3DRENDERSTATE_SPECULARENABLE (0x1d), FALSE (0x0)
	main::Main_ChangeRenderState(D3DRENDERSTATE_SPECULARENABLE,FALSE);
										// D3DRENDERSTATE_SHADEMODE (0x9), D3DSHADE_GOURAUD (0x2)
	main::Main_ChangeRenderState(D3DRENDERSTATE_SHADEMODE,D3DSHADE_GOURAUD);
										// D3DRENDERSTATE_DITHERENABLE (0x1a), TRUE (0x1)
	main::Main_ChangeRenderState(D3DRENDERSTATE_DITHERENABLE,TRUE);
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
										// D3DTSS_COLORARG1 (0x2), D3DTA_TEXTURE (0x2)
		Mesh_ChangeTextureStageState(D3DTSS_COLORARG1,D3DTA_TEXTURE);
										// D3DTSS_COLORARG2 (0x3), D3DTA_DIFFUSE (0x0)
		Mesh_ChangeTextureStageState(D3DTSS_COLORARG2,D3DTA_DIFFUSE);
										// D3DTSS_ALPHAARG1 (0x5), D3DTA_TEXTURE (0x2)
		Mesh_ChangeTextureStageState(D3DTSS_ALPHAARG1,D3DTA_TEXTURE);
										// D3DTSS_ALPHAARG2 (0x6), D3DTA_DIFFUSE (0x0)
		Mesh_ChangeTextureStageState(D3DTSS_ALPHAARG2,D3DTA_DIFFUSE);
	}
	Mesh_SetRenderDesc((mesh->renderDesc).renderFlags,matWorld,alphaBlend);
	return;
}



void __cdecl lego::res::Mesh_SetRenderDesc(uint flags,Matrix4F *matWorld,BOOL alphaBlend)
{
	uint uVar1;
	undefined4 uVar2;
	DWORD dwRenderState;
	Matrix4F identity;
	
	uVar1 = flags & 0x1c00;
	if ((uVar1 != 0) && (alphaBlend != 0)) {
										// D3DRENDERSTATE_FOGENABLE (0x1c), FALSE (0x0)
		main::Main_ChangeRenderState(D3DRENDERSTATE_FOGENABLE,FALSE);
	}
	if ((uVar1 == 0) || (alphaBlend != 0)) {
		if ((flags & 0x400) == 0) {
			if ((flags & 0x800) == 0) {
				if ((flags & 0x1000) == 0) goto LAB_00482e79;
										// D3DBLEND_SRCALPHA (0x5), D3DBLEND_INVSRCALPHA (0x6)
				Mesh_SetAlphaRender(D3DBLEND_SRCALPHA,D3DBLEND_INVSRCALPHA);
			}
			else {
										// D3DBLEND_SRCALPHA (0x5), D3DBLEND_ONE (0x2)
				Mesh_SetAlphaRender(D3DBLEND_SRCALPHA,D3DBLEND_ONE);
			}
		}
		else {
										// D3DBLEND_ONE (0x2), D3DBLEND_ONE (0x2)
			Mesh_SetAlphaRender(D3DBLEND_ONE,D3DBLEND_ONE);
		}
	}
	else {
LAB_00482e79:
										// D3DRENDERSTATE_ALPHABLENDENABLE (0x1b), FALSE (0x0)
		main::Main_ChangeRenderState(D3DRENDERSTATE_ALPHABLENDENABLE,FALSE);
	}
	if ((flags & 0x4000000) == 0) {
										// D3DCULL_CCW (0x3)
		uVar2 = D3DCULL_CCW;
	}
	else {
										// D3DCULL_NONE (0x1)
		uVar2 = D3DCULL_NONE;
	}
										// D3DRENDERSTATE_CULLMODE (0x16), ...
	main::Main_ChangeRenderState(D3DRENDERSTATE_CULLMODE,uVar2);
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
		if ((flags & 0x20000) == 0) {
			if ((flags & 0x40000) == 0) {
										// D3DTOP_MODULATE (0x4)
				dwRenderState = D3DTOP_MODULATE;
			}
			else {
										// D3DTOP_SELECTARG2 (0x3)
				dwRenderState = D3DTOP_SELECTARG2;
			}
		}
		else {
										// D3DTOP_SELECTARG1 (0x2)
			dwRenderState = D3DTOP_SELECTARG1;
		}
										// D3DTSS_ALPHAOP (0x4), ...
		Mesh_ChangeTextureStageState(D3DTSS_ALPHAOP,dwRenderState);
	}
										// D3DRENDERSTATE_ZENABLE (0x7), TRUE (0x1)
	main::Main_ChangeRenderState(D3DRENDERSTATE_ZENABLE,TRUE);
	if ((uVar1 == 0) || (alphaBlend == 0)) {
		uVar2 = TRUE;
	}
	else {
		uVar2 = FALSE;
	}
										// D3DRENDERSTATE_ZWRITEENABLE (0xe), [TRUE (0x1) | FALSE (0x0)]
	main::Main_ChangeRenderState(D3DRENDERSTATE_ZWRITEENABLE,uVar2);
	if ((flags & 0x2000) == 0) {
		if ((flags & 0x4000) == 0) goto LAB_00482f21;
		Mesh_SetIdentityMatrix(&identity);
		matWorld = &identity;
	}
										// D3DTRANSFORMSTATE_WORLD (0x1)
	Mesh_SetTransform(D3DTRANSFORMSTATE_WORLD,matWorld);
LAB_00482f21:
	if ((flags & 0x800000) == 0) {
										// D3DRENDERSTATE_TEXTUREMAG (0x11), D3DFILTER_LINEAR (0x2)
		main::Main_ChangeRenderState(D3DRENDERSTATE_TEXTUREMAG,D3DFILTER_LINEAR);
										// D3DRENDERSTATE_TEXTUREMIN (0x12), D3DFILTER_MIPLINEAR (0x4)
		main::Main_ChangeRenderState(D3DRENDERSTATE_TEXTUREMIN,D3DFILTER_MIPLINEAR);
		return;
	}
										// D3DRENDERSTATE_TEXTUREMAG (0x11), D3DFILTER_NEAREST (0x1)
	main::Main_ChangeRenderState(D3DRENDERSTATE_TEXTUREMAG,D3DFILTER_NEAREST);
										// D3DRENDERSTATE_TEXTUREMIN (0x12), D3DFILTER_NEAREST (0x1)
	main::Main_ChangeRenderState(D3DRENDERSTATE_TEXTUREMIN,D3DFILTER_NEAREST);
	return;
}



void __cdecl lego::res::Mesh_SetAlphaRender(D3DBlend src,D3DBlend dest)
{
										// D3DRENDERSTATE_ALPHABLENDENABLE (0x1b), TRUE (0x1)
	main::Main_ChangeRenderState(D3DRENDERSTATE_ALPHABLENDENABLE,TRUE);
										// D3DRENDERSTATE_SRCBLEND (0x13)
	main::Main_ChangeRenderState(D3DRENDERSTATE_SRCBLEND,src);
										// D3DRENDERSTATE_DSTBLEND (0x20)
	main::Main_ChangeRenderState(D3DRENDERSTATE_DESTBLEND,dest);
	return;
}



void __cdecl lego::res::Mesh_AddToPostRenderList(Mesh *mesh,Matrix4F *matWorld)
{
	Mesh_PostRenderInfo *pMVar1;
	int iVar2;
	Mesh_PostRenderInfo *pMVar3;
	
	pMVar1 = (Mesh_PostRenderInfo *)std::malloc(0x48);
	pMVar3 = pMVar1;
	for (iVar2 = 0x12; iVar2 != 0; iVar2 += -1) {
		pMVar3->mesh = NULL;
		pMVar3 = (Mesh_PostRenderInfo *)&pMVar3->matWorld;
	}
	pMVar1->mesh = mesh;
	if (matWorld != NULL) {
		pMVar3 = pMVar1;
		for (iVar2 = 0x10; pMVar3 = (Mesh_PostRenderInfo *)&pMVar3->matWorld, iVar2 != 0; iVar2 += -1) {
			(*(float (*) [4])&pMVar3->mesh)[0] = matWorld->values[0];
			matWorld = (Matrix4F *)(matWorld->values + 1);
		}
	}
	pMVar1->next = globs::meshGlobs.postRenderMeshList;
	globs::meshGlobs.postRenderMeshList = pMVar1;
	return;
}



void __cdecl lego::res::Mesh_ClearPostRenderList(void)
{
	Mesh_PostRenderInfo *pMVar1;
	Mesh_PostRenderInfo *buffer;
	
	buffer = globs::meshGlobs.postRenderMeshList;
	if (globs::meshGlobs.postRenderMeshList != NULL) {
		do {
			pMVar1 = buffer->next;
			std::free(buffer);
			buffer = pMVar1;
		} while (pMVar1 != NULL);
	}
	globs::meshGlobs.postRenderMeshList = NULL;
	return;
}



void __cdecl lego::view::Mesh_PostRenderAll(Viewport *view)
{
	BOOL BVar1;
	Mesh *pMVar2;
	int iVar3;
	uint uVar4;
	Mesh_PostRenderInfo *pMVar5;
	Mesh_Group *pMVar6;
	
	pMVar5 = globs::meshGlobs.postRenderMeshList;
	if (globs::meshGlobs.postRenderMeshList != NULL) {
		res::Mesh_SetCurrentGODSViewport(view);
		res::Mesh_StoreTextureAndMat();
		do {
			if ((*(byte *)&pMVar5->mesh->flags & 1) == 0) {
				res::Mesh_SetMeshRenderDesc(pMVar5->mesh,view,&pMVar5->matWorld,1);
				pMVar2 = pMVar5->mesh;
				if ((*(byte *)&pMVar2->flags & 2) == 0) {
					uVar4 = 0;
					if (pMVar2->groupCount != 0) {
						iVar3 = 0;
						do {
							pMVar6 = (Mesh_Group *)((int)&pMVar2->groupList->faceDataSize + iVar3);
							BVar1 = res::Mesh_CanRenderGroup(pMVar6);
							if (((BVar1 != 0) && ((pMVar6->flags & 0x80000) != 0)) && (pMVar6->renderFlags == 0))
							{
								res::Mesh_RenderGroup(pMVar5->mesh,pMVar6,&pMVar5->matWorld,1);
							}
							pMVar2 = pMVar5->mesh;
							uVar4 += 1;
							iVar3 += 0x70;
						} while (uVar4 < pMVar2->groupCount);
					}
					pMVar2 = pMVar5->mesh;
					uVar4 = 0;
					if (pMVar2->groupCount != 0) {
						iVar3 = 0;
						do {
							pMVar6 = (Mesh_Group *)((int)&pMVar2->groupList->faceDataSize + iVar3);
							BVar1 = res::Mesh_CanRenderGroup(pMVar6);
							if (((BVar1 != 0) && ((pMVar6->flags & 0x80000) != 0)) && (pMVar6->renderFlags != 0))
							{
								res::Mesh_RenderGroup(pMVar5->mesh,pMVar6,&pMVar5->matWorld,1);
							}
							pMVar2 = pMVar5->mesh;
							uVar4 += 1;
							iVar3 += 0x70;
						} while (uVar4 < pMVar2->groupCount);
					}
				}
				else {
					res::Mesh_RenderMesh(pMVar2,&pMVar5->matWorld,1);
				}
			}
			pMVar5 = pMVar5->next;
		} while (pMVar5 != NULL);
		res::Mesh_ClearPostRenderList();
		main::Main_RestoreStates();
		res::Mesh_RestoreTextureAndMat();
	}
	return;
}



Container_Texture * __cdecl
lego::res::Mesh_LoadTexture(char *baseDir,char *name,uint *out_width,uint *out_height)
{
	char cVar1;
	Mesh_TextureReference *pMVar2;
	IDirectDrawSurface4 *surface;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	char *pcVar7;
	undefined4 *puVar8;
	uint *ref_count;
	IDirectDrawSurface4 *local_10c;
	Container_Texture *local_108;
	char filepath [260];
	
	local_108 = (Container_Texture *)std::malloc(0xc);
	if (baseDir == NULL) {
										// std::strcpy(filepath, filename)
		uVar3 = 0xffffffff;
		pcVar6 = name;
		do {
			pcVar7 = pcVar6;
			if (uVar3 == 0) break;
			uVar3 -= 1;
			pcVar7 = pcVar6 + 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar7;
		} while (cVar1 != '\0');
		uVar3 = ~uVar3;
		puVar5 = (undefined4 *)(pcVar7 + -uVar3);
		puVar8 = (undefined4 *)filepath;
		for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
			*puVar8 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar8 = puVar8 + 1;
		}
		for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
			*(undefined *)puVar8 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar8 = (undefined4 *)((int)puVar8 + 1);
		}
	}
	else {
		std::sprintf(filepath,"%s%s",baseDir,name);
	}
	pMVar2 = Mesh_SearchTexturePathList
										 (globs::meshGlobs.textureList,globs::meshGlobs.textureCount,filepath);
	if (pMVar2 != NULL) {
		surface = pMVar2->surface;
		if (surface != NULL) {
			(*surface->lpVtbl->AddRef)((IUnknown *)surface);
		}
		local_10c = (IDirectDrawSurface4 *)pMVar2->trans;
		goto LAB_004832a8;
	}
	surface = Container_LoadTextureSurface(filepath,1,out_width,out_height,(BOOL *)&local_10c);
	if (surface == NULL) {
		if (globs::meshGlobs.sharedTextureDir == NULL) goto LAB_004832a8;
		std::sprintf(filepath,"%s%s",globs::meshGlobs.sharedTextureDir,name);
		pMVar2 = Mesh_SearchTexturePathList
											 (globs::meshGlobs.textureListShared,globs::meshGlobs.textureCountShared,
												filepath);
		if (pMVar2 != NULL) {
			surface = pMVar2->surface;
			if (surface != NULL) {
				(*surface->lpVtbl->AddRef)((IUnknown *)surface);
			}
			local_10c = (IDirectDrawSurface4 *)pMVar2->trans;
			goto LAB_004832a8;
		}
		surface = Container_LoadTextureSurface(filepath,1,out_width,out_height,(BOOL *)&local_10c);
		if (surface == NULL) goto LAB_004832a8;
		ref_count = &globs::meshGlobs.textureCountShared;
		pMVar2 = globs::meshGlobs.textureListShared;
	}
	else {
		ref_count = &globs::meshGlobs.textureCount;
		pMVar2 = globs::meshGlobs.textureList;
	}
	Mesh_AddTexturePathEntry(pMVar2,ref_count,filepath,surface,local_10c);
LAB_004832a8:
	if (surface != NULL) {
		local_108->texture = NULL;
		local_108->surface = surface;
		local_108->colourKey = (BOOL)local_10c;
		return local_108;
	}
	std::free(local_108);
	return NULL;
}



Mesh_TextureReference * __cdecl
lego::res::Mesh_SearchTexturePathList(Mesh_TextureReference *list,uint count,char *path)
{
	int iVar1;
	uint uVar2;
	char **ppcVar3;
	
	uVar2 = 0;
	if (count == 0) {
		return NULL;
	}
	ppcVar3 = &list->path;
	do {
		iVar1 = std::_stricmp(path,*ppcVar3);
		if (iVar1 == 0) {
			return list + uVar2;
		}
		uVar2 += 1;
		ppcVar3 = ppcVar3 + 3;
	} while (uVar2 < count);
	return NULL;
}



void __cdecl
lego::res::Mesh_AddTexturePathEntry
					(Mesh_TextureReference *list,uint *ref_count,char *path,IDirectDrawSurface4 *surface,
					BOOL trans)
{
	char *pcVar1;
	
	pcVar1 = std::_strdup(path);
	list[*ref_count].path = pcVar1;
	list[*ref_count].surface = surface;
	list[*ref_count].trans = trans;
	*ref_count = *ref_count + 1;
	return;
}



void __cdecl
lego::res::Mesh_SetGroupTexture(Mesh *mesh,D3DRMGroupIndex groupID,Container_Texture *mt)
{
	uint *puVar1;
	IDirectDrawSurface4 *This;
	
	if (mt != NULL) {
		This = mt->surface;
		if (This != NULL) {
			(*This->lpVtbl->QueryInterface)
								((IUnknown *)This,(IID *)&idl::IID_IDirect3DTexture2,
								 &mesh->groupList[groupID].imText);
		}
		if (mt->colourKey != 0) {
			puVar1 = &mesh->groupList[groupID].flags;
			*puVar1 = *puVar1 | 0x400000;
			return;
		}
		mesh->groupList[groupID].flags = mesh->groupList[groupID].flags & 0xffbfffff;
	}
	return;
}



void __cdecl lego::res::Mesh_RemoveGroupTexture(Mesh *mesh,D3DRMGroupIndex groupID)
{
	Mesh_Group *pMVar1;
	IDirect3DTexture2 *This;
	
	pMVar1 = mesh->groupList;
	This = pMVar1[groupID].imText;
	if (This != NULL) {
		(*This->lpVtbl->Release)((IUnknown *)This);
		pMVar1[groupID].imText = NULL;
	}
	return;
}



BOOL __cdecl lego::res::Mesh_CreateGroupMaterial(Mesh *mesh,D3DRMGroupIndex groupID)
{
	int iVar1;
	D3DMaterial *pDVar2;
	D3DMaterial *pDVar3;
	D3DMaterial material;
	
	material.hTexture = 0;
	material.dwRampSize = 0;
	material.dwSize = 0x50;
	material.diffuse.red = 1.0;
	material.diffuse.green = 1.0;
	material.diffuse.blue = 1.0;
	material.diffuse.alpha = 1.0;
	material.ambient.red = 0.0;
	material.ambient.green = 0.0;
	material.ambient.blue = 0.0;
	material.ambient.alpha = 0.0;
	material.specular.red = 0.0;
	material.specular.green = 0.0;
	material.specular.blue = 0.0;
	material.specular.alpha = 0.0;
	material.emissive.red = 0.0;
	material.emissive.green = 0.0;
	material.emissive.blue = 0.0;
	material.emissive.alpha = 0.0;
	material.power = 0.0;
	pDVar2 = &material;
	pDVar3 = &mesh->groupList[groupID].material;
	for (iVar1 = 0x14; iVar1 != 0; iVar1 += -1) {
		pDVar3->dwSize = pDVar2->dwSize;
		pDVar2 = (D3DMaterial *)&pDVar2->diffuse;
		pDVar3 = (D3DMaterial *)&pDVar3->diffuse;
	}
	return 1;
}



BOOL __cdecl lego::res::Mesh_SetGroupMaterial(Mesh *mesh,D3DRMGroupIndex groupID,D3DMaterial *mat)
{
	int iVar1;
	D3DMaterial *pDVar2;
	
	pDVar2 = &mesh->groupList[groupID].material;
	for (iVar1 = 0x14; iVar1 != 0; iVar1 += -1) {
		pDVar2->dwSize = mat->dwSize;
		mat = (D3DMaterial *)&mat->diffuse;
		pDVar2 = (D3DMaterial *)&pDVar2->diffuse;
	}
	return 1;
}



BOOL __cdecl
lego::res::Mesh_SetGroupColour
					(Mesh *mesh,D3DRMGroupIndex groupID,float r,float g,float b,MaterialType matType)
{
	D3DMaterial *pDVar1;
	Mesh_Group *pMVar2;
	
	pMVar2 = mesh->groupList + groupID;
	pDVar1 = Mesh_GetGroupMaterial(mesh,groupID);
	if (r < 0.0) {
		r = 0.0;
	}
	if (g < 0.0) {
		g = 0.0;
	}
	if (b < 0.0) {
		b = 0.0;
	}
	if ((ushort)((ushort)(r < 1.0) << 8 | (ushort)(r == 1.0) << 0xe) == 0) {
		r = 1.0;
	}
	if ((ushort)((ushort)(g < 1.0) << 8 | (ushort)(g == 1.0) << 0xe) == 0) {
		g = 1.0;
	}
	if ((ushort)((ushort)(b < 1.0) << 8 | (ushort)(b == 1.0) << 0xe) == 0) {
		b = 1.0;
	}
	if (matType == MATERIAL_DIFFUSE) {
		(pDVar1->diffuse).red = r;
		(pDVar1->diffuse).green = g;
		(pDVar1->diffuse).blue = b;
		if (((r == 1.0) && (g == 1.0)) && (b == 1.0)) {
			pMVar2->flags = pMVar2->flags | 0x100000;
			return 1;
		}
		pMVar2->flags = pMVar2->flags & 0xffefffff;
		return 1;
	}
	if (matType == MATERIAL_AMBIENT) {
		(pDVar1->ambient).green = g;
		(pDVar1->ambient).red = r;
		(pDVar1->ambient).blue = b;
		return 1;
	}
	if (matType != MATERIAL_EMISSIVE) {
		if (matType != MATERIAL_SPECULAR) {
			return 1;
		}
		(pDVar1->specular).green = g;
		(pDVar1->specular).red = r;
		(pDVar1->specular).blue = b;
		return 1;
	}
	(pDVar1->emissive).green = g;
	(pDVar1->emissive).red = r;
	(pDVar1->emissive).blue = b;
	return 1;
}



D3DMaterial * __cdecl lego::res::Mesh_GetGroupMaterial(Mesh *mesh,D3DRMGroupIndex groupID)
{
	return &mesh->groupList[groupID].material;
}



BOOL __cdecl
lego::res::Mesh_SetGroupMaterialValues
					(Mesh *mesh,D3DRMGroupIndex groupID,float value,MaterialType matType)
{
	D3DMaterial *pDVar1;
	uint uVar2;
	Mesh_Group *pMVar3;
	
	pMVar3 = mesh->groupList + groupID;
	pDVar1 = Mesh_GetGroupMaterial(mesh,groupID);
	if (value < 0.0) {
		value = 0.0;
	}
	if ((ushort)((ushort)(value < 1.0) << 8 | (ushort)(value == 1.0) << 0xe) == 0) {
		value = 1.0;
	}
	if (matType != MATERIAL_ALPHA) {
		if (matType == MATERIAL_POWER) {
			pDVar1->power = value;
			return 1;
		}
		return 1;
	}
	uVar2 = pMVar3->flags & 0xeff7ffff;
	pMVar3->flags = uVar2;
	if (value == 0.0) {
		if (pMVar3->renderFlags == 0) {
			if (((mesh->renderDesc).renderFlags & 0x1c00) == 0) goto LAB_004837a4;
			uVar2 |= 0x10000000;
		}
		else {
			uVar2 |= 0x10000000;
		}
	}
	else {
		if ((value == 1.0) ||
			 ((pMVar3->renderFlags == 0 && (((mesh->renderDesc).renderFlags & 0x1c00) == 0))))
		goto LAB_004837a4;
		uVar2 |= 0x80000;
	}
	pMVar3->flags = uVar2;
LAB_004837a4:
	if (pMVar3->renderFlags == 0) {
		if (((mesh->renderDesc).renderFlags & 0xc00) != 0) {
			pMVar3->flags = pMVar3->flags | 0x80000;
		}
	}
	else {
		if ((pMVar3->renderFlags & 0xc00) != 0) {
			pMVar3->flags = pMVar3->flags | 0x80000;
			(pDVar1->diffuse).alpha = value;
			return 1;
		}
	}
	(pDVar1->diffuse).alpha = value;
	return 1;
}



void __cdecl lego::res::Mesh_SetIdentityMatrix(Matrix4F *out_matrix)
{
	out_matrix->values[1][3] = 0.0;
	out_matrix->values[1][2] = 0.0;
	out_matrix->values[1][0] = 0.0;
	out_matrix->values[3] = 0.0;
	out_matrix->values[2] = 0.0;
	out_matrix->values[1] = 0.0;
	out_matrix->values[3][2] = 0.0;
	out_matrix->values[3][1] = 0.0;
	out_matrix->values[3][0] = 0.0;
	out_matrix->values[2][3] = 0.0;
	out_matrix->values[2][1] = 0.0;
	out_matrix->values[2][0] = 0.0;
	out_matrix->values[3][3] = 1.0;
	out_matrix->values[2][2] = 1.0;
	out_matrix->values[1][1] = 1.0;
	out_matrix->values[0] = 1.0;
	return;
}



BOOL __cdecl lego::res::Mesh_SetCurrentViewport(IDirect3DRMViewport *rmViewport)
{
	HRESULT HVar1;
	int iVar2;
	IDirect3DRMViewport *This;
	IDirect3DViewport *d3dViewport;
	
										// IDirect3DRMViewport->GetDirect3DViewport(this, IDirect3DViewport**
										// lplpD3DViewport)
	HVar1 = (*(code *)rmViewport->lpVtbl->GetDirect3DViewport)
										(rmViewport,(IDirect3DViewport **)&rmViewport);
	if (HVar1 != 0) {
		return 0;
	}
	HVar1 = (*rmViewport->lpVtbl->QueryInterface)
										((IUnknown *)rmViewport,(IID *)&idl::IID_IDirect3DViewport3,&d3dViewport);
	This = rmViewport;
	if (HVar1 == 0) {
		if (rmViewport != NULL) {
			(*rmViewport->lpVtbl->Release)((IUnknown *)rmViewport);
			rmViewport = NULL;
		}
		iVar2 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetCurrentViewport)
											(globs::mainGlobs.imDevice,d3dViewport);
		This = (IDirect3DRMViewport *)d3dViewport;
		if (iVar2 == 0) {
			if (d3dViewport != NULL) {
				(*d3dViewport->lpVtbl->Release)((IUnknown *)d3dViewport);
			}
			return 1;
		}
	}
	if (This != NULL) {
		(*This->lpVtbl->Release)((IUnknown *)This);
	}
	return 0;
}



BOOL __cdecl lego::res::Mesh_SetCurrentGODSViewport(Viewport *view)
{
	HRESULT HVar1;
	Viewport *pVVar2;
	Viewport *local_4;
	
										// IDirect3DRMViewport2->GetDirect3DViewport(this, IDirect3DViewport**
										// lplpD3DViewport)
	HVar1 = (*view->lpVP->lpVtbl->GetDirect3DViewport)(view->lpVP,(IDirect3DViewport **)&view);
	if (HVar1 != 0) {
		return 0;
	}
										// IDirect3DViewport->QueryInterface(this, IID_IDirect3DViewport3,
										// IDirect3DViewport3** lplpOut)
	HVar1 = (**(code **)view->xoffset)
										((IDirect3DViewport *)view,&idl::IID_IDirect3DViewport3,
										 (IDirect3DViewport3 **)&local_4);
	pVVar2 = view;
	if (HVar1 == 0) {
		if (view != NULL) {
										// IDirect3DViewport->Release(this)
			(**(code **)((int)view->xoffset + 8))((IDirect3DViewport *)view);
			view = NULL;
		}
										// IDirect3DDevice3->SetCurrentViewport(this, IDirect3DViewport3* lpd3dViewport)
		HVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetCurrentViewport)
											(globs::mainGlobs.imDevice,(IDirect3DViewport3 *)local_4);
		pVVar2 = local_4;
		if (HVar1 == 0) {
			if (local_4 != NULL) {
										// IDirect3DViewport3->Release(this)
				(**(code **)((int)local_4->xoffset + 8))((IDirect3DViewport3 *)local_4);
			}
			return 1;
		}
	}
	if (pVVar2 != NULL) {
										// IDirect3DViewport->Release(this)
										//  -or-
										// IDirect3DViewport3->Release(this)
		(*((IDirect3DViewportVtbl *)pVVar2->xoffset)->Release)((IDirect3DViewport *)pVVar2);
	}
	return 0;
}



// Sets g_IDirect3DDevice3->SetTransform
// RESULT: false if the current transform was not the same, and SetTransform failed

BOOL __cdecl lego::res::Mesh_SetTransform(D3DTransformStateType state,Matrix4F *matrix)
{
	int iVar1;
	float unaff_EBX;
	float unaff_ESI;
	Matrix4F *pMVar2;
	float unaff_EDI;
	Matrix4F *pMVar3;
	Matrix4F oldMatrix;
	Matrix4F newMatrix;
	
	pMVar2 = matrix;
	pMVar3 = &newMatrix;
										// std::memcpy(newMatrix, oldMatrix, 0x40)
	for (iVar1 = 0x10; iVar1 != 0; iVar1 += -1) {
		pMVar3->values[0] = pMVar2->values[0];
		pMVar2 = (Matrix4F *)(pMVar2->values + 1);
		pMVar3 = (Matrix4F *)(pMVar3->values + 1);
	}
										// IDirect3DDevice3->GetTransform(this, D3DTransformStateType
										// dtstTransformStateType, Matrix4F* lpD3DMatrix)
	(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetTransform)
						(globs::mainGlobs.imDevice,state,&oldMatrix);
	if (((((unaff_EDI != oldMatrix.values[3][1]) || (unaff_ESI != oldMatrix.values[3][2])) ||
			 (unaff_EBX != oldMatrix.values[3][3])) ||
			(((oldMatrix.values[0][0] != newMatrix.values[0][0] ||
				(oldMatrix.values[0][1] != newMatrix.values[0][1])) ||
			 ((oldMatrix.values[0][2] != newMatrix.values[0][2] ||
				((oldMatrix.values[0][3] != newMatrix.values[0][3] ||
				 (oldMatrix.values[1][0] != newMatrix.values[1][0])))))))) ||
		 ((oldMatrix.values[1][1] != newMatrix.values[1][1] ||
			(((((oldMatrix.values[1][2] != newMatrix.values[1][2] ||
					(oldMatrix.values[1][3] != newMatrix.values[1][3])) ||
				 (oldMatrix.values[2][0] != newMatrix.values[2][0])) ||
				((oldMatrix.values[2][1] != newMatrix.values[2][1] ||
				 (oldMatrix.values[2][2] != newMatrix.values[2][2])))) ||
			 ((oldMatrix.values[2][3] != newMatrix.values[2][3] ||
				(oldMatrix.values[3][0] != newMatrix.values[3][0])))))))) {
										// IDirect3DDevice3->SetTransform(this, D3DTransformStateType
										// dtstTransformStateType, Matrix4F* lpD3DMatrix)
		iVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetTransform)
											(globs::mainGlobs.imDevice,state,matrix);
		if (iVar1 != 0) {
			return 0;
		}
	}
	return 1;
}



BOOL __cdecl
lego::res::Mesh_ChangeTextureStageState
					(D3DTextureStageStateType dwRenderStateType,DWORD dwRenderState)
{
	D3DTextureStageStateType dwState;
	HRESULT HVar1;
	
	dwState = dwRenderStateType;
	HVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetTextureStageState)
										(globs::mainGlobs.imDevice,0,dwRenderStateType,&dwRenderStateType);
	if (HVar1 != 0) {
		dwRenderStateType = ~D3DTSS_TCI_PASSTHRU;
	}
	if (dwRenderStateType != dwRenderState) {
		HVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetTextureStageState)
											(globs::mainGlobs.imDevice,0,dwState,(DWORD *)dwRenderState);
		if (HVar1 != 0) {
			return 0;
		}
		if (globs::meshGlobs.stateData[dwState].changed == 0) {
			globs::meshGlobs.stateData[dwState].changed = 1;
			globs::meshGlobs.stateData[dwState].origValue = dwRenderStateType;
		}
		else {
			if (globs::meshGlobs.stateData[dwState].origValue == dwRenderStateType) {
				globs::meshGlobs.stateData[dwState].changed = 0;
				return 1;
			}
		}
	}
	return 1;
}



void __cdecl lego::res::Mesh_StoreTextureAndMat(void)
{
	(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetLightState)
						(globs::mainGlobs.imDevice,1,0x541568);
	globs::meshGlobs.currMatIM = globs::meshGlobs.oldMatIM;
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetTexture)(globs::mainGlobs.imDevice,0,0x54156c)
		;
		globs::meshGlobs.currTextureIM = globs::meshGlobs.oldTextureIM;
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetRenderState)
							(globs::mainGlobs.imDevice,1,0x541564);
		if (globs::meshGlobs.oldTextureRM != 0) {
			(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetRenderState)(globs::mainGlobs.imDevice,1,0);
			return;
		}
	}
	else {
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->GetRenderState)
							(globs::mainGlobs.imDevice,1,0x541564);
		globs::meshGlobs.currTextureRM = globs::meshGlobs.oldTextureRM;
	}
	return;
}



void __cdecl lego::res::Mesh_RestoreTextureAndMat(void)
{
	if (globs::meshGlobs.currMatIM != globs::meshGlobs.oldMatIM) {
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetLightState)
							(globs::mainGlobs.imDevice,1,globs::meshGlobs.oldMatIM);
	}
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
		if (globs::meshGlobs.currTextureIM != globs::meshGlobs.oldTextureIM) {
			(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetTexture)
								(globs::mainGlobs.imDevice,0,globs::meshGlobs.oldTextureIM);
		}
		if (globs::meshGlobs.oldTextureRM != 0) {
			(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetRenderState)
								(globs::mainGlobs.imDevice,1,globs::meshGlobs.oldTextureRM);
			return;
		}
	}
	else {
		(*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetRenderState)
							(globs::mainGlobs.imDevice,1,globs::meshGlobs.oldTextureRM);
	}
	return;
}



BOOL __cdecl lego::res::Mesh_RenderMesh(Mesh *mesh,Matrix4F *matWorld,BOOL alphaBlend)
{
	BOOL BVar1;
	uint uVar2;
	int iVar3;
	Mesh_Group *pMVar4;
	BOOL local_4;
	
	uVar2 = 0;
	local_4 = 1;
	if (mesh->groupCount != 0) {
		iVar3 = 0;
		do {
			pMVar4 = (Mesh_Group *)((int)&mesh->groupList->faceDataSize + iVar3);
			BVar1 = Mesh_CanRenderGroup(pMVar4);
			if ((BVar1 != 0) && (pMVar4->renderFlags == 0)) {
				BVar1 = Mesh_RenderGroup(mesh,pMVar4,matWorld,alphaBlend);
				if (BVar1 == 0) {
					local_4 = BVar1;
				}
			}
			uVar2 += 1;
			iVar3 += 0x70;
		} while (uVar2 < mesh->groupCount);
	}
	uVar2 = 0;
	if (mesh->groupCount != 0) {
		iVar3 = 0;
		do {
			pMVar4 = (Mesh_Group *)((int)&mesh->groupList->faceDataSize + iVar3);
			BVar1 = Mesh_CanRenderGroup(pMVar4);
			if ((BVar1 != 0) && (pMVar4->renderFlags != 0)) {
				BVar1 = Mesh_RenderGroup(mesh,pMVar4,matWorld,alphaBlend);
				if (BVar1 == 0) {
					local_4 = BVar1;
				}
			}
			uVar2 += 1;
			iVar3 += 0x70;
		} while (uVar2 < mesh->groupCount);
	}
	return local_4;
}



BOOL __cdecl lego::res::Mesh_CanRenderGroup(Mesh_Group *group)
{
	if (((group->flags & 1) == 0) && ((group->flags & 0x10000000) == 0)) {
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::res::Mesh_RenderGroup(Mesh *mesh,Mesh_Group *group,Matrix4F *matWorld,BOOL alphaBlend)
{
	BOOL BVar1;
	uint uVar2;
	
	Mesh_SetGroupRenderDesc(mesh,group,matWorld,alphaBlend);
	BVar1 = Mesh_SetMaterial(&group->material);
	uVar2 = (uint)(BVar1 != 0);
	BVar1 = Mesh_RenderTriangleList
										(globs::meshGlobs.matHandle,group->imText,0x112,group->vertices,
										 group->vertexCount,group->faceData,group->faceDataSize);
	if (BVar1 == 0) {
		uVar2 = 0;
	}
	return uVar2;
}



BOOL __cdecl
lego::res::Mesh_SetGroupRenderDesc(Mesh *mesh,Mesh_Group *group,Matrix4F *matWorld,BOOL alphaBlend)
{
	DWORD dwRenderState;
	
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
		if (((group->flags & 0x100000) == 0) || (group->imText == NULL)) {
										// D3DTOP_MODULATE (0x4)
			dwRenderState = D3DTOP_MODULATE;
		}
		else {
										// D3DTOP_SELECTARG1 (0x2)
			dwRenderState = D3DTOP_SELECTARG1;
		}
										// D3DTSS_COLOROP (0x1), ...
		Mesh_ChangeTextureStageState(D3DTSS_COLOROP,dwRenderState);
	}
										// D3DRENDERSTATE_COLORKEYENABLE (0x29), [BOOL]
	main::Main_ChangeRenderState(D3DRENDERSTATE_COLORKEYENABLE,(uint)((group->flags & 0x400000) != 0))
	;
	if (group->renderFlags != 0) {
		Mesh_SetRenderDesc(group->renderFlags,matWorld,alphaBlend);
		return 1;
	}
	return 0;
}



BOOL __cdecl
lego::res::Mesh_RenderTriangleList
					(DWORD matHandle,IDirect3DTexture2 *texture,DWORD renderFlags,Mesh_Vertex *vertices,
					DWORD vertexCount,WORD *faceData,DWORD indexCount)
{
	int iVar1;
	HRESULT HVar2;
	DWORD in_ECX;
	BOOL BVar3;
	DWORD local_4;
	
	BVar3 = 1;
	if (((byte)globs::mainGlobs.flags & CMD_NM) == 0) {
		local_4 = in_ECX;
		if (texture != globs::meshGlobs.currTextureIM) {
			iVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetTexture)
												(globs::mainGlobs.imDevice,0,texture);
			if (iVar1 == 0) {
				globs::meshGlobs.currTextureIM = texture;
			}
			else {
				BVar3 = 0;
			}
		}
	}
	else {
		local_4 = 0;
		if (texture != NULL) {
			(*(globs::mainGlobs.imDevice)->lpVtbl->QueryInterface)
								((IUnknown *)globs::mainGlobs.imDevice,(IID *)&idl::IID_IDirect3DDevice2,&texture);
										// IDirect3DDevice2->GetCaps(this, D3DDEVICEDESC_V1* lpD3DHWDevDesc,
										// D3DDEVICEDESC_V1* lpD3DHELDevDesc)
			(*(code *)texture->lpVtbl->GetHandle)(texture,texture,&local_4);
			if (texture != NULL) {
										// IDirect3DDevice2->Release(this)
				(*texture->lpVtbl->Release)((IUnknown *)texture);
			}
		}
		if (local_4 != globs::meshGlobs.currTextureRM) {
										// D3DRENDERSTATE_TEXTUREHANDLE (0x1)
			main::Main_ChangeRenderState(D3DRENDERSTATE_TEXTUREHANDLE,local_4);
			globs::meshGlobs.currTextureRM = local_4;
		}
	}
	if (matHandle != globs::meshGlobs.currMatIM) {
										// D3DLIGHTSTATE_MATERIAL (0x1)
		iVar1 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->SetLightState)
											(globs::mainGlobs.imDevice,D3DLIGHTSTATE_MATERIAL,matHandle);
		if (iVar1 == 0) {
			globs::meshGlobs.currMatIM = matHandle;
		}
		else {
			BVar3 = 0;
		}
	}
										// IDirect3DDevice3->DrawIndexedPrimitive(this, D3DPrimitiveType
										// dptPrimitiveType, DWORD dwVertexTypeDesc, void* lpvVertices, DWORD
										// dwVertexCount, WORD* lpwIndices, DWORD dwIndexCount, DWORD dwFlags)
										// 
										//  D3DPT_TRIANGLELIST (0x4)
	HVar2 = (*(code *)(globs::mainGlobs.imDevice)->lpVtbl->DrawIndexedPrimitive)
										(globs::mainGlobs.imDevice,D3DPT_TRIANGLELIST,renderFlags,vertices,vertexCount,
										 faceData,indexCount,0);
	if (HVar2 != 0) {
		BVar3 = 0;
	}
	return BVar3;
}



BOOL __cdecl lego::image::Flic_Setup(char *filename,ImageFlic **out_fsp,FlicUserFlags flags)
{
	char cVar1;
	IDirectDraw4 *pIVar2;
	ImageFlic *flic;
	BOOL BVar3;
	byte *pbVar4;
	File *pFVar5;
	void *pvVar6;
	int iVar7;
	uint uVar8;
	uint uVar9;
	undefined4 *puVar10;
	DDSURFACEDESC2 *pDVar11;
	char *pcVar12;
	char *pcVar13;
	undefined4 *puVar14;
	DDCOLORKEY colorKey;
	char drive [4];
	DDSURFACEDESC2 surfDesc;
	char errorMessage [128];
	char fname [256];
	char ext [256];
	char dir [256];
	
	pIVar2 = globs::directDrawGlobs.lpDirectDraw;
	flic = (ImageFlic *)std::malloc(0x6e8);
	*out_fsp = flic;
	for (iVar7 = 0x1ba; iVar7 != 0; iVar7 += -1) {
		flic->userflags = FLICDISK;
		flic = (ImageFlic *)&flic->fsXc;
	}
	(*out_fsp)->fsDisplayMode = FLICMODE_HICOLOR;
	std::_splitpath(filename,drive,dir,fname,ext);
	BVar3 = Flic_LoadHeader(filename,out_fsp);
	if (BVar3 == 0) {
		return 0;
	}
	flic = *out_fsp;
	pDVar11 = &surfDesc;
	for (iVar7 = 0x1f; iVar7 != 0; iVar7 += -1) {
		pDVar11->dwSize = 0;
		pDVar11 = (DDSURFACEDESC2 *)&pDVar11->dwFlags;
	}
	surfDesc.dwSize = 0x7c;
	surfDesc.dwFlags = 7;
	surfDesc.ddsCaps.dwCaps = 0x840;
	surfDesc.dwWidth = (DWORD)(flic->fsHeader).width;
	surfDesc.dwHeight = (DWORD)(flic->fsHeader).height;
	flic->fsXsize = surfDesc.dwWidth;
	(*out_fsp)->fsYsize = surfDesc.dwHeight;
	(*pIVar2->lpVtbl->CreateSurface)(pIVar2,&surfDesc,&(*out_fsp)->fsSurface,NULL);
	colorKey.dwColorSpaceLowValue = 0;
	colorKey.dwColorSpaceHighValue = 0;
										// A GRAPHICAL CRASH(FREEZE?) WAS OBSERVED HERE WHEN RUNNING IN OLLYDBG
										// POINT OF FAILURE (pointer evaluated to -1)
	(*(*out_fsp)->fsSurface->lpVtbl->SetColorKey)((*out_fsp)->fsSurface,8,&colorKey);
	(*out_fsp)->userflags = flags;
	uVar8 = 0xffffffff;
	pcVar12 = filename;
	do {
		pcVar13 = pcVar12;
		if (uVar8 == 0) break;
		uVar8 -= 1;
		pcVar13 = pcVar12 + 1;
		cVar1 = *pcVar12;
		pcVar12 = pcVar13;
	} while (cVar1 != '\0');
	uVar8 = ~uVar8;
	puVar10 = (undefined4 *)(pcVar13 + -uVar8);
	puVar14 = (undefined4 *)(*out_fsp)->filename;
	for (uVar9 = uVar8 >> 2; uVar9 != 0; uVar9 -= 1) {
		*puVar14 = *puVar10;
		puVar10 = puVar10 + 1;
		puVar14 = puVar14 + 1;
	}
	for (uVar8 &= 3; uVar8 != 0; uVar8 -= 1) {
		*(undefined *)puVar14 = *(undefined *)puVar10;
		puVar10 = (undefined4 *)((int)puVar10 + 1);
		puVar14 = (undefined4 *)((int)puVar14 + 1);
	}
	(*out_fsp)->fsXc = 0;
	(*out_fsp)->fsYc = 0;
	(*out_fsp)->currentframe = 0;
	(*out_fsp)->overallframe = 0;
	(*out_fsp)->framerate = 0x190000;
	flic = *out_fsp;
	if (((byte)flic->userflags & 1) == 1) {
		flic->pointerposition = 0;
		pbVar4 = (byte *)std::malloc(((*out_fsp)->fsHeader).size);
		(*out_fsp)->rambufferhandle = pbVar4;
		pFVar5 = lego::file::File_Open(filename,"rb");
		(*out_fsp)->filehandle = pFVar5;
		lego::file::File_Seek((*out_fsp)->filehandle,0x80,0);
		flic = *out_fsp;
		lego::file::File_Read(flic->rambufferhandle,(flic->fsHeader).size,1,flic->filehandle);
		lego::file::File_Close((*out_fsp)->filehandle);
	}
	else {
		flic->pointerposition = 0x80;
		pFVar5 = lego::file::File_Open(filename,"rb");
		(*out_fsp)->filehandle = pFVar5;
		if ((*out_fsp)->filehandle == NULL) {
			std::sprintf(errorMessage,"Not Enough Memory > %s",filename);
			return 0;
		}
		lego::file::File_Seek((*out_fsp)->filehandle,0x80,0);
	}
	pvVar6 = std::malloc(20000);
	(*out_fsp)->fsLoadBuffer = pvVar6;
	return TRUE;
}



BOOL __cdecl lego::image::Flic_Close(ImageFlic *fsp)
{
	if (fsp == NULL) {
		return 0;
	}
	if (((byte)fsp->userflags & FLICMEMORY) == FLICMEMORY) {
		std::free(fsp->rambufferhandle);
	}
	else {
		lego::file::File_Close(fsp->filehandle);
	}
	if (fsp->fsLoadBuffer != NULL) {
		std::free(fsp->fsLoadBuffer);
		fsp->fsLoadBuffer = NULL;
	}
	return TRUE;
}



// see: <https://www.compuphase.com/flic.htm#FLICHEADER>

BOOL __cdecl lego::image::Flic_LoadHeader(char *filename,ImageFlic **fsp)
{
	ushort uVar1;
	ImageFlic *pIVar2;
	File *f;
	int iVar3;
	char *format;
	char errorMessage [128];
	
	f = lego::file::File_Open(filename,"rb");
	if (f == NULL) {
		format = "Flic File Not Found %s";
	}
	else {
		lego::file::File_Seek(f,0,0);
		lego::file::File_Read(&(*fsp)->fsHeader,0x88,1,f);
		pIVar2 = *fsp;
		iVar3 = lego::file::File_Length(f);
		if ((pIVar2->fsHeader).size != iVar3) {
			lego::file::File_Close(f);
			std::sprintf(errorMessage,"Flic File Invalid",filename);
			return 0;
		}
		uVar1 = (pIVar2->fsHeader).magic;
		if (uVar1 < 0x911a) {
			if ((uVar1 == 0x9119) || (uVar1 == 0x1234)) {
LAB_004842d2:
				lego::file::File_Close(f);
				return TRUE;
			}
		}
		else {
			if (((uVar1 == 0xaf11) || (uVar1 == 0xaf12)) || (uVar1 == 0xaf43)) goto LAB_004842d2;
		}
		lego::file::File_Close(f);
		format = "Flic File Invalid %s";
	}
	std::sprintf(errorMessage,format,filename);
	return 0;
}



BOOL __cdecl lego::image::Flic_Animate(ImageFlic *fsp,Rect2F *destArea,BOOL advance,BOOL trans)
{
	IDirectDrawSurface4 *pIVar1;
	int iVar2;
	FlicError FVar3;
	DDSURFACEDESC2 *pDVar4;
	uint *puVar5;
	longlong lVar6;
	longlong lVar7;
	longlong lVar8;
	RECT dstRect;
	DDSURFACEDESC2 surfDesc;
	uint ddBltFX [25];
	
	pIVar1 = globs::directDrawGlobs.bSurf;
	lVar6 = __ftol((float10)destArea->x);
	dstRect.left = (int)lVar6;
	lVar7 = __ftol((float10)destArea->y);
	dstRect.top = (int)lVar7;
	lVar8 = __ftol((float10)destArea->width);
	dstRect.right = (int)lVar8 + (int)lVar6;
	lVar6 = __ftol((float10)destArea->height);
	dstRect.bottom = (int)lVar6 + (int)lVar7;
	FVar3 = FLICNOERROR;
	pDVar4 = &surfDesc;
	for (iVar2 = 0x1f; iVar2 != 0; iVar2 += -1) {
		pDVar4->dwSize = 0;
		pDVar4 = (DDSURFACEDESC2 *)&pDVar4->dwFlags;
	}
	surfDesc.dwSize = 0x7c;
	(*fsp->fsSurface->lpVtbl->Lock)(fsp->fsSurface,NULL,&surfDesc,1,NULL);
	fsp->fsPitch = surfDesc.lPitch;
	fsp->fsSPtr = surfDesc.lpSurface;
	fsp->is15bit = (uint)(surfDesc.ddpfPixelFormat.dwGBitMask == 0x3e0);
	iVar2 = 1;
	if (fsp->currentframe != 0) {
		iVar2 = advance;
	}
	if (iVar2 != 0) {
		if (((byte)fsp->userflags & FLICMEMORY) == FLICMEMORY) {
			FVar3 = Flic_Memory(fsp);
		}
		else {
			FVar3 = Flic_Load(fsp);
		}
	}
	(*fsp->fsSurface->lpVtbl->Unlock)(fsp->fsSurface,NULL);
	puVar5 = ddBltFX;
	for (iVar2 = 0x19; iVar2 != 0; iVar2 += -1) {
		*puVar5 = 0;
		puVar5 = puVar5 + 1;
	}
	ddBltFX[0] = 100;
	ddBltFX[20] = 0xff00;
										// DDBLT_WAIT | (trans ? DDBLT_KEYSRC : 0)  (0x1000000) (0x8000)
	(*pIVar1->lpVtbl->Blt)
						(pIVar1,(LPRECT)&dstRect,fsp->fsSurface,NULL,-(uint)(trans != 0) & 0x8000 | 0x1000000,
						 ddBltFX);
	return (uint)(FVar3 == FLICNOERROR);
}



FlicError __cdecl lego::image::Flic_Memory(ImageFlic *fsp)
{
	int iVar1;
	FlicError FVar2;
	
	FVar2 = FLICNOERROR;
	Flic_FindChunk(fsp);
	if (fsp->currentframe == 0) {
		fsp->ringframe = fsp->pointerposition;
	}
	iVar1 = fsp->currentframe + 1;
	fsp->currentframe = iVar1;
	fsp->overallframe = fsp->overallframe + 1;
	if (((byte)fsp->userflags & FLICLOOPINGON) == FLICLOOPINGON) {
		if (iVar1 == (fsp->fsHeader).frames + 1) {
			fsp->currentframe = 1;
			fsp->pointerposition = fsp->ringframe;
			return FLICNOERROR;
		}
	}
	else {
		if (iVar1 == (fsp->fsHeader).frames + 1) {
			FVar2 = FLICFINISHED;
		}
	}
	return FVar2;
}



FlicError __cdecl lego::image::Flic_Load(ImageFlic *fsp)
{
	int iVar1;
	FlicError FVar2;
	
	FVar2 = FLICNOERROR;
	if (fsp->currentframe == 0) {
		fsp->ringframe = fsp->pointerposition;
	}
	lego::file::File_Read(fsp->fsLoadBuffer,0x10,1,fsp->filehandle);
	Flic_FindChunk(fsp);
	iVar1 = fsp->currentframe + 1;
	fsp->currentframe = iVar1;
	fsp->overallframe = fsp->overallframe + 1;
	if (((byte)fsp->userflags & FLICLOOPINGON) == FLICLOOPINGON) {
		if ((int)(uint)(fsp->fsHeader).frames < iVar1) {
			lego::file::File_Seek(fsp->filehandle,fsp->ringframe,0);
			fsp->pointerposition = fsp->ringframe;
			fsp->currentframe = 0;
			return FLICNOERROR;
		}
	}
	else {
		if ((int)(uint)(fsp->fsHeader).frames < iVar1) {
			FVar2 = FLICFINISHED;
		}
	}
	return FVar2;
}



FlicError __cdecl lego::image::Flic_FindChunk(ImageFlic *fsp)
{
	short sVar1;
	int iVar2;
	bool bVar3;
	int iVar4;
	FlicUserFlags FVar5;
	int iVar6;
	int *piVar7;
	
	FVar5 = fsp->userflags & FLICMEMORY;
	if (FVar5 == FLICMEMORY) {
		piVar7 = (int *)fsp->rambufferhandle;
	}
	else {
		piVar7 = (int *)fsp->fsLoadBuffer;
	}
	iVar2 = fsp->pointerposition;
	if (FVar5 == FLICMEMORY) {
		iVar6 = *(int *)((int)piVar7 + iVar2);
		piVar7 = (int *)((int)piVar7 + iVar2);
		bVar3 = false;
		while (fsp->pointerposition < (fsp->fsHeader).size) {
			sVar1 = *(short *)(piVar7 + 1);
			if (sVar1 == 0xb) {
				Flic_LoadPalette64(fsp);
				iVar4 = fsp->pointerposition + *piVar7;
LAB_00484688:
				fsp->pointerposition = iVar4;
LAB_0048468e:
				piVar7 = (int *)((int)piVar7 + *piVar7);
				iVar6 += *piVar7;
			}
			else {
				if (sVar1 == 0x4b4c) {
					Flic_LoadPointers(fsp);
					fsp->pointerposition = fsp->pointerposition + *piVar7;
					goto LAB_0048468e;
				}
				if (sVar1 != -0xe06) {
					iVar4 = *piVar7 + fsp->pointerposition;
					goto LAB_00484688;
				}
				Flic_FrameChunk(fsp);
				bVar3 = true;
			}
			if (bVar3) {
				fsp->pointerposition = iVar2 + iVar6;
				return FLICNOERROR;
			}
		}
	}
	else {
		iVar6 = *piVar7;
		bVar3 = false;
		do {
			if ((fsp->fsHeader).size <= fsp->pointerposition) break;
			sVar1 = *(short *)(piVar7 + 1);
			if (sVar1 == 0xb) {
				Flic_LoadPalette64(fsp);
LAB_00484704:
				iVar4 = fsp->pointerposition + *piVar7;
				fsp->pointerposition = iVar4;
LAB_00484719:
				lego::file::File_Seek(fsp->filehandle,iVar4,0);
				piVar7 = (int *)fsp->fsLoadBuffer;
				lego::file::File_Read(piVar7,0x10,1,fsp->filehandle);
				iVar6 += *piVar7;
			}
			else {
				if (sVar1 == 0x4b4c) {
					Flic_LoadPointers(fsp);
					goto LAB_00484704;
				}
				if (sVar1 != -0xe06) {
					iVar4 = *piVar7 + fsp->pointerposition;
					fsp->pointerposition = iVar4;
					goto LAB_00484719;
				}
				Flic_FrameChunk(fsp);
				bVar3 = true;
			}
		} while (!bVar3);
	}
	fsp->pointerposition = iVar2 + iVar6;
	return FLICNOERROR;
}



BOOL __cdecl lego::image::Flic_FrameChunk(ImageFlic *fsp)
{
	byte bVar1;
	char cVar2;
	uint length;
	int *piVar3;
	char buff [128];
	
	if (((byte)fsp->userflags & FLICMEMORY) == FLICMEMORY) {
		bVar1 = (fsp->rambufferhandle + fsp->pointerposition)[6];
		piVar3 = (int *)(fsp->rambufferhandle + fsp->pointerposition + 0x10);
		fsp->pointerposition = fsp->pointerposition + 0x10;
		if ('\0' < (char)bVar1) {
			while (fsp->pointerposition < (fsp->fsHeader).size) {
				fsp->fsSource = piVar3;
				Flic_DoChunk(fsp);
				fsp->pointerposition = fsp->pointerposition + *piVar3;
				piVar3 = (int *)((int)piVar3 + *piVar3);
				bVar1 -= 1;
				if ((char)bVar1 < '\x01') {
					return TRUE;
				}
			}
		}
	}
	else {
		piVar3 = (int *)fsp->fsLoadBuffer;
		cVar2 = *(char *)((int)piVar3 + 6);
		length = *piVar3 - 0x10;
		if (fsp->fsLoadBufferSize < (int)length) {
			if (piVar3 != NULL) {
				std::free(piVar3);
			}
			fsp->fsLoadBufferSize = length;
			piVar3 = (int *)std::malloc(length);
			fsp->fsLoadBuffer = piVar3;
			if (piVar3 == NULL) {
				std::sprintf(buff,"Flic Not Enough Memory");
				return 0;
			}
		}
		lego::file::File_Read(piVar3,length,1,fsp->filehandle);
		fsp->pointerposition = fsp->pointerposition + 0x10;
		while (('\0' < cVar2 && (fsp->pointerposition < (fsp->fsHeader).size))) {
			fsp->fsSource = piVar3;
			Flic_DoChunk(fsp);
			fsp->pointerposition = fsp->pointerposition + *piVar3;
			piVar3 = (int *)((int)piVar3 + *piVar3);
			cVar2 += -1;
		}
	}
	return TRUE;
}



// sort out chunk type

FlicError __cdecl lego::image::Flic_DoChunk(ImageFlic *fsp)
{
	FlicError FVar1;
	int iVar2;
	
	FVar1 = FLICNOERROR;
	iVar2 = (int)*(short *)((int)fsp->fsSource + 4);
	if (iVar2 < 8) {
		if (iVar2 == 7) {
switchD_0048492b_caseD_1b:
			Flic_DeltaWord(fsp);
			return FLICFINISHED;
		}
		if (iVar2 == 4) {
			Flic_Palette256(fsp);
			return FLICFINISHED;
		}
	}
	else {
		if (iVar2 < 0x5345) {
			if (iVar2 != 0x5344) {
				if (false) {
					return FLICNOERROR;
				}
				switch(iVar2) {
				case 0xb:
					nerps::funcs::NERPFunc__True((int *)fsp);
					return FLICFINISHED;
				case 0xc:
					nerps::funcs::NERPFunc__True((int *)fsp);
					return FLICFINISHED;
				case 0xd:
					nerps::funcs::NERPFunc__True((int *)fsp);
					return FLICFINISHED;
				default:
					return FLICNOERROR;
				case 0xf:
				case 0x19:
					Flic_BrunDepack(fsp);
					return FLICFINISHED;
				case 0x10:
					Flic_Copy(fsp);
					return FLICFINISHED;
				case 0x1b:
					goto switchD_0048492b_caseD_1b;
				}
			}
		}
		else {
			if (iVar2 != 0x5555) {
				return FLICNOERROR;
			}
			nerps::funcs::NERPFunc__False((int *)fsp);
		}
		FVar1 = FLICFINISHED;
	}
	return FVar1;
}



// Function to load pointers for each frame of flic.

FlicError __cdecl lego::image::Flic_LoadPointers(ImageFlic *fsp)
{
	uint length;
	uint *buffer;
	char buff [256];
	
	if (((byte)fsp->userflags & FLICMEMORY) != FLICMEMORY) {
		buffer = (uint *)fsp->fsLoadBuffer;
		length = *buffer;
		if (fsp->fsLoadBufferSize < (int)length) {
			if (buffer != NULL) {
				std::free(buffer);
			}
			fsp->fsLoadBufferSize = length;
			buffer = (uint *)std::malloc(length);
			fsp->fsLoadBuffer = buffer;
			if (buffer == NULL) {
				std::sprintf(buff,"Flic Not Enough Memory");
				return FLICNOERROR;
			}
		}
		lego::file::File_Seek(fsp->filehandle,fsp->pointerposition,0);
		lego::file::File_Read(buffer,length,1,fsp->filehandle);
	}
	return FLICNOERROR;
}



// Function to load an 8 bit palette.

FlicError __cdecl lego::image::Flic_LoadPalette64(ImageFlic *fsp)
{
	uint length;
	uint *buffer;
	char buff [128];
	
	if (((byte)fsp->userflags & FLICMEMORY) != FLICMEMORY) {
		buffer = (uint *)fsp->fsLoadBuffer;
		length = *buffer;
		if (fsp->fsLoadBufferSize < (int)length) {
			if (buffer != NULL) {
				std::free(buffer);
			}
			fsp->fsLoadBufferSize = length;
			buffer = (uint *)std::malloc(length);
			fsp->fsLoadBuffer = buffer;
			if (buffer == NULL) {
				std::sprintf(buff,"Flic Not Enough Memory");
				return FLICFINISHED;
			}
		}
		lego::file::File_Seek(fsp->filehandle,fsp->pointerposition,0);
		lego::file::File_Read(buffer,length,1,fsp->filehandle);
	}
	return FLICNOERROR;
}



BOOL __cdecl lego::image::Flic_Copy(ImageFlic *fsp)
{
	if (fsp->fsBitPlanes == 0x10) {
										// FlicCopyHiColorFlic(fsp) => return;
		util::logf_removed((char *)fsp);
		return TRUE;
	}
	if (fsp->fsDisplayMode == FLICMODE_BYTEPERPIXEL) {
										// FlicCopyBytePerPixel(fsp) => return;
		util::logf_removed((char *)fsp);
	}
	if (fsp->fsDisplayMode == FLICMODE_HICOLOR) {
										// FlicCopyHiColor(fsp) => return;
		util::logf_removed((char *)fsp);
	}
	return TRUE;
}



BOOL __cdecl lego::image::FlicBRunDepackHiColor(ImageFlic *fsp)
{
	byte n;
	byte bVar1;
	ushort uVar2;
	uint uVar3;
	uint uVar4;
	ushort *puVar5;
	byte *pbVar6;
	byte *pbVar7;
	int local_8;
	uint local_4;
	
	pbVar6 = (byte *)((int)fsp->fsSource + 7);
	if (*(ushort *)&fsp->fsYsize != 0) {
		local_4 = (uint)*(ushort *)&fsp->fsYsize;
		local_8 = 0;
		do {
			uVar2 = *(ushort *)&fsp->fsXsize;
			uVar3 = (uint)uVar2;
			puVar5 = (ushort *)((int)fsp->fsSPtr + (fsp->fsPitch >> 1) * local_8 * 2);
			while (uVar2 != 0) {
				bVar1 = *pbVar6;
				uVar4 = (uint)bVar1;
				pbVar7 = pbVar6 + 1;
				if (bVar1 < 0x80) {
					n = *pbVar7;
					uVar3 -= uVar4;
					pbVar7 = pbVar6 + 2;
					if (bVar1 != 0) {
						do {
							uVar2 = getFlicCol(n,fsp);
							*puVar5 = uVar2;
							puVar5 = puVar5 + 1;
							uVar4 -= 1;
						} while (uVar4 != 0);
					}
				}
				else {
					uVar4 = 0x100 - uVar4;
					uVar3 -= uVar4;
					if ((short)uVar4 != 0) {
						uVar4 &= 0xffff;
						do {
							bVar1 = *pbVar7;
							pbVar7 = pbVar7 + 1;
							uVar2 = getFlicCol(bVar1,fsp);
							*puVar5 = uVar2;
							puVar5 = puVar5 + 1;
							uVar4 -= 1;
						} while (uVar4 != 0);
					}
				}
				pbVar6 = pbVar7;
				uVar2 = (ushort)uVar3;
			}
			local_8 += 1;
			pbVar6 = pbVar6 + 1;
			local_4 -= 1;
		} while (local_4 != 0);
	}
	return TRUE;
}



BOOL __cdecl lego::image::FlicBRunDepackHiColorFlic32k(ImageFlic *fsp)
{
	ushort uVar1;
	short sVar2;
	ImageFlic *pIVar3;
	ushort uVar4;
	uint uVar5;
	uint uVar6;
	ushort *puVar7;
	ushort *puVar8;
	ushort *puVar9;
	short sVar10;
	
	pIVar3 = fsp;
	fsp = NULL;
	sVar2 = *(short *)&pIVar3->fsYsize;
	puVar8 = (ushort *)((int)pIVar3->fsSource + 7);
	if (0 < sVar2) {
		uVar5 = 0;
		do {
			sVar10 = *(short *)&pIVar3->fsXsize;
			puVar7 = (ushort *)((int)pIVar3->fsSPtr + (pIVar3->fsPitch >> 1) * uVar5 * 2);
			while (0 < sVar10) {
				uVar4 = (ushort)*(byte *)puVar8;
				puVar9 = (ushort *)((int)puVar8 + 1);
				if (uVar4 < 0x80) {
					uVar1 = *puVar9;
					sVar10 -= uVar4;
					puVar8 = (ushort *)((int)puVar8 + 3);
					uVar5 = (uVar1 & 0xffe0) << 1;
					if (uVar4 != 0) {
						uVar6 = (uint)uVar4;
						do {
							if (pIVar3->is15bit == 0) {
								uVar4 = (ushort)uVar5;
							}
							else {
								uVar4 = (ushort)((uVar5 & 0xffff) >> 1);
							}
							*puVar7 = uVar4 | uVar1 & 0x1f;
							puVar7 = puVar7 + 1;
							uVar6 -= 1;
						} while (uVar6 != 0);
					}
				}
				else {
					uVar4 = 0x100 - uVar4;
					sVar10 -= uVar4;
					puVar8 = puVar9;
					if (uVar4 != 0) {
						uVar5 = (uint)uVar4;
						do {
							uVar4 = *puVar9;
							puVar9 = puVar9 + 1;
							uVar6 = (uVar4 & 0xffe0) << 1;
							if (pIVar3->is15bit == 0) {
								uVar1 = (ushort)uVar6;
							}
							else {
								uVar1 = (ushort)((uVar6 & 0xffff) >> 1);
							}
							*puVar7 = uVar1 | uVar4 & 0x1f;
							puVar7 = puVar7 + 1;
							uVar5 -= 1;
							puVar8 = puVar9;
						} while (uVar5 != 0);
					}
				}
			}
			puVar8 = (ushort *)((int)puVar8 + 1);
			fsp = (ImageFlic *)((int)&fsp->userflags + 1);
			uVar5 = (uint)fsp & 0xffff;
		} while ((int)uVar5 < (int)sVar2);
	}
	return TRUE;
}



BOOL __cdecl lego::image::Flic_BrunDepack(ImageFlic *fsp)
{
	ushort uVar1;
	
	uVar1 = (fsp->fsHeader).depth;
	if (uVar1 == 8) {
		if (fsp->fsDisplayMode == FLICMODE_BYTEPERPIXEL) {
										// FlicBRunDepackBytePerPixel(fsp) => return TRUE;
			nerps::funcs::NERPFunc__True((int *)fsp);
		}
		if (fsp->fsDisplayMode == FLICMODE_HICOLOR) {
			FlicBRunDepackHiColor(fsp);
			return TRUE;
		}
	}
	else {
		if (uVar1 == 0x10) {
			if ((fsp->fsHeader).magic == 0xaf43) {
				FlicBRunDepackHiColorFlic32k(fsp);
				return TRUE;
			}
										// FlicBRunDepackHiColorFlic(fsp) => return TRUE;
			nerps::funcs::NERPFunc__True((int *)fsp);
		}
	}
	return TRUE;
}



int __cdecl lego::nerps::funcs::NERPFunc__True(int *stack)
{
	return TRUE;
}



void __cdecl lego::image::FlicCreateHiColorTable(ImageFlic *fsp)
{
	ColourRGBPacked *pCVar1;
	ushort *puVar2;
	int iVar3;
	
	iVar3 = 0x100;
	pCVar1 = fsp->fsPalette256;
	puVar2 = fsp->fsPalette64k;
	do {
		iVar3 += -1;
		*puVar2 = (ushort)(((uint)pCVar1->green | (pCVar1->red & 0xffff003e) << 5) << 5) |
							(ushort)(pCVar1->blue >> 1);
		pCVar1 = pCVar1 + 1;
		puVar2 = puVar2 + 1;
	} while (iVar3 != 0);
	fsp->fsPalette64k[0] = 0;
	return;
}



BOOL __cdecl lego::image::Flic_Palette256(ImageFlic *fsp)
{
	byte bVar1;
	byte *pbVar2;
	byte *pbVar3;
	ColourRGBPacked *pCVar4;
	uint uVar5;
	int iVar6;
	short sVar7;
	
	pCVar4 = fsp->fsPalette256;
	pbVar2 = (byte *)((int)fsp->fsSource + 8);
	for (sVar7 = *(short *)((int)fsp->fsSource + 6); sVar7 != 0; sVar7 += -1) {
		pbVar3 = pbVar2 + 2;
		uVar5 = (uint)pbVar2[1];
		pCVar4 = pCVar4 + *pbVar2;
		if (pbVar2[1] == 0) {
			sVar7 = 1;
			uVar5 = 0x100;
			pCVar4 = fsp->fsPalette256;
		}
		iVar6 = uVar5 * 3;
		if ((short)iVar6 != 0) {
			do {
				bVar1 = *pbVar3;
				pbVar3 = pbVar3 + 1;
				pCVar4->red = bVar1 >> 2;
				pCVar4 = (ColourRGBPacked *)&pCVar4->green;
				iVar6 += -1;
			} while (iVar6 != 0);
		}
		pbVar2 = pbVar3;
	}
	if (fsp->fsDisplayMode == FLICMODE_HICOLOR) {
		FlicCreateHiColorTable(fsp);
	}
	return TRUE;
}



void __cdecl lego::util::logf_removed(char *message,...)
{
	return;
}



void __cdecl lego::image::FlicDeltaWordHiColor(ImageFlic *fsp)
{
	void **ppvVar1;
	byte bVar2;
	byte bVar3;
	ushort uVar4;
	ushort uVar5;
	uint uVar6;
	short sVar7;
	short sVar8;
	ushort *puVar9;
	ushort *puVar10;
	ushort *puVar11;
	uint local_10;
	byte local_4;
	ImageFlic *fsp_00;
	
	fsp_00 = fsp;
	ppvVar1 = &fsp->fsSource;
	fsp = NULL;
	sVar8 = *(short *)((int)*ppvVar1 + 6);
	puVar10 = (ushort *)((int)*ppvVar1 + 8);
	sVar7 = sVar8;
	while( true ) {
		while( true ) {
			if (sVar7 == 0) {
				return;
			}
			uVar5 = *puVar10;
			puVar9 = (ushort *)(((uint)fsp & 0xffff) * fsp_00->fsPitch + (int)fsp_00->fsSPtr);
			uVar4 = uVar5 >> 0xc & 0xc;
			if (uVar4 != 0xc) break;
			puVar10 = puVar10 + 1;
			fsp = (ImageFlic *)((int)fsp - (uint)uVar5);
		}
		if (uVar4 == 4) break;
		if (uVar4 == 8) {
			local_4 = *(byte *)puVar10;
			puVar10 = puVar10 + 1;
		}
		uVar5 = *puVar10;
		puVar10 = puVar10 + 1;
		if (uVar5 != 0) {
			local_10 = (uint)uVar5;
			puVar11 = puVar10;
			do {
				bVar3 = *(byte *)((int)puVar11 + 1);
				uVar6 = (uint)bVar3;
				puVar10 = puVar11 + 1;
				puVar9 = puVar9 + *(byte *)puVar11;
				if ((bVar3 & 0x80) == 0) {
					if (bVar3 != 0) {
						do {
							bVar3 = *(byte *)puVar10;
							bVar2 = *(byte *)((int)puVar10 + 1);
							puVar10 = puVar10 + 1;
							uVar5 = getFlicCol(bVar3,fsp_00);
							*puVar9 = uVar5;
							uVar5 = getFlicCol(bVar2,fsp_00);
							puVar9[1] = uVar5;
							puVar9 = puVar9 + 2;
							uVar6 -= 1;
						} while (uVar6 != 0);
					}
				}
				else {
					bVar3 = *(byte *)((int)puVar11 + 3);
					bVar2 = *(byte *)puVar10;
					puVar10 = puVar11 + 2;
					if ((short)(0x100 - uVar6) != 0) {
						uVar6 = 0x100 - uVar6 & 0xffff;
						do {
							uVar5 = getFlicCol(bVar2,fsp_00);
							*puVar9 = uVar5;
							uVar5 = getFlicCol(bVar3,fsp_00);
							puVar9[1] = uVar5;
							puVar9 = puVar9 + 2;
							uVar6 -= 1;
						} while (uVar6 != 0);
					}
				}
				local_10 -= 1;
				puVar11 = puVar10;
				sVar7 = sVar8;
			} while (local_10 != 0);
		}
		if (uVar4 == 8) {
			uVar5 = getFlicCol(local_4,fsp_00);
			*puVar9 = uVar5;
		}
		sVar8 = sVar7 + -1;
		fsp = (ImageFlic *)((int)&fsp->userflags + 1);
		sVar7 = sVar8;
	}
	return;
}



// WARNING: Could not reconcile some variable overlaps

void __cdecl lego::image::FlicDeltaWordHiColorFlic32k(ImageFlic *fsp)
{
	void **ppvVar1;
	byte bVar2;
	ushort uVar3;
	bool bVar4;
	short sVar5;
	ImageFlic *pIVar6;
	ushort uVar7;
	uint uVar8;
	short sVar9;
	uint uVar10;
	ushort *puVar11;
	ushort *puVar12;
	ushort *puVar13;
	uint local_10;
	uint local_8;
	
	pIVar6 = fsp;
	ppvVar1 = &fsp->fsSource;
	fsp = NULL;
	sVar9 = *(short *)((int)*ppvVar1 + 6);
	puVar11 = (ushort *)((int)*ppvVar1 + 8);
	sVar5 = sVar9;
	while( true ) {
		while( true ) {
			if (sVar9 == 0) {
				return;
			}
			uVar3 = *puVar11;
			uVar8 = (uint)uVar3;
			puVar13 = (ushort *)(((uint)fsp & 0xffff) * pIVar6->fsPitch + (int)pIVar6->fsSPtr);
			uVar7 = uVar3 >> 0xc & 0xc;
			if (uVar7 != 0xc) break;
			puVar11 = puVar11 + 1;
			fsp = (ImageFlic *)((int)fsp - uVar8);
		}
		if (uVar7 == 4) break;
		bVar4 = false;
		if (uVar7 == 8) {
			if (pIVar6->is15bit != 0) {
				uVar8 = uVar3 >> 1 & 0x7ff0 | uVar8 & 0x1f;
			}
			puVar11 = puVar11 + 1;
			bVar4 = true;
			local_8 = uVar8;
		}
		uVar3 = *puVar11;
		puVar11 = puVar11 + 1;
		if (uVar3 != 0) {
			local_10 = (uint)uVar3;
			puVar12 = puVar11;
			do {
				bVar2 = *(byte *)((int)puVar12 + 1);
				uVar8 = (uint)bVar2;
				puVar11 = puVar12 + 1;
				puVar13 = puVar13 + *(byte *)puVar12;
				if ((bVar2 & 0x80) == 0) {
					if (bVar2 != 0) {
						do {
							uVar3 = *puVar11;
							puVar11 = puVar11 + 1;
							uVar10 = (uVar3 & 0xffe0) << 1;
							if (pIVar6->is15bit == 0) {
								uVar7 = (ushort)uVar10;
							}
							else {
								uVar7 = (ushort)((uVar10 & 0xffff) >> 1);
							}
							*puVar13 = uVar7 | uVar3 & 0x1f;
							puVar13 = puVar13 + 1;
							uVar8 -= 1;
						} while (uVar8 != 0);
					}
				}
				else {
					uVar3 = *puVar11;
					puVar11 = puVar12 + 2;
					uVar10 = (uVar3 & 0xffe0) << 1;
					if ((short)(0x100 - uVar8) != 0) {
						uVar8 = 0x100 - uVar8 & 0xffff;
						do {
							if (pIVar6->is15bit == 0) {
								uVar7 = (ushort)uVar10;
							}
							else {
								uVar7 = (ushort)((uVar10 & 0xffff) >> 1);
							}
							*puVar13 = uVar7 | uVar3 & 0x1f;
							puVar13 = puVar13 + 1;
							uVar8 -= 1;
						} while (uVar8 != 0);
					}
				}
				local_10 -= 1;
				puVar12 = puVar11;
				sVar9 = sVar5;
			} while (local_10 != 0);
		}
		if (bVar4) {
			*(undefined *)puVar13 = (undefined)local_8;
		}
		fsp = (ImageFlic *)((int)&fsp->userflags + 1);
		sVar9 += -1;
		sVar5 = sVar9;
	}
	return;
}



BOOL __cdecl lego::image::Flic_DeltaWord(ImageFlic *fsp)
{
	ushort uVar1;
	
	uVar1 = (fsp->fsHeader).depth;
	if (uVar1 == 8) {
		if (fsp->fsDisplayMode == FLICMODE_BYTEPERPIXEL) {
										// FlicDeltaWordBytePerPixel(fsp) => return;
			util::logf_removed((char *)fsp);
		}
		if (fsp->fsDisplayMode == FLICMODE_HICOLOR) {
			FlicDeltaWordHiColor(fsp);
			return TRUE;
		}
	}
	else {
		if (uVar1 == 0x10) {
			uVar1 = (fsp->fsHeader).magic;
			if (uVar1 == 0x1234) {
										// FlicDeltaWordHiColorDZ(fsp) => return;
				util::logf_removed((char *)fsp);
				return TRUE;
			}
			if (uVar1 == 0xaf43) {
				FlicDeltaWordHiColorFlic32k(fsp);
				return TRUE;
			}
										// FlicDeltaWordHiColorFlic(fsp) => return;
			util::logf_removed((char *)fsp);
		}
	}
	return TRUE;
}



// MACRO: #define FHCOL(n)  getFlicCol(n,fsp)

ushort __cdecl lego::image::getFlicCol(byte n,ImageFlic *fsp)
{
	return fsp->fsPalette64k[n];
}



uint __cdecl lego::image::Flic_GetHeight(ImageFlic *fsp)
{
	return fsp->fsYsize;
}



TextWindow * __cdecl lego::front::TextWindow_Create(ImageFont *font,Rect2F *area,uint size)
{
	TextWindow *textWnd;
	void *pvVar1;
	int iVar2;
	TextWindow *pTVar3;
	
	textWnd = (TextWindow *)std::malloc(0x830);
	if (textWnd != NULL) {
		pTVar3 = textWnd;
		for (iVar2 = 0x20c; iVar2 != 0; iVar2 += -1) {
			pTVar3->font = NULL;
			pTVar3 = (TextWindow *)&pTVar3->windowSize;
		}
		textWnd->font = font;
		(textWnd->windowSize).x = area->x;
		(textWnd->windowSize).y = area->y;
		(textWnd->windowSize).width = area->width;
		(textWnd->windowSize).height = area->height;
		pvVar1 = std::malloc(size);
		textWnd->windowBuffer = pvVar1;
		textWnd->bufferSize = size;
		TextWindow_EnableCentering(textWnd,1);
	}
	return textWnd;
}



void __cdecl lego::front::TextWindow_EnableCentering(TextWindow *textWnd,BOOL enable)
{
	if (enable != 0) {
		textWnd->flags = textWnd->flags | 4;
		return;
	}
	textWnd->flags = textWnd->flags & 0xfffffffb;
	return;
}



void __cdecl lego::front::TextWindow_Remove(TextWindow *textWnd)
{
	std::free(textWnd->windowBuffer);
	std::free(textWnd);
	return;
}



void __cdecl lego::front::TextWindow_ChangePosition(TextWindow *textWnd,int xpos,int ypos)
{
	(textWnd->windowSize).x = (float)xpos;
	(textWnd->windowSize).y = (float)ypos;
	return;
}



void __cdecl lego::front::TextWindow_ChangeSize(TextWindow *textWnd,uint width,uint height)
{
	(textWnd->windowSize).width = (float)(ulonglong)width;
	(textWnd->windowSize).height = (float)(ulonglong)height;
	return;
}



void __cdecl lego::front::TextWindow_PagePrintF(TextWindow *textWnd,int page,char *format,...)
{
	TextWindow_VPrintF(textWnd,page,format,&stack0x00000010);
	return;
}



void __cdecl lego::front::TextWindow_PrintF(TextWindow *textWnd,char *format,...)
{
	TextWindow_VPrintF(textWnd,0,format,&stack0x0000000c);
	return;
}



void __cdecl
lego::front::TextWindow_VPrintF(TextWindow *textWnd,int page,char *format,va_list argptr)
{
	uint uVar1;
	uint uVar2;
	int iVar3;
	uint uVar4;
	char local_400 [1024];
	
	iVar3 = 0;
	uVar1 = std::vsprintf(local_400,format,argptr);
	uVar2 = 0;
	if (uVar1 != 0) {
		do {
			if (iVar3 == page) break;
			if (local_400[uVar2] == '\a') {
				iVar3 += 1;
			}
			uVar2 += 1;
		} while (uVar2 < uVar1);
	}
	if (uVar2 != uVar1) {
		for (; uVar2 < uVar1; uVar2 += 1) {
			*(char *)((int)textWnd->windowBuffer + textWnd->bufferEnd) = local_400[uVar2];
			uVar4 = textWnd->bufferEnd + 1;
			textWnd->bufferEnd = uVar4;
			if (uVar4 == textWnd->bufferSize) {
				textWnd->bufferEnd = 0;
				textWnd->flags = textWnd->flags | 1;
			}
		}
	}
	return;
}



void __cdecl
lego::front::TextWindow_PrintFOverlay(TextWindow *textWnd,BOOL oneFrame,char *format,...)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	undefined4 *puVar4;
	char *pcVar5;
	char *pcVar6;
	undefined4 *puVar7;
	char local_400 [1024];
	
	std::vsprintf(local_400,format,&stack0x00000010);
	uVar2 = 0xffffffff;
	pcVar5 = local_400;
	do {
		pcVar6 = pcVar5;
		if (uVar2 == 0) break;
		uVar2 -= 1;
		pcVar6 = pcVar5 + 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar6;
	} while (cVar1 != '\0');
	uVar2 = ~uVar2;
	puVar4 = (undefined4 *)(pcVar6 + -uVar2);
	puVar7 = (undefined4 *)textWnd->secondBuffer;
	for (uVar3 = uVar2 >> 2; uVar3 != 0; uVar3 -= 1) {
		*puVar7 = *puVar4;
		puVar4 = puVar4 + 1;
		puVar7 = puVar7 + 1;
	}
	for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
		*(undefined *)puVar7 = *(undefined *)puVar4;
		puVar4 = (undefined4 *)((int)puVar4 + 1);
		puVar7 = (undefined4 *)((int)puVar7 + 1);
	}
	if (oneFrame == 0) {
		textWnd->displayDelay = 25.0;
	}
	else {
		textWnd->displayDelay = 0.0;
	}
	textWnd->flags = textWnd->flags | 2;
	return;
}



BOOL __cdecl
lego::front::TextWindow_Update
					(TextWindow *textWnd,uint posFromEnd,float elapsed,int *out_lowestPoint)
{
	float fVar1;
	byte c;
	uint uVar2;
	float fVar3;
	uint uVar4;
	uint uVar5;
	BOOL BVar6;
	uint *puVar7;
	uint uVar8;
	int iVar9;
	ulonglong uVar10;
	longlong lVar11;
	uint local_414;
	uint *local_410;
	uint *local_40c;
	uint auStack1028 [257];
	
	uVar8 = 0;
	local_414 = 0;
	local_410 = NULL;
	if (out_lowestPoint != NULL) {
		*out_lowestPoint = 0;
	}
	uVar10 = __ftol((float10)(textWnd->windowSize).height);
	textWnd->linesCapacity = (int)((uVar10 & 0xffffffff) / (ulonglong)textWnd->font->fontHeight);
	if ((textWnd->flags & 2) != 0) {
		BVar6 = TextWindow_UpdateOverlay(textWnd,elapsed,out_lowestPoint);
		return BVar6;
	}
	uVar5 = textWnd->bufferSize;
	if (((textWnd->flags & 1) != 0) && (local_40c = (uint *)textWnd->linesCount, local_40c != NULL)) {
		puVar7 = textWnd->lines;
		do {
			uVar4 = *puVar7 - textWnd->bufferEnd;
			if ((0 < (int)uVar4) && ((int)uVar4 < (int)uVar5)) {
				uVar5 = uVar4;
				local_414 = *puVar7;
			}
			puVar7 = puVar7 + 1;
			local_40c = (uint *)((int)local_40c - 1);
		} while (local_40c != NULL);
	}
	textWnd->linesCount = 0;
	textWnd->lines[0] = local_414;
	textWnd->linesCount = textWnd->linesCount + 1;
	if (local_414 != textWnd->bufferEnd) {
		do {
			c = *(byte *)(local_414 + (int)textWnd->windowBuffer);
			if (c == '\a') break;
			if (c == '\n') {
				textWnd->lines[textWnd->linesCount] = local_414 + 1;
				uVar5 = textWnd->linesCount;
				auStack1028[uVar5] = uVar8;
				textWnd->linesCount = uVar5 + 1;
				local_410 = NULL;
				uVar8 = 0;
			}
			else {
										// int std::isspace(int c)
				if (std::globals::_pcharwidth < 2) {
					uVar5 = *(byte *)(std::globals::_pctype + c) & C1_SPACE;
				}
				else {
					uVar5 = std::_isctype((uint)c,C1_SPACE);
				}
				if (uVar5 != 0) {
					local_410 = NULL;
					textWnd->lines[textWnd->linesCount] = local_414 + 1;
					auStack1028[textWnd->linesCount] = uVar8;
				}
				uVar5 = lego::image::Font_GetCharWidth(textWnd->font,c);
				local_410 = (uint *)((int)local_410 + uVar5);
				fVar3 = (float)(uVar8 + uVar5);
				fVar1 = (textWnd->windowSize).width;
				uVar8 = uVar8 + uVar5;
				if ((ushort)((ushort)(fVar3 < fVar1) << 8 | (ushort)(fVar3 == fVar1) << 0xe) == 0) {
					textWnd->linesCount = textWnd->linesCount + 1;
					uVar8 = (uint)local_410;
				}
			}
			local_414 += 1;
			if (textWnd->bufferSize <= local_414) {
				local_414 = 0;
			}
		} while (local_414 != textWnd->bufferEnd);
	}
	textWnd->lines[textWnd->linesCount] = local_414;
	uVar5 = textWnd->linesCount;
	iVar9 = textWnd->linesCapacity;
	auStack1028[uVar5] = uVar8;
	uVar8 = (uVar5 - iVar9) + 1;
	uVar4 = 0;
	if (uVar8 == 0) {
		posFromEnd = 0;
	}
	else {
		posFromEnd %= uVar8;
	}
	if (uVar5 != 0) {
		local_40c = auStack1028;
		local_410 = textWnd->lines;
		do {
			local_40c = local_40c + 1;
			local_410 = local_410 + 1;
			lVar11 = __ftol((float10)(textWnd->windowSize).x);
			local_414 = (uint)lVar11;
			if ((*(byte *)&textWnd->flags & 4) != 0) {
				auStack1028[0] = 0;
				lVar11 = __ftol(((float10)(textWnd->windowSize).width - (float10)(ulonglong)*local_40c) *
												(float10)0.5);
				local_414 += (int)lVar11;
			}
			uVar8 = textWnd->linesCapacity;
			if (uVar8 < uVar5) {
				if ((uVar4 < (uVar5 - posFromEnd) - uVar8) || (uVar5 - posFromEnd <= uVar4)) {
					if (uVar5 <= uVar8) goto LAB_004858e9;
					iVar9 = 0;
				}
				else {
					uVar2 = textWnd->font->fontHeight;
					lVar11 = __ftol((float10)(textWnd->windowSize).y);
					iVar9 = ((posFromEnd + uVar4 + uVar8) - uVar5) * uVar2 + (int)lVar11;
				}
			}
			else {
LAB_004858e9:
				uVar8 = textWnd->font->fontHeight;
				lVar11 = __ftol((float10)(textWnd->windowSize).y);
				iVar9 = uVar8 * uVar4 + (int)lVar11;
			}
			if ((out_lowestPoint != NULL) && (*out_lowestPoint < iVar9)) {
				*out_lowestPoint = iVar9;
			}
			if ((iVar9 != 0) && (uVar8 = local_410[-1], uVar8 != *local_410)) {
				do {
					uVar5 = lego::image::Font_OutputChar
														(textWnd->font,local_414,iVar9,
														 *(char *)(uVar8 + (int)textWnd->windowBuffer),1);
					local_414 += uVar5;
					uVar8 += 1;
					if (uVar8 == textWnd->bufferSize + 1) {
						uVar8 = 0;
					}
				} while (uVar8 != *local_410);
			}
			uVar5 = textWnd->linesCount;
			uVar4 += 1;
		} while (uVar4 < uVar5);
	}
	if (out_lowestPoint != NULL) {
		*out_lowestPoint = *out_lowestPoint + textWnd->font->fontHeight;
	}
	return 0;
}



BOOL __cdecl
lego::front::TextWindow_UpdateOverlay(TextWindow *textWnd,float elapsed,int *out_lowestPoint)
{
	float fVar1;
	uint uVar2;
	float fVar3;
	byte c;
	uint uVar4;
	int iVar5;
	int iVar6;
	undefined *puVar7;
	int iVar8;
	longlong lVar9;
	int *local_820;
	uint local_81c;
	int local_818;
	uint local_810;
	int *local_80c;
	BOOL local_804;
	int local_800 [255];
	int aiStack1028 [2];
	undefined local_3fc [1020];
	
	iVar5 = 0;
	iVar8 = 0;
	iVar6 = 0;
	c = textWnd->secondBuffer[0];
	local_810 = 0;
	local_804 = 0;
	local_800[0] = 0;
	local_81c = 1;
	if (c != 0) {
		local_80c = local_800 + 1;
		local_820 = (int *)0x1;
		puVar7 = local_3fc;
		do {
			if (c == 10) {
				*(int *)(puVar7 + -4) = iVar8;
				local_81c += 1;
				*local_80c = (int)local_820;
				local_80c = local_80c + 1;
				puVar7 = puVar7 + 4;
				iVar6 = 0;
				iVar8 = 0;
			}
			else {
										// int std::isspace(int c)
				if (std::globals::_pcharwidth < 2) {
					uVar4 = *(byte *)(std::globals::_pctype + c) & C1_SPACE;
				}
				else {
					uVar4 = std::_isctype((uint)c,C1_SPACE);
				}
				if (uVar4 != 0) {
					*(int *)(puVar7 + -4) = iVar8;
					iVar6 = 0;
					*local_80c = (int)local_820;
				}
				uVar4 = lego::image::Font_GetCharWidth(textWnd->font,c);
				iVar6 += uVar4;
				fVar3 = (float)(iVar8 + uVar4);
				fVar1 = (textWnd->windowSize).width;
				iVar8 = iVar8 + uVar4;
				if ((ushort)((ushort)(fVar3 < fVar1) << 8 | (ushort)(fVar3 == fVar1) << 0xe) == 0) {
					local_81c += 1;
					puVar7 = puVar7 + 4;
					local_80c = local_80c + 1;
					iVar8 = iVar6;
				}
			}
			iVar5 = local_810 + 1;
			local_820 = (int *)((int)local_820 + 1);
			c = textWnd->secondBuffer[local_810 + 1];
			local_810 = iVar5;
		} while (c != 0);
	}
	aiStack1028[local_81c] = iVar8;
	local_800[local_81c] = iVar5;
	local_810 = 0;
	if (local_81c != 0) {
		local_820 = local_800;
		do {
			local_820 = local_820 + 1;
			lVar9 = __ftol((float10)(textWnd->windowSize).x);
			local_818 = (int)lVar9;
			if ((*(byte *)&textWnd->flags & 4) != 0) {
				lVar9 = __ftol(((float10)(textWnd->windowSize).width -
											 (float10)(ulonglong)*(uint *)(local_3fc + local_810 * 4 + -4)) * (float10)0.5
											);
				local_818 += (int)lVar9;
			}
			uVar4 = textWnd->linesCapacity;
			if (uVar4 < local_81c) {
				if ((local_810 < local_81c - uVar4) || (local_81c <= local_810)) {
					if (local_81c <= uVar4) goto LAB_00485b9f;
					iVar8 = 0;
				}
				else {
					uVar2 = textWnd->font->fontHeight;
					lVar9 = __ftol((float10)(textWnd->windowSize).y);
					iVar8 = ((local_810 - local_81c) + uVar4) * uVar2 + (int)lVar9;
					local_804 = 1;
				}
			}
			else {
LAB_00485b9f:
				uVar4 = textWnd->font->fontHeight;
				lVar9 = __ftol((float10)(textWnd->windowSize).y);
				iVar8 = uVar4 * local_810 + (int)lVar9;
			}
			if ((out_lowestPoint != NULL) && (*out_lowestPoint < iVar8)) {
				*out_lowestPoint = iVar8;
			}
			if (iVar8 != 0) {
				iVar6 = *local_820;
				for (iVar5 = local_800[local_810]; iVar5 != iVar6; iVar5 += 1) {
					uVar4 = lego::image::Font_OutputChar
														(textWnd->font,local_818,iVar8,textWnd->secondBuffer[iVar5],1);
					local_818 += uVar4;
				}
			}
			local_810 += 1;
		} while (local_810 < local_81c);
	}
	fVar1 = textWnd->displayDelay - elapsed;
	textWnd->displayDelay = fVar1;
	if (fVar1 < 0.0) {
		textWnd->flags = textWnd->flags & 0xfffffffd;
	}
	return local_804;
}



void __cdecl lego::front::TextWindow_Clear(TextWindow *textWnd)
{
	uint uVar1;
	uint uVar2;
	int iVar3;
	undefined4 *puVar4;
	
	uVar2 = textWnd->bufferSize;
	puVar4 = (undefined4 *)textWnd->windowBuffer;
	for (uVar1 = uVar2 >> 2; uVar1 != 0; uVar1 -= 1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
		*(undefined *)puVar4 = 0;
		puVar4 = (undefined4 *)((int)puVar4 + 1);
	}
	puVar4 = (undefined4 *)textWnd->secondBuffer;
	for (iVar3 = 0x100; iVar3 != 0; iVar3 += -1) {
		*puVar4 = 0;
		puVar4 = puVar4 + 1;
	}
	textWnd->linesCount = 0;
	textWnd->bufferEnd = 0;
	textWnd->flags = textWnd->flags & 0xfffffffe;
	return;
}



void __cdecl
lego::front::TextWindow_GetInfo(TextWindow *textWnd,uint *out_linesCount,uint *out_linesCapacity)
{
	*out_linesCount = textWnd->linesCount;
	*out_linesCapacity = textWnd->linesCapacity;
	return;
}



void __cdecl lego::input::Keys_Initialise(void)
{
	int iVar1;
	Key_Globs *pKVar2;
	
	pKVar2 = &globs::keyGlobs;
	for (iVar1 = 0x100; iVar1 != 0; iVar1 += -1) {
		pKVar2->keyName[0] = NULL;
		pKVar2 = (Key_Globs *)(pKVar2->keyName + 1);
	}
	globs::keyGlobs.keyName[1] = "KEY_ESCAPE";
	globs::keyGlobs.keyName[2] = "KEY_ONE";
	globs::keyGlobs.keyName[3] = "KEY_TWO";
	globs::keyGlobs.keyName[4] = "KEY_THREE";
	globs::keyGlobs.keyName[5] = "KEY_FOUR";
	globs::keyGlobs.keyName[6] = "KEY_FIVE";
	globs::keyGlobs.keyName[7] = "KEY_SIX";
	globs::keyGlobs.keyName[8] = "KEY_SEVEN";
	globs::keyGlobs.keyName[9] = "KEY_EIGHT";
	globs::keyGlobs.keyName[10] = "KEY_NINE";
	globs::keyGlobs.keyName[11] = "KEY_ZERO";
	globs::keyGlobs.keyName[12] = "KEY_MINUS";
	globs::keyGlobs.keyName[13] = "KEY_EQUALS";
	globs::keyGlobs.keyName[14] = "KEY_BACKSPACE";
	globs::keyGlobs.keyName[15] = "KEY_TAB";
	globs::keyGlobs.keyName[16] = "KEY_Q";
	globs::keyGlobs.keyName[17] = "KEY_W";
	globs::keyGlobs.keyName[18] = "KEY_E";
	globs::keyGlobs.keyName[19] = "KEY_R";
	globs::keyGlobs.keyName[20] = "KEY_T";
	globs::keyGlobs.keyName[21] = "KEY_Y";
	globs::keyGlobs.keyName[22] = "KEY_U";
	globs::keyGlobs.keyName[23] = "KEY_I";
	globs::keyGlobs.keyName[24] = "KEY_O";
	globs::keyGlobs.keyName[25] = "KEY_P";
	globs::keyGlobs.keyName[26] = "KEY_LEFTBRACE";
	globs::keyGlobs.keyName[27] = "KEY_RIGHTBRACE";
	globs::keyGlobs.keyName[28] = "KEY_RETURN";
	globs::keyGlobs.keyName[29] = "KEY_LEFTCTRL";
	globs::keyGlobs.keyName[30] = "KEY_A";
	globs::keyGlobs.keyName[31] = "KEY_S";
	globs::keyGlobs.keyName[32] = "KEY_D";
	globs::keyGlobs.keyName[33] = "KEY_F";
	globs::keyGlobs.keyName[34] = "KEY_G";
	globs::keyGlobs.keyName[35] = "KEY_H";
	globs::keyGlobs.keyName[36] = "KEY_J";
	globs::keyGlobs.keyName[37] = "KEY_K";
	globs::keyGlobs.keyName[38] = "KEY_L";
	globs::keyGlobs.keyName[39] = "KEY_SEMICOLON";
	globs::keyGlobs.keyName[40] = "KEY_AT";
	globs::keyGlobs.keyName[41] = "KEY_RSINGLEQUOTE";
	globs::keyGlobs.keyName[42] = "KEY_LEFTSHIFT";
	globs::keyGlobs.keyName[43] = "KEY_HASH";
	globs::keyGlobs.keyName[44] = "KEY_Z";
	globs::keyGlobs.keyName[45] = "KEY_X";
	globs::keyGlobs.keyName[46] = "KEY_C";
	globs::keyGlobs.keyName[47] = "KEY_V";
	globs::keyGlobs.keyName[48] = "KEY_B";
	globs::keyGlobs.keyName[49] = "KEY_N";
	globs::keyGlobs.keyName[50] = "KEY_M";
	globs::keyGlobs.keyName[51] = "KEY_LEFTARROW";
	globs::keyGlobs.keyName[52] = "KEY_RIGHTARROW";
	globs::keyGlobs.keyName[53] = "KEY_QUESTIONMARK";
	globs::keyGlobs.keyName[54] = "KEY_RIGHTSHIFT";
	globs::keyGlobs.keyName[55] = "KEYPAD_ASTERISK";
	globs::keyGlobs.keyName[56] = "KEY_ALT";
	globs::keyGlobs.keyName[57] = "KEY_SPACE";
	globs::keyGlobs.keyName[58] = "KEY_CAPLOCK";
	globs::keyGlobs.keyName[59] = "KEY_F1";
	globs::keyGlobs.keyName[60] = "KEY_F2";
	globs::keyGlobs.keyName[61] = "KEY_F3";
	globs::keyGlobs.keyName[62] = "KEY_F4";
	globs::keyGlobs.keyName[63] = "KEY_F5";
	globs::keyGlobs.keyName[64] = "KEY_F6";
	globs::keyGlobs.keyName[65] = "KEY_F7";
	globs::keyGlobs.keyName[66] = "KEY_F8";
	globs::keyGlobs.keyName[67] = "KEY_F9";
	globs::keyGlobs.keyName[68] = "KEY_F10";
	globs::keyGlobs.keyName[69] = "KEYPAD_NUMLOCK";
	globs::keyGlobs.keyName[70] = "KEY_SCROLLLOCK";
	globs::keyGlobs.keyName[71] = "KEYPAD_7";
	globs::keyGlobs.keyName[72] = "KEYPAD_8";
	globs::keyGlobs.keyName[73] = "KEYPAD_9";
	globs::keyGlobs.keyName[74] = "KEYPAD_MINUS";
	globs::keyGlobs.keyName[75] = "KEYPAD_4";
	globs::keyGlobs.keyName[76] = "KEYPAD_5";
	globs::keyGlobs.keyName[77] = "KEYPAD_6";
	globs::keyGlobs.keyName[78] = "KEYPAD_PLUS";
	globs::keyGlobs.keyName[79] = "KEYPAD_1";
	globs::keyGlobs.keyName[80] = "KEYPAD_2";
	globs::keyGlobs.keyName[81] = "KEYPAD_3";
	globs::keyGlobs.keyName[82] = "KEYPAD_0";
	globs::keyGlobs.keyName[83] = "KEYPAD_DELETE";
	globs::keyGlobs.keyName[86] = "KEY_BACKSLASH";
	globs::keyGlobs.keyName[87] = "KEY_F11";
	globs::keyGlobs.keyName[88] = "KEY_F12";
	globs::keyGlobs.keyName[156] = "KEYPAD_ENTER";
	globs::keyGlobs.keyName[157] = "KEY_RIGHTCTRL";
	globs::keyGlobs.keyName[181] = "KEYPAD_FORWARDSLASH";
	globs::keyGlobs.keyName[183] = "KEY_PRINTSCREEN";
	globs::keyGlobs.keyName[184] = "KEY_ALTGR";
	globs::keyGlobs.keyName[199] = "KEY_HOME";
	globs::keyGlobs.keyName[200] = "KEY_CURSORUP";
	globs::keyGlobs.keyName[201] = "KEY_PGUP";
	globs::keyGlobs.keyName[203] = "KEY_CURSORLEFT";
	globs::keyGlobs.keyName[205] = "KEY_CURSORRIGHT";
	globs::keyGlobs.keyName[207] = "KEY_END";
	globs::keyGlobs.keyName[208] = "KEY_CURSORDOWN";
	globs::keyGlobs.keyName[209] = "KEY_PGDN";
	globs::keyGlobs.keyName[210] = "KEY_INSERT";
	globs::keyGlobs.keyName[211] = "KEY_DELETE";
	return;
}



BOOL __cdecl lego::input::Key_Find(char *name,KeysByte *out_keyCode)
{
	char *_Str1;
	int iVar1;
	KeysByte KVar2;
	Key_Globs *pKVar3;
	
	KVar2 = KEY__NONE;
	pKVar3 = &globs::keyGlobs;
	do {
		_Str1 = *(char **)((FileCheck_Globs *)pKVar3)->loadedList;
		if (_Str1 != NULL) {
			iVar1 = std::_stricmp(_Str1,name);
			if (iVar1 == 0) {
				*out_keyCode = KVar2;
				return 1;
			}
		}
		pKVar3 = (Key_Globs *)(((FileCheck_Globs *)pKVar3)->loadedList + 4);
		KVar2 += KEY_ESCAPE;
	} while (pKVar3 < &globs::checkGlobs);
	return 0;
}



void __cdecl lego::draw::Draw_Initialise(Rect2F *window)
{
	globs::drawGlobs.flags |= 1;
	Draw_SetClipWindow(window);
	return;
}



void __cdecl lego::draw::Draw_SetClipWindow(Rect2F *window)
{
	float fVar1;
	HRESULT HVar2;
	int iVar3;
	DDSURFACEDESC2 *pDVar4;
	DDSURFACEDESC2 desc;
	
	globs::drawGlobs.clipStart.x = 0.0;
	globs::drawGlobs.clipStart.y = 0.0;
	if (window != NULL) {
		if ((ushort)((ushort)(window->x < 0.0) << 8 | (ushort)(window->x == 0.0) << 0xe) == 0) {
			globs::drawGlobs.clipStart.x = window->x;
		}
		if ((ushort)((ushort)(window->y < 0.0) << 8 | (ushort)(window->y == 0.0) << 0xe) == 0) {
			globs::drawGlobs.clipStart.y = window->y;
		}
	}
	pDVar4 = &desc;
	for (iVar3 = 0x1f; iVar3 != 0; iVar3 += -1) {
		pDVar4->dwSize = 0;
		pDVar4 = (DDSURFACEDESC2 *)&pDVar4->dwFlags;
	}
	desc.dwSize = 0x7c;
	HVar2 = (*(code *)(globs::directDrawGlobs.bSurf)->lpVtbl->GetSurfaceDesc)
										(globs::directDrawGlobs.bSurf,&desc);
	if (HVar2 == 0) {
		globs::drawGlobs.clipEnd.x = (float)(ulonglong)desc.dwWidth;
		globs::drawGlobs.clipEnd.y = (float)(ulonglong)desc.dwHeight;
		if (window != NULL) {
			fVar1 = window->width + window->x;
			if (fVar1 < globs::drawGlobs.clipEnd.x) {
				globs::drawGlobs.clipEnd.x = fVar1;
			}
			fVar1 = window->height + window->y;
			if (fVar1 < globs::drawGlobs.clipEnd.y) {
				globs::drawGlobs.clipEnd.y = fVar1;
				return;
			}
		}
	}
	return;
}



void __cdecl lego::draw::Draw_GetClipWindow(Rect2F *out_window)
{
	out_window->x = globs::drawGlobs.clipStart.x;
	out_window->y = globs::drawGlobs.clipStart.y;
	out_window->width = globs::drawGlobs.clipEnd.x - globs::drawGlobs.clipStart.x;
	out_window->height = globs::drawGlobs.clipEnd.y - globs::drawGlobs.clipStart.y;
	return;
}



void __cdecl
lego::draw::Draw_LineListEx
					(Point2F *fromList,Point2F *toList,uint count,float r,float g,float b,DrawEffect effect)
{
	IDirectDrawSurface4 *surface;
	BOOL BVar1;
	uint uVar2;
	int y2;
	int x2;
	int y1;
	Point2F *pPVar3;
	float *pfVar4;
	longlong lVar5;
	uint colour;
	
	surface = globs::directDrawGlobs.bSurf;
	BVar1 = Draw_LockSurface(globs::directDrawGlobs.bSurf,effect);
	if (BVar1 != 0) {
		uVar2 = Draw_GetColour(r,g,b);
		if (count != 0) {
			pfVar4 = &fromList->y;
			pPVar3 = (Point2F *)((int)toList - (int)fromList);
			do {
				colour = uVar2;
				lVar5 = __ftol((float10)*(float *)((int)&pPVar3->x + (int)pfVar4));
				y2 = (int)lVar5;
				lVar5 = __ftol((float10)toList->x);
				x2 = (int)lVar5;
				lVar5 = __ftol((float10)*pfVar4);
				y1 = (int)lVar5;
				lVar5 = __ftol((float10)pfVar4[-1]);
				Draw_LineActual((int)lVar5,y1,x2,y2,colour);
				pfVar4 = pfVar4 + 2;
				toList = toList + 1;
				count -= 1;
			} while (count != 0);
		}
		Draw_UnlockSurface(surface);
	}
	return;
}



void __cdecl
lego::draw::Draw_RectListEx(Rect2F *rectList,uint count,float r,float g,float b,DrawEffect effect)
{
	int iVar1;
	IDirectDrawSurface4 *surface;
	BOOL BVar2;
	uint uVar3;
	int iVar4;
	float10 extraout_ST0;
	longlong lVar5;
	longlong lVar6;
	longlong lVar7;
	float local_18;
	float local_10;
	float local_c;
	
	surface = globs::directDrawGlobs.bSurf;
	BVar2 = Draw_LockSurface(globs::directDrawGlobs.bSurf,effect);
	if (BVar2 != 0) {
		uVar3 = Draw_GetColour(r,g,b);
		if (count != 0) {
			effect = (DrawEffect)rectList;
			b = (float)count;
			do {
				local_10 = *(float *)effect;
				local_c = *(float *)(effect + 4);
				local_18 = local_10 + *(float *)(effect + 8);
				if (local_10 < globs::drawGlobs.clipStart.x) {
					local_10 = globs::drawGlobs.clipStart.x;
				}
				if (local_c < globs::drawGlobs.clipStart.y) {
					local_c = globs::drawGlobs.clipStart.y;
				}
				if (globs::drawGlobs.clipEnd.x <= local_18) {
					local_18 = globs::drawGlobs.clipEnd.x - 1.0;
				}
				lVar5 = __ftol((float10)local_18);
				lVar6 = __ftol(extraout_ST0);
				lVar7 = __ftol((float10)local_c);
				iVar4 = (int)lVar7;
				if (iVar4 < (int)lVar6) {
					lVar7 = __ftol((float10)local_10);
					iVar1 = (int)lVar7;
					do {
						for (; iVar1 < (int)lVar5; iVar1 = iVar1 + 1) {
							(*globs::drawGlobs.drawPixelFunc)(iVar1,iVar4,uVar3);
						}
						iVar4 += 1;
						iVar1 = (int)lVar7;
					} while (iVar4 < (int)lVar6);
				}
				effect += 0x10;
				b = (float)((int)b + -1);
			} while (b != 0.0);
		}
		Draw_UnlockSurface(surface);
	}
	return;
}



void __cdecl lego::draw::Draw_RectList2Ex(Draw_Rect *rectList,uint count,DrawEffect effect)
{
	int iVar1;
	IDirectDrawSurface4 *surface;
	BOOL BVar2;
	uint uVar3;
	float *pfVar4;
	int iVar5;
	float10 extraout_ST0;
	longlong lVar6;
	longlong lVar7;
	longlong lVar8;
	float local_18;
	float local_10;
	float local_c;
	
	surface = globs::directDrawGlobs.bSurf;
	BVar2 = Draw_LockSurface(globs::directDrawGlobs.bSurf,effect);
	if (BVar2 != 0) {
		if (count != 0) {
			pfVar4 = &rectList->g;
			rectList = (Draw_Rect *)count;
			do {
				local_10 = pfVar4[-5];
				local_c = pfVar4[-4];
				local_18 = pfVar4[-3];
				uVar3 = Draw_GetColour(pfVar4[-1],*pfVar4,pfVar4[1]);
				local_18 = local_10 + local_18;
				if (local_10 < globs::drawGlobs.clipStart.x) {
					local_10 = globs::drawGlobs.clipStart.x;
				}
				if (local_c < globs::drawGlobs.clipStart.y) {
					local_c = globs::drawGlobs.clipStart.y;
				}
				if (globs::drawGlobs.clipEnd.x <= local_18) {
					local_18 = globs::drawGlobs.clipEnd.x - 1.0;
				}
				lVar6 = __ftol((float10)local_18);
				lVar7 = __ftol(extraout_ST0);
				lVar8 = __ftol((float10)local_c);
				iVar5 = (int)lVar8;
				if (iVar5 < (int)lVar7) {
					lVar8 = __ftol((float10)local_10);
					iVar1 = (int)lVar8;
					do {
						for (; iVar1 < (int)lVar6; iVar1 = iVar1 + 1) {
							(*globs::drawGlobs.drawPixelFunc)(iVar1,iVar5,uVar3);
						}
						iVar5 += 1;
						iVar1 = (int)lVar8;
					} while (iVar5 < (int)lVar7);
				}
				pfVar4 = pfVar4 + 7;
				rectList = (Draw_Rect *)((int)&rectList[-1].b + 3);
			} while (rectList != NULL);
		}
		Draw_UnlockSurface(surface);
	}
	return;
}



float10 __cdecl
lego::draw::Draw_DotCircle
					(Point2F *pos,uint radius,uint dots,float r,float g,float b,DrawEffect effect)
{
	IDirectDrawSurface4 *surface;
	BOOL BVar1;
	uint uVar2;
	uint uVar3;
	float10 extraout_ST0;
	float10 fVar4;
	unkbyte10 extraout_ST0_00;
	float10 extraout_ST0_01;
	ulonglong uVar5;
	ulonglong uVar6;
	
	surface = globs::directDrawGlobs.bSurf;
	BVar1 = Draw_LockSurface(globs::directDrawGlobs.bSurf,effect);
	fVar4 = extraout_ST0;
	if (BVar1 != 0) {
		uVar2 = Draw_GetColour(r,g,b);
		uVar3 = 0;
		if (dots != 0) {
			do {
				fVar4 = (float10)fsin((float10)(ulonglong)uVar3 *
															(float10)(6.283185 / (float)(ulonglong)dots));
				uVar5 = __ftol(fVar4 * (float10)(ulonglong)radius + (float10)pos->x);
				fVar4 = (float10)fcos(extraout_ST0_00);
				uVar6 = __ftol(fVar4 * (float10)(ulonglong)radius + (float10)pos->y);
				if ((((globs::drawGlobs.clipStart.x <= (float)(uVar5 & 0xffffffff)) &&
						 (globs::drawGlobs.clipStart.y <= (float)(uVar6 & 0xffffffff))) &&
						((float)(uVar5 & 0xffffffff) < globs::drawGlobs.clipEnd.x)) &&
					 ((float)(uVar6 & 0xffffffff) < globs::drawGlobs.clipEnd.y)) {
					(*globs::drawGlobs.drawPixelFunc)((int)uVar5,(int)uVar6,uVar2);
				}
				uVar3 += 1;
			} while (uVar3 < dots);
		}
		Draw_UnlockSurface(surface);
		fVar4 = extraout_ST0_01;
	}
	return fVar4;
}



uint __cdecl lego::draw::Draw_GetColour(float r,float g,float b)
{
	char cVar1;
	char cVar2;
	byte bVar3;
	uint uVar4;
	longlong lVar5;
	longlong lVar6;
	longlong lVar7;
	
	uVar4 = 0;
	if (globs::drawGlobs.bpp != 8) {
		lVar5 = __ftol((float10)r * (float10)255.0);
		cVar1 = (char)globs::drawGlobs.redBits;
		cVar2 = (char)globs::drawGlobs.greenBits;
		bVar3 = (byte)globs::drawGlobs.blueBits;
		lVar6 = __ftol((float10)g * (float10)255.0);
		lVar7 = __ftol((float10)b * (float10)255.0);
		uVar4 = ((uint)lVar5 >> (8U - cVar1 & 0x1f)) << (cVar2 + bVar3 & 0x1f) |
						((uint)lVar6 >> (8U - cVar2 & 0x1f)) << (bVar3 & 0x1f) |
						(uint)lVar7 >> (8 - bVar3 & 0x1f);
	}
	return uVar4;
}



BOOL __cdecl lego::draw::Draw_LockSurface(IDirectDrawSurface4 *surface,DrawEffect effect)
{
	HRESULT HVar1;
	uint uVar2;
	BOOL BVar3;
	int iVar4;
	uint uVar5;
	DDSURFACEDESC2 *pDVar6;
	DDSURFACEDESC2 desc;
	
	pDVar6 = &desc;
	for (iVar4 = 0x1f; iVar4 != 0; iVar4 += -1) {
		pDVar6->dwSize = 0;
		pDVar6 = (DDSURFACEDESC2 *)&pDVar6->dwFlags;
	}
	desc.dwSize = 0x7c;
	HVar1 = (*surface->lpVtbl->Lock)(surface,NULL,&desc,1,NULL);
	if (HVar1 == 0) {
		globs::drawGlobs.buffer = desc.lpSurface;
		uVar5 = 0;
		globs::drawGlobs.pitch = desc.lPitch;
		globs::drawGlobs.redMask = desc.ddpfPixelFormat.dwRBitMask;
		globs::drawGlobs.greenMask = desc.ddpfPixelFormat.dwGBitMask;
		globs::drawGlobs.blueMask = desc.ddpfPixelFormat.dwBBitMask;
		globs::drawGlobs.bpp = desc.ddpfPixelFormat.dwRGBBitCount;
		globs::drawGlobs.blueBits = 0;
		globs::drawGlobs.greenBits = 0;
		globs::drawGlobs.redBits = 0;
		if (desc.ddpfPixelFormat.dwRGBBitCount != 0) {
			do {
				uVar2 = 1 << ((byte)uVar5 & 0x1f);
				if ((uVar2 & desc.ddpfPixelFormat.dwRBitMask) != 0) {
					globs::drawGlobs.redBits += 1;
				}
				if ((uVar2 & desc.ddpfPixelFormat.dwGBitMask) != 0) {
					globs::drawGlobs.greenBits += 1;
				}
				if ((uVar2 & desc.ddpfPixelFormat.dwBBitMask) != 0) {
					globs::drawGlobs.blueBits += 1;
				}
				uVar5 += 1;
			} while (uVar5 < desc.ddpfPixelFormat.dwRGBBitCount);
		}
		BVar3 = Draw_SetDrawPixelFunc(effect);
		if (BVar3 != 0) {
			return TRUE;
		}
		Draw_UnlockSurface(surface);
	}
	return 0;
}



void __cdecl lego::draw::Draw_UnlockSurface(IDirectDrawSurface4 *surface)
{
	(*surface->lpVtbl->Unlock)(surface,NULL);
	globs::drawGlobs.drawPixelFunc = NULL;
	globs::drawGlobs.buffer = NULL;
	globs::drawGlobs.pitch = 0;
	globs::drawGlobs.bpp = 0;
	globs::drawGlobs.redMask = 0;
	globs::drawGlobs.greenMask = 0;
	globs::drawGlobs.blueMask = 0;
	return;
}



BOOL __cdecl lego::draw::Draw_SetDrawPixelFunc(DrawEffect effect)
{
	if (globs::drawGlobs.bpp == 8) {
		globs::drawGlobs.drawPixelFunc = Draw_Pixel8;
		return DRAWEFFECT_XOR;
	}
	if (globs::drawGlobs.bpp != 0x10) {
		if (globs::drawGlobs.bpp == 0x18) {
			globs::drawGlobs.drawPixelFunc = Draw_Pixel24;
			return DRAWEFFECT_XOR;
		}
		if (globs::drawGlobs.bpp == 0x20) {
			globs::drawGlobs.drawPixelFunc = Draw_Pixel32;
			return DRAWEFFECT_XOR;
		}
		globs::drawGlobs.drawPixelFunc = NULL;
		return DRAWEFFECT_NONE;
	}
	if (effect == DRAWEFFECT_XOR) {
		globs::drawGlobs.drawPixelFunc = Draw_Pixel16XOR;
		return effect;
	}
	if (effect == DRAWEFFECT_HALFTRANS) {
		globs::drawGlobs.drawPixelFunc = Draw_Pixel16HalfTrans;
		return DRAWEFFECT_XOR;
	}
	globs::drawGlobs.drawPixelFunc = Draw_Pixel16;
	return DRAWEFFECT_XOR;
}



void __cdecl lego::draw::Draw_LineActual(int x1,int y1,int x2,int y2,uint colour)
{
	bool bVar1;
	uint uVar2;
	int iVar3;
	int iVar4;
	int iVar5;
	int iVar6;
	int iVar7;
	uint uVar8;
	int iVar9;
	uint local_10;
	int local_4;
	
	iVar4 = y1;
	iVar3 = x1;
	uVar8 = x2 - x1 >> 0x1f;
	iVar7 = (x2 - x1 ^ uVar8) - uVar8;
	uVar8 = y2 - y1 >> 0x1f;
	iVar5 = (y2 - y1 ^ uVar8) - uVar8;
	bVar1 = iVar7 < iVar5;
	if (bVar1) {
		iVar6 = iVar7 - iVar5;
		iVar9 = iVar7 * 2 - iVar5;
		local_4 = iVar5;
	}
	else {
		iVar6 = iVar5 - iVar7;
		iVar9 = iVar5 * 2 - iVar7;
		local_4 = iVar7;
		iVar7 = iVar5;
	}
	local_10 = 1;
	y1 = 1;
	x1 = ZEXT14(!bVar1);
	local_4 += 1;
	uVar8 = (uint)bVar1;
	if (x2 < iVar3) {
		y1 = -1;
		x1 = -x1;
	}
	if (y2 < iVar4) {
		uVar8 = -uVar8;
		local_10 = 0xffffffff;
	}
	x2 = iVar3;
	y2 = iVar4;
	if (0 < local_4) {
		do {
			if ((((globs::drawGlobs.clipStart.x <= (float)x2) &&
					 (globs::drawGlobs.clipStart.y <= (float)y2)) && ((float)x2 < globs::drawGlobs.clipEnd.x))
				 && ((float)y2 < globs::drawGlobs.clipEnd.y)) {
				(*globs::drawGlobs.drawPixelFunc)(x2,y2,colour);
			}
			uVar2 = local_10;
			iVar3 = y1;
			iVar4 = iVar6;
			if (iVar9 < 0) {
				uVar2 = uVar8;
				iVar3 = x1;
				iVar4 = iVar7;
			}
			x2 += iVar3;
			iVar9 += iVar4 * 2;
			y2 += uVar2;
			local_4 += -1;
		} while (local_4 != 0);
	}
	return;
}



// 8bit Pixel Routine

void __cdecl lego::draw::Draw_Pixel8(int x,int y,uint value)
{
	*(undefined *)(y * globs::drawGlobs.pitch + x + (int)globs::drawGlobs.buffer) = (undefined)value;
	return;
}



// 16bit (565) Pixel Routine (normal)

void __cdecl lego::draw::Draw_Pixel16(int x,int y,uint value)
{
	*(undefined2 *)((int)globs::drawGlobs.buffer + x * 2 + y * globs::drawGlobs.pitch) =
			 (undefined2)value;
	return;
}



// 16bit (565) Pixel Routine (XOR)

void __cdecl lego::draw::Draw_Pixel16XOR(int x,int y,uint value)
{
	ushort *puVar1;
	
	puVar1 = (ushort *)((int)globs::drawGlobs.buffer + x * 2 + y * globs::drawGlobs.pitch);
	*puVar1 = *puVar1 ^ (ushort)value;
	return;
}



// 16bit (565) Pixel Routine (HalfTrans)

void __cdecl lego::draw::Draw_Pixel16HalfTrans(int x,int y,uint value)
{
	ushort *puVar1;
	ushort uVar2;
	ushort uVar3;
	
	puVar1 = (ushort *)((int)globs::drawGlobs.buffer + x * 2 + y * globs::drawGlobs.pitch);
	uVar2 = *puVar1;
	uVar3 = (ushort)value;
	*puVar1 = (((ushort)globs::drawGlobs.greenMask & uVar2) >> 1 & 0x7fe0) +
						(((ushort)globs::drawGlobs.greenMask & uVar3) >> 1 & 0x7fe0) &
						(ushort)globs::drawGlobs.greenMask |
						((uVar3 & (ushort)globs::drawGlobs.blueMask) >> 1) +
						((uVar2 & (ushort)globs::drawGlobs.blueMask) >> 1) & (ushort)globs::drawGlobs.blueMask |
						(uVar3 >> 1 & 0x7800) + (uVar2 >> 1 & 0x7800) & (ushort)globs::drawGlobs.redMask;
	return;
}



// 24bit Pixel Routine

void __cdecl lego::draw::Draw_Pixel24(int x,int y,uint value)
{
	uint *puVar1;
	
	puVar1 = (uint *)((int)globs::drawGlobs.buffer + x * 3 + y * globs::drawGlobs.pitch);
	*puVar1 = value << 8 | *puVar1 & 0xff;
	return;
}



// 32bit Pixel Routine

void __cdecl lego::draw::Draw_Pixel32(int x,int y,uint value)
{
	*(uint *)((int)globs::drawGlobs.buffer + x * 4 + y * globs::drawGlobs.pitch) = value;
	return;
}



Lws_Info * __cdecl lego::res::Lws_Parse(char *fname,BOOL looping)
{
	char *pcVar1;
	int iVar2;
	float fVar3;
	char cVar4;
	byte bVar5;
	ushort uVar6;
	File *file;
	byte *pbVar7;
	int iVar8;
	byte *pbVar9;
	char *pcVar10;
	Lws_Node *pLVar11;
	int iVar12;
	Lws_KeyInfo *pLVar13;
	float *pfVar14;
	ushort *puVar15;
	uint uVar16;
	uint uVar17;
	Lws_Node *pLVar18;
	Lws_Info *scene;
	char *pcVar19;
	undefined4 *puVar20;
	Lws_Info *pLVar21;
	undefined4 *puVar22;
	bool bVar23;
	float10 fVar24;
	void *local_968;
	uint local_964;
	uint local_960;
	Lws_Node *local_958;
	byte *local_954;
	byte *local_950;
	char *local_94c;
	char *local_948;
	char *local_944;
	char *local_940;
	char *local_93c;
	char *local_938;
	char *local_934;
	char *local_930;
	char local_904 [260];
	char local_800 [1024];
	char local_400 [1024];
	
	scene = NULL;
	std::sprintf(local_904,"%s.%s",fname,"lws");
	file = lego::file::File_Open(local_904,"r");
	if (file != NULL) {
		lego::file::File_GetLine(local_800,0x400,file);
		uVar16 = 0xffffffff;
		pcVar19 = local_800;
		do {
			if (uVar16 == 0) break;
			uVar16 -= 1;
			cVar4 = *pcVar19;
			pcVar19 = pcVar19 + 1;
		} while (cVar4 != '\0');
		pbVar9 = (byte *)(local_800 + (~uVar16 & 0xffff));
		lego::file::File_GetLine((char *)pbVar9,0x400 - (~uVar16 & 0xffff),file);
		pcVar19 = "LWSC";
		pbVar7 = (byte *)local_800;
		do {
			bVar5 = *pbVar7;
			bVar23 = bVar5 < (byte)*pcVar19;
			if (bVar5 != *pcVar19) {
LAB_00486d70:
				iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
				goto LAB_00486d75;
			}
			if (bVar5 == 0) break;
			bVar5 = pbVar7[1];
			bVar23 = bVar5 < ((byte *)pcVar19)[1];
			if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00486d70;
			pbVar7 = pbVar7 + 2;
			pcVar19 = (char *)((byte *)pcVar19 + 2);
		} while (bVar5 != 0);
		iVar8 = 0;
LAB_00486d75:
		if (iVar8 == 0) {
			pcVar19 = "1";
			do {
				bVar5 = *pbVar9;
				bVar23 = bVar5 < (byte)*pcVar19;
				if (bVar5 != *pcVar19) {
LAB_00486da8:
					iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
					goto LAB_00486dad;
				}
				if (bVar5 == 0) break;
				bVar5 = pbVar9[1];
				bVar23 = bVar5 < ((byte *)pcVar19)[1];
				if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00486da8;
				pbVar9 = pbVar9 + 2;
				pcVar19 = (char *)((byte *)pcVar19 + 2);
			} while (bVar5 != 0);
			iVar8 = 0;
LAB_00486dad:
			if (iVar8 == 0) {
				local_964 = 0;
				local_960 = 0;
				pLVar18 = NULL;
				pcVar19 = local_904;
				pcVar10 = local_904;
				cVar4 = local_904[0];
				while (cVar4 != '\0') {
					if (cVar4 == '\\') {
						pcVar19 = pcVar10;
					}
					pcVar1 = pcVar10 + 1;
					pcVar10 = pcVar10 + 1;
					cVar4 = *pcVar1;
				}
				pcVar19[pcVar19 != local_904] = '\0';
				scene = (Lws_Info *)std::malloc(0x38);
				pLVar21 = scene;
				for (iVar8 = 0xe; iVar8 != 0; iVar8 += -1) {
					*(undefined4 *)pLVar21 = 0;
					pLVar21 = (Lws_Info *)&pLVar21->fps;
				}
				if (local_904[0] == '\0') {
					scene->filePath = NULL;
				}
				else {
					pcVar19 = std::_strdup(local_904);
					scene->filePath = pcVar19;
				}
				scene->nodeListSize = 10;
				scene->referenceCount = 1;
				if (looping != 0) {
					scene->flags = scene->flags | 1;
				}
				pLVar11 = (Lws_Node *)std::malloc(0x208);
				scene->nodeList = pLVar11;
				local_968 = std::malloc((uint)scene->nodeListSize << 1);
				pcVar19 = lego::file::File_GetLine(local_800,0x400,file);
				while (pcVar19 != NULL) {
					uVar16 = 0xffffffff;
					pcVar19 = local_800;
					do {
						pcVar10 = pcVar19;
						if (uVar16 == 0) break;
						uVar16 -= 1;
						pcVar10 = pcVar19 + 1;
						cVar4 = *pcVar19;
						pcVar19 = pcVar10;
					} while (cVar4 != '\0');
					uVar16 = ~uVar16;
					puVar20 = (undefined4 *)(pcVar10 + -uVar16);
					puVar22 = (undefined4 *)local_400;
					for (uVar17 = uVar16 >> 2; uVar17 != 0; uVar17 -= 1) {
						*puVar22 = *puVar20;
						puVar20 = puVar20 + 1;
						puVar22 = puVar22 + 1;
					}
					for (uVar16 &= 3; uVar16 != 0; uVar16 -= 1) {
						*(undefined *)puVar22 = *(undefined *)puVar20;
						puVar20 = (undefined4 *)((int)puVar20 + 1);
						puVar22 = (undefined4 *)((int)puVar22 + 1);
					}
					iVar8 = util::Util_WSTokenise(local_400,(char **)&local_954);
					if (iVar8 != 0) {
						if (pLVar18 == NULL) {
							pcVar19 = "FirstFrame";
							pbVar9 = local_954;
							do {
								bVar5 = *pcVar19;
								bVar23 = bVar5 < *pbVar9;
								if (bVar5 != *pbVar9) {
LAB_00486f0b:
									iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
									goto LAB_00486f10;
								}
								if (bVar5 == 0) break;
								bVar5 = ((byte *)pcVar19)[1];
								bVar23 = bVar5 < pbVar9[1];
								if (bVar5 != pbVar9[1]) goto LAB_00486f0b;
								pcVar19 = (char *)((byte *)pcVar19 + 2);
								pbVar9 = pbVar9 + 2;
							} while (bVar5 != 0);
							iVar8 = 0;
LAB_00486f10:
							if (iVar8 == 0) {
								iVar8 = std::atoi((char *)local_950);
								scene->firstFrame = (ushort)iVar8;
							}
							pcVar19 = "LastFrame";
							pbVar9 = local_954;
							do {
								bVar5 = *pcVar19;
								bVar23 = bVar5 < *pbVar9;
								if (bVar5 != *pbVar9) {
LAB_00486f55:
									iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
									goto LAB_00486f5a;
								}
								if (bVar5 == 0) break;
								bVar5 = ((byte *)pcVar19)[1];
								bVar23 = bVar5 < pbVar9[1];
								if (bVar5 != pbVar9[1]) goto LAB_00486f55;
								pcVar19 = (char *)((byte *)pcVar19 + 2);
								pbVar9 = pbVar9 + 2;
							} while (bVar5 != 0);
							iVar8 = 0;
LAB_00486f5a:
							if (iVar8 == 0) {
								iVar8 = std::atoi((char *)local_950);
								scene->lastFrame = (ushort)iVar8;
							}
							if (scene->lastFrame == 0) {
								scene->lastFrame = 1;
							}
							pcVar19 = "FramesPerSecond";
							pbVar9 = local_954;
							do {
								bVar5 = *pcVar19;
								bVar23 = bVar5 < *pbVar9;
								if (bVar5 != *pbVar9) {
LAB_00486fb3:
									iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
									goto LAB_00486fb8;
								}
								if (bVar5 == 0) break;
								bVar5 = ((byte *)pcVar19)[1];
								bVar23 = bVar5 < pbVar9[1];
								if (bVar5 != pbVar9[1]) goto LAB_00486fb3;
								pcVar19 = (char *)((byte *)pcVar19 + 2);
								pbVar9 = pbVar9 + 2;
							} while (bVar5 != 0);
							iVar8 = 0;
LAB_00486fb8:
							if (iVar8 == 0) {
								fVar24 = std::atof((char *)local_950);
								scene->fps = (float)fVar24;
							}
							pcVar19 = "AddNullObject";
							pbVar9 = local_954;
							do {
								bVar5 = *pcVar19;
								bVar23 = bVar5 < *pbVar9;
								if (bVar5 != *pbVar9) {
LAB_00486fff:
									iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
									goto LAB_00487004;
								}
								if (bVar5 == 0) break;
								bVar5 = ((byte *)pcVar19)[1];
								bVar23 = bVar5 < pbVar9[1];
								if (bVar5 != pbVar9[1]) goto LAB_00486fff;
								pcVar19 = (char *)((byte *)pcVar19 + 2);
								pbVar9 = pbVar9 + 2;
							} while (bVar5 != 0);
							iVar8 = 0;
LAB_00487004:
							if (iVar8 != 0) {
								pcVar19 = "LoadObject";
								pbVar9 = local_954;
								do {
									bVar5 = *pcVar19;
									bVar23 = bVar5 < *pbVar9;
									if (bVar5 != *pbVar9) {
LAB_00487033:
										iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
										goto LAB_00487038;
									}
									if (bVar5 == 0) break;
									bVar5 = ((byte *)pcVar19)[1];
									bVar23 = bVar5 < pbVar9[1];
									if (bVar5 != pbVar9[1]) goto LAB_00487033;
									pcVar19 = (char *)((byte *)pcVar19 + 2);
									pbVar9 = pbVar9 + 2;
								} while (bVar5 != 0);
								iVar8 = 0;
LAB_00487038:
								if (iVar8 != 0) goto LAB_004877aa;
							}
							if (scene->nodeCount == scene->nodeListSize) {
								uVar6 = scene->nodeListSize + 10;
								scene->nodeListSize = uVar6;
								pLVar18 = (Lws_Node *)std::realloc(scene->nodeList,(uint)uVar6 * 0x34);
								scene->nodeList = pLVar18;
								local_968 = std::realloc(local_968,(uint)scene->nodeListSize << 1);
							}
							*(undefined2 *)((int)local_968 + (uint)scene->nodeCount * 2) = 0;
							pLVar18 = scene->nodeList + scene->nodeCount;
							local_958 = pLVar18;
							pLVar11 = pLVar18;
							for (iVar8 = 0xd; iVar8 != 0; iVar8 += -1) {
								pLVar11->name = NULL;
								pLVar11 = (Lws_Node *)&pLVar11->reference;
							}
							pcVar19 = "AddNullObject";
							pbVar9 = local_954;
							do {
								bVar5 = *pcVar19;
								bVar23 = bVar5 < *pbVar9;
								if (bVar5 != *pbVar9) {
LAB_004870eb:
									iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
									goto LAB_004870f0;
								}
								if (bVar5 == 0) break;
								bVar5 = ((byte *)pcVar19)[1];
								bVar23 = bVar5 < pbVar9[1];
								if (bVar5 != pbVar9[1]) goto LAB_004870eb;
								pcVar19 = (char *)((byte *)pcVar19 + 2);
								pbVar9 = pbVar9 + 2;
							} while (bVar5 != 0);
							iVar8 = 0;
LAB_004870f0:
							if (iVar8 == 0) {
								pLVar18->flags = pLVar18->flags | 1;
								pcVar19 = std::_strdup(local_800 + 0xe);
								pLVar18->name = pcVar19;
								iVar8 = std::_strnicmp(pcVar19,"SFX",3);
								if ((iVar8 == 0) && (iVar8 = std::_strnicmp(pLVar18->name + 3,",",1), iVar8 == 0)) {
									pLVar18->flags = pLVar18->flags | 2;
									scene->triggerCount = scene->triggerCount + 1;
								}
							}
							else {
								uVar16 = 0xffffffff;
								pcVar19 = local_800;
								do {
									pcVar10 = pcVar19;
									if (uVar16 == 0) break;
									uVar16 -= 1;
									pcVar10 = pcVar19 + 1;
									cVar4 = *pcVar19;
									pcVar19 = pcVar10;
								} while (cVar4 != '\0');
								uVar16 = ~uVar16;
								puVar20 = (undefined4 *)(pcVar10 + -uVar16);
								puVar22 = (undefined4 *)local_400;
								for (uVar17 = uVar16 >> 2; uVar17 != 0; uVar17 -= 1) {
									*puVar22 = *puVar20;
									puVar20 = puVar20 + 1;
									puVar22 = puVar22 + 1;
								}
								for (uVar16 &= 3; uVar16 != 0; uVar16 -= 1) {
									*(undefined *)puVar22 = *(undefined *)puVar20;
									puVar20 = (undefined4 *)((int)puVar20 + 1);
									puVar22 = (undefined4 *)((int)puVar22 + 1);
								}
								iVar8 = util::Util_Tokenise(local_800,(char **)&local_954,"\\");
								pcVar19 = util::Util_StrIStr((char *)(&local_958)[iVar8],".lwo");
								if (pcVar19 != NULL) {
									*pcVar19 = '\0';
								}
								pcVar19 = std::_strdup((char *)(&local_958)[iVar8]);
								pLVar18->name = pcVar19;
							}
							iVar8 = scene->nodeCount - 1;
							if (-1 < iVar8) {
								pLVar11 = scene->nodeList + iVar8;
								do {
									bVar5 = pLVar11->flags & 1;
									if (((bVar5 != 0) && ((pLVar18->flags & 1) != 0)) ||
										 ((bVar5 == 0 && ((pLVar18->flags & 1) == 0)))) {
										pbVar9 = (byte *)pLVar11->name;
										pbVar7 = (byte *)pLVar18->name;
										do {
											bVar5 = *pbVar7;
											bVar23 = bVar5 < *pbVar9;
											if (bVar5 != *pbVar9) {
LAB_00487222:
												iVar12 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
												goto LAB_00487227;
											}
											if (bVar5 == 0) break;
											bVar5 = pbVar7[1];
											bVar23 = bVar5 < pbVar9[1];
											if (bVar5 != pbVar9[1]) goto LAB_00487222;
											pbVar7 = pbVar7 + 2;
											pbVar9 = pbVar9 + 2;
										} while (bVar5 != 0);
										iVar12 = 0;
LAB_00487227:
										pLVar18 = local_958;
										if (iVar12 == 0) {
											local_958->reference = scene->nodeList[iVar8].reference + 1;
											break;
										}
									}
									iVar8 += -1;
									pLVar11 = pLVar11 + -1;
								} while (-1 < iVar8);
							}
						}
						else {
							if (local_964 == 0) {
								if (local_960 == 0) {
									pcVar19 = "ObjectMotion";
									pbVar9 = local_954;
									do {
										bVar5 = *pbVar9;
										bVar23 = bVar5 < (byte)*pcVar19;
										if (bVar5 != *pcVar19) {
LAB_00487586:
											iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
											goto LAB_0048758b;
										}
										if (bVar5 == 0) break;
										bVar5 = pbVar9[1];
										bVar23 = bVar5 < ((byte *)pcVar19)[1];
										if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487586;
										pbVar9 = pbVar9 + 2;
										pcVar19 = (char *)((byte *)pcVar19 + 2);
									} while (bVar5 != 0);
									iVar8 = 0;
LAB_0048758b:
									if (iVar8 == 0) {
										local_964 = 1;
									}
									else {
										pcVar19 = "ObjDissolve";
										pbVar9 = local_954;
										do {
											bVar5 = *pbVar9;
											bVar23 = bVar5 < (byte)*pcVar19;
											if (bVar5 != *pcVar19) {
LAB_004875c7:
												iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
												goto LAB_004875cc;
											}
											if (bVar5 == 0) break;
											bVar5 = pbVar9[1];
											bVar23 = bVar5 < ((byte *)pcVar19)[1];
											if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_004875c7;
											pbVar9 = pbVar9 + 2;
											pcVar19 = (char *)((byte *)pcVar19 + 2);
										} while (bVar5 != 0);
										iVar8 = 0;
LAB_004875cc:
										if (iVar8 == 0) {
											pcVar19 = "(envelope)";
											pbVar9 = local_950;
											do {
												bVar5 = *pbVar9;
												bVar23 = bVar5 < (byte)*pcVar19;
												if (bVar5 != *pcVar19) {
LAB_00487603:
													iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
													goto LAB_00487608;
												}
												if (bVar5 == 0) break;
												bVar5 = pbVar9[1];
												bVar23 = bVar5 < ((byte *)pcVar19)[1];
												if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487603;
												pbVar9 = pbVar9 + 2;
												pcVar19 = (char *)((byte *)pcVar19 + 2);
											} while (bVar5 != 0);
											iVar8 = 0;
LAB_00487608:
											if (iVar8 == 0) {
												local_960 = 1;
											}
											else {
												fVar24 = std::atof((char *)local_950);
												globs::lwsGlobs.staticDissolveLevel[globs::lwsGlobs.staticDissolveCount] =
														 (float)fVar24;
												pLVar18->dissolveLevel =
														 globs::lwsGlobs.staticDissolveLevel +
														 globs::lwsGlobs.staticDissolveCount;
												globs::lwsGlobs.staticDissolveCount += 1;
												pLVar18->dissolveLevel = NULL;
											}
										}
										else {
											pcVar19 = "ParentObject";
											pbVar9 = local_954;
											do {
												bVar5 = *pbVar9;
												bVar23 = bVar5 < (byte)*pcVar19;
												if (bVar5 != *pcVar19) {
LAB_00487680:
													iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
													goto LAB_00487685;
												}
												if (bVar5 == 0) break;
												bVar5 = pbVar9[1];
												bVar23 = bVar5 < ((byte *)pcVar19)[1];
												if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487680;
												pbVar9 = pbVar9 + 2;
												pcVar19 = (char *)((byte *)pcVar19 + 2);
											} while (bVar5 != 0);
											iVar8 = 0;
LAB_00487685:
											if (iVar8 == 0) {
												iVar8 = std::atoi((char *)local_950);
												*(short *)((int)local_968 + (uint)scene->nodeCount * 2) = (short)iVar8;
											}
											else {
												pcVar19 = "PivotPoint";
												pbVar9 = local_954;
												do {
													bVar5 = *pbVar9;
													bVar23 = bVar5 < (byte)*pcVar19;
													if (bVar5 != *pcVar19) {
LAB_004876d8:
														iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
														goto LAB_004876dd;
													}
													if (bVar5 == 0) break;
													bVar5 = pbVar9[1];
													bVar23 = bVar5 < ((byte *)pcVar19)[1];
													if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_004876d8;
													pbVar9 = pbVar9 + 2;
													pcVar19 = (char *)((byte *)pcVar19 + 2);
												} while (bVar5 != 0);
												iVar8 = 0;
LAB_004876dd:
												if (iVar8 == 0) {
													fVar24 = std::atof((char *)local_950);
													(pLVar18->pivotVector).x = (float)-fVar24;
													fVar24 = std::atof(local_94c);
													(pLVar18->pivotVector).y = (float)-fVar24;
													fVar24 = std::atof(local_948);
													(pLVar18->pivotVector).z = (float)-fVar24;
												}
												else {
													pcVar19 = "UnseenByCamera";
													pbVar9 = local_954;
													do {
														bVar5 = *pbVar9;
														bVar23 = bVar5 < (byte)*pcVar19;
														if (bVar5 != *pcVar19) {
LAB_00487747:
															iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
															goto LAB_0048774c;
														}
														if (bVar5 == 0) break;
														bVar5 = pbVar9[1];
														bVar23 = bVar5 < ((byte *)pcVar19)[1];
														if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487747;
														pbVar9 = pbVar9 + 2;
														pcVar19 = (char *)((byte *)pcVar19 + 2);
													} while (bVar5 != 0);
													iVar8 = 0;
LAB_0048774c:
													if ((iVar8 == 0) && (iVar8 = std::atoi((char *)local_950), iVar8 == 1)) {
														pLVar18->flags = pLVar18->flags | 4;
													}
													else {
														pcVar19 = "ShadowOptions";
														pbVar9 = local_954;
														do {
															bVar5 = *pbVar9;
															bVar23 = bVar5 < (byte)*pcVar19;
															if (bVar5 != *pcVar19) {
LAB_00487797:
																iVar8 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
																goto LAB_0048779c;
															}
															if (bVar5 == 0) break;
															bVar5 = pbVar9[1];
															bVar23 = bVar5 < ((byte *)pcVar19)[1];
															if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487797;
															pbVar9 = pbVar9 + 2;
															pcVar19 = (char *)((byte *)pcVar19 + 2);
														} while (bVar5 != 0);
														iVar8 = 0;
LAB_0048779c:
														if (iVar8 == 0) {
															pLVar18 = NULL;
															scene->nodeCount = scene->nodeCount + 1;
														}
													}
												}
											}
										}
									}
								}
								else {
									if (local_960 != 1) {
										if (local_960 == 2) {
											uVar16 = std::atoi((char *)local_950);
											pLVar18->dissolveCount = (ushort)uVar16;
											pfVar14 = (float *)std::malloc((uVar16 & 0xffff) * 4 + 4);
											pLVar18->dissolveLevel = pfVar14;
											puVar15 = (ushort *)std::malloc((uint)pLVar18->dissolveCount * 2 + 2);
											pLVar18->dissolveFrame = puVar15;
										}
										else {
											uVar16 = (int)(local_960 - 3) / 2;
											if ((ushort)uVar16 < pLVar18->dissolveCount) {
												uVar17 = (int)local_960 >> 0x1f;
												if (((local_960 ^ uVar17) - uVar17 & 1 ^ uVar17) == uVar17) {
													iVar8 = std::atoi((char *)local_950);
													pLVar18->dissolveFrame[uVar16 & 0xffff] = (ushort)iVar8;
												}
												else {
													uVar16 &= 0xffff;
													fVar24 = std::atof((char *)local_950);
													pLVar18->dissolveLevel[uVar16] = (float)fVar24;
													if (pLVar18->dissolveLevel[uVar16] < 0.0) {
														pLVar18->dissolveLevel[uVar16] = 0.0;
													}
													fVar3 = pLVar18->dissolveLevel[uVar16];
													if ((ushort)((ushort)(fVar3 < 1.0) << 8 | (ushort)(fVar3 == 1.0) << 0xe)
															== 0) {
														pLVar18->dissolveLevel[uVar16] = 1.0;
													}
													pLVar18->dissolveLevel[uVar16] = 1.0 - pLVar18->dissolveLevel[uVar16];
												}
											}
										}
									}
									pcVar19 = "EndBehavior";
									pbVar9 = local_954;
									do {
										bVar5 = *pbVar9;
										bVar23 = bVar5 < (byte)*pcVar19;
										if (bVar5 != *pcVar19) {
LAB_00487541:
											uVar16 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
											goto LAB_00487546;
										}
										if (bVar5 == 0) break;
										bVar5 = pbVar9[1];
										bVar23 = bVar5 < ((byte *)pcVar19)[1];
										if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_00487541;
										pbVar9 = pbVar9 + 2;
										pcVar19 = (char *)((byte *)pcVar19 + 2);
									} while (bVar5 != 0);
									uVar16 = 0;
LAB_00487546:
									local_960 = local_960 + 1;
									if (uVar16 == 0) {
										local_960 = uVar16;
									}
								}
							}
							else {
								if (local_964 != 1) {
									if (local_964 == 2) {
										uVar16 = std::atoi((char *)local_950);
										pLVar18->keyCount = (ushort)uVar16;
										pLVar13 = (Lws_KeyInfo *)std::malloc(((uVar16 & 0xffff) + 1) * 0x28);
										pLVar18->keyList = pLVar13;
									}
									else {
										uVar16 = (int)(local_964 - 3) / 2;
										if ((ushort)uVar16 < pLVar18->keyCount) {
											uVar17 = (int)local_964 >> 0x1f;
											if (((local_964 ^ uVar17) - uVar17 & 1 ^ uVar17) == uVar17) {
												iVar8 = std::atoi((char *)local_950);
												pLVar18->keyList[uVar16 & 0xffff].frame = (ushort)iVar8;
											}
											else {
												uVar16 &= 0xffff;
												fVar24 = std::atof((char *)local_950);
												pLVar18->keyList[uVar16].position.x = (float)fVar24;
												fVar24 = std::atof(local_94c);
												pLVar18->keyList[uVar16].position.y = (float)fVar24;
												fVar24 = std::atof(local_948);
												pLVar18->keyList[uVar16].position.z = (float)fVar24;
												fVar24 = std::atof(local_944);
												pLVar18->keyList[uVar16].hpb.x =
														 (float)(fVar24 * (float10)0.005555556 * (float10)3.141593);
												fVar24 = std::atof(local_940);
												pLVar18->keyList[uVar16].hpb.y =
														 (float)(fVar24 * (float10)0.005555556 * (float10)3.141593);
												fVar24 = std::atof(local_93c);
												pLVar18->keyList[uVar16].hpb.z =
														 (float)(fVar24 * (float10)0.005555556 * (float10)3.141593);
												fVar24 = std::atof(local_938);
												pLVar18->keyList[uVar16].scale.x = (float)fVar24;
												fVar24 = std::atof(local_934);
												pLVar18->keyList[uVar16].scale.y = (float)fVar24;
												fVar24 = std::atof(local_930);
												pLVar18->keyList[uVar16].scale.z = (float)fVar24;
											}
										}
									}
								}
								pcVar19 = "EndBehavior";
								pbVar9 = local_954;
								do {
									bVar5 = *pbVar9;
									bVar23 = bVar5 < (byte)*pcVar19;
									if (bVar5 != *pcVar19) {
LAB_004873f6:
										uVar16 = (1 - (uint)bVar23) - (uint)(bVar23 != 0);
										goto LAB_004873fb;
									}
									if (bVar5 == 0) break;
									bVar5 = pbVar9[1];
									bVar23 = bVar5 < ((byte *)pcVar19)[1];
									if (bVar5 != ((byte *)pcVar19)[1]) goto LAB_004873f6;
									pbVar9 = pbVar9 + 2;
									pcVar19 = (char *)((byte *)pcVar19 + 2);
								} while (bVar5 != 0);
								uVar16 = 0;
LAB_004873fb:
								local_964 = local_964 + 1;
								if (uVar16 == 0) {
									local_964 = uVar16;
								}
							}
						}
					}
LAB_004877aa:
					pcVar19 = lego::file::File_GetLine(local_800,0x400,file);
				}
				iVar8 = 0;
				if (scene->nodeCount != 0) {
					iVar12 = 0;
					do {
						pbVar9 = scene->nodeList->padding1 + iVar12 + -9;
						if (*(ushort *)(pbVar9 + 0x24) != 1) {
							iVar2 = *(int *)(pbVar9 + 0x18) + (uint)*(ushort *)(pbVar9 + 0x24) * 0x28;
							if (*(ushort *)(iVar2 + -4) < scene->lastFrame) {
								*(ushort *)(iVar2 + 0x24) = scene->lastFrame;
								puVar20 = (undefined4 *)
													(*(int *)(pbVar9 + 0x18) + (uint)*(ushort *)(pbVar9 + 0x24) * 0x28);
								*puVar20 = puVar20[-10];
								puVar20[1] = puVar20[-9];
								puVar20[2] = puVar20[-8];
								iVar2 = *(int *)(pbVar9 + 0x18) + (uint)*(ushort *)(pbVar9 + 0x24) * 0x28;
								*(undefined4 *)(iVar2 + 0xc) = *(undefined4 *)(iVar2 + -0x1c);
								*(undefined4 *)(iVar2 + 0x10) = *(undefined4 *)(iVar2 + -0x18);
								*(undefined4 *)(iVar2 + 0x14) = *(undefined4 *)(iVar2 + -0x14);
								iVar2 = *(int *)(pbVar9 + 0x18) + (uint)*(ushort *)(pbVar9 + 0x24) * 0x28;
								*(undefined4 *)(iVar2 + 0x18) = *(undefined4 *)(iVar2 + -0x10);
								*(undefined4 *)(iVar2 + 0x1c) = *(undefined4 *)(iVar2 + -0xc);
								*(undefined4 *)(iVar2 + 0x20) = *(undefined4 *)(iVar2 + -8);
								*(short *)(pbVar9 + 0x24) = *(short *)(pbVar9 + 0x24) + 1;
							}
						}
						iVar8 += 1;
						iVar12 += 0x34;
					} while (iVar8 < (int)(uint)scene->nodeCount);
				}
				iVar8 = 0;
				if (scene->nodeCount != 0) {
					iVar12 = 0;
					do {
						pbVar9 = scene->nodeList->padding1 + iVar12 + -9;
						if (*(ushort *)(pbVar9 + 0x26) != 0) {
							puVar15 = (ushort *)(*(int *)(pbVar9 + 0x20) + (uint)*(ushort *)(pbVar9 + 0x26) * 2);
							if (puVar15[-1] < scene->lastFrame) {
								*puVar15 = scene->lastFrame;
								puVar20 = (undefined4 *)
													(*(int *)(pbVar9 + 0x1c) + (uint)*(ushort *)(pbVar9 + 0x26) * 4);
								*puVar20 = puVar20[-1];
								*(short *)(pbVar9 + 0x26) = *(short *)(pbVar9 + 0x26) + 1;
							}
						}
						iVar8 += 1;
						iVar12 += 0x34;
					} while (iVar8 < (int)(uint)scene->nodeCount);
				}
				uVar16 = (uint)scene->nodeCount;
				iVar8 = uVar16 - 1;
				if (-1 < iVar8) {
					puVar15 = (ushort *)((int)local_968 + iVar8 * 2);
					iVar8 *= 0x34;
					do {
						pLVar18 = (Lws_Node *)(scene->nodeList->padding1 + iVar8 + -9);
						if (*puVar15 == 0) {
							pLVar18->next = scene->masterNode;
							scene->masterNode = pLVar18;
						}
						else {
							pLVar11 = scene->nodeList + (*puVar15 - 1);
							pLVar18->next = pLVar11->childList;
							pLVar11->childList = pLVar18;
						}
						iVar8 += -0x34;
						puVar15 = puVar15 + -1;
						uVar16 -= 1;
					} while (uVar16 != 0);
				}
				std::free(local_968);
				Lws_SetupSoundTriggers(scene);
			}
		}
		lego::file::File_Close(file);
	}
	return scene;
}



void __cdecl
lego::res::Lws_Initialise
					(char *sharedDir,_LwsFindSFXIDFunc *FindSFXID,_LwsPlaySample3DFunc *PlaySample3D,
					_LwsSoundEnabledFunc *SoundEnabled)
{
	char cVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	if (sharedDir != NULL) {
		uVar2 = 0xffffffff;
		pcVar6 = sharedDir;
		do {
			if (uVar2 == 0) break;
			uVar2 -= 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
		uVar3 = ~uVar2 - 1;
		if (sharedDir[(uVar3 & 0xffff) - 1] != '\\') {
			uVar3 = ~uVar2;
		}
		uVar3 &= 0xffff;
		globs::lwsGlobs.sharedDir = (char *)std::malloc(uVar3 + 1);
		uVar2 = 0xffffffff;
		do {
			pcVar6 = sharedDir;
			if (uVar2 == 0) break;
			uVar2 -= 1;
			pcVar6 = sharedDir + 1;
			cVar1 = *sharedDir;
			sharedDir = pcVar6;
		} while (cVar1 != '\0');
		uVar2 = ~uVar2;
		puVar5 = (undefined4 *)(pcVar6 + -uVar2);
		puVar7 = (undefined4 *)globs::lwsGlobs.sharedDir;
		for (uVar4 = uVar2 >> 2; uVar4 != 0; uVar4 -= 1) {
			*puVar7 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar7 = puVar7 + 1;
		}
		for (uVar2 &= 3; uVar2 != 0; uVar2 -= 1) {
			*(undefined *)puVar7 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar7 = (undefined4 *)((int)puVar7 + 1);
		}
		globs::lwsGlobs.sharedDir[uVar3 - 1] = '\\';
		globs::lwsGlobs.sharedDir[uVar3] = '\0';
	}
	globs::lwsGlobs.FindSFXIDFunc = (LwsFindSFXIDFunc)FindSFXID;
	globs::lwsGlobs.SoundEnabledFunc = (LwsSoundEnabledFunc)SoundEnabled;
	globs::lwsGlobs.PlaySample3DFunc = (LwsPlaySample3DFunc)PlaySample3D;
	return;
}



void __cdecl lego::res::Lws_Shutdown(void)
{
	uint uVar1;
	uint uVar2;
	
	uVar2 = 0;
	if (globs::lwsGlobs.meshPathCount != 0) {
		uVar1 = 0;
		do {
			std::free(globs::lwsGlobs.meshPathList[uVar1].path);
			uVar2 += 1;
			uVar1 = uVar2 & 0xffff;
		} while (uVar1 < globs::lwsGlobs.meshPathCount);
	}
	uVar2 = 0;
	if (globs::lwsGlobs.meshPathCountShared != 0) {
		uVar1 = 0;
		do {
			std::free(globs::lwsGlobs.meshPathListShared[uVar1].path);
			uVar2 += 1;
			uVar1 = uVar2 & 0xffff;
		} while (uVar1 < globs::lwsGlobs.meshPathCountShared);
	}
	return;
}



uint __cdecl lego::res::Lws_GetFrameCount(Lws_Info *scene)
{
	return (uint)scene->lastFrame;
}



void __cdecl lego::res::Lws_SetupSoundTriggers(Lws_Info *scene)
{
	Lws_Node *pLVar1;
	char cVar2;
	byte bVar3;
	ushort uVar4;
	ushort uVar5;
	Lws_SoundTrigger *pLVar6;
	int iVar7;
	BOOL BVar8;
	char *pcVar9;
	uint uVar10;
	uint uVar11;
	undefined4 *puVar12;
	ushort *puVar13;
	char *pcVar14;
	undefined4 *puVar15;
	char **ppcVar16;
	uint uStack2052;
	char *local_800;
	char *local_7fc;
	char *apcStack2040 [254];
	undefined4 local_400 [256];
	
	if (globs::lwsGlobs.FindSFXIDFunc == NULL) {
		scene->triggerCount = 0;
	}
	else {
		bVar3 = 0;
		if (scene->triggerCount != 0) {
			pLVar6 = (Lws_SoundTrigger *)std::malloc((uint)scene->triggerCount * 0xd0);
			scene->triggerList = pLVar6;
			uVar5 = 0;
			if (scene->nodeCount != 0) {
				do {
					pLVar1 = scene->nodeList + uVar5;
					if ((scene->nodeList[uVar5].flags & 2) != 0) {
						pLVar6 = scene->triggerList + bVar3;
						pLVar1->triggerIndex = bVar3;
						bVar3 += 1;
						uVar10 = 0xffffffff;
						pcVar9 = pLVar1->name;
						do {
							pcVar14 = pcVar9;
							if (uVar10 == 0) break;
							uVar10 -= 1;
							pcVar14 = pcVar9 + 1;
							cVar2 = *pcVar9;
							pcVar9 = pcVar14;
						} while (cVar2 != '\0');
						uVar10 = ~uVar10;
						puVar12 = (undefined4 *)(pcVar14 + -uVar10);
						puVar15 = local_400;
						for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
							*puVar15 = *puVar12;
							puVar12 = puVar12 + 1;
							puVar15 = puVar15 + 1;
						}
						for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
							*(undefined *)puVar15 = *(undefined *)puVar12;
							puVar12 = (undefined4 *)((int)puVar12 + 1);
							puVar15 = (undefined4 *)((int)puVar15 + 1);
						}
						iVar7 = util::Util_Tokenise((char *)local_400,&local_800,",");
						pLVar6->count = (short)iVar7 - 2;
						BVar8 = (*globs::lwsGlobs.FindSFXIDFunc)(local_7fc,(uint *)pLVar6);
						if (((globs::mainGlobs.flags & CMD_REDUCESAMPLES) != CMD_NONE) && (BVar8 == 0)) {
							pLVar6->sfxID = 0;
						}
						uStack2052 = 0;
						if (pLVar6->count != 0) {
							ppcVar16 = apcStack2040;
							puVar13 = pLVar6->frameEndList;
							do {
								pcVar9 = std::strstr(*ppcVar16,"-");
								iVar7 = std::atoi(*ppcVar16);
								uVar4 = (ushort)iVar7;
								puVar13[-0x19] = uVar4;
								if (pcVar9 != NULL) {
									iVar7 = std::atoi(pcVar9 + 1);
									uVar4 = (ushort)iVar7;
								}
								*puVar13 = uVar4;
								uStack2052 += 1;
								puVar13 = puVar13 + 1;
								ppcVar16 = ppcVar16 + 1;
							} while (uStack2052 < pLVar6->count);
						}
					}
					uVar5 += 1;
					if (scene->nodeCount <= uVar5) {
						return;
					}
				} while( true );
			}
		}
	}
	return;
}



void __cdecl lego::res::Lws_LoadMeshes(Lws_Info *scene,IDirect3DRMFrame3 *parent)
{
	Lws_Node *node;
	IDirect3DRMFrame3 *pIVar1;
	undefined4 local_4;
	
	local_4 = 0;
	pIVar1 = (IDirect3DRMFrame3 *)std::malloc((uint)scene->nodeCount << 2);
	node = scene->masterNode;
	scene->frameList = pIVar1;
	for (; node != NULL; node = node->next) {
		Lws_CreateFrames(scene,node,parent,(ushort *)&local_4);
		Lws_LoadNodes(scene,node);
	}
	Lws_SetTime(scene,0.0);
	return;
}



Lws_Info * __cdecl lego::res::Lws_Clone(Lws_Info *scene,IDirect3DRMFrame3 *parent)
{
	Lws_Node *pLVar1;
	Lws_Info *scene_00;
	IDirect3DRMFrame3 *pIVar2;
	uint uVar3;
	Mesh *mesh;
	int iVar4;
	Lws_Info *pLVar5;
	undefined4 unaff_EBP;
	Lws_Info *pLVar6;
	Lws_Info *pLVar7;
	IDirect3DRMFrame3Vtbl *pIVar8;
	int *piVar9;
	int local_50 [2];
	undefined4 local_48;
	undefined auStack68 [40];
	int *piStack28;
	code **ppcStack16;
	undefined auStack4 [4];
	
	scene_00 = (Lws_Info *)std::malloc(0x38);
	local_48 = 0;
	pLVar5 = scene;
	if (scene->clonedFrom != NULL) {
		pLVar5 = scene->clonedFrom;
	}
	pLVar6 = scene_00;
	for (iVar4 = 0xe; iVar4 != 0; iVar4 += -1) {
		*(undefined4 *)pLVar6 = 0;
		pLVar6 = (Lws_Info *)&pLVar6->fps;
	}
	pLVar6 = pLVar5;
	pLVar7 = scene_00;
	for (iVar4 = 0xe; iVar4 != 0; iVar4 += -1) {
		*(undefined4 *)pLVar7 = *(undefined4 *)pLVar6;
		pLVar6 = (Lws_Info *)&pLVar6->fps;
		pLVar7 = (Lws_Info *)&pLVar7->fps;
	}
	scene_00->referenceCount = 1;
	pIVar2 = (IDirect3DRMFrame3 *)std::malloc((uint)scene_00->nodeCount << 2);
	pLVar1 = scene_00->masterNode;
	scene_00->frameList = pIVar2;
	for (; pLVar1 != NULL; pLVar1 = pLVar1->next) {
		Lws_CreateFrames(scene_00,pLVar1,parent,(ushort *)&local_48);
	}
	scene = NULL;
	if (scene_00->nodeCount != 0) {
		do {
			uVar3 = (uint)scene & 0xffff;
			pLVar1 = scene_00->nodeList + uVar3;
			piVar9 = local_50;
			pIVar8 = pLVar5->frameList[uVar3].lpVtbl;
			(**(code **)(pIVar8->QueryInterface + 0x5c))(pIVar8);
			pIVar8 = pLVar5->frameList[uVar3].lpVtbl;
			(**(code **)(pIVar8->QueryInterface + 0x74))(pIVar8,unaff_EBP,&local_48);
			(**(code **)(*piVar9 + 8))(piVar9);
			pIVar8 = scene_00->frameList[uVar3].lpVtbl;
			(**(code **)(pIVar8->QueryInterface + 0x38))(pIVar8,0,&stack0xffffffa8);
			if ((pLVar1->flags & 1) == 0) {
				pIVar8 = pLVar5->frameList[pLVar1->frameIndex].lpVtbl;
				(**(code **)(pIVar8->QueryInterface + 0x80))(pIVar8,auStack68);
				piVar9 = local_50;
				(**(code **)(pIVar8->QueryInterface + 0x80))(pIVar8,piVar9,auStack4);
				(**(code **)*ppcStack16)(ppcStack16,&idl::IID_IDirect3DRMUserVisual,&stack0xffffff9c);
				(**(code **)(*piStack28 + 8))(piStack28);
				mesh = (Mesh *)(**(code **)(*piVar9 + 0x1c))(piVar9);
				(**(code **)(pIVar8->QueryInterface + 8))(pIVar8);
				Mesh_Clone(mesh,(IDirect3DRMFrame3 *)scene_00->frameList[pLVar1->frameIndex].lpVtbl);
			}
			scene = (Lws_Info *)((int)&scene->firstFrame + 1);
		} while ((ushort)scene < scene_00->nodeCount);
	}
	scene_00->clonedFrom = pLVar5;
	pLVar5->referenceCount = pLVar5->referenceCount + 1;
	Lws_SetTime(scene_00,0.0);
	return scene_00;
}



void __cdecl lego::res::Lws_SetTime(Lws_Info *scene,float time)
{
	Lws_Node *node;
	float fVar1;
	Lws_Info *scene_00;
	Lws_Info *pLVar2;
	ushort uVar3;
	float10 fVar4;
	
	scene_00 = scene;
	scene->lastTime = scene->time;
	if ((scene->flags & 1) == 0) {
		pLVar2 = (Lws_Info *)(uint)scene->lastFrame;
		fVar1 = (float)(int)pLVar2;
		if ((ushort)((ushort)(time < fVar1) << 8 | (ushort)(time == fVar1) << 0xe) == 0) {
			scene->time = fVar1;
			scene = pLVar2;
		}
		else {
			scene->time = time;
			scene = pLVar2;
		}
	}
	else {
		fVar4 = std::fmod((float10)time,(float10)(uint)scene->lastFrame);
		scene_00->time = (float)fVar4;
	}
	uVar3 = 0;
	if (scene_00->nodeCount != 0) {
		do {
			node = scene_00->nodeList + uVar3;
			if (1 < scene_00->nodeList[uVar3].keyCount) {
				fVar4 = Lws_FindPrevKey(node,scene_00->time,(ushort *)&scene);
				Lws_InterpolateKeys(scene_00,node,(ushort)scene,(float)fVar4);
			}
			if (1 < node->dissolveCount) {
				fVar4 = Lws_FindPrevDissolve(node,scene_00->time,(ushort *)&scene);
				Lws_InterpolateDissolve(scene_00,node,(ushort)scene,(float)fVar4);
			}
			Lws_AnimateTextures(scene_00,node);
			Lws_HandleTrigger(scene_00,node);
			uVar3 += 1;
		} while (uVar3 < scene_00->nodeCount);
	}
	return;
}



float10 __cdecl lego::res::Lws_FindPrevKey(Lws_Node *node,float time,ushort *prev)
{
	float fVar1;
	uint uVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	float10 fVar6;
	
	uVar2 = 0;
	uVar5 = (uint)node->keyCount;
	while( true ) {
		uVar4 = uVar2;
		uVar3 = (uVar5 + uVar4) / 2;
		uVar2 = (uint)node->keyList[uVar3].frame;
		if ((ushort)uVar3 == (ushort)uVar4) break;
		fVar1 = (float)uVar2;
		uVar2 = uVar3;
		if ((ushort)((ushort)(fVar1 < time) << 8 | (ushort)(fVar1 == time) << 0xe) == 0) {
			uVar2 = uVar4;
			uVar5 = uVar3;
		}
	}
	fVar6 = (float10)uVar2;
	*prev = (ushort)uVar3;
	return ((float10)time - fVar6) / ((float10)(uint)node->keyList[uVar3 + 1].frame - fVar6);
}



void __cdecl lego::res::Lws_AnimateTextures(Lws_Info *scene,Lws_Node *node)
{
	Mesh *mesh;
	int **ppiVar1;
	IDirect3DRMFrame3Vtbl *pIVar2;
	int *piVar3;
	int *piStack20;
	code **ppcStack16;
	int local_4;
	
	if ((node->flags & 1) == 0) {
		ppcStack16 = NULL;
		pIVar2 = scene->frameList[node->frameIndex].lpVtbl;
		piStack20 = &local_4;
		(**(code **)(pIVar2->QueryInterface + 0x80))(pIVar2);
		piVar3 = &local_4;
		(**(code **)(pIVar2->QueryInterface + 0x80))(pIVar2,&ppcStack16);
		ppiVar1 = &piStack20;
		(**(code **)*ppcStack16)(ppcStack16,&idl::IID_IDirect3DRMUserVisual);
		(**(code **)(*piVar3 + 8))(piVar3);
		mesh = (Mesh *)(**(code **)(pIVar2->QueryInterface + 0x1c))(pIVar2);
		(*(code *)(*ppiVar1)[2])(ppiVar1);
		Mesh_SetTextureTime2(mesh,scene->time);
	}
	return;
}



void __cdecl lego::res::Lws_HandleTrigger(Lws_Info *scene,Lws_Node *node)
{
	ushort *puVar1;
	IDirect3DRMFrame3Vtbl *frame;
	Lws_Node *pLVar2;
	BOOL BVar3;
	uint uVar4;
	uint loop;
	Lws_SoundTrigger *pLVar5;
	uint uVar6;
	
	pLVar2 = node;
	if ((node->flags & 2) != 0) {
		puVar1 = &node->frameIndex;
		node = NULL;
		frame = scene->frameList[*puVar1].lpVtbl;
		pLVar5 = scene->triggerList + pLVar2->triggerIndex;
		if (pLVar5->count != 0) {
			do {
				uVar6 = (uint)node & 0xffff;
				loop = (uint)(pLVar5->frameStartList[uVar6] != pLVar5->frameEndList[uVar6]);
				BVar3 = Lws_KeyPassed(scene,(uint)pLVar5->frameStartList[uVar6]);
				if ((BVar3 != 0) && (BVar3 = (*globs::lwsGlobs.SoundEnabledFunc)(), BVar3 != 0)) {
					uVar4 = (*globs::lwsGlobs.PlaySample3DFunc)
														((IDirect3DRMFrame3 *)frame,pLVar5->sfxID,loop,1,NULL);
					pLVar5->loopUID[uVar6] = uVar4;
				}
				if ((loop != 0) &&
					 (BVar3 = Lws_KeyPassed(scene,(uint)pLVar5->frameEndList[uVar6]), BVar3 != 0)) {
					snd::Sound3D_StopSound(pLVar5->loopUID[uVar6]);
				}
				node = (Lws_Node *)((int)&node->name + 1);
			} while ((ushort)node < pLVar5->count);
		}
	}
	return;
}



BOOL __cdecl lego::res::Lws_KeyPassed(Lws_Info *scene,uint key)
{
	Lws_Info *pLVar1;
	Lws_Info *pLVar2;
	float fVar3;
	Lws_Info *pLVar4;
	uint uVar5;
	
	pLVar1 = (Lws_Info *)scene->lastTime;
	pLVar2 = (Lws_Info *)scene->time;
	fVar3 = (float)(ulonglong)key;
	uVar5 = Lws_GetFrameCount(scene);
	pLVar4 = pLVar2;
	if ((ushort)((ushort)((float)pLVar1 < (float)pLVar2) << 8 |
							(ushort)((float)pLVar1 == (float)pLVar2) << 0xe) == 0) {
		pLVar4 = pLVar1;
	}
	scene = pLVar2;
	if ((float)pLVar1 < (float)pLVar2) {
		scene = pLVar1;
	}
	if (0.5 <= ((float)pLVar4 - (float)scene) / (float)(ulonglong)uVar5) {
		if ((fVar3 >= (float)pLVar4) ||
			 ((ushort)((ushort)(fVar3 < (float)scene) << 8 | (ushort)(fVar3 == (float)scene) << 0xe) != 0)
			 ) {
			return TRUE;
		}
	}
	else {
		if (((ushort)((ushort)(fVar3 < (float)pLVar4) << 8 | (ushort)(fVar3 == (float)pLVar4) << 0xe) !=
				 0) && ((float)scene <= fVar3)) {
			return TRUE;
		}
	}
	return 0;
}



float10 __cdecl lego::res::Lws_FindPrevDissolve(Lws_Node *node,float time,ushort *prev)
{
	ushort uVar1;
	ushort uVar2;
	ushort uVar3;
	
	uVar1 = node->dissolveCount;
	uVar3 = 1;
	if (uVar1 < 2) {
		*prev = uVar1 - 1;
		return (float10)0.0;
	}
	do {
		uVar2 = node->dissolveFrame[uVar3];
		if (time <= (float)(uint)uVar2) {
			*prev = uVar3 - 1;
			return ((float10)time - (float10)(uint)node->dissolveFrame[(ushort)(uVar3 - 1)]) /
						 ((float10)(uint)uVar2 - (float10)(uint)node->dissolveFrame[(ushort)(uVar3 - 1)]);
		}
		uVar3 += 1;
	} while (uVar3 < uVar1);
	*prev = uVar1 - 1;
	return (float10)0.0;
}



void __cdecl
lego::res::Lws_InterpolateDissolve(Lws_Info *scene,Lws_Node *node,ushort prev,float delta)
{
	float level;
	uint uVar1;
	
	uVar1 = (uint)prev;
	level = node->dissolveLevel[uVar1];
	if (uVar1 == node->dissolveCount - 1) {
		Lws_SetDissolveLevel(scene,node,level);
		return;
	}
	Lws_SetDissolveLevel(scene,node,(node->dissolveLevel[uVar1 + 1] - level) * delta + level);
	return;
}



void __cdecl lego::res::Lws_SetDissolveLevel(Lws_Info *scene,Lws_Node *node,float level)
{
	Mesh *mesh;
	D3DRMGroupIndex DVar1;
	D3DRMGroupIndex groupID;
	code **unaff_EDI;
	IDirect3DRMFrame3Vtbl *pIVar2;
	int *value;
	IDirect3DRMFrame3Vtbl *pIVar3;
	undefined4 uStack20;
	undefined local_4 [4];
	
	pIVar2 = scene->frameList[node->frameIndex].lpVtbl;
	uStack20 = 0;
	pIVar3 = pIVar2;
	(**(code **)(pIVar2->QueryInterface + 0x80))(pIVar2,local_4);
	value = (int *)&stack0xfffffff0;
	(**(code **)(pIVar2->QueryInterface + 0x80))(pIVar2,value,local_4);
	(**(code **)*unaff_EDI)(unaff_EDI,&idl::IID_IDirect3DRMUserVisual,&uStack20);
	(**(code **)(pIVar3->QueryInterface + 8))(pIVar3);
	mesh = (Mesh *)(**(code **)(*value + 0x1c))(value);
	(**(code **)(pIVar2->QueryInterface + 8))(pIVar2);
	DVar1 = Mesh_GetGroupCount(mesh);
	groupID = D3DRMGROUP_0;
	if (DVar1 != D3DRMGROUP_0) {
		do {
			Mesh_SetGroupMaterialValues(mesh,groupID,(float)value,MATERIAL_ALPHA);
			groupID += 1;
		} while (groupID < DVar1);
	}
	return;
}



void __cdecl lego::res::Lws_InterpolateKeys(Lws_Info *scene,Lws_Node *node,ushort key,float delta)
{
	int iVar1;
	Lws_KeyInfo *pLVar2;
	Lws_KeyInfo *pLVar3;
	Vector3F local_24;
	Vector3F local_18;
	Vector3F local_c;
	
	pLVar3 = node->keyList;
	iVar1 = key + 1;
	pLVar2 = pLVar3 + key;
	local_18.x = (pLVar2->position).x + (pLVar3[iVar1].position.x - (pLVar2->position).x) * delta;
	local_18.y = (pLVar3[iVar1].position.y - (pLVar2->position).y) * delta + (pLVar2->position).y;
	local_18.z = (pLVar3[iVar1].position.z - (pLVar2->position).z) * delta + (pLVar2->position).z;
	local_24.x = (pLVar2->scale).x + (pLVar2[1].scale.x - (pLVar2->scale).x) * delta;
	local_24.y = (pLVar2[1].scale.y - (pLVar2->scale).y) * delta + (pLVar2->scale).y;
	local_24.z = (pLVar2[1].scale.z - (pLVar2->scale).z) * delta + (pLVar2->scale).z;
	local_c.x = (pLVar2->hpb).x + (pLVar2[1].hpb.x - (pLVar2->hpb).x) * delta;
	local_c.y = (pLVar2[1].hpb.y - (pLVar2->hpb).y) * delta + (pLVar2->hpb).y;
	local_c.z = (pLVar2[1].hpb.z - (pLVar2->hpb).z) * delta + (pLVar2->hpb).z;
	Lws_SetupNodeTransform(scene,node,&local_18,&local_c,&local_24);
	return;
}



void __cdecl
lego::res::Lws_SetupNodeTransform
					(Lws_Info *scene,Lws_Node *node,Vector3F *pos,Vector3F *hpb,Vector3F *scale)
{
	float fVar1;
	Lws_Node *pLVar2;
	float fVar3;
	IDirect3DRMFrame3Vtbl *pIVar4;
	float fVar5;
	float fVar6;
	float fVar7;
	float fVar8;
	float fVar9;
	float10 fVar10;
	float10 fVar11;
	float10 fVar12;
	float10 fVar13;
	float10 fVar14;
	float10 fVar15;
	undefined4 unaff_retaddr;
	float local_48;
	float local_44;
	float local_40;
	float local_3c;
	float local_38;
	undefined4 local_34;
	float local_30;
	float local_2c;
	float local_28;
	undefined4 local_24;
	float local_20;
	float local_1c;
	float local_18;
	undefined4 local_14;
	float local_10;
	int *local_c;
	float local_8;
	undefined4 local_4;
	
	pIVar4 = scene->frameList[node->frameIndex].lpVtbl;
	if ((node->flags & 4) == 0) {
		fVar10 = (float10)fsin((float10)hpb->z);
		fVar11 = (float10)fsin((float10)hpb->y);
		fVar12 = (float10)fcos((float10)hpb->z);
		fVar13 = (float10)fsin((float10)hpb->x);
		fVar5 = (node->pivotVector).x;
		fVar14 = (float10)fcos((float10)hpb->x);
		fVar15 = (float10)fcos((float10)hpb->y);
		local_3c = scale->x * (float)fVar10;
		fVar8 = scale->x * (float)fVar12;
		fVar1 = (float)fVar13;
		pLVar2 = (Lws_Node *)(float)fVar14;
		local_44 = scale->y * (float)fVar12;
		fVar3 = (float)(fVar11 * (float10)local_3c);
		local_2c = (float)fVar15;
		local_3c = local_2c * local_3c;
		local_48 = (float)fVar11 * local_44;
		fVar6 = (node->pivotVector).y;
		fVar7 = (node->pivotVector).z;
		fVar9 = -(scale->y * (float)fVar10);
		local_40 = (float)((float10)fVar1 * (float10)fVar3 + fVar14 * (float10)fVar8);
		local_38 = (float)((float10)(float)pLVar2 * (float10)fVar3 + -(fVar13 * (float10)fVar8));
		local_18 = scale->z * local_2c;
		local_1c = -(scale->z * (float)fVar11);
		local_20 = fVar1 * local_18;
		local_18 = (float)pLVar2 * local_18;
		local_2c = local_2c * local_44;
		local_30 = fVar1 * local_48 + (float)pLVar2 * fVar9;
		local_28 = -(fVar1 * fVar9) + (float)pLVar2 * local_48;
		local_34 = 0;
		local_24 = 0;
		local_10 = fVar6 * local_30 + fVar5 * local_40 + fVar7 * local_20 + pos->x;
		local_c = (int *)(fVar6 * local_2c + fVar5 * local_3c + fVar7 * local_1c + pos->y);
		local_8 = fVar6 * local_28 + fVar5 * local_38 + fVar7 * local_18 + pos->z;
		local_14 = 0;
		local_4 = 0x3f800000;
		node = pLVar2;
	}
	else {
		(**(code **)(pIVar4->QueryInterface + 0x5c))(pIVar4,&node);
		(**(code **)(pIVar4->QueryInterface + 0x74))(pIVar4,unaff_retaddr,&local_48);
		(**(code **)(*local_c + 8))(local_c);
		node = NULL;
		local_40 = local_40 * scale->x;
		local_2c = scale->y * local_2c;
		local_18 = scale->z * local_18;
		local_10 = pos->x;
		local_c = (int *)pos->y;
		local_8 = pos->z;
	}
	(**(code **)(pIVar4->QueryInterface + 0x38))(pIVar4,0,&local_40);
	return;
}



Mesh * __cdecl
lego::res::Lws_LoadMesh(char *baseDir,char *fname,IDirect3DRMFrame3 *frame,BOOL noTextures)
{
	char cVar1;
	Mesh *pMVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	char *pcVar7;
	undefined4 *puVar8;
	char filenameBuffer [260];
	
	if (baseDir == NULL) {
		uVar3 = 0xffffffff;
		pcVar6 = fname;
		do {
			pcVar7 = pcVar6;
			if (uVar3 == 0) break;
			uVar3 -= 1;
			pcVar7 = pcVar6 + 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar7;
		} while (cVar1 != '\0');
		uVar3 = ~uVar3;
		puVar5 = (undefined4 *)(pcVar7 + -uVar3);
		puVar8 = (undefined4 *)filenameBuffer;
		for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
			*puVar8 = *puVar5;
			puVar5 = puVar5 + 1;
			puVar8 = puVar8 + 1;
		}
		for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
			*(undefined *)puVar8 = *(undefined *)puVar5;
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			puVar8 = (undefined4 *)((int)puVar8 + 1);
		}
	}
	else {
		std::sprintf(filenameBuffer,"%s%s",baseDir,fname);
	}
	pMVar2 = Lws_SearchMeshPathList
										 ((Lws_MeshPath *)&globs::lwsGlobs,globs::lwsGlobs.meshPathCount,filenameBuffer)
	;
	if (pMVar2 != NULL) {
		Mesh_Clone(pMVar2,frame);
		return pMVar2;
	}
	pMVar2 = Mesh_Load(filenameBuffer,frame,noTextures);
	if (pMVar2 != NULL) {
		Lws_AddMeshPathEntry
							((Lws_MeshPath *)&globs::lwsGlobs,&globs::lwsGlobs.meshPathCount,filenameBuffer,pMVar2
							);
		return pMVar2;
	}
	if (globs::lwsGlobs.sharedDir != NULL) {
		std::sprintf(filenameBuffer,"%s%s",globs::lwsGlobs.sharedDir,fname);
		pMVar2 = Lws_SearchMeshPathList
											 (globs::lwsGlobs.meshPathListShared,globs::lwsGlobs.meshPathCountShared,fname
											 );
		if (pMVar2 != NULL) {
			Mesh_Clone(pMVar2,frame);
			return pMVar2;
		}
		pMVar2 = Mesh_Load(filenameBuffer,frame,noTextures);
		if (pMVar2 != NULL) {
			Lws_AddMeshPathEntry
								(globs::lwsGlobs.meshPathListShared,&globs::lwsGlobs.meshPathCountShared,fname,
								 pMVar2);
			return pMVar2;
		}
	}
	return NULL;
}



Mesh * __cdecl lego::res::Lws_SearchMeshPathList(Lws_MeshPath *list,uint count,char *path)
{
	uint uVar1;
	int iVar2;
	uint uVar3;
	
	uVar3 = 0;
	if (count == 0) {
		return NULL;
	}
	uVar1 = 0;
	do {
		iVar2 = std::_stricmp(path,list[uVar1].path);
		if (iVar2 == 0) {
			return list[uVar3 & 0xffff].mesh;
		}
		uVar3 += 1;
		uVar1 = uVar3 & 0xffff;
	} while (uVar1 < count);
	return NULL;
}



void __cdecl
lego::res::Lws_AddMeshPathEntry(Lws_MeshPath *ref_list,uint *ref_count,char *path,Mesh *mesh)
{
	char *pcVar1;
	
	pcVar1 = std::_strdup(path);
	ref_list[*ref_count].path = pcVar1;
	ref_list[*ref_count].mesh = mesh;
	*ref_count = *ref_count + 1;
	return;
}



// WARNING: Type propagation algorithm not settling

void __cdecl
lego::res::Lws_CreateFrames
					(Lws_Info *scene,Lws_Node *node,IDirect3DRMFrame3 *parent,ushort *ref_frameCount)
{
	byte *pbVar1;
	Lws_Node *node_00;
	uint uVar2;
	int iVar3;
	IDirect3DRMFrame3 *unaff_EBP;
	byte *pbVar4;
	undefined4 *puVar5;
	IDirect3DRMFrame3 local_444;
	undefined4 auStack1088 [5];
	undefined4 uStack1068;
	undefined4 uStack1048;
	undefined4 uStack1040;
	undefined4 uStack1036;
	undefined4 uStack1032;
	undefined4 uStack1028;
	byte abStack1024 [1024];
	
	(*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
						(globs::mainGlobs.lpD3DRM,parent,(IDirect3DRMFrame3 **)&local_444);
	if ((node->flags & 4) != 0) {
		puVar5 = auStack1088;
		for (iVar3 = 0x10; iVar3 != 0; iVar3 += -1) {
			*puVar5 = 0;
			puVar5 = puVar5 + 1;
		}
		uStack1032 = 0;
		uStack1036 = 0;
		uStack1040 = 0;
		uStack1028 = 0x3f800000;
		uStack1048 = 0x3f800000;
		uStack1068 = 0x3f800000;
		auStack1088[0] = 0x3f800000;
		(**(code **)(*(int *)local_444 + 0x38))(local_444,0,auStack1088);
	}
	scene->frameList[*ref_frameCount].lpVtbl = local_444;
	node->frameIndex = *ref_frameCount;
	*ref_frameCount = *ref_frameCount + 1;
	std::sprintf((char *)abStack1024,"%s_%0.2i",node->name,(uint)node->reference);
	pbVar4 = abStack1024;
	while (abStack1024[0] != 0) {
										// int std::isgraph(int c)
										//  (or close enough to this?)
		if (std::globals::_pcharwidth < 2) {
										// C1_ALPHA | C1_BLANK | C1_PUNCT | C1_DIGIT | C1_LOWER | C1_UPPER (0x100 | 0x40
										// | 0x10 | 0x4 | 0x2 | 0x1)
			uVar2 = std::globals::_pctype[*pbVar4] & 0x157;
		}
		else {
			uVar2 = std::_isctype((uint)*pbVar4,0x157);
		}
		if (uVar2 == 0) {
			*pbVar4 = 0x5f;
		}
		pbVar1 = pbVar4 + 1;
		pbVar4 = pbVar4 + 1;
		abStack1024[0] = *pbVar1;
	}
	(**(code **)(*(int *)local_444 + 0x20))(local_444,abStack1024);
	for (node_00 = node->childList; node_00 != NULL; node_00 = node_00->next) {
		Lws_CreateFrames(scene,node_00,unaff_EBP,ref_frameCount);
	}
	return;
}



void __cdecl lego::res::Lws_LoadNodes(Lws_Info *scene,Lws_Node *node)
{
	IDirect3DRMFrame3Vtbl *frame;
	Lws_Node *node_00;
	Mesh *pMVar1;
	
	frame = scene->frameList[node->frameIndex].lpVtbl;
	if (node->keyCount == 1) {
		Lws_SetAbsoluteKey(scene,node,0);
	}
	if (((node->flags & 1) == 0) &&
		 (pMVar1 = Lws_LoadMesh(scene->filePath,node->name,(IDirect3DRMFrame3 *)frame,0), pMVar1 != NULL
		 )) {
		if ((node->flags & 4) != 0) {
			pMVar1->flags = pMVar1->flags | 0x1000000;
		}
		if ((node->dissolveLevel != NULL) && (node->dissolveCount == 0)) {
			Lws_SetDissolveLevel(scene,node,*node->dissolveLevel);
			node->dissolveLevel = NULL;
		}
	}
	for (node_00 = node->childList; node_00 != NULL; node_00 = node_00->next) {
		Lws_LoadNodes(scene,node_00);
	}
	return;
}



void __cdecl lego::res::Lws_SetAbsoluteKey(Lws_Info *scene,Lws_Node *node,ushort key)
{
	Lws_KeyInfo *pos;
	
	pos = node->keyList + key;
	Lws_SetupNodeTransform(scene,node,(Vector3F *)pos,&pos->hpb,&pos->scale);
	return;
}



void __cdecl lego::res::Lws_Free(Lws_Info *scene)
{
	Lws_Info *pLVar1;
	uint uVar2;
	ushort uVar3;
	
	do {
		pLVar1 = scene->clonedFrom;
		uVar2 = scene->referenceCount - 1;
		scene->referenceCount = uVar2;
		if (uVar2 == 0) {
			uVar3 = 0;
			if (scene->nodeCount != 0) {
				do {
					Lws_FreeNode(scene,scene->nodeList + uVar3);
					uVar3 += 1;
				} while (uVar3 < scene->nodeCount);
			}
			if (scene->clonedFrom == NULL) {
				std::free(scene->nodeList);
				std::free(scene->filePath);
				if (scene->triggerCount != 0) {
					std::free(scene->triggerList);
				}
			}
			std::free(scene->frameList);
			std::free(scene);
		}
		scene = pLVar1;
	} while (pLVar1 != NULL);
	return;
}



void __cdecl lego::res::Lws_FreeNode(Lws_Info *scene,Lws_Node *node)
{
	Mesh *mesh;
	code **unaff_EDI;
	IDirect3DRMFrame3Vtbl *pIVar1;
	int *piVar2;
	IDirect3DRMFrame3Vtbl *pIVar3;
	undefined local_4 [4];
	
	if ((node->flags & 1) == 0) {
		pIVar1 = scene->frameList[node->frameIndex].lpVtbl;
		pIVar3 = pIVar1;
		(**(code **)(pIVar1->QueryInterface + 0x80))(pIVar1,local_4);
		piVar2 = (int *)&stack0xfffffff0;
		(**(code **)(pIVar1->QueryInterface + 0x80))(pIVar1,piVar2,local_4);
		(**(code **)*unaff_EDI)(unaff_EDI,&idl::IID_IDirect3DRMUserVisual,&stack0xffffffec);
		(**(code **)(pIVar3->QueryInterface + 8))(pIVar3);
		mesh = (Mesh *)(**(code **)(*piVar2 + 0x1c))(piVar2);
		(**(code **)(pIVar1->QueryInterface + 8))(pIVar1);
		Mesh_Remove(mesh,(IDirect3DRMFrame3 *)scene->frameList[node->frameIndex].lpVtbl);
	}
	if ((scene->clonedFrom == NULL) && (scene->referenceCount == 0)) {
		std::free(node->name);
		std::free(node->keyList);
		if (node->dissolveCount != 0) {
			std::free(node->dissolveLevel);
			std::free(node->dissolveFrame);
		}
	}
	return;
}



BOOL __cdecl lego::snd::Sound_Initialise(BOOL nosound)
{
	BOOL BVar1;
	
	globs::soundGlobs.initialised = ZEXT14(nosound == 0);
	globs::soundGlobs.loopCDTrack = -1;
	if (nosound != 0) {
		globs::soundGlobs.loopCDTrack = -1;
		return 1;
	}
	BVar1 = Sound3D_Initialise(globs::mainGlobs.hWnd);
	return (uint)(BVar1 != 0);
}



BOOL __cdecl lego::snd::Sound_IsInitialised(void)
{
	if ((globs::soundGlobs.initialised != 0) && (globs::sound3DGlobs.intialised != 0)) {
		return TRUE;
	}
	return 0;
}



BOOL __cdecl
lego::snd::Sound_PlayCDTrack(uint track,SoundMode mode,SoundCDStopCallback stopCallback)
{
	BOOL BVar1;
	
	BVar1 = globs::soundGlobs.initialised;
	if (globs::soundGlobs.initialised != 0) {
		if (mode == SOUND_LOOP) {
			globs::soundGlobs.loopCDTrack = TRUE;
		}
		globs::soundGlobs.currTrack = track;
		globs::soundGlobs.CDStopCallback = stopCallback;
		BVar1 = Play_CDTrack(track);
	}
	return BVar1;
}



BOOL __cdecl lego::snd::Sound_StopCD(void)
{
	BOOL BVar1;
	
	if (globs::soundGlobs.initialised != 0) {
		BVar1 = Stop_CDTrack();
		return BVar1;
	}
	return 0;
}



void __cdecl lego::snd::Sound_Update(BOOL cdtrack)
{
	uint uVar1;
	DWORD DVar2;
	BOOL BVar3;
	
	uVar1 = globs::soundGlobs.s_Update_lastUpdate;
	if ((((globs::soundGlobs.initialised != 0) &&
			 (DVar2 = timeGetTime(), uVar1 = globs::soundGlobs.s_Update_lastUpdate,
			 globs::soundGlobs.s_Update_lastUpdate + 4000 < DVar2)) && (uVar1 = DVar2, cdtrack != 0)) &&
		 (BVar3 = Status_CDTrack(globs::soundGlobs.currTrack), BVar3 == 0)) {
		if (globs::soundGlobs.loopCDTrack != 0) {
			Restart_CDTrack(globs::soundGlobs.currTrack);
		}
		if (globs::soundGlobs.CDStopCallback != NULL) {
			(*globs::soundGlobs.CDStopCallback)();
		}
	}
	globs::soundGlobs.s_Update_lastUpdate = uVar1;
	return;
}



// WARNING: Could not reconcile some variable overlaps
// This function will open a wave input file and prepare it for reading,
// so the data can be easily
// read with WaveReadFile. Returns 0 if successful, the error code if not.
//     pszFileName - Input filename to load.
//     phmmioIn    - Pointer to handle which will be used
//         for further mmio routines.
//     ppwfxInfo   - Ptr to ptr to WaveFormatEx structure
//         with all info about the file. 

int __cdecl
lego::snd::WaveOpenFile
					(void *fileData,uint fileSize,HMMIO *out_phmmioIn,WAVEFORMATEX **out_ppwfxInfo,
					MMCKINFO *out_pckInRIFF)
{
	HMMIO hmmio;
	LONG LVar1;
	WAVEFORMATEX *pWVar2;
	uint uVar3;
	int iVar4;
	MMRESULT MVar5;
	_MMIOINFO *p_Var6;
	undefined4 local_6c;
	DWORD local_68;
	DWORD local_64;
	undefined4 local_60;
	_MMCKINFO local_5c;
	_MMIOINFO local_48;
	
	*out_ppwfxInfo = NULL;
	p_Var6 = &local_48;
	for (iVar4 = 0x12; iVar4 != 0; iVar4 += -1) {
		p_Var6->dwFlags = 0;
		p_Var6 = (_MMIOINFO *)&p_Var6->fccIOProc;
	}
										// "MEM "
	local_48.fccIOProc = 0x204d454d;
	local_48.pchBuffer = (HPSTR)fileData;
	local_48.cchBuffer = fileSize;
	hmmio = mmioOpenA(NULL,(LPMMIOINFO)&local_48,0x10000);
	if (hmmio == NULL) {
		MVar5 = 0xe100;
	}
	else {
		MVar5 = mmioDescend(hmmio,(LPMMCKINFO)out_pckInRIFF,NULL,0);
		if (MVar5 == 0) {
			if ((out_pckInRIFF->ckid == 0x46464952) && (out_pckInRIFF->fccType == 0x45564157)) {
				local_5c.ckid = 0x20746d66;
				MVar5 = mmioDescend(hmmio,(LPMMCKINFO)&local_5c,out_pckInRIFF,0x10);
				if (MVar5 != 0) goto LAB_004890e9;
				if (0xf < local_5c.cksize) {
					LVar1 = mmioRead(hmmio,(HPSTR)&local_6c,0x10);
					if (LVar1 != 0x10) {
						MVar5 = 0xe102;
						goto LAB_004890e9;
					}
					if ((short)local_6c == 1) {
						fileData = NULL;
					}
					else {
						LVar1 = mmioRead(hmmio,(HPSTR)&fileData,2);
						if (LVar1 != 2) {
							MVar5 = 0xe102;
							goto LAB_004890e9;
						}
					}
					pWVar2 = (WAVEFORMATEX *)GlobalAlloc(0,((uint)fileData & 0xffff) + 0x12);
					*out_ppwfxInfo = pWVar2;
					if (pWVar2 == NULL) {
						MVar5 = 0xe000;
						goto LAB_004890e9;
					}
					*(undefined4 *)pWVar2 = local_6c;
					pWVar2->nSamplesPerSec = local_68;
					pWVar2->nAvgBytesPerSec = local_64;
					*(undefined4 *)&pWVar2->nBlockAlign = local_60;
					(*out_ppwfxInfo)->cbSize = (WORD)fileData;
					if (((WORD)fileData == 0) ||
						 (uVar3 = mmioRead(hmmio,(HPSTR)(*out_ppwfxInfo + 1),(uint)fileData & 0xffff),
						 uVar3 == ((uint)fileData & 0xffff))) {
						MVar5 = mmioAscend(hmmio,(LPMMCKINFO)&local_5c,0);
						if (MVar5 == 0) {
							*out_phmmioIn = hmmio;
							return 0;
						}
						goto LAB_004890e9;
					}
				}
			}
			MVar5 = 0xe101;
		}
	}
LAB_004890e9:
	if (*out_ppwfxInfo != NULL) {
		GlobalFree(*out_ppwfxInfo);
		*out_ppwfxInfo = NULL;
	}
	if (hmmio != NULL) {
		mmioClose(hmmio,0);
		hmmio = NULL;
	}
	*out_phmmioIn = hmmio;
	return MVar5;
}



uint __cdecl lego::snd::GetWaveAvgBytesPerSec(char *pszFileName)
{
	HMMIO hmmio;
	MMRESULT MVar1;
	LONG LVar2;
	uint uVar3;
	PCMWAVEFORMAT local_38;
	_MMCKINFO local_28;
	_MMCKINFO local_14;
	
	uVar3 = 0;
	hmmio = mmioOpenA(pszFileName,NULL,0);
	if (hmmio != NULL) {
		MVar1 = mmioDescend(hmmio,(LPMMCKINFO)&local_28,NULL,0);
										// "RIFF", "WAVE"
		if (((MVar1 == 0) && (local_28.ckid == 1179011410)) && (local_28.fccType == 1163280727)) {
										// "fmt "
			local_14.ckid = 544501094;
			MVar1 = mmioDescend(hmmio,(LPMMCKINFO)&local_14,(MMCKINFO *)&local_28,0x10);
			if ((MVar1 == 0) && (0xf < local_14.cksize)) {
				LVar2 = mmioRead(hmmio,(HPSTR)&local_38,0x10);
				if (LVar2 == 0x10) {
					uVar3 = local_38.wf.nAvgBytesPerSec;
				}
			}
		}
		if (hmmio != NULL) {
			mmioClose(hmmio,0);
		}
	}
	return uVar3;
}



// WARNING: Could not reconcile some variable overlaps

int __cdecl
lego::snd::WaveOpenFile2
					(char *pszFileName,HMMIO *out_phmmioIn,WAVEFORMATEX **out_ppwfxInfo,
					MMCKINFO *out_pckInRIFF)
{
	HMMIO hmmio;
	LONG LVar1;
	WAVEFORMATEX *pWVar2;
	uint uVar3;
	MMRESULT MVar4;
	undefined4 local_24;
	DWORD local_20;
	DWORD local_1c;
	undefined4 local_18;
	_MMCKINFO local_14;
	
	*out_ppwfxInfo = NULL;
	hmmio = mmioOpenA(pszFileName,NULL,0x10000);
	if (hmmio == NULL) {
		MVar4 = 0xe100;
	}
	else {
		MVar4 = mmioDescend(hmmio,(LPMMCKINFO)out_pckInRIFF,NULL,0);
		if (MVar4 == 0) {
			if ((out_pckInRIFF->ckid == 1179011410) && (out_pckInRIFF->fccType == 1163280727)) {
				local_14.ckid = 544501094;
				MVar4 = mmioDescend(hmmio,(LPMMCKINFO)&local_14,out_pckInRIFF,0x10);
				if (MVar4 != 0) goto LAB_00489343;
				if (0xf < local_14.cksize) {
					LVar1 = mmioRead(hmmio,(HPSTR)&local_24,0x10);
					if (LVar1 != 0x10) {
						MVar4 = 0xe102;
						goto LAB_00489343;
					}
					if ((short)local_24 == 1) {
						pszFileName = NULL;
					}
					else {
						LVar1 = mmioRead(hmmio,(HPSTR)&pszFileName,2);
						if (LVar1 != 2) {
							MVar4 = 0xe102;
							goto LAB_00489343;
						}
					}
					pWVar2 = (WAVEFORMATEX *)GlobalAlloc(0,((uint)pszFileName & 0xffff) + 0x12);
					*out_ppwfxInfo = pWVar2;
					if (pWVar2 == NULL) {
						MVar4 = 0xe000;
						goto LAB_00489343;
					}
					*(undefined4 *)pWVar2 = local_24;
					pWVar2->nSamplesPerSec = local_20;
					pWVar2->nAvgBytesPerSec = local_1c;
					*(undefined4 *)&pWVar2->nBlockAlign = local_18;
					(*out_ppwfxInfo)->cbSize = (WORD)pszFileName;
					if (((WORD)pszFileName == 0) ||
						 (uVar3 = mmioRead(hmmio,(HPSTR)(*out_ppwfxInfo + 1),(uint)pszFileName & 0xffff),
						 uVar3 == ((uint)pszFileName & 0xffff))) {
						MVar4 = mmioAscend(hmmio,(LPMMCKINFO)&local_14,0);
						if (MVar4 == 0) {
							*out_phmmioIn = hmmio;
							return 0;
						}
						goto LAB_00489343;
					}
				}
			}
			MVar4 = 0xe101;
		}
	}
LAB_00489343:
	if (*out_ppwfxInfo != NULL) {
		GlobalFree(*out_ppwfxInfo);
		*out_ppwfxInfo = NULL;
	}
	if (hmmio != NULL) {
		mmioClose(hmmio,0);
		hmmio = NULL;
	}
	*out_phmmioIn = hmmio;
	return MVar4;
}



// This routine has to be called before WaveReadFile as it searchs for the chunk to descend into for
// reading, that is, the 'data' chunk.  For simplicity, this used to be in the open routine, but was
// taken out and moved to a separate routine so there was more control on the chunks that are before
// the data chunk, such as 'fact', etc...

int __cdecl lego::snd::WaveStartDataRead(HMMIO *phmmioIn,MMCKINFO *pckIn,MMCKINFO *pckInRIFF)
{
	MMRESULT MVar1;
	
	mmioSeek(*phmmioIn,pckInRIFF->dwDataOffset + 4,0);
	pckIn->ckid = 1635017060;
	MVar1 = mmioDescend(*phmmioIn,(LPMMCKINFO)pckIn,pckInRIFF,0x10);
	return MVar1;
}



// This will read wave data from the wave file.  Makre sure we're descended into
// the data chunk, else this will fail bigtime!
// hmmioIn         - Handle to mmio.
// cbRead          - # of bytes to read.   
// pbDest          - Destination buffer to put bytes.
// cbActualRead- # of bytes actually read.

int __cdecl
lego::snd::WaveReadFile(HMMIO hmmioIn,uint cbRead,byte *pbDest,MMCKINFO *pckIn,uint *cbActualRead)
{
	byte bVar1;
	MMRESULT MVar2;
	uint uVar3;
	byte *pbVar4;
	uint uVar5;
	_MMIOINFO local_48;
	
	MVar2 = mmioGetInfo(hmmioIn,(LPMMIOINFO)&local_48,0);
	uVar3 = (uint)(MVar2 != 0);
	if (uVar3 == 0) {
		uVar3 = pckIn->cksize;
		if (uVar3 < cbRead) {
			cbRead = uVar3;
		}
		uVar5 = 0;
		pckIn->cksize = uVar3 - cbRead;
		pbVar4 = (byte *)local_48.pchEndRead;
		if (cbRead != 0) {
			do {
				if ((byte *)local_48.pchNext == pbVar4) {
					uVar3 = mmioAdvance(hmmioIn,(LPMMIOINFO)&local_48,0);
					if (uVar3 != 0) goto LAB_00489456;
					pbVar4 = (byte *)local_48.pchEndRead;
					if (local_48.pchNext == local_48.pchEndRead) {
						*cbActualRead = 0;
						return 0xe103;
					}
				}
				bVar1 = *local_48.pchNext;
				local_48.pchNext = (HPSTR)((byte *)local_48.pchNext + 1);
				pbDest[uVar5] = bVar1;
				uVar5 += 1;
			} while (uVar5 < cbRead);
		}
		uVar3 = mmioSetInfo(hmmioIn,(LPCMMIOINFO)&local_48,0);
		if (uVar3 == 0) {
			*cbActualRead = cbRead;
			return 0;
		}
	}
LAB_00489456:
	*cbActualRead = 0;
	return uVar3;
}



// This will close the wave file openned with WaveOpenFile.  
// phmmioIn - Pointer to the handle to input MMIO.
// ppwfxSrc - Pointer to pointer to WaveFormatEx structure.
// 
// Returns 0 if successful, non-zero if there was a warning.

int __cdecl lego::snd::WaveCloseReadFile(HMMIO *phmmio,WAVEFORMATEX **ppwfxSrc)
{
	if (*ppwfxSrc != NULL) {
		GlobalFree(*ppwfxSrc);
		*ppwfxSrc = NULL;
	}
	if (*phmmio != NULL) {
		mmioClose(*phmmio,0);
		*phmmio = NULL;
	}
	return 0;
}



BOOL __cdecl lego::snd::Restart_CDTrack(int track)
{
	CHAR local_64 [100];
	
	wsprintfA(local_64,"play cdaudio from %i",track + 1);
	globs::soundGlobs.mciErr = mciSendStringA(local_64,globs::mciReturn,200,NULL);
	if (globs::soundGlobs.mciErr != 0) {
		ReportCDError();
		return 0;
	}
	return TRUE;
}



void __cdecl lego::snd::ReportCDError(void)
{
	mciGetErrorStringA(globs::soundGlobs.mciErr,globs::mciReturn,200);
	return;
}



BOOL __cdecl lego::snd::Status_CDTrack(int track)
{
	int iVar1;
	char buff [100];
	
	std::sprintf(buff,"status cdaudio mode");
	globs::soundGlobs.mciErr = mciSendStringA(buff,globs::mciReturn,200,NULL);
	iVar1 = std::_stricmp(globs::mciReturn,"stopped");
	if (iVar1 != 0) {
		std::sprintf(buff,"status cdaudio current track");
		globs::soundGlobs.mciErr = mciSendStringA(buff,globs::mciReturn,200,NULL);
		iVar1 = std::atoi(globs::mciReturn);
		if (iVar1 <= track + 1) {
			return 1;
		}
	}
	ReportCDError();
	return 0;
}



BOOL __cdecl lego::snd::Play_CDTrack(int track)
{
	globs::soundGlobs.mciErr = mciSendStringA("open cdaudio",globs::mciReturn,200,NULL);
	if (globs::soundGlobs.mciErr == 0) {
		globs::soundGlobs.mciErr =
				 mciSendStringA("set cdaudio time format tmsf",globs::mciReturn,200,NULL);
		if (globs::soundGlobs.mciErr == 0) {
			Restart_CDTrack(track);
			if (globs::soundGlobs.mciErr == 0) {
				return 1;
			}
		}
	}
	ReportCDError();
	return 0;
}



BOOL __cdecl lego::snd::Stop_CDTrack(void)
{
	globs::soundGlobs.mciErr = mciSendStringA("stop cdaudio",globs::mciReturn,200,NULL);
	if (globs::soundGlobs.mciErr == 0) {
		globs::soundGlobs.mciErr = mciSendStringA("close cdaudio",globs::mciReturn,200,NULL);
		if (globs::soundGlobs.mciErr == 0) {
			return TRUE;
		}
	}
	ReportCDError();
	return 0;
}



void __cdecl lego::file::Mem_Initialise(void)
{
	Mem_HandleFlags *pMVar1;
	
	pMVar1 = &globs::memGlobs.handleList[0].flags;
	do {
		pMVar1[-1] = MEMORY_HANDLE_FLAG_NONE;
		*pMVar1 = MEMORY_HANDLE_FLAG_NONE;
		pMVar1 = pMVar1 + 2;
	} while (pMVar1 < &DAT_005498a4);
	return;
}



uint __cdecl lego::file::Mem_AllocHandle(uint size)
{
	Mem_HandleFlags *pMVar1;
	void *pvVar2;
	uint uVar3;
	
	uVar3 = 0;
	pMVar1 = &globs::memGlobs.handleList[0].flags;
	do {
		if ((*(byte *)pMVar1 & MEMORY_HANDLE_FLAG_USED) == 0) {
			pvVar2 = std::malloc(size);
			globs::memGlobs.handleList[uVar3].addr = pvVar2;
			globs::memGlobs.handleList[uVar3].flags = globs::memGlobs.handleList[uVar3].flags | 1;
			return uVar3;
		}
		pMVar1 = pMVar1 + 2;
		uVar3 += 1;
	} while (pMVar1 < &DAT_005498a4);
	return 0xffffffff;
}



void __cdecl lego::file::Mem_FreeHandle(uint handle)
{
	if ((handle < 2000) && ((*(byte *)&globs::memGlobs.handleList[handle].flags & 1) != 0)) {
		std::free(globs::memGlobs.handleList[handle].addr);
		globs::memGlobs.handleList[handle].addr = NULL;
		globs::memGlobs.handleList[handle].flags = MEMORY_HANDLE_FLAG_NONE;
	}
	return;
}



void * __cdecl lego::file::Mem_AddressHandle(uint handle)
{
	if ((handle < 2000) && ((*(byte *)&globs::memGlobs.handleList[handle].flags & 1) != 0)) {
		return globs::memGlobs.handleList[handle].addr;
	}
	return NULL;
}



IDirect3DRMMaterial2 * __cdecl
lego::res::Material_Create
					(float emissiveRed,float emissiveGreen,float emissiveBlue,float specularRed,
					float specularGreen,float specularBlue,float power)
{
	HRESULT HVar1;
	
	HVar1 = (*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateMaterial)
										(globs::mainGlobs.lpD3DRM,power,(IDirect3DRMMaterial2 **)&power);
	if (HVar1 == 0) {
										// IDirect3DRMMaterial2->SetEmissive(this, float r, float g, float b)
		(**(code **)((int)*(IDirect3DRMMaterial2 *)power + 0x34))
							((IDirect3DRMMaterial2 *)power,emissiveRed,emissiveGreen,emissiveBlue);
										// IDirect3DRMMaterial2->SetSpecular(this, float r, float g, float b)
		(**(code **)((int)*(IDirect3DRMMaterial2 *)power + 0x30))
							((IDirect3DRMMaterial2 *)power,specularRed,specularGreen,specularBlue);
		return (IDirect3DRMMaterial2 *)power;
	}
	return NULL;
}



AnimClone * __cdecl
lego::res::AnimClone_Register
					(IDirect3DRMAnimationSet2 *animSet,IDirect3DRMFrame3 *root,uint frameCount)
{
	uint *data;
	AnimClone *actFrame;
	AnimClone dummyActFrame;
	
	actFrame = (AnimClone *)std::malloc(0x20);
	actFrame->clonedFrom = NULL;
	actFrame->animSet = animSet;
	actFrame->scene = NULL;
	actFrame->lws = 0;
	actFrame->root = root;
	(*root->lpVtbl->AddRef)((IUnknown *)root);
	data = &actFrame->partCount;
	*data = 0;
	actFrame->frameCount = (uint)root;
	AnimClone_WalkTree(root,0,AnimClone_FrameCountCallback,data);
	dummyActFrame.root = (IDirect3DRMFrame3 *)std::malloc(*data << 2);
	actFrame->partArray = (IDirect3DRMFrame3 **)dummyActFrame.root;
	dummyActFrame.partArray = NULL;
	AnimClone_WalkTree(root,0,AnimClone_SetupFrameArrayCallback,&stack0xffffffdc);
	return actFrame;
}



AnimClone * __cdecl
lego::res::AnimClone_RegisterLws(void *struct38,IDirect3DRMFrame3 *rmFrame3,undefined4 field1c)
{
	uint *data;
	AnimClone *pAVar1;
	AnimClone dummyActFrame;
	
	pAVar1 = (AnimClone *)std::malloc(0x20);
	pAVar1->clonedFrom = NULL;
	pAVar1->animSet = NULL;
	pAVar1->scene = (Lws_Info *)struct38;
	pAVar1->lws = 1;
	pAVar1->root = rmFrame3;
	(*rmFrame3->lpVtbl->AddRef)((IUnknown *)rmFrame3);
	data = &pAVar1->partCount;
	*data = 0;
	pAVar1->frameCount = (uint)rmFrame3;
	AnimClone_WalkTree(rmFrame3,0,AnimClone_FrameCountCallback,data);
	dummyActFrame.root = (IDirect3DRMFrame3 *)std::malloc(*data << 2);
	pAVar1->partArray = (IDirect3DRMFrame3 **)dummyActFrame.root;
	dummyActFrame.partArray = NULL;
	AnimClone_WalkTree(rmFrame3,0,AnimClone_SetupFrameArrayCallback,&stack0xffffffdc);
	return pAVar1;
}



AnimClone * __cdecl
lego::res::AnimClone_Make(AnimClone *lastActFrameRes,IDirect3DRMFrame3 *parent,uint *out_frameCount)
{
	IDirect3DRMFrame3 **lplpD3DRMFrame;
	AnimClone *pAVar1;
	Lws_Info *pLVar2;
	IDirect3DRMFrame3 **ppIVar3;
	int iVar4;
	AnimClone *pAVar5;
	AnimClone *pAVar6;
	uint *unaff_retaddr;
	IDirect3DRMFrame3 **ppIStack24;
	undefined4 uStack20;
	
	pAVar1 = (AnimClone *)std::malloc(0x20);
	iVar4 = 8;
	pAVar5 = lastActFrameRes;
	pAVar6 = pAVar1;
	if (lastActFrameRes->lws == 0) {
		for (; iVar4 != 0; iVar4 += -1) {
			pAVar6->clonedFrom = NULL;
			pAVar6 = (AnimClone *)&pAVar6->scene;
		}
										// IDirect3DRMAnimationSet2->SetTime(IDirect3DRMAnimationSet2* this, float
										// rvTime)
		(*(code *)lastActFrameRes->animSet->lpVtbl->SetTime)(lastActFrameRes->animSet,0.0);
		pAVar1->animSet = NULL;
		pAVar1->clonedFrom = lastActFrameRes;
		lplpD3DRMFrame = &pAVar1->root;
										// IDirect3DRM3->CreateFrame(this, IDirect3DRMFrame3* lpD3DRMFrame,
										// IDirect3DRMFrame3** lplpD3DRMFrame)
		(*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
							(globs::mainGlobs.lpD3DRM,parent,lplpD3DRMFrame);
		ppIVar3 = (IDirect3DRMFrame3 **)std::malloc(lastActFrameRes->partCount << 2);
		pAVar1->partArray = ppIVar3;
		AnimClone_CreateCopy(lastActFrameRes->root,*lplpD3DRMFrame,lastActFrameRes->lws);
		pAVar1->partCount = lastActFrameRes->partCount;
		if (unaff_retaddr != NULL) {
			*unaff_retaddr = lastActFrameRes->frameCount;
		}
		ppIStack24 = pAVar1->partArray;
		uStack20 = 0;
		AnimClone_WalkTree(*lplpD3DRMFrame,0,AnimClone_SetupFrameArrayCallback,&stack0xffffffd4);
	}
	else {
		for (; iVar4 != 0; iVar4 += -1) {
			pAVar6->clonedFrom = pAVar5->clonedFrom;
			pAVar5 = (AnimClone *)&pAVar5->scene;
			pAVar6 = (AnimClone *)&pAVar6->scene;
		}
		pLVar2 = Lws_Clone(lastActFrameRes->scene,parent);
		pAVar1->scene = pLVar2;
		pAVar1->clonedFrom = NULL;
		if (out_frameCount != NULL) {
			*out_frameCount = lastActFrameRes->frameCount;
			return pAVar1;
		}
	}
	return pAVar1;
}



void __cdecl lego::res::AnimClone_Remove(AnimClone *actFrameRes)
{
	uint uVar1;
	
	if (actFrameRes != NULL) {
		if (actFrameRes->clonedFrom == NULL) {
			if (actFrameRes->lws == 0) {
				(*actFrameRes->animSet->lpVtbl->Release)((IUnknown *)actFrameRes->animSet);
				(*actFrameRes->root->lpVtbl->Release)((IUnknown *)actFrameRes->root);
			}
			else {
				Lws_Free(actFrameRes->scene);
			}
		}
		if (actFrameRes->lws == 0) {
			uVar1 = 0;
			if (actFrameRes->partCount != 0) {
				do {
					(*actFrameRes->partArray[uVar1]->lpVtbl->Release)
										((IUnknown *)actFrameRes->partArray[uVar1]);
					uVar1 += 1;
				} while (uVar1 < actFrameRes->partCount);
			}
			std::free(actFrameRes->partArray);
		}
		std::free(actFrameRes);
	}
	return;
}



// This function seems to double as lego::image::Flic_GetWidth (ImageFlic->dwWidth 0xc)

BOOL __cdecl lego::res::AnimClone_IsLws(AnimClone *clone)
{
	return clone->lws;
}



void __cdecl lego::res::AnimClone_SetTime(AnimClone *clone,float time,float *out_oldTime)
{
	AnimClone *pAVar1;
	uint uVar2;
	Matrix4F local_40;
	
	pAVar1 = clone->clonedFrom;
	if (pAVar1 == NULL) {
		if (clone->lws != 0) {
			Lws_SetTime(clone->scene,time);
			return;
		}
		(*(code *)clone->animSet->lpVtbl->SetTime)(clone->animSet,time);
	}
	else {
		if (pAVar1->lws == 0) {
			(*(code *)pAVar1->animSet->lpVtbl->SetTime)(pAVar1->animSet,time);
		}
		else {
			Lws_SetTime(pAVar1->scene,time);
		}
		uVar2 = 0;
		if (clone->partCount != 0) {
			do {
				(*pAVar1->partArray[uVar2]->lpVtbl->GetParent)
									(pAVar1->partArray[uVar2],(IDirect3DRMFrame3 **)&time);
				(*pAVar1->partArray[uVar2]->lpVtbl->GetTransform)
									(pAVar1->partArray[uVar2],(IDirect3DRMFrame3 *)time,&local_40);
				(**(code **)((int)*(IDirect3DRMFrame3 *)time + 8))((IUnknown *)time);
				(*clone->partArray[uVar2]->lpVtbl->AddTransform)
									(clone->partArray[uVar2],D3DRMCOMBINE_REPLACE,&local_40);
				uVar2 += 1;
			} while (uVar2 < clone->partCount);
		}
		if (out_oldTime != NULL) {
			if (pAVar1->lws != 0) {
				Lws_SetTime(pAVar1->scene,*out_oldTime);
				return;
			}
			(*(code *)pAVar1->animSet->lpVtbl->SetTime)(pAVar1->animSet,*out_oldTime);
			return;
		}
	}
	return;
}



BOOL __cdecl lego::res::AnimClone_FrameCountCallback(IDirect3DRMFrame3 *frame,int *lpFramesCount)
{
	*lpFramesCount = *lpFramesCount + 1;
	return 0;
}



BOOL __cdecl
lego::res::AnimClone_SetupFrameArrayCallback(IDirect3DRMFrame3 *frame,AnimClone *actFrameRes)
{
	actFrameRes->partArray[actFrameRes->partCount] = frame;
	actFrameRes->partCount = actFrameRes->partCount + 1;
	return 0;
}



BOOL __cdecl
lego::res::AnimClone_WalkTree
					(IDirect3DRMFrame3 *frame,uint level,AnimCloneWalkTreeCallback Callback,
					IDirect3DRMFrame3 *data)
{
	IDirect3DRMFrame3 *pIVar1;
	AnimCloneWalkTreeCallback Callback_00;
	IDirect3DRMFrame3 *data_00;
	int iVar2;
	HRESULT HVar3;
	uint uVar4;
	BOOL BVar5;
	uint index;
	BOOL local_8;
	
	data_00 = data;
	Callback_00 = Callback;
	pIVar1 = frame;
	local_8 = 0;
	iVar2 = (*Callback)(frame,data);
	if (iVar2 != 0) {
		return 1;
	}
										// IDirect3DRMFrame3->GetChildren(this, IDirect3DRMFrameArray** lplpChildren)
	HVar3 = (*pIVar1->lpVtbl->GetChildren)(pIVar1,(IDirect3DRMFrameArray **)&frame);
	if (HVar3 == 0) {
										// DWORD IDirect3DRMFrameArray->GetSize(this)
		uVar4 = (*frame->lpVtbl->Clone)((IDirect3DRMFrameArray *)frame);
		index = 0;
		if (uVar4 != 0) {
			do {
										// IDirect3DRMFrameArray->GetElement(this, DWORD index, IDirect3DRMFrame**
										// lplpD3DRMFrame)
				(*frame->lpVtbl->AddDestroyCallback)
									((IDirect3DRMFrameArray *)frame,index,(IUnknown **)&Callback);
										// IDirect3DRMFrame->QueryInterface(this, IID_IDirect3DRMFrame3,
										// IDirect3DRMFrame3** lplpOut)
				(**(code **)*(IUnknown *)Callback)((IUnknown *)Callback,&idl::IID_IDirect3DRMFrame3,&data);
										// IDirect3DRMFrame->Release(this)
				(**(code **)((int)*(IUnknown *)Callback + 8))((IUnknown *)Callback);
				BVar5 = AnimClone_WalkTree(data,level + 1,Callback_00,data_00);
				if (BVar5 != 0) {
					local_8 = 1;
					(*data->lpVtbl->Release)((IUnknown *)data);
					break;
				}
				(*data->lpVtbl->Release)((IUnknown *)data);
				index += 1;
			} while (index < uVar4);
		}
		(*frame->lpVtbl->Release)((IUnknown *)frame);
	}
	return local_8;
}



void __cdecl
lego::res::AnimClone_CreateCopy(IDirect3DRMFrame3 *orig,IDirect3DRMFrame3 *clone,BOOL lws)
{
	IDirect3DRMFrame3 *this;
	IDirect3DRMFrame3 *this_00;
	BOOL lws_00;
	LPCSTR lpName;
	HRESULT HVar1;
	uint uVar2;
	LPVOID *unaff_EBP;
	IID *unaff_ESI;
	DWORD index;
	IUnknown *unaff_EDI;
	IDirect3DRMFrameArray *in_stack_00000014;
	Matrix4F local_40;
	
	lws_00 = lws;
	this_00 = clone;
	this = orig;
	if ((IDirect3DRMFrame3 *)lws == NULL) {
		AnimClone_ReferenceVisuals(orig,clone);
	}
	else {
		AnimClone_CloneLwsMesh(orig,clone);
	}
										// IDirect3DRMFrame3->GetName(this, DWORD* lpdwSize, LPSTR lpName)
	(*this->lpVtbl->GetName)(this,(LPDWORD)&orig,NULL);
	if (orig != NULL) {
		lpName = (LPCSTR)std::malloc((uint)orig);
										// IDirect3DRMFrame3->GetName(this, DWORD* lpdwSize, LPSTR lpName)
		(*this->lpVtbl->GetName)(this,(LPDWORD)&orig,lpName);
										// IDirect3DRMFrame3->SetName(this, LPCSTR lpName)
		(*this_00->lpVtbl->SetName)(this_00,lpName);
		std::free(lpName);
	}
										// IDirect3DRMFrame3->GetParent(this, IDirect3DRMFrame3** lplpParent)
	(*this->lpVtbl->GetParent)(this,(IDirect3DRMFrame3 **)&lws);
										// IDirect3DRMFrame3->GetTransform(this, IDirect3DRMFrame3* lpRefFrame,
										// Matrix4F** rmMatrix)
	(*this->lpVtbl->GetTransform)(this,(IDirect3DRMFrame3 *)lws,(Matrix4F **)&local_40);
										// IDirect3DRMFrame3->Release(this)
										//  (this = GetParent)
	(**(code **)((int)*(IDirect3DRMFrame3 *)lws + 8))((IDirect3DRMFrame3 *)lws);
										// IDirect3DRMFrame3->AddTransform(this, TD3DRMCombineType rctCombine, Matrix4F*
										// rmMatrix)
	(*this_00->lpVtbl->AddTransform)(this_00,D3DRMCOMBINE_REPLACE,&local_40);
										// IDirect3DRMFrame3->GetChildren(this, IDirect3DRMFrameArray** lplpChildren)
	HVar1 = (*this->lpVtbl->GetChildren)(this,(IDirect3DRMFrameArray **)&clone);
	if (HVar1 == 0) {
										// DWORD IDirect3DRMFrameArray->GetSize(this)
		uVar2 = (*clone->lpVtbl->Clone)((IUnknown *)clone,unaff_EDI,unaff_ESI,unaff_EBP);
		index = 0;
		if (uVar2 != 0) {
			do {
										// IDirect3DRMFrameArray->GetElement(this, DWORD index, IDirect3DRMFrame**
										// lplpD3DRMFrame)
				(*in_stack_00000014->lpVtbl->GetElement)(in_stack_00000014,index,(IUnknown **)&local_40);
										// IDirect3DRMFrame->QueryInterface(this, IID_IDirect3DRMFrame3,
										// IDirect3DRMFrame3** lplpOut)
				(*(*(IDirect3DRMFrame3Vtbl **)local_40.values[0][0])->QueryInterface)
									((IUnknown *)local_40.values[0][0],&idl::IID_IDirect3DRMFrame3,
									 (IDirect3DRMFrame3 **)(local_40.values + 2));
										// IDirect3DRMFrame->Release(this)
				(*(*(IDirect3DRMFrame3Vtbl **)local_40.values[0][0])->Release)
									((IUnknown *)local_40.values[0][0]);
										// IDirect3DRM3->CreateFrame(this, IDirect3DRMFrame3* lpD3DRMFrame,
										// IDirect3DRMFrame3** lplpD3DRMFrame)
				(*(globs::mainGlobs.lpD3DRM)->lpVtbl->CreateFrame)
									(globs::mainGlobs.lpD3DRM,this_00,(IDirect3DRMFrame3 **)&local_40);
				AnimClone_CreateCopy
									((IDirect3DRMFrame3 *)local_40.values[0][1],
									 (IDirect3DRMFrame3 *)local_40.values[0][0],lws_00);
				(*(*(IDirect3DRMFrame3Vtbl **)local_40.values[0][0])->Release)
									((IUnknown *)local_40.values[0][0]);
				(*(*(IDirect3DRMFrame3Vtbl **)local_40.values[0][1])->Release)
									((IUnknown *)local_40.values[0][1]);
				index += 1;
			} while (index < uVar2);
		}
		(*in_stack_00000014->lpVtbl->Release)((IUnknown *)in_stack_00000014);
	}
	return;
}



void __cdecl
lego::res::AnimClone_CloneLwsMesh(IDirect3DRMFrame3 *rmFrame3,IDirect3DRMFrame3 *param_2)
{
	HRESULT HVar1;
	Mesh *mesh;
	IDirect3DRMVisual **ppIVar2;
	IDirect3DRMFrame3 *pIVar3;
	IDirect3DRMUserVisual *local_14;
	IDirect3DRMVisual *local_10 [4];
	
	pIVar3 = rmFrame3;
										// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount,
										// IDirect3DRMVisualArray** lplpVisuals)
										//  (NOTE: lightalloy's implementation is missing an argument)
	(*rmFrame3->lpVtbl->GetVisuals)(rmFrame3,(DWORD *)&rmFrame3,NULL);
	if (rmFrame3 != NULL) {
										// IDirect3DRMFrame3->GetVisuals(this, DWORD* lpdwCount,
										// IDirect3DRMVisualArray** lplpVisuals)
										//  (NOTE: lightalloy's implementation is missing an argument)
		(*pIVar3->lpVtbl->GetVisuals)(pIVar3,(DWORD *)&rmFrame3,local_10);
		pIVar3 = NULL;
		if (rmFrame3 != NULL) {
			ppIVar2 = local_10;
			do {
				HVar1 = (*(*ppIVar2)->lpVtbl->QueryInterface)
													(*ppIVar2,&idl::IID_IDirect3DRMUserVisual,&local_14);
				if (HVar1 == 0) {
					mesh = (Mesh *)(*local_14->lpVtbl->GetAppData)((IUnknown *)local_14);
					Mesh_Clone(mesh,param_2);
				}
				pIVar3 = (IDirect3DRMFrame3 *)((int)&pIVar3->lpVtbl + 1);
				ppIVar2 = ppIVar2 + 1;
			} while (pIVar3 < rmFrame3);
		}
	}
	return;
}



void __cdecl lego::res::AnimClone_ReferenceVisuals(IDirect3DRMFrame3 *orig,IDirect3DRMFrame3 *clone)
{
	IDirect3DRMFrame3 *pIVar1;
	IDirect3DRMVisual **ppIVar2;
	IDirect3DRMVisual *local_10 [4];
	
	pIVar1 = orig;
	(*orig->lpVtbl->GetVisuals)(orig,(DWORD *)&orig,NULL);
	if (orig != NULL) {
		(*pIVar1->lpVtbl->GetVisuals)(pIVar1,(DWORD *)&orig,local_10);
		pIVar1 = NULL;
		if (orig != NULL) {
			ppIVar2 = local_10;
			do {
				(*clone->lpVtbl->AddVisual)(clone,*ppIVar2);
				pIVar1 = (IDirect3DRMFrame3 *)((int)&pIVar1->lpVtbl + 1);
				ppIVar2 = ppIVar2 + 1;
			} while (pIVar1 < orig);
		}
	}
	return;
}



void __cdecl lego::image::BMP_Parse(BITMAP_FILE_INFO_STRUCT *data,uint size,D3DRMImage *istruct)
{
	byte bVar1;
	D3DRMPaletteEntry *pDVar2;
	int iVar3;
	DWORD DVar4;
	D3DRMPaletteEntry *pDVar5;
	uint uVar6;
	DWORD DVar7;
	D3DRMPaletteEntry *pDVar8;
	
	if ((data->bmi).biBitCount == 8) {
		DVar7 = (data->bmi).biClrUsed;
		if (DVar7 == 0) {
			DVar7 = 0x100;
		}
		pDVar2 = (D3DRMPaletteEntry *)std::malloc(0x400);
		pDVar5 = pDVar2;
		for (iVar3 = 0x100; iVar3 != 0; iVar3 += -1) {
			*pDVar5 = (D3DRMPaletteEntry)0x0;
			pDVar5 = pDVar5 + 1;
		}
		pDVar5 = (D3DRMPaletteEntry *)data->bmiColors;
		pDVar8 = pDVar2;
		for (DVar4 = DVar7; DVar4 != 0; DVar4 -= 1) {
			*pDVar8 = *pDVar5;
			pDVar5 = pDVar5 + 1;
			pDVar8 = pDVar8 + 1;
		}
		istruct->rgb = 0;
		istruct->red_mask = 0xfc;
		istruct->green_mask = 0xfc;
		istruct->blue_mask = 0xfc;
		istruct->alpha_mask = 0xfc;
		istruct->palette_size = DVar7;
		pDVar5 = pDVar2;
		if (0 < (int)DVar7) {
			do {
				bVar1 = pDVar5->red;
				pDVar5->red = pDVar5->blue;
				pDVar5->blue = bVar1;
				DVar7 -= 1;
				pDVar5 = pDVar5 + 1;
			} while (DVar7 != 0);
		}
		istruct->palette = pDVar2;
	}
	else {
		istruct->rgb = 1;
		istruct->palette_size = 0;
		istruct->palette = NULL;
	}
	istruct->width = (data->bmi).biWidth;
	istruct->height = (data->bmi).biHeight;
	uVar6 = (uint)(data->bmi).biBitCount;
	istruct->depth = uVar6;
	if (false) {
switchD_00489faf_caseD_9:
		iVar3 = 0;
	}
	else {
		switch(uVar6) {
		case 8:
			iVar3 = 1;
			break;
		default:
			goto switchD_00489faf_caseD_9;
		case 0xf:
		case 0x10:
			iVar3 = 2;
			break;
		case 0x18:
			iVar3 = 3;
			break;
		case 0x20:
			iVar3 = 4;
		}
	}
	istruct->bytes_per_line = iVar3 * istruct->width + 3U & 0xfffffffc;
	DVar7 = (data->hdr).bfOffBits;
	istruct->aspecty = 1;
	istruct->aspectx = 1;
	istruct->buffer1 = (byte *)((int)data->bmiColors + (DVar7 - 0x36));
	istruct->buffer2 = NULL;
	return;
}



void __cdecl lego::image::BMP_Cleanup(D3DRMImage *istruct)
{
	if (istruct->palette != NULL) {
		std::free(istruct->palette);
	}
	return;
}



void __cdecl lego::debug::SE(char *error,char *errorDesc)
{
	std::sprintf(globs::dxbugGlobs.DXErrorString,
							 "A DirectX error was set in module %s at line no %i.\nError : %s (code %i)\nDX Module : %s\nError Description : %s\n"
							 ,globs::dxbugGlobs.file,globs::dxbugGlobs.line,error,globs::dxbugGlobs.errnum,
							 globs::DXModuleName[globs::dxbugGlobs.DXModuleNameNumber],errorDesc);
	return;
}



HRESULT __cdecl lego::debug::Error_SetDXError(HRESULT err,int DXModule,char *File,int Line)
{
	globs::dxbugGlobs.errnum = err;
	if ((DXModule < 1) || (globs::dxbugGlobs.DXModuleNameNumber = DXModule, 7 < DXModule)) {
		globs::dxbugGlobs.DXModuleNameNumber = 0;
	}
	globs::dxbugGlobs.line = Line;
	globs::dxbugGlobs.DXNumErrorsSet += 1;
	globs::dxbugGlobs.file = File;
	switch(DXModule) {
	case 2:
		if (err < -0x7fffbffe) {
			if (err == -0x7fffbfff) {
				SE("DIERR_UNSUPPORTED",
					 "The function called is not supported at this time.\nThis value is equal to the E_NOTIMPL\nstandard COM return value."
					);
				return -0x7fffbfff;
			}
			if (err == -0x7ffffff6) {
				SE("E_PENDING","Data is not yet availabe.");
				return -0x7ffffff6;
			}
		}
		else {
			if (err < -0x7fffbffa) {
				if (err == -0x7fffbffb) {
					SE("DIERR_GENERIC",
						 "An undetermined error occurred inside the DirectInput subsystem.\nThis value is equal to the E_FAIL standard\nCOM return value."
						);
					return -0x7fffbffb;
				}
				if (err == -0x7fffbffe) {
					SE("DIERR_NOINTERFACE",
						 "The specified interface is not supported by\nthe object. This value is equal to the E_NOINTERFACE\nstandard COM return value."
						);
					return -0x7fffbffe;
				}
			}
			else {
				if (err < -0x7ffbfeab) {
					if (err == -0x7ffbfeac) {
						SE("DIERR_DEVICENOTREG",
							 "The device or device instance is not registered with\nDirectInput. This value is equal to the\nREGDB_E_CLASSNOTREG standard COM return value."
							);
						return -0x7ffbfeac;
					}
					if (err == -0x7ffbfef0) {
						SE("DIERR_NOAGGREGATION","This object does not support aggregation.");
						return -0x7ffbfef0;
					}
				}
				else {
					if (err < -0x7ff8fffd) {
						if (err == -0x7ff8fffe) {
							SE("DIERR_NOTFOUND","The requested object does not exist.");
							return -0x7ff8fffe;
						}
						switch(err) {
						case -0x7ffbfdff:
							SE("DIERR_DEVICEFULL","The device is full.");
							return err;
						case -0x7ffbfdfe:
							SE("DIERR_MOREDATA","Not all the requested information fitted into the buffer");
							return err;
						case -0x7ffbfdfd:
							SE("DIERR_NOTDOWNLOADED","The effect is not downloaded");
							return err;
						case -0x7ffbfdfc:
							SE("DIERR_HASEFFECTS",
								 "The device cannot be reinitialized because there\nare still effects attached to it"
								);
							return err;
						case -0x7ffbfdfb:
							SE("DIERR_NOTEXCLUSIVEACQUIRED",
								 "The operation cannot be performed unless the device\nis acquired in DISCL_EXCLUSIVE mode."
								);
							return err;
						case -0x7ffbfdfa:
							SE("DIERR_INCOMPLETEEFFECT",
								 "The effect could not be downloaded because essential\ninformation is missing. For example, no axes have\nbeen associated with the effect, or no type-specific\ninformation has been supplied"
								);
							return err;
						case -0x7ffbfdf9:
							SE("DIERR_NOTBUFFERED",
								 "The device is not buffered.\nSet the DIPROP_BUFFERSIZE property to enable buffering"
								);
							return err;
						case -0x7ffbfdf8:
							SE("DIERR_EFFECTPLAYING",
								 "The parameters were updated in memory but were not\ndownloaded to the device because the device does not\nsupport updating an effect while it is still playing."
								);
							return err;
						}
					}
					else {
						if (err < -0x7ff8fff3) {
							if (err == -0x7ff8fff4) {
								SE("DIERR_NOTACQUIRED",
									 "The operation cannot be performed unless\nthe device is acquired.");
								return -0x7ff8fff4;
							}
							if (err == -0x7ff8fffb) {
								SE("DIERR_HANDLEEXISTS",
									 "The device already has an event notification associated\nwith it. This value is equal to the E_ACCESSDENIED\nstandard COM return value."
									);
								return -0x7ff8fffb;
							}
						}
						else {
							if (err < -0x7ff8ffea) {
								if (err == -0x7ff8ffeb) {
									SE("DIERR_NOTINITIALIZED","This object has not been initialized.");
									return -0x7ff8ffeb;
								}
								if (err == -0x7ff8fff2) {
									SE("DIERR_OUTOFMEMORY",
										 "The DirectInput subsystem couldn\'t allocate\nsufficient memory to complete the call.\nThis value is equal to the E_OUTOFMEMORY\nstandard COM return value."
										);
									return -0x7ff8fff2;
								}
							}
							else {
								if (err < -0x7ff8ffa8) {
									if (err == -0x7ff8ffa9) {
										SE("DIERR_INVALIDPARAM",
											 "An invalid parameter was passed to the returning function, or the object was not in a state that permitted the function to be called. This value is equal to the E_INVALIDARG standard COM return value."
											);
										return -0x7ff8ffa9;
									}
									if (err == -0x7ff8ffe2) {
										SE("DIERR_INPUTLOST",
											 "Access to the input device has been lost. It must be reacquired.");
										return -0x7ff8ffe2;
									}
								}
								else {
									if (err < -0x7ff8ff55) {
										if (err == -0x7ff8ff56) {
											SE("DIERR_ACQUIRED",
												 "The operation cannot be performed while\nthe device is acquired.");
											return -0x7ff8ff56;
										}
										if (err == -0x7ff8ff89) {
											SE("DIERR_BADDRIVERVER",
												 "The object could not be created due to an\nincompatible driver version or mismatched or\nincomplete driver components."
												);
											return -0x7ff8ff89;
										}
									}
									else {
										if (err < -0x7ff8fb7e) {
											if (err == -0x7ff8fb7f) {
												SE("DIERR_BETADIRECTINPUTVERSION",
													 "The application was written for an unsupported\nprerelease version of DirectInput."
													);
												return -0x7ff8fb7f;
											}
											if (err == -0x7ff8fb82) {
												SE("DIERR_OLDDIRECTINPUTVERSION",
													 "The application requires a newer version of DirectInput.");
												return -0x7ff8fb82;
											}
										}
										else {
											if (err < 1) {
												if (err == 0) {
													SE("DI_OK",
														 "The operation completed successfully.\nThis value is equal to the S_OK standard\nCOM return value."
														);
													return 0;
												}
												if (err == -0x7ff8fb21) {
													SE("DIERR_ALREADYINITIALIZED","This object is already initialized");
													return -0x7ff8fb21;
												}
											}
											else {
												if (true) {
													switch(err) {
													case 1:
														SE("DI_BUFFEROVERFLOW",
															 "The device buffer overflowed and some input was lost.\nThis value is equal to the S_FALSE\nstandard COM return value."
															);
														return err;
													case 2:
														SE("DI_POLLEDDEVICE",
															 "The device is a polled device.\nAs a result, device buffering will not collect\nany data and event notifications will not be signaled\nuntil the IDirectInputDevice2::Poll method is called."
															);
														return err;
													case 3:
														SE("DI_DOWNLOADSKIPPED",
															 "The parameters of the effect were successfully updated,\nbut the effect could not be downloaded because the associated\ndevice was not acquired in exclusive mode."
															);
														return err;
													case 4:
														SE("DI_EFFECTRESTARTED",
															 "The effect was stopped,\nthe parameters were updated,\nand the effect was restarted."
															);
														return err;
													case 8:
														SE("DI_TRUNCATED",
															 "The parameters of the effect were successfully updated,\nbut some of them were beyond the capabilities of the\ndevice and were truncated to the nearest supported value."
															);
														return err;
													case 0xc:
														SE("DI_TRUNCATEDANDRESTARTED",
															 "Equal to DI_EFFECTRESTARTED | DI_TRUNCATED");
														return err;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		break;
	case 3:
		if (err < -0x7fffbffa) {
			if (err == -0x7fffbffb) {
				SE("DDERR_GENERIC","There is an undefined error condition.");
				return -0x7fffbffb;
			}
			if (err == -0x7fffbfff) {
				SE("DDERR_UNSUPPORTED","The operation is not supported.");
				return -0x7fffbfff;
			}
		}
		else {
			if (err < -0x7ff8fff1) {
				if (err == -0x7ff8fff2) {
					SE("DDERR_OUTOFMEMORY","DirectDraw does not have enough\nmemory to perform the operation."
						);
					return -0x7ff8fff2;
				}
				if (err == -0x7ffbfe10) {
					SE("DDERR_NOTINITIALIZED",
						 "An attempt was made to call an interface method\nof a DirectDraw object created by CoCreateInstance before\nthe object was initialized."
						);
					return -0x7ffbfe10;
				}
			}
			else {
				if (err < -0x7789fffa) {
					if (err == -0x7789fffb) {
						SE("DDERR_ALREADYINITIALIZED","The object has already been initialized.");
						return -0x7789fffb;
					}
					if (err == -0x7ff8ffa9) {
						SE("DDERR_INVALIDPARAMS",
							 "One or more of the parameters passed to the\nmethod are incorrect.");
						return -0x7ff8ffa9;
					}
				}
				else {
					if (err < -0x7789ffeb) {
						if (err == -0x7789ffec) {
							SE("DDERR_CANNOTDETACHSURFACE",
								 "A surface cannot be detached from another\nrequested surface.");
							return -0x7789ffec;
						}
						if (err == -0x7789fff6) {
							SE("DDERR_CANNOTATTACHSURFACE",
								 "A surface cannot be attached to\nanother requested surface.");
							return -0x7789fff6;
						}
					}
					else {
						if (err < -0x7789ffc8) {
							if (err == -0x7789ffc9) {
								SE("DDERR_EXCEPTION",
									 "An exception was encountered while performing the requested operation.");
								return -0x7789ffc9;
							}
							if (err == -0x7789ffd8) {
								SE("DDERR_CURRENTLYNOTAVAIL","No support is currently available.");
								return -0x7789ffd8;
							}
						}
						else {
							if (err < -0x7789ffa0) {
								if (err == -0x7789ffa1) {
									SE("DDERR_INCOMPATIBLEPRIMARY",
										 "The primary surface creation request does\nnot match with the existing primary surface."
										);
									return -0x7789ffa1;
								}
								if (err == -0x7789ffa6) {
									SE("DDERR_HEIGHTALIGN",
										 "The height of the provided rectangle is not\na multiple of the required alignment."
										);
									return -0x7789ffa6;
								}
							}
							else {
								if (err < -0x7789ff91) {
									if (err == -0x7789ff92) {
										SE("DDERR_INVALIDCLIPLIST","DirectDraw does not support the provided clip list."
											);
										return -0x7789ff92;
									}
									if (err == -0x7789ff9c) {
										SE("DDERR_INVALIDCAPS",
											 "One or more of the capability bits passed to\nthe callback function are incorrect."
											);
										return -0x7789ff9c;
									}
								}
								else {
									if (err < -0x7789ff7d) {
										if (err == -0x7789ff7e) {
											SE("DDERR_INVALIDOBJECT",
												 "DirectDraw received a pointer that was an\ninvalid DirectDraw object.");
											return -0x7789ff7e;
										}
										if (err == -0x7789ff88) {
											SE("DDERR_INVALIDMODE","DirectDraw does not support the requested mode.");
											return -0x7789ff88;
										}
									}
									else {
										if (err < -0x7789ff69) {
											if (err == -0x7789ff6a) {
												SE("DDERR_INVALIDRECT","The provided rectangle was invalid.");
												return -0x7789ff6a;
											}
											if (err == -0x7789ff6f) {
												SE("DDERR_INVALIDPIXELFORMAT","The pixel format was invalid as specified.");
												return -0x7789ff6f;
											}
										}
										else {
											if (err < -0x7789ff55) {
												if (err == -0x7789ff56) {
													SE("DDERR_NO3D","No 3-D hardware or emulation is present.");
													return -0x7789ff56;
												}
												if (err == -0x7789ff60) {
													SE("DDERR_LOCKEDSURFACES",
														 "One or more surfaces are locked, causing the failure of\nthe requested operation."
														);
													return -0x7789ff60;
												}
											}
											else {
												if (err < -0x7789ff32) {
													if (err == -0x7789ff33) {
														SE("DDERR_NOCLIPLIST","No clip list is available.");
														return -0x7789ff33;
													}
													if (err == -0x7789ff4c) {
														SE("DDERR_NOALPHAHW",
															 "No alpha acceleration hardware is present or\navailable, causing the failure of\nthe requested operation."
															);
														return -0x7789ff4c;
													}
												}
												else {
													if (err < -0x7789ff23) {
														if (err == -0x7789ff24) {
															SE("DDERR_NOCOLORKEYHW",
																 "The operation cannot be carried out because there is\nno hardware support for the destination color key."
																);
															return -0x7789ff24;
														}
														if (err == -0x7789ff2e) {
															SE("DDERR_NOCOLORCONVHW",
																 "The operation cannot be carried out because no\ncolor-conversion hardware is present or available."
																);
															return -0x7789ff2e;
														}
														if (err == -0x7789ff2c) {
															SE("DDERR_NOCOOPERATIVELEVELSET",
																 "A create function is called without the\nIDirectDraw2::SetCooperativeLevel method being called."
																);
															return -0x7789ff2c;
														}
														if (err == -0x7789ff29) {
															SE("DDERR_NOCOLORKEY",
																 "The surface does not currently have a color key.");
															return -0x7789ff29;
														}
													}
													else {
														if (err < -0x7789ff1e) {
															if (err == -0x7789ff1f) {
																SE("DDERR_NOEXCLUSIVEMODE",
																	 "The operation requires the application to have exclusive mode,\nbut the application does not have exclusive mode."
																	);
																return -0x7789ff1f;
															}
															if (err == -0x7789ff22) {
																SE("DDERR_NODIRECTDRAWSUPPORT",
																	 "DirectDraw support is not possible\nwith the current display driver."
																	);
																return -0x7789ff22;
															}
														}
														else {
															if (err < -0x7789ff0f) {
																if (err == -0x7789ff10) {
																	SE("DDERR_NOGDI","No GDI is present.");
																	return -0x7789ff10;
																}
																if (err == -0x7789ff1a) {
																	SE("DDERR_NOFLIPHW","Flipping visible surfaces is not supported.")
																	;
																	return -0x7789ff1a;
																}
															}
															else {
																if (err < -0x7789ff00) {
																	if (err == -0x7789ff01) {
																		SE("DDERR_NOTFOUND","The requested item was not found.");
																		return -0x7789ff01;
																	}
																	if (err == -0x7789ff06) {
																		SE("DDERR_NOMIRRORHW",
																			 "The operation cannot be carried out because no mirroring\nhardware is present or available."
																			);
																		return -0x7789ff06;
																	}
																}
																else {
																	if (err < -0x7789fee7) {
																		if (err == -0x7789fee8) {
																			SE("DDERR_NORASTEROPHW",
																				 "The operation cannot be carried out because no appropriate\nraster operation hardware is present or available."
																				);
																			return -0x7789fee8;
																		}
																		if (err == -0x7789fefc) {
																			SE("DDERR_NOOVERLAYHW",
																				 "The operation cannot be carried out because no\noverlay hardware is present or available."
																				);
																			return -0x7789fefc;
																		}
																	}
																	else {
																		if (err < -0x7789fec9) {
																			if (err == -0x7789feca) {
																				SE("DDERR_NOSTRETCHHW",
																					 "The operation cannot be carried out because\nthere is no hardware support for stretching."
																					);
																				return -0x7789feca;
																			}
																			if (err == -0x7789fede) {
																				SE("DDERR_NOROTATIONHW",
																					 "The operation cannot be carried out because\nno rotation hardware is present or available."
																					);
																				return -0x7789fede;
																			}
																		}
																		else {
																			if (err < -0x7789feb5) {
																				if (err == -0x7789feb6) {
																					SE("DDERR_NOTEXTUREHW",
																						 "The operation cannot be carried out because no\ntexture-mapping hardware is present or available."
																						);
																					return -0x7789feb6;
																				}
																				if (err == -0x7789fec4) {
																					SE("DDERR_NOT4BITCOLOR",
																						 "The DirectDrawSurface object is not using a 4-bit color palette\nand the requested operation requires a 4-bit color palette."
																						);
																					return -0x7789fec4;
																				}
																				if (err == -0x7789fec3) {
																					SE("DDERR_NOT4BITCOLORINDEX",
																						 "The DirectDrawSurface object is not using a 4-bit color index\npalette and the requested operation requires a\n4-bit color index palette."
																						);
																					return -0x7789fec3;
																				}
																				if (err == -0x7789fec0) {
																					SE("DDERR_NOT8BITCOLOR",
																						 "The DirectDrawSurface object is not using an 8-bit color\npalette and the requested operation requires\nan 8-bit color palette."
																						);
																					return -0x7789fec0;
																				}
																			}
																			else {
																				if (err < -0x7789feab) {
																					if (err == -0x7789feac) {
																						SE("DDERR_NOZBUFFERHW",
																							 "The operation to create a z-buffer in display memory\nor to perform a blit using a z-buffer cannot be\ncarried out because there is no hardware support\nfor z-buffers."
																							);
																						return -0x7789feac;
																					}
																					if (err == -0x7789feb1) {
																						SE("DDERR_NOVSYNCHW",
																							 "The operation cannot be carried out because\nthere is no hardware support for vertical\nblank synchronized operations."
																							);
																						return -0x7789feb1;
																					}
																				}
																				else {
																					if (err < -0x7789fe97) {
																						if (err == -0x7789fe98) {
																							SE("DDERR_OUTOFCAPS",
																								 "The hardware needed for the requested\noperation has already been allocated."
																								);
																							return -0x7789fe98;
																						}
																						if (err == -0x7789fea2) {
																							SE("DDERR_NOZOVERLAYHW",
																								 "The overlay surfaces cannot be z-layered based on the\nz-order because the hardware does not support\nz-ordering of overlays."
																								);
																							return -0x7789fea2;
																						}
																					}
																					else {
																						if (err < -0x7789fe6f) {
																							if (err == -0x7789fe70) {
																								SE("DDERR_COLORKEYNOTSET",
																																																			
																									"No source color key is specified for this operation."
																									);
																								return -0x7789fe70;
																							}
																							if (true) {
																								switch(err) {
																								case -0x7789fe84:
																									SE("DDERR_OUTOFVIDEOMEMORY",
																																																					
																									"DirectDraw does not have enough display\nmemory to perform the operation."
																									);
																									return err;
																								case -0x7789fe82:
																									SE("DDERR_OVERLAYCANTCLIP",
																																																					
																									"The hardware does not support clipped overlays.")
																									;
																									return err;
																								case -0x7789fe80:
																									SE("DDERR_OVERLAYCOLORKEYONLYONEACTIVE",
																																																					
																									"An attempt was made to have more than one\ncolor key active on an overlay."
																									);
																									return err;
																								case -0x7789fe7d:
																									SE("DDERR_PALETTEBUSY",
																																																					
																									"Access to this palette is refused because\nthe palette is locked by another thread."
																									);
																									return err;
																								}
																							}
																						}
																						else {
																							if (err < -0x7789fe5b) {
																								if (err == -0x7789fe5c) {
																									SE("DDERR_SURFACEALREADYDEPENDENT",
																																																					
																									"An attempt was made to make a surface a dependency\nof another surface to which it is\nalready dependent."
																									);
																									return -0x7789fe5c;
																								}
																								if (err == -0x7789fe66) {
																									SE("DDERR_SURFACEALREADYATTACHED",
																																																					
																									"An attempt was made to attach a surface to another\nsurface to which it is already attached."
																									);
																									return -0x7789fe66;
																								}
																							}
																							else {
																								if (err < -0x7789fe4c) {
																									if (err == -0x7789fe4d) {
																										SE("DDERR_CANTLOCKSURFACE",
																																																							
																									"Access to this surface is refused because an\nattempt was made to lock the primary\nsurface without DCI support."
																									);
																									return -0x7789fe4d;
																									}
																									if (err == -0x7789fe52) {
																										SE("DDERR_SURFACEBUSY",
																																																							
																									"Access to the surface is refused because\nthe surface is locked by another thread."
																									);
																									return -0x7789fe52;
																									}
																								}
																								else {
																									if (err < -0x7789fe3d) {
																										if (err == -0x7789fe3e) {
																											SE("DDERR_SURFACELOST",
																																																									
																									"Access to the surface is refused because the surface\nmemory is gone. The DirectDrawSurface object representing this\nsurface should have the IDirectDrawSurface3::Restore\nmethod called on it."
																									);
																									return -0x7789fe3e;
																									}
																									if (err == -0x7789fe48) {
																										SE("DDERR_SURFACEISOBSCURED",
																																																							
																									"Access to the surface is refused\nbecause the surface is obscured."
																									);
																									return -0x7789fe48;
																									}
																									}
																									else {
																										if (err < -0x7789fe29) {
																											if (err == -0x7789fe2a) {
																												SE("DDERR_TOOBIGHEIGHT",
																																																											
																									"The height requested by DirectDraw is too large."
																									);
																									return -0x7789fe2a;
																									}
																									if (err == -0x7789fe34) {
																										SE("DDERR_SURFACENOTATTACHED",
																											 "The requested surface is not attached.");
																										return -0x7789fe34;
																									}
																									}
																									else {
																										if (err < -0x7789fe15) {
																											if (err == -0x7789fe16) {
																												SE("DDERR_TOOBIGWIDTH",
																																																											
																									"The width requested by DirectDraw\nis too large."
																									);
																									return -0x7789fe16;
																									}
																									if (err == -0x7789fe20) {
																										SE("DDERR_TOOBIGSIZE",
																																																							
																									"The size requested by DirectDraw is too large.\nHowever, the individual height and\nwidth are OK."
																									);
																									return -0x7789fe20;
																									}
																									}
																									else {
																										if (err < -0x7789fdf7) {
																											if (err == -0x7789fdf8) {
																												SE("DDERR_UNSUPPORTEDMASK",
																																																											
																									"The bitmask in the pixel format requested\nis not supported by DirectDraw."
																									);
																									return -0x7789fdf8;
																									}
																									if (err == -0x7789fe02) {
																										SE("DDERR_UNSUPPORTEDFORMAT",
																																																							
																									"The FourCC format requested is\nnot supported by DirectDraw."
																									);
																									return -0x7789fe02;
																									}
																									}
																									else {
																										if (err < -0x7789fde3) {
																											if (err == -0x7789fde4) {
																												SE("DDERR_WASSTILLDRAWING",
																																																											
																									"The previous blit operation that is transferring\ninformation to or from this\nsurface is incomplete."
																									);
																									return -0x7789fde4;
																									}
																									if (err == -0x7789fde7) {
																										SE("DDERR_VERTICALBLANKINPROGRESS",
																											 "A vertical blank is in progress.");
																										return -0x7789fde7;
																									}
																									}
																									else {
																										if (err < -0x7789fd89) {
																											if (err == -0x7789fd8a) {
																												SE("DDERR_NONONLOCALVIDME",
																																																											
																									"An attempt was made to allocate non-local video\nmemory from a device that does not support non-local\nvideo memory"
																									);
																									return -0x7789fd8a;
																									}
																									if (true) {
																										switch(err) {
																										case -0x7789fdd0:
																											SE("DDERR_XALIGN",
																																																									
																									"The provided rectangle was not horizontally\naligned on a required boundary."
																									);
																									return err;
																									case -0x7789fdcf:
																										SE("DDERR_INVALIDDIRECTDRAWGUID",
																																																							
																									"The globally unique identifier (GUID) passed to the\nDirectDrawCreate function is not a valid DirectDraw\ndriver identifier."
																									);
																									return err;
																									case -0x7789fdce:
																										SE("DDERR_DIRECTDRAWALREADYCREATED",
																																																							
																									"A DirectDraw object representing this driver\nhas already been created for this process."
																									);
																									return err;
																									case -0x7789fdcd:
																										SE("DDERR_NODIRECTDRAWHW",
																																																							
																									"Hardware-only DirectDraw object creation is not possible;\nthe driver does not support any hardware."
																									);
																									return err;
																									case -0x7789fdcc:
																										SE("DDERR_PRIMARYSURFACEALREADYEXISTS",
																																																							
																									"This process has already created a primary surface."
																									);
																									return err;
																									case -0x7789fdcb:
																										SE("DDERR_NOEMULATION",
																											 "Software emulation is not available.");
																										return err;
																									case -0x7789fdca:
																										SE("DDERR_REGIONTOOSMALL",
																																																							
																									"The region passed to the\nIDirectDrawClipper::GetClipList\nmethod is too small."
																									);
																									return err;
																									case -0x7789fdc9:
																										SE("DDERR_CLIPPERISUSINGHWND",
																																																							
																									"An attempt was made to set a clip list for a\nDirectDrawClipper object that is already monitoring\na window handle."
																									);
																									return err;
																									case -0x7789fdc8:
																										SE("DDERR_NOCLIPPERATTACHED",
																																																							
																									"No DirectDrawClipper object is attached\nto the surface object."
																									);
																									return err;
																									case -0x7789fdc7:
																										SE("DDERR_NOHWND",
																																																							
																									"Clipper notification requires a window handle,\nor no window handle has been previously set as\nthe cooperative level window handle."
																									);
																									return err;
																									case -0x7789fdc6:
																										SE("DDERR_HWNDSUBCLASSED",
																																																							
																									"DirectDraw is prevented from restoring state\nbecause the DirectDraw cooperative level window\nhandle has been subclassed."
																									);
																									return err;
																									case -0x7789fdc5:
																										SE("DDERR_HWNDALREADYSET",
																																																							
																									"The DirectDraw cooperative level window handle\nhas already been set. It cannot be reset while the process\nhas surfaces or palettes created."
																									);
																									return err;
																									case -0x7789fdc4:
																										SE("DDERR_NOPALETTEATTACHED",
																																																							
																									"No palette object is attached to this surface.");
																									return err;
																									case -0x7789fdc3:
																										SE("DDERR_NOPALETTEHW",
																																																							
																									"There is no hardware support for 16- or 256-color palettes."
																									);
																									return err;
																									case -0x7789fdc2:
																										SE("DDERR_BLTFASTCANTCLIP",
																																																							
																									"A DirectDrawClipper object is attached to a source\nsurface that has passed into a call to the\nIDirectDrawSurface3::BltFast method."
																									);
																									return err;
																									case -0x7789fdc1:
																										SE("DDERR_NOBLTHW",
																											 "No blitter hardware is present.");
																										return err;
																									case -0x7789fdc0:
																										SE("DDERR_NODDROPSHW",
																																																							
																									"No DirectDraw raster operation (ROP) hardware is available."
																									);
																									return err;
																									case -0x7789fdbf:
																										SE("DDERR_OVERLAYNOTVISIBLE",
																																																							
																									"The IDirectDrawSurface3::GetOverlayPosition method\nis called on a hidden overlay."
																									);
																									return err;
																									case -0x7789fdbe:
																										SE("DDERR_NOOVERLAYDEST",
																																																							
																									"The IDirectDrawSurface3::GetOverlayPosition method is called\non an overlay that the IDirectDrawSurface3::UpdateOverlay method\nhas not been called on to establish a destination."
																									);
																									return err;
																									case -0x7789fdbd:
																										SE("DDERR_INVALIDPOSITION",
																																																							
																									"The position of the overlay on the destination is no longer legal."
																									);
																									return err;
																									case -0x7789fdbc:
																										SE("DDERR_NOTAOVERLAYSURFACE",
																																																							
																									"An overlay component is called for a non-overlay surface."
																									);
																									return err;
																									case -0x7789fdbb:
																										SE("DDERR_EXCLUSIVEMODEALREADYSET",
																																																							
																									"An attempt was made to set the cooperative level\nwhen it was already set to exclusive."
																									);
																									return err;
																									case -0x7789fdba:
																										SE("DDERR_NOTFLIPPABLE",
																																																							
																									"An attempt has been made to flip\na surface that cannot be flipped."
																									);
																									return err;
																									case -0x7789fdb9:
																										SE("DDERR_CANTDUPLICATE",
																																																							
																									"Primary and 3-D surfaces, or surfaces that\nare implicitly created, cannot be duplicated."
																									);
																									return err;
																									case -0x7789fdb8:
																										SE("DDERR_NOTLOCKED",
																																																							
																									"An attempt is made to unlock a\nsurface that was not locked."
																									);
																									return err;
																									case -0x7789fdb7:
																										SE("DDERR_CANTCREATEDC",
																																																							
																									"Windows cannot create any more device\ncontexts (DCs)."
																									);
																									return err;
																									case -0x7789fdb6:
																										SE("DDERR_NODC",
																																																							
																									"No DC has ever been created for this surface.");
																									return err;
																									case -0x7789fdb5:
																										SE("DDERR_WRONGMODE",
																																																							
																									"This surface cannot be restored because it\nwas created in a different mode."
																									);
																									return err;
																									case -0x7789fdb4:
																										SE("DDERR_IMPLICITLYCREATED",
																																																							
																									"The surface cannot be restored because\nit is an implicitly created surface."
																									);
																									return err;
																									case -0x7789fdb3:
																										SE("DDERR_NOTPALETTIZED",
																																																							
																									"The surface being used is not a\npalette-based surface."
																									);
																									return err;
																									case -0x7789fdb2:
																										SE("DDERR_UNSUPPORTEDMODE",
																																																							
																									"The display is currently in\nan unsupported mode."
																									);
																									return err;
																									case -0x7789fdb1:
																										SE("DDERR_NOMIPMAPHW",
																																																							
																									"The operation cannot be carried out because no mipmap\ntexture mapping hardware is present or available."
																									);
																									return err;
																									case -0x7789fdb0:
																										SE("DDERR_INVALIDSURFACETYPE",
																																																							
																									"The requested operation could not be performed\nbecause the surface was of the wrong type."
																									);
																									return err;
																									case -0x7789fda8:
																										SE("DDERR_NOOPTIMIZEH",
																																																							
																									"The device does not support optimized surfaces");
																									return err;
																									case -0x7789fda7:
																										SE("DDERR_NOTLOADE",
																																																							
																									"The surface is an optimized surface,\nbut it has not yet been allocated any memory"
																									);
																									return err;
																									case -0x7789fd94:
																										SE("DDERR_DCALREADYCREATED",
																																																							
																									"A device context (DC) has already been returned\nfor this surface. Only one DC can be retrieved for each surface."
																									);
																									return err;
																									}
																									}
																									}
																									else {
																										if (err < -0x7789fd6b) {
																											if (err == -0x7789fd6c) {
																												SE("DDERR_CANTPAGEUNLOCK",
																																																											
																									"An attempt to page unlock a surface failed.\nPage unlock will not work on a display-memory\nsurface or an emulated primary surface."
																									);
																									return -0x7789fd6c;
																									}
																									if (err == -0x7789fd80) {
																										SE("DDERR_CANTPAGELOCK",
																																																							
																									"An attempt to page lock a surface failed.\nPage lock will not work on a display-memory surface or\nan emulated primary surface."
																									);
																									return -0x7789fd80;
																									}
																									}
																									else {
																										if (err < -0x7789fd4d) {
																											if (err == -0x7789fd4e) {
																												SE("DDERR_MOREDAT",
																																																											
																									"There is more data available than the\nspecified buffer size can hold"
																									);
																									return -0x7789fd4e;
																									}
																									if (err == -0x7789fd58) {
																										SE("DDERR_NOTPAGELOCKED",
																																																							
																									"An attempt is made to page unlock a\nsurface with no outstanding page locks."
																									);
																									return -0x7789fd58;
																									}
																									}
																									else {
																										if (err == -0x7789fd49) {
																											SE("DDERR_VIDEONOTACTIV",
																												 "The video port is not active");
																											return -0x7789fd49;
																										}
																										if (err == -0x7789fd45) {
																											SE("DDERR_DEVICEDOESNTOWNSURFAC",
																																																									
																									"Surfaces created by one direct draw device cannot\nbe used directly by another direct draw device"
																									);
																									return -0x7789fd45;
																									}
																									if (err == 0) {
																										SE("DD_OK","The request completed successfully."
																											);
																										return 0;
																									}
																									}
																									}
																									}
																									}
																									}
																									}
																									}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		break;
	case 4:
		SE("Unknown","Error handling is unsupported in this module");
	case 5:
		SE("Unknown","Error handling is unsupported in this module");
	case 6:
		SE("Unknown","Error handling is unsupported in this module");
	case 1:
		if (err < 1) {
			if (err == 0) {
				SE("D3DRM_OK","No error.");
				return 0;
			}
			if (true) {
				switch(err) {
				case -0x7789fcf3:
					SE("D3DRMERR_BADOBJECT","Object expected in argument.");
					return err;
				case -0x7789fcf2:
					SE("D3DRMERR_BADTYPE","Bad argument type passed.");
					return err;
				case -0x7789fcf1:
					SE("D3DRMERR_BADALLOC","Out of memory.");
					return err;
				case -0x7789fcf0:
					SE("D3DRMERR_FACEUSED","Face already used in a mesh.");
					return err;
				case -0x7789fcef:
					SE("D3DRMERR_NOTFOUND","Object not found in specified place.");
					return err;
				case -0x7789fcee:
					SE("D3DRMERR_NOTDONEYET","Unimplemented.");
					return err;
				case -0x7789fced:
					SE("D3DRMERR_FILENOTFOUND","File cannot be opened.");
					return err;
				case -0x7789fcec:
					SE("D3DRMERR_BADFILE","Data file is corrupt.");
					return err;
				case -0x7789fceb:
					SE("D3DRMERR_BADDEVICE","Device is not compatible with renderer.");
					return err;
				case -0x7789fcea:
					SE("D3DRMERR_BADVALUE","Bad argument value passed.");
					return err;
				case -0x7789fce9:
					SE("D3DRMERR_BADMAJORVERSION","Bad DLL major version.");
					return err;
				case -0x7789fce8:
					SE("D3DRMERR_BADMINORVERSION","Bad DLL minor version.");
					return err;
				case -0x7789fce7:
					SE("D3DRMERR_UNABLETOEXECUTE","Unable to carry out procedure.");
					return err;
				case -0x7789fce4:
					SE("D3DRMERR_PENDING",
						 "The data required to supply the requested\ninformation has not finished loading.");
					return err;
				case -0x7789fce3:
					SE("D3DRMERR_NOTENOUGHDATA",
						 "Not enough data has been loaded to\nperform the requested operation.");
					return err;
				case -0x7789fce2:
					SE("D3DRMERR_REQUESTTOOLARGE",
						 "An attempt was made to set a level\nof detail in a progressive mesh greater than the maximum available."
						);
					return err;
				case -0x7789fce1:
					SE("D3DRMERR_REQUESTTOOSMALL",
						 "An attempt was made to set the minimum\nrendering detail of a progressive mesh smaller than\nthe detail in the base mesh\n(the minimum for rendering)."
						);
					return err;
				case -0x7789fce0:
					SE("D3DRMERR_CONNECTIONLOST",
						 "Data connection was lost during a load,\nclone, or duplicate.");
					return err;
				case -0x7789fcdc:
					SE("D3DRMERR_BOXNOTSET",
						 "An attempt was made to access a bounding box\n(for example, with IDirect3DRMFrame2::GetBox)\nwhen no bounding box was set on the frame."
						);
					return err;
				case -0x7789fcdb:
					SE("D3DRMERR_BADPMDATA",
						 "The data in the X File is corrupted.\nThe conversion to a progressive mesh succeeded but\nproduced an invalid progressive mesh in\nthe X File."
						);
					return err;
				}
			}
		}
		break;
	case 7:
		SE("QUERY_INTERFACE","The requested interface could not be obtained");
		return err;
	default:
		SE("Unknown","An error in an unknown DirectX module/object was raised");
		return err;
	}
	SE("UNKNOWN ERROR","Invalid error code specified");
	return err;
}



void __cdecl lego::debug::Error_Initialise(void)
{
	globs::errorGlobs.dumpFile = NULL;
	globs::errorGlobs.loadLogFile = NULL;
	globs::errorGlobs.loadErrorLogFile = NULL;
	globs::errorGlobs.redundantLogFile = NULL;
	globs::errorGlobs.fullScreen = 0;
	return;
}



void __cdecl lego::debug::Error_FullScreen(BOOL on)
{
	globs::errorGlobs.fullScreen = on;
	return;
}



void __cdecl lego::debug::Error_CloseLog(void)
{
	if (globs::errorGlobs.dumpFile != NULL) {
		lego::file::File_Close(globs::errorGlobs.dumpFile);
	}
	if (globs::errorGlobs.loadLogFile != NULL) {
		lego::file::File_Close(globs::errorGlobs.loadLogFile);
	}
	if (globs::errorGlobs.loadErrorLogFile != NULL) {
		lego::file::File_Close(globs::errorGlobs.loadErrorLogFile);
	}
	globs::errorGlobs.dumpFile = NULL;
	globs::errorGlobs.loadLogFile = NULL;
	globs::errorGlobs.loadErrorLogFile = NULL;
	return;
}



void __cdecl lego::debug::Error_Shutdown(void)
{
	Error_CloseLog();
	globs::errorGlobs.redundantLogFile = lego::file::File_Open(globs::errorGlobs.redundantLogName,"w")
	;
	if (globs::errorGlobs.redundantLogFile != NULL) {
		lego::file::File_CheckRedundantFiles(globs::errorGlobs.loadLogName);
		lego::file::File_Close(globs::errorGlobs.redundantLogFile);
	}
	return;
}



char * __cdecl lego::registry::Registry_GetKeyFromPath(char *path,char *out_str)
{
	char cVar1;
	
	*out_str = '\0';
	cVar1 = *path;
	while ((cVar1 != '\0' && (cVar1 != '\\'))) {
		path = path + 1;
		*out_str = cVar1;
		out_str = out_str + 1;
		cVar1 = *path;
	}
	if (*path == '\\') {
		path = path + 1;
	}
	*out_str = '\0';
	return path;
}



BOOL __cdecl
lego::registry::Registry_GetValue
					(char *path,char *key,RegistryType dataType,char *out_data,uint dataSize)
{
	BOOL BVar1;
	
	BVar1 = Registry_GetValue_Recursive((HKEY)HKEY_LOCAL_MACHINE,path,key,dataType,out_data,dataSize);
	return BVar1;
}



BOOL __cdecl
lego::registry::Registry_GetValue_Recursive
					(HKEY parent,char *path,char *key,RegistryType dataType,char *out_data,uint dataSize)
{
	char *path_00;
	LSTATUS LVar1;
	HKEY pHVar2;
	HKEY local_68;
	char str [100];
	
	path_00 = Registry_GetKeyFromPath(path,str);
	if (str[0] != '\0') {
										// Open the key and recurse
		RegCreateKeyA(parent,str,(PHKEY)&local_68);
		if (local_68 == NULL) {
			return (BOOL)local_68;
		}
		pHVar2 = (HKEY)Registry_GetValue_Recursive(local_68,path_00,key,dataType,out_data,dataSize);
		RegCloseKey(local_68);
		return (BOOL)pHVar2;
	}
	path = NULL;
										// REG_NONE (0x0)
	if (dataType != REGISTRY_STRING_VALUE) {
										// REG_SZ (0x1)
		if (dataType != REGISTRY_DWORD_VALUE) {
			return (BOOL)NULL;
		}
		LVar1 = RegQueryValueExA(parent,key,NULL,(LPDWORD)&path,(LPBYTE)out_data,&dataSize);
		return (BOOL)(HKEY)(uint)(LVar1 == 0);
	}
	LVar1 = RegQueryValueExA(parent,key,NULL,(LPDWORD)&path,(LPBYTE)out_data,&dataSize);
	return (BOOL)(HKEY)(uint)(LVar1 == 0);
}



BOOL __cdecl lego::wad::GetFileName(FILE *f,char *out_str)
{
	char cVar1;
	int iVar2;
	
	iVar2 = std::fgetc(f);
	cVar1 = (char)iVar2;
	while (cVar1 != '\0') {
		*out_str = (char)iVar2;
		out_str = out_str + 1;
		iVar2 = std::fgetc(f);
		cVar1 = (char)iVar2;
	}
	*out_str = '\0';
	return TRUE;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe
// Open the wad and map in the file data.
// Returns a handle to the wad file.

int __cdecl lego::wad::Wad_Load(char *fName)
{
	char cVar1;
	int wadNo;
	FILE *stream;
	Wad *pWVar2;
	size_t sVar3;
	char **ppcVar4;
	BOOL BVar5;
	char *pcVar6;
	WadEntry *pWVar7;
	int iVar8;
	uint uVar9;
	uint uVar10;
	int iVar11;
	undefined4 *puVar12;
	char *pcVar13;
	undefined4 *puVar14;
	bool bVar15;
	size_t sVar16;
	FILE *pFVar17;
	char acStack4100 [4];
	char acStack4096 [4092];
	undefined4 uStack4;
	
	uStack4 = 0x48b7aa;
	iVar11 = 0;
	wadNo = Wad_GetFreeWadSlot();
	if (wadNo != -1) {
		stream = std::fopen(fName,"rb");
		pWVar2 = Wad_Get(wadNo);
		pWVar2->fWad = stream;
		if (stream != NULL) {
			pWVar2 = Wad_Get(wadNo);
			pWVar2->active = 1;
			sVar3 = std::fread(acStack4100,1,4,stream);
			if (sVar3 != 4) {
				std::fclose(stream);
				return -1;
			}
			iVar8 = 4;
			bVar15 = true;
			pcVar6 = acStack4100;
			pcVar13 = "WWAD";
			do {
				if (iVar8 == 0) break;
				iVar8 += -1;
				bVar15 = *pcVar6 == *pcVar13;
				pcVar6 = pcVar6 + 1;
				pcVar13 = pcVar13 + 1;
			} while (bVar15);
			if (!bVar15) {
				std::fclose(stream);
				return -1;
			}
			sVar16 = 4;
			sVar3 = 1;
			pFVar17 = stream;
			pWVar2 = Wad_Get(wadNo);
			sVar3 = std::fread(&pWVar2->numFiles,sVar3,sVar16,pFVar17);
			if (sVar3 != 4) {
				std::fclose(stream);
				return -1;
			}
			pWVar2 = Wad_Get(wadNo);
			ppcVar4 = (char **)std::malloc(pWVar2->numFiles << 2);
			pWVar2 = Wad_Get(wadNo);
			pWVar2->wadNames = ppcVar4;
			pWVar2 = Wad_Get(wadNo);
			ppcVar4 = (char **)std::malloc(pWVar2->numFiles << 2);
			pWVar2 = Wad_Get(wadNo);
			pWVar2->fileNames = ppcVar4;
			pWVar2 = Wad_Get(wadNo);
			if ((pWVar2->wadNames != NULL) && (pWVar2 = Wad_Get(wadNo), pWVar2->fileNames != NULL)) {
				pWVar2 = Wad_Get(wadNo);
				uVar9 = pWVar2->numFiles;
				pWVar2 = Wad_Get(wadNo);
				ppcVar4 = pWVar2->wadNames;
				for (uVar9 &= 0x3fffffff; uVar9 != 0; uVar9 -= 1) {
					*ppcVar4 = NULL;
					ppcVar4 = ppcVar4 + 1;
				}
				for (iVar8 = 0; iVar8 != 0; iVar8 += -1) {
					*(undefined *)ppcVar4 = 0;
					ppcVar4 = (char **)((int)ppcVar4 + 1);
				}
				pWVar2 = Wad_Get(wadNo);
				uVar9 = pWVar2->numFiles;
				pWVar2 = Wad_Get(wadNo);
				ppcVar4 = pWVar2->fileNames;
				for (uVar9 &= 0x3fffffff; uVar9 != 0; uVar9 -= 1) {
					*ppcVar4 = NULL;
					ppcVar4 = ppcVar4 + 1;
				}
				for (iVar8 = 0; iVar8 != 0; iVar8 += -1) {
					*(undefined *)ppcVar4 = 0;
					ppcVar4 = (char **)((int)ppcVar4 + 1);
				}
				pWVar2 = Wad_Get(wadNo);
				if (0 < pWVar2->numFiles) {
					do {
						BVar5 = GetFileName(stream,acStack4096);
						if (BVar5 == 0) {
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->wadNames != NULL) {
								iVar11 = 0;
								pWVar2 = Wad_Get(wadNo);
								if (0 < pWVar2->numFiles) {
									do {
										pWVar2 = Wad_Get(wadNo);
										if (pWVar2->wadNames[iVar11] != NULL) {
											pWVar2 = Wad_Get(wadNo);
											std::free(pWVar2->wadNames[iVar11]);
										}
										iVar11 += 1;
										pWVar2 = Wad_Get(wadNo);
									} while (iVar11 < pWVar2->numFiles);
								}
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->wadNames);
							}
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->fileNames != NULL) {
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->fileNames);
							}
							std::fclose(stream);
							return -1;
						}
						uVar9 = 0xffffffff;
						pcVar6 = acStack4096;
						do {
							if (uVar9 == 0) break;
							uVar9 -= 1;
							cVar1 = *pcVar6;
							pcVar6 = pcVar6 + 1;
						} while (cVar1 != '\0');
						pcVar6 = (char *)std::malloc(~uVar9);
						pWVar2 = Wad_Get(wadNo);
						pWVar2->wadNames[iVar11] = pcVar6;
						pWVar2 = Wad_Get(wadNo);
						uVar9 = 0xffffffff;
						pcVar6 = acStack4096;
						do {
							pcVar13 = pcVar6;
							if (uVar9 == 0) break;
							uVar9 -= 1;
							pcVar13 = pcVar6 + 1;
							cVar1 = *pcVar6;
							pcVar6 = pcVar13;
						} while (cVar1 != '\0');
						uVar9 = ~uVar9;
						puVar12 = (undefined4 *)(pcVar13 + -uVar9);
						puVar14 = (undefined4 *)pWVar2->wadNames[iVar11];
						for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 -= 1) {
							*puVar14 = *puVar12;
							puVar12 = puVar12 + 1;
							puVar14 = puVar14 + 1;
						}
						for (uVar9 &= 3; uVar9 != 0; uVar9 -= 1) {
							*(undefined *)puVar14 = *(undefined *)puVar12;
							puVar12 = (undefined4 *)((int)puVar12 + 1);
							puVar14 = (undefined4 *)((int)puVar14 + 1);
						}
						pWVar2 = Wad_Get(wadNo);
						lego::file::File_Error("%s\n",pWVar2->wadNames[iVar11]);
						iVar11 += 1;
						pWVar2 = Wad_Get(wadNo);
					} while (iVar11 < pWVar2->numFiles);
				}
				iVar11 = 0;
				pWVar2 = Wad_Get(wadNo);
				if (0 < pWVar2->numFiles) {
					do {
						BVar5 = GetFileName(stream,acStack4096);
						if (BVar5 == 0) {
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->fileNames != NULL) {
								iVar11 = 0;
								pWVar2 = Wad_Get(wadNo);
								if (0 < pWVar2->numFiles) {
									do {
										pWVar2 = Wad_Get(wadNo);
										if (pWVar2->wadNames[iVar11] != NULL) {
											pWVar2 = Wad_Get(wadNo);
											std::free(pWVar2->wadNames[iVar11]);
										}
										iVar11 += 1;
										pWVar2 = Wad_Get(wadNo);
									} while (iVar11 < pWVar2->numFiles);
								}
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->wadNames);
							}
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->fileNames != NULL) {
								iVar11 = 0;
								pWVar2 = Wad_Get(wadNo);
								if (0 < pWVar2->numFiles) {
									do {
										pWVar2 = Wad_Get(wadNo);
										if (pWVar2->fileNames[iVar11] != NULL) {
											pWVar2 = Wad_Get(wadNo);
											std::free(pWVar2->fileNames[iVar11]);
										}
										iVar11 += 1;
										pWVar2 = Wad_Get(wadNo);
									} while (iVar11 < pWVar2->numFiles);
								}
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->fileNames);
								std::fclose(stream);
								return -1;
							}
							goto LAB_0048be6d;
						}
						uVar9 = 0xffffffff;
						pcVar6 = acStack4096;
						do {
							if (uVar9 == 0) break;
							uVar9 -= 1;
							cVar1 = *pcVar6;
							pcVar6 = pcVar6 + 1;
						} while (cVar1 != '\0');
						pcVar6 = (char *)std::malloc(~uVar9);
						pWVar2 = Wad_Get(wadNo);
						pWVar2->fileNames[iVar11] = pcVar6;
						pWVar2 = Wad_Get(wadNo);
						uVar9 = 0xffffffff;
						pcVar6 = acStack4096;
						do {
							pcVar13 = pcVar6;
							if (uVar9 == 0) break;
							uVar9 -= 1;
							pcVar13 = pcVar6 + 1;
							cVar1 = *pcVar6;
							pcVar6 = pcVar13;
						} while (cVar1 != '\0');
						uVar9 = ~uVar9;
						puVar12 = (undefined4 *)(pcVar13 + -uVar9);
						puVar14 = (undefined4 *)pWVar2->fileNames[iVar11];
						for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 -= 1) {
							*puVar14 = *puVar12;
							puVar12 = puVar12 + 1;
							puVar14 = puVar14 + 1;
						}
						for (uVar9 &= 3; uVar9 != 0; uVar9 -= 1) {
							*(undefined *)puVar14 = *(undefined *)puVar12;
							puVar12 = (undefined4 *)((int)puVar12 + 1);
							puVar14 = (undefined4 *)((int)puVar14 + 1);
						}
						pWVar2 = Wad_Get(wadNo);
						lego::file::File_Error("%s\n",pWVar2->fileNames[iVar11]);
						iVar11 += 1;
						pWVar2 = Wad_Get(wadNo);
					} while (iVar11 < pWVar2->numFiles);
				}
				pWVar2 = Wad_Get(wadNo);
				pWVar7 = (WadEntry *)std::malloc(pWVar2->numFiles << 4);
				pWVar2 = Wad_Get(wadNo);
				pWVar2->wadEntries = pWVar7;
				pWVar2 = Wad_Get(wadNo);
				if (pWVar2->wadEntries == NULL) {
					pWVar2 = Wad_Get(wadNo);
					if (pWVar2->fileNames != NULL) {
						iVar11 = 0;
						pWVar2 = Wad_Get(wadNo);
						if (0 < pWVar2->numFiles) {
							do {
								pWVar2 = Wad_Get(wadNo);
								if (pWVar2->wadNames[iVar11] != NULL) {
									pWVar2 = Wad_Get(wadNo);
									std::free(pWVar2->wadNames[iVar11]);
								}
								iVar11 += 1;
								pWVar2 = Wad_Get(wadNo);
							} while (iVar11 < pWVar2->numFiles);
						}
						pWVar2 = Wad_Get(wadNo);
						std::free(pWVar2->wadNames);
					}
					pWVar2 = Wad_Get(wadNo);
					if (pWVar2->fileNames != NULL) {
						iVar11 = 0;
						pWVar2 = Wad_Get(wadNo);
						if (0 < pWVar2->numFiles) {
							do {
								pWVar2 = Wad_Get(wadNo);
								if (pWVar2->fileNames[iVar11] != NULL) {
									pWVar2 = Wad_Get(wadNo);
									std::free(pWVar2->fileNames[iVar11]);
								}
								iVar11 += 1;
								pWVar2 = Wad_Get(wadNo);
							} while (iVar11 < pWVar2->numFiles);
						}
						pWVar2 = Wad_Get(wadNo);
						std::free(pWVar2->fileNames);
					}
					std::fclose(stream);
					return -1;
				}
				pFVar17 = stream;
				pWVar2 = Wad_Get(wadNo);
				sVar3 = pWVar2->numFiles << 4;
				sVar16 = 1;
				pWVar2 = Wad_Get(wadNo);
				sVar3 = std::fread(pWVar2->wadEntries,sVar16,sVar3,pFVar17);
				pWVar2 = Wad_Get(wadNo);
				if (sVar3 == pWVar2->numFiles << 4) {
					return wadNo;
				}
				pWVar2 = Wad_Get(wadNo);
				if (pWVar2->fileNames != NULL) {
					iVar11 = 0;
					pWVar2 = Wad_Get(wadNo);
					if (0 < pWVar2->numFiles) {
						do {
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->wadNames[iVar11] != NULL) {
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->wadNames[iVar11]);
							}
							iVar11 += 1;
							pWVar2 = Wad_Get(wadNo);
						} while (iVar11 < pWVar2->numFiles);
					}
					pWVar2 = Wad_Get(wadNo);
					std::free(pWVar2->wadNames);
				}
				pWVar2 = Wad_Get(wadNo);
				if (pWVar2->fileNames != NULL) {
					iVar11 = 0;
					pWVar2 = Wad_Get(wadNo);
					if (0 < pWVar2->numFiles) {
						do {
							pWVar2 = Wad_Get(wadNo);
							if (pWVar2->fileNames[iVar11] != NULL) {
								pWVar2 = Wad_Get(wadNo);
								std::free(pWVar2->fileNames[iVar11]);
							}
							iVar11 += 1;
							pWVar2 = Wad_Get(wadNo);
						} while (iVar11 < pWVar2->numFiles);
					}
					pWVar2 = Wad_Get(wadNo);
					std::free(pWVar2->fileNames);
				}
				pWVar2 = Wad_Get(wadNo);
				if (pWVar2->wadEntries != NULL) {
					pWVar2 = Wad_Get(wadNo);
					std::free(pWVar2->wadEntries);
				}
LAB_0048be6d:
				std::fclose(stream);
				return -1;
			}
			std::fclose(stream);
			pWVar2 = Wad_Get(wadNo);
			if (pWVar2->wadNames != NULL) {
				pWVar2 = Wad_Get(wadNo);
				std::free(pWVar2->wadNames);
			}
			pWVar2 = Wad_Get(wadNo);
			if (pWVar2->fileNames != NULL) {
				pWVar2 = Wad_Get(wadNo);
				std::free(pWVar2->fileNames);
			}
		}
	}
	return -1;
}



Wad * __cdecl lego::wad::Wad_Get(int wadNo)
{
	return globs::wadGlobs.wads + wadNo;
}



int __cdecl lego::wad::Wad_FileLength(int wadNo,int fileNo)
{
	Wad *pWVar1;
	
	pWVar1 = Wad_Get(wadNo);
	return pWVar1->wadEntries[fileNo].decompressedLength;
}



int __cdecl lego::wad::Wad_FileCompressedLength(int wadNo,int fileNo)
{
	Wad *pWVar1;
	
	pWVar1 = Wad_Get(wadNo);
	return pWVar1->wadEntries[fileNo].fileLength;
}



int __cdecl lego::wad::Wad_FindFreeFileHandle(void)
{
	int iVar1;
	int *piVar2;
	
	iVar1 = 0;
	piVar2 = &globs::wadGlobs.fileHandles[0].active;
	do {
		if (*piVar2 == 0) {
			return iVar1;
		}
		piVar2 = piVar2 + 4;
		iVar1 += 1;
	} while ((int)piVar2 < 0x576ce4);
	return -1;
}



int __cdecl lego::wad::Wad_IsFileInWad(char *fName,int opt_wadNo)
{
	Wad *pWVar1;
	int iVar2;
	int iVar3;
	
	if (opt_wadNo != -1) {
		iVar3 = _Wad_IsFileInWad(fName,opt_wadNo);
		return iVar3;
	}
	iVar3 = 9;
	while ((pWVar1 = Wad_Get(iVar3), pWVar1->active == 0 ||
				 (iVar2 = _Wad_IsFileInWad(fName,iVar3), iVar2 == -1))) {
		iVar3 += -1;
		if (iVar3 < 0) {
			return -1;
		}
	}
	return iVar2;
}



int __cdecl lego::wad::_Wad_IsFileInWad(char *fName,int wadNo)
{
	int iVar1;
	int iVar2;
	
	iVar2 = 0;
	if (globs::wadGlobs.wads[wadNo].numFiles < 1) {
		return -1;
	}
	do {
		iVar1 = std::_stricmp(globs::wadGlobs.wads[wadNo].wadNames[iVar2],fName);
		if (iVar1 == 0) {
			return iVar2;
		}
		iVar2 += 1;
	} while (iVar2 < globs::wadGlobs.wads[wadNo].numFiles);
	return -1;
}



int __cdecl lego::wad::Wad_GetFreeWadSlot(void)
{
	int *piVar1;
	int iVar2;
	int iVar3;
	Wad *pWVar4;
	
	iVar3 = 0;
	piVar1 = &globs::wadGlobs.wads[0].active;
	do {
		if (*piVar1 == 0) {
			pWVar4 = globs::wadGlobs.wads + iVar3;
			for (iVar2 = 9; iVar2 != 0; iVar2 += -1) {
				pWVar4->fName = NULL;
				pWVar4 = (Wad *)&pWVar4->active;
			}
			return iVar3;
		}
		piVar1 = piVar1 + 9;
		iVar3 += 1;
	} while ((int)piVar1 < 0x57666c);
	return -1;
}



int __cdecl lego::wad::_Wad_FileOpen(char *fName,int wadNo)
{
	int iVar1;
	int fileNo;
	uint length;
	void *out_buffer;
	Wad *pWVar2;
	size_t sVar3;
	int offset;
	size_t count;
	int origin;
	FILE *stream;
	int wadNo_00;
	
	iVar1 = Wad_FindFreeFileHandle();
	wadNo_00 = wadNo;
	if (iVar1 == -1) {
		return -1;
	}
	fileNo = Wad_IsFileInWad(fName,wadNo);
	if (fileNo == -1) {
		return -1;
	}
	length = Wad_FileCompressedLength(wadNo_00,fileNo);
	out_buffer = std::malloc(length);
	if (out_buffer == NULL) {
		return -1;
	}
	origin = 0;
	pWVar2 = Wad_Get(wadNo_00);
	offset = pWVar2->wadEntries[fileNo].addr;
	pWVar2 = Wad_Get(wadNo_00);
	std::fseek(pWVar2->fWad,offset,origin);
	pWVar2 = Wad_Get(wadNo_00);
	stream = pWVar2->fWad;
	count = 1;
	sVar3 = Wad_FileCompressedLength(wadNo_00,fileNo);
	sVar3 = std::fread(out_buffer,sVar3,count,stream);
	if (sVar3 != 1) {
		std::free(out_buffer);
		return -1;
	}
	pWVar2 = Wad_Get(wadNo_00);
	wadNo = (int)out_buffer;
	if ((*(byte *)&pWVar2->wadEntries[fileNo].compression & 2) != 0) {
		wadNo = 0;
		rnc::RNC_Uncompress(out_buffer,(void **)&wadNo);
		std::free(out_buffer);
	}
	globs::wadGlobs.fileHandles[iVar1].data = (void *)wadNo;
	globs::wadGlobs.fileHandles[iVar1].active = 1;
	globs::wadGlobs.fileHandles[iVar1].wadFile = wadNo_00;
	globs::wadGlobs.fileHandles[iVar1].indexOfFileInWad = fileNo;
	return iVar1;
}



int __cdecl lego::wad::Wad_FileOpen(char *fName,int opt_wadNo)
{
	Wad *pWVar1;
	int iVar2;
	int iVar3;
	
	if (opt_wadNo != -1) {
		iVar3 = _Wad_FileOpen(fName,opt_wadNo);
		return iVar3;
	}
	iVar3 = 9;
	while ((pWVar1 = Wad_Get(iVar3), pWVar1->active == 0 ||
				 (iVar2 = _Wad_FileOpen(fName,iVar3), iVar2 == -1))) {
		iVar3 += -1;
		if (iVar3 < 0) {
			return -1;
		}
	}
	return iVar2;
}



void __cdecl lego::wad::Wad_FileClose(int handle)
{
	if (globs::wadGlobs.fileHandles[handle].active != 0) {
		std::free(globs::wadGlobs.fileHandles[handle].data);
		globs::wadGlobs.fileHandles[handle].active = 0;
	}
	return;
}



void * __cdecl lego::wad::Wad_FileGetPointer(int handle)
{
	if (globs::wadGlobs.fileHandles[handle].active != 0) {
		return globs::wadGlobs.fileHandles[handle].data;
	}
	return NULL;
}



int __cdecl lego::wad::Wad_hLength(int handle)
{
	int iVar1;
	
	iVar1 = Wad_FileLength(globs::wadGlobs.fileHandles[handle].wadFile,
												 globs::wadGlobs.fileHandles[handle].indexOfFileInWad);
	return iVar1;
}



void * __cdecl lego::wad::Wad_hData(int handle)
{
	void *pvVar1;
	
	pvVar1 = Wad_FileGetPointer(handle);
	return pvVar1;
}



char * __cdecl lego::lw::lwExtractString(char *str1,char *str2,uint *out_pos,uint *out_len)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	size_t _MaxCount;
	char *pcVar5;
	
	uVar3 = 0xffffffff;
	pcVar5 = str1;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	uVar4 = 0xffffffff;
	pcVar5 = str2;
	do {
		if (uVar4 == 0) break;
		uVar4 -= 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	_MaxCount = ~uVar4 - 1;
	if (((uVar3 != 1) && (_MaxCount != 0)) && (uVar4 = 0, uVar3 != 1)) {
		do {
			iVar2 = std::_strnicmp(str1,str2,_MaxCount);
			if (iVar2 == 0) {
				if (out_pos != NULL) {
					*out_pos = uVar4;
				}
				if (out_len != NULL) {
					*out_len = _MaxCount;
				}
				return str1;
			}
			uVar4 += 1;
			str1 = str1 + 1;
		} while (uVar4 < uVar3 - 1);
		return NULL;
	}
	return NULL;
}



char * __cdecl lego::lw::stringAlloc(char *str)
{
	char cVar1;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	uVar3 = 0xffffffff;
	pcVar6 = str;
	do {
		if (uVar3 == 0) break;
		uVar3 -= 1;
		cVar1 = *pcVar6;
		pcVar6 = pcVar6 + 1;
	} while (cVar1 != '\0');
	uVar4 = ~uVar3 + (~uVar3 & 1);
	puVar2 = (undefined4 *)std::malloc(uVar4);
	puVar5 = puVar2;
	for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 -= 1) {
		*puVar5 = 0;
		puVar5 = puVar5 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar5 = 0;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
	}
	uVar3 = 0xffffffff;
	do {
		pcVar6 = str;
		if (uVar3 == 0) break;
		uVar3 -= 1;
		pcVar6 = str + 1;
		cVar1 = *str;
		str = pcVar6;
	} while (cVar1 != '\0');
	uVar3 = ~uVar3;
	puVar5 = (undefined4 *)(pcVar6 + -uVar3);
	puVar7 = puVar2;
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
		*puVar7 = *puVar5;
		puVar5 = puVar5 + 1;
		puVar7 = puVar7 + 1;
	}
	for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)puVar7 = *(undefined *)puVar5;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
		puVar7 = (undefined4 *)((int)puVar7 + 1);
	}
	return (char *)puVar2;
}



// Defaults to "PLANAR" on failure to parse

uint __cdecl lego::lw::texMapType(char *shapeName)
{
	char cVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	char **ppcVar5;
	char *pcVar6;
	char *tTypes [3];
	
	tTypes[0] = "PLANAR";
	tTypes[1] = "CYLINDRICAL";
	tTypes[2] = "SPHERICAL";
	uVar4 = 0;
	ppcVar5 = tTypes;
	do {
		uVar3 = 0xffffffff;
		pcVar6 = *ppcVar5;
		do {
			if (uVar3 == 0) break;
			uVar3 -= 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
		iVar2 = std::_strnicmp(shapeName,*ppcVar5,~uVar3 - 1);
		if (iVar2 == 0) break;
		uVar4 += 1;
		ppcVar5 = ppcVar5 + 1;
	} while (uVar4 < 3);
	if (uVar4 == 3) {
		uVar4 = 0;
	}
	return uVar4;
}



void __cdecl lego::lw::surfFree(LWSURFACE *srf,BOOL flag)
{
	if (srf->srfName != NULL) {
		std::free(srf->srfName);
	}
	if (srf->srfPath != NULL) {
		std::free(srf->srfPath);
	}
	if (srf->srfNextSurf != NULL) {
		surfFree(srf->srfNextSurf,1);
	}
	if (flag != 0) {
		std::free(srf);
	}
	return;
}



BOOL __cdecl lego::lw::LWD3D(byte **p,float *f)
{
	byte *pbVar1;
	
	*(byte *)((int)f + 3) = **p;
	pbVar1 = *p;
	*p = pbVar1 + 1;
	*(byte *)((int)f + 2) = pbVar1[1];
	pbVar1 = *p;
	*p = pbVar1 + 1;
	*(byte *)((int)f + 1) = pbVar1[1];
	pbVar1 = *p;
	*p = pbVar1 + 1;
	*(byte *)f = pbVar1[1];
	*p = *p + 1;
	return TRUE;
}



// WARNING: Could not reconcile some variable overlaps

BOOL __cdecl lego::lw::PNTSprc(File *file,LWSIZE *sizeData,int csize,float **verts,BOOL dflag)
{
	float *pfVar1;
	int iVar2;
	float local_120;
	float fStack284;
	undefined uStack280;
	undefined local_117;
	undefined2 uStack278;
	byte *local_114;
	byte *local_110;
	uint local_10c;
	char local_108 [260];
	
	iVar2 = 0;
	local_120 = (float)(uint)local_120._0_1_;
	fStack284 = 0.0;
	uStack280 = 0;
	local_117 = 0;
	local_114 = (byte *)std::malloc(csize + 0x10);
	local_110 = local_114;
	lego::file::File_Read(local_114,csize,1,file);
	sizeData->lwVertCount = csize / 0xc;
	if (verts != NULL) {
		pfVar1 = (float *)std::malloc(csize + 4);
		*verts = pfVar1;
		if (0 < csize) {
			local_10c = (csize + 0xbU) / 0xc;
			do {
				LWD3D(&local_114,&local_120);
				LWD3D(&local_114,&fStack284);
				LWD3D(&local_114,(float *)&uStack280);
				*pfVar1 = local_120;
				pfVar1[1] = fStack284;
				pfVar1[2] = (float)CONCAT22(uStack278,CONCAT11(local_117,uStack280));
				pfVar1 = pfVar1 + 3;
				if (dflag != 0) {
					std::sprintf(local_108,"Point %d > %f %f %f\n",iVar2,(double)local_120,(double)fStack284);
				}
				iVar2 += 1;
				local_10c -= 1;
			} while (local_10c != 0);
		}
	}
	std::free(local_110);
	return TRUE;
}



BOOL __cdecl lego::lw::CRVSprc(File *file,int csize,BOOL dflag)
{
	ushort uVar1;
	ushort *out_buffer;
	uint uVar2;
	ushort *puVar3;
	int iVar4;
	
	out_buffer = (ushort *)std::malloc(csize + 0x10);
	lego::file::File_Read(out_buffer,csize,1,file);
	puVar3 = out_buffer;
	if (0 < csize) {
		do {
			uVar1 = *puVar3 * 0x100 + (*puVar3 >> 8);
			puVar3 = puVar3 + 1;
			iVar4 = csize + -2;
			if (uVar1 != 0) {
				uVar2 = (uint)uVar1;
				puVar3 = puVar3 + uVar2;
				do {
					iVar4 += -2;
					uVar2 -= 1;
				} while (uVar2 != 0);
			}
			csize = iVar4 + -4;
			puVar3 = puVar3 + 2;
		} while (0 < csize);
	}
	std::free(out_buffer);
	return TRUE;
}



BOOL __cdecl lego::lw::POLSprc(File *file,LWSIZE *sizeData,LWPOLY **polys,int csize,BOOL dflag)
{
	char cVar1;
	ushort *out_buffer;
	LWPOLY *pLVar2;
	ushort *puVar3;
	uint uVar4;
	int iVar5;
	uint uVar6;
	ushort uVar7;
	ushort uVar8;
	LWPOLY *pLVar9;
	undefined4 *puVar10;
	LWPOLY *pLVar11;
	char *pcVar12;
	char *pcVar13;
	char *pcVar14;
	undefined4 *puVar15;
	ushort *local_150;
	uint local_14c;
	char local_140 [64];
	char local_100 [256];
	
	out_buffer = (ushort *)std::malloc(csize + 0x10);
	lego::file::File_Read(out_buffer,csize,1,file);
	uVar8 = 0;
	local_150 = out_buffer;
	uVar7 = 0;
	if (0 < csize) {
		do {
			uVar7 = *local_150 * 0x100 + (*local_150 >> 8);
			local_150 = local_150 + 1;
			csize += -2;
			if (polys != NULL) {
				if (uVar8 == 0) {
					pLVar2 = (LWPOLY *)std::malloc(0xc);
					*polys = pLVar2;
				}
				else {
					uVar4 = (uint)uVar8;
					pLVar2 = (LWPOLY *)std::malloc((uVar4 + 1) * 0xc);
					pLVar9 = *polys;
					pLVar11 = pLVar2;
					for (iVar5 = uVar4 * 3; iVar5 != 0; iVar5 += -1) {
						pLVar11->plyCount = pLVar9->plyCount;
						pLVar9 = (LWPOLY *)&pLVar9->plySurface;
						pLVar11 = (LWPOLY *)&pLVar11->plySurface;
					}
					for (iVar5 = 0; iVar5 != 0; iVar5 += -1) {
						*(undefined *)&pLVar11->plyCount = *(undefined *)&pLVar9->plyCount;
						pLVar9 = (LWPOLY *)((int)&pLVar9->plyCount + 1);
						pLVar11 = (LWPOLY *)((int)&pLVar11->plyCount + 1);
					}
					std::free(*polys);
					*polys = pLVar2;
					pLVar2 = pLVar2 + uVar4;
				}
				local_14c = (uint)uVar7;
				puVar3 = (ushort *)std::malloc(local_14c * 2);
				if (dflag != 0) {
					std::sprintf(local_100,"Poly %d, Vertex Count %d > ",(uint)uVar8,local_14c);
				}
				pLVar2->plyCount = local_14c;
				pLVar2->plyData = puVar3;
				if (uVar7 != 0) {
					do {
						uVar7 = *local_150 * 0x100 + (*local_150 >> 8);
						if (dflag != 0) {
							std::sprintf(local_140,"%d ",(uint)uVar7);
							uVar4 = 0xffffffff;
							pcVar13 = local_140;
							do {
								pcVar12 = pcVar13;
								if (uVar4 == 0) break;
								uVar4 -= 1;
								pcVar12 = pcVar13 + 1;
								cVar1 = *pcVar13;
								pcVar13 = pcVar12;
							} while (cVar1 != '\0');
							uVar4 = ~uVar4;
							iVar5 = -1;
							pcVar13 = local_100;
							do {
								pcVar14 = pcVar13;
								if (iVar5 == 0) break;
								iVar5 += -1;
								pcVar14 = pcVar13 + 1;
								cVar1 = *pcVar13;
								pcVar13 = pcVar14;
							} while (cVar1 != '\0');
							puVar10 = (undefined4 *)(pcVar12 + -uVar4);
							puVar15 = (undefined4 *)(pcVar14 + -1);
							for (uVar6 = uVar4 >> 2; uVar6 != 0; uVar6 -= 1) {
								*puVar15 = *puVar10;
								puVar10 = puVar10 + 1;
								puVar15 = puVar15 + 1;
							}
							for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
								*(undefined *)puVar15 = *(undefined *)puVar10;
								puVar10 = (undefined4 *)((int)puVar10 + 1);
								puVar15 = (undefined4 *)((int)puVar15 + 1);
							}
						}
						*puVar3 = uVar7;
						puVar3 = puVar3 + 1;
						local_150 = local_150 + 1;
						csize += -2;
						local_14c -= 1;
					} while (local_14c != 0);
				}
				uVar4 = (uint)(byte)*local_150 * 0x100 + -1 + (uint)(*local_150 >> 8) & 0xffff;
				pLVar2->plySurface = uVar4;
				if (dflag != 0) {
					std::sprintf(local_140,"Surface :- %d\n",uVar4);
					uVar4 = 0xffffffff;
					pcVar13 = local_140;
					do {
						pcVar12 = pcVar13;
						if (uVar4 == 0) break;
						uVar4 -= 1;
						pcVar12 = pcVar13 + 1;
						cVar1 = *pcVar13;
						pcVar13 = pcVar12;
					} while (cVar1 != '\0');
					uVar4 = ~uVar4;
					iVar5 = -1;
					pcVar13 = local_100;
					do {
						pcVar14 = pcVar13;
						if (iVar5 == 0) break;
						iVar5 += -1;
						pcVar14 = pcVar13 + 1;
						cVar1 = *pcVar13;
						pcVar13 = pcVar14;
					} while (cVar1 != '\0');
					puVar10 = (undefined4 *)(pcVar12 + -uVar4);
					puVar15 = (undefined4 *)(pcVar14 + -1);
					for (uVar6 = uVar4 >> 2; uVar6 != 0; uVar6 -= 1) {
						*puVar15 = *puVar10;
						puVar10 = puVar10 + 1;
						puVar15 = puVar15 + 1;
					}
					for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
						*(undefined *)puVar15 = *(undefined *)puVar10;
						puVar10 = (undefined4 *)((int)puVar10 + 1);
						puVar15 = (undefined4 *)((int)puVar15 + 1);
					}
				}
			}
			csize += -2;
			uVar8 += 1;
			local_150 = local_150 + 1;
			uVar7 = uVar8;
		} while (0 < csize);
	}
	sizeData->lwPolyCount = (uint)uVar7;
	std::free(out_buffer);
	return TRUE;
}



BOOL __cdecl
lego::lw::SRFSprc(File *file,LWSIZE *sizeData,LWSURFLIST **srfl,int csize,uint *srflCount,BOOL dflag
								 )
{
	char cVar1;
	undefined4 *out_buffer;
	undefined4 *puVar2;
	char **ppcVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	uint uVar7;
	undefined4 *puVar8;
	char **ppcVar9;
	undefined4 *puVar10;
	undefined4 *puVar11;
	char **ppcVar12;
	uint local_224;
	LWSURFLIST *local_220;
	char local_200 [512];
	
	uVar7 = 0;
	local_224 = 0;
	out_buffer = (undefined4 *)std::malloc(csize + 0x10);
	lego::file::File_Read(out_buffer,csize,1,file);
	if (srfl != NULL) {
		local_220 = (LWSURFLIST *)std::malloc(8);
		local_220->srflCount = 0;
		local_220->srflName = NULL;
	}
	puVar10 = out_buffer;
	if (0 < csize) {
		do {
			if (dflag != 0) {
				std::sprintf(local_200,"Surface %d > %s\n",local_224,puVar10);
			}
			uVar4 = 0xffffffff;
			puVar8 = puVar10;
			do {
				if (uVar4 == 0) break;
				uVar4 -= 1;
				cVar1 = *(char *)puVar8;
				puVar8 = (undefined4 *)((int)puVar8 + 1);
			} while (cVar1 != '\0');
			uVar4 = ~uVar4;
			if ((uVar4 & 1) != 0) {
				uVar4 += 1;
			}
			if (srfl != NULL) {
				puVar2 = (undefined4 *)std::malloc(uVar4);
				ppcVar3 = (char **)std::malloc(uVar7 + 4);
				puVar8 = puVar10;
				puVar11 = puVar2;
				for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
					*puVar11 = *puVar8;
					puVar8 = puVar8 + 1;
					puVar11 = puVar11 + 1;
				}
				for (uVar5 = uVar4 & 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar11 = *(undefined *)puVar8;
					puVar8 = (undefined4 *)((int)puVar8 + 1);
					puVar11 = (undefined4 *)((int)puVar11 + 1);
				}
				if (uVar7 != 0) {
					ppcVar9 = local_220->srflName;
					ppcVar12 = ppcVar3;
					for (uVar5 = uVar7 >> 2; uVar5 != 0; uVar5 -= 1) {
						*ppcVar12 = *ppcVar9;
						ppcVar9 = ppcVar9 + 1;
						ppcVar12 = ppcVar12 + 1;
					}
					for (iVar6 = 0; iVar6 != 0; iVar6 += -1) {
						*(undefined *)ppcVar12 = *(undefined *)ppcVar9;
						ppcVar9 = (char **)((int)ppcVar9 + 1);
						ppcVar12 = (char **)((int)ppcVar12 + 1);
					}
					std::free(local_220->srflName);
				}
				*(undefined4 **)((int)ppcVar3 + uVar7) = puVar2;
				local_220->srflName = ppcVar3;
				*srfl = local_220;
				local_220->srflCount = local_224 + 1;
			}
			local_224 += 1;
			uVar7 += 4;
			*srflCount = local_224;
			puVar10 = (undefined4 *)((int)puVar10 + uVar4);
			csize -= uVar4;
		} while (0 < csize);
	}
	std::free(out_buffer);
	return TRUE;
}



// WARNING: Could not reconcile some variable overlaps

BOOL __cdecl lego::lw::SURFprc(File *file,LWSIZE *sizeData,LWSURFACE **surf,int csize,BOOL dflag)
{
	char cVar1;
	float fVar2;
	char *pcVar3;
	LWSURFACE *pLVar4;
	char *pcVar5;
	int iVar6;
	LWTEXMAPTYPE LVar7;
	LWSURFACE *pLVar8;
	int iVar9;
	uint uVar10;
	uint uVar11;
	LWTEXFLAGS LVar12;
	LWSRFFLAGS LVar13;
	char **shapeName;
	char **ppcVar14;
	undefined4 *puVar15;
	int iVar16;
	LWSURFACE *pLVar17;
	char **ppcVar18;
	char *pcVar19;
	char *pcVar20;
	undefined4 *puVar21;
	char **local_50c;
	LWSURFACE *local_508;
	uint local_504;
	char local_500;
	undefined4 local_4ff;
	undefined4 local_4fb;
	undefined local_4f7;
	char **local_4f4;
	int local_4f0;
	char *local_4ec;
	char *local_4e8;
	char *local_4e4;
	char *local_4e0;
	char *local_4dc;
	char *local_4d8;
	char *local_4d4;
	uint local_4d0;
	int local_4cc;
	char *local_4c8 [4];
	char *local_4b8;
	char *local_4b4;
	char *local_4b0;
	char *local_4ac [4];
	char *local_49c;
	char *local_498;
	char *local_494;
	char *local_490;
	char *local_48c;
	char *local_488;
	uint local_484;
	char local_480 [511];
	undefined uStack641;
	char *local_280 [32];
	char local_200 [512];
	
	local_4ff = 0;
	local_4fb = 0;
	local_500 = '\0';
	local_4f7 = 0;
	pcVar3 = (char *)std::malloc(csize + 0x10);
	local_4ec = pcVar3;
	lego::file::File_Read(pcVar3,csize,1,file);
	uVar10 = sizeData->lwSurfaceCount;
	pLVar4 = local_508;
	local_504 = uVar10;
	if (surf != NULL) {
		if (uVar10 == 0) {
			pLVar4 = (LWSURFACE *)std::malloc(0x54);
			*surf = pLVar4;
			pLVar8 = pLVar4;
			for (iVar9 = 0x15; iVar9 != 0; iVar9 += -1) {
				pLVar8->srfName = NULL;
				pLVar8 = (LWSURFACE *)&pLVar8->srfNextSurf;
			}
			local_508 = pLVar4;
			pcVar5 = stringAlloc(pcVar3);
			pLVar4->srfName = pcVar5;
		}
		else {
			pLVar4 = (LWSURFACE *)std::malloc((uVar10 + 1) * 0x54);
			pLVar8 = *surf;
			pLVar17 = pLVar4;
			for (uVar11 = uVar10 * 0x15 & 0x3fffffff; uVar11 != 0; uVar11 -= 1) {
				pLVar17->srfName = pLVar8->srfName;
				pLVar8 = (LWSURFACE *)&pLVar8->srfNextSurf;
				pLVar17 = (LWSURFACE *)&pLVar17->srfNextSurf;
			}
			for (iVar9 = 0; iVar9 != 0; iVar9 += -1) {
				*(undefined *)&pLVar17->srfName = *(undefined *)&pLVar8->srfName;
				pLVar8 = (LWSURFACE *)((int)&pLVar8->srfName + 1);
				pLVar17 = (LWSURFACE *)((int)&pLVar17->srfName + 1);
			}
			std::free(*surf);
			*surf = pLVar4;
			pLVar4 = pLVar4 + uVar10;
			pLVar8 = pLVar4;
			for (iVar9 = 0x15; iVar9 != 0; iVar9 += -1) {
				pLVar8->srfName = NULL;
				pLVar8 = (LWSURFACE *)&pLVar8->srfNextSurf;
			}
			local_508 = pLVar4;
			pcVar3 = stringAlloc(local_4ec);
			pLVar4->srfName = pcVar3;
			pcVar3 = local_4ec;
		}
	}
	if (dflag != 0) {
		std::sprintf(local_200,"Surface %d :- %s");
	}
	uVar10 = 0xffffffff;
	pcVar5 = pcVar3;
	do {
		if (uVar10 == 0) break;
		uVar10 -= 1;
		cVar1 = *pcVar5;
		pcVar5 = pcVar5 + 1;
	} while (cVar1 != '\0');
	uVar10 = ~uVar10;
	if ((uVar10 & 1) != 0) {
		uVar10 += 1;
	}
	iVar9 = csize - uVar10;
	pcVar3 = pcVar3 + uVar10;
	do {
		if (iVar9 < 1) {
			sizeData->lwSurfaceCount = sizeData->lwSurfaceCount + 1;
			std::free(local_4ec);
			return TRUE;
		}
		std::_strncpy(&local_500,pcVar3,4);
		local_4cc = (*(ushort *)(pcVar3 + 4) & 0xff) * 0x100 + (uint)(*(ushort *)(pcVar3 + 4) >> 8);
		std::sprintf(local_200," %s (%d)");
		shapeName = (char **)(pcVar3 + 6);
		iVar6 = std::_strnicmp(&local_500,"TIMG",4);
		if (iVar6 == 0) {
			uVar10 = 0xffffffff;
			ppcVar14 = shapeName;
			do {
				ppcVar18 = ppcVar14;
				if (uVar10 == 0) break;
				uVar10 -= 1;
				ppcVar18 = (char **)((int)ppcVar14 + 1);
				cVar1 = *(char *)ppcVar14;
				ppcVar14 = ppcVar18;
			} while (cVar1 != '\0');
			uVar10 = ~uVar10;
			iVar6 = -1;
			pcVar3 = local_200;
			do {
				pcVar5 = pcVar3;
				if (iVar6 == 0) break;
				iVar6 += -1;
				pcVar5 = pcVar3 + 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar5;
			} while (cVar1 != '\0');
			ppcVar14 = (char **)((int)ppcVar18 - uVar10);
			ppcVar18 = (char **)(pcVar5 + -1);
			for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
				*ppcVar18 = *ppcVar14;
				ppcVar14 = ppcVar14 + 1;
				ppcVar18 = ppcVar18 + 1;
			}
			for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
				*(undefined *)ppcVar18 = *(undefined *)ppcVar14;
				ppcVar14 = (char **)((int)ppcVar14 + 1);
				ppcVar18 = (char **)((int)ppcVar18 + 1);
			}
			if (surf != NULL) {
				uVar10 = 0xffffffff;
				ppcVar14 = shapeName;
				do {
					ppcVar18 = ppcVar14;
					if (uVar10 == 0) break;
					uVar10 -= 1;
					ppcVar18 = (char **)((int)ppcVar14 + 1);
					cVar1 = *(char *)ppcVar14;
					ppcVar14 = ppcVar18;
				} while (cVar1 != '\0');
				uVar10 = ~uVar10;
				ppcVar14 = (char **)((int)ppcVar18 - uVar10);
				ppcVar18 = local_280;
				for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
					*ppcVar18 = *ppcVar14;
					ppcVar14 = ppcVar14 + 1;
					ppcVar18 = ppcVar18 + 1;
				}
				for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
					*(undefined *)ppcVar18 = *(undefined *)ppcVar14;
					ppcVar14 = (char **)((int)ppcVar14 + 1);
					ppcVar18 = (char **)((int)ppcVar18 + 1);
				}
				pcVar3 = lwExtractString((char *)local_280,"(sequence)",&local_4d0,&local_484);
				if (pcVar3 != NULL) {
					LVar12 = pLVar4->srfTexFlags;
					*(undefined *)((int)local_280 + (local_4d0 - 1)) = 0;
					pLVar4->srfTexFlags = LVar12 | TFM_SEQUENCE;
				}
				pcVar3 = stringAlloc((char *)local_280);
				pLVar4->srfPath = pcVar3;
			}
		}
		else {
			iVar6 = std::_strnicmp(&local_500,"COLR",4);
			if (iVar6 == 0) {
				std::sprintf(local_480," RGBA %d,%d,%d,%d");
				uVar10 = 0xffffffff;
				pcVar5 = local_480;
				do {
					pcVar20 = pcVar5;
					if (uVar10 == 0) break;
					uVar10 -= 1;
					pcVar20 = pcVar5 + 1;
					cVar1 = *pcVar5;
					pcVar5 = pcVar20;
				} while (cVar1 != '\0');
				uVar10 = ~uVar10;
				iVar6 = -1;
				pcVar5 = local_200;
				do {
					pcVar19 = pcVar5;
					if (iVar6 == 0) break;
					iVar6 += -1;
					pcVar19 = pcVar5 + 1;
					cVar1 = *pcVar5;
					pcVar5 = pcVar19;
				} while (cVar1 != '\0');
				puVar15 = (undefined4 *)(pcVar20 + -uVar10);
				puVar21 = (undefined4 *)(pcVar19 + -1);
				for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
					*puVar21 = *puVar15;
					puVar15 = puVar15 + 1;
					puVar21 = puVar21 + 1;
				}
				for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
					*(undefined *)puVar21 = *(undefined *)puVar15;
					puVar15 = (undefined4 *)((int)puVar15 + 1);
					puVar21 = (undefined4 *)((int)puVar21 + 1);
				}
				if (surf != NULL) {
					(pLVar4->srfCol).colRed = *(byte *)shapeName;
					(pLVar4->srfCol).colGreen = pcVar3[7];
					(pLVar4->srfCol).colBlue = pcVar3[8];
					(pLVar4->srfCol).colAlpha = pcVar3[9];
				}
			}
			else {
				iVar6 = std::_strnicmp(&local_500,"CTEX",4);
				if (iVar6 == 0) {
					uVar10 = 0xffffffff;
					ppcVar14 = shapeName;
					do {
						ppcVar18 = ppcVar14;
						if (uVar10 == 0) break;
						uVar10 -= 1;
						ppcVar18 = (char **)((int)ppcVar14 + 1);
						cVar1 = *(char *)ppcVar14;
						ppcVar14 = ppcVar18;
					} while (cVar1 != '\0');
					uVar10 = ~uVar10;
					iVar6 = -1;
					pcVar3 = local_200;
					do {
						pcVar5 = pcVar3;
						if (iVar6 == 0) break;
						iVar6 += -1;
						pcVar5 = pcVar3 + 1;
						cVar1 = *pcVar3;
						pcVar3 = pcVar5;
					} while (cVar1 != '\0');
					ppcVar14 = (char **)((int)ppcVar18 - uVar10);
					ppcVar18 = (char **)(pcVar5 + -1);
					for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
						*ppcVar18 = *ppcVar14;
						ppcVar14 = ppcVar14 + 1;
						ppcVar18 = ppcVar18 + 1;
					}
					for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
						*(undefined *)ppcVar18 = *(undefined *)ppcVar14;
						ppcVar14 = (char **)((int)ppcVar14 + 1);
						ppcVar18 = (char **)((int)ppcVar18 + 1);
					}
					if (surf != NULL) {
						LVar7 = texMapType((char *)shapeName);
						pLVar4->srfTexType = LVar7;
					}
				}
				else {
					iVar6 = std::_strnicmp(&local_500,"TTEX",4);
					if (iVar6 == 0) {
						uVar10 = 0xffffffff;
						ppcVar14 = shapeName;
						do {
							ppcVar18 = ppcVar14;
							if (uVar10 == 0) break;
							uVar10 -= 1;
							ppcVar18 = (char **)((int)ppcVar14 + 1);
							cVar1 = *(char *)ppcVar14;
							ppcVar14 = ppcVar18;
						} while (cVar1 != '\0');
						uVar10 = ~uVar10;
						iVar6 = -1;
						pcVar3 = local_200;
						do {
							pcVar5 = pcVar3;
							if (iVar6 == 0) break;
							iVar6 += -1;
							pcVar5 = pcVar3 + 1;
							cVar1 = *pcVar3;
							pcVar3 = pcVar5;
						} while (cVar1 != '\0');
						ppcVar14 = (char **)((int)ppcVar18 - uVar10);
						ppcVar18 = (char **)(pcVar5 + -1);
						for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
							*ppcVar18 = *ppcVar14;
							ppcVar14 = ppcVar14 + 1;
							ppcVar18 = ppcVar18 + 1;
						}
						for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
							*(undefined *)ppcVar18 = *(undefined *)ppcVar14;
							ppcVar14 = (char **)((int)ppcVar14 + 1);
							ppcVar18 = (char **)((int)ppcVar18 + 1);
						}
						if (surf != NULL) {
							pLVar8 = (LWSURFACE *)std::malloc(0x54);
							pLVar4->srfNextSurf = pLVar8;
							pLVar4 = pLVar8;
							for (iVar6 = 0x15; iVar6 != 0; iVar6 += -1) {
								pLVar4->srfName = NULL;
								pLVar4 = (LWSURFACE *)&pLVar4->srfNextSurf;
							}
							local_508 = pLVar8;
							LVar7 = texMapType((char *)shapeName);
							pLVar8->srfTexType = LVar7;
							pLVar4 = pLVar8;
						}
					}
					else {
						iVar6 = std::_strnicmp(&local_500,"TFLG",4);
						if (iVar6 == 0) {
							local_4f4 = NULL;
							if (surf != NULL) {
								LVar12 = (uint)(*(ushort *)shapeName >> 8) + (*(ushort *)shapeName & 0xff) * 0x100 &
												 0xffff;
								local_4c8[0] = "Axis_x";
								local_508->srfTexFlags = local_508->srfTexFlags | LVar12;
								local_4c8[1] = "Axis_y";
								local_4c8[2] = "Axis_z";
								local_4c8[3] = "World Coord";
								local_4b8 = "Negative Image";
								local_4b4 = "Pixel Blending";
								local_4b0 = "Anti Aliasing";
								std::sprintf(local_480,"%xH - ");
								local_50c = local_4c8;
								local_4f0 = 0;
								local_504 = 8;
								do {
									if ((LVar12 & 1 << ((byte)local_4f0 & 0x1f)) != 0) {
										if ((short)local_4f4 != 0) {
											uVar10 = 0xffffffff;
											pcVar3 = ",";
											do {
												pcVar5 = pcVar3;
												if (uVar10 == 0) break;
												uVar10 -= 1;
												pcVar5 = pcVar3 + 1;
												cVar1 = *pcVar3;
												pcVar3 = pcVar5;
											} while (cVar1 != '\0');
											uVar10 = ~uVar10;
											iVar6 = -1;
											pcVar3 = local_480;
											do {
												pcVar20 = pcVar3;
												if (iVar6 == 0) break;
												iVar6 += -1;
												pcVar20 = pcVar3 + 1;
												cVar1 = *pcVar3;
												pcVar3 = pcVar20;
											} while (cVar1 != '\0');
											puVar15 = (undefined4 *)(pcVar5 + -uVar10);
											puVar21 = (undefined4 *)(pcVar20 + -1);
											for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
												*puVar21 = *puVar15;
												puVar15 = puVar15 + 1;
												puVar21 = puVar21 + 1;
											}
											for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
												*(undefined *)puVar21 = *(undefined *)puVar15;
												puVar15 = (undefined4 *)((int)puVar15 + 1);
												puVar21 = (undefined4 *)((int)puVar21 + 1);
											}
										}
										local_4f4 = (char **)((int)local_4f4 + 1);
										uVar10 = 0xffffffff;
										pcVar3 = *local_50c;
										do {
											pcVar5 = pcVar3;
											if (uVar10 == 0) break;
											uVar10 -= 1;
											pcVar5 = pcVar3 + 1;
											cVar1 = *pcVar3;
											pcVar3 = pcVar5;
										} while (cVar1 != '\0');
										uVar10 = ~uVar10;
										iVar6 = -1;
										pcVar3 = local_480;
										do {
											pcVar20 = pcVar3;
											if (iVar6 == 0) break;
											iVar6 += -1;
											pcVar20 = pcVar3 + 1;
											cVar1 = *pcVar3;
											pcVar3 = pcVar20;
										} while (cVar1 != '\0');
										puVar15 = (undefined4 *)(pcVar5 + -uVar10);
										puVar21 = (undefined4 *)(pcVar20 + -1);
										for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
											*puVar21 = *puVar15;
											puVar15 = puVar15 + 1;
											puVar21 = puVar21 + 1;
										}
										for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
											*(undefined *)puVar21 = *(undefined *)puVar15;
											puVar15 = (undefined4 *)((int)puVar15 + 1);
											puVar21 = (undefined4 *)((int)puVar21 + 1);
										}
									}
									local_4f0 += 1;
									local_50c = local_50c + 1;
									local_504 -= 1;
								} while (local_504 != 0);
LAB_0048d1d2:
								uVar10 = 0xffffffff;
								pcVar3 = local_480;
								do {
									pcVar5 = pcVar3;
									if (uVar10 == 0) break;
									uVar10 -= 1;
									pcVar5 = pcVar3 + 1;
									cVar1 = *pcVar3;
									pcVar3 = pcVar5;
								} while (cVar1 != '\0');
								uVar10 = ~uVar10;
								iVar6 = -1;
								pcVar3 = local_200;
								do {
									pcVar20 = pcVar3;
									if (iVar6 == 0) break;
									iVar6 += -1;
									pcVar20 = pcVar3 + 1;
									cVar1 = *pcVar3;
									pcVar3 = pcVar20;
								} while (cVar1 != '\0');
								puVar15 = (undefined4 *)(pcVar5 + -uVar10);
								puVar21 = (undefined4 *)(pcVar20 + -1);
								for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
									*puVar21 = *puVar15;
									puVar15 = puVar15 + 1;
									puVar21 = puVar21 + 1;
								}
								for (uVar10 &= 3; pLVar4 = local_508, uVar10 != 0; uVar10 -= 1) {
									*(undefined *)puVar21 = *(undefined *)puVar15;
									puVar15 = (undefined4 *)((int)puVar15 + 1);
									puVar21 = (undefined4 *)((int)puVar21 + 1);
								}
							}
						}
						else {
							iVar6 = std::_strnicmp(&local_500,"FLAG",4);
							if (iVar6 == 0) {
								local_50c = NULL;
								if (surf != NULL) {
									local_4ac[0] = "Luminous";
									LVar13 = (uint)(*(ushort *)shapeName >> 8) + (*(ushort *)shapeName & 0xff) * 0x100
													 & 0xffff;
									local_4ac[1] = "Outline";
									local_4ac[2] = "Smoothing";
									local_4ac[3] = "Color Highlights";
									local_49c = "Color Filter";
									local_498 = "Opaque Edge";
									local_494 = "Transparent Edge";
									local_490 = "Sharp Terminator";
									local_48c = "Double Sided";
									local_488 = "Additive";
									local_508->srfFlags = LVar13;
									std::sprintf(local_480,"%xH - ");
									local_4f4 = local_4ac;
									local_504 = 0;
									local_4f0 = 10;
									do {
										if ((LVar13 & 1 << ((byte)local_504 & 0x1f)) != 0) {
											if ((short)local_50c != 0) {
												uVar10 = 0xffffffff;
												pcVar3 = ",";
												do {
													pcVar5 = pcVar3;
													if (uVar10 == 0) break;
													uVar10 -= 1;
													pcVar5 = pcVar3 + 1;
													cVar1 = *pcVar3;
													pcVar3 = pcVar5;
												} while (cVar1 != '\0');
												uVar10 = ~uVar10;
												iVar6 = -1;
												pcVar3 = local_480;
												do {
													pcVar20 = pcVar3;
													if (iVar6 == 0) break;
													iVar6 += -1;
													pcVar20 = pcVar3 + 1;
													cVar1 = *pcVar3;
													pcVar3 = pcVar20;
												} while (cVar1 != '\0');
												puVar15 = (undefined4 *)(pcVar5 + -uVar10);
												puVar21 = (undefined4 *)(pcVar20 + -1);
												for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
													*puVar21 = *puVar15;
													puVar15 = puVar15 + 1;
													puVar21 = puVar21 + 1;
												}
												for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
													*(undefined *)puVar21 = *(undefined *)puVar15;
													puVar15 = (undefined4 *)((int)puVar15 + 1);
													puVar21 = (undefined4 *)((int)puVar21 + 1);
												}
											}
											local_50c = (char **)((int)local_50c + 1);
											uVar10 = 0xffffffff;
											pcVar3 = *local_4f4;
											do {
												pcVar5 = pcVar3;
												if (uVar10 == 0) break;
												uVar10 -= 1;
												pcVar5 = pcVar3 + 1;
												cVar1 = *pcVar3;
												pcVar3 = pcVar5;
											} while (cVar1 != '\0');
											uVar10 = ~uVar10;
											iVar6 = -1;
											pcVar3 = local_480;
											do {
												pcVar20 = pcVar3;
												if (iVar6 == 0) break;
												iVar6 += -1;
												pcVar20 = pcVar3 + 1;
												cVar1 = *pcVar3;
												pcVar3 = pcVar20;
											} while (cVar1 != '\0');
											puVar15 = (undefined4 *)(pcVar5 + -uVar10);
											puVar21 = (undefined4 *)(pcVar20 + -1);
											for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
												*puVar21 = *puVar15;
												puVar15 = puVar15 + 1;
												puVar21 = puVar21 + 1;
											}
											for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
												*(undefined *)puVar21 = *(undefined *)puVar15;
												puVar15 = (undefined4 *)((int)puVar15 + 1);
												puVar21 = (undefined4 *)((int)puVar21 + 1);
											}
										}
										local_504 += 1;
										local_4f4 = local_4f4 + 1;
										local_4f0 += -1;
									} while (local_4f0 != 0);
									goto LAB_0048d1d2;
								}
							}
							else {
								iVar6 = std::_strnicmp(&local_500,"TSIZ",4);
								if (iVar6 == 0) {
									if (surf != NULL) {
										local_50c = shapeName;
										LWD3D((byte **)&local_50c,(float *)&local_4dc);
										LWD3D((byte **)&local_50c,(float *)&local_4d8);
										LWD3D((byte **)&local_50c,(float *)&local_4d4);
										std::sprintf(local_480," (%f,%f,%f)");
										(pLVar4->srfTexSize).tdX = (float)local_4dc;
										(pLVar4->srfTexSize).tdY = (float)local_4d8;
										(pLVar4->srfTexSize).tdZ = (float)local_4d4;
LAB_0048d369:
										uVar10 = 0xffffffff;
										pcVar3 = local_480;
										do {
											pcVar5 = pcVar3;
											if (uVar10 == 0) break;
											uVar10 -= 1;
											pcVar5 = pcVar3 + 1;
											cVar1 = *pcVar3;
											pcVar3 = pcVar5;
										} while (cVar1 != '\0');
										uVar10 = ~uVar10;
										iVar6 = -1;
										pcVar3 = local_200;
										do {
											pcVar20 = pcVar3;
											if (iVar6 == 0) break;
											iVar6 += -1;
											pcVar20 = pcVar3 + 1;
											cVar1 = *pcVar3;
											pcVar3 = pcVar20;
										} while (cVar1 != '\0');
										puVar15 = (undefined4 *)(pcVar5 + -uVar10);
										puVar21 = (undefined4 *)(pcVar20 + -1);
										for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
											*puVar21 = *puVar15;
											puVar15 = puVar15 + 1;
											puVar21 = puVar21 + 1;
										}
										for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
											*(undefined *)puVar21 = *(undefined *)puVar15;
											puVar15 = (undefined4 *)((int)puVar15 + 1);
											puVar21 = (undefined4 *)((int)puVar21 + 1);
										}
									}
								}
								else {
									iVar6 = std::_strnicmp(&local_500,"TCTR",4);
									if ((iVar6 == 0) && (surf != NULL)) {
										local_50c = shapeName;
										LWD3D((byte **)&local_50c,(float *)&local_4e8);
										LWD3D((byte **)&local_50c,(float *)&local_4e4);
										LWD3D((byte **)&local_50c,(float *)&local_4e0);
										std::sprintf(local_480," (%f,%f,%f)");
										(pLVar4->srfTexCentre).tdX = (float)local_4e8;
										(pLVar4->srfTexCentre).tdY = (float)local_4e4;
										(pLVar4->srfTexCentre).tdZ = (float)local_4e0;
										goto LAB_0048d369;
									}
								}
							}
						}
					}
				}
			}
		}
		iVar16 = 0;
		iVar6 = std::_strnicmp(&local_500,"TRAN",4);
		if (iVar6 == 0) {
			iVar16 = 1;
		}
		else {
			iVar6 = std::_strnicmp(&local_500,"DIFF",4);
			if (iVar6 == 0) {
				iVar16 = 2;
			}
			else {
				iVar6 = std::_strnicmp(&local_500,"LUMI",4);
				if (iVar6 == 0) {
					iVar16 = 3;
				}
				else {
					iVar6 = std::_strnicmp(&local_500,"REFL",4);
					if (iVar6 == 0) {
						iVar16 = 4;
					}
					else {
						iVar6 = std::_strnicmp(&local_500,"SPEC",4);
						if (iVar6 == 0) {
							iVar16 = 5;
						}
						else {
							iVar6 = std::_strnicmp(&local_500,"GLOS",4);
							if (iVar6 == 0) {
								iVar16 = 6;
							}
						}
					}
				}
			}
		}
		if ((iVar16 != 0) && (surf != NULL)) {
			local_504 = (uint)(*(ushort *)shapeName >> 8) + (*(ushort *)shapeName & 0xff) * 0x100 & 0xffff
			;
			fVar2 = (float)local_504 * 0.00390625;
			switch(iVar16) {
			case 1:
				pLVar4->srfTransparent = fVar2;
				break;
			case 2:
				pLVar4->srfDiffuse = fVar2;
				break;
			case 3:
				pLVar4->srfLuminous = fVar2;
				break;
			case 4:
				pLVar4->srfReflect = fVar2;
				break;
			case 5:
				pLVar4->srfSpecular = fVar2;
				break;
			case 6:
				pLVar4->srfSpecPower = fVar2;
			}
			std::sprintf(local_480,"%f");
			uVar10 = 0xffffffff;
			pcVar3 = local_480;
			do {
				pcVar5 = pcVar3;
				if (uVar10 == 0) break;
				uVar10 -= 1;
				pcVar5 = pcVar3 + 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar5;
			} while (cVar1 != '\0');
			uVar10 = ~uVar10;
			iVar6 = -1;
			pcVar3 = local_200;
			do {
				pcVar20 = pcVar3;
				if (iVar6 == 0) break;
				iVar6 += -1;
				pcVar20 = pcVar3 + 1;
				cVar1 = *pcVar3;
				pcVar3 = pcVar20;
			} while (cVar1 != '\0');
			puVar15 = (undefined4 *)(pcVar5 + -uVar10);
			puVar21 = (undefined4 *)(pcVar20 + -1);
			for (uVar11 = uVar10 >> 2; uVar11 != 0; uVar11 -= 1) {
				*puVar21 = *puVar15;
				puVar15 = puVar15 + 1;
				puVar21 = puVar21 + 1;
			}
			for (uVar10 &= 3; uVar10 != 0; uVar10 -= 1) {
				*(undefined *)puVar21 = *(undefined *)puVar15;
				puVar15 = (undefined4 *)((int)puVar15 + 1);
				puVar21 = (undefined4 *)((int)puVar21 + 1);
			}
		}
		pcVar3 = (char *)((int)shapeName + local_4cc);
		iVar9 += -6 - local_4cc;
	} while( true );
}



BOOL __cdecl
lego::lw::LoadLWOB(char *fn,LWSIZE *sd,float **verts,LWPOLY **polys,LWSURFACE **surfs,
									File **out_fileUV,BOOL dflag)
{
	File *f;
	LWSIZE *sizeData;
	BOOL BVar1;
	File *pFVar2;
	int iVar3;
	int iVar4;
	char *pcVar5;
	uint uVar6;
	byte *pbVar7;
	LWSURFACE *pLVar8;
	char **ppcVar9;
	uint local_534;
	uint local_530;
	LWSURFLIST *local_52c;
	uint local_528;
	char local_524;
	undefined4 local_523;
	undefined4 local_51f;
	undefined local_51b;
	uint local_518;
	uint local_514;
	char *local_510;
	File *local_50c;
	LWSIZE *local_508;
	LWSURFACE *local_504;
	char filenameLwo [256];
	char buff [1024];
	
	local_523 = 0;
	local_51f = 0;
	local_524 = '\0';
	local_51b = 0;
	local_530 = 0;
	std::sprintf(filenameLwo,"%s.lwo",fn);
	f = lego::file::File_Open(filenameLwo,"rb");
	if (f == NULL) {
		return 0;
	}
	local_50c = f;
	sizeData = (LWSIZE *)std::malloc(0xc);
	sizeData->lwSurfaceCount = 0;
	sizeData->lwPolyCount = 0;
	sizeData->lwVertCount = 0;
	local_508 = sizeData;
	if (out_fileUV != NULL) {
		std::sprintf(filenameLwo,"%s.uv",fn);
		BVar1 = lego::file::File_Exists(filenameLwo);
		if (BVar1 == 0) {
			*out_fileUV = NULL;
		}
		else {
			pFVar2 = lego::file::File_Open(filenameLwo,"rb");
			*out_fileUV = pFVar2;
		}
	}
	lego::file::File_Read(&local_524,4,1,f);
	iVar3 = std::_stricmp(&local_524,"FORM");
	if (iVar3 == 0) {
		lego::file::File_Read(&local_518,4,1,f);
		local_518 = ((local_518 & 0xff00) + (local_518 & 0xff) * 0x10000) * 0x100 +
								(local_518 >> 0x10 & 0xff) * 0x100 + (local_518 >> 0x18);
		lego::file::File_Read(&local_524,4,1,f);
		iVar3 = std::_stricmp(&local_524,"LWOB");
		if (iVar3 == 0) {
			for (iVar3 = local_518 - 4; 0 < iVar3; iVar3 += -8 - local_534) {
				lego::file::File_Read(&local_524,4,1,f);
				lego::file::File_Read(&local_534,4,1,f);
				local_534 = ((local_534 & 0xff00) + (local_534 & 0xff) * 0x10000) * 0x100 +
										(local_534 >> 0x10 & 0xff) * 0x100 + (local_534 >> 0x18);
				if (dflag != 0) {
					std::sprintf(buff,"LW OBJECT %s %d\n",&local_524,local_534);
				}
				iVar4 = std::_stricmp(&local_524,"PNTS");
				if (iVar4 == 0) {
					PNTSprc(f,sizeData,local_534,verts,dflag);
				}
				else {
					iVar4 = std::_stricmp(&local_524,"SRFS");
					if (iVar4 == 0) {
						SRFSprc(f,sizeData,&local_52c,local_534,&local_530,dflag);
					}
					else {
						iVar4 = std::_stricmp(&local_524,"SURF");
						if (iVar4 == 0) {
							SURFprc(f,sizeData,surfs,local_534,dflag);
						}
						else {
							iVar4 = std::_stricmp(&local_524,"CRVS");
							if (iVar4 == 0) {
								CRVSprc(f,local_534,dflag);
							}
							else {
								iVar4 = std::_stricmp(&local_524,"POLS");
								if (iVar4 == 0) {
									POLSprc(f,sizeData,polys,local_534,dflag);
								}
								else {
									lego::file::File_Seek(f,local_534,1);
								}
							}
						}
					}
				}
			}
			local_528 = sizeData->lwSurfaceCount;
			if (((surfs != NULL) && (local_52c != NULL)) && (sizeData != NULL)) {
				local_504 = (LWSURFACE *)std::malloc(local_530 * 0x54);
				pLVar8 = local_504;
				for (uVar6 = local_530 * 0x15 & 0x3fffffff; uVar6 != 0; uVar6 -= 1) {
					pLVar8->srfName = NULL;
					pLVar8 = (LWSURFACE *)&pLVar8->srfNextSurf;
				}
				for (iVar3 = 0; iVar3 != 0; iVar3 += -1) {
					*(undefined *)&pLVar8->srfName = 0;
					pLVar8 = (LWSURFACE *)((int)&pLVar8->srfName + 1);
				}
				local_514 = 0;
				if (local_530 != 0) {
					pbVar7 = &(local_504->srfCol).colGreen;
					do {
						uVar6 = 0;
						local_510 = local_52c->srflName[local_514];
						if (local_528 != 0) {
							iVar3 = 0;
LAB_0048d940:
							iVar4 = std::_stricmp(*(char **)((*surfs)->srfTCLR + iVar3 + -0x10),local_510);
							if (iVar4 != 0) goto code_r0x0048d95e;
							pLVar8 = *surfs + uVar6;
							ppcVar9 = (char **)(pbVar7 + -0xd);
							for (iVar3 = 0x15; f = local_50c, iVar3 != 0; iVar3 += -1) {
								*ppcVar9 = pLVar8->srfName;
								pLVar8 = (LWSURFACE *)&pLVar8->srfNextSurf;
								ppcVar9 = ppcVar9 + 1;
							}
						}
LAB_0048d990:
						if (uVar6 == local_528) {
							pcVar5 = stringAlloc("Default");
							*(char **)(pbVar7 + -0xd) = pcVar5;
							pbVar7[-1] = 0xff;
							*pbVar7 = 0xff;
							pbVar7[1] = 0xff;
							local_528 = local_530;
						}
						pbVar7 = pbVar7 + 0x54;
						local_514 += 1;
						sizeData = local_508;
					} while (local_514 < local_530);
				}
				pLVar8 = local_504;
				std::free(*surfs);
				*surfs = pLVar8;
			}
			sizeData->lwSurfaceCount = local_528;
			if (sd != NULL) {
				sd->lwVertCount = sizeData->lwVertCount;
				sd->lwPolyCount = sizeData->lwPolyCount;
				sd->lwSurfaceCount = sizeData->lwSurfaceCount;
			}
			std::free(sizeData);
			if (local_530 != 0) {
				uVar6 = 0;
				if (local_530 != 0) {
					do {
						std::free(local_52c->srflName[uVar6]);
						uVar6 += 1;
					} while (uVar6 < local_530);
				}
				std::free(local_52c->srflName);
				std::free(local_52c);
			}
			lego::file::File_Close(f);
			return TRUE;
		}
	}
	std::free(sizeData);
	lego::file::File_Close(f);
	std::sprintf(buff,"Error in Lightwave file %s",fn);
	return 0;
code_r0x0048d95e:
	uVar6 += 1;
	iVar3 += 0x54;
	if (local_528 <= uVar6) goto LAB_0048d990;
	goto LAB_0048d940;
}



BOOL __cdecl lego::lw::LoadAppObj(char *fn,APPOBJ **out_ao,BOOL flag)
{
	APPOBJ *pAVar1;
	char *pcVar2;
	BOOL BVar3;
	int iVar4;
	char path [128];
	
	pAVar1 = (APPOBJ *)std::malloc(0x20);
	*out_ao = pAVar1;
	for (iVar4 = 8; iVar4 != 0; iVar4 += -1) {
		pAVar1->aoPath = NULL;
		pAVar1 = (APPOBJ *)&pAVar1->aoSize;
	}
	std::_splitpath(fn,NULL,path,NULL,NULL);
	pcVar2 = stringAlloc(path);
	(*out_ao)->aoPath = pcVar2;
	pAVar1 = *out_ao;
	BVar3 = LoadLWOB(fn,&pAVar1->aoSize,&pAVar1->aoVerts,&pAVar1->aoPoly,&pAVar1->aoSurface,
									 &pAVar1->aoFileUV,flag);
	if (BVar3 != 0) {
		return TRUE;
	}
	std::free((*out_ao)->aoPath);
	std::free(*out_ao);
	return 0;
}



BOOL __cdecl lego::lw::FreeLWOB(APPOBJ *ao)
{
	uint uVar1;
	LWSURFACE *srf;
	int iVar2;
	
	if (ao != NULL) {
		if (ao->aoFileUV != NULL) {
			lego::file::File_Close(ao->aoFileUV);
		}
		srf = ao->aoSurface;
		if (srf != NULL) {
			for (uVar1 = (ao->aoSize).lwSurfaceCount; uVar1 != 0; uVar1 -= 1) {
				surfFree(srf,0);
				srf = srf + 1;
			}
			std::free(ao->aoSurface);
		}
		if (ao->aoPoly != NULL) {
			uVar1 = (ao->aoSize).lwPolyCount;
			if (uVar1 != 0) {
				iVar2 = 0;
				do {
					std::free(*(void **)((int)&ao->aoPoly->plyData + iVar2));
					iVar2 += 0xc;
					uVar1 -= 1;
				} while (uVar1 != 0);
			}
			std::free(ao->aoPoly);
		}
		std::free(ao->aoVerts);
		std::free(ao->aoPath);
		std::free(ao);
		return TRUE;
	}
	return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
// Name: __fpmath
// Library: Visual Studio 1998 Release

void __cdecl __fpmath(int param_1)
{
	std::internal::__fpmath_internal();
	_DAT_0054a0cc = std::internal::__fpmath__00490540();
	__setdefaultprecision();
	return;
}



void std::internal::__fpmath_internal(void)
{
	PTR___std_FUN_004b0f80 = __std_FUN_00490a10;
	PTR___std_FUN_004b0f84 = __fpmath__004905d0;
	PTR___std_FUN_004b0f88 = __std_FUN_00490660;
	PTR___std_FUN_004b0f8c = __fpmath__00490570;
	PTR___std_FUN_004b0f90 = __fpmath_isdouble_ge_0;
	PTR___std_FUN_004b0f94 = __std_FUN_00490a10;
	return;
}



float10 __cdecl std::atof(char *str)
{
	byte bVar1;
	uint uVar2;
	undefined *puVar3;
	int iVar4;
	byte *pbVar5;
	
	while( true ) {
										// int std::isspace(int c)
		if (globals::_pcharwidth < 2) {
			uVar2 = *(byte *)(globals::_pctype + (byte)*str) & C1_SPACE;
		}
		else {
			uVar2 = _isctype((uint)(byte)*str,C1_SPACE);
		}
		if (uVar2 == 0) break;
		str = (char *)((byte *)str + 1);
	}
	iVar4 = -1;
	pbVar5 = (byte *)str;
	do {
		if (iVar4 == 0) break;
		iVar4 += -1;
		bVar1 = *pbVar5;
		pbVar5 = pbVar5 + 1;
	} while (bVar1 != 0);
	puVar3 = internal::__atof_internal(str);
	return (float10)*(double *)(puVar3 + 0x10);
}



int __cdecl std::sprintf(char *out_buffer,char *format,...)
{
	int iVar1;
	FILE dummyFile;
	
	dummyFile._base = out_buffer;
	dummyFile._ptr = out_buffer;
	dummyFile._flag = 0x42;
	dummyFile._cnt = 0x7fffffff;
	iVar1 = internal::__vfprintf_internal(&dummyFile,format,&stack0x0000000c);
	dummyFile._cnt += -1;
	if (-1 < dummyFile._cnt) {
		*dummyFile._ptr = '\0';
		return iVar1;
	}
	internal::__fafterwrite_00490b60(0,(char **)&dummyFile);
	return iVar1;
}



char * __cdecl std::strstr(char *str,char *strSearch)
{
	char *pcVar1;
	char *pcVar2;
	char cVar3;
	uint uVar4;
	char cVar5;
	uint uVar6;
	char *pcVar7;
	uint uVar8;
	uint *puVar9;
	char *pcVar10;
	
	cVar3 = *strSearch;
	if (cVar3 == '\0') {
		return (char *)(uint *)str;
	}
	if (strSearch[1] == '\0') {
		uVar4 = (uint)str & 3;
		while (uVar4 != 0) {
			if (*str == cVar3) {
				return (char *)(uint *)str;
			}
			if (*str == '\0') {
				return (char *)NULL;
			}
			uVar4 = (uint)(uint *)((int)str + 1) & 3;
			str = (char *)(uint *)((int)str + 1);
		}
		while( true ) {
			while( true ) {
				uVar4 = *(uint *)str;
				uVar8 = uVar4 ^ CONCAT22(CONCAT11(cVar3,cVar3),CONCAT11(cVar3,cVar3));
				uVar6 = uVar4 ^ 0xffffffff ^ uVar4 + 0x7efefeff;
				puVar9 = (uint *)((int)str + 4);
				if (((uVar8 ^ 0xffffffff ^ uVar8 + 0x7efefeff) & 0x81010100) != 0) break;
				str = (char *)puVar9;
				if ((uVar6 & 0x81010100) != 0) {
					if ((uVar6 & 0x1010100) != 0) {
						return (char *)NULL;
					}
					if ((uVar4 + 0x7efefeff & 0x80000000) == 0) {
						return (char *)NULL;
					}
				}
			}
			uVar4 = *(uint *)str;
			if ((char)uVar4 == cVar3) {
				return (char *)(uint *)str;
			}
			if ((char)uVar4 == '\0') {
				return (char *)NULL;
			}
			cVar5 = (char)(uVar4 >> 8);
			if (cVar5 == cVar3) {
				return (char *)(uint *)((int)str + 1);
			}
			if (cVar5 == '\0') break;
			cVar5 = (char)(uVar4 >> 0x10);
			if (cVar5 == cVar3) {
				return (char *)(uint *)((int)str + 2);
			}
			if (cVar5 == '\0') {
				return (char *)NULL;
			}
			cVar5 = (char)(uVar4 >> 0x18);
			if (cVar5 == cVar3) {
				return (char *)(uint *)((int)str + 3);
			}
			str = (char *)puVar9;
			if (cVar5 == '\0') {
				return (char *)NULL;
			}
		}
		return (char *)NULL;
	}
	do {
		cVar5 = *str;
		do {
			while (str = str + 1, cVar5 != cVar3) {
				if (cVar5 == '\0') {
					return (char *)NULL;
				}
				cVar5 = *str;
			}
			cVar5 = *str;
			pcVar10 = str + 1;
			pcVar7 = strSearch;
		} while (cVar5 != strSearch[1]);
		do {
			if (pcVar7[2] == '\0') {
LAB_0048dd83:
				return (char *)(uint *)(str + -1);
			}
			if (*pcVar10 != pcVar7[2]) break;
			pcVar1 = pcVar7 + 3;
			if (*pcVar1 == '\0') goto LAB_0048dd83;
			pcVar2 = pcVar10 + 1;
			pcVar7 = pcVar7 + 2;
			pcVar10 = pcVar10 + 2;
		} while (*pcVar1 == *pcVar2);
	} while( true );
}



int __cdecl std::internal::__atoi_internal(char *str)
{
	byte bVar1;
	uint uVar2;
	uint uVar3;
	uint c;
	int iVar4;
	byte *pbVar5;
	
	while( true ) {
		if (std::globals::_pcharwidth < 2) {
			uVar2 = *(byte *)(std::globals::_pctype + (byte)*str) & 8;
		}
		else {
			uVar2 = _isctype((uint)(byte)*str,8);
		}
		if (uVar2 == 0) break;
		str = (char *)((byte *)str + 1);
	}
	uVar2 = (uint)(byte)*str;
	pbVar5 = (byte *)str + 1;
	if ((uVar2 == '-') || (c = uVar2, uVar2 == '+')) {
		c = (uint)*pbVar5;
		pbVar5 = (byte *)str + 2;
	}
	iVar4 = 0;
	while( true ) {
		if (std::globals::_pcharwidth < 2) {
			uVar3 = *(byte *)(std::globals::_pctype + c) & 4;
		}
		else {
			uVar3 = _isctype(c,C1_DIGIT);
		}
		if (uVar3 == 0) break;
		bVar1 = *pbVar5;
		pbVar5 = pbVar5 + 1;
		iVar4 = (c - 0x30) + iVar4 * 10;
		c = (uint)bVar1;
	}
	if (uVar2 == '-') {
		iVar4 = -iVar4;
	}
	return iVar4;
}



int __cdecl std::atoi(char *str)
{
	int iVar1;
	
	iVar1 = internal::__atoi_internal(str);
	return iVar1;
}



void __cdecl std::free(void *buffer)
{
	void *lpMem;
	byte *pbVar1;
	int *local_4;
	
	lpMem = buffer;
	if (buffer != NULL) {
		pbVar1 = (byte *)internal::__realloc_free__00491b00
															 ((undefined *)buffer,&local_4,(uint *)&buffer);
		if (pbVar1 != NULL) {
			internal::__free_realloc__00491b60((int)local_4,(int)buffer,pbVar1);
			return;
		}
		HeapFree(DAT_0076eec4,0,lpMem);
	}
	return;
}



void * __cdecl std::malloc(uint length)
{
	void *buffer;
	
	buffer = internal::__malloc_handlermode(length,internal::globals::__g_malloc_handlermode);
	return buffer;
}



void * __cdecl std::internal::__malloc_handlermode(uint length,BOOL new_handlermode)
{
	void *pvVar1;
	BOOL BVar2;
	
	if (length < 0xffffffe1) {
		if (length == 0) {
			length = 1;
		}
		do {
			if (length < 0xffffffe1) {
				pvVar1 = __malloc_2__0048df00(length);
			}
			else {
				pvVar1 = NULL;
			}
			if (pvVar1 != NULL) {
				return pvVar1;
			}
			if (new_handlermode == 0) {
				return NULL;
			}
			BVar2 = __call_new_handler(length);
		} while (BVar2 != 0);
	}
	return NULL;
}



void * __cdecl std::internal::__malloc_2__0048df00(uint length)
{
	int *piVar1;
	uint dwBytes;
	
	dwBytes = length + 0xf & 0xfffffff0;
	if ((dwBytes <= UINT_004b2fdc) &&
		 (piVar1 = __malloc__00491bc0((int *)(length + 0xf >> 4)), piVar1 != NULL)) {
		return piVar1;
	}
	piVar1 = (int *)HeapAlloc(DAT_0076eec4,0,dwBytes);
	return piVar1;
}



void * __cdecl std::realloc(void *memblock,uint size)
{
	int *piVar1;
	int **ppiVar2;
	int iVar3;
	BOOL BVar4;
	uint uVar5;
	uint uVar6;
	int *piVar7;
	int *piVar8;
	int **local_8;
	int *local_4;
	
	if (memblock == NULL) {
		piVar1 = (int *)malloc(size);
		return piVar1;
	}
	if (size == 0) {
		free(memblock);
		return NULL;
	}
	if (size < 0xffffffe1) {
		if (size == 0) {
			size = 0x10;
		}
		else {
			size = size + 0xf & 0xfffffff0;
		}
	}
	do {
		piVar1 = NULL;
		if (size < 0xffffffe1) {
			ppiVar2 = (int **)internal::__realloc_free__00491b00
																	((undefined *)memblock,&local_4,(uint *)&local_8);
			if (ppiVar2 == NULL) {
				piVar1 = (int *)HeapReAlloc(DAT_0076eec4,0,memblock,size);
				goto LAB_0048e0aa;
			}
			if (size < UINT_004b2fdc) {
				iVar3 = internal::__realloc__00491f80((int)local_4,local_8,ppiVar2,(uint)(int *)(size >> 4))
				;
				piVar1 = (int *)memblock;
				if (iVar3 != 0) goto LAB_0048e03f;
				piVar1 = internal::__malloc__00491bc0((int *)(size >> 4));
				if (piVar1 != NULL) {
					uVar6 = (uint)*(byte *)ppiVar2 << 4;
					if (size <= (uint)*(byte *)ppiVar2 << 4) {
						uVar6 = size;
					}
					piVar7 = (int *)memblock;
					piVar8 = piVar1;
					for (uVar5 = uVar6 >> 2; uVar5 != 0; uVar5 -= 1) {
						*piVar8 = *piVar7;
						piVar7 = piVar7 + 1;
						piVar8 = piVar8 + 1;
					}
					for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
						*(undefined *)piVar8 = *(undefined *)piVar7;
						piVar7 = (int *)((int)piVar7 + 1);
						piVar8 = (int *)((int)piVar8 + 1);
					}
					internal::__free_realloc__00491b60((int)local_4,(int)local_8,(byte *)ppiVar2);
					goto LAB_0048e03f;
				}
			}
			else {
LAB_0048e03f:
				if (piVar1 != NULL) {
					return piVar1;
				}
			}
			piVar1 = (int *)HeapAlloc(DAT_0076eec4,0,size);
			if (piVar1 != NULL) {
				uVar6 = (uint)*(byte *)ppiVar2 << 4;
				if (size <= (uint)*(byte *)ppiVar2 << 4) {
					uVar6 = size;
				}
				piVar7 = (int *)memblock;
				piVar8 = piVar1;
				for (uVar5 = uVar6 >> 2; uVar5 != 0; uVar5 -= 1) {
					*piVar8 = *piVar7;
					piVar7 = piVar7 + 1;
					piVar8 = piVar8 + 1;
				}
				for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
					*(undefined *)piVar8 = *(undefined *)piVar7;
					piVar7 = (int *)((int)piVar7 + 1);
					piVar8 = (int *)((int)piVar8 + 1);
				}
				internal::__free_realloc__00491b60((int)local_4,(int)local_8,(byte *)ppiVar2);
				goto LAB_0048e0aa;
			}
		}
		else {
LAB_0048e0aa:
			if (piVar1 != NULL) {
				return piVar1;
			}
		}
		if (internal::globals::__g_malloc_handlermode == 0) {
			return piVar1;
		}
		BVar4 = internal::__call_new_handler(size);
		if (BVar4 == 0) {
			return NULL;
		}
	} while( true );
}



void __cdecl std::qsort(void *base,uint number,uint width,CompareCallback *compare)
{
	uint uVar1;
	int iVar2;
	byte *a;
	byte *b;
	byte *local_100;
	byte **local_fc;
	byte **local_f8;
	int local_f4;
	byte *local_f0 [30];
	byte *local_78 [30];
	
	if ((number < 2) || (width == 0)) {
		return;
	}
	local_100 = (byte *)((number - 1) * width + (int)base);
	local_fc = local_f0;
	local_f8 = local_78;
	local_f4 = 0;
LAB_0048e134:
	uVar1 = (uint)(local_100 + -(int)base) / width + 1;
	if (8 < uVar1) {
		internal::__memswap((byte *)((int)base + (uVar1 >> 1) * width),(byte *)base,width);
		b = local_100 + width;
		a = (byte *)base;
LAB_0048e1ae:
		a = a + width;
		if (a <= local_100) goto code_r0x0048e1b8;
		goto LAB_0048e1c8;
	}
	internal::__qsort((byte *)base,local_100,width,compare);
	goto LAB_0048e155;
code_r0x0048e1b8:
	iVar2 = (*compare)(a,base);
	if (iVar2 < 1) goto LAB_0048e1ae;
LAB_0048e1c8:
	do {
		b = b + -width;
		if (b <= base) break;
		iVar2 = (*compare)(b,base);
	} while (-1 < iVar2);
	if (a <= b) {
		internal::__memswap(a,b,width);
		goto LAB_0048e1ae;
	}
	internal::__memswap((byte *)base,b,width);
	if ((int)(b + (-1 - (int)base)) < (int)(local_100 + -(int)a)) {
		if (a < local_100) {
			*local_f8 = a;
			*local_fc = local_100;
			local_f4 += 1;
			local_f8 = local_f8 + 1;
			local_fc = local_fc + 1;
		}
		if ((byte *)((int)base + width) < b) {
			local_100 = b + -width;
			goto LAB_0048e134;
		}
	}
	else {
		if ((byte *)((int)base + width) < b) {
			*local_f8 = (byte *)base;
			*local_fc = b + -width;
			local_f4 += 1;
			local_f8 = local_f8 + 1;
			local_fc = local_fc + 1;
		}
		base = a;
		if (a < local_100) goto LAB_0048e134;
	}
LAB_0048e155:
	local_f4 += -1;
	local_f8 = local_f8 + -1;
	local_fc = local_fc + -1;
	if (local_f4 < 0) {
		return;
	}
	local_100 = *local_fc;
	base = *local_f8;
	goto LAB_0048e134;
}



void __cdecl std::internal::__qsort(byte *a,byte *b,uint width,CompareCallback *compare)
{
	int result;
	byte *dest;
	byte *item;
	
	if (a < b) {
		item = a + width;
		dest = a;
		do {
			for (; item <= b; item = item + width) {
				result = (*compare)(item,dest);
				if (0 < result) {
					dest = item;
				}
			}
			__memswap(dest,b,width);
			b = b + -width;
			item = a + width;
			dest = a;
		} while (a < b);
	}
	return;
}



void __cdecl std::internal::__memswap(byte *a,byte *b,uint count)
{
	byte bVar1;
	
	if ((a != b) && (count != 0)) {
		do {
			bVar1 = *a;
			*a = *b;
			a = a + 1;
			*b = bVar1;
			b = b + 1;
			count -= 1;
		} while (count != 0);
	}
	return;
}



// Library Function - Single Match
// Name: __ftol
// Library: Visual Studio

longlong __ftol(float10 param_1)
{
	return (longlong)ROUND(param_1);
}



float10 __cdecl std::acos(float10 x)
{
	float10 fVar1;
	double dVar2;
	
	dVar2 = (double)x;
	internal::__std_FUN_00492328(dVar2);
	fVar1 = internal::__std_FUN_0048e36d(dVar2);
	return fVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

float10 __cdecl std::internal::__std_FUN_0048e36d(double param_1)
{
	uint in_EAX;
	uint in_EDX;
	bool in_ZF;
	float10 in_ST0;
	float10 extraout_ST0;
	float10 extraout_ST0_00;
	float10 fVar1;
	ushort in_FPUControlWord;
	ushort in_FPUStatusWord;
	uint uVar2;
	
	uVar2 = in_EDX & 0xffff0000 | (uint)in_FPUControlWord;
	if (in_ZF) {
		if (((in_EAX & 0xfffff) != 0) || (fVar1 = _DAT_004b2fe0, param_1._0_4_ != 0)) {
			__std_FUN_004922cc(in_EAX);
			fVar1 = extraout_ST0_00;
		}
LAB_0048e3fc:
		if (_DAT_0054a0c8 == 0) {
			fVar1 = (float10)__startOneArgErrorHandling();
			return fVar1;
		}
	}
	else {
		if (in_FPUControlWord != 0x27f) {
			in_EAX = __std_FUN_004922b5(uVar2);
			in_ST0 = extraout_ST0;
		}
		if (in_EAX < 0x3ff00000) {
			fVar1 = (float10)fpatan(SQRT(((float10)1 - in_ST0) * ((float10)1 + in_ST0)),in_ST0);
		}
		else {
			fVar1 = _DAT_004b2fe0;
			if ((0x3ff00000 < in_EAX) || ((param_1._4_4_ & 0xfffff | param_1._0_4_) != 0))
			goto LAB_0048e3fc;
			if (((ulonglong)param_1 & 0x8000000000000000) == 0) {
				fVar1 = (float10)0;
			}
			else {
				fVar1 = (float10)3.141592653589793;
			}
		}
		if (_DAT_0054a0c8 == 0) {
			if ((((short)uVar2 != 0x27f) && ((uVar2 & 0x20) != 0)) && ((in_FPUStatusWord & 0x20) != 0)) {
				fVar1 = (float10)__startOneArgErrorHandling();
				return fVar1;
			}
			return fVar1;
		}
	}
	return fVar1;
}



void __cdecl std::srand(uint seed)
{
	lego::globals::g_RAND = seed;
	return;
}



int __cdecl std::rand(void)
{
	lego::globals::g_RAND = lego::globals::g_RAND * 0x343fd + 0x269ec3;
	return (int)lego::globals::g_RAND >> 0x10 & 0x7fff;
}



float10 __cdecl std::fmod(float10 x,float10 y)
{
	float10 fVar1;
	
	fVar1 = (float10)__cintrindisp2();
	return fVar1;
}



int __cdecl std::vsprintf(char *buffer,char *format,va_list argptr)
{
	int iVar1;
	FILE dummyFile;
	
	dummyFile._base = buffer;
	dummyFile._ptr = buffer;
	dummyFile._flag = 0x42;
	dummyFile._cnt = 0x7fffffff;
	iVar1 = internal::__vfprintf_internal(&dummyFile,format,argptr);
	dummyFile._cnt += -1;
	if (-1 < dummyFile._cnt) {
		*dummyFile._ptr = '\0';
		return iVar1;
	}
	internal::__fafterwrite_00490b60(0,(char **)&dummyFile);
	return iVar1;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack

void * std::_alloca4k(uint size)
{
	undefined *puVar1;
	void *unaff_retaddr;
	
	puVar1 = &stack0x00000004;
	if (0xfff < size) {
		do {
			puVar1 = puVar1 + -0x1000;
			size -= 0x1000;
		} while (0xfff < size);
	}
	*(void **)(puVar1 + (-4 - size)) = unaff_retaddr;
	return unaff_retaddr;
}



// (probably)

float10 __cdecl __floor(double x)
{
	double dVar1;
	uint new;
	int iVar2;
	float10 fVar3;
	
	new = std::_control87(0x173f,0xffff);
	if ((x._6_2_ & 0x7ff0) != 0x7ff0) {
		fVar3 = std::internal::__std_unk_round_internal__00493410(x);
		dVar1 = (double)fVar3;
		if ((dVar1 != x) && ((new & 0x20) == 0)) {
			fVar3 = std::internal::__std_FUN_00493480(0x10,0xb,x,dVar1,new);
			return fVar3;
		}
		std::_control87(new,0xffff);
		return (float10)dVar1;
	}
	iVar2 = std::internal::__std_FUN_00493d40(x);
	if (0 < iVar2) {
		if (iVar2 < 3) {
			std::_control87(new,0xffff);
			return (float10)x;
		}
		if (iVar2 == 3) {
			fVar3 = std::internal::__std_unk_math__00493430(0xb,x,new);
			return fVar3;
		}
	}
	fVar3 = std::internal::__std_FUN_00493480(8,0xb,x,x - -1.0,new);
	return fVar3;
}



int __cdecl std::toupper(int c)
{
	int iVar1;
	uint uVar2;
	LPCWSTR pWVar3;
	int iVar4;
	uint local_8 [2];
	
	iVar1 = c;
	if (DAT_0054a180 == 0) {
		if ((0x60 < c) && (c < 0x7b)) {
			return c - 0x20;
		}
	}
	else {
		if (c < 0x100) {
										// int std::islower(int c)
			if (globals::_pcharwidth < 2) {
				uVar2 = *(byte *)(globals::_pctype + c) & C1_LOWER;
			}
			else {
				uVar2 = _isctype(c,C1_LOWER);
			}
			if (uVar2 == 0) {
				return iVar1;
			}
		}
		if ((*(byte *)((int)globals::_pctype + (iVar1 >> 8 & 0xffU) * 2 + 1) & 0x80) == 0) {
			c = c & 0xffff0000U | iVar1 & 0xffU;
			pWVar3 = (LPCWSTR)0x1;
		}
		else {
			c = c & 0xff000000U | (uint)CONCAT11((char)iVar1,(char)((uint)iVar1 >> 8));
			pWVar3 = (LPCWSTR)0x2;
		}
		iVar4 = internal::__uprlwr__00493f60(DAT_0054a180,0x200,(char *)&c,pWVar3,(LPWSTR)local_8,3,0);
		if (iVar4 == 0) {
			return iVar1;
		}
		if (iVar4 == 1) {
			return local_8[0] & 0xff;
		}
		c = (local_8[0] >> 8 & 0xff) << 8 | local_8[0] & 0xff;
	}
	return c;
}



void __cdecl std::internal::__entry__0048e740(void)
{
	if (PTR___fpmath_004b0ca8 != NULL) {
		(*(code *)PTR___fpmath_004b0ca8)();
	}
	__std_FUN_0048e860((undefined **)&DAT_004a2008,(undefined **)&DAT_004a2014);
	__std_FUN_0048e860((undefined **)&DAT_004a2000,(undefined **)&DAT_004a2004);
	return;
}



void __cdecl std::exit(int status)
{
	internal::__std_FUN_0048e7b0(status,0,0);
	return;
}



// Library Function - Single Match
// Name: __exit
// Library: Visual Studio 1998 Release

void __cdecl std::quick_exit(int _Code)
{
	internal::__std_FUN_0048e7b0(_Code,1,0);
	return;
}



void __cdecl std::internal::__std_FUN_0048e7b0(UINT param_1,int param_2,int param_3)
{
	HANDLE hProcess;
	code **ppcVar1;
	code **ppcVar2;
	UINT uExitCode;
	
	if (DAT_0054a118 == 1) {
		uExitCode = param_1;
		hProcess = GetCurrentProcess();
		TerminateProcess(hProcess,uExitCode);
	}
	DAT_0054a114 = 1;
	DAT_0054a110 = (undefined)param_3;
	if (param_2 == 0) {
		if ((DAT_0076eed0 != NULL) &&
			 (ppcVar2 = (code **)(DAT_0076eecc + -4), ppcVar1 = DAT_0076eed0, DAT_0076eed0 <= ppcVar2)) {
			do {
				if (*ppcVar2 != NULL) {
					(**ppcVar2)();
					ppcVar1 = DAT_0076eed0;
				}
				ppcVar2 = ppcVar2 + -1;
			} while (ppcVar1 <= ppcVar2);
		}
		__std_FUN_0048e860((undefined **)&DAT_004a2018,(undefined **)&DAT_004a2020);
	}
	__std_FUN_0048e860((undefined **)&DAT_004a2024,(undefined **)&DAT_004a202c);
	if (param_3 == 0) {
		DAT_0054a118 = 1;
		ExitProcess(param_1);
	}
	return;
}



void __cdecl std::internal::__std_FUN_0048e860(undefined **param_1,undefined **param_2)
{
	if (param_1 < param_2) {
		do {
			if ((code *)*param_1 != NULL) {
				(*(code *)*param_1)();
			}
			param_1 = (code **)param_1 + 1;
		} while (param_1 < param_2);
	}
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

float10 __cdecl std::sqrt(double x)
{
	uint uVar1;
	undefined4 in_ECX;
	uint extraout_EDX;
	undefined in_ZF;
	float10 extraout_ST0;
	float10 extraout_ST0_00;
	float10 fVar2;
	float10 extraout_ST0_01;
	float10 fVar3;
	ushort in_FPUControlWord;
	ushort in_FPUStatusWord;
	uint uVar4;
	
	__fload_withFB(in_ECX,(int)&x);
	uVar4 = extraout_EDX & 0xffff0000 | (uint)in_FPUControlWord;
	fVar2 = extraout_ST0;
	if ((bool)in_ZF) {
		if ((((ulonglong)x & 0xfffff00000000) == 0) && (x._0_4_ == 0)) {
			fVar3 = _DAT_004b2fe0;
			if (((ulonglong)x & 0x8000000000000000) == 0) goto LAB_0048e8be;
		}
		else {
			internal::__std_FUN_004922cc(x._4_4_);
			fVar3 = extraout_ST0_01;
		}
LAB_0048e91b:
		if (_DAT_0054a0c8 == 0) {
			fVar2 = (float10)__startOneArgErrorHandling();
			return fVar2;
		}
	}
	else {
		uVar1 = x._4_4_;
		if (in_FPUControlWord != 0x27f) {
			uVar1 = internal::__std_FUN_004922b5(uVar4);
			fVar2 = extraout_ST0_00;
		}
		if ((uVar1 & 0x80000000) == 0) {
			fVar2 = SQRT(fVar2);
		}
		else {
			fVar3 = _DAT_004b2fe0;
			if ((((uVar1 & 0x7ff00000) != 0) || ((uVar1 & 0xfffff) != 0)) || (x._0_4_ != 0))
			goto LAB_0048e91b;
		}
LAB_0048e8be:
		fVar3 = fVar2;
		if (_DAT_0054a0c8 == 0) {
			if ((((short)uVar4 != 0x27f) && ((uVar4 & 0x20) != 0)) && ((in_FPUStatusWord & 0x20) != 0)) {
				fVar2 = (float10)__startOneArgErrorHandling();
				return fVar2;
			}
			return fVar2;
		}
	}
	return fVar3;
}



// (probably)

float10 __cdecl std::round(double x)
{
	uint new;
	int iVar1;
	float10 fVar2;
	
	new = _control87(0x133f,0xffff);
	if ((x._6_2_ & 0x7ff0) != 0x7ff0) {
		_control87(new,0xffff);
		return (float10)(double)((ulonglong)x & 0x7fffffffffffffff);
	}
	iVar1 = internal::__std_FUN_00493d40(x);
	if (iVar1 == 1) {
		_control87(new,0xffff);
		return (float10)x;
	}
	if (iVar1 == 2) {
		_control87(new,0xffff);
		return -(float10)x;
	}
	if (iVar1 != 3) {
		fVar2 = internal::__std_FUN_00493480(8,0x15,x,x - -1.0,new);
		return fVar2;
	}
	fVar2 = internal::__std_unk_math__00493430(0x15,x,new);
	return fVar2;
}



// Library Function - Single Match
// Name: _strncpy
// Library: Visual Studio 1998 Release

char * __cdecl std::_strncpy(char *_Dest,char *_Source,size_t _Count)
{
	uint uVar1;
	uint uVar2;
	char cVar3;
	uint uVar4;
	uint *puVar5;
	
	if (_Count == 0) {
		return _Dest;
	}
	puVar5 = (uint *)_Dest;
	if (((uint)_Source & 3) != 0) {
		while( true ) {
			cVar3 = *_Source;
			_Source = (char *)((int)_Source + 1);
			*(char *)puVar5 = cVar3;
			puVar5 = (uint *)((int)puVar5 + 1);
			_Count -= 1;
			if (_Count == 0) {
				return _Dest;
			}
			if (cVar3 == '\0') break;
			if (((uint)_Source & 3) == 0) {
				uVar4 = _Count >> 2;
				goto joined_r0x0048ea6e;
			}
		}
		do {
			if (((uint)puVar5 & 3) == 0) {
				uVar4 = _Count >> 2;
				if (uVar4 == 0) goto LAB_0048eaab;
				goto LAB_0048eb19;
			}
			*(undefined *)puVar5 = 0;
			puVar5 = (uint *)((int)puVar5 + 1);
			_Count -= 1;
		} while (_Count != 0);
		return _Dest;
	}
	uVar4 = _Count >> 2;
	if (uVar4 != 0) {
		do {
			uVar1 = *(uint *)_Source;
			uVar2 = *(uint *)_Source;
			_Source = (char *)((int)_Source + 4);
			if (((uVar1 ^ 0xffffffff ^ uVar1 + 0x7efefeff) & 0x81010100) != 0) {
				if ((char)uVar2 == '\0') {
					*puVar5 = 0;
joined_r0x0048eb15:
					while( true ) {
						uVar4 -= 1;
						puVar5 = puVar5 + 1;
						if (uVar4 == 0) break;
LAB_0048eb19:
						*puVar5 = 0;
					}
					cVar3 = '\0';
					_Count &= 3;
					if (_Count != 0) goto LAB_0048eaab;
					return _Dest;
				}
				if ((char)(uVar2 >> 8) == '\0') {
					*puVar5 = uVar2 & 0xff;
					goto joined_r0x0048eb15;
				}
				if ((uVar2 & 0xff0000) == 0) {
					*puVar5 = uVar2 & 0xffff;
					goto joined_r0x0048eb15;
				}
				if ((uVar2 & 0xff000000) == 0) {
					*puVar5 = uVar2;
					goto joined_r0x0048eb15;
				}
			}
			*puVar5 = uVar2;
			puVar5 = puVar5 + 1;
			uVar4 -= 1;
joined_r0x0048ea6e:
		} while (uVar4 != 0);
		_Count &= 3;
		if (_Count == 0) {
			return _Dest;
		}
	}
	do {
		cVar3 = *_Source;
		_Source = (char *)((int)_Source + 1);
		*(char *)puVar5 = cVar3;
		puVar5 = (uint *)((int)puVar5 + 1);
		if (cVar3 == '\0') {
			while (_Count -= 1, _Count != 0) {
LAB_0048eaab:
				*(char *)puVar5 = cVar3;
				puVar5 = (uint *)((int)puVar5 + 1);
			}
			return _Dest;
		}
		_Count -= 1;
	} while (_Count != 0);
	return _Dest;
}



int __cdecl std::_finite(double x)
{
	return (uint)((x._6_2_ & 0x7ff0) != 0x7ff0);
}



void __cdecl std::sscanf(char *buffer,char *format,...)
{
	char cVar1;
	uint uVar2;
	FILE file;
	
	uVar2 = 0xffffffff;
	file._base = buffer;
	file._ptr = buffer;
	do {
		if (uVar2 == 0) break;
		uVar2 -= 1;
		cVar1 = *buffer;
		buffer = buffer + 1;
	} while (cVar1 != '\0');
	file._cnt = ~uVar2 - 1;
	file._flag = 0x49;
	vfscanf(&file,format,&stack0x0000000c);
	return;
}



// (probably)

float10 __cdecl std::ceil(double x)
{
	double dVar1;
	uint new;
	int iVar2;
	float10 fVar3;
	
	new = _control87(0x1b3f,0xffff);
	if ((x._6_2_ & 0x7ff0) != 0x7ff0) {
		fVar3 = internal::__std_unk_round_internal__00493410(x);
		dVar1 = (double)fVar3;
		if ((dVar1 != x) && ((new & 0x20) == 0)) {
			fVar3 = internal::__std_FUN_00493480(0x10,0xc,x,dVar1,new);
			return fVar3;
		}
		_control87(new,0xffff);
		return (float10)dVar1;
	}
	iVar2 = internal::__std_FUN_00493d40(x);
	if (0 < iVar2) {
		if (iVar2 < 3) {
			_control87(new,0xffff);
			return (float10)x;
		}
		if (iVar2 == 3) {
			fVar3 = internal::__std_unk_math__00493430(0xc,x,new);
			return fVar3;
		}
	}
	fVar3 = internal::__std_FUN_00493480(8,0xc,x,x - -1.0,new);
	return fVar3;
}



// Library Function - Single Match
// Name: __alldiv
// Library: Visual Studio

undefined8 __alldiv(uint param_1,uint param_2,uint param_3,uint param_4)
{
	ulonglong uVar1;
	longlong lVar2;
	uint uVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	bool bVar10;
	char cVar11;
	uint uVar9;
	
	cVar11 = (int)param_2 < 0;
	if ((bool)cVar11) {
		bVar10 = param_1 != 0;
		param_1 = -param_1;
		param_2 = -(uint)bVar10 - param_2;
	}
	if ((int)param_4 < 0) {
		cVar11 += '\x01';
		bVar10 = param_3 != 0;
		param_3 = -param_3;
		param_4 = -(uint)bVar10 - param_4;
	}
	uVar3 = param_1;
	uVar5 = param_3;
	uVar6 = param_2;
	uVar9 = param_4;
	if (param_4 == 0) {
		uVar3 = param_2 / param_3;
		iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
								 (ulonglong)param_3);
	}
	else {
		do {
			uVar8 = uVar9 >> 1;
			uVar5 = uVar5 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
			uVar7 = uVar6 >> 1;
			uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
			uVar6 = uVar7;
			uVar9 = uVar8;
		} while (uVar8 != 0);
		uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar5;
		iVar4 = (int)uVar1;
		lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
		uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
		uVar5 = uVar3 + iVar4 * param_4;
		if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar5)) ||
			 ((param_2 <= uVar5 && (param_1 < (uint)lVar2)))) {
			iVar4 += -1;
		}
		uVar3 = 0;
	}
	if (cVar11 == '\x01') {
		bVar10 = iVar4 != 0;
		iVar4 = -iVar4;
		uVar3 = -(uint)bVar10 - uVar3;
	}
	return CONCAT44(uVar3,iVar4);
}



// Library Function - Single Match
// Name: __allmul
// Library: Visual Studio

ulonglong __allmul(uint param_1,uint param_2,uint param_3,uint param_4)
{
	if ((param_4 | param_2) == 0) {
		return (ulonglong)param_1 * (ulonglong)param_3;
	}
	return (ulonglong)param_1 * (ulonglong)param_3 & 0xffffffff |
				 (ulonglong)
				 ((int)((ulonglong)param_1 * (ulonglong)param_3 >> 0x20) +
				 param_2 * param_3 + param_1 * param_4) << 0x20;
}



void * __cdecl std::operator_new(uint length)
{
	void *pvVar1;
	
	pvVar1 = internal::__malloc_handlermode(length,1);
	return pvVar1;
}



int __cdecl std::fclose(FILE *stream)
{
	int iVar1;
	int iVar2;
	
	iVar2 = -1;
	if ((stream->_flag & 0x40U) != 0) {
		stream->_flag = 0;
		return -1;
	}
	if ((stream->_flag & 0x83U) != 0) {
		iVar2 = internal::__std_fflush__0048ffe0(stream);
		internal::__ffree__004950b0(stream);
		iVar1 = internal::__fdclose__00494fd0(stream->_file);
		if (iVar1 < 0) {
			stream->_flag = 0;
			return -1;
		}
		if (stream->_tmpfname != NULL) {
			free(stream->_tmpfname);
			stream->_tmpfname = NULL;
		}
	}
	stream->_flag = 0;
	return iVar2;
}



FILE * __cdecl std::_fsopen(LPCSTR filename,char *mode,int shflag)
{
	FILE *stream;
	
	stream = internal::__fsopen__004952c0();
	if (stream == NULL) {
		return NULL;
	}
	stream = internal::__fsopen__004950f0(filename,mode,shflag,stream);
	return stream;
}



FILE * __cdecl std::fopen(LPCSTR filename,char *mode)
{
	FILE *pFVar1;
	
	pFVar1 = _fsopen(filename,mode,SH_DENYNO);
	return pFVar1;
}



void std::internal::__std_FUN_0048ee70(undefined *UNRECOVERED_JUMPTABLE)
{
	undefined4 *in_FS_OFFSET;
	
	*in_FS_OFFSET = *(undefined4 *)*in_FS_OFFSET;
										// WARNING: Could not recover jumptable at 0x0048ee9b. Too many branches
										// WARNING: Treating indirect jump as call
	(*(code *)UNRECOVERED_JUMPTABLE)();
	return;
}



void std::internal::__std_FUN_0048eeb0(undefined4 param_1,undefined *UNRECOVERED_JUMPTABLE)
{
										// WARNING: Could not recover jumptable at 0x0048eeb5. Too many branches
										// WARNING: Treating indirect jump as call
	(*(code *)UNRECOVERED_JUMPTABLE)();
	return;
}



void std::internal::__std_FUN_0048eec0(PVOID param_1,PEXCEPTION_RECORD param_2)
{
	undefined4 *puVar1;
	undefined4 *in_FS_OFFSET;
	
	puVar1 = (undefined4 *)*in_FS_OFFSET;
	RtlUnwind(param_1,(PVOID)0x48eeec,param_2,NULL);
	param_2->ExceptionFlags = param_2->ExceptionFlags & 0xfffffffd;
	*puVar1 = *in_FS_OFFSET;
	*in_FS_OFFSET = puVar1;
	return;
}



undefined4
std::internal::__std_FUN_0048ef20
					(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3,undefined4 param_4)
{
	int *in_EAX;
	undefined4 uVar1;
	
	uVar1 = __std_FUN_00495350(param_1,param_2,param_3,param_4,in_EAX,NULL,NULL,0);
	return uVar1;
}



undefined4 __cdecl
std::internal::__std_FUN_0048ef60
					(undefined4 param_1,undefined4 param_2,undefined4 param_3,int param_4,int param_5)
{
	undefined4 uVar1;
	int **in_FS_OFFSET;
	int *local_18;
	code *local_14;
	undefined4 local_10;
	undefined4 local_c;
	int local_8;
	
	local_8 = param_4 + 1;
	local_14 = __std_FUN_0048efc0;
	local_10 = param_2;
	local_c = param_1;
	local_18 = *in_FS_OFFSET;
	*in_FS_OFFSET = (int *)&local_18;
	uVar1 = __CallSettingFrame_12(param_3,param_1,param_5);
	*in_FS_OFFSET = local_18;
	return uVar1;
}



void __cdecl
std::internal::__std_FUN_0048efc0(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3)
{
	__std_FUN_00495350(param_1,*(PVOID *)((int)param_2 + 0xc),param_3,0,*(int **)((int)param_2 + 8),
										 *(PVOID *)((int)param_2 + 0x10),param_2,0);
	return;
}



undefined4 __cdecl
std::internal::__std_FUN_0048eff0
					(undefined4 *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
					undefined4 param_5,undefined4 param_6,undefined4 param_7)
{
	undefined4 **in_FS_OFFSET;
	undefined4 local_38;
	undefined4 *local_34;
	undefined4 local_30;
	undefined4 *local_2c;
	code *local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined4 local_1c;
	undefined4 local_18;
	undefined4 local_14;
	undefined *local_10;
	undefined *local_c;
	int local_8;
	
	local_c = &stack0xfffffffc;
	local_10 = &stack0xffffffbc;
	local_28 = __std_FUN_0048f0c0;
	local_24 = param_5;
	local_20 = param_2;
	local_1c = param_6;
	local_18 = param_7;
	local_8 = 0;
	local_14 = 0x48f08a;
	local_2c = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_2c;
	local_38 = 1;
	local_34 = param_1;
	local_30 = param_3;
	(*DAT_0054a19c)(*param_1,&local_34);
	if (local_8 == 0) {
		*in_FS_OFFSET = local_2c;
	}
	else {
		*local_2c = **in_FS_OFFSET;
		*in_FS_OFFSET = local_2c;
	}
	return 0;
}



undefined4 __cdecl
std::internal::__std_FUN_0048f0c0(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3)
{
	undefined4 uVar1;
	
	if ((param_1->ExceptionFlags & 0x66) != 0) {
		*(undefined4 *)((int)param_2 + 0x24) = 1;
		return 1;
	}
	__std_FUN_00495350(param_1,*(PVOID *)((int)param_2 + 0xc),param_3,0,*(int **)((int)param_2 + 8),
										 *(PVOID *)((int)param_2 + 0x10),*(PVOID *)((int)param_2 + 0x14),1);
	if (*(int *)((int)param_2 + 0x24) == 0) {
		__std_FUN_0048eec0(param_2,param_1);
	}
										// WARNING: Could not recover jumptable at 0x0048f134. Too many branches
										// WARNING: Treating indirect jump as call
	uVar1 = (**(code **)((int)param_2 + 0x18))();
	return uVar1;
}



int __cdecl
std::internal::__std_FUN_0048f150(int param_1,int param_2,int param_3,uint *param_4,uint *param_5)
{
	int iVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	
	iVar2 = *(int *)(param_1 + 0x10);
	uVar3 = *(uint *)(param_1 + 0xc);
	uVar4 = uVar3;
	uVar5 = uVar3;
	if (-1 < param_2) {
		do {
			if (uVar4 == 0xffffffff) {
				__std_FUN_00495e30();
			}
			uVar4 -= 1;
			iVar1 = iVar2 + uVar4 * 0x14;
			if (((*(int *)(iVar1 + 4) < param_3) && (param_3 <= *(int *)(iVar1 + 8))) ||
				 (uVar4 == 0xffffffff)) {
				param_2 += -1;
				uVar3 = uVar5;
				uVar5 = uVar4;
			}
		} while (-1 < param_2);
	}
	uVar4 += 1;
	*param_4 = uVar4;
	*param_5 = uVar3;
	if ((*(uint *)(param_1 + 0xc) <= uVar3 && uVar3 != *(uint *)(param_1 + 0xc)) || (uVar3 < uVar4)) {
		__std_FUN_00495e30();
	}
	return iVar2 + uVar4 * 0x14;
}



// Library Function - Single Match
// Name: __global_unwind2
// Library: Visual Studio

void __cdecl __global_unwind2(PVOID param_1)
{
	RtlUnwind(param_1,(PVOID)0x48f1e8,NULL,NULL);
	return;
}



// Library Function - Single Match
// Name: __local_unwind2
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __cdecl __local_unwind2(int param_1,int param_2)
{
	int iVar1;
	int iVar2;
	undefined4 *in_FS_OFFSET;
	undefined4 uStack28;
	undefined *puStack24;
	undefined4 local_14;
	int iStack16;
	
	iStack16 = param_1;
	puStack24 = &LAB_0048f1f0;
	uStack28 = *in_FS_OFFSET;
	*in_FS_OFFSET = &uStack28;
	while( true ) {
		iVar1 = *(int *)(param_1 + 8);
		iVar2 = *(int *)(param_1 + 0xc);
		if ((iVar2 == -1) || (iVar2 == param_2)) break;
		local_14 = *(undefined4 *)(iVar1 + iVar2 * 0xc);
		*(undefined4 *)(param_1 + 0xc) = local_14;
		if (*(int *)(iVar1 + 4 + iVar2 * 0xc) == 0) {
			__NLG_Notify(0x101);
			(**(code **)(iVar1 + 8 + iVar2 * 0xc))();
		}
	}
	*in_FS_OFFSET = uStack28;
	return;
}



// Library Function - Single Match
// Name: __abnormal_termination
// Library: Visual Studio

int __cdecl __abnormal_termination(void)
{
	int iVar1;
	int iVar2;
	int *in_FS_OFFSET;
	
	iVar2 = 0;
	iVar1 = *in_FS_OFFSET;
	if ((*(undefined **)(iVar1 + 4) == &LAB_0048f1f0) &&
		 (*(int *)(iVar1 + 8) == *(int *)(*(int *)(iVar1 + 0xc) + 0xc))) {
		iVar2 = 1;
	}
	return iVar2;
}



// Library Function - Single Match
// Name: __NLG_Notify1
// Libraries: Visual Studio 2003 Debug, Visual Studio 2003 Release

void __fastcall __NLG_Notify1(undefined4 param_1)
{
	undefined4 in_EAX;
	undefined4 unaff_EBP;
	
	DAT_004b0d54 = in_EAX;
	DAT_004b0d58 = param_1;
	DAT_004b0d5c = unaff_EBP;
	return;
}



// Library Function - Single Match
// Name: __NLG_Notify
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __NLG_Notify(ulong param_1)
{
	undefined4 in_EAX;
	int unaff_EBP;
	
	DAT_004b0d54 = in_EAX;
	DAT_004b0d58 = *(undefined4 *)(unaff_EBP + 8);
	DAT_004b0d5c = unaff_EBP;
	return;
}



void entry(void)
{
	byte bVar1;
	DWORD DVar2;
	BOOL BVar3;
	uint nShowCmd;
	HINSTANCE hInstance;
	int status;
	LPSTR *ppCVar4;
	undefined4 *in_FS_OFFSET;
	HINSTANCE hPrevInstance;
	LPSTR lpCmdLine;
	STARTUPINFOA startupInfo;
	undefined4 local_14;
	undefined *puStack16;
	undefined *puStack12;
	undefined4 local_8;
	
	local_8 = 0xffffffff;
	puStack12 = &DAT_0049fb20;
	puStack16 = &LAB_00496a98;
	local_14 = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_14;
	DVar2 = GetVersion();
	std::globals::g_dwMajorVersion = DVar2 >> 8 & 0xff;
	std::globals::g_dwMinorVersion = DVar2 & 0xff;
	std::globals::g_dwMajorMinorVersion =
			 std::globals::g_dwMinorVersion * 0x100 + std::globals::g_dwMajorVersion;
	std::globals::g_dwBuildNumber = DVar2 >> 0x10;
	BVar3 = std::internal::__entry__00491820();
	if (BVar3 == 0) {
		__amsg_exit(0x1c);
	}
	local_8 = 0;
	std::internal::__entry__00496890();
	std::internal::__entry__00496880();
	std::globals::_acmdln = (LPSTR *)GetCommandLineA();
	std::globals::__initenv = std::internal::__GetEnvironmentStringsA();
	if ((std::globals::__initenv == NULL) || (std::globals::_acmdln == NULL)) {
		std::exit(-1);
	}
	std::internal::__entry__004961a0();
	std::internal::__entry__004960b0();
	std::internal::__entry__0048e740();
	lpCmdLine = (LPSTR)std::globals::_acmdln;
	if (*(char *)std::globals::_acmdln == '\"') {
		while( true ) {
			ppCVar4 = (LPSTR *)lpCmdLine;
			lpCmdLine = (LPSTR)((int)ppCVar4 + 1);
			bVar1 = *lpCmdLine;
			if ((bVar1 == '\"') || (bVar1 == 0)) break;
			BVar3 = std::internal::__entry_cmdline__00496050((uint)bVar1);
			if (BVar3 != 0) {
				lpCmdLine = (LPSTR)((int)ppCVar4 + 2);
			}
		}
		if (*lpCmdLine == '\"') {
			lpCmdLine = (LPSTR)((int)ppCVar4 + 2);
		}
	}
	else {
		for (; 0x20 < (byte)*lpCmdLine; lpCmdLine = (LPSTR)((int)lpCmdLine + 1)) {
		}
	}
	for (; (*lpCmdLine != 0 && ((byte)*lpCmdLine < 0x21)); lpCmdLine = lpCmdLine + 1) {
	}
	startupInfo.dwFlags = 0;
	GetStartupInfoA((LPSTARTUPINFOA)&startupInfo);
	if ((startupInfo.dwFlags & 1) == 0) {
										// STARTF_USECOUNTCHARS (0x8) | STARTF_USESIZE (0x2)
		nShowCmd = 10;
	}
	else {
										// WORD wShowWindow
		nShowCmd = startupInfo._48_4_ & 0xffff;
	}
	hPrevInstance = NULL;
	hInstance = (HINSTANCE)GetModuleHandleA(NULL);
	status = lego::WinMain(hInstance,hPrevInstance,lpCmdLine,nShowCmd);
	std::exit(status);
	*in_FS_OFFSET = local_14;
	return;
}



// Library Function - Single Match
// Name: __amsg_exit
// Library: Visual Studio 1998 Release

void __cdecl __amsg_exit(int param_1)
{
	if (DAT_0054a124 == 1) {
		std::internal::__std_FUN_00496b70();
	}
	std::internal::__std_FUN_00496bb0(param_1);
	(*(code *)PTR_quick_exit_004b0d60)(0xff);
	return;
}



BOOL __cdecl std::_isctype(int c,uint desc)
{
	int iVar1;
	LCID LVar2;
	uint local_4;
	
	if (c + 1U < 0x101) {
		return globals::_pctype[c] & desc;
	}
	if ((*(byte *)((int)globals::_pctype + (c >> 8 & 0xffU) * 2 + 1) & 0x80) == 0) {
		c &= 0xffff00ff;
		iVar1 = 1;
	}
	else {
		c = c & 0xff000000U | (uint)CONCAT11((char)c,(char)((uint)c >> 8));
		iVar1 = 2;
	}
	LVar2 = internal::__ctype_internal(1,(LPCSTR)&c,iVar1,(LPWORD)&local_4,0,0);
	if (LVar2 == 0) {
		return 0;
	}
	return local_4 & 0xffff & desc;
}



// Library Function - Single Match
// Name: _strncmp
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release

int __cdecl std::strncmp(char *_Str1,char *_Str2,size_t _MaxCount)
{
	char cVar1;
	char cVar2;
	byte bVar3;
	size_t sVar4;
	int iVar5;
	uint uVar6;
	char *pcVar7;
	char *pcVar8;
	bool bVar9;
	
	sVar4 = _MaxCount;
	pcVar7 = _Str1;
	if (_MaxCount != 0) {
		do {
			if (sVar4 == 0) break;
			sVar4 -= 1;
			cVar1 = *pcVar7;
			pcVar7 = pcVar7 + 1;
		} while (cVar1 != '\0');
		iVar5 = _MaxCount - sVar4;
		do {
			pcVar7 = _Str2;
			pcVar8 = _Str1;
			if (iVar5 == 0) break;
			iVar5 += -1;
			pcVar8 = _Str1 + 1;
			pcVar7 = _Str2 + 1;
			cVar1 = *_Str2;
			cVar2 = *_Str1;
			_Str2 = pcVar7;
			_Str1 = pcVar8;
		} while (cVar1 == cVar2);
		bVar3 = pcVar7[-1];
		uVar6 = 0;
		bVar9 = bVar3 == pcVar8[-1];
		if (bVar3 < (byte)pcVar8[-1] || bVar9) {
			if (bVar9) {
				return 0;
			}
			uVar6 = 0xfffffffe;
		}
		_MaxCount = ~uVar6;
	}
	return _MaxCount;
}



long __cdecl std::ftell(FILE *stream)
{
	uint uVar1;
	uint uVar2;
	int iVar3;
	char *pcVar4;
	char *pcVar5;
	int iVar6;
	char *pcVar7;
	char *local_8;
	char *local_4;
	
	uVar1 = stream->_file;
	if (stream->_cnt < 0) {
		stream->_cnt = 0;
	}
	local_4 = (char *)internal::__fdread__00496ec0(uVar1,0,1);
	if ((int)local_4 < 0) {
		return (long)(char *)0xffffffff;
	}
	uVar2 = stream->_flag;
	if ((uVar2 & 0x108) == 0) {
		return (long)(local_4 + -stream->_cnt);
	}
	pcVar7 = stream->_ptr;
	pcVar4 = stream->_base;
	local_8 = pcVar7 + -(int)pcVar4;
	iVar3 = (int)uVar1 >> 5;
	if ((uVar2 & 3) == 0) {
		if ((uVar2 & 0x80) == 0) {
			globals::g_msvc_errno = 0x16;
			return (long)(char *)0xffffffff;
		}
	}
	else {
		pcVar5 = pcVar4;
		if ((*(byte *)((&DAT_0076edc0)[iVar3] + 4 + (uVar1 & 0x1f) * 8) & 0x80) != 0) {
			for (; pcVar5 < pcVar7; pcVar5 = pcVar5 + 1) {
				if (*pcVar5 == '\n') {
					local_8 = local_8 + 1;
				}
			}
		}
	}
	if (local_4 == NULL) {
		return (long)local_8;
	}
	if ((*(byte *)&stream->_flag & 1) == 0) goto LAB_0048f6e5;
	if (stream->_cnt == 0) {
		return (long)local_4;
	}
	pcVar7 = pcVar7 + (stream->_cnt - (int)pcVar4);
	iVar6 = (uVar1 & 0x1f) * 8;
	if ((*(byte *)(iVar6 + 4 + (&DAT_0076edc0)[iVar3]) & 0x80) != 0) {
		pcVar4 = (char *)internal::__fdread__00496ec0(uVar1,0,2);
		if (pcVar4 == local_4) {
			pcVar5 = stream->_base;
			pcVar4 = pcVar5 + (int)pcVar7;
			for (; pcVar5 < pcVar4; pcVar5 = pcVar5 + 1) {
				if (*pcVar5 == '\n') {
					pcVar7 = pcVar7 + 1;
				}
			}
			if ((stream->_flag & 0x2000U) != 0) {
LAB_0048f6dc:
				pcVar7 = pcVar7 + 1;
			}
		}
		else {
			internal::__fdread__00496ec0(uVar1,(LONG)local_4,0);
			if (((pcVar7 < (char *)0x201) && ((stream->_flag & 8U) != 0)) &&
				 ((stream->_flag & 0x400U) == 0)) {
				pcVar7 = (char *)0x200;
			}
			else {
				pcVar7 = (char *)stream->_bufsiz;
			}
			if ((*(byte *)(iVar6 + 4 + (&DAT_0076edc0)[iVar3]) & 4) != 0) goto LAB_0048f6dc;
		}
	}
	local_4 = local_4 + -(int)pcVar7;
LAB_0048f6e5:
	return (long)(local_4 + (int)local_8);
}



int __cdecl std::fseek(FILE *stream,long offset,int origin)
{
	uint uVar1;
	long lVar2;
	DWORD DVar3;
	
	if (((stream->_flag & 0x83U) != 0) && (((origin == 0 || (origin == 1)) || (origin == 2)))) {
		stream->_flag = stream->_flag & 0xffffffef;
		if (origin == 1) {
			lVar2 = ftell(stream);
			offset += lVar2;
			origin = 0;
		}
		internal::__std_fflush__0048ffe0(stream);
		uVar1 = stream->_flag;
		if ((uVar1 & 0x80) == 0) {
			if ((((uVar1 & 1) != 0) && ((uVar1 & 8) != 0)) && ((uVar1 & 0x400) == 0)) {
				stream->_bufsiz = 0x200;
			}
		}
		else {
			stream->_flag = uVar1 & 0xfffffffc;
		}
		DVar3 = internal::__fdread__00496ec0(stream->_file,offset,origin);
		return (DVar3 != 0xffffffff) - 1;
	}
	globals::g_msvc_errno = EINVAL;
	return -1;
}



size_t __cdecl std::fwrite(void *out_buffer,size_t size,size_t count,FILE *stream)
{
	FILE *stream_00;
	FILE *pFVar1;
	int iVar2;
	FILE *pFVar3;
	uint uVar4;
	FILE *pFVar5;
	FILE *pFVar6;
	undefined4 *puVar7;
	undefined4 *puVar8;
	
	stream_00 = stream;
	pFVar5 = (FILE *)(count * size);
	if (pFVar5 == NULL) {
		return 0;
	}
	pFVar6 = pFVar5;
	if ((stream->_flag & 0x10cU) == 0) {
		stream = (FILE *)0x1000;
	}
	else {
		stream = (FILE *)stream->_bufsiz;
	}
	do {
		uVar4 = stream_00->_flag & 0x108;
		if ((uVar4 == 0) || (pFVar1 = (FILE *)stream_00->_cnt, pFVar1 == NULL)) {
			if (pFVar6 < stream) {
										// WARNING: Load size is inaccurate
				uVar4 = internal::__fafterwrite_00490b60((int)*out_buffer,(char **)stream_00);
				if (uVar4 == 0xffffffff) goto LAB_0048f8f4;
				stream = (FILE *)stream_00->_bufsiz;
				out_buffer = (void *)((int)out_buffer + 1);
				pFVar6 = (FILE *)((int)&pFVar6[-1]._tmpfname + 3);
				if ((int)stream < 1) {
					stream = (FILE *)0x1;
				}
			}
			else {
				if ((uVar4 != 0) && (iVar2 = internal::__std_fflush__0048ffe0(stream_00), iVar2 != 0)) {
LAB_0048f8f4:
					return (uint)((int)pFVar5 - (int)pFVar6) / size;
				}
				pFVar1 = pFVar6;
				if (stream != NULL) {
					pFVar1 = (FILE *)((int)pFVar6 - (uint)pFVar6 % (uint)stream);
				}
				pFVar3 = (FILE *)internal::__fdwrite__00496f80
																	 (stream_00->_file,(char *)out_buffer,(char *)pFVar1);
				if (pFVar3 == (FILE *)0xffffffff) {
LAB_0048f8d9:
					stream_00->_flag = stream_00->_flag | 0x20;
					return (uint)((int)pFVar5 - (int)pFVar6) / size;
				}
				pFVar6 = (FILE *)((int)pFVar6 - (int)pFVar3);
				out_buffer = (void *)((int)out_buffer + (int)pFVar3);
				if (pFVar3 < pFVar1) goto LAB_0048f8d9;
			}
		}
		else {
			if (pFVar6 < pFVar1) {
				pFVar1 = pFVar6;
			}
			pFVar6 = (FILE *)((int)pFVar6 - (int)pFVar1);
			puVar7 = (undefined4 *)out_buffer;
			puVar8 = (undefined4 *)stream_00->_ptr;
			for (uVar4 = (uint)pFVar1 >> 2; uVar4 != 0; uVar4 -= 1) {
				*puVar8 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar8 = puVar8 + 1;
			}
			for (uVar4 = (uint)pFVar1 & 3; uVar4 != 0; uVar4 -= 1) {
				*(undefined *)puVar8 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar8 = (undefined4 *)((int)puVar8 + 1);
			}
			out_buffer = (void *)((int)out_buffer + (int)pFVar1);
			stream_00->_cnt = stream_00->_cnt - (int)pFVar1;
			stream_00->_ptr = (char *)((int)&pFVar1->_ptr + (int)stream_00->_ptr);
		}
		if (pFVar6 == NULL) {
			return count;
		}
	} while( true );
}



int __cdecl std::remove(LPCSTR filename)
{
	BOOL BVar1;
	uint error_value;
	
	BVar1 = DeleteFileA(filename);
	if (BVar1 == 0) {
		error_value = GetLastError();
	}
	else {
		error_value = 0;
	}
	if (error_value != 0) {
		internal::__set_doserrno(error_value);
		return -1;
	}
	return 0;
}



int __cdecl std::_chmod(LPCSTR filename,int pmode)
{
	DWORD DVar1;
	BOOL BVar2;
	
	DVar1 = GetFileAttributesA(filename);
	if (DVar1 != INVALID_FILE_ATTRIBUTES) {
		if ((pmode & FILE_ATTRIBUTE_NORMAL) == 0) {
			DVar1 |= 1;
		}
		else {
			DVar1 &= 0xfffffffe;
		}
		BVar2 = SetFileAttributesA(filename,DVar1);
		if (BVar2 != 0) {
			return 0;
		}
	}
	DVar1 = GetLastError();
	internal::__set_doserrno(DVar1);
	return -1;
}



int __cdecl std::_mkdir(LPCSTR dirname)
{
	BOOL BVar1;
	uint error_value;
	
	BVar1 = CreateDirectoryA(dirname,NULL);
	if (BVar1 == 0) {
		error_value = GetLastError();
	}
	else {
		error_value = 0;
	}
	if (error_value != 0) {
		internal::__set_doserrno(error_value);
		return -1;
	}
	return 0;
}



HANDLE __cdecl std::_findfirst32(LPCSTR filename,_finddata32_t *fileinfo)
{
	char cVar1;
	HANDLE pvVar2;
	DWORD DVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	char *pcVar9;
	undefined4 *puVar10;
	_WIN32_FIND_DATAA local_140;
	
	pvVar2 = FindFirstFileA(filename,(LPWIN32_FIND_DATAA)&local_140);
	if (pvVar2 == (HANDLE)0xffffffff) {
		DVar3 = GetLastError();
		if (true) {
			switch(DVar3) {
			case 2:
			case 3:
			case 0x12:
				globals::g_msvc_errno = 2;
				return (HANDLE)0xffffffff;
			case 8:
				globals::g_msvc_errno = 0xc;
				return (HANDLE)0xffffffff;
			}
		}
		globals::g_msvc_errno = 0x16;
		return (HANDLE)0xffffffff;
	}
	fileinfo->attrib = -(uint)(local_140.dwFileAttributes != 0x80) & local_140.dwFileAttributes;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftCreationTime);
	fileinfo->time_create = iVar4;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftLastAccessTime);
	fileinfo->time_access = iVar4;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftLastWriteTime);
	fileinfo->time_write = iVar4;
	uVar5 = 0xffffffff;
	pcVar8 = local_140.cFileName;
	do {
		pcVar9 = pcVar8;
		if (uVar5 == 0) break;
		uVar5 -= 1;
		pcVar9 = pcVar8 + 1;
		cVar1 = *pcVar8;
		pcVar8 = pcVar9;
	} while (cVar1 != '\0');
	uVar5 = ~uVar5;
	fileinfo->size = local_140.nFileSizeLow;
	puVar7 = (undefined4 *)(pcVar9 + -uVar5);
	puVar10 = (undefined4 *)fileinfo->name;
	for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
		*puVar10 = *puVar7;
		puVar7 = puVar7 + 1;
		puVar10 = puVar10 + 1;
	}
	for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
		*(undefined *)puVar10 = *(undefined *)puVar7;
		puVar7 = (undefined4 *)((int)puVar7 + 1);
		puVar10 = (undefined4 *)((int)puVar10 + 1);
	}
	return pvVar2;
}



int __cdecl std::_findnext32(HANDLE handle,_finddata32_t *fileinfo)
{
	char cVar1;
	BOOL BVar2;
	DWORD DVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	char *pcVar8;
	char *pcVar9;
	undefined4 *puVar10;
	_WIN32_FIND_DATAA local_140;
	
	BVar2 = FindNextFileA(handle,(LPWIN32_FIND_DATAA)&local_140);
	if (BVar2 == 0) {
		DVar3 = GetLastError();
		if (true) {
			switch(DVar3) {
			case 2:
			case 3:
			case 0x12:
				globals::g_msvc_errno = ENOENT;
				return -1;
			case 8:
				globals::g_msvc_errno = ENOMEM;
				return -1;
			}
		}
		globals::g_msvc_errno = EINVAL;
		return -1;
	}
	fileinfo->attrib = -(uint)(local_140.dwFileAttributes != 0x80) & local_140.dwFileAttributes;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftCreationTime);
	fileinfo->time_create = iVar4;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftLastAccessTime);
	fileinfo->time_access = iVar4;
	iVar4 = internal::__unk_ftime__0048fc30(&local_140.ftLastWriteTime);
	fileinfo->time_write = iVar4;
	uVar5 = 0xffffffff;
	pcVar8 = local_140.cFileName;
	do {
		pcVar9 = pcVar8;
		if (uVar5 == 0) break;
		uVar5 -= 1;
		pcVar9 = pcVar8 + 1;
		cVar1 = *pcVar8;
		pcVar8 = pcVar9;
	} while (cVar1 != '\0');
	uVar5 = ~uVar5;
	fileinfo->size = local_140.nFileSizeLow;
	puVar7 = (undefined4 *)(pcVar9 + -uVar5);
	puVar10 = (undefined4 *)fileinfo->name;
	for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
		*puVar10 = *puVar7;
		puVar7 = puVar7 + 1;
		puVar10 = puVar10 + 1;
	}
	for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
		*(undefined *)puVar10 = *(undefined *)puVar7;
		puVar7 = (undefined4 *)((int)puVar7 + 1);
		puVar10 = (undefined4 *)((int)puVar10 + 1);
	}
	return 0;
}



int __cdecl std::_findclose(HANDLE handle)
{
	BOOL BVar1;
	
	BVar1 = FindClose(handle);
	if (BVar1 == 0) {
		globals::g_msvc_errno = 0x16;
		return -1;
	}
	return 0;
}



int __cdecl std::internal::__unk_ftime__0048fc30(FILETIME *param_1)
{
	BOOL BVar1;
	int iVar2;
	_FILETIME local_18;
	_SYSTEMTIME local_10;
	
	if ((param_1->dwLowDateTime != 0) || (param_1->dwHighDateTime != 0)) {
		BVar1 = FileTimeToLocalFileTime(param_1,(LPFILETIME)&local_18);
		if (BVar1 != 0) {
			BVar1 = FileTimeToSystemTime((FILETIME *)&local_18,(LPSYSTEMTIME)&local_10);
			if (BVar1 != 0) {
				iVar2 = __unkftime__00497210
													((uint)local_10.wYear,(uint)local_10.wMonth,(uint)local_10.wDay,
													 (uint)local_10.wHour,(uint)local_10.wMinute,(uint)local_10.wSecond,-1);
				return iVar2;
			}
		}
	}
	return -1;
}



char * __cdecl std::_getcwd(char *out_buffer,int maxlen)
{
	char *pcVar1;
	
	pcVar1 = _getdcwd(0,out_buffer,maxlen);
	return pcVar1;
}



char * __cdecl std::_getdcwd(int drive,char *out_buffer,int maxlen)
{
	char cVar1;
	BOOL BVar2;
	DWORD DVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	char *pcVar7;
	char *pcVar8;
	undefined4 *puVar9;
	char local_10c;
	undefined local_10b;
	undefined local_10a;
	undefined local_109;
	LPSTR local_108;
	CHAR local_104 [260];
	
	if (drive == 0) {
		DVar3 = GetCurrentDirectoryA(MAX_PATH,local_104);
	}
	else {
		BVar2 = internal::__dcwd_exists(drive);
		if (BVar2 == 0) {
			globals::g_msvc_errno = EACCES;
			globals::g_msvc_doserrno = 0xf;
			return NULL;
		}
		local_10c = (char)drive + '@';
		local_10b = 0x3a;
		local_10a = 0x2e;
		local_109 = 0;
		DVar3 = GetFullPathNameA(&local_10c,MAX_PATH,local_104,&local_108);
	}
	if ((DVar3 == 0) || (uVar4 = DVar3 + 1, MAX_PATH < uVar4)) {
		return (char *)NULL;
	}
	if (out_buffer == NULL) {
		if ((int)uVar4 <= maxlen) {
			uVar4 = maxlen;
		}
		out_buffer = (char *)malloc(uVar4);
		if ((undefined4 *)out_buffer == NULL) {
			globals::g_msvc_errno = ENOMEM;
			return NULL;
		}
	}
	else {
		if (maxlen < (int)uVar4) {
			globals::g_msvc_errno = ERANGE;
			return (char *)NULL;
		}
	}
	uVar4 = 0xffffffff;
	pcVar7 = local_104;
	do {
		pcVar8 = pcVar7;
		if (uVar4 == 0) break;
		uVar4 -= 1;
		pcVar8 = pcVar7 + 1;
		cVar1 = *pcVar7;
		pcVar7 = pcVar8;
	} while (cVar1 != '\0');
	uVar4 = ~uVar4;
	puVar6 = (undefined4 *)(pcVar8 + -uVar4);
	puVar9 = (undefined4 *)out_buffer;
	for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
		*puVar9 = *puVar6;
		puVar6 = puVar6 + 1;
		puVar9 = puVar9 + 1;
	}
	for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
		*(undefined *)puVar9 = *(undefined *)puVar6;
		puVar6 = (undefined4 *)((int)puVar6 + 1);
		puVar9 = (undefined4 *)((int)puVar9 + 1);
	}
	return (char *)(undefined4 *)out_buffer;
}



BOOL __cdecl std::internal::__dcwd_exists(int drive)
{
	UINT UVar1;
	
	if (drive == 0) {
		return 1;
	}
	drive = ZEXT34(CONCAT12('\\',CONCAT11(':',(char)drive + '@')));
	UVar1 = GetDriveTypeA((LPCSTR)&drive);
	if ((UVar1 != 0) && (UVar1 != DRIVE_NO_ROOT_DIR)) {
		return 1;
	}
	return 0;
}



size_t __cdecl std::fread(void *out_buffer,size_t size,size_t count,FILE *stream)
{
	FILE *file;
	FILE *pFVar1;
	char *pcVar2;
	int iVar3;
	uint uVar4;
	FILE *pFVar5;
	FILE *pFVar6;
	undefined4 *puVar7;
	FILE *pFVar8;
	undefined4 *puVar9;
	
	file = stream;
	pFVar5 = (FILE *)(count * size);
	if (pFVar5 == NULL) {
		return 0;
	}
	pFVar6 = pFVar5;
	if ((stream->_flag & 0x10cU) == 0) {
		stream = (FILE *)0x1000;
		pFVar8 = (FILE *)0x1000;
	}
	else {
		pFVar8 = (FILE *)stream->_bufsiz;
		stream = pFVar8;
	}
	do {
		if (((file->_flag & 0x10cU) == 0) || (pFVar1 = (FILE *)file->_cnt, pFVar1 == NULL)) {
			if (pFVar6 < pFVar8) {
				iVar3 = internal::__fpeekc(file);
				if (iVar3 == -1) {
					return (uint)((int)pFVar5 - (int)pFVar6) / size;
				}
				*(char *)out_buffer = (char)iVar3;
				pFVar8 = (FILE *)file->_bufsiz;
				out_buffer = (void *)((int)out_buffer + 1);
				iVar3 = -1;
				stream = pFVar8;
			}
			else {
				pFVar1 = pFVar6;
				if (pFVar8 != NULL) {
					pFVar1 = (FILE *)((int)pFVar6 - (uint)pFVar6 % (uint)pFVar8);
				}
				pcVar2 = internal::__fdread(file->_file,(char *)out_buffer,(DWORD)pFVar1);
				if (pcVar2 == NULL) {
					file->_flag = file->_flag | 0x10;
					return (uint)((int)pFVar5 - (int)pFVar6) / size;
				}
				if (pcVar2 == (char *)0xffffffff) {
					file->_flag = file->_flag | 0x20;
					return (uint)((int)pFVar5 - (int)pFVar6) / size;
				}
				iVar3 = -(int)pcVar2;
				out_buffer = (void *)((int)out_buffer + (int)pcVar2);
			}
		}
		else {
			if (pFVar6 < pFVar1) {
				pFVar1 = pFVar6;
			}
			iVar3 = -(int)pFVar1;
			puVar7 = (undefined4 *)file->_ptr;
			puVar9 = (undefined4 *)out_buffer;
			for (uVar4 = (uint)pFVar1 >> 2; uVar4 != 0; uVar4 -= 1) {
				*puVar9 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar9 = puVar9 + 1;
			}
			for (uVar4 = (uint)pFVar1 & 3; uVar4 != 0; uVar4 -= 1) {
				*(undefined *)puVar9 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar9 = (undefined4 *)((int)puVar9 + 1);
			}
			out_buffer = (void *)((int)out_buffer + (int)pFVar1);
			file->_cnt = file->_cnt - (int)pFVar1;
			file->_ptr = (char *)((int)&pFVar1->_ptr + (int)file->_ptr);
			pFVar8 = stream;
		}
		pFVar6 = (FILE *)((int)&pFVar6->_ptr + iVar3);
		if (pFVar6 == NULL) {
			return count;
		}
	} while( true );
}



int __cdecl std::internal::__std_FUN_0048ff90(FILE *stream)
{
	int iVar1;
	
	if (stream == NULL) {
		iVar1 = __std_FUN_00490060(0);
		return iVar1;
	}
	iVar1 = __std_fflush__0048ffe0(stream);
	if (iVar1 != 0) {
		return -1;
	}
	if ((stream->_flag & 0x4000U) != 0) {
		iVar1 = __std_FUN_00497650(stream->_file);
		return -(uint)(iVar1 != 0);
	}
	return 0;
}



int __cdecl std::internal::__std_fflush__0048ffe0(FILE *stream)
{
	uint uVar1;
	char *pcVar2;
	int iVar3;
	char *pcVar4;
	
	iVar3 = 0;
	if ((((byte)stream->_flag & 3) == 2) && ((stream->_flag & 0x108U) != 0)) {
		pcVar4 = stream->_ptr + -(int)stream->_base;
		if (0 < (int)pcVar4) {
			pcVar2 = (char *)__fdwrite__00496f80(stream->_file,stream->_base,pcVar4);
			uVar1 = stream->_flag;
			if (pcVar2 == pcVar4) {
				if ((uVar1 & 0x80) != 0) {
					stream->_cnt = 0;
					stream->_flag = uVar1 & 0xfffffffd;
					stream->_ptr = stream->_base;
					return 0;
				}
			}
			else {
				iVar3 = -1;
				stream->_flag = uVar1 | 0x20;
			}
		}
	}
	stream->_cnt = 0;
	stream->_ptr = stream->_base;
	return iVar3;
}



void std::internal::__std_FUN_00490050(void)
{
	__std_FUN_00490060(1);
	return;
}



int __cdecl std::internal::__std_FUN_00490060(int param_1)
{
	FILE *stream;
	int iVar1;
	int iVar2;
	int iVar3;
	int iVar4;
	
	iVar2 = 0;
	iVar4 = 0;
	iVar3 = 0;
	if (0 < globals::__filesCount_0076eda0) {
		do {
			stream = globals::__filesTable_0076dd98[iVar3];
			if ((stream != NULL) && ((stream->_flag & 0x83U) != 0)) {
				if (param_1 == 1) {
					iVar1 = __std_FUN_0048ff90(stream);
					if (iVar1 != -1) {
						iVar2 += 1;
					}
				}
				else {
					if ((param_1 == 0) && ((stream->_flag & 2U) != 0)) {
						iVar1 = __std_FUN_0048ff90(stream);
						if (iVar1 == -1) {
							iVar4 = -1;
						}
					}
				}
			}
			iVar3 += 1;
		} while (iVar3 < globals::__filesCount_0076eda0);
	}
	if (param_1 != 1) {
		iVar2 = iVar4;
	}
	return iVar2;
}



int __cdecl std::fgetc(FILE *stream)
{
	byte bVar1;
	int iVar2;
	uint uVar3;
	
	iVar2 = stream->_cnt + -1;
	stream->_cnt = iVar2;
	if (-1 < iVar2) {
		bVar1 = *stream->_ptr;
		stream->_ptr = stream->_ptr + 1;
		return (uint)bVar1;
	}
	uVar3 = internal::__fpeekc(stream);
	return uVar3;
}



char * __cdecl std::fgets(char *str,int numChars,FILE *stream)
{
	int iVar1;
	uint uVar2;
	int iVar3;
	char *pcVar4;
	
	if (numChars < 1) {
		return NULL;
	}
	iVar3 = numChars + -1;
	pcVar4 = str;
	if (iVar3 != 0) {
		while( true ) {
			iVar1 = stream->_cnt + -1;
			stream->_cnt = iVar1;
			if (iVar1 < 0) {
				uVar2 = internal::__fpeekc(stream);
			}
			else {
				uVar2 = (uint)(byte)*stream->_ptr;
				stream->_ptr = stream->_ptr + 1;
			}
			if (uVar2 == 0xffffffff) break;
			*pcVar4 = (char)uVar2;
			pcVar4 = pcVar4 + 1;
			if ((char)uVar2 == '\n') goto LAB_00490176;
			iVar3 += -1;
			if (iVar3 == 0) {
				*pcVar4 = '\0';
				return str;
			}
		}
		if (pcVar4 == str) {
			return NULL;
		}
	}
LAB_00490176:
	*pcVar4 = '\0';
	return str;
}



int __cdecl std::vfprintf(FILE *stream,char *format,va_list argptr)
{
	BOOL BVar1;
	int iVar2;
	
	BVar1 = internal::__vfprintf__00497790(stream);
	iVar2 = internal::__vfprintf_internal(stream,format,argptr);
	internal::__vfprintf__00497830(BVar1,stream);
	return iVar2;
}



// Library Function - Single Match
// Name: __strcmpi
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release

int __cdecl std::_stricmp(char *_Str1,char *_Str2)
{
	char cVar1;
	char cVar2;
	byte bVar3;
	byte bVar5;
	uint uVar4;
	uint c;
	
	if (DAT_0054a180 == 0) {
		uVar4 = 0xff;
		do {
			do {
				cVar2 = (char)uVar4;
				if (cVar2 == '\0') goto LAB_0049021e;
				cVar2 = *_Str2;
				_Str2 = _Str2 + 1;
				cVar1 = *_Str1;
				uVar4 = (uint)CONCAT11(cVar1,cVar2);
				_Str1 = _Str1 + 1;
			} while ((char)(uVar4 >> 8) == cVar2);
			bVar3 = cVar1 + 0xbf;
			bVar3 = bVar3 + (-(bVar3 < 0x1a) & 0x20U) + 0x41;
			uVar4 = (uint)CONCAT11(cVar2 + 0xbfU + (-((byte)(cVar2 + 0xbfU) < 0x1a) & 0x20U) + 'A',bVar3);
			bVar5 = (byte)(uVar4 >> 8);
		} while (bVar3 == bVar5);
		cVar2 = (bVar3 < bVar5) * -2 + '\x01';
LAB_0049021e:
		uVar4 = SEXT14(cVar2);
	}
	else {
		c = 0;
		uVar4 = 0xff;
		do {
			do {
				if ((char)uVar4 == '\0') {
					return uVar4;
				}
				bVar3 = *_Str2;
				uVar4 = uVar4 & 0xffffff00 | (uint)bVar3;
				_Str2 = (char *)((byte *)_Str2 + 1);
				bVar5 = *_Str1;
				c = c & 0xffffff00 | (uint)bVar5;
				_Str1 = (char *)((byte *)_Str1 + 1);
			} while (bVar3 == bVar5);
			c = tolower(c);
			uVar4 = tolower(uVar4);
		} while ((byte)c == (byte)uVar4);
		uVar4 = (uint)((byte)c < (byte)uVar4);
		uVar4 = (1 - uVar4) - (uint)(uVar4 != 0);
	}
	return uVar4;
}



char * __cdecl std::_fullpath(char *out_absPath,LPCSTR relPath,uint maxLength)
{
	LPSTR lpBuffer;
	LPSTR pCVar1;
	DWORD error_value;
	char *pcVar2;
	LPSTR nBufferLength;
	
	if ((relPath == NULL) || (*relPath == '\0')) {
		pcVar2 = _getcwd(out_absPath,maxLength);
		return pcVar2;
	}
	lpBuffer = out_absPath;
	nBufferLength = (LPSTR)maxLength;
	if (out_absPath == NULL) {
		lpBuffer = (LPSTR)malloc(MAX_PATH);
		if (lpBuffer == NULL) {
			globals::g_msvc_errno = ENOMEM;
			return NULL;
		}
		nBufferLength = (LPSTR)MAX_PATH;
	}
	pCVar1 = (LPSTR)GetFullPathNameA(relPath,(DWORD)nBufferLength,lpBuffer,(LPSTR *)&maxLength);
	if (pCVar1 < nBufferLength) {
		if (pCVar1 != NULL) {
			return lpBuffer;
		}
		if (out_absPath == NULL) {
			free(lpBuffer);
		}
		error_value = GetLastError();
		internal::__set_doserrno(error_value);
		return NULL;
	}
	if (out_absPath == NULL) {
		free(lpBuffer);
	}
	globals::g_msvc_errno = ERANGE;
	return NULL;
}



int __cdecl std::fscanf(FILE *stream,char *format,...)
{
	int iVar1;
	
	iVar1 = vfscanf(stream,format,&stack0x0000000c);
	return iVar1;
}



void __cdecl std::_splitpath(char *path,char *drive,char *dir,char *fname,char *ext)
{
	char cVar1;
	byte bVar2;
	byte *pbVar3;
	int iVar4;
	byte *pbVar5;
	char *pcVar6;
	byte *local_4;
	
	iVar4 = -1;
	pcVar6 = path;
	do {
		if (iVar4 == 0) break;
		iVar4 += -1;
		cVar1 = *pcVar6;
		pcVar6 = pcVar6 + 1;
	} while (cVar1 != '\0');
	local_4 = NULL;
	if ((iVar4 == -2) || (path[1] != ':')) {
		if (drive != NULL) {
			*drive = '\0';
		}
	}
	else {
		if (drive != NULL) {
			strncpy(drive,path,2);
			drive[2] = '\0';
		}
		path = path + 2;
	}
	bVar2 = *path;
	drive = NULL;
	pbVar5 = (byte *)path;
	while (bVar2 != 0) {
		bVar2 = *pbVar5;
		if ((*(byte *)((int)&DAT_0054a2b8 + bVar2 + 1) & 4) == 0) {
			if ((bVar2 == '/') || (bVar2 == '\\')) {
				drive = (char *)(pbVar5 + 1);
			}
			else {
				if (bVar2 == '.') {
					local_4 = pbVar5;
				}
			}
		}
		else {
			pbVar5 = pbVar5 + 1;
		}
		pbVar3 = pbVar5 + 1;
		pbVar5 = pbVar5 + 1;
		bVar2 = *pbVar3;
	}
	if ((byte *)drive == NULL) {
		drive = path;
		if (dir != NULL) {
			*dir = '\0';
		}
	}
	else {
		if (dir != NULL) {
			pbVar3 = (byte *)drive + -(int)path;
			if ((byte *)0xfe < pbVar3) {
				pbVar3 = (byte *)0xff;
			}
			strncpy(dir,path,(size_t)pbVar3);
			pbVar3[(int)dir] = 0;
		}
	}
	if ((local_4 == NULL) || (local_4 < drive)) {
		if (fname != NULL) {
			pbVar5 = pbVar5 + -(int)drive;
			if ((byte *)0xfe < pbVar5) {
				pbVar5 = (byte *)0xff;
			}
			strncpy(fname,drive,(size_t)pbVar5);
			pbVar5[(int)fname] = 0;
		}
		if (ext != NULL) {
			*ext = '\0';
		}
	}
	else {
		if (fname != NULL) {
			pbVar3 = local_4 + -(int)drive;
			if ((byte *)0xfe < pbVar3) {
				pbVar3 = (byte *)0xff;
			}
			strncpy(fname,drive,(size_t)pbVar3);
			pbVar3[(int)fname] = 0;
		}
		if (ext != NULL) {
			pbVar5 = pbVar5 + -(int)local_4;
			if ((byte *)0xfe < pbVar5) {
				pbVar5 = (byte *)0xff;
			}
			strncpy(ext,(char *)local_4,(size_t)pbVar5);
			pbVar5[(int)ext] = 0;
			return;
		}
	}
	return;
}



// Library Function - Single Match
// Name: __setdefaultprecision
// Library: Visual Studio 1998 Release

void __setdefaultprecision(void)
{
	std::internal::__std_FUN_00497a70(0x10000,0x30000);
	return;
}



undefined4 std::internal::__fpmath__004904f0(void)
{
	if (false) {
		return 1;
	}
	return 0;
}



void std::internal::__fpmath__00490540(void)
{
	HMODULE hModule;
	FARPROC pFVar1;
	
	hModule = GetModuleHandleA("KERNEL32");
	if (hModule != NULL) {
		pFVar1 = GetProcAddress(hModule,"IsProcessorFeaturePresent");
		if (pFVar1 != NULL) {
			(*pFVar1)(0);
			return;
		}
	}
	__fpmath__004904f0();
	return;
}



void __cdecl std::internal::__fpmath__00490570(char *param_1)
{
	char cVar1;
	char cVar2;
	int iVar3;
	uint uVar4;
	
	iVar3 = tolower((int)*param_1);
	if (iVar3 != 0x65) {
		do {
			param_1 = param_1 + 1;
										// int std::isdigit(int c)
			if (std::globals::_pcharwidth < 2) {
				uVar4 = *(byte *)(std::globals::_pctype + *param_1) & C1_DIGIT;
			}
			else {
				uVar4 = _isctype((int)*param_1,C1_DIGIT);
			}
		} while (uVar4 != 0);
	}
	cVar2 = *param_1;
	*param_1 = DAT_004b0f78;
	do {
		param_1 = param_1 + 1;
		cVar1 = *param_1;
		*param_1 = cVar2;
		cVar2 = cVar1;
	} while (*param_1 != '\0');
	return;
}



void __cdecl std::internal::__fpmath__004905d0(char *param_1)
{
	char cVar1;
	char *pcVar2;
	char *pcVar3;
	char *pcVar4;
	
	cVar1 = *param_1;
	while ((cVar1 != '\0' && (cVar1 != DAT_004b0f78))) {
		pcVar2 = param_1 + 1;
		param_1 = param_1 + 1;
		cVar1 = *pcVar2;
	}
	pcVar2 = param_1 + 1;
	if (*param_1 != '\0') {
		cVar1 = *pcVar2;
		while (((cVar1 != '\0' && (cVar1 != 'e')) && (cVar1 != 'E'))) {
			pcVar3 = pcVar2 + 1;
			pcVar2 = pcVar2 + 1;
			cVar1 = *pcVar3;
		}
		cVar1 = pcVar2[-1];
		pcVar3 = pcVar2;
		while (pcVar4 = pcVar3 + -1, cVar1 == '0') {
			cVar1 = pcVar3[-2];
			pcVar3 = pcVar4;
		}
		if (*pcVar4 == DAT_004b0f78) {
			pcVar4 = pcVar3 + -2;
		}
		cVar1 = *pcVar2;
		pcVar4 = pcVar4 + 1;
		*pcVar4 = cVar1;
		while (cVar1 != '\0') {
			pcVar2 = pcVar2 + 1;
			cVar1 = *pcVar2;
			pcVar4 = pcVar4 + 1;
			*pcVar4 = cVar1;
		}
	}
	return;
}



undefined4 __cdecl std::internal::__fpmath_isdouble_ge_0(double *param_1)
{
	if (0.0 <= *param_1) {
		return 1;
	}
	return 0;
}



void __cdecl std::internal::__std_FUN_00490660(int param_1,byte **param_2,byte *param_3)
{
	byte *local_8;
	byte *local_4;
	
	if (param_1 != 0) {
		__std_FUN_00498060((uint *)&local_8,param_3);
		*param_2 = local_8;
		param_2[1] = local_4;
		return;
	}
	__std_FUN_004980a0((uint *)&param_3,param_3);
	*param_2 = param_3;
	return;
}



undefined * __cdecl
std::internal::__std_FUN_004906c0(undefined4 *param_1,undefined *param_2,int param_3,int param_4)
{
	int *piVar1;
	undefined *puVar2;
	int iVar3;
	undefined4 *puVar4;
	
	piVar1 = DAT_0054a128;
	if (DAT_0054a12c == '\0') {
		piVar1 = (int *)__std_FUN_00498180((char)*param_1);
		__std_FUN_004980e0((undefined4 *)(param_2 + (uint)(*piVar1 == 0x2d) + (uint)(0 < param_3)),
											 param_3 + 1,(int)piVar1);
	}
	else {
		__std_FUN_00490a80((undefined4 *)(param_2 + (*DAT_0054a128 == 0x2d)),(uint)(0 < param_3));
	}
	puVar2 = param_2;
	if (*piVar1 == 0x2d) {
		*param_2 = 0x2d;
		puVar2 = param_2 + 1;
	}
	if (0 < param_3) {
		*puVar2 = puVar2[1];
		puVar2 = puVar2 + 1;
		*puVar2 = DAT_004b0f78;
	}
	puVar4 = (undefined4 *)(puVar2 + param_3 + (uint)(DAT_0054a12c == '\0'));
	*puVar4 = 0x30302b65;
	*(undefined2 *)(puVar4 + 1) = 0x30;
	if (param_4 != 0) {
		*(undefined *)puVar4 = 0x45;
	}
	if (*(char *)piVar1[3] != '0') {
		iVar3 = piVar1[1] + -1;
		if (iVar3 < 0) {
			iVar3 = -iVar3;
			*(undefined *)((int)puVar4 + 1) = 0x2d;
		}
		if (99 < iVar3) {
			*(char *)((int)puVar4 + 2) = *(char *)((int)puVar4 + 2) + (char)(iVar3 / 100);
			iVar3 %= 100;
		}
		if (9 < iVar3) {
			*(char *)((int)puVar4 + 3) = *(char *)((int)puVar4 + 3) + (char)(iVar3 / 10);
			iVar3 %= 10;
		}
		*(char *)(puVar4 + 1) = *(char *)(puVar4 + 1) + (char)iVar3;
	}
	return param_2;
}



undefined4 * __cdecl
std::internal::__std_FUN_00490800(undefined4 *param_1,undefined4 *param_2,uint param_3)
{
	int iVar1;
	undefined *puVar2;
	int *piVar3;
	uint uVar4;
	undefined4 *puVar5;
	
	piVar3 = DAT_0054a128;
	if (DAT_0054a12c == '\0') {
		piVar3 = (int *)__std_FUN_00498180((char)*param_1);
		__std_FUN_004980e0((undefined4 *)((uint)(*piVar3 == 0x2d) + (int)param_2),piVar3[1] + param_3,
											 (int)piVar3);
	}
	else {
		if (DAT_0054a130 == param_3) {
			puVar2 = (undefined *)((int)param_2 + DAT_0054a130 + (*DAT_0054a128 == 0x2d));
			*puVar2 = 0x30;
			puVar2[1] = 0;
		}
	}
	puVar5 = param_2;
	if (*piVar3 == 0x2d) {
		*(undefined *)param_2 = 0x2d;
		puVar5 = (undefined4 *)((int)param_2 + 1);
	}
	if (piVar3[1] < 1) {
		__std_FUN_00490a80(puVar5,1);
		*(undefined *)puVar5 = 0x30;
		puVar5 = (undefined4 *)((int)puVar5 + 1);
	}
	else {
		puVar5 = (undefined4 *)((int)puVar5 + piVar3[1]);
	}
	if (0 < (int)param_3) {
		__std_FUN_00490a80(puVar5,1);
		*(undefined *)puVar5 = DAT_004b0f78;
		iVar1 = piVar3[1];
		if (iVar1 < 0) {
			if ((DAT_0054a12c != '\0') || (SBORROW4(param_3,-iVar1) == (int)(param_3 + iVar1) < 0)) {
				param_3 = -iVar1;
			}
			__std_FUN_00490a80((undefined4 *)((int)puVar5 + 1),param_3);
			puVar5 = (undefined4 *)((int)puVar5 + 1);
			for (uVar4 = param_3 >> 2; uVar4 != 0; uVar4 -= 1) {
				*puVar5 = 0x30303030;
				puVar5 = puVar5 + 1;
			}
			for (uVar4 = param_3 & 3; uVar4 != 0; uVar4 -= 1) {
				*(undefined *)puVar5 = 0x30;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
			}
		}
	}
	return param_2;
}



void __cdecl
std::internal::__std_FUN_00490900(undefined4 *param_1,undefined4 *param_2,uint param_3,int param_4)
{
	char cVar1;
	undefined4 *puVar2;
	
	DAT_0054a128 = (int *)__std_FUN_00498180((char)*param_1);
	DAT_0054a130 = DAT_0054a128[1] + -1;
	puVar2 = (undefined4 *)((uint)(*DAT_0054a128 == 0x2d) + (int)param_2);
	__std_FUN_004980e0(puVar2,param_3,(int)DAT_0054a128);
	DAT_0054a134 = DAT_0054a130 < DAT_0054a128[1] + -1;
	DAT_0054a130 = DAT_0054a128[1] + -1;
	if ((-5 < DAT_0054a130) && (DAT_0054a130 < (int)param_3)) {
		if ((bool)DAT_0054a134) {
			cVar1 = *(char *)puVar2;
			while (cVar1 != '\0') {
				cVar1 = *(char *)(undefined4 *)((int)puVar2 + 1);
				puVar2 = (undefined4 *)((int)puVar2 + 1);
			}
			*(undefined *)((int)puVar2 + -1) = 0;
		}
		__std_FUN_004909e0(param_1,param_2,param_3);
		return;
	}
	__std_FUN_004909b0(param_1,(undefined *)param_2,param_3,param_4);
	return;
}



void __cdecl
std::internal::__std_FUN_004909b0(undefined4 param_1,undefined *param_2,int param_3,int param_4)
{
	DAT_0054a12c = 1;
	__std_FUN_004906c0(param_1,param_2,param_3,param_4);
	DAT_0054a12c = 0;
	return;
}



void __cdecl std::internal::__std_FUN_004909e0(undefined4 param_1,undefined4 *param_2,uint param_3)
{
	DAT_0054a12c = 1;
	__std_FUN_00490800(param_1,param_2,param_3);
	DAT_0054a12c = 0;
	return;
}



void __cdecl
std::internal::__std_FUN_00490a10
					(undefined4 param_1,undefined4 *param_2,int param_3,uint param_4,int param_5)
{
	if ((param_3 != 0x65) && (param_3 != 0x45)) {
		if (param_3 == 0x66) {
			__std_FUN_00490800(param_1,param_2,param_4);
			return;
		}
		__std_FUN_00490900(param_1,param_2,param_4,param_5);
		return;
	}
	__std_FUN_004906c0(param_1,(undefined *)param_2,param_4,param_5);
	return;
}



void __cdecl std::internal::__std_FUN_00490a80(undefined4 *param_1,int param_2)
{
	char cVar1;
	uint uVar2;
	undefined4 *puVar3;
	
	if (param_2 != 0) {
		uVar2 = 0xffffffff;
		puVar3 = param_1;
		do {
			if (uVar2 == 0) break;
			uVar2 -= 1;
			cVar1 = *(char *)puVar3;
			puVar3 = (undefined4 *)((int)puVar3 + 1);
		} while (cVar1 != '\0');
		__std_FUN_004982c0((undefined4 *)(param_2 + (int)param_1),param_1,~uVar2);
	}
	return;
}



undefined * __cdecl std::internal::__atof_internal(char *str)
{
	char *pcVar1;
	uint uVar2;
	int iVar3;
	uint uVar4;
	uint local_14;
	undefined4 uStack16;
	ushort local_c [6];
	
	pcVar1 = str;
	uVar4 = 0;
	uVar2 = __std_FUN_00498610(local_c,(byte **)&str,(byte *)str,0,0,0,0);
	if ((uVar2 & 4) == 0) {
		iVar3 = __std_FUN_00498020(local_c,&local_14);
		if (((uVar2 & 2) != 0) || (iVar3 == 1)) {
			uVar4 = 0x80;
		}
		if (((uVar2 & 1) != 0) || (iVar3 == 2)) {
			uVar4 |= 0x100;
		}
	}
	else {
		uVar4 = 0x200;
		local_14 = 0;
		uStack16 = 0;
	}
	*(uint *)PTR_DAT_004b0f98 = uVar4;
	*(char **)(PTR_DAT_004b0f98 + 4) = str + -(int)pcVar1;
	*(ulonglong *)(PTR_DAT_004b0f98 + 0x10) = CONCAT44(uStack16,local_14);
	return PTR_DAT_004b0f98;
}



uint __cdecl std::internal::__fafterwrite_00490b60(uint param_1,char **param_2)
{
	char *fd;
	char *pcVar1;
	BOOL BVar2;
	undefined *puVar3;
	char *pcVar4;
	char *pcVar5;
	
	pcVar5 = param_2[3];
	fd = param_2[4];
	if ((((uint)pcVar5 & 0x82) == 0) || (((uint)pcVar5 & 0x40) != 0)) {
LAB_00490c80:
		param_2[3] = (char *)((uint)pcVar5 | 0x20);
		return 0xffffffff;
	}
	pcVar4 = NULL;
	if (((uint)pcVar5 & 1) != 0) {
		param_2[1] = NULL;
		if (((uint)pcVar5 & 0x10) == 0) goto LAB_00490c80;
		*param_2 = param_2[2];
		param_2[3] = (char *)((uint)pcVar5 & 0xfffffffe);
	}
	pcVar5 = param_2[3];
	param_2[1] = NULL;
	param_2[3] = (char *)((uint)pcVar5 & 0xffffffef | 2);
	if (((uint)pcVar5 & 0x10c) == 0) {
		if (((FILE *)param_2 == &globals::__FILE_004b3648) ||
			 ((FILE *)param_2 == &globals::__FILE_004b3668)) {
			BVar2 = __std_FUN_00498e00((uint)fd);
			if (BVar2 != 0) goto LAB_00490bd3;
		}
		__fileunk__00498da0((FILE *)param_2);
	}
LAB_00490bd3:
	if (((uint)param_2[3] & 0x108) == 0) {
		pcVar5 = (char *)0x1;
		pcVar4 = (char *)__fdwrite__00496f80((uint)fd,(char *)&param_1,(char *)0x1);
	}
	else {
		pcVar1 = param_2[2];
		pcVar5 = *param_2 + -(int)pcVar1;
		*param_2 = pcVar1 + 1;
		param_2[1] = param_2[6] + -1;
		if ((int)pcVar5 < 1) {
			if (fd == (char *)0xffffffff) {
				puVar3 = &DAT_004b3428;
			}
			else {
				puVar3 = (undefined *)((&DAT_0076edc0)[(int)fd >> 5] + ((uint)fd & 0x1f) * 8);
			}
			if ((puVar3[4] & 0x20) != 0) {
				__fdread__00496ec0((uint)fd,0,2);
			}
			*param_2[2] = (char)param_1;
		}
		else {
			pcVar4 = (char *)__fdwrite__00496f80((uint)fd,pcVar1,pcVar5);
			*param_2[2] = (char)param_1;
		}
	}
	if (pcVar4 != pcVar5) {
		param_2[3] = (char *)((uint)param_2[3] | 0x20);
		return 0xffffffff;
	}
	return param_1 & 0xff;
}



// WARNING: Could not reconcile some variable overlaps

int __cdecl std::internal::__vfprintf_internal(FILE *stream,char *format,va_list argptr,...)
{
	char cVar1;
	FILE *pFVar2;
	uint uVar3;
	short *psVar4;
	int *piVar5;
	undefined4 uVar6;
	LPSTR pCVar7;
	byte bVar8;
	ushort *puVar9;
	ushort *puVar10;
	ushort *puVar11;
	char *pcVar12;
	uint uVar13;
	int iVar14;
	ulonglong uVar15;
	undefined8 uVar16;
	ulonglong uVar17;
	uint local_24c;
	ushort *local_248;
	int local_244;
	int local_240;
	char local_23a;
	char local_239;
	int local_238;
	int local_234;
	int local_230;
	uint local_22c;
	int local_228;
	int local_224;
	int local_220;
	uint local_21c;
	undefined4 local_218;
	CHAR local_214 [4];
	undefined4 local_210;
	undefined4 local_20c;
	uint local_204;
	undefined local_200 [512];
	
	local_220 = 0;
	puVar10 = NULL;
	local_240 = 0;
	bVar8 = *format;
	format = format + 1;
	local_21c = local_21c & 0xffffff00 | (uint)bVar8;
	do {
		if ((bVar8 == 0) || (local_240 < 0)) {
			return local_240;
		}
		if (((char)bVar8 < ' ') || ('x' < (char)bVar8)) {
			uVar3 = 0;
		}
		else {
			uVar3 = (byte)"IsProcessorFeaturePresent"[(char)bVar8 + 0x18] & 0xf;
		}
		local_220 = (int)(char)(&DAT_0049fb70)[uVar3 * 8 + local_220] >> 4;
		switch(local_220) {
		case 0:
switchD_00490d0d_caseD_0:
			local_230 = 0;
			if ((*(byte *)((int)std::globals::_pctype + (local_21c & 0xff) * 2 + 1) & 0x80) != 0) {
				__std_FUN_00491620((int)(char)bVar8,(char **)stream,&local_240);
				bVar8 = *format;
				format = (char *)((byte *)format + 1);
			}
			__std_FUN_00491620((int)(char)bVar8,(char **)stream,&local_240);
			break;
		case 1:
			local_218 = 0;
			local_228 = 0;
			local_234 = 0;
			local_238 = 0;
			local_24c = 0;
			local_244 = -1;
			local_230 = 0;
			break;
		case 2:
			if (true) {
				switch(bVar8) {
				case 0x20:
					local_24c |= 2;
					break;
				case 0x23:
					local_24c |= 0x80;
					break;
				case 0x2b:
					local_24c |= 1;
					break;
				case 0x2d:
					local_24c |= 4;
					break;
				case 0x30:
					local_24c |= 8;
				}
			}
			break;
		case 3:
			if (bVar8 == 0x2a) {
				local_234 = __std_FUN_004916f0((int *)&argptr);
				if (local_234 < 0) {
					local_24c |= 4;
					local_234 = -local_234;
				}
			}
			else {
				local_234 = (char)bVar8 + -0x30 + local_234 * 10;
			}
			break;
		case 4:
			local_244 = 0;
			break;
		case 5:
			if (bVar8 == 0x2a) {
				local_244 = __std_FUN_004916f0((int *)&argptr);
				if (local_244 < 0) {
					local_244 = -1;
				}
			}
			else {
				local_244 = (char)bVar8 + -0x30 + local_244 * 10;
			}
			break;
		case 6:
			if (true) {
				switch(bVar8) {
				case 0x49:
					if ((*format != 0x36) || (((byte *)format)[1] != 0x34)) {
						local_220 = 0;
						goto switchD_00490d0d_caseD_0;
					}
					format = (char *)((byte *)format + 2);
					local_24c |= 0x8000;
					break;
				case 0x68:
					local_24c |= 0x20;
					break;
				case 0x6c:
					local_24c |= 0x10;
					break;
				case 0x77:
					local_24c |= 0x800;
				}
			}
			break;
		case 7:
			if (false) goto switchD_00490f21_caseD_44;
			switch(bVar8) {
			case 0x43:
				if ((local_24c & 0x830) == 0) {
					local_24c |= 0x800;
				}
			case 99:
				if ((local_24c & 0x810) == 0) {
					uVar6 = __std_FUN_004916f0((int *)&argptr);
					local_200[0] = (char)uVar6;
					puVar10 = (ushort *)0x1;
				}
				else {
					uVar3 = __std_FUN_00491730((ushort **)&argptr);
					puVar10 = (ushort *)__vfprintf__00498e30(local_200,(ushort)uVar3);
					if ((int)puVar10 < 0) {
						local_248 = (ushort *)local_200;
						local_228 = 1;
						break;
					}
				}
				local_248 = (ushort *)local_200;
				break;
			case 0x45:
			case 0x47:
				local_218 = 1;
				bVar8 += 0x20;
			case 0x65:
			case 0x66:
			case 0x67:
				local_248 = (ushort *)local_200;
				if (local_244 < 0) {
					local_244 = 6;
				}
				else {
					if ((local_244 == 0) && (bVar8 == 0x67)) {
						local_244 = 1;
					}
				}
				local_210 = *(undefined4 *)argptr;
				local_20c = *(undefined4 *)((int)argptr + 4);
				argptr = (va_list)((int)argptr + 8);
				(*(code *)PTR___std_FUN_004b0f80)(&local_210,local_200,(int)(char)bVar8,local_244,local_218)
				;
				if (((local_24c & 0x80) != 0) && (local_244 == 0)) {
					(*(code *)PTR___std_FUN_004b0f8c)(local_200);
				}
				if ((bVar8 == 0x67) && ((local_24c & 0x80) == 0)) {
					(*(code *)PTR___std_FUN_004b0f84)(local_200);
				}
				uVar3 = local_24c | 0x40;
				if (local_200[0] == '-') {
					local_248 = (ushort *)(local_200 + 1);
					uVar3 = local_24c | 0x140;
				}
				local_24c = uVar3;
				uVar3 = 0xffffffff;
				puVar10 = local_248;
				do {
					if (uVar3 == 0) break;
					uVar3 -= 1;
					cVar1 = *(char *)puVar10;
					puVar10 = (ushort *)((int)puVar10 + 1);
				} while (cVar1 != '\0');
				puVar10 = (ushort *)(~uVar3 - 1);
				break;
			case 0x53:
				if ((local_24c & 0x830) == 0) {
					local_24c |= 0x800;
				}
			case 0x73:
				iVar14 = 0x7fffffff;
				if (local_244 != -1) {
					iVar14 = local_244;
				}
				local_248 = (ushort *)__std_FUN_004916f0((int *)&argptr);
				if ((local_24c & 0x810) == 0) {
					puVar10 = local_248;
					if (local_248 == NULL) {
						puVar10 = (ushort *)PTR_s__null__004b0f9c;
						local_248 = (ushort *)PTR_s__null__004b0f9c;
					}
					for (; (iVar14 != 0 && (iVar14 += -1, *(char *)puVar10 != '\0'));
							puVar10 = (ushort *)((int)puVar10 + 1)) {
					}
					puVar10 = (ushort *)((int)puVar10 - (int)local_248);
				}
				else {
					if (local_248 == NULL) {
						local_248 = (ushort *)PTR_u__null__004b0fa0;
					}
					local_230 = 1;
					for (puVar10 = local_248; (iVar14 != 0 && (iVar14 += -1, *puVar10 != 0));
							puVar10 = puVar10 + 1) {
					}
					puVar10 = (ushort *)((int)((int)puVar10 - (int)local_248) >> 1);
				}
				break;
			case 0x58:
				goto switchD_00490f21_caseD_58;
			case 0x5a:
				psVar4 = (short *)__std_FUN_004916f0((int *)&argptr);
				if ((psVar4 == NULL) || (local_248 = *(ushort **)(psVar4 + 2), local_248 == NULL)) {
					uVar3 = 0xffffffff;
					local_248 = (ushort *)PTR_s__null__004b0f9c;
					pcVar12 = PTR_s__null__004b0f9c;
					do {
						if (uVar3 == 0) break;
						uVar3 -= 1;
						cVar1 = *pcVar12;
						pcVar12 = pcVar12 + 1;
					} while (cVar1 != '\0');
					puVar10 = (ushort *)(~uVar3 - 1);
				}
				else {
					if ((local_24c & 0x800) == 0) {
						puVar10 = (ushort *)(int)*psVar4;
						local_230 = 0;
					}
					else {
						local_230 = 1;
						puVar10 = (ushort *)((uint)(int)*psVar4 >> 1);
					}
				}
				break;
			case 100:
			case 0x69:
				local_22c = 10;
				local_24c |= 0x40;
				goto LAB_00491257;
			case 0x6e:
				piVar5 = (int *)__std_FUN_004916f0((int *)&argptr);
				if ((local_24c & 0x20) == 0) {
					local_228 = 1;
					*piVar5 = local_240;
				}
				else {
					local_228 = 1;
					*(undefined2 *)piVar5 = (undefined2)local_240;
				}
				break;
			case 0x6f:
				local_22c = 8;
				if ((local_24c & 0x80) != 0) {
					local_24c |= 0x200;
				}
				goto LAB_00491257;
			case 0x70:
				local_244 = 8;
switchD_00490f21_caseD_58:
				local_224 = 7;
LAB_00491212:
				local_22c = 0x10;
				if ((local_24c & 0x80) != 0) {
					local_23a = '0';
					local_239 = (char)local_224 + 'Q';
					local_238 = 2;
				}
				goto LAB_00491257;
			case 0x75:
				local_22c = 10;
LAB_00491257:
				if ((local_24c & 0x8000) == 0) {
					if ((local_24c & 0x20) == 0) {
						if ((local_24c & 0x40) == 0) {
							uVar3 = __std_FUN_004916f0((int *)&argptr);
							uVar15 = (ulonglong)uVar3;
						}
						else {
							iVar14 = __std_FUN_004916f0((int *)&argptr);
							uVar15 = SEXT48(iVar14);
						}
					}
					else {
						if ((local_24c & 0x40) == 0) {
							uVar3 = __std_FUN_004916f0((int *)&argptr);
							uVar15 = (ulonglong)uVar3 & 0xffffffff0000ffff;
						}
						else {
							uVar6 = __std_FUN_004916f0((int *)&argptr);
							uVar15 = SEXT48((int)(short)uVar6);
						}
					}
				}
				else {
					uVar15 = __std_FUN_00491710((int *)&argptr);
				}
				iVar14 = (int)(uVar15 >> 0x20);
				if ((((local_24c & 0x40) != 0) && (iVar14 == 0 || (longlong)uVar15 < 0)) &&
					 (((longlong)uVar15 < 0 || (false)))) {
					local_24c |= 0x100;
					uVar15 = CONCAT44(-(iVar14 + (uint)((int)uVar15 != 0)),-(int)uVar15);
				}
				uVar3 = (uint)(uVar15 >> 0x20);
				if ((local_24c & 0x8000) == 0) {
					uVar3 = 0;
				}
				uVar17 = uVar15 & 0xffffffff | (ulonglong)uVar3 << 0x20;
				if (local_244 < 0) {
					local_244 = 1;
				}
				else {
					local_24c &= 0xfffffff7;
				}
				if (((uint)uVar15 | uVar3) == 0) {
					local_238 = 0;
				}
				puVar9 = (ushort *)(local_200 + 0x1ff);
				iVar14 = local_244;
				while( true ) {
					uVar3 = local_22c;
					uVar13 = (uint)(uVar17 >> 0x20);
					local_244 = iVar14 + -1;
					if ((iVar14 < 1) && (uVar17 == 0)) break;
					local_204 = (int)local_22c >> 0x1f;
					uVar16 = __aullrem((uint)uVar17,uVar13,local_22c,local_204);
					iVar14 = (int)uVar16 + 0x30;
					uVar17 = __aulldiv((uint)uVar17,uVar13,uVar3,local_204);
					if (0x39 < iVar14) {
						iVar14 += local_224;
					}
					*(char *)puVar9 = (char)iVar14;
					puVar9 = (ushort *)((int)puVar9 + -1);
					iVar14 = local_244;
				}
				puVar10 = (ushort *)(local_200 + -(int)puVar9 + 0x1ff);
				local_248 = (ushort *)((int)puVar9 + 1);
				if (((local_24c & 0x200) != 0) && ((*(char *)local_248 != '0' || (puVar10 == NULL)))) {
					puVar10 = (ushort *)(&stack0x00000000 + -(int)puVar9);
					*(undefined *)puVar9 = 0x30;
					local_248 = puVar9;
				}
				break;
			case 0x78:
				local_224 = 0x27;
				goto LAB_00491212;
			}
switchD_00490f21_caseD_44:
			pFVar2 = stream;
			if (local_228 == 0) {
				if ((local_24c & 0x40) != 0) {
					if ((local_24c & 0x100) == 0) {
						if ((local_24c & 1) == 0) {
							if ((local_24c & 2) == 0) goto LAB_004913ef;
							local_23a = ' ';
						}
						else {
							local_23a = '+';
						}
					}
					else {
						local_23a = '-';
					}
					local_238 = 1;
				}
LAB_004913ef:
				iVar14 = (local_234 - local_238) - (int)puVar10;
				if ((local_24c & 0xc) == 0) {
					__std_FUN_00491670(0x20,iVar14,(char **)stream,&local_240);
				}
				__std_FUN_004916b0(&local_23a,local_238,(char **)pFVar2,&local_240);
				if (((local_24c & 8) != 0) && ((local_24c & 4) == 0)) {
					__std_FUN_00491670(0x30,iVar14,(char **)pFVar2,&local_240);
				}
				if ((local_230 == 0) || (puVar11 = local_248, puVar9 = puVar10, (int)puVar10 < 1)) {
					__std_FUN_004916b0((char *)local_248,(int)puVar10,(char **)pFVar2,&local_240);
				}
				else {
					do {
						puVar9 = (ushort *)((int)puVar9 + -1);
						pCVar7 = __vfprintf__00498e30(local_214,*puVar11);
						if ((int)pCVar7 < 1) break;
						__std_FUN_004916b0(local_214,(int)pCVar7,(char **)stream,&local_240);
						puVar11 = puVar11 + 1;
					} while (puVar9 != NULL);
				}
				if ((local_24c & 4) != 0) {
					__std_FUN_00491670(0x20,iVar14,(char **)stream,&local_240);
				}
			}
		}
		bVar8 = *format;
		format = format + 1;
		local_21c = local_21c & 0xffffff00 | (uint)bVar8;
	} while( true );
}



void __cdecl std::internal::__std_FUN_00491620(uint param_1,char **param_2,int *param_3)
{
	char *pcVar1;
	uint uVar2;
	
	pcVar1 = param_2[1];
	param_2[1] = pcVar1 + -1;
	if ((int)(pcVar1 + -1) < 0) {
		uVar2 = __fafterwrite_00490b60(param_1,param_2);
	}
	else {
		**param_2 = (char)param_1;
		uVar2 = param_1 & 0xff;
		*param_2 = *param_2 + 1;
	}
	if (uVar2 == 0xffffffff) {
		*param_3 = -1;
		return;
	}
	*param_3 = *param_3 + 1;
	return;
}



void __cdecl std::internal::__std_FUN_00491670(uint param_1,int param_2,char **param_3,int *param_4)
{
	if (0 < param_2) {
		do {
			param_2 += -1;
			__std_FUN_00491620(param_1,param_3,param_4);
			if (*param_4 == -1) {
				return;
			}
		} while (0 < param_2);
	}
	return;
}



void __cdecl
std::internal::__std_FUN_004916b0(char *param_1,int param_2,char **param_3,int *param_4)
{
	char cVar1;
	
	if (0 < param_2) {
		do {
			param_2 += -1;
			cVar1 = *param_1;
			param_1 = param_1 + 1;
			__std_FUN_00491620((int)cVar1,param_3,param_4);
			if (*param_4 == -1) {
				return;
			}
		} while (0 < param_2);
	}
	return;
}



undefined4 __cdecl std::internal::__std_FUN_004916f0(int *param_1)
{
	undefined4 *puVar1;
	
	puVar1 = (undefined4 *)*param_1;
	*param_1 = (int)(puVar1 + 1);
	return *puVar1;
}



undefined8 __cdecl std::internal::__std_FUN_00491710(int *param_1)
{
	undefined8 *puVar1;
	
	puVar1 = (undefined8 *)*param_1;
	*param_1 = (int)(puVar1 + 1);
	return *puVar1;
}



uint __cdecl std::internal::__std_FUN_00491730(ushort **param_1)
{
	ushort *puVar1;
	ushort *puVar2;
	
	puVar1 = *param_1;
	puVar2 = puVar1 + 2;
	*param_1 = puVar2;
	return (uint)puVar2 & 0xffff0000 | (uint)*puVar1;
}



uint * __cdecl std::internal::__std_FUN_00491760(uint *param_1,char param_2)
{
	uint uVar1;
	char cVar2;
	uint uVar3;
	uint uVar4;
	uint *puVar5;
	
	uVar1 = (uint)param_1 & 3;
	while (uVar1 != 0) {
		if (*(char *)param_1 == param_2) {
			return param_1;
		}
		if (*(char *)param_1 == '\0') {
			return NULL;
		}
		uVar1 = (uint)(uint *)((int)param_1 + 1) & 3;
		param_1 = (uint *)((int)param_1 + 1);
	}
	while( true ) {
		while( true ) {
			uVar1 = *param_1;
			uVar4 = uVar1 ^ CONCAT22(CONCAT11(param_2,param_2),CONCAT11(param_2,param_2));
			uVar3 = uVar1 ^ 0xffffffff ^ uVar1 + 0x7efefeff;
			puVar5 = param_1 + 1;
			if (((uVar4 ^ 0xffffffff ^ uVar4 + 0x7efefeff) & 0x81010100) != 0) break;
			param_1 = puVar5;
			if ((uVar3 & 0x81010100) != 0) {
				if ((uVar3 & 0x1010100) != 0) {
					return NULL;
				}
				if ((uVar1 + 0x7efefeff & 0x80000000) == 0) {
					return NULL;
				}
			}
		}
		uVar1 = *param_1;
		if ((char)uVar1 == param_2) {
			return param_1;
		}
		if ((char)uVar1 == '\0') {
			return NULL;
		}
		cVar2 = (char)(uVar1 >> 8);
		if (cVar2 == param_2) {
			return (uint *)((int)param_1 + 1);
		}
		if (cVar2 == '\0') break;
		cVar2 = (char)(uVar1 >> 0x10);
		if (cVar2 == param_2) {
			return (uint *)((int)param_1 + 2);
		}
		if (cVar2 == '\0') {
			return NULL;
		}
		cVar2 = (char)(uVar1 >> 0x18);
		if (cVar2 == param_2) {
			return (uint *)((int)param_1 + 3);
		}
		param_1 = puVar5;
		if (cVar2 == '\0') {
			return NULL;
		}
	}
	return NULL;
}



BOOL std::internal::__entry__00491820(void)
{
	undefined **ppuVar1;
	
	DAT_0076eec4 = HeapCreate(1,0x1000,0);
	if (DAT_0076eec4 == NULL) {
		return 0;
	}
	ppuVar1 = __std_FUN_00491860();
	if (ppuVar1 == NULL) {
		HeapDestroy(DAT_0076eec4);
		return 0;
	}
	return 1;
}



undefined ** std::internal::__std_FUN_00491860(void)
{
	bool bVar1;
	undefined4 *lpAddress;
	LPVOID pvVar2;
	int iVar3;
	undefined **ppuVar4;
	undefined **lpMem;
	undefined4 *puVar5;
	
	if (DAT_004b0fc8 == -1) {
		lpMem = &PTR_LOOP_004b0fb8;
	}
	else {
		lpMem = (undefined **)HeapAlloc(DAT_0076eec4,0,0x2020);
		if (lpMem == NULL) {
			return NULL;
		}
	}
	lpAddress = (undefined4 *)VirtualAlloc(NULL,0x400000,0x2000,4);
	if (lpAddress != NULL) {
		pvVar2 = VirtualAlloc(lpAddress,0x10000,0x1000,4);
		if (pvVar2 != NULL) {
			if (lpMem == &PTR_LOOP_004b0fb8) {
				if (PTR_LOOP_004b0fb8 == NULL) {
					PTR_LOOP_004b0fb8 = &PTR_LOOP_004b0fb8;
				}
				if (PTR_LOOP_004b0fbc == NULL) {
					PTR_LOOP_004b0fbc = &PTR_LOOP_004b0fb8;
				}
			}
			else {
				*lpMem = (undefined *)&PTR_LOOP_004b0fb8;
				lpMem[1] = (undefined *)PTR_LOOP_004b0fbc;
				PTR_LOOP_004b0fbc = lpMem;
				*(undefined ***)lpMem[1] = lpMem;
			}
			lpMem[5] = (undefined *)(lpAddress + 0x100000);
			lpMem[4] = (undefined *)lpAddress;
			lpMem[2] = (undefined *)(lpMem + 6);
			lpMem[3] = (undefined *)(lpMem + 0x26);
			iVar3 = 0;
			ppuVar4 = lpMem + 6;
			do {
				bVar1 = 0xf < iVar3;
				iVar3 += 1;
				*ppuVar4 = (undefined *)((bVar1 - 1 & 0xf1) - 1);
				ppuVar4[1] = (undefined *)0xf1;
				ppuVar4 = ppuVar4 + 2;
			} while (iVar3 < 0x400);
			puVar5 = lpAddress;
			for (iVar3 = 0x4000; iVar3 != 0; iVar3 += -1) {
				*puVar5 = 0;
				puVar5 = puVar5 + 1;
			}
			if (lpAddress < lpMem[4] + 0x10000) {
				do {
					lpAddress[1] = 0xf0;
					*lpAddress = lpAddress + 2;
					*(undefined *)(lpAddress + 0x3e) = 0xff;
					lpAddress = lpAddress + 0x400;
				} while (lpAddress < lpMem[4] + 0x10000);
			}
			return lpMem;
		}
		VirtualFree(lpAddress,0,0x8000);
	}
	if (lpMem != &PTR_LOOP_004b0fb8) {
		HeapFree(DAT_0076eec4,0,lpMem);
	}
	return NULL;
}



void __cdecl std::internal::__free__realloc__004919d0(undefined **param_1)
{
	VirtualFree(param_1[4],0,0x8000);
	if ((undefined **)PTR_LOOP_004b2fd8 == param_1) {
		PTR_LOOP_004b2fd8 = param_1[1];
	}
	if (param_1 != &PTR_LOOP_004b0fb8) {
		*(undefined **)param_1[1] = *param_1;
		*(undefined **)(*param_1 + 4) = param_1[1];
		HeapFree(DAT_0076eec4,0,param_1);
		return;
	}
	DAT_004b0fc8 = 0xffffffff;
	return;
}



void __cdecl std::internal::__free__realloc__00491a30(int param_1)
{
	BOOL BVar1;
	undefined **ppuVar2;
	int iVar3;
	int iVar4;
	undefined **ppuVar5;
	undefined **ppuVar6;
	
	ppuVar6 = (undefined **)PTR_LOOP_004b0fbc;
	do {
		ppuVar5 = ppuVar6;
		if (ppuVar6[4] != (undefined *)0xffffffff) {
			iVar4 = 0;
			ppuVar5 = ppuVar6 + 0x804;
			iVar3 = 0x3ff000;
			do {
				if (*ppuVar5 == (undefined *)0xf0) {
					BVar1 = VirtualFree(ppuVar6[4] + iVar3,0x1000,0x4000);
					if (BVar1 != 0) {
						*ppuVar5 = (undefined *)0xffffffff;
						DAT_0054a150 += -1;
						if (((undefined **)ppuVar6[3] == NULL) || (ppuVar5 < ppuVar6[3])) {
							ppuVar6[3] = (undefined *)ppuVar5;
						}
						iVar4 += 1;
						param_1 += -1;
						if (param_1 == 0) break;
					}
				}
				iVar3 += -0x1000;
				ppuVar5 = ppuVar5 + -2;
			} while (-1 < iVar3);
			ppuVar5 = (undefined **)ppuVar6[1];
			if ((iVar4 != 0) && (ppuVar6[6] == (undefined *)0xffffffff)) {
				iVar3 = 1;
				ppuVar2 = ppuVar6 + 8;
				do {
					if (*ppuVar2 != (undefined *)0xffffffff) break;
					iVar3 += 1;
					ppuVar2 = ppuVar2 + 2;
				} while (iVar3 < 0x400);
				if (iVar3 == 0x400) {
					__free__realloc__004919d0(ppuVar6);
				}
			}
		}
		if ((ppuVar5 == (undefined **)PTR_LOOP_004b0fbc) || (ppuVar6 = ppuVar5, param_1 < 1)) {
			return;
		}
	} while( true );
}



int __cdecl std::internal::__realloc_free__00491b00(undefined *param_1,int **param_2,uint *param_3)
{
	undefined **ppuVar1;
	uint uVar2;
	
	ppuVar1 = &PTR_LOOP_004b0fb8;
	while ((param_1 < ppuVar1[4] || param_1 == ppuVar1[4] || (ppuVar1[5] <= param_1))) {
		ppuVar1 = (undefined **)*ppuVar1;
		if (ppuVar1 == &PTR_LOOP_004b0fb8) {
			return 0;
		}
	}
	if (((uint)param_1 & 0xf) != 0) {
		return 0;
	}
	if (((uint)param_1 & 0xfff) < 0x100) {
		return 0;
	}
	*param_2 = (int *)ppuVar1;
	uVar2 = (uint)param_1 & 0xfffff000;
	*param_3 = uVar2;
	return ((int)(param_1 + (-0x100 - uVar2)) >> 4) + 8 + uVar2;
}



void __cdecl std::internal::__free_realloc__00491b60(int param_1,int param_2,byte *param_3)
{
	int *piVar1;
	int iVar2;
	
	iVar2 = param_2 - *(int *)(param_1 + 0x10) >> 0xc;
	piVar1 = (int *)(param_1 + 0x18 + iVar2 * 8);
	*piVar1 = *(int *)(param_1 + 0x18 + iVar2 * 8) + (uint)*param_3;
	*param_3 = 0;
	piVar1[1] = 0xf1;
	if ((*piVar1 == 0xf0) && (DAT_0054a150 += 1, DAT_0054a150 == 0x20)) {
		__free__realloc__00491a30(0x10);
	}
	return;
}



int * __cdecl std::internal::__malloc__00491bc0(int *param_1)
{
	undefined **ppuVar1;
	undefined **ppuVar2;
	undefined *puVar3;
	int *piVar4;
	int *piVar5;
	undefined **ppuVar6;
	undefined **ppuVar7;
	int **ppiVar8;
	int iVar9;
	int **ppiVar10;
	int **ppiVar11;
	bool bVar12;
	int *local_4;
	
	local_4 = (int *)PTR_LOOP_004b2fd8;
	do {
		if (local_4[4] != -1) {
			ppiVar10 = (int **)local_4[2];
			ppiVar8 = (int **)(((int)ppiVar10 + (-0x18 - (int)local_4) >> 3) * 0x1000 + local_4[4]);
			for (; ppiVar10 < local_4 + 0x806; ppiVar10 = ppiVar10 + 2) {
				if (((int)param_1 <= (int)*ppiVar10) && (param_1 <= ppiVar10[1] && ppiVar10[1] != param_1))
				{
					piVar4 = (int *)__std_FUN_00491e00(ppiVar8,*ppiVar10,param_1);
					if (piVar4 != NULL) {
						PTR_LOOP_004b2fd8 = (undefined *)local_4;
						*ppiVar10 = (int *)((int)*ppiVar10 - (int)param_1);
						local_4[2] = (int)ppiVar10;
						return piVar4;
					}
					ppiVar10[1] = param_1;
				}
				ppiVar8 = ppiVar8 + 0x400;
			}
			ppiVar8 = (int **)local_4[2];
			ppiVar11 = (int **)local_4[4];
			for (ppiVar10 = (int **)(local_4 + 6); ppiVar10 < ppiVar8; ppiVar10 = ppiVar10 + 2) {
				if (((int)param_1 <= (int)*ppiVar10) && (param_1 <= ppiVar10[1] && ppiVar10[1] != param_1))
				{
					piVar4 = (int *)__std_FUN_00491e00(ppiVar11,*ppiVar10,param_1);
					if (piVar4 != NULL) {
						PTR_LOOP_004b2fd8 = (undefined *)local_4;
						*ppiVar10 = (int *)((int)*ppiVar10 - (int)param_1);
						local_4[2] = (int)ppiVar10;
						return piVar4;
					}
					ppiVar10[1] = param_1;
				}
				ppiVar11 = ppiVar11 + 0x400;
			}
		}
		local_4 = (int *)*local_4;
	} while (local_4 != (int *)PTR_LOOP_004b2fd8);
	ppuVar7 = &PTR_LOOP_004b0fb8;
	while ((ppuVar7[4] == (undefined *)0xffffffff || (ppuVar7[3] == NULL))) {
		ppuVar7 = (undefined **)*ppuVar7;
		if (ppuVar7 == &PTR_LOOP_004b0fb8) {
			ppuVar7 = __std_FUN_00491860();
			if (ppuVar7 == NULL) {
				return NULL;
			}
			piVar4 = (int *)ppuVar7[4];
			*(char *)(piVar4 + 2) = (char)param_1;
			PTR_LOOP_004b2fd8 = (undefined *)ppuVar7;
			*piVar4 = (int)((int)piVar4 + 8) + (int)param_1;
			piVar4[1] = 0xf0 - (int)param_1;
			ppuVar7[6] = ppuVar7[6] + -((uint)param_1 & 0xff);
			return piVar4 + 0x40;
		}
	}
	ppuVar2 = (undefined **)ppuVar7[3];
	puVar3 = *ppuVar2;
	piVar4 = (int *)(ppuVar7[4] + ((int)ppuVar2 + (-0x18 - (int)ppuVar7) >> 3) * 0x1000);
	ppuVar6 = ppuVar2;
	for (iVar9 = 0; (puVar3 == (undefined *)0xffffffff && (iVar9 < 0x10)); iVar9 += 1) {
		puVar3 = ppuVar6[2];
		ppuVar6 = ppuVar6 + 2;
	}
	piVar5 = (int *)VirtualAlloc(piVar4,iVar9 << 0xc,0x1000,4);
	if (piVar5 != piVar4) {
		return NULL;
	}
	ppuVar6 = ppuVar2;
	if (0 < iVar9) {
		piVar5 = piVar4 + 1;
		do {
			*piVar5 = 0xf0;
			piVar5[-1] = (int)(piVar5 + 1);
			*(undefined *)(piVar5 + 0x3d) = 0xff;
			*ppuVar6 = (undefined *)0xf0;
			ppuVar6[1] = (undefined *)0xf1;
			piVar5 = piVar5 + 0x400;
			ppuVar6 = ppuVar6 + 2;
			iVar9 += -1;
		} while (iVar9 != 0);
	}
	ppuVar1 = ppuVar7 + 0x806;
	bVar12 = ppuVar6 < ppuVar1;
	if (bVar12) {
		do {
			if (*ppuVar6 == (undefined *)0xffffffff) break;
			ppuVar6 = ppuVar6 + 2;
		} while (ppuVar6 < ppuVar1);
		bVar12 = ppuVar6 < ppuVar1;
	}
	PTR_LOOP_004b2fd8 = (undefined *)ppuVar7;
	ppuVar7[3] = (undefined *)(-(uint)bVar12 & (uint)ppuVar6);
	*(char *)(piVar4 + 2) = (char)param_1;
	ppuVar7[2] = (undefined *)ppuVar2;
	*ppuVar2 = *ppuVar2 + -(int)param_1;
	piVar4[1] = piVar4[1] - (int)param_1;
	*piVar4 = (int)((int)piVar4 + 8) + (int)param_1;
	return piVar4 + 0x40;
}



int __cdecl std::internal::__std_FUN_00491e00(int **param_1,int *param_2,int *param_3)
{
	byte bVar1;
	int **ppiVar2;
	int **ppiVar3;
	int **ppiVar4;
	int *piVar5;
	int **ppiVar6;
	
	ppiVar2 = (int **)*param_1;
	if (param_3 <= param_1[1]) {
		*(byte *)ppiVar2 = (byte)param_3;
		if ((int **)((int)ppiVar2 + (int)param_3) < param_1 + 0x3e) {
			*param_1 = (int *)((int)*param_1 + (int)param_3);
			param_1[1] = (int *)((int)param_1[1] - (int)param_3);
		}
		else {
			param_1[1] = NULL;
			*param_1 = (int *)(param_1 + 2);
		}
		return (int)(ppiVar2 + 2) * 0x10 + (int)param_1 * -0xf;
	}
	ppiVar3 = (int **)((int)param_1[1] + (int)ppiVar2);
	ppiVar6 = ppiVar2;
	if (*(byte *)ppiVar3 != 0) {
		ppiVar6 = ppiVar3;
	}
	if ((int **)((int)ppiVar6 + (int)param_3) < param_1 + 0x3e) {
		do {
			if (*(byte *)ppiVar6 == 0) {
				ppiVar3 = (int **)((int)ppiVar6 + 1);
				piVar5 = (int *)0x1;
				bVar1 = *(byte *)((int)ppiVar6 + 1);
				while (bVar1 == 0) {
					ppiVar3 = (int **)((int)ppiVar3 + 1);
					piVar5 = (int *)((int)piVar5 + 1);
					bVar1 = *(byte *)ppiVar3;
				}
				if (param_3 <= piVar5) {
					if (param_1 + 0x3e <= (int **)((int)ppiVar6 + (int)param_3)) {
						*param_1 = (int *)(param_1 + 2);
						goto LAB_00491f4f;
					}
					*param_1 = (int *)(int **)((int)ppiVar6 + (int)param_3);
					param_1[1] = (int *)((int)piVar5 - (int)param_3);
					goto LAB_00491f56;
				}
				if (ppiVar6 == ppiVar2) {
					param_1[1] = piVar5;
				}
				else {
					param_2 = (int *)((int)param_2 - (int)piVar5);
					if (param_2 < param_3) {
						return 0;
					}
				}
			}
			else {
				ppiVar3 = (int **)((int)ppiVar6 + (uint)*(byte *)ppiVar6);
			}
			ppiVar6 = ppiVar3;
		} while ((int **)((int)ppiVar3 + (int)param_3) < param_1 + 0x3e);
	}
	ppiVar3 = param_1 + 2;
	ppiVar6 = ppiVar3;
	if (ppiVar3 < ppiVar2) {
		while ((int **)((int)ppiVar6 + (int)param_3) < param_1 + 0x3e) {
			if (*(byte *)ppiVar6 == 0) {
				ppiVar4 = (int **)((int)ppiVar6 + 1);
				piVar5 = (int *)0x1;
				bVar1 = *(byte *)((int)ppiVar6 + 1);
				while (bVar1 == 0) {
					ppiVar4 = (int **)((int)ppiVar4 + 1);
					piVar5 = (int *)((int)piVar5 + 1);
					bVar1 = *(byte *)ppiVar4;
				}
				if (param_3 <= piVar5) {
					if ((int **)((int)ppiVar6 + (int)param_3) < param_1 + 0x3e) {
						*param_1 = (int *)(int **)((int)ppiVar6 + (int)param_3);
						param_1[1] = (int *)((int)piVar5 - (int)param_3);
					}
					else {
						*param_1 = (int *)ppiVar3;
LAB_00491f4f:
						param_1[1] = NULL;
					}
LAB_00491f56:
					*(byte *)ppiVar6 = (byte)param_3;
					return (int)(ppiVar6 + 2) * 0x10 + (int)param_1 * -0xf;
				}
				param_2 = (int *)((int)param_2 - (int)piVar5);
				if (param_2 < param_3) {
					return 0;
				}
			}
			else {
				ppiVar4 = (int **)((int)ppiVar6 + (uint)*(byte *)ppiVar6);
			}
			ppiVar6 = ppiVar4;
			if (ppiVar2 <= ppiVar4) {
				return 0;
			}
		}
	}
	return 0;
}



undefined4 __cdecl
std::internal::__realloc__00491f80(int param_1,int **param_2,int **param_3,uint param_4)
{
	int **ppiVar1;
	int iVar2;
	int *piVar3;
	char cVar4;
	undefined4 uVar5;
	int *piVar6;
	uint uVar7;
	int **ppiVar8;
	
	uVar5 = 0;
	piVar3 = (int *)(param_1 + 0x18 + ((int)((int)param_2 - *(int *)(param_1 + 0x10)) >> 0xc) * 8);
	uVar7 = (uint)*(byte *)param_3;
	if (uVar7 <= param_4) {
		if ((uVar7 < param_4) && (ppiVar1 = (int **)(param_4 + (int)param_3), ppiVar1 <= param_2 + 0x3e)
			 ) {
			for (ppiVar8 = (int **)(uVar7 + (int)param_3);
					(ppiVar8 < ppiVar1 && (*(char *)ppiVar8 == '\0')); ppiVar8 = (int **)((int)ppiVar8 + 1)) {
			}
			if (ppiVar8 == ppiVar1) {
				*(char *)param_3 = (char)param_4;
				if ((param_3 <= *param_2) && (*param_2 < ppiVar1)) {
					if (ppiVar1 < param_2 + 0x3e) {
						*param_2 = (int *)ppiVar1;
						piVar6 = NULL;
						cVar4 = *(char *)ppiVar1;
						while (cVar4 == '\0') {
							iVar2 = (int)piVar6 + 1;
							piVar6 = (int *)((int)piVar6 + 1);
							cVar4 = *(char *)(iVar2 + (int)ppiVar1);
						}
						param_2[1] = piVar6;
					}
					else {
						param_2[1] = NULL;
						*param_2 = (int *)(param_2 + 2);
					}
				}
				*piVar3 = *piVar3 + (uVar7 - param_4);
				uVar5 = 1;
			}
		}
		return uVar5;
	}
	*(char *)param_3 = (char)param_4;
	piVar3[1] = 0xf1;
	*piVar3 = *piVar3 + (uVar7 - param_4);
	return 1;
}



BOOL __cdecl std::internal::__call_new_handler(size_t length)
{
	int iVar1;
	
	if (globals::__g_new_handler != NULL) {
		iVar1 = (*globals::__g_new_handler)(length);
		if (iVar1 != 0) {
			return 1;
		}
	}
	return 0;
}



// Library Function - Single Match
// Name: __trandisp1
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __fastcall __trandisp1(undefined4 param_1,int param_2)
{
	float10 fVar1;
	byte bVar2;
	undefined2 uVar3;
	int unaff_EBP;
	float10 in_ST0;
	
	if (*(char *)(param_2 + 0xe) == '\x05') {
		uVar3 = (undefined2)
						CONCAT31((uint3)((byte)((uint)*(ushort *)(unaff_EBP + -0xa4) >> 8) & 0xfe | 2),0x3f);
	}
	else {
		uVar3 = 0x133f;
	}
	*(undefined2 *)(unaff_EBP + -0xa2) = uVar3;
	fVar1 = (float10)0;
	*(int *)(unaff_EBP + -0x94) = param_2;
	*(ushort *)(unaff_EBP + -0xa0) =
			 (ushort)(in_ST0 < fVar1) << 9 | (ushort)(in_ST0 != fVar1) << 10 |
			 (ushort)(in_ST0 == fVar1) << 0xe;
	*(undefined *)(unaff_EBP + -0x90) = 0;
	bVar2 = (char)(*(char *)(unaff_EBP + -0x9f) << 1) >> 1;
										// WARNING: Could not recover jumptable at 0x004920d5. Too many branches
										// WARNING: Treating indirect jump as call
	(**(code **)(param_2 + (char)(&DAT_004b2ffd)[(byte)((bVar2 & 7) << 1 | (char)bVar2 < '\0')] + 0x10
							))();
	return;
}



// Library Function - Single Match
// Name: __trandisp2
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __fastcall __trandisp2(undefined4 param_1,int param_2)
{
	float10 fVar1;
	char cVar2;
	byte bVar3;
	undefined2 uVar4;
	int unaff_EBP;
	float10 in_ST0;
	float10 in_ST1;
	
	if (*(char *)(param_2 + 0xe) == '\x05') {
		uVar4 = (undefined2)
						CONCAT31((uint3)((byte)((uint)*(ushort *)(unaff_EBP + -0xa4) >> 8) & 0xfe | 2),0x3f);
	}
	else {
		uVar4 = 0x133f;
	}
	*(undefined2 *)(unaff_EBP + -0xa2) = uVar4;
	fVar1 = (float10)0;
	*(int *)(unaff_EBP + -0x94) = param_2;
	*(ushort *)(unaff_EBP + -0xa0) =
			 (ushort)(in_ST0 < fVar1) << 9 | (ushort)(in_ST0 != fVar1) << 10 |
			 (ushort)(in_ST0 == fVar1) << 0xe;
	*(undefined *)(unaff_EBP + -0x90) = 0;
	fVar1 = (float10)0;
	*(ushort *)(unaff_EBP + -0xa0) =
			 (ushort)(in_ST1 < fVar1) << 9 | (ushort)(in_ST1 != fVar1) << 10 |
			 (ushort)(in_ST1 == fVar1) << 0xe;
	bVar3 = (char)(*(char *)(unaff_EBP + -0x9f) << 1) >> 1;
	cVar2 = (char)(*(char *)(unaff_EBP + -0x9f) << 1) >> 1;
										// WARNING: Could not recover jumptable at 0x00492161. Too many branches
										// WARNING: Treating indirect jump as call
	(**(code **)(param_2 + (char)((&DAT_004b2ffd)[(byte)(cVar2 << 1 | cVar2 < '\0') & 0xf] |
															 (&DAT_004b2ffd)[(byte)((bVar3 & 7) << 1 | (char)bVar3 < '\0')] << 2)
							+ 0x10))();
	return;
}



float10 __fastcall
std::internal::__std_FUN_00492240
					(undefined4 param_1_00,uint param_2_00,ushort param_1,undefined4 param_2,
					undefined4 param_3,undefined4 param_4,undefined4 param_5,undefined4 param_6)
{
	float10 in_ST0;
	int local_24 [2];
	undefined4 uStack28;
	undefined4 uStack24;
	undefined4 local_14;
	undefined4 local_10;
	double dStack12;
	
	local_14 = param_5;
	local_10 = param_6;
	dStack12 = (double)in_ST0;
	uStack28 = param_3;
	uStack24 = param_4;
	__std_FUN_00498fa0(param_2_00,local_24,&param_1);
	return (float10)dStack12;
}



// Library Function - Single Match
// Name: __startOneArgErrorHandling
// Library: Visual Studio

float10 __fastcall
__startOneArgErrorHandling
					(undefined4 param_1_00,uint param_2_00,ushort param_1,undefined4 param_2,
					undefined4 param_3,undefined4 param_4)
{
	float10 in_ST0;
	int local_24 [2];
	undefined4 local_1c;
	undefined4 local_18;
	double local_c;
	
	local_c = (double)in_ST0;
	local_1c = param_3;
	local_18 = param_4;
	std::internal::__std_FUN_00498fa0(param_2_00,local_24,&param_1);
	return (float10)local_c;
}



void std::internal::__std_FUN_004922b5(undefined4 param_1)
{
	return;
}



undefined4 std::internal::__std_FUN_004922cc(uint param_1)
{
	if ((param_1 & 0x80000) != 0) {
		return 7;
	}
	return 1;
}



// Library Function - Single Match
// Name: __fload_withFB
// Library: Visual Studio

uint __fastcall __fload_withFB(undefined4 param_1,int param_2)
{
	uint uVar1;
	
	uVar1 = *(uint *)(param_2 + 4) & 0x7ff00000;
	if (uVar1 != 0x7ff00000) {
		return uVar1;
	}
	return *(uint *)(param_2 + 4);
}



uint __cdecl std::internal::__std_FUN_00492328(double param_1)
{
	if ((param_1._4_4_ & 0x7ff00000) != 0x7ff00000) {
		return param_1._4_4_ & 0x7ff00000;
	}
	return param_1._4_4_;
}



// Library Function - Single Match
// Name: __cintrindisp2
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __cintrindisp2(void)
{
	__trandisp2();
	DAT_0054a168 = 1;
	std::internal::__cintrindisp_internal();
	return;
}



// Library Function - Single Match
// Name: __cintrindisp1
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __cintrindisp1(void)
{
	__trandisp1();
	DAT_0054a168 = 1;
	std::internal::__cintrindisp_internal();
	return;
}



// Library Function - Single Match
// Name: __ctrandisp2
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __cdecl __ctrandisp2(uint param_1,int param_2,uint param_3,int param_4)
{
	__fload(param_1,param_2);
	__fload(param_3,param_4);
	__trandisp2();
	std::internal::__std_FUN_004924de();
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void std::internal::__std_FUN_004924de(void)
{
	char cVar1;
	int unaff_EBP;
	float10 in_ST0;
	ushort in_FPUStatusWord;
	
	DAT_0054a168 = '\0';
	if (_DAT_0054a0c8 != 0) {
		DAT_0054a168 = 0;
		return;
	}
										// WARNING: Read-only address (ram,0x0054a160) is written
	DOUBLE_0054a160 = (double)in_ST0;
	cVar1 = *(char *)(unaff_EBP + -0x90);
	if (cVar1 != '\0') {
		if ((cVar1 != -1) && (cVar1 != -2)) {
			if (cVar1 == '\0') {
				DAT_0054a168 = 0;
				return;
			}
			*(int *)(unaff_EBP + -0x8e) = (int)cVar1;
			goto LAB_004925b3;
		}
		if (((ulonglong)DOUBLE_0054a160 & 0x7ff0000000000000) == 0) {
			*(undefined4 *)(unaff_EBP + -0x8e) = 4;
			in_ST0 = (float10)fscale(in_ST0,(float10)1536.0);
			if (ABS(in_ST0) < (float10)2.225073858507201e-308) {
				in_ST0 = in_ST0 * (float10)0.0;
			}
			goto LAB_004925b3;
		}
		if ((DOUBLE_0054a160._6_2_ & 0x7ff0) == 0x7ff0) {
			*(undefined4 *)(unaff_EBP + -0x8e) = 3;
			in_ST0 = (float10)fscale(in_ST0,(float10)-1536.0);
			if ((float10)1.797693134862316e+308 < ABS(in_ST0)) {
				in_ST0 = in_ST0 * (float10)INFINITY;
			}
			goto LAB_004925b3;
		}
	}
	if ((*(ushort *)(unaff_EBP + -0xa4) & 0x20) != 0) {
		DAT_0054a168 = 0;
		return;
	}
	if ((in_FPUStatusWord & 0x20) == 0) {
		DAT_0054a168 = 0;
		return;
	}
	*(undefined4 *)(unaff_EBP + -0x8e) = 8;
LAB_004925b3:
	*(int *)(unaff_EBP + -0x8a) = *(int *)(unaff_EBP + -0x94) + 1;
	if (DAT_0054a168 == '\0') {
		*(undefined4 *)(unaff_EBP + -0x86) = *(undefined4 *)(unaff_EBP + 8);
		*(undefined4 *)(unaff_EBP + -0x82) = *(undefined4 *)(unaff_EBP + 0xc);
		if (*(char *)(*(int *)(unaff_EBP + -0x94) + 0xd) != '\x01') {
			*(undefined4 *)(unaff_EBP + -0x7e) = *(undefined4 *)(unaff_EBP + 0x10);
			*(undefined4 *)(unaff_EBP + -0x7a) = *(undefined4 *)(unaff_EBP + 0x14);
		}
	}
	*(double *)(unaff_EBP + -0x76) = (double)in_ST0;
	__std_FUN_00498fa0((int)*(char *)(*(int *)(unaff_EBP + -0x94) + 0xe),(int *)(unaff_EBP + -0x8e),
										 (ushort *)(unaff_EBP + -0xa4));
										// WARNING: Read-only address (ram,0x0054a160) is written
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void std::internal::__cintrindisp_internal(void)
{
	char cVar1;
	int unaff_EBP;
	float10 in_ST0;
	ushort in_FPUStatusWord;
	
	if (_DAT_0054a0c8 != 0) {
		return;
	}
										// WARNING: Read-only address (ram,0x0054a160) is written
	DOUBLE_0054a160 = (double)in_ST0;
	cVar1 = *(char *)(unaff_EBP + -0x90);
	if (cVar1 != '\0') {
		if ((cVar1 != -1) && (cVar1 != -2)) {
			if (cVar1 == '\0') {
				return;
			}
			*(int *)(unaff_EBP + -0x8e) = (int)cVar1;
			goto LAB_004925b3;
		}
		if (((ulonglong)DOUBLE_0054a160 & 0x7ff0000000000000) == 0) {
			*(undefined4 *)(unaff_EBP + -0x8e) = 4;
			in_ST0 = (float10)fscale(in_ST0,(float10)1536.0);
			if (ABS(in_ST0) < (float10)2.225073858507201e-308) {
				in_ST0 = in_ST0 * (float10)0.0;
			}
			goto LAB_004925b3;
		}
		if ((DOUBLE_0054a160._6_2_ & 0x7ff0) == 0x7ff0) {
			*(undefined4 *)(unaff_EBP + -0x8e) = 3;
			in_ST0 = (float10)fscale(in_ST0,(float10)-1536.0);
			if ((float10)1.797693134862316e+308 < ABS(in_ST0)) {
				in_ST0 = in_ST0 * (float10)INFINITY;
			}
			goto LAB_004925b3;
		}
	}
	if ((*(ushort *)(unaff_EBP + -0xa4) & 0x20) != 0) {
		return;
	}
	if ((in_FPUStatusWord & 0x20) == 0) {
		return;
	}
	*(undefined4 *)(unaff_EBP + -0x8e) = 8;
LAB_004925b3:
	*(int *)(unaff_EBP + -0x8a) = *(int *)(unaff_EBP + -0x94) + 1;
	if (DAT_0054a168 == '\0') {
		*(undefined4 *)(unaff_EBP + -0x86) = *(undefined4 *)(unaff_EBP + 8);
		*(undefined4 *)(unaff_EBP + -0x82) = *(undefined4 *)(unaff_EBP + 0xc);
		if (*(char *)(*(int *)(unaff_EBP + -0x94) + 0xd) != '\x01') {
			*(undefined4 *)(unaff_EBP + -0x7e) = *(undefined4 *)(unaff_EBP + 0x10);
			*(undefined4 *)(unaff_EBP + -0x7a) = *(undefined4 *)(unaff_EBP + 0x14);
		}
	}
	*(double *)(unaff_EBP + -0x76) = (double)in_ST0;
	__std_FUN_00498fa0((int)*(char *)(*(int *)(unaff_EBP + -0x94) + 0xe),(int *)(unaff_EBP + -0x8e),
										 (ushort *)(unaff_EBP + -0xa4));
										// WARNING: Read-only address (ram,0x0054a160) is written
	return;
}



// Library Function - Single Match
// Name: __ctrandisp1
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

void __cdecl __ctrandisp1(uint param_1,int param_2)
{
	__fload(param_1,param_2);
	__trandisp1();
	std::internal::__std_FUN_004924de();
	return;
}



// Library Function - Single Match
// Name: __fload
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release, Visual Studio 2003 Debug, Visual
// Studio 2003 Release

float10 __cdecl __fload(uint param_1,int param_2)
{
	float10 fVar1;
	
	if ((param_2._2_2_ & 0x7ff0) == 0x7ff0) {
		fVar1 = (float10)(CONCAT28(param_2._2_2_,CONCAT44(param_2 << 0xb | param_1 >> 0x15,param_1)) |
										 0x7fff);
	}
	else {
		fVar1 = (float10)(double)CONCAT26(param_2._2_2_,CONCAT24((undefined2)param_2,param_1));
	}
	return fVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 std::internal::__std_FUN_00492e86(undefined4 param_1,uint param_2,ushort param_3)
{
	undefined4 in_EAX;
	int iVar1;
	float10 fVar2;
	float10 fVar3;
	undefined4 in_stack_0000001c;
	undefined2 uStack00000020;
	uint in_stack_00000020;
	undefined2 uStack00000022;
	ushort in_stack_00000024;
	
	if ((((((CONCAT22(param_3,param_2._2_2_) ^ 0x700) & 0x700) == 0) &&
			 ((&DAT_004b302c)[(param_2._2_2_ & 0x7800) >> 0xb] != '\0')) && ((param_3 & 0x7fff) != 0x7fff)
			) && ((((in_stack_00000024 & 0x7fff) != 0 && ((in_stack_00000024 & 0x7fff) != 0x7fff)) &&
						(((in_stack_00000020 & 0x7fffffff) == 0 && ((param_2 & 0x7fffffff) == 0)))))) {
		if ((ushort)((param_3 & 0x7fff) + 0x3f) < (in_stack_00000024 & 0x7fff)) {
			iVar1 = ((in_stack_00000024 & 0x7fff) - (param_3 & 0x7fff) & 0x3f | 0x20) + 1;
			fVar3 = ABS((float10)CONCAT28(in_stack_00000024 & 0x7fff | param_3 & 0x8000,
																		CONCAT26(param_2._2_2_,CONCAT24((undefined2)param_2,param_1))));
			fVar2 = ABS((float10)CONCAT28(in_stack_00000024,
																		CONCAT26(uStack00000022,
																						 CONCAT24(uStack00000020,in_stack_0000001c))));
			do {
				if (fVar3 <= fVar2) {
					fVar2 = fVar2 - fVar3;
				}
				fVar3 = fVar3 * (float10)_DAT_004b305c;
				iVar1 += -1;
			} while (iVar1 != 0);
		}
		else {
			while (-1 < (int)((in_stack_00000024 & 0x7fff) - ((param_3 & 0x7fff) + 10))) {
				fVar2 = (float10)CONCAT28(in_stack_00000024,
																	CONCAT26(uStack00000022,CONCAT24(uStack00000020,in_stack_0000001c)
																					));
				fVar3 = (float10)CONCAT28((in_stack_00000024 & 0x7fff) -
																	((in_stack_00000024 & 0x7fff) - param_3 & 7 | 4) |
																	param_3 & 0x8000,
																	CONCAT26(param_2._2_2_,CONCAT24((undefined2)param_2,param_1)));
				fVar2 = fVar2 - (fVar2 / fVar3) * fVar3;
				in_stack_0000001c = SUB104(fVar2,0);
				uStack00000020 = (undefined2)((unkuint10)fVar2 >> 0x20);
				uStack00000022 = (undefined2)((unkuint10)fVar2 >> 0x30);
				in_stack_00000024 = (ushort)((unkuint10)fVar2 >> 0x40);
			}
		}
	}
	return in_EAX;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

float10 std::internal::__std_FUN_0049308c(void)
{
	float10 in_ST0;
	float10 fVar1;
	float10 in_ST1;
	
	if (((unkuint10)in_ST1 & 0) != 0) {
		fVar1 = (float10)__std_FUN_00492e86();
		return fVar1;
	}
	if ((SUB104(in_ST1,0) | (uint)((unkuint10)in_ST1 >> 0x20)) != 0) {
		fVar1 = (float10)__std_FUN_00492e86(in_ST1 * (float10)_DAT_004b3044);
		return fVar1;
	}
	return in_ST0 - (in_ST0 / in_ST1) * in_ST1;
}



float10 __cdecl std::internal::__std_unk_round_internal__00493410(double param_1)
{
	return (float10)ROUND(param_1);
}



float10 __cdecl std::internal::__std_unk_math__00493430(int param_1,double param_2,uint new)
{
	float10 fVar1;
	
	if (DAT_004b38e0 == 0) {
		fVar1 = __std_unk_math__00493bb0(1,param_1,param_2,0,0,param_2,new);
		return fVar1;
	}
	std::globals::g_msvc_errno = EDOM;
	_control87(new,0xffff);
	return (float10)param_2;
}



float10 __cdecl
std::internal::__std_FUN_00493480
					(uint param_1,uint param_2,double param_3,double param_4,uint param_5)
{
	uint uVar1;
	int iVar2;
	float10 fVar3;
	uint local_58 [14];
	uint local_20;
	
	uVar1 = __std_FUN_00493880(param_1,&param_4,param_5);
	if (uVar1 == 0) {
		local_20 &= 0xfffffffe;
		__std_FUN_00493540(local_58,&param_5,(byte)param_1,param_2,(uint *)&param_3,(uint *)&param_4);
	}
	iVar2 = __std_FUN_00493cc0(param_1);
	if ((DAT_004b38e0 == 0) && (iVar2 != 0)) {
		fVar3 = __std_unk_math__00493bb0(iVar2,param_2,param_3,0,0,param_4,param_5);
		return fVar3;
	}
	__std_FUN_00493c60(iVar2);
	_control87(param_5,0xffff);
	return (float10)param_4;
}



void __cdecl
std::internal::__std_FUN_00493540
					(uint *param_1,uint *param_2,byte param_3,uint param_4,uint *param_5,uint *param_6)
{
	uint uVar1;
	uint *dwExceptionCode;
	
	param_1[1] = 0;
	param_1[2] = 0;
	param_1[3] = 0;
	dwExceptionCode = param_1;
	if ((param_3 & 0x10) != 0) {
		param_1[1] = param_1[1] | 1;
		dwExceptionCode = (uint *)0xc000008f;
	}
	if ((param_3 & 2) != 0) {
		dwExceptionCode = (uint *)0xc0000093;
		param_1[1] = param_1[1] | 2;
	}
	if ((param_3 & 1) != 0) {
		dwExceptionCode = (uint *)0xc0000091;
		param_1[1] = param_1[1] | 4;
	}
	if ((param_3 & 4) != 0) {
		dwExceptionCode = (uint *)0xc000008e;
		param_1[1] = param_1[1] | 8;
	}
	if ((param_3 & 8) != 0) {
		dwExceptionCode = (uint *)0xc0000090;
		param_1[1] = param_1[1] | 0x10;
	}
	param_1[2] = (~*param_2 & 1) << 4 | param_1[2] & 0xffffffef;
	param_1[2] = (~*param_2 & 4) << 1 | param_1[2] & 0xfffffff7;
	param_1[2] = ~*param_2 >> 1 & 4 | param_1[2] & 0xfffffffb;
	param_1[2] = ~*param_2 >> 3 & 2 | param_1[2] & 0xfffffffd;
	param_1[2] = ~*param_2 >> 5 & 1 | param_1[2] & 0xfffffffe;
	uVar1 = _status87();
	if ((uVar1 & 1) != 0) {
		param_1[3] = param_1[3] | 0x10;
	}
	if ((uVar1 & 4) != 0) {
		param_1[3] = param_1[3] | 8;
	}
	if ((uVar1 & 8) != 0) {
		param_1[3] = param_1[3] | 4;
	}
	if ((uVar1 & 0x10) != 0) {
		param_1[3] = param_1[3] | 2;
	}
	if ((uVar1 & 0x20) != 0) {
		param_1[3] = param_1[3] | 1;
	}
	uVar1 = *param_2 & 0xc00;
	if (uVar1 < 0x401) {
		if (uVar1 == 0x400) {
			*param_1 = *param_1 & 0xfffffffd | 1;
		}
		else {
			if (uVar1 == 0) {
				*param_1 = *param_1 & 0xfffffffc;
			}
		}
	}
	else {
		if (uVar1 == 0x800) {
			*param_1 = *param_1 & 0xfffffffe | 2;
		}
		else {
			if (uVar1 == 0xc00) {
				*param_1 = *param_1 | 3;
			}
		}
	}
	uVar1 = *param_2 & 0x300;
	if (uVar1 == 0) {
		*param_1 = *param_1 & 0xffffffeb | 8;
	}
	else {
		if (uVar1 == 0x200) {
			*param_1 = *param_1 & 0xffffffe7 | 4;
		}
		else {
			if (uVar1 == 0x300) {
				*param_1 = *param_1 & 0xffffffe3;
			}
		}
	}
	*param_1 = *param_1 & 0xfffe001f | (param_4 & 0xfff) << 5;
	param_1[8] = param_1[8] | 1;
	param_1[8] = param_1[8] & 0xffffffe3 | 2;
	param_1[4] = *param_5;
	param_1[5] = param_5[1];
	param_1[0x14] = param_1[0x14] | 1;
	param_1[0x14] = param_1[0x14] & 0xffffffe3 | 2;
	param_1[0x10] = *param_6;
	param_1[0x11] = param_6[1];
	_clear87();
	RaiseException((DWORD)dwExceptionCode,0,1,(ULONG_PTR *)&param_1);
	if ((*(byte *)(param_1 + 2) & 0x10) != 0) {
		*param_2 = *param_2 & 0xfffffffe;
	}
	if ((*(byte *)(param_1 + 2) & 8) != 0) {
		*param_2 = *param_2 & 0xfffffffb;
	}
	if ((*(byte *)(param_1 + 2) & 4) != 0) {
		*param_2 = *param_2 & 0xfffffff7;
	}
	if ((*(byte *)(param_1 + 2) & 2) != 0) {
		*param_2 = *param_2 & 0xffffffef;
	}
	if ((*(byte *)(param_1 + 2) & 1) != 0) {
		*param_2 = *param_2 & 0xffffffdf;
	}
	switch(*param_1 & 3) {
	case 0:
		uVar1 = *param_2 & 0xfffff3ff;
		break;
	case 1:
		*param_2 = *param_2 & 0xfffff7ff | 0x400;
		goto switchD_004937db_caseD_4;
	case 2:
		uVar1 = *param_2 & 0xfffffbff | 0x800;
		break;
	case 3:
		uVar1 = *param_2 | 0xc00;
		break;
	default:
		goto switchD_004937db_caseD_4;
	}
	*param_2 = uVar1;
switchD_004937db_caseD_4:
	uVar1 = *param_1 >> 2 & 7;
	if (uVar1 == 0) {
		*param_2 = *param_2 & 0xfffff3ff | 0x300;
	}
	else {
		if (uVar1 == 1) {
			*param_2 = *param_2 & 0xfffff3ff | 0x200;
			*param_6 = param_1[0x10];
			param_6[1] = param_1[0x11];
			return;
		}
		if (uVar1 == 2) {
			*param_2 = *param_2 & 0xfffff3ff;
			*param_6 = param_1[0x10];
			param_6[1] = param_1[0x11];
			return;
		}
	}
	*param_6 = param_1[0x10];
	param_6[1] = param_1[0x11];
	return;
}



// WARNING: Could not reconcile some variable overlaps

uint __cdecl std::internal::__std_FUN_00493880(uint param_1,double *param_2,uint param_3)
{
	undefined4 uVar1;
	undefined4 uVar2;
	double dVar3;
	uint uVar4;
	bool bVar5;
	float10 fVar6;
	int local_14;
	undefined8 local_10;
	
	uVar4 = param_1 & 0x1f;
	if (((param_1 & 8) == 0) || ((param_3 & 1) == 0)) {
		if (((param_1 & 4) == 0) || ((param_3 & 4) == 0)) {
			if (((param_1 & 1) == 0) || ((param_3 & 8) == 0)) {
				if (((param_1 & 2) != 0) && ((param_3 & 0x10) != 0)) {
					bVar5 = (param_1 & 0x10) != 0;
					local_10 = *param_2;
					if (local_10 == 0.0) {
						bVar5 = true;
					}
					else {
						fVar6 = __std_FUN_00493da0(*param_2,&local_14);
						local_14 += -0x600;
						if (local_14 < -0x432) {
							bVar5 = true;
							*(undefined4 *)param_2 = 0;
							local_10 = 0.0;
							*(undefined4 *)((int)param_2 + 4) = 0;
						}
						else {
							local_10 = (double)(ulonglong)
																 (SUB87((double)fVar6,0) & 0xfffffffffffff | 0x10000000000000);
							if (local_14 < -0x3fd) {
								local_14 = -0x3fd - local_14;
								do {
									dVar3 = local_10;
									if ((((ulonglong)local_10 & 1) != 0) && (!bVar5)) {
										bVar5 = true;
									}
									local_10 = (double)((ulonglong)local_10 & 0xffffffff00000000 |
																		 (ulonglong)local_10 >> 1 & 0x7fffffff);
									if (((ulonglong)dVar3 & 0x100000000) != 0) {
										local_10 = (double)((ulonglong)local_10 | 0x80000000);
									}
									local_14 += -1;
									local_10 = (double)((ulonglong)local_10 & 0xffffffff |
																		 ((ulonglong)local_10 >> 0x21) << 0x20);
								} while (local_14 != 0);
							}
							if ((double)fVar6 < 0.0) {
								local_10 = -local_10;
							}
							*(undefined4 *)param_2 = (undefined4)local_10;
							*(undefined4 *)((int)param_2 + 4) = local_10._4_4_;
						}
					}
					if (bVar5) {
						__std_FUN_00493f00(0x10);
					}
					uVar4 = param_1 & 0x1d;
				}
			}
			else {
				__std_FUN_00493f00(8);
				uVar2 = DAT_004b325c;
				uVar1 = DAT_004b324c;
				uVar4 = param_3 & 0xc00;
				if (uVar4 < 0x401) {
					if (uVar4 == 0x400) {
						if ((ushort)((ushort)(*param_2 < 0.0) << 8 | (ushort)(*param_2 == 0.0) << 0xe) == 0) {
							*(undefined4 *)param_2 = DAT_004b3258;
							*(undefined4 *)((int)param_2 + 4) = uVar2;
							uVar4 = param_1 & 0x1e;
						}
						else {
							local_10 = -(double)CONCAT44(DAT_004b324c,DAT_004b3248);
							local_10._4_4_ = (undefined4)((ulonglong)local_10 >> 0x20);
							*(undefined4 *)param_2 = (undefined4)local_10;
							*(undefined4 *)((int)param_2 + 4) = local_10._4_4_;
							uVar4 = param_1 & 0x1e;
						}
						goto LAB_00493b8b;
					}
					if (uVar4 == 0) {
						if ((ushort)((ushort)(*param_2 < 0.0) << 8 | (ushort)(*param_2 == 0.0) << 0xe) == 0) {
							*(undefined4 *)param_2 = DAT_004b3248;
							*(undefined4 *)((int)param_2 + 4) = uVar1;
							uVar4 = param_1 & 0x1e;
						}
						else {
							local_10 = -(double)CONCAT44(DAT_004b324c,DAT_004b3248);
							local_10._4_4_ = (undefined4)((ulonglong)local_10 >> 0x20);
							*(undefined4 *)param_2 = (undefined4)local_10;
							*(undefined4 *)((int)param_2 + 4) = local_10._4_4_;
							uVar4 = param_1 & 0x1e;
						}
						goto LAB_00493b8b;
					}
				}
				else {
					if (uVar4 == 0x800) {
						if ((ushort)((ushort)(*param_2 < 0.0) << 8 | (ushort)(*param_2 == 0.0) << 0xe) == 0) {
							*(undefined4 *)param_2 = DAT_004b3248;
							*(undefined4 *)((int)param_2 + 4) = uVar1;
							uVar4 = param_1 & 0x1e;
							goto LAB_00493b8b;
						}
						local_10 = -(double)CONCAT44(DAT_004b325c,DAT_004b3258);
						local_10._4_4_ = (undefined4)((ulonglong)local_10 >> 0x20);
						*(undefined4 *)param_2 = (undefined4)local_10;
						*(undefined4 *)((int)param_2 + 4) = local_10._4_4_;
					}
					else {
						if (uVar4 == 0xc00) {
							if ((ushort)((ushort)(*param_2 < 0.0) << 8 | (ushort)(*param_2 == 0.0) << 0xe) == 0) {
								*(undefined4 *)param_2 = DAT_004b3258;
								*(undefined4 *)((int)param_2 + 4) = uVar2;
								uVar4 = param_1 & 0x1e;
							}
							else {
								local_10 = -(double)CONCAT44(DAT_004b325c,DAT_004b3258);
								local_10._4_4_ = (undefined4)((ulonglong)local_10 >> 0x20);
								*(undefined4 *)param_2 = (undefined4)local_10;
								*(undefined4 *)((int)param_2 + 4) = local_10._4_4_;
								uVar4 = param_1 & 0x1e;
							}
							goto LAB_00493b8b;
						}
					}
				}
				uVar4 = param_1 & 0x1e;
			}
		}
		else {
			__std_FUN_00493f00(4);
			uVar4 = param_1 & 0x1b;
		}
	}
	else {
		__std_FUN_00493f00(1);
		uVar4 = param_1 & 0x17;
	}
LAB_00493b8b:
	if (((param_1 & 0x10) != 0) && ((param_3 & 0x20) != 0)) {
		__std_FUN_00493f00(0x20);
		uVar4 &= 0xffffffef;
	}
	return (uint)(uVar4 == 0);
}



// WARNING: Could not reconcile some variable overlaps

float10 __cdecl
std::internal::__std_unk_math__00493bb0
					(int param_1,int param_2,double param_3,undefined4 param_4,undefined4 param_5,
					double param_6,uint param_7)
{
	int iVar1;
	int local_20;
	undefined *local_1c;
	undefined8 local_18;
	undefined4 local_10;
	undefined4 local_c;
	undefined8 local_8;
	
	local_1c = __std_FUN_00493c90(param_2);
	if (local_1c != NULL) {
		local_c = param_5;
		local_10 = param_4;
		local_20 = param_1;
		local_18 = param_3;
		local_8 = param_6;
		_control87(param_7,0xffff);
		iVar1 = lego::nerps::funcs::NERPFunc__False(&local_20);
		if (iVar1 == 0) {
			__std_FUN_00493c60(param_1);
		}
		return (float10)local_8;
	}
	_control87(param_7,0xffff);
	__std_FUN_00493c60(param_1);
	return (float10)param_6;
}



void __cdecl std::internal::__std_FUN_00493c60(int param_1)
{
	if (param_1 == 1) {
		std::globals::g_msvc_errno = 0x21;
	}
	else {
		if ((1 < param_1) && (param_1 < 4)) {
			std::globals::g_msvc_errno = 0x22;
			return;
		}
	}
	return;
}



undefined * __cdecl std::internal::__std_FUN_00493c90(int param_1)
{
	int *piVar1;
	int iVar2;
	
	iVar2 = 0;
	piVar1 = &DAT_004b3170;
	do {
		if (*piVar1 == param_1) {
			return (&PTR_s_exp_004b3174)[iVar2 * 2];
		}
		piVar1 = piVar1 + 2;
		iVar2 += 1;
	} while ((int)piVar1 < 0x4b3248);
	return NULL;
}



int __cdecl std::internal::__std_FUN_00493cc0(uint param_1)
{
	if ((param_1 & 0x20) != 0) {
		return 5;
	}
	if ((param_1 & 8) != 0) {
		return 1;
	}
	if ((param_1 & 4) != 0) {
		return 2;
	}
	if ((param_1 & 1) != 0) {
		return 3;
	}
	return (param_1 & 2) << 1;
}



float10 __cdecl
std::internal::__std_FUN_00493d00(undefined4 param_1,undefined4 param_2,short param_3)
{
	undefined2 uStack4;
	
	uStack4 = (undefined2)param_2;
	return (float10)(double)CONCAT26(param_2._2_2_ & 0x800f | (param_3 + 0x3fe) * 0x10,
																	 CONCAT24(uStack4,param_1));
}



undefined4 __cdecl std::internal::__std_FUN_00493d40(double param_1)
{
	if ((param_1 == INFINITY) && (true)) {
		return 1;
	}
	if ((param_1 == -INFINITY) && (true)) {
		return 2;
	}
	if ((param_1._6_2_ & 0x7ff8) == 0x7ff8) {
										// QNAN
		return 3;
	}
	if (((param_1._6_2_ & 0x7ff8) == 0x7ff0) &&
		 ((((ulonglong)param_1 & 0x7ffff00000000) != 0 || (param_1._0_4_ != 0)))) {
										// SNAN
		return 4;
	}
										// NONE
	return 0;
}



float10 __cdecl std::internal::__std_FUN_00493da0(double param_1,int *param_2)
{
	ushort uVar1;
	bool bVar2;
	uint uVar3;
	uint uVar4;
	int iVar5;
	float10 fVar6;
	
	if (param_1 == 0.0) {
		*param_2 = 0;
		return (float10)0.0;
	}
	if ((((ulonglong)param_1 & 0x7ff0000000000000) == 0) &&
		 ((((ulonglong)param_1 & 0xfffff00000000) != 0 || (param_1._0_4_ != 0)))) {
		bVar2 = param_1 < 0.0;
		iVar5 = -0x3fd;
		if (((ulonglong)param_1 & 0x10000000000000) == 0) {
			do {
				uVar3 = (int)((ulonglong)param_1 >> 0x20) << 1;
				param_1._4_2_ = (undefined2)uVar3;
				param_1._6_1_ = (undefined)(uVar3 >> 0x10);
				param_1._7_1_ = (byte)(uVar3 >> 0x18);
				uVar4 = uVar3;
				if (((ulonglong)param_1 & 0x80000000) != 0) {
					uVar4 = uVar3 | 1;
					param_1._4_2_ = (undefined2)uVar4;
				}
				param_1._0_4_ = SUB84(param_1,0) << 1;
				param_1 = (double)CONCAT44(uVar4,param_1._0_4_);
				iVar5 += -1;
			} while ((uVar3 & 0x100000) == 0);
		}
		uVar1 = CONCAT11(param_1._7_1_,param_1._6_1_) & 0xffef;
		param_1._6_1_ = (undefined)uVar1;
		param_1._7_1_ = (byte)(uVar1 >> 8);
		if (bVar2) {
			param_1._7_1_ |= 0x80;
		}
		fVar6 = __std_FUN_00493d00(param_1._0_4_,
															 CONCAT13(param_1._7_1_,CONCAT12(param_1._6_1_,param_1._4_2_)),0);
		*param_2 = iVar5;
		return (float10)(double)fVar6;
	}
	fVar6 = __std_FUN_00493d00(param_1._0_4_,(int)((ulonglong)param_1 >> 0x20),0);
	*param_2 = (((ushort)((ulonglong)param_1 >> 0x30) & 0x7ff0) >> 4) - 0x3fe;
	return (float10)(double)fVar6;
}



// Another float function guess

uint __cdecl std::_status87(void)
{
	short in_FPUStatusWord;
	
	return (int)in_FPUStatusWord;
}



uint __cdecl std::_clear87(void)
{
	short in_FPUStatusWord;
	
	return (int)in_FPUStatusWord;
}



// Not entirely sure

uint __cdecl std::_control87(uint new,uint mask)
{
	short in_FPUControlWord;
	
	return (int)in_FPUControlWord;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __cdecl std::internal::__std_FUN_00493f00(int param_1)
{
	uint in_EAX;
	ushort in_FPUStatusWord;
	
	if ((param_1 & 8U) != 0) {
		in_EAX = in_EAX & 0xffff0000 | (uint)in_FPUStatusWord;
	}
	return in_EAX;
}



int __cdecl
std::internal::__uprlwr__00493f60
					(LCID param_1,uint param_2,char *param_3,LPCWSTR param_4,LPWSTR param_5,int param_6,
					UINT param_7)
{
	int iVar1;
	LPCWSTR cbMultiByte;
	LPCWSTR lpWideCharStr;
	int iVar2;
	
	if (DAT_0054a170 == 0) {
		iVar1 = LCMapStringA(0,0x100,(LPCSTR)&lpSrcStr_0049fd38,1,NULL,0);
		if (iVar1 == 0) {
			iVar1 = LCMapStringW(0,0x100,(LPCWSTR)&lpSrcStr_0049fd3c,1,NULL,0);
			if (iVar1 == 0) {
				return 0;
			}
			DAT_0054a170 = 1;
		}
		else {
			DAT_0054a170 = 2;
		}
	}
	cbMultiByte = param_4;
	if (0 < (int)param_4) {
		cbMultiByte = (LPCWSTR)__unkftime_uprlwr__00494180(param_3,(int)param_4);
	}
	if (DAT_0054a170 == 2) {
		iVar1 = LCMapStringA(param_1,param_2,param_3,(int)cbMultiByte,(LPSTR)param_5,param_6);
		return iVar1;
	}
	if (DAT_0054a170 != 1) {
		return DAT_0054a170;
	}
	param_4 = NULL;
	if (param_7 == 0) {
		param_7 = DAT_0054a190;
	}
	iVar1 = MultiByteToWideChar(param_7,9,param_3,(int)cbMultiByte,NULL,0);
	if (iVar1 == 0) {
		return 0;
	}
	lpWideCharStr = (LPCWSTR)malloc(iVar1 * 2);
	if (lpWideCharStr == NULL) {
		return 0;
	}
	iVar2 = MultiByteToWideChar(param_7,1,param_3,(int)cbMultiByte,lpWideCharStr,iVar1);
	if ((iVar2 != 0) && (iVar2 = LCMapStringW(param_1,param_2,lpWideCharStr,iVar1,NULL,0), iVar2 != 0)
		 ) {
		if ((param_2 & 0x400) == 0) {
			param_4 = (LPCWSTR)malloc(iVar2 * 2);
			if ((param_4 == NULL) ||
				 (iVar1 = LCMapStringW(param_1,param_2,lpWideCharStr,iVar1,param_4,iVar2), iVar1 == 0))
			goto LAB_0049415f;
			if (param_6 == 0) {
				iVar2 = WideCharToMultiByte(param_7,0x220,param_4,iVar2,NULL,0,NULL,NULL);
				iVar1 = iVar2;
			}
			else {
				iVar2 = WideCharToMultiByte(param_7,0x220,param_4,iVar2,(LPSTR)param_5,param_6,NULL,NULL);
				iVar1 = iVar2;
			}
		}
		else {
			if (param_6 == 0) goto LAB_004940c4;
			if (param_6 < iVar2) goto LAB_0049415f;
			iVar1 = LCMapStringW(param_1,param_2,lpWideCharStr,iVar1,param_5,param_6);
		}
		if (iVar1 != 0) {
LAB_004940c4:
			free(lpWideCharStr);
			free(param_4);
			return iVar2;
		}
	}
LAB_0049415f:
	free(lpWideCharStr);
	free(param_4);
	return 0;
}



char * __cdecl std::internal::__unkftime_uprlwr__00494180(char *param_1,int param_2)
{
	char *pcVar1;
	int iVar2;
	
	pcVar1 = param_1;
	iVar2 = param_2;
	if (param_2 != 0) {
		do {
			iVar2 += -1;
			if (*pcVar1 == '\0') break;
			pcVar1 = pcVar1 + 1;
		} while (iVar2 != 0);
	}
	if (*pcVar1 == '\0') {
		return pcVar1 + -(int)param_1;
	}
	return (char *)param_2;
}



// WARNING: Could not reconcile some variable overlaps

int __cdecl std::vfscanf(FILE *stream,char *format,va_list argptr)
{
	byte *pbVar1;
	byte bVar2;
	int **ppiVar3;
	va_list *ppcVar4;
	uint uVar5;
	int iVar6;
	uint uVar7;
	int **c;
	uint uVar8;
	byte bVar9;
	byte *pbVar10;
	char *pcVar11;
	va_list *ppcVar12;
	char *pcVar13;
	int iVar14;
	undefined4 *puVar15;
	va_list *ppcVar16;
	va_list pcVar17;
	bool bVar18;
	ulonglong uVar19;
	FILE *file;
	char local_1cd;
	va_list local_1cc;
	char local_1c7;
	char local_1c6;
	char local_1c5;
	int local_1c4;
	char local_1c0;
	char local_1bf;
	char local_1be;
	byte local_1bd;
	uint local_1bc;
	va_list *local_1b8;
	undefined4 local_1b4;
	int local_1b0;
	int local_1ac;
	int local_1a8;
	va_list local_1a4;
	byte local_19e;
	undefined local_19d;
	undefined8 local_19c;
	uint local_194;
	ushort local_18e;
	int **local_18c;
	int local_188;
	uint local_184;
	undefined4 local_180 [2];
	undefined local_175;
	char local_160;
	char local_15f [351];
	
	local_1bf = '\0';
	local_1cc = NULL;
	local_1ac = 0;
	bVar2 = *format;
	c = local_18c;
	do {
		if (bVar2 == 0) {
LAB_00494e06:
			if ((c == (int **)0xffffffff) && ((local_1ac == 0 && (local_1bf == '\0')))) {
				local_1ac = -1;
			}
			return local_1ac;
		}
		iVar14 = 0;
		if (globals::_pcharwidth < 2) {
			uVar5 = *(byte *)(globals::_pctype + bVar2) & 8;
		}
		else {
			uVar5 = _isctype((uint)bVar2,8);
		}
		if (uVar5 != 0) {
			local_1cc = local_1cc + -1;
			file = stream;
			iVar6 = internal::__vfscanf__fgetc_skipws((int *)&local_1cc,stream);
			internal::__vfscanf__00494f60(iVar6,file);
			format = format + 1;
			iVar6 = isspace((uint)(byte)*format);
			while (iVar6 != 0) {
				format = (char *)((byte *)format + 1);
				iVar6 = isspace((uint)(byte)*format);
			}
		}
		if (*format != '%') {
			local_1cc = local_1cc + 1;
			c = (int **)internal::__vfscanf__fgetc(stream);
			if ((int **)(uint)(byte)*format != c) goto LAB_00494ded;
			pbVar10 = (byte *)(format + 1);
			if ((*(byte *)((int)globals::_pctype + ((uint)c & 0xff) * 2 + 1) & 0x80) != 0) {
				local_1cc = local_1cc + 1;
				uVar5 = internal::__vfscanf__fgetc(stream);
				if ((byte)format[1] != uVar5) {
					local_1cc = local_1cc + -1;
					internal::__vfscanf__00494f60(uVar5,stream);
					goto LAB_00494ded;
				}
				local_1cc = local_1cc + -1;
				pbVar10 = (byte *)(format + 2);
			}
			goto LAB_00494db3;
		}
		local_1a4 = NULL;
		local_1b4 &= 0xffffff00;
		local_1a8 = 0;
		local_1b0 = 0;
		local_1c4 = 0;
		local_1bd = 0;
		local_1be = '\0';
		local_1c5 = '\0';
		local_1cd = '\0';
		local_1c0 = '\0';
		local_1c7 = '\0';
		local_1c6 = '\x01';
		local_188 = 0;
		do {
			pbVar10 = (byte *)(format + 1);
			uVar5 = (uint)*pbVar10;
			if (globals::_pcharwidth < 2) {
				uVar7 = *(byte *)(globals::_pctype + uVar5) & 4;
			}
			else {
				uVar7 = _isctype(uVar5,4);
			}
			if (uVar7 != 0) {
				local_1b0 += 1;
				local_1c4 = (uVar5 - 0x30) + local_1c4 * 10;
				goto switchD_00494330_caseD_46;
			}
			if (false) {
switchD_00494330_caseD_2b:
				local_1cd += '\x01';
			}
			else {
				switch(uVar5) {
				case 0x2a:
					local_1c5 += '\x01';
					break;
				default:
					goto switchD_00494330_caseD_2b;
				case 0x46:
				case 0x4e:
					break;
				case 0x49:
					if ((format[2] != '6') || (format[3] != '4')) goto switchD_00494330_caseD_2b;
					iVar14 += 1;
					local_19c = 0;
					pbVar10 = (byte *)(format + 3);
					break;
				case 0x4c:
					local_1c6 += '\x01';
					break;
				case 0x68:
					local_1c6 += -1;
					local_1c7 += -1;
					break;
				case 0x6c:
					local_1c6 += '\x01';
				case 0x77:
					local_1c7 += '\x01';
				}
			}
switchD_00494330_caseD_46:
			format = (char *)pbVar10;
		} while (local_1cd == '\0');
		ppiVar3 = (int **)argptr;
		if (local_1c5 == '\0') {
			local_1b8 = *(va_list **)argptr;
			ppiVar3 = (int **)((int)argptr + 4);
			local_18c = (int **)argptr;
		}
		argptr = (va_list)ppiVar3;
		bVar18 = false;
		if ((local_1c7 == '\0') && ((*format == 'S' || (local_1c7 = -1, *format == 'C')))) {
			local_1c7 = '\x01';
		}
		local_1bc = (byte)*format | 0x20;
		local_188 = iVar14;
		uVar19 = local_19c;
		if (local_1bc != 0x6e) {
			if ((local_1bc == 99) || (local_1bc == 0x7b)) {
				local_1cc = local_1cc + 1;
				c = (int **)internal::__vfscanf__fgetc(stream);
				uVar19 = local_19c;
			}
			else {
				c = (int **)internal::__vfscanf__fgetc_skipws((int *)&local_1cc,stream);
				uVar19 = local_19c;
			}
		}
		ppcVar12 = local_1b8;
		uVar5 = local_1bc;
		local_19c = uVar19;
		if ((local_1b0 != 0) && (local_1c4 == 0)) {
LAB_00494ded:
			local_1cc = local_1cc + -1;
			internal::__vfscanf__00494f60((int)c,stream);
			goto LAB_00494e06;
		}
		if (false) {
switchD_00494448_caseD_68:
			if ((int **)(uint)(byte)*format != c) goto LAB_00494ded;
			local_1bf += -1;
			if (local_1c5 == '\0') {
				argptr = (va_list)local_18c;
			}
			goto LAB_00494d38;
		}
		switch(local_1bc) {
		case 99:
			if (local_1b0 == 0) {
				local_1b0 = 1;
				local_1c4 += 1;
			}
			if ('\0' < local_1c7) {
				local_1c0 = '\x01';
			}
			pcVar11 = &DAT_004b3294;
			break;
		case 100:
		case 0x6f:
		case 0x75:
			goto switchD_00494448_caseD_64;
		case 0x65:
		case 0x66:
		case 0x67:
			pcVar11 = &local_160;
			if (c == (int **)0x2d) {
				local_160 = '-';
				pcVar11 = local_15f;
LAB_00494af3:
				local_1c4 += -1;
				local_1cc = local_1cc + 1;
				c = (int **)internal::__vfscanf__fgetc(stream);
				uVar19 = local_19c;
			}
			else {
				if (c == (int **)0x2b) goto LAB_00494af3;
			}
			iVar14 = local_1a8;
			if ((local_1b0 == 0) || (0x15d < local_1c4)) {
				local_1c4 = 0x15d;
			}
			while( true ) {
				if (globals::_pcharwidth < 2) {
					uVar5 = *(byte *)(globals::_pctype + (int)c) & 4;
				}
				else {
					local_19c = uVar19;
					uVar5 = _isctype((int)c,4);
					uVar19 = local_19c;
				}
				local_19c = uVar19;
				if ((uVar5 == 0) ||
					 (iVar6 = local_1c4 + -1, bVar18 = local_1c4 == 0, local_1c4 = iVar6, bVar18)) break;
				*pcVar11 = (char)c;
				pcVar11 = pcVar11 + 1;
				local_1cc = local_1cc + 1;
				c = (int **)internal::__vfscanf__fgetc(stream);
				iVar14 = iVar14 + 1;
				uVar19 = local_19c;
			}
			if ((DAT_004b0f78 == (char)c) &&
				 (iVar6 = local_1c4 + -1, bVar18 = local_1c4 != 0, local_1c4 = iVar6, bVar18)) {
				local_1cc = local_1cc + 1;
				c = (int **)internal::__vfscanf__fgetc(stream);
				*pcVar11 = DAT_004b0f78;
				while( true ) {
					pcVar11 = pcVar11 + 1;
					if (globals::_pcharwidth < 2) {
						uVar5 = *(byte *)(globals::_pctype + (int)c) & 4;
						uVar19 = local_19c;
					}
					else {
						uVar5 = _isctype((int)c,4);
						uVar19 = local_19c;
					}
					if ((uVar5 == 0) ||
						 (iVar6 = local_1c4 + -1, bVar18 = local_1c4 == 0, local_1c4 = iVar6, bVar18)) break;
					*pcVar11 = (char)c;
					iVar14 += 1;
					local_1cc = local_1cc + 1;
					local_19c = uVar19;
					c = (int **)internal::__vfscanf__fgetc(stream);
				}
			}
			pcVar13 = pcVar11;
			if ((iVar14 != 0) &&
				 (((c == (int **)0x65 || (c == (int **)0x45)) &&
					(iVar6 = local_1c4 + -1, bVar18 = local_1c4 != 0, local_1c4 = iVar6, bVar18)))) {
				*pcVar11 = 'e';
				pcVar13 = pcVar11 + 1;
				local_1cc = local_1cc + 1;
				local_19c = uVar19;
				c = (int **)internal::__vfscanf__fgetc(stream);
				if (c == (int **)0x2d) {
					*pcVar13 = '-';
					pcVar13 = pcVar11 + 2;
LAB_00494c4e:
					iVar6 = local_1c4 + -1;
					uVar19 = local_19c;
					if (local_1c4 != 0) goto LAB_00494c63;
				}
				else {
					if (c == (int **)0x2b) goto LAB_00494c4e;
				}
				while( true ) {
					if (globals::_pcharwidth < 2) {
						uVar5 = *(byte *)(globals::_pctype + (int)c) & 4;
						uVar19 = local_19c;
					}
					else {
						uVar5 = _isctype((int)c,4);
						uVar19 = local_19c;
					}
					if ((uVar5 == 0) ||
						 (iVar6 = local_1c4 + -1, bVar18 = local_1c4 == 0, local_1c4 = iVar6, bVar18)) break;
					iVar14 += 1;
					*pcVar13 = (char)c;
					pcVar13 = pcVar13 + 1;
LAB_00494c63:
					local_1c4 = iVar6;
					local_1cc = local_1cc + 1;
					local_19c = uVar19;
					c = (int **)internal::__vfscanf__fgetc(stream);
				}
			}
			local_1cc = local_1cc + -1;
			local_19c = uVar19;
			internal::__vfscanf__00494f60((int)c,stream);
			if (iVar14 != 0) {
				uVar19 = local_19c;
				if (local_1c5 == '\0') {
					local_1ac += 1;
					*pcVar13 = '\0';
					(*(code *)PTR___std_FUN_004b0f88)(local_1c6 + -1,local_1b8,&local_160);
					uVar19 = local_19c;
				}
				goto LAB_00494d38;
			}
			goto LAB_00494e06;
		default:
			goto switchD_00494448_caseD_68;
		case 0x69:
			local_1bc = 100;
		case 0x78:
			uVar5 = local_1bc;
			if (c == (int **)0x2d) {
				local_1be = '\x01';
LAB_00494702:
				local_1c4 += -1;
				if ((local_1c4 == 0) && (local_1b0 != 0)) {
					bVar18 = true;
				}
				else {
					local_1cc = local_1cc + 1;
					c = (int **)internal::__vfscanf__fgetc(stream);
					uVar19 = local_19c;
				}
			}
			else {
				if (c == (int **)0x2b) goto LAB_00494702;
			}
			if (c == (int **)0x30) {
				local_1cc = local_1cc + 1;
				local_19c = uVar19;
				c = (int **)internal::__vfscanf__fgetc(stream);
				if (((char)c == 'x') || ((char)c == 'X')) {
					local_1cc = local_1cc + 1;
					c = (int **)internal::__vfscanf__fgetc(stream);
					uVar5 = 0x78;
					local_1bc = 0x78;
					uVar19 = local_19c;
				}
				else {
					local_1a8 = 1;
					if (uVar5 == 0x78) {
						local_1cc = local_1cc + -1;
						internal::__vfscanf__00494f60((int)c,stream);
						c = (int **)0x30;
						uVar19 = local_19c;
					}
					else {
						uVar5 = 0x6f;
						local_1bc = 0x6f;
						uVar19 = local_19c;
					}
				}
			}
			goto LAB_004947e4;
		case 0x6e:
			pcVar17 = local_1cc;
			if (local_1c5 != '\0') goto LAB_00494d38;
			goto LAB_00494aa5;
		case 0x70:
			local_1c6 = '\x01';
switchD_00494448_caseD_64:
			if (c == (int **)0x2d) {
				local_1be = '\x01';
LAB_004947ba:
				local_1c4 += -1;
				if ((local_1c4 == 0) && (local_1b0 != 0)) {
					bVar18 = true;
				}
				else {
					local_1cc = local_1cc + 1;
					c = (int **)internal::__vfscanf__fgetc(stream);
					uVar19 = local_19c;
				}
			}
			else {
				if (c == (int **)0x2b) goto LAB_004947ba;
			}
LAB_004947e4:
			pcVar17 = local_1a4;
			local_19c = uVar19;
			if (iVar14 == 0) {
				while (!bVar18) {
					local_19c = uVar19;
					if ((uVar5 == 0x78) || (uVar5 == 0x70)) {
						if (globals::_pcharwidth < 2) {
										// C1_XDIGIT (0x80)
							uVar7 = *(byte *)(globals::_pctype + (int)c) & C1_XDIGIT;
						}
						else {
										// C1_XDIGIT (0x80)
							uVar7 = _isctype((int)c,C1_XDIGIT);
							uVar19 = local_19c;
						}
						if (uVar7 != 0) {
							pcVar17 = (va_list)((int)pcVar17 << 4);
							local_19c = uVar19;
							c = (int **)internal::__hexdigit_subtractalpha((int)c);
							goto LAB_004949da;
						}
LAB_004949d6:
						bVar18 = true;
						local_19c = uVar19;
					}
					else {
						if (globals::_pcharwidth < 2) {
							uVar7 = *(byte *)(globals::_pctype + (int)c) & 4;
						}
						else {
							uVar7 = _isctype((int)c,4);
							uVar19 = local_19c;
						}
						if (uVar7 == 0) goto LAB_004949d6;
						local_19c = uVar19;
						if (uVar5 == 0x6f) {
							if (0x37 < (int)c) goto LAB_004949d6;
							pcVar17 = (va_list)((int)pcVar17 << 3);
						}
						else {
							pcVar17 = (va_list)((int)pcVar17 * 10);
						}
					}
LAB_004949da:
					if (bVar18) {
						local_1cc = local_1cc + -1;
						internal::__vfscanf__00494f60((int)c,stream);
						uVar19 = local_19c;
					}
					else {
						local_1a8 += 1;
						pcVar17 = (va_list)((int)c + (int)(pcVar17 + -0x30));
						if ((local_1b0 == 0) || (local_1c4 += -1, local_1c4 != 0)) {
							local_1cc = local_1cc + 1;
							c = (int **)internal::__vfscanf__fgetc(stream);
							uVar19 = local_19c;
						}
						else {
							bVar18 = true;
							uVar19 = local_19c;
						}
					}
				}
				local_1a4 = pcVar17;
				if (local_1be != '\0') {
					local_1a4 = (va_list)-(int)pcVar17;
				}
			}
			else {
				while( true ) {
					uVar5 = (uint)uVar19;
					uVar7 = (uint)(uVar19 >> 0x20);
					if (bVar18) break;
					if (local_1bc == 0x78) {
						if (globals::_pcharwidth < 2) {
							uVar5 = *(byte *)(globals::_pctype + (int)c) & 0x80;
						}
						else {
							uVar5 = _isctype((int)c,0x80);
						}
						if (uVar5 != 0) {
							uVar19 = internal::__allshl();
							c = (int **)internal::__hexdigit_subtractalpha((int)c);
							goto LAB_004948b1;
						}
LAB_004948ad:
						bVar18 = true;
					}
					else {
						if (globals::_pcharwidth < 2) {
							uVar8 = *(byte *)(globals::_pctype + (int)c) & 4;
						}
						else {
							uVar8 = _isctype((int)c,4);
						}
						if (uVar8 == 0) goto LAB_004948ad;
						if (local_1bc == 0x6f) {
							if (0x37 < (int)c) goto LAB_004948ad;
							uVar19 = internal::__allshl();
						}
						else {
							uVar19 = __allmul(uVar5,uVar7,10,0);
						}
					}
LAB_004948b1:
					if (bVar18) {
						local_1cc = local_1cc + -1;
						internal::__vfscanf__00494f60((int)c,stream);
					}
					else {
						ppiVar3 = c + -0xc;
						local_1a8 += 1;
						if ((local_1b0 == 0) || (local_1c4 += -1, local_1c4 != 0)) {
							local_1cc = local_1cc + 1;
							c = (int **)internal::__vfscanf__fgetc(stream);
							uVar19 = uVar19 + (longlong)(int)ppiVar3;
						}
						else {
							bVar18 = true;
							uVar19 = uVar19 + (longlong)(int)ppiVar3;
						}
					}
				}
				if (local_1be != '\0') {
					uVar19 = CONCAT44(-(uVar7 + (uVar5 != 0)),-uVar5);
				}
			}
			iVar14 = local_1a8;
			if (local_1bc == 0x46) {
				iVar14 = 0;
			}
			if (iVar14 != 0) {
				if (local_1c5 == '\0') {
					local_1ac += 1;
					pcVar17 = local_1a4;
					iVar14 = local_188;
LAB_00494aa5:
					local_19c._4_4_ = (va_list)(uVar19 >> 0x20);
					local_19c._0_4_ = (va_list)uVar19;
					if (iVar14 == 0) {
						if (local_1c6 == '\0') {
							*(short *)local_1b8 = (short)pcVar17;
						}
						else {
							*local_1b8 = pcVar17;
						}
					}
					else {
						*local_1b8 = (va_list)local_19c;
						local_1b8[1] = local_19c._4_4_;
					}
				}
				goto LAB_00494d38;
			}
			goto LAB_00494e06;
		case 0x73:
			if ('\0' < local_1c7) {
				local_1c0 = '\x01';
			}
			pcVar11 = " \t-\r]";
			break;
		case 0x7b:
			if ('\0' < local_1c7) {
				local_1c0 = '\x01';
			}
			pbVar10 = (byte *)(format + 1);
			pcVar11 = (char *)pbVar10;
			if (*pbVar10 == 0x5e) {
				pcVar11 = format + 2;
				format = (char *)pbVar10;
				break;
			}
			goto LAB_004944b3;
		}
		local_1bd = 0xff;
		pbVar10 = (byte *)format;
LAB_004944b3:
		format = (char *)pbVar10;
		puVar15 = local_180;
		for (iVar14 = 8; iVar14 != 0; iVar14 += -1) {
			*puVar15 = 0;
			puVar15 = puVar15 + 1;
		}
		if ((local_1bc == 0x7b) && (*pcVar11 == 0x5d)) {
			local_1b4 = CONCAT31(local_1b4._1_3_,0x5d);
			pcVar11 = (char *)((byte *)pcVar11 + 1);
			local_175 = 0x20;
		}
		bVar2 = *pcVar11;
		while (bVar2 != 0x5d) {
			pbVar10 = (byte *)pcVar11 + 1;
			local_184 = local_184 & 0xffffff00 | (uint)bVar2;
			if (((bVar2 == 0x2d) && ((byte)local_1b4 != 0)) && (bVar9 = *pbVar10, bVar9 != 0x5d)) {
				pbVar10 = (byte *)pcVar11 + 2;
				if ((byte)local_1b4 < bVar9) {
					local_194 = local_194 & 0xffffff00 | (uint)bVar9;
					bVar9 = (byte)local_1b4;
				}
				else {
					local_194 = local_194 & 0xffffff00 | local_1b4 & 0xff;
					local_1b4 = local_1b4 & 0xffffff00 | (uint)bVar9;
				}
				if (bVar9 <= (byte)local_194) {
					uVar5 = local_1b4 & 0xff;
					iVar14 = ((local_194 & 0xff) - uVar5) + 1;
					do {
						bVar2 = (byte)uVar5;
						pbVar1 = (byte *)((int)local_180 + (uVar5 >> 3));
						uVar5 += 1;
						iVar14 += -1;
						*pbVar1 = *pbVar1 | '\x01' << (bVar2 & 7);
					} while (iVar14 != 0);
				}
				local_1b4 &= 0xffffff00;
			}
			else {
				local_1b4 = local_1b4 & 0xffffff00 | (uint)bVar2;
				pbVar1 = (byte *)((int)local_180 + (uint)(bVar2 >> 3));
				*pbVar1 = *pbVar1 | '\x01' << (bVar2 & 7);
			}
			pcVar11 = (char *)pbVar10;
			bVar2 = *pbVar10;
		}
		if (*pcVar11 == 0) goto LAB_00494e06;
		if (local_1bc == 0x7b) {
			format = pcVar11;
		}
		local_1cc = local_1cc + -1;
		internal::__vfscanf__00494f60((int)c,stream);
		ppcVar16 = ppcVar12;
		while( true ) {
			if ((local_1b0 != 0) &&
				 (iVar14 = local_1c4 + -1, bVar18 = local_1c4 == 0, local_1c4 = iVar14, ppcVar4 = ppcVar16,
				 bVar18)) goto LAB_0049469c;
			local_1cc = local_1cc + 1;
			c = (int **)internal::__vfscanf__fgetc(stream);
			if ((c == (int **)0xffffffff) ||
				 (bVar2 = (byte)c,
				 ((int)(char)(*(byte *)((int)local_180 + ((int)c >> 3)) ^ local_1bd) & 1 << (bVar2 & 7)) ==
				 0)) break;
			if (local_1c5 == '\0') {
				if (local_1c0 == '\0') {
					*(byte *)ppcVar16 = bVar2;
					ppcVar16 = (va_list *)((int)ppcVar16 + 1);
				}
				else {
					local_19e = bVar2;
					if ((*(byte *)((int)globals::_pctype + ((uint)c & 0xff) * 2 + 1) & 0x80) != 0) {
						local_1cc = local_1cc + 1;
						iVar14 = internal::__vfscanf__fgetc(stream);
						local_19d = (undefined)iVar14;
					}
					internal::__vfscanf__004990c0(&local_18e,&local_19e,globals::_pcharwidth);
					*(ushort *)ppcVar16 = local_18e;
					ppcVar16 = (va_list *)((int)ppcVar16 + 2);
				}
			}
			else {
				ppcVar12 = (va_list *)((int)ppcVar12 + 1);
			}
		}
		local_1cc = local_1cc + -1;
		local_1b8 = ppcVar16;
		internal::__vfscanf__00494f60((int)c,stream);
		ppcVar4 = local_1b8;
LAB_0049469c:
		local_1b8 = ppcVar4;
		if (ppcVar12 == ppcVar16) goto LAB_00494e06;
		uVar19 = local_19c;
		if ((local_1c5 == '\0') && (local_1ac += 1, local_1bc != 99)) {
			if (local_1c0 == '\0') {
				*(undefined *)local_1b8 = 0;
			}
			else {
				*(undefined2 *)local_1b8 = 0;
			}
		}
LAB_00494d38:
		local_1bf += '\x01';
		pbVar10 = (byte *)(format + 1);
		local_19c = uVar19;
LAB_00494db3:
		format = (char *)pbVar10;
		if ((c == (int **)0xffffffff) && ((*format != '%' || (format[1] != 'n')))) goto LAB_00494e06;
		bVar2 = *format;
	} while( true );
}



int __cdecl std::internal::__hexdigit_subtractalpha(int c)
{
	uint uVar1;
	
										// int std::isdigit(int c)
	if (std::globals::_pcharwidth < 2) {
										// C1_DIGIT (0x4)
		uVar1 = *(byte *)(std::globals::_pctype + c) & C1_DIGIT;
	}
	else {
										// C1_DIGIT (0x4)
		uVar1 = _isctype(c,C1_DIGIT);
	}
	if (uVar1 == 0) {
		c = (c & 0xffffffdfU) - 7;
	}
	return c;
}



int __cdecl std::internal::__vfscanf__fgetc(FILE *file)
{
	byte bVar1;
	int iVar2;
	uint uVar3;
	
	iVar2 = file->_cnt + -1;
	file->_cnt = iVar2;
	if (-1 < iVar2) {
		bVar1 = *file->_ptr;
		file->_ptr = file->_ptr + 1;
		return (uint)bVar1;
	}
	uVar3 = __fpeekc(file);
	return uVar3;
}



int __cdecl std::internal::__vfscanf__00494f60(int c,FILE *file)
{
	if (c != -1) {
		c = __vfscanf__00499210(c,file);
	}
	return c;
}



int __cdecl std::internal::__vfscanf__fgetc_skipws(int *out_count,FILE *file)
{
	int c;
	int iVar1;
	
	*out_count = *out_count + 1;
	c = __vfscanf__fgetc(file);
	iVar1 = isspace(c);
	while (iVar1 != 0) {
		*out_count = *out_count + 1;
		c = __vfscanf__fgetc(file);
		iVar1 = isspace(c);
	}
	return c;
}



int __cdecl std::internal::__fdclose__00494fd0(uint fd)
{
	int iVar1;
	int iVar2;
	HANDLE hObject;
	BOOL BVar3;
	DWORD error_value;
	int iVar4;
	
	if (globals::__UINT_0076eec0 <= fd) {
		std::globals::g_msvc_errno = 9;
		std::globals::g_msvc_doserrno = 0;
		return -1;
	}
	iVar4 = (fd & 0x1f) * 8;
	if ((*(byte *)((&DAT_0076edc0)[(int)fd >> 5] + 4 + iVar4) & 1) == 0) {
		std::globals::g_msvc_errno = 9;
		std::globals::g_msvc_doserrno = 0;
		return -1;
	}
	iVar1 = __fdunk__004994b0(fd);
	if (iVar1 != -1) {
		if ((fd == 1) || (fd == 2)) {
			iVar1 = __fdunk__004994b0(2);
			iVar2 = __fdunk__004994b0(1);
			if (iVar2 == iVar1) goto LAB_00495057;
		}
		hObject = (HANDLE)__fdunk__004994b0(fd);
		BVar3 = CloseHandle(hObject);
		if (BVar3 == 0) {
			error_value = GetLastError();
			goto LAB_00495059;
		}
	}
LAB_00495057:
	error_value = 0;
LAB_00495059:
	__fdclose__00499410(fd);
	*(undefined *)((&DAT_0076edc0)[(int)fd >> 5] + 4 + iVar4) = 0;
	if (error_value == 0) {
		return 0;
	}
	__set_doserrno(error_value);
	return -1;
}



void __cdecl std::internal::__ffree__004950b0(FILE *file)
{
	if (((file->_flag & 0x83U) != 0) && ((file->_flag & 8U) != 0)) {
		free(file->_base);
		file->_flag = file->_flag & 0xfffffbf7;
		file->_ptr = NULL;
		file->_base = NULL;
		file->_cnt = 0;
	}
	return;
}



FILE * __cdecl
std::internal::__fsopen__004950f0(LPCSTR filename,char *mode,uint shflag,FILE *in_stream)
{
	char cVar1;
	bool bVar2;
	bool bVar3;
	bool bVar4;
	uint uVar5;
	char *pcVar6;
	uint uVar7;
	
	cVar1 = *mode;
	bVar3 = false;
	bVar4 = false;
	if (cVar1 == 'a') {
		uVar5 = 0x109;
	}
	else {
		if (cVar1 == 'r') {
			uVar5 = 0;
			uVar7 = DAT_0054a420 | 1;
			goto LAB_0049512d;
		}
		if (cVar1 != 'w') {
			return NULL;
		}
		uVar5 = 0x301;
	}
	uVar7 = DAT_0054a420 | 2;
LAB_0049512d:
	pcVar6 = mode + 1;
	bVar2 = true;
	cVar1 = *pcVar6;
	do {
		if ((cVar1 == '\0') || (!bVar2)) {
			uVar5 = __fsopen__00499500(filename,uVar5,shflag,0x1a4);
			if ((int)uVar5 < 0) {
				return NULL;
			}
			globals::__unkCount_0054a3e4 += 1;
			in_stream->_flag = uVar7;
			in_stream->_cnt = 0;
			in_stream->_ptr = NULL;
			in_stream->_base = NULL;
			in_stream->_tmpfname = NULL;
			in_stream->_file = uVar5;
			return in_stream;
		}
		if (false) goto switchD_00495160_caseD_2c;
		switch(cVar1) {
		case '+':
			if ((uVar5 & 2) != 0) break;
			uVar5 = uVar5 & 0xfffffffe | 2;
			uVar7 = uVar7 & 0xfffffffc | 0x80;
			goto LAB_004951de;
		case 'D':
			if ((uVar5 & 0x40) == 0) {
				uVar5 |= 0x40;
				goto LAB_004951de;
			}
			break;
		case 'R':
			if (!bVar4) {
				bVar4 = true;
				uVar5 |= 0x10;
				goto LAB_004951de;
			}
			break;
		case 'S':
			if (!bVar4) {
				bVar4 = true;
				uVar5 |= 0x20;
				goto LAB_004951de;
			}
			break;
		case 'T':
			if ((uVar5 & 0x1000) == 0) {
				uVar5 |= 0x1000;
				goto LAB_004951de;
			}
			break;
		case 'b':
			if ((uVar5 & 0xc000) == 0) {
				uVar5 |= 0x8000;
				goto LAB_004951de;
			}
			break;
		case 'c':
			if (!bVar3) {
				bVar3 = true;
				uVar7 |= 0x4000;
				goto LAB_004951de;
			}
			break;
		case 'n':
			if (!bVar3) {
				bVar3 = true;
				uVar7 &= 0xffffbfff;
				goto LAB_004951de;
			}
			break;
		case 't':
			if ((uVar5 & 0xc000) == 0) {
				uVar5 |= 0x4000;
				goto LAB_004951de;
			}
		}
switchD_00495160_caseD_2c:
		bVar2 = false;
LAB_004951de:
		pcVar6 = pcVar6 + 1;
		cVar1 = *pcVar6;
	} while( true );
}



FILE * __cdecl std::internal::__fsopen__004952c0(void)
{
	FILE *pFVar1;
	int iVar2;
	FILE **ppFVar3;
	FILE *pFVar4;
	
	pFVar4 = NULL;
	iVar2 = 0;
	ppFVar3 = globals::__filesTable_0076dd98;
	if (0 < globals::__filesCount_0076eda0) {
		do {
			if (*ppFVar3 == NULL) {
				pFVar1 = (FILE *)malloc(0x20);
				globals::__filesTable_0076dd98[iVar2] = pFVar1;
				if (globals::__filesTable_0076dd98[iVar2] != NULL) {
					pFVar4 = globals::__filesTable_0076dd98[iVar2];
				}
				break;
			}
			if ((*(byte *)&(*ppFVar3)->_flag & 0x83) == 0) {
				pFVar4 = globals::__filesTable_0076dd98[iVar2];
				break;
			}
			iVar2 += 1;
			ppFVar3 = ppFVar3 + 1;
		} while (iVar2 < globals::__filesCount_0076eda0);
	}
	if (pFVar4 != NULL) {
		pFVar4->_cnt = 0;
		pFVar4->_flag = 0;
		pFVar4->_base = NULL;
		pFVar4->_ptr = NULL;
		pFVar4->_tmpfname = NULL;
		pFVar4->_file = -1;
	}
	return pFVar4;
}



undefined4 __cdecl
std::internal::__std_FUN_00495350
					(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3,undefined4 param_4,
					int *param_5,PVOID param_6,PVOID param_7,undefined4 param_8)
{
	code *pcVar1;
	undefined4 uVar2;
	
	if (*param_5 != 0x19930520) {
		__std_FUN_00495e30();
	}
	if ((*(byte *)&param_1->ExceptionFlags & 0x66) == 0) {
		if (param_5[3] != 0) {
			if (((param_1->ExceptionCode == 0xe06d7363) && (0x19930520 < param_1->ExceptionInformation[0])
					) && (pcVar1 = *(code **)(param_1->ExceptionInformation[2] + 8), pcVar1 != NULL)) {
				uVar2 = (*pcVar1)(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8);
				return uVar2;
			}
			__std_FUN_00495420(param_1,param_2,param_3,param_4,(int)param_5,(char)param_8,param_6,param_7)
			;
		}
	}
	else {
		if ((param_5[1] != 0) && (param_6 == NULL)) {
			__std_FUN_004957a0((int)param_2,param_4,(int)param_5,-1);
			return 1;
		}
	}
	return 1;
}



void __cdecl
std::internal::__std_FUN_00495420
					(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3,undefined4 param_4,int param_5
					,char param_6,PVOID param_7,PVOID param_8)
{
	byte bVar1;
	int *piVar2;
	PEXCEPTION_RECORD pEVar3;
	uint uVar4;
	byte *pbVar5;
	int iVar6;
	byte **ppbVar7;
	int iVar8;
	byte *pbVar9;
	byte *pbVar10;
	bool bVar11;
	uint local_20;
	int *local_1c;
	int local_18;
	int local_14;
	int local_10;
	uint local_c;
	byte **local_8;
	int local_4;
	
	iVar8 = *(int *)((int)param_2 + 8);
	local_10 = iVar8;
	if ((iVar8 < -1) || (*(int *)(param_5 + 4) <= iVar8)) {
		__std_FUN_00495e30();
	}
	pEVar3 = DAT_0054a194;
	if (param_1->ExceptionCode == 0xe06d7363) {
		if (((param_1->NumberParameters == 3) && (param_1->ExceptionInformation[0] == 0x19930520)) &&
			 (param_1->ExceptionInformation[2] == 0)) {
			if (DAT_0054a194 == NULL) {
				return;
			}
			param_1 = DAT_0054a194;
			param_3 = DAT_0054a198;
			uVar4 = __std_FUN_00499950(DAT_0054a194,1);
			if (uVar4 == 0) {
				__std_FUN_00495e30();
			}
			if (pEVar3->ExceptionCode != 0xe06d7363) goto LAB_0049568b;
			if (((pEVar3->NumberParameters == 3) && (pEVar3->ExceptionInformation[0] == 0x19930520)) &&
				 (pEVar3->ExceptionInformation[2] == 0)) {
				__std_FUN_00495e30();
			}
		}
		if (((param_1->ExceptionCode == 0xe06d7363) && (param_1->NumberParameters == 3)) &&
			 (param_1->ExceptionInformation[0] == 0x19930520)) {
			local_1c = (int *)__std_FUN_0048f150(param_5,(int)param_7,iVar8,&local_20,&local_c);
			if (local_20 < local_c) {
				do {
					if ((*local_1c == iVar8 || *local_1c < iVar8) && (iVar8 <= local_1c[1])) {
						local_14 = local_1c[3];
						pbVar10 = (byte *)local_1c[4];
						if (0 < local_14) {
							piVar2 = *(int **)(param_1->ExceptionInformation[2] + 0xc);
							local_8 = (byte **)(piVar2 + 1);
							local_4 = *piVar2;
							do {
								local_18 = local_4;
								if (0 < local_4) {
									iVar8 = *(int *)(pbVar10 + 4);
									ppbVar7 = local_8;
									do {
										if ((iVar8 == 0) || (pbVar5 = (byte *)(iVar8 + 8), *(char *)(iVar8 + 8) == '\0')
											 ) {
LAB_004955e4:
											bVar11 = true;
										}
										else {
											iVar6 = *(int *)(*ppbVar7 + 4);
											if (iVar8 == iVar6) {
LAB_004955bf:
												if (((((**ppbVar7 & 2) == 0) || ((*pbVar10 & 8) != 0)) &&
														(((*(uint *)param_1->ExceptionInformation[2] & 1) == 0 ||
														 ((*pbVar10 & 1) != 0)))) &&
													 (((*(uint *)param_1->ExceptionInformation[2] & 2) == 0 ||
														((*pbVar10 & 2) != 0)))) goto LAB_004955e4;
												bVar11 = false;
											}
											else {
												pbVar9 = (byte *)(iVar6 + 8);
												do {
													bVar1 = *pbVar5;
													bVar11 = bVar1 < *pbVar9;
													if (bVar1 != *pbVar9) {
LAB_004955a2:
														iVar6 = (1 - (uint)bVar11) - (uint)(bVar11 != 0);
														goto LAB_004955a7;
													}
													if (bVar1 == 0) break;
													bVar1 = pbVar5[1];
													bVar11 = bVar1 < pbVar9[1];
													if (bVar1 != pbVar9[1]) goto LAB_004955a2;
													pbVar5 = pbVar5 + 2;
													pbVar9 = pbVar9 + 2;
												} while (bVar1 != 0);
												iVar6 = 0;
LAB_004955a7:
												if (iVar6 == 0) goto LAB_004955bf;
												bVar11 = false;
											}
										}
										if (bVar11) {
											__std_FUN_00495880(param_1,param_2,param_3,param_4,param_5,pbVar10,*ppbVar7,
																				 local_1c,(int)param_7,param_8);
											iVar8 = local_10;
											goto LAB_00495654;
										}
										ppbVar7 = ppbVar7 + 1;
										local_18 += -1;
									} while (0 < local_18);
								}
								local_14 += -1;
								pbVar10 = pbVar10 + 0x10;
								iVar8 = local_10;
							} while (0 < local_14);
						}
					}
LAB_00495654:
					local_20 += 1;
					local_1c = local_1c + 5;
				} while (local_20 < local_c);
			}
			if (param_6 == '\0') {
				return;
			}
			__std_FUN_00495ca0((int)param_1);
			return;
		}
	}
LAB_0049568b:
	if (param_6 != '\0') {
		__std_FUN_00495da0();
		return;
	}
	__std_FUN_004956d0(param_1,param_2,param_3,param_4,param_5,iVar8,param_7,param_8);
	return;
}



void __cdecl
std::internal::__std_FUN_004956d0
					(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3,undefined4 param_4,int param_5
					,int param_6,PVOID param_7,PVOID param_8)
{
	PVOID pvVar1;
	PVOID pvVar2;
	int iVar3;
	int *piVar4;
	int iVar5;
	
	pvVar2 = param_8;
	pvVar1 = param_7;
	if ((DAT_0054a19c != 0) &&
		 (iVar3 = __std_FUN_0048eff0((undefined4 *)param_1,param_2,param_3,param_4,param_5,param_7,
																 param_8), iVar3 != 0)) {
		return;
	}
	piVar4 = (int *)__std_FUN_0048f150(param_5,(int)pvVar1,param_6,(uint *)&param_8,(uint *)&param_7);
	if (param_8 < param_7) {
		do {
			if ((*piVar4 <= param_6) && (param_6 <= piVar4[1])) {
				iVar5 = piVar4[4] + piVar4[3] * 0x10;
				iVar3 = *(int *)(iVar5 + -0xc);
				if ((iVar3 == 0) || (*(char *)(iVar3 + 8) == '\0')) {
					__std_FUN_00495880(param_1,param_2,param_3,param_4,param_5,(byte *)(iVar5 + -0x10),NULL,
														 piVar4,(int)pvVar1,pvVar2);
				}
			}
			param_8 = (PVOID)((int)param_8 + 1);
			piVar4 = piVar4 + 5;
		} while (param_8 < param_7);
	}
	return;
}



void __cdecl
std::internal::__std_FUN_004957a0(int param_1,undefined4 param_2,int param_3,int param_4)
{
	int iVar1;
	int iVar2;
	undefined4 *in_FS_OFFSET;
	int local_20;
	undefined *local_1c;
	undefined4 local_14;
	undefined *puStack16;
	undefined *puStack12;
	undefined4 local_8;
	
	puStack12 = &DAT_0049fd50;
	puStack16 = &LAB_00496a98;
	local_14 = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_14;
	local_1c = &stack0xffffffd4;
	for (iVar2 = *(int *)(param_1 + 8); local_8 = 0xffffffff, iVar2 != param_4;
			iVar2 = *(int *)(*(int *)(param_3 + 8) + iVar2 * 8)) {
		local_20 = iVar2;
		if ((iVar2 < 0) || (*(int *)(param_3 + 4) <= iVar2)) {
			__std_FUN_00495e30();
		}
		local_8 = 0;
		iVar1 = *(int *)(*(int *)(param_3 + 8) + 4 + iVar2 * 8);
		if (iVar1 != 0) {
			__CallSettingFrame_12(iVar1,param_1,0x103);
		}
	}
	*(int *)(param_1 + 8) = iVar2;
	*in_FS_OFFSET = local_14;
	return;
}



undefined4 __cdecl std::internal::__std_FUN_00495860(int **param_1)
{
	if (**param_1 == -0x1f928c9d) {
		__std_FUN_00495da0();
	}
	return 0;
}



void __cdecl
std::internal::__std_FUN_00495880
					(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3,undefined4 param_4,int param_5
					,byte *param_6,byte *param_7,int *param_8,int param_9,PVOID param_10)
{
	undefined *UNRECOVERED_JUMPTABLE;
	
	if (param_7 != NULL) {
		__std_FUN_00495a90((int)param_1,(int)param_2,param_6,param_7);
	}
	if (param_10 == NULL) {
		param_10 = param_2;
	}
	__std_FUN_0048eec0(param_10,param_1);
	__std_FUN_004957a0((int)param_2,param_4,param_5,*param_8);
	*(int *)((int)param_2 + 8) = param_8[1] + 1;
	UNRECOVERED_JUMPTABLE =
			 (undefined *)
			 __std_FUN_00495910(param_1,(int)param_2,param_3,param_5,*(undefined4 *)(param_6 + 0xc),
													param_9,0x100);
	if (UNRECOVERED_JUMPTABLE != NULL) {
		__std_FUN_0048ee70(UNRECOVERED_JUMPTABLE);
	}
	return;
}



undefined4 __cdecl
std::internal::__std_FUN_00495910
					(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
					int param_6,int param_7)
{
	undefined4 uVar1;
	undefined4 *in_FS_OFFSET;
	undefined4 local_30;
	undefined4 local_2c;
	undefined4 local_28;
	undefined4 local_24;
	undefined4 local_20;
	undefined *local_1c;
	undefined4 local_14;
	undefined *puStack16;
	undefined *puStack12;
	undefined4 local_8;
	
	puStack12 = &DAT_0049fd60;
	puStack16 = &LAB_00496a98;
	local_14 = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_14;
	local_1c = &stack0xffffffc4;
	local_30 = param_5;
	local_28 = 0;
	local_2c = *(undefined4 *)(param_2 + -4);
	local_20 = DAT_0054a194;
	local_24 = DAT_0054a198;
	DAT_0054a194 = param_1;
	DAT_0054a198 = param_3;
	local_8 = 1;
	uVar1 = __std_FUN_0048ef60(param_2,param_4,param_5,param_6,param_7);
	local_8 = 0xffffffff;
	local_30 = uVar1;
	__std_FUN_004959fa();
	*in_FS_OFFSET = local_14;
	return uVar1;
}



void std::internal::__std_FUN_004959fa(void)
{
	int unaff_EBX;
	int unaff_EBP;
	int unaff_ESI;
	int *unaff_EDI;
	
	*(undefined4 *)(unaff_ESI + -4) = *(undefined4 *)(unaff_EBP + -0x28);
	DAT_0054a194 = *(undefined4 *)(unaff_EBP + -0x1c);
	DAT_0054a198 = *(undefined4 *)(unaff_EBP + -0x20);
	if ((((*unaff_EDI == -0x1f928c9d) && (unaff_EDI[4] == 3)) && (unaff_EDI[5] == 0x19930520)) &&
		 ((*(int *)(unaff_EBP + -0x24) == 0 && (unaff_EBX != 0)))) {
		__abnormal_termination();
		__std_FUN_00495ca0((int)unaff_EDI);
	}
	return;
}



undefined4 __cdecl std::internal::__std_FUN_00495a60(int **param_1)
{
	int *piVar1;
	
	piVar1 = *param_1;
	if ((((*piVar1 == -0x1f928c9d) && (piVar1[4] == 3)) && (piVar1[5] == 0x19930520)) &&
		 (piVar1[7] == 0)) {
		return 1;
	}
	return 0;
}



void __cdecl std::internal::__std_FUN_00495a90(int param_1,int param_2,byte *param_3,byte *param_4)
{
	int *piVar1;
	uint uVar2;
	int iVar3;
	undefined4 *puVar4;
	undefined4 *in_FS_OFFSET;
	undefined *local_1c;
	undefined4 local_14;
	undefined *puStack16;
	undefined *puStack12;
	undefined4 local_8;
	
	puStack12 = &DAT_0049fd78;
	puStack16 = &LAB_00496a98;
	local_14 = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_14;
	local_1c = &stack0xffffffd4;
	if (((*(int *)(param_3 + 4) != 0) && (*(char *)(*(int *)(param_3 + 4) + 8) != '\0')) &&
		 (*(int *)(param_3 + 8) != 0)) {
		piVar1 = (int *)(param_2 + 0xc + *(int *)(param_3 + 8));
		local_8 = 0;
		if ((*param_3 & 8) == 0) {
			if ((*param_4 & 1) == 0) {
				if (*(int *)(param_4 + 0x18) == 0) {
					local_1c = &stack0xffffffd4;
					uVar2 = __std_FUN_00499950(*(void **)(param_1 + 0x18),1);
					if ((uVar2 != 0) && (uVar2 = __std_FUN_00499970(piVar1,1), uVar2 != 0)) {
						uVar2 = *(uint *)(param_4 + 0x14);
						puVar4 = (undefined4 *)__std_FUN_00495d20(*(int *)(param_1 + 0x18),(int *)(param_4 + 8))
						;
						__std_FUN_004982c0(piVar1,puVar4,uVar2);
						goto LAB_00495c80;
					}
				}
				else {
					uVar2 = __std_FUN_00499950(*(void **)(param_1 + 0x18),1);
					if (((uVar2 != 0) && (uVar2 = __std_FUN_00499970(piVar1,1), uVar2 != 0)) &&
						 (uVar2 = __std_FUN_00499990(*(FARPROC *)(param_4 + 0x18)), uVar2 != 0)) {
						if ((*param_4 & 4) == 0) {
							__std_FUN_00495d20(*(int *)(param_1 + 0x18),(int *)(param_4 + 8));
							__std_FUN_0048eeb0(piVar1,*(undefined **)(param_4 + 0x18));
						}
						else {
							__std_FUN_00495d20(*(int *)(param_1 + 0x18),(int *)(param_4 + 8));
							__std_FUN_0048eeb0(piVar1,*(undefined **)(param_4 + 0x18));
						}
						goto LAB_00495c80;
					}
				}
			}
			else {
				local_1c = &stack0xffffffd4;
				uVar2 = __std_FUN_00499950(*(void **)(param_1 + 0x18),1);
				if ((uVar2 != 0) && (uVar2 = __std_FUN_00499970(piVar1,1), uVar2 != 0)) {
					__std_FUN_004982c0(piVar1,*(undefined4 **)(param_1 + 0x18),*(uint *)(param_4 + 0x14));
					if ((*(int *)(param_4 + 0x14) == 4) && (*piVar1 != 0)) {
						iVar3 = __std_FUN_00495d20(*piVar1,(int *)(param_4 + 8));
						*piVar1 = iVar3;
					}
					goto LAB_00495c80;
				}
			}
		}
		else {
			local_1c = &stack0xffffffd4;
			uVar2 = __std_FUN_00499950(*(void **)(param_1 + 0x18),1);
			if ((uVar2 != 0) && (uVar2 = __std_FUN_00499970(piVar1,1), uVar2 != 0)) {
				iVar3 = *(int *)(param_1 + 0x18);
				*piVar1 = iVar3;
				iVar3 = __std_FUN_00495d20(iVar3,(int *)(param_4 + 8));
				*piVar1 = iVar3;
				goto LAB_00495c80;
			}
		}
		__std_FUN_00495e30();
	}
LAB_00495c80:
	*in_FS_OFFSET = local_14;
	return;
}



void __cdecl std::internal::__std_FUN_00495ca0(int param_1)
{
	undefined *UNRECOVERED_JUMPTABLE;
	undefined4 *in_FS_OFFSET;
	undefined *local_1c;
	undefined4 local_14;
	undefined *puStack16;
	undefined *puStack12;
	undefined4 local_8;
	
	puStack12 = &DAT_0049fd88;
	puStack16 = &LAB_00496a98;
	local_14 = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_14;
	local_1c = &stack0xffffffd8;
	if ((param_1 != 0) &&
		 (UNRECOVERED_JUMPTABLE = *(undefined **)(*(int *)(param_1 + 0x1c) + 4),
		 UNRECOVERED_JUMPTABLE != NULL)) {
		local_8 = 0;
		__std_FUN_0048eeb0(*(undefined4 *)(param_1 + 0x18),UNRECOVERED_JUMPTABLE);
	}
	*in_FS_OFFSET = local_14;
	return;
}



int __cdecl std::internal::__std_FUN_00495d20(int param_1,int *param_2)
{
	int iVar1;
	int iVar2;
	
	iVar2 = param_1 + *param_2;
	iVar1 = param_2[1];
	if (-1 < iVar1) {
		iVar2 += *(int *)(*(int *)(param_1 + iVar1) + param_2[2]) + iVar1;
	}
	return iVar2;
}



// WARNING: Restarted to delay deadcode elimination for space: stack
// Library Function - Single Match
// Name: __CallSettingFrame@12
// Libraries: Visual Studio 2003 Debug, Visual Studio 2003 Release

void __CallSettingFrame_12(undefined4 param_1,undefined4 param_2,int param_3)
{
	code *pcVar1;
	
	pcVar1 = (code *)__NLG_Notify1(param_3);
	(*pcVar1)();
	if (param_3 == 0x100) {
		param_3 = 2;
	}
	__NLG_Notify1(param_3);
	return;
}



void std::internal::__std_FUN_00495da0(void)
{
	undefined *puVar1;
	undefined4 *in_FS_OFFSET;
	undefined *local_1c;
	undefined4 local_14;
	undefined *puStack16;
	undefined *puStack12;
	undefined4 local_8;
	
	puStack12 = &DAT_0049fd98;
	puStack16 = &LAB_00496a98;
	local_14 = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_14;
	local_1c = &stack0xffffffd8;
	puVar1 = &stack0xffffffd8;
	if (DAT_0054a1a0 != NULL) {
		local_8 = 1;
		(*DAT_0054a1a0)();
		puVar1 = local_1c;
	}
	local_1c = puVar1;
	local_8 = 0xffffffff;
	__std_calls_abort_FUN_00495e0e();
	*in_FS_OFFSET = local_14;
	return;
}



void std::internal::__std_calls_abort_FUN_00495e0e(void)
{
	abort();
	return;
}



void std::internal::__std_FUN_00495e30(void)
{
	undefined *puVar1;
	undefined4 *in_FS_OFFSET;
	undefined *local_1c;
	undefined4 local_14;
	undefined *puStack16;
	undefined *puStack12;
	undefined4 local_8;
	
	puStack12 = &DAT_0049fdb0;
	puStack16 = &LAB_00496a98;
	local_14 = *in_FS_OFFSET;
	*in_FS_OFFSET = &local_14;
	local_1c = &stack0xffffffd8;
	puVar1 = &stack0xffffffd8;
	if (PTR___std_FUN_004b32a4 != NULL) {
		local_8 = 1;
		(*(code *)PTR___std_FUN_004b32a4)();
		puVar1 = local_1c;
	}
	local_1c = puVar1;
	local_8 = 0xffffffff;
	__std_FUN_00495e9e();
	*in_FS_OFFSET = local_14;
	return;
}



void std::internal::__std_FUN_00495e9e(void)
{
	__std_FUN_00495da0();
	return;
}



BOOL __cdecl std::internal::__entry_cmdline__00496050(int c)
{
	BOOL BVar1;
	
	BVar1 = __entry_cmdline_2__00496070(c,0,4);
	return BVar1;
}



BOOL __cdecl std::internal::__entry_cmdline_2__00496070(int c,uint param_2,byte param_3)
{
	uint uVar1;
	
	if ((*(byte *)((int)&DAT_0054a2b8 + (c & 0xffU) + 1) & param_3) == 0) {
		if (param_2 == 0) {
			uVar1 = 0;
		}
		else {
			uVar1 = std::globals::_wctype[c & 0xffU] & param_2;
		}
		if (uVar1 == 0) {
			return 0;
		}
	}
	return 1;
}



void std::internal::__entry__004960b0(void)
{
	char cVar1;
	char cVar2;
	void **ppvVar3;
	void *pvVar4;
	uint uVar5;
	uint uVar6;
	uint uVar7;
	char *pcVar8;
	int iVar9;
	undefined4 *puVar10;
	char *pcVar11;
	char *pcVar12;
	undefined4 *puVar13;
	void **local_4;
	
	iVar9 = 0;
	cVar2 = *std::globals::__initenv;
	pcVar8 = std::globals::__initenv;
	while (cVar2 != '\0') {
		if (cVar2 != '=') {
			iVar9 += 1;
		}
		uVar5 = 0xffffffff;
		pcVar11 = pcVar8;
		do {
			if (uVar5 == 0) break;
			uVar5 -= 1;
			cVar2 = *pcVar11;
			pcVar11 = pcVar11 + 1;
		} while (cVar2 != '\0');
		pcVar11 = pcVar8 + ~uVar5;
		pcVar8 = pcVar8 + ~uVar5;
		cVar2 = *pcVar11;
	}
	ppvVar3 = (void **)malloc(iVar9 * 4 + 4);
	DAT_0054a0f8 = ppvVar3;
	if (ppvVar3 == NULL) {
		__amsg_exit(9);
	}
	cVar2 = *std::globals::__initenv;
	local_4 = ppvVar3;
	pcVar8 = std::globals::__initenv;
	do {
		if (cVar2 == '\0') {
			free(std::globals::__initenv);
			std::globals::__initenv = NULL;
			*ppvVar3 = NULL;
			return;
		}
		uVar5 = 0xffffffff;
		pcVar11 = pcVar8;
		do {
			if (uVar5 == 0) break;
			uVar5 -= 1;
			cVar1 = *pcVar11;
			pcVar11 = pcVar11 + 1;
		} while (cVar1 != '\0');
		uVar5 = ~uVar5;
		if (cVar2 != '=') {
			pvVar4 = malloc(uVar5);
			*ppvVar3 = pvVar4;
			if (pvVar4 == NULL) {
				__amsg_exit(9);
			}
			uVar6 = 0xffffffff;
			pcVar11 = pcVar8;
			do {
				pcVar12 = pcVar11;
				if (uVar6 == 0) break;
				uVar6 -= 1;
				pcVar12 = pcVar11 + 1;
				cVar2 = *pcVar11;
				pcVar11 = pcVar12;
			} while (cVar2 != '\0');
			uVar6 = ~uVar6;
			puVar10 = (undefined4 *)(pcVar12 + -uVar6);
			puVar13 = (undefined4 *)*local_4;
			for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
				*puVar13 = *puVar10;
				puVar10 = puVar10 + 1;
				puVar13 = puVar13 + 1;
			}
			ppvVar3 = local_4 + 1;
			for (uVar6 &= 3; local_4 = ppvVar3, uVar6 != 0; uVar6 -= 1) {
				*(undefined *)puVar13 = *(undefined *)puVar10;
				puVar10 = (undefined4 *)((int)puVar10 + 1);
				puVar13 = (undefined4 *)((int)puVar13 + 1);
			}
		}
		cVar2 = pcVar8[uVar5];
		pcVar8 = pcVar8 + uVar5;
	} while( true );
}



void std::internal::__entry__004961a0(void)
{
	byte **ppbVar1;
	LPSTR *ppCVar2;
	int local_8;
	int local_4;
	
	GetModuleFileNameA(NULL,(LPSTR)&lpFilename_0054a1a8,0x104);
	LPSTR_0054a108 = &lpFilename_0054a1a8;
	ppCVar2 = std::globals::_acmdln;
	if (*(char *)std::globals::_acmdln == '\0') {
		ppCVar2 = &lpFilename_0054a1a8;
	}
	__entry__00496240((byte *)ppCVar2,NULL,NULL,&local_8,&local_4);
	ppbVar1 = (byte **)malloc(local_4 + local_8 * 4);
	if (ppbVar1 == NULL) {
		__amsg_exit(8);
	}
	__entry__00496240((byte *)ppCVar2,ppbVar1,(byte *)(ppbVar1 + local_8),&local_8,&local_4);
	DAT_0054a0ec = local_8 + -1;
	DAT_0054a0f0 = ppbVar1;
	return;
}



void __cdecl
std::internal::__entry__00496240
					(byte *param_1,byte **param_2,byte *param_3,int *param_4,int *param_5)
{
	byte *pbVar1;
	byte bVar2;
	bool bVar3;
	bool bVar4;
	bool bVar5;
	int *piVar6;
	byte *pbVar7;
	uint uVar8;
	
	piVar6 = param_5;
	*param_5 = 0;
	*param_4 = 1;
	if (param_2 != NULL) {
		*param_2 = param_3;
		param_2 = param_2 + 1;
	}
	if (*param_1 == 0x22) {
		pbVar7 = param_1 + 1;
		bVar2 = param_1[1];
		while ((bVar2 != 0x22 && (bVar2 != 0))) {
			if (((*(byte *)((int)&DAT_0054a2b8 + bVar2 + 1) & 4) != 0) &&
				 (*param_5 = *param_5 + 1, param_3 != NULL)) {
				*param_3 = *pbVar7;
				param_3 = param_3 + 1;
				pbVar7 = pbVar7 + 1;
			}
			*param_5 = *param_5 + 1;
			if (param_3 != NULL) {
				*param_3 = *pbVar7;
				param_3 = param_3 + 1;
			}
			pbVar1 = pbVar7 + 1;
			pbVar7 = pbVar7 + 1;
			bVar2 = *pbVar1;
		}
		*param_5 = *param_5 + 1;
		if (param_3 != NULL) {
			*param_3 = 0;
			param_3 = param_3 + 1;
		}
		if (*pbVar7 == 0x22) {
			pbVar7 = pbVar7 + 1;
		}
	}
	else {
		do {
			*piVar6 = *piVar6 + 1;
			if (param_3 != NULL) {
				*param_3 = *param_1;
				param_3 = param_3 + 1;
			}
			bVar2 = *param_1;
			pbVar7 = param_1 + 1;
			param_5 = (int *)(uint)bVar2;
			if ((*(byte *)((int)param_5 + 0x54a2b9) & 4) != 0) {
				*piVar6 = *piVar6 + 1;
				if (param_3 != NULL) {
					*param_3 = *pbVar7;
					param_3 = param_3 + 1;
				}
				pbVar7 = param_1 + 2;
			}
			if (bVar2 == 0x20) break;
			if (bVar2 == 0) goto LAB_00496319;
			param_1 = pbVar7;
		} while (bVar2 != 9);
		if (bVar2 == 0) {
LAB_00496319:
			pbVar7 = pbVar7 + -1;
		}
		else {
			if (param_3 != NULL) {
				param_3[-1] = 0;
			}
		}
	}
	bVar4 = false;
	bVar5 = false;
	while (*pbVar7 != 0) {
		for (; (*pbVar7 == 0x20 || (*pbVar7 == 9)); pbVar7 = pbVar7 + 1) {
		}
		if (*pbVar7 == 0) break;
		if (param_2 != NULL) {
			*param_2 = param_3;
			param_2 = param_2 + 1;
		}
		*param_4 = *param_4 + 1;
		while( true ) {
			uVar8 = 0;
			bVar3 = true;
			bVar2 = *pbVar7;
			while (bVar2 == 0x5c) {
				pbVar1 = pbVar7 + 1;
				pbVar7 = pbVar7 + 1;
				uVar8 += 1;
				bVar2 = *pbVar1;
			}
			if (*pbVar7 == 0x22) {
				if ((uVar8 & 1) == 0) {
					if ((bVar4) && (pbVar7[1] == 0x22)) {
						pbVar7 = pbVar7 + 1;
					}
					else {
						bVar3 = false;
					}
					bVar4 = !bVar5;
					bVar5 = bVar4;
				}
				uVar8 >>= 1;
			}
			for (; uVar8 != 0; uVar8 -= 1) {
				if (param_3 != NULL) {
					*param_3 = 0x5c;
					param_3 = param_3 + 1;
				}
				*piVar6 = *piVar6 + 1;
			}
			bVar2 = *pbVar7;
			if ((bVar2 == 0) || ((!bVar4 && ((bVar2 == 0x20 || (bVar2 == 9)))))) break;
			if (bVar3) {
				if (param_3 == NULL) {
					if ((*(byte *)((int)&DAT_0054a2b8 + bVar2 + 1) & 4) != 0) {
						pbVar7 = pbVar7 + 1;
						*piVar6 = *piVar6 + 1;
					}
					*piVar6 = *piVar6 + 1;
					goto LAB_00496415;
				}
				if ((*(byte *)((int)&DAT_0054a2b8 + bVar2 + 1) & 4) != 0) {
					*param_3 = bVar2;
					param_3 = param_3 + 1;
					pbVar7 = pbVar7 + 1;
					*piVar6 = *piVar6 + 1;
				}
				*param_3 = *pbVar7;
				param_3 = param_3 + 1;
				*piVar6 = *piVar6 + 1;
				pbVar7 = pbVar7 + 1;
			}
			else {
LAB_00496415:
				pbVar7 = pbVar7 + 1;
			}
		}
		if (param_3 != NULL) {
			*param_3 = 0;
			param_3 = param_3 + 1;
		}
		*piVar6 = *piVar6 + 1;
	}
	if (param_2 != NULL) {
		*param_2 = NULL;
	}
	*param_4 = *param_4 + 1;
	return;
}



LPSTR std::internal::__GetEnvironmentStringsA(void)
{
	char cVar1;
	WCHAR WVar2;
	WCHAR *pWVar3;
	int iVar5;
	uint uVar6;
	undefined4 *puVar7;
	uint uVar8;
	undefined4 *puVar9;
	LPWCH lpWideCharStr;
	undefined4 *puVar10;
	undefined4 *puVar11;
	WCHAR *pWVar4;
	
	lpWideCharStr = NULL;
	puVar9 = NULL;
	if (INT_0054a2b0 == 0) {
		lpWideCharStr = GetEnvironmentStringsW();
		if (lpWideCharStr == NULL) {
			puVar9 = (undefined4 *)GetEnvironmentStrings();
			if (puVar9 == NULL) {
				return (LPSTR)NULL;
			}
			INT_0054a2b0 = 2;
		}
		else {
			INT_0054a2b0 = 1;
		}
	}
	if (INT_0054a2b0 == 1) {
		if ((lpWideCharStr != NULL) || (lpWideCharStr = GetEnvironmentStringsW(), lpWideCharStr != NULL)
			 ) {
			WVar2 = *lpWideCharStr;
			pWVar3 = lpWideCharStr;
			while (WVar2 != L'\0') {
				do {
					pWVar4 = pWVar3;
					pWVar3 = pWVar4 + 1;
				} while (*pWVar3 != L'\0');
				pWVar3 = pWVar4 + 2;
				WVar2 = *pWVar3;
			}
			iVar5 = ((int)((int)pWVar3 - (int)lpWideCharStr) >> 1) + 1;
			uVar6 = WideCharToMultiByte(0,0,lpWideCharStr,iVar5,NULL,0,NULL,NULL);
			if ((uVar6 != 0) && (puVar9 = (undefined4 *)malloc(uVar6), puVar9 != NULL)) {
				iVar5 = WideCharToMultiByte(0,0,lpWideCharStr,iVar5,(LPSTR)puVar9,uVar6,NULL,NULL);
				if (iVar5 == 0) {
					free(puVar9);
					puVar9 = NULL;
				}
				FreeEnvironmentStringsW(lpWideCharStr);
				return (LPSTR)puVar9;
			}
			FreeEnvironmentStringsW(lpWideCharStr);
			return (LPSTR)NULL;
		}
	}
	else {
		if ((INT_0054a2b0 == 2) &&
			 ((puVar9 != NULL || (puVar9 = (undefined4 *)GetEnvironmentStrings(), puVar9 != NULL)))) {
			cVar1 = *(char *)puVar9;
			puVar7 = puVar9;
			while (cVar1 != '\0') {
				do {
					puVar10 = puVar7;
					puVar7 = (undefined4 *)((int)puVar10 + 1);
				} while (*(char *)((int)puVar10 + 1) != '\0');
				puVar7 = (undefined4 *)((int)puVar10 + 2);
				cVar1 = *(char *)((int)puVar10 + 2);
			}
			uVar6 = (int)puVar7 + (1 - (int)puVar9);
			puVar7 = (undefined4 *)malloc(uVar6);
			if (puVar7 != NULL) {
				puVar10 = puVar9;
				puVar11 = puVar7;
				for (uVar8 = uVar6 >> 2; uVar8 != 0; uVar8 -= 1) {
					*puVar11 = *puVar10;
					puVar10 = puVar10 + 1;
					puVar11 = puVar11 + 1;
				}
				for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
					*(undefined *)puVar11 = *(undefined *)puVar10;
					puVar10 = (undefined4 *)((int)puVar10 + 1);
					puVar11 = (undefined4 *)((int)puVar11 + 1);
				}
				FreeEnvironmentStringsA((LPCH)puVar9);
				return (LPSTR)puVar7;
			}
			FreeEnvironmentStringsA((LPCH)puVar9);
			return (LPSTR)NULL;
		}
	}
	return (LPSTR)NULL;
}



int __cdecl std::internal::__entry__004965b0(int param_1)
{
	byte *pbVar1;
	byte bVar2;
	byte bVar3;
	UINT CodePage;
	UINT *pUVar4;
	BOOL BVar5;
	uint uVar6;
	uint uVar7;
	int iVar8;
	int iVar9;
	byte *pbVar10;
	byte *pbVar11;
	undefined4 *puVar12;
	_cpinfo local_14;
	
	CodePage = __entry_codepage__004967a0(param_1);
	if (CodePage == DAT_0054a3bc) {
		return 0;
	}
	if (CodePage == 0) {
		__entry__00496850();
		return 0;
	}
	iVar9 = 0;
	pUVar4 = &DAT_004b3338;
	do {
		if (*pUVar4 == CodePage) {
			puVar12 = &DAT_0054a2b8;
			for (iVar8 = 0x40; iVar8 != 0; iVar8 += -1) {
				*puVar12 = 0;
				puVar12 = puVar12 + 1;
			}
			*(undefined *)puVar12 = 0;
			uVar6 = 0;
			pbVar10 = &DAT_004b3348 + iVar9 * 0x30;
			do {
				bVar2 = *pbVar10;
				for (pbVar11 = pbVar10; (bVar2 != 0 && (bVar2 = pbVar11[1], bVar2 != 0));
						pbVar11 = pbVar11 + 2) {
					uVar7 = (uint)*pbVar11;
					if (uVar7 <= bVar2) {
						bVar3 = (&DAT_004b3330)[uVar6];
						do {
							pbVar1 = (byte *)((int)&DAT_0054a2b8 + uVar7 + 1);
							*pbVar1 = *pbVar1 | bVar3;
							uVar7 += 1;
						} while (uVar7 <= bVar2);
					}
					bVar2 = pbVar11[2];
				}
				uVar6 += 1;
				pbVar10 = pbVar10 + 8;
			} while (uVar6 < 4);
			DAT_0054a3bc = CodePage;
			DAT_0054a3c0 = __entry__004967f0(CodePage);
			DAT_0054a3c8 = (&DAT_004b333c)[iVar9 * 0xc];
			DAT_0054a3cc = (&DAT_004b3340)[iVar9 * 0xc];
			DAT_0054a3d0 = (&DAT_004b3344)[iVar9 * 0xc];
			return 0;
		}
		pUVar4 = pUVar4 + 0xc;
		iVar9 += 1;
	} while (pUVar4 < &DAT_004b3428);
	BVar5 = GetCPInfo(CodePage,(LPCPINFO)&local_14);
	if (BVar5 != 1) {
		if (DAT_0054a3d4 == 0) {
			return -1;
		}
		__entry__00496850();
		return 0;
	}
	puVar12 = &DAT_0054a2b8;
	for (iVar9 = 0x40; iVar9 != 0; iVar9 += -1) {
		*puVar12 = 0;
		puVar12 = puVar12 + 1;
	}
	*(undefined *)puVar12 = 0;
	if (local_14.MaxCharSize < 2) {
		DAT_0054a3bc = 0;
		DAT_0054a3c0 = 0;
	}
	else {
		if (local_14.LeadByte[0] != '\0') {
			pbVar10 = local_14.LeadByte + 1;
			do {
				bVar2 = *pbVar10;
				if (bVar2 == 0) break;
				for (uVar6 = (uint)pbVar10[-1]; uVar6 <= bVar2; uVar6 += 1) {
					*(byte *)((int)&DAT_0054a2b8 + uVar6 + 1) = *(byte *)((int)&DAT_0054a2b8 + uVar6 + 1) | 4;
				}
				pbVar11 = pbVar10 + 1;
				pbVar10 = pbVar10 + 2;
			} while (*pbVar11 != 0);
		}
		uVar6 = 1;
		do {
			*(byte *)((int)&DAT_0054a2b8 + uVar6 + 1) = *(byte *)((int)&DAT_0054a2b8 + uVar6 + 1) | 8;
			uVar6 += 1;
		} while (uVar6 < 0xff);
		DAT_0054a3bc = CodePage;
		DAT_0054a3c0 = __entry__004967f0(CodePage);
	}
	DAT_0054a3c8 = 0;
	DAT_0054a3cc = 0;
	DAT_0054a3d0 = 0;
	return 0;
}



UINT __cdecl std::internal::__entry_codepage__004967a0(int param_1)
{
	UINT UVar1;
	bool bVar2;
	
	if (param_1 == -2) {
		DAT_0054a3d4 = 1;
										// WARNING: Could not recover jumptable at 0x004967bd. Too many branches
										// WARNING: Treating indirect jump as call
		UVar1 = GetOEMCP();
		return UVar1;
	}
	if (param_1 == -3) {
		DAT_0054a3d4 = 1;
										// WARNING: Could not recover jumptable at 0x004967d2. Too many branches
										// WARNING: Treating indirect jump as call
		UVar1 = GetACP();
		return UVar1;
	}
	bVar2 = param_1 == -4;
	if (bVar2) {
		param_1 = DAT_0054a190;
	}
	DAT_0054a3d4 = (uint)bVar2;
	return param_1;
}



undefined4 __cdecl std::internal::__entry__004967f0(undefined4 param_1)
{
	if (true) {
		switch(param_1) {
		case 0x3a4:
			return 0x411;
		case 0x3a8:
			return 0x804;
		case 0x3b5:
			return 0x412;
		case 0x3b6:
			return 0x404;
		}
	}
	return 0;
}



void std::internal::__entry__00496850(void)
{
	int iVar1;
	undefined4 *puVar2;
	
	puVar2 = &DAT_0054a2b8;
	for (iVar1 = 0x40; iVar1 != 0; iVar1 += -1) {
		*puVar2 = 0;
		puVar2 = puVar2 + 1;
	}
	*(undefined *)puVar2 = 0;
	DAT_0054a3bc = 0;
	DAT_0054a3c0 = 0;
	DAT_0054a3c8 = 0;
	DAT_0054a3cc = 0;
	DAT_0054a3d0 = 0;
	return;
}



int std::internal::__entry__00496880(void)
{
	int iVar1;
	
	iVar1 = __entry__004965b0(-3);
	return iVar1;
}



void std::internal::__entry__00496890(void)
{
	byte bVar1;
	undefined4 *puVar2;
	DWORD DVar3;
	HANDLE hFile;
	int iVar4;
	HANDLE *ppvVar5;
	int *piVar6;
	uint uVar7;
	uint local_48;
	_STARTUPINFOA local_44;
	
	puVar2 = (undefined4 *)malloc(0x100);
	if (puVar2 == NULL) {
		__amsg_exit(0x1b);
	}
	globals::__UINT_0076eec0 = 0x20;
	DAT_0076edc0 = puVar2;
	if (puVar2 < puVar2 + 0x40) {
		do {
			*(undefined *)(puVar2 + 1) = 0;
			*puVar2 = 0xffffffff;
			*(undefined *)((int)puVar2 + 5) = 10;
			puVar2 = puVar2 + 2;
		} while (puVar2 < DAT_0076edc0 + 0x40);
	}
	GetStartupInfoA((LPSTARTUPINFOA)&local_44);
	if ((local_44.cbReserved2 != 0) && ((uint *)local_44.lpReserved2 != NULL)) {
		local_48 = *(uint *)local_44.lpReserved2;
		local_44.lpReserved2 = (LPBYTE)((int)local_44.lpReserved2 + 4);
		ppvVar5 = (HANDLE *)((int)local_44.lpReserved2 + local_48);
		if (0x7ff < (int)local_48) {
			local_48 = 0x800;
		}
		if ((int)globals::__UINT_0076eec0 < (int)local_48) {
			piVar6 = &DAT_0076edc4;
			do {
				puVar2 = (undefined4 *)malloc(0x100);
				if (puVar2 == NULL) {
					local_48 = globals::__UINT_0076eec0;
					break;
				}
				*piVar6 = (int)puVar2;
				globals::__UINT_0076eec0 += 0x20;
				if (puVar2 < puVar2 + 0x40) {
					do {
						*(undefined *)(puVar2 + 1) = 0;
						*puVar2 = 0xffffffff;
						*(undefined *)((int)puVar2 + 5) = 10;
						puVar2 = puVar2 + 2;
					} while (puVar2 < (undefined4 *)(*piVar6 + 0x100));
				}
				piVar6 = piVar6 + 1;
			} while ((int)globals::__UINT_0076eec0 < (int)local_48);
		}
		uVar7 = 0;
		if (0 < (int)local_48) {
			do {
				if (((*ppvVar5 != (HANDLE)0xffffffff) && ((*local_44.lpReserved2 & 1) != 0)) &&
					 (((*local_44.lpReserved2 & 8) != 0 || (DVar3 = GetFileType(*ppvVar5), DVar3 != 0)))) {
					iVar4 = (int)(&DAT_0076edc0)[(int)uVar7 >> 5];
					*(HANDLE *)(iVar4 + (uVar7 & 0x1f) * 8) = *ppvVar5;
					*(BYTE *)(iVar4 + (uVar7 & 0x1f) * 8 + 4) = *local_44.lpReserved2;
				}
				uVar7 += 1;
				local_44.lpReserved2 = (LPBYTE)((int)local_44.lpReserved2 + 1);
				ppvVar5 = ppvVar5 + 1;
			} while ((int)uVar7 < (int)local_48);
		}
	}
	iVar4 = 0;
	do {
		ppvVar5 = (HANDLE *)(DAT_0076edc0 + iVar4 * 2);
		if (DAT_0076edc0[iVar4 * 2] == -1) {
			*(undefined *)(ppvVar5 + 1) = 0x81;
			if (iVar4 == 0) {
				DVar3 = 0xfffffff6;
			}
			else {
				DVar3 = 0xfffffff5 - (iVar4 != 1);
			}
			hFile = GetStdHandle(DVar3);
			if ((hFile == (HANDLE)0xffffffff) || (DVar3 = GetFileType(hFile), DVar3 == 0)) {
				bVar1 = *(byte *)(ppvVar5 + 1) | 0x40;
				goto LAB_00496a6b;
			}
			*ppvVar5 = hFile;
			if ((DVar3 & 0xff) == 2) {
				bVar1 = *(byte *)(ppvVar5 + 1) | 0x40;
				goto LAB_00496a6b;
			}
			if ((DVar3 & 0xff) == 3) {
				bVar1 = *(byte *)(ppvVar5 + 1) | 8;
				goto LAB_00496a6b;
			}
		}
		else {
			bVar1 = *(byte *)(ppvVar5 + 1) | 0x80;
LAB_00496a6b:
			*(byte *)(ppvVar5 + 1) = bVar1;
		}
		iVar4 += 1;
		if (2 < iVar4) {
			SetHandleCount(globals::__UINT_0076eec0);
			return;
		}
	} while( true );
}



void std::internal::__std_FUN_00496b55(int param_1)
{
	__local_unwind2(*(int *)(param_1 + 0x18),*(int *)(param_1 + 0x1c));
	return;
}



void std::internal::__std_FUN_00496b70(void)
{
	if ((DAT_0054a124 == 1) || ((DAT_0054a124 == 0 && (DAT_004b0d64 == 1)))) {
		__std_FUN_00496bb0(0xfc);
		if (DAT_0054a3d8 != NULL) {
			(*DAT_0054a3d8)();
		}
		__std_FUN_00496bb0(0xff);
	}
	return;
}



void __cdecl std::internal::__std_FUN_00496bb0(int param_1)
{
	char cVar1;
	uint (*pauVar2) [2];
	DWORD DVar3;
	HANDLE hFile;
	int iVar4;
	uint uVar5;
	uint uVar6;
	undefined4 *puVar7;
	int iVar8;
	undefined4 *puVar9;
	undefined4 *puVar10;
	char *pcVar11;
	char *pcVar12;
	DWORD local_1a8;
	undefined4 local_1a4 [25];
	undefined4 auStack320 [15];
	undefined4 local_104;
	
	pauVar2 = (uint (*) [2])&DAT_004b3430;
	iVar8 = 0;
	do {
		if (param_1 == (*pauVar2)[0]) break;
		pauVar2 = pauVar2[1];
		iVar8 += 1;
	} while (pauVar2 < globals::__errorArray_004b34c0);
	if (param_1 == (&DAT_004b3430)[iVar8 * 2]) {
		if ((DAT_0054a124 == 1) || ((DAT_0054a124 == 0 && (DAT_004b0d64 == 1)))) {
			if ((DAT_0076edc0 == 0) ||
				 (hFile = *(HANDLE *)(DAT_0076edc0 + 0x10), hFile == (HANDLE)0xffffffff)) {
				hFile = GetStdHandle(0xfffffff4);
			}
			pcVar11 = *(char **)(iVar8 * 8 + 0x4b3434);
			uVar5 = 0xffffffff;
			pcVar12 = pcVar11;
			do {
				if (uVar5 == 0) break;
				uVar5 -= 1;
				cVar1 = *pcVar12;
				pcVar12 = pcVar12 + 1;
			} while (cVar1 != '\0');
			WriteFile(hFile,pcVar11,~uVar5 - 1,&local_1a8,NULL);
		}
		else {
			if (param_1 != 0xfc) {
				DVar3 = GetModuleFileNameA(NULL,(LPSTR)&local_104,0x104);
				if (DVar3 == 0) {
					puVar7 = (undefined4 *)"<program name unknown>";
					puVar9 = &local_104;
					for (iVar4 = 5; iVar4 != 0; iVar4 += -1) {
						*puVar9 = *puVar7;
						puVar7 = puVar7 + 1;
						puVar9 = puVar9 + 1;
					}
					*(undefined2 *)puVar9 = *(undefined2 *)puVar7;
					*(undefined *)((int)puVar9 + 2) = *(undefined *)((int)puVar7 + 2);
				}
				uVar5 = 0xffffffff;
				puVar7 = &local_104;
				puVar9 = &local_104;
				do {
					if (uVar5 == 0) break;
					uVar5 -= 1;
					cVar1 = *(char *)puVar9;
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				} while (cVar1 != '\0');
				if (0x3c < ~uVar5) {
					uVar5 = 0xffffffff;
					puVar7 = &local_104;
					do {
						if (uVar5 == 0) break;
						uVar5 -= 1;
						cVar1 = *(char *)puVar7;
						puVar7 = (undefined4 *)((int)puVar7 + 1);
					} while (cVar1 != '\0');
					puVar7 = (undefined4 *)((int)auStack320 + ~uVar5);
					_strncpy((char *)puVar7,"...",3);
				}
				puVar9 = (undefined4 *)"Runtime Error!\n\nProgram: ";
				puVar10 = local_1a4;
				for (iVar4 = 6; iVar4 != 0; iVar4 += -1) {
					*puVar10 = *puVar9;
					puVar9 = puVar9 + 1;
					puVar10 = puVar10 + 1;
				}
				*(undefined2 *)puVar10 = *(undefined2 *)puVar9;
				uVar5 = 0xffffffff;
				do {
					puVar9 = puVar7;
					if (uVar5 == 0) break;
					uVar5 -= 1;
					puVar9 = (undefined4 *)((int)puVar7 + 1);
					cVar1 = *(char *)puVar7;
					puVar7 = puVar9;
				} while (cVar1 != '\0');
				uVar5 = ~uVar5;
				iVar4 = -1;
				puVar7 = local_1a4;
				do {
					puVar10 = puVar7;
					if (iVar4 == 0) break;
					iVar4 += -1;
					puVar10 = (undefined4 *)((int)puVar7 + 1);
					cVar1 = *(char *)puVar7;
					puVar7 = puVar10;
				} while (cVar1 != '\0');
				puVar7 = (undefined4 *)((int)puVar9 - uVar5);
				puVar9 = (undefined4 *)((int)puVar10 + -1);
				for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
					*puVar9 = *puVar7;
					puVar7 = puVar7 + 1;
					puVar9 = puVar9 + 1;
				}
				for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar9 = *(undefined *)puVar7;
					puVar7 = (undefined4 *)((int)puVar7 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				uVar5 = 0xffffffff;
				pcVar11 = "\n\n";
				do {
					pcVar12 = pcVar11;
					if (uVar5 == 0) break;
					uVar5 -= 1;
					pcVar12 = pcVar11 + 1;
					cVar1 = *pcVar11;
					pcVar11 = pcVar12;
				} while (cVar1 != '\0');
				uVar5 = ~uVar5;
				iVar4 = -1;
				puVar7 = local_1a4;
				do {
					puVar9 = puVar7;
					if (iVar4 == 0) break;
					iVar4 += -1;
					puVar9 = (undefined4 *)((int)puVar7 + 1);
					cVar1 = *(char *)puVar7;
					puVar7 = puVar9;
				} while (cVar1 != '\0');
				puVar7 = (undefined4 *)(pcVar12 + -uVar5);
				puVar9 = (undefined4 *)((int)puVar9 + -1);
				for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
					*puVar9 = *puVar7;
					puVar7 = puVar7 + 1;
					puVar9 = puVar9 + 1;
				}
				for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar9 = *(undefined *)puVar7;
					puVar7 = (undefined4 *)((int)puVar7 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				uVar5 = 0xffffffff;
				pcVar11 = *(char **)(iVar8 * 8 + 0x4b3434);
				do {
					pcVar12 = pcVar11;
					if (uVar5 == 0) break;
					uVar5 -= 1;
					pcVar12 = pcVar11 + 1;
					cVar1 = *pcVar11;
					pcVar11 = pcVar12;
				} while (cVar1 != '\0');
				uVar5 = ~uVar5;
				iVar8 = -1;
				puVar7 = local_1a4;
				do {
					puVar9 = puVar7;
					if (iVar8 == 0) break;
					iVar8 += -1;
					puVar9 = (undefined4 *)((int)puVar7 + 1);
					cVar1 = *(char *)puVar7;
					puVar7 = puVar9;
				} while (cVar1 != '\0');
				puVar7 = (undefined4 *)(pcVar12 + -uVar5);
				puVar9 = (undefined4 *)((int)puVar9 + -1);
				for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 -= 1) {
					*puVar9 = *puVar7;
					puVar7 = puVar7 + 1;
					puVar9 = puVar9 + 1;
				}
				for (uVar5 &= 3; uVar5 != 0; uVar5 -= 1) {
					*(undefined *)puVar9 = *(undefined *)puVar7;
					puVar7 = (undefined4 *)((int)puVar7 + 1);
					puVar9 = (undefined4 *)((int)puVar9 + 1);
				}
				__std_FUN_004999f0(local_1a4,"Microsoft Visual C++ Runtime Library",0x12010);
				return;
			}
		}
	}
	return;
}



LCID __cdecl
std::internal::__ctype_internal
					(DWORD param_1,LPCSTR param_2,int param_3,LPWORD param_4,UINT param_5,LCID param_6)
{
	BOOL BVar1;
	LCID LVar2;
	int iVar3;
	int *lpWideCharStr;
	WORD local_2;
	
	lpWideCharStr = NULL;
	if (DAT_0054a3e0 == 0) {
		BVar1 = GetStringTypeA(0,1,(LPCSTR)&lpSrcStr_0049fd38,1,&local_2);
		if (BVar1 == 0) {
			BVar1 = GetStringTypeW(1,(LPCWSTR)&lpSrcStr_0049fd3c,1,&local_2);
			if (BVar1 == 0) {
				return 0;
			}
			DAT_0054a3e0 = 1;
		}
		else {
			DAT_0054a3e0 = 2;
		}
	}
	if (DAT_0054a3e0 == 2) {
		if (param_6 == 0) {
			param_6 = DAT_0054a180;
		}
		LVar2 = GetStringTypeA(param_6,param_1,param_2,param_3,param_4);
		return LVar2;
	}
	param_6 = DAT_0054a3e0;
	if (DAT_0054a3e0 == 1) {
		param_6 = 0;
		if (param_5 == 0) {
			param_5 = DAT_0054a190;
		}
		iVar3 = MultiByteToWideChar(param_5,9,param_2,param_3,NULL,0);
		if (iVar3 != 0) {
			lpWideCharStr = __std_FUN_00499a80(2,iVar3);
			if (lpWideCharStr != NULL) {
				iVar3 = MultiByteToWideChar(param_5,1,param_2,param_3,(LPWSTR)lpWideCharStr,iVar3);
				if (iVar3 != 0) {
					LVar2 = GetStringTypeW(param_1,(LPCWSTR)lpWideCharStr,iVar3,param_4);
					free(lpWideCharStr);
					return LVar2;
				}
			}
		}
		free(lpWideCharStr);
	}
	return param_6;
}



DWORD __cdecl std::internal::__fdread__00496ec0(uint param_1,LONG param_2,DWORD param_3)
{
	HANDLE hFile;
	DWORD DVar1;
	uint error_value;
	int iVar2;
	
	if (param_1 < globals::__UINT_0076eec0) {
		iVar2 = (param_1 & 0x1f) * 8;
		if ((*(byte *)((&DAT_0076edc0)[(int)param_1 >> 5] + 4 + iVar2) & 1) != 0) {
			hFile = (HANDLE)__fdunk__004994b0(param_1);
			if (hFile == (HANDLE)0xffffffff) {
				std::globals::g_msvc_errno = 9;
				return 0xffffffff;
			}
			DVar1 = SetFilePointer(hFile,param_2,NULL,param_3);
			if (DVar1 == 0xffffffff) {
				error_value = GetLastError();
			}
			else {
				error_value = 0;
			}
			if (error_value != 0) {
				__set_doserrno(error_value);
				return 0xffffffff;
			}
			*(byte *)((&DAT_0076edc0)[(int)param_1 >> 5] + 4 + iVar2) =
					 *(byte *)((&DAT_0076edc0)[(int)param_1 >> 5] + 4 + iVar2) & 0xfd;
			return DVar1;
		}
	}
	std::globals::g_msvc_errno = 9;
	std::globals::g_msvc_doserrno = 0;
	return 0xffffffff;
}



int __cdecl std::internal::__fdwrite__00496f80(uint param_1,char *param_2,char *param_3)
{
	int *piVar1;
	byte bVar2;
	char cVar3;
	char *pcVar4;
	BOOL BVar5;
	int iVar6;
	char *pcVar7;
	DWORD local_41c;
	DWORD local_414;
	DWORD local_410;
	int local_40c;
	int *local_408;
	char local_404 [1028];
	
	if (param_1 < globals::__UINT_0076eec0) {
		piVar1 = &DAT_0076edc0 + ((int)param_1 >> 5);
		iVar6 = (param_1 & 0x1f) * 8;
		bVar2 = *(byte *)(iVar6 + 4 + (&DAT_0076edc0)[(int)param_1 >> 5]);
		if ((bVar2 & 1) != 0) {
			local_41c = 0;
			local_40c = 0;
			if (param_3 == NULL) {
				return 0;
			}
			local_408 = piVar1;
			if ((bVar2 & 0x20) != 0) {
				__fdread__00496ec0(param_1,0,2);
			}
			if ((*(byte *)((HANDLE *)(*piVar1 + iVar6) + 1) & 0x80) == 0) {
				BVar5 = WriteFile(*(HANDLE *)(*piVar1 + iVar6),param_2,(DWORD)param_3,&local_410,NULL);
				if (BVar5 == 0) {
					local_414 = GetLastError();
				}
				else {
					local_41c = local_410;
					local_414 = 0;
				}
			}
			else {
				local_414 = 0;
				pcVar7 = param_2;
				if (param_3 != NULL) {
					do {
						pcVar4 = local_404;
						do {
							if (param_3 <= pcVar7 + -(int)param_2) break;
							cVar3 = *pcVar7;
							pcVar7 = pcVar7 + 1;
							if (cVar3 == '\n') {
								*pcVar4 = '\r';
								local_40c += 1;
								pcVar4 = pcVar4 + 1;
							}
							*pcVar4 = cVar3;
							pcVar4 = pcVar4 + 1;
						} while ((int)(pcVar4 + -(int)local_404) < 0x400);
						BVar5 = WriteFile(*(HANDLE *)(iVar6 + *local_408),local_404,
															(DWORD)(pcVar4 + -(int)local_404),&local_410,NULL);
						if (BVar5 == 0) {
							local_414 = GetLastError();
							break;
						}
						local_41c += local_410;
						if (((int)local_410 < (int)(pcVar4 + -(int)local_404)) ||
							 (param_3 <= pcVar7 + -(int)param_2)) break;
					} while( true );
				}
			}
			if (local_41c != 0) {
				return local_41c - local_40c;
			}
			if (local_414 == 0) {
				if (((*(byte *)(iVar6 + 4 + *local_408) & 0x40) != 0) && (*param_2 == '\x1a')) {
					return 0;
				}
				std::globals::g_msvc_errno = 0x1c;
				std::globals::g_msvc_doserrno = 0;
				return -1;
			}
			if (local_414 == 5) {
				std::globals::g_msvc_errno = 9;
				std::globals::g_msvc_doserrno = local_414;
				return -1;
			}
			__set_doserrno(local_414);
			return -1;
		}
	}
	std::globals::g_msvc_errno = 9;
	std::globals::g_msvc_doserrno = 0;
	return -1;
}



void __cdecl std::internal::__set_doserrno(uint error_value)
{
	uint (*pauVar1) [2];
	int iVar2;
	
	iVar2 = 0;
	pauVar1 = globals::__errorArray_004b34c0;
	do {
		if (error_value == (*pauVar1)[0]) {
			std::globals::g_msvc_errno = globals::__errorArray_004b34c0[iVar2][1];
			std::globals::g_msvc_doserrno = error_value;
			return;
		}
		pauVar1 = pauVar1[1];
		iVar2 += 1;
	} while (pauVar1 < &PTR_DAT_004b3628);
	if ((0x12 < error_value) && (error_value < 0x25)) {
		std::globals::g_msvc_errno = EACCES;
		std::globals::g_msvc_doserrno = error_value;
		return;
	}
	if ((error_value < 0xbc) || (std::globals::g_msvc_errno = ENOEXEC, 0xca < error_value)) {
		std::globals::g_msvc_errno = EINVAL;
	}
	std::globals::g_msvc_doserrno = error_value;
	return;
}



int __cdecl
std::internal::__unkftime__00497210
					(int param_1,int param_2,int param_3,int param_4,int param_5,int param_6,int param_7)
{
	int iVar1;
	uint uVar2;
	int local_24 [2];
	int local_1c;
	int local_14;
	uint local_10;
	int local_8;
	
	local_10 = param_1 - 0x76c;
	if (((int)local_10 < 0x46) || (0x8a < (int)local_10)) {
		return -1;
	}
	local_8 = *(int *)(&DAT_004b39dc + param_2 * 4) + param_3;
	if (((local_10 & 3) == 0) && (2 < param_2)) {
		local_8 += 1;
	}
	__unkftime__00499b20();
	local_1c = param_4;
	local_14 = param_2 + -1;
	iVar1 = param_6 + (param_5 +
										(param_4 + ((param_1 + -0x76d >> 2) + local_10 * 0x16d + local_8) * 0x18) * 0x3c
										) * 0x3c + 0x7c558180 + DAT_004b38f0;
	if (param_7 != 1) {
		if (param_7 != -1) {
			return iVar1;
		}
		if (DAT_004b38f4 == 0) {
			return iVar1;
		}
		uVar2 = __unkftime__00499df0(local_24);
		if (uVar2 == 0) {
			return iVar1;
		}
	}
	return iVar1 + DAT_004b38f8;
}



int __cdecl std::internal::__fpeekc(FILE *file)
{
	byte bVar1;
	uint uVar2;
	char *pcVar3;
	undefined *puVar4;
	
	uVar2 = file->_flag;
	if (((uVar2 & 0x83) != 0) && ((uVar2 & 0x40) == 0)) {
		if ((uVar2 & 2) != 0) {
			file->_flag = uVar2 | 0x20;
			return 0xffffffff;
		}
		file->_flag = uVar2 | 1;
		if ((uVar2 & 0x10c) == 0) {
			__fileunk__00498da0(file);
		}
		else {
			file->_ptr = file->_base;
		}
		pcVar3 = __fdread(file->_file,file->_base,file->_bufsiz);
		file->_cnt = (int)pcVar3;
		if ((pcVar3 != NULL) && (pcVar3 != (char *)0xffffffff)) {
			if ((file->_flag & 0x82U) == 0) {
				uVar2 = file->_file;
				if (uVar2 == 0xffffffff) {
					puVar4 = &DAT_004b3428;
				}
				else {
					puVar4 = (undefined *)((&DAT_0076edc0)[(int)uVar2 >> 5] + (uVar2 & 0x1f) * 8);
				}
				if ((puVar4[4] & 0x82) == 0x82) {
					file->_flag = file->_flag | 0x2000;
				}
			}
			if (((file->_bufsiz == 0x200) && ((file->_flag & 8U) != 0)) && ((file->_flag & 0x400U) == 0))
			{
				file->_bufsiz = 0x1000;
			}
			file->_cnt = (int)(pcVar3 + -1);
			bVar1 = *file->_ptr;
			file->_ptr = file->_ptr + 1;
			return (uint)bVar1;
		}
		file->_cnt = 0;
		file->_flag = file->_flag | (-(uint)(pcVar3 != NULL) & 0x10) + 0x10;
	}
	return 0xffffffff;
}



char * __cdecl std::internal::__fdread(uint fd,char *param_2,DWORD param_3)
{
	int *piVar1;
	char cVar2;
	byte bVar3;
	BOOL BVar4;
	DWORD DVar5;
	int iVar6;
	int iVar7;
	char *pcVar8;
	char *pcVar9;
	DWORD local_c;
	int *local_8;
	char *local_4;
	
	if (fd < globals::__UINT_0076eec0) {
		iVar6 = (fd & 0x1f) * 8;
		piVar1 = &DAT_0076edc0 + ((int)fd >> 5);
		local_c = iVar6 + (&DAT_0076edc0)[(int)fd >> 5];
		bVar3 = *(byte *)(local_c + 4);
		if ((bVar3 & 1) != 0) {
			iVar7 = 0;
			if ((param_3 == 0) || ((bVar3 & 2) != 0)) {
				return NULL;
			}
			pcVar8 = param_2;
			DVar5 = param_3;
			if (((bVar3 & 0x48) != 0) && (*(char *)(local_c + 5) != '\n')) {
				*param_2 = *(char *)(local_c + 5);
				pcVar8 = param_2 + 1;
				iVar7 = 1;
				DVar5 = param_3 - 1;
				*(undefined *)(iVar6 + 5 + *piVar1) = 10;
			}
			local_8 = piVar1;
			BVar4 = ReadFile(*(HANDLE *)(iVar6 + *piVar1),pcVar8,DVar5,&local_c,NULL);
			if (BVar4 == 0) {
				DVar5 = GetLastError();
				if (DVar5 == 5) {
					std::globals::g_msvc_errno = 9;
					std::globals::g_msvc_doserrno = DVar5;
					return (char *)0xffffffff;
				}
				if (DVar5 == 0x6d) {
					return NULL;
				}
				__set_doserrno(DVar5);
				return (char *)0xffffffff;
			}
			local_4 = (char *)(iVar7 + local_c);
			bVar3 = *(byte *)(iVar6 + 4 + *piVar1);
			if ((bVar3 & 0x80) != 0) {
				if ((local_c == 0) || (*param_2 != '\n')) {
					bVar3 &= 0xfb;
				}
				else {
					bVar3 |= 4;
				}
				*(byte *)(iVar6 + 4 + *piVar1) = bVar3;
				local_4 = local_4 + (int)param_2;
				pcVar8 = param_2;
				pcVar9 = param_2;
				if (param_2 < local_4) {
					while (cVar2 = *pcVar9, cVar2 != '\x1a') {
						if (cVar2 == '\r') {
							if (pcVar9 < local_4 + -1) {
								if (pcVar9[1] == '\n') {
									pcVar9 = pcVar9 + 2;
									*pcVar8 = '\n';
									goto LAB_004975d8;
								}
								*pcVar8 = '\r';
								pcVar8 = pcVar8 + 1;
								pcVar9 = pcVar9 + 1;
							}
							else {
								DVar5 = 0;
								pcVar9 = pcVar9 + 1;
								BVar4 = ReadFile(*(HANDLE *)(iVar6 + *local_8),&param_3,1,&local_c,NULL);
								if (BVar4 == 0) {
									DVar5 = GetLastError();
								}
								if ((DVar5 == 0) && (local_c != 0)) {
									if ((*(byte *)(iVar6 + 4 + *local_8) & 0x48) == 0) {
										if ((pcVar8 == param_2) && ((char)param_3 == '\n')) {
											*pcVar8 = '\n';
											goto LAB_004975d8;
										}
										__fdread__00496ec0(fd,-1,1);
										if ((char)param_3 != '\n') goto LAB_004975d5;
									}
									else {
										if ((char)param_3 == '\n') {
											*pcVar8 = '\n';
											goto LAB_004975d8;
										}
										*pcVar8 = '\r';
										pcVar8 = pcVar8 + 1;
										*(char *)(iVar6 + 5 + *local_8) = (char)param_3;
									}
								}
								else {
LAB_004975d5:
									*pcVar8 = '\r';
LAB_004975d8:
									pcVar8 = pcVar8 + 1;
								}
							}
						}
						else {
							*pcVar8 = cVar2;
							pcVar8 = pcVar8 + 1;
							pcVar9 = pcVar9 + 1;
						}
						if (local_4 <= pcVar9) {
							return pcVar8 + -(int)param_2;
						}
					}
					bVar3 = *(byte *)(iVar6 + 4 + *local_8);
					if ((bVar3 & 0x40) == 0) {
						*(byte *)(iVar6 + 4 + *local_8) = bVar3 | 2;
					}
				}
				local_4 = pcVar8 + -(int)param_2;
			}
			return local_4;
		}
	}
	std::globals::g_msvc_errno = 9;
	std::globals::g_msvc_doserrno = 0;
	return (char *)0xffffffff;
}



int __cdecl std::internal::__std_FUN_00497650(uint param_1)
{
	HANDLE hFile;
	BOOL BVar1;
	uint uVar2;
	
	uVar2 = std::globals::g_msvc_doserrno;
	if ((param_1 < globals::__UINT_0076eec0) &&
		 ((*(byte *)((&DAT_0076edc0)[(int)param_1 >> 5] + 4 + (param_1 & 0x1f) * 8) & 1) != 0)) {
		hFile = (HANDLE)__fdunk__004994b0(param_1);
		BVar1 = FlushFileBuffers(hFile);
		if (BVar1 == 0) {
			uVar2 = GetLastError();
		}
		else {
			uVar2 = 0;
		}
		if (uVar2 == 0) {
			return 0;
		}
	}
	std::globals::g_msvc_doserrno = uVar2;
	std::globals::g_msvc_errno = 9;
	return -1;
}



void std::internal::__std_FUN_004976b0(void)
{
	uint uVar1;
	undefined **ppuVar2;
	int iVar3;
	undefined4 *puVar4;
	
	if (globals::__filesCount_0076eda0 == 0) {
		globals::__filesCount_0076eda0 = 0x200;
	}
	else {
		if (globals::__filesCount_0076eda0 < 0x14) {
			globals::__filesCount_0076eda0 = 0x14;
		}
	}
	globals::__filesTable_0076dd98 = (FILE **)__std_FUN_00499a80(globals::__filesCount_0076eda0,4);
	if (globals::__filesTable_0076dd98 == NULL) {
		globals::__filesCount_0076eda0 = 0x14;
		globals::__filesTable_0076dd98 = (FILE **)__std_FUN_00499a80(0x14,4);
		if (globals::__filesTable_0076dd98 == NULL) {
			__amsg_exit(0x1a);
		}
	}
	iVar3 = 0;
	ppuVar2 = &PTR_DAT_004b3628;
	do {
		*(undefined ***)((int)globals::__filesTable_0076dd98 + iVar3) = ppuVar2;
		ppuVar2 = ppuVar2 + 8;
		iVar3 += 4;
	} while ((int)ppuVar2 < 0x4b38a8);
	uVar1 = 0;
	puVar4 = &DAT_004b3638;
	do {
		iVar3 = *(int *)((&DAT_0076edc0)[(int)uVar1 >> 5] + (uVar1 & 0x1f) * 8);
		if ((iVar3 == -1) || (iVar3 == 0)) {
			*puVar4 = 0xffffffff;
		}
		puVar4 = puVar4 + 8;
		uVar1 += 1;
	} while ((int)puVar4 < 0x4b3698);
	return;
}



uint std::internal::__std_FUN_00497770(void)
{
	FILE *stream;
	uint uVar1;
	int iVar2;
	int iVar3;
	
	uVar1 = __std_FUN_00490050();
	if (DAT_0054a110 == 0) {
		return uVar1 & 0xffffff00 | (uint)DAT_0054a110;
	}
	iVar3 = 3;
	uVar1 = 0;
	if (3 < globals::__filesCount_0076eda0) {
		do {
			stream = globals::__filesTable_0076dd98[iVar3];
			if (stream != NULL) {
				if (((*(byte *)&stream->_flag & 0x83) != 0) && (iVar2 = fclose(stream), iVar2 != -1)) {
					uVar1 += 1;
				}
				if (0x13 < iVar3) {
					free(globals::__filesTable_0076dd98[iVar3]);
					globals::__filesTable_0076dd98[iVar3] = NULL;
				}
			}
			iVar3 += 1;
		} while (iVar3 < globals::__filesCount_0076eda0);
	}
	return uVar1;
}



BOOL __cdecl std::internal::__vfprintf__00497790(FILE *stream)
{
	BOOL BVar1;
	char *pcVar2;
	int iVar3;
	
	BVar1 = __std_FUN_00498e00(stream->_file);
	if (BVar1 != 0) {
		if (stream == &globals::__FILE_004b3648) {
			iVar3 = 0;
		}
		else {
			if (stream != &globals::__FILE_004b3668) {
				return 0;
			}
			iVar3 = 1;
		}
		globals::__unkCount_0054a3e4 += 1;
		if ((stream->_flag & 0x10cU) == 0) {
			if (globals::__tmpFileBuffers_0054a3e8[iVar3] == NULL) {
				pcVar2 = (char *)malloc(0x1000);
				globals::__tmpFileBuffers_0054a3e8[iVar3] = pcVar2;
				if (pcVar2 == NULL) {
					return 0;
				}
			}
			pcVar2 = globals::__tmpFileBuffers_0054a3e8[iVar3];
			stream->_bufsiz = 0x1000;
			stream->_base = pcVar2;
			stream->_ptr = pcVar2;
			stream->_cnt = 0x1000;
			stream->_flag = stream->_flag | 0x1102;
			return 1;
		}
	}
	return 0;
}



void __cdecl std::internal::__vfprintf__00497830(BOOL param_1,FILE *stream)
{
	if (param_1 == 0) {
		if ((stream->_flag & 0x1000U) != 0) {
			__std_fflush__0048ffe0(stream);
		}
	}
	else {
		if ((stream->_flag & 0x1000U) != 0) {
			__std_fflush__0048ffe0(stream);
			stream->_bufsiz = 0;
			stream->_flag = stream->_flag & 0xffffeeff;
			stream->_ptr = NULL;
			stream->_base = NULL;
			return;
		}
	}
	return;
}



int __cdecl std::tolower(int c)
{
	int iVar1;
	uint uVar2;
	LPCWSTR pWVar3;
	int iVar4;
	uint local_8 [2];
	
	iVar1 = c;
	if (DAT_0054a180 == 0) {
		if ((0x40 < c) && (c < 0x5b)) {
			return c + 0x20;
		}
	}
	else {
		if (c < 0x100) {
										// int std::isupper(int c)
			if (globals::_pcharwidth < 2) {
				uVar2 = *(byte *)(globals::_pctype + c) & C1_UPPER;
			}
			else {
				uVar2 = _isctype(c,C1_UPPER);
			}
			if (uVar2 == 0) {
				return iVar1;
			}
		}
		if ((*(byte *)((int)globals::_pctype + (iVar1 >> 8 & 0xffU) * 2 + 1) & 0x80) == 0) {
			c = c & 0xffff0000U | iVar1 & 0xffU;
			pWVar3 = (LPCWSTR)0x1;
		}
		else {
			c = c & 0xff000000U | (uint)CONCAT11((char)iVar1,(char)((uint)iVar1 >> 8));
			pWVar3 = (LPCWSTR)0x2;
		}
		iVar4 = internal::__uprlwr__00493f60(DAT_0054a180,0x100,(char *)&c,pWVar3,(LPWSTR)local_8,3,0);
		if (iVar4 == 0) {
			return iVar1;
		}
		if (iVar4 == 1) {
			return local_8[0] & 0xff;
		}
		c = (local_8[0] >> 8 & 0xff) << 8 | local_8[0] & 0xff;
	}
	return c;
}



char * __cdecl std::strncpy(char *strDest,char *strSource,size_t count)
{
	byte bVar1;
	byte bVar2;
	char *pcVar3;
	uint uVar4;
	undefined4 *puVar5;
	undefined4 *puVar6;
	
	if (DAT_0054a3bc == 0) {
		pcVar3 = _strncpy(strDest,strSource,count);
		return pcVar3;
	}
	uVar4 = count;
	puVar6 = (undefined4 *)strDest;
	puVar5 = (undefined4 *)strDest;
	if (count != 0) {
		do {
			bVar1 = *strSource;
			count = uVar4 - 1;
			bVar2 = *(byte *)((int)&DAT_0054a2b8 + bVar1 + 1);
			*(byte *)puVar5 = bVar1;
			if ((bVar2 & 4) == 0) {
				puVar6 = (undefined4 *)((int)puVar5 + 1);
				strSource = (char *)((byte *)strSource + 1);
				if (bVar1 == 0) break;
			}
			else {
				puVar6 = (undefined4 *)((int)puVar5 + 1);
				if (count == 0) {
					*(undefined *)puVar5 = 0;
					break;
				}
				bVar1 = ((byte *)strSource)[1];
				count = uVar4 - 2;
				*(byte *)puVar6 = bVar1;
				puVar6 = (undefined4 *)((int)puVar5 + 2);
				strSource = (char *)((byte *)strSource + 2);
				if (bVar1 == 0) {
					*(undefined *)puVar5 = 0;
					break;
				}
			}
			uVar4 = count;
			puVar5 = puVar6;
		} while (count != 0);
	}
	if (count != 0) {
		for (uVar4 = count >> 2; uVar4 != 0; uVar4 -= 1) {
			*puVar6 = 0;
			puVar6 = puVar6 + 1;
		}
		for (uVar4 = count & 3; uVar4 != 0; uVar4 -= 1) {
			*(undefined *)puVar6 = 0;
			puVar6 = (undefined4 *)((int)puVar6 + 1);
		}
	}
	return strDest;
}



uint std::internal::__std_FUN_00497a30(uint param_1,uint param_2)
{
	uint uVar1;
	ushort in_FPUControlWord;
	
	uVar1 = __std_FUN_00497a90((uint)in_FPUControlWord);
	uVar1 = param_2 & param_1 | ~param_2 & uVar1;
	__std_FUN_00497b30(uVar1);
	return uVar1;
}



void __cdecl std::internal::__std_FUN_00497a70(undefined4 param_1,uint param_2)
{
	__std_FUN_00497a30(param_1,param_2 & 0xfff7ffff);
	return;
}



uint __cdecl std::internal::__std_FUN_00497a90(uint param_1)
{
	uint uVar1;
	uint uVar2;
	
	uVar1 = 0;
	if ((param_1 & 1) != 0) {
		uVar1 = 0x10;
	}
	if ((param_1 & 4) != 0) {
		uVar1 |= 8;
	}
	if ((param_1 & 8) != 0) {
		uVar1 |= 4;
	}
	if ((param_1 & 0x10) != 0) {
		uVar1 |= 2;
	}
	if ((param_1 & 0x20) != 0) {
		uVar1 |= 1;
	}
	if ((param_1 & 2) != 0) {
		uVar1 |= 0x80000;
	}
	uVar2 = param_1 & 0xc00;
	if (uVar2 < 0x401) {
		if (uVar2 == 0x400) {
			uVar1 |= 0x100;
		}
	}
	else {
		if (uVar2 == 0x800) {
			uVar1 |= 0x200;
		}
		else {
			if (uVar2 == 0xc00) {
				uVar1 |= 0x300;
			}
		}
	}
	if ((param_1 & 0x300) == 0) {
		uVar1 |= 0x20000;
	}
	else {
		if ((param_1 & 0x300) == 0x200) {
			uVar1 |= 0x10000;
		}
	}
	if ((param_1 & 0x1000) != 0) {
		uVar1 |= 0x40000;
	}
	return uVar1;
}



uint __cdecl std::internal::__std_FUN_00497b30(uint param_1)
{
	uint uVar1;
	uint uVar2;
	byte bVar3;
	
	bVar3 = (param_1 & 0x10) != 0;
	if ((param_1 & 8) != 0) {
		bVar3 |= 4;
	}
	if ((param_1 & 4) != 0) {
		bVar3 |= 8;
	}
	if ((param_1 & 2) != 0) {
		bVar3 |= 0x10;
	}
	if ((param_1 & 1) != 0) {
		bVar3 |= 0x20;
	}
	if ((param_1 & 0x80000) != 0) {
		bVar3 |= 2;
	}
	uVar1 = (uint)bVar3;
	uVar2 = param_1 & 0x300;
	if (uVar2 < 0x101) {
		if (uVar2 == 0x100) {
			uVar1 = bVar3 | 0x400;
		}
	}
	else {
		if (uVar2 == 0x200) {
			uVar1 = (uint)CONCAT11(8,bVar3);
		}
		else {
			if (uVar2 == 0x300) {
				uVar1 = (uint)CONCAT11(0xc,bVar3);
			}
		}
	}
	if ((param_1 & 0x30000) == 0) {
		uVar1 |= 0x300;
	}
	else {
		if ((param_1 & 0x30000) == 0x10000) {
			uVar1 |= 0x200;
		}
	}
	if ((param_1 & 0x40000) != 0) {
		uVar1 |= 0x1000;
	}
	return uVar1;
}



undefined4 __cdecl std::internal::__std_FUN_00497bc0(int param_1,int param_2)
{
	byte bVar1;
	int *piVar2;
	int iVar3;
	
	bVar1 = (byte)(param_2 >> 0x1f);
	iVar3 = (int)(param_2 + (param_2 >> 0x1f & 0x1fU)) >> 5;
	if ((*(uint *)(param_1 + iVar3 * 4) &
			~(-1 << (0x1f - ((((byte)param_2 ^ bVar1) - bVar1 & 0x1f ^ bVar1) - bVar1) & 0x1f))) != 0) {
		return 0;
	}
	iVar3 += 1;
	if (iVar3 < 3) {
		piVar2 = (int *)(param_1 + iVar3 * 4);
		do {
			if (*piVar2 != 0) {
				return 0;
			}
			iVar3 += 1;
			piVar2 = piVar2 + 1;
		} while (iVar3 < 3);
		return 1;
	}
	return 1;
}



void __cdecl std::internal::__std_FUN_00497c30(int param_1,int param_2)
{
	byte bVar1;
	int iVar2;
	int iVar3;
	uint *puVar4;
	
	bVar1 = (byte)(param_2 >> 0x1f);
	iVar3 = (int)(param_2 + (param_2 >> 0x1f & 0x1fU)) >> 5;
	iVar2 = __std_FUN_0049a270(*(uint *)(param_1 + iVar3 * 4),
														 1 << (0x1f - ((((byte)param_2 ^ bVar1) - bVar1 & 0x1f ^ bVar1) - bVar1)
																	& 0x1f),(uint *)(param_1 + iVar3 * 4));
	iVar3 += -1;
	if (-1 < iVar3) {
		puVar4 = (uint *)(param_1 + iVar3 * 4);
		do {
			if (iVar2 == 0) {
				return;
			}
			iVar2 = __std_FUN_0049a270(*puVar4,1,puVar4);
			iVar3 += -1;
			puVar4 = puVar4 + -1;
		} while (-1 < iVar3);
	}
	return;
}



undefined4 __cdecl std::internal::__std_FUN_00497ca0(int param_1,int param_2)
{
	int iVar1;
	byte bVar2;
	int iVar3;
	undefined4 *puVar4;
	undefined4 local_4;
	
	local_4 = 0;
	bVar2 = (byte)(param_2 >> 0x1f);
	bVar2 = 0x1f - ((((byte)param_2 ^ bVar2) - bVar2 & 0x1f ^ bVar2) - bVar2);
	iVar3 = (int)(param_2 + (param_2 >> 0x1f & 0x1fU)) >> 5;
	if (((*(uint *)(param_1 + iVar3 * 4) & 1 << (bVar2 & 0x1f)) != 0) &&
		 (iVar1 = __std_FUN_00497bc0(param_1,param_2 + 1), iVar1 == 0)) {
		local_4 = __std_FUN_00497c30(param_1,param_2 + -1);
	}
	*(uint *)(param_1 + iVar3 * 4) = *(uint *)(param_1 + iVar3 * 4) & -1 << (bVar2 & 0x1f);
	iVar3 += 1;
	if (iVar3 < 3) {
		puVar4 = (undefined4 *)(param_1 + iVar3 * 4);
		for (iVar1 = 3 - iVar3; iVar1 != 0; iVar1 += -1) {
			*puVar4 = 0;
			puVar4 = puVar4 + 1;
		}
	}
	return local_4;
}



void __cdecl std::internal::__std_FUN_00497d40(int param_1,undefined4 *param_2)
{
	int iVar1;
	int iVar2;
	
	iVar1 = param_1 - (int)param_2;
	iVar2 = 3;
	do {
		*(undefined4 *)((int)param_2 + iVar1) = *param_2;
		param_2 = param_2 + 1;
		iVar2 += -1;
	} while (iVar2 != 0);
	return;
}



void __cdecl std::internal::__std_FUN_00497d60(undefined4 *param_1)
{
	*param_1 = 0;
	param_1[1] = 0;
	param_1[2] = 0;
	return;
}



undefined4 __cdecl std::internal::__std_FUN_00497d70(int *param_1)
{
	int iVar1;
	
	iVar1 = 0;
	do {
		if (*param_1 != 0) {
			return 0;
		}
		iVar1 += 1;
		param_1 = param_1 + 1;
	} while (iVar1 < 3);
	return 1;
}



void __cdecl std::internal::__std_FUN_00497d90(uint *param_1,int param_2)
{
	int iVar1;
	byte bVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	uint *puVar6;
	int iVar7;
	
	iVar1 = (int)(param_2 + (param_2 >> 0x1f & 0x1fU)) >> 5;
	bVar2 = (byte)(param_2 >> 0x1f);
	uVar5 = 0;
	bVar2 = (((byte)param_2 ^ bVar2) - bVar2 & 0x1f ^ bVar2) - bVar2;
	param_2 = 3;
	puVar6 = param_1;
	do {
		uVar4 = *puVar6 >> (bVar2 & 0x1f) | uVar5;
		uVar5 = (~(-1 << (bVar2 & 0x1f)) & *puVar6) << (0x20 - bVar2 & 0x1f);
		*puVar6 = uVar4;
		param_2 += -1;
		puVar6 = puVar6 + 1;
	} while (param_2 != 0);
	iVar7 = 2;
	iVar3 = 8;
	do {
		if (iVar7 < iVar1) {
			*(undefined4 *)((int)param_1 + iVar3) = 0;
		}
		else {
			*(undefined4 *)((int)param_1 + iVar3) = *(undefined4 *)((int)param_1 + iVar3 + iVar1 * -4);
		}
		iVar7 += -1;
		iVar3 += -4;
	} while (-1 < iVar3);
	return;
}



undefined4 __cdecl std::internal::__std_FUN_00497e50(ushort *param_1,uint *param_2,int *param_3)
{
	ushort uVar1;
	int iVar2;
	undefined4 uVar3;
	uint uVar4;
	int iVar5;
	uint local_18;
	uint local_14;
	int local_10;
	undefined4 local_c [3];
	
	uVar1 = param_1[5];
	local_14 = *(uint *)(param_1 + 1);
	local_18 = *(uint *)(param_1 + 3);
	uVar4 = uVar1 & 0x7fff;
	iVar5 = uVar4 - 0x3fff;
	local_10 = (uint)*param_1 << 0x10;
	if (iVar5 == -0x3fff) {
		iVar5 = 0;
		iVar2 = __std_FUN_00497d70((int *)&local_18);
		if (iVar2 == 0) {
			__std_FUN_00497d60(&local_18);
			uVar3 = 2;
			goto LAB_00497fd1;
		}
	}
	else {
		__std_FUN_00497d40((int)local_c,&local_18);
		iVar2 = __std_FUN_00497ca0((int)&local_18,param_3[2]);
		if (iVar2 != 0) {
			iVar5 = uVar4 - 0x3ffe;
		}
		iVar2 = param_3[1];
		if (iVar5 < iVar2 - param_3[2]) {
			__std_FUN_00497d60(&local_18);
			iVar5 = 0;
			uVar3 = 2;
			goto LAB_00497fd1;
		}
		if (iVar5 <= iVar2) {
			__std_FUN_00497d40((int)&local_18,local_c);
			__std_FUN_00497d90(&local_18,iVar2 - iVar5);
			__std_FUN_00497ca0((int)&local_18,param_3[2]);
			__std_FUN_00497d90(&local_18,param_3[3] + 1);
			iVar5 = 0;
			uVar3 = 2;
			goto LAB_00497fd1;
		}
		if (*param_3 <= iVar5) {
			__std_FUN_00497d60(&local_18);
			local_18 |= 0x80000000;
			__std_FUN_00497d90(&local_18,param_3[3]);
			iVar5 = param_3[5] + *param_3;
			uVar3 = 1;
			goto LAB_00497fd1;
		}
		iVar5 = param_3[5] + iVar5;
		local_18 &= 0x7fffffff;
		__std_FUN_00497d90(&local_18,param_3[3]);
	}
	uVar3 = 0;
LAB_00497fd1:
	local_18 = iVar5 << (0x1fU - (char)param_3[3] & 0x1f) |
						 -(uint)((uVar1 & 0x8000) != 0) & 0x80000000 | local_18;
	if (param_3[4] == 0x40) {
		param_2[1] = local_18;
		*param_2 = local_14;
		return uVar3;
	}
	if (param_3[4] == 0x20) {
		*param_2 = local_18;
	}
	return uVar3;
}



void __cdecl std::internal::__std_FUN_00498020(ushort *param_1,uint *param_2)
{
	__std_FUN_00497e50(param_1,param_2,(int *)&DAT_004b38a8);
	return;
}



void __cdecl std::internal::__std_FUN_00498040(ushort *param_1,uint *param_2)
{
	__std_FUN_00497e50(param_1,param_2,(int *)&DAT_004b38c0);
	return;
}



void __cdecl std::internal::__std_FUN_00498060(uint *param_1,byte *param_2)
{
	ushort local_c [6];
	
	__std_FUN_00498610(local_c,&param_2,param_2,0,0,0,0);
	__std_FUN_00498020(local_c,param_1);
	return;
}



void __cdecl std::internal::__std_FUN_004980a0(uint *param_1,byte *param_2)
{
	ushort local_c [6];
	
	__std_FUN_00498610(local_c,&param_2,param_2,0,0,0,0);
	__std_FUN_00498040(local_c,param_1);
	return;
}



void __cdecl std::internal::__std_FUN_004980e0(undefined4 *param_1,int param_2,int param_3)
{
	char *pcVar1;
	char cVar2;
	uint uVar3;
	uint uVar4;
	char *pcVar5;
	int iVar6;
	undefined4 *puVar7;
	char *pcVar8;
	
	pcVar5 = *(char **)(param_3 + 0xc);
	pcVar8 = (char *)((int)param_1 + 1);
	*(undefined *)param_1 = 0x30;
	pcVar1 = pcVar8;
	iVar6 = param_2;
	if (0 < param_2) {
		do {
			cVar2 = *pcVar5;
			if (cVar2 == '\0') {
				cVar2 = '0';
			}
			else {
				pcVar5 = pcVar5 + 1;
			}
			*pcVar1 = cVar2;
			pcVar1 = pcVar1 + 1;
			iVar6 += -1;
			param_2 += -1;
		} while (param_2 != 0);
	}
	*pcVar1 = '\0';
	if ((-1 < iVar6) && ('4' < *pcVar5)) {
		cVar2 = pcVar1[-1];
		while (pcVar5 = pcVar1 + -1, cVar2 == '9') {
			*pcVar5 = '0';
			cVar2 = pcVar1[-2];
			pcVar1 = pcVar5;
		}
		*pcVar5 = *pcVar5 + '\x01';
	}
	if (*(char *)param_1 == '1') {
		*(int *)(param_3 + 4) = *(int *)(param_3 + 4) + 1;
		return;
	}
	uVar3 = 0xffffffff;
	do {
		pcVar5 = pcVar8;
		if (uVar3 == 0) break;
		uVar3 -= 1;
		pcVar5 = pcVar8 + 1;
		cVar2 = *pcVar8;
		pcVar8 = pcVar5;
	} while (cVar2 != '\0');
	uVar3 = ~uVar3;
	puVar7 = (undefined4 *)(pcVar5 + -uVar3);
	for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
		*param_1 = *puVar7;
		puVar7 = puVar7 + 1;
		param_1 = param_1 + 1;
	}
	for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
		*(undefined *)param_1 = *(undefined *)puVar7;
		puVar7 = (undefined4 *)((int)puVar7 + 1);
		param_1 = (undefined4 *)((int)param_1 + 1);
	}
	return;
}



undefined * std::internal::__std_FUN_00498180(undefined param_1)
{
	undefined4 in_stack_ffffffe4;
	undefined2 uVar1;
	uint local_c;
	uint local_8;
	undefined2 local_4;
	
	uVar1 = (undefined2)((uint)in_stack_ffffffe4 >> 0x10);
	__std_FUN_00498200(&local_c,(uint *)&param_1);
	DAT_0054a418 = __std_FUN_0049a470(local_c,local_8,CONCAT22(uVar1,local_4),0x11,0,&DAT_0054a3f0);
	DAT_0054a410 = (int)DAT_0054a3f2;
	DAT_0054a414 = (int)DAT_0054a3f0;
	DAT_0054a41c = &DAT_0054a3f4;
	return (undefined *)&DAT_0054a410;
}



void __cdecl std::internal::__std_FUN_00498200(uint *param_1,uint *param_2)
{
	ushort uVar1;
	uint uVar2;
	ushort uVar3;
	ushort uVar4;
	uint uVar5;
	uint uVar6;
	
	uVar6 = 0x80000000;
	uVar1 = *(ushort *)((int)param_2 + 6);
	uVar2 = *param_2;
	uVar3 = uVar1 >> 4;
	uVar4 = uVar3 & 0x7ff;
	if ((uVar3 & 0x7ff) == 0) {
		uVar6 = 0;
		if (((param_2[1] & 0xfffff) == 0) && (uVar2 == 0)) {
			param_1[1] = 0;
			*param_1 = 0;
			*(undefined2 *)(param_1 + 2) = 0;
			return;
		}
		uVar4 = 0x3c01;
	}
	else {
		if (uVar4 == 0x7ff) {
			uVar4 = 0x7fff;
		}
		else {
			uVar4 += 0x3c00;
		}
	}
	uVar5 = uVar2 >> 0x15 | (param_2[1] & 0xfffff) << 0xb | uVar6;
	param_1[1] = uVar5;
	*param_1 = uVar2 << 0xb;
	for (; uVar6 == 0; uVar6 &= 0x80000000) {
		uVar6 = uVar5 * 2;
		uVar5 = *param_1 >> 0x1f | uVar6;
		uVar4 -= 1;
		param_1[1] = uVar5;
		*param_1 = *param_1 * 2;
	}
	*(ushort *)(param_1 + 2) = uVar4 | uVar1 & 0x8000;
	return;
}



undefined4 * __cdecl
std::internal::__std_FUN_004982c0(undefined4 *param_1,undefined4 *param_2,uint param_3)
{
	undefined4 *puVar1;
	uint uVar2;
	uint uVar3;
	undefined4 *puVar4;
	
	if ((param_2 < param_1) && (param_1 < (undefined4 *)(param_3 + (int)param_2))) {
		puVar1 = (undefined4 *)((param_3 - 4) + (int)param_2);
		puVar4 = (undefined4 *)((param_3 - 4) + (int)param_1);
		if (((uint)puVar4 & 3) == 0) {
			uVar2 = param_3 >> 2;
			if (uVar2 < 8) goto LAB_00498480;
			for (; uVar2 != 0; uVar2 -= 1) {
				*puVar4 = *puVar1;
				puVar1 = puVar1 + -1;
				puVar4 = puVar4 + -1;
			}
			switch(param_3 & 3) {
			case 1:
				goto switchD_004984a4_caseD_1;
			case 2:
				goto switchD_004984a4_caseD_2;
			case 3:
				goto switchD_004984a4_caseD_3;
			}
		}
		else {
			switch(param_3) {
			case 0:
				break;
			case 1:
switchD_004984a4_caseD_1:
				*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
				return param_1;
			case 2:
switchD_004984a4_caseD_2:
				*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
				*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
				return param_1;
			case 3:
switchD_004984a4_caseD_3:
				*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
				*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
				*(undefined *)((int)puVar4 + 1) = *(undefined *)((int)puVar1 + 1);
				return param_1;
			default:
				uVar3 = param_3 - ((uint)puVar4 & 3);
				switch((uint)puVar4 & 3) {
				case 1:
					*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
					puVar1 = (undefined4 *)((int)puVar1 + -1);
					uVar2 = uVar3 >> 2;
					puVar4 = (undefined4 *)((int)puVar4 - 1);
					if (uVar2 < 8) {
LAB_00498480:
										// WARNING: Could not recover jumptable at 0x00498482. Too many branches
										// WARNING: Treating indirect jump as call
						puVar1 = (undefined4 *)(*(code *)(&PTR_LAB_00498550)[-uVar2])();
						return puVar1;
					}
					for (; uVar2 != 0; uVar2 -= 1) {
						*puVar4 = *puVar1;
						puVar1 = puVar1 + -1;
						puVar4 = puVar4 + -1;
					}
					switch(uVar3 & 3) {
					case 1:
						goto switchD_004984a4_caseD_1;
					case 2:
						goto switchD_004984a4_caseD_2;
					case 3:
						goto switchD_004984a4_caseD_3;
					}
					break;
				case 2:
					*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
					uVar2 = uVar3 >> 2;
					*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
					puVar1 = (undefined4 *)((int)puVar1 + -2);
					puVar4 = (undefined4 *)((int)puVar4 - 2);
					if (uVar2 < 8) goto LAB_00498480;
					for (; uVar2 != 0; uVar2 -= 1) {
						*puVar4 = *puVar1;
						puVar1 = puVar1 + -1;
						puVar4 = puVar4 + -1;
					}
					switch(uVar3 & 3) {
					case 1:
						goto switchD_004984a4_caseD_1;
					case 2:
						goto switchD_004984a4_caseD_2;
					case 3:
						goto switchD_004984a4_caseD_3;
					}
					break;
				case 3:
					*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
					*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
					uVar2 = uVar3 >> 2;
					*(undefined *)((int)puVar4 + 1) = *(undefined *)((int)puVar1 + 1);
					puVar1 = (undefined4 *)((int)puVar1 + -3);
					puVar4 = (undefined4 *)((int)puVar4 - 3);
					if (uVar2 < 8) goto LAB_00498480;
					for (; uVar2 != 0; uVar2 -= 1) {
						*puVar4 = *puVar1;
						puVar1 = puVar1 + -1;
						puVar4 = puVar4 + -1;
					}
					switch(uVar3 & 3) {
					case 1:
						goto switchD_004984a4_caseD_1;
					case 2:
						goto switchD_004984a4_caseD_2;
					case 3:
						goto switchD_004984a4_caseD_3;
					}
				}
			}
		}
		return param_1;
	}
	puVar1 = param_1;
	if (((uint)param_1 & 3) == 0) {
		uVar2 = param_3 >> 2;
		if (uVar2 < 8) goto LAB_0049831c;
		for (; uVar2 != 0; uVar2 -= 1) {
			*puVar1 = *param_2;
			param_2 = param_2 + 1;
			puVar1 = puVar1 + 1;
		}
		switch(param_3 & 3) {
		case 1:
			goto switchD_00498314_caseD_1;
		case 2:
			goto switchD_00498314_caseD_2;
		case 3:
			goto switchD_00498314_caseD_3;
		}
	}
	else {
		switch(param_3) {
		case 0:
			break;
		case 1:
switchD_00498314_caseD_1:
			*(undefined *)puVar1 = *(undefined *)param_2;
			return param_1;
		case 2:
switchD_00498314_caseD_2:
			*(undefined *)puVar1 = *(undefined *)param_2;
			*(undefined *)((int)puVar1 + 1) = *(undefined *)((int)param_2 + 1);
			return param_1;
		case 3:
switchD_00498314_caseD_3:
			*(undefined *)puVar1 = *(undefined *)param_2;
			*(undefined *)((int)puVar1 + 1) = *(undefined *)((int)param_2 + 1);
			*(undefined *)((int)puVar1 + 2) = *(undefined *)((int)param_2 + 2);
			return param_1;
		default:
			uVar3 = (param_3 - 4) + ((uint)param_1 & 3);
			switch((uint)param_1 & 3) {
			case 1:
				*(undefined *)param_1 = *(undefined *)param_2;
				*(undefined *)((int)param_1 + 1) = *(undefined *)((int)param_2 + 1);
				uVar2 = uVar3 >> 2;
				*(undefined *)((int)param_1 + 2) = *(undefined *)((int)param_2 + 2);
				param_2 = (undefined4 *)((int)param_2 + 3);
				puVar1 = (undefined4 *)((int)param_1 + 3);
				if (uVar2 < 8) {
LAB_0049831c:
										// WARNING: Could not recover jumptable at 0x0049831c. Too many branches
										// WARNING: Treating indirect jump as call
					puVar1 = (undefined4 *)(*(code *)(&PTR_LAB_0049839c)[uVar2])();
					return puVar1;
				}
				for (; uVar2 != 0; uVar2 -= 1) {
					*puVar1 = *param_2;
					param_2 = param_2 + 1;
					puVar1 = puVar1 + 1;
				}
				switch(uVar3 & 3) {
				case 1:
					goto switchD_00498314_caseD_1;
				case 2:
					goto switchD_00498314_caseD_2;
				case 3:
					goto switchD_00498314_caseD_3;
				}
				break;
			case 2:
				*(undefined *)param_1 = *(undefined *)param_2;
				uVar2 = uVar3 >> 2;
				*(undefined *)((int)param_1 + 1) = *(undefined *)((int)param_2 + 1);
				param_2 = (undefined4 *)((int)param_2 + 2);
				puVar1 = (undefined4 *)((int)param_1 + 2);
				if (uVar2 < 8) goto LAB_0049831c;
				for (; uVar2 != 0; uVar2 -= 1) {
					*puVar1 = *param_2;
					param_2 = param_2 + 1;
					puVar1 = puVar1 + 1;
				}
				switch(uVar3 & 3) {
				case 1:
					goto switchD_00498314_caseD_1;
				case 2:
					goto switchD_00498314_caseD_2;
				case 3:
					goto switchD_00498314_caseD_3;
				}
				break;
			case 3:
				*(undefined *)param_1 = *(undefined *)param_2;
				uVar2 = uVar3 >> 2;
				param_2 = (undefined4 *)((int)param_2 + 1);
				puVar1 = (undefined4 *)((int)param_1 + 1);
				if (uVar2 < 8) goto LAB_0049831c;
				for (; uVar2 != 0; uVar2 -= 1) {
					*puVar1 = *param_2;
					param_2 = param_2 + 1;
					puVar1 = puVar1 + 1;
				}
				switch(uVar3 & 3) {
				case 1:
					goto switchD_00498314_caseD_1;
				case 2:
					goto switchD_00498314_caseD_2;
				case 3:
					goto switchD_00498314_caseD_3;
				}
			}
		}
	}
	return param_1;
}



void std::internal::__std_FUN_00498600(void)
{
	__amsg_exit(2);
	return;
}



// WARNING: Could not reconcile some variable overlaps

undefined4 __cdecl
std::internal::__std_FUN_00498610
					(ushort *param_1,byte **param_2,byte *param_3,int param_4,int param_5,int param_6,
					int param_7)
{
	char cVar1;
	bool bVar2;
	bool bVar3;
	bool bVar4;
	bool bVar5;
	bool bVar6;
	ushort uVar7;
	int iVar8;
	uint uVar9;
	byte bVar10;
	byte *pbVar11;
	byte *pbVar12;
	uint uVar13;
	byte *pbVar14;
	int local_60;
	char *local_5c;
	uint local_54;
	byte *local_50;
	int local_4c;
	int local_48;
	undefined4 local_30;
	ushort local_2c;
	undefined2 uStack42;
	undefined2 uStack40;
	byte *local_26;
	undefined4 local_22;
	char local_1c [23];
	char local_5;
	
	local_5c = local_1c;
	iVar8 = 0;
	uVar13 = 0;
	uVar7 = 0;
	local_4c = 1;
	local_54 = 0;
	bVar2 = false;
	bVar4 = false;
	bVar3 = false;
	bVar5 = false;
	bVar6 = false;
	local_48 = 0;
	local_60 = 0;
	local_30 = 0;
	local_50 = param_3;
	for (pbVar11 = param_3;
			(((bVar10 = *pbVar11, bVar10 == 0x20 || (bVar10 == 9)) || (bVar10 == 10)) ||
			(pbVar14 = param_3, bVar10 == 0xd)); pbVar11 = pbVar11 + 1) {
	}
	do {
		bVar10 = *pbVar11;
		pbVar12 = pbVar11 + 1;
		uVar9 = (uint)bVar10;
		param_3 = (byte *)((uint)param_3 & 0xffffff00 | uVar9);
		if (true) {
			switch(iVar8) {
			case 0:
				if (('0' < (char)bVar10) && ((char)bVar10 < ':')) {
					iVar8 = 3;
					goto LAB_00498ae2;
				}
				if (bVar10 == DAT_004b0f78) {
					iVar8 = 5;
				}
				else {
					if (bVar10 == 0x2b) {
						iVar8 = 2;
						uVar7 = 0;
					}
					else {
						if (bVar10 == 0x2d) {
							iVar8 = 2;
							uVar7 = 0x8000;
						}
						else {
							if (bVar10 != 0x30) goto switchD_00498746_caseD_2c;
							iVar8 = 1;
						}
					}
				}
				break;
			case 1:
				bVar2 = true;
				if (('0' < (char)bVar10) && ((char)bVar10 < ':')) {
					iVar8 = 3;
					goto LAB_00498ae2;
				}
				if (bVar10 != DAT_004b0f78) {
					if (true) {
						switch(bVar10) {
						case 0x2b:
						case 0x2d:
							goto switchD_00498746_caseD_2b;
						case 0x30:
							goto switchD_00498746_caseD_30;
						case 0x44:
						case 0x45:
						case 100:
						case 0x65:
							goto switchD_00498746_caseD_44;
						}
					}
					goto switchD_00498746_caseD_2c;
				}
				iVar8 = 4;
				break;
			case 2:
				if (('0' < (char)bVar10) && ((char)bVar10 < ':')) {
					iVar8 = 3;
					goto LAB_00498ae2;
				}
				if (bVar10 == DAT_004b0f78) {
					iVar8 = 5;
				}
				else {
					if (bVar10 == 0x30) {
switchD_00498746_caseD_30:
						iVar8 = 1;
					}
					else {
						iVar8 = 10;
						pbVar12 = pbVar14;
					}
				}
				break;
			case 3:
				while( true ) {
					bVar2 = true;
										// int std::isdigit(int c)
					if (std::globals::_pcharwidth < 2) {
						uVar9 = *(byte *)(std::globals::_pctype + ((uint)param_3 & 0xff)) & C1_DIGIT;
					}
					else {
						uVar9 = _isctype((uint)param_3 & 0xff,C1_DIGIT);
					}
					if (uVar9 == 0) break;
					if (uVar13 < 0x19) {
						uVar13 += 1;
						*local_5c = bVar10 - 0x30;
						bVar10 = *pbVar12;
						local_5c = local_5c + 1;
						param_3 = (byte *)((uint)param_3 & 0xffffff00 | (uint)bVar10);
						pbVar12 = pbVar12 + 1;
					}
					else {
						bVar10 = *pbVar12;
						local_60 += 1;
						param_3 = (byte *)((uint)param_3 & 0xffffff00 | (uint)bVar10);
						pbVar12 = pbVar12 + 1;
					}
				}
				local_54 = uVar13;
				if (bVar10 != DAT_004b0f78) {
					if (true) {
						switch(bVar10) {
						case 0x2b:
						case 0x2d:
							goto switchD_00498746_caseD_2b;
						case 0x44:
						case 0x45:
						case 100:
						case 0x65:
							goto switchD_00498746_caseD_44;
						}
					}
					goto switchD_00498746_caseD_2c;
				}
				iVar8 = 4;
				break;
			case 4:
				bVar4 = true;
				if (uVar13 == 0) {
					while (bVar10 == 0x30) {
						bVar10 = *pbVar12;
						local_60 += -1;
						pbVar12 = pbVar12 + 1;
						param_3 = (byte *)((uint)param_3 & 0xffffff00 | (uint)bVar10);
					}
				}
				while( true ) {
					bVar2 = true;
										// int std::isdigit(int c)
					if (std::globals::_pcharwidth < 2) {
						uVar9 = *(byte *)(std::globals::_pctype + ((uint)param_3 & 0xff)) & C1_DIGIT;
					}
					else {
						uVar9 = _isctype((uint)param_3 & 0xff,C1_DIGIT);
					}
					if (uVar9 == 0) break;
					if (uVar13 < 0x19) {
						uVar13 += 1;
						*local_5c = bVar10 - 0x30;
						local_5c = local_5c + 1;
						local_60 += -1;
					}
					bVar10 = *pbVar12;
					pbVar12 = pbVar12 + 1;
					param_3 = (byte *)((uint)param_3 & 0xffffff00 | (uint)bVar10);
				}
				local_54 = uVar13;
				if (false) {
switchD_00498746_caseD_2c:
					iVar8 = 10;
					goto LAB_00498ae2;
				}
				switch(bVar10) {
				case 0x2b:
				case 0x2d:
switchD_00498746_caseD_2b:
					bVar2 = true;
					pbVar12 = pbVar12 + -1;
					iVar8 = 0xb;
					break;
				default:
					goto switchD_00498746_caseD_2c;
				case 0x44:
				case 0x45:
				case 100:
				case 0x65:
switchD_00498746_caseD_44:
					bVar2 = true;
					iVar8 = 6;
				}
				break;
			case 5:
				bVar4 = true;
										// int std::isdigit(int c)
				if (std::globals::_pcharwidth < 2) {
					uVar9 = *(byte *)(std::globals::_pctype + uVar9) & C1_DIGIT;
				}
				else {
					uVar9 = _isctype(uVar9,C1_DIGIT);
				}
				if (uVar9 == 0) {
					iVar8 = 10;
					pbVar12 = pbVar14;
				}
				else {
					iVar8 = 4;
					pbVar12 = pbVar11;
				}
				break;
			case 6:
				pbVar11 = pbVar11 + -1;
				pbVar14 = pbVar11;
				local_50 = pbVar11;
				if (('0' < (char)bVar10) && ((char)bVar10 < ':')) {
					iVar8 = 9;
					goto LAB_00498ae2;
				}
				if (bVar10 == 0x2b) {
LAB_00498ad6:
					iVar8 = 7;
					pbVar14 = pbVar11;
					local_50 = pbVar11;
				}
				else {
					if (bVar10 != 0x2d) goto LAB_004989c6;
LAB_00498ac7:
					iVar8 = 7;
					local_4c = -1;
					pbVar14 = pbVar11;
					local_50 = pbVar11;
				}
				break;
			case 7:
				if (('0' < (char)bVar10) && ((char)bVar10 < ':')) {
					iVar8 = 9;
					goto LAB_00498ae2;
				}
LAB_004989c6:
				if (bVar10 == 0x30) {
					iVar8 = 8;
				}
				else {
					iVar8 = 10;
					pbVar12 = pbVar14;
				}
				break;
			case 8:
				bVar3 = true;
				while (bVar10 == 0x30) {
					bVar10 = *pbVar12;
					pbVar12 = pbVar12 + 1;
				}
				if (((char)bVar10 < '1') || ('9' < (char)bVar10)) goto switchD_00498746_caseD_2c;
				iVar8 = 9;
LAB_00498ae2:
				pbVar12 = pbVar12 + -1;
				break;
			case 9:
				bVar3 = true;
				local_48 = 0;
				while( true ) {
										// int std::isdigit(int c)
					if (std::globals::_pcharwidth < 2) {
						uVar13 = *(byte *)(std::globals::_pctype + ((uint)param_3 & 0xff)) & C1_DIGIT;
					}
					else {
						uVar13 = _isctype((uint)param_3 & 0xff,C1_DIGIT);
					}
					if (uVar13 == 0) goto LAB_00498a4a;
					local_48 = (char)bVar10 + -0x30 + local_48 * 10;
					if (0x1450 < local_48) break;
					bVar10 = *pbVar12;
					pbVar12 = pbVar12 + 1;
					param_3 = (byte *)((uint)param_3 & 0xffffff00 | (uint)bVar10);
				}
				local_48 = 0x1451;
LAB_00498a4a:
				while( true ) {
					if (std::globals::_pcharwidth < 2) {
						uVar13 = *(byte *)(std::globals::_pctype + ((uint)param_3 & 0xff)) & 4;
					}
					else {
						uVar13 = _isctype((uint)param_3 & 0xff,4);
					}
					if (uVar13 == 0) break;
					bVar10 = *pbVar12;
					pbVar12 = pbVar12 + 1;
					param_3 = (byte *)((uint)param_3 & 0xffffff00 | (uint)bVar10);
				}
				iVar8 = 10;
				pbVar12 = pbVar12 + -1;
				uVar13 = local_54;
				pbVar14 = local_50;
				break;
			case 0xb:
				if (param_7 == 0) goto switchD_00498746_caseD_2c;
				if (bVar10 == 0x2b) goto LAB_00498ad6;
				if (bVar10 == 0x2d) goto LAB_00498ac7;
				iVar8 = 10;
				pbVar12 = pbVar11;
				pbVar14 = pbVar11;
				local_50 = pbVar11;
			}
		}
		pbVar11 = pbVar12;
	} while (iVar8 != 10);
	*param_2 = pbVar12;
	if (bVar2) {
		if (0x18 < uVar13) {
			if ('\x04' < local_5) {
				local_5 += '\x01';
			}
			local_5c = local_5c + -1;
			local_60 += 1;
			uVar13 = 0x18;
		}
		if (uVar13 == 0) {
			local_2c = 0;
			local_22._0_2_ = 0;
			param_3 = NULL;
			pbVar11 = NULL;
			goto LAB_00498bb4;
		}
		cVar1 = local_5c[-1];
		while (cVar1 == '\0') {
			uVar13 -= 1;
			local_60 += 1;
			cVar1 = local_5c[-2];
			local_5c = local_5c + -1;
		}
		__std_FUN_0049a370(local_1c,uVar13,(uint *)&local_2c);
		if (local_4c < 0) {
			local_48 = -local_48;
		}
		uVar13 = local_48 + local_60;
		if (!bVar3) {
			uVar13 += param_5;
		}
		if (!bVar4) {
			uVar13 -= param_6;
		}
		if ((int)uVar13 < 0x1451) {
			if (-0x1451 < (int)uVar13) {
				__std_FUN_0049aac0((int *)&local_2c,uVar13,param_4);
				pbVar11 = (byte *)CONCAT22(uStack40,uStack42);
				param_3 = local_26;
				goto LAB_00498bb4;
			}
			bVar6 = true;
		}
		else {
			bVar5 = true;
		}
	}
	local_2c = (ushort)param_3;
	pbVar11 = param_3;
	local_22._0_2_ = local_2c;
LAB_00498bb4:
	if (bVar2) {
		if (bVar5) {
			pbVar11 = NULL;
			local_22._0_2_ = 0x7fff;
			param_3 = (byte *)0x80000000;
			local_2c = 0;
			local_30 = 2;
		}
		else {
			if (bVar6) {
				local_2c = 0;
				local_22._0_2_ = 0;
				param_3 = NULL;
				pbVar11 = NULL;
				local_30 = 1;
			}
		}
	}
	else {
		local_2c = 0;
		local_22._0_2_ = 0;
		param_3 = NULL;
		pbVar11 = NULL;
		local_30 = 4;
	}
	*param_1 = local_2c;
	*(byte **)(param_1 + 1) = pbVar11;
	*(byte **)(param_1 + 3) = param_3;
	param_1[5] = (ushort)local_22 | uVar7;
	return local_30;
}



void __cdecl std::internal::__fileunk__00498da0(FILE *file)
{
	char *pcVar1;
	
	globals::__unkCount_0054a3e4 += 1;
	pcVar1 = (char *)malloc(0x1000);
	file->_base = pcVar1;
	if (pcVar1 != NULL) {
		file->_flag = file->_flag | 8;
		file->_bufsiz = 0x1000;
		file->_ptr = file->_base;
		file->_cnt = 0;
		return;
	}
	file->_bufsiz = 2;
	file->_flag = file->_flag | 4;
	file->_base = (char *)&file->_charbuf;
	file->_ptr = (char *)&file->_charbuf;
	file->_cnt = 0;
	return;
}



BOOL __cdecl std::internal::__std_FUN_00498e00(uint fd)
{
	if (globals::__UINT_0076eec0 <= fd) {
		return 0;
	}
	return *(byte *)((&DAT_0076edc0)[(int)fd >> 5] + 4 + (fd & 0x1f) * 8) & 0x40;
}



LPSTR __cdecl std::internal::__vfprintf__00498e30(LPSTR param_1,ushort param_2)
{
	LPSTR pCVar1;
	
	pCVar1 = param_1;
	if (param_1 == NULL) {
		return param_1;
	}
	if (DAT_0054a180 == 0) {
		if (param_2 < 0x100) {
			*param_1 = (CHAR)param_2;
			return (LPSTR)0x1;
		}
	}
	else {
		param_1 = NULL;
		pCVar1 = (LPSTR)WideCharToMultiByte(DAT_0054a190,0x220,(LPCWSTR)&param_2,1,pCVar1,
																				std::globals::_pcharwidth,NULL,(LPBOOL)&param_1);
		if ((pCVar1 != NULL) && (param_1 == NULL)) {
			return pCVar1;
		}
	}
	std::globals::g_msvc_errno = 0x2a;
	return (LPSTR)0xffffffff;
}



// Library Function - Single Match
// Name: __aulldiv
// Library: Visual Studio

undefined8 std::internal::__aulldiv(uint param_1,uint param_2,uint param_3,uint param_4)
{
	ulonglong uVar1;
	longlong lVar2;
	uint uVar3;
	int iVar4;
	uint uVar5;
	uint uVar6;
	uint uVar7;
	uint uVar8;
	uint uVar9;
	
	uVar3 = param_1;
	uVar8 = param_4;
	uVar6 = param_2;
	uVar9 = param_3;
	if (param_4 == 0) {
		uVar3 = param_2 / param_3;
		iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
								 (ulonglong)param_3);
	}
	else {
		do {
			uVar5 = uVar8 >> 1;
			uVar9 = uVar9 >> 1 | (uint)((uVar8 & 1) != 0) << 0x1f;
			uVar7 = uVar6 >> 1;
			uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
			uVar8 = uVar5;
			uVar6 = uVar7;
		} while (uVar5 != 0);
		uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar9;
		iVar4 = (int)uVar1;
		lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
		uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
		uVar8 = uVar3 + iVar4 * param_4;
		if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar8)) ||
			 ((param_2 <= uVar8 && (param_1 < (uint)lVar2)))) {
			iVar4 += -1;
		}
		uVar3 = 0;
	}
	return CONCAT44(uVar3,iVar4);
}



// Library Function - Single Match
// Name: __aullrem
// Library: Visual Studio

undefined8 std::internal::__aullrem(uint param_1,uint param_2,uint param_3,uint param_4)
{
	ulonglong uVar1;
	longlong lVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	int iVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	bool bVar11;
	
	uVar3 = param_1;
	uVar4 = param_4;
	uVar9 = param_2;
	uVar10 = param_3;
	if (param_4 == 0) {
		iVar6 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) %
								 (ulonglong)param_3);
		iVar7 = 0;
	}
	else {
		do {
			uVar5 = uVar4 >> 1;
			uVar10 = uVar10 >> 1 | (uint)((uVar4 & 1) != 0) << 0x1f;
			uVar8 = uVar9 >> 1;
			uVar3 = uVar3 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
			uVar4 = uVar5;
			uVar9 = uVar8;
		} while (uVar5 != 0);
		uVar1 = CONCAT44(uVar8,uVar3) / (ulonglong)uVar10;
		uVar3 = (int)uVar1 * param_4;
		lVar2 = (uVar1 & 0xffffffff) * (ulonglong)param_3;
		uVar9 = (uint)((ulonglong)lVar2 >> 0x20);
		uVar4 = (uint)lVar2;
		uVar10 = uVar9 + uVar3;
		if (((CARRY4(uVar9,uVar3)) || (param_2 < uVar10)) || ((param_2 <= uVar10 && (param_1 < uVar4))))
		{
			bVar11 = uVar4 < param_3;
			uVar4 -= param_3;
			uVar10 = (uVar10 - param_4) - (uint)bVar11;
		}
		iVar6 = -(uVar4 - param_1);
		iVar7 = -(uint)(uVar4 - param_1 != 0) - ((uVar10 - param_2) - (uint)(uVar4 < param_1));
	}
	return CONCAT44(iVar7,iVar6);
}



void __cdecl std::internal::__std_FUN_00498fa0(uint param_1,int *param_2,ushort *param_3)
{
	uint uVar1;
	int iVar2;
	uint uVar3;
	uint local_58 [10];
	int local_30;
	int local_2c;
	uint local_20;
	
	param_3 = (ushort *)(uint)*param_3;
	if (false) goto switchD_00498fbf_caseD_6;
	switch(*param_2) {
	case 1:
	case 5:
		uVar3 = 8;
		break;
	case 2:
		uVar3 = 4;
		break;
	case 3:
		uVar3 = 0x11;
		break;
	case 4:
		uVar3 = 0x12;
		break;
	default:
		goto switchD_00498fbf_caseD_6;
	case 7:
		*param_2 = 1;
		goto switchD_00498fbf_caseD_6;
	case 8:
		uVar3 = 0x10;
	}
	uVar1 = __std_FUN_00493880(uVar3,(double *)(param_2 + 6),(uint)param_3);
	if (uVar1 == 0) {
		if (((param_1 == 0x10) || (param_1 == 0x16)) || (param_1 == 0x1d)) {
			local_30 = param_2[4];
			local_20 = local_20 & 0xffffffe3 | 3;
			local_2c = param_2[5];
		}
		else {
			local_20 &= 0xfffffffe;
		}
		__std_FUN_00493540(local_58,(uint *)&param_3,(byte)uVar3,param_1,(uint *)(param_2 + 2),
											 (uint *)(param_2 + 6));
	}
switchD_00498fbf_caseD_6:
	_control87((uint)param_3,0xffff);
	iVar2 = 0;
	if ((*param_2 != 8) && (DAT_004b38e0 == 0)) {
		iVar2 = lego::nerps::funcs::NERPFunc__False(param_2);
	}
	if (iVar2 == 0) {
		__std_FUN_00493c60(*param_2);
	}
	return;
}



uint __cdecl std::internal::__vfscanf__004990c0(ushort *param_1,byte *param_2,uint param_3)
{
	byte bVar1;
	int iVar2;
	
	if ((param_2 != NULL) && (param_3 != 0)) {
		bVar1 = *param_2;
		if (bVar1 != 0) {
			if (DAT_0054a180 == 0) {
				if (param_1 == NULL) {
					return 1;
				}
				*param_1 = (ushort)bVar1;
				return 1;
			}
			if ((*(byte *)((int)std::globals::_pctype + (uint)bVar1 * 2 + 1) & 0x80) == 0) {
				iVar2 = MultiByteToWideChar(DAT_0054a190,9,(LPCSTR)param_2,1,(LPWSTR)param_1,
																		(uint)(param_1 != NULL));
				if (iVar2 != 0) {
					return 1;
				}
				std::globals::g_msvc_errno = 0x2a;
				return 0xffffffff;
			}
			if (((1 < std::globals::_pcharwidth) && (std::globals::_pcharwidth <= (int)param_3)) &&
				 (iVar2 = MultiByteToWideChar(DAT_0054a190,9,(LPCSTR)param_2,std::globals::_pcharwidth,
																			(LPWSTR)param_1,(uint)(param_1 != NULL)), iVar2 != 0)) {
				return std::globals::_pcharwidth;
			}
			if (param_3 < (uint)std::globals::_pcharwidth) {
				std::globals::g_msvc_errno = 0x2a;
				return 0xffffffff;
			}
			if (param_2[1] != 0) {
				return std::globals::_pcharwidth;
			}
			std::globals::g_msvc_errno = 0x2a;
			return 0xffffffff;
		}
		if (param_1 != NULL) {
			*param_1 = 0;
			return 0;
		}
	}
	return 0;
}



int __cdecl std::isspace(int c)
{
	uint uVar1;
	
	if (1 < globals::_pcharwidth) {
										// C1_SPACE (0x8)
		uVar1 = _isctype(c,C1_SPACE);
		return uVar1;
	}
										// C1_SPACE (0x8)
	return *(byte *)(globals::_pctype + c) & C1_SPACE;
}



// Library Function - Single Match
// Name: __allshl
// Library: Visual Studio

longlong __fastcall std::internal::__allshl(byte param_1,int param_2)
{
	uint in_EAX;
	
	if (0x3f < param_1) {
		return 0;
	}
	if (param_1 < 0x20) {
		return CONCAT44(param_2 << (param_1 & 0x1f) | in_EAX >> 0x20 - (param_1 & 0x1f),
										in_EAX << (param_1 & 0x1f));
	}
	return (ulonglong)(in_EAX << (param_1 & 0x1f)) << 0x20;
}



int __cdecl std::internal::__vfscanf__00499210(int c,FILE *file)
{
	uint uVar1;
	char *pcVar2;
	char *pcVar3;
	
	if ((c != -1) &&
		 ((uVar1 = file->_flag, (uVar1 & 1) != 0 || (((uVar1 & 0x80) != 0 && ((uVar1 & 2) == 0)))))) {
		if (file->_base == NULL) {
			__fileunk__00498da0(file);
		}
		if (file->_ptr == file->_base) {
			if (file->_cnt != 0) {
				return 0xffffffff;
			}
			file->_ptr = file->_ptr + 1;
		}
		if ((*(byte *)&file->_flag & 0x40) == 0) {
			pcVar2 = file->_ptr;
			file->_ptr = pcVar2 + -1;
			pcVar2[-1] = (char)c;
		}
		else {
			pcVar2 = file->_ptr;
			pcVar3 = pcVar2 + -1;
			file->_ptr = pcVar3;
			if (*pcVar3 != (char)c) {
				file->_ptr = pcVar2;
				return 0xffffffff;
			}
		}
		file->_cnt = file->_cnt + 1;
		file->_flag = file->_flag & 0xffffffefU | 1;
		return c & 0xff;
	}
	return 0xffffffff;
}



int std::internal::__std_FUN_004992a0(void)
{
	undefined4 *puVar1;
	undefined4 *puVar2;
	int *piVar3;
	int iVar4;
	int iVar5;
	int iVar6;
	
	iVar4 = -1;
	iVar5 = 0;
	iVar6 = 0;
	piVar3 = &DAT_0076edc0;
	do {
		puVar2 = (undefined4 *)*piVar3;
		if (puVar2 == NULL) {
			puVar2 = (undefined4 *)malloc(0x100);
			if (puVar2 != NULL) {
				globals::__UINT_0076eec0 += 0x20;
				(&DAT_0076edc0)[iVar5] = puVar2;
				if (puVar2 < puVar2 + 0x40) {
					do {
						*(undefined *)(puVar2 + 1) = 0;
						*puVar2 = 0xffffffff;
						*(undefined *)((int)puVar2 + 5) = 10;
						puVar2 = puVar2 + 2;
					} while (puVar2 < (undefined4 *)((&DAT_0076edc0)[iVar5] + 0x100));
				}
				iVar4 = iVar5 << 5;
			}
			return iVar4;
		}
		puVar1 = puVar2 + 0x40;
		for (; puVar2 < puVar1; puVar2 = puVar2 + 2) {
			if ((*(byte *)(puVar2 + 1) & 1) == 0) {
				*puVar2 = 0xffffffff;
				iVar4 = ((int)((int)puVar2 - *piVar3) >> 3) + iVar6;
				break;
			}
		}
		if (iVar4 != -1) {
			return iVar4;
		}
		piVar3 = piVar3 + 1;
		iVar5 += 1;
		iVar6 += 0x20;
		if (0x76eebf < (int)piVar3) {
			return -1;
		}
	} while( true );
}



undefined4 __cdecl std::internal::__std_FUN_00499360(uint param_1,HANDLE param_2)
{
	int *piVar1;
	int iVar2;
	
	if (param_1 < globals::__UINT_0076eec0) {
		piVar1 = &DAT_0076edc0 + ((int)param_1 >> 5);
		iVar2 = (param_1 & 0x1f) * 8;
		if (*(int *)((&DAT_0076edc0)[(int)param_1 >> 5] + iVar2) == -1) {
			if (DAT_004b0d64 == 1) {
				if (param_1 == 0) {
					SetStdHandle(0xfffffff6,param_2);
				}
				else {
					if (param_1 == 1) {
						SetStdHandle(0xfffffff5,param_2);
						*(HANDLE *)(*piVar1 + iVar2) = param_2;
						return 0;
					}
					if (param_1 == 2) {
						SetStdHandle(0xfffffff4,param_2);
						*(HANDLE *)(*piVar1 + iVar2) = param_2;
						return 0;
					}
				}
			}
			*(HANDLE *)(*piVar1 + iVar2) = param_2;
			return 0;
		}
	}
	std::globals::g_msvc_errno = 9;
	std::globals::g_msvc_doserrno = 0;
	return 0xffffffff;
}



int __cdecl std::internal::__fdclose__00499410(uint fd)
{
	int iVar1;
	DWORD nStdHandle;
	
	if (fd < globals::__UINT_0076eec0) {
		iVar1 = (fd & 0x1f) * 8;
		if (((*(byte *)((&DAT_0076edc0)[(int)fd >> 5] + 4 + iVar1) & 1) != 0) &&
			 (*(int *)((&DAT_0076edc0)[(int)fd >> 5] + iVar1) != -1)) {
			if (DAT_004b0d64 == 1) {
				if (fd == 0) {
					nStdHandle = STD_INPUT_HANDLE;
				}
				else {
					if (fd == 1) {
						nStdHandle = STD_OUTPUT_HANDLE;
					}
					else {
						if (fd != 2) goto LAB_0049947a;
						nStdHandle = STD_ERROR_HANDLE;
					}
				}
				SetStdHandle(nStdHandle,NULL);
			}
LAB_0049947a:
			*(undefined4 *)((&DAT_0076edc0)[(int)fd >> 5] + iVar1) = 0xffffffff;
			return 0;
		}
	}
	std::globals::g_msvc_errno = 9;
	std::globals::g_msvc_doserrno = 0;
	return -1;
}



int __cdecl std::internal::__fdunk__004994b0(uint fd)
{
	if ((fd < globals::__UINT_0076eec0) &&
		 ((*(byte *)((&DAT_0076edc0)[(int)fd >> 5] + 4 + (fd & 0x1f) * 8) & 1) != 0)) {
		return *(int *)((&DAT_0076edc0)[(int)fd >> 5] + (fd & 0x1f) * 8);
	}
	std::globals::g_msvc_errno = 9;
	std::globals::g_msvc_doserrno = 0;
	return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __cdecl
std::internal::__fsopen__00499500(LPCSTR filename,uint param_2,uint shflag,undefined4 param_4)
{
	uint uVar1;
	HANDLE hFile;
	char *pcVar2;
	int iVar3;
	DWORD DVar4;
	DWORD dwCreationDisposition;
	DWORD dwFlagsAndAttributes;
	int iVar5;
	bool bVar6;
	byte local_11;
	uint local_10;
	_SECURITY_ATTRIBUTES local_c;
	
	bVar6 = (param_2 & 0x80) == 0;
	local_c.nLength = 0xc;
	local_c.lpSecurityDescriptor = NULL;
	if (bVar6) {
		local_11 = 0;
	}
	else {
		local_11 = 0x10;
	}
	local_c.bInheritHandle = ZEXT14(bVar6);
	if (((param_2 & 0x8000) == 0) && (((param_2 & 0x4000) != 0 || (_DAT_0054a4f4 != 0x8000)))) {
		local_11 |= 0x80;
	}
	uVar1 = param_2 & 3;
	if (uVar1 == 0) {
		local_10 = 0x80000000;
	}
	else {
		if (uVar1 == 1) {
			local_10 = 0x40000000;
		}
		else {
			if (uVar1 != 2) {
				std::globals::g_msvc_errno = 0x16;
				std::globals::g_msvc_doserrno = 0;
				return 0xffffffff;
			}
			local_10 = 0xc0000000;
		}
	}
	if (false) {
switchD_00499598_caseD_11:
		std::globals::g_msvc_errno = 0x16;
		std::globals::g_msvc_doserrno = 0;
		return 0xffffffff;
	}
	switch(shflag) {
	case 0x10:
		DVar4 = 0;
		break;
	default:
		goto switchD_00499598_caseD_11;
	case 0x20:
		DVar4 = 1;
		break;
	case 0x30:
		DVar4 = 2;
		break;
	case 0x40:
		DVar4 = 3;
	}
	uVar1 = param_2 & 0x700;
	if (uVar1 < 0x101) {
		if (uVar1 == 0x100) {
			dwCreationDisposition = 4;
			goto LAB_0049962b;
		}
		if (uVar1 != 0) {
			std::globals::g_msvc_errno = 0x16;
			std::globals::g_msvc_doserrno = 0;
			return 0xffffffff;
		}
LAB_00499606:
		dwCreationDisposition = 3;
		goto LAB_0049962b;
	}
	if (uVar1 < 0x301) {
		if (uVar1 == 0x300) {
			dwCreationDisposition = 2;
			goto LAB_0049962b;
		}
		if (uVar1 != 0x200) {
			std::globals::g_msvc_errno = 0x16;
			std::globals::g_msvc_doserrno = 0;
			return 0xffffffff;
		}
LAB_00499626:
		dwCreationDisposition = 5;
	}
	else {
		if (uVar1 < 0x501) {
			if (uVar1 != 0x500) {
				if (uVar1 != 0x400) {
					std::globals::g_msvc_errno = 0x16;
					std::globals::g_msvc_doserrno = 0;
					return 0xffffffff;
				}
				goto LAB_00499606;
			}
		}
		else {
			if (uVar1 == 0x600) goto LAB_00499626;
			if (uVar1 != 0x700) {
				std::globals::g_msvc_errno = 0x16;
				std::globals::g_msvc_doserrno = 0;
				return 0xffffffff;
			}
		}
		dwCreationDisposition = 1;
	}
LAB_0049962b:
	dwFlagsAndAttributes = 0x80;
	if (((param_2 & 0x100) != 0) && (((byte)param_4 & ~(byte)DAT_0054a0d8 & 0x80) == 0)) {
		dwFlagsAndAttributes = 1;
	}
	if ((param_2 & 0x40) != 0) {
		dwFlagsAndAttributes |= 0x4000000;
		local_10 |= 0x10000;
	}
	if ((param_2 & 0x1000) != 0) {
		dwFlagsAndAttributes |= 0x100;
	}
	if ((param_2 & 0x20) == 0) {
		if ((param_2 & 0x10) != 0) {
			dwFlagsAndAttributes |= 0x10000000;
		}
	}
	else {
		dwFlagsAndAttributes |= 0x8000000;
	}
	uVar1 = __std_FUN_004992a0();
	if (uVar1 == 0xffffffff) {
		std::globals::g_msvc_errno = 0x18;
		std::globals::g_msvc_doserrno = 0;
		return 0xffffffff;
	}
	hFile = CreateFileA(filename,local_10,DVar4,(LPSECURITY_ATTRIBUTES)&local_c,dwCreationDisposition,
											dwFlagsAndAttributes,NULL);
	if (hFile == (HANDLE)0xffffffff) {
		DVar4 = GetLastError();
		__set_doserrno(DVar4);
		return 0xffffffff;
	}
	DVar4 = GetFileType(hFile);
	if (DVar4 == 0) {
		CloseHandle(hFile);
		DVar4 = GetLastError();
		__set_doserrno(DVar4);
		return 0xffffffff;
	}
	if (DVar4 == 2) {
		local_11 |= 0x40;
	}
	else {
		if (DVar4 == 3) {
			local_11 |= 8;
		}
	}
	__std_FUN_00499360(uVar1,hFile);
	iVar5 = (uVar1 & 0x1f) * 8;
	*(byte *)(iVar5 + 4 + (&DAT_0076edc0)[(int)uVar1 >> 5]) = local_11 | 1;
	if ((((local_11 & 0x48) == 0) && ((local_11 & 0x80) != 0)) && ((param_2 & 2) != 0)) {
		DVar4 = __fdread__00496ec0(uVar1,-1,2);
		if (DVar4 == 0xffffffff) {
			if (std::globals::g_msvc_doserrno != 0x83) {
				__fdclose__00494fd0(uVar1);
				return 0xffffffff;
			}
		}
		else {
			shflag &= 0xffffff00;
			pcVar2 = __fdread(uVar1,(char *)&shflag,1);
			if (((pcVar2 == NULL) && ((char)shflag == '\x1a')) &&
				 (iVar3 = __fsunk__0049ab50((char)uVar1), iVar3 == -1)) {
				__fdclose__00494fd0(uVar1);
				return 0xffffffff;
			}
			DVar4 = __fdread__00496ec0(uVar1,0,0);
			if (DVar4 == 0xffffffff) {
				__fdclose__00494fd0(uVar1);
				return 0xffffffff;
			}
		}
	}
	if (((local_11 & 0x48) == 0) && ((param_2 & 8) != 0)) {
		*(byte *)(iVar5 + 4 + (&DAT_0076edc0)[(int)uVar1 >> 5]) =
				 *(byte *)(iVar5 + 4 + (&DAT_0076edc0)[(int)uVar1 >> 5]) | 0x20;
	}
	return uVar1;
}



void std::internal::__std_FUN_00499920(void)
{
	DAT_0054a424 = SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)&LAB_004998c0);
	return;
}



void std::internal::__std_FUN_00499940(void)
{
	SetUnhandledExceptionFilter(DAT_0054a424);
	return;
}



uint __cdecl std::internal::__std_FUN_00499950(void *param_1,UINT_PTR param_2)
{
	BOOL BVar1;
	
	BVar1 = IsBadReadPtr(param_1,param_2);
	return (uint)(BVar1 == 0);
}



uint __cdecl std::internal::__std_FUN_00499970(LPVOID param_1,UINT_PTR param_2)
{
	BOOL BVar1;
	
	BVar1 = IsBadWritePtr(param_1,param_2);
	return (uint)(BVar1 == 0);
}



uint __cdecl std::internal::__std_FUN_00499990(FARPROC param_1)
{
	BOOL BVar1;
	
	BVar1 = IsBadCodePtr(param_1);
	return (uint)(BVar1 == 0);
}



// Library Function - Single Match
// Name: _abort
// Library: Visual Studio 1998 Release

void __cdecl std::abort(void)
{
	internal::__std_FUN_00496bb0(10);
	internal::__std_FUN_0049acd0(0x16);
	quick_exit(3);
	return;
}



int __cdecl std::internal::__unkftime__004999d0(short *param_1)
{
	short sVar1;
	short *psVar2;
	
	sVar1 = *param_1;
	psVar2 = param_1 + 1;
	while (sVar1 != 0) {
		sVar1 = *psVar2;
		psVar2 = psVar2 + 1;
	}
	return ((int)((int)psVar2 - (int)param_1) >> 1) + -1;
}



int __cdecl
std::internal::__std_FUN_004999f0(undefined4 param_1,undefined4 param_2,undefined4 param_3)
{
	HMODULE hModule;
	int iVar1;
	
	iVar1 = 0;
	if (DAT_0054a428 != NULL) {
LAB_00499a40:
		if (DAT_0054a42c != NULL) {
			iVar1 = (*DAT_0054a42c)();
		}
		if ((iVar1 != 0) && (DAT_0054a430 != NULL)) {
			iVar1 = (*DAT_0054a430)(iVar1);
		}
		iVar1 = (*DAT_0054a428)(iVar1,param_1,param_2,param_3);
		return iVar1;
	}
	hModule = LoadLibraryA("user32.dll");
	if (hModule != NULL) {
		DAT_0054a428 = GetProcAddress(hModule,"MessageBoxA");
		if (DAT_0054a428 != NULL) {
			DAT_0054a42c = GetProcAddress(hModule,"GetActiveWindow");
			DAT_0054a430 = GetProcAddress(hModule,"GetLastActivePopup");
			goto LAB_00499a40;
		}
	}
	return 0;
}



int * __cdecl std::internal::__std_FUN_00499a80(int param_1,int param_2)
{
	BOOL BVar1;
	uint uVar2;
	int *piVar3;
	uint dwBytes;
	int *piVar4;
	
	dwBytes = param_2 * param_1;
	if (dwBytes < 0xffffffe1) {
		if (dwBytes == 0) {
			dwBytes = 0x10;
		}
		else {
			dwBytes = dwBytes + 0xf & 0xfffffff0;
		}
	}
	do {
		piVar3 = NULL;
		if (dwBytes < 0xffffffe1) {
			if (UINT_004b2fdc < dwBytes) {
LAB_00499ae0:
				if (piVar3 != NULL) {
					return piVar3;
				}
			}
			else {
				piVar3 = __malloc__00491bc0((int *)(dwBytes >> 4));
				if (piVar3 != NULL) {
					piVar4 = piVar3;
					for (uVar2 = dwBytes >> 2; uVar2 != 0; uVar2 -= 1) {
						*piVar4 = 0;
						piVar4 = piVar4 + 1;
					}
					for (uVar2 = dwBytes & 3; uVar2 != 0; uVar2 -= 1) {
						*(undefined *)piVar4 = 0;
						piVar4 = (int *)((int)piVar4 + 1);
					}
					goto LAB_00499ae0;
				}
			}
			piVar3 = (int *)HeapAlloc(DAT_0076eec4,8,dwBytes);
		}
		if ((piVar3 != NULL) || (globals::__g_malloc_handlermode == 0)) {
			return piVar3;
		}
		BVar1 = __call_new_handler(dwBytes);
		if (BVar1 == 0) {
			return NULL;
		}
	} while( true );
}



void std::internal::__unkftime__00499b20(void)
{
	if (DAT_0054a4f0 == 0) {
		__unkftime__00499b40();
		DAT_0054a4f0 += 1;
	}
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void std::internal::__unkftime__00499b40(void)
{
	byte bVar1;
	byte bVar2;
	byte *pbVar3;
	DWORD DVar4;
	int iVar5;
	uint uVar6;
	uint uVar7;
	byte *pbVar8;
	undefined4 *puVar9;
	byte *pbVar10;
	undefined4 *puVar11;
	bool bVar12;
	
	DAT_0054a438 = 0;
	_DAT_004b3998 = 0xffffffff;
	DAT_004b3988 = 0xffffffff;
	pbVar3 = __unkftime__0049b0d0((byte *)"TZ");
	if (pbVar3 == NULL) {
		DVar4 = GetTimeZoneInformation((LPTIME_ZONE_INFORMATION)&lpTimeZoneInformation_0054a440);
		if (DVar4 != 0xffffffff) {
			DAT_0054a438 = 1;
			DAT_004b38f0 = (int)lpTimeZoneInformation_0054a440 * 0x3c;
			if (DAT_0054a486 != 0) {
				DAT_004b38f0 += DAT_0054a494 * 0x3c;
			}
			if ((DAT_0054a4da == 0) || (DAT_0054a4e8 == 0)) {
				DAT_004b38f4 = 0;
				DAT_004b38f8 = 0;
			}
			else {
				DAT_004b38f4 = 1;
				DAT_004b38f8 = (DAT_0054a4e8 - DAT_0054a494) * 0x3c;
			}
			__unkftime__0049aea0(PTR_DAT_004b3980,(ushort *)&DAT_0054a444,0x40);
			__unkftime__0049aea0(PTR_DAT_004b3984,(ushort *)&DAT_0054a498,0x40);
			PTR_DAT_004b3984[0x3f] = 0;
			PTR_DAT_004b3980[0x3f] = 0;
			return;
		}
	}
	else {
		if (*pbVar3 != 0) {
			pbVar8 = pbVar3;
			puVar9 = DAT_0054a4ec;
			if (DAT_0054a4ec != NULL) {
				do {
					bVar1 = *pbVar8;
					bVar12 = bVar1 < *(byte *)puVar9;
					if (bVar1 != *(byte *)puVar9) {
LAB_00499c83:
						iVar5 = (1 - (uint)bVar12) - (uint)(bVar12 != 0);
						goto LAB_00499c88;
					}
					if (bVar1 == 0) break;
					bVar1 = pbVar8[1];
					bVar12 = bVar1 < *(byte *)((int)puVar9 + 1);
					if (bVar1 != *(byte *)((int)puVar9 + 1)) goto LAB_00499c83;
					pbVar8 = pbVar8 + 2;
					puVar9 = (undefined4 *)((int)puVar9 + 2);
				} while (bVar1 != 0);
				iVar5 = 0;
LAB_00499c88:
				if (iVar5 == 0) {
					return;
				}
			}
			free(DAT_0054a4ec);
			uVar6 = 0xffffffff;
			pbVar8 = pbVar3;
			do {
				if (uVar6 == 0) break;
				uVar6 -= 1;
				bVar1 = *pbVar8;
				pbVar8 = pbVar8 + 1;
			} while (bVar1 != 0);
			DAT_0054a4ec = (undefined4 *)malloc(~uVar6);
			if (DAT_0054a4ec != NULL) {
				uVar6 = 0xffffffff;
				pbVar8 = pbVar3;
				do {
					pbVar10 = pbVar8;
					if (uVar6 == 0) break;
					uVar6 -= 1;
					pbVar10 = pbVar8 + 1;
					bVar1 = *pbVar8;
					pbVar8 = pbVar10;
				} while (bVar1 != 0);
				uVar6 = ~uVar6;
				puVar9 = (undefined4 *)(pbVar10 + -uVar6);
				puVar11 = DAT_0054a4ec;
				for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 -= 1) {
					*puVar11 = *puVar9;
					puVar9 = puVar9 + 1;
					puVar11 = puVar11 + 1;
				}
				for (uVar6 &= 3; uVar6 != 0; uVar6 -= 1) {
					*(undefined *)puVar11 = *(undefined *)puVar9;
					puVar9 = (undefined4 *)((int)puVar9 + 1);
					puVar11 = (undefined4 *)((int)puVar11 + 1);
				}
				_strncpy(PTR_DAT_004b3980,(char *)pbVar3,3);
				pbVar8 = pbVar3 + 3;
				PTR_DAT_004b3980[3] = 0;
				bVar1 = *pbVar8;
				if (bVar1 == 0x2d) {
					pbVar8 = pbVar3 + 4;
				}
				iVar5 = __atoi_internal((char *)pbVar8);
				DAT_004b38f0 = iVar5 * 0xe10;
				for (; (bVar2 = *pbVar8, bVar2 == 0x2b || (('/' < (char)bVar2 && ((char)bVar2 < ':'))));
						pbVar8 = pbVar8 + 1) {
				}
				if (*pbVar8 == 0x3a) {
					pbVar8 = pbVar8 + 1;
					iVar5 = __atoi_internal((char *)pbVar8);
					DAT_004b38f0 += iVar5 * 0x3c;
					bVar2 = *pbVar8;
					while (('/' < (char)bVar2 && ((char)bVar2 < ':'))) {
						pbVar3 = pbVar8 + 1;
						pbVar8 = pbVar8 + 1;
						bVar2 = *pbVar3;
					}
					if (*pbVar8 == 0x3a) {
						pbVar8 = pbVar8 + 1;
						iVar5 = __atoi_internal((char *)pbVar8);
						DAT_004b38f0 += iVar5;
						bVar2 = *pbVar8;
						while (('/' < (char)bVar2 && ((char)bVar2 < ':'))) {
							pbVar3 = pbVar8 + 1;
							pbVar8 = pbVar8 + 1;
							bVar2 = *pbVar3;
						}
					}
				}
				if (bVar1 == 0x2d) {
					DAT_004b38f0 = -DAT_004b38f0;
				}
				DAT_004b38f4 = (int)(char)*pbVar8;
				if (DAT_004b38f4 != 0) {
					_strncpy(PTR_DAT_004b3984,(char *)pbVar8,3);
					PTR_DAT_004b3984[3] = 0;
					return;
				}
				*PTR_DAT_004b3984 = 0;
			}
		}
	}
	return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __cdecl std::internal::__unkftime__00499df0(int *param_1)
{
	uint uVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	uint uVar5;
	int iVar6;
	uint uVar7;
	uint uVar8;
	uint uVar9;
	uint uVar10;
	uint uVar11;
	
	if (DAT_004b38f4 == 0) {
		return 0;
	}
	uVar7 = param_1[5];
	if ((uVar7 == DAT_004b3988) && (uVar7 == _DAT_004b3998)) goto LAB_00499fc4;
	if (DAT_0054a438 == 0) {
		__unkftime__0049a060(1,1,uVar7,4,1,0,0,2,0,0,0);
		uVar7 = param_1[5];
		uVar11 = 0;
		uVar3 = 0;
		uVar10 = 0;
		uVar4 = 2;
		uVar1 = 0;
		uVar9 = 5;
		uVar8 = 10;
LAB_00499fb8:
		uVar5 = 0;
		iVar6 = 1;
	}
	else {
		if (_DAT_0054a4d8 != 0) {
			uVar10 = (uint)DAT_0054a4dc._2_2_;
			uVar3 = 0;
			uVar1 = 0;
		}
		else {
			uVar3 = DAT_0054a4dc & 0xffff;
			uVar10 = 0;
			uVar1 = (uint)DAT_0054a4dc._2_2_;
		}
		__unkftime__0049a060
							(1,(uint)(_DAT_0054a4d8 == 0),uVar7,(uint)DAT_0054a4da,uVar1,uVar3,uVar10,
							 _DAT_0054a4e0 & 0xffff,_DAT_0054a4e0 >> 0x10,DAT_0054a4e4 & 0xffff,
							 DAT_0054a4e4 >> 0x10);
		if (_DAT_0054a484 == 0) {
			uVar11 = (uint)DAT_0054a490._2_2_;
			uVar3 = DAT_0054a490 & 0xffff;
			uVar10 = (uint)DAT_0054a48c._2_2_;
			uVar4 = DAT_0054a48c & 0xffff;
			uVar1 = DAT_0054a488 & 0xffff;
			uVar9 = (uint)DAT_0054a488._2_2_;
			uVar8 = (uint)DAT_0054a486;
			uVar7 = param_1[5];
			goto LAB_00499fb8;
		}
		uVar11 = (uint)DAT_0054a490._2_2_;
		uVar3 = DAT_0054a490 & 0xffff;
		uVar10 = (uint)DAT_0054a48c._2_2_;
		uVar5 = (uint)DAT_0054a488._2_2_;
		uVar4 = DAT_0054a48c & 0xffff;
		uVar7 = param_1[5];
		uVar8 = (uint)DAT_0054a486;
		uVar1 = 0;
		uVar9 = 0;
		iVar6 = 0;
	}
	__unkftime__0049a060(0,iVar6,uVar7,uVar8,uVar9,uVar1,uVar5,uVar4,uVar10,uVar3,uVar11);
LAB_00499fc4:
	iVar6 = param_1[7];
	if (DAT_004b398c < DAT_004b399c) {
		if ((iVar6 < DAT_004b398c) || (DAT_004b399c < iVar6)) {
			return 0;
		}
		if ((DAT_004b398c < iVar6) && (iVar6 < DAT_004b399c)) {
			return 1;
		}
	}
	else {
		if ((iVar6 < DAT_004b399c) || (DAT_004b398c < iVar6)) {
			return 1;
		}
		if ((DAT_004b399c < iVar6) && (iVar6 < DAT_004b398c)) {
			return 0;
		}
	}
	iVar2 = (*param_1 + (param_1[1] + param_1[2] * 0x3c) * 0x3c) * 1000;
	if (iVar6 != DAT_004b398c) {
		return (uint)(iVar2 < DAT_004b39a0);
	}
	return (uint)(DAT_004b3990 <= iVar2);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl
std::internal::__unkftime__0049a060
					(int param_1,int param_2,uint param_3,int param_4,int param_5,int param_6,int param_7,
					int param_8,int param_9,int param_10,int param_11)
{
	int iVar1;
	int iVar2;
	
	if (param_2 == 1) {
		if ((param_3 & 3) == 0) {
			iVar1 = *(int *)(&DAT_004b39a4 + param_4 * 4);
		}
		else {
			iVar1 = *(int *)(&DAT_004b39dc + param_4 * 4);
		}
		iVar2 = (int)(((int)(param_3 - 1) >> 2) + -0x63db + param_3 * 0x16d + iVar1 + 1) % 7;
		if (iVar2 < param_6) {
			iVar1 = iVar1 + -6 + (param_5 * 7 - iVar2) + param_6;
		}
		else {
			iVar1 = iVar1 + 1 + (param_5 * 7 - iVar2) + param_6;
		}
		if (param_5 == 5) {
			if ((param_3 & 3) == 0) {
				iVar2 = *(int *)(&DAT_004b39a8 + param_4 * 4);
			}
			else {
				iVar2 = *(int *)(&DAT_004b39e0 + param_4 * 4);
			}
			if (iVar2 < iVar1) {
				iVar1 += -7;
			}
		}
	}
	else {
		if ((param_3 & 3) == 0) {
			iVar1 = *(int *)(&DAT_004b39a4 + param_4 * 4);
		}
		else {
			iVar1 = *(int *)(&DAT_004b39dc + param_4 * 4);
		}
		iVar1 += param_7;
	}
	if (param_1 == 1) {
		DAT_004b3988 = param_3;
		DAT_004b398c = iVar1;
		DAT_004b3990 = param_11 + (param_10 + (param_9 + param_8 * 0x3c) * 0x3c) * 1000;
		return;
	}
	DAT_004b39a0 = param_11 + (param_10 + (param_9 + param_8 * 0x3c) * 0x3c + DAT_004b38f8) * 1000;
	if (DAT_004b39a0 < 0) {
		_DAT_004b3998 = param_3;
		DAT_004b399c = iVar1;
		DAT_004b39a0 = DAT_004b39a0 + 86399999;
		return;
	}
	if (86399999 < DAT_004b39a0) {
		DAT_004b39a0 += -86399999;
	}
	_DAT_004b3998 = param_3;
	DAT_004b399c = iVar1;
	return;
}



undefined4 __cdecl std::internal::__std_FUN_0049a270(uint param_1,uint param_2,uint *param_3)
{
	uint uVar1;
	undefined4 uVar2;
	
	uVar2 = 0;
	uVar1 = param_2 + param_1;
	if ((uVar1 < param_1) || (uVar1 < param_2)) {
		uVar2 = 1;
	}
	*param_3 = uVar1;
	return uVar2;
}



void __cdecl std::internal::__std_FUN_0049a2a0(uint *param_1,uint *param_2)
{
	int iVar1;
	
	iVar1 = __std_FUN_0049a270(*param_1,*param_2,param_1);
	if (iVar1 != 0) {
		iVar1 = __std_FUN_0049a270(param_1[1],1,param_1 + 1);
		if (iVar1 != 0) {
			param_1[2] = param_1[2] + 1;
		}
	}
	iVar1 = __std_FUN_0049a270(param_1[1],param_2[1],param_1 + 1);
	if (iVar1 != 0) {
		param_1[2] = param_1[2] + 1;
	}
	__std_FUN_0049a270(param_1[2],param_2[2],param_1 + 2);
	return;
}



void __cdecl std::internal::__std_FUN_0049a310(uint *param_1)
{
	uint uVar1;
	uint uVar2;
	
	uVar1 = *param_1;
	uVar2 = param_1[1];
	*param_1 = uVar1 * 2;
	param_1[1] = uVar2 * 2 | uVar1 >> 0x1f;
	param_1[2] = param_1[2] << 1 | uVar2 >> 0x1f;
	return;
}



void __cdecl std::internal::__std_FUN_0049a340(uint *param_1)
{
	uint uVar1;
	
	uVar1 = param_1[1];
	param_1[1] = uVar1 >> 1 | param_1[2] << 0x1f;
	param_1[2] = param_1[2] >> 1;
	*param_1 = *param_1 >> 1 | uVar1 << 0x1f;
	return;
}



void __cdecl std::internal::__std_FUN_0049a370(char *param_1,int param_2,uint *param_3)
{
	uint uVar1;
	uint *puVar2;
	short sVar3;
	uint local_c;
	uint local_8;
	uint local_4;
	
	puVar2 = param_3;
	sVar3 = 0x404e;
	*param_3 = 0;
	param_3[1] = 0;
	param_3[2] = 0;
	if (param_2 != 0) {
		param_3 = (uint *)param_2;
		do {
			local_c = *puVar2;
			local_8 = puVar2[1];
			local_4 = puVar2[2];
			__std_FUN_0049a310(puVar2);
			__std_FUN_0049a310(puVar2);
			__std_FUN_0049a2a0(puVar2,&local_c);
			__std_FUN_0049a310(puVar2);
			local_c = SEXT14(*param_1);
			local_8 = 0;
			local_4 = 0;
			__std_FUN_0049a2a0(puVar2,&local_c);
			param_1 = param_1 + 1;
			param_3 = (uint *)((int)param_3 + -1);
		} while (param_3 != NULL);
	}
	uVar1 = puVar2[2];
	while (uVar1 == 0) {
		sVar3 += -0x10;
		puVar2[2] = puVar2[1] >> 0x10;
		uVar1 = puVar2[2];
		puVar2[1] = *puVar2 >> 0x10 | puVar2[1] << 0x10;
		*puVar2 = *puVar2 << 0x10;
	}
	uVar1 = puVar2[2];
	while ((uVar1 & 0x8000) == 0) {
		__std_FUN_0049a310(puVar2);
		sVar3 += -1;
		uVar1 = puVar2[2];
	}
	*(short *)((int)puVar2 + 10) = sVar3;
	return;
}



// WARNING: Could not reconcile some variable overlaps

undefined4 __cdecl
std::internal::__std_FUN_0049a470
					(uint param_1,uint param_2,uint param_3,int param_4,byte param_5,short *param_6)
{
	short *psVar1;
	ushort uVar2;
	char cVar3;
	uint uVar4;
	int iVar5;
	short *psVar6;
	short *psVar7;
	short sVar8;
	int iVar9;
	undefined local_1c;
	undefined local_1b;
	undefined local_1a;
	undefined local_19;
	undefined local_18;
	undefined local_17;
	undefined local_16;
	undefined local_15;
	undefined local_14;
	undefined local_13;
	undefined local_12;
	undefined local_11;
	undefined2 local_10;
	undefined4 uStack14;
	undefined4 uStack10;
	undefined local_6;
	char cStack5;
	
	local_1c = 0xcc;
	local_1b = 0xcc;
	local_1a = 0xcc;
	local_19 = 0xcc;
	local_18 = 0xcc;
	local_17 = 0xcc;
	local_16 = 0xcc;
	local_15 = 0xcc;
	local_14 = 0xcc;
	local_13 = 0xcc;
	uVar4 = param_3 & 0x7fff;
	local_12 = 0xfb;
	local_11 = 0x3f;
	if ((param_3 & 0x8000) == 0) {
		*(undefined *)(param_6 + 1) = 0x20;
	}
	else {
		*(undefined *)(param_6 + 1) = 0x2d;
	}
	if ((((short)uVar4 == 0) && (param_2 == 0)) && (param_1 == 0)) {
		*param_6 = 0;
LAB_0049a67f:
		*(undefined *)(param_6 + 1) = 0x20;
		*(undefined *)((int)param_6 + 3) = 1;
		*(undefined *)(param_6 + 2) = 0x30;
		*(undefined *)((int)param_6 + 5) = 0;
		return 1;
	}
	if ((short)uVar4 == 0x7fff) {
		*param_6 = 1;
		if (((param_2 != 0x80000000) || (param_1 != 0)) && ((param_2 & 0x40000000) == 0)) {
			*(undefined4 *)(param_6 + 2) = 0x4e532331;
			param_6[4] = 0x4e41;
			*(undefined *)((int)param_6 + 3) = 6;
			*(undefined *)(param_6 + 5) = 0;
			return 0;
		}
		if ((((param_3 & 0x8000) != 0) && (param_2 == 0xc0000000)) && (param_1 == 0)) {
			*(undefined4 *)(param_6 + 2) = 0x4e492331;
			*(undefined *)((int)param_6 + 3) = 5;
			param_6[4] = 0x44;
			return 0;
		}
		if ((param_2 == 0x80000000) && (param_1 == 0)) {
			*(undefined4 *)(param_6 + 2) = 0x4e492331;
			*(undefined *)((int)param_6 + 3) = 5;
			param_6[4] = 0x46;
			return 0;
		}
		*(undefined4 *)(param_6 + 2) = 0x4e512331;
		param_6[4] = 0x4e41;
		*(undefined *)((int)param_6 + 3) = 6;
		*(undefined *)(param_6 + 5) = 0;
		return 0;
	}
	local_6 = (undefined)uVar4;
	cStack5 = (char)(uVar4 >> 8);
	local_10 = 0;
	sVar8 = (short)(((uVar4 >> 8) + (param_2 >> 0x18) * 2) * 0x4d + -0x134312f4 + uVar4 * 0x4d10 >>
								 0x10);
	uStack10 = param_2;
	uStack14 = param_1;
	__std_FUN_0049aac0((int *)&local_10,-(int)sVar8,1);
	if (0x3ffe < CONCAT11(cStack5,local_6)) {
		sVar8 += 1;
		__std_FUN_0049a800((int *)&local_10,(int *)&local_1c);
	}
	*param_6 = sVar8;
	if (((param_5 & 1) != 0) && (param_4 += sVar8, param_4 < 1)) {
		*param_6 = 0;
		goto LAB_0049a67f;
	}
	if (0x15 < param_4) {
		param_4 = 0x15;
	}
	uVar2 = CONCAT11(cStack5,local_6);
	local_6 = 0;
	cStack5 = '\0';
	iVar5 = 8;
	iVar9 = uVar2 - 0x3ffe;
	do {
		__std_FUN_0049a310((uint *)&local_10);
		iVar5 += -1;
	} while (iVar5 != 0);
	if (iVar9 < 0) {
		for (uVar4 = -iVar9 & 0xff; uVar4 != 0; uVar4 -= 1) {
			__std_FUN_0049a340((uint *)&local_10);
		}
	}
	psVar1 = param_6 + 2;
	iVar5 = param_4 + 1;
	psVar6 = psVar1;
	if (0 < iVar5) {
		do {
			param_1 = CONCAT22((undefined2)uStack14,local_10);
			__std_FUN_0049a310((uint *)&local_10);
			__std_FUN_0049a310((uint *)&local_10);
			__std_FUN_0049a2a0((uint *)&local_10,&param_1);
			__std_FUN_0049a310((uint *)&local_10);
			cVar3 = cStack5 + '0';
			cStack5 = '\0';
			*(char *)psVar6 = cVar3;
			psVar6 = (short *)((int)psVar6 + 1);
			iVar5 += -1;
		} while (iVar5 != 0);
	}
	psVar7 = psVar6 + -1;
	if (*(char *)((int)psVar6 + -1) < '5') {
		if (psVar1 <= psVar7) {
			do {
				if (*(char *)psVar7 != '0') break;
				psVar7 = (short *)((int)psVar7 + -1);
			} while (psVar1 <= psVar7);
			if (psVar1 <= psVar7) goto LAB_0049a7d6;
		}
		*(char *)psVar1 = '0';
		*param_6 = 0;
		*(undefined *)(param_6 + 1) = 0x20;
		*(undefined *)((int)param_6 + 3) = 1;
		*(undefined *)((int)param_6 + 5) = 0;
		return 1;
	}
	if (psVar1 <= psVar7) {
		do {
			if (*(char *)psVar7 != '9') break;
			*(char *)psVar7 = '0';
			psVar7 = (short *)((int)psVar7 + -1);
		} while (psVar1 <= psVar7);
		if (psVar1 <= psVar7) {
			*(char *)psVar7 = *(char *)psVar7 + '\x01';
			goto LAB_0049a7d6;
		}
	}
	psVar7 = (short *)((int)psVar7 + 1);
	*param_6 = *param_6 + 1;
	*(char *)psVar7 = *(char *)psVar7 + '\x01';
LAB_0049a7d6:
	cVar3 = ((char)psVar7 - (char)param_6) + -3;
	*(char *)((int)param_6 + 3) = cVar3;
	*(undefined *)((int)param_6 + cVar3 + 4) = 0;
	return 1;
}



void __cdecl std::internal::__std_FUN_0049a800(int *param_1,int *param_2)
{
	ushort uVar1;
	int iVar2;
	ushort uVar3;
	ushort uVar4;
	int iVar5;
	ushort uVar6;
	int *piVar7;
	int *piVar8;
	short *local_20;
	int local_18;
	int local_14;
	int local_10;
	byte local_c;
	undefined uStack11;
	undefined2 uStack10;
	short local_8;
	undefined2 uStack6;
	undefined2 local_4;
	ushort uStack2;
	
	local_14 = 0;
	local_c = 0;
	uStack11 = 0;
	uStack10 = 0;
	local_8 = 0;
	uStack6 = 0;
	uVar3 = *(ushort *)((int)param_2 + 10) & 0x7fff;
	uVar1 = *(ushort *)((int)param_1 + 10) & 0x7fff;
	uVar6 = (*(ushort *)((int)param_2 + 10) ^ *(ushort *)((int)param_1 + 10)) & 0x8000;
	uVar4 = uVar3 + uVar1;
	local_4 = 0;
	uStack2 = 0;
	if (((0x7ffe < uVar1) || (0x7ffe < uVar3)) || (0xbffd < uVar4)) {
		param_1[1] = 0;
		*param_1 = 0;
		param_1[2] = (-(uint)(uVar6 != 0) & 0x80000000) + 0x7fff8000;
		return;
	}
	if (uVar4 < 0x3fc0) {
		param_1[2] = 0;
		param_1[1] = 0;
		*param_1 = 0;
		return;
	}
	if (((uVar1 == 0) && (uVar4 += 1, (param_1[2] & 0x7fffffffU) == 0)) &&
		 ((param_1[1] == 0 && (*param_1 == 0)))) {
		*(undefined2 *)((int)param_1 + 10) = 0;
		return;
	}
	if (((uVar3 == 0) && (uVar4 += 1, (param_2[2] & 0x7fffffffU) == 0)) &&
		 ((param_2[1] == 0 && (*param_2 == 0)))) {
		param_1[2] = 0;
		param_1[1] = 0;
		*param_1 = 0;
		return;
	}
	local_20 = &local_8;
	local_18 = 0;
	iVar5 = 5;
	do {
		if (0 < iVar5) {
			piVar8 = param_2 + 2;
			piVar7 = (int *)(local_18 * 2 + (int)param_1);
			local_10 = iVar5;
			do {
				iVar2 = __std_FUN_0049a270(*(uint *)(local_20 + -2),
																	 (uint)*(ushort *)piVar8 * (uint)*(ushort *)piVar7,
																	 (uint *)(local_20 + -2));
				if (iVar2 != 0) {
					*local_20 = *local_20 + 1;
				}
				piVar7 = (int *)((int)piVar7 + 2);
				piVar8 = (int *)((int)piVar8 + -2);
				local_10 += -1;
			} while (local_10 != 0);
		}
		local_20 = local_20 + 1;
		local_18 += 1;
		iVar5 += -1;
	} while (0 < iVar5);
	uVar4 += 0xc002;
	while ((0 < (short)uVar4 && ((uStack2 & 0x8000) == 0))) {
		__std_FUN_0049a310((uint *)&local_c);
		uVar4 -= 1;
	}
	if ((short)uVar4 < 1) {
		uVar4 -= 1;
		if ((short)uVar4 < 0) {
			iVar5 = -(int)(short)uVar4;
			uVar4 += (short)iVar5;
			do {
				if ((local_c & 1) != 0) {
					local_14 += 1;
				}
				__std_FUN_0049a340((uint *)&local_c);
				iVar5 += -1;
			} while (iVar5 != 0);
		}
		if (local_14 != 0) {
			local_c |= 1;
		}
	}
	if ((0x8000 < CONCAT11(uStack11,local_c)) ||
		 ((CONCAT22(uStack10,CONCAT11(uStack11,local_c)) & 0x1ffff) == 0x18000)) {
		if (CONCAT22(local_8,uStack10) == -1) {
			uStack10 = 0;
			local_8 = 0;
			if (CONCAT22(local_4,uStack6) == -1) {
				uStack6 = 0;
				local_4 = 0;
				if (uStack2 == 0xffff) {
					uStack2 = 0x8000;
					uVar4 += 1;
				}
				else {
					uStack2 += 1;
				}
			}
			else {
				iVar5 = CONCAT22(local_4,uStack6) + 1;
				uStack6 = (undefined2)iVar5;
				local_4 = (undefined2)((uint)iVar5 >> 0x10);
			}
		}
		else {
			iVar5 = CONCAT22(local_8,uStack10) + 1;
			uStack10 = (undefined2)iVar5;
			local_8 = (short)((uint)iVar5 >> 0x10);
		}
	}
	if (0x7ffe < uVar4) {
		param_1[1] = 0;
		*param_1 = 0;
		param_1[2] = (-(uint)(uVar6 != 0) & 0x80000000) + 0x7fff8000;
		return;
	}
	*(undefined2 *)param_1 = uStack10;
	*(uint *)((int)param_1 + 2) = CONCAT22(uStack6,local_8);
	*(uint *)((int)param_1 + 6) = CONCAT22(uStack2,local_4);
	*(ushort *)((int)param_1 + 10) = uVar4 | uVar6;
	return;
}



void __cdecl std::internal::__std_FUN_0049aac0(int *param_1,uint param_2,int param_3)
{
	uint uVar1;
	int iVar2;
	int *piVar3;
	int iVar4;
	undefined2 local_c;
	undefined2 uStack10;
	undefined2 local_8;
	undefined2 uStack6;
	int local_4;
	
	iVar4 = 0x4b39b8;
	if (param_2 != 0) {
		if ((int)param_2 < 0) {
			param_2 = -param_2;
			iVar4 = 0x4b3b18;
		}
		if (param_3 == 0) {
			*(undefined2 *)param_1 = 0;
		}
		while (param_2 != 0) {
			iVar4 += 0x54;
			uVar1 = param_2 & 7;
			param_2 = (int)param_2 >> 3;
			if (uVar1 != 0) {
				piVar3 = (int *)(iVar4 + uVar1 * 0xc);
				if (0x7fff < *(ushort *)(iVar4 + uVar1 * 0xc)) {
					local_c = (undefined2)*piVar3;
					uStack10 = (undefined2)((uint)*piVar3 >> 0x10);
					local_8 = (undefined2)piVar3[1];
					uStack6 = (undefined2)((uint)piVar3[1] >> 0x10);
					local_4 = piVar3[2];
					iVar2 = CONCAT22(local_8,uStack10) + -1;
					uStack10 = (undefined2)iVar2;
					local_8 = (undefined2)((uint)iVar2 >> 0x10);
					piVar3 = (int *)&local_c;
				}
				__std_FUN_0049a800(param_1,piVar3);
			}
		}
	}
	return;
}



// WARNING: Function: _alloca4k replaced with injection: alloca_probe

int std::internal::__fsunk__0049ab50(byte param_1)
{
	DWORD DVar1;
	DWORD DVar2;
	char *pcVar3;
	int iVar4;
	HANDLE hFile;
	BOOL BVar5;
	int iVar6;
	int iVar7;
	char *pcVar8;
	undefined4 *puVar9;
	undefined3 in_stack_00000005;
	int in_stack_00000008;
	undefined4 auStack4096 [1023];
	undefined4 uStack4;
	
	uStack4 = 0x49ab5a;
	iVar7 = 0;
	if ((_param_1 < globals::__UINT_0076eec0) &&
		 ((*(byte *)((&DAT_0076edc0)[(int)_param_1 >> 5] + 4 + (param_1 & 0x1f) * 8) & 1) != 0)) {
		DVar1 = __fdread__00496ec0(_param_1,0,1);
		if ((DVar1 != 0xffffffff) && (DVar2 = __fdread__00496ec0(_param_1,0,2), DVar2 != 0xffffffff)) {
			pcVar8 = (char *)(in_stack_00000008 - DVar2);
			if ((int)pcVar8 < 1) {
				if ((int)pcVar8 < 0) {
					__fdread__00496ec0(_param_1,in_stack_00000008,0);
					hFile = (HANDLE)__fdunk__004994b0(_param_1);
					BVar5 = SetEndOfFile(hFile);
					iVar7 = (BVar5 != 0) - 1;
					if (iVar7 == -1) {
						std::globals::g_msvc_errno = 0xd;
						std::globals::g_msvc_doserrno = GetLastError();
					}
				}
				__fdread__00496ec0(_param_1,DVar1,0);
				return iVar7;
			}
			puVar9 = auStack4096;
			for (iVar6 = 0x400; iVar6 != 0; iVar6 += -1) {
				*puVar9 = 0;
				puVar9 = puVar9 + 1;
			}
			iVar6 = __fsunk__0049b160(_param_1,0x8000);
			while( true ) {
				pcVar3 = (char *)0x1000;
				if ((int)pcVar8 < 0x1000) {
					pcVar3 = pcVar8;
				}
				iVar4 = __fdwrite__00496f80(_param_1,(char *)auStack4096,pcVar3);
				if (iVar4 == -1) break;
				pcVar8 = pcVar8 + -iVar4;
				if ((int)pcVar8 < 1) {
LAB_0049ac31:
					__fsunk__0049b160(_param_1,iVar6);
					__fdread__00496ec0(_param_1,DVar1,0);
					return iVar7;
				}
			}
			if (std::globals::g_msvc_doserrno == 5) {
				std::globals::g_msvc_errno = 0xd;
			}
			iVar7 = -1;
			goto LAB_0049ac31;
		}
	}
	else {
		std::globals::g_msvc_errno = 9;
	}
	return -1;
}



undefined4 __cdecl std::internal::__std_FUN_0049acd0(int param_1)
{
	int iVar1;
	int iVar2;
	undefined *puVar3;
	undefined4 *puVar4;
	int iVar5;
	code *pcVar6;
	int iVar7;
	code **ppcVar8;
	
	iVar2 = param_1;
	if (false) {
switchD_0049acec_caseD_3:
		return 0xffffffff;
	}
	switch(param_1) {
	case 2:
		ppcVar8 = &DAT_0054a4f8;
		pcVar6 = DAT_0054a4f8;
		break;
	default:
		goto switchD_0049acec_caseD_3;
	case 4:
	case 8:
	case 0xb:
		puVar3 = __std_FUN_0049ae50(param_1);
		ppcVar8 = (code **)(puVar3 + 8);
		pcVar6 = *ppcVar8;
		break;
	case 0xf:
		ppcVar8 = &DAT_0054a504;
		pcVar6 = DAT_0054a504;
		break;
	case 0x15:
		ppcVar8 = &DAT_0054a4fc;
		pcVar6 = DAT_0054a4fc;
		break;
	case 0x16:
		ppcVar8 = &DAT_0054a500;
		pcVar6 = DAT_0054a500;
	}
	if (pcVar6 == (code *)0x1) {
		return 0;
	}
	if (pcVar6 == NULL) {
		quick_exit(3);
	}
	iVar1 = DAT_0054a1a4;
	iVar5 = DAT_004b332c;
	if (((param_1 == 8) || (param_1 == 0xb)) || (iVar7 = param_1, param_1 == 4)) {
		DAT_0054a1a4 = 0;
		iVar7 = iVar1;
		if (param_1 == 8) {
			DAT_004b332c = 0x8c;
			param_1 = iVar5;
			goto LAB_0049ad8f;
		}
	}
	else {
LAB_0049ad8f:
		if (iVar2 == 8) {
			if (DAT_004b3320 < DAT_004b3324 + DAT_004b3320) {
				iVar5 = (DAT_004b3324 + DAT_004b3320) - DAT_004b3320;
				puVar4 = (undefined4 *)(DAT_004b3320 * 0xc + 0x4b32b0);
				do {
					*puVar4 = 0;
					puVar4 = puVar4 + 3;
					iVar5 += -1;
				} while (iVar5 != 0);
			}
			goto LAB_0049adc6;
		}
	}
	*ppcVar8 = NULL;
LAB_0049adc6:
	if (iVar2 == 8) {
		(*pcVar6)(8,DAT_004b332c);
	}
	else {
		(*pcVar6)(iVar2);
		if ((iVar2 != 0xb) && (iVar2 != 4)) {
			return 0;
		}
	}
	if (iVar2 == 8) {
		DAT_004b332c = param_1;
	}
	DAT_0054a1a4 = iVar7;
	return 0;
}



undefined * __cdecl std::internal::__std_FUN_0049ae50(int param_1)
{
	int *piVar1;
	undefined *puVar2;
	undefined *puVar3;
	
	puVar2 = &DAT_004b32a8;
	if (DAT_004b32ac != param_1) {
		puVar3 = puVar2;
		do {
			puVar2 = puVar3 + 0xc;
			if (&DAT_004b32a8 + DAT_004b3328 * 0xc <= puVar2) break;
			piVar1 = (int *)(puVar3 + 0x10);
			puVar3 = puVar2;
		} while (*piVar1 != param_1);
	}
	if ((&DAT_004b32a8 + DAT_004b3328 * 0xc <= puVar2) || (*(int *)(puVar2 + 4) != param_1)) {
		puVar2 = NULL;
	}
	return puVar2;
}



uint __cdecl std::internal::__unkftime__0049aea0(LPSTR param_1,ushort *param_2,uint param_3)
{
	char cVar1;
	uint uVar2;
	DWORD DVar3;
	int iVar4;
	int iVar5;
	ushort *lpWideCharStr;
	int local_4;
	
	lpWideCharStr = param_2;
	uVar2 = 0;
	local_4 = 0;
	if ((param_1 != NULL) && (param_3 == 0)) {
		return uVar2;
	}
	if (param_1 == NULL) {
		if (DAT_0054a180 == 0) {
			uVar2 = __unkftime__004999d0((short *)param_2);
			return uVar2;
		}
		iVar4 = WideCharToMultiByte(DAT_0054a190,0x220,(LPCWSTR)param_2,-1,NULL,0,NULL,&local_4);
		if ((iVar4 != 0) && (local_4 == 0)) {
			return iVar4 - 1;
		}
	}
	else {
		if (DAT_0054a180 == 0) {
			if (param_3 == 0) {
				return 0;
			}
			while (*param_2 < 0x100) {
				param_1[uVar2] = *(CHAR *)param_2;
				if (*param_2 == 0) {
					return uVar2;
				}
				uVar2 += 1;
				param_2 = param_2 + 1;
				if (param_3 <= uVar2) {
					return uVar2;
				}
			}
		}
		else {
			if (std::globals::_pcharwidth == 1) {
				if (param_3 != 0) {
					param_3 = __unkftime__0049b090((short *)param_2,param_3);
				}
				uVar2 = WideCharToMultiByte(DAT_0054a190,0x220,(LPCWSTR)lpWideCharStr,param_3,param_1,
																		param_3,NULL,&local_4);
				if ((uVar2 != 0) && (local_4 == 0)) {
					if (param_1[uVar2 - 1] == '\0') {
						return uVar2 - 1;
					}
					return uVar2;
				}
			}
			else {
				uVar2 = WideCharToMultiByte(DAT_0054a190,0x220,(LPCWSTR)param_2,-1,param_1,param_3,NULL,
																		&local_4);
				if (uVar2 == 0) {
					if ((local_4 == 0) && (DVar3 = GetLastError(), DVar3 == 0x7a)) {
						if (param_3 != 0) {
							do {
								iVar4 = WideCharToMultiByte(DAT_0054a190,0,(LPCWSTR)lpWideCharStr,1,(LPSTR)&param_2,
																						std::globals::_pcharwidth,NULL,&local_4);
								if (iVar4 == 0) {
									std::globals::g_msvc_errno = 0x2a;
									return 0xffffffff;
								}
								if (local_4 != 0) {
									std::globals::g_msvc_errno = 0x2a;
									return 0xffffffff;
								}
								if (param_3 < iVar4 + uVar2) {
									return uVar2;
								}
								iVar5 = 0;
								if (0 < iVar4) {
									do {
										cVar1 = *(char *)((int)&param_2 + iVar5);
										param_1[uVar2] = cVar1;
										if (cVar1 == '\0') {
											return uVar2;
										}
										iVar5 += 1;
										uVar2 += 1;
									} while (iVar5 < iVar4);
								}
								lpWideCharStr = lpWideCharStr + 1;
							} while (uVar2 < param_3);
						}
						return uVar2;
					}
				}
				else {
					if (local_4 == 0) {
						return uVar2 - 1;
					}
				}
			}
		}
	}
	std::globals::g_msvc_errno = 0x2a;
	return 0xffffffff;
}



int __cdecl std::internal::__unkftime__0049b090(short *param_1,int param_2)
{
	short *psVar1;
	int iVar2;
	
	psVar1 = param_1;
	iVar2 = param_2;
	if (param_2 != 0) {
		do {
			if (*psVar1 == 0) break;
			psVar1 = psVar1 + 1;
			iVar2 += -1;
		} while (iVar2 != 0);
		if ((iVar2 != 0) && (*psVar1 == 0)) {
			return ((int)((int)psVar1 - (int)param_1) >> 1) + 1;
		}
	}
	return param_2;
}



byte * __cdecl std::internal::__unkftime__0049b0d0(byte *param_1)
{
	byte bVar1;
	LPCWSTR pWVar2;
	LPWSTR pWVar3;
	uint uVar4;
	LPWSTR pWVar5;
	uint uVar6;
	byte *pbVar7;
	byte **ppbVar8;
	byte *pbVar9;
	
	if (((DAT_0054a0f8 != NULL) ||
			(((DAT_0054a100 == 0 || (pWVar2 = __unkftime__0049b220(), pWVar2 == NULL)) &&
			 (DAT_0054a0f8 != NULL)))) && (param_1 != NULL)) {
		uVar4 = 0xffffffff;
		pbVar7 = *DAT_0054a0f8;
		pbVar9 = param_1;
		do {
			if (uVar4 == 0) break;
			uVar4 -= 1;
			bVar1 = *pbVar9;
			pbVar9 = pbVar9 + 1;
		} while (bVar1 != 0);
		pWVar5 = (LPWSTR)(~uVar4 - 1);
		ppbVar8 = DAT_0054a0f8;
		if (pbVar7 != NULL) {
			do {
				uVar6 = 0xffffffff;
				pbVar9 = pbVar7;
				do {
					if (uVar6 == 0) break;
					uVar6 -= 1;
					bVar1 = *pbVar9;
					pbVar9 = pbVar9 + 1;
				} while (bVar1 != 0);
				if (((pWVar5 < (LPWSTR)(~uVar6 - 1)) && (*(char *)((int)pWVar5 + (int)pbVar7) == '=')) &&
					 (pWVar3 = __unkftime__0049b1e0(pbVar7,param_1,pWVar5), pWVar3 == NULL)) {
					return *ppbVar8 + ~uVar4;
				}
				pbVar7 = ppbVar8[1];
				ppbVar8 = ppbVar8 + 1;
				if (pbVar7 == NULL) {
					return NULL;
				}
			} while( true );
		}
	}
	return NULL;
}



int __cdecl std::internal::__fsunk__0049b160(uint param_1,int param_2)
{
	byte bVar1;
	byte bVar2;
	
	if (param_1 < globals::__UINT_0076eec0) {
		bVar1 = *(byte *)((&DAT_0076edc0)[(int)param_1 >> 5] + 4 + (param_1 & 0x1f) * 8);
		if ((bVar1 & 1) != 0) {
			if (param_2 == 0x8000) {
				bVar2 = bVar1 & 0x7f;
			}
			else {
				if (param_2 != 0x4000) {
					std::globals::g_msvc_errno = 0x16;
					return -1;
				}
				bVar2 = bVar1 | 0x80;
			}
			*(byte *)((&DAT_0076edc0)[(int)param_1 >> 5] + 4 + (param_1 & 0x1f) * 8) = bVar2;
			return (-(uint)((bVar1 & 0x80) != 0) & 0xffffc000) + 0x8000;
		}
	}
	std::globals::g_msvc_errno = 9;
	return -1;
}



LPWSTR __cdecl std::internal::__unkftime__0049b1e0(byte *param_1,byte *param_2,LPWSTR param_3)
{
	int iVar1;
	
	if (param_3 == NULL) {
		return param_3;
	}
	iVar1 = __unkftime__0049b2a0(DAT_0054a3c0,1,param_1,param_3,param_2,(char *)param_3,DAT_0054a3bc);
	if (iVar1 == 0) {
		return (LPWSTR)0x7fffffff;
	}
	return (LPWSTR)(iVar1 + -2);
}



LPCWSTR std::internal::__unkftime__0049b220(void)
{
	LPCWSTR lpWideCharStr;
	uint length;
	uint *lpMultiByteStr;
	int iVar1;
	LPCWSTR *ppWVar2;
	
	lpWideCharStr = *DAT_0054a100;
	ppWVar2 = DAT_0054a100;
	if (lpWideCharStr == NULL) {
		return NULL;
	}
	while (((length = WideCharToMultiByte(1,0,lpWideCharStr,-1,NULL,0,NULL,NULL), length != 0 &&
					(lpMultiByteStr = (uint *)malloc(length), lpMultiByteStr != NULL)) &&
				 (iVar1 = WideCharToMultiByte(1,0,*ppWVar2,-1,(LPSTR)lpMultiByteStr,length,NULL,NULL),
				 iVar1 != 0))) {
		__unkftime__0049b570(lpMultiByteStr,0);
		lpWideCharStr = ppWVar2[1];
		ppWVar2 = ppWVar2 + 1;
		if (lpWideCharStr == NULL) {
			return lpWideCharStr;
		}
	}
	return (LPCWSTR)0xffffffff;
}



int __cdecl
std::internal::__unkftime__0049b2a0
					(LCID param_1,DWORD param_2,byte *param_3,LPWSTR param_4,byte *param_5,char *param_6,
					UINT param_7)
{
	int iVar1;
	LPWSTR cbMultiByte;
	BOOL BVar2;
	byte *pbVar3;
	PCNZWCH lpWideCharStr;
	int iVar4;
	int iVar5;
	int local_18;
	_cpinfo local_14;
	
	if (DAT_0054a510 == 0) {
		iVar1 = CompareStringA(0,0,(PCNZCH)&lpSrcStr_0049fd38,1,(PCNZCH)&lpSrcStr_0049fd38,1);
		if (iVar1 == 0) {
			iVar1 = CompareStringW(0,0,(PCNZWCH)&lpSrcStr_0049fd3c,1,(PCNZWCH)&lpSrcStr_0049fd3c,1);
			if (iVar1 == 0) {
				return 0;
			}
			DAT_0054a510 = 1;
		}
		else {
			DAT_0054a510 = 2;
		}
	}
	cbMultiByte = param_4;
	if (0 < (int)param_4) {
		cbMultiByte = (LPWSTR)__unkftime_uprlwr__00494180((char *)param_3,(int)param_4);
	}
	if (0 < (int)param_6) {
		param_6 = __unkftime_uprlwr__00494180((char *)param_5,(int)param_6);
	}
	if (DAT_0054a510 == 2) {
		iVar1 = CompareStringA(param_1,param_2,(PCNZCH)param_3,(int)cbMultiByte,(PCNZCH)param_5,
													 (int)param_6);
		return iVar1;
	}
	local_18 = DAT_0054a510;
	if (DAT_0054a510 == 1) {
		local_18 = 0;
		param_4 = NULL;
		if (param_7 == 0) {
			param_7 = DAT_0054a190;
		}
		if ((cbMultiByte == NULL) || (param_6 == NULL)) {
			if (cbMultiByte == (LPWSTR)param_6) {
				return 2;
			}
			if (1 < (int)param_6) {
				return 1;
			}
			if (1 < (int)cbMultiByte) {
				return 3;
			}
			BVar2 = GetCPInfo(param_7,(LPCPINFO)&local_14);
			if (BVar2 == 0) {
				return 0;
			}
			if (0 < (int)cbMultiByte) {
				if (local_14.MaxCharSize < 2) {
					return 3;
				}
				pbVar3 = local_14.LeadByte;
				while( true ) {
					if ((local_14.LeadByte[0] == 0) || (pbVar3[1] == 0)) {
						return 3;
					}
					if ((*pbVar3 <= *param_3) && (*param_3 <= pbVar3[1])) break;
					local_14.LeadByte[0] = pbVar3[2];
					pbVar3 = pbVar3 + 2;
				}
				return 2;
			}
			if (0 < (int)param_6) {
				if (local_14.MaxCharSize < 2) {
					return 1;
				}
				pbVar3 = local_14.LeadByte;
				while( true ) {
					if ((local_14.LeadByte[0] == 0) || (pbVar3[1] == 0)) {
						return 1;
					}
					if ((*pbVar3 <= *param_5) && (*param_5 <= pbVar3[1])) break;
					local_14.LeadByte[0] = pbVar3[2];
					pbVar3 = pbVar3 + 2;
				}
				return 2;
			}
		}
		iVar1 = MultiByteToWideChar(param_7,9,(LPCSTR)param_3,(int)cbMultiByte,NULL,0);
		if (iVar1 == 0) {
			return 0;
		}
		lpWideCharStr = (PCNZWCH)malloc(iVar1 * 2);
		if (lpWideCharStr == NULL) {
			return 0;
		}
		iVar4 = MultiByteToWideChar(param_7,1,(LPCSTR)param_3,(int)cbMultiByte,lpWideCharStr,iVar1);
		if ((((iVar4 != 0) &&
				 (iVar4 = MultiByteToWideChar(param_7,9,(LPCSTR)param_5,(int)param_6,NULL,0), iVar4 != 0))
				&& (param_4 = (LPWSTR)malloc(iVar4 * 2), param_4 != NULL)) &&
			 (iVar5 = MultiByteToWideChar(param_7,1,(LPCSTR)param_5,(int)param_6,param_4,iVar4),
			 iVar5 != 0)) {
			local_18 = CompareStringW(param_1,param_2,lpWideCharStr,iVar1,param_4,iVar4);
		}
		free(lpWideCharStr);
		free(param_4);
	}
	return local_18;
}



int __cdecl std::internal::__unkftime__0049b570(uint *param_1,int param_2)
{
	char cVar1;
	char *pcVar2;
	char **ppcVar3;
	uint *puVar4;
	LPCWSTR pWVar5;
	int iVar6;
	char **ppcVar7;
	uint *puVar8;
	uint uVar9;
	uint uVar10;
	uint *puVar11;
	uint *puVar12;
	bool bVar13;
	
	if (param_1 == NULL) {
		return -1;
	}
	puVar4 = __unkftime__0049b870(param_1,0x3d);
	if (puVar4 == NULL) {
		return -1;
	}
	if (param_1 == puVar4) {
		return -1;
	}
	bVar13 = *(char *)((int)puVar4 + 1) == '\0';
	if (DAT_0054a0f8 == DAT_0054a0fc) {
		DAT_0054a0f8 = (char **)__unkftime__0049b800(DAT_0054a0f8);
	}
	if (DAT_0054a0f8 == NULL) {
		if ((param_2 == 0) || (DAT_0054a100 == NULL)) {
			if (bVar13) {
				return 0;
			}
			DAT_0054a0f8 = (char **)malloc(4);
			if (DAT_0054a0f8 == NULL) {
				return -1;
			}
			*DAT_0054a0f8 = NULL;
			if (DAT_0054a100 == NULL) {
				DAT_0054a100 = (undefined4 *)malloc(4);
				if (DAT_0054a100 == NULL) {
					return -1;
				}
				*DAT_0054a100 = 0;
			}
		}
		else {
			pWVar5 = __unkftime__0049b220();
			if (pWVar5 != NULL) {
				return -1;
			}
		}
	}
	ppcVar7 = DAT_0054a0f8;
	puVar4 = (uint *)((int)puVar4 - (int)param_1);
	iVar6 = __unkftime__0049b780((byte *)param_1,(LPWSTR)puVar4);
	if ((iVar6 < 0) || (*ppcVar7 == NULL)) {
		if (bVar13) {
			return 0;
		}
		if (iVar6 < 0) {
			iVar6 = -iVar6;
		}
		ppcVar7 = (char **)realloc(ppcVar7,iVar6 * 4 + 8);
		if (ppcVar7 == NULL) {
			return -1;
		}
		ppcVar7[iVar6] = (char *)param_1;
		ppcVar7[iVar6 + 1] = NULL;
		DAT_0054a0f8 = ppcVar7;
	}
	else {
		if (bVar13) {
			free(ppcVar7[iVar6]);
			pcVar2 = ppcVar7[iVar6];
			ppcVar3 = ppcVar7 + iVar6;
			while (pcVar2 != NULL) {
				*ppcVar3 = ppcVar3[1];
				iVar6 += 1;
				pcVar2 = ppcVar3[1];
				ppcVar3 = ppcVar3 + 1;
			}
			ppcVar7 = (char **)realloc(ppcVar7,iVar6 * 4);
			if (ppcVar7 != NULL) {
				DAT_0054a0f8 = ppcVar7;
			}
		}
		else {
			ppcVar7[iVar6] = (char *)param_1;
		}
	}
	if (param_2 != 0) {
		uVar9 = 0xffffffff;
		puVar8 = param_1;
		do {
			if (uVar9 == 0) break;
			uVar9 -= 1;
			cVar1 = *(char *)puVar8;
			puVar8 = (uint *)((int)puVar8 + 1);
		} while (cVar1 != '\0');
		puVar8 = (uint *)malloc(~uVar9 + 1);
		if (puVar8 != NULL) {
			uVar9 = 0xffffffff;
			do {
				puVar11 = param_1;
				if (uVar9 == 0) break;
				uVar9 -= 1;
				puVar11 = (uint *)((int)param_1 + 1);
				cVar1 = *(char *)param_1;
				param_1 = puVar11;
			} while (cVar1 != '\0');
			uVar9 = ~uVar9;
			puVar11 = (uint *)((int)puVar11 - uVar9);
			puVar12 = puVar8;
			for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 -= 1) {
				*puVar12 = *puVar11;
				puVar11 = puVar11 + 1;
				puVar12 = puVar12 + 1;
			}
			for (uVar9 &= 3; uVar9 != 0; uVar9 -= 1) {
				*(undefined *)puVar12 = *(undefined *)puVar11;
				puVar11 = (uint *)((int)puVar11 + 1);
				puVar12 = (uint *)((int)puVar12 + 1);
			}
			*(undefined *)((int)puVar8 + (int)puVar4) = 0;
			SetEnvironmentVariableA
								((LPCSTR)puVar8,(LPCSTR)(~-(uint)bVar13 & (int)puVar8 + 1 + (int)puVar4));
			free(puVar8);
			return 0;
		}
	}
	return 0;
}



int __cdecl std::internal::__unkftime__0049b780(byte *param_1,LPWSTR param_2)
{
	byte *pbVar1;
	LPWSTR pWVar2;
	byte **ppbVar3;
	
	pbVar1 = *DAT_0054a0f8;
	ppbVar3 = DAT_0054a0f8;
	if (pbVar1 == NULL) {
		return 0;
	}
	while ((pWVar2 = __unkftime__0049b1e0(param_1,pbVar1,param_2), pWVar2 != NULL ||
				 (((*ppbVar3)[(int)param_2] != 0x3d && ((*ppbVar3)[(int)param_2] != 0))))) {
		pbVar1 = ppbVar3[1];
		ppbVar3 = ppbVar3 + 1;
		if (pbVar1 == NULL) {
			return -((int)((int)ppbVar3 - (int)DAT_0054a0f8) >> 2);
		}
	}
	return (int)((int)ppbVar3 - (int)DAT_0054a0f8) >> 2;
}



undefined4 * __cdecl std::internal::__unkftime__0049b800(char **param_1)
{
	char *pcVar1;
	char **ppcVar2;
	undefined4 *puVar3;
	undefined4 *puVar4;
	int iVar5;
	undefined4 *puVar6;
	
	iVar5 = 0;
	if (param_1 != NULL) {
		pcVar1 = *param_1;
		ppcVar2 = param_1;
		while (pcVar1 != NULL) {
			ppcVar2 = ppcVar2 + 1;
			iVar5 += 1;
			pcVar1 = *ppcVar2;
		}
		puVar3 = (undefined4 *)malloc(iVar5 * 4 + 4);
		if (puVar3 == NULL) {
			__amsg_exit(9);
		}
		pcVar1 = *param_1;
		puVar6 = puVar3;
		while (pcVar1 != NULL) {
			param_1 = param_1 + 1;
			puVar4 = __unkftime__0049b920(pcVar1);
			*puVar6 = puVar4;
			puVar6 = puVar6 + 1;
			pcVar1 = *param_1;
		}
		*puVar6 = 0;
		return puVar3;
	}
	return NULL;
}



uint * __cdecl std::internal::__unkftime__0049b870(uint *param_1,uint param_2)
{
	uint *puVar1;
	uint uVar2;
	
	if (DAT_0054a3bc == 0) {
		puVar1 = __std_FUN_00491760(param_1,(char)param_2);
		return puVar1;
	}
	uVar2 = (uint)*(byte *)param_1;
	if (*(byte *)param_1 == 0) {
LAB_0049b907:
		return (uint *)((param_2 != uVar2) - 1 & (uint)param_1);
	}
	do {
		if ((*(byte *)((int)&DAT_0054a2b8 + uVar2 + 1) & 4) == 0) {
			puVar1 = param_1;
			if (param_2 == uVar2) goto LAB_0049b907;
		}
		else {
			puVar1 = (uint *)((int)param_1 + 1);
			if (*(byte *)((int)param_1 + 1) == 0) {
				return NULL;
			}
			if (param_2 == (uVar2 << 8 | (uint)*(byte *)((int)param_1 + 1))) {
				return param_1;
			}
		}
		uVar2 = (uint)*(byte *)((int)puVar1 + 1);
		param_1 = (uint *)((int)puVar1 + 1);
		if (*(byte *)((int)puVar1 + 1) == 0) {
			return (uint *)((param_2 != uVar2) - 1 & (uint)param_1);
		}
	} while( true );
}



undefined4 * __cdecl std::internal::__unkftime__0049b920(char *param_1)
{
	char cVar1;
	undefined4 *puVar2;
	uint uVar3;
	uint uVar4;
	undefined4 *puVar5;
	char *pcVar6;
	undefined4 *puVar7;
	
	if (param_1 != NULL) {
		uVar3 = 0xffffffff;
		pcVar6 = param_1;
		do {
			if (uVar3 == 0) break;
			uVar3 -= 1;
			cVar1 = *pcVar6;
			pcVar6 = pcVar6 + 1;
		} while (cVar1 != '\0');
		puVar2 = (undefined4 *)malloc(~uVar3);
		if (puVar2 != NULL) {
			uVar3 = 0xffffffff;
			do {
				pcVar6 = param_1;
				if (uVar3 == 0) break;
				uVar3 -= 1;
				pcVar6 = param_1 + 1;
				cVar1 = *param_1;
				param_1 = pcVar6;
			} while (cVar1 != '\0');
			uVar3 = ~uVar3;
			puVar5 = (undefined4 *)(pcVar6 + -uVar3);
			puVar7 = puVar2;
			for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 -= 1) {
				*puVar7 = *puVar5;
				puVar5 = puVar5 + 1;
				puVar7 = puVar7 + 1;
			}
			for (uVar3 &= 3; uVar3 != 0; uVar3 -= 1) {
				*(undefined *)puVar7 = *(undefined *)puVar5;
				puVar5 = (undefined4 *)((int)puVar5 + 1);
				puVar7 = (undefined4 *)((int)puVar7 + 1);
			}
			return puVar2;
		}
	}
	return NULL;
}



HRESULT Direct3DRMCreate(IUnknown **lplpIDirect3DRM)
{
	HRESULT HVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b970. Too many branches
										// WARNING: Treating indirect jump as call
	HVar1 = Direct3DRMCreate(lplpIDirect3DRM);
	return HVar1;
}



Vector3F * D3DRMVectorRandom(Vector3F *d)
{
	Vector3F *pVVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b976. Too many branches
										// WARNING: Treating indirect jump as call
	pVVar1 = D3DRMVectorRandom(d);
	return pVVar1;
}



Vector3F * D3DRMVectorRotate(Vector3F *r,Vector3F *v,Vector3F *axis,float theta)
{
	Vector3F *pVVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b97c. Too many branches
										// WARNING: Treating indirect jump as call
	pVVar1 = D3DRMVectorRotate(r,v,axis,theta);
	return pVVar1;
}



HRESULT DirectDrawEnumerateA(DDENUMCALLBACKA *lpCallback,LPVOID lpContext)
{
	HRESULT HVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b982. Too many branches
										// WARNING: Treating indirect jump as call
	HVar1 = DirectDrawEnumerateA(lpCallback,lpContext);
	return HVar1;
}



HRESULT DirectDrawCreate(LPGUID lpGUID,IDirectDraw **lplpIDirectDraw,LPUNKNOWN pUnkOuter)
{
	HRESULT HVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b988. Too many branches
										// WARNING: Treating indirect jump as call
	HVar1 = DirectDrawCreate(lpGUID,lplpIDirectDraw,pUnkOuter);
	return HVar1;
}



HRESULT AVIStreamInfoA(IAVIStream *pIAVIStream,AVISTREAMINFOA *pAVIStreamInfoA,LONG lSize)
{
	HRESULT HVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b98e. Too many branches
										// WARNING: Treating indirect jump as call
	HVar1 = AVIStreamInfoA(pIAVIStream,pAVIStreamInfoA,lSize);
	return HVar1;
}



IGetFrame * AVIStreamGetFrameOpen(IAVIStream *pIAVIStream,BITMAPINFOHEADER *lpbiWanted)
{
	IGetFrame *pIVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b994. Too many branches
										// WARNING: Treating indirect jump as call
	pIVar1 = AVIStreamGetFrameOpen(pIAVIStream,lpbiWanted);
	return pIVar1;
}



HRESULT AVIStreamOpenFromFileA
									(IAVIStream **lplpIAVIStream,LPCSTR szFile,DWORD fccType,LONG lParam,UINT mode,
									CLSID *pclsidHandler)
{
	HRESULT HVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b99a. Too many branches
										// WARNING: Treating indirect jump as call
	HVar1 = AVIStreamOpenFromFileA(lplpIAVIStream,szFile,fccType,lParam,mode,pclsidHandler);
	return HVar1;
}



ULONG AVIStreamRelease(IAVIStream *pIAVIStream)
{
	ULONG UVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b9a0. Too many branches
										// WARNING: Treating indirect jump as call
	UVar1 = AVIStreamRelease(pIAVIStream);
	return UVar1;
}



LPVOID AVIStreamGetFrame(IGetFrame *pIGetFrame,LONG lPos)
{
	LPVOID pvVar1;
	
										// WARNING: Could not recover jumptable at 0x0049b9a6. Too many branches
										// WARNING: Treating indirect jump as call
	pvVar1 = AVIStreamGetFrame(pIGetFrame,lPos);
	return pvVar1;
}



HRESULT DirectInputCreateA(HINSTANCE hInst,DWORD dwVersion,IUnknown **lplpIDirectInput,
													IUnknown *pUnkOuter)
{
	HRESULT HVar1;
	
										// WARNING: Could not recover jumptable at 0x0049ca68. Too many branches
										// WARNING: Treating indirect jump as call
	HVar1 = DirectInputCreateA(hInst,dwVersion,lplpIDirectInput,pUnkOuter);
	return HVar1;
}



HRESULT DirectSoundCreate(LPGUID lpGuid,IDirectSound **lplpIDirectSound,IUnknown *pUnkOuter)
{
	HRESULT HVar1;
	
										// WARNING: Could not recover jumptable at 0x0049ca6e. Too many branches
										// WARNING: Treating indirect jump as call
	HVar1 = DirectSoundCreate(lpGuid,lplpIDirectSound,pUnkOuter);
	return HVar1;
}



void RtlUnwind(PVOID TargetFrame,PVOID TargetIp,PEXCEPTION_RECORD ExceptionRecord,PVOID ReturnValue)
{
										// WARNING: Could not recover jumptable at 0x0049ca74. Too many branches
										// WARNING: Treating indirect jump as call
	RtlUnwind(TargetFrame,TargetIp,ExceptionRecord,ReturnValue);
	return;
}



// RNC (Rob Northern Compression)
// https://moddingwiki.shikadi.net/wiki/Rob_Northern_Compression

uint __cdecl rnc::RNC_Uncompress(void *bufferIn,void **out_bufferOut)
{
	short sVar1;
	byte *dstBuffer;
	uint uVar2;
	
	uVar2 = *(uint *)((int)bufferIn + 4);
	uVar2 = ((uVar2 & 0xff00) + uVar2 * 0x10000) * 0x100 + (uVar2 >> 0x10 & 0xff) * 0x100 +
					(uVar2 >> 0x18);
	if (out_bufferOut == NULL) {
		return uVar2;
	}
	dstBuffer = (byte *)std::malloc(uVar2);
	if (dstBuffer != NULL) {
		sVar1 = Rnc_Decompress__internal((byte *)bufferIn,dstBuffer);
		if (sVar1 != 0) {
			std::free(dstBuffer);
			return 0;
		}
		*out_bufferOut = dstBuffer;
		return uVar2;
	}
	return 0;
}



short __cdecl rnc::Rnc_Decompress__internal(byte *srcBuffer,byte *dstBuffer)
{
	byte bVar1;
	short sVar2;
	int iVar3;
	uint uVar4;
	uint uVar5;
	undefined4 *puVar6;
	
	iVar3 = std::strncmp((char *)srcBuffer,const::s_RNC,3);
	if (iVar3 != 0) {
		return -1;
	}
	bVar1 = srcBuffer[3];
	if (bVar1 == 0) {
		uVar5 = *(uint *)(srcBuffer + 4);
		uVar4 = (((uVar5 >> 8 & 0xff) + uVar5 * 0x100) * 0x100 + (uVar5 >> 0x10 & 0xff)) * 0x100 +
						(uVar5 >> 0x18);
		puVar6 = (undefined4 *)(srcBuffer + 0x12);
		for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 -= 1) {
			*(undefined4 *)dstBuffer = *puVar6;
			puVar6 = puVar6 + 1;
			dstBuffer = (byte *)((int)dstBuffer + 4);
		}
		for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
			*dstBuffer = *(undefined *)puVar6;
			puVar6 = (undefined4 *)((int)puVar6 + 1);
			dstBuffer = (byte *)((int)dstBuffer + 1);
		}
		return 0;
	}
	if (bVar1 == 1) {
		sVar2 = Rnc_Decompress_Method1(srcBuffer,dstBuffer);
		return sVar2;
	}
	if (bVar1 != 2) {
		return -2;
	}
	sVar2 = Rnc_Decompress_Method2(srcBuffer,dstBuffer);
	return sVar2;
}



short __cdecl rnc::Rnc_Decompress_Method1(byte *srcBuffer,byte *dstBuffer)
{
	uint uVar1;
	uint uVar2;
	int iVar3;
	byte *pbVar4;
	
	Rnc_BitStreamInit(srcBuffer,dstBuffer);
	Rnc_BitStreamAdvance(2);
	if (lego::globs::rncGlobs.Output < lego::globs::rncGlobs.OutputEnd) {
		do {
			Rnc_ReadHuffmanTable(lego::globs::rncGlobs.HuffmanTable_Raw,0x10);
			Rnc_ReadHuffmanTable(lego::globs::rncGlobs.HuffmanTable_Dst,0x10);
			Rnc_ReadHuffmanTable(lego::globs::rncGlobs.HuffmanTable_Len,0x10);
			uVar1 = Rnc_BitStreamAdvance(0x10);
			while( true ) {
				uVar2 = Rnc_ReadHuffman(lego::globs::rncGlobs.HuffmanTable_Raw);
				if ((short)uVar2 != 0) {
					iVar3 = (uVar2 + 0xffff & 0xffff) + 1;
					do {
						*lego::globs::rncGlobs.Output = *lego::globs::rncGlobs.Input;
						lego::globs::rncGlobs.Output = lego::globs::rncGlobs.Output + 1;
						lego::globs::rncGlobs.Input = lego::globs::rncGlobs.Input + 1;
						iVar3 += -1;
					} while (iVar3 != 0);
				}
				uVar1 += 0xffff;
				lego::globs::rncGlobs.BitBuffer =
						 (((uint)lego::globs::rncGlobs.Input[1] + (uint)lego::globs::rncGlobs.Input[2] * 0x100)
							* 0x100 + (uint)*lego::globs::rncGlobs.Input <<
						 (lego::globs::rncGlobs.BitCount & 0x1f)) +
						 ((1 << (lego::globs::rncGlobs.BitCount & 0x1f)) - 1U & lego::globs::rncGlobs.BitBuffer)
				;
				if ((short)uVar1 == 0) break;
				uVar2 = Rnc_ReadHuffman(lego::globs::rncGlobs.HuffmanTable_Dst);
				pbVar4 = lego::globs::rncGlobs.Output + (-1 - (uVar2 & 0xffff));
				uVar2 = Rnc_ReadHuffman(lego::globs::rncGlobs.HuffmanTable_Len);
				if ((short)uVar2 != -2) {
					iVar3 = (uVar2 + 0x10001 & 0xffff) + 1;
					do {
						*lego::globs::rncGlobs.Output = *pbVar4;
						lego::globs::rncGlobs.Output = lego::globs::rncGlobs.Output + 1;
						pbVar4 = pbVar4 + 1;
						iVar3 += -1;
					} while (iVar3 != 0);
				}
			}
		} while (lego::globs::rncGlobs.Output < lego::globs::rncGlobs.OutputEnd);
	}
	return 0;
}



short __cdecl rnc::Rnc_Decompress_Method2(byte *srcBuffer,byte *dstBuffer)
{
	short sVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	byte *pbVar5;
	
	Rnc_BitStreamInit(srcBuffer,dstBuffer);
	Rnc_FUN_0049cff0(2);
	if (lego::globs::rncGlobs.Output < lego::globs::rncGlobs.OutputEnd) {
		do {
			while( true ) {
				while( true ) {
					iVar2 = Rnc_FUN_0049cff0(1);
					sVar1 = (short)iVar2;
					while (sVar1 == 0) {
						*lego::globs::rncGlobs.Output = *lego::globs::rncGlobs.Input;
						lego::globs::rncGlobs.Output = lego::globs::rncGlobs.Output + 1;
						lego::globs::rncGlobs.Input = lego::globs::rncGlobs.Input + 1;
						iVar2 = Rnc_FUN_0049cff0(1);
						sVar1 = (short)iVar2;
					}
					iVar2 = Rnc_FUN_0049cff0(1);
					if ((short)iVar2 != 0) break;
					uVar3 = Rnc_FUN_0049d130();
					if ((short)uVar3 == 9) {
						iVar2 = Rnc_FUN_0049cff0(4);
						if ((short)(iVar2 * 4) != -0xc) {
							iVar2 = (iVar2 * 4 + 0x1000bU & 0xffff) + 1;
							do {
								*lego::globs::rncGlobs.Output = *lego::globs::rncGlobs.Input;
								lego::globs::rncGlobs.Output = lego::globs::rncGlobs.Output + 1;
								lego::globs::rncGlobs.Input = lego::globs::rncGlobs.Input + 1;
								iVar2 += -1;
							} while (iVar2 != 0);
						}
					}
					else {
						uVar4 = Rnc_FUN_0049d170();
						pbVar5 = lego::globs::rncGlobs.Output + -(uVar4 & 0xffff);
						if ((short)uVar3 != 0) {
							iVar2 = (uVar3 + 0xffff & 0xffff) + 1;
							do {
								*lego::globs::rncGlobs.Output = *pbVar5;
								lego::globs::rncGlobs.Output = lego::globs::rncGlobs.Output + 1;
								pbVar5 = pbVar5 + 1;
								iVar2 += -1;
							} while (iVar2 != 0);
						}
					}
				}
				iVar2 = Rnc_FUN_0049cff0(1);
				if ((short)iVar2 != 0) break;
				sVar1 = 2;
				uVar3 = *lego::globs::rncGlobs.Input + 1;
				lego::globs::rncGlobs.Input = lego::globs::rncGlobs.Input + 1;
LAB_0049ce07:
				pbVar5 = lego::globs::rncGlobs.Output + -(uVar3 & 0xffff);
				if (sVar1 != 0) {
					iVar2 = (ushort)(sVar1 - 1) + 1;
					do {
						*lego::globs::rncGlobs.Output = *pbVar5;
						lego::globs::rncGlobs.Output = lego::globs::rncGlobs.Output + 1;
						pbVar5 = pbVar5 + 1;
						iVar2 += -1;
					} while (iVar2 != 0);
				}
			}
			iVar2 = Rnc_FUN_0049cff0(1);
			if ((short)iVar2 == 0) {
				sVar1 = 3;
LAB_0049ce02:
				uVar3 = Rnc_FUN_0049d170();
				goto LAB_0049ce07;
			}
			sVar1 = *lego::globs::rncGlobs.Input + 8;
			lego::globs::rncGlobs.Input = lego::globs::rncGlobs.Input + 1;
			if (sVar1 != 8) goto LAB_0049ce02;
			Rnc_FUN_0049cff0(1);
		} while (lego::globs::rncGlobs.Output < lego::globs::rncGlobs.OutputEnd);
	}
	return 0;
}



byte * __cdecl rnc::Rnc_BitStreamInit(byte *srcBuffer,byte *dstBuffer)
{
	uint uVar1;
	
	uVar1 = *(uint *)(srcBuffer + 4);
	lego::globs::rncGlobs.BitCount = 0;
	lego::globs::rncGlobs.Input = srcBuffer + 0x12;
	lego::globs::rncGlobs.Output = dstBuffer;
	lego::globs::rncGlobs.OutputEnd =
			 dstBuffer +
			 (uVar1 >> 0x18) +
			 (((uVar1 >> 8 & 0xff) + uVar1 * 0x100) * 0x100 + (uVar1 >> 0x10 & 0xff)) * 0x100;
	return dstBuffer +
				 (uVar1 >> 0x18) +
				 (((uVar1 >> 8 & 0xff) + uVar1 * 0x100) * 0x100 + (uVar1 >> 0x10 & 0xff)) * 0x100;
}



uint __cdecl rnc::Rnc_BitStreamAdvance(byte bits)
{
	uint uVar1;
	int iVar2;
	uint *puVar3;
	uint uVar4;
	
	uVar1 = 0;
	uVar4 = 1;
	_bits = (uint)(byte)(bits - 1);
	if (bits != 0) {
		iVar2 = _bits + 1;
		puVar3 = (uint *)lego::globs::rncGlobs.Input;
		do {
			if (lego::globs::rncGlobs.BitCount == 0) {
				lego::globs::rncGlobs.BitBuffer = *puVar3;
				puVar3 = (uint *)((int)puVar3 + 2);
				lego::globs::rncGlobs.BitCount = 0x10;
				lego::globs::rncGlobs.Input = (byte *)puVar3;
			}
			if ((lego::globs::rncGlobs.BitBuffer & 1) != 0) {
				uVar1 |= uVar4;
			}
			uVar4 <<= 1;
			lego::globs::rncGlobs.BitBuffer >>= 1;
			lego::globs::rncGlobs.BitCount -= 1;
			iVar2 += -1;
		} while (iVar2 != 0);
	}
	return uVar1;
}



int __cdecl rnc::Rnc_FUN_0049cff0(byte bits)
{
	int iVar1;
	byte *pbVar2;
	int iVar3;
	
	iVar1 = 0;
	_bits = (uint)(byte)(bits - 1);
	if (bits != 0) {
		iVar3 = _bits + 1;
		pbVar2 = lego::globs::rncGlobs.Input;
		do {
			if (lego::globs::rncGlobs.BitCount == 0) {
				lego::globs::rncGlobs.byte_320 = *pbVar2;
				pbVar2 = pbVar2 + 1;
				lego::globs::rncGlobs.BitCount = 8;
				lego::globs::rncGlobs.Input = pbVar2;
			}
			iVar1 *= 2;
			if ((lego::globs::rncGlobs.byte_320 & 0x80) != 0) {
				iVar1 += 1;
			}
			lego::globs::rncGlobs.byte_320 <<= 1;
			lego::globs::rncGlobs.BitCount -= 1;
			iVar3 += -1;
		} while (iVar3 != 0);
	}
	return iVar1;
}



void __cdecl rnc::Rnc_ReadHuffmanTable(HuffmanLeaf *table,byte bits)
{
	byte bits_00;
	uint uVar1;
	uint uVar2;
	ushort *puVar3;
	
	Rnc_FUN_0049d210(table,bits);
	uVar1 = Rnc_BitStreamAdvance(5);
	bits_00 = (byte)uVar1;
	if (bits_00 != 0) {
		if (0x10 < bits_00) {
			bits_00 = 0x10;
		}
		if (bits_00 != 0) {
			puVar3 = &table->count_2;
			uVar1 = (uint)bits_00;
			do {
				uVar2 = Rnc_BitStreamAdvance(4);
				*puVar3 = (ushort)uVar2;
				puVar3 = puVar3 + 8;
				uVar1 -= 1;
			} while (uVar1 != 0);
		}
		Rnc_FUN_0049d250(table,bits_00);
	}
	return;
}



uint __cdecl rnc::Rnc_ReadHuffman(HuffmanLeaf *table)
{
	uint uVar1;
	byte bVar2;
	
	bVar2 = 0;
	for (; (table->count_2 == 0 ||
				 (((1 << ((byte)table->count_2 & 0x1f)) - 1U & lego::globs::rncGlobs.BitBuffer) !=
					table->value_2)); table = table + 1) {
		bVar2 += 1;
	}
	uVar1 = Rnc_BitStreamAdvance(*(byte *)&table->count_2);
	if (bVar2 < 2) {
		return uVar1 & 0xffff0000 | (uint)bVar2;
	}
	uVar1 = Rnc_BitStreamAdvance(bVar2 - 1);
	return uVar1 | 1 << (bVar2 - 1 & 0x1f);
}



uint __cdecl rnc::Rnc_FUN_0049d130(void)
{
	uint uVar1;
	int iVar2;
	uint unaff_ESI;
	uint uVar3;
	
	uVar1 = Rnc_FUN_0049cff0(1);
	uVar3 = (unaff_ESI & 0xffff0000 | uVar1 & 0xffff) + 4;
	uVar1 = Rnc_FUN_0049cff0(1);
	if ((short)uVar1 == 0) {
		return uVar1 & 0xffff0000 | uVar3 & 0xffff;
	}
	iVar2 = Rnc_FUN_0049cff0(1);
	return iVar2 + -2 + uVar3 * 2;
}



int __cdecl rnc::Rnc_FUN_0049d170(void)
{
	byte bVar1;
	int iVar2;
	uint uVar3;
	uint uVar4;
	
	uVar4 = 0;
	iVar2 = Rnc_FUN_0049cff0(1);
	if ((short)iVar2 != 0) {
		uVar4 = Rnc_FUN_0049cff0(1);
		iVar2 = Rnc_FUN_0049cff0(1);
		if ((short)iVar2 == 0) {
			if ((short)uVar4 == 0) {
				uVar3 = Rnc_FUN_0049cff0(1);
				uVar4 = (uVar4 & 0xffff0000 | uVar3 & 0xffff) + 2;
			}
		}
		else {
			iVar2 = Rnc_FUN_0049cff0(1);
			uVar4 = iVar2 + uVar4 * 2 | 4;
			iVar2 = Rnc_FUN_0049cff0(1);
			if ((short)iVar2 == 0) {
				iVar2 = Rnc_FUN_0049cff0(1);
				uVar4 = iVar2 + uVar4 * 2;
			}
		}
	}
	bVar1 = *lego::globs::rncGlobs.Input;
	lego::globs::rncGlobs.Input = lego::globs::rncGlobs.Input + 1;
	return uVar4 * 0x100 + 1 + (uint)bVar1;
}



void __cdecl rnc::Rnc_FUN_0049d210(HuffmanLeaf *table,byte bits)
{
	int iVar1;
	
	_bits = (uint)(byte)(bits - 1);
	if (bits != 0) {
		iVar1 = _bits + 1;
		do {
			table->value_1 = 0;
			table->count_1 = 0xffff;
			table->value_2 = 0;
			table->count_2 = 0;
			table = table + 1;
			iVar1 += -1;
		} while (iVar1 != 0);
	}
	return;
}



void __cdecl rnc::Rnc_FUN_0049d250(HuffmanLeaf *table,byte bits)
{
	uint uVar1;
	ushort uVar2;
	uint uVar3;
	uint *puVar4;
	uint uVar5;
	uint local_4;
	
	uVar2 = 1;
	local_4 = 0;
	uVar3 = 0x80000000;
	do {
		uVar5 = (uint)bits;
		if (bits != 0) {
			puVar4 = &table->value_2;
			do {
				if (*(ushort *)(puVar4 + 1) == uVar2) {
					uVar1 = Rnc_MirrorBits(local_4 / uVar3,(byte)uVar2);
					*puVar4 = uVar1;
					local_4 += uVar3;
				}
				puVar4 = puVar4 + 4;
				uVar5 -= 1;
			} while (uVar5 != 0);
		}
		uVar2 += 1;
		uVar3 >>= 1;
	} while (uVar2 < 0x11);
	return;
}



uint __cdecl rnc::Rnc_MirrorBits(uint value,byte bits)
{
	uint uVar1;
	int iVar2;
	
	uVar1 = 0;
	_bits = (uint)(byte)(bits - 1);
	if (bits != 0) {
		iVar2 = _bits + 1;
		do {
			uVar1 <<= 1;
			if ((value & 1) != 0) {
				uVar1 |= 1;
			}
			value >>= 1;
			iVar2 += -1;
		} while (iVar2 != 0);
	}
	return uVar1;
}



// (ChooseScreenMode)

BOOL __cdecl
lego::setup::Init_Initialise(BOOL setup,BOOL debug,BOOL best,BOOL window,char *noHALMsg)
{
	bool bVar1;
	BOOL BVar2;
	DirectDraw_DeviceFlags *pDVar3;
	int iVar4;
	int iVar5;
	uint modeIndex;
	DirectDraw_Driver *driver;
	INT_PTR local_4;
	
	local_4 = 1;
	globs::initGlobs.selDriver = NULL;
	globs::initGlobs.selDevice = NULL;
	globs::initGlobs.selMode = NULL;
	globs::initGlobs.wasFullScreen = 1;
	globs::initGlobs.selFullScreen = 1;
	globs::initGlobs.validModeCount = 0;
	Init_AddValidMode(640,480,0x10);
	if (debug != 0) {
		Init_AddValidMode(800,600,0x10);
		Init_AddValidMode(1024,768,0x10);
	}
	ddraw::DirectDraw_EnumDrivers(globs::initGlobs.drivers,(uint *)&globs::initGlobs);
	if (globs::initGlobs.driverCount != 0) {
		globs::initGlobs.selDriver = globs::initGlobs.drivers;
		if (best == 0) {
			if (setup != 0) {
				local_4 = DialogBoxParamA(globs::mainGlobs.hInst,(LPCSTR)LEGORR_MODESELECTION_DIALOG,
																	globs::mainGlobs.hWnd,Init_DialogProc,0);
			}
		}
		else {
			bVar1 = false;
			iVar5 = globs::initGlobs.driverCount - 1;
			local_4 = 1;
			globs::initGlobs.selFullScreen = ZEXT14(window == 0);
			if (-1 < iVar5) {
				driver = (DirectDraw_Driver *)((int)&globs::initGlobs + iVar5 * 0x114 + 0xc);
LAB_0049d3d2:
				BVar2 = ddraw::DirectDraw_EnumDevices
													(driver,globs::initGlobs.devices,&globs::initGlobs.deviceCount);
				if (BVar2 == 0) {
					MessageBoxA(NULL,"Please install DirectX version 6 or later","Error",0);
					return 0;
				}
				ddraw::DirectDraw_EnumModes
									(driver,globs::initGlobs.selFullScreen,globs::initGlobs.modes,
									 &globs::initGlobs.modeCount);
				modeIndex = 0;
				if (globs::initGlobs.modeCount != 0) {
					do {
						BVar2 = Init_IsValidMode(modeIndex);
						if (BVar2 != 0) {
							iVar4 = globs::initGlobs.deviceCount - 1;
							if (-1 < iVar4) {
								pDVar3 = &globs::initGlobs.devices[globs::initGlobs.deviceCount - 1].flags;
								goto LAB_0049d447;
							}
							break;
						}
						modeIndex += 1;
					} while (modeIndex < globs::initGlobs.modeCount);
				}
				goto LAB_0049d48f;
			}
LAB_0049d4a8:
			if (!bVar1) {
				MessageBoxA(NULL,noHALMsg,"Error",0);
				return 0;
			}
		}
		if (local_4 == 1) {
			if (globs::initGlobs.selFullScreen != 0) {
				BVar2 = ddraw::DirectDraw_Setup
													(1,globs::initGlobs.selDriver,globs::initGlobs.selDevice,
													 globs::initGlobs.selMode,0,0,320,200);
				return BVar2;
			}
			if (globs::initGlobs.selMode == NULL) {
				BVar2 = ddraw::DirectDraw_Setup(0,NULL,globs::initGlobs.selDevice,NULL,40,40,640,480);
				return BVar2;
			}
			BVar2 = ddraw::DirectDraw_Setup
												(0,NULL,globs::initGlobs.selDevice,NULL,100,100,
												 (globs::initGlobs.selMode)->width,(globs::initGlobs.selMode)->height);
			return BVar2;
		}
	}
	return 0;
	while( true ) {
		iVar4 += -1;
		pDVar3 = pDVar3 + -0x45;
		if (iVar4 < 0) break;
LAB_0049d447:
		if ((*pDVar3 & DIRECTDRAW_FLAG_DEVICE_HARDWARE) != DIRECTDRAW_FLAG_DEVICE_NONE) {
			globs::initGlobs.selMode = globs::initGlobs.modes + modeIndex;
			bVar1 = true;
			globs::initGlobs.selDevice = globs::initGlobs.devices + iVar4;
			globs::initGlobs.selDriver = driver;
			break;
		}
	}
LAB_0049d48f:
	if (bVar1) goto LAB_0049d4a8;
	iVar5 += -1;
	driver = driver + -1;
	if (iVar5 < 0) goto LAB_0049d4a8;
	goto LAB_0049d3d2;
}



INT_PTR lego::setup::Init_DialogProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
	short sVar1;
	HWND pHVar2;
	LRESULT LVar3;
	WPARAM wParam2;
	BOOL BVar4;
	short sVar5;
	uint uVar6;
	int iVar7;
	uint outIndex;
	tagRECT dlgRect;
	tagRECT desktopRect;
	char screenModeText [1024];
	
	if (message == WM_INITDIALOG) {
		pHVar2 = GetDesktopWindow();
		GetWindowRect(pHVar2,(LPRECT)&desktopRect);
		GetWindowRect(hDlg,(LPRECT)&dlgRect);
		MoveWindow(hDlg,desktopRect.right / 2 - (dlgRect.right - dlgRect.left) / 2,
							 desktopRect.bottom / 2 - (dlgRect.bottom - dlgRect.top) / 2,
							 dlgRect.right - dlgRect.left,dlgRect.bottom - dlgRect.top,1);
		if (globs::initGlobs.selFullScreen == 0) {
			iVar7 = LEGORR_ID_WINDOW_RADIOBUTTON;
		}
		else {
			iVar7 = LEGORR_ID_FULLSCREEN_RADIOBUTTON;
		}
		pHVar2 = GetDlgItem(hDlg,iVar7);
		SendMessageA(pHVar2,BM_SETCHECK,BST_CHECKED,0);
		pHVar2 = GetDlgItem(hDlg,LEGORR_ID_DRIVER_LISTBOX);
		uVar6 = 0;
		if (globs::initGlobs.driverCount != 0) {
			iVar7 = 0x5590bc;
			do {
				SendMessageA(pHVar2,LB_ADDSTRING,0,iVar7);
				uVar6 += 1;
				iVar7 += 0x114;
			} while (uVar6 < globs::initGlobs.driverCount);
		}
		SendMessageA(pHVar2,LB_SETCURSEL,0,0);
		SetFocus(pHVar2);
		Init_HandleWindowButton(hDlg);
		Init_SetDeviceList(hDlg);
		Init_SetModeList(hDlg);
		return 0;
	}
	if (message != WM_COMMAND) {
		return 0;
	}
	sVar1 = (short)(wParam >> 0x10);
	sVar5 = (short)wParam;
	if (sVar1 == 1) {
		if (sVar5 == LEGORR_ID_DEVICE_LISTBOX) {
			LVar3 = SendMessageA((HWND)lParam,LB_GETCURSEL,0,0);
			globs::initGlobs.selDevice = globs::initGlobs.devices + LVar3;
			return 1;
		}
		if (sVar5 == LEGORR_ID_SCREENMODES_LISTBOX) {
			wParam2 = SendMessageA((HWND)lParam,LB_GETCURSEL,0,0);
			SendMessageA((HWND)lParam,LB_GETTEXT,wParam2,(LPARAM)screenModeText);
			BVar4 = Init_GetMode(screenModeText,&outIndex);
			if (BVar4 != 0) {
				globs::initGlobs.selMode = globs::initGlobs.modes + outIndex;
				return 1;
			}
		}
		else {
			if (sVar5 == LEGORR_ID_DRIVER_LISTBOX) {
				LVar3 = SendMessageA((HWND)lParam,LB_GETCURSEL,0,0);
				globs::initGlobs.selDriver = globs::initGlobs.drivers + LVar3;
				Init_HandleWindowButton(hDlg);
				Init_SetModeList(hDlg);
				Init_SetDeviceList(hDlg);
				return 1;
			}
		}
	}
	else {
		if (sVar1 == 0) {
			if (sVar5 == LEGORR_ID_WINDOW_RADIOBUTTON) {
				Init_SetFullScreen(hDlg,0);
			}
			if (sVar5 == LEGORR_ID_FULLSCREEN_RADIOBUTTON) {
				Init_SetFullScreen(hDlg,1);
				return 1;
			}
			if ((sVar5 == IDOK) || (sVar5 == IDCANCEL)) {
				EndDialog(hDlg,wParam);
			}
		}
	}
	return 1;
}



void __cdecl lego::setup::Init_SetFullScreen(HWND hDlg,BOOL on)
{
	HWND hWnd;
	
	globs::initGlobs.selFullScreen = on;
	Init_SetModeList(hDlg);
	hWnd = GetDlgItem(hDlg,LEGORR_ID_SCREENMODES_LABEL);
	if (on != 0) {
		SendMessageA(hWnd,WM_SETTEXT,0,(LPARAM)"Screen Mode");
		return;
	}
	SendMessageA(hWnd,WM_SETTEXT,0,(LPARAM)"Window Size");
	return;
}



void __cdecl lego::setup::Init_SetModeList(HWND hDlg)
{
	bool bVar1;
	HWND hCtrl_Screens;
	int iVar2;
	BOOL BVar3;
	HWND hCtrl_OK;
	DirectDraw_Mode *pDVar4;
	uint local_104;
	char unsupportedMessage [256];
	
	bVar1 = true;
	hCtrl_Screens = GetDlgItem(hDlg,LEGORR_ID_SCREENMODES_LISTBOX);
	iVar2 = SendMessageA(hCtrl_Screens,LB_DELETESTRING,0,0);
	while (iVar2 != -1) {
		iVar2 = SendMessageA(hCtrl_Screens,LB_DELETESTRING,0,0);
	}
	ddraw::DirectDraw_EnumModes
						(globs::initGlobs.selDriver,globs::initGlobs.selFullScreen,globs::initGlobs.modes,
						 &globs::initGlobs.modeCount);
	local_104 = 0;
	if (globs::initGlobs.modeCount != 0) {
		pDVar4 = globs::initGlobs.modes;
		do {
			BVar3 = Init_IsValidMode(local_104);
			if ((BVar3 != 0) && (SendMessageA(hCtrl_Screens,LB_ADDSTRING,0,(LPARAM)pDVar4->desc), bVar1))
			{
				bVar1 = false;
				globs::initGlobs.selMode = pDVar4;
			}
			local_104 += 1;
			pDVar4 = pDVar4 + 1;
		} while (local_104 < globs::initGlobs.modeCount);
	}
	hCtrl_OK = GetDlgItem(hDlg,IDOK);
	if (bVar1) {
		if (globs::initGlobs.selFullScreen == 0) {
			iVar2 = main::Main_GetWindowsBitDepth();
			std::sprintf(unsupportedMessage,"No supported %i bit modes found",iVar2);
		}
		else {
			std::sprintf(unsupportedMessage,"No supported screen modes found");
		}
		SendMessageA(hCtrl_Screens,LB_ADDSTRING,0,(LPARAM)unsupportedMessage);
		BVar3 = 0;
	}
	else {
		BVar3 = 1;
	}
	EnableWindow(hCtrl_OK,BVar3);
	SendMessageA(hCtrl_Screens,LB_SETCURSEL,0,0);
	return;
}



void __cdecl lego::setup::Init_SetDeviceList(HWND hDlg)
{
	HWND hWnd;
	int iVar1;
	BOOL BVar2;
	WPARAM wParam;
	WPARAM WVar3;
	WPARAM local_4;
	
	local_4 = 0;
	hWnd = GetDlgItem(hDlg,LEGORR_ID_DEVICE_LISTBOX);
	iVar1 = SendMessageA(hWnd,LB_DELETESTRING,0,0);
	while (iVar1 != -1) {
		iVar1 = SendMessageA(hWnd,LB_DELETESTRING,0,0);
	}
	BVar2 = ddraw::DirectDraw_EnumDevices
										(globs::initGlobs.selDriver,globs::initGlobs.devices,
										 &globs::initGlobs.deviceCount);
	if (BVar2 != 0) {
		WVar3 = 0;
		wParam = 0;
		if (globs::initGlobs.deviceCount != 0) {
			iVar1 = 0x55a64c;
			do {
				if ((*(uint *)(iVar1 + 0x100) & 0x2000) != 0) {
					local_4 = WVar3;
				}
				SendMessageA(hWnd,LB_ADDSTRING,0,iVar1);
				WVar3 += 1;
				iVar1 += 0x114;
				wParam = local_4;
			} while (WVar3 < globs::initGlobs.deviceCount);
		}
		globs::initGlobs.selDevice = globs::initGlobs.devices + wParam;
		SendMessageA(hWnd,LB_SETCURSEL,wParam,0);
		return;
	}
	SendMessageA(hWnd,LB_ADDSTRING,0,(LPARAM)"Error: DirectX6 not installed.");
	SendMessageA(hWnd,LB_SETCURSEL,0,0);
	return;
}



void __cdecl lego::setup::Init_AddValidMode(uint width,uint height,uint depth)
{
	globs::initGlobs.validModes[globs::initGlobs.validModeCount].width = width;
	globs::initGlobs.validModes[globs::initGlobs.validModeCount].height = height;
	globs::initGlobs.validModes[globs::initGlobs.validModeCount].bitDepth = depth;
	globs::initGlobs.validModeCount = globs::initGlobs.validModeCount + 1;
	return;
}



BOOL __cdecl lego::setup::Init_IsValidMode(uint modeIndex)
{
	uint *puVar1;
	uint uVar2;
	
	if (globs::initGlobs.validModeCount == 0) {
		return 1;
	}
	uVar2 = 0;
	if (globs::initGlobs.validModeCount != 0) {
		puVar1 = &globs::initGlobs.validModes[0].height;
		do {
			if (((puVar1[-1] == 0) || (puVar1[-1] == globs::initGlobs.modes[modeIndex].width)) &&
				 ((*puVar1 == 0 || (*puVar1 == globs::initGlobs.modes[modeIndex].height)))) {
				if (puVar1[1] == 0) {
					return 1;
				}
				if (puVar1[1] == globs::initGlobs.modes[modeIndex].bitDepth) {
					return 1;
				}
			}
			uVar2 += 1;
			puVar1 = puVar1 + 0x44;
		} while (uVar2 < globs::initGlobs.validModeCount);
	}
	return 0;
}



BOOL __cdecl lego::setup::Init_GetMode(char *name,uint *out_modeIndex)
{
	byte bVar1;
	byte *pbVar2;
	int iVar3;
	uint uVar4;
	byte *pbVar5;
	byte *pbVar6;
	bool bVar7;
	
	uVar4 = 0;
	if (globs::initGlobs.modeCount == 0) {
		return 0;
	}
	pbVar2 = (byte *)globs::initGlobs.modes[0].desc;
	pbVar5 = (byte *)name;
	pbVar6 = pbVar2;
LAB_0049dc2b:
	do {
		bVar1 = *pbVar2;
		bVar7 = bVar1 < *pbVar5;
		if (bVar1 == *pbVar5) {
			if (bVar1 != 0) {
				bVar1 = pbVar2[1];
				bVar7 = bVar1 < pbVar5[1];
				if (bVar1 != pbVar5[1]) goto LAB_0049dc4f;
				pbVar2 = pbVar2 + 2;
				pbVar5 = pbVar5 + 2;
				if (bVar1 != 0) goto LAB_0049dc2b;
			}
			iVar3 = 0;
		}
		else {
LAB_0049dc4f:
			iVar3 = (1 - (uint)bVar7) - (uint)(bVar7 != 0);
		}
		if (iVar3 == 0) {
			*out_modeIndex = uVar4;
			return 1;
		}
		uVar4 += 1;
		pbVar2 = pbVar6 + 0x110;
		pbVar5 = (byte *)name;
		pbVar6 = pbVar2;
		if (globs::initGlobs.modeCount <= uVar4) {
			return 0;
		}
	} while( true );
}



void __cdecl lego::setup::Init_HandleWindowButton(HWND hDlg)
{
	HWND pHVar1;
	
	if ((*(byte *)&(globs::initGlobs.selDriver)->flags & DIRECTDRAW_FLAG_DRIVER_WINDOWOK) == 0) {
		globs::initGlobs.wasFullScreen = globs::initGlobs.selFullScreen;
		Init_SetFullScreen(hDlg,1);
		pHVar1 = GetDlgItem(hDlg,LEGORR_ID_WINDOW_RADIOBUTTON);
		SendMessageA(pHVar1,BM_SETCHECK,0,0);
		EnableWindow(pHVar1,0);
		pHVar1 = GetDlgItem(hDlg,LEGORR_ID_FULLSCREEN_RADIOBUTTON);
		SendMessageA(pHVar1,BM_SETCHECK,1,0);
	}
	else {
		pHVar1 = GetDlgItem(hDlg,LEGORR_ID_WINDOW_RADIOBUTTON);
		EnableWindow(pHVar1,1);
		if (globs::initGlobs.wasFullScreen == 0) {
			Init_SetFullScreen(hDlg,0);
			pHVar1 = GetDlgItem(hDlg,LEGORR_ID_FULLSCREEN_RADIOBUTTON);
			SendMessageA(pHVar1,BM_SETCHECK,0,0);
			pHVar1 = GetDlgItem(hDlg,LEGORR_ID_WINDOW_RADIOBUTTON);
			SendMessageA(pHVar1,BM_SETCHECK,1,0);
			return;
		}
	}
	return;
}



// Library Function - Single Match
// Name: __strnicmp
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release

int __cdecl std::_strnicmp(char *_Str1,char *_Str2,size_t _MaxCount)
{
	byte bVar1;
	byte bVar2;
	uint c;
	uint c_00;
	bool bVar3;
	
	if (_MaxCount != 0) {
		if (DAT_0054a180 == 0) {
			do {
				bVar2 = *_Str1;
				bVar1 = *_Str2;
				if ((bVar2 == 0) || (bVar1 == 0)) break;
				_Str1 = (char *)((byte *)_Str1 + 1);
				_Str2 = (char *)((byte *)_Str2 + 1);
				if ((0x40 < bVar2) && (bVar2 < 0x5b)) {
					bVar2 += 0x20;
				}
				if ((0x40 < bVar1) && (bVar1 < 0x5b)) {
					bVar1 += 0x20;
				}
				bVar3 = bVar2 < bVar1;
				if (bVar2 != bVar1) goto LAB_0049ddcb;
				_MaxCount -= 1;
			} while (_MaxCount != 0);
			_MaxCount = 0;
			bVar3 = bVar2 < bVar1;
			if (bVar2 != bVar1) {
LAB_0049ddcb:
				_MaxCount = 0xffffffff;
				if (!bVar3) {
					_MaxCount = 1;
				}
			}
		}
		else {
			c_00 = 0;
			c = 0;
			do {
				c = c & 0xffffff00 | (uint)(byte)*_Str1;
				c_00 = c_00 & 0xffffff00 | (uint)(byte)*_Str2;
				if ((c == 0) || (c_00 == 0)) break;
				_Str1 = (char *)((byte *)_Str1 + 1);
				_Str2 = (char *)((byte *)_Str2 + 1);
				c_00 = tolower(c_00);
				c = tolower(c);
				bVar3 = c < c_00;
				if (c != c_00) goto LAB_0049de0d;
				_MaxCount -= 1;
			} while (_MaxCount != 0);
			_MaxCount = 0;
			bVar3 = c < c_00;
			if (c != c_00) {
LAB_0049de0d:
				_MaxCount = 0xffffffff;
				if (!bVar3) {
					_MaxCount = 1;
				}
			}
		}
	}
	return _MaxCount;
}



char * __cdecl std::itoa(int value,char *buffer,int radix)
{
	if ((radix == 10) && (value < 0)) {
		internal::__itoa__internal(value,buffer,10,1);
		return buffer;
	}
	internal::__itoa__internal(value,buffer,radix,0);
	return buffer;
}



void __cdecl std::internal::__itoa__internal(int value,char *buffer,int radix,BOOL isNegative)
{
	ulonglong uVar1;
	char *pcVar2;
	char cVar3;
	char *pcVar4;
	
	pcVar2 = buffer;
	if (isNegative != 0) {
		*buffer = '-';
		buffer = buffer + 1;
		value = -value;
		pcVar2 = buffer;
	}
	do {
		pcVar4 = pcVar2;
		uVar1 = (ulonglong)(uint)value;
		value = (uint)value / (uint)radix;
		cVar3 = (char)(uVar1 % (ulonglong)(uint)radix);
		if ((uint)(uVar1 % (ulonglong)(uint)radix) < 10) {
			cVar3 += '0';
		}
		else {
			cVar3 += 'W';
		}
		*pcVar4 = cVar3;
		pcVar2 = pcVar4 + 1;
	} while (value != 0);
	pcVar4[1] = '\0';
	do {
		cVar3 = *pcVar4;
		*pcVar4 = *buffer;
		*buffer = cVar3;
		pcVar4 = pcVar4 + -1;
		buffer = buffer + 1;
	} while (buffer < pcVar4);
	return;
}



char * __cdecl std::_strlwr(char *str)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	int iVar5;
	uint uVar6;
	LPWSTR buffer;
	undefined4 *puVar7;
	LPWSTR pWVar8;
	LPWSTR pWVar9;
	undefined4 *puVar10;
	
	buffer = NULL;
	if (DAT_0054a180 == 0) {
		pcVar3 = str;
		if (*str != '\0') {
			do {
				cVar2 = *str;
				if (('@' < cVar2) && (cVar2 < '[')) {
					*str = cVar2 + ' ';
				}
				pcVar1 = str + 1;
				str = str + 1;
			} while (*pcVar1 != '\0');
			return pcVar3;
		}
	}
	else {
		uVar4 = internal::__uprlwr__00493f60(DAT_0054a180,0x100,str,(LPCWSTR)0xffffffff,NULL,0,0);
		if (((uVar4 != 0) && (buffer = (LPWSTR)malloc(uVar4), buffer != NULL)) &&
			 (iVar5 = internal::__uprlwr__00493f60
													(DAT_0054a180,0x100,str,(LPCWSTR)0xffffffff,buffer,uVar4,0), iVar5 != 0))
		{
			uVar4 = 0xffffffff;
			pWVar8 = buffer;
			do {
				pWVar9 = pWVar8;
				if (uVar4 == 0) break;
				uVar4 -= 1;
				pWVar9 = (LPWSTR)((int)pWVar8 + 1);
				cVar2 = *(char *)pWVar8;
				pWVar8 = pWVar9;
			} while (cVar2 != '\0');
			uVar4 = ~uVar4;
			puVar7 = (undefined4 *)((int)pWVar9 - uVar4);
			puVar10 = (undefined4 *)str;
			for (uVar6 = uVar4 >> 2; uVar6 != 0; uVar6 -= 1) {
				*puVar10 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar10 = puVar10 + 1;
			}
			for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
				*(undefined *)puVar10 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar10 = (undefined4 *)((int)puVar10 + 1);
			}
		}
		free(buffer);
	}
	return str;
}



char * __cdecl std::_strupr(char *str)
{
	char *pcVar1;
	char cVar2;
	char *pcVar3;
	uint uVar4;
	int iVar5;
	uint uVar6;
	LPWSTR buffer;
	undefined4 *puVar7;
	LPWSTR pWVar8;
	LPWSTR pWVar9;
	undefined4 *puVar10;
	
	buffer = NULL;
	if (DAT_0054a180 == 0) {
		pcVar3 = str;
		if (*str != '\0') {
			do {
				cVar2 = *str;
				if (('`' < cVar2) && (cVar2 < '{')) {
					*str = cVar2 + -0x20;
				}
				pcVar1 = str + 1;
				str = str + 1;
			} while (*pcVar1 != '\0');
			return pcVar3;
		}
	}
	else {
		uVar4 = internal::__uprlwr__00493f60(DAT_0054a180,0x200,str,(LPCWSTR)0xffffffff,NULL,0,0);
		if (((uVar4 != 0) && (buffer = (LPWSTR)malloc(uVar4), buffer != NULL)) &&
			 (iVar5 = internal::__uprlwr__00493f60
													(DAT_0054a180,0x200,str,(LPCWSTR)0xffffffff,buffer,uVar4,0), iVar5 != 0))
		{
			uVar4 = 0xffffffff;
			pWVar8 = buffer;
			do {
				pWVar9 = pWVar8;
				if (uVar4 == 0) break;
				uVar4 -= 1;
				pWVar9 = (LPWSTR)((int)pWVar8 + 1);
				cVar2 = *(char *)pWVar8;
				pWVar8 = pWVar9;
			} while (cVar2 != '\0');
			uVar4 = ~uVar4;
			puVar7 = (undefined4 *)((int)pWVar9 - uVar4);
			puVar10 = (undefined4 *)str;
			for (uVar6 = uVar4 >> 2; uVar6 != 0; uVar6 -= 1) {
				*puVar10 = *puVar7;
				puVar7 = puVar7 + 1;
				puVar10 = puVar10 + 1;
			}
			for (uVar4 &= 3; uVar4 != 0; uVar4 -= 1) {
				*(undefined *)puVar10 = *(undefined *)puVar7;
				puVar7 = (undefined4 *)((int)puVar7 + 1);
				puVar10 = (undefined4 *)((int)puVar10 + 1);
			}
		}
		free(buffer);
	}
	return str;
}



void Unwind_0049e050(void)
{
	int unaff_EBP;
	
	lego::game::LevelStruct3C_Free_Unwind(*(LevelStruct_3c **)(unaff_EBP + -0x210));
	return;
}



void Unwind_0049e05e(void)
{
	int unaff_EBP;
	
	lego::game::LevelStruct3C_Free_Unwind(*(LevelStruct_3c **)(unaff_EBP + -0x210));
	return;
}



void Unwind_0049e080(void)
{
	int unaff_EBP;
	
	lego::game::LevelStruct3C_Free_Unwind(*(LevelStruct_3c **)(unaff_EBP + 4));
	return;
}



void Unwind_0049e0a0(void)
{
	int unaff_EBP;
	
	lego::game::LevelStruct3C_Free_Unwind(*(LevelStruct_3c **)(unaff_EBP + -0x10));
	return;
}


